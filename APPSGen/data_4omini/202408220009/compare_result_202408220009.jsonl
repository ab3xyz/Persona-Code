{"solution": "def max_accordion_length(s):\n    # Initialize variables to track the positions of the first and last brackets and colons\n    first_open = s.find('[')\n    last_close = s.rfind(']')\n    first_colon = s.find(':')\n    last_colon = s.rfind(':')\n\n    # Check if we can form an accordion\n    if first_open == -1 or last_close == -1 or first_colon == -1 or last_colon == -1:\n        return -1\n    if first_open > first_colon or last_colon > last_close:\n        return -1\n\n    # Count the number of vertical lines between the colons\n    vertical_lines = s[first_colon + 1:last_colon].count('|')\n\n    # The maximum length of the accordion\n    return 4 + vertical_lines\n\n# Read input\ns = input().strip()\n# Print the result\nprint(max_accordion_length(s))"}
{"solution": "def max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    # Start with the original number\n    best_number = x\n    best_sum = sum(int(d) for d in str_x)\n    \n    # Try to create numbers by reducing digits\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit and setting all following digits to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n        \n        if new_number > 0 and new_number <= x:\n            new_sum = sum(int(d) for d in str(new_number))\n            if new_sum > best_sum or (new_sum == best_sum and new_number > best_number):\n                best_number = new_number\n                best_sum = new_sum\n    \n    return best_number\n\nx = int(input().strip())\nprint(max_digit_sum(x))"}
{"solution": "n = int(input())\n\ndef is_lucky_year(year):\n    non_zero_digits = [digit for digit in str(year) if digit != '0']\n    return len(non_zero_digits) <= 1\n\nnext_year = n + 1\nwhile not is_lucky_year(next_year):\n    next_year += 1\n\nprint(next_year - n)"}
{"solution": "def max_painted_sections(n, q, painters):\n    def count_painted(painters):\n        painted = [0] * (n + 1)\n        for l, r in painters:\n            for i in range(l, r + 1):\n                painted[i] = 1\n        return sum(painted)\n\n    max_sections = 0\n    for i in range(q):\n        for j in range(i + 1, q):\n            selected_painters = [painters[k] for k in range(q) if k != i and k != j]\n            max_sections = max(max_sections, count_painted(selected_painters))\n\n    return max_sections\n\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def is_lucky(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef time_before(hh, mm, x):\n    mm -= x\n    if mm < 0:\n        mm += 60\n        hh -= 1\n        if hh < 0:\n            hh += 24\n    return hh, mm\n\ndef minimum_snooze_presses(x, hh, mm):\n    presses = 0\n    while not is_lucky(hh, mm):\n        hh, mm = time_before(hh, mm, x)\n        presses += 1\n    return presses\n\nx = int(input().strip())\nhh, mm = map(int, input().strip().split())\nprint(minimum_snooze_presses(x, hh, mm))"}
{"solution": "def min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0  # No tabs to close\n\n    seconds = 0\n\n    # Close tabs to the left of l\n    if pos > l:\n        seconds += (pos - l) + 1  # Move to l and close left\n    else:\n        seconds += (l - pos)  # Just move to l\n\n    # Close tabs to the right of r\n    if pos < r:\n        seconds += (r - pos) + 1  # Move to r and close right\n    else:\n        seconds += (pos - r)  # Just move to r\n\n    return seconds\n\n# Input reading\nn, pos, l, r = map(int, input().split())\n# Output the result\nprint(min_seconds_to_close_tabs(n, pos, l, r))"}
{"solution": "def min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x = query[0]\n        blows = query[1]\n        \n        # Find the best blow\n        best_d = 0\n        best_h = 0\n        \n        for d, h in blows:\n            if d > best_d:\n                best_d = d\n                best_h = h\n            elif d == best_d:\n                best_h = min(best_h, h)\n        \n        if best_d == 0:\n            results.append(-1)\n            continue\n        \n        if best_d >= x:\n            results.append(1)\n            continue\n        \n        # Calculate the effective damage and growth\n        effective_damage = best_d - best_h\n        \n        if effective_damage <= 0:\n            results.append(-1)\n            continue\n        \n        # Calculate the number of blows needed\n        blows_needed = (x - best_d + effective_damage - 1) // effective_damage + 1\n        results.append(blows_needed)\n    \n    return results\n\n# Input reading\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append(((n, x), blows))\n\n# Get results\nresults = min_blows_to_defeat_zmei(t, queries)\n\n# Output results\nfor result in results:\n    print(result)"}
{"solution": "def day_when_barn_empty(n, m):\n    day = 0\n    grains = n\n    \n    while grains > 0:\n        day += 1\n        grains += m\n        if grains > n:\n            grains = n\n        grains -= day\n        \n    return day\n\n# Read input\nn, m = map(int, input().split())\n# Output the result\nprint(day_when_barn_empty(n, m))"}
{"solution": "def min_tiles_to_draw(tiles):\n    from collections import defaultdict\n\n    # Parse the input tiles\n    hand = tiles.split()\n    counts = defaultdict(int)\n    suits = defaultdict(list)\n\n    for tile in hand:\n        num = int(tile[0])\n        suit = tile[1]\n        counts[tile] += 1\n        suits[suit].append(num)\n\n    # Check for koutsu (triplet)\n    for tile, count in counts.items():\n        if count >= 3:\n            return 0  # Already has a koutsu\n\n    # Check for shuntsu (sequence)\n    for suit, numbers in suits.items():\n        numbers.sort()\n        for i in range(len(numbers)):\n            if i + 2 < len(numbers) and numbers[i] + 1 == numbers[i + 1] and numbers[i] + 2 == numbers[i + 2]:\n                return 0  # Already has a shuntsu\n\n        # Check for possible shuntsu with one draw\n        for num in numbers:\n            if num - 1 >= 1 and num + 1 <= 9:\n                if (num - 1 not in numbers) or (num + 1 not in numbers):\n                    return 1  # Can form a shuntsu with one draw\n\n    # Check for possible koutsu with one draw\n    for tile, count in counts.items():\n        if count == 2:\n            return 1  # Can form a koutsu with one draw\n\n    # If no mentsu can be formed with one draw, we need two draws\n    return 2\n\n# Read input\ntiles = input().strip()\n# Output the result\nprint(min_tiles_to_draw(tiles))"}
{"solution": "def find_grandpa_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b):\n    # Create a list to store the positions of the sofas\n    positions = []\n    \n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        positions.append((x1, y1, x2, y2))\n    \n    for i in range(d):\n        x1, y1, x2, y2 = positions[i]\n        \n        # Count sofas in each direction\n        left_count = right_count = top_count = bottom_count = 0\n        \n        for j in range(d):\n            if i == j:\n                continue\n            x1_j, y1_j, x2_j, y2_j = positions[j]\n            \n            if x1 < x1_j and x2 < x1_j:  # Sofa i is to the left of sofa j\n                left_count += 1\n            if x1_j < x1 and x2_j < x1:  # Sofa j is to the left of sofa i\n                right_count += 1\n            if y1 < y1_j and y2 < y1_j:  # Sofa i is above sofa j\n                top_count += 1\n            if y1_j < y1 and y2_j < y1:  # Sofa j is above sofa i\n                bottom_count += 1\n        \n        if (left_count == cnt_l and right_count == cnt_r and \n            top_count == cnt_t and bottom_count == cnt_b):\n            return i + 1  # Return 1-based index\n    \n    return -1\n\n# Input reading\nd = int(input())\nn, m = map(int, input().split())\nsofas = [tuple(map(int, input().split())) for _ in range(d)]\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\n# Output the result\nprint(find_grandpa_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b))"}
{"solution": "n = int(input())\n\n# Calculate maximum days off\nmax_days_off = (n // 7) * 2 + min(2, n % 7)\n\n# Calculate minimum days off\nif n < 5:\n    min_days_off = 0\nelse:\n    min_days_off = (n // 7) * 2\n\nprint(min_days_off, max_days_off)"}
{"solution": "def max_chocolates(n, a, b, p, q):\n    count_a = n // a\n    count_b = n // b\n    count_ab = n // (a * b)  # Count of indices divisible by both a and b\n\n    # Calculate chocolates if we prioritize Red (p) over Blue (q)\n    chocolates_red_first = (count_a - count_ab) * p + (count_b - count_ab) * q + count_ab * max(p, q)\n\n    return chocolates_red_first\n\n# Read input\nn, a, b, p, q = map(int, input().split())\n# Calculate and print the result\nprint(max_chocolates(n, a, b, p, q))"}
{"solution": "def max_beauty_with_one_swap(n, trophies):\n    # Find the lengths of segments of golden trophies\n    segments = []\n    current_length = 0\n    \n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n    \n    if current_length > 0:\n        segments.append(current_length)\n    \n    # If there are no golden trophies\n    if not segments:\n        return 0\n    \n    # Calculate the maximum length of golden trophies segment\n    max_length = max(segments)\n    \n    # If there is only one segment, we cannot increase its length by swapping\n    if len(segments) == 1:\n        return max_length\n    \n    # Check for possible swaps between segments\n    max_possible_length = max_length\n    for i in range(len(segments) - 1):\n        # If we swap one trophy from the end of segments[i] with one from the start of segments[i + 1]\n        combined_length = segments[i] + segments[i + 1]\n        max_possible_length = max(max_possible_length, combined_length)\n    \n    return max_possible_length\n\n# Input reading\nn = int(input().strip())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_with_one_swap(n, trophies))"}
{"solution": "from collections import deque, defaultdict\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, k = map(int, data[0].split())\nmain_courses = list(map(int, data[1].split()))\ndependencies = defaultdict(list)\nin_degree = [0] * (n + 1)\n\n# Read dependencies\nfor i in range(2, n + 2):\n    line = list(map(int, data[i].split()))\n    t_i = line[0]\n    for dep in line[1:t_i + 1]:\n        dependencies[dep].append(i - 1)  # i - 2 + 1 = i - 1 (0-indexed)\n        in_degree[i - 1] += 1\n\n# Topological sort using Kahn's algorithm\nqueue = deque()\nfor course in range(1, n + 1):\n    if in_degree[course - 1] == 0:\n        queue.append(course)\n\norder = []\npassed_courses = set()\n\nwhile queue:\n    course = queue.popleft()\n    order.append(course)\n    passed_courses.add(course)\n    \n    for next_course in dependencies[course]:\n        in_degree[next_course] -= 1\n        if in_degree[next_course] == 0:\n            queue.append(next_course + 1)\n\n# Check if all main courses can be passed\nto_pass = set(main_courses)\nfor course in order:\n    if course in to_pass:\n        to_pass.remove(course)\n    if not to_pass:\n        break\n\nif to_pass:\n    print(-1)\nelse:\n    # We need to ensure we have all main courses and their dependencies\n    result = []\n    for course in order:\n        if course in main_courses or any(dep in passed_courses for dep in dependencies[course]):\n            result.append(course)\n            if course in main_courses:\n                main_courses.remove(course)\n    \n    print(len(result))\n    print(' '.join(map(str, result)))"}
{"solution": "def is_stack_sortable(n, k, p):\n    # Initialize the stack and the result array\n    stack = []\n    result = p[:]\n    \n    # Create a set for the used numbers\n    used = set(p)\n    \n    # The next number to be added to the permutation\n    next_num = n\n    \n    # Iterate over the first k elements\n    for i in range(k):\n        # While the stack is not empty and the top of the stack is less than the next number\n        while stack and stack[-1] < next_num:\n            result.append(stack.pop())\n        \n        # If the current number is less than the next number, we cannot sort\n        if p[i] < next_num:\n            return -1\n        \n        # Push the current number onto the stack\n        stack.append(p[i])\n        \n        # Decrease the next number\n        next_num -= 1\n    \n    # Now we need to fill the rest of the permutation\n    while next_num > 0:\n        # If the next number is already used, skip it\n        if next_num not in used:\n            # Push it onto the stack\n            stack.append(next_num)\n        next_num -= 1\n    \n    # Finally, pop all remaining elements from the stack\n    while stack:\n        result.append(stack.pop())\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = is_stack_sortable(n, k, p)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "a, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "cnt1 = int(input().strip())\ncnt2 = int(input().strip())\ncnt3 = int(input().strip())\ncnt4 = int(input().strip())\n\n# Check if it's possible to form a regular bracket sequence\nif cnt1 + cnt2 + cnt3 + cnt4 == 0:\n    print(1)\nelse:\n    open_needed = cnt1 + cnt2\n    close_needed = cnt3 + cnt4\n    \n    if open_needed >= close_needed and (open_needed - close_needed) % 2 == 0:\n        print(1)\n    else:\n        print(0)"}
{"solution": "n, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelse:\n    print(n + k - t)"}
{"solution": "def minimal_lexicographic_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t:\n            if not u or t[-1] <= u[-1]:\n                u.append(t.pop())\n            else:\n                break\n    \n    return ''.join(u)\n\ns = input().strip()\nresult = minimal_lexicographic_string(s)\nprint(result)"}
{"solution": "def check_records(test_cases):\n    results = []\n    for case in test_cases:\n        n = case[0]\n        records = case[1]\n        \n        valid = True\n        prev_p, prev_c = 0, 0\n        \n        for p, c in records:\n            if p < prev_p or c < prev_c or c > p:\n                valid = False\n                break\n            if p - prev_p < c - prev_c:\n                valid = False\n                break\n            \n            prev_p, prev_c = p, c\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nT = int(data[0])\ntest_cases = []\nindex = 1\n\nfor _ in range(T):\n    n = int(data[index])\n    records = []\n    for j in range(n):\n        p, c = map(int, data[index + j + 1].split())\n        records.append((p, c))\n    test_cases.append((n, records))\n    index += n + 1\n\n# Get results\nresults = check_records(test_cases)\n\n# Print output\nfor result in results:\n    print(result)"}
{"solution": "def is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n\ntime_input = input().strip()\nhh, mm = map(int, time_input.split(':'))\nresult = next_palindrome_time(hh, mm)\nprint(result)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Calculate the current distance\ncurrent_distance = abs(min_index - max_index)\n\n# Calculate the maximum possible distance after one swap\nmax_distance = max(abs(min_index - 0), abs(min_index - (n - 1)), abs(max_index - 0), abs(max_index - (n - 1)))\n\n# The result is the maximum of the current distance and the calculated max distance\nresult = max(current_distance, max_distance)\nprint(result)"}
{"solution": "def is_s_palindrome(s):\n    mirror_chars = {\n        'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M', \n        'O': 'O', 'o': 'o', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S', \n        'T': 'T', 'U': 'U', 'v': 'v', 'V': 'V', 'W': 'W', 'x': 'x', \n        'Y': 'Y'\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        if s[i] not in mirror_chars or mirror_chars[s[i]] != s[n - 1 - i]:\n            return \"NIE\"\n    return \"TAK\"\n\ns = input().strip()\nprint(is_s_palindrome(s))"}
{"solution": "def max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n\n    # Convert a to string to work with its digits\n    str_a = str(a)\n    str_b = str(b)\n\n    # Generate all unique permutations of the digits of a\n    permuted_numbers = set(int(''.join(p)) for p in permutations(str_a))\n\n    # Filter out numbers that are greater than b and have the same length as a\n    valid_numbers = [num for num in permuted_numbers if num <= b and len(str(num)) == len(str_a)]\n\n    # Return the maximum valid number\n    return max(valid_numbers)\n\n# Read input\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result and print it\nresult = max_permutation_not_exceeding(a, b)\nprint(result)"}
{"solution": "def can_alice_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal down-right, diagonal down-left\n    n = 10\n\n    def check_win(x, y):\n        for dx, dy in directions:\n            count = 1  # count the current piece\n            # Check in the positive direction\n            for step in range(1, 5):\n                nx, ny = x + dx * step, y + dy * step\n                if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                    count += 1\n                else:\n                    break\n            # Check in the negative direction\n            for step in range(1, 5):\n                nx, ny = x - dx * step, y - dy * step\n                if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                    count += 1\n                else:\n                    break\n            if count >= 5:\n                return True\n        return False\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                board[i][j] = 'X'  # Place Alice's cross\n                if check_win(i, j):\n                    return \"YES\"\n                board[i][j] = '.'  # Undo the move\n    return \"NO\"\n\n# Read input\nboard = [input().strip() for _ in range(10)]\nprint(can_alice_win(board))"}
{"solution": "def create_symmetric_matrix(n, k):\n    if k > n * n or (n % 2 == 0 and k % 2 != 0):\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        for j in range(i, n):\n            if i == j:  # Diagonal element\n                if k > 0:\n                    matrix[i][j] = 1\n                    k -= 1\n            else:  # Symmetric pair\n                if k >= 2:\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n\n    if k > 0:\n        return -1\n\n    return matrix\n\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))"}
{"solution": "import sys\n\n# Read input\nx, y, z = map(float, sys.stdin.readline().strip().split())\n\n# Define the expressions\nexpressions = [\n    (x ** (y ** z), \"x^y^z\"),\n    (x ** (z ** y), \"x^z^y\"),\n    ((x ** y) ** z, \"(x^y)^z\"),\n    ((x ** z) ** y, \"(x^z)^y\"),\n    (y ** (x ** z), \"y^x^z\"),\n    (y ** (z ** x), \"y^z^x\"),\n    ((y ** x) ** z, \"(y^x)^z\"),\n    ((y ** z) ** x, \"(y^z)^x\"),\n    (z ** (x ** y), \"z^x^y\"),\n    (z ** (y ** x), \"z^y^x\"),\n    ((z ** x) ** y, \"(z^x)^y\"),\n    ((z ** y) ** x, \"(z^y)^x\"),\n]\n\n# Find the maximum value and its corresponding expression\nmax_value = -1\nmax_index = -1\n\nfor i, (value, expr) in enumerate(expressions):\n    if value > max_value:\n        max_value = value\n        max_index = i\n\n# Output the corresponding expression\nprint(expressions[max_index][1])"}
{"solution": "n = int(input())\ns = input()\n\nmin_operations = n  # Start with the maximum operations (typing all characters one by one)\n\n# Check for every possible prefix length\nfor i in range(1, n):\n    prefix = s[:i]\n    if s.startswith(prefix * 2):  # Check if the string can be formed by prefix + prefix\n        # Calculate operations: type prefix + copy + remaining characters\n        operations = i + 1 + (n - 2 * i)\n        min_operations = min(min_operations, operations)\n\n# Print the minimum operations found\nprint(min_operations)"}
{"solution": "n = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = []\nregulars = []\n\nfor name, type_ in files:\n    if type_ == '1':\n        examples.append(name)\n    else:\n        regulars.append(name)\n\ne = len(examples)\nmoves = []\n\n# Move examples to their new positions\nfor i in range(e):\n    moves.append(f\"move {examples[i]} {i + 1}\")\n\n# Move regular tests to their new positions\nfor i in range(len(regulars)):\n    moves.append(f\"move {regulars[i]} {e + i + 1}\")\n\nprint(len(moves))\nfor move in moves:\n    print(move)"}
{"solution": "def min_replacements_to_lucky_ticket(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Create a list of possible changes\n    changes = []\n    if sum_first > sum_second:\n        # We need to decrease the first half or increase the second half\n        changes = [9 - digit for digit in first_half] + [digit for digit in second_half]\n    else:\n        # We need to increase the first half or decrease the second half\n        changes = [digit for digit in first_half] + [9 - digit for digit in second_half]\n    \n    # Sort changes in descending order\n    changes.sort(reverse=True)\n    \n    # Calculate the minimum number of replacements\n    replacements = 0\n    for change in changes:\n        diff -= change\n        replacements += 1\n        if diff <= 0:\n            break\n    \n    return replacements\n\nticket = input().strip()\nprint(min_replacements_to_lucky_ticket(ticket))"}
{"solution": "def minimum_traps(m, x):\n    # Since GCD(x, m) = 1, the x-mouse will visit all rooms\n    # The number of unique rooms visited is equal to m - 1\n    # We need to place traps in a way that covers all possible starting points\n    # The minimum number of traps needed is m - 1\n    return m - 1\n\n# Read input\nm, x = map(int, input().split())\n# Calculate and print the result\nprint(minimum_traps(m, x))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef birthday_paradox(n, k):\n    days = 1 << n  # 2^n\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no collision\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator *= (days - i)\n        denominator *= days\n\n    # Probability of at least one collision\n    A = denominator - numerator\n    B = denominator\n\n    # Reduce A/B to irreducible form\n    common_divisor = gcd(A, B)\n    A //= common_divisor\n    B //= common_divisor\n\n    # Modulo operation\n    MOD = 1000003\n    A %= MOD\n    B %= MOD\n\n    return A, B\n\nn, k = map(int, input().split())\nA, B = birthday_paradox(n, k)\nprint(A, B)"}
{"solution": "def is_valid_journey(n, journey):\n    current_position = 0  # 0 represents North Pole, 20000 represents South Pole\n\n    for t, direction in journey:\n        if current_position == 0 and direction != \"South\":\n            return \"NO\"\n        if current_position == 20000 and direction != \"North\":\n            return \"NO\"\n        \n        if direction == \"North\":\n            current_position -= t\n        elif direction == \"South\":\n            current_position += t\n        elif direction == \"West\" or direction == \"East\":\n            # Moving West or East does not change the position in terms of North/South\n            continue\n        \n        if current_position < 0 or current_position > 20000:\n            return \"NO\"\n\n    if current_position != 0:\n        return \"NO\"\n\n    return \"YES\"\n\n# Input reading\nn = int(input())\njourney = [tuple(input().split()) for _ in range(n)]\njourney = [(int(t), direction) for t, direction in journey]\n\n# Output the result\nprint(is_valid_journey(n, journey))"}
{"solution": "def count_common_terms(a1, b1, a2, b2, L, R):\n    from math import gcd\n\n    # Calculate the step size and the offset\n    step = abs(a1 * a2 // gcd(a1, a2))\n    \n    # Find the first valid x in the range [L, R]\n    def first_valid_x():\n        for k in range(0, step):\n            x = a1 * k + b1\n            if L <= x <= R:\n                return x\n            if x > R:\n                break\n        return None\n\n    # Find the first valid x\n    x_start = first_valid_x()\n    if x_start is None:\n        return 0\n\n    # Calculate the last valid x in the range [L, R]\n    def last_valid_x():\n        for k in range(step - 1, -1, -1):\n            x = a1 * k + b1\n            if L <= x <= R:\n                return x\n            if x < L:\n                break\n        return None\n\n    x_end = last_valid_x()\n    if x_end is None:\n        return 0\n\n    # Count the number of valid x's\n    count = (x_end - x_start) // step + 1\n    return count\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\nresult = count_common_terms(a1, b1, a2, b2, L, R)\nprint(result)"}
{"solution": "def max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_for_a = (a + x - 1) // x  # ceil(a / x)\n        plates_for_b = (b + x - 1) // x  # ceil(b / x)\n        return plates_for_a + plates_for_b <= n\n\n    left, right = 1, max(a, b)\n    answer = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if can_distribute(mid):\n            answer = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return answer\n\nn, a, b = map(int, input().split())\nprint(max_min_pieces(n, a, b))"}
{"solution": "def is_valid_flag(n, m, field):\n    if n % 3 == 0:\n        stripe_height = n // 3\n        colors = set()\n        for i in range(3):\n            stripe = field[i * stripe_height:(i + 1) * stripe_height]\n            if len(set(row for row in stripe)) != 1:\n                return \"NO\"\n            colors.add(stripe[0][0])\n        return \"YES\" if len(colors) == 3 else \"NO\"\n    elif m % 3 == 0:\n        stripe_width = m // 3\n        colors = set()\n        for i in range(3):\n            stripe = [row[i * stripe_width:(i + 1) * stripe_width] for row in field]\n            if len(set(stripe)) != 1:\n                return \"NO\"\n            colors.add(stripe[0][0])\n        return \"YES\" if len(colors) == 3 else \"NO\"\n    return \"NO\"\n\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\nprint(is_valid_flag(n, m, field))"}
{"solution": "def find_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 6 * layer\n\n    while n > moves_in_layer:\n        n -= moves_in_layer\n        layer += 1\n        moves_in_layer = 6 * layer\n\n    # The coordinates for the current layer\n    x, y = layer, 0\n\n    # Calculate the position in the current layer\n    for i in range(n):\n        if i < layer:\n            x -= 1\n        elif i < 2 * layer:\n            x -= 1\n            y += 1\n        elif i < 3 * layer:\n            y += 1\n        elif i < 4 * layer:\n            x += 1\n            y += 1\n        elif i < 5 * layer:\n            x += 1\n        else:\n            x += 1\n            y -= 1\n\n    return (x, y)\n\nn = int(input().strip())\nx, y = find_coordinates(n)\nprint(x, y)"}
{"solution": "def can_deal_exact_damage(a, b, c):\n    for i in range(c // a + 1):\n        if (c - a * i) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\na, b, c = map(int, input().split())\nprint(can_deal_exact_damage(a, b, c))"}
{"solution": "def can_tracks_coincide(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between consecutive barriers for Kefa\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    # Calculate the distances between consecutive barriers for Sasha\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if Kefa's differences can be rotated to match Sasha's differences\n    for i in range(n):\n        if kefa_diffs == sasha_diffs[i:] + sasha_diffs[:i]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_distances, sasha_distances))"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    if not is_palindrome(s):\n        return n\n    \n    for length in range(n - 1, 0, -1):\n        for start in range(n - length + 1):\n            substring = s[start:start + length]\n            if not is_palindrome(substring):\n                return length\n    \n    return 0\n\ns = input().strip()\nprint(longest_non_palindrome_substring(s))"}
{"solution": "n = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\nrated = False\nunrated = False\n\nfor a, b in ratings:\n    if a != b:\n        rated = True\n        break\n\nif rated:\n    print(\"rated\")\nelse:\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            unrated = True\n            break\n\n    if unrated:\n        print(\"unrated\")\n    else:\n        print(\"maybe\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nd = [float('inf')] * n\n\n# First pass: from left to right\nlast_zero = -1\nfor i in range(n):\n    if a[i] == 0:\n        last_zero = i\n    if last_zero != -1:\n        d[i] = i - last_zero\n\n# Second pass: from right to left\nlast_zero = -1\nfor i in range(n - 1, -1, -1):\n    if a[i] == 0:\n        last_zero = i\n    if last_zero != -1:\n        d[i] = min(d[i], last_zero - i)\n\nprint(' '.join(map(str, d)))"}
{"solution": "def count_cyclic_strings(n, s):\n    from itertools import product\n\n    def is_cyclic_shift(s1, s2):\n        return len(s1) == len(s2) and s1 in (s2 + s2)\n\n    def contains_substring(t, s):\n        return any(s in t[i:] + t[:i] for i in range(len(t)))\n\n    distinct_strings = set()\n    \n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if contains_substring(t, s):\n            distinct_strings.add(t)\n\n    return len(distinct_strings)\n\nn = int(input().strip())\ns = input().strip()\nresult = count_cyclic_strings(n, s)\nprint(result)"}
{"solution": "import sys\nimport math\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    vectors = []\n    \n    for i in range(1, n + 1):\n        x, y = map(int, data[i].split())\n        angle = math.atan2(y, x)\n        vectors.append((angle, i))\n    \n    vectors.sort()\n    \n    min_angle = float('inf')\n    best_pair = (0, 0)\n    \n    for i in range(n):\n        angle1, index1 = vectors[i]\n        angle2, index2 = vectors[(i + 1) % n]\n        \n        # Calculate the non-oriented angle\n        angle_diff = abs(angle2 - angle1)\n        if angle_diff > math.pi:\n            angle_diff = 2 * math.pi - angle_diff\n        \n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            best_pair = (index1, index2)\n    \n    print(best_pair[0], best_pair[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def minimal_time_to_post_office(d, k, a, b, t):\n    # Calculate the number of full segments the car can drive\n    full_segments = d // k\n    remaining_distance = d % k\n\n    # Time if Vasiliy drives the full segments and walks the remaining distance\n    time_using_car = full_segments * (k * a + t) + remaining_distance * a\n    if full_segments > 0:\n        time_using_car -= t  # Remove the last repair time since he doesn't need to repair after the last segment\n\n    # Time if Vasiliy walks the entire distance\n    time_walking = d * b\n\n    # Time if Vasiliy drives as much as possible and then walks\n    time_mixed = 0\n    if full_segments > 0:\n        time_mixed += full_segments * (k * a + t)  # Driving full segments\n        time_mixed += remaining_distance * a  # Driving remaining distance\n        time_mixed -= t  # Remove the last repair time\n    time_mixed += (d - (full_segments * k + remaining_distance)) * b  # Walking the rest\n\n    # Calculate the minimum time\n    min_time = min(time_using_car, time_walking, time_mixed)\n\n    return min_time\n\n# Input reading\nd, k, a, b, t = map(int, input().split())\nprint(minimal_time_to_post_office(d, k, a, b, t))"}
{"solution": "def find_sequence(n, k):\n    if k * (k + 1) // 2 > n:\n        return -1\n    \n    # The minimum sum of the first k natural numbers is k * (k + 1) // 2\n    # We can find the maximum GCD by distributing the remaining sum evenly\n    remaining = n - (k * (k + 1) // 2)\n    gcd = remaining // k + 1\n    \n    sequence = [i + gcd for i in range(1, k + 1)]\n    return sequence\n\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def count_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n        \n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n        \n    result = 0\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n        \n    return result\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))"}
{"solution": "def max_beauty_with_subarray(n, x, a):\n    # Function to calculate maximum subarray sum using Kadane's algorithm\n    def kadane(arr):\n        max_ending_here = max_so_far = 0\n        for value in arr:\n            max_ending_here = max(0, max_ending_here + value)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    # Calculate the beauty of the original array\n    original_beauty = kadane(a)\n\n    # Calculate the maximum beauty after multiplying a subarray by x\n    max_increase = 0\n    current_sum = 0\n    for i in range(n):\n        current_sum += a[i]\n        max_increase = max(max_increase, current_sum * x)\n        if current_sum < 0:\n            current_sum = 0\n\n    # Calculate the maximum beauty after applying the operation\n    max_beauty = original_beauty + max_increase\n\n    return max(max_beauty, original_beauty)\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_beauty_with_subarray(n, x, a))"}
{"solution": "def kth_largest_in_multiplication_table(n, m, k):\n    left, right = 1, n * m\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = 0\n        \n        for i in range(1, n + 1):\n            count += min(mid // i, m)\n        \n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return left\n\n# Read input\nn, m, k = map(int, input().split())\n# Get the k-th largest number\nresult = kth_largest_in_multiplication_table(n, m, k)\n# Print the result\nprint(result)"}
{"solution": "def find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    start += (k - 1) // length\n    num_str = str(start)\n    return int(num_str[(k - 1) % length])\n\nk = int(input().strip())\nprint(find_kth_digit(k))"}
{"solution": "def max_bourles_after_trading(n, m, r, buy_prices, sell_prices):\n    min_buy_price = min(buy_prices)\n    max_sell_price = max(sell_prices)\n\n    if max_sell_price <= min_buy_price:\n        return r\n\n    shares_can_buy = r // min_buy_price\n    remaining_bourles = r % min_buy_price\n    total_bourles_after_selling = remaining_bourles + shares_can_buy * max_sell_price\n\n    return total_bourles_after_selling\n\n# Input reading\nn, m, r = map(int, input().split())\nbuy_prices = list(map(int, input().split()))\nsell_prices = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = max_bourles_after_trading(n, m, r, buy_prices, sell_prices)\nprint(result)"}
{"solution": "def find_possible_message(t):\n    n = len(t)\n    \n    for i in range(1, n // 2 + 1):\n        if t[:i] == t[n-i:n] and n - i > i:\n            return \"YES\\n\" + t[:n-i]\n    \n    return \"NO\"\n\nt = input().strip()\nprint(find_possible_message(t))"}
{"solution": "def total_games(teams):\n    games = 0\n    while teams > 1:\n        if teams % 2 == 0:\n            games += teams // 2\n            teams //= 2\n        else:\n            games += (teams - 1) // 2\n            teams = (teams + 1) // 2\n    return games\n\ndef find_teams(n):\n    possible_teams = []\n    for i in range(1, 2 * n + 1):\n        if total_games(i) == n:\n            possible_teams.append(i)\n    \n    if possible_teams:\n        return possible_teams\n    else:\n        return [-1]\n\nn = int(input().strip())\nresult = find_teams(n)\nfor r in result:\n    print(r)"}
{"solution": "def max_antipalindromic_beauty(n, s, beauties):\n    from collections import Counter\n\n    # Count the frequency of each character\n    char_count = Counter(s)\n    \n    # Create two halves for the antipalindromic string\n    half1 = []\n    half2 = []\n    \n    # Fill the halves with characters\n    for char, count in char_count.items():\n        half1.extend([char] * (count // 2))\n        half2.extend([char] * (count // 2))\n    \n    # Sort halves to maximize beauty\n    half1.sort()\n    half2.sort(reverse=True)\n    \n    # Create the antipalindromic string\n    t = half1 + half2\n    \n    # Calculate the maximum beauty\n    max_beauty = 0\n    for i in range(n):\n        if s[i] == t[i]:\n            max_beauty += beauties[i]\n    \n    return max_beauty\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\nbeauties = list(map(int, input().strip().split()))\n\n# Get the result and print it\nresult = max_antipalindromic_beauty(n, s, beauties)\nprint(result)"}
{"solution": "def can_balance(w, m):\n    while m > 0:\n        remainder = m % w\n        if remainder > 1:\n            return \"NO\"\n        m //= w\n    return \"YES\"\n\nw, m = map(int, input().split())\nprint(can_balance(w, m))"}
{"solution": "def find_sequence(n, k):\n    # Step 1: Decompose n into powers of 2\n    powers = []\n    for i in range(60):  # 2^60 > 10^18\n        if n & (1 << i):\n            powers.append(i)\n\n    # Step 2: Check if we can form a sequence of length k\n    if len(powers) > k:\n        return \"No\"\n    \n    # Step 3: Fill the sequence to reach length k\n    while len(powers) < k:\n        # Split the largest power into two smaller powers\n        largest = powers.pop()\n        if largest == 0:\n            return \"No\"  # Cannot split 2^0 anymore\n        powers.append(largest - 1)\n        powers.append(largest - 1)\n\n    # Step 4: Sort the powers in descending order for lexicographically largest\n    powers.sort(reverse=True)\n\n    return \"Yes\\n\" + \" \".join(map(str, powers))\n\n# Input reading\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\nprint(result)"}
{"solution": "def champagne_pyramid(n, t):\n    # Create a 2D list to represent the glasses in the pyramid\n    glasses = [[0] * (i + 1) for i in range(n)]\n    \n    # Pour champagne into the top glass\n    glasses[0][0] = t\n    \n    # Distribute champagne\n    for i in range(n):\n        for j in range(i + 1):\n            if glasses[i][j] > 1:\n                overflow = glasses[i][j] - 1\n                glasses[i][j] = 1\n                if i + 1 < n:\n                    glasses[i + 1][j] += overflow / 2\n                    glasses[i + 1][j + 1] += overflow / 2\n    \n    # Count the number of completely full glasses\n    full_glasses = sum(1 for i in range(n) for j in range(i + 1) if glasses[i][j] == 1)\n    \n    return full_glasses\n\n# Read input\nn, t = map(int, input().split())\n# Get the result and print it\nprint(champagne_pyramid(n, t))"}
{"solution": "def calculate_rectangle_area(n, points):\n    if n == 1:\n        return -1\n    elif n == 2:\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        return abs(x2 - x1) * abs(y2 - y1)\n    elif n == 3:\n        x_coords = {points[0][0], points[1][0], points[2][0]}\n        y_coords = {points[0][1], points[1][1], points[2][1]}\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            return abs(max(x_coords) - min(x_coords)) * abs(max(y_coords) - min(y_coords))\n        else:\n            return -1\n    elif n == 4:\n        x_coords = {point[0] for point in points}\n        y_coords = {point[1] for point in points}\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            return abs(max(x_coords) - min(x_coords)) * abs(max(y_coords) - min(y_coords))\n        else:\n            return -1\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\narea = calculate_rectangle_area(n, points)\nprint(area)"}
{"solution": "def min_wooden_bars(n, a, b):\n    # Total lengths needed for two doors\n    total_length = 2 * (2 * a + b)  # 2 verticals and 1 top for each door\n    \n    # Calculate the minimum number of bars needed\n    min_bars = (total_length + n - 1) // n  # Ceiling division\n    \n    return min_bars\n\n# Input reading\nn = int(input())\na = int(input())\nb = int(input())\n\n# Output the result\nprint(min_wooden_bars(n, a, b))"}
{"solution": "def can_sort(n, a, s):\n    # Create a list of segments where swaps are allowed\n    segments = []\n    start = 0\n    \n    for i in range(n - 1):\n        if s[i] == '0':\n            segments.append((start, i + 1))\n            start = i + 1\n            \n    segments.append((start, n))  # Add the last segment\n    \n    # Check each segment if it can be sorted\n    for start, end in segments:\n        segment = a[start:end]\n        if sorted(segment) != segment:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\ns = input().strip()\n\n# Output the result\nprint(can_sort(n, a, s))"}
{"solution": "def time_to_get_lunch(seat_info):\n    n = int(seat_info[:-1])\n    s = seat_info[-1]\n    \n    # Calculate the number of complete cycles before row n\n    complete_cycles = (n - 1) // 4\n    time_spent = complete_cycles * 18  # Each complete cycle takes 18 seconds\n    \n    # Determine the position of the row in the current cycle\n    row_in_cycle = (n - 1) % 4\n    \n    # Time spent serving rows in the current cycle\n    if row_in_cycle == 0:  # Row 1\n        time_spent += 1  # First attendant serves row 1\n    elif row_in_cycle == 1:  # Row 2\n        time_spent += 10  # After serving row 1 and moving to row 2\n    elif row_in_cycle == 2:  # Row 3\n        time_spent += 6 + 1  # Serve row 3 and move to row 4\n    elif row_in_cycle == 3:  # Row 4\n        time_spent += 11  # After serving row 3 and moving to row 4\n    \n    # Determine the additional time based on the seat\n    if s in 'def':\n        time_spent += 'def'.index(s) + 1  # Seats d, e, f are served first\n    else:\n        time_spent += 6 + 'abc'.index(s) + 1  # Seats a, b, c are served after\n    \n    return time_spent\n\n# Read input\nseat_info = input().strip()\n# Calculate and print the result\nprint(time_to_get_lunch(seat_info))"}
{"solution": "def convert_to_decimal(digits, base):\n    value = 0\n    for digit in digits:\n        value = value * base + digit\n    return value\n\nn, b_x = map(int, input().split())\nx_digits = list(map(int, input().split()))\nm, b_y = map(int, input().split())\ny_digits = list(map(int, input().split()))\n\nx_value = convert_to_decimal(x_digits, b_x)\ny_value = convert_to_decimal(y_digits, b_y)\n\nif x_value < y_value:\n    print('<')\nelif x_value > y_value:\n    print('>')\nelse:\n    print('=')"}
{"solution": "def determine_winner(n, a):\n    # Calculate the nim-sum (xor of all elements)\n    nim_sum = 0\n    for value in a:\n        nim_sum ^= value\n    \n    # If nim-sum is 0, BitAryo wins, otherwise BitLGM wins\n    return \"BitAryo\" if nim_sum == 0 else \"BitLGM\"\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, a))"}
{"solution": "def count_valid_decks(n, k, a):\n    from math import gcd\n    from functools import reduce\n\n    def prime_factors(x):\n        factors = {}\n        d = 2\n        while d * d <= x:\n            while (x % d) == 0:\n                if d in factors:\n                    factors[d] += 1\n                else:\n                    factors[d] = 1\n                x //= d\n            d += 1\n        if x > 1:\n            factors[x] = 1\n        return factors\n\n    k_factors = prime_factors(k)\n    k_factor_keys = list(k_factors.keys())\n    \n    prefix_product = [1] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_product[i] = prefix_product[i - 1] * a[i - 1]\n\n    valid_count = 0\n\n    for x in range(n):\n        for y in range(n - x):\n            if x + y >= n - 1:\n                break\n            product = prefix_product[n - y] // prefix_product[x]\n            if all(product % (p ** k_factors[p]) == 0 for p in k_factor_keys):\n                valid_count += 1\n\n    return valid_count\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(count_valid_decks(n, k, a))"}
{"solution": "n, k = map(int, input().split())\ns = input().strip()\n\nfrom collections import Counter\n\ncolor_count = Counter(s)\nmax_color_count = max(color_count.values())\n\nif max_color_count > k:\n    print(\"NO\")\nelse:\n    print(\"YES\")"}
{"solution": "n = int(input())\narray = list(map(int, input().split()))\n\nmin_value = min(array)\nlast_index = -1\nmin_distance = float('inf')\n\nfor i in range(n):\n    if array[i] == min_value:\n        if last_index != -1:\n            min_distance = min(min_distance, i - last_index)\n        last_index = i\n\nprint(min_distance)"}
{"solution": "from math import gcd\n\ndef probability_of_tie(t, w, b):\n    # Calculate the maximum steps Willman and Bolt can take\n    max_steps_w = t // w\n    max_steps_b = t // b\n    \n    # Calculate the number of lengths where they tie\n    tie_lengths = min(max_steps_w, max_steps_b)\n    \n    # The total possible lengths of the racetrack\n    total_lengths = t\n    \n    # The probability as a fraction\n    p = tie_lengths\n    q = total_lengths\n    \n    # Reduce the fraction\n    divisor = gcd(p, q)\n    p //= divisor\n    q //= divisor\n    \n    return f\"{p}/{q}\"\n\n# Input reading\nt, w, b = map(int, input().split())\nprint(probability_of_tie(t, w, b))"}
{"solution": "x, y, z = map(int, input().split())\n\nmin_upvotes = x\nmax_upvotes = x + z\nmin_downvotes = y\nmax_downvotes = y + z\n\nif max_upvotes < min_downvotes:\n    print(\"-\")\nelif max_downvotes < min_upvotes:\n    print(\"+\")\nelif min_upvotes == max_upvotes and min_downvotes == max_downvotes:\n    print(\"0\")\nelse:\n    print(\"?\")"}
{"solution": "def min_change_length(n, operations, x, y):\n    # Count the number of each operation\n    count_U = operations.count('U')\n    count_D = operations.count('D')\n    count_L = operations.count('L')\n    count_R = operations.count('R')\n    \n    # Calculate the required moves\n    required_U = max(0, y)\n    required_D = max(0, -y)\n    required_L = max(0, -x)\n    required_R = max(0, x)\n    \n    # Check if it's possible to reach (x, y)\n    if required_U + required_D > count_U + count_D or required_L + required_R > count_L + count_R:\n        return -1\n    \n    # Calculate the excess moves\n    excess_U = count_U - required_U\n    excess_D = count_D - required_D\n    excess_L = count_L - required_L\n    excess_R = count_R - required_R\n    \n    # Calculate the number of changes needed\n    changes_needed = 0\n    if excess_U < 0:\n        changes_needed += -excess_U\n    if excess_D < 0:\n        changes_needed += -excess_D\n    if excess_L < 0:\n        changes_needed += -excess_L\n    if excess_R < 0:\n        changes_needed += -excess_R\n    \n    # If we need to change more than we have, return -1\n    if changes_needed > n:\n        return -1\n    \n    # Calculate the minimum length of the segment to change\n    min_length = 0\n    if changes_needed > 0:\n        min_length = changes_needed\n    \n    return min_length\n\n# Input reading\nn = int(input().strip())\noperations = input().strip()\nx, y = map(int, input().strip().split())\n\n# Output the result\nprint(min_change_length(n, operations, x, y))"}
{"solution": "def count_prefixes(T, test_cases):\n    results = []\n    \n    for n, x, s in test_cases:\n        cnt0 = s.count('0')\n        cnt1 = s.count('1')\n        balance = cnt0 - cnt1\n        \n        # Calculate the balance of prefixes of s\n        current_balance = 0\n        prefix_balances = {}\n        prefix_balances[0] = 1  # empty prefix\n        \n        for char in s:\n            if char == '0':\n                current_balance += 1\n            else:\n                current_balance -= 1\n            \n            if current_balance in prefix_balances:\n                prefix_balances[current_balance] += 1\n            else:\n                prefix_balances[current_balance] = 1\n        \n        # Check for infinite solutions\n        if balance == 0:\n            if x in prefix_balances:\n                results.append(-1)\n            else:\n                results.append(0)\n        else:\n            # Calculate the number of valid prefixes\n            count = 0\n            for k in prefix_balances:\n                if (x - k) % balance == 0 and (x - k) // balance >= 0:\n                    count += prefix_balances[k]\n            results.append(count)\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nT = int(data[0])\ntest_cases = []\n\nfor i in range(1, 2 * T, 2):\n    n, x = map(int, data[i].split())\n    s = data[i + 1]\n    test_cases.append((n, x, s))\n\n# Get results\nresults = count_prefixes(T, test_cases)\n\n# Print results\nfor result in results:\n    print(result)"}
{"solution": "def min_deletions_to_divisible(n, k):\n    n_str = str(n)\n    target_zeros = '0' * k\n    count = 0\n    found_zeros = 0\n\n    for digit in reversed(n_str):\n        if found_zeros < k and digit == '0':\n            found_zeros += 1\n        elif found_zeros == k:\n            break\n        else:\n            count += 1\n\n    return count + (len(n_str) - found_zeros - k)\n\nn, k = map(int, input().split())\nprint(min_deletions_to_divisible(n, k))"}
{"solution": "def count_questions(n, m, k, x, y):\n    total_questions_per_cycle = n * m * 2 - m  # Total questions in one full cycle\n    full_cycles = k // total_questions_per_cycle\n    remaining_questions = k % total_questions_per_cycle\n\n    # Each pupil gets questions from full cycles\n    max_questions = full_cycles\n    min_questions = full_cycles\n\n    # Count questions for each pupil in the remaining questions\n    questions = [[0] * m for _ in range(n)]\n\n    # Fill questions for the first pass\n    for row in range(n):\n        for col in range(m):\n            if remaining_questions > 0:\n                questions[row][col] += 1\n                remaining_questions -= 1\n\n    # Fill questions for the second pass (reverse)\n    for row in range(n - 2, -1, -1):\n        for col in range(m):\n            if remaining_questions > 0:\n                questions[row][col] += 1\n                remaining_questions -= 1\n\n    # Calculate max and min questions\n    for row in range(n):\n        for col in range(m):\n            if questions[row][col] > max_questions:\n                max_questions = questions[row][col]\n            if questions[row][col] < min_questions:\n                min_questions = questions[row][col]\n\n    # Add full cycles to each pupil's count\n    for row in range(n):\n        for col in range(m):\n            questions[row][col] += full_cycles\n\n    # Count Sergei's questions\n    sergei_questions = questions[x - 1][y - 1]\n\n    print(max_questions, min_questions, sergei_questions)\n\n# Input reading\nn, m, k, x, y = map(int, input().split())\ncount_questions(n, m, k, x, y)"}
{"solution": "def max_beauty_after_turns(n, ribbons):\n    max_length = len(ribbons[0])\n    beauties = []\n\n    for ribbon in ribbons:\n        # Count frequency of each character\n        frequency = {}\n        for char in ribbon:\n            if char in frequency:\n                frequency[char] += 1\n            else:\n                frequency[char] = 1\n        \n        # Find the maximum frequency\n        max_freq = max(frequency.values())\n        \n        # Calculate the maximum beauty after n turns\n        max_possible_beauty = min(max_length, max_freq + n)\n        beauties.append(max_possible_beauty)\n\n    # Determine the winner\n    max_beauty = max(beauties)\n    if beauties.count(max_beauty) > 1:\n        return \"Draw\"\n    else:\n        return [\"Kuro\", \"Shiro\", \"Katie\"][beauties.index(max_beauty)]\n\n# Read input\nn = int(input().strip())\nribbons = [input().strip() for _ in range(3)]\n\n# Get the result and print it\nresult = max_beauty_after_turns(n, ribbons)\nprint(result)"}
{"solution": "c, v_0, v_1, a, l = map(int, input().split())\n\ndays = 0\npages_read = 0\ncurrent_speed = v_0\n\nwhile pages_read < c:\n    days += 1\n    if days == 1:\n        pages_read += current_speed\n    else:\n        pages_read += min(current_speed, v_1) - l\n        current_speed += a\n\nprint(days)"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nn = int(input().strip())\n\nif n == 3:\n    print(1)\n    print(3)\nelif n % 2 == 1:\n    if is_prime(n - 2):\n        print(2)\n        print(n - 2, 2)\n    else:\n        print(3)\n        print(3, (n - 3) // 2, (n - 3) // 2 + 1)"}
{"solution": "def can_wipe_out_walls(n, m, field):\n    total_walls = sum(row.count('*') for row in field)\n    \n    for i in range(n):\n        for j in range(m):\n            # Count walls in the current row and column\n            row_walls = field[i].count('*')\n            col_walls = sum(1 for k in range(n) if field[k][j] == '*')\n            \n            # Total walls that would be destroyed if bomb is placed at (i, j)\n            destroyed_walls = row_walls + col_walls\n            \n            # If the bomb is placed on a wall, we need to subtract 1\n            if field[i][j] == '*':\n                destroyed_walls -= 1\n            \n            # Check if all walls can be destroyed\n            if destroyed_walls == total_walls:\n                return \"YES\", (i + 1, j + 1)  # Return 1-based index\n    \n    return \"NO\", None\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Get the result\nresult, coordinates = can_wipe_out_walls(n, m, field)\n\n# Print output\nprint(result)\nif coordinates:\n    print(coordinates[0], coordinates[1])"}
{"solution": "def min_cost_to_adjust_boxes(n, m, a, b):\n    remainder = n % m\n    \n    if remainder == 0:\n        return 0\n    \n    # Cost to build boxes to the next multiple of m\n    boxes_to_build = m - remainder\n    cost_to_build = boxes_to_build * a\n    \n    # Cost to demolish boxes to the previous multiple of m\n    boxes_to_demolish = remainder\n    cost_to_demolish = boxes_to_demolish * b\n    \n    return min(cost_to_build, cost_to_demolish)\n\n# Input reading\nn, m, a, b = map(int, input().split())\n# Output the result\nprint(min_cost_to_adjust_boxes(n, m, a, b))"}
{"solution": "def max_odd_subsequence_sum(n, a):\n    total_sum = sum(x for x in a if x > 0)\n    if total_sum % 2 == 1:\n        return total_sum\n    \n    min_positive_odd = float('inf')\n    max_negative_even = float('-inf')\n    \n    for x in a:\n        if x % 2 == 1 and x > 0:\n            min_positive_odd = min(min_positive_odd, x)\n        elif x % 2 == 0 and x < 0:\n            max_negative_even = max(max_negative_even, x)\n    \n    if min_positive_odd != float('inf'):\n        return total_sum - min_positive_odd\n    elif max_negative_even != float('-inf'):\n        return total_sum + max_negative_even\n    else:\n        return total_sum\n\nn = int(input())\na = list(map(int, input().split()))\nprint(max_odd_subsequence_sum(n, a))"}
{"solution": "def count_playlists(n, T, songs):\n    MOD = 10**9 + 7\n    dp = [[[0] * 4 for _ in range(T + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 1  # Base case: 1 way to have 0 songs and 0 time\n\n    for i in range(1, n + 1):\n        t_i, g_i = songs[i - 1]\n        for j in range(T + 1):\n            for k in range(4):  # Previous genre\n                # If we don't take the current song\n                dp[i][j][k] = (dp[i - 1][j][k] + dp[i][j][k]) % MOD\n                \n                # If we take the current song\n                if j >= t_i and k != g_i:  # Ensure we have enough time and different genre\n                    for prev in range(4):\n                        if prev != g_i:\n                            dp[i][j][g_i] = (dp[i][j][g_i] + dp[i - 1][j - t_i][prev]) % MOD\n\n    result = 0\n    for k in range(1, 4):  # Sum up all playlists of length T with any last genre\n        result = (result + dp[n][T][k]) % MOD\n\n    return result\n\n# Input reading\nn, T = map(int, input().split())\nsongs = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(count_playlists(n, T, songs))"}
{"solution": "def mod_inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef expected_length(m):\n    MOD = 10**9 + 7\n    expected = 0\n    for g in range(1, m + 1):\n        count = m // g\n        expected += count * mod_inverse(count, MOD)\n        expected %= MOD\n    expected = (expected * mod_inverse(m, MOD)) % MOD\n    return expected\n\nm = int(input())\nresult = expected_length(m)\nprint(result)"}
{"solution": "def count_good_pairs(l, r, x, y):\n    if y % x != 0:\n        return 0\n    \n    k = y // x\n    count = 0\n    \n    for i in range(1, int(k**0.5) + 1):\n        if k % i == 0:\n            a1 = i * x\n            b1 = (k // i) * x\n            \n            if l <= a1 <= r and l <= b1 <= r:\n                count += 1 if a1 == b1 else 2\n            \n            if i != k // i:\n                a2 = (k // i) * x\n                b2 = i * x\n                \n                if l <= a2 <= r and l <= b2 <= r:\n                    count += 1 if a2 == b2 else 2\n    \n    return count\n\nl, r, x, y = map(int, input().split())\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "import math\n\ndef smallest_k(a, b):\n    if a > b:\n        a, b = b, a\n    \n    # The difference between b and a\n    d = b - a\n    \n    # If a and b are the same, the answer is 0\n    if d == 0:\n        return 0\n    \n    # To store the minimum LCM and the corresponding k\n    min_lcm = float('inf')\n    best_k = 0\n    \n    # Iterate over all divisors of d\n    for i in range(1, int(math.sqrt(d)) + 1):\n        if d % i == 0:\n            # Check both divisors i and d // i\n            for divisor in (i, d // i):\n                k = (divisor - a % divisor) % divisor\n                lcm = (a + k) * (b + k) // math.gcd(a + k, b + k)\n                \n                if lcm < min_lcm or (lcm == min_lcm and k < best_k):\n                    min_lcm = lcm\n                    best_k = k\n    \n    return best_k\n\n# Read input\na, b = map(int, input().split())\n# Get the result\nresult = smallest_k(a, b)\n# Print the result\nprint(result)"}
{"solution": "import math\n\ndef minimal_additional_marks(n, k, marks):\n    current_sum = sum(marks)\n    current_count = n\n    \n    while True:\n        average = current_sum / current_count\n        rounded_average = math.ceil(average)\n        \n        if rounded_average >= k:\n            return current_count - n\n        \n        current_sum += k\n        current_count += 1\n\n# Read input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(minimal_additional_marks(n, k, marks))"}
{"solution": "import math\n\nn = int(input())\na = list(map(int, input().split()))\n\nrequired_positive_count = math.ceil(n / 2)\n\n# Check for positive d\nfor d in range(1, 1001):\n    positive_count = sum(1 for x in a if x / d > 0)\n    if positive_count >= required_positive_count:\n        print(d)\n        break\nelse:\n    # Check for negative d\n    for d in range(-1, -1001, -1):\n        positive_count = sum(1 for x in a if x / d > 0)\n        if positive_count >= required_positive_count:\n            print(d)\n            break\n    else:\n        print(0)"}
{"solution": "def count_pairs_with_max_nines(n):\n    # The maximum number of nines at the end of the sum can be determined\n    # by finding pairs (i, j) such that (i + j) % 10 == 9\n    # This means we need to find pairs where the last digits of i and j sum to 9.\n    \n    # Count of pairs that can form the maximum number of nines\n    count = 0\n    \n    # We can iterate through possible last digits\n    for i in range(1, 10):\n        j = 9 - i\n        if j < 1 or j > 9:\n            continue\n        \n        # Calculate how many numbers end with digit i and j\n        count_i = (n - i) // 10 + 1\n        count_j = (n - j) // 10 + 1\n        \n        # If i and j are the same, we need to choose 2 from count_i\n        if i == j:\n            count += count_i * (count_i - 1) // 2\n        else:\n            count += count_i * count_j\n    \n    return count\n\nn = int(input())\nprint(count_pairs_with_max_nines(n))"}
{"solution": "def min_minutes_to_equal_bars(a1, b1, a2, b2):\n    def possible_sizes(a, b):\n        sizes = set()\n        sizes.add((a, b))\n        if a % 2 == 0:\n            sizes.add((a // 2, b))\n        if b % 2 == 0:\n            sizes.add((a, b // 2))\n        if a % 3 == 0:\n            sizes.add((a // 3, b))\n        if b % 3 == 0:\n            sizes.add((a, b // 3))\n        return sizes\n\n    sizes1 = possible_sizes(a1, b1)\n    sizes2 = possible_sizes(a2, b2)\n\n    common_sizes = sizes1.intersection(sizes2)\n\n    if not common_sizes:\n        return -1\n\n    min_minutes = float('inf')\n    result_sizes = None\n\n    for size in common_sizes:\n        size1 = (size[0], size[1])\n        size2 = (size[0], size[1])\n        minutes = 0\n\n        if size1 != (a1, b1):\n            if a1 % 2 == 0 and (a1 // 2, b1) == size1:\n                minutes += 1\n            elif b1 % 2 == 0 and (a1, b1 // 2) == size1:\n                minutes += 1\n            elif a1 % 3 == 0 and (a1 // 3, b1) == size1:\n                minutes += 1\n            elif b1 % 3 == 0 and (a1, b1 // 3) == size1:\n                minutes += 1\n\n        if size2 != (a2, b2):\n            if a2 % 2 == 0 and (a2 // 2, b2) == size2:\n                minutes += 1\n            elif b2 % 2 == 0 and (a2, b2 // 2) == size2:\n                minutes += 1\n            elif a2 % 3 == 0 and (a2 // 3, b2) == size2:\n                minutes += 1\n            elif b2 % 3 == 0 and (a2, b2 // 3) == size2:\n                minutes += 1\n\n        if minutes < min_minutes:\n            min_minutes = minutes\n            result_sizes = (size1, size2)\n\n    return min_minutes, result_sizes\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\nresult = min_minutes_to_equal_bars(a1, b1, a2, b2)\n\nif result == -1:\n    print(-1)\nelse:\n    min_minutes, sizes = result\n    print(min_minutes)\n    print(sizes[0][0], sizes[0][1])\n    print(sizes[1][0], sizes[1][1])"}
{"solution": "def determine_winner(xp, yp, xv, yv):\n    # Calculate the distance to (0, 0) for both players\n    polycarp_distance = xp + yp\n    vasiliy_distance = xv + yv\n    \n    # Determine the winner based on the distances\n    if polycarp_distance <= vasiliy_distance:\n        return \"Polycarp\"\n    else:\n        return \"Vasiliy\"\n\n# Read input\nxp, yp, xv, yv = map(int, input().split())\n\n# Output the winner\nprint(determine_winner(xp, yp, xv, yv))"}
{"solution": "def number_of_columns(m, d):\n    # Days in each month for a non-leap year\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    # Get the number of days in the given month\n    days = days_in_month[m - 1]\n    \n    # Calculate the number of columns needed\n    # d is the weekday of the first day of the month (1 = Monday, ..., 7 = Sunday)\n    # We need to find out how many weeks (columns) are needed to fit all days\n    first_week_days = 8 - d  # Days that fit in the first week\n    remaining_days = days - first_week_days  # Remaining days after the first week\n    \n    # If there are no remaining days, we only need one column\n    if remaining_days <= 0:\n        return 1\n    \n    # Calculate full weeks needed for the remaining days\n    full_weeks = (remaining_days + 6) // 7  # +6 to round up for any leftover days\n    \n    # Total columns is the first week + full weeks\n    return 1 + full_weeks\n\n# Input reading\nm, d = map(int, input().split())\n# Output the result\nprint(number_of_columns(m, d))"}
{"solution": "def count_years_with_one_zero(a, b):\n    count = 0\n    for year in range(a, b + 1):\n        binary_representation = bin(year)[2:]  # Get binary representation without '0b' prefix\n        if binary_representation.count('0') == 1:\n            count += 1\n    return count\n\n# Read input\na, b = map(int, input().split())\n# Get the result\nresult = count_years_with_one_zero(a, b)\n# Print the result\nprint(result)"}
{"solution": "def min_layers(N):\n    return (N + 1) // 2 * (N // 2 + 1) + (N // 2) * (N // 2 + 1)\n\nN = int(input().strip())\nprint(min_layers(N))"}
{"solution": "from itertools import combinations\n\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n\ndef count_ways(n, k, S, cubes):\n    count = 0\n    for r in range(1, n + 1):\n        for indices in combinations(range(n), r):\n            total_sum = 0\n            factorials = []\n            for index in indices:\n                total_sum += cubes[index]\n                factorials.append(factorial(cubes[index]))\n            \n            # Check all combinations of applying stickers\n            for sticker_combination in range(1 << r):\n                current_sum = total_sum\n                stickers_used = 0\n                for j in range(r):\n                    if sticker_combination & (1 << j):\n                        if stickers_used < k:\n                            current_sum += (factorials[j] - cubes[indices[j]])\n                            stickers_used += 1\n                if current_sum == S:\n                    count += 1\n    return count\n\n# Input reading\nn, k, S = map(int, input().split())\ncubes = list(map(int, input().split()))\n\n# Output the result\nprint(count_ways(n, k, S, cubes))"}
{"solution": "def can_achieve_array(test_cases):\n    results = []\n    for n, k, a in test_cases:\n        powers = []\n        current_power = 1\n        while current_power <= 10**16:\n            powers.append(current_power)\n            current_power *= k\n        \n        count = {}\n        for value in a:\n            if value == 0:\n                continue\n            for power in reversed(powers):\n                while value >= power:\n                    value -= power\n                    count[power] = count.get(power, 0) + 1\n            if value > 0:\n                results.append(\"NO\")\n                break\n        else:\n            if all(count.get(power, 0) <= 1 for power in count):\n                results.append(\"YES\")\n            else:\n                results.append(\"NO\")\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nT = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(T):\n    n, k = map(int, data[index].split())\n    a = list(map(int, data[index + 1].split()))\n    test_cases.append((n, k, a))\n    index += 2\n\n# Get results\nresults = can_achieve_array(test_cases)\n\n# Print output\nfor result in results:\n    print(result)"}
{"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count\n\ndef calculate_sum(a, b, c):\n    total_sum = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                total_sum += count_divisors(i * j * k)\n                total_sum %= 1073741824\n    return total_sum\n\na, b, c = map(int, input().split())\nresult = calculate_sum(a, b, c)\nprint(result)"}
{"solution": "def can_reach_same_configuration(bessie, elsie):\n    def get_positions(grid):\n        return {grid[i][j]: (i, j) for i in range(2) for j in range(2) if grid[i][j] != 'X'}\n\n    bessie_positions = get_positions(bessie)\n    elsie_positions = get_positions(elsie)\n\n    return sorted(bessie_positions.items()) == sorted(elsie_positions.items())\n\nbessie = [input().strip() for _ in range(2)]\nelsie = [input().strip() for _ in range(2)]\n\nif can_reach_same_configuration(bessie, elsie):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def convert_to_decimal(n, k):\n    decimal_value = 0\n    length = len(k)\n    \n    for i in range(length):\n        digit = int(k[length - 1 - i])\n        decimal_value += digit * (n ** i)\n    \n    return decimal_value\n\nn = int(input().strip())\nk = input().strip()\n\nresult = convert_to_decimal(n, k)\nprint(result)"}
{"solution": "def is_unimodal(arr):\n    n = len(arr)\n    if n == 0:\n        return False\n\n    i = 0\n\n    # Increasing part\n    while i < n - 1 and arr[i] < arr[i + 1]:\n        i += 1\n\n    # Constant part\n    while i < n - 1 and arr[i] == arr[i + 1]:\n        i += 1\n\n    # Decreasing part\n    while i < n - 1 and arr[i] > arr[i + 1]:\n        i += 1\n\n    return i == n - 1\n\nn = int(input())\narr = list(map(int, input().split()))\n\nif is_unimodal(arr):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def max_y_in_k_paths(n, k):\n    # Function to count how many paths contain a specific value y\n    def count_paths_containing_y(y):\n        count = 0\n        # Start from y and go upwards to n\n        for x in range(y, n + 1):\n            current = x\n            while current >= y:\n                if current == y:\n                    count += 1\n                    break\n                if current % 2 == 0:\n                    current //= 2\n                else:\n                    current -= 1\n        return count\n\n    # Binary search for the maximum y\n    left, right = 1, n\n    answer = 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if count_paths_containing_y(mid) >= k:\n            answer = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return answer\n\n# Read input\nn, k = map(int, input().split())\n# Get the result\nresult = max_y_in_k_paths(n, k)\n# Print the result\nprint(result)"}
{"solution": "def billiard_pocket(n, m, x, y, v_x, v_y):\n    if v_x == 0 and v_y == 0:\n        return -1\n\n    # Calculate time to hit the walls\n    if v_x > 0:\n        time_to_x_wall = (n - x) / v_x\n    elif v_x < 0:\n        time_to_x_wall = x / -v_x\n    else:\n        time_to_x_wall = float('inf')\n\n    if v_y > 0:\n        time_to_y_wall = (m - y) / v_y\n    elif v_y < 0:\n        time_to_y_wall = y / -v_y\n    else:\n        time_to_y_wall = float('inf')\n\n    # Determine the time of the next collision\n    if time_to_x_wall < time_to_y_wall:\n        time = time_to_x_wall\n        x_final = n if v_x > 0 else 0\n        y_final = y + v_y * time\n    else:\n        time = time_to_y_wall\n        x_final = x + v_x * time\n        y_final = m if v_y > 0 else 0\n\n    # Check if the ball falls into a pocket\n    if x_final == 0 and y_final == 0:\n        return (0, 0)\n    elif x_final == n and y_final == 0:\n        return (n, 0)\n    elif x_final == 0 and y_final == m:\n        return (0, m)\n    elif x_final == n and y_final == m:\n        return (n, m)\n    else:\n        return -1\n\n# Read input\nn, m, x, y, v_x, v_y = map(int, input().split())\nresult = billiard_pocket(n, m, x, y, v_x, v_y)\n\n# Print output\nif result == -1:\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    # Check all combinations of orientations for the board and paintings\n    for (w1, h1) in [(a1, b1), (b1, a1)]:\n        for (w2, h2) in [(a2, b2), (b2, a2)]:\n            for (w3, h3) in [(a3, b3), (b3, a3)]:\n                # Check if both paintings can fit side by side\n                if (w2 + w3 <= w1 and max(h2, h3) <= h1) or (h2 + h3 <= h1 and max(w2, w3) <= w1):\n                    return \"YES\"\n                # Check if both paintings can fit one above the other\n                if (max(w2, w3) <= w1 and h2 + h3 <= h1) or (max(h2, h3) <= h1 and w2 + w3 <= w1):\n                    return \"YES\"\n    return \"NO\"\n\n# Read input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\n# Output the result\nprint(can_place_paintings(a1, b1, a2, b2, a3, b3))"}
{"solution": "def count_geometric_progression_terms(b1, q, l, m, bad_integers):\n    bad_set = set(bad_integers)\n    \n    if abs(b1) > l:\n        return 0\n    \n    if q == 0:\n        if b1 in bad_set:\n            return 0\n        else:\n            return 1 if abs(b1) <= l else 0\n    \n    if q == 1:\n        if b1 in bad_set:\n            return 0\n        else:\n            return \"inf\" if abs(b1) <= l else 0\n    \n    if q == -1:\n        if b1 in bad_set:\n            return 0\n        else:\n            return \"inf\" if abs(b1) <= l else 0\n    \n    count = 0\n    current = b1\n    \n    while abs(current) <= l:\n        if current not in bad_set:\n            count += 1\n        current *= q\n    \n    return count\n\n# Input reading\nb1, q, l, m = map(int, input().split())\nbad_integers = list(map(int, input().split()))\n\n# Output the result\nresult = count_geometric_progression_terms(b1, q, l, m, bad_integers)\nprint(result)"}
{"solution": "def find_frame(n, m, monitor):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n\n    # Find the bounding box of all 'w' pixels\n    for i in range(n):\n        for j in range(m):\n            if monitor[i][j] == 'w':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n\n    # If no 'w' pixels found, return -1\n    if max_row == -1:\n        return -1\n\n    # Check if we can form a frame around the bounding box\n    frame_possible = True\n    for i in range(min_row, max_row + 1):\n        for j in range(min_col, max_col + 1):\n            if monitor[i][j] == 'w':\n                continue\n            if (i == min_row or i == max_row or j == min_col or j == max_col):\n                continue\n            frame_possible = False\n\n    if not frame_possible:\n        return -1\n\n    # Create the output monitor with the frame\n    output_monitor = [list(row) for row in monitor]\n\n    # Draw the frame\n    for j in range(min_col, max_col + 1):\n        output_monitor[min_row][j] = '+'  # Top edge\n        output_monitor[max_row][j] = '+'  # Bottom edge\n\n    for i in range(min_row, max_row + 1):\n        output_monitor[i][min_col] = '+'  # Left edge\n        output_monitor[i][max_col] = '+'  # Right edge\n\n    # Ensure corners are '+' if they are not 'w'\n    output_monitor[min_row][min_col] = '+' if output_monitor[min_row][min_col] != 'w' else output_monitor[min_row][min_col]\n    output_monitor[min_row][max_col] = '+' if output_monitor[min_row][max_col] != 'w' else output_monitor[min_row][max_col]\n    output_monitor[max_row][min_col] = '+' if output_monitor[max_row][min_col] != 'w' else output_monitor[max_row][min_col]\n    output_monitor[max_row][max_col] = '+' if output_monitor[max_row][max_col] != 'w' else output_monitor[max_row][max_col]\n\n    return [''.join(row) for row in output_monitor]\n\n# Input reading\nn, m = map(int, input().split())\nmonitor = [input().strip() for _ in range(n)]\n\n# Finding the frame\nresult = find_frame(n, m, monitor)\n\n# Output result\nif result == -1:\n    print(-1)\nelse:\n    for line in result:\n        print(line)"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\n\nfound = False\nfor x in range(n // a + 1):\n    if (n - x * a) % b == 0:\n        y = (n - x * a) // b\n        print(\"YES\")\n        print(x, y)\n        found = True\n        break\n\nif not found:\n    print(\"NO\")"}
{"solution": "def number_to_words(s):\n    if s < 0 or s > 99:\n        return \"\"\n    \n    ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    \n    if s < 10:\n        return ones[s]\n    elif 10 <= s < 20:\n        return teens[s - 10]\n    else:\n        ten_part = tens[s // 10]\n        one_part = ones[s % 10]\n        return ten_part + ('' if one_part == '' else '-' + one_part)\n\ns = int(input().strip())\nprint(number_to_words(s))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmax_erase = 0\n\nfor i in range(n):\n    for j in range(i, n):\n        if i > 0 and j < n - 1:\n            if a[j + 1] - a[i - 1] <= j - i + 1:\n                max_erase = max(max_erase, j - i + 1)\n        elif i == 0 and j < n - 1:\n            if a[j + 1] - a[i] <= j - i + 1:\n                max_erase = max(max_erase, j - i + 1)\n        elif i > 0 and j == n - 1:\n            if a[j] - a[i - 1] <= j - i + 1:\n                max_erase = max(max_erase, j - i + 1)\n\nprint(max_erase)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ntotal_problems = sum(a)\nhalf_problems = total_problems / 2\n\nsolved_problems = 0\nfor i in range(n):\n    solved_problems += a[i]\n    if solved_problems >= half_problems:\n        print(i + 1)\n        break"}
{"solution": "from collections import deque\n\ndef knight_moves(x, y, N):\n    moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    return [(x + dx, y + dy) for dx, dy in moves if 0 <= x + dx < N and 0 <= y + dy < N]\n\ndef bishop_moves(x, y, N):\n    moves = []\n    for dx in range(-N, N):\n        for dy in range(-N, N):\n            if abs(dx) == abs(dy) and (dx != 0 or dy != 0):\n                if 0 <= x + dx < N and 0 <= y + dy < N:\n                    moves.append((x + dx, y + dy))\n    return moves\n\ndef rook_moves(x, y, N):\n    moves = []\n    for dx in range(-N + 1, N):\n        if dx != 0:\n            if 0 <= x + dx < N:\n                moves.append((x + dx, y))\n        for dy in range(-N + 1, N):\n            if dy != 0:\n                if 0 <= y + dy < N:\n                    moves.append((x, y + dy))\n    return moves\n\ndef bfs(N, board):\n    positions = {board[i][j]: (i, j) for i in range(N) for j in range(N)}\n    target = positions[1]\n    queue = deque([(target[0], target[1], 1, 0)])  # (x, y, current_number, replacements)\n    visited = set()\n    visited.add((target[0], target[1], 1))\n    \n    while queue:\n        x, y, current_number, replacements = queue.popleft()\n        \n        if current_number == N * N:\n            return (len(visited), replacements)\n        \n        next_number = current_number + 1\n        if next_number in positions:\n            next_x, next_y = positions[next_number]\n            for piece in range(3):  # 0: knight, 1: bishop, 2: rook\n                if piece == 0:  # Knight\n                    for nx, ny in knight_moves(x, y, N):\n                        if (nx, ny, next_number) not in visited:\n                            visited.add((nx, ny, next_number))\n                            queue.append((nx, ny, next_number, replacements))\n                elif piece == 1:  # Bishop\n                    for nx, ny in bishop_moves(x, y, N):\n                        if (nx, ny, next_number) not in visited:\n                            visited.add((nx, ny, next_number))\n                            queue.append((nx, ny, next_number, replacements))\n                elif piece == 2:  # Rook\n                    for nx, ny in rook_moves(x, y, N):\n                        if (nx, ny, next_number) not in visited:\n                            visited.add((nx, ny, next_number))\n                            queue.append((nx, ny, next_number, replacements))\n        \n        # Replace piece\n        for piece in range(3):\n            if (x, y, current_number) not in visited:\n                visited.add((x, y, current_number))\n                queue.append((x, y, current_number, replacements + 1))\n    \n    return (0, 0)\n\ndef main():\n    N = int(input().strip())\n    board = [list(map(int, input().strip().split())) for _ in range(N)]\n    steps, replacements = bfs(N, board)\n    print(steps, replacements)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_min_time(n, m, k, a, b):\n    def apartment_to_position(apartment):\n        # Calculate the entrance, floor, and position in the floor\n        entrance = (apartment - 1) // (m * k) + 1\n        floor = ((apartment - 1) % (m * k)) // k + 1\n        return entrance, floor\n\n    def time_to_floor(entrance, floor):\n        return (floor - 1) * 5\n\n    def time_to_move_between_entrances(start, end):\n        distance = abs(start - end)\n        return min(distance, n - distance) * 15\n\n    entrance_a, floor_a = apartment_to_position(a)\n    entrance_b, floor_b = apartment_to_position(b)\n\n    # Time using stairs\n    time_stairs = time_to_floor(entrance_a, floor_a) + time_to_move_between_entrances(entrance_a, entrance_b) + time_to_floor(entrance_b, floor_b)\n\n    # Time using elevator\n    time_elevator = 10 + (floor_a - 1) + time_to_move_between_entrances(entrance_a, entrance_b) + time_to_floor(entrance_b, floor_b)\n\n    return min(time_stairs, time_elevator)\n\n# Input reading\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_min_time(n, m, k, a, b))"}
{"solution": "def can_form_divisible_by_64(s):\n    # To be divisible by 64 in binary, the last 6 digits must be '000000'\n    # and there must be at least one '1' before these zeros.\n    \n    count_zeros = 0\n    found_one = False\n    \n    # Traverse the string from the end to the beginning\n    for char in reversed(s):\n        if char == '0':\n            count_zeros += 1\n        elif char == '1':\n            found_one = True\n            # We only need to find the first '1' before we have 6 zeros\n            if count_zeros >= 6:\n                print(\"yes\")\n                return\n    \n    print(\"no\")\n\n# Read input\ns = input().strip()\ncan_form_divisible_by_64(s)"}
{"solution": "def can_form_alphabet_subsequence(s):\n    target = \"abcdefghijklmnopqrstuvwxyz\"\n    target_index = 0\n    result = []\n\n    for char in s:\n        if target_index < len(target) and char <= target[target_index]:\n            result.append(target[target_index])\n            target_index += 1\n        else:\n            result.append(char)\n\n        if target_index == len(target):\n            break\n\n    if target_index < len(target):\n        return \"-1\"\n    \n    return ''.join(result)\n\ns = input().strip()\nprint(can_form_alphabet_subsequence(s))"}
{"solution": "def max_expected_fishes(n, m, r, k):\n    # Total number of positions the scoop can be placed\n    total_positions = (n - r + 1) * (m - r + 1)\n    \n    # If k is greater than the total positions, we can only catch fishes in those positions\n    if k >= total_positions:\n        return float(total_positions) * (r * r) / (n * m)\n    \n    # Calculate the maximum expected number of caught fishes\n    # The expected value is the number of fishes divided by the number of positions\n    expected_value = (k * (r * r)) / total_positions\n    \n    return expected_value\n\n# Read input\nn, m, r, k = map(int, input().split())\n\n# Calculate and print the result\nresult = max_expected_fishes(n, m, r, k)\nprint(f\"{result:.10f}\")"}
{"solution": "def maximize_product(n, a):\n    for i in range(n):\n        if a[i] < -1:\n            a[i] = -a[i] - 1\n        elif a[i] == -1:\n            a[i] = 0\n    return a\n\nn = int(input())\na = list(map(int, input().split()))\nresult = maximize_product(n, a)\nprint(' '.join(map(str, result)))"}
{"solution": "def kth_smallest_divisor(n, k):\n    divisors = []\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    \n    divisors.sort()\n    \n    if len(divisors) < k:\n        return -1\n    else:\n        return divisors[k - 1]\n\nn, k = map(int, input().split())\nprint(kth_smallest_divisor(n, k))"}
{"solution": "def can_form_number(cubes, number):\n    str_num = str(number)\n    if len(str_num) > len(cubes):\n        return False\n    \n    from itertools import permutations\n    \n    for perm in permutations(cubes, len(str_num)):\n        if all(int(digit) in perm[i] for i, digit in enumerate(str_num)):\n            return True\n    return False\n\ndef max_natural_x(n, cubes):\n    x = 1\n    while can_form_number(cubes, x):\n        x += 1\n    return x - 1\n\nn = int(input().strip())\ncubes = [list(map(int, input().strip().split())) for _ in range(n)]\n\nresult = max_natural_x(n, cubes)\nprint(result)"}
{"solution": "def k_rounding(n, k):\n    if k == 0:\n        return n\n    \n    # Calculate the factor to make the number end with k zeros\n    factor = 10 ** k\n    \n    # Find the smallest multiple of n that is also a multiple of factor\n    x = n\n    while x % factor != 0:\n        x += n\n    \n    return x\n\n# Read input\nn, k = map(int, input().split())\n# Calculate and print the k-rounding of n\nprint(k_rounding(n, k))"}
{"solution": "def can_transform(n, m, A):\n    operations = []\n    \n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                operations.append((i + 1, j + 1))  # Store 1-based index\n                # Simulate the operation on A\n                A[i][j] = A[i][j + 1] = A[i + 1][j] = A[i + 1][j + 1] = 0\n\n    # Check if A is now all zeros\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] == 1:\n                print(-1)\n                return\n\n    print(len(operations))\n    for op in operations:\n        print(op[0], op[1])\n\n# Read input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\ncan_transform(n, m, A)"}
{"solution": "def bad_luck_island(r, s, p):\n    total = r + s + p\n    if total == 0:\n        return (0.0, 0.0, 0.0)\n\n    # Probabilities of each species surviving\n    prob_r = r / total\n    prob_s = s / total\n    prob_p = p / total\n\n    # Normalize the probabilities\n    total_prob = prob_r + prob_s + prob_p\n    return (prob_r / total_prob, prob_s / total_prob, prob_p / total_prob)\n\n# Read input\nr, s, p = map(int, input().split())\nresult = bad_luck_island(r, s, p)\n\n# Print output\nprint(f\"{result[0]:.12f} {result[1]:.12f} {result[2]:.12f}\")"}
{"solution": "def calculate_minutes(l1, r1, l2, r2, k):\n    # Calculate the overlap between Sonya's awake time and Filya's visiting time\n    start = max(l1, l2)\n    end = min(r1, r2)\n    \n    if start > end:\n        return 0  # No overlap\n    \n    # Calculate the total minutes they can spend together\n    total_minutes = end - start + 1\n    \n    # Check if the prinking time k is within the overlapping time\n    if start <= k <= end:\n        total_minutes -= 1  # Subtract the minute when Sonya is unavailable\n    \n    return total_minutes\n\n# Read input\nl1, r1, l2, r2, k = map(int, input().split())\n# Calculate and print the result\nprint(calculate_minutes(l1, r1, l2, r2, k))"}
{"solution": "def cow_reach_area(N, M, vertical_lines, horizontal_lines):\n    from collections import defaultdict\n\n    # Create a set to store the boundaries\n    vertical_boundaries = []\n    horizontal_boundaries = []\n\n    # Collect vertical lines\n    for A, B, C in vertical_lines:\n        vertical_boundaries.append((A, C, 'L'))  # Left boundary\n        vertical_boundaries.append((B, C, 'R'))  # Right boundary\n\n    # Collect horizontal lines\n    for D, E, F in horizontal_lines:\n        horizontal_boundaries.append((E, D, 'B'))  # Bottom boundary\n        horizontal_boundaries.append((F, D, 'T'))  # Top boundary\n\n    # Sort boundaries\n    vertical_boundaries.sort()\n    horizontal_boundaries.sort()\n\n    # Check for infinite area\n    if not vertical_boundaries or not horizontal_boundaries:\n        return \"INF\"\n\n    # Determine the limits of the cow's movement\n    x_min = -float('inf')\n    x_max = float('inf')\n    y_min = -float('inf')\n    y_max = float('inf')\n\n    # Process vertical boundaries\n    for x, y, typ in vertical_boundaries:\n        if typ == 'L':\n            if x > x_min:\n                x_min = x\n        elif typ == 'R':\n            if x < x_max:\n                x_max = x\n\n    # Process horizontal boundaries\n    for y, x, typ in horizontal_boundaries:\n        if typ == 'B':\n            if y > y_min:\n                y_min = y\n        elif typ == 'T':\n            if y < y_max:\n                y_max = y\n\n    # Check if the area is infinite\n    if x_min == -float('inf') or x_max == float('inf') or y_min == -float('inf') or y_max == float('inf'):\n        return \"INF\"\n\n    # Calculate the area\n    area = (x_max - x_min) * (y_max - y_min)\n    return area\n\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN, M = map(int, data[0].split())\nvertical_lines = [tuple(map(int, line.split())) for line in data[1:N+1]]\nhorizontal_lines = [tuple(map(int, line.split())) for line in data[N+1:N+M+1]]\n\nresult = cow_reach_area(N, M, vertical_lines, horizontal_lines)\nprint(result)"}
{"solution": "t, s, x = map(int, input().split())\n\nif x == t:\n    print(\"YES\")\nelif x > t:\n    if (x - t) % s == 0 or (x - t - 1) % s == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    print(\"NO\")"}
{"solution": "def find_nested_segments(n, segments):\n    indexed_segments = [(l, r, i + 1) for i, (l, r) in enumerate(segments)]\n    indexed_segments.sort()  # Sort by left endpoint, then by right endpoint\n\n    max_right = -1\n    max_index = -1\n\n    for l, r, index in indexed_segments:\n        if r <= max_right:\n            return index, max_index\n        if r > max_right:\n            max_right = r\n            max_index = index\n\n    return -1, -1\n\n# Input reading\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Finding the result\ni, j = find_nested_segments(n, segments)\n\n# Output the result\nprint(i, j)"}
{"solution": "def decode_genome(n, s):\n    count_A = s.count('A')\n    count_C = s.count('C')\n    count_G = s.count('G')\n    count_T = s.count('T')\n    count_Q = s.count('?')\n\n    # Each nucleotide should appear n // 4 times\n    target_count = n // 4\n\n    # Calculate how many more of each nucleotide we need\n    need_A = max(0, target_count - count_A)\n    need_C = max(0, target_count - count_C)\n    need_G = max(0, target_count - count_G)\n    need_T = max(0, target_count - count_T)\n\n    # Total needed nucleotides should not exceed the number of '?'\n    if need_A + need_C + need_G + need_T > count_Q:\n        print(\"===\")\n        return\n\n    # Replace '?' with the needed nucleotides\n    result = list(s)\n    for i in range(n):\n        if result[i] == '?':\n            if need_A > 0:\n                result[i] = 'A'\n                need_A -= 1\n            elif need_C > 0:\n                result[i] = 'C'\n                need_C -= 1\n            elif need_G > 0:\n                result[i] = 'G'\n                need_G -= 1\n            elif need_T > 0:\n                result[i] = 'T'\n                need_T -= 1\n\n    # Final check to ensure all counts are equal\n    if (result.count('A') == target_count and\n        result.count('C') == target_count and\n        result.count('G') == target_count and\n        result.count('T') == target_count):\n        print(''.join(result))\n    else:\n        print(\"===\")\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\ndecode_genome(n, s)"}
{"solution": "def can_win(board):\n    # Check all possible winning positions\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                # Temporarily place 'x' in the empty cell\n                board[i][j] = 'x'\n                \n                # Check for a win\n                if (check_win(board, i, j)):\n                    return \"YES\"\n                \n                # Restore the cell\n                board[i][j] = '.'\n    return \"NO\"\n\ndef check_win(board, row, col):\n    # Check horizontal\n    if col <= 1 and board[row][col+1] == 'x' and board[row][col+2] == 'x':\n        return True\n    if col >= 2 and board[row][col-1] == 'x' and board[row][col-2] == 'x':\n        return True\n    if 0 < col < 3 and board[row][col-1] == 'x' and board[row][col+1] == 'x':\n        return True\n\n    # Check vertical\n    if row <= 1 and board[row+1][col] == 'x' and board[row+2][col] == 'x':\n        return True\n    if row >= 2 and board[row-1][col] == 'x' and board[row-2][col] == 'x':\n        return True\n    if 0 < row < 3 and board[row-1][col] == 'x' and board[row+1][col] == 'x':\n        return True\n\n    # Check diagonal (top-left to bottom-right)\n    if row <= 1 and col <= 1 and board[row+1][col+1] == 'x' and board[row+2][col+2] == 'x':\n        return True\n    if row >= 2 and col >= 2 and board[row-1][col-1] == 'x' and board[row-2][col-2] == 'x':\n        return True\n    if 0 < row < 3 and 0 < col < 3 and board[row-1][col-1] == 'x' and board[row+1][col+1] == 'x':\n        return True\n\n    # Check diagonal (top-right to bottom-left)\n    if row <= 1 and col >= 2 and board[row+1][col-1] == 'x' and board[row+2][col-2] == 'x':\n        return True\n    if row >= 2 and col <= 1 and board[row-1][col+1] == 'x' and board[row-2][col+2] == 'x':\n        return True\n    if 0 < row < 3 and 1 < col < 4 and board[row-1][col+1] == 'x' and board[row+1][col-1] == 'x':\n        return True\n\n    return False\n\n# Read input\nboard = [input().strip() for _ in range(4)]\nprint(can_win(board))"}
{"solution": "def can_divide_array(n, a):\n    total_sum = sum(a)\n    prefix_sum = 0\n    \n    for i in range(n):\n        prefix_sum += a[i]\n        suffix_sum = total_sum - prefix_sum\n        \n        if prefix_sum == suffix_sum:\n            return \"YES\"\n        \n        # Check if moving the current element can balance the sums\n        if i < n - 1:  # Ensure we don't check the last element\n            new_suffix_sum = suffix_sum + a[i]\n            new_prefix_sum = prefix_sum - a[i]\n            if new_prefix_sum == new_suffix_sum:\n                return \"YES\"\n    \n    return \"NO\"\n\nn = int(input())\na = list(map(int, input().split()))\nprint(can_divide_array(n, a))"}
{"solution": "def can_form_non_increasing_sequence(n, k, a, b):\n    # Replace zeros in a with elements from b\n    zero_indices = [i for i in range(n) if a[i] == 0]\n    \n    # Sort b in descending order to maximize the chance of creating a non-increasing sequence\n    b.sort(reverse=True)\n    \n    # Fill the zeros in a with elements from b\n    for idx, zero_index in enumerate(zero_indices):\n        a[zero_index] = b[idx]\n    \n    # Check if the resulting sequence is non-increasing\n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            return \"Yes\"\n    \n    return \"No\"\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_form_non_increasing_sequence(n, k, a, b)\nprint(result)"}
{"solution": "def can_distribute_grapes(x, y, z, a, b, c):\n    # Check if Andrew can get enough green grapes\n    if a < x:\n        return \"NO\"\n    \n    # Remaining green grapes after Andrew's share\n    remaining_green = a - x\n    \n    # Dmitry can take from remaining green and purple grapes\n    # Total grapes available for Dmitry\n    total_for_dmitry = remaining_green + b\n    \n    if total_for_dmitry < y:\n        return \"NO\"\n    \n    # Remaining grapes after Dmitry's share\n    remaining_for_michal = total_for_dmitry - y\n    \n    # Michal can take from remaining grapes (green, purple, black)\n    total_for_michal = remaining_for_michal + c\n    \n    if total_for_michal < z:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Get the result and print it\nresult = can_distribute_grapes(x, y, z, a, b, c)\nprint(result)"}
{"solution": "def is_accident_possible(traffic_lights):\n    for i in range(4):\n        l, s, r, p = traffic_lights[i]\n        \n        # Check if pedestrian light is green\n        if p == 1:\n            # Check if any car light is green in the same part\n            if l == 1 or s == 1 or r == 1:\n                return \"YES\"\n            \n            # Check if cars from adjacent parts can hit the pedestrian\n            if i == 0:  # Part 1\n                if s == 1 and traffic_lights[3][l] == 1:  # Part 4 left\n                    return \"YES\"\n                if r == 1 and traffic_lights[1][l] == 1:  # Part 2 left\n                    return \"YES\"\n            elif i == 1:  # Part 2\n                if s == 1 and traffic_lights[0][r] == 1:  # Part 1 right\n                    return \"YES\"\n                if l == 1 and traffic_lights[2][r] == 1:  # Part 3 right\n                    return \"YES\"\n            elif i == 2:  # Part 3\n                if s == 1 and traffic_lights[1][l] == 1:  # Part 2 left\n                    return \"YES\"\n                if r == 1 and traffic_lights[3][l] == 1:  # Part 4 left\n                    return \"YES\"\n            elif i == 3:  # Part 4\n                if s == 1 and traffic_lights[2][r] == 1:  # Part 3 right\n                    return \"YES\"\n                if l == 1 and traffic_lights[0][r] == 1:  # Part 1 right\n                    return \"YES\"\n    \n    return \"NO\"\n\n# Read input\ntraffic_lights = [list(map(int, input().split())) for _ in range(4)]\n# Check for possible accidents\nresult = is_accident_possible(traffic_lights)\n# Print the result\nprint(result)"}
{"solution": "def finger_movements(n, number):\n    # Define the positions of the keys on the keypad\n    positions = {\n        '0': (1, 3), '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2)\n    }\n    \n    # Calculate the movement vectors\n    movements = []\n    for i in range(1, n):\n        x1, y1 = positions[number[i - 1]]\n        x2, y2 = positions[number[i]]\n        movements.append((x2 - x1, y2 - y1))\n    \n    # Check for unique movements\n    unique_movements = set(movements)\n    \n    # If the number of unique movements is equal to the number of movements,\n    # it means there are no repeated movements, hence it can be unique\n    if len(unique_movements) == len(movements):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Input reading\nn = int(input().strip())\nnumber = input().strip()\n\n# Output the result\nprint(finger_movements(n, number))"}
{"solution": "def max_sold_products(n, f, days):\n    sales = []\n    \n    for k, l in days:\n        sales.append(min(k, l))\n    \n    if f == 0:\n        return sum(sales)\n    \n    additional_sales = []\n    \n    for i in range(n):\n        k, l = days[i]\n        if k > 0:\n            # Calculate the potential increase in sales if this day is chosen for sell-out\n            potential_sales = min(2 * k, l)\n            additional_sales.append(potential_sales - sales[i])\n        else:\n            additional_sales.append(0)\n    \n    # Sort the additional sales in descending order to pick the best f days\n    additional_sales.sort(reverse=True)\n    \n    # Calculate the maximum sales\n    max_sales = sum(sales) + sum(additional_sales[:f])\n    \n    return max_sales\n\n# Input reading\nn, f = map(int, input().split())\ndays = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_sold_products(n, f, days))"}
{"solution": "def max_messiness(n, k):\n    # The maximum number of pairs (i, j) such that i < j is n * (n - 1) // 2\n    max_pairs = n * (n - 1) // 2\n    \n    # The maximum messiness we can achieve is limited by the number of swaps we can make\n    # Each swap can increase the messiness by at most 1 pair\n    # However, we cannot exceed the total number of pairs\n    return min(max_pairs, k)\n\n# Read input\nn, k = map(int, input().split())\n# Calculate and print the result\nprint(max_messiness(n, k))"}
{"solution": "def minimum_coins(N, M, K, L):\n    # Check if it's possible to satisfy the conditions\n    if M > N:\n        return -1  # More friends than different coins\n    if L > (N - K):\n        return -1  # Not enough new coins possible\n    \n    # Calculate the minimum number of coins each friend can gift\n    # We need at least L new coins, and each friend must gift the same amount\n    # Let x be the number of coins each friend gifts\n    # Total coins gifted = M * x\n    # We need M * x >= L + (M * x - L) (which means total coins must be at least M)\n    \n    # Rearranging gives us:\n    # M * x >= L + M * x - M\n    # M * x >= L\n    # x >= L / M\n    # Since x must be an integer, we take the ceiling of L / M\n    min_coins_per_friend = (L + M - 1) // M  # This is equivalent to ceil(L / M)\n    \n    # Check if the total coins gifted will exceed the available different coins\n    if min_coins_per_friend * M > N:\n        return -1  # Not enough different coins available\n    \n    return min_coins_per_friend\n\n# Read input\nN, M, K, L = map(int, input().split())\n# Get the result\nresult = minimum_coins(N, M, K, L)\n# Print the result\nprint(result)"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    # Find the bounds of the black cells\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # If no black cells are found\n    if max_row == -1:\n        return 1  # Need to paint at least one cell black\n    \n    # Calculate the size of the square needed\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    \n    # Check if the square can fit within the grid\n    if min_row + side_length > n or min_col + side_length > m:\n        return -1\n    \n    # Count how many cells need to be painted\n    cells_to_paint = 0\n    for i in range(min_row, min_row + side_length):\n        for j in range(min_col, min_col + side_length):\n            if i < n and j < m and grid[i][j] == 'W':\n                cells_to_paint += 1\n    \n    return cells_to_paint\n\n# Input reading\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(min_cells_to_paint(n, m, grid))"}
{"solution": "def can_records_be_consistent(n, x, y):\n    total_x = sum(x)\n    total_y = sum(y)\n    \n    if total_y > total_x:\n        return \"No\"\n    \n    return \"Yes\"\n\nn = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\nresult = can_records_be_consistent(n, x, y)\nprint(result)"}
{"solution": "def minimal_difference(n, angles):\n    total_angle = sum(angles)\n    min_diff = total_angle  # Start with the maximum possible difference\n\n    # We will use a prefix sum to calculate the angles of continuous sectors\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + angles[i]\n\n    # Check all possible continuous sectors\n    for start in range(n):\n        for length in range(1, n + 1):  # Length of the sector\n            end = (start + length - 1) % n\n            if end >= start:\n                sector_angle = prefix_sum[end + 1] - prefix_sum[start]\n            else:\n                sector_angle = prefix_sum[n] - (prefix_sum[start] - prefix_sum[end + 1])\n\n            other_sector_angle = total_angle - sector_angle\n            min_diff = min(min_diff, abs(sector_angle - other_sector_angle))\n\n    return min_diff\n\n# Input reading\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Output the result\nprint(minimal_difference(n, angles))"}
{"solution": "def count_ways(n, m):\n    MOD = 10**9 + 7\n    # Calculate (2^m - 1)^n % MOD\n    ways_per_present = pow(2, m, MOD) - 1\n    total_ways = pow(ways_per_present, n, MOD)\n    return total_ways\n\n# Read input\nn, m = map(int, input().split())\n# Calculate and print the result\nprint(count_ways(n, m))"}
{"solution": "def find_pythagorean_triple(n):\n    if n <= 0:\n        return -1\n    \n    if n % 2 == 0:\n        m = (n // 2) ** 2 - 1\n        k = (n // 2) ** 2 + 1\n    else:\n        m = (n ** 2 - 1) // 2\n        k = (n ** 2 + 1) // 2\n    \n    if m > 0 and k > 0:\n        return m, k\n    else:\n        return -1\n\nn = int(input().strip())\nresult = find_pythagorean_triple(n)\n\nif result == -1:\n    print(-1)\nelse:\n    print(result[0], result[1])"}
{"solution": "def are_remainders_distinct(n, k):\n    if k > n:\n        return \"Yes\"\n    \n    remainders = set()\n    for i in range(1, k + 1):\n        remainder = n % i\n        if remainder in remainders:\n            return \"No\"\n        remainders.add(remainder)\n    \n    return \"Yes\"\n\nn, k = map(int, input().split())\nprint(are_remainders_distinct(n, k))"}
{"solution": "import sys\n\ndef compare_large_numbers():\n    a = sys.stdin.readline().strip()\n    b = sys.stdin.readline().strip()\n    \n    # Remove leading zeros\n    a = a.lstrip('0')\n    b = b.lstrip('0')\n    \n    # Compare lengths first\n    if len(a) < len(b):\n        print(\"<\")\n    elif len(a) > len(b):\n        print(\">\")\n    else:\n        # If lengths are equal, compare lexicographically\n        if a < b:\n            print(\"<\")\n        elif a > b:\n            print(\">\")\n        else:\n            print(\"=\")\n\ncompare_large_numbers()"}
{"solution": "def count_ways(n, p, colors):\n    MOD = 10**9 + 7\n\n    # Count fixed colors\n    count_black = colors.count(0)\n    count_white = colors.count(1)\n    count_unpainted = colors.count(-1)\n\n    # Total ways to color unpainted pieces\n    total_colorings = pow(2, count_unpainted, MOD)\n\n    # Dynamic programming to count paths\n    dp = [[0, 0] for _ in range(n + 1)]\n    dp[0][0] = 1  # 1 way to have an empty path with even count\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if colors[j] == -1 or colors[i - 1] == -1 or colors[j] != colors[i - 1]:\n                dp[i][0] = (dp[i][0] + dp[j][1]) % MOD\n                dp[i][1] = (dp[i][1] + dp[j][0]) % MOD\n\n    total_paths = sum(dp[i][0] + dp[i][1] for i in range(1, n + 1)) % MOD\n\n    # Count valid configurations with the desired parity\n    if p == 0:\n        return (total_colorings * (total_paths // 2)) % MOD\n    else:\n        return (total_colorings * ((total_paths + 1) // 2)) % MOD\n\n# Input reading\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Output the result\nprint(count_ways(n, p, colors))"}
{"solution": "def min_rubles(n, a, b, c):\n    remainder = n % 4\n    if remainder == 0:\n        return 0\n    \n    # Calculate the number of copybooks needed to make n + k divisible by 4\n    k_needed = 4 - remainder\n    \n    # Calculate the minimum cost for each possible k\n    min_cost = float('inf')\n    \n    # Check for k = 1\n    if k_needed >= 1:\n        min_cost = min(min_cost, a)\n    \n    # Check for k = 2\n    if k_needed >= 2:\n        min_cost = min(min_cost, b)\n    \n    # Check for k = 3\n    if k_needed >= 3:\n        min_cost = min(min_cost, c)\n    \n    return min_cost\n\n# Input reading\nn, a, b, c = map(int, input().split())\n# Output the result\nprint(min_rubles(n, a, b, c))"}
{"solution": "def can_make_acyclic(n, m, edges):\n    from collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n\n    for u, v in edges:\n        graph[u].append(v)\n        in_degree[v] += 1\n\n    def has_cycle():\n        queue = deque()\n        for i in range(1, n + 1):\n            if in_degree[i] == 0:\n                queue.append(i)\n\n        count = 0\n        while queue:\n            node = queue.popleft()\n            count += 1\n            for neighbor in graph[node]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return count != n\n\n    if not has_cycle():\n        return \"YES\"\n\n    for u, v in edges:\n        graph[u].remove(v)\n        in_degree[v] -= 1\n\n        if not has_cycle():\n            return \"YES\"\n\n        graph[u].append(v)\n        in_degree[v] += 1\n\n    return \"NO\"\n\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nprint(can_make_acyclic(n, m, edges))"}
{"solution": "def min_coins_to_cover(n, m, antennas):\n    # Create a list to track the coverage of positions from 1 to m\n    coverage = [0] * (m + 1)\n\n    # Fill the coverage based on the initial scopes of the antennas\n    for x, s in antennas:\n        left = max(1, x - s)\n        right = min(m, x + s)\n        for i in range(left, right + 1):\n            coverage[i] = 1\n\n    # Calculate the minimum coins needed to cover all positions from 1 to m\n    coins = 0\n    for i in range(1, m + 1):\n        if coverage[i] == 0:\n            # Find the nearest antenna to the left and right\n            left_distance = float('inf')\n            right_distance = float('inf')\n\n            for x, s in antennas:\n                if x < i:\n                    left_distance = min(left_distance, i - (x - s))\n                elif x > i:\n                    right_distance = min(right_distance, (x + s) - i)\n\n            # We need to increase the scope of the nearest antenna\n            if left_distance < right_distance:\n                # Increase the left antenna's scope\n                coins += left_distance\n            else:\n                # Increase the right antenna's scope\n                coins += right_distance\n\n            # Update the coverage for the position after increasing the scope\n            for x, s in antennas:\n                if x < i:\n                    new_left = x - (s + left_distance)\n                    new_right = x + (s + left_distance)\n                    if new_left <= i <= new_right:\n                        coverage[i] = 1\n                        break\n                elif x > i:\n                    new_left = x - (s + right_distance)\n                    new_right = x + (s + right_distance)\n                    if new_left <= i <= new_right:\n                        coverage[i] = 1\n                        break\n\n    return coins\n\n# Read input\nn, m = map(int, input().split())\nantennas = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = min_coins_to_cover(n, m, antennas)\nprint(result)"}
{"solution": "def max_good_subset_weight(W, counts):\n    total_weight = 0\n    \n    for weight in range(1, 9):\n        count = counts[weight - 1]\n        max_items = min(count, W // weight)\n        total_weight += max_items * weight\n        W -= max_items * weight\n        \n        if W <= 0:\n            break\n            \n    return total_weight\n\nW = int(input().strip())\ncounts = list(map(int, input().strip().split()))\nresult = max_good_subset_weight(W, counts)\nprint(result)"}
{"solution": "def min_cost_to_buy_lemonade(n, L, costs):\n    volumes = [(1 << i) - 1 for i in range(n)]  # Calculate volumes: 2^i - 1\n    dp = [float('inf')] * (L + 1)\n    dp[0] = 0  # Cost to buy 0 liters is 0\n\n    for i in range(n):\n        volume = volumes[i]\n        cost = costs[i]\n        for j in range(volume, L + 1):\n            dp[j] = min(dp[j], dp[j - volume] + cost)\n\n    # Find the minimum cost for at least L liters\n    return min(dp[L:])\n\n# Input reading\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Output the result\nprint(min_cost_to_buy_lemonade(n, L, costs))"}
{"solution": "def maximum_mex(n, a):\n    # Create a set to store unique values from the array\n    unique_values = set(a)\n    \n    # Initialize mex to 1\n    mex = 1\n    \n    # Increment mex until we find a value that is not in the unique values\n    while mex in unique_values:\n        mex += 1\n    \n    return mex\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result and print it\nresult = maximum_mex(n, a)\nprint(result)"}
{"solution": "def is_lucky_ticket(n, ticket):\n    digits = list(map(int, ticket))\n    total_sum = sum(digits)\n\n    for segment_sum in range(1, total_sum // 2 + 1):\n        current_sum = 0\n        count_segments = 0\n        \n        for digit in digits:\n            current_sum += digit\n            if current_sum == segment_sum:\n                count_segments += 1\n                current_sum = 0\n            elif current_sum > segment_sum:\n                break\n        \n        if count_segments >= 2 and current_sum == 0:\n            return \"YES\"\n    \n    return \"NO\"\n\nn = int(input().strip())\nticket = input().strip()\nprint(is_lucky_ticket(n, ticket))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\"\n\nusername = input().strip()\nprint(determine_gender(username))"}
{"solution": "def max_absolute_difference(n, k, tabs):\n    max_diff = 0\n    \n    for b in range(1, n + 1):\n        closed = set()\n        \n        # Close tabs based on the chosen b\n        for i in range(-n, n + 1):\n            c = b + i * k\n            if 1 <= c <= n:\n                closed.add(c)\n        \n        # Count remaining tabs\n        e = sum(1 for i in range(1, n + 1) if i not in closed and tabs[i - 1] == 1)\n        s = sum(1 for i in range(1, n + 1) if i not in closed and tabs[i - 1] == -1)\n        \n        max_diff = max(max_diff, abs(e - s))\n    \n    return max_diff\n\n# Input reading\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Output the result\nprint(max_absolute_difference(n, k, tabs))"}
{"solution": "def minimum_cost(n, c0, c1):\n    # Calculate the number of bits needed\n    length = 0\n    total_codes = 1\n    while total_codes < n:\n        length += 1\n        total_codes *= 2\n\n    # Calculate the number of '0's and '1's used\n    num_zeros = 0\n    num_ones = 0\n\n    # For each level of the binary tree, count the number of '0's and '1's\n    for i in range(length):\n        if i < length - 1:\n            num_zeros += (1 << i)  # 2^i\n            num_ones += (1 << i)   # 2^i\n        else:\n            # Last level, we only need to account for the remaining codes\n            remaining_codes = n - (1 << (length - 1))\n            num_zeros += remaining_codes // 2\n            num_ones += remaining_codes - (remaining_codes // 2)\n\n    # Calculate the total cost\n    total_cost = num_zeros * c0 + num_ones * c1\n    return total_cost\n\n# Read input\nn, c0, c1 = map(int, input().split())\n# Output the result\nprint(minimum_cost(n, c0, c1))"}
{"solution": "n, a, x, b, y = map(int, input().split())\n\nwhile a != x and b != y:\n    if a == b:\n        print(\"YES\")\n        break\n    a = a + 1 if a < n else 1\n    b = b - 1 if b > 1 else n\nelse:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "def find_unlucky_years(x, y, l, r):\n    unlucky_years = set()\n    \n    # Generate all powers of x and y within the range\n    a = 0\n    while True:\n        power_x = x ** a\n        if power_x > r:\n            break\n        b = 0\n        while True:\n            power_y = y ** b\n            if power_x + power_y > r:\n                break\n            if power_x + power_y >= l:\n                unlucky_years.add(power_x + power_y)\n            b += 1\n        a += 1\n    \n    return unlucky_years\n\ndef max_golden_age_length(x, y, l, r):\n    unlucky_years = find_unlucky_years(x, y, l, r)\n    \n    if not unlucky_years:\n        return r - l + 1\n    \n    max_length = 0\n    current_start = l\n    \n    for year in sorted(unlucky_years):\n        if year < l:\n            continue\n        if year > r:\n            break\n        if year > current_start:\n            max_length = max(max_length, year - current_start)\n        current_start = year + 1\n    \n    if current_start <= r:\n        max_length = max(max_length, r - current_start + 1)\n    \n    return max_length\n\n# Input reading\nx, y, l, r = map(int, input().split())\n# Output the result\nprint(max_golden_age_length(x, y, l, r))"}
{"solution": "def max_divisor(n):\n    for i in range(int(n**0.5), 1, -1):\n        if n % i == 0:\n            return n // i\n    return 1\n\ndef min_tax(n):\n    if n % 2 == 0:\n        return n // 2\n    else:\n        return max_divisor(n)\n\nn = int(input())\nprint(min_tax(n))"}
{"solution": "def is_consonant(c):\n    return c not in 'aeiou'\n\ndef has_typo(word):\n    count = 0\n    last_char = ''\n    for char in word:\n        if is_consonant(char):\n            if char == last_char:\n                count += 1\n            else:\n                count = 1\n            last_char = char\n            if count >= 3:\n                return True\n        else:\n            last_char = ''\n            count = 0\n    return False\n\ndef fix_typos(word):\n    result = []\n    count = 0\n    last_char = ''\n    \n    for char in word:\n        if is_consonant(char):\n            if char == last_char:\n                count += 1\n            else:\n                count = 1\n            last_char = char\n        else:\n            last_char = ''\n            count = 0\n        \n        result.append(char)\n        \n        if count == 3 and is_consonant(char):\n            result.pop()  # Remove the last character\n            result.append(' ')  # Add a space\n            result.append(char)  # Add the character again\n            count = 1  # Reset count for the new segment\n    \n    return ''.join(result)\n\nword = input().strip()\nif has_typo(word):\n    print(fix_typos(word))\nelse:\n    print(word)"}
{"solution": "def min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d):\n    # Initialize the minimum time to prepare potions without any spells\n    min_time = n * x\n    \n    # Check all combinations of spells of the first and second type\n    for i in range(m):\n        if b[i] <= s:  # Check if we can afford the first type spell\n            potion_time = a[i]\n            remaining_mana = s - b[i]\n            potions_made = 0\n            \n            # Check how many potions we can make with the remaining mana using the second type spells\n            for j in range(k):\n                if d[j] <= remaining_mana:\n                    potions_made = c[j]\n                else:\n                    break\n            \n            # Calculate remaining potions to be made\n            remaining_potions = max(0, n - potions_made)\n            total_time = remaining_potions * potion_time\n            \n            # Update the minimum time\n            min_time = min(min_time, total_time)\n    \n    # Check only the second type spells without the first type spell\n    for j in range(k):\n        if d[j] <= s:\n            potions_made = c[j]\n            remaining_potions = max(0, n - potions_made)\n            total_time = remaining_potions * x\n            \n            # Update the minimum time\n            min_time = min(min_time, total_time)\n    \n    return min_time\n\n# Input reading\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d)\nprint(result)"}
{"solution": "def max_points(n, k, M, t):\n    total_points = 0\n    \n    # Calculate the total time to complete all subtasks of a task\n    total_time_per_task = sum(t)\n    \n    # Try to complete as many tasks as possible\n    for completed_tasks in range(n + 1):\n        time_spent = completed_tasks * total_time_per_task\n        if time_spent > M:\n            break\n        \n        points = completed_tasks * (k + 1)  # Points for completed tasks\n        \n        remaining_time = M - time_spent\n        \n        # Calculate how many additional subtasks can be solved\n        additional_points = 0\n        for j in range(k):\n            if remaining_time <= 0:\n                break\n            max_subtasks = remaining_time // t[j]\n            if max_subtasks > n - completed_tasks:\n                max_subtasks = n - completed_tasks\n            additional_points += max_subtasks\n            remaining_time -= max_subtasks * t[j]\n        \n        total_points = max(total_points, points + additional_points)\n    \n    return total_points\n\n# Input reading\nn, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Output the result\nprint(max_points(n, k, M, t))"}
{"solution": "def mod_inv(a, p):\n    return pow(a, p - 2, p)\n\ndef count_perfectly_balanced_striped_bst(n):\n    MOD = 998244353\n    \n    if n % 2 == 1:\n        return 0\n    \n    half_n = n // 2\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    inv_fact_half_n = mod_inv(fact[half_n], MOD)\n    inv_fact_half_n_1 = mod_inv(fact[half_n - 1], MOD)\n    \n    result = (fact[n] * inv_fact_half_n % MOD) * inv_fact_half_n_1 % MOD\n    return result\n\nn = int(input().strip())\nprint(count_perfectly_balanced_striped_bst(n))"}
{"solution": "def lara_position(n, m, k):\n    if k < m:\n        return (1, k + 1)\n    \n    k -= m\n    full_snake_moves = k // (m - 1)\n    position_in_snake = k % (m - 1)\n\n    row = 2 + full_snake_moves * 2\n    if full_snake_moves % 2 == 0:\n        col = position_in_snake + 1\n    else:\n        col = m - position_in_snake\n\n    if row > n:\n        row = n - (row - n)\n        col = m - position_in_snake if (full_snake_moves % 2 == 0) else position_in_snake + 1\n\n    return (row, col)\n\nn, m, k = map(int, input().split())\nresult = lara_position(n, m, k)\nprint(result[0], result[1])"}
{"solution": "import math\n\ndef find_min_max_lcm_pair(X):\n    min_max_value = float('inf')\n    best_a, best_b = 1, X\n    \n    for a in range(1, int(math.sqrt(X)) + 1):\n        if X % a == 0:\n            b = X // a\n            max_ab = max(a, b)\n            if max_ab < min_max_value:\n                min_max_value = max_ab\n                best_a, best_b = a, b\n                \n    return best_a, best_b\n\nX = int(input().strip())\na, b = find_min_max_lcm_pair(X)\nprint(a, b)"}
{"solution": "a = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate the maximum number of complete sets of fruits we can use\nmax_sets = min(a, b // 2, c // 4)\n\n# Calculate the total number of fruits used\ntotal_fruits = max_sets * (1 + 2 + 4)\n\nprint(total_fruits)"}
{"solution": "def can_divide_teams(n, ratings):\n    ratings.sort()\n    team1 = ratings[:n]\n    team2 = ratings[n:]\n    \n    for i in range(n):\n        if team1[i] >= team2[i]:\n            return \"NO\"\n    return \"YES\"\n\nn = int(input())\nratings = list(map(int, input().split()))\nprint(can_divide_teams(n, ratings))"}
{"solution": "from math import gcd\nfrom sys import stdin, stdout\n\ndef make_coprime_array(n, a):\n    result = []\n    count = 0\n    \n    result.append(a[0])\n    \n    for i in range(1, n):\n        if gcd(result[-1], a[i]) != 1:\n            count += 1\n            # Insert a number that is co-prime with both adjacent numbers\n            # We can use 1, since 1 is co-prime with any number\n            result.append(1)\n        \n        result.append(a[i])\n    \n    return count, result\n\ndef main():\n    input = stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:n+1]))\n    \n    k, new_array = make_coprime_array(n, a)\n    \n    stdout.write(f\"{k}\\n\")\n    stdout.write(\" \".join(map(str, new_array)) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_divisor_after_operations(N, K, A):\n    total_sum = sum(A)\n    min_A = min(A)\n    \n    # The maximum possible divisor we can achieve is limited by the total sum and the minimum element\n    max_possible_divisor = (total_sum + K) // N\n    \n    # We need to find the maximum divisor that is less than or equal to min_A + K\n    # because we can only increase the minimum element by K at most\n    max_divisor = min(min_A + K, max_possible_divisor)\n    \n    # We will check for the largest divisor from max_divisor down to 1\n    for d in range(max_divisor, 0, -1):\n        if all((a % d) == 0 for a in A):\n            return d\n    \n    return 1  # In the worst case, the answer is at least 1\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\nresult = max_divisor_after_operations(N, K, A)\nprint(result)"}
{"solution": "def perfect_longcat_transform(x):\n    # Check if x is already a perfect longcat\n    def is_perfect_longcat(num):\n        return (num & (num + 1)) == 0\n\n    if is_perfect_longcat(x):\n        print(0)\n        return\n\n    operations = []\n    \n    # Perform operations until we reach a perfect longcat\n    while not is_perfect_longcat(x) and len(operations) < 40:\n        # Find the position of the rightmost 0 in x\n        n = 0\n        while (1 << n) <= x:\n            n += 1\n        # n is now the position of the first 0 bit in x (0-indexed)\n        # We need to XOR with (2^n - 1) to flip all bits below the first 0\n        operations.append(n)\n        x ^= (1 << n) - 1  # Operation A: x = x XOR (2^n - 1)\n        \n        if is_perfect_longcat(x):\n            break\n        \n        x += 1  # Operation B: x = x + 1\n\n    print(len(operations))\n    if operations:\n        print(\" \".join(map(str, operations)))\n\n# Read input\nx = int(input().strip())\nperfect_longcat_transform(x)"}
{"solution": "def min_hours_to_water_garden(n, k, a):\n    min_hours = float('inf')\n    for length in a:\n        if k % length == 0:\n            hours = k // length\n            min_hours = min(min_hours, hours)\n    return min_hours\n\n# Input reading\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_hours_to_water_garden(n, k, a))"}
{"solution": "n, k = map(int, input().split())\nline = input().strip()\n\ng_index = line.index('G')\nt_index = line.index('T')\n\nif g_index < t_index:\n    step = k\nelse:\n    step = -k\n\nfor i in range(g_index, t_index + step, step):\n    if line[i] == '#':\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")"}
{"solution": "def find_aim_point(y1, y2, yw, xb, yb, r):\n    # Calculate the effective y-coordinates for the ball's center\n    yb_effective = yb + r\n    yb_effective_top = yb - r\n\n    # Check if the ball can hit the wall and then go into the goal\n    if yb_effective >= yw or yb_effective_top <= 0:\n        return -1\n\n    # Calculate the potential y-coordinates for the ball to hit the wall\n    y_hit_wall = (y1 + y2) / 2  # Midpoint of the goalposts\n\n    # Calculate the x-coordinate of the aiming point on the wall\n    xw = (yw - yb) * (xb / (yw - y_hit_wall)) + xb\n\n    # Check if the ball will go into the goal after bouncing\n    if y1 <= y_hit_wall <= y2:\n        return xw\n    else:\n        return -1\n\n# Read input\ny1, y2, yw, xb, yb, r = map(int, input().split())\n\n# Get the result\nresult = find_aim_point(y1, y2, yw, xb, yb, r)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    print(f\"{result:.10f}\")"}
{"solution": "def min_missed_meals(b, d, s):\n    # Calculate the maximum number of full days based on the meals\n    max_days = max(b, d, s)\n    \n    # Calculate the total meals that should have been had in those days\n    total_meals = max_days * 3\n    \n    # Calculate the total meals actually had\n    actual_meals = b + d + s\n    \n    # The missed meals are the difference\n    missed_meals = total_meals - actual_meals\n    \n    return missed_meals\n\n# Read input\nb, d, s = map(int, input().split())\n\n# Get the result\nresult = min_missed_meals(b, d, s)\n\n# Print the result\nprint(result)"}
{"solution": "def find_matrix_dimensions(n, path):\n    # Create a dictionary to store the positions of each number\n    position = {}\n    \n    for idx in range(n):\n        position[path[idx]] = idx\n    \n    # Determine the minimum and maximum row and column indices\n    min_row = float('inf')\n    max_row = float('-inf')\n    min_col = float('inf')\n    max_col = float('-inf')\n    \n    for num in path:\n        # Calculate the row and column based on the formula\n        row = (num - 1) // max_col + 1\n        col = (num - 1) % max_col + 1\n        \n        min_row = min(min_row, row)\n        max_row = max(max_row, row)\n        min_col = min(min_col, col)\n        max_col = max(max_col, col)\n    \n    # Calculate the dimensions of the matrix\n    x = max_row\n    y = max_col\n    \n    # Check if the path is valid\n    for i in range(1, n):\n        num1 = path[i - 1]\n        num2 = path[i]\n        \n        row1 = (num1 - 1) // y + 1\n        col1 = (num1 - 1) % y + 1\n        row2 = (num2 - 1) // y + 1\n        col2 = (num2 - 1) % y + 1\n        \n        if not ((abs(row1 - row2) == 1 and col1 == col2) or (abs(col1 - col2) == 1 and row1 == row2)):\n            return \"NO\"\n    \n    return \"YES\\n{} {}\".format(x, y)\n\n# Input reading\nn = int(input().strip())\npath = list(map(int, input().strip().split()))\n\n# Output the result\nprint(find_matrix_dimensions(n, path))"}
{"solution": "def longest_subsequence(a, b):\n    n, m = len(a), len(b)\n    \n    # Create a table to store the longest subsequence lengths\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n    \n    # Find the length of the longest subsequence\n    length = dp[n][m]\n    \n    # If there's no common subsequence\n    if length == 0:\n        return \"-\"\n    \n    # Reconstruct the longest subsequence\n    subsequence = []\n    i, j = n, m\n    while i > 0 and j > 0:\n        if a[i - 1] == b[j - 1]:\n            subsequence.append(a[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i][j - 1] >= dp[i - 1][j]:\n            j -= 1\n        else:\n            i -= 1\n    \n    # The subsequence is constructed in reverse order\n    subsequence.reverse()\n    \n    return ''.join(subsequence)\n\n# Read input\na = input().strip()\nb = input().strip()\n\n# Get the result and print it\nresult = longest_subsequence(a, b)\nprint(result)"}
{"solution": "n = int(input())\ns = input().strip()\n\nplus_count = s.count('+')\nminus_count = s.count('-')\n\n# The minimum number of stones needed to ensure all '-' operations can be performed\nmin_stones_needed = max(0, minus_count)\n\n# The final number of stones after all operations\nfinal_stones = min_stones_needed + plus_count\n\nprint(final_stones)"}
{"solution": "def max_kefir_liters(n, a, b, c):\n    # Calculate the maximum liters of kefir Kolya can drink\n    max_liters = 0\n    \n    # Option 1: Buy only plastic bottles\n    max_liters = n // a\n    \n    # Option 2: Buy glass bottles and return them\n    if b <= n:\n        # Calculate how many glass bottles can be bought initially\n        glass_bottles = n // b\n        remaining_money = n % b\n        \n        # Total liters from glass bottles\n        total_liters = glass_bottles\n        \n        # Money after returning glass bottles\n        money_after_return = glass_bottles * c + remaining_money\n        \n        # Buy more plastic bottles with the remaining money\n        total_liters += money_after_return // a\n        \n        # Update max_liters if this option is better\n        max_liters = max(max_liters, total_liters)\n    \n    return max_liters\n\n# Input reading\nn = int(input().strip())\na = int(input().strip())\nb = int(input().strip())\nc = int(input().strip())\n\n# Output the result\nprint(max_kefir_liters(n, a, b, c))"}
{"solution": "from collections import deque\n\ndef card_war(n, soldier1_cards, soldier2_cards):\n    soldier1 = deque(soldier1_cards)\n    soldier2 = deque(soldier2_cards)\n    seen_states = set()\n    fights = 0\n\n    while soldier1 and soldier2:\n        fights += 1\n        state = (tuple(soldier1), tuple(soldier2))\n        \n        if state in seen_states:\n            return -1\n        seen_states.add(state)\n\n        card1 = soldier1.popleft()\n        card2 = soldier2.popleft()\n\n        if card1 > card2:\n            soldier1.append(card2)\n            soldier1.append(card1)\n        else:\n            soldier2.append(card1)\n            soldier2.append(card2)\n\n    winner = 1 if soldier1 else 2\n    return fights, winner\n\n# Input reading\nn = int(input().strip())\nk1_data = list(map(int, input().strip().split()))\nk1 = k1_data[0]\nsoldier1_cards = k1_data[1:]\n\nk2_data = list(map(int, input().strip().split()))\nk2 = k2_data[0]\nsoldier2_cards = k2_data[1:]\n\n# Function call and output\nresult = card_war(n, soldier1_cards, soldier2_cards)\nprint(result if result == -1 else f\"{result[0]} {result[1]}\")"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    \n    has_upper = any(c.isupper() for c in password)\n    has_lower = any(c.islower() for c in password)\n    has_digit = any(c.isdigit() for c in password)\n    \n    if has_upper and has_lower and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\"\n\npassword = input().strip()\nprint(check_password_complexity(password))"}
{"solution": "def min_exchanges(n, group_a, group_b):\n    count_a = [0] * 6\n    count_b = [0] * 6\n\n    for score in group_a:\n        count_a[score] += 1\n    for score in group_b:\n        count_b[score] += 1\n\n    total_exchanges = 0\n    for i in range(1, 6):\n        if (count_a[i] + count_b[i]) % 2 != 0:\n            return -1\n        target = (count_a[i] + count_b[i]) // 2\n        excess_a = max(0, count_a[i] - target)\n        excess_b = max(0, count_b[i] - target)\n        total_exchanges += max(excess_a, excess_b)\n\n    return total_exchanges // 2\n\nn = int(input())\ngroup_a = list(map(int, input().split()))\ngroup_b = list(map(int, input().split()))\n\nresult = min_exchanges(n, group_a, group_b)\nprint(result)"}
{"solution": "def can_reach_all_junctions(n, m, horizontal, vertical):\n    # Create a grid to represent the junctions\n    grid = [[False] * m for _ in range(n)]\n    \n    # Mark reachable junctions based on horizontal street directions\n    for i in range(n):\n        if horizontal[i] == '>':\n            for j in range(m):\n                grid[i][j] = True\n        elif horizontal[i] == '<':\n            for j in range(m-1, -1, -1):\n                grid[i][j] = True\n\n    # Mark reachable junctions based on vertical street directions\n    for j in range(m):\n        if vertical[j] == 'v':\n            for i in range(n):\n                grid[i][j] = True\n        elif vertical[j] == '^':\n            for i in range(n-1, -1, -1):\n                grid[i][j] = True\n\n    # Check if all junctions are reachable\n    for i in range(n):\n        for j in range(m):\n            if not grid[i][j]:\n                return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nhorizontal = input().strip()\nvertical = input().strip()\n\n# Get the result and print it\nresult = can_reach_all_junctions(n, m, horizontal, vertical)\nprint(result)"}
{"solution": "def can_place_brackets(n, a):\n    if n == 1:\n        if a[0] == 0:\n            return \"YES\\n0\"\n        else:\n            return \"NO\"\n    \n    if a.count(1) == n:\n        return \"NO\"\n    \n    # We can create a false expression by using the last 1 and the first 0\n    # Example: (0 -> (1 -> 1)) -> 0\n    # We can also use the first 0 and any 1 to create a false expression\n    expression = []\n    \n    # Find the first 0\n    first_zero_index = a.index(0)\n    \n    # Build the expression\n    for i in range(first_zero_index):\n        expression.append(str(a[i]))\n        expression.append(\"->\")\n    \n    expression.append(str(a[first_zero_index]))\n    \n    for i in range(first_zero_index + 1, n):\n        expression.append(\"->\")\n        expression.append(str(a[i]))\n    \n    # Now we need to wrap the first part in brackets\n    result = \"(\" + \"\".join(expression) + \")\"\n    \n    return f\"YES\\n{result}\"\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Get the result\nresult = can_place_brackets(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def process_values(n, m):\n    while n > 0 and m > 0:\n        if n >= 2 * m:\n            n %= 2 * m\n        elif m >= 2 * n:\n            m %= 2 * n\n        else:\n            break\n    return n, m\n\nn, m = map(int, input().split())\nresult = process_values(n, m)\nprint(result[0], result[1])"}
{"solution": "k, a, b = map(int, input().split())\n\ndef count_k_divisible(k, a, b):\n    if a % k == 0:\n        start = a // k\n    else:\n        start = (a // k) + 1\n    \n    end = b // k\n    \n    return end - start + 1\n\nresult = count_k_divisible(k, a, b)\nprint(result)"}
{"solution": "k = int(input())\n\n# Initialize variables\nlength = 1  # Current length of numbers (1 for 1-9, 2 for 10-99, etc.)\ncount = 9   # Count of numbers with the current length\nstart = 1   # Starting number with the current length\n\n# Find the range where the k-th digit lies\nwhile k > length * count:\n    k -= length * count\n    length += 1\n    count *= 10\n    start *= 10\n\n# Find the actual number that contains the k-th digit\nnumber = start + (k - 1) // length\ndigit_index = (k - 1) % length\n\n# Print the k-th digit\nprint(str(number)[digit_index])"}
{"solution": "n = int(input().strip())\ns = input().strip()\n\n# Count the number of '8's in the string\ncount_8 = s.count('8')\n\n# Calculate the maximum number of moves Vasya can make\n# Vasya needs to ensure that there are at least 11 digits left\n# After Vasya's turn, there will be (n - 1) digits left\n# Petya will also make (n - 1) // 2 moves, so Vasya will have (n - 1) // 2 + 1 moves\n# Thus, Vasya can remove (n - 11) // 2 digits\nmax_removals = (n - 11) // 2\n\n# Vasya can win if there are at least 11 digits left and at least 1 '8' in those digits\nif count_8 > max_removals:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def factorial_mod(n, mod):\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    return fact\n\ndef count_valid_permutations(n, x, pos):\n    mod = 10**9 + 7\n    fact = factorial_mod(n, mod)\n\n    # Count numbers less than x and greater than x\n    less_count = x - 1\n    greater_count = n - x\n\n    # Determine the number of valid positions for numbers less than x\n    left_space = pos\n    right_space = n - pos - 1\n\n    # The number of valid permutations is determined by how we can arrange\n    # the numbers less than x and greater than x around the position of x\n    valid_permutations = 0\n\n    for l in range(max(0, less_count - right_space), min(less_count, left_space) + 1):\n        r = less_count - l\n        if r < 0 or r > right_space:\n            continue\n        # Calculate the number of ways to arrange the less than x and greater than x\n        valid_permutations += (fact[less_count] * fact[greater_count]) % mod\n        valid_permutations %= mod\n\n    return valid_permutations\n\nn, x, pos = map(int, input().split())\nresult = count_valid_permutations(n, x, pos)\nprint(result)"}
{"solution": "def decode_message(encoded_string, k):\n    result = []\n    i = 0\n    n = len(encoded_string)\n\n    while i < n:\n        char = encoded_string[i]\n        result.append(char)\n        \n        if i + 1 < n:\n            if encoded_string[i + 1] == '?':\n                # Candy cane: can remove or keep the last character\n                result.append(char)  # Keep the character\n            elif encoded_string[i + 1] == '*':\n                # Snowflake: can remove, keep, or repeat the last character\n                result.append(char)  # Keep the character\n                result.append(char)  # Repeat the character\n            i += 1  # Move past the special character\n        i += 1  # Move to the next character\n\n    # Now we have a list of characters that can be used to form the message\n    # We need to check if we can form a message of length k\n    if len(result) < k:\n        print(\"Impossible\")\n        return\n\n    # We can form a message of length k\n    message = []\n    count = 0\n\n    for char in result:\n        if count < k:\n            message.append(char)\n            count += 1\n        if count == k:\n            break\n\n    # If we have exactly k characters, we can print the message\n    if len(message) == k:\n        print(''.join(message))\n    else:\n        print(\"Impossible\")\n\n# Read input\nencoded_string = input().strip()\nk = int(input().strip())\n\n# Call the function\ndecode_message(encoded_string, k)"}
{"solution": "def min_rotations(x):\n    # Normalize the angle to be within [0, 360)\n    x = x % 360\n    if x < 0:\n        x += 360\n    \n    # Calculate the minimum deviation for 0, 90, 180, and 270 degrees\n    deviations = [(x - angle) % 360 for angle in [0, 90, 180, 270]]\n    \n    # Find the minimum deviation and its corresponding number of 90-degree turns\n    min_deviation = min(deviations)\n    min_turns = deviations.index(min_deviation)\n    \n    return min_turns\n\n# Read input\nx = int(input().strip())\n# Output the result\nprint(min_rotations(x))"}
{"solution": "def can_obtain_spheres(a, b, c, x, y, z):\n    # Calculate the surplus spheres\n    surplus_blue = a - x\n    surplus_violet = b - y\n    surplus_orange = c - z\n    \n    # If any required spheres are more than available, return \"No\"\n    if surplus_blue < 0 or surplus_violet < 0 or surplus_orange < 0:\n        return \"No\"\n    \n    # Calculate total surplus spheres\n    total_surplus = surplus_blue + surplus_violet + surplus_orange\n    \n    # Calculate total needed transformations\n    needed_transformations = (max(0, x - a) + max(0, y - b) + max(0, z - c)) // 2\n    \n    # Check if we can perform enough transformations\n    if total_surplus >= needed_transformations:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Input reading\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Output the result\nprint(can_obtain_spheres(a, b, c, x, y, z))"}
{"solution": "def count_valid_numbers(n, k, m):\n    # Count how many integers y > 0 exist such that y % k == 0\n    count_y = 0\n    for i in range(1, 10 * k):  # Check multiples of k\n        if i % k == 0:\n            count_y += 1\n\n    # Total numbers with n digits\n    total_numbers = 9 * (10 ** (n - 1))\n\n    # Calculate the result\n    result = (total_numbers * count_y) % m\n    return result\n\n# Read input\nn, k, m = map(int, input().split())\n# Get the result\nresult = count_valid_numbers(n, k, m)\n# Print the result\nprint(result)"}
{"solution": "l, r, a = map(int, input().split())\n\n# Balance the left and right players using ambidexters\nif l > r:\n    l, r = r, l  # Ensure l is always the smaller or equal to r\n\n# Use ambidexters to balance the teams\nneeded = (r - l) // 2\nif a <= needed:\n    l += a\n    a = 0\nelse:\n    l += needed\n    a -= needed\n    r += a // 2\n    l += a // 2\n\n# The maximum team size is twice the number of players on one side\nmax_team_size = (l + r) * 2\nprint(max_team_size)"}
{"solution": "def minimum_moves(n, k):\n    # Calculate the total moves required\n    total_moves = 0\n    \n    # Moves to throw stones from each manhole\n    total_moves += (n - 1) * 2  # Each manhole needs to throw its stone to another manhole\n    \n    # Moves to open each manhole\n    total_moves += n  # Opening each manhole\n    \n    # Moves to go to each manhole\n    # We need to go to the leftmost and rightmost manholes\n    if k == 1:\n        total_moves += (n - 1)  # Move to the rightmost manhole\n    elif k == n:\n        total_moves += (n - 1)  # Move to the leftmost manhole\n    else:\n        total_moves += (k - 1) + (n - k)  # Move to both ends\n    \n    return total_moves\n\n# Read input\nn, k = map(int, input().split())\n# Print the result\nprint(minimum_moves(n, k))"}
{"solution": "def minimum_tower_height(n, m):\n    max_height_two_blocks = n * (n + 1)  # Sum of first n natural numbers multiplied by 2\n    max_height_three_blocks = m * (m + 1) * 3 // 2  # Sum of first m natural numbers multiplied by 3\n\n    return max(max_height_two_blocks, max_height_three_blocks)\n\nn, m = map(int, input().split())\nprint(minimum_tower_height(n, m))"}
{"solution": "n = int(input())\ncards = [int(input()) for _ in range(n)]\n\nfrom collections import Counter\n\ncount = Counter(cards)\n\nif len(count) < 2:\n    print(\"NO\")\nelse:\n    items = list(count.items())\n    if len(items) == 2 and items[0][1] == items[1][1]:\n        print(\"YES\")\n        print(items[0][0], items[1][0])\n    else:\n        for i in range(len(items)):\n            for j in range(i + 1, len(items)):\n                if items[i][1] + items[j][1] == n and items[i][1] == items[j][1]:\n                    print(\"YES\")\n                    print(items[i][0], items[j][0])\n                    break\n            else:\n                continue\n            break\n        else:\n            print(\"NO\")"}
{"solution": "def can_arrange_soldiers(n, k, groups):\n    # Sort groups in descending order\n    groups.sort(reverse=True)\n    \n    # Calculate the maximum number of soldiers that can be placed in the airplane\n    max_soldiers_per_row = 8\n    total_seats = n * max_soldiers_per_row\n    \n    # Check if the largest group can fit without violating the neighbor rule\n    if groups[0] > (n * 4):\n        return \"NO\"\n    \n    # Check if the total number of soldiers can fit in the airplane\n    if sum(groups) > total_seats:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_arrange_soldiers(n, k, groups)\nprint(result)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmin_cost = float('inf')\nbest_t = -1\n\nfor t in range(1, 101):\n    cost = 0\n    for length in a:\n        if length < t - 1:\n            cost += (t - 1) - length\n        elif length > t + 1:\n            cost += length - (t + 1)\n    \n    if cost < min_cost:\n        min_cost = cost\n        best_t = t\n\nprint(best_t, min_cost)"}
{"solution": "n, m = map(int, input().split())\nsky_map = [input().strip() for _ in range(n)]\n\nmin_row = n\nmax_row = -1\nmin_col = m\nmax_col = -1\n\nfor i in range(n):\n    for j in range(m):\n        if sky_map[i][j] == '*':\n            if i < min_row:\n                min_row = i\n            if i > max_row:\n                max_row = i\n            if j < min_col:\n                min_col = j\n            if j > max_col:\n                max_col = j\n\nside_length = max(max_row - min_row + 1, max_col - min_col + 1)\nprint(side_length)"}
{"solution": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef mod_inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef probability_of_sorted_array(n, k, a):\n    MOD = 10**9 + 7\n    count_0 = a.count(0)\n    count_1 = n - count_0\n\n    if count_0 == 0 or count_1 == 0:\n        return 1  # Already sorted\n\n    if k == 0:\n        return 0  # No operations, not sorted\n\n    total_pairs = n * (n - 1) // 2\n    if total_pairs == 0:\n        return 0  # No pairs to swap\n\n    # Calculate the number of ways to choose k pairs\n    total_ways = pow(total_pairs, k, MOD)\n\n    # Calculate the number of ways to choose k pairs that keep the array sorted\n    if count_0 == 0 or count_1 == 0:\n        valid_ways = 0\n    else:\n        valid_pairs = count_0 * count_1\n        valid_ways = pow(valid_pairs, k, MOD)\n\n    if valid_ways == 0:\n        return 0\n\n    # Reduce the fraction valid_ways / total_ways\n    P = valid_ways\n    Q = total_ways\n\n    common_divisor = gcd(P, Q)\n    P //= common_divisor\n    Q //= common_divisor\n\n    # Calculate the result\n    result = (P * mod_inverse(Q, MOD)) % MOD\n    return result\n\n# Input reading\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(probability_of_sorted_array(n, k, a))"}
{"solution": "def min_seconds_to_devolve_triangle(x, y):\n    # The number of seconds required is the difference between the starting and ending side lengths\n    return (x - y) * 2 - 3\n\n# Read input\nx, y = map(int, input().split())\n# Calculate and print the result\nprint(min_seconds_to_devolve_triangle(x, y))"}
{"solution": "def minimum_norm_degenerate_matrix(a, b, c, d):\n    # Calculate the determinant of matrix A\n    det_A = a * d - b * c\n    \n    # If the determinant is already zero, the matrix is degenerate\n    if det_A == 0:\n        return 0.0\n    \n    # Calculate the norm of matrix A\n    norm_A = max(abs(a), abs(b), abs(c), abs(d))\n    \n    # Calculate the minimum possible value of ||A - B||\n    min_norm = abs(det_A) / (2 * norm_A)\n    \n    return min_norm\n\n# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate and print the result\nresult = minimum_norm_degenerate_matrix(a, b, c, d)\nprint(f\"{result:.10f}\")"}
{"solution": "def restaurant_service(n, a, b, groups):\n    denied_service = 0\n\n    for group in groups:\n        if group == 1:  # Group of one person\n            if a > 0:\n                a -= 1  # Seat at one-seater table\n            elif b > 0:\n                b -= 1  # Seat at two-seater table\n            elif b > 0:  # Seat at two-seater table with one person already\n                b -= 1\n            else:\n                denied_service += 1  # Deny service\n        else:  # Group of two people\n            if b > 0:\n                b -= 1  # Seat at two-seater table\n            else:\n                denied_service += 2  # Deny service to both\n\n    return denied_service\n\n# Input reading\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Output the result\nprint(restaurant_service(n, a, b, groups))"}
{"solution": "def calculate_failed_students(A, B, C, N):\n    # Calculate the number of students who passed the exam\n    passed_students = (A - C) + (B - C) + C\n    \n    # Calculate the number of students who didn't pass the exam\n    failed_students = N - passed_students\n    \n    # Check for contradictions\n    if failed_students < 1 or passed_students > N or A < C or B < C:\n        return -1\n    \n    return failed_students\n\n# Read input\nA, B, C, N = map(int, input().split())\n# Calculate and print the result\nprint(calculate_failed_students(A, B, C, N))"}
{"solution": "def expected_dresses(x, k):\n    MOD = 10**9 + 7\n    \n    if k == 0:\n        return (x * 2) % MOD\n    \n    # Calculate 2^(k+1) % MOD\n    power_of_two = pow(2, k + 1, MOD)\n    \n    # Calculate the expected number of dresses\n    expected_value = (x * power_of_two - (power_of_two - 1) * (1 if x > 0 else 0) // 2) % MOD\n    \n    return expected_value\n\n# Read input\nx, k = map(int, input().split())\n# Print the result\nprint(expected_dresses(x, k))"}
{"solution": "def mod_inverse(a, p):\n    return pow(a, p - 2, p)\n\ndef calculate_probability(n, ranges):\n    total_ways = 1\n    valid_ways = 0\n\n    for l, r in ranges:\n        total_ways *= (r - l + 1)\n        total_ways %= MOD\n\n    # Count valid arrangements\n    from itertools import permutations\n\n    for perm in permutations(range(n)):\n        valid = True\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if ranges[perm[i]][1] < ranges[perm[j]][0]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            valid_ways += 1\n\n    # Calculate the probability\n    x = valid_ways\n    y = total_ways\n\n    # Reduce x/y to irreducible form\n    from math import gcd\n    g = gcd(x, y)\n    x //= g\n    y //= g\n\n    # Calculate y^-1 mod MOD\n    y_inv = mod_inverse(y, MOD)\n\n    # Result is x * y^-1 mod MOD\n    result = (x * y_inv) % MOD\n    return result\n\nMOD = 998244353\n\nn = int(input())\nranges = [tuple(map(int, input().split())) for _ in range(n)]\nprint(calculate_probability(n, ranges))"}
{"solution": "def count_ways(n):\n    if n < 8:\n        return 0\n    count = 0\n    for a in range(1, (n // 2) + 1):\n        b = (n - 2 * a) // 2\n        if b > 0 and a != b:\n            count += 1\n    return count\n\nn = int(input())\nprint(count_ways(n))"}
{"solution": "def fair_nut_kvass(n, s, volumes):\n    total_kvass = sum(volumes)\n    \n    if total_kvass < s:\n        return -1\n    \n    left, right = 0, min(volumes)\n    \n    while left < right:\n        mid = (left + right + 1) // 2\n        needed = sum(max(0, v - mid) for v in volumes)\n        \n        if needed >= s:\n            left = mid\n        else:\n            right = mid - 1\n            \n    return left\n\n# Read input\nn, s = map(int, input().split())\nvolumes = list(map(int, input().split()))\n\n# Get the result and print it\nresult = fair_nut_kvass(n, s, volumes)\nprint(result)"}
{"solution": "h1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate the effective gain per day\nday_hours = 12\nnight_hours = 12\n\n# Caterpillar's position at the end of the first day\ninitial_position = h1 + (a * (day_hours - 4))  # 2 PM to 10 PM is 8 hours\nif initial_position >= h2:\n    print(0)\n    exit()\n\n# Effective gain after a full day\neffective_gain = a * day_hours - b * night_hours\n\n# If the caterpillar goes down more than it goes up, it will never reach the apple\nif effective_gain <= 0:\n    print(-1)\n    exit()\n\n# Calculate the remaining distance to the apple\nremaining_distance = h2 - initial_position\n\n# Calculate the number of full days needed\ndays_needed = (remaining_distance + effective_gain - 1) // effective_gain\n\nprint(days_needed)"}
{"solution": "def max_joy_units(C, H_r, H_b, W_r, W_b):\n    max_joy = 0\n    \n    # Try all possible counts of red candies\n    for red_candies in range(C // W_r + 1):\n        weight_used = red_candies * W_r\n        remaining_weight = C - weight_used\n        \n        # Calculate the maximum blue candies that can be eaten with the remaining weight\n        blue_candies = remaining_weight // W_b\n        \n        # Calculate joy units\n        joy = red_candies * H_r + blue_candies * H_b\n        max_joy = max(max_joy, joy)\n    \n    return max_joy\n\n# Read input\nC, H_r, H_b, W_r, W_b = map(int, input().split())\n# Print the result\nprint(max_joy_units(C, H_r, H_b, W_r, W_b))"}
{"solution": "x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\ndx = abs(x2 - x1)\ndy = abs(y2 - y1)\n\nprint(max(dx, dy))"}
{"solution": "def predict_vote_outcome(n, employees):\n    d_count = employees.count('D')\n    r_count = employees.count('R')\n    \n    if d_count > r_count:\n        return 'D'\n    else:\n        return 'R'\n\nn = int(input().strip())\nemployees = input().strip()\nresult = predict_vote_outcome(n, employees)\nprint(result)"}
{"solution": "def count_tv_sets(a, b, x, y):\n    # Calculate the greatest common divisor of x and y\n    from math import gcd\n    g = gcd(x, y)\n    x //= g\n    y //= g\n    \n    # Initialize the count of valid (w, h) pairs\n    count = 0\n    \n    # Find the maximum k such that (k * x <= a) and (k * y <= b)\n    k_max = min(a // x, b // y)\n    \n    # The number of valid pairs is k_max\n    return k_max\n\n# Read input\na, b, x, y = map(int, input().split())\n# Calculate and print the result\nprint(count_tv_sets(a, b, x, y))"}
{"solution": "def prime_factors(b):\n    factors = {}\n    d = 2\n    while d * d <= b:\n        while (b % d) == 0:\n            if d in factors:\n                factors[d] += 1\n            else:\n                factors[d] = 1\n            b //= d\n        d += 1\n    if b > 1:\n        factors[b] = 1\n    return factors\n\ndef count_factors_in_factorial(n, p):\n    count = 0\n    power = p\n    while power <= n:\n        count += n // power\n        power *= p\n    return count\n\ndef trailing_zeros_in_base(n, b):\n    factors = prime_factors(b)\n    min_trailing_zeros = float('inf')\n    \n    for p, k in factors.items():\n        count = count_factors_in_factorial(n, p)\n        min_trailing_zeros = min(min_trailing_zeros, count // k)\n    \n    return min_trailing_zeros\n\nn, b = map(int, input().split())\nprint(trailing_zeros_in_base(n, b))"}
{"solution": "def sum_of_reachable_positions(m, a, b):\n    if a == b:\n        return (m + 1) * (m + 2) // 2\n    \n    g = abs(a - b)\n    reachable_count = 0\n    \n    for i in range(m + 1):\n        if i < a:\n            reachable_count += 1\n        else:\n            reachable_count += (i // g) + 1\n    \n    return reachable_count\n\nm, a, b = map(int, input().split())\nresult = sum_of_reachable_positions(m, a, b)\nprint(result)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nif n % 2 == 1 and a[0] % 2 == 1 and a[-1] % 2 == 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "x1, y1, x2, y2 = map(int, input().split())\n\nif x1 == x2:\n    # Same x-coordinate, vertical line\n    side_length = abs(y2 - y1)\n    x3, y3 = x1 + side_length, y1\n    x4, y4 = x2 + side_length, y2\nelif y1 == y2:\n    # Same y-coordinate, horizontal line\n    side_length = abs(x2 - x1)\n    x3, y3 = x1, y1 + side_length\n    x4, y4 = x2, y2 + side_length\nelif abs(x2 - x1) == abs(y2 - y1):\n    # Diagonal points of a square\n    x3, y3 = x1, y2\n    x4, y4 = x2, y1\nelse:\n    # Not forming a square\n    print(-1)\n    exit()\n\nprint(x3, y3, x4, y4)"}
{"solution": "def calculate_f_n(x, y, n):\n    MOD = 1000000007\n    \n    if n == 1:\n        return x % MOD\n    elif n == 2:\n        return y % MOD\n    else:\n        # The sequence is periodic with a period of 6\n        f_n = [x % MOD, y % MOD, (y - x) % MOD, (-x) % MOD, (-y) % MOD, (x - y) % MOD]\n        return f_n[(n - 1) % 6]\n\nx, y = map(int, input().split())\nn = int(input())\nresult = calculate_f_n(x, y, n)\nprint(result)"}
{"solution": "n = int(input())\nA = list(map(int, input().split()))\n\ntotal_sum = sum(A)\n\nif total_sum == 0:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    if total_sum > 0:\n        print(1)\n        print(1, n)\n    else:\n        current_sum = 0\n        segments = []\n        start = 1\n        \n        for i in range(n):\n            current_sum += A[i]\n            if current_sum == 0:\n                segments.append((start, i + 1))\n                start = i + 2\n                current_sum = 0\n        \n        if current_sum != 0:\n            segments.append((start, n))\n        \n        print(len(segments))\n        for l, r in segments:\n            print(l, r)"}
{"solution": "def minimum_score(n, m, k):\n    MOD = 1000000009\n    \n    if m == 0:\n        return 0\n    \n    # Calculate the number of full groups of k correct answers\n    full_groups = m // k\n    remaining_correct = m % k\n    \n    # Calculate the minimum score\n    score = (full_groups * (2 * k - 1) + remaining_correct) % MOD\n    \n    return score\n\n# Read input\nn, m, k = map(int, input().split())\n# Print the result\nprint(minimum_score(n, m, k))"}
{"solution": "n = input().strip()\n\n# Check for single digit numbers\nfor digit in n:\n    if int(digit) % 8 == 0:\n        print(\"YES\")\n        print(digit)\n        exit()\n\n# Check for two digit combinations\nfor i in range(len(n)):\n    for j in range(i + 1, len(n)):\n        if int(n[i] + n[j]) % 8 == 0:\n            print(\"YES\")\n            print(n[i] + n[j])\n            exit()\n\n# Check for three digit combinations\nfor i in range(len(n)):\n    for j in range(i + 1, len(n)):\n        for k in range(j + 1, len(n)):\n            if int(n[i] + n[j] + n[k]) % 8 == 0:\n                print(\"YES\")\n                print(n[i] + n[j] + n[k])\n                exit()\n\nprint(\"NO\")"}
{"solution": "def find_floor(n, m, memories):\n    possible_floors = set()\n    \n    for k, f in memories:\n        # Calculate the number of flats per floor\n        flats_per_floor = (k - 1) // (f - 1) if f > 1 else k\n        if flats_per_floor > 0:\n            possible_floors.add(flats_per_floor)\n    \n    valid_floors = set()\n    \n    for flats_per_floor in possible_floors:\n        floor_of_n = (n - 1) // flats_per_floor + 1\n        if (n - 1) % flats_per_floor < flats_per_floor:\n            valid_floors.add(floor_of_n)\n    \n    if len(valid_floors) == 1:\n        return valid_floors.pop()\n    else:\n        return -1\n\n# Input reading\nn, m = map(int, input().split())\nmemories = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output the result\nprint(find_floor(n, m, memories))"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    count = 0\n    i = 0\n    \n    while i < n:\n        if board1[i] == '0' and board2[i] == '0':\n            if i + 1 < n and board1[i + 1] == '0':\n                count += 1\n                i += 2  # Place a bishwock in horizontal position\n            elif i + 1 < n and board2[i + 1] == '0':\n                count += 1\n                i += 2  # Place a bishwock in horizontal position\n            elif i + 1 < n and board1[i + 1] == '0' and board2[i + 1] == '0':\n                count += 1\n                i += 2  # Place a bishwock in vertical position\n            else:\n                count += 1\n                i += 1  # Place a single bishwock\n        else:\n            i += 1  # Move to the next column\n    \n    return count\n\n# Read input\nboard1 = input().strip()\nboard2 = input().strip()\n\n# Calculate and print the result\nprint(max_bishwocks(board1, board2))"}
{"solution": "def max_pretty_set(n, s):\n    max_count = 0\n    current_set = set()\n\n    for char in s:\n        if char.islower():\n            current_set.add(char)\n        else:\n            max_count = max(max_count, len(current_set))\n            current_set.clear()\n\n    max_count = max(max_count, len(current_set))\n    return max_count\n\nn = int(input())\ns = input().strip()\nprint(max_pretty_set(n, s))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nB = sum(x for x in a if x > 0)\nC = sum(x for x in a if x < 0)\n\nmax_value = B - C\nprint(max_value)"}
{"solution": "def min_refuels(a, b, f, k):\n    distance_per_journey = 2 * a\n    total_distance = k * distance_per_journey\n    \n    if b < a:\n        return -1\n    \n    if b >= total_distance:\n        return 0\n    \n    # Calculate the distance to the gas station and back\n    distance_to_station = f\n    distance_from_station_to_a = a - f\n    \n    # Check if we can reach the gas station\n    if b < distance_to_station:\n        return -1\n    \n    # Calculate the number of journeys we can make before needing to refuel\n    refuels = 0\n    current_fuel = b\n    \n    for journey in range(k):\n        # Each journey consists of going to 'a' and back to '0'\n        # Going to 'a'\n        if current_fuel < distance_to_station:\n            return -1\n        \n        current_fuel -= distance_to_station\n        \n        # If we can reach the gas station on the way to 'a'\n        if current_fuel < distance_from_station_to_a:\n            # We need to refuel at the gas station\n            refuels += 1\n            current_fuel = b\n        \n        # Now we can go from 'f' to 'a'\n        current_fuel -= distance_from_station_to_a\n        \n        # Coming back from 'a' to '0'\n        if current_fuel < distance_to_station:\n            return -1\n        \n        current_fuel -= distance_to_station\n        \n        # If we can reach the gas station on the way back\n        if journey < k - 1:  # No need to refuel after the last journey\n            if current_fuel < distance_from_station_to_a:\n                # We need to refuel at the gas station\n                refuels += 1\n                current_fuel = b\n            \n            # Now we can go from 'a' to 'f'\n            current_fuel -= distance_from_station_to_a\n    \n    return refuels\n\n# Input reading\na, b, f, k = map(int, input().split())\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    for i in range(n // p + 1):\n        remaining_length = n - i * p\n        if remaining_length >= 0 and remaining_length % q == 0:\n            j = remaining_length // q\n            result = []\n            result.extend([s[k * p:(k + 1) * p] for k in range(i)])\n            result.extend([s[i * p + k * q:i * p + (k + 1) * q] for k in range(j)])\n            print(len(result))\n            for part in result:\n                print(part)\n            return\n    print(-1)\n\n# Read input\nn, p, q = map(int, input().split())\ns = input().strip()\n\nsplit_string(n, p, q, s)"}
{"solution": "def can_reach_finish(n, m, s, d, obstacles):\n    obstacles.sort()\n    obstacles = [0] + obstacles + [m]  # Add start and finish points\n    current_position = 0\n    commands = []\n    \n    for i in range(len(obstacles) - 1):\n        start = obstacles[i]\n        end = obstacles[i + 1]\n        \n        # Check if we can run to the next obstacle\n        distance_to_next = end - current_position\n        \n        if distance_to_next > d + s:\n            return \"IMPOSSIBLE\"\n        \n        # Run to the point where we can jump\n        if distance_to_next > s:\n            run_distance = min(distance_to_next - d, s)\n            commands.append(f\"RUN {run_distance}\")\n            current_position += run_distance\n        \n        # Now we can jump over the obstacle\n        jump_distance = end - current_position\n        if jump_distance > d:\n            return \"IMPOSSIBLE\"\n        \n        commands.append(f\"JUMP {jump_distance}\")\n        current_position += jump_distance\n    \n    return \"\\n\".join(commands)\n\n# Input reading\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\n# Output the result\nresult = can_reach_finish(n, m, s, d, obstacles)\nprint(result)"}
{"solution": "def count_pairs(s, x):\n    if (s < x) or ((s - x) % 2 != 0):\n        return 0\n    \n    a_plus_b = s\n    a_minus_b = x\n    a = (a_plus_b + a_minus_b) // 2\n    b = (a_plus_b - a_minus_b) // 2\n    \n    if a <= 0 or b <= 0:\n        return 0\n    \n    # Count the number of bits that are set in (s - x)\n    count = 0\n    for i in range(64):\n        if (s - x) & (1 << i):\n            count += 1\n            \n    return 1 << count\n\ns, x = map(int, input().split())\nprint(count_pairs(s, x))"}
{"solution": "def turn_skewers(n, k):\n    actions = []\n    for i in range(1, n + 1, k + 1):\n        actions.append(i)\n    return actions\n\nn, k = map(int, input().split())\nactions = turn_skewers(n, k)\nprint(len(actions))\nprint(' '.join(map(str, actions)))"}
{"solution": "def min_operations_to_square(n):\n    n_str = str(n)\n    max_square_root = int(n**0.5) + 1\n    squares = [str(i * i) for i in range(1, max_square_root)]\n    \n    min_operations = float('inf')\n    \n    for square in squares:\n        square_len = len(square)\n        n_len = len(n_str)\n        \n        # Two pointers to check if square can be formed from n_str\n        i, j = 0, 0\n        while i < n_len and j < square_len:\n            if n_str[i] == square[j]:\n                j += 1\n            i += 1\n        \n        if j == square_len:  # Found a valid square\n            operations = n_len - square_len\n            min_operations = min(min_operations, operations)\n    \n    return min_operations if min_operations != float('inf') else -1\n\nn = int(input().strip())\nprint(min_operations_to_square(n))"}
{"solution": "def count_permutations(n):\n    MOD = 1000000007\n    \n    # Calculate factorials and their modular inverses\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    # The maximum value of f(p) is the number of distinct prime factors of n\n    def count_distinct_prime_factors(x):\n        count = 0\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                count += 1\n                while x % i == 0:\n                    x //= i\n        if x > 1:\n            count += 1\n        return count\n    \n    distinct_primes = count_distinct_prime_factors(n)\n    \n    # The number of permutations with f(p) = f_max(n) is fact[n] / fact[distinct_primes]\n    result = fact[n] * pow(fact[distinct_primes], MOD - 2, MOD) % MOD\n    \n    return result\n\nn = int(input())\nprint(count_permutations(n))"}
{"solution": "def min_jump_ability(s):\n    vowels = set('AEIOUY')\n    positions = [i for i, char in enumerate(s) if char in vowels]\n    \n    if not positions:\n        return len(s) + 1  # If there are no vowels, jump ability must be greater than the string length\n    \n    max_jump = 0\n    # Include the start and end positions\n    positions = [-1] + positions + [len(s)]\n    \n    for i in range(1, len(positions)):\n        max_jump = max(max_jump, positions[i] - positions[i - 1])\n    \n    return max_jump\n\n# Read input\ninput_string = input().strip()\n# Calculate and print the result\nprint(min_jump_ability(input_string))"}
{"solution": "def can_distribute_candies(a):\n    total = sum(a)\n    if total % 2 != 0:\n        return \"NO\"\n    \n    target = total // 2\n    n = len(a)\n    \n    # Check all combinations of bags\n    for i in range(1 << n):\n        current_sum = 0\n        for j in range(n):\n            if i & (1 << j):\n                current_sum += a[j]\n        if current_sum == target:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\na = list(map(int, input().split()))\nprint(can_distribute_candies(a))"}
{"solution": "def optimal_pie_distribution(n, slices):\n    alice_sum = 0\n    bob_sum = 0\n    turn = 0  # 0 for Bob's turn, 1 for Alice's turn\n\n    for size in slices:\n        if turn == 0:  # Bob's turn\n            bob_sum += size\n            turn = 1  # Pass the decider token to Alice\n        else:  # Alice's turn\n            alice_sum += size\n            turn = 0  # Pass the decider token to Bob\n\n    return alice_sum, bob_sum\n\n# Read input\nn = int(input())\nslices = list(map(int, input().split()))\n\n# Get the result\nalice, bob = optimal_pie_distribution(n, slices)\n\n# Print the output\nprint(alice, bob)"}
{"solution": "def min_variables(n, a):\n    a.sort()\n    max_a = a[-1]\n    \n    # Check if we can form the sequence with m variables\n    for m in range(1, n + 1):\n        # Initialize the variables\n        b = [0] * m\n        b[0] = a[0]  # First operation\n\n        # Set to keep track of reachable sums\n        reachable = {b[0]}\n\n        for t in range(1, n):\n            current_value = a[t]\n            found = False\n            \n            # Try to find a combination of b[i] and b[j] that sums to current_value\n            for i in range(m):\n                for j in range(m):\n                    if b[i] + b[j] == current_value:\n                        b[t % m] = current_value\n                        reachable.add(current_value)\n                        found = True\n                        break\n                if found:\n                    break\n            \n            if not found:\n                break\n        \n        if len(reachable) == n and all(x in reachable for x in a):\n            return m\n    \n    return -1\n\n# Input reading\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Output the result\nprint(min_variables(n, a))"}
{"solution": "def determine_winner(n, piles):\n    # Sort the piles in descending order\n    piles.sort(reverse=True)\n    \n    # Calculate the nim-sum (XOR of all piles)\n    nim_sum = 0\n    for pile in piles:\n        nim_sum ^= pile\n    \n    # If the nim-sum is 0, Bob wins; otherwise, Alice wins\n    return \"Bob\" if nim_sum == 0 else \"Alice\"\n\n# Read input\nn = int(input().strip())\npiles = list(map(int, input().strip().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, piles))"}
{"solution": "def can_make_equal(n, a):\n    unique_values = set(a)\n    \n    if len(unique_values) > 3:\n        return \"NO\"\n    elif len(unique_values) == 3:\n        min_val = min(unique_values)\n        max_val = max(unique_values)\n        mid_val = sum(unique_values) - min_val - max_val\n        if mid_val * 2 != min_val + max_val:\n            return \"NO\"\n    return \"YES\"\n\nn = int(input())\na = list(map(int, input().split()))\nprint(can_make_equal(n, a))"}
{"solution": "def max_repeated_substring_length(N, S):\n    max_len = 0\n    \n    for length in range(1, N // 2 + 1):\n        seen = set()\n        for start in range(N - length + 1):\n            substring = S[start:start + length]\n            if substring in seen:\n                max_len = length\n                break\n            seen.add(substring)\n    \n    return max_len\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nS = data[1]\n\nprint(max_repeated_substring_length(N, S))"}
{"solution": "n, a = map(int, input().split())\n\nif a % 2 == 1:  # Odd house\n    time = (a // 2) + 1\nelse:  # Even house\n    time = (n - a) // 2 + 1\n\nprint(time)"}
{"solution": "def can_select_jedi(n, m, colors, k):\n    # Create a count array for the required colors\n    required_counts = [0] * (m + 1)\n    for i in range(1, m + 1):\n        required_counts[i] = k[i - 1]\n\n    # Sliding window to find the contiguous interval\n    for start in range(n):\n        current_counts = [0] * (m + 1)\n        for end in range(start, n):\n            current_counts[colors[end]] += 1\n            \n            # Check if current_counts matches required_counts\n            if current_counts == required_counts:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\nk = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_select_jedi(n, m, colors, k)\nprint(result)"}
{"solution": "n = int(input())\nmishka_wins = 0\nchris_wins = 0\n\nfor _ in range(n):\n    m, c = map(int, input().split())\n    if m > c:\n        mishka_wins += 1\n    elif c > m:\n        chris_wins += 1\n\nif mishka_wins > chris_wins:\n    print(\"Mishka\")\nelif chris_wins > mishka_wins:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")"}
{"solution": "def is_valid_minesweeper_field(n, m, field):\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    \n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                continue\n            \n            bomb_count = 0\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':\n                    bomb_count += 1\n            \n            if field[i][j] == '.':\n                if bomb_count != 0:\n                    return \"NO\"\n            elif field[i][j].isdigit():\n                if bomb_count != int(field[i][j]):\n                    return \"NO\"\n    \n    return \"YES\"\n\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\nprint(is_valid_minesweeper_field(n, m, field))"}
{"solution": "def min_k_to_eat_half_candies(n):\n    left, right = 1, n\n    target = (n + 1) // 2  # At least half of n\n\n    while left < right:\n        k = (left + right) // 2\n        candies = n\n        vasya_eaten = 0\n\n        while candies > 0:\n            vasya_eaten += min(k, candies)\n            candies -= min(k, candies)\n            candies -= candies // 10  # Petya eats 10% of remaining candies\n\n        if vasya_eaten >= target:\n            right = k\n        else:\n            left = k + 1\n\n    return left\n\nn = int(input())\nprint(min_k_to_eat_half_candies(n))"}
{"solution": "s = input().strip()\n\n# Count the number of pearls and links\npearls = s.count('o')\nlinks = s.count('-')\n\n# If there are no pearls, it's trivially YES\nif pearls == 0:\n    print(\"YES\")\n# If there are pearls, we need to check the condition\nelif links % pearls == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def max_pillows(n, m, k):\n    left = k - 1\n    right = n - k\n    low, high = 1, m\n\n    while low < high:\n        mid = (low + high + 1) // 2\n        total_pillows = mid + max(0, mid - 1) * left + max(0, mid - 2) * right\n        if total_pillows <= m:\n            low = mid\n        else:\n            high = mid - 1\n\n    return low\n\nn, m, k = map(int, input().split())\nprint(max_pillows(n, m, k))"}
{"solution": "import sys\nimport math\n\ndef max_cost_subarray(n, m, k, a):\n    max_cost = 0\n    current_sum = 0\n    for r in range(n):\n        current_sum += a[r]\n        length = r + 1\n        cost = current_sum - k * math.ceil(length / m)\n        max_cost = max(max_cost, cost)\n        \n        # Reset current_sum if it becomes negative\n        if current_sum < 0:\n            current_sum = 0\n            \n    return max_cost\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2])\n    a = list(map(int, data[3:]))\n    \n    result = max_cost_subarray(n, m, k, a)\n    print(result)"}
{"solution": "def longest_polyline(n, m):\n    # The four points that will create the longest polyline\n    points = [\n        (0, 0),     # Bottom-left corner\n        (n, 0),     # Bottom-right corner\n        (n, m),     # Top-right corner\n        (0, m)      # Top-left corner\n    ]\n    \n    return points\n\n# Read input\nn, m = map(int, input().split())\n\n# Get the points for the longest polyline\nresult_points = longest_polyline(n, m)\n\n# Print the result\nfor point in result_points:\n    print(point[0], point[1])"}
{"solution": "def find_smallest_n(received, remembered):\n    from collections import Counter\n\n    # Count the digits in the received string\n    count_received = Counter(received)\n    \n    # Count the digits in the remembered substring\n    count_remembered = Counter(remembered)\n    \n    # Remove the remembered digits from the received count\n    for digit in count_remembered:\n        count_received[digit] -= count_remembered[digit]\n    \n    # Create the smallest possible n\n    result = []\n    \n    # Add the remembered substring first\n    result.append(remembered)\n    \n    # Create a list of remaining digits\n    remaining_digits = []\n    for digit in sorted(count_received.keys()):\n        remaining_digits.extend([digit] * count_received[digit])\n    \n    # If there are remaining digits, we need to ensure no leading zero\n    if remaining_digits:\n        if '0' in remaining_digits:\n            # Find the first non-zero digit to place at the front\n            for i in range(len(remaining_digits)):\n                if remaining_digits[i] != '0':\n                    # Place the first non-zero digit at the front\n                    result.append(remaining_digits[i])\n                    # Remove it from remaining digits\n                    remaining_digits.pop(i)\n                    break\n            # Add the rest of the remaining digits\n            result.extend(remaining_digits)\n        else:\n            # If there are no zeros, just add the remaining digits\n            result.extend(remaining_digits)\n    \n    # Join the result and return\n    return ''.join(result)\n\n# Input reading\nreceived = input().strip()\nremembered = input().strip()\n\n# Get the smallest n and print it\nprint(find_smallest_n(received, remembered))"}
{"solution": "n, m, min_temp, max_temp = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\ncurrent_min = min(temperatures)\ncurrent_max = max(temperatures)\n\nif current_min > min_temp or current_max < max_temp:\n    print(\"Incorrect\")\nelse:\n    needed_min = min_temp not in temperatures\n    needed_max = max_temp not in temperatures\n    if needed_min + needed_max <= n - m:\n        print(\"Correct\")\n    else:\n        print(\"Incorrect\")"}
{"solution": "def count_trailing_zeroes(n):\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count\n\ndef find_numbers_with_m_zeroes(m):\n    low, high = 0, 5 * (m + 1)\n    result = []\n\n    while low <= high:\n        mid = (low + high) // 2\n        zeroes = count_trailing_zeroes(mid)\n\n        if zeroes < m:\n            low = mid + 1\n        elif zeroes > m:\n            high = mid - 1\n        else:\n            result.append(mid)\n            # Check for other numbers with the same number of zeroes\n            left = mid - 1\n            while count_trailing_zeroes(left) == m:\n                result.append(left)\n                left -= 1\n            right = mid + 1\n            while count_trailing_zeroes(right) == m:\n                result.append(right)\n                right += 1\n            break\n\n    result = sorted(result)\n    return result\n\nm = int(input().strip())\nnumbers = find_numbers_with_m_zeroes(m)\nprint(len(numbers))\nif numbers:\n    print(\" \".join(map(str, numbers)))"}
{"solution": "import sys\nimport heapq\nfrom collections import defaultdict\n\ndef dijkstra_max_cost(n, graph, start):\n    max_cost = [float('inf')] * (n + 1)\n    max_cost[start] = 0\n    pq = [(0, start)]  # (cost, vertex)\n    \n    while pq:\n        current_cost, u = heapq.heappop(pq)\n        \n        if current_cost > max_cost[u]:\n            continue\n        \n        for v, weight in graph[u]:\n            new_cost = max(current_cost, weight)\n            if new_cost < max_cost[v]:\n                max_cost[v] = new_cost\n                heapq.heappush(pq, (new_cost, v))\n    \n    return max_cost\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    k = int(data[index + 2])\n    index += 3\n    \n    special_vertices = list(map(int, data[index:index + k]))\n    index += k\n    \n    graph = defaultdict(list)\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        index += 3\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    results = []\n    \n    for sv in special_vertices:\n        max_costs = dijkstra_max_cost(n, graph, sv)\n        max_distance = 0\n        for other_sv in special_vertices:\n            if sv != other_sv:\n                max_distance = max(max_distance, max_costs[other_sv])\n        results.append(max_distance)\n    \n    print(' '.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def initial_position(n, x):\n    # The position of the ball after n moves can be traced back\n    # by reversing the operations.\n    for i in range(n, 0, -1):\n        if i % 2 == 1:  # Odd move: swap 0 and 1\n            if x == 0:\n                x = 1\n            elif x == 1:\n                x = 0\n        else:  # Even move: swap 1 and 2\n            if x == 1:\n                x = 2\n            elif x == 2:\n                x = 1\n    return x\n\nn = int(input())\nx = int(input())\nprint(initial_position(n, x))"}
{"solution": "def rectangles_form_square(n, rectangles):\n    total_area = 0\n    min_x = min_y = float('inf')\n    max_x = max_y = float('-inf')\n\n    for x1, y1, x2, y2 in rectangles:\n        total_area += (x2 - x1) * (y2 - y1)\n        min_x = min(min_x, x1)\n        min_y = min(min_y, y1)\n        max_x = max(max_x, x2)\n        max_y = max(max_y, y2)\n\n    side_length = max_x - min_x\n    if side_length != (max_y - min_y):\n        return \"NO\"\n\n    if total_area == side_length * side_length:\n        return \"YES\"\n    else:\n        return \"NO\"\n\nn = int(input())\nrectangles = [tuple(map(int, input().split())) for _ in range(n)]\nprint(rectangles_form_square(n, rectangles))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(d) for d in str(x))\n\ndef count_really_big_numbers(n, s):\n    count = 0\n    for x in range(s, n + 1):\n        if x - sum_of_digits(x) >= s:\n            count += 1\n    return count\n\nn, s = map(int, input().split())\nresult = count_really_big_numbers(n, s)\nprint(result)"}
{"solution": "def can_draw_two_lines(points):\n    def check_line(p1, p2, points):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p1[0] * p2[1] - p2[0] * p1[1]\n        return all(a * x + b * y == c for x, y in points)\n\n    def try_with_fixed_points(p1, p2, points):\n        remaining_points = [p for p in points if not (p == p1 or p == p2)]\n        if not remaining_points:\n            return True\n        p3 = remaining_points[0]\n        if check_line(p1, p2, points):\n            return True\n        if check_line(p1, p3, remaining_points):\n            return True\n        if check_line(p2, p3, remaining_points):\n            return True\n        return False\n\n    if len(points) <= 2:\n        return True\n\n    for i in range(2):\n        p1 = points[i]\n        p2 = points[1] if i == 0 else points[0]\n        if try_with_fixed_points(p1, p2, points):\n            return True\n\n    return False\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\nif can_draw_two_lines(points):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_winning_games(a, b, k, t):\n    MOD = 10**9 + 7\n    \n    # Dynamic programming table\n    dp = [[0] * (2 * t * k + 1) for _ in range(t + 1)]\n    dp[0][0] = 1  # Base case: 1 way to have score difference of 0 at turn 0\n\n    for turn in range(1, t + 1):\n        for score_diff in range(-k * turn, k * turn + 1):\n            for delta in range(-k, k + 1):\n                dp[turn][score_diff + k * turn] += dp[turn - 1][score_diff + k * (turn - 1)]\n                dp[turn][score_diff + k * turn] %= MOD\n\n    total_games = pow(2 * k + 1, t, MOD)\n    winning_games = 0\n\n    for score_diff in range(1, 2 * t * k + 1):\n        winning_games += dp[t][score_diff]\n        winning_games %= MOD\n\n    return winning_games\n\n# Input reading\na, b, k, t = map(int, input().split())\nresult = count_winning_games(a, b, k, t)\nprint(result)"}
{"solution": "def min_marks_to_add(n, l, x, y, marks):\n    marks_set = set(marks)\n    needed_marks = []\n\n    # Check if we can measure x\n    can_measure_x = any((mark + x) in marks_set for mark in marks)\n    if not can_measure_x:\n        needed_marks.append(x)\n\n    # Check if we can measure y\n    can_measure_y = any((mark + y) in marks_set for mark in marks)\n    if not can_measure_y:\n        needed_marks.append(y)\n\n    # Check if we can measure y - x\n    if (y - x) not in marks_set:\n        needed_marks.append(y - x)\n\n    # Output the result\n    print(len(needed_marks))\n    if needed_marks:\n        print(\" \".join(map(str, needed_marks)))\n\n# Input reading\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\nmin_marks_to_add(n, l, x, y, marks)"}
{"solution": "import sys\nimport math\n\ndef calculate_volume(r, h):\n    return math.pi * r * r * h\n\ndef max_cake_volume(n, cakes):\n    # Calculate volumes and sort by radius and height\n    volumes = [(calculate_volume(r, h), r, h) for r, h in cakes]\n    volumes.sort(key=lambda x: (x[1], x[2]))  # Sort by radius, then height\n\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = volumes[i][0]  # Start with the volume of the cake itself\n        for j in range(i):\n            if volumes[j][0] < volumes[i][0]:  # Check if we can stack\n                dp[i] = max(dp[i], dp[j] + volumes[i][0])\n\n    return max(dp)\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().splitlines()\n    n = int(data[0])\n    cakes = [tuple(map(int, line.split())) for line in data[1:n+1]]\n    \n    result = max_cake_volume(n, cakes)\n    print(f\"{result:.12f}\")"}
{"solution": "def min_good_slices(n, k, heights):\n    heights.sort()\n    unique_heights = sorted(set(heights))\n    total_slices = 0\n    current_height = unique_heights[-1]\n    \n    for i in range(len(unique_heights) - 1, 0, -1):\n        next_height = unique_heights[i - 1]\n        cost = sum(max(0, h - next_height) for h in heights)\n        \n        if cost <= k:\n            total_slices += 1\n            current_height = next_height\n            \n    return total_slices\n\n# Input reading\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Output the result\nprint(min_good_slices(n, k, heights))"}
{"solution": "def max_score(n, a):\n    max_score = 0\n    \n    for l in range(n):\n        current_sum = 0\n        max_remove = float('-inf')\n        \n        for r in range(l, n):\n            current_sum += a[r]\n            max_remove = max(max_remove, a[r])\n            score = current_sum - max_remove\n            \n            max_score = max(max_score, score)\n    \n    return max_score\n\nn = int(input())\na = list(map(int, input().split()))\nprint(max_score(n, a))"}
{"solution": "def can_light_garlands(k1, k2, k3):\n    # Sort the intervals\n    k = sorted([k1, k2, k3])\n    \n    # Check if the sum of the two smallest intervals is greater than or equal to the largest interval\n    if k[0] + k[1] >= k[2]:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nk1, k2, k3 = map(int, input().split())\n# Print the result\nprint(can_light_garlands(k1, k2, k3))"}
{"solution": "def min_operations_to_delete(s):\n    n = len(s)\n    dp = [[float('inf')] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = 1  # Single character can be deleted in one operation\n    \n    for length in range(2, n + 1):  # length of the substring\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j - 1]  # If the ends are the same, we can consider them together\n            for k in range(i, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])  # Split the substring\n            \n    return dp[0][n - 1]\n\nn = int(input().strip())\ns = input().strip()\nprint(min_operations_to_delete(s))"}
{"solution": "def max_pairs(n, boys, m, girls):\n    boys.sort()\n    girls.sort()\n    \n    i, j = 0, 0\n    pairs = 0\n    \n    while i < n and j < m:\n        if abs(boys[i] - girls[j]) <= 1:\n            pairs += 1\n            i += 1\n            j += 1\n        elif boys[i] < girls[j]:\n            i += 1\n        else:\n            j += 1\n            \n    return pairs\n\n# Input reading\nn = int(input())\nboys = list(map(int, input().split()))\nm = int(input())\ngirls = list(map(int, input().split()))\n\n# Output the result\nprint(max_pairs(n, boys, m, girls))"}
{"solution": "def can_team_win(a1, b1, a2, b2):\n    return a1 > b2 and b1 > a2\n\ndef main():\n    players = [tuple(map(int, input().split())) for _ in range(4)]\n    \n    # Team 1 players\n    a1, b1 = players[0]  # Player 1\n    a2, b2 = players[1]  # Player 2\n    \n    # Team 2 players\n    a3, b3 = players[2]  # Player 3\n    a4, b4 = players[3]  # Player 4\n    \n    team1_wins = (\n        can_team_win(a1, b2, a3, b4) or\n        can_team_win(a2, b1, a3, b4) or\n        can_team_win(a1, b2, a4, b3) or\n        can_team_win(a2, b1, a4, b3)\n    )\n    \n    team2_wins = (\n        can_team_win(a3, b4, a1, b2) or\n        can_team_win(a4, b3, a1, b2) or\n        can_team_win(a3, b4, a2, b1) or\n        can_team_win(a4, b3, a2, b1)\n    )\n    \n    if team1_wins and not team2_wins:\n        print(\"Team 1\")\n    elif team2_wins and not team1_wins:\n        print(\"Team 2\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\nimport math\nfrom scipy.optimize import minimize\n\ndef time_to_grill(XY, meats, K):\n    X, Y = XY\n    times = []\n    for x_i, y_i, c_i in meats:\n        time = c_i * math.sqrt((X - x_i) ** 2 + (Y - y_i) ** 2)\n        times.append(time)\n    times.sort()\n    return max(times[:K])\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N, K = map(int, data[0].split())\n    meats = [tuple(map(int, line.split())) for line in data[1:N+1]]\n    \n    # Initial guess for the position of the heat source\n    initial_guess = (0.0, 0.0)\n    \n    # Minimize the time to grill K pieces of meat\n    result = minimize(time_to_grill, initial_guess, args=(meats, K), method='Nelder-Mead')\n    \n    # Output the minimum time found\n    print(f\"{result.fun:.10f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def determine_winner(n, ticket):\n    half_n = n // 2\n    left_sum = 0\n    right_sum = 0\n    left_questions = 0\n    right_questions = 0\n\n    for i in range(half_n):\n        if ticket[i] == '?':\n            left_questions += 1\n        else:\n            left_sum += int(ticket[i])\n\n    for i in range(half_n, n):\n        if ticket[i] == '?':\n            right_questions += 1\n        else:\n            right_sum += int(ticket[i])\n\n    total_questions = left_questions + right_questions\n    diff = abs(left_sum - right_sum)\n\n    if diff > total_questions * 9:\n        return \"Monocarp\"\n    \n    if (total_questions % 2 == 0 and diff % 2 == 0) or (total_questions % 2 == 1 and diff % 2 == 1):\n        return \"Bicarp\"\n    \n    return \"Monocarp\"\n\nn = int(input().strip())\nticket = input().strip()\nprint(determine_winner(n, ticket))"}
{"solution": "n, t = map(int, input().split())\nbuses = []\n\nfor i in range(n):\n    s, d = map(int, input().split())\n    if s >= t:\n        buses.append((s, i + 1))\n    else:\n        # Calculate the next bus time after t\n        if (t - s) % d == 0:\n            buses.append((t, i + 1))\n        else:\n            next_bus_time = s + ((t - s) // d + 1) * d\n            buses.append((next_bus_time, i + 1))\n\n# Find the bus with the minimum time\nbuses.sort()\nprint(buses[0][1])"}
{"solution": "def count_numbers_with_k_ones(n, k):\n    count = 0\n    for i in range(n + 1, 2 * n + 1):\n        if bin(i).count('1') == k:\n            count += 1\n    return count\n\ndef find_n(m, k):\n    n = 1\n    while True:\n        if count_numbers_with_k_ones(n, k) == m:\n            return n\n        n += 1\n\nm, k = map(int, input().split())\nresult = find_n(m, k)\nprint(result)"}
{"solution": "n = int(input())\nlevel = input().strip()\n\nplatforms = [i for i in range(n) if level[i] == '*']\n\nfor i in range(len(platforms)):\n    for j in range(i + 1, len(platforms)):\n        d = platforms[j] - platforms[i]\n        if platforms[i] + 2 * d in platforms and platforms[i] + 3 * d in platforms:\n            print(\"yes\")\n            exit()\n\nprint(\"no\")"}
{"solution": "def find_magic_number(n, grid):\n    empty_row, empty_col = -1, -1\n    total_sum = 0\n    row_sums = [0] * n\n    col_sums = [0] * n\n    main_diag_sum = 0\n    sec_diag_sum = 0\n    \n    # Find the empty cell and calculate sums\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                empty_row, empty_col = i, j\n            else:\n                total_sum += grid[i][j]\n                row_sums[i] += grid[i][j]\n                col_sums[j] += grid[i][j]\n                if i == j:\n                    main_diag_sum += grid[i][j]\n                if i + j == n - 1:\n                    sec_diag_sum += grid[i][j]\n    \n    # The target magic sum\n    target_sum = None\n    for i in range(n):\n        if i != empty_row:\n            if target_sum is None:\n                target_sum = row_sums[i]\n            elif target_sum != row_sums[i]:\n                return -1\n    \n    # Calculate the required number to fill in the empty cell\n    required_number = target_sum - row_sums[empty_row]\n    \n    # Check if the required number is positive\n    if required_number <= 0:\n        return -1\n    \n    # Check if filling the required number maintains the magic square properties\n    new_row_sum = row_sums[empty_row] + required_number\n    new_col_sum = col_sums[empty_col] + required_number\n    new_main_diag_sum = main_diag_sum\n    new_sec_diag_sum = sec_diag_sum\n    \n    if empty_row == empty_col:\n        new_main_diag_sum += required_number\n    if empty_row + empty_col == n - 1:\n        new_sec_diag_sum += required_number\n    \n    if (new_row_sum == target_sum and\n        new_col_sum == target_sum and\n        new_main_diag_sum == target_sum and\n        new_sec_diag_sum == target_sum):\n        return required_number\n    \n    return -1\n\n# Input reading\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(find_magic_number(n, grid))"}
{"solution": "n = int(input())\nm = int(input())\na = [int(input()) for _ in range(n)]\n\n# Calculate maximum possible k\nmax_k = max(a) + m\n\n# Calculate minimum possible k\n# Distribute m people as evenly as possible\ntotal_people = sum(a) + m\nmin_k = (total_people + n - 1) // n  # Ceiling division\n\nprint(min_k, max_k)"}
{"solution": "def count_boarding_ways(n, m):\n    MOD = 10**9 + 7\n    \n    # Calculate the total number of ways to assign seats and entrances\n    total_ways = pow(n, m, MOD) * pow(2, m, MOD) % MOD\n    \n    # Calculate the number of invalid ways (where at least one person gets angry)\n    # This happens when all m people are assigned to the same seat\n    invalid_ways = n * pow(2, m - 1, MOD) % MOD\n    \n    # Valid ways are total ways minus invalid ways\n    valid_ways = (total_ways - invalid_ways + MOD) % MOD\n    \n    return valid_ways\n\n# Read input\nn, m = map(int, input().split())\n# Print the result\nprint(count_boarding_ways(n, m))"}
{"solution": "def main():\n    import sys\n    from itertools import combinations\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m = map(int, data[0].split())\n    \n    friends_favorites = []\n    for i in range(1, n + 1):\n        line = list(map(int, data[i].split()))\n        friends_favorites.append(set(line[1:]))\n    \n    pizzas = []\n    for j in range(n + 1, n + m + 1):\n        line = list(map(int, data[j].split()))\n        price = line[0]\n        ingredients = set(line[2:])\n        pizzas.append((price, ingredients))\n    \n    max_happy_friends = 0\n    best_pair = (0, 1)\n    min_cost = float('inf')\n    \n    for i, j in combinations(range(m), 2):\n        combined_ingredients = pizzas[i][1] | pizzas[j][1]\n        happy_count = sum(1 for favorites in friends_favorites if favorites.issubset(combined_ingredients))\n        \n        total_cost = pizzas[i][0] + pizzas[j][0]\n        \n        if (happy_count > max_happy_friends) or (happy_count == max_happy_friends and total_cost < min_cost):\n            max_happy_friends = happy_count\n            min_cost = total_cost\n            best_pair = (i + 1, j + 1)  # +1 for 1-based index\n    \n    print(best_pair[0], best_pair[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_min_max_numbers(m, s):\n    if (s == 0 and m > 1) or (s > 9 * m):\n        return \"-1 -1\"\n\n    # Finding the minimum number\n    min_number = []\n    remaining_sum = s\n\n    for i in range(m):\n        for digit in range(0 if i > 0 else 1, 10):\n            if remaining_sum - digit >= 0 and remaining_sum - digit <= 9 * (m - i - 1):\n                min_number.append(digit)\n                remaining_sum -= digit\n                break\n\n    # Finding the maximum number\n    max_number = []\n    remaining_sum = s\n\n    for i in range(m):\n        for digit in range(9, -1, -1):\n            if remaining_sum - digit >= 0 and remaining_sum - digit <= 9 * (m - i - 1):\n                max_number.append(digit)\n                remaining_sum -= digit\n                break\n\n    return ''.join(map(str, min_number)), ''.join(map(str, max_number))\n\nm, s = map(int, input().split())\nmin_num, max_num = find_min_max_numbers(m, s)\nprint(min_num, max_num)"}
{"solution": "def count_valid_numbers_with_k_digits(l, r, k):\n    def is_valid(num):\n        return len(set(str(num))) <= k\n\n    total_sum = 0\n    for num in range(l, r + 1):\n        if is_valid(num):\n            total_sum += num\n            total_sum %= 998244353\n    return total_sum\n\nl, r, k = map(int, input().split())\nresult = count_valid_numbers_with_k_digits(l, r, k)\nprint(result)"}
{"solution": "def can_distribute_pencils(n, k, d, saturations):\n    saturations.sort()\n    count = 0\n    i = 0\n    \n    while i < n:\n        count += 1\n        start = saturations[i]\n        while i < n and saturations[i] - start <= d:\n            i += 1\n        if i - (count - 1) * k < k:\n            return \"NO\"\n    \n    return \"YES\" if count * k <= n else \"NO\"\n\n# Input reading\nn, k, d = map(int, input().split())\nsaturations = list(map(int, input().split()))\n\n# Output the result\nprint(can_distribute_pencils(n, k, d, saturations))"}
{"solution": "def count_dead_bulbs(s):\n    color_map = {'R': 0, 'B': 1, 'Y': 2, 'G': 3}\n    dead_count = [0, 0, 0, 0]\n    \n    # Find the first occurrence of each color\n    last_seen = [-1] * 4\n    for i, bulb in enumerate(s):\n        if bulb in color_map:\n            last_seen[color_map[bulb]] = i\n    \n    # Count dead bulbs based on the last seen positions\n    for i in range(len(s)):\n        if s[i] == '!':\n            # Determine the color that should be here\n            color_index = (i % 4)\n            if last_seen[color_index] != -1:\n                dead_count[color_index] += 1\n    \n    # Output the counts in the order of R, B, Y, G\n    print(dead_count[0], dead_count[1], dead_count[2], dead_count[3])\n\n# Read input\ns = input().strip()\ncount_dead_bulbs(s)"}
{"solution": "def expected_passages(N, M, passages):\n    from collections import defaultdict\n    import sys\n\n    # Create a graph representation\n    graph = defaultdict(list)\n    for s, t in passages:\n        graph[s].append(t)\n\n    # Calculate expected passages without blocking\n    E = [0] * (N + 1)\n    for room in range(N - 1, 0, -1):\n        if room in graph:\n            num_passages = len(graph[room])\n            E[room] = 1 + sum(E[next_room] for next_room in graph[room]) / num_passages\n\n    # Now consider blocking each passage from room 1\n    min_E = E[1]  # Start with the expected value without blocking\n    if 1 in graph:\n        for next_room in graph[1]:\n            # Temporarily block the passage from 1 to next_room\n            num_passages = len(graph[1]) - 1  # One less passage\n            if num_passages > 0:\n                new_E = 1 + sum(E[room] for room in graph[1] if room != next_room) / num_passages\n                # Calculate the expected value if this passage is blocked\n                min_E = min(min_E, new_E)\n\n    return min_E\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nN, M = map(int, data[0].split())\npassages = [tuple(map(int, line.split())) for line in data[1:M + 1]]\n\n# Calculate the expected number of passages\nresult = expected_passages(N, M, passages)\n\n# Print the result with the required precision\nprint(f\"{result:.10f}\")"}
{"solution": "n = int(input().strip())\n\nif n % 10 == 0:\n    print(n)\nelse:\n    lower = n - (n % 10)\n    upper = lower + 10\n    if (n - lower) < (upper - n):\n        print(lower)\n    else:\n        print(upper)"}
{"solution": "def find_swappable_pairs(s, t):\n    if len(s) != len(t):\n        return -1\n\n    pairs = {}\n    for char_s, char_t in zip(s, t):\n        if char_s != char_t:\n            if char_s in pairs:\n                if pairs[char_s] != char_t:\n                    return -1\n            elif char_t in pairs:\n                if pairs[char_t] != char_s:\n                    return -1\n            else:\n                pairs[char_s] = char_t\n                pairs[char_t] = char_s\n\n    seen = set()\n    result = []\n    for char_s, char_t in pairs.items():\n        if char_s < char_t and (char_s, char_t) not in seen:\n            result.append((char_s, char_t))\n            seen.add((char_s, char_t))\n            seen.add((char_t, char_s))\n\n    return result\n\ns = input().strip()\nt = input().strip()\n\nresult = find_swappable_pairs(s, t)\n\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for a, b in result:\n        print(a, b)"}
{"solution": "def earliest_login(first_name, last_name):\n    earliest = None\n    for i in range(1, len(first_name) + 1):\n        for j in range(1, len(last_name) + 1):\n            login = first_name[:i] + last_name[:j]\n            if earliest is None or login < earliest:\n                earliest = login\n    return earliest\n\nif __name__ == \"__main__\":\n    first_name, last_name = input().split()\n    print(earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(n, sequence):\n    height = sequence.count('[') + 1\n    width = 0\n    stack = []\n    positions = []\n\n    for char in sequence:\n        if char == '[':\n            stack.append(len(positions))\n            positions.append((width, height - len(stack)))\n            width += 3  # \"+-\" or \"-+\" takes 3 width\n        else:\n            start = stack.pop()\n            positions[start] = (positions[start][0], positions[start][1] - 1)\n            width += 1  # space between brackets\n\n    # Create the output grid\n    output = [[' ' for _ in range(width)] for _ in range(height)]\n\n    # Draw the brackets\n    for i, (x, y) in enumerate(positions):\n        if sequence[i] == '[':\n            output[y][x] = '+'\n            output[y][x + 1] = '-'\n            output[y + 1][x] = '|'\n            output[y + 1][x + 1] = ' '\n            output[y + 1][x + 2] = '|'\n        else:\n            output[y][x - 1] = '-'\n            output[y][x] = '+'\n            output[y + 1][x - 1] = '|'\n            output[y + 1][x] = ' '\n            output[y + 1][x + 1] = '|'\n\n    # Print the output\n    for row in output:\n        print(''.join(row).rstrip())\n\n# Input reading\nn = int(input().strip())\nsequence = input().strip()\ndraw_brackets(n, sequence)"}
{"solution": "import sys\n\ndef golden_value(s):\n    n = len(s)\n    value = 0\n    q = (5 ** 0.5 + 1) / 2\n    for i in range(n):\n        if s[i] == '1':\n            value += q ** (n - 1 - i)\n    return value\n\ndef compare_golden_numbers(num1, num2):\n    value1 = golden_value(num1)\n    value2 = golden_value(num2)\n    \n    if value1 > value2:\n        return \">\"\n    elif value1 < value2:\n        return \"<\"\n    else:\n        return \"=\"\n\nif __name__ == \"__main__\":\n    num1 = sys.stdin.readline().strip()\n    num2 = sys.stdin.readline().strip()\n    result = compare_golden_numbers(num1, num2)\n    print(result)"}
{"solution": "def find_absent_gems(n, colors):\n    gem_colors = {\n        \"Power\": \"purple\",\n        \"Time\": \"green\",\n        \"Space\": \"blue\",\n        \"Soul\": \"orange\",\n        \"Reality\": \"red\",\n        \"Mind\": \"yellow\"\n    }\n    \n    present_colors = set(colors)\n    absent_gems = [name for name, color in gem_colors.items() if color not in present_colors]\n    \n    print(len(absent_gems))\n    for gem in absent_gems:\n        print(gem)\n\n# Input reading\nn = int(input())\ncolors = [input().strip() for _ in range(n)]\nfind_absent_gems(n, colors)"}
{"solution": "def find_round(n, a, b):\n    round_number = 1\n    while n > 1:\n        if (a + 1) // 2 == (b + 1) // 2:\n            if n == 2:\n                return \"Final!\"\n            return round_number\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n //= 2\n        round_number += 1\n    return \"Final!\"\n\nn, a, b = map(int, input().split())\nprint(find_round(n, a, b))"}
{"solution": "def min_changes(n, p, b):\n    visited = [False] * n\n    cycles = 0\n\n    # Find cycles in the permutation\n    for i in range(n):\n        if not visited[i]:\n            cycles += 1\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                x = p[x] - 1  # Move to the next position in the permutation\n\n    # Count the number of 1s in b\n    count_b1 = sum(b)\n\n    # To ensure every skewer visits each of the 2n placements:\n    # We need at least `cycles` reversals (b[i] = 1) and `n - cycles` non-reversals (b[i] = 0)\n    # The minimum changes needed will be the maximum of:\n    # - The number of cycles (to ensure all cycles are covered)\n    # - The number of 1s needed (to ensure reversals are sufficient)\n    changes_needed = max(cycles, n - count_b1)\n\n    return changes_needed\n\n# Input reading\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Output the result\nprint(min_changes(n, p, b))"}
{"solution": "v1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\nspeeds = [0] * t\nspeeds[0] = v1\nspeeds[-1] = v2\n\nfor i in range(1, t - 1):\n    speeds[i] = speeds[i - 1] + d\n\nfor i in range(t - 2, 0, -1):\n    speeds[i] = min(speeds[i], speeds[i + 1] + d)\n\ntotal_distance = sum(speeds)\nprint(total_distance)"}
{"solution": "from itertools import permutations\nimport sys\n\ndef can_cross(camels, bridge_parts):\n    for l, v in bridge_parts:\n        total_weight = 0\n        for i in range(len(camels)):\n            total_weight += camels[i]\n            if total_weight > v:\n                return False\n            total_weight -= camels[i]\n    return True\n\ndef min_distance(camels, bridge_parts):\n    total_length = sum(l for l, _ in bridge_parts)\n    return total_length\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N, M = map(int, data[0].split())\n    weights = list(map(int, data[1].split()))\n    bridge_parts = [tuple(map(int, line.split())) for line in data[2:M+2]]\n    \n    if not any(v < max(weights) for _, v in bridge_parts):\n        print(-1)\n        return\n    \n    for perm in permutations(weights):\n        if can_cross(perm, bridge_parts):\n            print(min_distance(perm, bridge_parts))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def last_digit_of_factorial_ratio(a, b):\n    if a == b:\n        return 1  # a! / a! = 1\n    \n    # Calculate the last digit of the product of numbers from (a+1) to b\n    last_digit = 1\n    for i in range(a + 1, b + 1):\n        last_digit *= i\n        last_digit %= 10  # Keep only the last digit\n    \n    return last_digit\n\n# Read input\na, b = map(int, input().split())\n# Output the result\nprint(last_digit_of_factorial_ratio(a, b))"}
{"solution": "def min_jumps_to_home(n, d, s):\n    current_position = 0\n    jumps = 0\n    \n    while current_position < n - 1:\n        next_position = current_position\n        \n        # Try to find the farthest reachable lily\n        for jump in range(1, d + 1):\n            if current_position + jump < n and s[current_position + jump] == '1':\n                next_position = current_position + jump\n        \n        # If we can't move forward, return -1\n        if next_position == current_position:\n            return -1\n        \n        current_position = next_position\n        jumps += 1\n    \n    return jumps\n\n# Input reading\nn, d = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(min_jumps_to_home(n, d, s))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\nn = int(input().strip())\n\nfor m in range(1, 1001):\n    if not is_prime(n * m + 1):\n        print(m)\n        break"}
{"solution": "def can_spend_all_coins(n):\n    house_price = 1234567\n    car_price = 123456\n    computer_price = 1234\n\n    for a in range(n // house_price + 1):\n        remaining_after_houses = n - a * house_price\n        for b in range(remaining_after_houses // car_price + 1):\n            remaining_after_cars = remaining_after_houses - b * car_price\n            if remaining_after_cars >= 0 and remaining_after_cars % computer_price == 0:\n                return \"YES\"\n    return \"NO\"\n\nn = int(input())\nprint(can_spend_all_coins(n))"}
{"solution": "def can_intersect(n, x1, x2, lines):\n    # Sort lines based on their slopes (k_i)\n    lines.sort()\n    \n    # Check for intersections in the sorted lines\n    for i in range(n - 1):\n        k1, b1 = lines[i]\n        k2, b2 = lines[i + 1]\n        \n        # If the slopes are different, they will intersect\n        if k1 != k2:\n            # Calculate the x-coordinate of the intersection\n            x_intersect = (b2 - b1) / (k1 - k2)\n            # Check if the intersection is strictly between x1 and x2\n            if x1 < x_intersect < x2:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn = int(input())\nx1, x2 = map(int, input().split())\nlines = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_intersect(n, x1, x2, lines))"}
{"solution": "def count_different_weights(n):\n    return (n + 1) // 2\n\nn = int(input())\nprint(count_different_weights(n))"}
{"solution": "def good_apartments(n, k):\n    if k == 0:\n        return 0, 0\n    if k >= n:\n        return 0, 0\n    \n    # Minimum good apartments\n    min_good = 1 if k > 0 and n > k else 0\n    \n    # Maximum good apartments\n    max_good = min(n - k, 2 * k)\n    \n    return min_good, max_good\n\n# Input reading\nn, k = map(int, input().split())\nmin_good, max_good = good_apartments(n, k)\nprint(min_good, max_good)"}
{"solution": "def max_games(n):\n    games = 0\n    while n > 1:\n        games += 1\n        n = (n + 1) // 2\n    return games\n\nn = int(input())\nprint(max_games(n))"}
{"solution": "def max_vk_occurrences(s):\n    original_count = sum(1 for i in range(len(s) - 1) if s[i:i + 2] == \"VK\")\n    max_count = original_count\n\n    for i in range(len(s)):\n        if s[i] == 'V':\n            # Change 'V' to 'K'\n            new_s = s[:i] + 'K' + s[i + 1:]\n            new_count = sum(1 for j in range(len(new_s) - 1) if new_s[j:j + 2] == \"VK\")\n            max_count = max(max_count, new_count)\n        elif s[i] == 'K':\n            # Change 'K' to 'V'\n            new_s = s[:i] + 'V' + s[i + 1:]\n            new_count = sum(1 for j in range(len(new_s) - 1) if new_s[j:j + 2] == \"VK\")\n            max_count = max(max_count, new_count)\n\n    return max_count\n\ns = input().strip()\nprint(max_vk_occurrences(s))"}
{"solution": "def minimum_segments(n):\n    if n == 1:\n        return 2\n    return (n + 1) // 2 + 1\n\nn = int(input())\nprint(minimum_segments(n))"}
{"solution": "a, b = map(int, input().split())\nyears = 0\n\nwhile a <= b:\n    a *= 3\n    b *= 2\n    years += 1\n\nprint(years)"}
{"solution": "def count_visited_nodes(h, n):\n    visited = set()\n    current_node = 1\n    commands = \"LR\" * (2 ** h)  # Infinite command string\n    index = 0\n    visited_count = 0\n    skip_count = 0\n\n    while True:\n        if current_node == n:\n            break\n        \n        if index >= len(commands):\n            index = 0\n        \n        command = commands[index]\n        index += 1\n        \n        if command == 'L':\n            next_node = current_node * 2\n        else:  # command == 'R'\n            next_node = current_node * 2 + 1\n        \n        if next_node > 2 ** h:  # Out of bounds\n            continue\n        \n        if next_node in visited:\n            skip_count += 1\n            if skip_count == 2:\n                current_node //= 2  # Go back to parent\n                skip_count = 0\n            continue\n        \n        visited.add(next_node)\n        visited_count += 1\n        \n        if next_node > 2 ** (h - 1):  # If it's a leaf node\n            if next_node == n:\n                break\n            current_node //= 2  # Go back to parent\n        else:\n            current_node = next_node\n            skip_count = 0\n\n    return visited_count\n\nh, n = map(int, input().split())\nprint(count_visited_nodes(h, n))"}
{"solution": "def count_squares(n, m):\n    total = 0\n    for size in range(1, min(n, m) + 1):\n        total += (n - size + 1) * (m - size + 1)\n    return total\n\ndef find_tables_with_squares(x):\n    results = []\n    for n in range(1, int(x**0.5) + 2):\n        for m in range(1, x + 1):\n            if count_squares(n, m) == x:\n                results.append((n, m))\n            if n != m and count_squares(m, n) == x:\n                results.append((m, n))\n    return results\n\nx = int(input())\ntables = find_tables_with_squares(x)\nprint(len(tables))\nfor n, m in sorted(tables):\n    print(n, m)"}
{"solution": "def is_valid_sequence(n, days):\n    # Days in months for non-leap and leap years\n    months_non_leap = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    months_leap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    # Check for both non-leap and leap year scenarios\n    for start_months in (months_non_leap, months_leap):\n        for start in range(12):\n            if all(days[i] == start_months[(start + i) % 12] for i in range(n)):\n                return \"YES\"\n    return \"NO\"\n\nn = int(input())\ndays = list(map(int, input().split()))\nprint(is_valid_sequence(n, days))"}
{"solution": "def find_fractions(n):\n    if n == 2:\n        print(\"NO\")\n        return\n\n    divisors = [i for i in range(2, n) if n % i == 0]\n    fractions = []\n    total_sum = 0\n\n    for b in divisors:\n        a = b - 1\n        fractions.append((a, b))\n        total_sum += a / b\n\n    if total_sum == 1 - 1/n:\n        print(\"YES\")\n        print(len(fractions))\n        for a, b in fractions:\n            print(a, b)\n    else:\n        print(\"NO\")\n\nn = int(input())\nfind_fractions(n)"}
{"solution": "def min_unattractiveness(n, a, b, heights):\n    # Initialize DP table\n    dp = [[float('inf')] * (b + 1) for _ in range(a + 1)]\n    dp[0][0] = 0  # No boards painted, no unattractiveness\n\n    for i in range(n):\n        h = heights[i]\n        for j in range(a + 1):\n            for k in range(b + 1):\n                if dp[j][k] == float('inf'):\n                    continue\n                # Paint current board red\n                if j + h <= a:\n                    dp[j + h][k] = min(dp[j + h][k], dp[j][k])\n                # Paint current board green\n                if k + h <= b:\n                    dp[j][k + h] = min(dp[j][k + h], dp[j][k])\n\n        # Update unattractiveness based on previous board's color\n        for j in range(a + 1):\n            for k in range(b + 1):\n                if dp[j][k] == float('inf'):\n                    continue\n                if i > 0:\n                    # If previous board was red\n                    if j > 0:\n                        dp[j][k] += heights[i - 1]\n                    # If previous board was green\n                    if k > 0:\n                        dp[j][k] += heights[i - 1]\n\n    # Find the minimum unattractiveness\n    min_unattractiveness_value = float('inf')\n    for j in range(a + 1):\n        for k in range(b + 1):\n            if dp[j][k] < float('inf'):\n                min_unattractiveness_value = min(min_unattractiveness_value, dp[j][k])\n\n    return min_unattractiveness_value if min_unattractiveness_value != float('inf') else -1\n\n# Input reading\nn = int(input().strip())\na, b = map(int, input().strip().split())\nheights = list(map(int, input().strip().split()))\n\n# Output the result\nprint(min_unattractiveness(n, a, b, heights))"}
{"solution": "def find_triangle_points(n, m, k):\n    area = (n * m) / k\n    \n    if area != int(area) or area < 0:\n        print(\"NO\")\n        return\n    \n    area = int(area)\n    \n    # We need to find points such that the area is equal to the calculated area\n    # Area of triangle = 0.5 * base * height\n    # Let's choose base = n and height = m\n    # Then we need 0.5 * n * h = area => h = (2 * area) / n\n    # We can set h = (2 * area) / n and check if it is valid\n    \n    h = (2 * area) / n\n    \n    if h < 0 or h > m:\n        print(\"NO\")\n        return\n    \n    # We can choose points as follows:\n    # (0, 0), (n, 0), (0, h)\n    print(\"YES\")\n    print(0, 0)\n    print(n, 0)\n    print(0, int(h))\n\n# Read input\nn, m, k = map(int, input().split())\nfind_triangle_points(n, m, k)"}
{"solution": "n, k = map(int, input().split())\ntotal_moves = n // k\nif total_moves % 2 == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nchest = 0\nbiceps = 0\nback = 0\n\nfor i in range(n):\n    if i % 3 == 0:\n        chest += a[i]\n    elif i % 3 == 1:\n        biceps += a[i]\n    else:\n        back += a[i]\n\nif chest > biceps and chest > back:\n    print(\"chest\")\nelif biceps > chest and biceps > back:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "import math\n\ndef min_redos_to_get_five(n, grades):\n    current_sum = sum(grades)\n    target_average = 5\n    required_sum = target_average * n\n\n    if current_sum >= required_sum:\n        return 0\n\n    grades.sort()  # Sort grades to redo the lowest ones first\n    redos = 0\n\n    for grade in grades:\n        current_sum += (5 - grade)  # Assume we redo this grade to 5\n        redos += 1\n        if current_sum >= required_sum:\n            break\n\n    return redos\n\n# Input reading\nn = int(input())\ngrades = list(map(int, input().split()))\n\n# Output the result\nprint(min_redos_to_get_five(n, grades))"}
{"solution": "def find_array(u, v):\n    if u > v or (v - u) % 2 != 0:\n        return -1\n    \n    if u == 0 and v == 0:\n        return (0, [])\n    \n    x = (v - u) // 2\n    a = x + u\n    b = x\n    \n    return (2, [a, b])\n\nu, v = map(int, input().split())\nresult = find_array(u, v)\n\nif result == -1:\n    print(-1)\nelse:\n    n, array = result\n    print(n)\n    print(' '.join(map(str, array)))"}
{"solution": "n = int(input())\ncount_of_ones = 0\n\nwhile n > 0:\n    count_of_ones += n % 10\n    n //= 10\n\nprint(count_of_ones)"}
{"solution": "def can_reach_treasure(x1, y1, x2, y2, x, y):\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    \n    if dx % x == 0 and dy % y == 0:\n        if (dx // x) % 2 == (dy // y) % 2:\n            return \"YES\"\n    return \"NO\"\n\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\nprint(can_reach_treasure(x1, y1, x2, y2, x, y))"}
{"solution": "from itertools import permutations\n\ndef count_bus_variants(n):\n    str_n = str(n)\n    unique_permutations = set(permutations(str_n))\n    valid_numbers = set()\n\n    for perm in unique_permutations:\n        # Join the tuple to form the number\n        num_str = ''.join(perm)\n        # Check if it doesn't start with '0'\n        if num_str[0] != '0':\n            valid_numbers.add(int(num_str))\n\n    return len(valid_numbers)\n\nn = int(input())\nprint(count_bus_variants(n))"}
{"solution": "a = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\n# Calculate the maximum number of suits of each type\nmax_type1 = min(a, d)  # Ties and jackets for type 1 suits\nmax_type2 = min(b, c, d)  # Scarves, vests, and jackets for type 2 suits\n\n# Calculate the total cost for all combinations\ntotal_cost = 0\n\n# Try to maximize the profit by checking both combinations\nif e > f:\n    # Prioritize type 1 suits\n    suits_type1 = max_type1\n    remaining_jackets = d - suits_type1\n    suits_type2 = min(b, c, remaining_jackets)\nelse:\n    # Prioritize type 2 suits\n    suits_type2 = max_type2\n    remaining_jackets = d - suits_type2\n    suits_type1 = min(a, remaining_jackets)\n\n# Calculate the total cost\ntotal_cost = suits_type1 * e + suits_type2 * f\n\nprint(total_cost)"}
{"solution": "def count_satisfying_n(a, b, p, x):\n    count = 0\n    for n in range(1, min(x, p) + 1):\n        if (n * pow(a, n, p)) % p == b:\n            count += 1\n    return count\n\nif __name__ == \"__main__\":\n    a, b, p, x = map(int, input().split())\n    result = count_satisfying_n(a, b, p, x)\n    print(result)"}
{"solution": "def max_sum_of_favorite_integers(k2, k3, k5, k6):\n    # Calculate how many 256 can be formed\n    count_256 = min(k2, k5, k6)\n    \n    # Calculate how many 32 can be formed\n    count_32 = min(k2, k3)\n    \n    # Calculate the total sum\n    total_sum = count_256 * 256 + count_32 * 32\n    \n    return total_sum\n\n# Input reading\nk2, k3, k5, k6 = map(int, input().split())\n# Output the result\nprint(max_sum_of_favorite_integers(k2, k3, k5, k6))"}
{"solution": "def time_to_happiness(n, x, y, c):\n    if c == 1:\n        return 0\n    \n    # Calculate the maximum number of cells that can be turned on\n    max_cells = 1\n    seconds = 0\n    \n    while max_cells < c:\n        seconds += 1\n        max_cells += 4 * seconds\n    \n    return seconds\n\n# Read input\nn, x, y, c = map(int, input().split())\nresult = time_to_happiness(n, x, y, c)\nprint(result)"}
{"solution": "def max_xor(l, r):\n    xor = l ^ r\n    max_bit = 0\n    while xor > 0:\n        max_bit += 1\n        xor >>= 1\n    return (1 << max_bit) - 1\n\nl, r = map(int, input().split())\nprint(max_xor(l, r))"}
{"solution": "def minimum_height(n, k):\n    # The maximum area that can be achieved with height h is n * h\n    # We need to find the minimum height h such that n * h >= k\n    # This means h >= k / n\n    # Since h must be an integer, we take the ceiling of k / n\n    if k <= n:\n        return 1\n    else:\n        return (k + n - 1) // n  # This is equivalent to ceil(k / n)\n\n# Read input\nn, k = map(int, input().split())\n# Calculate and print the result\nprint(minimum_height(n, k))"}
{"solution": "x, y, z, t1, t2, t3 = map(int, input().split())\n\n# Calculate time using stairs\nstairs_time = abs(x - y) * t1\n\n# Calculate time using elevator\nelevator_time = (abs(z - x) * t2) + t3 + t3 + (abs(x - y) * t2) + t3\n\n# Determine which option is better\nif elevator_time <= stairs_time:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def best_choice(n, m):\n    if m == 1:\n        return 2\n    elif m == n:\n        return n - 1\n    else:\n        return m - 1 if (m - 1) <= (n - m) else m + 1\n\nn, m = map(int, input().split())\nprint(best_choice(n, m))"}
{"solution": "n = int(input())\nlessons = list(map(int, input().split()))\n\nstay_count = 0\ni = 0\n\n# Find the first class\nwhile i < n and lessons[i] == 0:\n    i += 1\n\n# If there are no classes\nif i == n:\n    print(0)\nelse:\n    # Alena will stay for the first class\n    stay_count += 1\n    i += 1\n\n    while i < n:\n        if lessons[i] == 1:\n            stay_count += 1\n            i += 1\n        else:\n            # Check for breaks\n            break_length = 0\n            while i < n and lessons[i] == 0:\n                break_length += 1\n                i += 1\n            \n            # If there are at least 2 breaks, Alena goes home\n            if break_length >= 2:\n                continue\n            else:\n                # If less than 2 breaks, she waits for the next class\n                stay_count += break_length\n\n    print(stay_count)"}
{"solution": "def min_days_to_give_candies(n, k, candies):\n    total_given = 0\n    for day in range(n):\n        total_given += min(candies[day], 8)\n        if total_given >= k:\n            return day + 1\n    return -1\n\n# Input reading\nn, k = map(int, input().split())\ncandies = list(map(int, input().split()))\n\n# Output the result\nprint(min_days_to_give_candies(n, k, candies))"}
{"solution": "def min_additional_walks(n, k, a):\n    b = [0] * n\n    additional_walks = 0\n    \n    # Set the first day's walks\n    b[0] = max(a[0], k)\n    \n    for i in range(1, n):\n        # Calculate the required walks for the current day\n        required_walks = k - b[i - 1]\n        b[i] = max(a[i], required_walks)\n        additional_walks += b[i] - a[i]\n    \n    # Print the results\n    print(additional_walks)\n    print(' '.join(map(str, b)))\n\n# Input reading\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nmin_additional_walks(n, k, a)"}
{"solution": "n = int(input())\n\nif n == 1:\n    print(1)\nelse:\n    cells = 1 + 4 * (n - 1) * n // 2\n    print(cells)"}
{"solution": "n = int(input().strip())\ns = input().strip()\n\n# Convert the string to lowercase and create a set of characters\nunique_chars = set(s.lower())\n\n# Check if the set contains all 26 letters of the alphabet\nif len(unique_chars) >= 26 and all(chr(i) in unique_chars for i in range(ord('a'), ord('z') + 1)):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def time_after_minutes(current_time, minutes_to_add):\n    hh, mm = map(int, current_time.split(':'))\n    total_minutes = hh * 60 + mm + minutes_to_add\n    new_hh = (total_minutes // 60) % 24\n    new_mm = total_minutes % 60\n    return f\"{new_hh:02}:{new_mm:02}\"\n\ncurrent_time = input().strip()\nminutes_to_add = int(input().strip())\nresult = time_after_minutes(current_time, minutes_to_add)\nprint(result)"}
{"solution": "def can_ignore_switch(n, m, switches):\n    # Convert the input into a list of sets for easier manipulation\n    lamp_sets = [set() for _ in range(m)]\n    \n    for i in range(n):\n        for j in range(m):\n            if switches[i][j] == '1':\n                lamp_sets[j].add(i)\n    \n    # Check each switch to see if it can be ignored\n    for i in range(n):\n        # Create a set of lamps that can be turned on without the i-th switch\n        lamps_on = set()\n        for j in range(n):\n            if j != i:\n                for k in range(m):\n                    if switches[j][k] == '1':\n                        lamps_on.add(k)\n        \n        # Check if all lamps are on\n        if len(lamps_on) == m:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nswitches = [input().strip() for _ in range(n)]\n\n# Get the result and print it\nresult = can_ignore_switch(n, m, switches)\nprint(result)"}
{"solution": "n = int(input())\ndominoes = [tuple(map(int, input().split())) for _ in range(n)]\n\nsum_upper = sum(x for x, y in dominoes)\nsum_lower = sum(y for x, y in dominoes)\n\nif sum_upper % 2 == 0 and sum_lower % 2 == 0:\n    print(0)\nelse:\n    odd_count = sum(1 for x, y in dominoes if (x + y) % 2 == 1)\n    if odd_count > 0:\n        print(1)\n    else:\n        print(-1)"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    a, b = map(int, input().split())\n    area = a * a - b * b\n    if is_prime(area):\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nprint(\"\\n\".join(results))"}
{"solution": "def can_remove_point(n, points):\n    left_count = 0\n    right_count = 0\n    \n    for x, y in points:\n        if x < 0:\n            left_count += 1\n        else:\n            right_count += 1\n            \n    # If all points are on one side or if we can remove one to make it so\n    if left_count <= 1 or right_count <= 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\nresult = can_remove_point(n, points)\nprint(result)"}
{"solution": "import math\nimport sys\n\ndef gcd_of_factorials(A, B):\n    min_factorial = min(A, B)\n    return math.factorial(min_factorial)\n\nif __name__ == \"__main__\":\n    A, B = map(int, sys.stdin.readline().strip().split())\n    result = gcd_of_factorials(A, B)\n    print(result)"}
{"solution": "def is_composite(num):\n    if num < 4:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return True\n    return False\n\ndef find_composite_pair(n):\n    a = n + 4  # Start with a known composite number\n    b = 4     # 4 is the smallest composite number\n    while not (is_composite(a) and is_composite(b)):\n        a += 1\n    return a, b\n\nn = int(input())\na, b = find_composite_pair(n)\nprint(a, b)"}
{"solution": "import sys\nimport heapq\n\ndef max_score(N, M, P, edges):\n    graph = [[] for _ in range(N + 1)]\n    for A, B, C in edges:\n        graph[A].append((B, C))\n\n    # Dijkstra-like approach to find maximum coins collected at each vertex\n    max_coins = [-float('inf')] * (N + 1)\n    max_coins[1] = 0\n    pq = [(-max_coins[1], 1)]  # (negative coins, vertex)\n\n    while pq:\n        current_coins, u = heapq.heappop(pq)\n        current_coins = -current_coins\n\n        for v, coins in graph[u]:\n            new_coins = current_coins + coins\n            if new_coins > max_coins[v]:\n                max_coins[v] = new_coins\n                heapq.heappush(pq, (-new_coins, v))\n\n    max_score = -1\n    for t in range(1, N + 1):\n        if max_coins[N] >= t * P:\n            score = max_coins[N] - t * P\n            max_score = max(max_score, score)\n\n    return max_score if max_score != -1 else -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    N, M, P = map(int, data[0].split())\n    edges = [tuple(map(int, line.split())) for line in data[1:M + 1]]\n    \n    result = max_score(N, M, P, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef min_cost_to_form_palindrome(n, strings_cost):\n    from collections import defaultdict\n    \n    cost_map = defaultdict(lambda: float('inf'))\n    used_strings = set()\n    \n    for s, c in strings_cost:\n        if is_palindrome(s):\n            cost_map[s] = min(cost_map[s], c)\n        rev_s = s[::-1]\n        if rev_s in cost_map:\n            used_strings.add((s, rev_s))\n    \n    total_cost = 0\n    for s, rev_s in used_strings:\n        total_cost += min(cost_map[s], cost_map[rev_s])\n    \n    single_cost = float('inf')\n    for s, c in strings_cost:\n        if is_palindrome(s):\n            single_cost = min(single_cost, c)\n    \n    if total_cost == 0 and single_cost == float('inf'):\n        return -1\n    \n    return total_cost + (single_cost if single_cost != float('inf') else 0)\n\nimport sys\ninput = sys.stdin.read\ndata = input().strip().splitlines()\n\nN = int(data[0])\nstrings_cost = [tuple(line.split()) for line in data[1:N+1]]\nstrings_cost = [(s, int(c)) for s, c in strings_cost]\n\nresult = min_cost_to_form_palindrome(N, strings_cost)\nprint(result)"}
{"solution": "def largest_xor_sum(n, k):\n    if k == n:\n        return n ^ (n - 1)  # If we can take all candies, return the xor of all\n    else:\n        # The largest xor-sum we can get is from the largest k numbers\n        # which are n, n-1, ..., n-k+1\n        result = 0\n        for i in range(k):\n            result ^= (n - i)\n        return result\n\n# Read input\nn, k = map(int, input().strip().split())\n# Output the result\nprint(largest_xor_sum(n, k))"}
{"solution": "def min_triangle_side(n, points):\n    max_x = max(point[0] for point in points)\n    max_y = max(point[1] for point in points)\n    \n    return max(max_x, max_y) * 2\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\nresult = min_triangle_side(n, points)\nprint(result)"}
{"solution": "from collections import Counter\n\ndef max_nineteens(s):\n    # Count the occurrences of each letter in the string\n    letter_count = Counter(s)\n    \n    # The word \"nineteen\" consists of:\n    # n: 2, i: 1, e: 2, t: 1\n    needed_counts = {'n': 2, 'i': 1, 'e': 2, 't': 1}\n    \n    # Calculate the maximum number of \"nineteen\" that can be formed\n    max_count = float('inf')\n    for letter, count in needed_counts.items():\n        if letter in letter_count:\n            max_count = min(max_count, letter_count[letter] // count)\n        else:\n            max_count = 0\n            break\n    \n    return max_count\n\n# Read input\ns = input().strip()\n# Print the result\nprint(max_nineteens(s))"}
{"solution": "def highest_safe_branch(p, y):\n    if y <= p:\n        return -1\n    \n    for branch in range(y, p, -1):\n        if all(branch % i != 0 for i in range(2, int(p**0.5) + 1) if p % i == 0):\n            return branch\n    return -1\n\np, y = map(int, input().split())\nprint(highest_safe_branch(p, y))"}
{"solution": "n, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\nmin_distance = float('inf')\n\nfor i in range(n):\n    if a[i] > 0 and a[i] <= k:\n        distance = abs(m - (i + 1)) * 10\n        min_distance = min(min_distance, distance)\n\nprint(min_distance)"}
{"solution": "def can_transform(n, m, A, B):\n    from collections import defaultdict\n\n    # Create a mapping of values to their positions in A and B\n    positions_A = defaultdict(list)\n    positions_B = defaultdict(list)\n\n    for i in range(n):\n        for j in range(m):\n            positions_A[A[i][j]].append((i, j))\n            positions_B[B[i][j]].append((i, j))\n\n    # Check if the positions of each value in A can match those in B\n    for value in positions_A:\n        if sorted(positions_A[value]) != sorted(positions_B[value]):\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nB = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_transform(n, m, A, B))"}
{"solution": "a = input().strip()\nb = input().strip()\n\nif a == b:\n    print(-1)\nelse:\n    print(max(len(a), len(b)))"}
{"solution": "def first_common_scream(a, b, c, d):\n    # We will use a set to track Rick's scream times\n    rick_screams = set()\n    \n    # Generate Rick's scream times\n    for i in range(10000):  # Arbitrarily large limit to ensure we cover enough time\n        rick_scream_time = b + i * a\n        rick_screams.add(rick_scream_time)\n    \n    # Check Morty's scream times against Rick's\n    for j in range(10000):  # Arbitrarily large limit to ensure we cover enough time\n        morty_scream_time = d + j * c\n        if morty_scream_time in rick_screams:\n            return morty_scream_time\n    \n    return -1\n\n# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Get the result and print it\nresult = first_common_scream(a, b, c, d)\nprint(result)"}
{"solution": "n = int(input())\n\nif n % 3 == 0:\n    a = 1\n    b = 1\n    c = n - 2\nelif n % 3 == 1:\n    a = 1\n    b = 2\n    c = n - 3\nelse:  # n % 3 == 2\n    a = 2\n    b = 2\n    c = n - 4\n\nprint(a, b, c)"}
{"solution": "def count_valid_squares(n, a, b, c, d):\n    # Calculate the sum of the top left 2x2 square\n    S = a + b + c + d\n    \n    # The possible values for the unknown cells\n    valid_count = 0\n    \n    # Iterate through all possible values for the unknown cells\n    for x1 in range(1, n + 1):  # Top left cell\n        for x2 in range(1, n + 1):  # Top right cell\n            for x3 in range(1, n + 1):  # Bottom left cell\n                for x4 in range(1, n + 1):  # Bottom right cell\n                    if (x1 + a + x2 == S) and (b + x3 + d == S) and (x2 + c + x4 == S) and (x3 + d + x4 == S):\n                        valid_count += 1\n    \n    return valid_count\n\n# Read input\nn, a, b, c, d = map(int, input().split())\n# Get the result\nresult = count_valid_squares(n, a, b, c, d)\n# Print the result\nprint(result)"}
{"solution": "w, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\nstones = {d1: u1, d2: u2}\n\nfor current_height in range(h, 0, -1):\n    w += current_height\n    if current_height in stones:\n        w -= stones[current_height]\n        if w < 0:\n            w = 0\n\nprint(w)"}
{"solution": "m = int(input())\nc = list(map(int, input().split()))\nx, y = map(int, input().split())\n\ntotal_students = sum(c)\n\nfor k in range(1, m + 1):\n    beginner_group_size = sum(c[i] for i in range(k - 1))\n    intermediate_group_size = sum(c[i] for i in range(k, m))\n\n    if x <= beginner_group_size <= y and x <= intermediate_group_size <= y:\n        print(k)\n        break\nelse:\n    print(0)"}
{"solution": "def min_cost_to_one(n, k, A, B):\n    cost = 0\n    while n > 1:\n        if k > 1 and n % k == 0:\n            # Calculate cost to divide\n            divide_cost = B\n            # Calculate cost to subtract to the next divisible number\n            next_divisible = (n // k) * k\n            subtract_cost = (n - next_divisible) * A\n            \n            if divide_cost < subtract_cost:\n                cost += divide_cost\n                n //= k\n            else:\n                cost += subtract_cost\n                n = next_divisible\n        else:\n            # If not divisible by k, just subtract to reach 1\n            cost += (n - 1) * A\n            n = 1\n    return cost\n\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\nprint(min_cost_to_one(n, k, A, B))"}
{"solution": "import math\nfrom collections import deque\n\ndef min_value_and_operations(n):\n    # To store the minimum value and the number of operations\n    min_value = n\n    min_operations = 0\n    \n    # To keep track of visited states\n    visited = set()\n    queue = deque([(n, 0)])  # (current value, operations count)\n    \n    while queue:\n        current, operations = queue.popleft()\n        \n        # Check if we have found a new minimum\n        if current < min_value:\n            min_value = current\n            min_operations = operations\n        \n        # Perform sqrt operation if possible\n        if current > 1:\n            sqrt_value = int(math.isqrt(current))\n            if sqrt_value * sqrt_value == current and sqrt_value not in visited:\n                visited.add(sqrt_value)\n                queue.append((sqrt_value, operations + 1))\n        \n        # Perform mul operation for all factors of current\n        for i in range(1, int(math.sqrt(current)) + 1):\n            if current % i == 0:\n                # i is a factor\n                mul_value = current * i\n                if mul_value not in visited:\n                    visited.add(mul_value)\n                    queue.append((mul_value, operations + 1))\n                \n                # current // i is also a factor\n                if i != current // i:\n                    mul_value = current * (current // i)\n                    if mul_value not in visited:\n                        visited.add(mul_value)\n                        queue.append((mul_value, operations + 1))\n    \n    return min_value, min_operations\n\nn = int(input().strip())\nresult = min_value_and_operations(n)\nprint(result[0], result[1])"}
{"solution": "def max_score(N, K, R, S, P, T):\n    dp = [[0] * 3 for _ in range(N + 1)]\n    \n    for i in range(1, N + 1):\n        for j in range(3):\n            if i > K:\n                dp[i][j] = max(dp[i - 1][(j + 1) % 3], dp[i - 1][(j + 2) % 3])\n            else:\n                dp[i][j] = max(dp[i - 1])  # Can use any hand in the first K rounds\n            \n            if T[i - 1] == 'r' and j == 0:  # Rock\n                dp[i][j] += R\n            elif T[i - 1] == 's' and j == 1:  # Scissors\n                dp[i][j] += S\n            elif T[i - 1] == 'p' and j == 2:  # Paper\n                dp[i][j] += P\n\n    return max(dp[N])\n\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nN, K = map(int, data[0].split())\nR, S, P = map(int, data[1].split())\nT = data[2]\n\nprint(max_score(N, K, R, S, P, T))"}
{"solution": "def max_good_string_length(a, b, c):\n    # Calculate the maximum length of the good string\n    if a > b:\n        a, b = b, a  # Ensure a <= b\n\n    # Use all 'ab' strings\n    length = c * 2\n    \n    # After using 'ab' strings, we can use the remaining 'a' and 'b'\n    remaining_a = a\n    remaining_b = b - c\n    \n    if remaining_b < 0:\n        remaining_b = 0\n    \n    # We can use pairs of remaining 'a' and 'b'\n    pairs = min(remaining_a, remaining_b)\n    length += pairs * 2\n    \n    # If there's an extra 'a' or 'b' left, we can add one more character\n    if remaining_a > pairs or remaining_b > pairs:\n        length += 1\n    \n    return length\n\n# Input reading\na, b, c = map(int, input().split())\n# Output the result\nprint(max_good_string_length(a, b, c))"}
{"solution": "def can_achieve_marks(n, k, p, x, y, marks):\n    current_sum = sum(marks)\n    remaining_tests = n - k\n    required_median_position = (n // 2) + 1\n    current_marks = sorted(marks)\n\n    # Calculate how many marks need to be at least y to achieve the median requirement\n    count_y_or_more = sum(1 for mark in current_marks if mark >= y)\n    needed_y_marks = max(0, required_median_position - count_y_or_more)\n\n    # If we need more marks than we can fill, return -1\n    if needed_y_marks > remaining_tests:\n        return -1\n\n    # Calculate the total sum if we fill the remaining tests with the minimum marks\n    total_marks = current_sum + needed_y_marks * y + (remaining_tests - needed_y_marks) * 1\n\n    # Check if the total marks exceed x\n    if total_marks > x:\n        return -1\n\n    # Prepare the result marks\n    result_marks = [y] * needed_y_marks + [1] * (remaining_tests - needed_y_marks)\n    return result_marks\n\n# Read input\nn, k, p, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Get the result\nresult = can_achieve_marks(n, k, p, x, y, marks)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def is_berlanese(s):\n    vowels = {'a', 'o', 'u', 'i', 'e'}\n    n = len(s)\n    \n    for i in range(n):\n        if s[i] not in vowels:  # If it's a consonant\n            if s[i] != 'n':  # If it's not 'n'\n                if i + 1 >= n or s[i + 1] not in vowels:  # Check next character\n                    return \"NO\"\n    return \"YES\"\n\ns = input().strip()\nprint(is_berlanese(s))"}
{"solution": "def max_dominoes(n, m, edges):\n    from itertools import combinations\n    \n    # Create a graph representation\n    graph = {i: [] for i in range(1, n + 1)}\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # All possible dominoes\n    dominoes = [(i, j) for i in range(1, 7) for j in range(i, 7)]\n    \n    def can_place(domino_count, used_dominoes):\n        # Check if we can place the dominoes according to the rules\n        vertex_dots = {}\n        for (u, v) in edges:\n            if domino_count[u] and domino_count[v]:\n                d1, d2 = domino_count[u], domino_count[v]\n                if d1 != d2:\n                    return False\n            if u in vertex_dots:\n                if vertex_dots[u] != domino_count[u]:\n                    return False\n            else:\n                vertex_dots[u] = domino_count[u]\n            if v in vertex_dots:\n                if vertex_dots[v] != domino_count[v]:\n                    return False\n            else:\n                vertex_dots[v] = domino_count[v]\n        return True\n\n    max_count = 0\n    for k in range(1 << len(dominoes)):\n        domino_count = {}\n        used_dominoes = set()\n        for i in range(len(dominoes)):\n            if k & (1 << i):\n                d1, d2 = dominoes[i]\n                for u, v in edges:\n                    if (u, v) not in used_dominoes and (v, u) not in used_dominoes:\n                        domino_count[u] = d1\n                        domino_count[v] = d2\n                        used_dominoes.add((u, v))\n                        break\n        if can_place(domino_count, used_dominoes):\n            max_count = max(max_count, len(used_dominoes))\n    \n    return max_count\n\n# Input reading\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output the result\nprint(max_dominoes(n, m, edges))"}
{"solution": "def max_points(n, m, prices, auction_indices):\n    auction_prices = [prices[i - 1] for i in auction_indices]\n    regular_prices = [prices[i] for i in range(n) if (i + 1) not in auction_indices]\n\n    # Sort auction prices in descending order\n    auction_prices.sort(reverse=True)\n    # Sort regular prices in descending order\n    regular_prices.sort(reverse=True)\n\n    # Calculate the total points\n    total_points = 0\n\n    # First, answer all auction questions\n    for price in auction_prices:\n        total_points += price * 2  # Correct answer gives points equal to the price\n\n    # Then, answer all regular questions\n    for price in regular_prices:\n        total_points += price  # Correct answer gives points equal to the price\n\n    return total_points\n\n# Read input\nn, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauction_indices = list(map(int, input().split()))\n\n# Calculate and print the maximum points\nresult = max_points(n, m, prices, auction_indices)\nprint(result)"}
{"solution": "def calculate_score(m, w, h_s, h_u):\n    max_points = [500, 1000, 1500, 2000, 2500]\n    total_score = 0\n\n    for i in range(5):\n        x = max_points[i]\n        m_i = m[i]\n        w_i = w[i]\n        score_i = max(0.3 * x, (1 - m_i / 250) * x - 50 * w_i)\n        total_score += score_i\n\n    total_score += 100 * h_s\n    total_score -= 50 * h_u\n\n    return int(total_score)\n\n# Input reading\nm = list(map(int, input().split()))\nw = list(map(int, input().split()))\nh_s, h_u = map(int, input().split())\n\n# Calculate and print the final score\nfinal_score = calculate_score(m, w, h_s, h_u)\nprint(final_score)"}
{"solution": "def count_valid_grids(n, m, L, R):\n    MOD = 998244353\n    \n    # Total number of cells\n    total_cells = n * m\n    \n    # The minimum and maximum possible heights\n    min_height = L * total_cells\n    max_height = R * total_cells\n    \n    # The number of valid heights that can be achieved\n    valid_heights = (max_height - min_height) // total_cells + 1\n    \n    # The result should be valid_heights modulo MOD\n    return valid_heights % MOD\n\n# Read input\nn, m, L, R = map(int, input().split())\n# Calculate and print the result\nprint(count_valid_grids(n, m, L, R))"}
{"solution": "def is_possible(n, m, matrix_a, matrix_b):\n    for i in range(n):\n        for j in range(m):\n            # Get the values from both matrices at position (i, j)\n            a_val = matrix_a[i][j]\n            b_val = matrix_b[i][j]\n            # We need to ensure that the minimum value is at the current position\n            # and the maximum value is at the next position in the row and column\n            if i > 0:\n                if not (min(a_val, b_val) > min(matrix_a[i-1][j], matrix_b[i-1][j])):\n                    return \"Impossible\"\n            if j > 0:\n                if not (min(a_val, b_val) > min(matrix_a[i][j-1], matrix_b[i][j-1])):\n                    return \"Impossible\"\n            if i < n - 1:\n                if not (max(a_val, b_val) < min(matrix_a[i+1][j], matrix_b[i+1][j])):\n                    return \"Impossible\"\n            if j < m - 1:\n                if not (max(a_val, b_val) < min(matrix_a[i][j+1], matrix_b[i][j+1])):\n                    return \"Impossible\"\n    return \"Possible\"\n\n# Read input\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\nmatrix_b = [list(map(int, input().split())) for _ in range(n)]\n\n# Check if it's possible to make both matrices increasing\nresult = is_possible(n, m, matrix_a, matrix_b)\nprint(result)"}
{"solution": "def max_length_string(n, a):\n    a.sort(reverse=True)\n    used_counts = set()\n    total_length = 0\n\n    for count in a:\n        while count > 0 and count in used_counts:\n            count -= 1\n        if count > 0:\n            used_counts.add(count)\n            total_length += count\n\n    return total_length\n\nn = int(input())\na = list(map(int, input().split()))\nresult = max_length_string(n, a)\nprint(result)"}
{"solution": "def min_problems_to_solve(n, k, difficulties):\n    difficulties.sort()\n    count = 0\n    for difficulty in difficulties:\n        if k < difficulty / 2:\n            # We need to solve a problem with difficulty at least difficulty / 2\n            # Find the minimum difficulty we can solve\n            while k < difficulty / 2:\n                k *= 2  # Solve a problem with difficulty k\n                count += 1\n        # Now we can solve the current problem\n        k = max(k, difficulty)  # Update k to the maximum difficulty solved\n    return count\n\n# Input reading\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Output the result\nprint(min_problems_to_solve(n, k, difficulties))"}
{"solution": "n = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\n# Start with the minimum required diplomas\nd1 = min_1\nd2 = min_2\nd3 = min_3\n\n# Calculate the remaining diplomas to distribute\nremaining = n - (d1 + d2 + d3)\n\n# Try to maximize the first degree diplomas\nif remaining > 0:\n    additional_1 = min(max_1 - d1, remaining)\n    d1 += additional_1\n    remaining -= additional_1\n\n# Try to maximize the second degree diplomas\nif remaining > 0:\n    additional_2 = min(max_2 - d2, remaining)\n    d2 += additional_2\n    remaining -= additional_2\n\n# The rest goes to the third degree diplomas\nd3 += remaining\n\nprint(d1, d2, d3)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(-1)\nelse:\n    last = a[-1]\n    second_last = a[-2]\n\n    if last == 0:\n        print(\"UP\")\n    elif last == 15:\n        print(\"DOWN\")\n    elif last > second_last:\n        print(\"UP\")\n    elif last < second_last:\n        print(\"DOWN\")\n    else:\n        print(-1)"}
{"solution": "def can_transform(s, t):\n    if len(s) != len(t):\n        return \"No\"\n    \n    vowels = set('aeiou')\n    \n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels) != (char_t in vowels):\n            return \"No\"\n    \n    return \"Yes\"\n\ns = input().strip()\nt = input().strip()\nprint(can_transform(s, t))"}
{"solution": "def pawn_chess_winner(board):\n    white_positions = []\n    black_positions = []\n    \n    for r in range(8):\n        for c in range(8):\n            if board[r][c] == 'W':\n                white_positions.append(r)\n            elif board[r][c] == 'B':\n                black_positions.append(r)\n    \n    # Calculate the minimum moves for player A (white) to reach row 1\n    min_white_moves = min(white_positions) if white_positions else float('inf')\n    # Calculate the minimum moves for player B (black) to reach row 8\n    min_black_moves = 8 - max(black_positions) if black_positions else float('inf')\n    \n    if min_white_moves <= min_black_moves:\n        return 'A'\n    else:\n        return 'B'\n\n# Read the board input\nboard = [input().strip() for _ in range(8)]\nprint(pawn_chess_winner(board))"}
{"solution": "def max_equal_length(n, A, m, B):\n    from collections import defaultdict\n\n    def get_prefix_sums(arr):\n        prefix_sums = []\n        current_sum = 0\n        for num in arr:\n            current_sum += num\n            if not prefix_sums or prefix_sums[-1] != current_sum:\n                prefix_sums.append(current_sum)\n        return prefix_sums\n\n    prefix_A = get_prefix_sums(A)\n    prefix_B = get_prefix_sums(B)\n\n    count_A = defaultdict(int)\n    count_B = defaultdict(int)\n\n    for sum_A in prefix_A:\n        count_A[sum_A] += 1\n\n    for sum_B in prefix_B:\n        count_B[sum_B] += 1\n\n    max_length = 0\n    for sum_value in count_A:\n        if sum_value in count_B:\n            max_length = max(max_length, count_A[sum_value] + count_B[sum_value])\n\n    return max_length if max_length > 0 else -1\n\n# Input reading\nn = int(input().strip())\nA = list(map(int, input().strip().split()))\nm = int(input().strip())\nB = list(map(int, input().strip().split()))\n\n# Output the result\nprint(max_equal_length(n, A, m, B))"}
{"solution": "def is_problem_from_contest(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    count = 0\n    \n    for friend in friends:\n        count += problem_name.count(friend)\n    \n    return \"YES\" if count == 1 else \"NO\"\n\nproblem_name = input().strip()\nprint(is_problem_from_contest(problem_name))"}
{"solution": "def sieve_of_eratosthenes(n):\n    is_prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (is_prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n    is_prime[0], is_prime[1] = False, False\n    return is_prime\n\ndef min_length(a, b, k):\n    is_prime = sieve_of_eratosthenes(b)\n    prime_count = [0] * (b + 1)\n\n    for i in range(1, b + 1):\n        prime_count[i] = prime_count[i - 1] + (1 if is_prime[i] else 0)\n\n    for l in range(1, b - a + 2):\n        valid = True\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] < k:\n                valid = False\n                break\n        if valid:\n            return l\n\n    return -1\n\na, b, k = map(int, input().split())\nprint(min_length(a, b, k))"}
{"solution": "def minimum_x(a, h, w):\n    # Check if it's possible to place at least one photo\n    if a > h or a > w:\n        return -1\n    \n    # Calculate the maximum number of photos that can fit in height and width\n    max_rows = h // a\n    max_cols = w // a\n    \n    # If we can fit at least one photo in both dimensions\n    if max_rows == 0 or max_cols == 0:\n        return -1\n    \n    # Calculate the remaining space after placing the photos\n    remaining_height = h - (max_rows * a)\n    remaining_width = w - (max_cols * a)\n    \n    # Calculate the minimum x\n    x_height = remaining_height / (max_rows + 1)\n    x_width = remaining_width / (max_cols + 1)\n    \n    return min(x_height, x_width)\n\n# Input reading\na, h, w = map(int, input().split())\nresult = minimum_x(a, h, w)\n\n# Output the result\nprint(f\"{result:.10f}\")"}
{"solution": "n = int(input())\nchapters = [tuple(map(int, input().split())) for _ in range(n)]\nk = int(input())\n\nunread_chapters = 0\n\nfor l, r in chapters:\n    if k <= r:\n        unread_chapters += 1\n\nprint(unread_chapters)"}
{"solution": "def can_form_codeforces(banner):\n    target = \"CODEFORCES\"\n    n = len(banner)\n    m = len(target)\n\n    # Check all possible ways to cut the substring\n    for i in range(m + 1):\n        # Take the first i characters from target and the last (m - i) characters\n        prefix = target[:i]\n        suffix = target[i:]\n        \n        # Check if the prefix and suffix can be found in the banner\n        if banner.startswith(prefix) and banner.endswith(suffix):\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nbanner = input().strip()\n# Output the result\nprint(can_form_codeforces(banner))"}
{"solution": "def min_triangulation_weight(n):\n    # Create a DP table to store the minimum weights\n    dp = [[0] * n for _ in range(n)]\n    \n    # Fill the DP table\n    for length in range(2, n):  # length of the polygon side\n        for i in range(n - length):\n            j = i + length\n            dp[i][j] = float('inf')\n            for k in range(i + 1, j):\n                weight = (i + 1) * (k + 1) * (j + 1)  # weight of triangle (i, k, j)\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + weight)\n    \n    return dp[0][n - 1]\n\nn = int(input())\nprint(min_triangulation_weight(n))"}
{"solution": "def count_digits(n):\n    digits = 0\n    length = 1\n    current_limit = 10\n    \n    while n >= current_limit:\n        digits += length * (current_limit - (current_limit // 10))\n        length += 1\n        current_limit *= 10\n    \n    digits += length * (n - (current_limit // 10) + 1)\n    \n    return digits\n\nn = int(input())\nprint(count_digits(n))"}
{"solution": "def find_winning_color(n, A, cars):\n    count_A = 0\n    count_B = {}\n    \n    for car in cars:\n        if car == A:\n            count_A += 1\n        else:\n            if car not in count_B:\n                count_B[car] = 0\n            count_B[car] += 1\n            \n    for B, count_b in count_B.items():\n        if count_b >= count_A:\n            # Check if Bob can maintain the condition cnt_B(i) >= cnt_A(i) for all i\n            cnt_A_temp = 0\n            cnt_B_temp = 0\n            valid = True\n            \n            for car in cars:\n                if car == A:\n                    cnt_A_temp += 1\n                elif car == B:\n                    cnt_B_temp += 1\n                \n                if cnt_B_temp < cnt_A_temp:\n                    valid = False\n                    break\n            \n            if valid:\n                return B\n    \n    return -1\n\n# Input reading\nn, A = map(int, input().split())\ncars = list(map(int, input().split()))\n\n# Finding the winning color for Bob\nresult = find_winning_color(n, A, cars)\nprint(result)"}
{"solution": "n, x = map(int, input().split())\na = list(map(int, input().split()))\n\ntotal_length = sum(a) + (n - 1)  # total length of segments + gaps between them\n\nif total_length == x:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n, S = map(int, input().split())\nmin_coins = (S + n - 1) // n\nprint(min_coins)"}
{"solution": "def smallest_palindrome(s):\n    from collections import Counter\n\n    # Count frequency of each character\n    count = Counter(s)\n    \n    # Prepare to build the palindrome\n    half_palindrome = []\n    odd_char = None\n    \n    # Create half of the palindrome\n    for char in sorted(count.keys()):\n        if count[char] % 2 == 1:\n            if odd_char is None or char < odd_char:\n                if odd_char is not None:\n                    half_palindrome.append(odd_char)\n                odd_char = char\n            else:\n                half_palindrome.append(char)\n        half_palindrome.extend([char] * (count[char] // 2))\n    \n    # Create the first half of the palindrome\n    half_palindrome.sort()\n    first_half = ''.join(half_palindrome)\n    \n    # Create the second half of the palindrome\n    second_half = first_half[::-1]\n    \n    # If there's an odd character, add it in the middle\n    if odd_char:\n        palindrome = first_half + odd_char + second_half\n    else:\n        palindrome = first_half + second_half\n    \n    return palindrome\n\ns = input().strip()\nprint(smallest_palindrome(s))"}
{"solution": "def calculate_weight(board):\n    weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n    }\n    \n    white_weight = 0\n    black_weight = 0\n    \n    for row in board:\n        for piece in row:\n            if piece in weights:\n                if piece.isupper():\n                    white_weight += weights[piece]\n                else:\n                    black_weight += weights[piece]\n    \n    if white_weight > black_weight:\n        return \"White\"\n    elif black_weight > white_weight:\n        return \"Black\"\n    else:\n        return \"Draw\"\n\nboard = [input().strip() for _ in range(8)]\nresult = calculate_weight(board)\nprint(result)"}
{"solution": "from collections import deque\n\ndef sugoroku(N, M, S):\n    # BFS initialization\n    queue = deque([(0, [])])  # (current square, path)\n    visited = [False] * (N + 1)\n    visited[0] = True\n    \n    while queue:\n        current_square, path = queue.popleft()\n        \n        # Try all possible moves from current square\n        for move in range(1, M + 1):\n            next_square = current_square + move\n            \n            if next_square > N:\n                continue  # Out of bounds\n            if S[next_square] == '1':\n                continue  # Game Over Square\n            if visited[next_square]:\n                continue  # Already visited\n            \n            # Mark as visited\n            visited[next_square] = True\n            \n            # Create new path\n            new_path = path + [move]\n            \n            if next_square == N:\n                return new_path  # Found a valid path to N\n            \n            queue.append((next_square, new_path))\n    \n    return -1  # No valid path found\n\n# Read input\nN, M = map(int, input().split())\nS = input().strip()\n\n# Get the result\nresult = sugoroku(N, M, S)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def can_finish_game(K, X, Y):\n    # Calculate the Manhattan distance to the target\n    manhattan_distance = abs(X) + abs(Y)\n    \n    # Check if the game can be finished\n    if manhattan_distance % K != 0 or manhattan_distance < K:\n        return -1\n    \n    # Calculate the number of strokes needed\n    strokes = manhattan_distance // K\n    \n    # If the number of strokes is odd and K is even or vice versa, we need one extra stroke\n    if (strokes % 2) != (manhattan_distance % K == 0):\n        strokes += 1\n    \n    # Generate the path\n    path = []\n    current_x, current_y = 0, 0\n    \n    for _ in range(strokes):\n        if abs(current_x - X) + abs(current_y - Y) >= K:\n            if abs(X) > abs(Y):\n                if X > current_x:\n                    current_x += K\n                else:\n                    current_x -= K\n            else:\n                if Y > current_y:\n                    current_y += K\n                else:\n                    current_y -= K\n        else:\n            # Move directly towards the target\n            if current_x < X:\n                current_x += min(K, X - current_x)\n            elif current_x > X:\n                current_x -= min(K, current_x - X)\n            if current_y < Y:\n                current_y += min(K, Y - current_y)\n            elif current_y > Y:\n                current_y -= min(K, current_y - Y)\n        \n        path.append((current_x, current_y))\n    \n    return strokes, path\n\nimport sys\ninput = sys.stdin.read\nK, X, Y = map(int, input().strip().split())\n\nresult = can_finish_game(K, X, Y)\n\nif result == -1:\n    print(-1)\nelse:\n    strokes, path = result\n    print(strokes)\n    for x, y in path:\n        print(x, y)"}
{"solution": "def find_min_n(m):\n    if m == 1:\n        return 8\n    \n    count = 0\n    n = 0\n    \n    for k in range(2, 10**6):\n        total = 0\n        current = 1\n        while current <= 10**15:\n            total += 1\n            current *= k\n        \n        if total > 4:\n            ways = (total - 4) * (total - 3) * (total - 2) // 6\n            if ways == m:\n                n = max(n, (k**4 - 1) // (k - 1))\n                count += 1\n    \n    return n if count > 0 else -1\n\nm = int(input().strip())\nprint(find_min_n(m))"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\n    if d >= r1 + r2:\n        return 0.0\n    if d <= abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n\n    r1_sq = r1 ** 2\n    r2_sq = r2 ** 2\n\n    part1 = r1_sq * math.acos((d ** 2 + r1_sq - r2_sq) / (2 * d * r1))\n    part2 = r2_sq * math.acos((d ** 2 + r2_sq - r1_sq) / (2 * d * r2))\n    part3 = 0.5 * math.sqrt((-d + r1 + r2) * (d + r1 - r2) * (d - r1 + r2) * (d + r1 + r2))\n\n    return part1 + part2 - part3\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\narea = circle_intersection_area(x1, y1, r1, x2, y2, r2)\nprint(f\"{area:.20f}\")"}
{"solution": "def min_value_after_operations(v):\n    if v == 1:\n        return 1\n    # The minimum value of n we can achieve is 1\n    return 1\n\nv = int(input())\nprint(min_value_after_operations(v))"}
{"solution": "def main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    p = list(map(int, data[1:n]))\n    a = list(map(int, data[n:2*n]))\n\n    # Build the tree structure\n    tree = defaultdict(list)\n    for i in range(2, n + 1):\n        tree[p[i - 2]].append(i)\n\n    # To store the maximum citizens that can be caught\n    def dfs(node):\n        total_citizens = a[node - 1]\n        children_citizens = []\n        \n        for child in tree[node]:\n            child_citizens = dfs(child)\n            children_citizens.append(child_citizens)\n        \n        if not children_citizens:\n            return total_citizens\n        \n        # Sort children by the number of citizens they can catch\n        children_citizens.sort(reverse=True)\n        \n        # Citizens can be distributed among children\n        for i in range(len(children_citizens)):\n            if total_citizens > 0:\n                total_citizens += children_citizens[i]\n            else:\n                break\n        \n        return total_citizens\n\n    result = dfs(1)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_possible_words(n, S, T):\n    count = 0\n    for i in range(n):\n        if S[i] != T[i]:\n            # Check the two possible positions for the missing character\n            if S[i+1:] == T[i:] or S[i:] == T[i+1:]:\n                count += 1\n            break\n    else:\n        # If we didn't break, it means S and T are the same until the last character\n        count += 1  # The last character can be anything different from S[n-1] or T[n-1]\n    \n    return count\n\nn = int(input().strip())\nS = input().strip()\nT = input().strip()\n\nresult = count_possible_words(n, S, T)\nprint(result)"}
{"solution": "def min_computer_strength(n, strengths, edges):\n    from collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    max_strength = max(strengths)\n    min_strength = max_strength\n\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n\n    for i in range(1, n + 1):\n        bfs(i)\n        if strengths[i - 1] > min_strength:\n            min_strength = strengths[i - 1]\n\n    return min_strength\n\n# Input reading\nn = int(input())\nstrengths = list(map(int, input().split()))\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Output the result\nprint(min_computer_strength(n, strengths, edges))"}
{"solution": "def max_groups(n, m):\n    if m == 0:\n        return 1\n    elif m >= n:\n        return 0\n    else:\n        return min(m, n - m)\n\nn, m = map(int, input().split())\nprint(max_groups(n, m))"}
{"solution": "k, r = map(int, input().split())\n\nfor n in range(1, 11):\n    total_cost = n * k\n    if total_cost % 10 == 0 or total_cost % 10 == r:\n        print(n)\n        break"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                if i < min_row:\n                    min_row = i\n                if i > max_row:\n                    max_row = i\n                if j < min_col:\n                    min_col = j\n                if j > max_col:\n                    max_col = j\n    \n    # Calculate the dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Count the number of 'X' in the bounding box\n    count_x = 0\n    for i in range(min_row, max_row + 1):\n        for j in range(min_col, max_col + 1):\n            if grid[i][j] == 'X':\n                count_x += 1\n    \n    # Check if the number of 'X' matches the area of the bounding box\n    if count_x == height * width:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "def min_segments(points):\n    x_coords = {p[0] for p in points}\n    y_coords = {p[1] for p in points}\n    \n    if len(x_coords) == 1 or len(y_coords) == 1:\n        return 1\n    elif len(x_coords) == 2 and len(y_coords) == 2:\n        return 2\n    else:\n        return 3\n\npoints = [tuple(map(int, input().split())) for _ in range(3)]\nprint(min_segments(points))"}
{"solution": "def k_regular_graph_with_bridge(k):\n    if k == 1:\n        print(\"YES\")\n        print(2, 1)\n        print(1, 2)\n        return\n    \n    if k % 2 == 1 or k > 2 * 10**6:\n        print(\"NO\")\n        return\n    \n    n = k + 1\n    edges = []\n    \n    for i in range(1, n):\n        edges.append((i, i + 1))\n    \n    edges.append((n, 1))\n    \n    for i in range(1, n - 1):\n        edges.append((i, n))\n    \n    print(\"YES\")\n    print(n, len(edges))\n    for a, b in edges:\n        print(a, b)\n\nk = int(input().strip())\nk_regular_graph_with_bridge(k)"}
{"solution": "def count_occurrences(s, t, queries):\n    n = len(s)\n    m = len(t)\n    \n    # Precompute occurrences of t in s\n    occurrences = [0] * (n + 1)\n    \n    for i in range(n - m + 1):\n        if s[i:i + m] == t:\n            occurrences[i + 1] = 1\n    \n    # Create a prefix sum array\n    for i in range(1, n + 1):\n        occurrences[i] += occurrences[i - 1]\n    \n    results = []\n    for l, r in queries:\n        if r - l + 1 < m:\n            results.append(0)\n        else:\n            results.append(occurrences[r - m + 1] - occurrences[l - 1])\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, m, q = map(int, data[0].split())\ns = data[1]\nt = data[2]\nqueries = [tuple(map(int, line.split())) for line in data[3:]]\n\n# Get results\nresults = count_occurrences(s, t, queries)\n\n# Print results\nfor result in results:\n    print(result)"}
{"solution": "def count_paths(n, k, d):\n    MOD = 1000000007\n    \n    # dp[i] will store the number of ways to reach weight i without the restriction of d\n    dp = [0] * (n + 1)\n    dp[0] = 1  # There's one way to have a path of weight 0 (the empty path)\n    \n    # Calculate the number of ways to reach each weight from 1 to n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if i - j >= 0:\n                dp[i] = (dp[i] + dp[i - j]) % MOD\n    \n    # total_paths is the number of ways to reach weight n\n    total_paths = dp[n]\n    \n    # Now we need to calculate the number of ways to reach weight n without using any edge of weight >= d\n    dp_no_d = [0] * (n + 1)\n    dp_no_d[0] = 1  # There's one way to have a path of weight 0 (the empty path)\n    \n    # Calculate the number of ways to reach each weight from 1 to n without using edges of weight >= d\n    for i in range(1, n + 1):\n        for j in range(1, d):  # Only consider edges of weight < d\n            if i - j >= 0:\n                dp_no_d[i] = (dp_no_d[i] + dp_no_d[i - j]) % MOD\n    \n    # paths_with_d is the number of ways to reach weight n using at least one edge of weight >= d\n    paths_with_d = (total_paths - dp_no_d[n] + MOD) % MOD\n    \n    return paths_with_d\n\n# Read input\nn, k, d = map(int, input().split())\n# Get the result\nresult = count_paths(n, k, d)\n# Print the result\nprint(result)"}
{"solution": "n = int(input().strip())\nrow = input().strip()\n\ngroups = []\ncount = 0\n\nfor char in row:\n    if char == 'B':\n        count += 1\n    else:\n        if count > 0:\n            groups.append(count)\n            count = 0\n\nif count > 0:\n    groups.append(count)\n\nprint(len(groups))\nif groups:\n    print(' '.join(map(str, groups)))"}
{"solution": "def find_pair(brackets):\n    stack = []\n    pairs = {}\n    for i, char in enumerate(brackets):\n        if char == '(':\n            stack.append(i)\n        else:\n            if stack:\n                opening_index = stack.pop()\n                pairs[opening_index] = i\n                pairs[i] = opening_index\n    return pairs\n\ndef process_editor(n, m, p, brackets, operations):\n    pairs = find_pair(brackets)\n    cursor = p - 1  # Convert to 0-based index\n    deleted = [False] * n\n\n    for operation in operations:\n        if operation == 'L':\n            cursor -= 1\n        elif operation == 'R':\n            cursor += 1\n        elif operation == 'D':\n            start = cursor\n            end = pairs[cursor]\n            if start > end:\n                start, end = end, start\n            for i in range(start, end + 1):\n                deleted[i] = True\n            \n            # Move cursor to the nearest non-deleted bracket\n            next_cursor = cursor + 1\n            while next_cursor < n and deleted[next_cursor]:\n                next_cursor += 1\n            if next_cursor >= n:\n                next_cursor = cursor - 1\n                while next_cursor >= 0 and deleted[next_cursor]:\n                    next_cursor -= 1\n            cursor = next_cursor\n\n    result = ''.join(brackets[i] for i in range(n) if not deleted[i])\n    return result\n\n# Input reading\nn, m, p = map(int, input().split())\nbrackets = input().strip()\noperations = input().strip()\n\n# Process and output the result\nresult = process_editor(n, m, p, brackets, operations)\nprint(result)"}
{"solution": "def find_y(n, questions):\n    lower_bound = -2 * 10**9\n    upper_bound = 2 * 10**9\n\n    for sign, x, answer in questions:\n        x = int(x)\n        if sign == '>':\n            if answer == 'Y':\n                lower_bound = max(lower_bound, x + 1)\n            else:  # answer == 'N'\n                upper_bound = min(upper_bound, x)\n        elif sign == '<':\n            if answer == 'Y':\n                upper_bound = min(upper_bound, x - 1)\n            else:  # answer == 'N'\n                lower_bound = max(lower_bound, x)\n        elif sign == '>=':\n            if answer == 'Y':\n                lower_bound = max(lower_bound, x)\n            else:  # answer == 'N'\n                upper_bound = min(upper_bound, x - 1)\n        elif sign == '<=':\n            if answer == 'Y':\n                upper_bound = min(upper_bound, x)\n            else:  # answer == 'N'\n                lower_bound = max(lower_bound, x + 1)\n\n    if lower_bound <= upper_bound:\n        return lower_bound\n    else:\n        return \"Impossible\"\n\n# Input reading\nn = int(input())\nquestions = [input().split() for _ in range(n)]\nresult = find_y(n, questions)\nprint(result)"}
{"solution": "def count_different_periods(a, b):\n    # The maximum period can be a + b\n    max_period = a + b\n    # The minimum period can be the maximum of a and b\n    min_period = max(a, b)\n    \n    # The number of different periods is the range from min_period to max_period\n    return max_period - min_period + 1\n\n# Read input\na, b = map(int, input().split())\n# Calculate and print the result\nprint(count_different_periods(a, b))"}
{"solution": "def find_soldier_names(n, k, effectiveness):\n    names = [\"\"] * n\n    unique_names = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"]\n    \n    for i in range(n - k + 1):\n        if effectiveness[i] == \"YES\":\n            # Ensure all names in the current window are unique\n            for j in range(k):\n                names[i + j] = unique_names[j]\n        else:\n            # If it's \"NO\", we need to ensure at least one name is repeated\n            if i > 0:\n                # Copy the last name from the previous window\n                names[i] = names[i - 1]\n            else:\n                # If it's the first window, just use the first name\n                names[i] = unique_names[0]\n    \n    # Fill in any remaining names\n    for i in range(n):\n        if names[i] == \"\":\n            names[i] = unique_names[0]\n    \n    return names\n\n# Read input\nn, k = map(int, input().split())\neffectiveness = input().split()\n\n# Get the soldier names\nresult = find_soldier_names(n, k, effectiveness)\n\n# Print the result\nprint(\" \".join(result))"}
{"solution": "def min_operations_to_equal(a, b):\n    if a == b:\n        return 0\n\n    def reduce(n):\n        operations = 0\n        while n % 2 == 0:\n            n //= 2\n            operations += 1\n        while n % 3 == 0:\n            n //= 3\n            operations += 1\n        while n % 5 == 0:\n            n //= 5\n            operations += 1\n        return n, operations\n\n    reduced_a, ops_a = reduce(a)\n    reduced_b, ops_b = reduce(b)\n\n    if reduced_a != reduced_b:\n        return -1\n\n    return ops_a + ops_b\n\na, b = map(int, input().split())\nprint(min_operations_to_equal(a, b))"}
{"solution": "def min_cost_palindrome(n, a, b, colors):\n    cost = 0\n    for i in range((n + 1) // 2):\n        left = colors[i]\n        right = colors[n - 1 - i]\n        \n        if left == 2 and right == 2:\n            cost += 2 * min(a, b)  # Buy both suits\n        elif left == 2:\n            if right == 0:\n                cost += a  # Buy white for left\n            else:\n                cost += b  # Buy black for left\n        elif right == 2:\n            if left == 0:\n                cost += a  # Buy white for right\n            else:\n                cost += b  # Buy black for right\n        elif left != right:\n            return -1  # Cannot form a palindrome\n    \n    return cost\n\n# Read input\nn, a, b = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = min_cost_palindrome(n, a, b, colors)\nprint(result)"}
{"solution": "def paint_cube(k):\n    if k == 1:\n        print(-1)\n        return\n    \n    cube = [[['' for _ in range(k)] for _ in range(k)] for _ in range(k)]\n    \n    for z in range(k):\n        for x in range(k):\n            for y in range(k):\n                if (x + y + z) % 2 == 0:\n                    cube[z][x][y] = 'b'\n                else:\n                    cube[z][x][y] = 'w'\n    \n    for z in range(k):\n        for x in range(k):\n            print(''.join(cube[z][x]))\n        if z < k - 1:\n            print()\n\nk = int(input().strip())\npaint_cube(k)"}
{"solution": "def largest_lovely_number(n):\n    # To find the largest lovely number, we need to remove all prime factors with exponent >= 2\n    lovely_number = 1\n    factor = 2\n    \n    while factor * factor <= n:\n        if n % factor == 0:\n            lovely_number *= factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    \n    if n > 1:\n        lovely_number *= n\n    \n    return lovely_number\n\nn = int(input())\nprint(largest_lovely_number(n))"}
{"solution": "n = int(input().strip())\nseating = input().strip()\n\n# Check for adjacent occupied seats\nfor i in range(n - 1):\n    if seating[i] == '1' and seating[i + 1] == '1':\n        print(\"No\")\n        break\nelse:\n    # Check if there's a possibility to add another person\n    for i in range(n):\n        if seating[i] == '0':\n            # Check if the seat is not adjacent to an occupied seat\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                print(\"No\")\n                break\n    else:\n        print(\"Yes\")"}
{"solution": "def find_possible_lengths(n, a):\n    possible_lengths = []\n    \n    for k in range(1, n + 1):\n        x = [0] * k\n        valid = True\n        \n        for i in range(n):\n            idx = i % k\n            if i == 0:\n                x[idx] = a[i]\n            else:\n                expected_value = a[i] - a[i - 1]\n                if x[idx] == 0:\n                    x[idx] = expected_value\n                elif x[idx] != expected_value:\n                    valid = False\n                    break\n        \n        if valid:\n            possible_lengths.append(k)\n    \n    return possible_lengths\n\nn = int(input())\na = list(map(int, input().split()))\n\npossible_lengths = find_possible_lengths(n, a)\n\nprint(len(possible_lengths))\nprint(\" \".join(map(str, possible_lengths)))"}
{"solution": "from itertools import combinations\n\ndef can_form_equal_teams(scores):\n    total_score = sum(scores)\n    \n    if total_score % 2 != 0:\n        return \"NO\"\n    \n    target = total_score // 2\n    for team in combinations(scores, 3):\n        if sum(team) == target:\n            return \"YES\"\n    \n    return \"NO\"\n\nscores = list(map(int, input().split()))\nprint(can_form_equal_teams(scores))"}
{"solution": "def count_2_3_integers(l, r):\n    count = 0\n    power_of_2 = 1\n    \n    while power_of_2 <= r:\n        power_of_3 = 1\n        while power_of_2 * power_of_3 <= r:\n            number = power_of_2 * power_of_3\n            if l <= number <= r:\n                count += 1\n            power_of_3 *= 3\n        power_of_2 *= 2\n    \n    return count\n\nl, r = map(int, input().split())\nprint(count_2_3_integers(l, r))"}
{"solution": "def candies_eaten(n, k):\n    # Let x be the number of candies eaten\n    # The total number of candies put in the box is the sum of the first (x + 1) natural numbers\n    # Total candies put = (x + 1) * (x + 2) / 2\n    # The final number of candies in the box is:\n    # Total candies put - x = k\n    # Therefore, we can derive the equation:\n    # (x + 1) * (x + 2) / 2 - x = k\n    # Rearranging gives us:\n    # (x + 1) * (x + 2) / 2 = k + x\n    # (x + 1) * (x + 2) = 2 * (k + x)\n    # x^2 + 3x + 2 = 2k + 2x\n    # x^2 + x + 2 - 2k = 0\n    # This is a quadratic equation in the form of ax^2 + bx + c = 0\n    # where a = 1, b = 1, c = 2 - 2k\n\n    a = 1\n    b = 1\n    c = 2 - 2 * k\n\n    # Using the quadratic formula to find x\n    discriminant = b * b - 4 * a * c\n    x = (-b + discriminant**0.5) / (2 * a)\n\n    return int(x)\n\nn, k = map(int, input().split())\nprint(candies_eaten(n, k))"}
{"solution": "def can_form_triangle(n, lengths):\n    lengths.sort()\n    for i in range(n - 2):\n        if lengths[i] + lengths[i + 1] > lengths[i + 2]:\n            return \"YES\"\n    return \"NO\"\n\nn = int(input())\nlengths = list(map(int, input().split()))\nprint(can_form_triangle(n, lengths))"}
{"solution": "def can_get_toys(x, y):\n    # Check if the number of original toys is at least 1\n    if y < 1:\n        return \"No\"\n    \n    # Calculate the maximum number of copies that can be generated\n    # The number of original toys must be at least y\n    # The number of copies must be at least (y - 1) * 2\n    if x < (y - 1) * 2:\n        return \"No\"\n    \n    # Check if the total number of toys (original + copies) is even\n    if (x + y) % 3 != 0:\n        return \"No\"\n    \n    # Check if the number of original toys is not more than the number of copies\n    if y > x + 1:\n        return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nx, y = map(int, input().split())\n# Print the result\nprint(can_get_toys(x, y))"}
{"solution": "def max_total_rating(n, k, skills):\n    total_rating = sum(skill // 10 for skill in skills)\n    improvements_needed = []\n    \n    for skill in skills:\n        next_threshold = (skill // 10 + 1) * 10\n        if next_threshold <= 100:\n            improvements_needed.append(next_threshold - skill)\n    \n    improvements_needed.sort()\n    \n    for needed in improvements_needed:\n        if k >= needed:\n            k -= needed\n            total_rating += 1\n        else:\n            break\n    \n    return total_rating\n\n# Input reading\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Output the result\nprint(max_total_rating(n, k, skills))"}
{"solution": "n, m = map(int, input().split())\nlist_a = set(input().split())\nlist_b = set(input().split())\n\n# Find the intersection of both lists\ncommon_digits = list_a.intersection(list_b)\n\nif common_digits:\n    # If there are common digits, the smallest pretty integer is the smallest common digit\n    print(min(common_digits))\nelse:\n    # If there are no common digits, form the smallest pretty integer\n    smallest_a = min(list_a)\n    smallest_b = min(list_b)\n    # The smallest pretty integer can be formed by combining the smallest digits from both lists\n    print(min(int(smallest_a + smallest_b), int(smallest_b + smallest_a)))"}
{"solution": "n, k = map(int, input().split())\ntotal_time = 240 - k  # Total time available for solving problems\n\ntime_spent = 0\nproblems_solved = 0\n\nfor i in range(1, n + 1):\n    time_spent += 5 * i\n    if time_spent <= total_time:\n        problems_solved += 1\n    else:\n        break\n\nprint(problems_solved)"}
{"solution": "def can_print(teams, x, y, mid):\n    needed_x = 0\n    needed_y = 0\n    \n    for pages in teams[:mid]:\n        if pages % 2 == 0:\n            needed_x += pages // 2\n        else:\n            needed_x += pages // 2\n            needed_y += 1\n    \n    needed_y += sum(1 for pages in teams[:mid] if pages % 2 == 1)\n    \n    return needed_x <= x and needed_y <= y\n\ndef max_teams(n, x, y, a):\n    left, right = 0, n\n    while left < right:\n        mid = (left + right + 1) // 2\n        if can_print(a, x, y, mid):\n            left = mid\n        else:\n            right = mid - 1\n    return left\n\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\nresult = max_teams(n, x, y, a)\nprint(result)"}
{"solution": "def count_different_numbers(b):\n    divisors = set()\n    for i in range(1, int(b**0.5) + 1):\n        if b % i == 0:\n            divisors.add(i)\n            divisors.add(b // i)\n    \n    return len(divisors)\n\nb = int(input())\nprint(count_different_numbers(b))"}
{"solution": "def count_falling_positions(n, bumpers):\n    count = 0\n    \n    # Check positions from the left\n    for i in range(n):\n        if bumpers[i] == '<':\n            count += 1\n        else:\n            break\n    \n    # Check positions from the right\n    for i in range(n - 1, -1, -1):\n        if bumpers[i] == '>':\n            count += 1\n        else:\n            break\n    \n    return count\n\n# Input reading\nn = int(input().strip())\nbumpers = input().strip()\n\n# Output the result\nprint(count_falling_positions(n, bumpers))"}
{"solution": "def max_rectangle_area(n, lengths):\n    from collections import Counter\n\n    # Count the occurrences of each length\n    count = Counter(lengths)\n    \n    # Prepare a list to store pairs of lengths that can form rectangles\n    pairs = []\n    \n    # Check for each length and its count\n    for length in sorted(count.keys()):\n        # Calculate how many pairs can be formed with the current length\n        pairs_count = count[length] // 2\n        if pairs_count > 0:\n            pairs.extend([length] * pairs_count)\n        \n        # Check if we can form pairs with the length reduced by 1\n        if length > 1:\n            reduced_length = length - 1\n            if reduced_length in count:\n                pairs_count = count[reduced_length] // 2\n                if pairs_count > 0:\n                    pairs.extend([reduced_length] * pairs_count)\n\n    # Now we have a list of lengths that can form pairs\n    area = 0\n    for i in range(0, len(pairs) - 1, 2):\n        area += pairs[i] * pairs[i + 1]\n\n    return area\n\n# Input reading\nn = int(input())\nlengths = list(map(int, input().split()))\n\n# Calculate and print the maximum total area\nprint(max_rectangle_area(n, lengths))"}
{"solution": "def min_sum_after_restoration(n, strings):\n    from collections import defaultdict\n\n    # To store the contribution of each letter\n    letter_value = defaultdict(int)\n    leading_letters = set()\n\n    # Calculate the contribution of each letter\n    for s in strings:\n        length = len(s)\n        for i, char in enumerate(s):\n            # The value of the letter is determined by its position\n            letter_value[char] += 10 ** (length - i - 1)\n            if i == 0:\n                leading_letters.add(char)\n\n    # Sort letters by their contribution in descending order\n    sorted_letters = sorted(letter_value.items(), key=lambda x: -x[1])\n    \n    # Assign digits to letters\n    digit_assignment = {}\n    used_digits = set()\n    \n    # Assign the first digit (1-9) to leading letters\n    digit = 1\n    for char, _ in sorted_letters:\n        if char in leading_letters:\n            digit_assignment[char] = digit\n            used_digits.add(digit)\n            digit += 1\n            break\n\n    # Assign remaining digits (0-9) to other letters\n    for char, _ in sorted_letters:\n        if char not in digit_assignment:\n            while digit in used_digits:\n                digit += 1\n            digit_assignment[char] = digit\n            used_digits.add(digit)\n            digit += 1\n\n    # Calculate the minimum sum\n    total_sum = 0\n    for s in strings:\n        number = 0\n        for char in s:\n            number = number * 10 + digit_assignment[char]\n        total_sum += number\n\n    return total_sum\n\n# Input reading\nn = int(input().strip())\nstrings = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(min_sum_after_restoration(n, strings))"}
{"solution": "def max_teams(n, m):\n    # The maximum number of teams is limited by the total number of participants divided by 3\n    # and also by the specific requirements of each team type.\n    return min((n + m) // 3, n, m // 2)\n\n# Read input\nn, m = map(int, input().split())\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def contains_non_overlapping_AB_BA(s):\n    ab_index = s.find(\"AB\")\n    ba_index = s.find(\"BA\")\n    \n    while ab_index != -1:\n        if ba_index != -1 and abs(ab_index - ba_index) > 1:\n            return \"YES\"\n        ab_index = s.find(\"AB\", ab_index + 1)\n    \n    while ba_index != -1:\n        if ab_index != -1 and abs(ba_index - ab_index) > 1:\n            return \"YES\"\n        ba_index = s.find(\"BA\", ba_index + 1)\n    \n    return \"NO\"\n\ns = input().strip()\nprint(contains_non_overlapping_AB_BA(s))"}
{"solution": "def can_eat_monsters(n, a, k, b):\n    from collections import deque\n\n    # Create a deque for the initial weights\n    queue = deque(a)\n    actions = []\n\n    # Process the final weights\n    for weight in b:\n        # While the current monster in the queue does not match the expected weight\n        while queue and queue[0] < weight:\n            # Try to find a monster that can eat the first monster in the queue\n            if len(queue) > 1 and queue[1] > queue[0]:\n                # The second monster eats the first monster\n                actions.append((1, 'L'))  # 1-based index\n                queue[1] += queue[0]\n                queue.popleft()\n            elif len(queue) > 1 and queue[-1] > queue[0]:\n                # The last monster eats the first monster\n                actions.append((1, 'R'))  # 1-based index\n                queue[-1] += queue[0]\n                queue.popleft()\n            else:\n                # If no monster can eat the first monster, return NO\n                return \"NO\"\n\n        # If the first monster matches the expected weight, remove it\n        if queue and queue[0] == weight:\n            queue.popleft()\n        else:\n            return \"NO\"\n\n    # If we successfully matched all weights, return YES and the actions\n    result = [\"YES\"]\n    result.extend(f\"{idx} {direction}\" for idx, direction in actions)\n    return \"\\n\".join(result)\n\n# Input reading\nn = int(input().strip())\na = list(map(int, input().strip().split()))\nk = int(input().strip())\nb = list(map(int, input().strip().split()))\n\n# Get the result\nresult = can_eat_monsters(n, a, k, b)\n\n# Print the result\nprint(result)"}
{"solution": "def do_intersect(p1, q1, p2, q2):\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def on_segment(p, q, r):\n        return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n                min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    return False\n\ndef can_assign_spaceships(R, B, spaceships, bases):\n    if R != B:\n        return False\n\n    for i in range(R):\n        for j in range(R):\n            if i != j:\n                for k in range(B):\n                    for l in range(B):\n                        if k != l:\n                            if do_intersect(spaceships[i], bases[k], spaceships[j], bases[l]):\n                                return False\n    return True\n\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nR, B = map(int, data[0].split())\nspaceships = [tuple(map(int, data[i + 1].split())) for i in range(R)]\nbases = [tuple(map(int, data[i + 1 + R].split())) for i in range(B)]\n\nif can_assign_spaceships(R, B, spaceships, bases):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmax_power_of_two = 1\ncount = 0\n\nfor number in a:\n    power = 1\n    while number % 2 == 0:\n        number //= 2\n        power *= 2\n    if power > max_power_of_two:\n        max_power_of_two = power\n\nfor number in a:\n    if number % max_power_of_two == 0:\n        count += 1\n\nprint(max_power_of_two, count)"}
{"solution": "def min_button_clicks(n, m):\n    clicks = 0\n    while n < m:\n        if m % 2 == 0:\n            m //= 2\n        else:\n            m += 1\n        clicks += 1\n    return clicks + (n - m)\n\nn, m = map(int, input().split())\nprint(min_button_clicks(n, m))"}
{"solution": "def is_tree(n, segments):\n    from collections import defaultdict, deque\n\n    # Create adjacency list for the graph\n    graph = defaultdict(list)\n\n    # Sort segments by their left endpoint\n    segments.sort()\n\n    # Build the graph based on the intersection criteria\n    active_segments = []\n    \n    for i in range(n):\n        l_i, r_i = segments[i]\n        \n        # Remove segments that end before the current segment starts\n        active_segments = [seg for seg in active_segments if seg[1] > l_i]\n        \n        # Check for intersections with active segments\n        for l_j, r_j in active_segments:\n            if not (r_i <= l_j or r_j <= l_i):  # They intersect\n                graph[i].append(segments.index((l_j, r_j)))\n                graph[segments.index((l_j, r_j))].append(i)\n        \n        # Add the current segment to the active list\n        active_segments.append((l_i, r_i))\n\n    # Check if the graph is connected and has exactly n-1 edges\n    visited = [False] * n\n    edge_count = 0\n\n    def bfs(start):\n        nonlocal edge_count\n        queue = deque([start])\n        visited[start] = True\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                edge_count += 1\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n\n    bfs(0)\n\n    # Each edge is counted twice in an undirected graph\n    edge_count //= 2\n\n    # A tree must have exactly n-1 edges and be connected\n    return edge_count == n - 1 and all(visited)\n\n# Input reading\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(\"YES\" if is_tree(n, segments) else \"NO\")"}
{"solution": "n = int(input())\nrequests = list(map(int, input().split()))\n\nmax_length = 0\n\nfor start in range(n):\n    total_requests = 0\n    for end in range(start, n):\n        total_requests += requests[end]\n        time_period = end - start + 1\n        if total_requests > 100 * time_period:\n            max_length = max(max_length, time_period)\n\nprint(max_length)"}
{"solution": "def can_dissatisfaction_be_exact(n, k, episodes):\n    # Count the maximum consecutive 'N's\n    max_consecutive_n = 0\n    current_consecutive_n = 0\n    \n    for episode in episodes:\n        if episode == 'N':\n            current_consecutive_n += 1\n        else:\n            max_consecutive_n = max(max_consecutive_n, current_consecutive_n)\n            current_consecutive_n = 0\n            \n    max_consecutive_n = max(max_consecutive_n, current_consecutive_n)\n    \n    # Count the number of '?' characters\n    question_marks = episodes.count('?')\n    \n    # Check if we can achieve exactly k dissatisfaction\n    if max_consecutive_n > k:\n        return \"NO\"\n    elif max_consecutive_n < k:\n        if question_marks > 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        return \"YES\"\n\n# Input reading\nn, k = map(int, input().split())\nepisodes = input().strip()\n\n# Output the result\nprint(can_dissatisfaction_be_exact(n, k, episodes))"}
{"solution": "def possible_values(N, X, D):\n    # Calculate the first and last elements of the sequence\n    A1 = X\n    AN = X + (N - 1) * D\n    \n    # The total sum of the sequence\n    total_sum = (N * (A1 + AN)) // 2\n    \n    # The possible values of S - T can be derived from the sums taken by Takahashi\n    # The difference S - T can be expressed as 2S - total_sum\n    # The possible values of S range from 0 to total_sum\n    # Thus, the possible values of S - T range from -total_sum to total_sum\n    \n    # The number of distinct values is total_sum - (-total_sum) + 1\n    return total_sum * 2 + 1\n\nimport sys\ninput = sys.stdin.read\nN, X, D = map(int, input().strip().split())\nprint(possible_values(N, X, D))"}
{"solution": "n = int(input())\ngood_performance = False\n\nfor _ in range(n):\n    data = input().split()\n    handle = data[0]\n    before_rating = int(data[1])\n    after_rating = int(data[2])\n    \n    if before_rating >= 2400 and after_rating > before_rating:\n        good_performance = True\n\nprint(\"YES\" if good_performance else \"NO\")"}
{"solution": "s = input().strip()\ns_decimal = int(s, 2)\n\ncount = 0\npower_of_four = 1  # This represents 4^k, starting with k=0\n\nwhile power_of_four < s_decimal:\n    count += 1\n    power_of_four *= 4  # Move to the next power of 4\n\nprint(count)"}
{"solution": "def min_rows_for_mirroring(n, m, a):\n    # Create a set to store unique rows\n    unique_rows = set()\n    \n    # Add each row to the set\n    for row in a:\n        unique_rows.add(tuple(row))\n    \n    # The minimum number of rows in matrix b is the number of unique rows\n    return len(unique_rows)\n\n# Read input\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\n# Get the result\nresult = min_rows_for_mirroring(n, m, a)\n\n# Print the result\nprint(result)"}
{"solution": "def max_orders(n, orders):\n    # Sort orders by their finish time\n    orders.sort(key=lambda x: x[1])\n    \n    count = 0\n    last_end_time = 0\n    \n    for start, end in orders:\n        if start > last_end_time:\n            count += 1\n            last_end_time = end\n            \n    return count\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    orders = [tuple(map(int, line.split())) for line in data[1:n+1]]\n    \n    result = max_orders(n, orders)\n    print(result)"}
{"solution": "def can_rearrange(n, k, tables, formulas):\n    total_tables = sum(tables)\n    total_formulas = sum(formulas)\n\n    # Calculate the maximum number of blocks needed for tables and formulas\n    max_table_blocks = (total_tables + k - 1) // k\n    max_formula_blocks = (total_formulas + k - 1) // k\n\n    # Check if we can fit the blocks into the available pages\n    if max_table_blocks <= total_formulas + n and max_formula_blocks <= total_tables + n:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\ntables = list(map(int, input().split()))\nformulas = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_rearrange(n, k, tables, formulas)\nprint(result)"}
{"solution": "def can_human_win(n, k, coefficients):\n    # Calculate the current value of the polynomial at x = k\n    current_value = 0\n    undefined_count = 0\n    \n    for i in range(n + 1):\n        if coefficients[i] == '?':\n            undefined_count += 1\n        else:\n            current_value += coefficients[i] * (k ** i)\n    \n    # If there are no undefined coefficients, check divisibility\n    if undefined_count == 0:\n        return current_value == 0\n    \n    # If there are undefined coefficients, the human can always adjust\n    # the polynomial to make it divisible by (x - k)\n    return True\n\n# Read input\nn, k = map(int, input().split())\ncoefficients = [input().strip() for _ in range(n + 1)]\n\n# Determine if the human can guarantee a win\nif can_human_win(n, k, coefficients):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def smallest_starting_number(X2):\n    # Function to generate all primes less than a given number using Sieve of Eratosthenes\n    def sieve(n):\n        is_prime = [True] * (n + 1)\n        p = 2\n        while (p * p <= n):\n            if (is_prime[p] == True):\n                for i in range(p * p, n + 1, p):\n                    is_prime[i] = False\n            p += 1\n        return [p for p in range(2, n) if is_prime[p]]\n\n    # Generate all primes less than X2\n    primes = sieve(X2)\n\n    # Initialize the minimum possible X0\n    min_X0 = float('inf')\n\n    # Check all primes less than X2\n    for p in primes:\n        # Calculate the previous number X1\n        if X2 % p == 0:\n            X1 = X2\n        else:\n            X1 = (X2 // p) * p + p\n        \n        # Now we need to find the smallest X0 such that Alice can reach X1\n        for q in primes:\n            if q < X1:\n                if X1 % q == 0:\n                    X0 = X1\n                else:\n                    X0 = (X1 // q) * q + q\n                \n                min_X0 = min(min_X0, X0)\n\n    return min_X0\n\n# Read input\nX2 = int(input().strip())\n# Output the result\nprint(smallest_starting_number(X2))"}
{"solution": "def min_p_binary_numbers(n, p):\n    if p > n:\n        return -1\n    \n    # Count the number of 1s in the binary representation of n\n    count_of_ones = bin(n).count('1')\n    \n    # If p is 0, we can directly use the count of 1s\n    if p == 0:\n        return count_of_ones\n    \n    # If p is positive, we need to account for the additional p in each summand\n    if p > 0:\n        return count_of_ones + (n - count_of_ones * p + (p - 1)) // p\n    \n    # If p is negative, we need to check if we can represent n\n    # We need to ensure that we can form n using p-binary numbers\n    # The minimum number of summands will be the count of 1s plus the number of times we need to add p\n    # to reach n\n    total_needed = n - count_of_ones * p\n    if total_needed < 0:\n        return -1\n    \n    return count_of_ones + (total_needed + (-p - 1)) // -p\n\n# Read input\nn, p = map(int, input().split())\n# Get the result\nresult = min_p_binary_numbers(n, p)\n# Print the result\nprint(result)"}
{"solution": "def minimize_number(n, k, S):\n    S = list(S)\n    \n    if k > 0 and S[0] != '1':\n        S[0] = '1'\n        k -= 1\n\n    for i in range(1, n):\n        if k <= 0:\n            break\n        if S[i] != '0':\n            S[i] = '0'\n            k -= 1\n\n    result = ''.join(S)\n    return result\n\nn, k = map(int, input().split())\nS = input().strip()\nprint(minimize_number(n, k, S))"}
{"solution": "def min_value(cnt_1, cnt_2, x, y):\n    def count_valid_numbers(v):\n        count_x = v // x\n        count_y = v // y\n        count_xy = v // (x * y)\n        return v - (count_x + count_y - count_xy)\n\n    left, right = 1, 2 * (cnt_1 + cnt_2)\n    while left < right:\n        mid = (left + right) // 2\n        if count_valid_numbers(mid) >= cnt_1 + cnt_2:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ncnt_1, cnt_2, x, y = map(int, input().split())\nprint(min_value(cnt_1, cnt_2, x, y))"}
{"solution": "def bear_final_position(n, sx, sy, dx, dy, t):\n    x, y = sx, sy\n    for _ in range(t):\n        bushes = x + y\n        dx += bushes\n        dy += bushes\n        x = (x + dx - 1) % n + 1\n        y = (y + dy - 1) % n + 1\n    return x, y\n\n# Read input\nn, sx, sy, dx, dy, t = map(int, input().split())\nresult = bear_final_position(n, sx, sy, dx, dy, t)\nprint(result[0], result[1])"}
{"solution": "def is_nice_word_possible(s):\n    n = len(s)\n    if n < 26:\n        return -1\n\n    for i in range(n - 25):\n        substring = s[i:i + 26]\n        if can_form_nice_word(substring):\n            return fill_nice_word(s, i)\n    \n    return -1\n\ndef can_form_nice_word(substring):\n    seen = set()\n    for char in substring:\n        if char != '?':\n            if char in seen:\n                return False\n            seen.add(char)\n    return len(seen) + substring.count('?') >= 26\n\ndef fill_nice_word(s, start):\n    alphabet = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    substring = list(s[start:start + 26])\n    seen = set(char for char in substring if char != '?')\n    missing = list(alphabet - seen)\n    \n    for i in range(26):\n        if substring[i] == '?':\n            substring[i] = missing.pop()\n    \n    result = list(s)\n    result[start:start + 26] = substring\n    for i in range(len(result)):\n        if result[i] == '?':\n            result[i] = 'A'  # Fill remaining '?' with 'A'\n    \n    return ''.join(result)\n\ns = input().strip()\nresult = is_nice_word_possible(s)\nprint(result)"}
{"solution": "def can_divide_apples(n, weights):\n    count_100 = weights.count(100)\n    count_200 = weights.count(200)\n    \n    total_weight = sum(weights)\n    \n    if total_weight % 2 != 0:\n        return \"NO\"\n    \n    target_weight = total_weight // 2\n    \n    # Check if we can reach the target weight using the available apples\n    for i in range(count_200 + 1):\n        if i * 200 > target_weight:\n            break\n        remaining_weight = target_weight - i * 200\n        if remaining_weight <= count_100 * 100:\n            return \"YES\"\n    \n    return \"NO\"\n\nn = int(input())\nweights = list(map(int, input().split()))\nprint(can_divide_apples(n, weights))"}
{"solution": "def min_time_to_turn_off_lights(n, m, building):\n    total_time = 0\n\n    for floor in range(n):\n        lights_on = [i for i in range(m) if building[floor][i + 1] == '1']\n        if lights_on:\n            leftmost = lights_on[0]\n            rightmost = lights_on[-1]\n            time_to_turn_off = (rightmost - leftmost) + 2  # move to leftmost, then to rightmost\n            total_time += time_to_turn_off + (floor + 1)  # time to go up to the next floor\n\n    return total_time - 1  # subtract 1 because we don't need to go back to the starting position\n\n# Input reading\nn, m = map(int, input().split())\nbuilding = [input().strip() for _ in range(n)]\n\n# Calculate and print the result\nresult = min_time_to_turn_off_lights(n, m, building)\nprint(result)"}
{"solution": "def minimal_trap_cost(n, costs, a):\n    visited = [False] * n\n    in_cycle = [False] * n\n    total_cost = 0\n\n    def find_cycle(start):\n        nonlocal total_cost\n        current = start\n        path = []\n        while not visited[current]:\n            visited[current] = True\n            path.append(current)\n            current = a[current] - 1  # Move to the next room (0-indexed)\n\n        if current in path:\n            cycle_start = path.index(current)\n            cycle = path[cycle_start:]\n            min_cost = min(costs[i] for i in cycle)\n            total_cost += min_cost\n            for i in cycle:\n                in_cycle[i] = True\n\n    for i in range(n):\n        if not visited[i]:\n            find_cycle(i)\n\n    for i in range(n):\n        if not in_cycle[i]:\n            total_cost += costs[i]\n\n    return total_cost\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\na = list(map(int, input().split()))\n\n# Output the result\nprint(minimal_trap_cost(n, costs, a))"}
{"solution": "n, a, b = map(int, input().split())\nfinal_position = (a + b - 1) % n + 1\nprint(final_position)"}
{"solution": "def min_arithmetic_progressions(n, a):\n    progressions = 0\n    i = 0\n    \n    while i < n:\n        if a[i] == -1:\n            # Start a new progression\n            progressions += 1\n            # Move to the next known value or end\n            while i < n and a[i] == -1:\n                i += 1\n            continue\n        \n        # Start a new progression with a[i]\n        progressions += 1\n        start = a[i]\n        diff = None\n        \n        # Continue until we find a break in the progression\n        while i < n:\n            if a[i] != -1:\n                if diff is None:\n                    # Calculate the difference if we have a valid previous element\n                    if i > 0 and a[i-1] != -1:\n                        diff = a[i] - a[i-1]\n                else:\n                    # Check if the current element fits the progression\n                    expected_value = start + (i - (i - (diff is not None))) * diff\n                    if a[i] != expected_value:\n                        break\n            \n            i += 1\n            \n    return progressions\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_arithmetic_progressions(n, a))"}
{"solution": "def max_beauty(n, k, s):\n    def max_length_with_char(target_char):\n        left = 0\n        max_length = 0\n        count_changes = 0\n        \n        for right in range(n):\n            if s[right] != target_char:\n                count_changes += 1\n            \n            while count_changes > k:\n                if s[left] != target_char:\n                    count_changes -= 1\n                left += 1\n            \n            max_length = max(max_length, right - left + 1)\n        \n        return max_length\n\n    max_a = max_length_with_char('a')\n    max_b = max_length_with_char('b')\n    \n    return max(max_a, max_b)\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, a):\n    total_seats = sum(a)\n    majority = total_seats // 2 + 1\n    alice_seats = a[0]\n    \n    coalition = [1]  # Start with Alice's party\n    coalition_seats = alice_seats\n    \n    for i in range(1, n):\n        if alice_seats >= 2 * a[i]:  # Check if Alice can invite this party\n            coalition.append(i + 1)  # Store the index (1-based)\n            coalition_seats += a[i]\n    \n    if coalition_seats >= majority:\n        print(len(coalition))\n        print(\" \".join(map(str, coalition)))\n    else:\n        print(0)\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nfind_coalition(n, a)"}
{"solution": "def maximum_prize(n):\n    total_reward = 0.0\n    for i in range(n, 0, -1):\n        total_reward += 1 / i\n    return total_reward\n\nn = int(input().strip())\nresult = maximum_prize(n)\nprint(f\"{result:.12f}\")"}
{"solution": "n = int(input())\nk = 0\ncandies = []\n\n# Find the maximum number of distinct positive integers that sum up to n\nwhile n > 0:\n    k += 1\n    if n >= k:\n        candies.append(k)\n        n -= k\n    else:\n        candies[-1] += n\n        break\n\nprint(len(candies))\nprint(' '.join(map(str, candies)))"}
{"solution": "n = int(input())\nm = int(input())\n\nmod_value = 1 << n  # This is equivalent to 2 ** n\nresult = m % mod_value\n\nprint(result)"}
{"solution": "def correct_word(n, s):\n    vowels = set('aeiouy')\n    result = []\n    \n    for char in s:\n        if result and char in vowels and result[-1] in vowels:\n            continue\n        result.append(char)\n    \n    return ''.join(result)\n\nn = int(input().strip())\ns = input().strip()\nprint(correct_word(n, s))"}
{"solution": "def max_students(n, a, b, seats):\n    segments = seats.split('*')\n    total_students = 0\n\n    for segment in segments:\n        length = len(segment)\n        if length == 0:\n            continue\n        \n        # Calculate the maximum number of students that can be seated in this segment\n        if a > b:\n            # Start with programmers\n            programmers_to_seat = (length + 1) // 2\n            athletes_to_seat = length // 2\n        else:\n            # Start with athletes\n            athletes_to_seat = (length + 1) // 2\n            programmers_to_seat = length // 2\n        \n        # Seat as many programmers as possible\n        seated_programmers = min(programmers_to_seat, a)\n        a -= seated_programmers\n        total_students += seated_programmers\n        \n        # Seat as many athletes as possible\n        seated_athletes = min(athletes_to_seat, b)\n        b -= seated_athletes\n        total_students += seated_athletes\n\n    return total_students\n\n# Input reading\nn, a, b = map(int, input().split())\nseats = input().strip()\n\n# Output the result\nprint(max_students(n, a, b, seats))"}
{"solution": "def find_xy(r):\n    for x in range(1, int(r**0.5) + 1):\n        # Calculate the value of H(x, y) = r\n        # Rearranging gives us: y = (r - x^2 - x - 1) / (2x)\n        numerator = r - (x**2 + x + 1)\n        if numerator <= 0:\n            continue\n        if numerator % (2 * x) == 0:\n            y = numerator // (2 * x)\n            if y > 0:\n                return x, y\n    return \"NO\"\n\nr = int(input().strip())\nresult = find_xy(r)\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "def divide_balloons(n, a):\n    if n == 1:\n        return -1\n    \n    total_balloons = sum(a)\n    \n    # If all packets have the same number of balloons\n    if len(set(a)) == 1:\n        return -1\n    \n    # Give the first packet to Grigory\n    grigory_packets = [1]\n    grigory_sum = a[0]\n    \n    # Check if we can give one more packet to Grigory\n    if n > 2:\n        grigory_packets.append(2)\n        grigory_sum += a[1]\n    \n    # Output the result\n    return (len(grigory_packets), grigory_packets)\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\nresult = divide_balloons(n, a)\n\nif result == -1:\n    print(-1)\nelse:\n    k, indices = result\n    print(k)\n    print(' '.join(map(str, indices)))"}
{"solution": "n = int(input())\n\n# The maximum digit we can use is 9\nif n % 9 == 0:\n    k = n // 9\n    digits = [9] * k\nelse:\n    k = n // 9 + 1\n    digits = [9] * (k - 1) + [n % 9]\n\nprint(k)\nprint(' '.join(map(str, digits)))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef find_simple_subset(n, a):\n    odd_count = sum(1 for x in a if x % 2 == 1)\n    even_count = n - odd_count\n    \n    if odd_count >= 2:\n        return odd_count, [x for x in a if x % 2 == 1]\n    elif even_count >= 2:\n        return even_count, [x for x in a if x % 2 == 0]\n    elif odd_count == 1:\n        return 1, [x for x in a if x % 2 == 1]\n    elif even_count == 1:\n        return 1, [x for x in a if x % 2 == 0]\n    else:\n        return 0, []\n\nn = int(input())\na = list(map(int, input().split()))\n\nm, subset = find_simple_subset(n, a)\nprint(m)\nprint(' '.join(map(str, subset)))"}
{"solution": "def is_beautiful(num):\n    k = 1\n    while True:\n        beautiful_number = (2**k - 1) * (2**k - 1)\n        if beautiful_number > num:\n            break\n        if num % beautiful_number == 0:\n            max_beautiful = beautiful_number\n        k += 1\n    return max_beautiful\n\nn = int(input().strip())\nprint(is_beautiful(n))"}
{"solution": "def is_d_magic(num_str, d):\n    for i in range(len(num_str)):\n        if (i % 2 == 1 and num_str[i] != str(d)) or (i % 2 == 0 and num_str[i] == str(d)):\n            return False\n    return True\n\ndef count_d_magic_numbers(m, d, a, b):\n    MOD = 10**9 + 7\n    count = 0\n    \n    a_int = int(a)\n    b_int = int(b)\n    \n    for num in range(a_int, b_int + 1):\n        if num % m == 0 and is_d_magic(str(num), d):\n            count = (count + 1) % MOD\n            \n    return count\n\nm, d = map(int, input().split())\na = input().strip()\nb = input().strip()\n\nresult = count_d_magic_numbers(m, d, a, b)\nprint(result)"}
{"solution": "from collections import deque\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\nqueue = deque([(i + 1, a[i]) for i in range(n)])  # (child_index, candies_needed)\n\nlast_child = -1\n\nwhile queue:\n    child_index, candies_needed = queue.popleft()\n    candies_needed -= m\n    if candies_needed > 0:\n        queue.append((child_index, candies_needed))\n    last_child = child_index\n\nprint(last_child)"}
{"solution": "def min_bills(n):\n    denominations = [100, 20, 10, 5, 1]\n    count = 0\n    \n    for bill in denominations:\n        count += n // bill\n        n %= bill\n    \n    return count\n\nn = int(input())\nprint(min_bills(n))"}
{"solution": "def count_permutations(n, k):\n    MOD = 1000000007\n    \n    # dp[i][j] will store the number of permutations of size i with exactly j good positions\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Base case: 1 permutation of size 0 with 0 good positions\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            # Case 1: The i-th position is not good\n            dp[i][j] = (dp[i - 1][j] * (i - j)) % MOD\n            \n            # Case 2: The i-th position is good\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n    \n    return dp[n][k]\n\n# Read input\nn, k = map(int, input().split())\n# Print the result\nprint(count_permutations(n, k))"}
{"solution": "def max_beauty_bouquet(n, k, beauties, colors):\n    from collections import defaultdict\n    \n    # Group roses by color\n    color_groups = defaultdict(list)\n    for beauty, color in zip(beauties, colors):\n        color_groups[color].append(beauty)\n    \n    # Sort each color group in descending order of beauty\n    for color in color_groups:\n        color_groups[color].sort(reverse=True)\n    \n    # If we have only one color, we cannot form a valid bouquet\n    if len(color_groups) == 1:\n        return -1\n    \n    max_beauty = -1\n    \n    # Try combinations of two different colors\n    color_keys = list(color_groups.keys())\n    for i in range(len(color_keys)):\n        for j in range(i + 1, len(color_keys)):\n            color1 = color_keys[i]\n            color2 = color_keys[j]\n            \n            # Get the top k beauties from both colors\n            beauties1 = color_groups[color1]\n            beauties2 = color_groups[color2]\n            \n            # We can take at most k from both colors\n            total_beauties = []\n            for take_from_color1 in range(max(0, k - len(beauties2)), min(k, len(beauties1)) + 1):\n                take_from_color2 = k - take_from_color1\n                if take_from_color2 <= len(beauties2):\n                    total_beauties = (\n                        beauties1[:take_from_color1] + beauties2[:take_from_color2]\n                    )\n                    max_beauty = max(max_beauty, sum(total_beauties))\n    \n    return max_beauty\n\n# Input reading\nn, k = map(int, input().split())\nbeauties = list(map(int, input().split()))\ncolors = input().strip()\n\n# Output the result\nprint(max_beauty_bouquet(n, k, beauties, colors))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef fraction_from_continued_fraction(a):\n    n = len(a)\n    if n == 0:\n        return (0, 1)\n    \n    numerator = 1\n    denominator = a[-1]\n    \n    for i in range(n - 2, -1, -1):\n        numerator, denominator = denominator, a[i] * denominator + numerator\n    \n    return (denominator, numerator)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    p = int(data[0])\n    q = int(data[1])\n    n = int(data[2])\n    a = list(map(int, data[3:3+n]))\n    \n    # Get the fraction from the continued fraction representation\n    cf_numerator, cf_denominator = fraction_from_continued_fraction(a)\n    \n    # Compare the two fractions\n    if p * cf_denominator == q * cf_numerator:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_sticks_expression(expression):\n    # Split the expression into parts\n    parts = expression.split('+')\n    A = parts[0].count('|')\n    B, C = parts[1].split('=')\n    B = B.count('|')\n    C = C.count('|')\n\n    # Check if the current expression is already correct\n    if A + B == C:\n        return expression\n\n    # Try shifting one stick from A, B, or C\n    for i in range(1, 4):\n        if i == 1 and A > 1:  # Shift from A to B\n            if A - 1 + B + 1 == C:\n                return '|' * (A - 1) + '+' + '|' * (B + 1) + '=' + '|' * C\n        elif i == 2 and B > 1:  # Shift from B to A\n            if A + 1 + B - 1 == C:\n                return '|' * (A + 1) + '+' + '|' * (B - 1) + '=' + '|' * C\n        elif i == 3 and C > 1:  # Shift from C to B\n            if A + B + 1 == C - 1:\n                return '|' * A + '+' + '|' * (B + 1) + '=' + '|' * (C - 1)\n\n    # If no valid shift found, return Impossible\n    return \"Impossible\"\n\n# Read input\nexpression = input().strip()\n# Get the result\nresult = count_sticks_expression(expression)\n# Print the result\nprint(result)"}
{"solution": "def count_permutations_with_oddness(n, k):\n    MOD = 10**9 + 7\n    \n    # dp[i][j] will store the number of permutations of {1, 2, ..., i} with oddness j\n    dp = [[0] * (n * n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case: one way to arrange zero elements with oddness 0\n\n    for i in range(1, n + 1):\n        for j in range(n * n + 1):\n            for p in range(1, i + 1):\n                oddness_contribution = abs(p - i)\n                if j >= oddness_contribution:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - oddness_contribution]) % MOD\n\n    return dp[n][k]\n\nimport sys\ninput = sys.stdin.read\nn, k = map(int, input().strip().split())\nprint(count_permutations_with_oddness(n, k))"}
{"solution": "def can_construct_robot_arm(N, points):\n    # Calculate the total distance needed in x and y directions\n    total_x = sum(x for x, y in points)\n    total_y = sum(y for x, y in points)\n\n    # The maximum distance in x and y directions\n    max_x = max(abs(x) for x, y in points)\n    max_y = max(abs(y) for x, y in points)\n\n    # The number of sections needed\n    m = max(max_x, max_y)\n\n    # The distances for each section\n    d = [1] * m  # Each section has a length of 1\n\n    # Prepare the output\n    output = []\n    output.append(str(m))\n    output.append(\" \".join(map(str, d)))\n\n    # For each point, determine the directions\n    for x, y in points:\n        directions = []\n        current_x, current_y = 0, 0\n\n        # Move in x direction\n        if x > 0:\n            directions.extend(['R'] * x)\n        elif x < 0:\n            directions.extend(['L'] * (-x))\n\n        # Move in y direction\n        if y > 0:\n            directions.extend(['U'] * y)\n        elif y < 0:\n            directions.extend(['D'] * (-y))\n\n        # If we have more sections than needed, fill with 'R' (or any valid direction)\n        while len(directions) < m:\n            directions.append('R')\n\n        # If we have more sections than needed, we can just ignore the extra\n        output.append(\"\".join(directions[:m]))\n\n    return \"\\n\".join(output)\n\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN = int(data[0])\npoints = [tuple(map(int, line.split())) for line in data[1:N + 1]]\n\nresult = can_construct_robot_arm(N, points)\nprint(result)"}
{"solution": "def replace_fillers(n, s):\n    i = 0\n    result = []\n    \n    while i < n:\n        if s[i:i+3] == \"ogo\":\n            # Found a filler, replace it with ***\n            result.append(\"***\")\n            i += 3\n            \n            # Check for additional \"go\" at the end\n            while s[i:i+2] == \"go\":\n                result.append(\"***\")\n                i += 2\n        else:\n            result.append(s[i])\n            i += 1\n            \n    print(\"\".join(result))\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\nreplace_fillers(n, s)"}
{"solution": "def prime_factors(x):\n    factors = set()\n    d = 2\n    while d * d <= x:\n        while (x % d) == 0:\n            factors.add(d)\n            x //= d\n        d += 1\n    if x > 1:\n        factors.add(x)\n    return factors\n\ndef g(y, p):\n    k = 0\n    while y % p == 0:\n        y //= p\n        k += 1\n    return p ** k\n\ndef f(x, y):\n    primes = prime_factors(x)\n    product = 1\n    for p in primes:\n        product *= g(y, p)\n        product %= (10**9 + 7)\n    return product\n\ndef calculate_result(x, n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= f(x, i)\n        result %= (10**9 + 7)\n    return result\n\nx, n = map(int, input().split())\nresult = calculate_result(x, n)\nprint(result)"}
{"solution": "def digit_sum(x):\n    return sum(int(d) for d in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for s in range(1, 82):  # Maximum digit sum for numbers < 10^9 is 81 (9*9)\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and digit_sum(x) == s:\n            solutions.append(x)\n    return sorted(solutions)\n\na, b, c = map(int, input().split())\nsolutions = find_solutions(a, b, c)\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "def can_solve_with_one_rotation(cube):\n    # Count occurrences of each color\n    color_count = [0] * 7  # Index 0 is unused, colors are 1 to 6\n    for color in cube:\n        color_count[color] += 1\n\n    # Check the counts\n    count_of_counts = {}\n    for count in color_count[1:]:\n        if count > 0:\n            if count in count_of_counts:\n                count_of_counts[count] += 1\n            else:\n                count_of_counts[count] = 1\n\n    # We can have the following valid configurations:\n    # 1. Four colors with 4 occurrences (solved)\n    # 2. One color with 4 occurrences and two colors with 2 occurrences (one rotation can solve)\n    # 3. Two colors with 4 occurrences (not possible to solve with one rotation)\n    \n    if 4 in count_of_counts and count_of_counts[4] == 1 and len(count_of_counts) == 1:\n        return \"NO\"  # Already solved\n    elif 4 in count_of_counts and count_of_counts[4] == 1 and count_of_counts.get(2, 0) == 2:\n        return \"YES\"  # One rotation can solve\n    else:\n        return \"NO\"  # Not possible to solve with one rotation\n\n# Read input\ncube_state = list(map(int, input().strip().split()))\n# Output result\nprint(can_solve_with_one_rotation(cube_state))"}
{"solution": "def get_tshirt_places():\n    places = set()\n    for s in range(20001):\n        i = (s // 50) % 475\n        for _ in range(25):\n            i = (i * 96 + 42) % 475\n            places.add(26 + i)\n    return places\n\ndef min_successful_hacks(p, x, y):\n    places = get_tshirt_places()\n    min_hacks = float('inf')\n    \n    for successful_hacks in range(200):  # Arbitrarily large number to ensure we cover all cases\n        score = x + successful_hacks * 100 - (successful_hacks * 50)\n        if score >= y:\n            if any((score // 50) % 475 == (place - 26) for place in places):\n                min_hacks = min(min_hacks, successful_hacks)\n                break  # No need to check further if we found a valid score\n    \n    return min_hacks\n\np, x, y = map(int, input().split())\nresult = min_successful_hacks(p, x, y)\nprint(result)"}
{"solution": "def minimum_distance(n, a, b, c):\n    if n == 1:\n        return 0\n    \n    # Calculate the minimum distance for n meals\n    # The optimal path is to visit each house in a round-robin fashion\n    # The distances between the houses are a, b, c\n    # We can visit Rabbit -> Owl -> Eeyore or any other combination\n    \n    # The minimum distance for 2 meals is the distance to the nearest house\n    if n == 2:\n        return min(a, b, c)\n    \n    # For n >= 3, we can calculate the distance based on the pattern\n    # The pattern will be: Rabbit -> Owl -> Eeyore -> Rabbit (or any permutation)\n    # Each full cycle (3 meals) will cost a + b + c\n    full_cycles = (n - 1) // 3\n    remaining_meals = (n - 1) % 3\n    \n    total_distance = full_cycles * (a + b + c)\n    \n    # Add the distance for the remaining meals\n    if remaining_meals == 1:\n        total_distance += min(a, b, c)\n    elif remaining_meals == 2:\n        total_distance += a + b + c - max(a, b, c)  # sum of two smallest distances\n    \n    return total_distance\n\n# Input reading\nn = int(input().strip())\na = int(input().strip())\nb = int(input().strip())\nc = int(input().strip())\n\n# Output the result\nprint(minimum_distance(n, a, b, c))"}
{"solution": "x1, x2, x3 = map(int, input().split())\nfriends = [x1, x2, x3]\nfriends.sort()\nmin_distance = (friends[2] - friends[0])\nprint(min_distance)"}
{"solution": "def min_operations_to_equal_elements(n, x, a):\n    count = {}\n    for num in a:\n        count[num] = count.get(num, 0) + 1\n    \n    # Check if there are already duplicates\n    for num in count:\n        if count[num] > 1:\n            return 0\n    \n    # Create a new array with the AND operation applied\n    transformed = [num & x for num in a]\n    \n    # Count occurrences in the transformed array\n    transformed_count = {}\n    for num in transformed:\n        transformed_count[num] = transformed_count.get(num, 0) + 1\n    \n    # Check for duplicates in the transformed array\n    for num in transformed_count:\n        if transformed_count[num] > 1:\n            return 1\n    \n    # Check if any original number matches a transformed number\n    for num in a:\n        if num in transformed_count:\n            return 1\n    \n    return -1\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_operations_to_equal_elements(n, x, a))"}
{"solution": "def has_single_plus_shape(h, w, picture):\n    # Find the center of the plus shape\n    center = None\n    for i in range(h):\n        for j in range(w):\n            if picture[i][j] == '*':\n                if center is None:\n                    center = (i, j)\n                else:\n                    # If we find more than one center, return NO\n                    return \"NO\"\n\n    if center is None:\n        return \"NO\"  # No '*' found\n\n    cx, cy = center\n\n    # Check for rays in all four directions\n    up, down, left, right = 0, 0, 0, 0\n\n    # Count upward\n    for i in range(cx - 1, -1, -1):\n        if picture[i][cy] == '*':\n            up += 1\n        else:\n            break\n\n    # Count downward\n    for i in range(cx + 1, h):\n        if picture[i][cy] == '*':\n            down += 1\n        else:\n            break\n\n    # Count leftward\n    for j in range(cy - 1, -1, -1):\n        if picture[cx][j] == '*':\n            left += 1\n        else:\n            break\n\n    # Count rightward\n    for j in range(cy + 1, w):\n        if picture[cx][j] == '*':\n            right += 1\n        else:\n            break\n\n    # Check if there is at least one ray in each direction\n    if up > 0 and down > 0 and left > 0 and right > 0:\n        # Now check if all other cells are empty\n        for i in range(h):\n            for j in range(w):\n                if (i == cx and j == cy) or \\\n                   (up > 0 and i < cx and picture[i][cy] == '*') or \\\n                   (down > 0 and i > cx and picture[i][cy] == '*') or \\\n                   (left > 0 and j < cy and picture[cx][j] == '*') or \\\n                   (right > 0 and j > cy and picture[cx][j] == '*'):\n                    continue\n                if picture[i][j] == '*':\n                    return \"NO\"\n        return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nh, w = map(int, input().split())\npicture = [input().strip() for _ in range(h)]\n\n# Output the result\nprint(has_single_plus_shape(h, w, picture))"}
{"solution": "def create_adjacency_matrix(n, a, b):\n    if a + b > n + 1:\n        return \"NO\"\n    \n    # Initialize the adjacency matrix with zeros\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Create components for the graph\n    components = []\n    for i in range(a):\n        components.append([i])\n    \n    # Fill the remaining vertices into the last component\n    for i in range(a, n):\n        components[-1].append(i)\n    \n    # Create edges within each component\n    for component in components:\n        size = len(component)\n        for i in range(size):\n            for j in range(i + 1, size):\n                matrix[component[i]][component[j]] = 1\n                matrix[component[j]][component[i]] = 1\n    \n    # Create components for the complement\n    complement_components = []\n    for i in range(b):\n        complement_components.append([i])\n    \n    # Fill the remaining vertices into the last component\n    for i in range(b, n):\n        complement_components[-1].append(i)\n    \n    # Check if the complement components are valid\n    if len(complement_components) > 1:\n        for i in range(len(complement_components) - 1):\n            for j in range(i + 1, len(complement_components)):\n                for u in complement_components[i]:\n                    for v in complement_components[j]:\n                        if matrix[u][v] == 0:\n                            matrix[u][v] = 1\n                            matrix[v][u] = 1\n    \n    return \"YES\", matrix\n\nn, a, b = map(int, input().split())\nresult = create_adjacency_matrix(n, a, b)\n\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(''.join(map(str, row)))"}
{"solution": "def min_problems_needed(c, d, n, m, k):\n    total_needed = n * m\n    already_invited = k\n    remaining_needed = max(0, total_needed - already_invited)\n\n    main_rounds = remaining_needed // n\n    if remaining_needed % n != 0:\n        main_rounds += 1\n\n    additional_rounds = 0\n    if remaining_needed > 0:\n        additional_rounds = remaining_needed\n\n    total_problems = main_rounds * c + additional_rounds * d\n    return total_problems\n\n# Read input\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\n# Calculate and print the result\nresult = min_problems_needed(c, d, n, m, k)\nprint(result)"}
{"solution": "def can_form_path(s):\n    from collections import defaultdict, deque\n\n    # Create a grid representation\n    grid = [[''] * 13 for _ in range(2)]\n    letter_positions = defaultdict(list)\n\n    # Fill the grid with letters from the string\n    for i, letter in enumerate(s):\n        row = i // 13\n        col = i % 13\n        grid[row][col] = letter\n        letter_positions[letter].append((row, col))\n\n    # Directions for adjacency (8 directions)\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n\n    # Check if we can form the path\n    def is_adjacent(pos1, pos2):\n        for dr, dc in directions:\n            if (pos1[0] + dr, pos1[1] + dc) == pos2:\n                return True\n        return False\n\n    # Build the path\n    path = []\n    for i in range(len(s)):\n        if i == 0:\n            path.append(letter_positions[s[i]][0])\n        else:\n            found = False\n            for pos in letter_positions[s[i]]:\n                if is_adjacent(path[-1], pos):\n                    path.append(pos)\n                    found = True\n                    break\n            if not found:\n                return \"Impossible\"\n\n    # Create the output grid\n    output_grid = [[''] * 13 for _ in range(2)]\n    for r in range(2):\n        for c in range(13):\n            output_grid[r][c] = grid[r][c]\n\n    return [''.join(output_grid[0]), ''.join(output_grid[1])]\n\ns = input().strip()\nresult = can_form_path(s)\nif result == \"Impossible\":\n    print(result)\nelse:\n    for line in result:\n        print(line)"}
{"solution": "import math\n\nx, y = map(int, input().split())\n\nif x == y:\n    print('=')\nelse:\n    # Compare x^y and y^x using logarithms\n    # We compare y * log(x) with x * log(y)\n    left = y * math.log(x)\n    right = x * math.log(y)\n\n    if left < right:\n        print('<')\n    elif left > right:\n        print('>')"}
{"solution": "import math\n\ndef max_balloons(r, h):\n    balloon_radius = r / 2\n    cupboard_height = h + r\n    max_balloons_in_height = cupboard_height // (2 * balloon_radius)\n    \n    # The width of the cupboard is the diameter of the semicircle\n    cupboard_width = r\n    max_balloons_in_width = cupboard_width // (2 * balloon_radius)\n    \n    # Total balloons is the product of the two dimensions\n    return max_balloons_in_height * max_balloons_in_width\n\n# Read input\nr, h = map(int, input().split())\n# Calculate and print the result\nprint(max_balloons(r, h))"}
{"solution": "from collections import Counter\n\n# Read input\ncards = list(map(int, input().split()))\n\n# Calculate the total sum of the cards\ntotal_sum = sum(cards)\n\n# Count the occurrences of each number\ncount = Counter(cards)\n\n# Initialize the minimum sum as the total sum\nmin_sum = total_sum\n\n# Check for pairs and triplets\nfor number, freq in count.items():\n    if freq >= 2:\n        # If we can discard two cards of this number\n        min_sum = min(min_sum, total_sum - 2 * number)\n    if freq >= 3:\n        # If we can discard three cards of this number\n        min_sum = min(min_sum, total_sum - 3 * number)\n\n# Print the minimum possible sum\nprint(min_sum)"}
{"solution": "def minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    \n    if n == 1:\n        return abs(a - checkpoints[0])\n    \n    leftmost = checkpoints[0]\n    rightmost = checkpoints[-1]\n    \n    # Calculate the distance if we visit the leftmost n-1 checkpoints\n    distance_left = abs(a - rightmost) + (rightmost - leftmost)\n    \n    # Calculate the distance if we visit the rightmost n-1 checkpoints\n    distance_right = abs(a - leftmost) + (rightmost - leftmost)\n    \n    return min(distance_left, distance_right)\n\n# Input reading\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Output the result\nprint(minimum_distance(n, a, checkpoints))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(d) for d in str(x))\n\ndef find_smallest_root(n):\n    for s in range(1, 163):  # s(x) can be at most 162 for x < 10^18\n        # Calculate the discriminant\n        discriminant = s * s + 4 * n\n        if discriminant < 0:\n            continue\n        \n        sqrt_discriminant = int(discriminant**0.5)\n        if sqrt_discriminant * sqrt_discriminant != discriminant:\n            continue\n        \n        # Calculate the two possible roots\n        x1 = (-s + sqrt_discriminant) // 2\n        x2 = (-s - sqrt_discriminant) // 2\n        \n        if x1 > 0 and sum_of_digits(x1) == s:\n            return x1\n        if x2 > 0 and sum_of_digits(x2) == s:\n            return x2\n    \n    return -1\n\nn = int(input().strip())\nresult = find_smallest_root(n)\nprint(result)"}
{"solution": "def time_to_bed(current_time, sleep_duration):\n    # Split the current time and sleep duration into hours and minutes\n    current_hours, current_minutes = map(int, current_time.split(':'))\n    sleep_hours, sleep_minutes = map(int, sleep_duration.split(':'))\n    \n    # Convert both times to total minutes\n    total_current_minutes = current_hours * 60 + current_minutes\n    total_sleep_minutes = sleep_hours * 60 + sleep_minutes\n    \n    # Calculate the time when George went to bed in total minutes\n    total_bed_time_minutes = total_current_minutes - total_sleep_minutes\n    \n    # If the result is negative, it means he went to bed the previous day\n    if total_bed_time_minutes < 0:\n        total_bed_time_minutes += 24 * 60\n    \n    # Convert back to hours and minutes\n    bed_hours = total_bed_time_minutes // 60\n    bed_minutes = total_bed_time_minutes % 60\n    \n    # Format the output to ensure two digits for hours and minutes\n    return f\"{bed_hours:02}:{bed_minutes:02}\"\n\n# Read input\ncurrent_time = input().strip()\nsleep_duration = input().strip()\n\n# Calculate and print the time George went to bed\nprint(time_to_bed(current_time, sleep_duration))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmax_value = max(a)\nmax_length = 0\ncurrent_length = 0\n\nfor value in a:\n    if value == max_value:\n        current_length += 1\n    else:\n        max_length = max(max_length, current_length)\n        current_length = 0\n\nmax_length = max(max_length, current_length)\n\nprint(max_length)"}
{"solution": "def count_painting_ways(n, m, k):\n    MOD = 998244353\n    \n    if k == 0:\n        return m % MOD\n    \n    # Calculate the number of ways\n    # The first brick can be painted in m ways\n    # The next k bricks must be different from the previous one\n    # The remaining (n - k - 1) bricks can be painted in m ways\n    ways = m * pow(m - 1, k, MOD) % MOD * pow(m, n - k - 1, MOD) % MOD\n    return ways\n\n# Read input\nn, m, k = map(int, input().split())\n# Output the result\nprint(count_painting_ways(n, m, k))"}
{"solution": "def is_magic_number(n):\n    s = str(n)\n    i = 0\n    while i < len(s):\n        if s[i:i+3] == '144':\n            i += 3\n        elif s[i:i+2] == '14':\n            i += 2\n        elif s[i:i+1] == '1':\n            i += 1\n        else:\n            return \"NO\"\n    return \"YES\"\n\nn = int(input().strip())\nprint(is_magic_number(n))"}
{"solution": "def min_moves_to_corners(n, m, i, j, a, b):\n    corners = [(1, 1), (1, m), (n, 1), (n, m)]\n    min_moves = float('inf')\n\n    for x, y in corners:\n        if (abs(x - i) % a == 0) and (abs(y - j) % b == 0):\n            moves_x = abs(x - i) // a\n            moves_y = abs(y - j) // b\n            if (moves_x % 2) == (moves_y % 2):\n                min_moves = min(min_moves, max(moves_x, moves_y))\n\n    return min_moves if min_moves != float('inf') else \"Poor Inna and pony!\"\n\n# Read input\nn, m, i, j, a, b = map(int, input().split())\nresult = min_moves_to_corners(n, m, i, j, a, b)\nprint(result)"}
{"solution": "def max_removals(s):\n    n = len(s)\n    removable = [False] * n\n\n    for i in range(n):\n        if i > 0 and ord(s[i]) - ord(s[i - 1]) == 1:\n            removable[i] = True\n        if i < n - 1 and ord(s[i]) - ord(s[i + 1]) == 1:\n            removable[i] = True\n\n    count = 0\n    while True:\n        found = False\n        for i in range(n):\n            if removable[i]:\n                count += 1\n                found = True\n                s = s[:i] + s[i + 1:]\n                n -= 1\n                removable = [False] * n\n                for j in range(n):\n                    if j > 0 and ord(s[j]) - ord(s[j - 1]) == 1:\n                        removable[j] = True\n                    if j < n - 1 and ord(s[j]) - ord(s[j + 1]) == 1:\n                        removable[j] = True\n                break\n        if not found:\n            break\n\n    return count\n\n# Input reading\nlength = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(max_removals(s))"}
{"solution": "def min_bills(n, k, denominations, q, requests):\n    results = []\n    \n    for amount in requests:\n        min_bills_needed = float('inf')\n        \n        for i in range(n):\n            for j in range(i, n):\n                d1 = denominations[i]\n                d2 = denominations[j]\n                \n                for x in range(k + 1):\n                    for y in range(k - x + 1):\n                        if x + y > k:\n                            continue\n                        total = x * d1 + y * d2\n                        if total == amount:\n                            min_bills_needed = min(min_bills_needed, x + y)\n        \n        if min_bills_needed == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_bills_needed)\n    \n    return results\n\n# Input reading\nn, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\nrequests = [int(input()) for _ in range(q)]\n\n# Get results\nresults = min_bills(n, k, denominations, q, requests)\n\n# Output results\nfor result in results:\n    print(result)"}
{"solution": "def min_time_to_reach(s, x1, x2, t1, t2, p, d):\n    # Calculate the time it takes for Igor to walk directly to x2\n    direct_walk_time = abs(x1 - x2) * t2\n\n    # Function to calculate the time for tram to reach a certain position\n    def tram_time_to_position(start_pos, direction, target_pos):\n        if direction == 1:  # Tram going towards s\n            if start_pos <= target_pos:\n                return (target_pos - start_pos) * t1\n            else:\n                # Tram goes to s, turns around, and comes back\n                time_to_s = (s - start_pos) * t1\n                time_to_return = (s - target_pos) * t1\n                return time_to_s + time_to_return\n        else:  # Tram going towards 0\n            if start_pos >= target_pos:\n                return (start_pos - target_pos) * t1\n            else:\n                # Tram goes to 0, turns around, and comes back\n                time_to_0 = start_pos * t1\n                time_to_return = target_pos * t1\n                return time_to_0 + time_to_return\n\n    # Calculate the time for Igor to wait for the tram and then reach x2\n    min_time = direct_walk_time\n\n    # Check the time for different scenarios of waiting for the tram\n    for i in range(2):  # Check both directions\n        if i == 0:\n            # Tram is going in the current direction\n            tram_start_pos = p\n            tram_direction = d\n        else:\n            # Tram is going in the opposite direction\n            tram_start_pos = p\n            tram_direction = -d\n\n        # Calculate the time for the tram to reach x1\n        time_to_x1 = tram_time_to_position(tram_start_pos, tram_direction, x1)\n\n        # Calculate the time for the tram to reach x2 from x1\n        time_to_x2 = tram_time_to_position(x1, tram_direction, x2)\n\n        # Total time if Igor waits for the tram\n        total_time = time_to_x1 + time_to_x2\n        min_time = min(min_time, total_time)\n\n    return min_time\n\n# Input reading\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Calculate and print the minimum time\nresult = min_time_to_reach(s, x1, x2, t1, t2, p, d)\nprint(result)"}
{"solution": "def count_occurrences(n, x):\n    count = 0\n    for i in range(1, n + 1):\n        if x % i == 0:\n            j = x // i\n            if 1 <= j <= n:\n                count += 1\n    return count\n\nn, x = map(int, input().split())\nresult = count_occurrences(n, x)\nprint(result)"}
{"solution": "n, k = map(int, input().split())\n\n# Generate the first k lowercase letters\nletters = [chr(i) for i in range(ord('a'), ord('a') + k)]\n\n# Create the password by repeating the letters in a way that no two consecutive letters are the same\npassword = []\nfor i in range(n):\n    password.append(letters[i % k])\n\n# Join the list into a string and print the result\nprint(''.join(password))"}
{"solution": "def first_collision(n, directions, positions):\n    min_time = float('inf')\n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            # Calculate the time until they collide\n            time = (positions[i + 1] - positions[i]) // 2\n            min_time = min(min_time, time)\n    \n    return min_time if min_time != float('inf') else -1\n\n# Input reading\nn = int(input().strip())\ndirections = input().strip()\npositions = list(map(int, input().strip().split()))\n\n# Get the result and print it\nresult = first_collision(n, directions, positions)\nprint(result)"}
{"solution": "def can_fit(w1, h1, w2, h2, a, b):\n    return (w1 + w2 <= a and max(h1, h2) <= b) or (max(w1, w2) <= a and h1 + h2 <= b)\n\ndef max_area(n, a, b, seals):\n    max_total_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = seals[i]\n            x2, y2 = seals[j]\n            areas = [\n                (x1 * y1, x2 * y2),\n                (x1 * y1, y2 * x2),\n                (y1 * x1, x2 * y2),\n                (y1 * x1, y2 * x2),\n            ]\n            for area1, area2 in areas:\n                if can_fit(x1, y1, x2, y2, a, b):\n                    max_total_area = max(max_total_area, area1 + area2)\n    return max_total_area\n\nn, a, b = map(int, input().split())\nseals = [tuple(map(int, input().split())) for _ in range(n)]\nresult = max_area(n, a, b, seals)\nprint(result)"}
{"solution": "def find_inner_point(n, points):\n    x_count = {}\n    y_count = {}\n    \n    for x, y in points:\n        if x in x_count:\n            x_count[x] += 1\n        else:\n            x_count[x] = 1\n        \n        if y in y_count:\n            y_count[y] += 1\n        else:\n            y_count[y] = 1\n    \n    # The point that is not on the boundary will have an odd count\n    for x in x_count:\n        if x_count[x] % 2 == 1:\n            inner_x = x\n            break\n    \n    for y in y_count:\n        if y_count[y] % 2 == 1:\n            inner_y = y\n            break\n    \n    return inner_x, inner_y\n\nn = int(input().strip())\npoints = [tuple(map(int, input().strip().split())) for _ in range(4 * n + 1)]\ninner_point = find_inner_point(n, points)\nprint(inner_point[0], inner_point[1])"}
{"solution": "def product_of_digits(x):\n    product = 1\n    while x > 0:\n        product *= x % 10\n        x //= 10\n    return product\n\ndef max_product(n):\n    str_n = str(n)\n    max_prod = product_of_digits(n)\n    \n    for i in range(len(str_n)):\n        if str_n[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit by 1 and setting all following digits to 9\n        new_number = str_n[:i] + str(int(str_n[i]) - 1) + '9' * (len(str_n) - i - 1)\n        max_prod = max(max_prod, product_of_digits(int(new_number)))\n    \n    return max_prod\n\nn = int(input().strip())\nprint(max_product(n))"}
{"solution": "def smallest_winning_k(n, a):\n    total_votes_elodreip = sum(a)\n    max_a = max(a)\n    \n    k = max_a\n    while True:\n        votes_awruk = n * k - total_votes_elodreip\n        if votes_awruk > total_votes_elodreip:\n            return k\n        k += 1\n\nn = int(input())\na = list(map(int, input().split()))\nprint(smallest_winning_k(n, a))"}
{"solution": "def count_operations(points):\n    operations = 0\n    while True:\n        to_delete = set()\n        n = len(points)\n        \n        for i in range(n):\n            if (i > 0 and points[i] != points[i - 1]) or (i < n - 1 and points[i] != points[i + 1]):\n                to_delete.add(i)\n        \n        if not to_delete:\n            break\n        \n        points = ''.join(points[i] for i in range(n) if i not in to_delete)\n        operations += 1\n    \n    return operations\n\n# Read input\ninput_points = input().strip()\n# Get the result\nresult = count_operations(input_points)\n# Print the output\nprint(result)"}
{"solution": "from collections import Counter\nfrom itertools import combinations\n\ndef count_min_product_triples(n, a):\n    # Count the occurrences of each number\n    count = Counter(a)\n    \n    # Get the three smallest unique numbers\n    unique_numbers = sorted(count.keys())\n    \n    # If there are less than 3 unique numbers, we cannot form a valid triple\n    if len(unique_numbers) < 3:\n        return 0\n    \n    # The three smallest numbers\n    x1, x2, x3 = unique_numbers[0], unique_numbers[1], unique_numbers[2]\n    \n    # Calculate the minimum product\n    min_product = x1 * x2 * x3\n    \n    # Count the number of ways to form the triples\n    total_triples = 0\n    \n    # Check combinations of the smallest three numbers\n    if count[x1] >= 3:\n        total_triples += (count[x1] * (count[x1] - 1) * (count[x1] - 2)) // 6  # C(count[x1], 3)\n    \n    if count[x1] >= 2 and count[x2] >= 1:\n        total_triples += (count[x1] * (count[x1] - 1) // 2) * count[x2]  # C(count[x1], 2) * count[x2]\n    \n    if count[x1] >= 2 and count[x3] >= 1:\n        total_triples += (count[x1] * (count[x1] - 1) // 2) * count[x3]  # C(count[x1], 2) * count[x3]\n    \n    if count[x2] >= 2 and count[x1] >= 1:\n        total_triples += (count[x2] * (count[x2] - 1) // 2) * count[x1]  # C(count[x2], 2) * count[x1]\n    \n    if count[x2] >= 2 and count[x3] >= 1:\n        total_triples += (count[x2] * (count[x2] - 1) // 2) * count[x3]  # C(count[x2], 2) * count[x3]\n    \n    if count[x3] >= 2 and count[x1] >= 1:\n        total_triples += (count[x3] * (count[x3] - 1) // 2) * count[x1]  # C(count[x3], 2) * count[x1]\n    \n    if count[x3] >= 2 and count[x2] >= 1:\n        total_triples += (count[x3] * (count[x3] - 1) // 2) * count[x2]  # C(count[x3], 2) * count[x2]\n    \n    return total_triples\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(count_min_product_triples(n, a))"}
{"solution": "def min_cuts(n):\n    if n == 0:\n        return 0\n    elif n % 2 == 0:\n        return n // 2 + 1\n    else:\n        return n\n\nn = int(input().strip())\nprint(min_cuts(n))"}
{"solution": "n = int(input().strip())\n\n# If n is non-negative, the maximum state is n itself\nif n >= 0:\n    print(n)\nelse:\n    # Convert to string to manipulate digits\n    n_str = str(n)\n    \n    # Option 1: Remove the last digit\n    option1 = int(n_str[:-1])\n    \n    # Option 2: Remove the second to last digit\n    option2 = int(n_str[:-2] + n_str[-1]) if len(n_str) > 2 else 0\n    \n    # The maximum state of the bank account\n    print(max(n, option1, option2))"}
{"solution": "def determine_direction(start, end, n):\n    positions = ['v', '<', '^', '>']\n    start_index = positions.index(start)\n    end_index = positions.index(end)\n\n    # Calculate the resulting position after n seconds in both directions\n    cw_position = (start_index + n) % 4\n    ccw_position = (start_index - n) % 4\n\n    if cw_position == end_index and ccw_position == end_index:\n        return \"undefined\"\n    elif cw_position == end_index:\n        return \"cw\"\n    elif ccw_position == end_index:\n        return \"ccw\"\n    else:\n        return \"undefined\"\n\n# Read input\ninput_data = input().strip().split()\nstart_position = input_data[0]\nend_position = input_data[1]\nn_seconds = int(input().strip())\n\n# Determine and print the direction\nresult = determine_direction(start_position, end_position, n_seconds)\nprint(result)"}
{"solution": "def domino_show(n, s):\n    # Create a list to represent the final state of the dominoes\n    final_state = list(s)\n    \n    # Process the dominoes\n    for i in range(n):\n        if final_state[i] == 'R':\n            j = i + 1\n            while j < n and final_state[j] == '.':\n                final_state[j] = 'R'\n                j += 1\n            if j < n and final_state[j] == 'L':\n                # If we encounter an 'L', we need to determine the balance\n                left_count = j - (i + 1)\n                right_count = 1\n                while j < n and final_state[j] == 'L':\n                    right_count += 1\n                    j += 1\n                if left_count < right_count:\n                    for k in range(i + 1, i + 1 + left_count):\n                        final_state[k] = 'R'\n                elif left_count > right_count:\n                    for k in range(j - right_count, j):\n                        final_state[k] = 'L'\n                # If they are equal, they both stay as is\n                # Move i to j - 1 to continue processing\n                i = j - 1\n\n    # Count the number of standing dominoes\n    standing_count = final_state.count('.')\n    return standing_count\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(domino_show(n, s))"}
{"solution": "def restore_permutation(n, m, leaders):\n    a = [0] * n\n    visited = [False] * n\n\n    for i in range(m - 1):\n        current_leader = leaders[i] - 1\n        next_leader = leaders[i + 1] - 1\n        step_count = (next_leader - current_leader + n) % n\n        \n        if a[current_leader] == 0:\n            a[current_leader] = step_count\n        elif a[current_leader] != step_count:\n            return -1\n        \n        visited[next_leader] = True\n\n    for i in range(n):\n        if a[i] == 0:\n            a[i] = n - sum(a) + a.count(0)\n\n    if len(set(a)) != n or any(x < 1 or x > n for x in a):\n        return -1\n\n    return a\n\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\nresult = restore_permutation(n, m, leaders)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "def max_number_after_swaps(a, k):\n    a = list(str(a))\n    n = len(a)\n\n    for i in range(n):\n        if k <= 0:\n            break\n        max_digit = a[i]\n        max_index = i\n        \n        # Find the maximum digit we can bring to the current position\n        for j in range(i + 1, min(n, i + k + 1)):\n            if a[j] > max_digit:\n                max_digit = a[j]\n                max_index = j\n        \n        # Calculate how many swaps are needed to bring max_index to i\n        swaps_needed = max_index - i\n        \n        if swaps_needed <= k:\n            # Perform the swaps\n            for j in range(max_index, i, -1):\n                a[j], a[j - 1] = a[j - 1], a[j]\n            k -= swaps_needed\n\n    return ''.join(a)\n\n# Input reading\na, k = input().split()\na = int(a)\nk = int(k)\n\n# Output the result\nprint(max_number_after_swaps(a, k))"}
{"solution": "def next_number(sequence):\n    a, b, c, d = sequence\n\n    # Check for arithmetic progression\n    if (b - a) == (c - b) == (d - c):\n        next_ap = d + (b - a)\n        print(next_ap)\n        return\n\n    # Check for geometric progression\n    if (b % a == 0) and (c % b == 0) and (d % c == 0):\n        q1 = b // a\n        q2 = c // b\n        q3 = d // c\n        if q1 == q2 == q3 and q1 != 1:\n            next_gp = d * q1\n            if next_gp % 1 == 0:\n                print(next_gp)\n                return\n\n    print(42)\n\n# Read input\nsequence = list(map(int, input().split()))\nnext_number(sequence)"}
{"solution": "def max_distance(n, colors):\n    first_color = {}\n    last_color = {}\n    \n    for i in range(n):\n        color = colors[i]\n        if color not in first_color:\n            first_color[color] = i\n        last_color[color] = i\n    \n    max_dist = 0\n    for color in first_color:\n        for other_color in last_color:\n            if color != other_color:\n                dist = abs(last_color[other_color] - first_color[color])\n                max_dist = max(max_dist, dist)\n    \n    return max_dist\n\nn = int(input())\ncolors = list(map(int, input().split()))\nprint(max_distance(n, colors))"}
{"solution": "n, m, k = map(int, input().split())\n\n# Calculate the total number of places per lane\nplaces_per_lane = 2 * m\n\n# Determine the lane (1-indexed)\nlane = (k - 1) // places_per_lane + 1\n\n# Determine the position within the lane\nposition_in_lane = (k - 1) % places_per_lane\n\n# Determine the desk (1-indexed)\ndesk = position_in_lane // 2 + 1\n\n# Determine the side (L or R)\nside = 'L' if position_in_lane % 2 == 0 else 'R'\n\nprint(lane, desk, side)"}
{"solution": "def possible_final_colors(n, s):\n    count = {'R': 0, 'G': 0, 'B': 0}\n    \n    for color in s:\n        count[color] += 1\n    \n    r, g, b = count['R'], count['G'], count['B']\n    \n    if r % 2 == 0 and g % 2 == 0 and b % 2 == 0:\n        return 'BGR'\n    elif r % 2 == 1 and g % 2 == 1 and b % 2 == 1:\n        return 'BGR'\n    else:\n        result = []\n        if r % 2 == 1:\n            result.append('R')\n        if g % 2 == 1:\n            result.append('G')\n        if b % 2 == 1:\n            result.append('B')\n        return ''.join(sorted(result))\n\nn = int(input())\ns = input().strip()\nprint(possible_final_colors(n, s))"}
