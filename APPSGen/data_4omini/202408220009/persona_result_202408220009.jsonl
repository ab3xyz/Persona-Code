{"solution": "def max_length_accordion(s):\n    n = len(s)\n    \n    # Find the first opening bracket\n    first_open = s.find('[')\n    if first_open == -1:\n        return -1  # No opening bracket\n    \n    # Find the first colon after the first opening bracket\n    first_colon = s.find(':', first_open)\n    if first_colon == -1:\n        return -1  # No colon after opening bracket\n    \n    # Find the last closing bracket\n    last_close = s.rfind(']')\n    if last_close == -1 or last_close < first_colon:\n        return -1  # No closing bracket or it's before the colon\n    \n    # Find the second colon after the first colon\n    second_colon = s.find(':', first_colon + 1)\n    if second_colon == -1 or second_colon > last_close:\n        return -1  # No second colon or it's after the closing bracket\n    \n    # Count the number of '|' between the first colon and the second colon\n    count_vertical_lines = s[first_colon + 1:second_colon].count('|')\n    \n    # Calculate the maximum length of the accordion\n    max_length = 1 + 1 + count_vertical_lines + 1 + 1  # [ + : + |* + : + ]\n    \n    return max_length\n\n# Read input\ns = input().strip()\n# Print output\nprint(max_length_accordion(s))"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef max_digit_sum(x):\n    str_x = str(x)\n    max_sum = sum_of_digits(x)\n    best_number = x\n\n    for i in range(len(str_x)):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a candidate by reducing the current digit by 1\n        # and setting all subsequent digits to 9\n        candidate = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (len(str_x) - i - 1)\n        candidate = int(candidate)\n        \n        if candidate > 0 and candidate <= x:\n            candidate_sum = sum_of_digits(candidate)\n            if candidate_sum > max_sum or (candidate_sum == max_sum and candidate > best_number):\n                max_sum = candidate_sum\n                best_number = candidate\n\n    return best_number\n\nx = int(input().strip())\nprint(max_digit_sum(x))"}
{"solution": "def is_lucky(year):\n    # Convert year to string and count non-zero digits\n    return sum(1 for digit in str(year) if digit != '0') <= 1\n\ndef next_lucky_year(n):\n    # Start checking from the next year\n    current_year = n + 1\n    while not is_lucky(current_year):\n        current_year += 1\n    return current_year - n\n\n# Read input\nn = int(input())\n# Print the result\nprint(next_lucky_year(n))"}
{"solution": "def max_painted_sections(n, q, painters):\n    # Step 1: Calculate total coverage with all painters\n    painted = [0] * (n + 1)  # painted[i] will be 1 if section i is painted\n    for l, r in painters:\n        for i in range(l, r + 1):\n            painted[i] = 1\n\n    total_painted = sum(painted)  # Total unique painted sections with all painters\n\n    # Step 2: Evaluate the impact of removing each painter\n    max_painted_after_removal = 0\n\n    for index in range(q):\n        l, r = painters[index]\n        # Create a temporary painted array to simulate removal of the current painter\n        temp_painted = painted[:]\n        \n        # Remove the current painter's contribution\n        for i in range(l, r + 1):\n            temp_painted[i] = 0\n        \n        # Count the number of painted sections after removal\n        painted_after_removal = sum(temp_painted)\n        \n        # Update the maximum painted sections after removing one painter\n        max_painted_after_removal = max(max_painted_after_removal, painted_after_removal)\n\n    # Since we can only hire q - 2 painters, we need to consider the total painted sections\n    # minus the maximum impact of removing one painter\n    return max_painted_after_removal\n\n# Read input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\nresult = max_painted_sections(n, q, painters)\nprint(result)"}
{"solution": "def is_lucky_time(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef find_min_snooze_presses(x, hh, mm):\n    y = 0\n    while True:\n        # Calculate the time y * x minutes before hh:mm\n        total_minutes = hh * 60 + mm - y * x\n        if total_minutes < 0:\n            total_minutes += 24 * 60  # Wrap around to the previous day\n        \n        new_hh = total_minutes // 60\n        new_mm = total_minutes % 60\n        \n        if is_lucky_time(new_hh, new_mm):\n            return y\n        \n        y += 1\n\n# Input reading\nx = int(input().strip())\nhh, mm = map(int, input().strip().split())\n\n# Output the result\nprint(find_min_snooze_presses(x, hh, mm))"}
{"solution": "def min_seconds_to_close_tabs(n, pos, l, r):\n    # If all tabs are already within the range [l, r]\n    if l <= pos <= r:\n        # Close tabs to the left and right\n        left_close_time = 0 if l == 1 else 1 + (pos - l)  # Move to l and close left\n        right_close_time = 0 if r == n else 1 + (r - pos)  # Move to r and close right\n        return left_close_time + right_close_time\n\n    # If the cursor is to the left of the range\n    if pos < l:\n        # Move to l and close all tabs to the left\n        return (l - pos) + (l - 1)\n\n    # If the cursor is to the right of the range\n    if pos > r:\n        # Move to r and close all tabs to the right\n        return (pos - r) + (n - r)\n\n# Read input\nn, pos, l, r = map(int, input().split())\n# Calculate and print the result\nprint(min_seconds_to_close_tabs(n, pos, l, r))"}
{"solution": "import math\n\ndef min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x, blows = query\n        max_effective_damage = float('-inf')\n        \n        for d, h in blows:\n            effective_damage = d - h\n            if effective_damage > 0:\n                max_effective_damage = max(max_effective_damage, effective_damage)\n        \n        if max_effective_damage <= 0:\n            results.append(-1)\n        else:\n            blows_needed = math.ceil(x / max_effective_damage)\n            results.append(blows_needed)\n    \n    return results\n\n# Input reading\nt = int(input())\nqueries = []\n\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Get results\nresults = min_blows_to_defeat_zmei(t, queries)\n\n# Output results\nfor result in results:\n    print(result)"}
{"solution": "def day_when_barn_empty(n, m):\n    total_eaten = 0\n    current_grains = n\n    day = 0\n    \n    while current_grains > 0:\n        day += 1\n        # Add grains to the barn\n        current_grains += m\n        \n        # If the barn exceeds its capacity, it stays full\n        if current_grains > n:\n            current_grains = n\n        \n        # Sparrows eat grains\n        total_eaten += day\n        \n        # Update the current grains after sparrows eat\n        current_grains -= total_eaten\n        \n    return day\n\n# Read input\nn, m = map(int, input().split())\n# Print the result\nprint(day_when_barn_empty(n, m))"}
{"solution": "def min_extra_tiles(tiles):\n    # Parse the input tiles\n    hand = [(int(tile[0]), tile[1]) for tile in tiles]\n    \n    # Check for koutsu (triplet)\n    def has_koutsu(hand):\n        counts = {}\n        for num, suit in hand:\n            if (num, suit) in counts:\n                counts[(num, suit)] += 1\n            else:\n                counts[(num, suit)] = 1\n        return any(count == 3 for count in counts.values())\n    \n    # Check for shuntsu (sequence)\n    def has_shuntsu(hand):\n        suits = {}\n        for num, suit in hand:\n            if suit not in suits:\n                suits[suit] = []\n            suits[suit].append(num)\n        \n        for suit, nums in suits.items():\n            nums.sort()\n            for i in range(len(nums) - 2):\n                if nums[i] + 1 == nums[i + 1] and nums[i] + 2 == nums[i + 2]:\n                    return True\n        return False\n    \n    # Check if already has a mentsu\n    if has_koutsu(hand) or has_shuntsu(hand):\n        return 0\n    \n    # Check for minimum draws needed\n    needed = float('inf')\n    \n    # Check for koutsu\n    counts = {}\n    for num, suit in hand:\n        if (num, suit) in counts:\n            counts[(num, suit)] += 1\n        else:\n            counts[(num, suit)] = 1\n    \n    for (num, suit), count in counts.items():\n        if count == 2:\n            needed = min(needed, 1)  # Need 1 more for koutsu\n        elif count == 1:\n            needed = min(needed, 2)  # Need 2 more for koutsu\n    \n    # Check for shuntsu\n    suits = {}\n    for num, suit in hand:\n        if suit not in suits:\n            suits[suit] = []\n        suits[suit].append(num)\n    \n    for suit, nums in suits.items():\n        nums.sort()\n        for i in range(len(nums) - 1):\n            if nums[i] + 1 == nums[i + 1]:\n                needed = min(needed, 1)  # Need 1 more for shuntsu\n            if i < len(nums) - 2 and nums[i] + 2 == nums[i + 2]:\n                needed = min(needed, 0)  # Already has shuntsu\n    \n    # Check for potential shuntsu with draws\n    for suit in suits:\n        for num in range(1, 10):\n            if num not in suits[suit]:\n                if num - 1 in suits[suit] and num + 1 in suits[suit]:\n                    needed = min(needed, 1)  # Can form shuntsu with 1 draw\n                elif num - 1 in suits[suit] or num + 1 in suits[suit]:\n                    needed = min(needed, 2)  # Need 2 draws to form shuntsu\n    \n    return needed\n\n# Read input\ntiles = input().strip().split()\n# Output the result\nprint(min_extra_tiles(tiles))"}
{"solution": "def find_grandpa_sofa(d, n, m, sofas, counts):\n    cnt_l, cnt_r, cnt_t, cnt_b = counts\n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        \n        # Normalize coordinates to always have (x1, y1) as the top-left corner\n        if x1 > x2 or (x1 == x2 and y1 > y2):\n            x1, y1, x2, y2 = x2, y2, x1, y1\n        \n        left_count = right_count = top_count = bottom_count = 0\n        \n        for j in range(d):\n            if i == j:\n                continue\n            \n            x3, y3, x4, y4 = sofas[j]\n            # Normalize coordinates for comparison\n            if x3 > x4 or (x3 == x4 and y3 > y4):\n                x3, y3, x4, y4 = x4, y4, x3, y3\n            \n            # Check positions\n            if x1 == x3 and y1 < y3:  # A is above B\n                top_count += 1\n            if x1 == x3 and y1 > y4:  # A is below B\n                bottom_count += 1\n            if y1 == y3 and x2 < x3:  # A is to the left of B\n                left_count += 1\n            if y1 == y3 and x1 > x4:  # A is to the right of B\n                right_count += 1\n        \n        # Check if counts match\n        if (left_count == cnt_l and right_count == cnt_r and\n                top_count == cnt_t and bottom_count == cnt_b):\n            return i + 1  # Return 1-based index\n    \n    return -1  # No matching sofa found\n\n# Input reading\nd = int(input())\nn, m = map(int, input().split())\nsofas = [tuple(map(int, input().split())) for _ in range(d)]\ncounts = tuple(map(int, input().split()))\n\n# Output the result\nprint(find_grandpa_sofa(d, n, m, sofas, counts))"}
{"solution": "def calculate_days_off(n):\n    # Calculate minimum days off\n    min_days_off = 0 if n < 5 else 2\n    \n    # Calculate maximum days off\n    complete_weeks = n // 7\n    remaining_days = n % 7\n    max_days_off = complete_weeks * 2 + (1 if remaining_days == 6 else 0)\n    \n    return min_days_off, max_days_off\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the result\nmin_days_off, max_days_off = calculate_days_off(n)\nprint(min_days_off, max_days_off)"}
{"solution": "import math\n\ndef max_chocolates(n, a, b, p, q):\n    count_red = n // a\n    count_blue = n // b\n    lcm_ab = (a * b) // math.gcd(a, b)\n    count_both = n // lcm_ab\n    \n    if p > q:\n        effective_red = count_red - count_both\n        effective_blue = count_blue\n    else:\n        effective_red = count_red\n        effective_blue = count_blue - count_both\n    \n    total_chocolates = (effective_red * p) + (effective_blue * q)\n    return total_chocolates\n\n# Read input\nn, a, b, p, q = map(int, input().split())\n# Calculate and print the result\nprint(max_chocolates(n, a, b, p, q))"}
{"solution": "def max_beauty_after_swap(n, trophies):\n    segments = []\n    current_length = 0\n    \n    # Step 1: Identify segments of 'G'\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n    if current_length > 0:\n        segments.append(current_length)\n    \n    # Step 2: Calculate the maximum length without swaps\n    max_length = max(segments) if segments else 0\n    \n    # Step 3: Consider possible swaps\n    if len(segments) < 2:\n        return max_length  # No possible swaps if less than 2 segments\n    \n    # Step 4: Check for possible combinations\n    for i in range(len(segments) - 1):\n        combined_length = segments[i] + segments[i + 1]\n        max_length = max(max_length, combined_length)\n    \n    # Step 5: Return the maximum possible length\n    return max_length\n\n# Input reading\nn = int(input())\ntrophies = input().strip()\nprint(max_beauty_after_swap(n, trophies))"}
{"solution": "from collections import deque, defaultdict\n\ndef find_courses(n, k, main_courses, dependencies):\n    # Create graph and in-degree array\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    \n    # Read dependencies\n    for i in range(1, n + 1):\n        t_i = dependencies[i - 1][0]\n        for j in range(1, t_i + 1):\n            dep_course = dependencies[i - 1][j]\n            graph[dep_course].append(i)\n            in_degree[i] += 1\n    \n    # Queue for courses with no prerequisites\n    queue = deque()\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    order = []\n    taken_courses = set()\n    \n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        taken_courses.add(course)\n        \n        for next_course in graph[course]:\n            in_degree[next_course] -= 1\n            if in_degree[next_course] == 0:\n                queue.append(next_course)\n    \n    # Check if we can complete all main courses\n    if not all(course in taken_courses for course in main_courses):\n        return -1\n    \n    # Collect the result\n    return len(taken_courses), order\n\n# Input reading\nn, k = map(int, input().split())\nmain_courses = list(map(int, input().split()))\ndependencies = [list(map(int, input().split())) for _ in range(n)]\n\nresult = find_courses(n, k, main_courses, dependencies)\nif result == -1:\n    print(-1)\nelse:\n    m, order = result\n    print(m)\n    print(' '.join(map(str, order)))"}
{"solution": "def is_stack_sortable(n, k, p):\n    # Create a set of used elements from the first k elements\n    used = set(p)\n    # Initialize the result array with the first k elements\n    result = p[:]\n    \n    # Initialize the next number to be added to the permutation\n    next_num = n\n    \n    # Stack to simulate the stack operations\n    stack = []\n    \n    # Iterate through the first k elements\n    for i in range(k):\n        # While the stack is not empty and the top of the stack is the next expected number\n        while stack and stack[-1] == next_num:\n            result.append(stack.pop())\n            next_num -= 1\n        \n        # If the current element is greater than the next expected number, it's invalid\n        if p[i] > next_num:\n            return -1\n        \n        # Push the current element onto the stack\n        stack.append(p[i])\n        \n        # Decrease the next expected number\n        next_num = p[i] - 1\n    \n    # After processing the first k elements, we need to add remaining numbers\n    while next_num > 0:\n        # If the next number is already used, we cannot use it\n        if next_num not in used:\n            stack.append(next_num)\n        next_num -= 1\n    \n    # Now pop all remaining elements from the stack to the result\n    while stack:\n        result.append(stack.pop())\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = is_stack_sortable(n, k, p)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "a, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "def can_form_regular_bracket_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    total_open = 2 * cnt_1 + cnt_2\n    total_close = 2 * cnt_4 + cnt_3\n    \n    # Check if the total number of opening and closing brackets are equal\n    if total_open != total_close:\n        return 0\n    \n    # Check if we have enough opening brackets at any point\n    if cnt_1 + cnt_2 < cnt_3 + cnt_4:\n        return 0\n    \n    return 1\n\n# Read input values\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\n# Print the result\nprint(can_form_regular_bracket_sequence(cnt_1, cnt_2, cnt_3, cnt_4))"}
{"solution": "def standing_spectators(n, k, t):\n    if t <= k:\n        return t\n    elif t <= n:\n        return k\n    else:\n        return k - (t - n - 1)\n\nn, k, t = map(int, input().split())\nprint(standing_spectators(n, k, t))"}
{"solution": "def lexicographically_minimal_string(s):\n    from collections import deque\n    \n    # Initialize an empty deque for t and a list for u\n    t = deque()\n    u = []\n    \n    # Count the frequency of each character in s\n    freq = [0] * 26\n    for char in s:\n        freq[ord(char) - ord('a')] += 1\n    \n    for char in s:\n        # Decrease the frequency of the current character\n        freq[ord(char) - ord('a')] -= 1\n        \n        # Append the current character to t\n        t.append(char)\n        \n        # While we can pop from t to u\n        while t:\n            # Check if the character at the front of t can be moved to u\n            if not t or (freq[ord(t[-1]) - ord('a')] == 0 and t[-1] > min((chr(i + ord('a')) for i in range(26) if freq[i] > 0), default='z' + 1)):\n                break\n            u.append(t.pop())\n    \n    return ''.join(u)\n\n# Read input\ns = input().strip()\nresult = lexicographically_minimal_string(s)\nprint(result)"}
{"solution": "def check_records(test_cases):\n    results = []\n    \n    for case in test_cases:\n        n, stats = case\n        valid = True\n        \n        for i in range(1, n):\n            p_prev, c_prev = stats[i - 1]\n            p_curr, c_curr = stats[i]\n            \n            if p_curr < p_prev or c_curr < c_prev or c_curr > p_curr:\n                valid = False\n                break\n            \n            if (c_curr - c_prev) > (p_curr - p_prev):\n                valid = False\n                break\n        \n        # Check the first moment\n        if stats[0][1] > stats[0][0]:  # c_1 > p_1\n            valid = False\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nT = int(data[0])\nindex = 1\ntest_cases = []\n\nfor _ in range(T):\n    n = int(data[index])\n    index += 1\n    stats = []\n    for _ in range(n):\n        p, c = map(int, data[index].split())\n        stats.append((p, c))\n        index += 1\n    test_cases.append((n, stats))\n\nresults = check_records(test_cases)\nfor result in results:\n    print(result)"}
{"solution": "def is_palindrome(time_str):\n    return time_str == time_str[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        # Format the time as hh:mm\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n        \n        # Increment the time by one minute\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        \n        minutes_passed += 1\n\n# Read input\ncurrent_time = input().strip()\nhh, mm = map(int, current_time.split(':'))\n\n# Calculate the minimum minutes to the next palindromic time\nresult = next_palindrome_time(hh, mm)\n\n# Print the result\nprint(result)"}
{"solution": "def max_distance_after_swap(n, a):\n    # Find the positions of the minimum and maximum elements\n    min_index = a.index(1)\n    max_index = a.index(n)\n    \n    # Calculate the current distance\n    current_distance = abs(min_index - max_index)\n    \n    # Evaluate potential maximum distances after swaps\n    # Swap min element with the first element\n    distance1 = abs(0 - max_index)\n    # Swap min element with the last element\n    distance2 = abs(n - 1 - max_index)\n    # Swap max element with the first element\n    distance3 = abs(min_index - 0)\n    # Swap max element with the last element\n    distance4 = abs(min_index - (n - 1))\n    \n    # The maximum distance achievable after one swap\n    max_distance = max(current_distance, distance1, distance2, distance3, distance4)\n    \n    return max_distance\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_distance_after_swap(n, a))"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    mid = n // 2\n    \n    # For odd length strings, we ignore the middle character\n    if n % 2 == 1:\n        first_half = s[:mid]\n        second_half = s[mid + 1:][::-1]\n    else:\n        first_half = s[:mid]\n        second_half = s[mid:][::-1]\n    \n    return first_half == second_half\n\ns = input().strip()\nif is_s_palindrome(s):\n    print(\"TAK\")\nelse:\n    print(\"NIE\")"}
{"solution": "from itertools import permutations\n\ndef max_permutation_not_exceeding(a, b):\n    a_str = str(a)\n    b_str = str(b)\n    \n    # Generate all unique permutations of the digits of a\n    perm_set = set(permutations(a_str))\n    \n    # Filter permutations that are valid (not starting with '0' and same length as a)\n    valid_permutations = []\n    for perm in perm_set:\n        perm_num_str = ''.join(perm)\n        if perm_num_str[0] != '0' and len(perm_num_str) == len(a_str):\n            perm_num = int(perm_num_str)\n            if perm_num <= b:\n                valid_permutations.append(perm_num)\n    \n    # Return the maximum valid permutation\n    return max(valid_permutations)\n\n# Input reading\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result and print it\nresult = max_permutation_not_exceeding(a, b)\nprint(result)"}
{"solution": "def can_alice_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # horizontal, vertical, diagonal right, diagonal left\n    n = 10  # size of the board\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                # Simulate placing 'X' at (i, j)\n                for dx, dy in directions:\n                    count = 1  # count the placed 'X'\n                    \n                    # Check in the positive direction\n                    x, y = i + dx, j + dy\n                    while 0 <= x < n and 0 <= y < n and board[x][y] == 'X':\n                        count += 1\n                        x += dx\n                        y += dy\n                    \n                    # Check in the negative direction\n                    x, y = i - dx, j - dy\n                    while 0 <= x < n and 0 <= y < n and board[x][y] == 'X':\n                        count += 1\n                        x -= dx\n                        y -= dy\n                    \n                    # Check if we have 5 or more in a row\n                    if count >= 5:\n                        return \"YES\"\n    \n    return \"NO\"\n\n# Read the board input\nboard = [input().strip() for _ in range(10)]\nprint(can_alice_win(board))"}
{"solution": "def construct_symmetric_matrix(n, k):\n    # Maximum number of 1's that can be placed in a symmetric n x n matrix\n    max_ones = (n * (n + 1)) // 2\n    \n    if k > max_ones:\n        return -1\n    \n    # Initialize the matrix with zeros\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the matrix to make it lexicographically maximal\n    for i in range(n):\n        for j in range(i, n):\n            if k > 0:\n                if i == j:  # Diagonal element\n                    matrix[i][j] = 1\n                    k -= 1\n                elif k >= 2:  # Symmetric pair\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n    \n    return matrix\n\n# Read input\nn, k = map(int, input().split())\n\n# Construct the matrix\nresult = construct_symmetric_matrix(n, k)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))"}
{"solution": "def calculate_expressions(x, y, z):\n    expressions = [\n        (x ** (y ** z), \"x^y^z\"),\n        (x ** (z ** y), \"x^z^y\"),\n        ((x ** y) ** z, \"(x^y)^z\"),\n        ((x ** z) ** y, \"(x^z)^y\"),\n        (y ** (x ** z), \"y^x^z\"),\n        (y ** (z ** x), \"y^z^x\"),\n        ((y ** x) ** z, \"(y^x)^z\"),\n        ((y ** z) ** x, \"(y^z)^x\"),\n        (z ** (x ** y), \"z^x^y\"),\n        (z ** (y ** x), \"z^y^x\"),\n        ((z ** x) ** y, \"(z^x)^y\"),\n        ((z ** y) ** x, \"(z^y)^x\"),\n    ]\n    \n    max_value = float('-inf')\n    max_index = -1\n    \n    for index, (value, expr) in enumerate(expressions):\n        if value > max_value:\n            max_value = value\n            max_index = index\n            \n    return expressions[max_index][1]\n\n# Read input\nx, y, z = map(float, input().split())\n\n# Calculate and print the result\nresult = calculate_expressions(x, y, z)\nprint(result)"}
{"solution": "def min_operations(n, s):\n    # Start with the assumption that we will type all characters one by one\n    min_ops = n\n    \n    # Check for possible copy operations\n    for i in range(1, n):\n        # If the prefix s[0:i] can be copied and still match the beginning of s\n        if s[:i] == s[i:i+i]:\n            # Calculate operations: type i characters, copy, and type the rest\n            operations = i + 1 + (n - (i * 2))\n            min_ops = min(min_ops, operations)\n    \n    return min_ops\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(min_operations(n, s))"}
{"solution": "def rename_files(n, files):\n    examples = []\n    regulars = []\n    \n    # Separate examples and regular tests\n    for name, type_ in files:\n        if type_ == '1':\n            examples.append(name)\n        else:\n            regulars.append(name)\n    \n    # Prepare the moves\n    moves = []\n    e = len(examples)\n    \n    # Move example files to their new names\n    for i in range(e):\n        moves.append(f\"move {examples[i]} {i + 1}\")\n    \n    # Move regular test files to their new names\n    for i in range(len(regulars)):\n        moves.append(f\"move {regulars[i]} {e + i + 1}\")\n    \n    # Output the result\n    print(len(moves))\n    for move in moves:\n        print(move)\n\n# Read input\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\n# Call the function\nrename_files(n, files)"}
{"solution": "def min_replacements_to_lucky_ticket(ticket):\n    # Split the ticket into two halves\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    # Calculate the sums of both halves\n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    # If the sums are already equal, no replacements are needed\n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    difference = abs(sum_first - sum_second)\n    \n    # Determine which half needs to be increased or decreased\n    if sum_first > sum_second:\n        # We need to decrease the first half or increase the second half\n        changes = [9 - digit for digit in first_half] + second_half\n    else:\n        # We need to increase the first half or decrease the second half\n        changes = first_half + [9 - digit for digit in second_half]\n    \n    # Sort changes in descending order to maximize the effect of each change\n    changes.sort(reverse=True)\n    \n    # Calculate the minimum number of changes needed\n    num_replacements = 0\n    for change in changes:\n        difference -= change\n        num_replacements += 1\n        if difference <= 0:\n            break\n    \n    return num_replacements\n\n# Read input\nticket = input().strip()\n# Get the result\nresult = min_replacements_to_lucky_ticket(ticket)\n# Print the output\nprint(result)"}
{"solution": "def minimum_traps(m, x):\n    # Since GCD(x, m) = 1, the minimum number of traps needed is m - 1\n    return m - 1\n\n# Read input\nm, x = map(int, input().split())\n\n# Calculate and print the result\nprint(minimum_traps(m, x))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef birthday_paradox(n, k):\n    MOD = 10**6 + 3\n    days = 1 << n  # This is 2^n\n\n    if k > days:\n        return 1, 1  # Guaranteed that at least two people share a birthday\n\n    # Calculate the probability of all k people having different birthdays\n    numerator = 1\n    denominator = pow(days, k, MOD)\n\n    for i in range(k):\n        numerator = (numerator * (days - i)) % MOD\n\n    # Probability of at least one shared birthday\n    # P(at least one shared) = 1 - P(all different)\n    # P(all different) = numerator / denominator\n    # P(at least one shared) = (denominator - numerator) / denominator\n\n    A = (denominator - numerator) % MOD\n    B = denominator\n\n    # Reduce A and B by their gcd\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n\n    return A % MOD, B % MOD\n\n# Read input\nn, k = map(int, input().strip().split())\nA, B = birthday_paradox(n, k)\nprint(A, B)"}
{"solution": "def is_valid_journey(n, journey):\n    current_position = 0  # 0 means North Pole, 20000 means South Pole\n\n    for t, direction in journey:\n        if current_position == 0 and direction != \"South\":\n            return \"NO\"\n        if current_position == 20000 and direction != \"North\":\n            return \"NO\"\n\n        if direction == \"South\":\n            current_position += t\n        elif direction == \"North\":\n            current_position -= t\n        elif direction == \"West\" or direction == \"East\":\n            # Moving West or East does not change the position in terms of North/South\n            continue\n\n        # Check if current position is valid\n        if current_position < 0 or current_position > 20000:\n            return \"NO\"\n\n    # Final position must be North Pole\n    if current_position != 0:\n        return \"NO\"\n\n    return \"YES\"\n\n# Read input\nn = int(input())\njourney = [tuple(input().split()) for _ in range(n)]\njourney = [(int(t), direction) for t, direction in journey]\n\n# Get the result and print it\nresult = is_valid_journey(n, journey)\nprint(result)"}
{"solution": "import sys\nfrom math import gcd\n\ndef count_common_terms(a1, b1, a2, b2, L, R):\n    C = b2 - b1\n    d = gcd(a1, a2)\n\n    if C % d != 0:\n        return 0\n\n    a1 //= d\n    a2 //= d\n    C //= d\n\n    # General solution for k' and l'\n    k0, l0 = 0, 0  # Initial solution (can be found using extended Euclidean algorithm)\n    \n    # Find a particular solution\n    for k in range(0, a2):\n        if (C + a1 * k) % a2 == 0:\n            k0 = k\n            l0 = (C + a1 * k) // a2\n            break\n\n    # Now we have a particular solution (k0, l0)\n    # General solution is:\n    # k' = k0 + a2 * t\n    # l' = l0 + a1 * t\n    # for integer t\n\n    # Calculate the bounds for t\n    # x = a1 * k' + b1 = a1 * (k0 + a2 * t) + b1\n    # x = a1 * k0 + b1 + a1 * a2 * t\n    # We need L <= x <= R\n\n    x0 = a1 * k0 + b1\n    step = a1 * a2\n\n    # Find the minimum t such that x >= L\n    if step > 0:\n        t_min = (L - x0 + step - 1) // step  # ceil((L - x0) / step)\n    else:\n        t_min = 0\n\n    # Find the maximum t such that x <= R\n    if step > 0:\n        t_max = (R - x0) // step  # floor((R - x0) / step)\n    else:\n        t_max = 0\n\n    # The number of valid t values\n    return max(0, t_max - t_min + 1)\n\n# Read input\na1, b1, a2, b2, L, R = map(int, sys.stdin.readline().strip().split())\nresult = count_common_terms(a1, b1, a2, b2, L, R)\nprint(result)"}
{"solution": "def can_distribute(n, a, b, x):\n    plates_from_a = a // x\n    plates_from_b = b // x\n    return plates_from_a + plates_from_b >= n\n\ndef max_min_pieces(n, a, b):\n    low, high = 1, max(a, b)\n    result = 0\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if can_distribute(n, a, b, mid):\n            result = mid  # mid is a valid solution\n            low = mid + 1  # try for a larger x\n        else:\n            high = mid - 1  # try for a smaller x\n            \n    return result\n\n# Input reading\nn, a, b = map(int, input().split())\n# Output the result\nprint(max_min_pieces(n, a, b))"}
{"solution": "def is_valid_flag(n, m, field):\n    # Check for horizontal stripes\n    if n % 3 == 0:\n        stripe_height = n // 3\n        colors = set()\n        for i in range(3):\n            stripe_color = field[i * stripe_height][0]\n            colors.add(stripe_color)\n            for j in range(stripe_height):\n                if field[i * stripe_height + j] != stripe_color * m:\n                    return \"NO\"\n        if len(colors) == 3:\n            return \"YES\"\n\n    # Check for vertical stripes\n    if m % 3 == 0:\n        stripe_width = m // 3\n        colors = set()\n        for i in range(3):\n            stripe_color = field[0][i * stripe_width]\n            colors.add(stripe_color)\n            for j in range(n):\n                if any(field[j][k] != stripe_color for k in range(i * stripe_width, (i + 1) * stripe_width)):\n                    return \"NO\"\n        if len(colors) == 3:\n            return \"YES\"\n\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(is_valid_flag(n, m, field))"}
{"solution": "def find_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    # Determine the layer k\n    k = 0\n    while True:\n        if 1 + 3 * k * (k + 1) > n:\n            break\n        k += 1\n    k -= 1  # k is the last valid layer\n\n    # Calculate the number of moves to the start of layer k\n    moves_to_start_of_k = 1 + 3 * k * (k + 1)\n    position_in_layer = n - moves_to_start_of_k\n\n    # Starting coordinates for layer k\n    x, y = k, 0\n\n    # Determine the position in the layer\n    directions = [\n        (1, 0),  # Right\n        (0, 1),  # Up-Right\n        (-1, 1), # Up-Left\n        (-1, 0), # Left\n        (0, -1), # Down-Left\n        (1, -1)  # Down-Right\n    ]\n\n    # Move through the layer\n    for i in range(position_in_layer):\n        direction = directions[i % 6]\n        x += direction[0]\n        y += direction[1]\n\n    return (x, y)\n\n# Read input\nn = int(input())\nx, y = find_coordinates(n)\nprint(x, y)"}
{"solution": "import math\n\ndef can_deal_exact_damage(a, b, c):\n    # Calculate the greatest common divisor of a and b\n    g = math.gcd(a, b)\n    \n    # Check if c is divisible by the gcd\n    if c % g != 0:\n        return \"No\"\n    \n    # If c is divisible by g, we can express c as a linear combination of a and b\n    return \"Yes\"\n\n# Read input\na, b, c = map(int, input().split())\n\n# Get the result and print it\nresult = can_deal_exact_damage(a, b, c)\nprint(result)"}
{"solution": "def calculate_distances(barriers, L):\n    n = len(barriers)\n    distances = []\n    for i in range(n):\n        next_index = (i + 1) % n\n        distance = (barriers[next_index] - barriers[i]) % L\n        distances.append(distance)\n    return distances\n\ndef can_run_same_track(n, L, kefa_distances, sasha_distances):\n    kefa_distances = calculate_distances(kefa_distances, L)\n    sasha_distances = calculate_distances(sasha_distances, L)\n    \n    # Create a doubled version of Kefa's distances\n    doubled_kefa = kefa_distances + kefa_distances\n    \n    # Check if Sasha's distances is a subarray of doubled Kefa's distances\n    for i in range(n):\n        if doubled_kefa[i:i+n] == sasha_distances:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_run_same_track(n, L, kefa_distances, sasha_distances))"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    # Check if the entire string is a palindrome\n    if not is_palindrome(s):\n        return n  # The whole string is the longest non-palindrome substring\n    \n    # Check if all characters are the same\n    if s.count(s[0]) == n:\n        return 0  # All characters are the same, hence all substrings are palindromes\n    \n    # If the string is a palindrome but not uniform, return n - 1\n    return n - 1\n\n# Read input\ns = input().strip()\n# Print the result\nprint(longest_non_palindrome_substring(s))"}
{"solution": "def determine_round_rating(n, ratings):\n    # Check if any rating has changed\n    for a, b in ratings:\n        if a != b:\n            print(\"rated\")\n            return\n    \n    # Check for unrated condition\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            print(\"unrated\")\n            return\n    \n    # If no ratings changed and standings are in non-increasing order\n    print(\"maybe\")\n\n# Input reading\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Determine the round rating\ndetermine_round_rating(n, ratings)"}
{"solution": "def nearest_zero_distance(n, arr):\n    # Initialize the distance array with a large value\n    distances = [float('inf')] * n\n    \n    # First pass: left to right\n    last_zero_index = -1\n    for i in range(n):\n        if arr[i] == 0:\n            last_zero_index = i\n            distances[i] = 0\n        elif last_zero_index != -1:\n            distances[i] = i - last_zero_index\n    \n    # Second pass: right to left\n    last_zero_index = -1\n    for i in range(n - 1, -1, -1):\n        if arr[i] == 0:\n            last_zero_index = i\n        elif last_zero_index != -1:\n            distances[i] = min(distances[i], last_zero_index - i)\n    \n    print(' '.join(map(str, distances)))\n\n# Read input\nn = int(input().strip())\narr = list(map(int, input().strip().split()))\n\n# Call the function\nnearest_zero_distance(n, arr)"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_cyclic_strings(n, s):\n    m = len(s)\n    \n    # Total number of binary strings of length n\n    total_strings = 2 ** n\n    \n    # Function to count strings of length n that do not contain s\n    def count_without_s(n, s):\n        m = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case: one way to create an empty string\n        \n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] * 2  # All strings of length i-1 can be extended by '0' or '1'\n            if i >= m:\n                # Subtract the cases where the last m characters are exactly s\n                dp[i] -= dp[i - m]\n        \n        return dp[n]\n    \n    # Count strings of length n that do not contain s\n    count_without_s_substring = count_without_s(n, s)\n    \n    # The number of strings that contain s as a substring\n    count_with_s = total_strings - count_without_s_substring\n    \n    # Now we need to account for cyclic shifts\n    # Using Burnside's lemma to count distinct cyclic strings\n    distinct_cyclic_count = 0\n    \n    for k in range(n):\n        # Count the number of strings fixed by the k-th rotation\n        # A string is fixed by a k-th rotation if it is periodic with period gcd(n, k)\n        period = gcd(n, k)\n        count_fixed = 2 ** (n // period)\n        distinct_cyclic_count += count_fixed\n    \n    # Average over the number of rotations\n    distinct_cyclic_count //= n\n    \n    return distinct_cyclic_count\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Calculate and print the result\nresult = count_cyclic_strings(n, s)\nprint(result)"}
{"solution": "import sys\nimport math\n\ndef find_minimal_angle_pair(n, vectors):\n    angles = []\n    \n    # Calculate angles and store with their original indices\n    for i in range(n):\n        x, y = vectors[i]\n        angle = math.atan2(y, x)  # Get the angle in radians\n        angles.append((angle, i + 1))  # Store angle and 1-based index\n\n    # Sort angles\n    angles.sort()\n\n    # Initialize minimum angle and pair of indices\n    min_angle = float('inf')\n    min_pair = (0, 0)\n\n    # Check adjacent angles and wrap around\n    for i in range(n):\n        angle1, index1 = angles[i]\n        angle2, index2 = angles[(i + 1) % n]  # Wrap around to the first angle\n\n        # Calculate the non-oriented angle\n        angle_diff = angle2 - angle1\n        if angle_diff < 0:\n            angle_diff += 2 * math.pi  # Ensure it's non-negative\n\n        # We want the minimal angle between 0 and \u03c0\n        if angle_diff > math.pi:\n            angle_diff = 2 * math.pi - angle_diff\n\n        # Update minimum angle and pair if found\n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            min_pair = (index1, index2)\n\n    return min_pair\n\n# Read input\nn = int(sys.stdin.readline().strip())\nvectors = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n# Find the pair of indices with the minimal non-oriented angle\nresult = find_minimal_angle_pair(n, vectors)\n\n# Print the result\nprint(result[0], result[1])"}
{"solution": "def minimal_time_to_post_office(d, k, a, b, t):\n    # Initialize the minimum time with walking the entire distance\n    min_time = d * b\n    \n    # Calculate the number of full segments Vasiliy can drive\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Calculate time for driving full segments and walking the remaining distance\n    time_with_full_segments = full_segments * (k * a) + (full_segments - 1) * t + remaining_distance * b\n    min_time = min(min_time, time_with_full_segments)\n    \n    # Check if he can drive fewer segments and walk the rest\n    for segments in range(full_segments + 1):\n        distance_driven = segments * k\n        time_spent = distance_driven * a\n        \n        if segments > 0:\n            time_spent += (segments - 1) * t\n        \n        remaining_distance = d - distance_driven\n        time_spent += remaining_distance * b\n        \n        min_time = min(min_time, time_spent)\n    \n    return min_time\n\n# Read input\nd, k, a, b, t = map(int, input().split())\n# Calculate and print the minimal time\nprint(minimal_time_to_post_office(d, k, a, b, t))"}
{"solution": "def create_sequence(n, k):\n    # Calculate the minimum sum of the first k positive integers\n    min_sum = k * (k + 1) // 2\n    \n    # If n is less than the minimum sum, return -1\n    if n < min_sum:\n        return -1\n    \n    # Calculate the maximum GCD\n    d = (n - min_sum) // k + 1\n    \n    # If d is less than or equal to 0, return -1\n    if d <= 0:\n        return -1\n    \n    # Create the sequence\n    sequence = [i + d for i in range(1, k + 1)]\n    \n    return sequence\n\n# Read input\nn, k = map(int, input().split())\n\n# Get the result\nresult = create_sequence(n, k)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def count_pairs(n, m):\n    # Count the number of integers in each remainder class for n\n    count_n = [0] * 5\n    for i in range(5):\n        count_n[i] = (n // 5) + (1 if i <= n % 5 else 0)\n\n    # Count the number of integers in each remainder class for m\n    count_m = [0] * 5\n    for i in range(5):\n        count_m[i] = (m // 5) + (1 if i <= m % 5 else 0)\n\n    # Calculate the number of valid pairs\n    total_pairs = (count_n[0] * count_m[0] +  # (0, 0)\n                   count_n[1] * count_m[4] +  # (1, 4)\n                   count_n[2] * count_m[3] +  # (2, 3)\n                   count_n[3] * count_m[2] +  # (3, 2)\n                   count_n[4] * count_m[1])    # (4, 1)\n\n    return total_pairs\n\n# Read input\nn, m = map(int, input().split())\n# Get the result\nresult = count_pairs(n, m)\n# Print the output\nprint(result)"}
{"solution": "def max_beauty_with_multiplication(n, x, a):\n    # Function to calculate the maximum subarray sum using Kadane's algorithm\n    def kadane(arr):\n        max_ending_here = max_so_far = 0\n        for value in arr:\n            max_ending_here = max(0, max_ending_here + value)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    # Calculate the original beauty of the array\n    original_beauty = kadane(a)\n\n    # Initialize variables to track the maximum beauty after multiplication\n    max_beauty = original_beauty\n\n    # Iterate through all possible subarrays\n    for start in range(n):\n        current_sum = 0\n        for end in range(start, n):\n            current_sum += a[end]\n            # Calculate the new beauty if we multiply the subarray a[start:end+1] by x\n            new_sum = current_sum * x\n            # Calculate the beauty of the array with the modified subarray\n            modified_array = a[:start] + [new_sum] + a[end + 1:]\n            new_beauty = kadane(modified_array)\n            max_beauty = max(max_beauty, new_beauty)\n\n    print(max_beauty)\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Call the function with the input values\nmax_beauty_with_multiplication(n, x, a)"}
{"solution": "def kth_largest_in_multiplication_table(n, m, k):\n    # Binary search for the k-th largest number\n    left, right = 1, n * m\n    \n    while left < right:\n        mid = (left + right) // 2\n        # Count how many numbers are less than or equal to mid\n        count = 0\n        for i in range(1, n + 1):\n            count += min(mid // i, m)\n        \n        if count < k:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left - 1\n\n# Read input\nn, m, k = map(int, input().split())\n# Get the k-th largest number\nresult = kth_largest_in_multiplication_table(n, m, k)\n# Print the result\nprint(result)"}
{"solution": "def find_kth_digit(k):\n    digit_length = 1\n    count = 9\n    start = 1\n    \n    # Step 1: Find the range\n    while k > digit_length * count:\n        k -= digit_length * count\n        digit_length += 1\n        count *= 10\n        start *= 10\n    \n    # Step 2: Find the exact number\n    start += (k - 1) // digit_length\n    number_str = str(start)\n    \n    # Step 3: Find the exact digit\n    digit_index = (k - 1) % digit_length\n    return number_str[digit_index]\n\n# Read input\nk = int(input())\n# Print the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "def maximize_bourles(n, m, r, buying_prices, selling_prices):\n    # Find the minimum buying price\n    min_buy_price = min(buying_prices)\n    \n    # Find the maximum selling price\n    max_sell_price = max(selling_prices)\n    \n    # If the maximum selling price is less than or equal to the minimum buying price,\n    # it's not profitable to buy any shares.\n    if max_sell_price <= min_buy_price:\n        return r\n    \n    # Calculate the maximum number of shares that can be bought\n    shares_to_buy = r // min_buy_price\n    \n    # Calculate the total cost of buying the shares\n    total_cost = shares_to_buy * min_buy_price\n    \n    # Calculate the remaining bourles after buying shares\n    remaining_bourles = r - total_cost\n    \n    # Calculate the total bourles after selling the shares\n    total_bourles_after_selling = remaining_bourles + (shares_to_buy * max_sell_price)\n    \n    return total_bourles_after_selling\n\n# Input reading\nn, m, r = map(int, input().split())\nbuying_prices = list(map(int, input().split()))\nselling_prices = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = maximize_bourles(n, m, r, buying_prices, selling_prices)\nprint(result)"}
{"solution": "def find_original_message(t):\n    n = len(t)\n    \n    # Check for all possible overlap lengths\n    for k in range(1, n // 2 + 1):\n        # Check if the last k characters of t match the first k characters\n        if t[:k] == t[n-k:n]:\n            # If they match, we can construct the original message\n            s = t[:-k]  # Take the string without the last k characters\n            if len(s) > 0 and len(s) + k == n:  # Ensure s is valid\n                return \"YES\\n\" + s\n    \n    return \"NO\"\n\n# Read input\nt = input().strip()\n# Get the result\nresult = find_original_message(t)\n# Print the result\nprint(result)"}
{"solution": "def games_count(k):\n    total_games = 0\n    while k > 1:\n        if k % 2 == 0:\n            total_games += k // 2\n            k //= 2\n        else:\n            total_games += (k * (k - 1)) // 2\n            break\n    return total_games\n\ndef find_teams(n):\n    possible_teams = []\n    k = 1\n    while True:\n        current_games = games_count(k)\n        if current_games > n:\n            break\n        if current_games == n:\n            possible_teams.append(k)\n        k += 1\n    \n    if possible_teams:\n        return possible_teams\n    else:\n        return [-1]\n\n# Input reading\nn = int(input().strip())\nresult = find_teams(n)\n\n# Output results\nfor r in result:\n    print(r)"}
{"solution": "def max_antipalindromic_beauty(n, s, beauty):\n    from collections import Counter\n\n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # Prepare two halves for the antipalindromic string\n    half_length = n // 2\n    first_half = []\n    second_half = []\n    \n    # Create two lists to hold characters for the two halves\n    for char, count in char_count.items():\n        # Distribute characters evenly between the two halves\n        for _ in range(count // 2):\n            first_half.append(char)\n            second_half.append(char)\n        # If there's an odd count, we can only use one character in the first half\n        if count % 2 == 1:\n            first_half.append(char)\n\n    # Sort the halves to maximize beauty\n    first_half.sort()\n    second_half.sort(reverse=True)\n\n    # Create the antipalindromic string t\n    t = first_half + second_half\n\n    # Calculate the maximum beauty\n    max_beauty = 0\n    for i in range(n):\n        if s[i] == t[i]:\n            max_beauty += beauty[i]\n\n    return max_beauty\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\nbeauty = list(map(int, input().strip().split()))\n\n# Calculate and print the maximum beauty\nresult = max_antipalindromic_beauty(n, s, beauty)\nprint(result)"}
{"solution": "def can_balance_scales(w, m):\n    while m > 0:\n        remainder = m % w\n        if remainder > 1:\n            return \"NO\"\n        m //= w\n    return \"YES\"\n\n# Read input\nw, m = map(int, input().split())\n# Print the result\nprint(can_balance_scales(w, m))"}
{"solution": "def find_sequence(n, k):\n    # Step 1: Decompose n into powers of 2\n    powers = []\n    for i in range(60):  # 2^60 is greater than 10^18\n        if n & (1 << i):\n            powers.append(i)\n\n    # Step 2: Check if we can form a sequence of length k\n    if len(powers) > k:\n        print(\"No\")\n        return\n\n    # Step 3: Start with the current powers and fill up to k\n    result = []\n    for power in reversed(powers):\n        result.append(power)\n\n    # Step 4: If we have less than k elements, we need to split the largest powers\n    while len(result) < k:\n        largest = result.pop()  # Take the largest power\n        if largest == 0:\n            print(\"No\")\n            return\n        # Split it into two smaller powers\n        result.append(largest - 1)\n        result.append(largest - 1)\n\n    # Step 5: Sort the result in descending order to ensure lexicographical order\n    result.sort(reverse=True)\n\n    print(\"Yes\")\n    print(\" \".join(map(str, result)))\n\n# Read input\nn, k = map(int, input().split())\nfind_sequence(n, k)"}
{"solution": "def champagne_pyramid(n, t):\n    # Total number of glasses in the pyramid\n    total_glasses = n * (n + 1) // 2\n    glasses = [0] * total_glasses  # Initialize all glasses to 0\n    \n    # Pour champagne for t seconds\n    for _ in range(t):\n        glasses[0] += 1  # Pour 1 unit into the top glass\n        # Check for overflow\n        for i in range(total_glasses):\n            if glasses[i] > 1:  # If the glass overflows\n                overflow = glasses[i] - 1  # Calculate overflow\n                glasses[i] = 1  # Set current glass to full\n                if i + 1 < total_glasses:  # Left child\n                    glasses[i + 1] += overflow / 2\n                if i + 2 < total_glasses:  # Right child\n                    glasses[i + 2] += overflow / 2\n    \n    # Count the number of full glasses\n    full_glasses_count = sum(1 for glass in glasses if glass >= 1)\n    return full_glasses_count\n\n# Read input\nn, t = map(int, input().split())\n# Print the result\nprint(champagne_pyramid(n, t))"}
{"solution": "def calculate_rectangle_area(n, vertices):\n    if n == 1:\n        return -1\n    elif n == 2:\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        return abs(x1 - x2) * abs(y1 - y2)\n    elif n == 3:\n        x_coords = [vertices[0][0], vertices[1][0], vertices[2][0]]\n        y_coords = [vertices[0][1], vertices[1][1], vertices[2][1]]\n        \n        unique_x = set(x_coords)\n        unique_y = set(y_coords)\n        \n        if len(unique_x) == 2 and len(unique_y) == 2:\n            return abs(max(unique_x) - min(unique_x)) * abs(max(unique_y) - min(unique_y))\n        else:\n            return -1\n    elif n == 4:\n        x_coords = [v[0] for v in vertices]\n        y_coords = [v[1] for v in vertices]\n        return (max(x_coords) - min(x_coords)) * (max(y_coords) - min(y_coords))\n\n# Read input\nn = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the area\narea = calculate_rectangle_area(n, vertices)\nprint(area)"}
{"solution": "import math\n\n# Read input values\nn = int(input().strip())\na = int(input().strip())\nb = int(input().strip())\n\n# Calculate the total length needed for two doors\ntotal_length = 4 * a + 2 * b\n\n# Calculate the minimal number of wooden bars needed\nnumber_of_bars = math.ceil(total_length / n)\n\n# Print the result\nprint(number_of_bars)"}
{"solution": "def can_sort_array(n, a, swaps):\n    # Create a list to track the segments of the array that can be sorted\n    segments = []\n    start = 0\n\n    # Identify segments based on the swaps allowed\n    for i in range(n - 1):\n        if swaps[i] == '0':\n            segments.append(a[start:i + 1])\n            start = i + 1\n    segments.append(a[start:n])  # Add the last segment\n\n    # Sort each segment and check if the entire array can be sorted\n    sorted_array = []\n    for segment in segments:\n        sorted_array.extend(sorted(segment))\n\n    # Check if the sorted array matches the original sorted version\n    if sorted_array == sorted(a):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Input reading\nn = int(input().strip())\na = list(map(int, input().strip().split()))\nswaps = input().strip()\n\n# Output the result\nprint(can_sort_array(n, a, swaps))"}
{"solution": "def calculate_wait_time(seat_info):\n    # Extract row number and seat letter\n    n = int(seat_info[:-1])\n    s = seat_info[-1]\n\n    # Time spent serving previous rows\n    if n % 2 == 1:  # Odd row\n        previous_rows = (n // 2) * 2 + 1  # Rows served: 1, 3, ..., n\n    else:  # Even row\n        previous_rows = (n // 2) * 2  # Rows served: 1, 3, ..., n-1\n\n    # Each row takes 6 seconds to serve (3 seats on each side)\n    time_served_previous_rows = previous_rows * 6\n\n    # Time to move to the current row\n    time_to_move = (n // 2) + (n % 2)  # Number of moves to reach row n\n\n    # Time to serve Vasya's seat\n    seat_serving_time = {\n        'f': 1,\n        'e': 2,\n        'd': 3,\n        'a': 4,\n        'b': 5,\n        'c': 6\n    }[s]\n\n    # Total wait time\n    total_wait_time = time_served_previous_rows + time_to_move + seat_serving_time\n\n    return total_wait_time\n\n# Read input\nseat_info = input().strip()\n# Calculate and print the wait time\nprint(calculate_wait_time(seat_info))"}
{"solution": "def convert_to_base_10(digits, base):\n    \"\"\"Convert a number represented by its digits in a given base to base 10.\"\"\"\n    value = 0\n    for digit in digits:\n        value = value * base + digit\n    return value\n\n# Read input for number X\nn, b_x = map(int, input().split())\nx_digits = list(map(int, input().split()))\n\n# Read input for number Y\nm, b_y = map(int, input().split())\ny_digits = list(map(int, input().split()))\n\n# Convert both numbers to base 10\nx_base_10 = convert_to_base_10(x_digits, b_x)\ny_base_10 = convert_to_base_10(y_digits, b_y)\n\n# Compare the two base 10 numbers and print the result\nif x_base_10 < y_base_10:\n    print('<')\nelif x_base_10 > y_base_10:\n    print('>')\nelse:\n    print('=')"}
{"solution": "def determine_winner(n, a):\n    # Calculate the nim-sum (XOR of all elements)\n    nim_sum = 0\n    for num in a:\n        nim_sum ^= num\n    \n    # If nim-sum is 0, BitAryo wins; otherwise, BitLGM wins\n    return \"BitAryo\" if nim_sum == 0 else \"BitLGM\"\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, a))"}
{"solution": "def count_valid_decks(n, k, cards):\n    # Function to calculate the prime factors of a number\n    def prime_factors(x):\n        factors = {}\n        d = 2\n        while d * d <= x:\n            while (x % d) == 0:\n                if d in factors:\n                    factors[d] += 1\n                else:\n                    factors[d] = 1\n                x //= d\n            d += 1\n        if x > 1:\n            factors[x] = 1\n        return factors\n\n    # Get the prime factors of k\n    k_factors = prime_factors(k)\n\n    # Count the number of valid ways\n    valid_count = 0\n    prefix_product = 1\n    suffix_product = 1\n    prefix_factors = {}\n    suffix_factors = {}\n\n    # Calculate prefix factors\n    for i in range(n):\n        prefix_product *= cards[i]\n        for p in prime_factors(cards[i]):\n            if p in prefix_factors:\n                prefix_factors[p] += prime_factors(cards[i])[p]\n            else:\n                prefix_factors[p] = prime_factors(cards[i])[p]\n\n        # Check if the product of the current prefix is divisible by k\n        if all(prefix_factors.get(p, 0) >= k_factors[p] for p in k_factors):\n            valid_count += (n - i)\n\n    # Calculate suffix factors\n    for i in range(n - 1, -1, -1):\n        suffix_product *= cards[i]\n        for p in prime_factors(cards[i]):\n            if p in suffix_factors:\n                suffix_factors[p] += prime_factors(cards[i])[p]\n            else:\n                suffix_factors[p] = prime_factors(cards[i])[p]\n\n        # Check if the product of the current suffix is divisible by k\n        if all(suffix_factors.get(p, 0) >= k_factors[p] for p in k_factors):\n            valid_count += (i + 1)\n\n    # Subtract the double counted cases where both x and y are removed\n    valid_count -= n\n\n    return valid_count\n\n# Input reading\nn, k = map(int, input().split())\ncards = list(map(int, input().split()))\n\n# Output the result\nprint(count_valid_decks(n, k, cards))"}
{"solution": "def can_distribute_balloons(n, k, s):\n    from collections import Counter\n    \n    # Count the frequency of each color\n    color_count = Counter(s)\n    \n    # Check if any color exceeds the number of friends\n    for count in color_count.values():\n        if count > k:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result and print it\nresult = can_distribute_balloons(n, k, s)\nprint(result)"}
{"solution": "def closest_min_distance(arr):\n    min_value = min(arr)\n    last_index = -1\n    min_distance = float('inf')\n\n    for i in range(len(arr)):\n        if arr[i] == min_value:\n            if last_index != -1:\n                min_distance = min(min_distance, i - last_index)\n            last_index = i\n\n    return min_distance\n\n# Read input\nn = int(input())\narray = list(map(int, input().split()))\n\n# Get the result and print it\nresult = closest_min_distance(array)\nprint(result)"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_ties(t, w, b):\n    # Calculate the least common multiple of w and b\n    lcm = (w * b) // gcd(w, b)\n    \n    # Count the number of lengths L where they tie\n    count = 0\n    for k in range(1, t // lcm + 1):\n        # Calculate the range for k\n        start = max(k * w, k * b)\n        end = min((k + 1) * w, (k + 1) * b)\n        \n        if start < end:\n            count += (end - start)\n    \n    return count\n\ndef main():\n    t, w, b = map(int, input().split())\n    \n    # Total possible lengths L\n    total_lengths = t\n    \n    # Count the number of lengths L where they tie\n    tie_count = count_ties(t, w, b)\n    \n    # Calculate the probability as a fraction\n    numerator = tie_count\n    denominator = total_lengths\n    \n    # Reduce the fraction\n    divisor = gcd(numerator, denominator)\n    numerator //= divisor\n    denominator //= divisor\n    \n    # Print the result\n    print(f\"{numerator}/{denominator}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def determine_vote_result(x, y, z):\n    # Calculate the minimum and maximum possible upvotes and downvotes\n    min_upvotes = x\n    max_upvotes = x + z\n    min_downvotes = y\n    max_downvotes = y + z\n\n    # Determine the result based on the ranges\n    if max_upvotes < min_downvotes:\n        return \"-\"\n    elif min_upvotes > max_downvotes:\n        return \"+\"\n    elif min_upvotes == max_downvotes:\n        return \"0\"\n    else:\n        return \"?\"\n\n# Read input\nx, y, z = map(int, input().split())\n\n# Get the result and print it\nresult = determine_vote_result(x, y, z)\nprint(result)"}
{"solution": "def min_change_length(n, operations, x, y):\n    # Count current movements\n    count_U = operations.count('U')\n    count_D = operations.count('D')\n    count_L = operations.count('L')\n    count_R = operations.count('R')\n    \n    # Calculate required movements\n    required_U = max(0, y)\n    required_D = max(0, -y)\n    required_R = max(0, x)\n    required_L = max(0, -x)\n    \n    # Check if it's possible to reach (x, y)\n    if (count_U < required_U or count_D < required_D or \n        count_L < required_L or count_R < required_R):\n        return -1\n    \n    # Calculate how many changes are needed\n    changes_needed = 0\n    changes_needed += max(0, required_U - count_U)\n    changes_needed += max(0, required_D - count_D)\n    changes_needed += max(0, required_R - count_R)\n    changes_needed += max(0, required_L - count_L)\n    \n    # If no changes are needed\n    if changes_needed == 0:\n        return 0\n    \n    # Find the minimum length of the subsegment to change\n    min_index = n\n    max_index = -1\n    \n    # We will track the indices of the operations that need to be changed\n    for i in range(n):\n        if (operations[i] == 'U' and required_U > count_U) or \\\n           (operations[i] == 'D' and required_D > count_D) or \\\n           (operations[i] == 'L' and required_L > count_L) or \\\n           (operations[i] == 'R' and required_R > count_R):\n            min_index = min(min_index, i)\n            max_index = max(max_index, i)\n    \n    # If we found valid indices, calculate the length\n    if max_index != -1:\n        return max_index - min_index + 1\n    else:\n        return 0\n\n# Input reading\nn = int(input().strip())\noperations = input().strip()\nx, y = map(int, input().strip().split())\n\n# Output the result\nprint(min_change_length(n, operations, x, y))"}
{"solution": "def count_balanced_prefixes(T, test_cases):\n    results = []\n    \n    for n, x, s in test_cases:\n        cnt_0 = s.count('0')\n        cnt_1 = n - cnt_0  # since s consists of only '0's and '1's\n        balance_s = cnt_0 - cnt_1\n        \n        # Calculate prefix balances\n        prefix_balances = [0]  # balance of empty prefix\n        current_balance = 0\n        \n        for char in s:\n            if char == '0':\n                current_balance += 1\n            else:\n                current_balance -= 1\n            prefix_balances.append(current_balance)\n        \n        if balance_s == 0:\n            # Check if x can be achieved by any prefix balance\n            if x in prefix_balances:\n                results.append(-1)  # Infinite solutions\n            else:\n                results.append(0)  # No valid prefixes\n        else:\n            count = 0\n            for balance_p in prefix_balances:\n                if (x - balance_p) % balance_s == 0:\n                    k = (x - balance_p) // balance_s\n                    if k >= 0:\n                        count += 1\n            results.append(count)\n    \n    return results\n\n# Input reading\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nT = int(data[0])\ntest_cases = []\n\nfor i in range(T):\n    n, x = map(int, data[2 * i + 1].split())\n    s = data[2 * i + 2]\n    test_cases.append((n, x, s))\n\n# Get results\nresults = count_balanced_prefixes(T, test_cases)\n\n# Print results\nfor result in results:\n    print(result)"}
{"solution": "def min_deletions_to_divisible_by_10k(n, k):\n    n_str = str(n)\n    length = len(n_str)\n    \n    # We need to find k zeros from the end\n    zeros_needed = k\n    deletions = 0\n    found_zeros = 0\n    \n    # Traverse from the end of the number\n    for i in range(length - 1, -1, -1):\n        if n_str[i] == '0':\n            found_zeros += 1\n            if found_zeros == zeros_needed:\n                # We found enough zeros, count how many digits we have seen\n                deletions += (length - 1 - i)  # All digits after the last zero we need to keep\n                break\n        else:\n            deletions += 1  # This digit will be deleted if we haven't found enough zeros yet\n    \n    # If we didn't find enough zeros, we need to delete all non-zero digits\n    if found_zeros < zeros_needed:\n        # We need to delete all digits until we can form a zero\n        deletions += (length - found_zeros)\n    \n    return deletions\n\n# Read input\nn, k = map(int, input().split())\n# Print the result\nprint(min_deletions_to_divisible_by_10k(n, k))"}
{"solution": "def count_questions(n, m, k, x, y):\n    total_pupils = n * m\n    full_cycles = k // (2 * total_pupils)\n    remaining_questions = k % (2 * total_pupils)\n\n    # Each pupil gets full_cycles questions from complete cycles\n    questions_count = [full_cycles] * total_pupils\n\n    # Simulate the remaining questions\n    for i in range(1, n + 1):  # Downward\n        if remaining_questions == 0:\n            break\n        for j in range(1, m + 1):\n            if remaining_questions == 0:\n                break\n            questions_count[(i - 1) * m + (j - 1)] += 1\n            remaining_questions -= 1\n\n    for i in range(n - 1, 0, -1):  # Upward\n        if remaining_questions == 0:\n            break\n        for j in range(1, m + 1):\n            if remaining_questions == 0:\n                break\n            questions_count[(i - 1) * m + (j - 1)] += 1\n            remaining_questions -= 1\n\n    # Determine Sergei's index\n    sergei_index = (x - 1) * m + (y - 1)\n    sergei_questions = questions_count[sergei_index]\n\n    max_questions = max(questions_count)\n    min_questions = min(questions_count)\n\n    return max_questions, min_questions, sergei_questions\n\n# Read input\nn, m, k, x, y = map(int, input().split())\n\n# Get the result\nmax_q, min_q, sergei_q = count_questions(n, m, k, x, y)\n\n# Print the output\nprint(max_q, min_q, sergei_q)"}
{"solution": "def max_beauty_after_turns(ribbon, n):\n    from collections import Counter\n    \n    # Count frequencies of each character\n    freq = Counter(ribbon)\n    max_initial_freq = max(freq.values())\n    length = len(ribbon)\n    \n    # Calculate the maximum beauty achievable\n    if n >= length:\n        return length  # Can change all to the same character\n    else:\n        return min(length, max_initial_freq + n)  # Can increase the max frequency by n\n\n# Read input\nn = int(input().strip())\nribbon_kuro = input().strip()\nribbon_shiro = input().strip()\nribbon_katie = input().strip()\n\n# Calculate maximum beauty for each ribbon\nbeauty_kuro = max_beauty_after_turns(ribbon_kuro, n)\nbeauty_shiro = max_beauty_after_turns(ribbon_shiro, n)\nbeauty_katie = max_beauty_after_turns(ribbon_katie, n)\n\n# Determine the winner\nmax_beauty = max(beauty_kuro, beauty_shiro, beauty_katie)\nwinners = []\n\nif beauty_kuro == max_beauty:\n    winners.append(\"Kuro\")\nif beauty_shiro == max_beauty:\n    winners.append(\"Shiro\")\nif beauty_katie == max_beauty:\n    winners.append(\"Katie\")\n\n# Output the result\nif len(winners) > 1:\n    print(\"Draw\")\nelse:\n    print(winners[0])"}
{"solution": "def days_to_finish_book(c, v_0, v_1, a, l):\n    total_pages_read = 0\n    days = 0\n    \n    while total_pages_read < c:\n        days += 1\n        if days == 1:\n            pages_today = v_0\n        else:\n            pages_today = min(v_0 + (days - 1) * a, v_1) - l\n        \n        total_pages_read += pages_today\n        \n    return days\n\n# Read input\nc, v_0, v_1, a, l = map(int, input().split())\n# Calculate and print the number of days needed to finish the book\nprint(days_to_finish_book(c, v_0, v_1, a, l))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_primes(n):\n    if is_prime(n):\n        print(1)\n        print(n)\n        return\n    \n    if is_prime(n - 2):\n        print(2)\n        print(2, n - 2)\n        return\n    \n    for i in range(3, n, 2):\n        if is_prime(i) and is_prime(n - i - 2):\n            print(3)\n            print(i, n - i - 2, 2)\n            return\n\nn = int(input())\nfind_primes(n)"}
{"solution": "def can_wipe_out_walls(n, m, depot):\n    total_walls = sum(row.count('*') for row in depot)\n    \n    for i in range(n):\n        for j in range(m):\n            # Count walls in the current row and column\n            row_walls = depot[i].count('*')\n            col_walls = sum(depot[k][j] == '*' for k in range(n))\n            \n            # Total walls destroyed if bomb is placed at (i, j)\n            walls_destroyed = row_walls + col_walls\n            \n            # If the bomb is placed on a wall, we counted it twice\n            if depot[i][j] == '*':\n                walls_destroyed -= 1\n            \n            # Check if we can destroy all walls\n            if walls_destroyed == total_walls:\n                return \"YES\", (i + 1, j + 1)  # Return 1-based index\n    \n    return \"NO\", None\n\n# Read input\nn, m = map(int, input().split())\ndepot = [input().strip() for _ in range(n)]\n\n# Get the result\nresult, coordinates = can_wipe_out_walls(n, m, depot)\n\n# Print the output\nprint(result)\nif coordinates:\n    print(coordinates[0], coordinates[1])"}
{"solution": "def minimal_cost(n, m, a, b):\n    r = n % m  # Remainder when n is divided by m\n    \n    if r == 0:\n        return 0  # No cost if already divisible\n    \n    # Cost to demolish r boxes\n    cost_demolish = r * b\n    \n    # Cost to build (m - r) boxes\n    cost_build = (m - r) * a\n    \n    # Return the minimum cost\n    return min(cost_demolish, cost_build)\n\n# Read input values\nn, m, a, b = map(int, input().split())\n# Print the minimal cost\nprint(minimal_cost(n, m, a, b))"}
{"solution": "def max_odd_sum_subsequence(n, arr):\n    total_sum = 0\n    min_odd = float('inf')\n    has_odd = False\n\n    for num in arr:\n        if num > 0:\n            total_sum += num\n            if num % 2 != 0:\n                has_odd = True\n                min_odd = min(min_odd, num)\n        elif num % 2 != 0:\n            has_odd = True\n            min_odd = min(min_odd, num)\n\n    if total_sum % 2 == 0:\n        if has_odd:\n            total_sum -= min_odd\n\n    return total_sum\n\n# Input reading\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output the result\nprint(max_odd_sum_subsequence(n, arr))"}
{"solution": "def count_playlists(n, T, songs):\n    MOD = 10**9 + 7\n    \n    # Initialize a DP table\n    dp = [[[0] * 4 for _ in range(n + 1)] for _ in range(T + 1)]\n    \n    # Base case: 0 songs, 0 time, 1 way (the empty playlist)\n    dp[0][0][0] = 1\n    \n    for time in range(T + 1):\n        for count in range(n):\n            for last_genre in range(4):\n                if dp[time][count][last_genre] == 0:\n                    continue\n                for i in range(n):\n                    song_time, song_genre = songs[i]\n                    if (last_genre != song_genre) and (count + 1 <= n):\n                        if time + song_time <= T:\n                            dp[time + song_time][count + 1][song_genre] += dp[time][count][last_genre]\n                            dp[time + song_time][count + 1][song_genre] %= MOD\n    \n    # Sum all valid playlists of length n that take exactly T time\n    result = 0\n    for last_genre in range(1, 4):\n        result += dp[T][n][last_genre]\n        result %= MOD\n    \n    return result\n\n# Read input\nn, T = map(int, input().split())\nsongs = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(count_playlists(n, T, songs))"}
{"solution": "def mod_inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef expected_length(m):\n    MOD = 10**9 + 7\n    E = [0] * (m + 1)\n    count = [0] * (m + 1)\n\n    for x in range(1, m + 1):\n        g = x\n        for j in range(x, m + 1, x):\n            count[j] += 1\n\n    for g in range(m, 0, -1):\n        total = 0\n        for j in range(g, m + 1, g):\n            total += count[j]\n        if total > 0:\n            E[g] = (1 + sum(E[j] * count[j] for j in range(g, m + 1, g))) * mod_inverse(total, MOD) % MOD\n\n    P = E[1]\n    Q = 1\n    return P * mod_inverse(Q, MOD) % MOD\n\nm = int(input().strip())\nprint(expected_length(m))"}
{"solution": "def count_good_pairs(l, r, x, y):\n    if y % x != 0:\n        return 0\n    \n    k = y // x\n    count = 0\n    \n    # Find all pairs (m, n) such that m * n = k\n    for m in range(1, int(k**0.5) + 1):\n        if k % m == 0:\n            n = k // m\n            \n            # Calculate a and b\n            a1, b1 = x * m, x * n\n            a2, b2 = x * n, x * m\n            \n            # Check if (a1, b1) is within the range\n            if l <= a1 <= r and l <= b1 <= r:\n                count += 1\n            \n            # Check if (a2, b2) is within the range and is different from (a1, b1)\n            if (a1 != b1) and (l <= a2 <= r and l <= b2 <= r):\n                count += 1\n    \n    return count\n\n# Read input\nl, r, x, y = map(int, input().split())\n# Get the result\nresult = count_good_pairs(l, r, x, y)\n# Print the result\nprint(result)"}
{"solution": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef find_min_k(a, b):\n    if a > b:\n        a, b = b, a  # Ensure a <= b\n    d = b - a  # Difference\n    if d == 0:\n        return 0  # a and b are the same\n    mod = a % d\n    if mod == 0:\n        return 0\n    else:\n        return d - mod\n\n# Read input\na, b = map(int, input().split())\n# Print the result\nprint(find_min_k(a, b))"}
{"solution": "def minimal_additional_marks(n, k, marks):\n    current_sum = sum(marks)\n    current_count = n\n    target_average = k - 0.5\n    additional_marks = 0\n\n    while True:\n        new_average = (current_sum + k * additional_marks) / (current_count + additional_marks)\n        if new_average >= target_average:\n            break\n        additional_marks += 1\n\n    return additional_marks\n\n# Read input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = minimal_additional_marks(n, k, marks)\nprint(result)"}
{"solution": "import math\n\ndef find_valid_d(n, a):\n    positive_count = sum(1 for x in a if x > 0)\n    negative_count = sum(1 for x in a if x < 0)\n    required_count = math.ceil(n / 2)\n\n    # Check for d > 0\n    if positive_count >= required_count:\n        return 1  # Any positive d will work, we can return 1\n\n    # Check for d < 0\n    if negative_count >= required_count:\n        return -1  # Any negative d will work, we can return -1\n\n    return 0  # No valid d found\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Finding and printing the result\nresult = find_valid_d(n, a)\nprint(result)"}
{"solution": "def count_pairs_with_max_nines(n):\n    # The maximum number of trailing nines we can achieve is 1 (i.e., sums ending in 9)\n    # We need to find pairs (i, j) such that (i + j) % 10 == 9\n    count = 0\n    \n    # We can iterate through possible last digits\n    for i in range(1, n + 1):\n        j = 9 - (i % 10)\n        if j < 0:\n            j += 10\n        \n        # Calculate the corresponding shovel number for j\n        if j == 0:\n            j = 10\n        if j > 0 and j <= n:\n            # Count pairs (i, n - (i - 1)) if they are valid\n            if i < n - (i - 1):\n                count += 1\n    \n    return count\n\nn = int(input())\nprint(count_pairs_with_max_nines(n))"}
{"solution": "from collections import deque\n\ndef possible_sizes(a, b):\n    sizes = set()\n    sizes.add((a, b))\n    \n    # Halve the bar if possible\n    if a % 2 == 0:\n        sizes.add((a // 2, b))\n    if b % 2 == 0:\n        sizes.add((a, b // 2))\n    \n    # Chip off a third if possible\n    if a % 3 == 0:\n        sizes.add((a // 3, b))\n    if b % 3 == 0:\n        sizes.add((a, b // 3))\n    \n    return sizes\n\ndef min_minutes(a1, b1, a2, b2):\n    area1 = a1 * b1\n    area2 = a2 * b2\n    \n    if area1 == area2:\n        return 0, (a1, b1), (a2, b2)\n    \n    # Use a set to track reachable areas\n    reachable1 = {area1: (a1, b1)}\n    reachable2 = {area2: (a2, b2)}\n    \n    queue1 = deque([(a1, b1, 0)])  # (current_a, current_b, minutes)\n    queue2 = deque([(a2, b2, 0)])\n    \n    while queue1 or queue2:\n        if queue1:\n            a, b, minutes = queue1.popleft()\n            for new_a, new_b in possible_sizes(a, b):\n                new_area = new_a * new_b\n                if new_area in reachable2:\n                    return minutes + 1, (new_a, new_b), reachable2[new_area]\n                if new_area not in reachable1:\n                    reachable1[new_area] = (new_a, new_b)\n                    queue1.append((new_a, new_b, minutes + 1))\n        \n        if queue2:\n            a, b, minutes = queue2.popleft()\n            for new_a, new_b in possible_sizes(a, b):\n                new_area = new_a * new_b\n                if new_area in reachable1:\n                    return minutes + 1, reachable1[new_area], (new_a, new_b)\n                if new_area not in reachable2:\n                    reachable2[new_area] = (new_a, new_b)\n                    queue2.append((new_a, new_b, minutes + 1))\n    \n    return -1\n\n# Input reading\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\n# Get the result\nresult = min_minutes(a1, b1, a2, b2)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(result[0])\n    print(result[1][0], result[1][1])\n    print(result[2][0], result[2][1])"}
{"solution": "def determine_winner(x_p, y_p, x_v, y_v):\n    # Calculate the distances to (0, 0)\n    D_p = x_p + y_p  # Polycarp's distance\n    D_v = x_v + y_v  # Vasiliy's distance\n\n    # Determine the winner based on the distances\n    if D_p < D_v:\n        return \"Polycarp\"\n    elif D_p > D_v:\n        return \"Vasiliy\"\n    else:\n        return \"Polycarp\"  # Polycarp wins if distances are equal due to first-move advantage\n\n# Read input\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Output the winner\nprint(determine_winner(x_p, y_p, x_v, y_v))"}
{"solution": "def calculate_columns(m, d):\n    # Days in each month (non-leap year)\n    days_in_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    # Get the number of days in the given month\n    days = days_in_month[m]\n    \n    # Calculate the number of columns needed\n    # d is the weekday of the first day (1 = Monday, ..., 7 = Sunday)\n    # We need to adjust d to be zero-indexed for easier calculations\n    start_day = d - 1  # Convert to 0-indexed (0 = Monday, ..., 6 = Sunday)\n    \n    # Calculate the number of columns\n    # The first week will have (7 - start_day) days filled\n    filled_days = 7 - start_day\n    \n    # Remaining days after the first week\n    remaining_days = days - filled_days\n    \n    # Calculate full weeks in the remaining days\n    full_weeks = remaining_days // 7\n    \n    # If there are leftover days after full weeks, we need an additional column\n    if remaining_days % 7 > 0:\n        full_weeks += 1\n    \n    # Total columns is the first week + full weeks\n    total_columns = 1 + full_weeks\n    \n    return total_columns\n\n# Read input\nm, d = map(int, input().split())\n\n# Calculate and print the number of columns\nprint(calculate_columns(m, d))"}
{"solution": "def count_years_with_one_zero(a, b):\n    count = 0\n    \n    # Iterate over possible values of k\n    for k in range(1, 60):\n        # Generate the number with all bits set to 1 (2^k - 1)\n        all_ones = (1 << k) - 1\n        \n        # Insert a zero in all possible positions\n        for pos in range(k + 1):\n            # Create the number by inserting a zero at position `pos`\n            number_with_zero = all_ones | (1 << pos)\n            \n            # Check if the number is within the range [a, b]\n            if a <= number_with_zero <= b:\n                count += 1\n    \n    return count\n\n# Read input\na, b = map(int, input().split())\n# Get the result\nresult = count_years_with_one_zero(a, b)\n# Print the result\nprint(result)"}
{"solution": "def minimal_layers(N):\n    # Create an array to count the number of segments covering each point\n    coverage = [0] * (N + 1)\n    \n    # Count the coverage for each segment [i, j]\n    for i in range(N):\n        for j in range(i + 1, N + 1):\n            for k in range(i, j + 1):\n                coverage[k] += 1\n    \n    # The maximum coverage at any point will determine the number of layers needed\n    return max(coverage)\n\n# Read input\nN = int(input().strip())\n# Output the result\nprint(minimal_layers(N))"}
{"solution": "def factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n\ndef count_ways(cubes, k, target_sum):\n    n = len(cubes)\n    total_ways = 0\n    \n    # Iterate through all subsets of cubes\n    for mask in range(1 << n):\n        selected_cubes = []\n        for i in range(n):\n            if mask & (1 << i):\n                selected_cubes.append(cubes[i])\n        \n        m = len(selected_cubes)\n        # We can apply at most k stickers\n        for sticker_mask in range(1 << m):\n            if bin(sticker_mask).count('1') > k:\n                continue\n            \n            current_sum = 0\n            for j in range(m):\n                if sticker_mask & (1 << j):\n                    current_sum += factorial(selected_cubes[j])\n                else:\n                    current_sum += selected_cubes[j]\n            \n            if current_sum == target_sum:\n                total_ways += 1\n    \n    return total_ways\n\n# Read input\nn, k, S = map(int, input().split())\ncubes = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = count_ways(cubes, k, S)\nprint(result)"}
{"solution": "def can_transform_to_target_array(test_cases):\n    results = []\n    \n    for n, k, a in test_cases:\n        # Dictionary to count the occurrences of each power of k\n        power_count = {}\n        \n        # Process each element in the target array\n        for number in a:\n            current = number\n            power_index = 0\n            \n            while current > 0:\n                # Get the current digit in base k\n                digit = current % k\n                \n                if digit > 1:\n                    results.append(\"NO\")\n                    break\n                \n                if digit == 1:\n                    if power_index in power_count:\n                        power_count[power_index] += 1\n                    else:\n                        power_count[power_index] = 1\n                \n                current //= k\n                power_index += 1\n            else:\n                continue  # Only continue if we didn't break\n            break  # Break the outer loop if we appended \"NO\"\n        else:\n            # If we didn't break, we can check if we can satisfy the counts\n            if all(count <= 1 for count in power_count.values()):\n                results.append(\"YES\")\n            else:\n                results.append(\"NO\")\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nT = int(data[0])\ntest_cases = []\n\nfor i in range(T):\n    n, k = map(int, data[2 * i + 1].split())\n    a = list(map(int, data[2 * i + 2].split()))\n    test_cases.append((n, k, a))\n\n# Get results\nresults = can_transform_to_target_array(test_cases)\n\n# Print results\nfor result in results:\n    print(result)"}
{"solution": "def count_divisors(max_n):\n    divisor_count = [0] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        for j in range(i, max_n + 1, i):\n            divisor_count[j] += 1\n    return divisor_count\n\ndef calculate_sum(a, b, c):\n    max_n = a * b * c\n    divisor_count = count_divisors(max_n)\n    \n    result = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                result += divisor_count[i * j * k]\n                result %= 1073741824  # Take modulo at each step to avoid overflow\n    return result\n\n# Input reading\na, b, c = map(int, input().split())\nprint(calculate_sum(a, b, c))"}
{"solution": "def get_possible_moves(grid):\n    moves = []\n    empty_pos = [(i, j) for i in range(2) for j in range(2) if grid[i][j] == 'X'][0]\n    x, y = empty_pos\n    \n    # Possible directions to move (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    for dx, dy in directions:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < 2 and 0 <= ny < 2:  # Check bounds\n            # Create a new configuration by swapping\n            new_grid = [list(row) for row in grid]  # Deep copy\n            new_grid[x][y], new_grid[nx][ny] = new_grid[nx][ny], new_grid[x][y]\n            moves.append(tuple(tuple(row) for row in new_grid))  # Store as tuple for immutability\n    \n    return moves\n\ndef generate_configurations(initial_grid):\n    from collections import deque\n    \n    configurations = set()\n    queue = deque([initial_grid])\n    \n    while queue:\n        current = queue.popleft()\n        if current in configurations:\n            continue\n        configurations.add(current)\n        \n        for next_config in get_possible_moves(current):\n            if next_config not in configurations:\n                queue.append(next_config)\n    \n    return configurations\n\ndef can_become_bff(initial_bessie, initial_elsie):\n    bessie_config = generate_configurations(tuple(tuple(row) for row in initial_bessie))\n    elsie_config = generate_configurations(tuple(tuple(row) for row in initial_elsie))\n    \n    return \"YES\" if bessie_config & elsie_config else \"NO\"\n\n# Read input\nbessie_puzzle = [input().strip() for _ in range(2)]\nelsie_puzzle = [input().strip() for _ in range(2)]\n\n# Output the result\nprint(can_become_bff(bessie_puzzle, elsie_puzzle))"}
{"solution": "def base_n_to_decimal(n, k):\n    decimal_value = 0\n    length = len(k)\n    \n    for i in range(length):\n        digit = int(k[length - 1 - i])  # Get the digit from the end\n        decimal_value += digit * (n ** i)  # Calculate the decimal value\n    \n    return decimal_value\n\n# Read input values\nn = int(input().strip())\nk = input().strip()\n\n# Calculate the result\nresult = base_n_to_decimal(n, k)\n\n# Print the output\nprint(result)"}
{"solution": "def is_unimodal(arr):\n    n = len(arr)\n    if n == 0:\n        return \"NO\"\n    \n    increasing = True\n    constant = False\n    \n    for i in range(1, n):\n        if increasing:\n            if arr[i] > arr[i - 1]:\n                continue\n            elif arr[i] == arr[i - 1]:\n                increasing = False\n                constant = True\n            else:\n                return \"NO\"\n        elif constant:\n            if arr[i] == arr[i - 1]:\n                continue\n            elif arr[i] < arr[i - 1]:\n                constant = False\n            else:\n                return \"NO\"\n        else:\n            if arr[i] < arr[i - 1]:\n                continue\n            else:\n                return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output the result\nprint(is_unimodal(arr))"}
{"solution": "def count_occurrences(y, n):\n    count = 0\n    # Count for even y\n    if y % 2 == 0:\n        while y <= n:\n            count += 1\n            y *= 2\n    else:\n        # Count for odd y\n        count += 1  # y itself\n        # Count even numbers that can reach y\n        even_y = y + 1\n        while even_y <= n:\n            count += 1\n            even_y *= 2\n    return count\n\ndef max_y_with_at_least_k_occurrences(n, k):\n    low, high = 1, n\n    answer = 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if count_occurrences(mid, n) >= k:\n            answer = mid  # mid is a valid candidate\n            low = mid + 1  # try for a larger y\n        else:\n            high = mid - 1  # try for a smaller y\n    \n    return answer\n\n# Input reading\nn, k = map(int, input().split())\nprint(max_y_with_at_least_k_occurrences(n, k))"}
{"solution": "def find_pocket(n, m, x, y, v_x, v_y):\n    # Calculate the time to hit the walls\n    if v_x == 1:\n        t_right = (n - x) / 1\n    elif v_x == -1:\n        t_right = x / 1\n    else:\n        t_right = float('inf')  # No horizontal movement\n\n    if v_y == 1:\n        t_top = (m - y) / 1\n    elif v_y == -1:\n        t_top = y / 1\n    else:\n        t_top = float('inf')  # No vertical movement\n\n    # Determine which wall will be hit first\n    while True:\n        if t_right < t_top:\n            # Hits right wall first\n            x = n\n            y += v_y * t_right\n            if y >= m:\n                y = 2 * m - y  # Reflect\n            elif y < 0:\n                y = -y  # Reflect\n            # Check if it falls into a pocket\n            if y == 0:\n                return (n, 0)\n            elif y == m:\n                return (n, m)\n            # Update time to hit walls again\n            t_right = float('inf')  # No more right wall hits\n            t_top = (m - y) / 1 if v_y == 1 else y / 1 if v_y == -1 else float('inf')\n            t_left = x / 1 if v_x == -1 else float('inf')\n            t_bottom = float('inf')  # No more bottom wall hits\n        else:\n            # Hits top wall first\n            y = m\n            x += v_x * t_top\n            if x >= n:\n                x = 2 * n - x  # Reflect\n            elif x < 0:\n                x = -x  # Reflect\n            # Check if it falls into a pocket\n            if x == 0:\n                return (0, m)\n            elif x == n:\n                return (n, m)\n            # Update time to hit walls again\n            t_top = float('inf')  # No more top wall hits\n            t_right = (n - x) / 1 if v_x == 1 else float('inf')\n            t_left = x / 1 if v_x == -1 else float('inf')\n            t_bottom = y / 1 if v_y == -1 else float('inf')\n\n        # Check for indefinite movement\n        if (v_x == 1 and x == n) or (v_x == -1 and x == 0) or (v_y == 1 and y == m) or (v_y == -1 and y == 0):\n            return -1\n\n# Read input\nn, m, x, y, v_x, v_y = map(int, input().split())\nresult = find_pocket(n, m, x, y, v_x, v_y)\n\n# Print output\nif result == -1:\n    print(-1)\nelse:\n    print(result[0], result[1])"}
{"solution": "def can_fit_paintings(board, painting1, painting2):\n    a1, b1 = board\n    a2, b2 = painting1\n    a3, b3 = painting2\n\n    # Check all possible orientations and placements\n    # 1. Both paintings side by side\n    if (a2 + a3 <= a1 and max(b2, b3) <= b1) or (max(a2, a3) <= a1 and b2 + b3 <= b1):\n        return True\n    # 2. Both paintings stacked\n    if (max(a2, a3) <= a1 and b2 + b3 <= b1) or (a2 + a3 <= a1 and max(b2, b3) <= b1):\n        return True\n    # 3. Rotating paintings\n    if (b2 + b3 <= b1 and max(a2, a3) <= a1) or (max(b2, b3) <= b1 and a2 + a3 <= a1):\n        return True\n    if (a2 + b3 <= a1 and b2 + a3 <= b1) or (b2 + a3 <= a1 and a2 + b3 <= b1):\n        return True\n    if (b2 + a3 <= a1 and a2 + b3 <= b1) or (a2 + b3 <= a1 and b2 + a3 <= b1):\n        return True\n\n    return False\n\n# Input reading\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\n# Check if the paintings can fit on the board\nif can_fit_paintings((a1, b1), (a2, b2), (a3, b3)):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_geometric_progression_terms(b1, q, l, m, bad_integers):\n    # Convert bad integers to a set for O(1) lookups\n    bad_set = set(bad_integers)\n    \n    # Handle special cases\n    if abs(b1) > l:\n        return 0  # First term is out of bounds\n    \n    if q == 0:\n        if b1 in bad_set:\n            return 0  # First term is bad\n        if 0 in bad_set:\n            return 1  # Only b1 is written\n        return \"inf\"  # b1 is written, then infinitely many 0s\n    \n    if q == 1:\n        if b1 in bad_set:\n            return 0  # All terms are bad\n        return \"inf\"  # All terms are b1 and valid\n    \n    if q == -1:\n        if b1 in bad_set and -b1 in bad_set:\n            return 0  # Both terms are bad\n        if b1 in bad_set or -b1 in bad_set:\n            return 1  # One term is bad, the other is valid\n        return \"inf\"  # Both terms are valid\n    \n    # For |q| > 1\n    count = 0\n    current_term = b1\n    \n    while abs(current_term) <= l:\n        if current_term not in bad_set:\n            count += 1\n        current_term *= q\n    \n    return count\n\n# Read input\nb1, q, l, m = map(int, input().split())\nbad_integers = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = count_geometric_progression_terms(b1, q, l, m, bad_integers)\nprint(result)"}
{"solution": "def find_frame(n, m, monitor):\n    # Step 1: Find the boundaries of the white pixels\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if monitor[i][j] == 'w':\n                if i < min_row:\n                    min_row = i\n                if i > max_row:\n                    max_row = i\n                if j < min_col:\n                    min_col = j\n                if j > max_col:\n                    max_col = j\n    \n    # Step 2: Check if we can create a frame\n    if min_row == 0 or max_row == n - 1 or min_col == 0 or max_col == m - 1:\n        return -1  # Frame cannot be created if it touches the edges\n    \n    # Step 3: Create the new monitor with the frame\n    new_monitor = [['.' for _ in range(m)] for _ in range(n)]\n    \n    # Copy the original monitor and add the frame\n    for i in range(n):\n        for j in range(m):\n            new_monitor[i][j] = monitor[i][j]\n    \n    # Add the frame\n    for j in range(min_col, max_col + 1):\n        new_monitor[min_row - 1][j] = '+'\n        new_monitor[max_row + 1][j] = '+'\n    \n    for i in range(min_row - 1, max_row + 2):\n        new_monitor[i][min_col - 1] = '+'\n        new_monitor[i][max_col + 1] = '+'\n    \n    # Step 4: Return the result\n    return [''.join(row) for row in new_monitor]\n\n# Input reading\nn, m = map(int, input().split())\nmonitor = [input().strip() for _ in range(n)]\n\n# Find the frame and print the result\nresult = find_frame(n, m, monitor)\nif result == -1:\n    print(-1)\nelse:\n    for line in result:\n        print(line)"}
{"solution": "def extended_gcd(a, b):\n    if b == 0:\n        return a, 1, 0\n    gcd, x1, y1 = extended_gcd(b, a % b)\n    x = y1\n    y = x1 - (a // b) * y1\n    return gcd, x, y\n\ndef can_buy(n, a, b):\n    gcd, x0, y0 = extended_gcd(a, b)\n    \n    if n % gcd != 0:\n        return \"NO\"\n    \n    # Scale the solution\n    x0 *= n // gcd\n    y0 *= n // gcd\n    \n    # Adjust to find non-negative solutions\n    k = 0\n    while x0 < 0 or y0 < 0:\n        if x0 < 0:\n            k += 1\n            x0 += b // gcd\n            y0 -= a // gcd\n        if y0 < 0:\n            k -= 1\n            x0 -= b // gcd\n            y0 += a // gcd\n    \n    if x0 >= 0 and y0 >= 0:\n        return \"YES\", x0, y0\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\n\n# Get the result\nresult = can_buy(n, a, b)\n\n# Print the output\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(result[1], result[2])"}
{"solution": "def number_to_words(s):\n    # Define the mappings for numbers\n    units = [\n        \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \n        \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \n        \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \n        \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \n        \"nineteen\"\n    ]\n    \n    tens = [\n        \"\", \"\", \"twenty\", \"thirty\", \"forty\", \n        \"fifty\", \"sixty\", \"seventy\", \"eighty\", \n        \"ninety\"\n    ]\n    \n    if 0 <= s < 20:\n        return units[s]\n    elif 20 <= s < 100:\n        ten_part = tens[s // 10]\n        unit_part = units[s % 10]\n        if unit_part == \"zero\":\n            return ten_part\n        else:\n            return f\"{ten_part}-{unit_part}\"\n\n# Read input\ns = int(input().strip())\n# Print the output\nprint(number_to_words(s))"}
{"solution": "def max_erasable_elements(n, a):\n    max_erase = 0\n    \n    # Check the edges\n    max_erase = max(max_erase, a[0] - 1)  # Erasing from the start\n    max_erase = max(max_erase, 1000 - a[-1])  # Erasing from the end\n    \n    # Check the gaps between consecutive elements\n    for i in range(1, n):\n        gap = a[i] - a[i - 1] - 1  # Number of elements that can be erased\n        max_erase = max(max_erase, gap)\n    \n    return max_erase\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_erasable_elements(n, a))"}
{"solution": "def find_equator_day(n, a):\n    total_problems = sum(a)\n    half_problems = total_problems / 2\n    cumulative_sum = 0\n    \n    for i in range(n):\n        cumulative_sum += a[i]\n        if cumulative_sum >= half_problems:\n            return i + 1  # +1 because we need 1-based index\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nprint(find_equator_day(n, a))"}
{"solution": "from collections import deque\n\n# Define the movement patterns for each piece\nknight_moves = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)]\nbishop_moves = [(-1, -1), (-1, 1), (1, -1), (1, 1)]\nrook_moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\ndef get_piece_moves(piece, x, y, N):\n    moves = []\n    if piece == 'knight':\n        for dx, dy in knight_moves:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                moves.append((nx, ny))\n    elif piece == 'bishop':\n        for dx, dy in bishop_moves:\n            nx, ny = x, y\n            while 0 <= nx < N and 0 <= ny < N:\n                moves.append((nx, ny))\n                nx += dx\n                ny += dy\n    elif piece == 'rook':\n        for dx, dy in rook_moves:\n            nx, ny = x, y\n            while 0 <= nx < N and 0 <= ny < N:\n                moves.append((nx, ny))\n                nx += dx\n                ny += dy\n    return moves\n\ndef bfs(N, board):\n    positions = {}\n    for i in range(N):\n        for j in range(N):\n            positions[board[i][j]] = (i, j)\n\n    # BFS queue: (current_number, current_x, current_y, current_piece, steps, replacements)\n    queue = deque()\n    visited = set()\n    \n    # Initialize with all pieces at position of number 1\n    for piece in ['knight', 'bishop', 'rook']:\n        queue.append((1, *positions[1], piece, 0, 0))\n        visited.add((1, positions[1][0], positions[1][1], piece))\n\n    min_steps = float('inf')\n    min_replacements = float('inf')\n\n    while queue:\n        current_number, x, y, current_piece, steps, replacements = queue.popleft()\n\n        if current_number == N * N:\n            if steps < min_steps or (steps == min_steps and replacements < min_replacements):\n                min_steps = steps\n                min_replacements = replacements\n            continue\n\n        # Get next number's position\n        next_number = current_number + 1\n        if next_number in positions:\n            next_x, next_y = positions[next_number]\n\n            # Move with the current piece\n            for move in get_piece_moves(current_piece, x, y, N):\n                if move == (next_x, next_y):\n                    if (next_number, next_x, next_y, current_piece) not in visited:\n                        visited.add((next_number, next_x, next_y, current_piece))\n                        queue.append((next_number, next_x, next_y, current_piece, steps + 1, replacements))\n\n            # Replace the piece and move\n            for new_piece in ['knight', 'bishop', 'rook']:\n                if new_piece != current_piece:\n                    for move in get_piece_moves(new_piece, x, y, N):\n                        if move == (next_x, next_y):\n                            if (next_number, next_x, next_y, new_piece) not in visited:\n                                visited.add((next_number, next_x, next_y, new_piece))\n                                queue.append((next_number, next_x, next_y, new_piece, steps + 1, replacements + 1))\n\n    return min_steps, min_replacements\n\n# Read input\nN = int(input())\nboard = [list(map(int, input().split())) for _ in range(N)]\n\n# Solve the problem\nsteps, replacements = bfs(N, board)\n\n# Output the result\nprint(steps, replacements)"}
{"solution": "import math\n\ndef calculate_time(n, m, k, a, b):\n    # Function to get entrance, floor, and apartment on floor\n    def get_location(x):\n        entrance = (x - 1) // (m * k) + 1\n        floor = ((x - 1) % (m * k)) // k + 1\n        apartment_on_floor = (x - 1) % k + 1\n        return entrance, floor, apartment_on_floor\n\n    # Get Edward's and Natasha's locations\n    edward_entrance, edward_floor, _ = get_location(a)\n    natasha_entrance, natasha_floor, _ = get_location(b)\n\n    # Calculate time using stairs\n    def time_using_stairs():\n        time = 0\n        # Go down to the first floor\n        time += (edward_floor - 1) * 5\n        # Walk to Natasha's entrance\n        time += 15 * min(abs(edward_entrance - natasha_entrance), n - abs(edward_entrance - natasha_entrance))\n        # Go up to Natasha's floor\n        time += (natasha_floor - 1) * 5\n        return time\n\n    # Calculate time using elevator\n    def time_using_elevator():\n        time = 0\n        # Call the elevator and go to the first floor\n        time += 10 + (edward_floor - 1) * 1\n        # Walk to Natasha's entrance\n        time += 15 * min(abs(edward_entrance - natasha_entrance), n - abs(edward_entrance - natasha_entrance))\n        # Go up to Natasha's floor\n        time += (natasha_floor - 1) * 1\n        return time\n\n    # Calculate both times\n    stairs_time = time_using_stairs()\n    elevator_time = time_using_elevator()\n\n    # Return the minimum time\n    return min(stairs_time, elevator_time)\n\n# Read input\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate and print the minimum time\nprint(calculate_time(n, m, k, a, b))"}
{"solution": "def can_form_divisible_by_64(s):\n    count_ones = s.count('1')\n    count_zeros = s.count('0')\n    \n    if count_ones >= 1 and count_zeros >= 6:\n        return \"yes\"\n    else:\n        return \"no\"\n\n# Read input\ns = input().strip()\n# Print the result\nprint(can_form_divisible_by_64(s))"}
{"solution": "def transform_to_alphabet_subsequence(s):\n    target = 'abcdefghijklmnopqrstuvwxyz'\n    target_index = 0\n    n = len(s)\n    result = list(s)\n\n    for i in range(n):\n        if target_index < 26 and result[i] < target[target_index]:\n            result[i] = target[target_index]\n        if target_index < 26 and result[i] == target[target_index]:\n            target_index += 1\n\n    if target_index < 26:\n        return \"-1\"\n    \n    return ''.join(result)\n\n# Read input\ns = input().strip()\n# Get the result\nresult = transform_to_alphabet_subsequence(s)\n# Print the result\nprint(result)"}
{"solution": "def max_expected_fishes(n, m, r, k):\n    # Total number of positions the scoop can be placed\n    total_positions = (n - r + 1) * (m - r + 1)\n    \n    # If the number of fishes is less than or equal to the number of positions,\n    # the maximum expected number of caught fishes is simply k divided by the total positions.\n    if k <= total_positions:\n        return k * (r * r) / total_positions\n    \n    # If k is greater than the number of positions, we can fill all positions\n    # and the expected value will be the maximum possible fishes that can be caught\n    # in the scoop area.\n    max_fishes_in_scoop = r * r\n    return min(k, total_positions) * (max_fishes_in_scoop) / total_positions\n\n# Read input\nn, m, r, k = map(int, input().split())\n\n# Calculate the maximum expected number of caught fishes\nresult = max_expected_fishes(n, m, r, k)\n\n# Print the result with the required precision\nprint(f\"{result:.10f}\")"}
{"solution": "def maximize_product(n, a):\n    negative_count = sum(1 for x in a if x < 0)\n    \n    # If we have an odd number of negatives, we will leave one negative\n    leave_one_negative = (negative_count % 2 == 1)\n    \n    result = []\n    \n    for x in a:\n        if x > 0:\n            # Convert positive to negative\n            result.append(-x - 1)\n        elif x < 0:\n            if leave_one_negative:\n                # Leave one negative as is\n                result.append(x)\n                leave_one_negative = False  # Only leave one\n            else:\n                # Convert negative to positive\n                result.append(-x - 1)\n        else:\n            # x is zero, convert to -1\n            result.append(-1)\n    \n    return result\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = maximize_product(n, a)\n\n# Print the result\nprint(\" \".join(map(str, result)))"}
{"solution": "def kth_smallest_divisor(n, k):\n    divisors = []\n    \n    # Iterate through potential divisors from 1 to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)  # i is a divisor\n            if i != n // i:\n                divisors.append(n // i)  # n // i is also a divisor\n\n    # Sort the list of divisors\n    divisors.sort()\n    \n    # Check if k-th smallest divisor exists\n    if k > len(divisors):\n        return -1\n    else:\n        return divisors[k - 1]\n\n# Read input\nn, k = map(int, input().split())\n# Get the result\nresult = kth_smallest_divisor(n, k)\n# Print the output\nprint(result)"}
{"solution": "def can_form_number(cubes, number):\n    str_num = str(number)\n    used_cubes = [False] * len(cubes)\n    \n    for digit in str_num:\n        found = False\n        for i in range(len(cubes)):\n            if not used_cubes[i] and int(digit) in cubes[i]:\n                used_cubes[i] = True\n                found = True\n                break\n        if not found:\n            return False\n    return True\n\ndef max_natural_number(cubes):\n    x = 0\n    while True:\n        x += 1\n        if not can_form_number(cubes, x):\n            return x - 1\n\n# Input reading\nn = int(input().strip())\ncubes = [list(map(int, input().strip().split())) for _ in range(n)]\n\n# Finding the maximum natural number\nresult = max_natural_number(cubes)\nprint(result)"}
{"solution": "import math\n\ndef k_rounding(n, k):\n    # Calculate 10^k\n    ten_power_k = 10 ** k\n    \n    # Calculate the least common multiple (LCM) of n and 10^k\n    lcm = (n * ten_power_k) // math.gcd(n, ten_power_k)\n    \n    return lcm\n\n# Read input\nn, k = map(int, input().strip().split())\n\n# Get the k-rounding of n\nresult = k_rounding(n, k)\n\n# Print the result\nprint(result)"}
{"solution": "def transform_matrices(n, m, A):\n    B = [[0] * m for _ in range(n)]\n    operations = []\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            # Check if we can perform the operation at (i, j)\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                # Perform the operation\n                B[i][j] = 1\n                B[i][j + 1] = 1\n                B[i + 1][j] = 1\n                B[i + 1][j + 1] = 1\n                operations.append((i + 1, j + 1))  # Store 1-based index\n\n    # Check if B matches A\n    if B == A:\n        print(len(operations))\n        for op in operations:\n            print(op[0], op[1])\n    else:\n        print(-1)\n\n# Read input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\ntransform_matrices(n, m, A)"}
{"solution": "def probabilities(r, s, p):\n    # Memoization dictionary\n    memo = {}\n\n    def dp(r, s, p):\n        if (r, s, p) in memo:\n            return memo[(r, s, p)]\n        \n        total = r + s + p\n        if total == 0:\n            return (0.0, 0.0, 0.0)\n        if r == 0:\n            return (0.0, 0.0, 1.0)\n        if s == 0:\n            return (1.0, 0.0, 0.0)\n        if p == 0:\n            return (0.0, 1.0, 0.0)\n\n        prob_r = (r * s) / (total * (total - 1))  # Rock vs Scissors\n        prob_s = (s * p) / (total * (total - 1))  # Scissors vs Paper\n        prob_p = (p * r) / (total * (total - 1))  # Paper vs Rock\n\n        # Calculate probabilities for each species\n        res_r = prob_r * dp(r, s - 1, p)[0] + prob_s * dp(r, s, p - 1)[0] + prob_p * dp(r - 1, s, p)[0]\n        res_s = prob_r * dp(r - 1, s, p)[1] + prob_s * dp(r, s, p - 1)[1] + prob_p * dp(r, s - 1, p)[1]\n        res_p = prob_r * dp(r, s, p - 1)[2] + prob_s * dp(r, s - 1, p)[2] + prob_p * dp(r - 1, s, p)[2]\n\n        memo[(r, s, p)] = (res_r, res_s, res_p)\n        return memo[(r, s, p)]\n\n    return dp(r, s, p)\n\n# Read input\nr, s, p = map(int, input().strip().split())\nresult = probabilities(r, s, p)\n\n# Print output\nprint(f\"{result[0]:.12f} {result[1]:.12f} {result[2]:.12f}\")"}
{"solution": "# Read input values\nl1, r1, l2, r2, k = map(int, input().split())\n\n# Calculate the start and end of the overlapping time\nstart_overlap = max(l1, l2)\nend_overlap = min(r1, r2)\n\n# Calculate the initial overlap duration\nif start_overlap <= end_overlap:\n    overlap_duration = end_overlap - start_overlap + 1\nelse:\n    overlap_duration = 0\n\n# Check if Sonya's prinking time affects the overlap\nif start_overlap <= k <= end_overlap:\n    overlap_duration -= 1\n\n# Ensure the overlap duration is not negative\noverlap_duration = max(overlap_duration, 0)\n\n# Print the result\nprint(overlap_duration)"}
{"solution": "def calculate_reachable_area(n, m, north_south_lines, east_west_lines):\n    # Initialize boundaries\n    min_x = -float('inf')\n    max_x = float('inf')\n    min_y = -float('inf')\n    max_y = float('inf')\n\n    # Process north-south lines\n    for A, B, C in north_south_lines:\n        if C == 0:  # Only consider lines that are at y = 0\n            min_x = max(min_x, A)\n            max_x = min(max_x, B)\n\n    # Process east-west lines\n    for D, E, F in east_west_lines:\n        if D == 0:  # Only consider lines that are at x = 0\n            min_y = max(min_y, E)\n            max_y = min(max_y, F)\n\n    # Check if the area is infinite\n    if min_x == -float('inf') or max_x == float('inf') or min_y == -float('inf') or max_y == float('inf'):\n        return \"INF\"\n\n    # Calculate the area\n    width = max_x - min_x\n    height = max_y - min_y\n\n    if width < 0 or height < 0:\n        return \"INF\"\n\n    return width * height\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\n# First line contains N and M\nN, M = map(int, data[0].split())\n\n# Read north-south lines\nnorth_south_lines = []\nfor i in range(1, N + 1):\n    A, B, C = map(int, data[i].split())\n    north_south_lines.append((A, B, C))\n\n# Read east-west lines\neast_west_lines = []\nfor j in range(N + 1, N + M + 1):\n    D, E, F = map(int, data[j].split())\n    east_west_lines.append((D, E, F))\n\n# Calculate and print the result\nresult = calculate_reachable_area(N, M, north_south_lines, east_west_lines)\nprint(result)"}
{"solution": "def will_pineapple_bark(t, s, x):\n    if x < t:\n        return \"NO\"\n    if x == t:\n        return \"YES\"\n    \n    d = x - t\n    if d % s == 0 or d % s == 1:\n        return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nt, s, x = map(int, input().split())\n# Output the result\nprint(will_pineapple_bark(t, s, x))"}
{"solution": "def find_contained_segments(segments):\n    n = len(segments)\n    indexed_segments = [(l, r, i + 1) for i, (l, r) in enumerate(segments)]\n    \n    # Sort by left endpoint, and by right endpoint in descending order\n    indexed_segments.sort(key=lambda x: (x[0], -x[1]))\n    \n    max_right = -1\n    max_right_index = -1\n    \n    for l, r, index in indexed_segments:\n        if r <= max_right:\n            # Found a segment that is contained\n            return (index, max_right_index)\n        if r > max_right:\n            max_right = r\n            max_right_index = index\n            \n    return (-1, -1)\n\n# Input reading\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\nresult = find_contained_segments(segments)\nprint(result[0], result[1])"}
{"solution": "def decode_genome(n, s):\n    # Count existing nucleotides\n    count_A = s.count('A')\n    count_C = s.count('C')\n    count_G = s.count('G')\n    count_T = s.count('T')\n    count_Q = s.count('?')\n\n    # Calculate required count for each nucleotide\n    required_count = n // 4\n\n    # Calculate how many more of each nucleotide is needed\n    needed_A = max(0, required_count - count_A)\n    needed_C = max(0, required_count - count_C)\n    needed_G = max(0, required_count - count_G)\n    needed_T = max(0, required_count - count_T)\n\n    # Total needed nucleotides\n    total_needed = needed_A + needed_C + needed_G + needed_T\n\n    # Check if we can replace '?' to balance the nucleotides\n    if total_needed > count_Q:\n        print(\"===\")\n        return\n\n    # Replace '?' with the needed nucleotides\n    result = list(s)\n    for i in range(n):\n        if result[i] == '?':\n            if needed_A > 0:\n                result[i] = 'A'\n                needed_A -= 1\n            elif needed_C > 0:\n                result[i] = 'C'\n                needed_C -= 1\n            elif needed_G > 0:\n                result[i] = 'G'\n                needed_G -= 1\n            elif needed_T > 0:\n                result[i] = 'T'\n                needed_T -= 1\n\n    # Join the list back into a string and print the result\n    print(''.join(result))\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Decode the genome\ndecode_genome(n, s)"}
{"solution": "def can_win(board):\n    # Check all possible winning lines for three 'x's\n    def check_win(x, y):\n        # Check horizontal\n        if y <= 1 and board[x][y+1] == 'x' and board[x][y+2] == 'x':\n            return True\n        # Check vertical\n        if x <= 1 and board[x+1][y] == 'x' and board[x+2][y] == 'x':\n            return True\n        # Check diagonal (top-left to bottom-right)\n        if x <= 1 and y <= 1 and board[x+1][y+1] == 'x' and board[x+2][y+2] == 'x':\n            return True\n        # Check diagonal (top-right to bottom-left)\n        if x <= 1 and y >= 2 and board[x+1][y-1] == 'x' and board[x+2][y-2] == 'x':\n            return True\n        return False\n\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                # Simulate placing 'x' in the empty cell\n                board[i] = board[i][:j] + 'x' + board[i][j+1:]\n                if check_win(i, j):\n                    return \"YES\"\n                # Revert the change\n                board[i] = board[i][:j] + '.' + board[i][j+1:]\n\n    return \"NO\"\n\n# Read input\nboard = [input().strip() for _ in range(4)]\n# Output the result\nprint(can_win(board))"}
{"solution": "def can_divide_array(n, a):\n    total_sum = sum(a)\n    \n    # If the total sum is odd, it's impossible to split it into two equal parts\n    if total_sum % 2 != 0:\n        return \"NO\"\n    \n    target_sum = total_sum // 2\n    prefix_sum = 0\n    seen_sums = set()\n    \n    for i in range(n):\n        prefix_sum += a[i]\n        \n        # Check if we can achieve the target sum by moving an element\n        if prefix_sum == target_sum or (prefix_sum - target_sum) in seen_sums:\n            return \"YES\"\n        \n        seen_sums.add(a[i])\n    \n    return \"NO\"\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(can_divide_array(n, a))"}
{"solution": "def can_form_non_increasing_sequence(n, k, a, b):\n    # Find the indices of zeros in sequence a\n    zero_indices = [i for i in range(n) if a[i] == 0]\n    \n    # Sort b in descending order to maximize the chance of creating a non-increasing sequence\n    b.sort(reverse=True)\n    \n    # Replace zeros in a with elements from b\n    for index in zero_indices:\n        a[index] = b.pop(0)\n    \n    # Check if the resulting sequence is not strictly increasing\n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_form_non_increasing_sequence(n, k, a, b)\nprint(result)"}
{"solution": "def can_distribute_grapes(x, y, z, a, b, c):\n    # Check if Andrew can be satisfied\n    if a < x:\n        return \"NO\"\n    \n    # Remaining green grapes after satisfying Andrew\n    remaining_green = a - x\n    \n    # Total grapes available for Dmitry and Michal\n    total_available = remaining_green + b + c\n    \n    # Check if Dmitry can be satisfied\n    if total_available < y:\n        return \"NO\"\n    \n    # Remaining grapes after satisfying Dmitry\n    remaining_after_dmitry = total_available - y\n    \n    # Check if Michal can be satisfied\n    if remaining_after_dmitry < z:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Output the result\nprint(can_distribute_grapes(x, y, z, a, b, c))"}
{"solution": "def is_accident_possible(traffic_lights):\n    # Check each part for potential accidents\n    for i in range(4):\n        l, s, r, p = traffic_lights[i]\n        \n        # Check if pedestrian light is green\n        if p == 1:\n            # Check if any vehicle light for the same part is green\n            if l == 1 or s == 1 or r == 1:\n                return \"YES\"\n            \n            # Check for potential accidents with adjacent parts\n            # Part 1 can hit pedestrians in Part 4 (i=0 -> i=3)\n            if i == 0 and (s == 1 or r == 1):\n                return \"YES\"\n            # Part 2 can hit pedestrians in Part 1 (i=1 -> i=0)\n            elif i == 1 and (l == 1 or s == 1):\n                return \"YES\"\n            # Part 3 can hit pedestrians in Part 2 (i=2 -> i=1)\n            elif i == 2 and (l == 1 or r == 1):\n                return \"YES\"\n            # Part 4 can hit pedestrians in Part 3 (i=3 -> i=2)\n            elif i == 3 and (l == 1 or s == 1):\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\ntraffic_lights = [list(map(int, input().split())) for _ in range(4)]\n\n# Determine if an accident is possible\nresult = is_accident_possible(traffic_lights)\n\n# Print the result\nprint(result)"}
{"solution": "def get_finger_movements(number):\n    # Define the keypad layout\n    keypad = {\n        '0': (1, 3), '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2)\n    }\n    \n    movements = []\n    \n    # Calculate the movements based on the number\n    for i in range(len(number) - 1):\n        start = keypad[number[i]]\n        end = keypad[number[i + 1]]\n        movement = (end[0] - start[0], end[1] - start[1])  # Vector from start to end\n        movements.append(movement)\n    \n    return movements\n\ndef can_be_sure(n, number):\n    original_movements = get_finger_movements(number)\n    \n    # Generate all possible numbers of the same length\n    from itertools import product\n    \n    for digits in product('0123456789', repeat=n):\n        candidate_number = ''.join(digits)\n        if candidate_number == number:\n            continue  # Skip the original number\n        \n        candidate_movements = get_finger_movements(candidate_number)\n        \n        if original_movements == candidate_movements:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn = int(input().strip())\nnumber = input().strip()\n\n# Output the result\nprint(can_be_sure(n, number))"}
{"solution": "def maximize_sales(n, f, sales_data):\n    sales = []\n    additional_sales = []\n\n    for k, l in sales_data:\n        # Calculate the sales without sell-out\n        sold_without_sellout = min(k, l)\n        sales.append(sold_without_sellout)\n\n        # Calculate the potential additional sales if this day is chosen for sell-out\n        sold_with_sellout = min(2 * k, l)\n        additional_sales.append(sold_with_sellout - sold_without_sellout)\n\n    # Calculate total sales without any sell-out\n    total_sales = sum(sales)\n\n    # If no sell-out days are chosen, return the total sales\n    if f == 0:\n        return total_sales\n\n    # Sort additional sales in descending order to pick the best f days\n    additional_sales.sort(reverse=True)\n\n    # Add the best f additional sales to the total sales\n    total_sales += sum(additional_sales[:f])\n\n    return total_sales\n\n# Input reading\nn, f = map(int, input().split())\nsales_data = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nresult = maximize_sales(n, f, sales_data)\nprint(result)"}
{"solution": "def max_messiness(n, k):\n    # Maximum possible inversions in an array of size n\n    max_inversions = n * (n - 1) // 2\n    \n    # If k is large enough to reverse the entire array\n    if k >= n // 2:\n        return max_inversions\n    else:\n        # If k is less than n // 2, we can only create k additional inversions\n        return k * (n - 1 - k)\n\n# Read input\nn, k = map(int, input().split())\n# Calculate and print the maximum messiness\nprint(max_messiness(n, k))"}
{"solution": "def min_coins(N, M, K, L):\n    # Check if it's impossible to satisfy the conditions\n    if K + L > N:\n        return -1\n    \n    # Calculate the minimum x required\n    min_x = (K + L + M - 1) // M  # This is equivalent to ceil((K + L) / M)\n    \n    # Calculate the maximum x allowed\n    max_x = N // M\n    \n    if min_x > max_x:\n        return -1\n    \n    return min_x\n\n# Read input values\nN, M, K, L = map(int, input().split())\n# Print the result\nprint(min_coins(N, M, K, L))"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    # Find the bounds of the black cells\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                if i < min_row:\n                    min_row = i\n                if i > max_row:\n                    max_row = i\n                if j < min_col:\n                    min_col = j\n                if j > max_col:\n                    max_col = j\n\n    # If no black cells are found, we need to paint one cell\n    if max_row == -1:\n        return 1\n\n    # Calculate the size of the rectangle that contains all black cells\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n\n    # The side of the square must be at least the maximum of height and width\n    side_length = max(height, width)\n\n    # Check if the square can fit within the grid\n    if side_length > n or side_length > m:\n        return -1\n\n    # Calculate the number of cells to paint\n    cells_to_paint = 0\n    for i in range(min_row, min_row + side_length):\n        for j in range(min_col, min_col + side_length):\n            if i >= n or j >= m or grid[i][j] == 'W':\n                cells_to_paint += 1\n\n    return cells_to_paint\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Get the result and print it\nresult = min_cells_to_paint(n, m, grid)\nprint(result)"}
{"solution": "def can_records_be_consistent(n, x, y):\n    sum_x = sum(x)\n    sum_y = sum(y)\n    \n    # Check if total stones in first visit is greater than or equal to the second visit\n    if sum_x < sum_y:\n        return \"No\"\n    \n    # Check if redistribution is possible\n    for i in range(n):\n        if y[i] > x[i] + (sum_x - sum_y):\n            return \"No\"\n    \n    return \"Yes\"\n\n# Input reading\nn = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Output the result\nprint(can_records_be_consistent(n, x, y))"}
{"solution": "def minimal_angle_difference(n, angles):\n    total_angle = sum(angles)\n    min_difference = total_angle  # Start with the maximum possible difference\n\n    # Create a prefix sum array to handle the circular nature of the pizza\n    prefix_sum = [0] * (2 * n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + angles[i - 1]\n    \n    # We can consider the pizza as circular by extending the prefix sums\n    for i in range(1, n + 1):\n        for j in range(i, n + i):\n            sector_sum = prefix_sum[j] - prefix_sum[i - 1]\n            other_sector_sum = total_angle - sector_sum\n            difference = abs(sector_sum - other_sector_sum)\n            min_difference = min(min_difference, difference)\n\n    return min_difference\n\n# Input reading\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Output the result\nprint(minimal_angle_difference(n, angles))"}
{"solution": "def modular_exponentiation(base, exp, mod):\n    result = 1\n    base = base % mod\n    while exp > 0:\n        if (exp % 2) == 1:  # If exp is odd\n            result = (result * base) % mod\n        exp = exp >> 1  # Divide exp by 2\n        base = (base * base) % mod  # Square the base\n    return result\n\ndef count_ways(n, m):\n    MOD = 10**9 + 7\n    # Calculate 2^m % MOD\n    power_of_two = modular_exponentiation(2, m, MOD)\n    # Calculate (2^m - 1) % MOD\n    valid_choices = (power_of_two - 1 + MOD) % MOD\n    # Calculate (valid_choices^n) % MOD\n    result = modular_exponentiation(valid_choices, n, MOD)\n    return result\n\n# Input reading\nn, m = map(int, input().split())\n# Output the result\nprint(count_ways(n, m))"}
{"solution": "def find_pythagorean_triple(n):\n    if n == 1:\n        return -1\n    \n    if n % 2 == 1:  # n is odd\n        m = (n * n - 1) // 2\n        k = (n * n + 1) // 2\n    else:  # n is even\n        m = (n // 2) * (n // 2) - 1\n        k = (n // 2) * (n // 2) + 1\n    \n    return m, k\n\n# Read input\nn = int(input().strip())\nresult = find_pythagorean_triple(n)\n\nif result == -1:\n    print(-1)\nelse:\n    print(result[0], result[1])"}
{"solution": "def distinct_remainders(n, k):\n    if k >= n:\n        return \"No\"\n    \n    remainders = set()\n    for i in range(1, k + 1):\n        remainder = n % i\n        if remainder in remainders:\n            return \"No\"\n        remainders.add(remainder)\n    \n    return \"Yes\"\n\n# Input reading\nn, k = map(int, input().split())\nprint(distinct_remainders(n, k))"}
{"solution": "import sys\n\ndef compare_large_integers():\n    # Read the input using sys.stdin for fast input\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    a = data[0].lstrip('0')  # Remove leading zeros\n    b = data[1].lstrip('0')  # Remove leading zeros\n    \n    # Compare lengths first\n    if len(a) > len(b):\n        print(\">\")\n    elif len(a) < len(b):\n        print(\"<\")\n    else:\n        # If lengths are equal, compare lexicographically\n        if a > b:\n            print(\">\")\n        elif a < b:\n            print(\"<\")\n        else:\n            print(\"=\")\n\n# Call the function to execute the comparison\ncompare_large_integers()"}
{"solution": "MOD = 10**9 + 7\n\ndef count_paths(n, p, colors):\n    # Count the number of uncolored pieces\n    uncolored_count = colors.count(-1)\n    \n    # Generate all possible colorings for uncolored pieces\n    total_colorings = 1 << uncolored_count  # 2^uncolored_count\n    valid_count = 0\n    \n    for mask in range(total_colorings):\n        # Create a new color array based on the current mask\n        current_colors = colors[:]\n        for i in range(uncolored_count):\n            if (mask & (1 << i)) != 0:\n                current_colors[current_colors.index(-1)] = 1  # Color white\n            else:\n                current_colors[current_colors.index(-1)] = 0  # Color black\n        \n        # Count valid paths\n        dp = [[0, 0] for _ in range(n)]  # dp[i][0] for black, dp[i][1] for white\n        \n        for i in range(n):\n            dp[i][current_colors[i]] += 1  # Each piece can start a path\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if current_colors[i] != current_colors[j]:  # Only if colors alternate\n                    dp[j][current_colors[j]] = (dp[j][current_colors[j]] + dp[i][current_colors[i]]) % MOD\n        \n        total_paths = sum(dp[i][0] + dp[i][1] for i in range(n)) % MOD\n        \n        if total_paths % 2 == p:\n            valid_count = (valid_count + 1) % MOD\n    \n    return valid_count\n\n# Read input\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Get the result\nresult = count_paths(n, p, colors)\n\n# Print the result\nprint(result)"}
{"solution": "def minimum_rubles(n, a, b, c):\n    remainder = n % 4\n    if remainder == 0:\n        return 0\n    \n    # Calculate the additional copybooks needed to make n + k divisible by 4\n    needed = (4 - remainder) % 4\n    \n    # Initialize the minimum cost to a large number\n    min_cost = float('inf')\n    \n    # Check all combinations of needed copybooks\n    for k in range(needed + 1):\n        if k == 1:\n            min_cost = min(min_cost, a)\n        elif k == 2:\n            min_cost = min(min_cost, b)\n        elif k == 3:\n            min_cost = min(min_cost, c)\n    \n    # Return the minimum cost found\n    return min_cost\n\n# Read input\nn, a, b, c = map(int, input().split())\n\n# Calculate and print the result\nprint(minimum_rubles(n, a, b, c))"}
{"solution": "def can_make_acyclic(n, m, edges):\n    from collections import defaultdict, deque\n\n    # Build the graph\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n\n    for u, v in edges:\n        graph[u].append(v)\n        in_degree[v] += 1\n\n    # Function to perform DFS and detect cycles\n    def has_cycle():\n        visited = [False] * (n + 1)\n        rec_stack = [False] * (n + 1)\n\n        def dfs(v):\n            visited[v] = True\n            rec_stack[v] = True\n\n            for neighbor in graph[v]:\n                if not visited[neighbor]:\n                    if dfs(neighbor):\n                        return True\n                elif rec_stack[neighbor]:\n                    return True\n\n            rec_stack[v] = False\n            return False\n\n        for node in range(1, n + 1):\n            if not visited[node]:\n                if dfs(node):\n                    return True\n        return False\n\n    # Check if the original graph has a cycle\n    if not has_cycle():\n        return \"YES\"\n\n    # Check for cycles by removing each edge\n    for u, v in edges:\n        # Temporarily remove the edge u -> v\n        graph[u].remove(v)\n        if not has_cycle():\n            return \"YES\"\n        # Add the edge back\n        graph[u].append(v)\n\n    return \"NO\"\n\n# Input reading\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output the result\nprint(can_make_acyclic(n, m, edges))"}
{"solution": "def min_cost_to_cover(n, m, antennas):\n    # Create a coverage array to track which positions are covered\n    coverage = [0] * (m + 1)\n\n    # Mark the initial coverage of each antenna\n    for x, s in antennas:\n        left = max(1, x - s)\n        right = min(m, x + s)\n        for i in range(left, right + 1):\n            coverage[i] = 1\n\n    # Now we need to find the minimum cost to cover all positions from 1 to m\n    cost = 0\n    current_coverage = 0\n\n    for position in range(1, m + 1):\n        if coverage[position] == 0:  # If this position is not covered\n            # We need to extend the coverage\n            # Find the nearest antenna to the left and right\n            left_antenna = None\n            right_antenna = None\n            \n            for i in range(n):\n                x, s = antennas[i]\n                if x - s <= position and x + s >= position:\n                    # This antenna already covers the position\n                    left_antenna = i\n                    right_antenna = i\n                    break\n                if x + s < position:\n                    left_antenna = i\n                if x - s > position and right_antenna is None:\n                    right_antenna = i\n            \n            # Calculate the cost to extend the nearest antennas\n            left_cost = float('inf')\n            right_cost = float('inf')\n\n            if left_antenna is not None:\n                x, s = antennas[left_antenna]\n                left_cost = max(0, position - (x + s))  # How much to extend this antenna\n\n            if right_antenna is not None:\n                x, s = antennas[right_antenna]\n                right_cost = max(0, (x - s) - position)  # How much to extend this antenna\n\n            # Choose the minimum cost to cover this position\n            cost += min(left_cost, right_cost)\n            # We can assume we extend the left antenna for simplicity\n            if left_cost < right_cost:\n                antennas[left_antenna] = (antennas[left_antenna][0], antennas[left_antenna][1] + left_cost)\n            else:\n                antennas[right_antenna] = (antennas[right_antenna][0], antennas[right_antenna][1] + right_cost)\n\n            # Update coverage for this position\n            coverage[position] = 1\n\n    return cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the minimum cost\nprint(min_cost_to_cover(n, m, antennas))"}
{"solution": "def max_good_subset_weight(W, counts):\n    total_weight = 0\n    \n    # Iterate from weight 8 down to 1\n    for weight in range(8, 0, -1):\n        if W <= 0:\n            break\n        \n        count = counts[weight - 1]  # counts is 0-indexed for weights 1 to 8\n        \n        # Maximum items we can take of this weight\n        max_items = min(count, W // weight)\n        \n        # Update total weight and remaining weight\n        total_weight += max_items * weight\n        W -= max_items * weight\n    \n    return total_weight\n\n# Read input\nW = int(input())\ncounts = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = max_good_subset_weight(W, counts)\nprint(result)"}
{"solution": "def min_cost_to_buy_lemonade(n, L, costs):\n    # Calculate the volumes of the bottles\n    volumes = [(1 << i) - 1 for i in range(1, n + 1)]\n    \n    # Initialize the DP array\n    dp = [float('inf')] * (L + 1)\n    dp[0] = 0  # Cost to buy 0 liters is 0\n\n    # Fill the DP array\n    for i in range(n):\n        volume = volumes[i]\n        cost = costs[i]\n        for j in range(volume, L + 1):\n            dp[j] = min(dp[j], dp[j - volume] + cost)\n\n    # Find the minimum cost for at least L liters\n    min_cost = min(dp[L:])\n    \n    return min_cost\n\n# Read input\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = min_cost_to_buy_lemonade(n, L, costs)\nprint(result)"}
{"solution": "def maximum_mex(n, a):\n    # Create a set to track the unique values in the array\n    unique_values = set(a)\n    \n    # Initialize the mex value\n    mex = 1\n    \n    # Increment mex until we find a value that is not in the unique values\n    while mex in unique_values:\n        mex += 1\n    \n    return mex\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result and print it\nresult = maximum_mex(n, a)\nprint(result)"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(digits)\n    \n    # If total sum is zero, we can always form segments of zero\n    if total_sum == 0:\n        return \"YES\"\n    \n    # Check for each possible segment sum\n    for segment_sum in range(1, total_sum // 2 + 1):\n        current_sum = 0\n        segment_count = 0\n        \n        for digit in digits:\n            current_sum += digit\n            \n            if current_sum == segment_sum:\n                segment_count += 1\n                current_sum = 0  # Reset for the next segment\n            \n            elif current_sum > segment_sum:\n                break  # No need to continue if we exceed the segment sum\n        \n        # If we have formed at least 2 segments\n        if segment_count >= 2:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn = int(input().strip())\ndigits = list(map(int, input().strip()))\n\n# Output the result\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\"\n\n# Read input\nusername = input().strip()\n# Output the result\nprint(determine_gender(username))"}
{"solution": "def max_absolute_difference(n, k, tabs):\n    max_difference = 0\n    \n    for b in range(1, n + 1):\n        closed_tabs = set()\n        \n        # Close tabs starting from b and every k-th tab\n        for i in range(-((n - b) // k), (b // k) + 1):\n            closed_tab = b + i * k\n            if 1 <= closed_tab <= n:\n                closed_tabs.add(closed_tab)\n        \n        # Count remaining tabs\n        e = 0  # count of test information tabs\n        s = 0  # count of social network tabs\n        \n        for i in range(1, n + 1):\n            if i not in closed_tabs:\n                if tabs[i - 1] == 1:\n                    e += 1\n                else:\n                    s += 1\n        \n        # Calculate the absolute difference\n        max_difference = max(max_difference, abs(e - s))\n    \n    return max_difference\n\n# Read input\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Output the result\nprint(max_absolute_difference(n, k, tabs))"}
{"solution": "def minimum_cost(n, c0, c1):\n    # Calculate the smallest k such that 2^k >= n\n    k = 0\n    while (1 << k) < n:\n        k += 1\n    \n    # Calculate the number of '0's and '1's based on k\n    if k % 2 == 0:\n        num_0s = num_1s = (1 << (k - 1))  # Even k\n    else:\n        num_0s = (1 << (k // 2))          # More '0's if k is odd\n        num_1s = (1 << (k // 2))          # More '1's if k is odd\n        num_0s += (1 << (k // 2))         # Add one more '0'\n    \n    # Adjust for the total number of letters\n    if num_0s + num_1s > n:\n        excess = (num_0s + num_1s) - n\n        if num_0s > num_1s:\n            num_0s -= excess\n        else:\n            num_1s -= excess\n    \n    # Calculate the total cost\n    total_cost = (num_0s * c0) + (num_1s * c1)\n    return total_cost\n\n# Read input\nn, c0, c1 = map(int, input().split())\n# Calculate and print the minimum cost\nprint(minimum_cost(n, c0, c1))"}
{"solution": "def will_meet(n, a, x, b, y):\n    # Current positions\n    daniel_position = a\n    vlad_position = b\n    \n    while True:\n        # Check if they are at the same station\n        if daniel_position == vlad_position:\n            return \"YES\"\n        \n        # Move Daniel\n        if daniel_position == x:\n            break  # Daniel exits\n        daniel_position = daniel_position + 1 if daniel_position < n else 1\n        \n        # Move Vlad\n        if vlad_position == y:\n            break  # Vlad exits\n        vlad_position = vlad_position - 1 if vlad_position > 1 else n\n    \n    return \"NO\"\n\n# Read input values\nn, a, x, b, y = map(int, input().split())\n# Print the result\nprint(will_meet(n, a, x, b, y))"}
{"solution": "def find_golden_age(x, y, l, r):\n    unlucky_years = set()\n    \n    # Generate unlucky years\n    a = 0\n    while True:\n        x_power = x ** a\n        if x_power > r:\n            break\n        b = 0\n        while True:\n            y_power = y ** b\n            if x_power + y_power > r:\n                break\n            unlucky_years.add(x_power + y_power)\n            b += 1\n        a += 1\n    \n    # Filter unlucky years within the range [l, r]\n    unlucky_years = sorted(year for year in unlucky_years if l <= year <= r)\n    \n    # If there are no unlucky years in the range\n    if not unlucky_years:\n        return r - l + 1  # All years are lucky\n    \n    # Calculate maximum gap\n    max_gap = 0\n    \n    # Check gap before the first unlucky year\n    if unlucky_years[0] > l:\n        max_gap = max(max_gap, unlucky_years[0] - l)\n    \n    # Check gaps between unlucky years\n    for i in range(1, len(unlucky_years)):\n        max_gap = max(max_gap, unlucky_years[i] - unlucky_years[i - 1] - 1)\n    \n    # Check gap after the last unlucky year\n    if unlucky_years[-1] < r:\n        max_gap = max(max_gap, r - unlucky_years[-1])\n    \n    return max_gap\n\n# Input reading\nx, y, l, r = map(int, input().split())\n# Output the result\nprint(find_golden_age(x, y, l, r))"}
{"solution": "def min_tax(n):\n    # Function to find the maximum divisor of n that is less than n\n    def max_divisor(x):\n        for i in range(int(x**0.5), 1, -1):\n            if x % i == 0:\n                return x // i\n        return 1  # If no divisor found, return 1 (for prime numbers)\n\n    # If n is even, the best split is into two equal parts\n    if n % 2 == 0:\n        return n // 2\n    else:\n        # If n is odd, we can split it into (n-1) and 1, but we can't have 1\n        # So we can split it into (n//2) and (n//2 + 1)\n        return max_divisor(n)\n\n# Read input\nn = int(input().strip())\n# Print the minimum tax\nprint(min_tax(n))"}
{"solution": "def correct_typos(word):\n    vowels = set('aeiou')\n    result = []\n    consonant_block = []\n    \n    for char in word:\n        if char not in vowels:  # It's a consonant\n            consonant_block.append(char)\n        else:  # It's a vowel\n            if len(consonant_block) >= 3:\n                # Check if there are at least two different consonants\n                if len(set(consonant_block)) > 1:\n                    # Insert spaces before the last two consonants\n                    result.append(''.join(consonant_block[:-2]))\n                    result.append(consonant_block[-2])\n                    result.append(consonant_block[-1])\n                else:\n                    result.append(''.join(consonant_block))\n            else:\n                result.append(''.join(consonant_block))\n            result.append(char)\n            consonant_block = []  # Reset the consonant block\n    \n    # Handle any remaining consonants at the end\n    if len(consonant_block) >= 3:\n        if len(set(consonant_block)) > 1:\n            result.append(''.join(consonant_block[:-2]))\n            result.append(consonant_block[-2])\n            result.append(consonant_block[-1])\n        else:\n            result.append(''.join(consonant_block))\n    else:\n        result.append(''.join(consonant_block))\n    \n    return ''.join(result)\n\n# Read input\nword = input().strip()\n# Print the corrected word\nprint(correct_typos(word))"}
{"solution": "def min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d):\n    # Initialize the minimum time to prepare n potions without any spells\n    min_time = n * x\n    \n    # Check all spells of the first type\n    for i in range(m):\n        if b[i] <= s:  # If we can afford this spell\n            potion_time = a[i]\n            # Check all spells of the second type\n            for j in range(k):\n                if d[j] + b[i] <= s:  # If we can afford both spells\n                    # Calculate the number of potions left after using the second spell\n                    potions_left = max(0, n - c[j])\n                    # Calculate the total time needed\n                    total_time = potions_left * potion_time\n                    min_time = min(min_time, total_time)\n    \n    # Check only spells of the second type without any first type spell\n    for j in range(k):\n        if d[j] <= s:  # If we can afford this spell\n            potions_left = max(0, n - c[j])\n            total_time = potions_left * x\n            min_time = min(min_time, total_time)\n    \n    return min_time\n\n# Read input\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\n# Calculate and print the minimum time\nresult = min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d)\nprint(result)"}
{"solution": "def max_points(n, k, M, t):\n    max_points = 0\n    \n    # Calculate the total time to complete one full task\n    total_time_per_task = sum(t)\n    \n    # Iterate over the number of fully completed tasks\n    for full_tasks in range(n + 1):\n        time_spent = full_tasks * total_time_per_task\n        if time_spent > M:\n            break\n        \n        # Points from fully completed tasks\n        points = full_tasks * (k + 1)\n        \n        # Remaining time after completing full tasks\n        remaining_time = M - time_spent\n        \n        # Calculate additional subtasks that can be solved with the remaining time\n        additional_points = 0\n        \n        # Try to solve as many subtasks as possible with the remaining time\n        for subtask_index in range(k):\n            time_for_subtask = t[subtask_index]\n            max_subtasks = remaining_time // time_for_subtask\n            \n            # We can only solve up to n - full_tasks subtasks for this subtask index\n            if full_tasks < n:\n                additional_points += min(max_subtasks, n - full_tasks)\n        \n        # Update the maximum points\n        max_points = max(max_points, points + additional_points)\n    \n    return max_points\n\n# Read input\nn, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Calculate and print the maximum points\nprint(max_points(n, k, M, t))"}
{"solution": "MOD = 998244353\n\ndef count_striped_bst(n):\n    if n % 2 != 0:\n        return 0  # Odd n cannot form a perfectly balanced striped BST\n\n    half_n = n // 2\n    # Calculate factorials and inverse factorials\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n\n    # Calculate the number of valid trees\n    # The number of perfectly balanced striped BSTs with n nodes is given by:\n    # C(half_n, half_n) * (half_n)! * (half_n)!\n    # where C is the binomial coefficient\n    # C(n, k) = n! / (k! * (n - k)!)\n    \n    # C(half_n, half_n) is 1, so we only need to calculate (half_n!)^2\n    result = (fact[half_n] * fact[half_n]) % MOD\n    return result\n\nn = int(input().strip())\nprint(count_striped_bst(n))"}
{"solution": "def lara_position(n, m, k):\n    # Calculate the total number of moves in the first column\n    if k < n:\n        return (k + 1, 1)  # Moving down in the first column\n\n    # Moves after reaching the bottom of the first column\n    k -= n - 1  # Subtract the moves to reach (n, 1)\n\n    # Calculate the number of complete zigzag cycles\n    full_cycles = k // (2 * (m - 1))\n    remaining_moves = k % (2 * (m - 1))\n\n    # Determine the current column after full cycles\n    current_column = full_cycles + 1\n\n    if current_column > m:\n        return (n, m)  # If we exceed the number of columns, we are at the bottom right corner\n\n    # Determine the row based on remaining moves\n    if remaining_moves < (m - 1):\n        return (n - remaining_moves, current_column + 1)  # Moving up in the current column\n    else:\n        remaining_moves -= (m - 1)\n        if remaining_moves < (m - 1):\n            return (1 + remaining_moves, current_column)  # Moving down in the previous column\n        else:\n            remaining_moves -= (m - 1)\n            return (1, current_column + 1)  # Moving to the next column\n\n# Read input\nn, m, k = map(int, input().split())\n# Get the position and print it\nposition = lara_position(n, m, k)\nprint(position[0], position[1])"}
{"solution": "def find_min_max_lcm_pair(X):\n    min_max_value = float('inf')\n    best_pair = (1, X)  # Default pair\n\n    # Iterate through all possible divisors of X\n    for d in range(1, int(X**0.5) + 1):\n        if X % d == 0:\n            a = d\n            b = X // d\n            \n            # Check the pair (a, b)\n            current_max = max(a, b)\n            if current_max < min_max_value:\n                min_max_value = current_max\n                best_pair = (a, b)\n\n            # Check the pair (b, a) as well\n            current_max = max(b, a)\n            if current_max < min_max_value:\n                min_max_value = current_max\n                best_pair = (b, a)\n\n    return best_pair\n\n# Input\nX = int(input().strip())\na, b = find_min_max_lcm_pair(X)\nprint(a, b)"}
{"solution": "# Read the number of lemons, apples, and pears from input\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate the maximum number of lemons (x) that can be used\nx_max = min(a, b // 2, c // 4)\n\n# Calculate the total number of fruits used in the compote\ntotal_fruits = x_max + 2 * x_max + 4 * x_max\n\n# Print the result\nprint(total_fruits)"}
{"solution": "def can_first_team_win(n, ratings):\n    # Sort the ratings\n    ratings.sort()\n    \n    # Team 1 will have the last n players (higher ratings)\n    # Team 2 will have the first n players (lower ratings)\n    \n    # Check if the weakest player in Team 1 can beat the strongest player in Team 2\n    if ratings[n] > ratings[n - 1]:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Input reading\nn = int(input())\nratings = list(map(int, input().split()))\n\n# Output the result\nprint(can_first_team_win(n, ratings))"}
{"solution": "import math\nfrom sys import stdin, stdout\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef make_coprime_array(arr):\n    n = len(arr)\n    new_array = []\n    insertions = 0\n    \n    new_array.append(arr[0])\n    \n    for i in range(1, n):\n        if gcd(new_array[-1], arr[i]) != 1:\n            # If they are not co-prime, we need to insert a number\n            # We can insert 1, which is co-prime with any number\n            new_array.append(1)\n            insertions += 1\n        \n        new_array.append(arr[i])\n    \n    return insertions, new_array\n\ndef main():\n    input = stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    arr = list(map(int, data[1:n+1]))\n    \n    insertions, new_array = make_coprime_array(arr)\n    \n    stdout.write(f\"{insertions}\\n\")\n    stdout.write(\" \".join(map(str, new_array)) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\nfrom math import gcd\nfrom functools import reduce\n\ndef max_divisor_after_operations(N, K, A):\n    # Calculate the minimum element in the array\n    min_A = min(A)\n    \n    # Calculate the differences from the minimum element\n    differences = [a - min_A for a in A]\n    \n    # Calculate the GCD of the differences\n    current_gcd = reduce(gcd, differences)\n    \n    # The maximum possible divisor we can achieve\n    # We can increase the GCD by at most K\n    return current_gcd + K\n\ndef main():\n    input_data = sys.stdin.read().strip().split()\n    N = int(input_data[0])\n    K = int(input_data[1])\n    A = list(map(int, input_data[2:2 + N]))\n    \n    result = max_divisor_after_operations(N, K, A)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_perfect_longcat(x):\n    return (x & (x + 1)) == 0\n\ndef nearest_perfect_longcat(x):\n    m = 1\n    while m <= x:\n        m <<= 1\n    return m - 1\n\ndef transform_to_longcat(x):\n    if is_perfect_longcat(x):\n        return 0, []\n    \n    operations = []\n    \n    while not is_perfect_longcat(x):\n        # Find the nearest perfect longcat number\n        target = nearest_perfect_longcat(x)\n        \n        # Determine the number of bits to flip\n        n = 0\n        while (1 << n) - 1 < target:\n            n += 1\n        \n        # Perform Operation A\n        operations.append(n)\n        x ^= (1 << n) - 1\n        \n        # Perform Operation B\n        x += 1\n        \n        # If we exceed 40 operations, we should stop\n        if len(operations) >= 40:\n            break\n    \n    return len(operations), operations\n\n# Input\nx = int(input().strip())\nt, ops = transform_to_longcat(x)\n\n# Output\nprint(t)\nif t > 0:\n    print(\" \".join(map(str, ops)))"}
{"solution": "def min_hours_to_water_garden(n, k, buckets):\n    min_hours = float('inf')\n    \n    for a in buckets:\n        if k % a == 0:  # Check if the bucket can evenly divide the garden length\n            hours = k // a  # Calculate the number of hours needed\n            min_hours = min(min_hours, hours)  # Update the minimum hours\n    \n    return min_hours\n\n# Input reading\nn, k = map(int, input().split())\nbuckets = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = min_hours_to_water_garden(n, k, buckets)\nprint(result)"}
{"solution": "def can_grasshopper_reach(n, k, line):\n    g_index = line.index('G')\n    t_index = line.index('T')\n    \n    if g_index < t_index:\n        # Jump to the right\n        for i in range(g_index, t_index + 1, k):\n            if line[i] == '#':\n                return \"NO\"\n            if i == t_index:\n                return \"YES\"\n    else:\n        # Jump to the left\n        for i in range(g_index, t_index - 1, -k):\n            if line[i] == '#':\n                return \"NO\"\n            if i == t_index:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\nline = input().strip()\n# Print the result\nprint(can_grasshopper_reach(n, k, line))"}
{"solution": "def find_aim_point(y1, y2, yw, xb, yb, r):\n    # The ball must land between y1 and y2 after bouncing off the wall\n    # The trajectory after bouncing can be calculated using the reflection principle\n    \n    # We need to find xw such that the ball bounces off (yw, yw) and goes to (0, y)\n    # where y is between y1 and y2.\n    \n    # The line from (xb, yb) to (xw, yw) and then to (0, y) must be calculated.\n    \n    # The slope of the line from (xb, yb) to (xw, yw)\n    # The slope of the line from (xw, yw) to (0, y) after reflection\n    # The angle of incidence equals the angle of reflection\n    \n    # We can derive the equations based on the geometry of the situation.\n    \n    # The y-coordinate after bouncing can be expressed as:\n    # y = (yw - yb) * (0 - xw) / (yw - xb) + yb\n    # Rearranging gives us:\n    # y = yb + (yw - yb) * (xw / (yw - xb))\n    \n    # We need to ensure that y1 - r <= y <= y2 + r\n    # This gives us two inequalities to solve for xw.\n    \n    # Calculate the minimum and maximum xw that satisfy the goal conditions\n    # For the lower bound\n    xw_min = (y1 + r - yb) * (yw - xb) / (yw - yb)\n    # For the upper bound\n    xw_max = (y2 - r - yb) * (yw - xb) / (yw - yb)\n    \n    # We need to ensure that xw_min and xw_max are valid\n    if xw_min < 0 or xw_max < 0:\n        return -1\n    \n    # The valid xw must also be less than or equal to yw\n    if xw_min > yw:\n        return -1\n    \n    # We can return any valid xw in the range [xw_min, min(xw_max, yw)]\n    xw = max(xw_min, 0)\n    if xw > yw:\n        return -1\n    \n    return xw\n\n# Read input\ny1, y2, yw, xb, yb, r = map(int, input().split())\nresult = find_aim_point(y1, y2, yw, xb, yb, r)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    print(f\"{result:.10f}\")"}
{"solution": "def minimum_missed_meals(b, d, s):\n    # Calculate the maximum number of days based on the meals attended\n    max_days = max(b, d, s)\n    \n    # Calculate the total meals that should have been available\n    total_meals = max_days * 3\n    \n    # Calculate the number of meals Vasiliy actually attended\n    attended_meals = b + d + s\n    \n    # The minimum missed meals is the difference\n    missed_meals = total_meals - attended_meals\n    \n    return missed_meals\n\n# Read input\nb, d, s = map(int, input().split())\n\n# Calculate and print the result\nprint(minimum_missed_meals(b, d, s))"}
{"solution": "def find_matrix_dimensions(n, path):\n    # Determine the minimum and maximum values in the path\n    min_val = min(path)\n    max_val = max(path)\n\n    # Calculate the maximum possible y based on the maximum value in the path\n    y = max_val - min_val + 1\n\n    # Calculate the maximum possible x based on the number of unique values in the path\n    unique_values = set(path)\n    x = (max_val + y - 1) // y  # This is equivalent to ceil(max_val / y)\n\n    # Check if the calculated dimensions are valid\n    if x <= 0 or y <= 0 or x > 10**9 or y > 10**9:\n        return \"NO\"\n\n    # Validate the path\n    position = {}\n    for idx, value in enumerate(path):\n        if value not in position:\n            i = (value - 1) // y + 1  # Calculate row\n            j = (value - 1) % y + 1   # Calculate column\n            position[value] = (i, j)\n\n    for k in range(1, n):\n        a1, a2 = path[k - 1], path[k]\n        i1, j1 = position[a1]\n        i2, j2 = position[a2]\n\n        # Check if (i1, j1) and (i2, j2) are adjacent\n        if not ((abs(i1 - i2) == 1 and j1 == j2) or (abs(j1 - j2) == 1 and i1 == i2)):\n            return \"NO\"\n\n    return f\"YES\\n{x} {y}\"\n\n# Input reading\nn = int(input().strip())\npath = list(map(int, input().strip().split()))\n\n# Output the result\nprint(find_matrix_dimensions(n, path))"}
{"solution": "def min_consecutive_removal_to_subsequence(a, b):\n    n, m = len(a), len(b)\n    \n    # Two pointers for a and b\n    i, j = 0, 0\n    longest_subsequence = []\n    \n    # To find the longest subsequence of b in a\n    while i < n and j < m:\n        if a[i] == b[j]:\n            longest_subsequence.append(a[i])\n            j += 1\n        i += 1\n    \n    # If we found a valid subsequence, return it\n    if longest_subsequence:\n        return ''.join(longest_subsequence)\n    else:\n        return \"-\"\n\n# Read input\na = input().strip()\nb = input().strip()\n\n# Get the result\nresult = min_consecutive_removal_to_subsequence(a, b)\n\n# Print the output\nprint(result)"}
{"solution": "def minimal_stones(n, operations):\n    plus_count = operations.count('+')\n    minus_count = operations.count('-')\n    \n    # The minimum initial stones needed to perform all '-' operations\n    initial_stones = max(0, minus_count)\n    \n    # Calculate the final number of stones\n    final_stones = initial_stones + plus_count - minus_count\n    \n    return final_stones\n\n# Read input\nn = int(input())\noperations = input().strip()\n# Print the result\nprint(minimal_stones(n, operations))"}
{"solution": "def max_kefir(n, a, b, c):\n    # Calculate the maximum liters of kefir Kolya can drink\n    max_liters = 0\n    \n    # Option 1: Buy only plastic bottles\n    max_liters = n // a\n    \n    # Option 2: Buy glass bottles and return them\n    if b <= n:\n        # Initial purchase of glass bottles\n        glass_bottles = n // b\n        remaining_money = n % b\n        \n        # Total liters from initial glass bottle purchases\n        total_liters = glass_bottles\n        \n        # Now consider returning glass bottles\n        while glass_bottles > 0:\n            # Refund for returned glass bottles\n            remaining_money += glass_bottles * c\n            \n            # Buy more glass bottles with the refunded money\n            new_glass_bottles = remaining_money // b\n            total_liters += new_glass_bottles\n            \n            # Update remaining money after buying new glass bottles\n            remaining_money %= b\n            \n            # Update the count of glass bottles\n            glass_bottles = new_glass_bottles\n        \n        # Compare with the maximum liters from plastic bottles\n        max_liters = max(max_liters, total_liters)\n    \n    return max_liters\n\n# Read input\nn = int(input().strip())\na = int(input().strip())\nb = int(input().strip())\nc = int(input().strip())\n\n# Calculate and print the result\nprint(max_kefir(n, a, b, c))"}
{"solution": "from collections import deque\n\ndef card_game(n, k1, soldier1_cards, k2, soldier2_cards):\n    # Initialize the queues for both soldiers\n    soldier1 = deque(soldier1_cards)\n    soldier2 = deque(soldier2_cards)\n    \n    seen_states = set()\n    rounds = 0\n    \n    while soldier1 and soldier2:\n        # Create a state representation\n        state = (tuple(soldier1), tuple(soldier2))\n        if state in seen_states:\n            return -1  # Infinite loop detected\n        seen_states.add(state)\n        \n        # Draw cards\n        card1 = soldier1.popleft()\n        card2 = soldier2.popleft()\n        \n        if card1 > card2:\n            # Soldier 1 wins this round\n            soldier1.append(card2)\n            soldier1.append(card1)\n        else:\n            # Soldier 2 wins this round\n            soldier2.append(card1)\n            soldier2.append(card2)\n        \n        rounds += 1\n    \n    # Determine the winner\n    if soldier1:\n        return rounds, 1  # Soldier 1 wins\n    else:\n        return rounds, 2  # Soldier 2 wins\n\n# Read input\nn = int(input())\nk1, *soldier1_cards = map(int, input().split())\nk2, *soldier2_cards = map(int, input().split())\n\nresult = card_game(n, k1, soldier1_cards, k2, soldier2_cards)\nprint(result[0], result[1]) if result != -1 else print(-1)"}
{"solution": "def check_password_complexity(password):\n    # Initialize flags for each condition\n    has_upper = False\n    has_lower = False\n    has_digit = False\n    is_long_enough = len(password) >= 5\n\n    # Iterate through each character in the password\n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n\n    # Final evaluation\n    if is_long_enough and has_upper and has_lower and has_digit:\n        print(\"Correct\")\n    else:\n        print(\"Too weak\")\n\n# Read input\npassword = input().strip()\ncheck_password_complexity(password)"}
{"solution": "def min_exchanges(n, group_a, group_b):\n    count_a = [0] * 6  # Index 0 will be unused\n    count_b = [0] * 6  # Index 0 will be unused\n\n    # Count performances in group A\n    for performance in group_a:\n        count_a[performance] += 1\n\n    # Count performances in group B\n    for performance in group_b:\n        count_b[performance] += 1\n\n    # Calculate the excess and deficit for each performance level\n    excess_a = [0] * 6\n    excess_b = [0] * 6\n    total_exchanges = 0\n\n    for i in range(1, 6):\n        total = count_a[i] + count_b[i]\n        if total % 2 != 0:\n            return -1  # If total is odd, we cannot balance\n        target = total // 2\n        if count_a[i] > target:\n            excess_a[i] = count_a[i] - target\n        elif count_b[i] > target:\n            excess_b[i] = count_b[i] - target\n\n    # Calculate the minimum number of exchanges needed\n    for i in range(1, 6):\n        total_exchanges += max(excess_a[i], excess_b[i])\n\n    # Each exchange resolves two excesses\n    return total_exchanges // 2\n\n# Input reading\nn = int(input())\ngroup_a = list(map(int, input().split()))\ngroup_b = list(map(int, input().split()))\n\n# Output the result\nprint(min_exchanges(n, group_a, group_b))"}
{"solution": "def can_reach_all_junctions(n, m, horizontal, vertical):\n    # Create a graph representation of the junctions\n    graph = [[False] * m for _ in range(n)]\n    \n    # Fill the graph based on the street directions\n    for i in range(n):\n        for j in range(m):\n            graph[i][j] = True  # Mark the junction as reachable\n            \n            # Check horizontal street direction\n            if horizontal[i] == '>':\n                if j < m - 1:\n                    graph[i][j + 1] = True  # Can move east\n            elif horizontal[i] == '<':\n                if j > 0:\n                    graph[i][j - 1] = True  # Can move west\n            \n            # Check vertical street direction\n            if vertical[j] == 'v':\n                if i < n - 1:\n                    graph[i + 1][j] = True  # Can move south\n            elif vertical[j] == '^':\n                if i > 0:\n                    graph[i - 1][j] = True  # Can move north\n\n    # Check if all junctions are reachable from the first junction (0, 0)\n    visited = [[False] * m for _ in range(n)]\n    \n    def dfs(x, y):\n        if visited[x][y]:\n            return\n        visited[x][y] = True\n        \n        # Explore all reachable junctions\n        if horizontal[x] == '>':\n            if y < m - 1:\n                dfs(x, y + 1)\n        elif horizontal[x] == '<':\n            if y > 0:\n                dfs(x, y - 1)\n        \n        if vertical[y] == 'v':\n            if x < n - 1:\n                dfs(x + 1, y)\n        elif vertical[y] == '^':\n            if x > 0:\n                dfs(x - 1, y)\n\n    # Start DFS from the first junction\n    dfs(0, 0)\n\n    # Check if all junctions are visited\n    for i in range(n):\n        for j in range(m):\n            if not visited[i][j]:\n                return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nhorizontal = input().strip()\nvertical = input().strip()\n\n# Get the result and print it\nresult = can_reach_all_junctions(n, m, horizontal, vertical)\nprint(result)"}
{"solution": "def can_form_false_expression(n, args):\n    # Check for the presence of 1 followed by 0\n    for i in range(n - 1):\n        if args[i] == 1 and args[i + 1] == 0:\n            # We found a valid pair\n            # Construct the expression\n            expression = []\n            for j in range(n):\n                if j == i:\n                    expression.append('(' + str(args[j]) + '->')\n                elif j == i + 1:\n                    expression.append(str(args[j]) + ')')\n                else:\n                    expression.append(str(args[j]))\n                if j < n - 1:\n                    expression.append('->')\n            return \"YES\\n\" + ''.join(expression)\n    \n    # If no valid pair found\n    if 0 in args and n == 1:\n        return \"YES\\n0\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\nargs = list(map(int, input().split()))\n\n# Get the result\nresult = can_form_false_expression(n, args)\nprint(result)"}
{"solution": "def process_values(n, m):\n    while n > 0 and m > 0:\n        if n >= 2 * m:\n            n %= 2 * m\n        elif m >= 2 * n:\n            m %= 2 * n\n        else:\n            break\n    return n, m\n\n# Read input\nn, m = map(int, input().split())\n# Process and get the result\nresult = process_values(n, m)\n# Print the output\nprint(result[0], result[1])"}
{"solution": "def count_k_divisible(k, a, b):\n    # Find the first number >= a that is divisible by k\n    if a % k == 0:\n        first = a\n    else:\n        first = a + (k - (a % k)) if a > 0 else a - (a % k)\n\n    # Find the last number <= b that is divisible by k\n    if b % k == 0:\n        last = b\n    else:\n        last = b - (b % k)\n\n    # If the first number is greater than the last, there are no valid numbers\n    if first > last:\n        return 0\n\n    # Count the numbers divisible by k in the range\n    count = (last - first) // k + 1\n    return count\n\n# Read input\nk, a, b = map(int, input().split())\n# Calculate and print the result\nprint(count_k_divisible(k, a, b))"}
{"solution": "def find_kth_digit(k):\n    # Step 1: Initialize variables\n    digit_length = 1\n    count = 9\n    start = 1\n    \n    # Step 2: Find the range where the k-th digit lies\n    while k > digit_length * count:\n        k -= digit_length * count\n        digit_length += 1\n        count *= 10\n        start *= 10\n    \n    # Step 3: Find the exact number\n    start += (k - 1) // digit_length\n    number_str = str(start)\n    \n    # Step 4: Find the exact digit\n    digit_index = (k - 1) % digit_length\n    return number_str[digit_index]\n\n# Read input\nk = int(input())\n# Print the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "def can_vasya_win(n, s):\n    # Count the number of '8's in the string\n    count_8 = s.count('8')\n    \n    # Calculate the number of moves Vasya can make\n    moves_vasya = (n - 11) // 2 + 1\n    \n    # Vasya can guarantee a win if there are at least 11 digits left\n    # and at least as many '8's as the number of moves he can make\n    if count_8 >= 1 and count_8 <= moves_vasya:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Print the result\nprint(can_vasya_win(n, s))"}
{"solution": "def factorial_mod(n, mod):\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % mod\n    return result\n\ndef count_valid_permutations(n, x, pos):\n    MOD = 10**9 + 7\n    \n    # Count elements to the left and right\n    left_count = n - x  # Elements greater than x\n    right_count = x - 1  # Elements less than x\n    \n    # Calculate the number of elements that can be placed to the left of pos\n    if pos > 0:\n        left_elements = min(left_count, pos)  # Maximum elements we can place to the left\n    else:\n        left_elements = 0\n    \n    # Calculate the number of elements that can be placed to the right of pos\n    if pos < n - 1:\n        right_elements = min(right_count, n - pos - 1)  # Maximum elements we can place to the right\n    else:\n        right_elements = 0\n    \n    # Calculate factorials for left and right arrangements\n    left_permutations = factorial_mod(left_elements, MOD)\n    right_permutations = factorial_mod(right_elements, MOD)\n    \n    # Total valid permutations\n    total_permutations = (left_permutations * right_permutations) % MOD\n    \n    return total_permutations\n\n# Input reading\nn, x, pos = map(int, input().strip().split())\nresult = count_valid_permutations(n, x, pos)\nprint(result)"}
{"solution": "def decode_message(encoded_string, k):\n    min_length = 0\n    max_length = 0\n    n = len(encoded_string)\n    \n    # Calculate min_length and max_length\n    i = 0\n    while i < n:\n        if encoded_string[i].isalpha():\n            min_length += 1\n            max_length += 1\n            if i + 1 < n and encoded_string[i + 1] == '?':\n                max_length += 1\n                i += 1  # Skip the candy cane\n            elif i + 1 < n and encoded_string[i + 1] == '*':\n                max_length += 200  # Assume a large number for repetition\n                i += 1  # Skip the snowflake\n        i += 1\n    \n    # Check if k is within the possible range\n    if k < min_length or k > max_length:\n        return \"Impossible\"\n    \n    # Construct a valid message\n    result = []\n    remaining_length = k\n    i = 0\n    \n    while i < n:\n        if encoded_string[i].isalpha():\n            result.append(encoded_string[i])\n            remaining_length -= 1\n            \n            if i + 1 < n and encoded_string[i + 1] == '?':\n                # Decide to keep or remove\n                if remaining_length < 0:  # If we need more letters, keep it\n                    result.append(encoded_string[i])\n                    remaining_length += 1\n                i += 1  # Skip the candy cane\n            \n            elif i + 1 < n and encoded_string[i + 1] == '*':\n                # We can repeat this letter\n                while remaining_length > 0:\n                    result.append(encoded_string[i])\n                    remaining_length -= 1\n                i += 1  # Skip the snowflake\n        i += 1\n    \n    # If we still need more letters, we can add more from the last letter\n    while remaining_length > 0 and result:\n        result.append(result[-1])\n        remaining_length -= 1\n    \n    return ''.join(result) if len(result) == k else \"Impossible\"\n\n# Input reading\nencoded_string = input().strip()\nk = int(input().strip())\n\n# Output the result\nprint(decode_message(encoded_string, k))"}
{"solution": "def minimum_turns(x):\n    # Normalize the angle to be within the range of 0 to 360 degrees\n    normalized_angle = x % 360\n    \n    # Calculate the effective angle after considering clockwise rotation\n    effective_angle = (360 - normalized_angle) % 360\n    \n    # Determine the minimum number of 90-degree clockwise turns\n    min_turns = effective_angle // 90\n    \n    # If there's a remainder, we need one additional turn\n    if effective_angle % 90 != 0:\n        min_turns += 1\n    \n    return min_turns\n\n# Read input\nx = int(input().strip())\n# Output the result\nprint(minimum_turns(x))"}
{"solution": "def can_transform_spheres(a, b, c, x, y, z):\n    # Calculate the surplus and deficit of each color\n    surplus_blue = a - x\n    surplus_violet = b - y\n    surplus_orange = c - z\n    \n    # Calculate total surplus and total deficit\n    total_surplus = max(0, surplus_blue) + max(0, surplus_violet) + max(0, surplus_orange)\n    total_deficit = max(0, -surplus_blue) + max(0, -surplus_violet) + max(0, -surplus_orange)\n    \n    # Each transformation requires 2 spheres of the same color to create 1 sphere of another color\n    # Therefore, the total surplus can be converted into (total_surplus // 2) new spheres\n    if total_surplus // 2 >= total_deficit:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Input reading\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Output the result\nprint(can_transform_spheres(a, b, c, x, y, z))"}
{"solution": "def count_valid_numbers(n, k, m):\n    # Count valid suffixes for each length from 1 to n\n    valid_suffix_count = [0] * (n + 1)\n\n    # Count valid suffixes of length d\n    for d in range(1, n + 1):\n        # The range of numbers with d digits\n        start = 10**(d - 1)\n        end = 10**d - 1\n        \n        # Count how many numbers in this range are divisible by k\n        count = (end // k) - ((start - 1) // k)\n        valid_suffix_count[d] = count\n\n    # Now we need to calculate the total valid numbers with n digits\n    total_count = 0\n    \n    # For each valid suffix length d, we can have (10^(n-d)) choices for the prefix\n    for d in range(1, n + 1):\n        # Number of valid prefixes for n-d digits\n        if n - d == 0:\n            prefix_count = 1  # Only one way to have a number with exactly d digits\n        else:\n            prefix_count = 9 * (10 ** (n - d - 1))  # 9 choices for the first digit (1-9) and 10 for the rest\n        \n        total_count += (prefix_count * valid_suffix_count[d]) % m\n        total_count %= m\n\n    return total_count\n\n# Read input\nn, k, m = map(int, input().split())\n\n# Get the result\nresult = count_valid_numbers(n, k, m)\n\n# Print the result\nprint(result)"}
{"solution": "def max_team_size(l, r, a):\n    # Ensure l is the smaller group\n    if l > r:\n        l, r = r, l\n    \n    # Calculate the difference between left and right\n    diff = r - l\n    \n    # If there are enough ambidexters to balance the teams\n    if a >= diff:\n        a -= diff\n        l += diff\n        # Now both sides are equal, distribute remaining ambidexters\n        l += a // 2\n        r += a // 2\n    else:\n        # Not enough ambidexters to balance, just add them to the smaller side\n        l += a\n    \n    # The total team size must be even\n    return (l + r) if (l + r) % 2 == 0 else (l + r - 1)\n\n# Read input\nl, r, a = map(int, input().split())\n# Calculate and print the maximum team size\nprint(max_team_size(l, r, a))"}
{"solution": "def minimum_moves(n, k):\n    # Calculate the total moves required\n    total_moves = 0\n    \n    # Moves to throw stones to open all manholes\n    # For each manhole, we need to throw stones to it\n    # Each manhole requires 1 throw to itself and 1 throw from each of its neighbors\n    total_moves += (n - 1) * 2  # Each manhole except the starting one needs 2 moves (1 throw + 1 move)\n    \n    # Moves to open all manholes\n    total_moves += n  # Opening each manhole takes 1 move\n    \n    # Moves to return to the starting position after collecting all coins\n    total_moves += abs(k - 1) + abs(k - n)  # Move to the first manhole and then to the last manhole\n    \n    return total_moves\n\n# Read input\nn, k = map(int, input().split())\n# Calculate and print the result\nprint(minimum_moves(n, k))"}
{"solution": "def minimum_tower_height(n, m):\n    # Heights for two-block pieces (2, 4, 6, ..., 2n)\n    two_block_heights = {2 * i for i in range(1, n + 1)}\n    \n    # Heights for three-block pieces (3, 6, 9, ..., 3m)\n    three_block_heights = {3 * i for i in range(1, m + 1)}\n    \n    # Combine both sets to ensure uniqueness\n    all_heights = two_block_heights.union(three_block_heights)\n    \n    # The maximum height will be the tallest tower\n    return max(all_heights)\n\n# Read input\nn, m = map(int, input().split())\n# Calculate and print the result\nprint(minimum_tower_height(n, m))"}
{"solution": "def fair_game(n, cards):\n    from collections import Counter\n    \n    # Count occurrences of each number\n    count = Counter(cards)\n    \n    # We need to find two distinct numbers with equal counts\n    candidates = []\n    \n    for num, cnt in count.items():\n        if cnt * 2 == n:  # Check if the count of this number can be half of n\n            candidates.append(num)\n    \n    # If we have at least two distinct numbers that can form a fair game\n    if len(candidates) >= 2:\n        return \"YES\", (candidates[0], candidates[1])\n    \n    # Check for pairs of distinct numbers\n    for num1 in count:\n        for num2 in count:\n            if num1 != num2 and count[num1] + count[num2] == n:\n                return \"YES\", (num1, num2)\n    \n    return \"NO\", None\n\n# Read input\nn = int(input())\ncards = [int(input()) for _ in range(n)]\nresult = fair_game(n, cards)\n\nif result[0] == \"NO\":\n    print(result[0])\nelse:\n    print(result[0])\n    print(result[1][0], result[1][1])"}
{"solution": "def can_seat_army(n, k, groups):\n    # Calculate the total number of pairs available\n    total_pairs = 5 * n\n    \n    # Find the maximum size of the groups\n    max_group_size = max(groups)\n    \n    # Check if the largest group can fit into the available pairs\n    if max_group_size > total_pairs:\n        return \"NO\"\n    \n    # If the total number of soldiers is less than or equal to the total number of seats\n    total_soldiers = sum(groups)\n    if total_soldiers <= 8 * n:\n        return \"YES\"\n    \n    # If we reach here, we need to check if we can arrange them properly\n    # We can use pairs of seats to fit the groups\n    # Sort groups in descending order\n    groups.sort(reverse=True)\n    \n    # Try to fill the pairs\n    pairs_used = 0\n    for group in groups:\n        # Each group can occupy pairs\n        pairs_needed = (group + 1) // 2  # ceil(group / 2)\n        pairs_used += pairs_needed\n    \n    # If we can fit all pairs used within the available pairs\n    if pairs_used <= total_pairs:\n        return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_seat_army(n, k, groups)\nprint(result)"}
{"solution": "def min_cost_to_make_sticks_almost_good(n, stick_lengths):\n    min_cost = float('inf')\n    best_t = -1\n\n    for t in range(1, 101):  # t can be from 1 to 100\n        cost = 0\n        for length in stick_lengths:\n            if length < t - 1:\n                cost += (t - 1) - length  # Need to increase length\n            elif length > t + 1:\n                cost += length - (t + 1)  # Need to decrease length\n            # If length is within [t-1, t+1], cost is 0\n\n        if cost < min_cost:\n            min_cost = cost\n            best_t = t\n\n    return best_t, min_cost\n\n# Input reading\nn = int(input())\nstick_lengths = list(map(int, input().split()))\n\n# Get the result\nresult_t, result_cost = min_cost_to_make_sticks_almost_good(n, stick_lengths)\n\n# Output the result\nprint(result_t, result_cost)"}
{"solution": "def min_square_side(n, m, star_map):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n\n    for i in range(n):\n        for j in range(m):\n            if star_map[i][j] == '*':\n                if i < min_row:\n                    min_row = i\n                if i > max_row:\n                    max_row = i\n                if j < min_col:\n                    min_col = j\n                if j > max_col:\n                    max_col = j\n\n    width = max_col - min_col + 1\n    height = max_row - min_row + 1\n    side_length = max(width, height)\n\n    return side_length\n\n# Read input\nn, m = map(int, input().split())\nstar_map = [input().strip() for _ in range(n)]\n\n# Calculate and print the result\nresult = min_square_side(n, m, star_map)\nprint(result)"}
{"solution": "def mod_inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:n+2]))\n    \n    MOD = 10**9 + 7\n    \n    c0 = a.count(0)\n    c1 = n - c0\n    \n    # If already sorted\n    if c0 == 0 or c1 == 0:\n        print(1)\n        return\n    \n    # If k is 0, we cannot swap, check if sorted\n    if k == 0:\n        if a == sorted(a):\n            print(1)\n        else:\n            print(0)\n        return\n    \n    # Calculate C(n, 2)\n    C_n_2 = (n * (n - 1) // 2) % MOD\n    \n    # Calculate C(n, 2)^k % MOD\n    total_configurations = pow(C_n_2, k, MOD)\n    \n    # The number of favorable configurations is 1 (the sorted array)\n    P = 1\n    Q = total_configurations\n    \n    # Calculate the result\n    result = (P * mod_inverse(Q, MOD)) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def minimum_seconds_to_transform(x, y):\n    # The number of seconds required to transform the triangle\n    seconds = 0\n    \n    # While the sides are not equal to y\n    while x > y:\n        # Reduce one side to y\n        if x > y:\n            x -= 1\n            seconds += 1\n        \n        # Ensure the triangle remains valid\n        if x > y:\n            x -= 1\n            seconds += 1\n        \n        # Reduce the last side to y\n        if x > y:\n            x -= 1\n            seconds += 1\n            \n    return seconds\n\n# Read input\nx, y = map(int, input().split())\n\n# Calculate and print the result\nprint(minimum_seconds_to_transform(x, y))"}
{"solution": "def minimum_norm(a, b, c, d):\n    # Calculate the determinant of matrix A\n    det_A = a * d - b * c\n    \n    # Calculate the sum of elements of matrix A\n    sum_A = a + b + c + d\n    \n    # Calculate the minimum possible value of ||A - B||\n    if sum_A == 0:\n        return abs(det_A)  # If sum_A is zero, we avoid division by zero\n    else:\n        return abs(det_A) / abs(sum_A)\n\n# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate and print the result\nresult = minimum_norm(a, b, c, d)\nprint(f\"{result:.10f}\")"}
{"solution": "def seating_groups(n, a, b, groups):\n    denied_service = 0\n\n    for group in groups:\n        if group == 1:  # Group of one person\n            if a > 0:  # Check for one-seater table\n                a -= 1\n            elif b > 0:  # Check for two-seater table\n                b -= 1\n            elif b < 0:  # Check for two-seater table with one person already seated\n                denied_service += 1\n            else:\n                denied_service += 1\n        elif group == 2:  # Group of two people\n            if b > 0:  # Check for two-seater table\n                b -= 1\n            else:\n                denied_service += 2  # Deny service to both people\n\n    return denied_service\n\n# Input reading\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Output the result\nprint(seating_groups(n, a, b, groups))"}
{"solution": "def calculate_students(A, B, C, N):\n    # Check for invalid conditions\n    if A < C or B < C or A + B - C > N:\n        return -1\n    \n    # Calculate the number of students who passed\n    passed = A + B - C\n    \n    # Calculate the number of students who did not pass\n    did_not_pass = N - passed\n    \n    # Check if at least one student did not pass (including Vasya)\n    if did_not_pass >= 1:\n        return did_not_pass\n    else:\n        return -1\n\n# Read input values\nA, B, C, N = map(int, input().split())\nresult = calculate_students(A, B, C, N)\nprint(result)"}
{"solution": "def expected_dresses(x, k):\n    MOD = 10**9 + 7\n    \n    if x == 0:\n        return 0\n    \n    # Calculate powers of 2 modulo MOD\n    pow2_k = pow(2, k, MOD)\n    pow2_k_plus_1 = (pow2_k * 2) % MOD\n    \n    # Calculate expected number of dresses\n    expected_value = (pow2_k_plus_1 * x % MOD - (pow2_k - 1) + MOD) % MOD\n    \n    return expected_value\n\n# Read input\nx, k = map(int, input().split())\n# Print the expected number of dresses\nprint(expected_dresses(x, k))"}
{"solution": "def mod_inverse(a, p):\n    return pow(a, p - 2, p)\n\ndef calculate_probability(n, ranges):\n    MOD = 998244353\n    \n    total_ways = 1\n    no_inversion_ways = 1\n    \n    for l, r in ranges:\n        total_ways *= (r - l + 1)\n        total_ways %= MOD\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            l1, r1 = ranges[i]\n            l2, r2 = ranges[j]\n            # Count the number of ways to choose values such that no inversion occurs\n            no_inversion_ways *= max(0, min(r1, r2) - max(l1, l2) + 1)\n            no_inversion_ways %= MOD\n    \n    # The probability is no_inversion_ways / total_ways\n    x = no_inversion_ways\n    y = total_ways\n    \n    if x == 0:\n        return 0\n    \n    y_inv = mod_inverse(y, MOD)\n    \n    result = (x * y_inv) % MOD\n    return result\n\n# Input reading\nn = int(input())\nranges = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(calculate_probability(n, ranges))"}
{"solution": "def count_ways(n):\n    if n % 2 != 0:\n        return 0  # If n is odd, return 0\n    m = n // 2\n    return (m - 1) // 2  # Count of valid pairs (a, b)\n\nn = int(input())\nprint(count_ways(n))"}
{"solution": "def can_pour(v, n, s, min_volume):\n    total_pourable = 0\n    for volume in v:\n        if volume > min_volume:\n            total_pourable += volume - min_volume\n        if total_pourable >= s:\n            return True\n    return total_pourable >= s\n\ndef max_min_kvass(n, s, volumes):\n    total_kvass = sum(volumes)\n    \n    if total_kvass < s:\n        return -1\n    \n    left, right = 0, min(volumes)\n    answer = 0\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if can_pour(volumes, n, s, mid):\n            answer = mid  # mid is a valid answer\n            left = mid + 1  # try for a larger minimum\n        else:\n            right = mid - 1  # try for a smaller minimum\n    \n    return answer\n\n# Read input\nn, s = map(int, input().split())\nvolumes = list(map(int, input().split()))\n\n# Print the result\nprint(max_min_kvass(n, s, volumes))"}
{"solution": "def caterpillar_to_apple(h1, h2, a, b):\n    # Calculate the height of the caterpillar at 10 pm on the first day\n    height_at_10_pm = h1 + 8 * a\n    \n    # Check if the caterpillar reaches the apple by 10 pm on the first day\n    if height_at_10_pm >= h2:\n        return 0\n    \n    # Calculate the height at 10 am the next day\n    height_at_10_am_next_day = height_at_10_pm - 12 * b\n    \n    # Calculate the net movement per day\n    net_movement = 8 * a - 12 * b\n    \n    # If the net movement is negative and it didn't reach the apple, it will never reach it\n    if net_movement < 0:\n        return -1\n    \n    # If the caterpillar has a positive net movement, calculate how many days it will take\n    days_needed = 0\n    while height_at_10_am_next_day < h2:\n        days_needed += 1\n        height_at_10_am_next_day += net_movement\n    \n    return days_needed\n\n# Read input\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Get the result and print it\nresult = caterpillar_to_apple(h1, h2, a, b)\nprint(result)"}
{"solution": "def max_joy(C, H_r, H_b, W_r, W_b):\n    # Calculate joy per gram for each type of candy\n    joy_per_gram_r = H_r / W_r\n    joy_per_gram_b = H_b / W_b\n    \n    # Determine which candy has a higher joy per gram\n    if joy_per_gram_r > joy_per_gram_b:\n        # Maximize red candies first\n        max_red_candies = C // W_r\n        total_joy = max_red_candies * H_r\n        remaining_weight = C - (max_red_candies * W_r)\n        max_blue_candies = remaining_weight // W_b\n        total_joy += max_blue_candies * H_b\n    else:\n        # Maximize blue candies first\n        max_blue_candies = C // W_b\n        total_joy = max_blue_candies * H_b\n        remaining_weight = C - (max_blue_candies * W_b)\n        max_red_candies = remaining_weight // W_r\n        total_joy += max_red_candies * H_r\n    \n    return total_joy\n\n# Read input\nC, H_r, H_b, W_r, W_b = map(int, input().split())\n\n# Calculate and print the maximum joy\nprint(max_joy(C, H_r, H_b, W_r, W_b))"}
{"solution": "# Read the starting coordinates\nx1, y1 = map(int, input().split())\n# Read the finishing coordinates\nx2, y2 = map(int, input().split())\n\n# Calculate the differences in x and y coordinates\ndx = abs(x2 - x1)\ndy = abs(y2 - y1)\n\n# The minimal number of steps is the maximum of the two differences\nd = max(dx, dy)\n\n# Print the result\nprint(d)"}
{"solution": "def predict_vote_outcome(n, employees):\n    depublicans = employees.count('D')\n    remocrats = employees.count('R')\n    \n    # The faction with the majority will win\n    if depublicans > remocrats:\n        return 'D'\n    else:\n        return 'R'\n\n# Input reading\nn = int(input().strip())\nemployees = input().strip()\n\n# Predict and print the outcome\nprint(predict_vote_outcome(n, employees))"}
{"solution": "def count_tv_sets(a, b, x, y):\n    # Calculate the greatest common divisor of x and y\n    from math import gcd\n    g = gcd(x, y)\n    \n    # Reduce x and y by their gcd\n    x //= g\n    y //= g\n    \n    # Calculate the maximum k for width and height\n    k_max_width = a // x\n    k_max_height = b // y\n    \n    # The maximum k that satisfies both conditions\n    k_max = min(k_max_width, k_max_height)\n    \n    return k_max\n\n# Read input\na, b, x, y = map(int, input().split())\n# Print the result\nprint(count_tv_sets(a, b, x, y))"}
{"solution": "def prime_factorization(b):\n    factors = {}\n    d = 2\n    while d * d <= b:\n        while (b % d) == 0:\n            if d in factors:\n                factors[d] += 1\n            else:\n                factors[d] = 1\n            b //= d\n        d += 1\n    if b > 1:\n        factors[b] = 1\n    return factors\n\ndef count_factors_in_factorial(n, p):\n    count = 0\n    power = p\n    while power <= n:\n        count += n // power\n        power *= p\n    return count\n\ndef trailing_zeros_in_base(n, b):\n    factors = prime_factorization(b)\n    min_trailing_zeros = float('inf')\n    \n    for p, e in factors.items():\n        count_p = count_factors_in_factorial(n, p)\n        min_trailing_zeros = min(min_trailing_zeros, count_p // e)\n    \n    return min_trailing_zeros\n\n# Read input\nn, b = map(int, input().split())\n# Calculate and print the number of trailing zeros\nprint(trailing_zeros_in_base(n, b))"}
{"solution": "def sum_of_reachable(m, a, b):\n    from math import gcd\n    \n    g = gcd(a, b)\n    \n    # Calculate the number of reachable integers for each i from 0 to m\n    total_sum = 0\n    \n    # The number of reachable integers f(i) can be calculated based on the intervals\n    for i in range(m + 1):\n        if i < b:\n            total_sum += (i // g) + 1\n        else:\n            total_sum += (i // g) + 1\n    \n    return total_sum\n\n# Read input\nm, a, b = map(int, input().split())\n# Print the result\nprint(sum_of_reachable(m, a, b))"}
{"solution": "# Read the length of the sequence\nn = int(input().strip())\n\n# Read the sequence of integers\nsequence = list(map(int, input().strip().split()))\n\n# Check the conditions for the sequence\nif n % 2 == 1 and sequence[0] % 2 == 1 and sequence[-1] % 2 == 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def find_square_trees(x1, y1, x2, y2):\n    if x1 == x2:  # Vertical alignment\n        distance = abs(y2 - y1)\n        x3, y3 = x1 + distance, y1\n        x4, y4 = x2 + distance, y2\n    elif y1 == y2:  # Horizontal alignment\n        distance = abs(x2 - x1)\n        x3, y3 = x1, y1 + distance\n        x4, y4 = x2, y2 + distance\n    elif abs(x1 - x2) == abs(y1 - y2):  # Diagonal alignment\n        x3, y3 = x1, y2\n        x4, y4 = x2, y1\n    else:\n        return -1  # No valid square can be formed\n\n    return x3, y3, x4, y4\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\nresult = find_square_trees(x1, y1, x2, y2)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def calculate_fn(x, y, n):\n    MOD = 1000000007\n    \n    # Calculate the position in the cycle\n    position = n % 6\n    \n    if position == 1:\n        result = x\n    elif position == 2:\n        result = y\n    elif position == 3:\n        result = y - x\n    elif position == 4:\n        result = -x\n    elif position == 5:\n        result = -y\n    elif position == 0:\n        result = x - y\n    \n    # Adjust result to be within the range [0, MOD)\n    result = result % MOD\n    return result\n\n# Input reading\nx, y = map(int, input().split())\nn = int(input())\nprint(calculate_fn(x, y, n))"}
{"solution": "def split_array(n, A):\n    total_sum = sum(A)\n    \n    if total_sum == 0:\n        # Check if all elements are zero\n        if all(x == 0 for x in A):\n            print(\"NO\")\n            return\n        else:\n            # We can split into non-zero subarrays\n            subarrays = []\n            current_sum = 0\n            start_index = 0\n            \n            for i in range(n):\n                current_sum += A[i]\n                if current_sum == 0:\n                    # We found a zero-sum subarray, we need to split here\n                    subarrays.append((start_index + 1, i))  # Store 1-based index\n                    start_index = i + 1\n                    current_sum = 0\n            \n            # Add the last segment if it has non-zero sum\n            if start_index < n:\n                subarrays.append((start_index + 1, n))\n            \n            print(\"YES\")\n            print(len(subarrays))\n            for l, r in subarrays:\n                print(l, r)\n    else:\n        # If total sum is not zero, we can take the whole array as one subarray\n        print(\"YES\")\n        print(1)\n        print(1, n)\n\n# Read input\nn = int(input())\nA = list(map(int, input().split()))\n\n# Call the function\nsplit_array(n, A)"}
{"solution": "def minimum_score(n, m, k):\n    MOD = 1000000009\n    \n    if m == 0:\n        return 0  # If no correct answers, score is 0\n    \n    # Number of complete sets of k correct answers\n    complete_sets = m // k\n    # Remaining correct answers after complete sets\n    remaining_correct = m % k\n    \n    # Calculate the score\n    score = (remaining_correct + complete_sets) % MOD\n    score = (score * pow(2, complete_sets, MOD)) % MOD\n    \n    return score\n\n# Read input\nn, m, k = map(int, input().split())\n# Print the result\nprint(minimum_score(n, m, k))"}
{"solution": "def is_divisible_by_8(n):\n    length = len(n)\n    \n    # Check single digit\n    for i in range(length):\n        if int(n[i]) % 8 == 0:\n            return True, n[i]\n    \n    # Check two digits\n    for i in range(length):\n        for j in range(i + 1, length):\n            if int(n[i] + n[j]) % 8 == 0:\n                return True, n[i] + n[j]\n    \n    # Check three digits\n    for i in range(length):\n        for j in range(i + 1, length):\n            for k in range(j + 1, length):\n                if int(n[i] + n[j] + n[k]) % 8 == 0:\n                    return True, n[i] + n[j] + n[k]\n    \n    return False, \"\"\n\nn = input().strip()\npossible, result = is_divisible_by_8(n)\n\nif possible:\n    print(\"YES\")\n    print(result)\nelse:\n    print(\"NO\")"}
{"solution": "def find_floor(n, m, memories):\n    min_x = 1\n    max_x = 100\n    \n    for k_i, f_i in memories:\n        # Calculate the bounds for x based on the memory\n        lower_bound = (k_i + f_i - 1) // f_i  # ceil(k_i / f_i)\n        upper_bound = k_i // (f_i - 1) if f_i > 1 else 100  # floor(k_i / (f_i - 1))\n        \n        min_x = max(min_x, lower_bound)\n        max_x = min(max_x, upper_bound)\n    \n    if min_x > max_x:\n        return -1  # No valid x exists\n    \n    # Now we need to check the floors for each valid x\n    possible_floors = set()\n    \n    for x in range(min_x, max_x + 1):\n        floor = (n + x - 1) // x  # ceil(n / x)\n        possible_floors.add(floor)\n    \n    if len(possible_floors) == 1:\n        return possible_floors.pop()  # Return the unique floor\n    else:\n        return -1  # More than one possible floor\n\n# Input reading\nn, m = map(int, input().split())\nmemories = [tuple(map(int, input().split())) for _ in range(m)]\nprint(find_floor(n, m, memories))"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    count = 0\n    i = 0\n    \n    while i < n:\n        # Check for the first orientation (horizontal placement)\n        if board1[i] == '0' and board1[i + 1] == '0' and i + 1 < n:\n            count += 1\n            i += 2  # Move past the two squares occupied by the Bishwock\n        # Check for the second orientation (vertical placement)\n        elif board1[i] == '0' and board2[i] == '0':\n            count += 1\n            i += 1  # Move past the square occupied by the Bishwock\n        else:\n            i += 1  # Move to the next square\n\n    return count\n\n# Read input\nboard1 = input().strip()\nboard2 = input().strip()\n\n# Calculate and print the maximum number of Bishwocks\nprint(max_bishwocks(board1, board2))"}
{"solution": "def max_pretty_set(n, s):\n    max_count = 0\n    current_segment = set()\n    \n    for char in s:\n        if char.islower():\n            current_segment.add(char)\n        else:\n            # Uppercase letter encountered, evaluate the current segment\n            max_count = max(max_count, len(current_segment))\n            current_segment.clear()  # Reset for the next segment\n    \n    # Final check for the last segment\n    max_count = max(max_count, len(current_segment))\n    \n    return max_count\n\n# Input reading\nn = int(input())\ns = input().strip()\nprint(max_pretty_set(n, s))"}
{"solution": "def maximize_difference(n, a):\n    B = sum(x for x in a if x > 0)  # Sum of positive elements\n    C = sum(x for x in a if x < 0)  # Sum of negative elements\n    return B - C  # B - C is equivalent to B + (-C)\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = maximize_difference(n, a)\nprint(result)"}
{"solution": "def min_refuels(a, b, f, k):\n    total_distance = 2 * a * k  # Total distance for k journeys\n    if b < f:  # Cannot reach the gas station\n        return -1\n    \n    # Calculate the distance the bus can travel before needing to refuel\n    distance_to_gas_station = f\n    distance_to_a = a\n    \n    # Check if the bus can complete the first journey\n    if b < distance_to_a:\n        return -1\n    \n    # Calculate the number of refuels needed\n    refuels = 0\n    remaining_distance = total_distance\n    \n    # While there are journeys left to complete\n    for journey in range(k):\n        # Each journey consists of going to 'a' and back to '0'\n        # Check if we need to refuel before reaching 'a'\n        if journey > 0:  # For subsequent journeys, we need to consider refuels\n            if remaining_distance < distance_to_gas_station:\n                return -1  # Not enough fuel to reach the gas station\n            \n            # Refuel at the gas station\n            refuels += 1\n            remaining_distance -= distance_to_gas_station  # Distance to gas station\n            remaining_distance -= distance_to_gas_station  # Distance back to '0'\n        \n        # After refueling, we can go to 'a' and back to '0'\n        remaining_distance -= distance_to_a  # Go to 'a'\n        remaining_distance -= distance_to_a  # Return to '0'\n    \n    return refuels\n\n# Input reading\na, b, f, k = map(int, input().split())\n# Output the result\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    for x in range(n // p + 1):\n        remaining_length = n - x * p\n        if remaining_length >= 0 and remaining_length % q == 0:\n            y = remaining_length // q\n            result = []\n            index = 0\n            \n            # Add x pieces of length p\n            for _ in range(x):\n                result.append(s[index:index + p])\n                index += p\n            \n            # Add y pieces of length q\n            for _ in range(y):\n                result.append(s[index:index + q])\n                index += q\n            \n            print(len(result))\n            for piece in result:\n                print(piece)\n            return\n    \n    print(-1)\n\n# Read input\nn, p, q = map(int, input().split())\ns = input().strip()\n\n# Call the function\nsplit_string(n, p, q, s)"}
{"solution": "def can_reach_finish(n, m, s, d, obstacles):\n    obstacles.sort()\n    current_position = 0\n    commands = []\n    \n    for obstacle in obstacles:\n        # Calculate the distance to the next obstacle\n        distance_to_obstacle = obstacle - current_position\n        \n        # Check if we can run to the obstacle\n        if distance_to_obstacle > s + d:\n            # We can run the maximum distance we can before jumping\n            run_distance = s\n            commands.append(f\"RUN {run_distance}\")\n            current_position += run_distance\n            \n            # Now we can jump over the obstacle\n            jump_distance = obstacle - current_position + d\n            commands.append(f\"JUMP {jump_distance}\")\n            current_position = obstacle + jump_distance\n        else:\n            # We need to run to the obstacle and jump over it\n            if distance_to_obstacle <= s:\n                # We can run directly to the obstacle\n                commands.append(f\"RUN {distance_to_obstacle}\")\n                current_position = obstacle\n            else:\n                # We need to run the maximum we can before jumping\n                run_distance = s\n                commands.append(f\"RUN {run_distance}\")\n                current_position += run_distance\n            \n            # Now we can jump over the obstacle\n            jump_distance = obstacle - current_position + d\n            if jump_distance <= d:\n                commands.append(f\"JUMP {jump_distance}\")\n                current_position = obstacle + jump_distance\n            else:\n                return \"IMPOSSIBLE\"\n    \n    # After the last obstacle, check if we can reach the finish line\n    distance_to_finish = m - current_position\n    if distance_to_finish > s + d:\n        run_distance = s\n        commands.append(f\"RUN {run_distance}\")\n        current_position += run_distance\n        \n        jump_distance = distance_to_finish\n        if jump_distance <= d:\n            commands.append(f\"JUMP {jump_distance}\")\n            current_position = m\n        else:\n            return \"IMPOSSIBLE\"\n    else:\n        if distance_to_finish <= s:\n            commands.append(f\"RUN {distance_to_finish}\")\n            current_position = m\n        else:\n            run_distance = s\n            commands.append(f\"RUN {run_distance}\")\n            current_position += run_distance\n            \n            jump_distance = distance_to_finish\n            if jump_distance <= d:\n                commands.append(f\"JUMP {jump_distance}\")\n                current_position = m\n            else:\n                return \"IMPOSSIBLE\"\n    \n    return \"\\n\".join(commands)\n\n# Input reading\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\n# Get the result\nresult = can_reach_finish(n, m, s, d, obstacles)\n\n# Print the result\nprint(result)"}
{"solution": "def count_ordered_pairs(s, x):\n    # Check the conditions for validity\n    if s < x or (s - x) % 2 != 0:\n        return 0\n    \n    # Calculate a & b\n    k = (s - x) // 2\n    \n    # Check if (k & x) is 0\n    if (k & x) != 0:\n        return 0\n    \n    # Count the number of bits that are 0 in (k & x)\n    count_of_zero_bits = 0\n    combined = k | x  # Combine k and x to check the bits\n    for i in range(64):  # Check up to 64 bits\n        if (combined & (1 << i)) == 0:\n            count_of_zero_bits += 1\n    \n    # The number of valid pairs is 2 raised to the number of zero bits\n    return 1 << count_of_zero_bits\n\n# Read input\ns, x = map(int, input().split())\n# Get the result\nresult = count_ordered_pairs(s, x)\n# Print the output\nprint(result)"}
{"solution": "def turn_skewers(n, k):\n    actions = []\n    step_size = 2 * k + 1  # Total skewers affected by one action\n    for i in range(1, n + 1, step_size):\n        actions.append(i)\n    \n    print(len(actions))\n    print(\" \".join(map(str, actions)))\n\n# Read input\nn, k = map(int, input().split())\nturn_skewers(n, k)"}
{"solution": "def min_deletions_to_square(n):\n    n_str = str(n)\n    max_square_root = int(2 * 10**9**0.5)  # 44721\n    perfect_squares = [i * i for i in range(1, max_square_root + 1)]\n    \n    min_deletions = float('inf')\n    found_square = False\n    \n    for square in perfect_squares:\n        square_str = str(square)\n        i, j = 0, 0\n        \n        # Check if square_str is a subsequence of n_str\n        while i < len(n_str) and j < len(square_str):\n            if n_str[i] == square_str[j]:\n                j += 1\n            i += 1\n        \n        if j == len(square_str):  # Found a valid subsequence\n            found_square = True\n            deletions = len(n_str) - len(square_str)\n            min_deletions = min(min_deletions, deletions)\n    \n    return min_deletions if found_square else -1\n\n# Read input\nn = int(input())\n# Print the result\nprint(min_deletions_to_square(n))"}
{"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count\n\ndef factorial_mod(n, mod):\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % mod\n    return result\n\ndef main():\n    n = int(input().strip())\n    mod = 1000000007\n    \n    d_n = count_divisors(n)\n    result = factorial_mod(d_n, mod)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_jump_ability(s):\n    vowels = 'AEIOUY'\n    positions = []\n    \n    # Add the starting position (-1) and the end position (length of the string)\n    positions.append(-1)\n    \n    # Find positions of vowels in the string\n    for i, char in enumerate(s):\n        if char in vowels:\n            positions.append(i)\n    \n    # Add the end position\n    positions.append(len(s))\n    \n    # Calculate the maximum gap between consecutive positions\n    max_gap = max(positions[i + 1] - positions[i] for i in range(len(positions) - 1))\n    \n    return max_gap\n\n# Read input\ninput_string = input().strip()\n# Get the minimum jump ability\nresult = min_jump_ability(input_string)\n# Print the result\nprint(result)"}
{"solution": "from itertools import combinations\n\n# Read input\na1, a2, a3, a4 = map(int, input().split())\ncandies = [a1, a2, a3, a4]\n\n# Calculate total sum of candies\ntotal_sum = sum(candies)\n\n# If total sum is odd, it's impossible to split evenly\nif total_sum % 2 != 0:\n    print(\"NO\")\nelse:\n    target_sum = total_sum // 2\n    # Check all combinations of bags\n    for r in range(1, 5):  # r is the number of bags to choose\n        for combo in combinations(candies, r):\n            if sum(combo) == target_sum:\n                print(\"YES\")\n                exit()\n    print(\"NO\")"}
{"solution": "def optimal_pie_sharing(n, slices):\n    # Initialize scores for Alice and Bob\n    alice_score = 0\n    bob_score = 0\n    \n    # Bob starts with the decider token\n    is_bob_turn = True\n    \n    # Iterate through the slices\n    for i in range(n):\n        if is_bob_turn:\n            # Bob's turn to decide\n            # He will take the largest slice available\n            chosen_slice = max(slices)\n            bob_score += chosen_slice\n            slices.remove(chosen_slice)\n            # Pass the decider token to Alice\n            is_bob_turn = False\n        else:\n            # Alice's turn to decide\n            # She will take the largest slice available\n            chosen_slice = max(slices)\n            alice_score += chosen_slice\n            slices.remove(chosen_slice)\n            # Pass the decider token to Bob\n            is_bob_turn = True\n    \n    return alice_score, bob_score\n\n# Read input\nn = int(input())\nslices = list(map(int, input().split()))\n\n# Get the result\nalice, bob = optimal_pie_sharing(n, slices)\n\n# Print the output\nprint(alice, bob)"}
{"solution": "def can_form_sequence(a, m):\n    # Initialize variables\n    sums = set()\n    b = [0] * m\n    \n    # First operation\n    b[0] = a[0]\n    sums.add(b[0])\n    \n    for t in range(1, len(a)):\n        found = False\n        for i in range(m):\n            for j in range(m):\n                if i != j:\n                    new_sum = b[i] + b[j]\n                    if new_sum == a[t]:\n                        b[t] = new_sum\n                        sums.add(new_sum)\n                        found = True\n                        break\n            if found:\n                break\n        \n        if not found:\n            return False\n    \n    return True\n\ndef min_variables(n, a):\n    a.sort()\n    \n    for m in range(1, n + 1):\n        if can_form_sequence(a, m):\n            return m\n    \n    return -1\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_variables(n, a))"}
{"solution": "def determine_winner(n, piles):\n    # Count the number of non-empty piles\n    non_empty_piles = sum(1 for x in piles if x > 0)\n    \n    # If there are less than n/2 non-empty piles, Alice cannot make a move\n    if non_empty_piles < n // 2:\n        return \"Bob\"\n    \n    # Calculate the total number of stones\n    total_stones = sum(piles)\n    \n    # If the total number of stones is even, Bob can mirror Alice's moves\n    if total_stones % 2 == 0:\n        return \"Bob\"\n    \n    return \"Alice\"\n\n# Read input\nn = int(input())\npiles = list(map(int, input().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, piles))"}
{"solution": "def can_make_equal(n, arr):\n    unique_values = set(arr)\n    \n    if len(unique_values) == 1:\n        return \"YES\"\n    elif len(unique_values) == 2:\n        return \"YES\"\n    elif len(unique_values) == 3:\n        sorted_values = sorted(unique_values)\n        if sorted_values[1] - sorted_values[0] == sorted_values[2] - sorted_values[1]:\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        return \"NO\"\n\n# Input reading\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output the result\nprint(can_make_equal(n, arr))"}
{"solution": "def build_suffix_array(s):\n    n = len(s)\n    suffixes = sorted((s[i:], i) for i in range(n))\n    suffix_array = [suffix[1] for suffix in suffixes]\n    return suffix_array\n\ndef build_lcp(s, suffix_array):\n    n = len(s)\n    rank = [0] * n\n    lcp = [0] * n\n    \n    for i, suffix_index in enumerate(suffix_array):\n        rank[suffix_index] = i\n    \n    h = 0\n    for i in range(n):\n        if rank[i] > 0:\n            j = suffix_array[rank[i] - 1]\n            while (i + h < n) and (j + h < n) and (s[i + h] == s[j + h]):\n                h += 1\n            lcp[rank[i]] = h\n            if h > 0:\n                h -= 1\n    return lcp\n\ndef max_non_overlapping_length(s):\n    n = len(s)\n    if n < 2:\n        return 0\n    \n    suffix_array = build_suffix_array(s)\n    lcp = build_lcp(s, suffix_array)\n    \n    max_length = 0\n    for i in range(1, n):\n        len_lcp = lcp[i]\n        if len_lcp > 0:\n            # Check for non-overlapping condition\n            if suffix_array[i] >= suffix_array[i - 1] + len_lcp:\n                max_length = max(max_length, len_lcp)\n    \n    return max_length\n\n# Input reading\nN = int(input().strip())\nS = input().strip()\n\n# Output the result\nprint(max_non_overlapping_length(S))"}
{"solution": "def minimum_time(n, a):\n    if a % 2 == 1:  # a is odd\n        return (a + 1) // 2\n    else:  # a is even\n        return (n - a) // 2 + 1\n\nn, a = map(int, input().split())\nprint(minimum_time(n, a))"}
{"solution": "def can_select_jedi(n, m, colors, desired_counts):\n    # Create a list to store the current counts of each color in the sliding window\n    current_counts = [0] * (m + 1)\n    \n    # Initialize the left pointer of the sliding window\n    left = 0\n    \n    # Iterate over the right pointer of the sliding window\n    for right in range(n):\n        # Increment the count of the current color\n        current_counts[colors[right]] += 1\n        \n        # Check if the current window matches the desired counts\n        while True:\n            # Check if the current counts match the desired counts\n            if all(current_counts[i] >= desired_counts[i - 1] for i in range(1, m + 1)):\n                # If they match, we can check if we can reduce the window size\n                # to see if we can still satisfy the condition\n                if all(current_counts[i] == desired_counts[i - 1] for i in range(1, m + 1)):\n                    return \"YES\"\n                # Move the left pointer to reduce the window size\n                current_counts[colors[left]] -= 1\n                left += 1\n            else:\n                break\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\ndesired_counts = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_select_jedi(n, m, colors, desired_counts)\nprint(result)"}
{"solution": "n = int(input())\nmishka_wins = 0\nchris_wins = 0\n\nfor _ in range(n):\n    m, c = map(int, input().split())\n    if m > c:\n        mishka_wins += 1\n    elif c > m:\n        chris_wins += 1\n\nif mishka_wins > chris_wins:\n    print(\"Mishka\")\nelif chris_wins > mishka_wins:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")"}
{"solution": "def is_valid_minesweeper_field(n, m, field):\n    # Directions for the 8 neighboring cells\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),          (0, 1),\n                  (1, -1), (1, 0), (1, 1)]\n    \n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                continue\n            \n            # Count bombs around the current cell\n            bomb_count = 0\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':\n                    bomb_count += 1\n            \n            # Check the validity of the current cell\n            if field[i][j] == '.':\n                if bomb_count != 0:\n                    return \"NO\"\n            elif field[i][j].isdigit():\n                if bomb_count != int(field[i][j]):\n                    return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Validate the Minesweeper field\nresult = is_valid_minesweeper_field(n, m, field)\nprint(result)"}
{"solution": "def can_vasya_eat_half(n, k):\n    total_vasya = 0\n    remaining_candies = n\n    \n    while remaining_candies > 0:\n        # Vasya eats k candies or all remaining if less than k\n        vasya_eats = min(k, remaining_candies)\n        total_vasya += vasya_eats\n        remaining_candies -= vasya_eats\n        \n        # Petya eats 10% of the remaining candies\n        petya_eats = remaining_candies // 10\n        remaining_candies -= petya_eats\n    \n    return total_vasya >= (n + 1) // 2  # At least half of n\n\ndef find_min_k(n):\n    left, right = 1, n\n    answer = n\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            answer = mid\n            right = mid - 1  # Try to find a smaller k\n        else:\n            left = mid + 1  # Increase k\n    \n    return answer\n\n# Input\nn = int(input())\n# Output the result\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace(s):\n    p = s.count('o')  # Count pearls\n    l = s.count('-')  # Count links\n    \n    if p == 0 or p == 1:\n        return \"YES\"\n    \n    if l % p == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\ns = input().strip()\n# Output the result\nprint(can_rearrange_necklace(s))"}
{"solution": "def can_distribute_pillows(n, m, k, x):\n    # Calculate pillows needed for left side\n    left_hobbits = k - 1\n    left_pillows = 0\n    if left_hobbits > 0:\n        # Maximum pillows for left side\n        left_pillows = min(left_hobbits * (x - 1), (left_hobbits * (left_hobbits + 1)) // 2)\n    \n    # Calculate pillows needed for right side\n    right_hobbits = n - k\n    right_pillows = 0\n    if right_hobbits > 0:\n        # Maximum pillows for right side\n        right_pillows = min(right_hobbits * (x - 1), (right_hobbits * (right_hobbits + 1)) // 2)\n    \n    # Total pillows needed\n    total_pillows = left_pillows + right_pillows + x\n    return total_pillows <= m\n\ndef max_pillows(n, m, k):\n    low, high = 1, m\n    answer = 0\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if can_distribute_pillows(n, m, k, mid):\n            answer = mid  # mid is a valid solution\n            low = mid + 1  # try for more pillows\n        else:\n            high = mid - 1  # try for fewer pillows\n    \n    return answer\n\n# Read input\nn, m, k = map(int, input().split())\n# Print the result\nprint(max_pillows(n, m, k))"}
{"solution": "def max_cost_subarray(n, m, k, a):\n    # Step 1: Calculate prefix sums\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + a[i - 1]\n\n    max_cost = 0  # Start with the cost of the empty subarray\n\n    # Step 2: Iterate over all possible starting points\n    for l in range(n):\n        for r in range(l, n):\n            # Calculate the sum of the subarray a[l] to a[r]\n            subarray_sum = prefix_sum[r + 1] - prefix_sum[l]\n            length = r - l + 1\n            penalty = k * ((length + m - 1) // m)  # This is equivalent to k * ceil(length / m)\n            cost = subarray_sum - penalty\n            \n            # Update max_cost if we found a new maximum\n            max_cost = max(max_cost, cost)\n\n    return max_cost\n\n# Read input\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate and print the maximum cost\nprint(max_cost_subarray(n, m, k, a))"}
{"solution": "def longest_polyline(n, m):\n    # Choosing the four corners of the rectangle\n    points = [\n        (0, 0),   # Bottom-left corner\n        (0, m),   # Top-left corner\n        (n, 0),   # Bottom-right corner\n        (n, m)    # Top-right corner\n    ]\n    \n    # Print the points in the required order\n    for point in points:\n        print(point[0], point[1])\n\n# Read input\nn, m = map(int, input().split())\nlongest_polyline(n, m)"}
{"solution": "def smallest_integer(n_str, remembered_substring):\n    from collections import Counter\n\n    # Count the digits in the received string\n    digit_count = Counter(n_str)\n    \n    # Count the digits in the remembered substring\n    remembered_count = Counter(remembered_substring)\n    \n    # Subtract the remembered substring's digits from the total count\n    for digit in remembered_count:\n        digit_count[digit] -= remembered_count[digit]\n    \n    # Prepare the result\n    result = []\n    \n    # Add the remembered substring first\n    result.append(remembered_substring)\n    \n    # Create a list of remaining digits sorted\n    remaining_digits = []\n    for digit in sorted(digit_count.keys()):\n        remaining_digits.extend([digit] * digit_count[digit])\n    \n    # We need to ensure that the result does not start with '0' unless it's the only digit\n    if result[0][0] == '0':\n        # If the remembered substring starts with '0', we need to find the first non-zero digit\n        for i in range(len(remaining_digits)):\n            if remaining_digits[i] != '0':\n                # Place the first non-zero digit at the start\n                result.insert(0, remaining_digits[i])\n                remaining_digits.pop(i)\n                break\n    \n    # Append the remaining digits to the result\n    result.append(''.join(remaining_digits))\n    \n    # Join the result and print\n    final_number = ''.join(result)\n    print(final_number)\n\n# Read input\nn_str = input().strip()\nremembered_substring = input().strip()\n\n# Call the function\nsmallest_integer(n_str, remembered_substring)"}
{"solution": "def can_adjust_temperatures(n, m, min_temp, max_temp, recorded_temperatures):\n    # Check if the required min and max temperatures are already in the recorded temperatures\n    has_min = min_temp in recorded_temperatures\n    has_max = max_temp in recorded_temperatures\n    \n    # Calculate how many temperatures we need to add\n    temperatures_to_add = n - m\n    \n    # Determine if we can achieve the required min and max\n    if has_min and has_max:\n        return \"Correct\"\n    elif not has_min and not has_max:\n        # We need to add both min and max\n        return \"Correct\" if temperatures_to_add >= 2 else \"Incorrect\"\n    elif not has_min or not has_max:\n        # We need to add either min or max\n        return \"Correct\" if temperatures_to_add >= 1 else \"Incorrect\"\n    \n    return \"Incorrect\"\n\n# Read input\nn, m, min_temp, max_temp = map(int, input().split())\nrecorded_temperatures = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_adjust_temperatures(n, m, min_temp, max_temp, recorded_temperatures)\nprint(result)"}
{"solution": "def trailing_zeroes(n):\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count\n\ndef find_n_with_trailing_zeroes(m):\n    low, high = 0, 5 * (m + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if trailing_zeroes(mid) < m:\n            low = mid + 1\n        else:\n            high = mid\n    lower_bound = low\n\n    high = 5 * (m + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if trailing_zeroes(mid) <= m:\n            low = mid + 1\n        else:\n            high = mid\n    upper_bound = low\n\n    count = upper_bound - lower_bound\n    return count, list(range(lower_bound, upper_bound))\n\nm = int(input().strip())\ncount, n_values = find_n_with_trailing_zeroes(m)\nprint(count)\nif count > 0:\n    print(\" \".join(map(str, n_values)))"}
{"solution": "def find_max_distance(n, m, k, special_vertices, edges):\n    from collections import defaultdict\n    import heapq\n\n    # Create a graph representation\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    def dijkstra(start):\n        # Distance array initialized to infinity\n        distances = {i: float('inf') for i in range(1, n + 1)}\n        distances[start] = 0\n        priority_queue = [(0, start)]  # (distance, vertex)\n\n        while priority_queue:\n            current_distance, current_vertex = heapq.heappop(priority_queue)\n\n            if current_distance > distances[current_vertex]:\n                continue\n\n            for neighbor, weight in graph[current_vertex]:\n                distance = max(current_distance, weight)\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n\n        return distances\n\n    # Store the maximum distances for each special vertex\n    result = []\n    for vertex in special_vertices:\n        distances = dijkstra(vertex)\n        max_distance = 0\n        for special in special_vertices:\n            if special != vertex:\n                max_distance = max(max_distance, distances[special])\n        result.append(max_distance)\n\n    return result\n\n# Input reading\nn, m, k = map(int, input().split())\nspecial_vertices = list(map(int, input().split()))\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the result\nresult = find_max_distance(n, m, k, special_vertices, edges)\n\n# Print the result\nprint(' '.join(map(str, result)))"}
{"solution": "def find_initial_position(n, x):\n    # Calculate effective moves\n    effective_moves = n % 6\n    \n    # Reverse the movements\n    position = x\n    \n    for move in range(effective_moves):\n        if move % 2 == 0:  # Reverse of odd move\n            if position == 0:\n                position = 1\n            elif position == 1:\n                position = 0\n            # If position is 2, it remains 2\n        else:  # Reverse of even move\n            if position == 1:\n                position = 2\n            elif position == 2:\n                position = 1\n            # If position is 0, it remains 0\n    \n    return position\n\n# Input reading\nn = int(input())\nx = int(input())\n\n# Output the initial position\nprint(find_initial_position(n, x))"}
{"solution": "def rectangles_form_square(n, rectangles):\n    min_x = float('inf')\n    min_y = float('inf')\n    max_x = float('-inf')\n    max_y = float('-inf')\n    total_area = 0\n\n    for rect in rectangles:\n        x1, y1, x2, y2 = rect\n        min_x = min(min_x, x1)\n        min_y = min(min_y, y1)\n        max_x = max(max_x, x2)\n        max_y = max(max_y, y2)\n        total_area += (x2 - x1) * (y2 - y1)\n\n    # Calculate the dimensions of the bounding box\n    width = max_x - min_x\n    height = max_y - min_y\n\n    # Check if the bounding box is a square and if the area matches\n    if width == height and total_area == width * height:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Input reading\nn = int(input())\nrectangles = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(rectangles_form_square(n, rectangles))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(d) for d in str(x))\n\ndef count_really_big_numbers(n, s):\n    count = 0\n    # Start checking from the maximum of 1 and s + 162\n    for x in range(max(1, s + 162), n + 1):\n        if x - sum_of_digits(x) >= s:\n            count += 1\n    return count\n\n# Read input\nn, s = map(int, input().split())\n# Print the result\nprint(count_really_big_numbers(n, s))"}
{"solution": "def can_cover_with_two_lines(points):\n    def check_line(p1, p2, remaining_points):\n        line_points = set()\n        for p in remaining_points:\n            if (p2[0] - p1[0]) * (p[1] - p1[1]) == (p[0] - p1[0]) * (p2[1] - p1[1]):\n                line_points.add(p)\n        return line_points\n\n    n = len(points)\n    if n <= 2:\n        return True\n\n    # Try to use the first two points to define the first line\n    for i in range(2):\n        p1 = points[0]\n        p2 = points[i + 1]\n        \n        # Find points on the first line\n        line1_points = check_line(p1, p2, points)\n        \n        # Remaining points that are not on the first line\n        remaining_points = [p for p in points if p not in line1_points]\n        \n        if not remaining_points:\n            return True\n        \n        # Check if the remaining points can be covered by a second line\n        if len(remaining_points) <= 2:\n            return True\n        \n        # Use the first two remaining points to define the second line\n        p3 = remaining_points[0]\n        p4 = remaining_points[1]\n        \n        line2_points = check_line(p3, p4, remaining_points)\n        \n        if len(line2_points) == len(remaining_points):\n            return True\n\n    return False\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    points = [tuple(map(int, line.split())) for line in data[1:n + 1]]\n    \n    if can_cover_with_two_lines(points):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_winning_games(a, b, k, t):\n    MOD = 10**9 + 7\n    max_score = a + t * k + 1  # Maximum possible score after t turns\n    dp = [[[0] * (max_score) for _ in range(max_score)] for _ in range(t + 1)]\n    \n    dp[0][a][b] = 1  # Base case\n    \n    for turn in range(t):\n        for m_score in range(max_score):\n            for l_score in range(max_score):\n                if dp[turn][m_score][l_score] > 0:\n                    for m_move in range(-k, k + 1):\n                        for l_move in range(-k, k + 1):\n                            new_m_score = m_score + m_move\n                            new_l_score = l_score + l_move\n                            if 0 <= new_m_score < max_score and 0 <= new_l_score < max_score:\n                                dp[turn + 1][new_m_score][new_l_score] += dp[turn][m_score][l_score]\n                                dp[turn + 1][new_m_score][new_l_score] %= MOD\n    \n    result = 0\n    for m_score in range(max_score):\n        for l_score in range(m_score):\n            result += dp[t][m_score][l_score]\n            result %= MOD\n    \n    return result\n\n# Read input\na, b, k, t = map(int, input().split())\n# Print the result\nprint(count_winning_games(a, b, k, t))"}
{"solution": "def min_marks_needed(n, l, x, y, marks):\n    # Create a set to store all measurable distances\n    measurable_distances = set()\n    \n    # Calculate all measurable distances\n    for i in range(n):\n        for j in range(i + 1, n):\n            measurable_distances.add(marks[j] - marks[i])\n    \n    # Check if x and y are measurable\n    can_measure_x = x in measurable_distances\n    can_measure_y = y in measurable_distances\n    \n    # Determine the number of additional marks needed\n    additional_marks = []\n    \n    if not can_measure_x:\n        additional_marks.append(x)\n    if not can_measure_y:\n        additional_marks.append(y)\n    \n    # If both are not measurable, we need to add both\n    if not can_measure_x and not can_measure_y:\n        # We can add both marks directly\n        additional_marks = [x, y]\n    \n    # Output the results\n    print(len(additional_marks))\n    if additional_marks:\n        print(\" \".join(map(str, additional_marks)))\n\n# Read input\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Call the function\nmin_marks_needed(n, l, x, y, marks)"}
{"solution": "import sys\nimport math\n\ndef calculate_volume(r, h):\n    return math.pi * r * r * h\n\ndef max_cake_volume(n, cakes):\n    # Calculate volumes and sort by volume\n    volumes = [calculate_volume(r, h) for r, h in cakes]\n    sorted_volumes = sorted(volumes)\n\n    # Dynamic programming array to store maximum volume up to each cake\n    dp = [0] * n\n\n    for i in range(n):\n        dp[i] = sorted_volumes[i]  # Start with the volume of the cake itself\n        for j in range(i):\n            if sorted_volumes[i] > sorted_volumes[j]:\n                dp[i] = max(dp[i], dp[j] + sorted_volumes[i])\n\n    return max(dp)\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    cakes = [tuple(map(int, line.split())) for line in data[1:n+1]]\n    \n    result = max_cake_volume(n, cakes)\n    print(f\"{result:.9f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_good_slices(n, k, heights):\n    # Step 1: Get unique heights and sort them\n    unique_heights = sorted(set(heights))\n    \n    # Step 2: Initialize variables\n    good_slices_count = 0\n    \n    # Step 3: Iterate through unique heights\n    for h in unique_heights:\n        # Calculate the cost to slice to height h\n        current_cost = sum(max(0, height - h) for height in heights)\n        \n        # Check if the current cost is a good slice\n        if current_cost <= k:\n            good_slices_count += 1\n    \n    return good_slices_count\n\n# Input reading\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Output the result\nprint(min_good_slices(n, k, heights))"}
{"solution": "def max_score(n, a):\n    max_score = 0  # Initialize the maximum score\n    for l in range(n):\n        total_sum = 0\n        max_card = float('-inf')\n        for r in range(l, n):\n            total_sum += a[r]\n            max_card = max(max_card, a[r])\n            # Calculate the score for the current segment [l, r]\n            score = total_sum - max_card\n            max_score = max(max_score, score)\n    return max_score\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nprint(max_score(n, a))"}
{"solution": "import math\nfrom functools import reduce\n\n# Function to calculate GCD of multiple numbers\ndef gcd_multiple(numbers):\n    return reduce(math.gcd, numbers)\n\n# Read input\nk1, k2, k3 = map(int, input().split())\n\n# Calculate GCD of the three intervals\ngcd_value = gcd_multiple([k1, k2, k3])\n\n# Determine if it's possible to cover all seconds\nif gcd_value == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_operations_to_delete_string(n, s):\n    # Initialize the DP table\n    dp = [[float('inf')] * n for _ in range(n)]\n    \n    # Base case: single character substrings\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the DP table\n    for length in range(2, n + 1):  # length of the substring\n        for i in range(n - length + 1):\n            j = i + length - 1  # end index of the substring\n            # Remove the last character\n            dp[i][j] = dp[i][j - 1] + 1\n            \n            # Check for combining with previous characters\n            for k in range(i, j):\n                if s[k] == s[j]:\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j - 1])\n    \n    return dp[0][n - 1]\n\n# Read input\nn = int(input())\ns = input().strip()\n# Output the result\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "def max_pairs(boys, girls):\n    boys.sort()\n    girls.sort()\n    \n    i, j = 0, 0\n    pairs = 0\n    \n    while i < len(boys) and j < len(girls):\n        if abs(boys[i] - girls[j]) <= 1:\n            pairs += 1\n            i += 1\n            j += 1\n        elif boys[i] < girls[j] - 1:\n            i += 1\n        else:\n            j += 1\n            \n    return pairs\n\n# Input reading\nn = int(input())\nboys = list(map(int, input().split()))\nm = int(input())\ngirls = list(map(int, input().split()))\n\n# Calculate and print the maximum number of pairs\nprint(max_pairs(boys, girls))"}
{"solution": "def can_team_win(a1, b1, a2, b2):\n    # Check if team 1 can win\n    if a1 > b2 and b1 > a2:\n        return \"Team 1\"\n    # Check if team 2 can win\n    if a2 > b1 and b2 > a1:\n        return \"Team 2\"\n    return \"Draw\"\n\n# Read input\nplayers = [tuple(map(int, input().split())) for _ in range(4)]\na1, b1 = players[0]  # Team 1 Player 1\na2, b2 = players[1]  # Team 1 Player 2\na3, b3 = players[2]  # Team 2 Player 1\na4, b4 = players[3]  # Team 2 Player 2\n\n# Check all combinations for team 1\nresult = can_team_win(a1, b1, a3, b4)  # Team 1 Player 1 as attacker, Player 2 as defender\nif result == \"Draw\":\n    result = can_team_win(a2, b2, a3, b4)  # Team 1 Player 2 as attacker, Player 1 as defender\n\n# Check all combinations for team 2\nif result == \"Draw\":\n    result = can_team_win(a1, b1, a4, b3)  # Team 1 Player 1 as attacker, Player 2 as defender\nif result == \"Draw\":\n    result = can_team_win(a2, b2, a4, b3)  # Team 1 Player 2 as attacker, Player 1 as defender\n\nprint(result)"}
{"solution": "import sys\nimport math\nfrom scipy.optimize import minimize\n\ndef time_to_grill(XY, meats):\n    X, Y = XY\n    times = []\n    for (x_i, y_i, c_i) in meats:\n        time = c_i * math.sqrt((X - x_i) ** 2 + (Y - y_i) ** 2)\n        times.append(time)\n    times.sort()\n    return times[K - 1]  # We want the K-th smallest time\n\ndef find_optimal_heat_source(meats):\n    # Initial guess for the heat source position\n    initial_guess = (0, 0)\n    \n    # Minimize the time to grill K pieces of meat\n    result = minimize(time_to_grill, initial_guess, args=(meats,), method='Nelder-Mead')\n    \n    return result.fun\n\n# Read input\ninput_data = sys.stdin.read().strip().splitlines()\nN, K = map(int, input_data[0].split())\nmeats = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n# Find the optimal time\noptimal_time = find_optimal_heat_source(meats)\n\n# Print the result with the required precision\nprint(f\"{optimal_time:.10f}\")"}
{"solution": "def determine_winner(n, ticket):\n    sum1 = 0\n    sum2 = 0\n    q1 = 0\n    q2 = 0\n    \n    for i in range(n):\n        if i < n // 2:\n            if ticket[i] == '?':\n                q1 += 1\n            else:\n                sum1 += int(ticket[i])\n        else:\n            if ticket[i] == '?':\n                q2 += 1\n            else:\n                sum2 += int(ticket[i])\n    \n    diff = sum1 - sum2\n    \n    # Calculate the maximum possible adjustments\n    max_adjustment1 = 9 * q1\n    max_adjustment2 = 9 * q2\n    \n    # Check if Monocarp can ensure a win\n    if diff > max_adjustment2:\n        return \"Monocarp\"\n    elif diff < -max_adjustment1:\n        return \"Bicarp\"\n    else:\n        return \"Bicarp\"  # Bicarp can always adjust to make it happy\n\n# Read input\nn = int(input().strip())\nticket = input().strip()\n\n# Determine and print the winner\nprint(determine_winner(n, ticket))"}
{"solution": "import math\n\n# Read input values\nn, t = map(int, input().split())\nbuses = []\n\n# Read each bus route's first arrival time and interval\nfor i in range(n):\n    s_i, d_i = map(int, input().split())\n    buses.append((s_i, d_i))\n\n# Initialize variables to track the earliest bus time and its index\nearliest_time = float('inf')\nearliest_index = -1\n\n# Iterate through each bus route\nfor index, (s_i, d_i) in enumerate(buses):\n    if s_i >= t:\n        # If the first bus arrives after or at time t, it's a candidate\n        next_bus_time = s_i\n    else:\n        # Calculate the next bus time after t\n        k = math.ceil((t - s_i) / d_i)\n        next_bus_time = s_i + k * d_i\n\n    # Check if this bus is the earliest one found so far\n    if next_bus_time < earliest_time:\n        earliest_time = next_bus_time\n        earliest_index = index + 1  # +1 for 1-based index\n\n# Print the index of the bus route Serval will take\nprint(earliest_index)"}
{"solution": "def count_numbers_with_k_ones(n, k):\n    count = 0\n    for num in range(n + 1, 2 * n + 1):\n        if bin(num).count('1') == k:\n            count += 1\n    return count\n\ndef find_n(m, k):\n    n = 1\n    while n <= 10**18:\n        if count_numbers_with_k_ones(n, k) == m:\n            return n\n        n += 1\n    return -1  # In case no valid n is found, though the problem guarantees a solution.\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    m, k = map(int, input().strip().split())\n    result = find_n(m, k)\n    print(result)"}
{"solution": "def is_good_level(n, level):\n    # Extract indices of platforms\n    platforms = [i for i in range(n) if level[i] == '*']\n    \n    # Check for sequences of 5 platforms\n    num_platforms = len(platforms)\n    \n    for i in range(num_platforms):\n        for j in range(i + 1, num_platforms):\n            d = platforms[j] - platforms[i]  # Calculate the jump distance\n            # Check if we can find 5 platforms with this distance\n            count = 2  # We already have platforms[i] and platforms[j]\n            next_pos = platforms[j] + d\n            \n            while next_pos < n and next_pos in platforms:\n                count += 1\n                if count == 5:\n                    return \"yes\"\n                next_pos += d\n    \n    return \"no\"\n\n# Input reading\nn = int(input().strip())\nlevel = input().strip()\n\n# Output the result\nprint(is_good_level(n, level))"}
{"solution": "def find_magic_number(n, grid):\n    empty_row, empty_col = -1, -1\n    target_sum = 0\n    \n    # Locate the empty cell and calculate the target magic sum\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                empty_row, empty_col = i, j\n            else:\n                if i == 0:  # Use the first row to determine the target sum\n                    target_sum += grid[i][j]\n\n    # Calculate the sum of the row and column containing the empty cell\n    row_sum = sum(grid[empty_row])\n    col_sum = sum(grid[i][empty_col] for i in range(n))\n\n    # Calculate the required value to fill in the empty cell\n    required_value = target_sum - row_sum\n\n    # Check if the required value is positive\n    if required_value <= 0:\n        return -1\n\n    # Check if filling the required value maintains the magic square property\n    grid[empty_row][empty_col] = required_value\n\n    # Check the sums of the row, column, and diagonals\n    if (sum(grid[empty_row]) != target_sum or\n        sum(grid[i][empty_col] for i in range(n)) != target_sum):\n        return -1\n\n    # Check the main diagonal if the empty cell is on it\n    if empty_row == empty_col:\n        if sum(grid[i][i] for i in range(n)) != target_sum:\n            return -1\n\n    # Check the secondary diagonal if the empty cell is on it\n    if empty_row + empty_col == n - 1:\n        if sum(grid[i][n - 1 - i] for i in range(n)) != target_sum:\n            return -1\n\n    return required_value\n\n# Read input\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\n# Find the magic number and print the result\nresult = find_magic_number(n, grid)\nprint(result)"}
{"solution": "def min_max_bench_capacity(n, m, a):\n    max_a = max(a)\n    \n    # Calculate maximum k\n    max_k = max_a + m\n    \n    # Binary search for minimum k\n    low, high = max_a, max_k\n    \n    while low < high:\n        mid = (low + high) // 2\n        total_addable = sum(max(0, mid - ai) for ai in a)\n        \n        if total_addable >= m:\n            high = mid  # mid is a valid candidate\n        else:\n            low = mid + 1  # mid is too small\n    \n    min_k = low  # This is the minimum k found\n    \n    return min_k, max_k\n\n# Read input\nn = int(input())\nm = int(input())\na = [int(input()) for _ in range(n)]\n\nmin_k, max_k = min_max_bench_capacity(n, m, a)\nprint(min_k, max_k)"}
{"solution": "def count_boarding_ways(n, m):\n    MOD = 10**9 + 7\n    \n    # Calculate the total number of ways to assign seats and choose entrances\n    # Each passenger can choose either F or B, so there are 2^m choices for entrances\n    # For each of the m passengers, they can be assigned to any of the n seats\n    total_ways = pow(n, m, MOD) * pow(2, m, MOD) % MOD\n    \n    # The result is the total ways modulo 10^9 + 7\n    return total_ways\n\n# Read input\nn, m = map(int, input().split())\n# Calculate and print the result\nprint(count_boarding_ways(n, m))"}
{"solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m = map(int, data[0].split())\n    \n    # Read friends' favorite ingredients\n    friends_masks = []\n    for i in range(1, n + 1):\n        line = list(map(int, data[i].split()))\n        f_i = line[0]\n        ingredients = line[1:f_i + 1]\n        mask = 0\n        for ing in ingredients:\n            mask |= (1 << (ing - 1))  # Set the bit for the ingredient\n        friends_masks.append(mask)\n    \n    # Read pizzas\n    pizzas = []\n    for j in range(n + 1, n + m + 1):\n        line = list(map(int, data[j].split()))\n        price = line[0]\n        r_j = line[1]\n        ingredients = line[2:r_j + 2]\n        mask = 0\n        for ing in ingredients:\n            mask |= (1 << (ing - 1))  # Set the bit for the ingredient\n        pizzas.append((mask, price, j - (n + 1) + 1))  # Store mask, price, and index\n\n    # Initialize variables to track the best result\n    max_satisfied = 0\n    min_cost = float('inf')\n    best_pair = (0, 0)\n\n    # Check all pairs of pizzas\n    for i in range(m):\n        for j in range(i + 1, m):\n            combined_mask = pizzas[i][0] | pizzas[j][0]\n            satisfied_count = sum(1 for friend_mask in friends_masks if (friend_mask & combined_mask) == friend_mask)\n            \n            total_cost = pizzas[i][1] + pizzas[j][1]\n            \n            if (satisfied_count > max_satisfied) or (satisfied_count == max_satisfied and total_cost < min_cost):\n                max_satisfied = satisfied_count\n                min_cost = total_cost\n                best_pair = (pizzas[i][2], pizzas[j][2])  # Store the indices of the pizzas\n\n    # Output the best pair of pizza indices\n    print(best_pair[0], best_pair[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_min_max_numbers(m, s):\n    if (s == 0 and m > 1) or (s > 9 * m):\n        return \"-1 -1\"\n    \n    # Finding the smallest number\n    min_number = [0] * m\n    sum_remaining = s\n    \n    for i in range(m):\n        if i == 0:\n            # First digit must be at least 1\n            min_number[i] = 1\n            sum_remaining -= 1\n        \n        # Fill the current digit with the minimum possible value\n        if sum_remaining > 0:\n            add = min(9 - min_number[i], sum_remaining)\n            min_number[i] += add\n            sum_remaining -= add\n    \n    # Finding the largest number\n    max_number = [0] * m\n    sum_remaining = s\n    \n    for i in range(m):\n        # Fill the current digit with the maximum possible value\n        if sum_remaining > 0:\n            add = min(9, sum_remaining)\n            max_number[i] = add\n            sum_remaining -= add\n    \n    return ''.join(map(str, min_number)), ''.join(map(str, max_number))\n\n# Read input\nm, s = map(int, input().split())\nmin_num, max_num = find_min_max_numbers(m, s)\nprint(min_num, max_num)"}
{"solution": "def sum_with_k_digits(l, r, k):\n    MOD = 998244353\n    total_sum = 0\n    \n    def generate_numbers(current_number, used_digits):\n        nonlocal total_sum\n        if current_number > r:\n            return\n        if current_number >= l:\n            total_sum = (total_sum + current_number) % MOD\n        \n        for digit in range(10):\n            if digit not in used_digits:\n                if len(used_digits) < k:\n                    new_used_digits = used_digits | {digit}\n                    new_number = current_number * 10 + digit\n                    generate_numbers(new_number, new_used_digits)\n            else:\n                new_number = current_number * 10 + digit\n                generate_numbers(new_number, used_digits)\n    \n    # Start generating numbers from an empty state\n    generate_numbers(0, set())\n    \n    return total_sum\n\n# Read input\nl, r, k = map(int, input().split())\n# Calculate and print the result\nprint(sum_with_k_digits(l, r, k))"}
{"solution": "def can_distribute_pencils(n, k, d, saturations):\n    # Sort the saturation values\n    saturations.sort()\n    \n    # Initialize variables\n    count = 0\n    boxes = 0\n    \n    # Iterate through the sorted saturation values\n    for i in range(n):\n        count += 1  # Count the current pencil\n        \n        # Check if we can form a box with the current pencil\n        if i == n - 1 or saturations[i + 1] - saturations[i] > d:\n            # If the count of pencils in the current box is at least k\n            if count >= k:\n                boxes += 1  # We can form a box\n            count = 0  # Reset count for the next box\n    \n    # If we have formed at least one box, return \"YES\"\n    return \"YES\" if boxes > 0 else \"NO\"\n\n# Read input\nn, k, d = map(int, input().split())\nsaturations = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_distribute_pencils(n, k, d, saturations)\nprint(result)"}
{"solution": "def count_dead_bulbs(s):\n    # Initialize counts for each color\n    count = {'R': 0, 'B': 0, 'Y': 0, 'G': 0}\n    \n    # Define the color pattern\n    color_pattern = ['R', 'B', 'Y', 'G']\n    \n    # Iterate through the string\n    for i in range(len(s)):\n        if s[i] == '!':\n            # Determine the color based on the position\n            color = color_pattern[i % 4]\n            count[color] += 1\n    \n    # Output the counts in the order of R, B, Y, G\n    print(count['R'], count['B'], count['Y'], count['G'])\n\n# Read input\ns = input().strip()\ncount_dead_bulbs(s)"}
{"solution": "def calculate_expected_passages(N, M, passages):\n    from collections import defaultdict\n    \n    # Create adjacency list\n    graph = defaultdict(list)\n    for s, t in passages:\n        graph[s].append(t)\n    \n    # Initialize expected values\n    E = [0] * (N + 1)\n    E[N] = 0  # No passages needed from Room N\n    \n    # Calculate expected values from N-1 to 1\n    for i in range(N-1, 0, -1):\n        if i in graph:\n            k = len(graph[i])\n            E[i] = 1 + sum(E[j] for j in graph[i]) / k\n    \n    # Now consider blocking each passage from Room 1\n    min_expected = float('inf')\n    \n    for t in graph[1]:  # For each passage from Room 1\n        # Temporarily block the passage from 1 to t\n        original_graph = graph[1][:]\n        graph[1].remove(t)\n        \n        # Recalculate E[1]\n        k = len(graph[1])\n        if k > 0:\n            E[1] = 1 + sum(E[j] for j in graph[1]) / k\n        else:\n            E[1] = float('inf')  # If no passages left, this shouldn't happen\n        \n        # Update minimum expected value\n        min_expected = min(min_expected, E[1])\n        \n        # Restore the passage\n        graph[1] = original_graph\n    \n    return min_expected\n\n# Read input and call the function\nN, M = map(int, input().split())\npassages = [tuple(map(int, input().split())) for _ in range(M)]\nresult = calculate_expected_passages(N, M, passages)\nprint(f\"{result:.10f}\")"}
{"solution": "n = int(input().strip())\n\nif n % 10 == 0:\n    print(n)\nelse:\n    lower_multiple = n - (n % 10)\n    upper_multiple = lower_multiple + 10\n    \n    if n % 10 < 5:\n        print(lower_multiple)\n    else:\n        print(upper_multiple)"}
{"solution": "def find_swaps(s, t):\n    if len(s) != len(t):\n        return -1\n    \n    mapping = {}\n    reverse_mapping = {}\n    pairs = set()\n    \n    for char_s, char_t in zip(s, t):\n        if char_s != char_t:\n            if char_s in mapping:\n                if mapping[char_s] != char_t:\n                    return -1\n            else:\n                mapping[char_s] = char_t\n            \n            if char_t in reverse_mapping:\n                if reverse_mapping[char_t] != char_s:\n                    return -1\n            else:\n                reverse_mapping[char_t] = char_s\n            \n            # Add the pair to the set\n            pairs.add(tuple(sorted((char_s, char_t))))\n    \n    # Prepare the output\n    result_pairs = list(pairs)\n    k = len(result_pairs)\n    \n    output = [str(k)]\n    for a, b in result_pairs:\n        output.append(f\"{a} {b}\")\n    \n    return \"\\n\".join(output)\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Get the result and print it\nresult = find_swaps(s, t)\nprint(result)"}
{"solution": "def earliest_login(first_name, last_name):\n    earliest = None\n    \n    # Generate all non-empty prefixes of first_name\n    for i in range(1, len(first_name) + 1):\n        first_prefix = first_name[:i]\n        \n        # Generate all non-empty prefixes of last_name\n        for j in range(1, len(last_name) + 1):\n            last_prefix = last_name[:j]\n            \n            # Combine prefixes\n            login = first_prefix + last_prefix\n            \n            # Update earliest if it's the first or is alphabetically earlier\n            if earliest is None or login < earliest:\n                earliest = login\n                \n    return earliest\n\n# Read input\ninput_data = input().strip()\nfirst_name, last_name = input_data.split()\n\n# Get the earliest login and print it\nprint(earliest_login(first_name, last_name))"}
{"solution": "def draw_bracket_sequence(n, sequence):\n    # Calculate the maximum depth of the brackets\n    depth = 0\n    max_depth = 0\n    for char in sequence:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        else:\n            depth -= 1\n\n    # Prepare the output structure\n    height = max_depth * 2 + 1\n    width = 0\n    for char in sequence:\n        if char == '[':\n            width += 3  # \"+-\" for opening bracket\n        else:\n            width += 3  # \"+-\" for closing bracket\n        width += 1  # space between brackets\n\n    # Create a grid for the output\n    output = [[' ' for _ in range(width)] for _ in range(height)]\n\n    # Fill the grid with the bracket representation\n    current_x = 0\n    current_depth = 0\n    for char in sequence:\n        if char == '[':\n            # Draw opening bracket\n            output[0][current_x] = '+'\n            output[0][current_x + 1] = '-'\n            output[1][current_x] = '|'\n            output[current_depth + 1][current_x] = '|'\n            output[current_depth + 1][current_x + 1] = '-'\n            output[current_depth + 1][current_x + 2] = '+'\n            current_depth += 1\n            current_x += 3\n        else:\n            current_depth -= 1\n            # Draw closing bracket\n            output[current_depth + 1][current_x - 3] = '|'\n            output[current_depth + 1][current_x - 2] = '-'\n            output[current_depth + 1][current_x - 1] = '+'\n            output[0][current_x - 3] = '+'\n            output[0][current_x - 2] = '-'\n            current_x += 1  # space after closing bracket\n\n        # Draw vertical lines for the depth\n        for i in range(current_depth + 1):\n            output[i + 1][current_x - 3] = '|'\n\n    # Print the output\n    for row in output:\n        print(''.join(row).rstrip())\n\n# Read input\nn = int(input().strip())\nsequence = input().strip()\n\n# Draw the bracket sequence\ndraw_bracket_sequence(n, sequence)"}
{"solution": "def compare_golden_system(num1, num2):\n    # Remove leading zeros\n    num1 = num1.lstrip('0')\n    num2 = num2.lstrip('0')\n    \n    # Compare lengths\n    len1 = len(num1)\n    len2 = len(num2)\n    \n    if len1 > len2:\n        return \">\"\n    elif len1 < len2:\n        return \"<\"\n    \n    # If lengths are equal, compare digit by digit\n    for i in range(len1):\n        if num1[i] > num2[i]:\n            return \">\"\n        elif num1[i] < num2[i]:\n            return \"<\"\n    \n    return \"=\"\n\n# Read input\nnum1 = input().strip()\nnum2 = input().strip()\nresult = compare_golden_system(num1, num2)\nprint(result)"}
{"solution": "# Define the mapping of colors to gem names\ngems = {\n    \"purple\": \"Power\",\n    \"green\": \"Time\",\n    \"blue\": \"Space\",\n    \"orange\": \"Soul\",\n    \"red\": \"Reality\",\n    \"yellow\": \"Mind\"\n}\n\n# Read the number of gems present\nn = int(input().strip())\n\n# Read the colors of the gems present\npresent_colors = {input().strip() for _ in range(n)}\n\n# Determine the absent gems\nabsent_gems = [name for color, name in gems.items() if color not in present_colors]\n\n# Output the results\nprint(len(absent_gems))\nfor gem in absent_gems:\n    print(gem)"}
{"solution": "def find_meeting_round(n, a, b):\n    round_number = 0\n    \n    # Ensure a is the smaller ID for consistency\n    if a > b:\n        a, b = b, a\n    \n    while a != b:\n        round_number += 1\n        a = (a + 1) // 2  # Move to the next round\n        b = (b + 1) // 2  # Move to the next round\n    \n    # If they meet in the final, they would have to be in different halves\n    if round_number == (n.bit_length() - 1):  # Final round check\n        return \"Final!\"\n    else:\n        return round_number\n\n# Read input\nn, a, b = map(int, input().split())\n# Print the result\nprint(find_meeting_round(n, a, b))"}
{"solution": "def min_changes(n, p, b):\n    visited = [False] * n\n    cycles = []\n    \n    # Find cycles in the permutation\n    for i in range(n):\n        if not visited[i]:\n            cycle = []\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                cycle.append(x)\n                x = p[x] - 1  # Move to the next position in the permutation\n            cycles.append(cycle)\n    \n    # Count the number of odd cycles and check b\n    odd_cycles = 0\n    need_b_change = 0\n    \n    for cycle in cycles:\n        cycle_length = len(cycle)\n        if cycle_length % 2 == 1:\n            odd_cycles += 1\n            # Check if there's at least one b[i] = 1 in this cycle\n            if not any(b[idx] == 1 for idx in cycle):\n                need_b_change += 1\n    \n    # The minimum changes needed is the number of odd cycles that need b changes\n    return need_b_change\n\n# Input reading\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Output the result\nprint(min_changes(n, p, b))"}
{"solution": "def max_path_length(v1, v2, t, d):\n    speeds = [0] * t\n    speeds[0] = v1\n    speeds[-1] = v2\n\n    # Fill the speeds array from the start to the end\n    for i in range(1, t - 1):\n        speeds[i] = speeds[i - 1] + d\n\n    # Fill the speeds array from the end to the start\n    for i in range(t - 2, 0, -1):\n        speeds[i] = min(speeds[i], speeds[i + 1] + d)\n\n    return sum(speeds)\n\n# Input reading\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Calculate and print the maximum path length\nprint(max_path_length(v1, v2, t, d))"}
{"solution": "from itertools import permutations\nimport sys\n\ndef can_cross_bridge(camels, bridge_parts):\n    for l, v in bridge_parts:\n        current_weight = 0\n        for i in range(len(camels)):\n            current_weight += camels[i]\n            if current_weight > v:\n                return False\n            # When we reach the end of the part, we need to remove the weight of the first camel\n            if i < len(camels) - 1:\n                current_weight -= camels[i]\n    return True\n\ndef min_distance_between_camels(camels, bridge_parts):\n    min_distance = float('inf')\n    for perm in permutations(camels):\n        if can_cross_bridge(perm, bridge_parts):\n            # Calculate the distance needed\n            total_length = sum(l for l, _ in bridge_parts)\n            # The minimum distance is the total length minus the sum of the weights of the camels\n            distance = total_length - sum(perm)\n            min_distance = min(min_distance, distance)\n    return min_distance if min_distance != float('inf') else -1\n\ndef main():\n    input_data = sys.stdin.read().strip().splitlines()\n    N, M = map(int, input_data[0].split())\n    camels = list(map(int, input_data[1].split()))\n    bridge_parts = [tuple(map(int, line.split())) for line in input_data[2:M+2]]\n    \n    result = min_distance_between_camels(camels, bridge_parts)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def last_digit_of_reincarnations(a, b):\n    if b - a >= 5:\n        return 0\n    \n    product = 1\n    for i in range(a + 1, b + 1):\n        product *= i\n        product %= 10  # We only care about the last digit\n    \n    return product\n\n# Read input\na, b = map(int, input().split())\n# Calculate and print the last digit of the number of reincarnations\nprint(last_digit_of_reincarnations(a, b))"}
{"solution": "from collections import deque\n\ndef min_jumps_to_home(n, d, s):\n    # BFS initialization\n    queue = deque([(1, 0)])  # (current position, number of jumps)\n    visited = [False] * (n + 1)\n    visited[1] = True  # Start from position 1\n\n    while queue:\n        position, jumps = queue.popleft()\n\n        # Check if we reached home\n        if position == n:\n            return jumps\n\n        # Explore all possible jumps\n        for jump in range(1, d + 1):\n            next_position = position + jump\n            if next_position <= n and s[next_position - 1] == '1' and not visited[next_position]:\n                visited[next_position] = True\n                queue.append((next_position, jumps + 1))\n\n    return -1  # If we exhaust the queue without reaching n\n\n# Input reading\nn, d = map(int, input().split())\ns = input().strip()\nprint(min_jumps_to_home(n, d, s))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef find_counterexample(n):\n    for m in range(1, 1001):\n        candidate = n * m + 1\n        if not is_prime(candidate):\n            return m\n\n# Read input\nn = int(input().strip())\n# Find and print the counterexample\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all_coins(n):\n    # Prices of houses, cars, and computers\n    house_price = 1234567\n    car_price = 123456\n    computer_price = 1234\n\n    # Iterate over the number of houses that can be bought\n    for a in range(n // house_price + 1):\n        remaining_after_houses = n - a * house_price\n        \n        # Iterate over the number of cars that can be bought with the remaining coins\n        for b in range(remaining_after_houses // car_price + 1):\n            remaining_after_cars = remaining_after_houses - b * car_price\n            \n            # Check if the remaining coins can be spent on computers\n            if remaining_after_cars >= 0 and remaining_after_cars % computer_price == 0:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input().strip())\n# Output the result\nprint(can_spend_all_coins(n))"}
{"solution": "def can_intersect(n, x1, x2, lines):\n    # Sort lines based on their slopes (k_i)\n    lines.sort()\n    \n    for i in range(n - 1):\n        k1, b1 = lines[i]\n        k2, b2 = lines[i + 1]\n        \n        # Check if the slopes are different\n        if k1 != k2:\n            # Calculate the intersection point\n            x_intersection = (b2 - b1) / (k1 - k2)\n            # Check if the intersection point is within the strip\n            if x1 < x_intersection < x2:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn = int(input())\nx1, x2 = map(int, input().split())\nlines = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_intersect(n, x1, x2, lines))"}
{"solution": "def distinct_weights(n):\n    weights = set()\n    k = 1\n    while k <= n:\n        weight = n // k\n        weights.add(weight)\n        k += 1\n        # Skip to the next k that gives a different weight\n        k = n // weight + 1  # This ensures we jump to the next range\n    \n    return len(weights)\n\n# Input reading\nn = int(input().strip())\n# Output the result\nprint(distinct_weights(n))"}
{"solution": "def find_good_apartments(n, k):\n    # Calculate minimum good apartments\n    if k == 0:\n        min_good = 0\n    elif k == 1:\n        min_good = 1\n    else:\n        min_good = 1\n\n    # Calculate maximum good apartments\n    if k == 0:\n        max_good = 0\n    elif k == 1:\n        max_good = 2 if n > 1 else 1\n    else:\n        max_good = min(n - k, 2 * k)\n\n    return min_good, max_good\n\n# Read input\nn, k = map(int, input().split())\nmin_good, max_good = find_good_apartments(n, k)\n\n# Print output\nprint(min_good, max_good)"}
{"solution": "import math\n\ndef max_games(n):\n    return math.floor(math.log2(n))\n\nn = int(input())\nprint(max_games(n))"}
{"solution": "def max_vk_occurrences(s):\n    # Function to count occurrences of \"VK\" in the string\n    def count_vk(string):\n        return sum(1 for i in range(len(string) - 1) if string[i:i + 2] == \"VK\")\n\n    # Initial count of \"VK\" in the original string\n    max_count = count_vk(s)\n\n    # Try changing each character and see if it increases the count of \"VK\"\n    for i in range(len(s)):\n        original_char = s[i]\n        \n        # Change 'V' to 'K' if it's 'V'\n        if original_char == 'V':\n            new_string = s[:i] + 'K' + s[i + 1:]\n            max_count = max(max_count, count_vk(new_string))\n        \n        # Change 'K' to 'V' if it's 'K'\n        elif original_char == 'K':\n            new_string = s[:i] + 'V' + s[i + 1:]\n            max_count = max(max_count, count_vk(new_string))\n\n    return max_count\n\n# Read input\ns = input().strip()\n# Print the output\nprint(max_vk_occurrences(s))"}
{"solution": "import math\n\ndef minimum_segments(n):\n    k = int(math.sqrt(n))\n    remaining_squares = n - k * k\n    return 2 * k + remaining_squares\n\n# Read input\nn = int(input().strip())\n# Output the result\nprint(minimum_segments(n))"}
{"solution": "a, b = map(int, input().split())\n\nyears = 0\nwhile a <= b:\n    a *= 3\n    b *= 2\n    years += 1\n\nprint(years)"}
{"solution": "def count_visited_nodes(h, n):\n    visited = set()\n    current_node = 1\n    visited.add(current_node)\n    command_index = 0\n    skip_count = 0\n    total_visited = 0\n\n    while True:\n        if current_node == n:\n            break\n        \n        # Determine the next command\n        command = 'L' if command_index % 2 == 0 else 'R'\n        command_index += 1\n        \n        # Calculate the next node based on the command\n        if command == 'L':\n            next_node = current_node * 2\n        else:\n            next_node = current_node * 2 + 1\n        \n        # Check if the next node is a leaf\n        if next_node > 2 ** h:\n            next_node = None\n        \n        if next_node is not None:\n            if next_node in visited:\n                skip_count += 1\n                if skip_count == 2:\n                    # Go back to parent\n                    current_node //= 2\n                    skip_count = 0\n                continue\n            else:\n                visited.add(next_node)\n                total_visited += 1\n                current_node = next_node\n                skip_count = 0\n        else:\n            # If it's a leaf and not the exit, go back to parent\n            current_node //= 2\n\n    return total_visited\n\n# Read input\nh, n = map(int, input().split())\n# Get the result\nresult = count_visited_nodes(h, n)\n# Print the output\nprint(result)"}
{"solution": "def count_squares(n, m):\n    total_squares = 0\n    for k in range(1, min(n, m) + 1):\n        total_squares += (n - k + 1) * (m - k + 1)\n    return total_squares\n\ndef find_pairs(x):\n    pairs = []\n    for n in range(1, int((2 * x) ** 0.5) + 2):\n        m = 1\n        while True:\n            squares = count_squares(n, m)\n            if squares == x:\n                pairs.append((n, m))\n            elif squares > x:\n                break\n            m += 1\n    return pairs\n\ndef main():\n    x = int(input().strip())\n    pairs = find_pairs(x)\n    print(len(pairs))\n    for n, m in sorted(pairs):\n        print(n, m)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_valid_sequence(n, days):\n    # Days in months for non-leap and leap years\n    months_non_leap = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    months_leap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    # Check for both non-leap and leap year scenarios\n    for start_month in range(12):\n        # Check non-leap year\n        if start_month + n <= 12:\n            if days == months_non_leap[start_month:start_month + n]:\n                return \"YES\"\n        \n        # Check leap year\n        if start_month + n <= 12:\n            if days == months_leap[start_month:start_month + n]:\n                return \"YES\"\n\n    # Check wrapping around the year\n    for start_month in range(12):\n        if start_month + n > 12:\n            # Non-leap year\n            wrapped_days = months_non_leap[start_month:] + months_non_leap[:(start_month + n) % 12]\n            if days == wrapped_days[:n]:\n                return \"YES\"\n            \n            # Leap year\n            wrapped_days = months_leap[start_month:] + months_leap[:(start_month + n) % 12]\n            if days == wrapped_days[:n]:\n                return \"YES\"\n\n    return \"NO\"\n\n# Input reading\nn = int(input())\ndays = list(map(int, input().split()))\n\n# Output the result\nprint(is_valid_sequence(n, days))"}
{"solution": "def find_fractions(n):\n    divisors = []\n    \n    # Find divisors of n in the range (1, n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    \n    # Sort divisors\n    divisors = sorted(divisors)\n    \n    # Check if we can form the required sum\n    k = len(divisors)\n    if k == 0:\n        print(\"NO\")\n        return\n    \n    # We can use each divisor b_i and set a_i = b_i - 1\n    print(\"YES\")\n    print(k)\n    for b in divisors:\n        print(b - 1, b)\n\n# Read input\nn = int(input())\nfind_fractions(n)"}
{"solution": "def min_unattractiveness(n, a, b, heights):\n    total_area = sum(heights)\n    \n    # Check if it's possible to paint the fence\n    if total_area > a + b:\n        return -1\n    \n    # Initialize DP table\n    dp = [[float('inf')] * (b + 1) for _ in range(n + 1)]\n    dp[0][0] = 0  # No boards painted, no unattractiveness\n    \n    for i in range(1, n + 1):\n        height = heights[i - 1]\n        for j in range(b + 1):\n            # Paint current board red\n            if a >= height:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + (height if j < b and i > 1 and heights[i - 2] > height else 0))\n            # Paint current board green\n            if j >= height:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j - height] + (height if a > 0 and i > 1 and heights[i - 2] > height else 0))\n    \n    # Find the minimum unattractiveness\n    min_unattractiveness_value = float('inf')\n    for j in range(b + 1):\n        min_unattractiveness_value = min(min_unattractiveness_value, dp[n][j])\n    \n    return min_unattractiveness_value if min_unattractiveness_value != float('inf') else -1\n\n# Input reading\nn = int(input().strip())\na, b = map(int, input().strip().split())\nheights = list(map(int, input().strip().split()))\n\n# Output the result\nprint(min_unattractiveness(n, a, b, heights))"}
{"solution": "def find_triangle_points(n, m, k):\n    # Calculate the target area\n    target_area = (n * m) / k\n    \n    # Check if the area is an integer and if it is feasible\n    if (n * m) % k != 0 or target_area > (n * m) / 2:\n        return \"NO\"\n    \n    # We can choose points (0, 0), (n, 0), and calculate (x3, y3)\n    # Area = 1/2 * base * height\n    # Here base = n, we need height = 2 * target_area / n\n    height = (2 * target_area) // n\n    \n    if height > m:\n        return \"NO\"\n    \n    # Points are (0, 0), (n, 0), (x3, height)\n    x3 = 0  # We can choose x3 = 0 for simplicity\n    y3 = height\n    \n    return f\"YES\\n0 0\\n{n} 0\\n{x3} {y3}\"\n\n# Read input\nn, m, k = map(int, input().split())\nresult = find_triangle_points(n, m, k)\nprint(result)"}
{"solution": "def sasha_wins(n, k):\n    total_turns = n // k\n    if total_turns % 2 == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\n# Print the result\nprint(sasha_wins(n, k))"}
{"solution": "def determine_most_exercised_muscle(n, exercises):\n    chest = 0\n    biceps = 0\n    back = 0\n    \n    for i in range(n):\n        if i % 3 == 0:\n            chest += exercises[i]\n        elif i % 3 == 1:\n            biceps += exercises[i]\n        else:\n            back += exercises[i]\n    \n    if chest > biceps and chest > back:\n        return \"chest\"\n    elif biceps > chest and biceps > back:\n        return \"biceps\"\n    else:\n        return \"back\"\n\n# Input reading\nn = int(input())\nexercises = list(map(int, input().split()))\nresult = determine_most_exercised_muscle(n, exercises)\nprint(result)"}
{"solution": "def min_redos(n, grades):\n    current_sum = sum(grades)\n    required_sum = (4.5 * n)\n    \n    # Since we need an integer sum, we round up\n    required_sum = int(required_sum) if required_sum.is_integer() else int(required_sum) + 1\n    \n    if current_sum >= required_sum:\n        return 0  # No need to redo any lab works\n    \n    # Sort grades in ascending order to maximize the increase\n    grades.sort()\n    \n    redos = 0\n    for grade in grades:\n        if current_sum >= required_sum:\n            break\n        # Calculate the increase in sum if we change this grade to 5\n        current_sum += (5 - grade)\n        redos += 1\n    \n    return redos\n\n# Input reading\nn = int(input())\ngrades = list(map(int, input().split()))\nprint(min_redos(n, grades))"}
{"solution": "def find_array(u, v):\n    if v < u or (u + v) % 2 != 0 or (v - u) % 2 != 0:\n        return -1\n    \n    a = (u + v) // 2\n    b = (v - u) // 2\n    \n    if a == 0 and b == 0:\n        return (0, [])\n    \n    result = []\n    \n    if a > 0:\n        result.append(a)\n    if b > 0:\n        result.append(b)\n    \n    # If we have a zero, we need to add 1s to make all elements positive\n    while len(result) < 2:\n        result.append(1)\n    \n    return (len(result), result)\n\n# Read input\nu, v = map(int, input().split())\nresult = find_array(u, v)\n\nif result == -1:\n    print(-1)\nelse:\n    n, arr = result\n    print(n)\n    print(\" \".join(map(str, arr)))"}
{"solution": "def minimal_ones(n):\n    total_ones = 0\n    place_value = 1\n    \n    while n > 0:\n        digit = n % 10\n        total_ones += digit * place_value\n        n //= 10\n        place_value += 1\n    \n    return total_ones\n\n# Input\nn = int(input())\n# Output\nprint(minimal_ones(n))"}
{"solution": "def can_reach_treasure(x1, y1, x2, y2, x, y):\n    dx = x2 - x1\n    dy = y2 - y1\n    \n    # Check divisibility\n    if dx % x != 0 or dy % y != 0:\n        return \"NO\"\n    \n    # Check parity\n    if (dx // x) % 2 != (dy // y) % 2:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\n# Output the result\nprint(can_reach_treasure(x1, y1, x2, y2, x, y))"}
{"solution": "from itertools import permutations\n\ndef count_valid_bus_numbers(n):\n    # Convert the number to a string to extract digits\n    digits = str(n)\n    \n    # Use a set to store unique valid bus numbers\n    valid_numbers = set()\n    \n    # Generate all unique permutations of the digits\n    for perm in set(permutations(digits)):\n        # Join the tuple of characters to form a number\n        num_str = ''.join(perm)\n        # Check if the number does not start with '0'\n        if num_str[0] != '0':\n            valid_numbers.add(num_str)\n    \n    # Return the count of valid bus numbers\n    return len(valid_numbers)\n\n# Read input\nn = int(input().strip())\n# Output the result\nprint(count_valid_bus_numbers(n))"}
{"solution": "def max_suit_cost(a, b, c, d, e, f):\n    # Strategy 1: Prioritize Suit Type 1\n    type1_count = min(a, d)  # Max suits of type 1\n    remaining_jackets_after_type1 = d - type1_count\n    type2_count = min(b, c, remaining_jackets_after_type1)  # Max suits of type 2\n    total_cost_strategy1 = type1_count * e + type2_count * f\n\n    # Strategy 2: Prioritize Suit Type 2\n    type2_count = min(b, c, d)  # Max suits of type 2\n    remaining_jackets_after_type2 = d - type2_count\n    type1_count = min(a, remaining_jackets_after_type2)  # Max suits of type 1\n    total_cost_strategy2 = type1_count * e + type2_count * f\n\n    # Return the maximum of both strategies\n    return max(total_cost_strategy1, total_cost_strategy2)\n\n# Input reading\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\n# Output the maximum total cost\nprint(max_suit_cost(a, b, c, d, e, f))"}
{"solution": "def count_valid_n(a, b, p, x):\n    count = 0\n    # We only need to check n from 1 to min(x, p)\n    for n in range(1, min(x, p) + 1):\n        a_n = pow(a, n, p)  # Calculate a^n mod p\n        if (n * a_n) % p == b:\n            count += 1\n    return count\n\n# Read input values\na, b, p, x = map(int, input().split())\nresult = count_valid_n(a, b, p, x)\nprint(result)"}
{"solution": "def max_sum_of_favorites(k_2, k_3, k_5, k_6):\n    # Calculate the maximum number of 256s that can be formed\n    count_256 = min(k_2, k_5, k_6)\n    \n    # Update the count of digit 2 after forming 256s\n    k_2 -= count_256\n    \n    # Calculate the maximum number of 32s that can be formed\n    count_32 = min(k_2, k_3)\n    \n    # Calculate the total sum\n    total_sum = count_256 * 256 + count_32 * 32\n    \n    return total_sum\n\n# Input reading\nk_2, k_3, k_5, k_6 = map(int, input().split())\n\n# Output the result\nprint(max_sum_of_favorites(k_2, k_3, k_5, k_6))"}
{"solution": "import math\nimport sys\n\ndef time_to_happiness(n, x, y, c):\n    if c == 1:\n        return 0\n    \n    # Calculate the minimum time t required to have at least c switched on cells\n    t = math.ceil((math.sqrt(c) - 1) / 2)\n    \n    # The maximum number of cells that can be switched on is limited by the grid size\n    max_cells = n * n\n    \n    # Check if the calculated t is valid within the grid limits\n    while (2 * t + 1) ** 2 > max_cells:\n        t -= 1\n    \n    return t\n\n# Read input\ninput_data = sys.stdin.read().strip()\nn, x, y, c = map(int, input_data.split())\n\n# Get the result\nresult = time_to_happiness(n, x, y, c)\n\n# Print the result\nprint(result)"}
{"solution": "def max_xor(l, r):\n    # Step 1: Calculate l XOR r\n    xor_value = l ^ r\n    \n    # Step 2: Find the position of the most significant bit (MSB)\n    msb_position = 0\n    while xor_value > 0:\n        msb_position += 1\n        xor_value >>= 1\n    \n    # Step 3: Calculate the maximum XOR value\n    max_xor_value = (1 << msb_position) - 1\n    \n    return max_xor_value\n\n# Read input\nl, r = map(int, input().strip().split())\n\n# Get the result and print it\nresult = max_xor(l, r)\nprint(result)"}
{"solution": "def minimum_height(n, k):\n    # Calculate the minimum height\n    return (k + n - 1) // n  # This is equivalent to ceil(k / n)\n\n# Read input\nn, k = map(int, input().split())\n# Get the result\nresult = minimum_height(n, k)\n# Print the result\nprint(result)"}
{"solution": "# Read input values\nx, y, z, t1, t2, t3 = map(int, input().split())\n\n# Calculate time taken using stairs\ntime_stairs = abs(x - y) * t1\n\n# Calculate time taken using elevator\ntime_elevator_to_masha = abs(z - x) * t2\ntime_elevator_to_egor = abs(x - y) * t2\ntime_elevator = time_elevator_to_masha + 3 * t3 + time_elevator_to_egor\n\n# Determine whether to use stairs or elevator\nif time_elevator <= time_stairs:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def optimal_choice(n, m):\n    # Candidates for Andrew's choice\n    candidates = []\n    \n    if m > 1:\n        candidates.append(m - 1)\n    if m < n:\n        candidates.append(m + 1)\n    \n    # Return the minimum valid candidate\n    return min(candidates)\n\n# Read input\nn, m = map(int, input().split())\n# Print the optimal choice for Andrew\nprint(optimal_choice(n, m))"}
{"solution": "def alena_stays_at_university(n, schedule):\n    # Find the first class\n    first_class_index = -1\n    for i in range(n):\n        if schedule[i] == 1:\n            first_class_index = i\n            break\n    \n    # If there are no classes, return 0\n    if first_class_index == -1:\n        return 0\n    \n    # Count the number of pairs Alena stays at the university\n    stay_count = 0\n    i = first_class_index\n    \n    while i < n:\n        if schedule[i] == 1:\n            stay_count += 1\n            i += 1\n        else:\n            # We have a break\n            break_length = 0\n            while i < n and schedule[i] == 0:\n                break_length += 1\n                i += 1\n            \n            # If there are at least two breaks, Alena goes home\n            if break_length >= 2:\n                continue\n            else:\n                # If it's a single break, she waits for the next class\n                stay_count += break_length\n    \n    return stay_count\n\n# Read input\nn = int(input())\nschedule = list(map(int, input().split()))\n\n# Output the result\nprint(alena_stays_at_university(n, schedule))"}
{"solution": "def minimum_days(n, k, candies):\n    total_given = 0\n    total_candies = 0\n    \n    for day in range(n):\n        total_candies += candies[day]\n        # Give Bran the minimum of 8 or the total candies available\n        to_give = min(8, total_candies)\n        total_given += to_give\n        total_candies -= to_give\n        \n        # Check if we have given enough candies\n        if total_given >= k:\n            return day + 1  # Return the day index (1-based)\n    \n    return -1  # If we finish all days and haven't given enough candies\n\n# Input reading\nn, k = map(int, input().split())\ncandies = list(map(int, input().split()))\nprint(minimum_days(n, k, candies))"}
{"solution": "def min_additional_walks(n, k, a):\n    # Initialize b with the planned walks\n    b = a[:]\n    additional_walks = 0\n    \n    # We assume that before the first day and after the last day, there are k walks\n    # This means we can treat the first day as having k walks before it\n    # and the last day as having k walks after it.\n    \n    # Iterate through the days\n    for i in range(n - 1):\n        # Check if the current and next day meet the requirement\n        if b[i] + b[i + 1] < k:\n            # Calculate how many additional walks are needed\n            needed = k - b[i]\n            additional_walks += needed\n            b[i + 1] += needed  # Increase the next day's walks\n            \n    return additional_walks, b\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nadditional_walks, b = min_additional_walks(n, k, a)\n\n# Print the results\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "def rhombus_cells(n):\n    return 2 * n * n - 2 * n + 1\n\n# Read input\nn = int(input().strip())\n# Output the result\nprint(rhombus_cells(n))"}
{"solution": "def is_pangram(n, s):\n    # Normalize the string to lowercase\n    s = s.lower()\n    # Create a set of all unique characters in the string\n    unique_chars = set(s)\n    # Check if the set contains all 26 letters of the alphabet\n    if len(unique_chars) >= 26 and all(chr(i) in unique_chars for i in range(ord('a'), ord('z') + 1)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(is_pangram(n, s))"}
{"solution": "# Read the current time in hh:mm format\ncurrent_time = input().strip()\n# Read the number of minutes to add\nminutes_to_add = int(input().strip())\n\n# Split the current time into hours and minutes\nhh, mm = map(int, current_time.split(':'))\n\n# Convert the current time to total minutes since midnight\ntotal_minutes = hh * 60 + mm\n\n# Add the specified number of minutes\nnew_total_minutes = (total_minutes + minutes_to_add) % 1440\n\n# Convert back to hours and minutes\nnew_hh = new_total_minutes // 60\nnew_mm = new_total_minutes % 60\n\n# Print the result in hh:mm format with leading zeros\nprint(f\"{new_hh:02}:{new_mm:02}\")"}
{"solution": "def can_ignore_switch(n, m, matrix):\n    # Convert the input matrix from strings to a list of lists of integers\n    switches = [[int(char) for char in row] for row in matrix]\n\n    # For each switch, check if we can ignore it\n    for i in range(n):\n        # Create a set to track which lamps can be turned on by the remaining switches\n        lamps_on = [0] * m\n        \n        # Check all switches except the i-th one\n        for j in range(n):\n            if j != i:\n                for k in range(m):\n                    lamps_on[k] |= switches[j][k]\n        \n        # Check if all lamps are on\n        if all(lamps_on):\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nmatrix = [input().strip() for _ in range(n)]\n\n# Get the result and print it\nresult = can_ignore_switch(n, m, matrix)\nprint(result)"}
{"solution": "def min_rotations(n, dominoes):\n    sum_upper = sum(x for x, y in dominoes)\n    sum_lower = sum(y for x, y in dominoes)\n\n    # Check the parity of the sums\n    upper_even = sum_upper % 2 == 0\n    lower_even = sum_lower % 2 == 0\n\n    if upper_even and lower_even:\n        return 0\n    elif not upper_even and not lower_even:\n        # Check for at least one domino with one odd and one even number\n        for x, y in dominoes:\n            if (x % 2) != (y % 2):\n                return 1\n        return -1\n    else:\n        return -1\n\n# Read input\nn = int(input())\ndominoes = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = min_rotations(n, dominoes)\nprint(result)"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    a, b = map(int, input().split())\n    remaining_area = a * a - b * b  # Calculate the remaining area\n    if is_prime(remaining_area):\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nprint(\"\\n\".join(results))"}
{"solution": "def can_remove_point(n, points):\n    left_count = 0\n    right_count = 0\n\n    for x, y in points:\n        if x < 0:\n            left_count += 1\n        else:\n            right_count += 1\n\n    # We can remove one point if all remaining points are on one side\n    if left_count <= 1 or right_count <= 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Input reading\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_remove_point(n, points))"}
{"solution": "import math\n\n# Read input\nA, B = map(int, input().split())\n\n# Find the minimum of A and B\nmin_value = min(A, B)\n\n# Calculate the factorial of the minimum value\nresult = math.factorial(min_value)\n\n# Print the result\nprint(result)"}
{"solution": "def is_composite(num):\n    if num < 4:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return True\n    return False\n\ndef find_composite_pair(n):\n    # Start with a known composite number\n    b = 4\n    a = b + n\n    \n    # Ensure both a and b are composite\n    while not is_composite(a) or not is_composite(b):\n        b += 1\n        a = b + n\n    \n    return a, b\n\n# Read input\nn = int(input().strip())\na, b = find_composite_pair(n)\nprint(a, b)"}
{"solution": "import sys\nimport collections\n\ndef max_score(N, M, P, edges):\n    graph = collections.defaultdict(list)\n    \n    for A, B, C in edges:\n        graph[A].append((B, C))\n    \n    # Initialize the maximum coins collected at each vertex\n    max_coins = [0] * (N + 1)\n    max_coins[1] = 0  # Starting at vertex 1 with 0 coins\n    \n    # Use a queue for BFS-like traversal\n    queue = collections.deque([(1, 0)])  # (current_vertex, time_taken)\n    \n    while queue:\n        current_vertex, time_taken = queue.popleft()\n        \n        for neighbor, coins in graph[current_vertex]:\n            new_coins = max_coins[current_vertex] + coins\n            \n            # If we can collect more coins at the neighbor\n            if new_coins > max_coins[neighbor]:\n                max_coins[neighbor] = new_coins\n                queue.append((neighbor, time_taken + 1))\n    \n    # Now calculate the maximum score at vertex N\n    max_coins_at_N = max_coins[N]\n    max_time = 0\n    \n    # Calculate the maximum score possible\n    max_score = -1\n    for time_taken in range(1, N + 1):\n        cost = time_taken * P\n        if max_coins_at_N >= cost:\n            score = max_coins_at_N - cost\n        else:\n            score = max_coins_at_N\n        \n        max_score = max(max_score, score)\n    \n    return max_score\n\n# Read input\ninput_data = sys.stdin.read().strip().splitlines()\nN, M, P = map(int, input_data[0].split())\nedges = [tuple(map(int, line.split())) for line in input_data[1:M + 1]]\n\n# Get the result and print it\nresult = max_score(N, M, P, edges)\nprint(result)"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef min_cost_to_form_palindrome(n, strings_with_costs):\n    from collections import defaultdict\n\n    cost_map = {}\n    for s, c in strings_with_costs:\n        cost_map[s] = min(cost_map.get(s, float('inf')), c)\n\n    used = set()\n    total_cost = 0\n    odd_count = 0\n    odd_cost = float('inf')\n\n    for s in list(cost_map.keys()):\n        rev_s = s[::-1]\n        if s == rev_s:  # Palindromic string\n            total_cost += cost_map[s]\n            odd_count += 1\n            odd_cost = min(odd_cost, cost_map[s])\n        elif rev_s in cost_map and rev_s not in used:\n            total_cost += cost_map[s] + cost_map[rev_s]\n            used.add(s)\n            used.add(rev_s)\n\n    if odd_count > 0:\n        total_cost -= odd_cost  # Remove the cost of one odd palindromic string if we have one\n\n    return total_cost if total_cost > 0 else -1\n\n# Input reading\nimport sys\ninput = sys.stdin.read\ndata = input().strip().splitlines()\n\nN = int(data[0])\nstrings_with_costs = [line.split() for line in data[1:N+1]]\nstrings_with_costs = [(s, int(c)) for s, c in strings_with_costs]\n\n# Calculate and print the result\nresult = min_cost_to_form_palindrome(N, strings_with_costs)\nprint(result)"}
{"solution": "def max_xor_sum(n, k):\n    # Calculate the maximum power of 2 less than or equal to n\n    max_power_of_2 = 1\n    while max_power_of_2 <= n:\n        max_power_of_2 <<= 1\n    max_power_of_2 >>= 1  # Go back to the last valid power of 2\n\n    # Calculate the number of bits in n\n    m = max_power_of_2.bit_length()  # Number of bits required to represent n\n\n    # Determine the maximum xor-sum based on k\n    if k >= m:\n        return (1 << m) - 1  # 2^m - 1\n    else:\n        # If k < m, we need to select the k largest numbers\n        # The maximum xor-sum we can achieve is by taking the k largest numbers\n        # from the set {1, 2, ..., n}\n        result = 0\n        for i in range(n, n - k, -1):\n            result ^= i\n        return result\n\n# Read input\nn, k = map(int, input().strip().split())\n# Output the result\nprint(max_xor_sum(n, k))"}
{"solution": "def minimum_length_of_triangle(n, points):\n    max_sum = 0\n    for x, y in points:\n        max_sum = max(max_sum, x + y)\n    return max_sum\n\n# Read input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nresult = minimum_length_of_triangle(n, points)\nprint(result)"}
{"solution": "def max_nineteens(s):\n    # Count the occurrences of each letter in the string\n    letter_count = {}\n    for char in s:\n        if char in letter_count:\n            letter_count[char] += 1\n        else:\n            letter_count[char] = 1\n\n    # Calculate the maximum number of times we can form the word \"nineteen\"\n    n_count = letter_count.get('n', 0) // 2  # Need 2 'n's\n    i_count = letter_count.get('i', 0) // 1  # Need 1 'i'\n    e_count = letter_count.get('e', 0) // 2  # Need 2 'e's\n    t_count = letter_count.get('t', 0) // 1  # Need 1 't'\n\n    # The limiting factor will determine the maximum number of \"nineteen\"\n    return min(n_count, i_count, e_count, t_count)\n\n# Read input\ns = input().strip()\n# Print the result\nprint(max_nineteens(s))"}
{"solution": "def highest_safe_branch(p, y):\n    # Start checking from the highest branch y down to p + 1\n    for branch in range(y, p, -1):\n        # Check if branch is reachable by any grasshopper\n        is_reachable = False\n        \n        # Check for all grasshoppers from 2 to p\n        for grasshopper in range(2, min(p + 1, int(branch**0.5) + 1)):\n            if branch % grasshopper == 0:\n                is_reachable = True\n                break\n        \n        # If not reachable, return this branch\n        if not is_reachable:\n            return branch\n    \n    # If no suitable branch found, return -1\n    return -1\n\n# Read input\np, y = map(int, input().split())\n# Get the result\nresult = highest_safe_branch(p, y)\n# Print the result\nprint(result)"}
{"solution": "def minimum_distance_to_crush_house(n, m, k, house_prices):\n    crush_house_index = m - 1  # Convert to 0-based index\n    min_distance = float('inf')  # Initialize minimum distance to infinity\n\n    for i in range(n):\n        if house_prices[i] > 0 and house_prices[i] <= k:  # Check if house is affordable and unoccupied\n            distance = abs(crush_house_index - i) * 10  # Calculate distance in meters\n            min_distance = min(min_distance, distance)  # Update minimum distance if found a closer house\n\n    return min_distance\n\n# Input reading\nn, m, k = map(int, input().split())\nhouse_prices = list(map(int, input().split()))\n\n# Calculate and print the minimum distance\nresult = minimum_distance_to_crush_house(n, m, k, house_prices)\nprint(result)"}
{"solution": "def can_transform(n, m, A, B):\n    from collections import Counter\n    \n    # Count frequencies of elements in both matrices\n    count_A = Counter()\n    count_B = Counter()\n    \n    for i in range(n):\n        for j in range(m):\n            count_A[A[i][j]] += 1\n            count_B[B[i][j]] += 1\n    \n    # Check if frequencies match\n    if count_A != count_B:\n        return \"NO\"\n    \n    # Check connectivity of each unique element\n    def get_positions(matrix, value):\n        return [(i, j) for i in range(n) for j in range(m) if matrix[i][j] == value]\n    \n    for value in count_A.keys():\n        positions_A = get_positions(A, value)\n        positions_B = get_positions(B, value)\n        \n        # Sort positions to compare\n        positions_A.sort()\n        positions_B.sort()\n        \n        if positions_A != positions_B:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nB = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_transform(n, m, A, B))"}
{"solution": "def longest_uncommon_subsequence(a: str, b: str) -> int:\n    if a == b:\n        return -1\n    return max(len(a), len(b))\n\n# Read input\na = input().strip()\nb = input().strip()\n\n# Output the result\nprint(longest_uncommon_subsequence(a, b))"}
{"solution": "def find_scream_time(a, b, c, d):\n    # We will iterate over possible values of n and m\n    for n in range(10000):  # Arbitrarily large limit to ensure we find a solution if it exists\n        # Calculate the time Rick screams\n        rick_time = b + n * a\n        \n        # Check if this time can be expressed as Morty's scream time\n        if (rick_time - d) % c == 0:\n            m = (rick_time - d) // c\n            if m >= 0:\n                return rick_time  # Return the first time they scream together\n    \n    return -1  # If no valid time is found\n\n# Read input values\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Print the result\nprint(find_scream_time(a, b, c, d))"}
{"solution": "def split_number(n):\n    if n % 3 == 0:\n        a, b, c = 1, 1, n - 2\n    elif n % 3 == 1:\n        a, b, c = 1, 2, n - 3\n    else:  # n % 3 == 2\n        a, b, c = 1, 2, n - 3\n    \n    print(a, b, c)\n\nn = int(input())\nsplit_number(n)"}
{"solution": "def count_distinct_squares(n, a, b, c, d):\n    # Calculate the sum of the top-left 2x2 square\n    S = a + b + c + d\n    \n    # The possible values for the unknown cells\n    count = 0\n    \n    # Iterate through all possible values for the unknown cells\n    for x1 in range(1, n + 1):  # Top-left cell\n        for x2 in range(1, n + 1):  # Top-right cell\n            for x3 in range(1, n + 1):  # Bottom-left cell\n                for x4 in range(1, n + 1):  # Bottom-right cell\n                    # Check if the sums of the 2x2 squares are equal\n                    if (x1 + a + x2 + b == S and\n                        b + x3 + d + x4 == S and\n                        a + x2 + c + x4 == S and\n                        x1 + b + x3 + d == S):\n                        count += 1\n    \n    return count\n\n# Read input\nn, a, b, c, d = map(int, input().split())\n\n# Get the result\nresult = count_distinct_squares(n, a, b, c, d)\n\n# Print the output\nprint(result)"}
{"solution": "def final_snowball_weight(w, h, u1, d1, u2, d2):\n    current_weight = w\n    \n    for height in range(h, 0, -1):\n        # Increase weight by the current height\n        current_weight += height\n        \n        # Check if there's a stone at this height\n        if height == d1:\n            current_weight -= u1\n        elif height == d2:\n            current_weight -= u2\n        \n        # Ensure weight does not go below zero\n        if current_weight < 0:\n            current_weight = 0\n    \n    return current_weight\n\n# Read input\nw, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\n# Calculate and print the final weight of the snowball\nprint(final_snowball_weight(w, h, u1, d1, u2, d2))"}
{"solution": "def find_passing_rate(m, scores, x, y):\n    total_students = sum(scores)\n    \n    for k in range(1, m + 1):\n        beginner_count = sum(scores[:k-1])  # Students scoring less than k\n        intermediate_count = sum(scores[k-1:])  # Students scoring k or more\n        \n        if x <= beginner_count <= y and x <= intermediate_count <= y:\n            return k\n    \n    return 0\n\n# Input reading\nm = int(input().strip())\nscores = list(map(int, input().strip().split()))\nx, y = map(int, input().strip().split())\n\n# Finding the passing rate\nresult = find_passing_rate(m, scores, x, y)\n\n# Output the result\nprint(result)"}
{"solution": "def min_cost_to_reduce_to_one(n, k, A, B):\n    cost = 0\n    while n > 1:\n        if k > 1 and n % k == 0:\n            # Calculate cost of dividing\n            divide_cost = B\n            # Calculate cost of subtracting to reach the next divisible number\n            next_divisible = (n // k) * k\n            subtract_cost = (n - next_divisible) * A\n            \n            # Choose the minimum cost operation\n            if divide_cost < subtract_cost:\n                cost += divide_cost\n                n //= k\n            else:\n                cost += subtract_cost\n                n = next_divisible\n        else:\n            # If not divisible by k, just subtract to reach 1\n            cost += (n - 1) * A\n            n = 1\n            \n    return cost\n\n# Input reading\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\n# Calculate and print the minimum cost\nprint(min_cost_to_reduce_to_one(n, k, A, B))"}
{"solution": "def prime_factors(n):\n    factors = {}\n    d = 2\n    while d * d <= n:\n        while (n % d) == 0:\n            if d in factors:\n                factors[d] += 1\n            else:\n                factors[d] = 1\n            n //= d\n        d += 1\n    if n > 1:\n        factors[n] = 1\n    return factors\n\ndef min_value_and_operations(n):\n    factors = prime_factors(n)\n    min_value = 1\n    operations = 0\n    \n    for prime, exponent in factors.items():\n        if exponent % 2 == 0:\n            operations += exponent // 2\n        else:\n            operations += (exponent // 2) + 1\n            min_value *= prime\n            \n    return min_value, operations\n\n# Input\nn = int(input())\nresult = min_value_and_operations(n)\nprint(result[0], result[1])"}
{"solution": "def max_score(N, K, R, S, P, T):\n    # Initialize a DP table to store the maximum scores\n    dp = [[0] * 3 for _ in range(N + 1)]\n    \n    # Mapping for hands to indices\n    hand_index = {'r': 0, 's': 1, 'p': 2}\n    scores = [R, S, P]\n    \n    for i in range(1, N + 1):\n        for j in range(3):\n            # Determine the machine's move\n            machine_move = T[i - 1]\n            machine_index = hand_index[machine_move]\n            \n            # Calculate the score for the current move\n            current_score = 0\n            if j == 0 and machine_index == 1:  # Rock vs Scissors\n                current_score = R\n            elif j == 1 and machine_index == 2:  # Scissors vs Paper\n                current_score = S\n            elif j == 2 and machine_index == 0:  # Paper vs Rock\n                current_score = P\n            \n            # Update the DP table\n            dp[i][j] = current_score + max(dp[i - 1][(j + 1) % 3], dp[i - 1][(j + 2) % 3])\n            \n            # If we are past the K rounds, we need to consider the restriction\n            if i > K:\n                dp[i][j] = max(dp[i][j], current_score + max(dp[i - K][(j + 1) % 3], dp[i - K][(j + 2) % 3]))\n    \n    # The answer is the maximum score we can achieve in the last round\n    return max(dp[N])\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN, K = map(int, data[0].split())\nR, S, P = map(int, data[1].split())\nT = data[2].strip()\n\n# Calculate and print the maximum score\nprint(max_score(N, K, R, S, P, T))"}
{"solution": "def longest_good_string(a, b, c):\n    # Use as many \"ab\" as possible\n    total_length = c * 2\n    \n    # After using \"ab\", we need to balance the remaining \"a\" and \"b\"\n    remaining_a = a\n    remaining_b = b\n    \n    # We can use one more \"a\" or \"b\" after each \"ab\"\n    if remaining_a > remaining_b:\n        total_length += remaining_b * 2 + (1 if remaining_a - remaining_b > 0 else 0)\n    else:\n        total_length += remaining_a * 2 + (1 if remaining_b - remaining_a > 0 else 0)\n    \n    return total_length\n\n# Input reading\na, b, c = map(int, input().split())\n# Output the result\nprint(longest_good_string(a, b, c))"}
{"solution": "def vova_marks(n, k, p, x, y, current_marks):\n    # Calculate the current sum of marks\n    current_sum = sum(current_marks)\n    remaining_tests = n - k\n    required_median_count = (n // 2) + 1  # Since n is odd, this is the position of the median\n\n    # Count how many marks are >= y in the current marks\n    count_y_or_more = sum(1 for mark in current_marks if mark >= y)\n\n    # Calculate how many more marks we need to ensure the median is at least y\n    needed_y_marks = max(0, required_median_count - count_y_or_more)\n\n    # If we need more marks than we have remaining tests, it's impossible\n    if needed_y_marks > remaining_tests:\n        return -1\n\n    # Calculate the maximum sum we can have with the remaining tests\n    max_possible_sum = current_sum + remaining_tests * p\n\n    # If the maximum possible sum exceeds x, we need to adjust\n    if max_possible_sum > x:\n        # We can only use marks that keep the total sum <= x\n        # Calculate how many marks we can use as p\n        max_p_marks = remaining_tests - needed_y_marks\n        \n        # Calculate the sum we can use for the remaining tests\n        if needed_y_marks > 0:\n            # Use y for the needed marks to ensure median\n            marks = [y] * needed_y_marks\n        else:\n            marks = []\n        \n        # Use p for the rest if possible\n        if max_p_marks > 0:\n            marks += [p] * max_p_marks\n        \n        # Calculate the current sum with these marks\n        new_sum = current_sum + sum(marks)\n        \n        # If the new sum exceeds x, we need to adjust\n        if new_sum > x:\n            # We need to reduce the marks\n            excess = new_sum - x\n            # We can reduce the marks from p to 1\n            for i in range(len(marks)):\n                if marks[i] == p:\n                    # Calculate how much we can reduce\n                    reduction = min(excess, p - 1)\n                    marks[i] -= reduction\n                    excess -= reduction\n                    if excess <= 0:\n                        break\n        \n        # Check if we still meet the conditions\n        if sum(marks) + current_sum > x:\n            return -1\n        \n        # Ensure we have enough marks to maintain the median\n        if len(marks) < remaining_tests:\n            marks += [1] * (remaining_tests - len(marks))\n        \n        # Final check for the median\n        final_marks = current_marks + marks\n        final_marks.sort()\n        if final_marks[(n // 2)] < y:\n            return -1\n        \n        return marks\n    else:\n        # If the maximum possible sum is within the limit, we can just fill with p\n        marks = [p] * remaining_tests\n        # Ensure we have enough marks to maintain the median\n        if needed_y_marks > 0:\n            marks[:needed_y_marks] = [y] * needed_y_marks\n        \n        return marks\n\n# Read input\nn, k, p, x, y = map(int, input().split())\ncurrent_marks = list(map(int, input().split()))\n\n# Get the result\nresult = vova_marks(n, k, p, x, y, current_marks)\n\n# Print the output\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def is_berlanese(s):\n    vowels = {'a', 'o', 'u', 'i', 'e'}\n    length = len(s)\n    \n    for i in range(length):\n        if s[i] not in vowels and s[i] != 'n':  # If it's a consonant\n            if i + 1 >= length or s[i + 1] not in vowels:  # Check next character\n                return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nword = input().strip()\n# Print the result\nprint(is_berlanese(word))"}
{"solution": "def can_place(domino, vertex_dots):\n    a, b = domino\n    # Check if we can place this domino on the vertices\n    if vertex_dots[0] is None or vertex_dots[0] == a:\n        if vertex_dots[1] is None or vertex_dots[1] == b:\n            return True\n    return False\n\ndef place_domino(domino, vertex_dots):\n    a, b = domino\n    vertex_dots[0] = a\n    vertex_dots[1] = b\n\ndef remove_domino(vertex_dots):\n    vertex_dots[0] = None\n    vertex_dots[1] = None\n\ndef backtrack(edges, dominoes, index, vertex_dots):\n    if index == len(edges):\n        return 0\n    \n    u, v = edges[index]\n    max_count = backtrack(edges, dominoes, index + 1, vertex_dots)  # Skip this edge\n    \n    for domino in dominoes:\n        if can_place(domino, (vertex_dots[u-1], vertex_dots[v-1])):\n            place_domino(domino, (vertex_dots[u-1], vertex_dots[v-1]))\n            count = 1 + backtrack(edges, dominoes, index + 1, vertex_dots)\n            max_count = max(max_count, count)\n            remove_domino((vertex_dots[u-1], vertex_dots[v-1]))\n    \n    return max_count\n\ndef max_dominoes(n, edges):\n    dominoes = [(i, j) for i in range(1, 7) for j in range(i, 7)]\n    vertex_dots = [None] * n  # None means no domino half directed towards this vertex\n    return backtrack(edges, dominoes, 0, vertex_dots)\n\n# Input reading\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output the result\nprint(max_dominoes(n, edges))"}
{"solution": "def max_points(n, m, prices, auction_indices):\n    auction_prices = [prices[i - 1] for i in auction_indices]\n    regular_prices = [prices[i] for i in range(n) if (i + 1) not in auction_indices]\n\n    # Sort auction prices in descending order\n    auction_prices.sort(reverse=True)\n    # Sort regular prices in descending order\n    regular_prices.sort(reverse=True)\n\n    # Start with the total points from regular questions\n    total_points = sum(regular_prices)\n\n    # Initialize current points to the sum of regular questions\n    current_points = total_points\n\n    # For each auction question, we can set the price to the current points\n    for price in auction_prices:\n        if current_points > price:\n            # We can set the auction price to current_points\n            total_points += current_points\n            current_points += current_points  # Correct answer adds the price\n        else:\n            # If we can't set the price, we just answer it normally\n            total_points += price\n            current_points += price  # Correct answer adds the price\n\n    return total_points\n\n# Read input\nn, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauction_indices = list(map(int, input().split()))\n\n# Calculate and print the maximum points\nresult = max_points(n, m, prices, auction_indices)\nprint(result)"}
{"solution": "# Read input values\nsubmission_times = list(map(int, input().split()))\nwrong_submissions = list(map(int, input().split()))\nsuccessful_hacks, unsuccessful_hacks = map(int, input().split())\n\n# Maximum point values for each problem\nmax_points = [500, 1000, 1500, 2000, 2500]\n\n# Calculate total score from problems\ntotal_score = 0\nfor i in range(5):\n    x = max_points[i]\n    m = submission_times[i]\n    w = wrong_submissions[i]\n    \n    score_i = max(0.3 * x, (1 - m / 250) * x - 50 * w)\n    total_score += score_i\n\n# Calculate final score\nfinal_score = int(total_score + 100 * successful_hacks - 50 * unsuccessful_hacks)\n\n# Print the final score\nprint(final_score)"}
{"solution": "def mod_exp(base, exp, mod):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return result\n\ndef count_valid_grids(n, m, L, R):\n    MOD = 998244353\n    \n    S_min = n * m * L\n    S_max = n * m * R\n    \n    # Check parities\n    if (S_min % 2) != (S_max % 2):\n        return 0  # Different parities, no valid configurations\n    \n    # Calculate the number of configurations\n    num_choices = R - L + 1\n    total_configurations = mod_exp(num_choices, n * m, MOD)\n    \n    return total_configurations\n\n# Read input\nn, m, L, R = map(int, input().split())\n# Output the result\nprint(count_valid_grids(n, m, L, R))"}
{"solution": "def is_increasing(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n    \n    # Check rows\n    for i in range(n):\n        for j in range(1, m):\n            if matrix[i][j] <= matrix[i][j - 1]:\n                return False\n    \n    # Check columns\n    for j in range(m):\n        for i in range(1, n):\n            if matrix[i][j] <= matrix[i - 1][j]:\n                return False\n    \n    return True\n\ndef can_make_increasing(n, m, A, B):\n    for i in range(n):\n        for j in range(m):\n            # Check if we can make both matrices increasing by considering both options\n            a1, a2 = A[i][j], B[i][j]\n            if not (a1 < a2):\n                A[i][j], B[i][j] = a2, a1\n            \n            # Check if both matrices are increasing after the swap\n            if not (is_increasing(A) and is_increasing(B)):\n                return \"Impossible\"\n    \n    return \"Possible\"\n\n# Read input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nB = [list(map(int, input().split())) for _ in range(n)]\n\n# Determine if it's possible to make both matrices increasing\nresult = can_make_increasing(n, m, A, B)\nprint(result)"}
{"solution": "def max_length_distinct_occurrences(n, a):\n    # Sort the occurrences in descending order\n    a.sort(reverse=True)\n    \n    # Initialize variables\n    max_length = 0\n    last_count = float('inf')\n    \n    for count in a:\n        # We need to ensure that the current count is distinct and does not exceed the last assigned count\n        if count >= last_count:\n            last_count -= 1\n        else:\n            last_count = count\n        \n        # If last_count goes below 0, we can't assign any more distinct counts\n        if last_count < 0:\n            break\n        \n        max_length += last_count\n    \n    return max_length\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_length_distinct_occurrences(n, a))"}
{"solution": "def min_problems_to_solve(n, k, difficulties):\n    # Sort the difficulties in ascending order\n    difficulties.sort()\n    \n    # Initialize the count of additional problems to solve\n    additional_problems = 0\n    \n    # Iterate through the sorted difficulties\n    for difficulty in difficulties:\n        # Check if the current maximum difficulty k is sufficient to solve the problem\n        while k < difficulty / 2:\n            # If not, we need to solve an additional problem\n            additional_problems += 1\n            # Increase k to the maximum difficulty we can solve, which is double the current k\n            k *= 2\n        \n        # After ensuring we can solve the current problem, update k\n        k = max(k, difficulty)\n    \n    return additional_problems\n\n# Read input\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Get the result\nresult = min_problems_to_solve(n, k, difficulties)\n\n# Print the output\nprint(result)"}
{"solution": "def distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3):\n    # Start by allocating the minimum required diplomas\n    d1 = min_1\n    d2 = min_2\n    d3 = min_3\n    \n    # Calculate the remaining diplomas to distribute\n    remaining = n - (d1 + d2 + d3)\n    \n    # Try to maximize the first degree diplomas\n    if remaining > 0:\n        additional_d1 = min(max_1 - d1, remaining)\n        d1 += additional_d1\n        remaining -= additional_d1\n    \n    # Try to maximize the second degree diplomas\n    if remaining > 0:\n        additional_d2 = min(max_2 - d2, remaining)\n        d2 += additional_d2\n        remaining -= additional_d2\n    \n    # The rest goes to the third degree diplomas\n    if remaining > 0:\n        additional_d3 = min(max_3 - d3, remaining)\n        d3 += additional_d3\n        remaining -= additional_d3\n    \n    # Output the result\n    return d1, d2, d3\n\n# Read input\nn = int(input().strip())\nmin_1, max_1 = map(int, input().strip().split())\nmin_2, max_2 = map(int, input().strip().split())\nmin_3, max_3 = map(int, input().strip().split())\n\n# Get the distribution\nresult = distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3)\n\n# Print the result\nprint(result[0], result[1], result[2])"}
{"solution": "def predict_moon_size(n, sizes):\n    last_size = sizes[-1]\n    \n    if n == 1:\n        return -1  # Cannot determine with only one observation\n    \n    if last_size == 15:\n        return \"DOWN\"\n    elif last_size == 0:\n        return \"UP\"\n    else:\n        previous_size = sizes[-2]\n        if previous_size < last_size:\n            return \"UP\"\n        elif previous_size > last_size:\n            return \"DOWN\"\n        else:\n            return -1  # Previous size is equal to last size\n\n# Read input\nn = int(input())\nsizes = list(map(int, input().split()))\nresult = predict_moon_size(n, sizes)\nprint(result)"}
{"solution": "def can_transform(s, t):\n    if len(s) != len(t):\n        return \"No\"\n    \n    vowels = set('aeiou')\n    \n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels) != (char_t in vowels):\n            return \"No\"\n    \n    return \"Yes\"\n\n# Input reading\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(can_transform(s, t))"}
{"solution": "def determine_winner(board):\n    # Calculate the minimum moves for player A (white pawns) to reach row 1\n    min_moves_A = float('inf')\n    for c in range(8):\n        for r in range(8):\n            if board[r][c] == 'W':\n                # Calculate how many empty cells are above this pawn\n                moves = r\n                min_moves_A = min(min_moves_A, moves)\n\n    # Calculate the minimum moves for player B (black pawns) to reach row 8\n    min_moves_B = float('inf')\n    for c in range(8):\n        for r in range(7, -1, -1):\n            if board[r][c] == 'B':\n                # Calculate how many empty cells are below this pawn\n                moves = 7 - r\n                min_moves_B = min(min_moves_B, moves)\n\n    # Determine the winner based on the minimum moves\n    if min_moves_A <= min_moves_B:\n        return 'A'\n    else:\n        return 'B'\n\n# Read the board input\nboard = [input().strip() for _ in range(8)]\n\n# Determine and print the winner\nprint(determine_winner(board))"}
{"solution": "def calculate_possible_sums(arr):\n    n = len(arr)\n    possible_sums = set()\n    \n    # Calculate all possible sums of contiguous subsegments\n    for start in range(n):\n        current_sum = 0\n        for end in range(start, n):\n            current_sum += arr[end]\n            possible_sums.add(current_sum)\n    \n    return possible_sums\n\ndef max_equal_length(n, A, m, B):\n    # Calculate possible sums for both arrays\n    sums_A = calculate_possible_sums(A)\n    sums_B = calculate_possible_sums(B)\n    \n    # Find the intersection of the two sets\n    common_sums = sums_A.intersection(sums_B)\n    \n    # If there are no common sums, return -1\n    if not common_sums:\n        return -1\n    \n    # The maximum length of the resulting arrays is the number of common sums\n    return len(common_sums)\n\n# Input reading\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\n# Get the result\nresult = max_equal_length(n, A, m, B)\n\n# Output the result\nprint(result)"}
{"solution": "def is_problem_from_contest(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    count = 0\n    \n    for friend in friends:\n        occurrences = problem_name.count(friend)\n        if occurrences > 1:\n            return \"NO\"\n        count += occurrences\n    \n    return \"YES\" if count == 1 else \"NO\"\n\n# Read input\nproblem_name = input().strip()\n# Output the result\nprint(is_problem_from_contest(problem_name))"}
{"solution": "def sieve_of_eratosthenes(max_num):\n    is_prime = [True] * (max_num + 1)\n    is_prime[0] = is_prime[1] = False\n    for start in range(2, int(max_num**0.5) + 1):\n        if is_prime[start]:\n            for multiple in range(start*start, max_num + 1, start):\n                is_prime[multiple] = False\n    return is_prime\n\ndef count_primes_in_range(a, b, k):\n    is_prime = sieve_of_eratosthenes(b)\n    prime_count = [0] * (b + 1)\n    \n    for i in range(1, b + 1):\n        prime_count[i] = prime_count[i - 1] + (1 if is_prime[i] else 0)\n    \n    def has_at_least_k_primes(l):\n        for start in range(a, b - l + 2):  # b - l + 1 + 1 for inclusive range\n            end = start + l - 1\n            if prime_count[end] - prime_count[start - 1] < k:\n                return False\n        return True\n    \n    left, right = 1, b - a + 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if has_at_least_k_primes(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\n# Input reading\na, b, k = map(int, input().strip().split())\nprint(count_primes_in_range(a, b, k))"}
{"solution": "def min_spacing(a, h, w):\n    min_x = float('inf')\n    found = False\n    \n    for m in range(1, h // a + 1):\n        # Calculate the maximum x for this m\n        max_x_h = (h - m * a) / (m + 1)\n        \n        # Now we need to find valid n\n        for n in range(1, w // a + 1):\n            # Calculate the maximum x for this n\n            max_x_w = (w - n * a) / (n + 1)\n            \n            # The valid x must be the minimum of both constraints\n            x = min(max_x_h, max_x_w)\n            \n            if x >= 0:\n                found = True\n                min_x = min(min_x, x)\n    \n    return min_x if found else -1\n\n# Read input\na, h, w = map(int, input().split())\nresult = min_spacing(a, h, w)\nprint(f\"{result:.6f}\")"}
{"solution": "# Read the number of chapters\nn = int(input().strip())\n\n# Initialize a list to store the chapters\nchapters = []\n\n# Read each chapter's page range\nfor _ in range(n):\n    l, r = map(int, input().strip().split())\n    chapters.append((l, r))\n\n# Read the marked page\nk = int(input().strip())\n\n# Initialize a counter for unread chapters\nunread_count = 0\n\n# Check each chapter\nfor l, r in chapters:\n    if l >= k or (l < k <= r):\n        unread_count += 1\n\n# Output the number of unread chapters\nprint(unread_count)"}
{"solution": "def can_form_codeforces(banner):\n    target = \"CODEFORCES\"\n    n = len(banner)\n    \n    if n < len(target):\n        return \"NO\"\n    \n    for i in range(len(target) + 1):\n        # First i characters from the start and (10 - i) characters from the end\n        start_part = banner[:i]\n        end_part = banner[n - (len(target) - i):]\n        \n        if start_part + end_part == target:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nbanner = input().strip()\n# Print the result\nprint(can_form_codeforces(banner))"}
{"solution": "def min_weight_triangulation(n):\n    # Create a DP table initialized to infinity\n    dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    \n    # Base case: Triangles\n    for i in range(1, n - 1):\n        dp[i][i + 2] = i * (i + 1) * (i + 2)\n    \n    # Fill the DP table\n    for length in range(3, n + 1):  # length of the polygon\n        for i in range(1, n - length + 2):  # starting vertex\n            j = i + length - 1  # ending vertex\n            for k in range(i + 1, j):  # possible k vertices\n                weight = dp[i][k] + dp[k][j] + i * j * k\n                dp[i][j] = min(dp[i][j], weight)\n    \n    return dp[1][n]\n\n# Read input\nn = int(input())\n# Calculate and print the minimum weight triangulation\nprint(min_weight_triangulation(n))"}
{"solution": "def count_digits(n):\n    total_digits = 0\n    digit_length = 1\n    current_limit = 9\n    \n    while n > current_limit:\n        total_digits += digit_length * (current_limit - (10**(digit_length - 1) - 1))\n        digit_length += 1\n        current_limit = current_limit * 10 + 9  # Move to the next range\n    \n    # For the last range\n    total_digits += digit_length * (n - (10**(digit_length - 1) - 1))\n    \n    return total_digits\n\n# Input\nn = int(input())\n# Output\nprint(count_digits(n))"}
{"solution": "def find_winning_color(n, A, colors):\n    from collections import defaultdict\n    \n    # Count occurrences of each color\n    color_count = defaultdict(int)\n    for color in colors:\n        color_count[color] += 1\n    \n    # We need to check each color that is not A\n    for B in color_count:\n        if B == A:\n            continue\n        \n        cnt_A = 0\n        cnt_B = 0\n        can_win = True\n        \n        for color in colors:\n            if color == A:\n                cnt_A += 1\n            elif color == B:\n                cnt_B += 1\n            \n            # Check the winning condition\n            if cnt_A > cnt_B:\n                can_win = False\n                break\n        \n        if can_win:\n            return B\n    \n    return -1\n\n# Read input\nn, A = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Get the result\nresult = find_winning_color(n, A, colors)\n\n# Print the result\nprint(result)"}
{"solution": "def check_crossword(n, x, a):\n    total_segments_length = sum(a)\n    required_length = total_segments_length + (n - 1)\n    \n    if required_length == x:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input values\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(check_crossword(n, x, a))"}
{"solution": "def min_coins(n, S):\n    return (S + n - 1) // n\n\n# Read input\nn, S = map(int, input().split())\n# Calculate and print the result\nprint(min_coins(n, S))"}
{"solution": "def smallest_palindrome(s):\n    from collections import Counter\n\n    # Count the frequency of each character\n    freq = Counter(s)\n    \n    # Prepare to build the first half of the palindrome\n    half_palindrome = []\n    odd_char = None\n    \n    # Create the first half of the palindrome\n    for char in sorted(freq.keys()):  # Sort to ensure lexicographical order\n        count = freq[char]\n        if count % 2 == 1:\n            if odd_char is None or char < odd_char:\n                if odd_char is not None:\n                    half_palindrome.append(odd_char)  # Add previous odd character\n                odd_char = char  # Update to the new odd character\n            else:\n                half_palindrome.append(char)  # Add current odd character\n        half_palindrome.extend([char] * (count // 2))  # Add half of the even counts\n\n    # Construct the palindrome\n    first_half = ''.join(half_palindrome)\n    second_half = first_half[::-1]  # Mirror the first half\n    palindrome = first_half + (odd_char if odd_char else '') + second_half\n\n    return palindrome\n\n# Read input\ns = input().strip()\n# Get the result\nresult = smallest_palindrome(s)\n# Print the result\nprint(result)"}
{"solution": "def calculate_chess_weights(board):\n    piece_weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1, 'K': 0,\n        'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1, 'k': 0\n    }\n    \n    white_weight = 0\n    black_weight = 0\n    \n    for row in board:\n        for piece in row:\n            if piece in piece_weights:\n                if piece.isupper():  # White pieces\n                    white_weight += piece_weights[piece]\n                else:  # Black pieces\n                    black_weight += piece_weights[piece]\n    \n    if white_weight > black_weight:\n        return \"White\"\n    elif black_weight > white_weight:\n        return \"Black\"\n    else:\n        return \"Draw\"\n\n# Read the chess board input\nboard = [input().strip() for _ in range(8)]\nresult = calculate_chess_weights(board)\nprint(result)"}
{"solution": "from collections import deque\n\ndef find_sequence(N, M, S):\n    # BFS initialization\n    queue = deque([0])\n    moves = [float('inf')] * (N + 1)\n    parent = [-1] * (N + 1)\n    step_taken = [-1] * (N + 1)\n    moves[0] = 0\n    \n    while queue:\n        current = queue.popleft()\n        \n        for step in range(1, M + 1):\n            next_square = current + step\n            if next_square > N:\n                break  # No need to check further, as we exceed N\n            if S[next_square] == '1':\n                continue  # Game Over Square\n            \n            if moves[next_square] > moves[current] + 1:\n                moves[next_square] = moves[current] + 1\n                parent[next_square] = current\n                step_taken[next_square] = step\n                queue.append(next_square)\n            elif moves[next_square] == moves[current] + 1:\n                # Check if we can update the parent for lexicographical order\n                if parent[next_square] == -1 or current < parent[next_square]:\n                    parent[next_square] = current\n                    step_taken[next_square] = min(step_taken[next_square], step) if step_taken[next_square] != -1 else step\n\n    # If we cannot reach square N\n    if moves[N] == float('inf'):\n        return -1\n    \n    # Reconstruct the path\n    sequence = []\n    current = N\n    while current != 0:\n        sequence.append(step_taken[current])\n        current = parent[current]\n    \n    sequence.reverse()  # Reverse to get the correct order\n    return ' '.join(map(str, sequence))\n\n# Input reading\nN, M = map(int, input().split())\nS = input().strip()\n\n# Find and print the sequence\nresult = find_sequence(N, M, S)\nprint(result)"}
{"solution": "def can_reach_goal(K, X, Y):\n    # Calculate the Manhattan distance to the target\n    manhattan_distance = abs(X) + abs(Y)\n    \n    # Check if the target can be reached\n    if manhattan_distance % K != 0 or manhattan_distance < K:\n        return -1\n    \n    # Calculate the number of strokes needed\n    strokes = manhattan_distance // K\n    \n    # If the number of strokes is odd and the distance is even or vice versa, we need to adjust\n    if (strokes % 2) != (manhattan_distance % K == 0):\n        strokes += 1\n    \n    # Prepare the path\n    path = []\n    current_x, current_y = 0, 0\n    \n    for _ in range(strokes):\n        # Calculate the next point\n        if abs(current_x) + abs(current_y) < manhattan_distance:\n            # Move towards the target\n            if abs(X - current_x) >= K:\n                next_x = current_x + (K if X > current_x else -K)\n                next_y = current_y\n            else:\n                next_x = X\n                next_y = current_y + (K if Y > current_y else -K)\n        else:\n            # Move in a direction that maintains the distance K\n            if current_x < X:\n                next_x = current_x + K\n            elif current_x > X:\n                next_x = current_x - K\n            else:\n                next_x = current_x\n            \n            if current_y < Y:\n                next_y = current_y + K\n            elif current_y > Y:\n                next_y = current_y - K\n            else:\n                next_y = current_y\n        \n        path.append((next_x, next_y))\n        current_x, current_y = next_x, next_y\n    \n    return strokes, path\n\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split()\nK = int(data[0])\nX = int(data[1])\nY = int(data[2])\n\nresult = can_reach_goal(K, X, Y)\n\nif result == -1:\n    print(-1)\nelse:\n    strokes, path = result\n    print(strokes)\n    for x, y in path:\n        print(x, y)"}
{"solution": "def find_smallest_n(m):\n    # To store the smallest n found\n    smallest_n = float('inf')\n    \n    # Iterate over possible values of k starting from 2\n    for k in range(2, int((m * 4) ** 0.25) + 2):\n        # Calculate the maximum x for this k\n        # We need to find the number of valid x values\n        count = 0\n        # The maximum x that can be taken by the first thief\n        max_x = (m * (k**4 - 1)) // (k - 1)\n        \n        # Iterate over possible values of x\n        for x in range(1, max_x + 1):\n            # Calculate the total chocolates taken\n            total_chocolates = x * (1 + k + k**2 + k**3)\n            if total_chocolates > 0 and total_chocolates <= max_x:\n                count += 1\n        \n        # If the count of ways matches m, update smallest_n\n        if count == m:\n            smallest_n = min(smallest_n, total_chocolates)\n    \n    # If we found a valid n, return it; otherwise, return -1\n    return smallest_n if smallest_n != float('inf') else -1\n\n# Read input\nm = int(input().strip())\n# Get the result\nresult = find_smallest_n(m)\n# Print the result\nprint(result)"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    # Calculate the distance between the centers of the circles\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\n    # No intersection\n    if d >= r1 + r2:\n        return 0.0\n    # One circle is completely inside the other\n    elif d <= abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n    else:\n        # Calculate the area of intersection\n        r1_sq = r1 ** 2\n        r2_sq = r2 ** 2\n        \n        # Calculate the angles for the circular segments\n        angle1 = 2 * math.acos((d ** 2 + r1_sq - r2_sq) / (2 * d * r1))\n        angle2 = 2 * math.acos((d ** 2 + r2_sq - r1_sq) / (2 * d * r2))\n        \n        # Calculate the area of the circular segments\n        area1 = 0.5 * r1_sq * (angle1 - math.sin(angle1))\n        area2 = 0.5 * r2_sq * (angle2 - math.sin(angle2))\n        \n        return area1 + area2\n\n# Input reading\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\n# Calculate and print the area of intersection\narea = circle_intersection_area(x1, y1, r1, x2, y2, r2)\nprint(f\"{area:.12f}\")"}
{"solution": "def minimize_n(v):\n    return 1\n\nif __name__ == \"__main__\":\n    v = int(input().strip())\n    print(minimize_n(v))"}
{"solution": "def main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    p = list(map(int, data[1:n]))\n    a = list(map(int, data[n:2*n]))\n    \n    # Build the tree\n    tree = defaultdict(list)\n    for i in range(2, n + 1):\n        tree[p[i - 2]].append(i)\n    \n    # To store the maximum citizens caught\n    max_caught = 0\n    \n    def dfs(node):\n        nonlocal max_caught\n        total_citizens = a[node - 1]  # citizens in the current node\n        children_citizens = []\n        \n        for child in tree[node]:\n            child_citizens = dfs(child)\n            children_citizens.append(child_citizens)\n            total_citizens += child_citizens\n        \n        if children_citizens:\n            # The bandit will go to the child with the maximum citizens\n            max_caught += max(children_citizens)\n        \n        return total_citizens\n    \n    dfs(1)\n    \n    # Add the citizens in the main square (node 1)\n    max_caught += a[0]\n    \n    print(max_caught)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_possible_words(n, S, T):\n    # Initialize a set to store the distinct possible words W\n    possible_words = set()\n\n    # Iterate through the length of the words\n    for i in range(n):\n        # Create a word W by inserting a character from S at position i\n        W_from_S = S[:i] + T[i] + S[i:]\n        possible_words.add(W_from_S)\n\n        # Create a word W by inserting a character from T at position i\n        W_from_T = T[:i] + S[i] + T[i:]\n        possible_words.add(W_from_T)\n\n    # Check the last character insertion\n    W_from_S_last = S + T[-1]\n    possible_words.add(W_from_S_last)\n\n    W_from_T_last = T + S[-1]\n    possible_words.add(W_from_T_last)\n\n    # Return the number of distinct words W\n    return len(possible_words)\n\n# Read input\nn = int(input().strip())\nS = input().strip()\nT = input().strip()\n\n# Get the result and print it\nresult = count_possible_words(n, S, T)\nprint(result)"}
{"solution": "def min_computer_strength(n, strengths, connections):\n    from collections import defaultdict, deque\n\n    # Create an adjacency list for the banks\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Initialize the maximum strength needed\n    max_strength = max(strengths)\n\n    # BFS to determine the minimum strength required\n    visited = [False] * (n + 1)\n    queue = deque()\n    \n    # Start from the bank with the maximum strength\n    for i in range(1, n + 1):\n        if strengths[i - 1] == max_strength:\n            queue.append(i)\n            visited[i] = True\n\n    # Perform BFS\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n\n    # The minimum strength required is the maximum strength of the banks\n    return max_strength\n\n# Read input\nn = int(input())\nstrengths = list(map(int, input().split()))\nconnections = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Calculate and print the result\nprint(min_computer_strength(n, strengths, connections))"}
{"solution": "def max_groups(n, m):\n    if m == n:\n        return 0\n    elif m == 0:\n        return 1\n    else:\n        return min(m, n - m) + 1\n\n# Read input\nn, m = map(int, input().split())\n# Print the result\nprint(max_groups(n, m))"}
{"solution": "k, r = map(int, input().split())\n\nn = 1\nwhile True:\n    total_cost = n * k\n    if total_cost % 10 == 0 or total_cost % 10 == r:\n        print(n)\n        break\n    n += 1"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                if i < min_row:\n                    min_row = i\n                if i > max_row:\n                    max_row = i\n                if j < min_col:\n                    min_col = j\n                if j > max_col:\n                    max_col = j\n    \n    # Calculate the dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Count the number of 'X' characters in the bounding box\n    count_x = 0\n    for i in range(min_row, max_row + 1):\n        for j in range(min_col, max_col + 1):\n            if grid[i][j] == 'X':\n                count_x += 1\n    \n    # Check if the number of 'X' characters matches the area of the bounding box\n    if count_x == height * width:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "def min_segments(points):\n    # Extracting the coordinates\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n    \n    # Check for collinearity\n    if (x1 == x2 == x3) or (y1 == y2 == y3):\n        return 1  # All points are aligned vertically or horizontally\n    \n    # Check if two points are aligned\n    if (x1 == x2 and y1 != y2) or (x1 == x3 and y1 != y3) or (x2 == x3 and y2 != y3):\n        return 2  # Two points are aligned, one is not\n    \n    # If no points are aligned\n    return 3  # All points are distinct and not aligned\n\n# Read input\npoints = [tuple(map(int, input().split())) for _ in range(3)]\n\n# Calculate and print the result\nprint(min_segments(points))"}
{"solution": "def construct_k_regular_graph(k):\n    if k == 1:\n        # For k = 1, we can have a simple edge between two vertices\n        print(\"YES\")\n        print(2, 1)\n        print(1, 2)\n        return\n    \n    if k == 2:\n        # For k = 2, we can create a square (4 vertices) and remove one edge to create a bridge\n        print(\"YES\")\n        print(4, 4)\n        print(1, 2)\n        print(2, 3)\n        print(3, 4)\n        print(4, 1)\n        return\n    \n    if k % 2 == 1:\n        # For odd k >= 3, we can create a cycle of (k + 1) vertices and add edges to ensure k-regularity\n        n = k + 1\n        edges = []\n        for i in range(1, n + 1):\n            edges.append((i, (i % n) + 1))  # Create a cycle\n        for i in range(1, n // 2 + 1):\n            edges.append((i, i + n // 2))  # Connect vertices to ensure k-regularity\n        \n        print(\"YES\")\n        print(n, len(edges))\n        for a, b in edges:\n            print(a, b)\n        return\n    \n    if k % 2 == 0:\n        # For even k >= 4, we can create a cycle of (k + 1) vertices and add edges to ensure k-regularity\n        n = k + 1\n        edges = []\n        for i in range(1, n + 1):\n            edges.append((i, (i % n) + 1))  # Create a cycle\n        for i in range(1, n // 2 + 1):\n            edges.append((i, i + n // 2))  # Connect vertices to ensure k-regularity\n        \n        # Remove one edge to create a bridge\n        edges.pop()  # Remove the last edge to create a bridge\n        \n        print(\"YES\")\n        print(n, len(edges))\n        for a, b in edges:\n            print(a, b)\n        return\n\n# Read input\nk = int(input().strip())\nconstruct_k_regular_graph(k)"}
{"solution": "def count_occurrences(n, m, q, s, t, queries):\n    # Step 1: Preprocess occurrences of t in s\n    occurrences = [0] * (n + 1)\n    \n    for i in range(n - m + 1):\n        if s[i:i + m] == t:\n            occurrences[i + 1] = 1  # Store in 1-based index\n    \n    # Step 2: Create prefix sum array\n    prefix_count = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_count[i] = prefix_count[i - 1] + occurrences[i]\n    \n    # Step 3: Answer each query\n    results = []\n    for l, r in queries:\n        if r - l + 1 < m:\n            results.append(0)  # t cannot fit in this substring\n        else:\n            count = prefix_count[r - m + 1] - prefix_count[l - 1]\n            results.append(count)\n    \n    return results\n\n# Read input\nn, m, q = map(int, input().split())\ns = input().strip()\nt = input().strip()\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get results\nresults = count_occurrences(n, m, q, s, t, queries)\n\n# Print results\nfor result in results:\n    print(result)"}
{"solution": "def count_paths(n, k, d):\n    MOD = 1000000007\n    \n    # dp[i] will store the number of ways to reach weight i\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case\n    \n    # Fill dp array\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if i - j >= 0:\n                dp[i] = (dp[i] + dp[i - j]) % MOD\n    \n    # dp_with_d[i] will store the number of ways to reach weight i with at least one edge >= d\n    dp_with_d = [0] * (n + 1)\n    dp_with_d[0] = 1  # Base case\n    \n    # Fill dp_with_d array\n    for i in range(1, n + 1):\n        for j in range(d, k + 1):\n            if i - j >= 0:\n                dp_with_d[i] = (dp_with_d[i] + dp_with_d[i - j]) % MOD\n    \n    # The result is the total paths minus those without any edge >= d\n    result = (dp[n] - dp_with_d[n]) % MOD\n    return result\n\n# Read input\nn, k, d = map(int, input().split())\n# Print the result\nprint(count_paths(n, k, d))"}
{"solution": "n = int(input().strip())\nrow = input().strip()\n\ngroup_sizes = []\ncurrent_count = 0\n\nfor char in row:\n    if char == 'B':\n        current_count += 1\n    else:\n        if current_count > 0:\n            group_sizes.append(current_count)\n            current_count = 0\n\n# If the last character(s) were 'B', we need to add the last group\nif current_count > 0:\n    group_sizes.append(current_count)\n\nprint(len(group_sizes))\nif group_sizes:\n    print(' '.join(map(str, group_sizes)))"}
{"solution": "def polycarps_editor(n, m, p, brackets, operations):\n    # Convert the cursor position from 1-based to 0-based\n    cursor = p - 1\n    \n    # Stack to find matching brackets\n    stack = []\n    pairs = {}\n    \n    # Create pairs of brackets\n    for i in range(n):\n        if brackets[i] == '(':\n            stack.append(i)\n        else:\n            opening_index = stack.pop()\n            pairs[opening_index] = i\n            pairs[i] = opening_index\n    \n    # Convert brackets to a list for mutability\n    brackets = list(brackets)\n    \n    for operation in operations:\n        if operation == 'L':\n            cursor -= 1\n        elif operation == 'R':\n            cursor += 1\n        elif operation == 'D':\n            # Get the matching bracket index\n            matching_index = pairs[cursor]\n            # Determine the range to delete\n            start = min(cursor, matching_index)\n            end = max(cursor, matching_index)\n            # Delete the brackets in the range\n            for i in range(start, end + 1):\n                brackets[i] = ''\n            # Move cursor to the nearest right bracket or left if none\n            if end + 1 < n and brackets[end + 1] != '':\n                cursor = end + 1\n            else:\n                cursor = start - 1\n                while cursor >= 0 and brackets[cursor] == '':\n                    cursor -= 1\n    \n    # Join the remaining brackets and print the result\n    result = ''.join(filter(lambda x: x != '', brackets))\n    print(result)\n\n# Read input\nn, m, p = map(int, input().split())\nbrackets = input().strip()\noperations = input().strip()\n\n# Call the function\npolycarps_editor(n, m, p, brackets, operations)"}
{"solution": "def find_y(n, queries):\n    low = -2000000000\n    high = 2000000000\n    \n    for query in queries:\n        sign, x, answer = query.split()\n        x = int(x)\n        \n        if sign == '>':\n            if answer == 'Y':\n                low = max(low, x + 1)\n            else:\n                high = min(high, x)\n        elif sign == '<':\n            if answer == 'Y':\n                high = min(high, x)\n            else:\n                low = max(low, x + 1)\n        elif sign == '>=':\n            if answer == 'Y':\n                low = max(low, x)\n            else:\n                high = min(high, x - 1)\n        elif sign == '<=':\n            if answer == 'Y':\n                high = min(high, x)\n            else:\n                low = max(low, x + 1)\n    \n    if low <= high:\n        return low  # or any number in the range [low, high]\n    else:\n        return \"Impossible\"\n\n# Read input\nn = int(input())\nqueries = [input().strip() for _ in range(n)]\n\n# Get the result\nresult = find_y(n, queries)\n\n# Print the result\nprint(result)"}
{"solution": "def count_periods(a, b):\n    total_length = a + b\n    count = 0\n    \n    # Iterate through all possible periods\n    for k in range(1, total_length + 1):\n        if total_length % k == 0:  # k must be a divisor of total_length\n            m = total_length // k  # number of segments\n            # Check if we can fill the segments with 'A's and 'B's\n            if (a + m - 1) // m <= k and (b + m - 1) // m <= k:\n                count += 1\n                \n    return count\n\n# Read input\na, b = map(int, input().split())\n# Calculate and print the number of different periods\nprint(count_periods(a, b))"}
{"solution": "def generate_soldier_names(n, k, effectiveness):\n    names = [\"\"] * n\n    unique_names = [\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\", \"Frank\", \"Grace\", \"Hannah\", \"Ivy\", \"Jack\"]\n    \n    for i in range(n):\n        if i < k:\n            # Fill the first k names\n            names[i] = unique_names[i % len(unique_names)]\n        else:\n            # Check the effectiveness of the previous k groups\n            if effectiveness[i - k] == \"YES\":\n                # If the previous group was effective, we need to ensure uniqueness\n                names[i] = unique_names[(i % len(unique_names))]\n            else:\n                # If the previous group was not effective, we need to repeat one of the names\n                names[i] = names[i - 1]  # Repeat the last name\n\n    # Adjust names to ensure all conditions are met\n    for i in range(n - k + 1):\n        if effectiveness[i] == \"NO\":\n            # Ensure that at least one name is repeated in this segment\n            for j in range(i, i + k):\n                if names[j] == names[i]:\n                    break\n            else:\n                # If no name was repeated, repeat the first name in this segment\n                names[i] = names[i + 1]\n\n    return names\n\n# Read input\nn, k = map(int, input().split())\neffectiveness = input().split()\n\n# Generate soldier names\nsoldier_names = generate_soldier_names(n, k, effectiveness)\n\n# Print the result\nprint(\" \".join(soldier_names))"}
{"solution": "def min_operations_to_equal(a, b):\n    def factor_out(n):\n        count_2 = count_3 = count_5 = 0\n        while n % 2 == 0:\n            n //= 2\n            count_2 += 1\n        while n % 3 == 0:\n            n //= 3\n            count_3 += 1\n        while n % 5 == 0:\n            n //= 5\n            count_5 += 1\n        return n, count_2, count_3, count_5\n\n    core_a, count_2_a, count_3_a, count_5_a = factor_out(a)\n    core_b, count_2_b, count_3_b, count_5_b = factor_out(b)\n\n    if core_a != core_b:\n        return -1\n\n    # Calculate the number of operations needed\n    operations = abs(count_2_a - count_2_b) + abs(count_3_a - count_3_b) + abs(count_5_a - count_5_b)\n    return operations\n\n# Read input\na, b = map(int, input().split())\n# Print output\nprint(min_operations_to_equal(a, b))"}
{"solution": "def min_cost_palindrome(n, a, b, suits):\n    total_cost = 0\n    \n    for i in range((n + 1) // 2):\n        left = suits[i]\n        right = suits[n - i - 1]\n        \n        if left == 2 and right == 2:\n            # Both are to be bought, choose the cheaper option for both\n            total_cost += 2 * min(a, b)\n        elif left == 2:\n            # Left is to be bought, match it with right\n            if right == 0:\n                total_cost += a  # Buy white\n            else:\n                total_cost += b  # Buy black\n        elif right == 2:\n            # Right is to be bought, match it with left\n            if left == 0:\n                total_cost += a  # Buy white\n            else:\n                total_cost += b  # Buy black\n        else:\n            # Both are already bought\n            if left != right:\n                return -1  # Cannot form a palindrome\n    \n    return total_cost\n\n# Read input\nn, a, b = map(int, input().split())\nsuits = list(map(int, input().split()))\n\n# Calculate result\nresult = min_cost_palindrome(n, a, b, suits)\n\n# Print output\nprint(result)"}
{"solution": "def paint_cube(k):\n    if k == 1:\n        return -1\n    \n    # Initialize the cube\n    cube = [[['' for _ in range(k)] for _ in range(k)] for _ in range(k)]\n    \n    # Fill the cube based on the checkerboard pattern\n    for z in range(k):\n        for x in range(k):\n            for y in range(k):\n                if (x + y + z) % 2 == 0:\n                    cube[z][x][y] = 'b'\n                else:\n                    cube[z][x][y] = 'w'\n    \n    return cube\n\ndef print_cube(cube):\n    if cube == -1:\n        print(-1)\n        return\n    \n    for z in range(len(cube)):\n        for x in range(len(cube[z])):\n            print(''.join(cube[z][x]))\n        if z < len(cube) - 1:\n            print()  # Print a blank line between layers\n\nk = int(input().strip())\nresult = paint_cube(k)\nprint_cube(result)"}
{"solution": "def largest_lovely_number(n):\n    lovely_number = 1\n    factor = 2\n    \n    # Check for factors from 2 to sqrt(n)\n    while factor * factor <= n:\n        if n % factor == 0:\n            # If factor is a prime factor, include it in the lovely number\n            lovely_number *= factor\n            # Remove all occurrences of this factor from n\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    \n    # If n is still greater than 1, then it is a prime number\n    if n > 1:\n        lovely_number *= n\n    \n    return lovely_number\n\n# Read input\nn = int(input())\n# Print the largest lovely number\nprint(largest_lovely_number(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    # Check for adjacent occupants\n    if '11' in seating:\n        return \"No\"\n    \n    # Check for possible additional seating\n    for i in range(n):\n        if seating[i] == '0':\n            # Check if this '0' can be occupied\n            left_empty = (i == 0 or seating[i - 1] == '0')\n            right_empty = (i == n - 1 or seating[i + 1] == '0')\n            if left_empty and right_empty:\n                return \"No\"\n    \n    return \"Yes\"\n\n# Input reading\nn = int(input())\nseating = input().strip()\nprint(is_maximal_seating(n, seating))"}
{"solution": "def find_possible_lengths(n, a):\n    # Calculate the differences d_i\n    d = [a[i] - a[i - 1] for i in range(1, n + 1)]\n    \n    possible_lengths = []\n    \n    # Check each k from 1 to n\n    for k in range(1, n + 1):\n        valid = True\n        # Check if d_i == d_{i+k} for all valid i\n        for i in range(n - k):\n            if d[i] != d[i + k]:\n                valid = False\n                break\n        if valid:\n            possible_lengths.append(k)\n    \n    return possible_lengths\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Find possible lengths\npossible_lengths = find_possible_lengths(n, a)\n\n# Output the results\nprint(len(possible_lengths))\nprint(\" \".join(map(str, possible_lengths)))"}
{"solution": "from itertools import combinations\n\ndef can_form_equal_teams(scores):\n    total_score = sum(scores)\n    \n    # If total score is odd, we cannot split it into two equal parts\n    if total_score % 2 != 0:\n        return \"NO\"\n    \n    target_score = total_score // 2\n    \n    # Generate all combinations of 3 participants\n    for team1 in combinations(scores, 3):\n        if sum(team1) == target_score:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nscores = list(map(int, input().strip().split()))\n\n# Output the result\nprint(can_form_equal_teams(scores))"}
{"solution": "def count_2_3_integers(l, r):\n    two_three_integers = set()\n    \n    # Generate 2-3-integers\n    x = 0\n    while (2 ** x) <= 2 * 10**9:\n        y = 0\n        while (2 ** x) * (3 ** y) <= 2 * 10**9:\n            two_three_integers.add((2 ** x) * (3 ** y))\n            y += 1\n        x += 1\n    \n    # Convert to sorted list\n    two_three_integers = sorted(two_three_integers)\n    \n    # Count how many are in the range [l, r]\n    count = 0\n    for num in two_three_integers:\n        if l <= num <= r:\n            count += 1\n            \n    return count\n\n# Read input\nl, r = map(int, input().split())\n# Print the result\nprint(count_2_3_integers(l, r))"}
{"solution": "import math\n\ndef candies_eaten(n, k):\n    # Calculate p using the derived formula\n    p = (-3 + math.sqrt(9 + 8 * (n + k))) / 2\n    # Since p must be an integer, we convert it to int\n    p = int(p)\n    # Calculate e\n    e = n - p\n    return e\n\n# Read input\nn, k = map(int, input().split())\n# Output the result\nprint(candies_eaten(n, k))"}
{"solution": "def can_form_triangle(n, lengths):\n    # Sort the lengths\n    lengths.sort()\n    \n    # Check for any three consecutive lengths\n    for i in range(2, n):\n        if lengths[i-2] + lengths[i-1] > lengths[i]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\nlengths = list(map(int, input().split()))\n\n# Output the result\nprint(can_form_triangle(n, lengths))"}
{"solution": "def can_achieve_toys(x, y):\n    # Check if the number of original toys is at least 1\n    if y < 1:\n        return \"No\"\n    \n    # Calculate the number of copies needed after achieving y original toys\n    # After y-1 applications to original toys, we will have y originals and (y-1) copies\n    # We need to check if we can reach exactly x copies from (y-1) copies\n    copies_needed = x - (y - 1)\n    \n    # If copies_needed is negative, it means we have more copies than needed\n    if copies_needed < 0:\n        return \"No\"\n    \n    # Check if we can achieve the required number of copies\n    # We can only generate copies in pairs from the copies we have\n    if copies_needed % 2 == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input\nx, y = map(int, input().split())\n# Print the result\nprint(can_achieve_toys(x, y))"}
{"solution": "def maximize_rating(n, k, skills):\n    # Calculate the initial rating\n    current_rating = sum(skill // 10 for skill in skills)\n    \n    # List to store the number of units needed to reach the next multiple of 10\n    improvements_needed = []\n    \n    for skill in skills:\n        if skill < 100:\n            next_threshold = (skill // 10 + 1) * 10\n            units_needed = next_threshold - skill\n            if units_needed <= 100 - skill:  # Ensure we don't exceed the max skill level\n                improvements_needed.append(units_needed)\n    \n    # Sort the improvements needed in ascending order\n    improvements_needed.sort()\n    \n    # Use the improvement units\n    for units in improvements_needed:\n        if k >= units:\n            k -= units\n            current_rating += 1  # Each improvement to the next threshold increases the rating by 1\n        else:\n            break  # No more units can be used\n    \n    # Return the maximum total rating\n    return current_rating\n\n# Read input\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(maximize_rating(n, k, skills))"}
{"solution": "def smallest_pretty_integer(n, m, list_a, list_b):\n    # Convert lists to sets for easier comparison\n    set_a = set(list_a)\n    set_b = set(list_b)\n\n    # Step 1: Find common digits\n    common_digits = set_a.intersection(set_b)\n    if common_digits:\n        return min(common_digits)\n\n    # Step 2: Find the smallest digits in both lists\n    min_a = min(set_a)\n    min_b = min(set_b)\n\n    # Step 3: Form two-digit numbers and return the smallest\n    return min(int(f\"{min_a}{min_b}\"), int(f\"{min_b}{min_a}\"))\n\n# Input reading\nn, m = map(int, input().split())\nlist_a = list(map(int, input().split()))\nlist_b = list(map(int, input().split()))\n\n# Output the result\nprint(smallest_pretty_integer(n, m, list_a, list_b))"}
{"solution": "def max_problems(n, k):\n    available_time = 240 - k\n    total_time = 0\n    problems_solved = 0\n    \n    for i in range(1, n + 1):\n        time_for_problem = 5 * i\n        if total_time + time_for_problem <= available_time:\n            total_time += time_for_problem\n            problems_solved += 1\n        else:\n            break\n            \n    return problems_solved\n\n# Read input\nn, k = map(int, input().split())\n# Print the result\nprint(max_problems(n, k))"}
{"solution": "def max_teams(n, x, y, pages):\n    # Sort the pages required for each team in ascending order\n    pages.sort()\n    \n    count = 0\n    \n    for a in pages:\n        # Calculate the number of double-sided sheets needed\n        double_sided_needed = a // 2\n        single_sided_needed = a % 2\n        \n        if double_sided_needed <= x:\n            # If we can fulfill the double-sided requirement\n            x -= double_sided_needed\n            if single_sided_needed > 0:\n                # If there's a need for a single-sided sheet\n                if y > 0:\n                    y -= 1\n                else:\n                    break\n        else:\n            # If we don't have enough double-sided sheets\n            remaining_pages = a - 2 * x\n            if remaining_pages > y:\n                break\n            else:\n                y -= remaining_pages\n                x = 0\n        \n        count += 1\n    \n    return count\n\n# Input reading\nn, x, y = map(int, input().split())\npages = list(map(int, input().split()))\n\n# Output the result\nprint(max_teams(n, x, y, pages))"}
{"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1  # i is a divisor\n            if i != n // i:\n                count += 1  # n // i is also a divisor\n    return count\n\n# Read input\nb = int(input().strip())\n# Calculate and print the number of distinct values\nprint(count_divisors(b))"}
{"solution": "def count_falling_positions(n, bumpers):\n    left_fall_count = 0\n    right_fall_count = 0\n    \n    # Count consecutive '<' from the left\n    for i in range(n):\n        if bumpers[i] == '<':\n            left_fall_count += 1\n        else:\n            break\n    \n    # Count consecutive '>' from the right\n    for i in range(n-1, -1, -1):\n        if bumpers[i] == '>':\n            right_fall_count += 1\n        else:\n            break\n    \n    # Total positions that lead to falling off the field\n    return left_fall_count + right_fall_count\n\n# Input reading\nn = int(input())\nbumpers = input().strip()\nprint(count_falling_positions(n, bumpers))"}
{"solution": "def max_rectangle_area(n, lengths):\n    from collections import Counter\n\n    # Count the occurrences of each stick length\n    count = Counter(lengths)\n    \n    # Prepare a list to store pairs of lengths\n    pairs = []\n    \n    # Iterate through the counted lengths\n    for length in sorted(count.keys()):\n        # Calculate how many pairs can be formed with the current length\n        while count[length] >= 2:\n            pairs.append(length)\n            count[length] -= 2\n        \n        # Check if we can form pairs with the length reduced by 1\n        if count[length] == 1 and count[length - 1] >= 1:\n            pairs.append(length - 1)\n            count[length - 1] -= 1\n    \n    # Now we have a list of lengths that can form pairs\n    area = 0\n    for i in range(0, len(pairs) - 1, 2):\n        area += pairs[i] * pairs[i + 1]\n    \n    return area\n\n# Input reading\nn = int(input())\nlengths = list(map(int, input().split()))\n\n# Calculate and print the maximum total area\nprint(max_rectangle_area(n, lengths))"}
{"solution": "def restore_numbers(n, strings):\n    from collections import defaultdict\n\n    # Step 1: Calculate the contribution of each letter\n    contribution = defaultdict(int)\n    leading_letters = set()\n\n    for s in strings:\n        length = len(s)\n        for i, char in enumerate(s):\n            # Calculate the positional value\n            contribution[char] += 10 ** (length - i - 1)\n            # Track leading letters\n            if i == 0:\n                leading_letters.add(char)\n\n    # Step 2: Sort letters by their contribution\n    sorted_letters = sorted(contribution.items(), key=lambda x: -x[1])\n\n    # Step 3: Assign digits to letters\n    letter_to_digit = {}\n    used_digits = set()\n    \n    # Assign digits from 0 to 9\n    for letter, _ in sorted_letters:\n        if letter in leading_letters:\n            # Assign the smallest non-zero digit to leading letters\n            for digit in range(1, 10):\n                if digit not in used_digits:\n                    letter_to_digit[letter] = digit\n                    used_digits.add(digit)\n                    break\n        else:\n            # Assign the smallest available digit\n            for digit in range(10):\n                if digit not in used_digits:\n                    letter_to_digit[letter] = digit\n                    used_digits.add(digit)\n                    break\n\n    # Step 4: Calculate the total sum of restored numbers\n    total_sum = 0\n    for s in strings:\n        number = 0\n        for char in s:\n            number = number * 10 + letter_to_digit[char]\n        total_sum += number\n\n    return total_sum\n\n# Input reading\nn = int(input().strip())\nstrings = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(restore_numbers(n, strings))"}
{"solution": "def max_teams(n, m):\n    return min((n + m) // 3, n, m)\n\n# Read input\nn, m = map(int, input().split())\n# Print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def contains_non_overlapping_AB_BA(s):\n    n = len(s)\n    found_ab = False\n    found_ba = False\n\n    for i in range(n - 1):\n        if s[i:i + 2] == \"AB\":\n            if found_ba and i > last_ba_index + 1:\n                return \"YES\"\n            found_ab = True\n            last_ab_index = i\n        elif s[i:i + 2] == \"BA\":\n            if found_ab and i > last_ab_index + 1:\n                return \"YES\"\n            found_ba = True\n            last_ba_index = i\n\n    return \"NO\"\n\ns = input().strip()\nprint(contains_non_overlapping_AB_BA(s))"}
{"solution": "def monster_eating_sequence(n, a, k, b):\n    from collections import deque\n\n    # Initial queue of monsters\n    queue = deque(a)\n    actions = []\n\n    # Process the final weights\n    for weight in b:\n        # While the current weight in b is not found in the queue\n        while queue and queue[0] < weight:\n            # If the first monster can eat the next one\n            if len(queue) > 1 and queue[0] > queue[1]:\n                actions.append((1, 'R'))  # 1-based index\n                queue[0] += queue[1]\n                queue.popleft()  # Remove the second monster\n            else:\n                # If the first monster cannot eat the next one, check the last\n                if len(queue) > 1 and queue[-1] > queue[-2]:\n                    actions.append((len(queue), 'L'))  # 1-based index\n                    queue[-2] += queue[-1]\n                    queue.pop()  # Remove the last monster\n                else:\n                    return \"NO\"\n\n        # If the first monster matches the current weight in b\n        if queue and queue[0] == weight:\n            queue.popleft()  # Remove the monster from the queue\n        else:\n            return \"NO\"\n\n    # If we successfully matched all weights in b\n    result = [\"YES\"]\n    result.extend(f\"{idx} {direction}\" for idx, direction in actions)\n    return \"\\n\".join(result)\n\n# Input reading\nn = int(input().strip())\na = list(map(int, input().strip().split()))\nk = int(input().strip())\nb = list(map(int, input().strip().split()))\n\n# Get the result\nresult = monster_eating_sequence(n, a, k, b)\n\n# Print the result\nprint(result)"}
{"solution": "def orientation(p, q, r):\n    \"\"\"Return the orientation of the triplet (p, q, r).\n    0 -> p, q and r are collinear\n    1 -> Clockwise\n    2 -> Counterclockwise\n    \"\"\"\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0\n    return 1 if val > 0 else 2\n\ndef do_intersect(p1, q1, p2, q2):\n    \"\"\"Check if line segments 'p1q1' and 'p2q2' intersect.\"\"\"\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case\n    if o1 != o2 and o3 != o4:\n        return True\n    return False\n\ndef is_valid_matching(spaceships, bases, matching):\n    \"\"\"Check if the given matching is valid (no intersections).\"\"\"\n    for i in range(len(matching)):\n        for j in range(i + 1, len(matching)):\n            if do_intersect(spaceships[matching[i]], bases[i], spaceships[matching[j]], bases[j]):\n                return False\n    return True\n\ndef backtrack(matching, used, spaceships, bases, R, B):\n    if len(matching) == R:\n        return is_valid_matching(spaceships, bases, matching)\n\n    for i in range(B):\n        if not used[i]:\n            used[i] = True\n            matching.append(i)\n            if backtrack(matching, used, spaceships, bases, R, B):\n                return True\n            matching.pop()\n            used[i] = False\n    return False\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    R, B = map(int, data[0].split())\n    spaceships = [tuple(map(int, data[i + 1].split())) for i in range(R)]\n    bases = [tuple(map(int, data[i + 1 + R].split())) for i in range(B)]\n    \n    if R != B:\n        print(\"No\")\n        return\n    \n    used = [False] * B\n    if backtrack([], used, spaceships, bases, R, B):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_power_of_two_and_count(n, a):\n    max_power = 0\n    count = 0\n\n    for number in a:\n        current_power = 0\n        while number % 2 == 0:\n            number //= 2\n            current_power += 1\n        \n        if current_power > max_power:\n            max_power = current_power\n\n    r = 2 ** max_power\n\n    for number in a:\n        if number % r == 0:\n            count += 1\n\n    return r, count\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = max_power_of_two_and_count(n, a)\n\n# Output the result\nprint(result[0], result[1])"}
{"solution": "def min_button_presses(n, m):\n    if n >= m:\n        return n - m\n    else:\n        presses = 0\n        while m > n:\n            if m % 2 == 0:\n                m //= 2\n            else:\n                m += 1\n            presses += 1\n        return presses + (n - m)\n\n# Read input\nn, m = map(int, input().split())\n# Calculate and print the result\nprint(min_button_presses(n, m))"}
{"solution": "class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [1] * size\n        self.count = size\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v):\n        root_u = self.find(u)\n        root_v = self.find(v)\n        if root_u != root_v:\n            if self.rank[root_u] > self.rank[root_v]:\n                self.parent[root_v] = root_u\n            elif self.rank[root_u] < self.rank[root_v]:\n                self.parent[root_u] = root_v\n            else:\n                self.parent[root_v] = root_u\n                self.rank[root_u] += 1\n            self.count -= 1\n\ndef segments_intersect(seg1, seg2):\n    return not (seg1[1] < seg2[0] or seg2[1] < seg1[0])\n\ndef is_tree(n, segments):\n    if n == 1:\n        return True  # A single segment is trivially a tree\n\n    segments.sort()  # Sort segments by their starting point\n    uf = UnionFind(n)\n\n    active_segments = []\n    \n    for i in range(n):\n        l_i, r_i = segments[i]\n        \n        # Check for intersections with active segments\n        for j in active_segments:\n            l_j, r_j = segments[j]\n            if segments_intersect((l_i, r_i), (l_j, r_j)):\n                uf.union(i, j)\n\n        # Add current segment to active segments\n        active_segments.append(i)\n\n        # Remove segments that cannot intersect with future segments\n        active_segments = [j for j in active_segments if segments[j][1] >= l_i]\n\n    # Check if the graph is connected and has exactly n-1 edges\n    return uf.count == 1 and len(active_segments) == n - 1\n\nimport sys\ninput = sys.stdin.read\n\ndata = input().splitlines()\nn = int(data[0])\nsegments = [tuple(map(int, line.split())) for line in data[1:n + 1]]\n\nif is_tree(n, segments):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def longest_ddos_attack(n, requests):\n    # Step 1: Create a prefix sum array\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + requests[i - 1]\n\n    max_length = 0\n\n    # Step 2: Iterate over all possible starting points\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            total_requests = prefix_sum[j] - prefix_sum[i - 1]\n            length = j - i + 1\n            if total_requests > 100 * length:\n                max_length = max(max_length, length)\n\n    return max_length\n\n# Read input\nn = int(input())\nrequests = list(map(int, input().split()))\n# Print the result\nprint(longest_ddos_attack(n, requests))"}
{"solution": "def can_achieve_dissatisfaction(n, k, sequence):\n    # Count the maximum number of consecutive 'N's\n    max_dissatisfaction = 0\n    current_dissatisfaction = 0\n    uncertain_count = 0\n\n    for char in sequence:\n        if char == 'N':\n            current_dissatisfaction += 1\n        elif char == 'Y':\n            max_dissatisfaction = max(max_dissatisfaction, current_dissatisfaction)\n            current_dissatisfaction = 0\n        elif char == '?':\n            uncertain_count += 1\n\n    # Final check for the last segment\n    max_dissatisfaction = max(max_dissatisfaction, current_dissatisfaction)\n\n    # Check if we can achieve exactly k dissatisfaction\n    if max_dissatisfaction > k:\n        return \"NO\"\n    elif max_dissatisfaction == k:\n        return \"YES\"\n    else:\n        # We need to check if we can use '?' to increase dissatisfaction to k\n        if (k - max_dissatisfaction) <= uncertain_count:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\nsequence = input().strip()\n\n# Get the result and print it\nresult = can_achieve_dissatisfaction(n, k, sequence)\nprint(result)"}
{"solution": "def possible_values_of_s_minus_t(N, X, D):\n    # Calculate the total sum of the sequence\n    total_sum = N * X + D * (N - 1) * N // 2\n    \n    # The minimum sum S Takahashi can take is 0 (taking no elements)\n    # The maximum sum S Takahashi can take is total_sum (taking all elements)\n    \n    # The difference S - T can be expressed as:\n    # S - T = 2S - total_sum\n    # The possible values of S range from 0 to total_sum.\n    \n    # The number of distinct values of S - T is determined by the number of distinct values of S,\n    # which is the number of elements Takahashi can choose (from 0 to N).\n    \n    # The possible values of S - T will be:\n    # -total_sum, -total_sum + 2D, -total_sum + 4D, ..., total_sum\n    # This forms an arithmetic sequence with a common difference of 2D.\n    \n    # The number of distinct values of S - T can be calculated as:\n    if D == 0:\n        # If D is 0, all elements are the same, hence only one unique value of S - T\n        return 1\n    else:\n        # The range of S - T is from -total_sum to total_sum\n        # The number of distinct values is given by the formula:\n        return (total_sum - (-total_sum)) // abs(2 * D) + 1\n\n# Read input\nimport sys\ninput = sys.stdin.read\nN, X, D = map(int, input().strip().split())\n\n# Calculate and print the result\nresult = possible_values_of_s_minus_t(N, X, D)\nprint(result)"}
{"solution": "n = int(input())\nperformed_good = False\n\nfor _ in range(n):\n    data = input().split()\n    handle = data[0]\n    before_rating = int(data[1])\n    after_rating = int(data[2])\n    \n    if before_rating >= 2400 and after_rating > before_rating:\n        performed_good = True\n\nif performed_good:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Read the binary input\ns_binary = input().strip()\n# Convert binary to decimal\ns_decimal = int(s_binary, 2)\n\n# Initialize the count of missed trains\nmissed_trains = 0\n# Start with k = 0 (which corresponds to 4^0 = 1)\nk = 0\n# Calculate 4^k (which is 2^(2k))\nwhile True:\n    train_time = 4 ** k  # This is the same as 2 ** (2 * k)\n    if train_time < s_decimal:\n        missed_trains += 1\n        k += 1\n    else:\n        break\n\n# Output the number of missed trains\nprint(missed_trains)"}
{"solution": "def min_rows_for_mirroring(n, m, matrix_a):\n    # Create a set to store unique rows\n    unique_rows = set()\n    \n    # Iterate through the matrix to collect unique rows\n    for row in matrix_a:\n        unique_rows.add(tuple(row))\n    \n    # Convert the set back to a list and sort it\n    unique_rows = list(unique_rows)\n    \n    # Count the number of unique rows\n    unique_count = len(unique_rows)\n    \n    # The minimum number of rows in matrix b is the number of unique rows\n    # divided by 2, rounded up (since we can mirror them)\n    min_rows_b = (unique_count + 1) // 2\n    \n    return min_rows_b\n\n# Read input\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\n\n# Get the result\nresult = min_rows_for_mirroring(n, m, matrix_a)\n\n# Print the output\nprint(result)"}
{"solution": "def max_non_overlapping_orders(n, orders):\n    # Step 2: Sort the orders based on their finish times\n    orders.sort(key=lambda x: x[1])\n    \n    # Step 3: Greedy selection\n    count = 0\n    last_end_time = 0\n    \n    for start, end in orders:\n        if start >= last_end_time:\n            count += 1\n            last_end_time = end\n            \n    return count\n\n# Input parsing\nn = int(input())\norders = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = max_non_overlapping_orders(n, orders)\nprint(result)"}
{"solution": "import math\n\ndef can_rearrange(n, k, tables, formulas):\n    total_tables = sum(tables)\n    total_formulas = sum(formulas)\n    \n    # Calculate the number of blocks needed\n    blocks_of_tables = math.ceil(total_tables / k)\n    blocks_of_formulas = math.ceil(total_formulas / k)\n    \n    # Check if the arrangement is possible\n    if blocks_of_tables <= total_formulas and blocks_of_formulas <= total_tables:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\ntables = list(map(int, input().split()))\nformulas = list(map(int, input().split()))\n\n# Print the result\nprint(can_rearrange(n, k, tables, formulas))"}
{"solution": "def can_human_win(n, k, coefficients):\n    # Calculate the current value of the polynomial at x = k\n    current_value = 0\n    undefined_count = 0\n    \n    for i in range(n + 1):\n        if coefficients[i] == '?':\n            undefined_count += 1\n        else:\n            current_value += coefficients[i] * (k ** i)\n    \n    # If the current value is already 0, human wins\n    if current_value == 0:\n        return \"Yes\"\n    \n    # If there are undefined coefficients\n    if undefined_count > 0:\n        # If the current value is not zero, human can always adjust the undefined coefficients\n        return \"Yes\"\n    \n    # If there are no undefined coefficients and current_value is not zero\n    return \"No\"\n\n# Read input\nn, k = map(int, input().split())\ncoefficients = [input().strip() for _ in range(n + 1)]\n\n# Determine if the human can guarantee a win\nresult = can_human_win(n, k, coefficients)\nprint(result)"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef primes_up_to(n):\n    return [i for i in range(2, n + 1) if is_prime(i)]\n\ndef smallest_X0(X2):\n    primes = primes_up_to(X2)\n    min_X0 = float('inf')\n\n    for p in primes:\n        if p >= X2:\n            continue\n        # Calculate possible X1\n        X1 = (X2 // p) * p\n        if X1 < X2:\n            X1 += p\n        \n        # Now find the minimum X0 that can lead to X1\n        for q in primes:\n            if q >= X1:\n                continue\n            # Calculate possible X0\n            X0 = (X1 // q) * q\n            if X0 < X1:\n                X0 += q\n            \n            min_X0 = min(min_X0, X0)\n\n    return min_X0\n\n# Read input\nX2 = int(input())\n# Output the result\nprint(smallest_X0(X2))"}
{"solution": "def min_p_binary_summands(n, p):\n    # Calculate the effective target we need to represent\n    target = n - p\n    \n    # If the target is less than 0, it's impossible to represent n\n    if target < 0:\n        return -1\n    \n    # Count the number of 1s in the binary representation of target\n    count_of_ones = bin(target).count('1')\n    \n    # If p is positive, we need to add count_of_ones to account for the p's\n    if p > 0:\n        return count_of_ones + count_of_ones  # Each 1 needs an additional p\n    else:\n        return count_of_ones  # No additional p needed\n\n# Read input\nn, p = map(int, input().split())\n# Print the result\nprint(min_p_binary_summands(n, p))"}
{"solution": "def minimize_number(n, k, S):\n    S = list(S)  # Convert string to list for mutability\n    changes = 0\n    \n    # Handle the first digit\n    if S[0] != '1':\n        S[0] = '1'\n        changes += 1\n    \n    # Handle the rest of the digits\n    for i in range(1, n):\n        if changes < k and S[i] != '0':\n            S[i] = '0'\n            changes += 1\n    \n    return ''.join(S)\n\n# Read input\nn, k = map(int, input().split())\nS = input().strip()\nresult = minimize_number(n, k, S)\nprint(result)"}
{"solution": "def count_valid_numbers(v, x, y):\n    # Count numbers from 1 to v that are not divisible by x or y\n    count_x = v // x\n    count_y = v // y\n    count_xy = v // (x * y)  # lcm of x and y since x and y are prime\n    return v - (count_x + count_y - count_xy)\n\ndef find_minimum_v(cnt1, cnt2, x, y):\n    left, right = 1, 2 * (cnt1 + cnt2)  # Start with a reasonable upper bound\n    while left < right:\n        mid = (left + right) // 2\n        if count_valid_numbers(mid, x, y) >= cnt1 + cnt2:\n            right = mid  # Try for a smaller v\n        else:\n            left = mid + 1  # Increase v\n    return left\n\n# Read input\ncnt1, cnt2, x, y = map(int, input().split())\n# Calculate and print the result\nprint(find_minimum_v(cnt1, cnt2, x, y))"}
{"solution": "def bear_final_position(n, sx, sy, dx, dy, t):\n    # Initial position\n    x, y = sx, sy\n    \n    for _ in range(t):\n        # Calculate the number of bushes in the current cell\n        k = x + y\n        \n        # Update speed\n        dx += k\n        dy += k\n        \n        # Move to the new position\n        x = (x + dx - 1) % n + 1\n        y = (y + dy - 1) % n + 1\n        \n        # After moving, one additional raspberry bush grows in each cell\n        # This is already accounted for in the next iteration's k calculation\n    \n    return x, y\n\n# Read input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Get the final position of the bear\nfinal_position = bear_final_position(n, sx, sy, dx, dy, t)\n\n# Print the result\nprint(final_position[0], final_position[1])"}
{"solution": "def is_nice_word_possible(s):\n    n = len(s)\n    if n < 26:\n        return -1\n\n    # Sliding window to check each substring of length 26\n    for i in range(n - 25):\n        substring = s[i:i + 26]\n        char_count = {}\n        question_marks = 0\n        \n        # Count characters and question marks\n        for char in substring:\n            if char == '?':\n                question_marks += 1\n            else:\n                char_count[char] = char_count.get(char, 0) + 1\n        \n        # Check if we have all letters A-Z\n        if len(char_count) + question_marks == 26 and all(count == 1 for count in char_count.values()):\n            # We can form a nice word\n            result = list(s)\n            used_chars = set(char_count.keys())\n            missing_chars = [chr(c) for c in range(ord('A'), ord('Z') + 1) if chr(c) not in used_chars]\n            \n            # Fill in the substring with missing characters\n            missing_index = 0\n            for j in range(i, i + 26):\n                if result[j] == '?':\n                    if missing_index < len(missing_chars):\n                        result[j] = missing_chars[missing_index]\n                        missing_index += 1\n            \n            # Replace remaining '?' with 'A' (or any character)\n            for j in range(n):\n                if result[j] == '?':\n                    result[j] = 'A'\n            \n            return ''.join(result)\n\n    return -1\n\n# Read input\ns = input().strip()\n# Get the result\nresult = is_nice_word_possible(s)\n# Print the output\nprint(result)"}
{"solution": "def can_divide_apples(n, weights):\n    total_weight = sum(weights)\n    \n    # Check if the total weight is even\n    if total_weight % 2 != 0:\n        return \"NO\"\n    \n    target_weight = total_weight // 2\n    count_100 = weights.count(100)\n    count_200 = weights.count(200)\n    \n    # Try to use 200g apples first\n    max_200_used = min(count_200, target_weight // 200)\n    remaining_weight = target_weight - (max_200_used * 200)\n    \n    # Check if we can fulfill the remaining weight with 100g apples\n    if remaining_weight <= count_100 * 100:\n        return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn = int(input())\nweights = list(map(int, input().split()))\n\n# Output the result\nprint(can_divide_apples(n, weights))"}
{"solution": "def minimum_time_to_turn_off_lights(n, m, floors):\n    total_time = 0\n    \n    for i in range(n):\n        floor = floors[i]\n        leftmost = -1\n        rightmost = -1\n        \n        # Find leftmost and rightmost rooms with lights on\n        for j in range(1, m + 1):\n            if floor[j] == '1':\n                if leftmost == -1:\n                    leftmost = j\n                rightmost = j\n        \n        if leftmost != -1:  # There are lights on\n            # Time to turn off lights on this floor\n            time_on_floor = (leftmost - 1) + (rightmost - leftmost) + (1)  # to leftmost, to rightmost, back to stairs\n            total_time += time_on_floor\n        \n        # Time to go to the next floor (if not the last floor)\n        if i < n - 1:\n            total_time += 1  # going up to the next floor\n    \n    return total_time\n\n# Input reading\nn, m = map(int, input().split())\nfloors = [input().strip() for _ in range(n)]\n\n# Calculate and print the result\nprint(minimum_time_to_turn_off_lights(n, m, floors))"}
{"solution": "def find_scc(n, a):\n    index = 0\n    stack = []\n    indices = [-1] * n\n    lowlink = [-1] * n\n    on_stack = [False] * n\n    sccs = []\n    \n    def strongconnect(v):\n        nonlocal index\n        indices[v] = lowlink[v] = index\n        index += 1\n        stack.append(v)\n        on_stack[v] = True\n        \n        # Consider successors of v\n        w = a[v] - 1  # Convert to 0-based index\n        if indices[w] == -1:\n            # Successor w has not yet been visited; recurse on it\n            strongconnect(w)\n            lowlink[v] = min(lowlink[v], lowlink[w])\n        elif on_stack[w]:\n            # Successor w is in stack and hence in the current SCC\n            lowlink[v] = min(lowlink[v], indices[w])\n        \n        # If v is a root node, pop the stack and generate an SCC\n        if lowlink[v] == indices[v]:\n            current_scc = []\n            while True:\n                w = stack.pop()\n                on_stack[w] = False\n                current_scc.append(w)\n                if w == v:\n                    break\n            sccs.append(current_scc)\n    \n    for v in range(n):\n        if indices[v] == -1:\n            strongconnect(v)\n    \n    return sccs\n\ndef minimal_trap_cost(n, c, a):\n    sccs = find_scc(n, a)\n    total_cost = 0\n    \n    for scc in sccs:\n        min_cost = min(c[i] for i in scc)\n        total_cost += min_cost\n    \n    return total_cost\n\n# Input reading\nn = int(input())\nc = list(map(int, input().split()))\na = list(map(int, input().split()))\n\n# Output the result\nprint(minimal_trap_cost(n, c, a))"}
{"solution": "def final_entrance(n, a, b):\n    # Calculate the final entrance using the derived formula\n    k = (a + b - 1) % n + 1\n    return k\n\n# Read input values\nn, a, b = map(int, input().split())\n# Print the result\nprint(final_entrance(n, a, b))"}
{"solution": "def min_arithmetic_progressions(n, a):\n    # Initialize the count of arithmetic progressions\n    count = 0\n    i = 0\n    \n    while i < n:\n        # If we encounter a known value, we start a new progression\n        if a[i] != -1:\n            count += 1\n            # Move to the next known value or the end of the list\n            while i < n and a[i] != -1:\n                i += 1\n        else:\n            # If we encounter -1, we need to find the next known value\n            start = i\n            while i < n and a[i] == -1:\n                i += 1\n            \n            # If we have a known value after the -1s, we can check for progressions\n            if i < n:\n                # We have a known value a[i]\n                if start > 0 and a[start - 1] != -1:\n                    # We can determine the difference from the previous known value\n                    diff = a[i] - a[start - 1]\n                    # We can fill the -1s with values that maintain the progression\n                    for j in range(start, i):\n                        a[j] = a[start - 1] + (j - start + 1) * (diff // (i - start))\n                # If we have no known value before the -1s, we can just treat them as a new progression\n                count += 1\n            else:\n                # If we reached the end and still have -1s, treat them as a new progression\n                count += 1\n    \n    return count\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = min_arithmetic_progressions(n, a)\n\n# Print the output\nprint(result)"}
{"solution": "def max_beauty(n, k, s):\n    def max_length_with_char(target_char):\n        left = 0\n        max_length = 0\n        changes = 0\n        \n        for right in range(n):\n            if s[right] != target_char:\n                changes += 1\n            \n            while changes > k:\n                if s[left] != target_char:\n                    changes -= 1\n                left += 1\n            \n            max_length = max(max_length, right - left + 1)\n        \n        return max_length\n    \n    # Calculate the maximum length for both 'a' and 'b'\n    max_a = max_length_with_char('a')\n    max_b = max_length_with_char('b')\n    \n    return max(max_a, max_b)\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n# Output the result\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, a):\n    total_seats = sum(a)\n    majority = total_seats // 2 + 1\n    \n    coalition = [1]  # Start with Alice's party\n    coalition_seats = a[0]  # Seats in Alice's party\n    \n    # Check other parties\n    for i in range(1, n):\n        if a[0] >= 2 * a[i]:  # Alice's party can invite party i+1\n            coalition.append(i + 1)  # Store the index (1-based)\n            coalition_seats += a[i]  # Add their seats to the coalition\n    \n    # Check if the coalition has a strict majority\n    if coalition_seats >= majority:\n        print(len(coalition))\n        print(\" \".join(map(str, coalition)))\n    else:\n        print(0)\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nfind_coalition(n, a)"}
{"solution": "def maximum_reward(n):\n    total_reward = 0.0\n    for i in range(1, n + 1):\n        total_reward += 1 / i\n    return total_reward\n\n# Read input\nn = int(input().strip())\n# Calculate and print the maximum reward\nprint(f\"{maximum_reward(n):.12f}\")"}
{"solution": "def distribute_candies(n):\n    k = 0\n    total = 0\n    \n    # Find the maximum k such that the sum of first k natural numbers is <= n\n    while total + (k + 1) <= n:\n        k += 1\n        total += k\n    \n    # Remaining candies after distributing 1 to k\n    remaining = n - total\n    \n    # Prepare the result\n    result = list(range(1, k + 1))\n    \n    # If there are remaining candies, add them to the last child\n    if remaining > 0:\n        result[-1] += remaining\n    \n    # Output the results\n    print(k)\n    print(\" \".join(map(str, result)))\n\n# Read input\nn = int(input())\ndistribute_candies(n)"}
{"solution": "n = int(input())\nm = int(input())\n\n# Calculate m mod 2^n\nif n >= 27:  # Since m <= 10^8, we only need to consider up to 27 bits\n    result = m\nelse:\n    result = m & ((1 << n) - 1)  # This is equivalent to m % (2^n)\n\nprint(result)"}
{"solution": "def correct_word(s):\n    vowels = set('aeiouy')\n    result = []\n    \n    for char in s:\n        if result and char in vowels and result[-1] in vowels:\n            continue  # Skip adding the current vowel\n        result.append(char)\n    \n    return ''.join(result)\n\nn = int(input())\ns = input().strip()\nprint(correct_word(s))"}
{"solution": "def max_students(n, a, b, seats):\n    segments = []\n    current_length = 0\n    \n    # Identify segments of empty seats\n    for char in seats:\n        if char == '.':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n    if current_length > 0:\n        segments.append(current_length)\n    \n    total_students = 0\n    \n    # Fill each segment\n    for length in segments:\n        if a > b:\n            # Start with programmers\n            programmers_to_seat = min((length + 1) // 2, a)\n            athletes_to_seat = min(length // 2, b)\n        else:\n            # Start with athletes\n            athletes_to_seat = min((length + 1) // 2, b)\n            programmers_to_seat = min(length // 2, a)\n        \n        total_students += programmers_to_seat + athletes_to_seat\n        a -= programmers_to_seat\n        b -= athletes_to_seat\n    \n    return total_students\n\n# Read input\nn, a, b = map(int, input().split())\nseats = input().strip()\n# Print the result\nprint(max_students(n, a, b, seats))"}
{"solution": "def find_xy(r):\n    x = 1\n    while True:\n        # Calculate the value of the polynomial\n        polynomial_value = x**2 + x + 1\n        if polynomial_value >= r:\n            break\n        \n        # Calculate the remainder\n        remainder = r - polynomial_value\n        \n        # Check if remainder is divisible by 2x\n        if remainder > 0 and remainder % (2 * x) == 0:\n            y = remainder // (2 * x)\n            if y > 0:\n                print(x, y)\n                return\n        \n        x += 1\n    \n    print(\"NO\")\n\n# Read input\nr = int(input().strip())\nfind_xy(r)"}
{"solution": "def divide_balloons(n, a):\n    if n == 1:\n        return -1  # Impossible to divide with only one packet\n    \n    total_balloons = sum(a)\n    \n    # If there are two packets, check if they are equal\n    if n == 2:\n        if a[0] == a[1]:\n            return -1  # Both would have the same total\n        else:\n            return 1, [1]  # Give one packet to Grigory, the other to Andrew\n    \n    # For n > 2, we can always find a valid distribution\n    # We can give the first packet to Grigory and the rest to Andrew\n    return n - 1, list(range(2, n + 1))  # Grigory gets the first packet\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nresult = divide_balloons(n, a)\n\nif result == -1:\n    print(-1)\nelse:\n    k, indices = result\n    print(k)\n    print(' '.join(map(str, indices)))"}
{"solution": "def split_number(n):\n    # Determine the largest digit we can use, which is 9\n    if n <= 9:\n        # If n is less than or equal to 9, we can just use n itself\n        print(1)\n        print(n)\n    else:\n        # If n is greater than 9, we will use 9 as many times as possible\n        count_of_nines = n // 9\n        remainder = n % 9\n        \n        # Prepare the result list\n        result = []\n        \n        # Add 9s to the result\n        result.extend([9] * count_of_nines)\n        \n        # If there is a remainder, add it to the result\n        if remainder > 0:\n            result.append(remainder)\n        \n        # Output the number of digits and the digits themselves\n        print(len(result))\n        print(' '.join(map(str, result)))\n\n# Read input\nn = int(input())\nsplit_number(n)"}
{"solution": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef sieve_of_eratosthenes(max_num):\n    is_prime = [True] * (max_num + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(max_num**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, max_num + 1, i):\n                is_prime[j] = False\n    return is_prime\n\ndef find_largest_simple_subset(arr):\n    max_num = 2 * 10**6\n    prime_check = sieve_of_eratosthenes(max_num)\n    \n    even_count = 0\n    odd_count = 0\n    even_number = None\n    odd_numbers = []\n    \n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n            even_number = num\n        else:\n            odd_count += 1\n            odd_numbers.append(num)\n    \n    if even_count > 0:\n        # We can take one even number and all odd numbers\n        result = [even_number] + odd_numbers\n    else:\n        # Only odd numbers, we need to check pairwise sums\n        result = []\n        for i in range(len(odd_numbers)):\n            can_add = True\n            for j in range(i):\n                if not prime_check[odd_numbers[i] + odd_numbers[j]]:\n                    can_add = False\n                    break\n            if can_add:\n                result.append(odd_numbers[i])\n    \n    return result\n\n# Input reading\nn = int(input())\narr = list(map(int, input().split()))\n\n# Finding the largest simple subset\nsimple_subset = find_largest_simple_subset(arr)\n\n# Output the result\nprint(len(simple_subset))\nprint(' '.join(map(str, simple_subset)))"}
{"solution": "def generate_beautiful_numbers(limit):\n    beautiful_numbers = []\n    k = 1\n    while True:\n        beautiful_number = (2**k - 1) ** 2\n        if beautiful_number > limit:\n            break\n        beautiful_numbers.append(beautiful_number)\n        k += 1\n    return beautiful_numbers\n\ndef greatest_beautiful_divisor(n):\n    beautiful_numbers = generate_beautiful_numbers(n)\n    greatest_divisor = 1  # Since 1 is always a divisor\n    for b in beautiful_numbers:\n        if n % b == 0:\n            greatest_divisor = b\n    return greatest_divisor\n\n# Input\nn = int(input())\n# Output\nprint(greatest_beautiful_divisor(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef is_d_magic(num_str, d):\n    for i in range(len(num_str)):\n        digit = int(num_str[i])\n        if (i + 1) % 2 == 0:  # even position (1-based)\n            if digit == d:\n                continue\n        else:  # odd position (1-based)\n            if digit == d:\n                return False\n    return True\n\ndef count_d_magic_numbers(m, d, a, b):\n    count = 0\n    for num in range(int(a), int(b) + 1):\n        if num % m == 0 and is_d_magic(str(num), d):\n            count = (count + 1) % MOD\n    return count\n\ndef main():\n    m, d = map(int, input().split())\n    a = input().strip()\n    b = input().strip()\n    \n    result = count_d_magic_numbers(m, d, a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def last_child(n, m, requirements):\n    from collections import deque\n    \n    queue = deque([(i + 1, requirements[i]) for i in range(n)])  # (child_index, remaining_candies)\n    last_child_index = -1\n    \n    while queue:\n        child_index, remaining_candies = queue.popleft()\n        remaining_candies -= m\n        \n        if remaining_candies > 0:\n            queue.append((child_index, remaining_candies))  # Not enough candies, go to the end of the line\n        else:\n            last_child_index = child_index  # This child goes home\n    \n    return last_child_index\n\n# Read input\nn, m = map(int, input().split())\nrequirements = list(map(int, input().split()))\n# Output the result\nprint(last_child(n, m, requirements))"}
{"solution": "def min_bills(n):\n    denominations = [100, 20, 10, 5, 1]\n    total_bills = 0\n    \n    for bill in denominations:\n        if n == 0:\n            break\n        count = n // bill\n        total_bills += count\n        n -= count * bill\n    \n    return total_bills\n\n# Read input\nn = int(input().strip())\n# Output the result\nprint(min_bills(n))"}
{"solution": "def count_permutations(n, k):\n    MOD = 1000000007\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Base cases\n    dp[1][0] = 1  # Only one permutation of size 1 with 0 good positions\n    \n    for i in range(2, n + 1):\n        dp[i][0] = (i - 1) * dp[i - 1][0] % MOD  # All positions not good\n        for j in range(1, i + 1):\n            dp[i][j] = (dp[i - 1][j] + (dp[i - 2][j - 1] if j > 0 else 0)) % MOD\n    \n    return dp[n][k]\n\n# Read input\nn, k = map(int, input().split())\n# Output the result\nprint(count_permutations(n, k))"}
{"solution": "def max_bouquet_beauty(n, k, beauties, colors):\n    from collections import defaultdict\n    \n    # Group roses by color\n    color_groups = defaultdict(list)\n    for beauty, color in zip(beauties, colors):\n        color_groups[color].append(beauty)\n    \n    # Sort each color group in descending order of beauty\n    for color in color_groups:\n        color_groups[color].sort(reverse=True)\n    \n    # If we don't have at least two colors, return -1\n    if len(color_groups) < 2:\n        return -1\n    \n    max_beauty = -1\n    \n    # Check combinations of two different colors\n    color_keys = list(color_groups.keys())\n    \n    for i in range(len(color_keys)):\n        for j in range(i + 1, len(color_keys)):\n            color1 = color_keys[i]\n            color2 = color_keys[j]\n            \n            roses1 = color_groups[color1]\n            roses2 = color_groups[color2]\n            \n            # We can take up to k roses from both colors\n            for take_from_1 in range(max(0, k - len(roses2)), min(k, len(roses1)) + 1):\n                take_from_2 = k - take_from_1\n                \n                if take_from_2 <= len(roses2):\n                    total_beauty = sum(roses1[:take_from_1]) + sum(roses2[:take_from_2])\n                    max_beauty = max(max_beauty, total_beauty)\n    \n    return max_beauty\n\n# Read input\nn, k = map(int, input().split())\nbeauties = list(map(int, input().split()))\ncolors = input().strip()\n\n# Get the result\nresult = max_bouquet_beauty(n, k, beauties, colors)\n\n# Print the output\nprint(result)"}
{"solution": "def continued_fraction_to_fraction(a):\n    n = len(a)\n    if n == 0:\n        return (0, 1)  # Undefined case, but we won't hit this in valid input\n    \n    # Start from the last term\n    numerator = a[-1]\n    denominator = 1\n    \n    # Process the continued fraction from the end to the start\n    for i in range(n - 2, -1, -1):\n        # a[i] + 1/(numerator/denominator)\n        # This is equivalent to:\n        # a[i] + denominator/numerator\n        # which can be expressed as:\n        # (a[i] * numerator + denominator) / numerator\n        numerator, denominator = a[i] * numerator + denominator, numerator\n    \n    return (numerator, denominator)\n\ndef are_fractions_equal(p, q, n, a):\n    # Get the fraction from the continued fraction representation\n    N, D = continued_fraction_to_fraction(a)\n    \n    # Compare p/q with N/D\n    return p * D == q * N\n\n# Input reading\np, q = map(int, input().split())\nn = int(input())\na = list(map(int, input().split()))\n\n# Check if the fractions are equal\nif are_fractions_equal(p, q, n, a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def adjust_sticks(expression):\n    # Split the expression into parts\n    parts = expression.split('+')\n    A = len(parts[0])  # Count of sticks in A\n    parts = parts[1].split('=')\n    B = len(parts[0])  # Count of sticks in B\n    C = len(parts[1])  # Count of sticks in C\n\n    # Check if already correct\n    if A + B == C:\n        return expression\n\n    # Try shifting sticks\n    # Possible shifts:\n    shifts = [\n        (1, 0, 0),  # A to B\n        (1, 0, 1),  # A to C\n        (0, 1, 0),  # B to A\n        (0, 1, 1),  # B to C\n        (0, 0, 1),  # C to A\n        (0, 0, 0)   # C to B\n    ]\n\n    for shift in shifts:\n        a_shift, b_shift, c_shift = shift\n        new_A = A - a_shift + c_shift\n        new_B = B - b_shift + a_shift\n        new_C = C - c_shift + b_shift\n\n        if new_A + new_B == new_C and new_A >= 0 and new_B >= 0 and new_C >= 0:\n            # Construct the new expression\n            new_expression = '|' * new_A + '+' + '|' * new_B + '=' + '|' * new_C\n            return new_expression\n\n    return \"Impossible\"\n\n# Example usage\ninput_expression = input().strip()\nresult = adjust_sticks(input_expression)\nprint(result)"}
{"solution": "def count_permutations_with_oddness(n, k):\n    MOD = 10**9 + 7\n    \n    # dp[i][j] will store the number of permutations of {1, 2, ..., i} with oddness j\n    dp = [[0] * (n * n + 1) for _ in range(n + 1)]\n    \n    # Base case: there's one way to arrange 0 elements with oddness 0\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(n * n + 1):\n            # Calculate the number of permutations of {1, 2, ..., i}\n            for p in range(1, i + 1):\n                oddness_contribution = abs(p - i)  # contribution of placing i at position p\n                if j >= oddness_contribution:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - oddness_contribution]) % MOD\n    \n    return dp[n][k]\n\n# Read input\nimport sys\ninput = sys.stdin.read\nn, k = map(int, input().strip().split())\n\n# Get the result and print it\nresult = count_permutations_with_oddness(n, k)\nprint(result)"}
{"solution": "def can_configure_robot_arm(N, targets):\n    # Calculate the total required movements in x and y directions\n    total_x = sum(x for x, y in targets)\n    total_y = sum(y for x, y in targets)\n\n    # The maximum absolute values of x and y needed\n    max_x = max(abs(x) for x, y in targets)\n    max_y = max(abs(y) for x, y in targets)\n\n    # The number of sections needed\n    m = max(max_x, max_y)\n\n    # The lengths of the sections can be set to 1 for simplicity\n    d = [1] * m\n\n    # Prepare the output for each target point\n    movements = []\n    for x, y in targets:\n        w = []\n        current_x, current_y = 0, 0\n        \n        # Move in x direction\n        if x > 0:\n            w.extend(['R'] * x)\n        elif x < 0:\n            w.extend(['L'] * (-x))\n        \n        # Move in y direction\n        if y > 0:\n            w.extend(['U'] * y)\n        elif y < 0:\n            w.extend(['D'] * (-y))\n        \n        # Fill the remaining sections with 'R' (or any valid direction)\n        while len(w) < m:\n            w.append('R')\n        \n        movements.append(''.join(w))\n\n    return m, d, movements\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN = int(data[0])\ntargets = [tuple(map(int, line.split())) for line in data[1:N + 1]]\n\n# Get the configuration\nm, d, movements = can_configure_robot_arm(N, targets)\n\n# Print the output\nprint(m)\nprint(' '.join(map(str, d)))\nfor movement in movements:\n    print(movement)"}
{"solution": "def replace_fillers(n, s):\n    result = []\n    i = 0\n    \n    while i < n:\n        if s[i] == 'o':\n            # Check if we have a filler starting with 'o'\n            start = i\n            if i + 1 < n and s[i + 1] == 'g':\n                i += 2  # Move past 'og'\n                while i < n and s[i] == 'o':\n                    # We found another 'o', now check for 'go'\n                    if i + 1 < n and s[i + 1] == 'g':\n                        i += 2  # Move past 'go'\n                    else:\n                        break\n                # We have identified a filler from start to i\n                result.append(\"***\")\n                continue  # Skip to the next iteration\n        # If not a filler, just add the current character\n        result.append(s[i])\n        i += 1\n    \n    # Join the result list into a string and return\n    return ''.join(result)\n\n# Input reading\nn = int(input())\ns = input().strip()\nprint(replace_fillers(n, s))"}
{"solution": "def prime_factors(n):\n    i = 2\n    factors = {}\n    while i * i <= n:\n        while (n % i) == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n //= i\n        i += 1\n    if n > 1:\n        factors[n] = 1\n    return factors\n\ndef g(y, p):\n    result = 1\n    while y % p == 0:\n        result *= p\n        y //= p\n    return result\n\ndef f(x, y, primes):\n    product = 1\n    for p in primes:\n        product *= g(y, p)\n    return product\n\ndef mod_exp(base, exp, mod):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return result\n\ndef main(x, n):\n    MOD = 10**9 + 7\n    factors = prime_factors(x)\n    primes = list(factors.keys())\n    \n    # Calculate the product over one cycle\n    cycle_product = 1\n    for y in range(1, min(n, max(primes)) + 1):\n        cycle_product *= f(x, y, primes)\n        cycle_product %= MOD\n    \n    # Total product\n    total_product = 1\n    for i in range(1, n + 1):\n        total_product *= f(x, i, primes)\n        total_product %= MOD\n    \n    return total_product\n\n# Input reading\nx, n = map(int, input().split())\nprint(main(x, n))"}
{"solution": "def digit_sum(n):\n    return sum(int(d) for d in str(n))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    \n    for s in range(1, 82):  # s can be from 1 to 81\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and digit_sum(x) == s:\n            solutions.append(x)\n    \n    solutions.sort()  # Sort the solutions in increasing order\n    return solutions\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find solutions\nsolutions = find_solutions(a, b, c)\n\n# Output results\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "def can_solve_with_one_rotation(cube):\n    # Define the indices for each face of the 2x2x2 cube\n    face_indices = [\n        [0, 1, 2, 3],  # Front face\n        [4, 5, 6, 7],  # Right face\n        [8, 9, 10, 11],  # Back face\n        [12, 13, 14, 15],  # Left face\n        [16, 17, 18, 19],  # Top face\n        [20, 21, 22, 23]   # Bottom face\n    ]\n    \n    # Check each face to see if it can be solved with one rotation\n    for indices in face_indices:\n        colors = [cube[i] for i in indices]\n        # Count occurrences of each color\n        color_count = {}\n        for color in colors:\n            if color in color_count:\n                color_count[color] += 1\n            else:\n                color_count[color] = 1\n        \n        # Check if any color has 3 or 4 occurrences\n        if any(count >= 3 for count in color_count.values()):\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\ncube_input = list(map(int, input().strip().split()))\n# Get the result\nresult = can_solve_with_one_rotation(cube_input)\n# Print the result\nprint(result)"}
{"solution": "def calculate_tshirt_winners(s):\n    i = (s // 50) % 475\n    winners = set()\n    \n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        winners.add(26 + i)\n    \n    return winners\n\ndef min_successful_hacks(p, x, y):\n    # Ensure we have at least y points\n    if x < y:\n        return float('inf')  # Not possible if current score is less than y\n    \n    # Check for the minimum successful hacks needed\n    for successful_hacks in range(0, 200):  # Arbitrarily large number to ensure we find a solution\n        # Calculate the score after successful hacks and unsuccessful hacks\n        score = x + successful_hacks * 100 - (0 * 50)  # 0 unsuccessful hacks initially\n        \n        # Check if we can reach at least y points\n        if score < y:\n            continue\n        \n        # Calculate the winners for the current score\n        winners = calculate_tshirt_winners(score)\n        \n        # Check if our place p is in the winners\n        if p in winners:\n            return successful_hacks\n    \n    return -1  # Should not reach here as per problem statement\n\n# Input reading\np, x, y = map(int, input().strip().split())\nresult = min_successful_hacks(p, x, y)\nprint(result)"}
{"solution": "def minimum_distance(n, a, b, c):\n    # If Winnie only needs to eat once, he can do so at Rabbit's house without traveling\n    if n == 1:\n        return 0\n    \n    # Calculate the minimum distance for n meals\n    # The first meal is at Rabbit's house, so we start from there\n    # We can alternate between the houses to minimize the distance\n    # The possible patterns are:\n    # 1. Rabbit -> Owl -> Eeyore (and repeat)\n    # 2. Rabbit -> Eeyore -> Owl (and repeat)\n    \n    # Calculate the distance for the first pattern\n    distance_owl_eeyore = (n - 1) // 2 * (a + c) + (n - 1) % 2 * a\n    # Calculate the distance for the second pattern\n    distance_eeyore_owl = (n - 1) // 2 * (b + c) + (n - 1) % 2 * b\n    \n    # The minimum distance will be the minimum of the two patterns\n    return min(distance_owl_eeyore, distance_eeyore_owl)\n\n# Read input\nn = int(input().strip())\na = int(input().strip())\nb = int(input().strip())\nc = int(input().strip())\n\n# Calculate and print the minimum distance\nprint(minimum_distance(n, a, b, c))"}
{"solution": "# Read the input values\nx1, x2, x3 = map(int, input().split())\n\n# Sort the points to find the median\npoints = sorted([x1, x2, x3])\n\n# The median is the second element in the sorted list\nmedian = points[1]\n\n# Calculate the total distance to the median\ntotal_distance = abs(x1 - median) + abs(x2 - median) + abs(x3 - median)\n\n# Print the result\nprint(total_distance)"}
{"solution": "def min_operations_to_equal_elements(n, x, arr):\n    # Step 1: Check for already existing duplicates\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return 0\n        seen.add(num)\n\n    # Step 2: Create a new set to track AND results\n    and_results = {}\n    for num in arr:\n        and_result = num & x\n        if and_result in and_results:\n            and_results[and_result] += 1\n        else:\n            and_results[and_result] = 1\n\n    # Step 3: Check if any AND result can create a duplicate\n    for num in arr:\n        if num in and_results and and_results[num] > 1:\n            return 1  # One operation needed\n\n    # Step 4: Check if we can create duplicates with AND results\n    for and_result in and_results:\n        if and_results[and_result] > 1:\n            return 1  # One operation needed\n\n    # Step 5: Check if we can create duplicates with two different numbers\n    for num in arr:\n        and_result = num & x\n        if and_result in seen:\n            return 1  # One operation needed\n\n    return -1  # Impossible to create duplicates\n\n# Input reading\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Output the result\nprint(min_operations_to_equal_elements(n, x, arr))"}
{"solution": "def has_single_plus_shape(h, w, grid):\n    center = None\n    total_stars = 0\n\n    # Find the center of the \"+\" shape\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*':\n                total_stars += 1\n                if center is None:\n                    center = (i, j)\n\n    if center is None:\n        return \"NO\"  # No stars at all\n\n    center_x, center_y = center\n    up, down, left, right = 0, 0, 0, 0\n\n    # Count rays in each direction\n    # Up\n    for i in range(center_x - 1, -1, -1):\n        if grid[i][center_y] == '*':\n            up += 1\n        else:\n            break\n\n    # Down\n    for i in range(center_x + 1, h):\n        if grid[i][center_y] == '*':\n            down += 1\n        else:\n            break\n\n    # Left\n    for j in range(center_y - 1, -1, -1):\n        if grid[center_x][j] == '*':\n            left += 1\n        else:\n            break\n\n    # Right\n    for j in range(center_y + 1, w):\n        if grid[center_x][j] == '*':\n            right += 1\n        else:\n            break\n\n    # Check if there is at least one star in each direction\n    if up < 1 or down < 1 or left < 1 or right < 1:\n        return \"NO\"\n\n    # Check if all other cells are empty\n    for i in range(h):\n        for j in range(w):\n            if (i == center_x and j == center_y) or \\\n               (up > 0 and i < center_x and j == center_y) or \\\n               (down > 0 and i > center_x and j == center_y) or \\\n               (left > 0 and j < center_y and i == center_x) or \\\n               (right > 0 and j > center_y and i == center_x):\n                continue\n            if grid[i][j] == '*':\n                return \"NO\"\n\n    # Check if the total number of stars matches the \"+\" shape\n    if total_stars == (up + down + left + right + 1):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Input reading\nh, w = map(int, input().split())\ngrid = [input().strip() for _ in range(h)]\n\n# Output the result\nprint(has_single_plus_shape(h, w, grid))"}
{"solution": "def create_adjacency_matrix(n, a, b):\n    # Check feasibility conditions\n    if a + b > n + 1 or a > n - b or b > n - a:\n        return \"NO\"\n    \n    # Initialize the adjacency matrix\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Create components\n    vertices = list(range(n))\n    component_size = n // a\n    remainder = n % a\n    \n    index = 0\n    for i in range(a):\n        size = component_size + (1 if i < remainder else 0)\n        for j in range(size):\n            for k in range(j + 1, size):\n                matrix[index + j][index + k] = 1\n                matrix[index + k][index + j] = 1\n        index += size\n    \n    return \"YES\", matrix\n\n# Read input\nn, a, b = map(int, input().split())\nresult = create_adjacency_matrix(n, a, b)\n\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(''.join(map(str, row)))"}
{"solution": "import math\n\n# Read input values\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\n# Calculate the total number of participants needed\nneeded_participants = n * m - k\n\n# If no additional participants are needed, return 0\nif needed_participants <= 0:\n    print(0)\n    exit()\n\n# Calculate the number of main rounds needed\nmain_rounds = math.ceil(needed_participants / n)\nproblems_from_main = main_rounds * c\n\n# Calculate remaining participants after main rounds\nremaining_participants = needed_participants - (main_rounds * n)\n\n# Calculate the number of additional rounds needed\nproblems_from_additional = max(0, remaining_participants) * d\n\n# Total problems needed\ntotal_problems = problems_from_main + problems_from_additional\n\n# Print the result\nprint(total_problems)"}
{"solution": "def is_adjacent(a, b):\n    # Check if two positions are adjacent in a 2x13 grid\n    row_a, col_a = divmod(a, 13)\n    row_b, col_b = divmod(b, 13)\n    return abs(row_a - row_b) <= 1 and abs(col_a - col_b) <= 1\n\ndef can_form_path(s):\n    # Create a grid of 2 rows and 13 columns\n    grid = [[''] * 13 for _ in range(2)]\n    letter_positions = {}\n    \n    # Fill the letter positions\n    for index, letter in enumerate(s):\n        if letter not in letter_positions:\n            letter_positions[letter] = []\n        letter_positions[letter].append(index)\n    \n    # Try to place letters in the grid\n    for letter, positions in letter_positions.items():\n        for pos in positions:\n            placed = False\n            for r in range(2):\n                for c in range(13):\n                    if grid[r][c] == '':\n                        grid[r][c] = letter\n                        placed = True\n                        break\n                if placed:\n                    break\n            if not placed:\n                return \"Impossible\"\n    \n    # Check if the path can be formed\n    path = []\n    for i in range(len(s)):\n        path.append((s[i], i))\n    \n    for i in range(len(path) - 1):\n        current_letter, current_index = path[i]\n        next_letter, next_index = path[i + 1]\n        \n        current_pos = [(r, c) for r in range(2) for c in range(13) if grid[r][c] == current_letter]\n        next_pos = [(r, c) for r in range(2) for c in range(13) if grid[r][c] == next_letter]\n        \n        if not any(is_adjacent(current_index, next_index) for current_index in current_pos for next_index in next_pos):\n            return \"Impossible\"\n    \n    return grid\n\ndef print_grid(grid):\n    if grid == \"Impossible\":\n        print(grid)\n    else:\n        for row in grid:\n            print(''.join(row))\n\ns = input().strip()\nresult = can_form_path(s)\nprint_grid(result)"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    \n    left = y * math.log(x)\n    right = x * math.log(y)\n    \n    if left < right:\n        return '<'\n    elif left > right:\n        return '>'\n    else:\n        return '='\n\n# Read input\nx, y = map(int, input().split())\n# Get the result\nresult = compare_powers(x, y)\n# Print the result\nprint(result)"}
{"solution": "def max_balloons(r, h):\n    # Calculate the number of layers of balloons that can fit vertically\n    layers = (h + r) // r\n    # Each layer can hold 3 balloons\n    total_balloons = layers * 3\n    return total_balloons\n\n# Read input\nr, h = map(int, input().strip().split())\n# Output the result\nprint(max_balloons(r, h))"}
{"solution": "def min_sum_after_discards(cards):\n    # Step 1: Calculate the initial sum\n    initial_sum = sum(cards)\n    \n    # Step 2: Count frequencies of each number\n    from collections import Counter\n    frequency = Counter(cards)\n    \n    # Step 3: Initialize the minimum sum as the initial sum\n    min_sum = initial_sum\n    \n    # Step 4: Evaluate discarding options\n    for number, count in frequency.items():\n        if count >= 2:\n            # If we can discard two cards of this number\n            new_sum = initial_sum - 2 * number\n            min_sum = min(min_sum, new_sum)\n        if count >= 3:\n            # If we can discard three cards of this number\n            new_sum = initial_sum - 3 * number\n            min_sum = min(min_sum, new_sum)\n    \n    # Step 5: Return the minimum sum found\n    return min_sum\n\n# Read input\ncards = list(map(int, input().split()))\n# Print the result\nprint(min_sum_after_discards(cards))"}
{"solution": "def minimum_distance(n, a, checkpoints):\n    # Sort the checkpoints\n    checkpoints.sort()\n    \n    # If n is 1, Vasya doesn't need to visit any checkpoints\n    if n == 1:\n        return 0\n    \n    # Calculate distances for both strategies\n    # Omitting the leftmost checkpoint\n    distance_omit_left = abs(a - checkpoints[-1]) + abs(checkpoints[-1] - checkpoints[-2])\n    \n    # Omitting the rightmost checkpoint\n    distance_omit_right = abs(a - checkpoints[0]) + abs(checkpoints[0] - checkpoints[1])\n    \n    # Return the minimum of the two distances\n    return min(distance_omit_left, distance_omit_right)\n\n# Read input\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Print the result\nprint(minimum_distance(n, a, checkpoints))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(d) for d in str(x))\n\ndef find_smallest_root(n):\n    for x in range(1, 10**6):  # Adjust the upper limit as necessary\n        s_x = sum_of_digits(x)\n        if x * x + s_x * x == n:\n            return x\n    return -1\n\n# Input reading\nn = int(input())\nprint(find_smallest_root(n))"}
{"solution": "def time_to_bed(current_time, sleep_duration):\n    # Parse the current time\n    current_hours, current_minutes = map(int, current_time.split(':'))\n    # Parse the sleep duration\n    sleep_hours, sleep_minutes = map(int, sleep_duration.split(':'))\n    \n    # Convert current time and sleep duration to total minutes\n    current_total_minutes = current_hours * 60 + current_minutes\n    sleep_total_minutes = sleep_hours * 60 + sleep_minutes\n    \n    # Calculate the time when George went to bed\n    bed_time_minutes = current_total_minutes - sleep_total_minutes\n    \n    # If the result is negative, it means he went to bed the previous day\n    if bed_time_minutes < 0:\n        bed_time_minutes += 1440  # Add 24 hours in minutes\n    \n    # Convert back to hours and minutes\n    bed_hours = bed_time_minutes // 60\n    bed_minutes = bed_time_minutes % 60\n    \n    # Format the output to \"hh:mm\"\n    return f\"{bed_hours:02}:{bed_minutes:02}\"\n\n# Read input\ncurrent_time = input().strip()\nsleep_duration = input().strip()\n\n# Calculate and print the time George went to bed\nprint(time_to_bed(current_time, sleep_duration))"}
{"solution": "def longest_max_mean_subsegment(n, a):\n    # Step 1: Find the maximum value in the array\n    max_value = max(a)\n    \n    # Step 2: Find the longest contiguous subsegment of max_value\n    longest_length = 0\n    current_length = 0\n    \n    for value in a:\n        if value == max_value:\n            current_length += 1\n            longest_length = max(longest_length, current_length)\n        else:\n            current_length = 0\n    \n    return longest_length\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nprint(longest_max_mean_subsegment(n, a))"}
{"solution": "def count_painting_ways(n, m, k):\n    MOD = 998244353\n    \n    # Initialize the DP table\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    # Base case\n    dp[1][0] = m  # One way to paint one brick with no transitions\n    \n    # Fill the DP table\n    for i in range(2, n + 1):\n        for j in range(0, min(k, i - 1) + 1):\n            dp[i][j] = dp[i - 1][j] * 1 % MOD  # Same color as previous\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * (m - 1)) % MOD  # Different color\n    \n    return dp[n][k]\n\n# Read input\nn, m, k = map(int, input().split())\n# Print the result\nprint(count_painting_ways(n, m, k))"}
{"solution": "def is_magic_number(n):\n    s = str(n)\n    i = len(s) - 1\n    \n    while i >= 0:\n        if s[i] == '1':\n            i -= 1\n        elif i > 0 and s[i-1:i+1] == '14':\n            i -= 2\n        elif i > 1 and s[i-2:i+1] == '144':\n            i -= 3\n        else:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn = int(input().strip())\n# Output the result\nprint(is_magic_number(n))"}
{"solution": "def min_moves_to_corners(n, m, i, j, a, b):\n    corners = [(1, 1), (1, m), (n, 1), (n, m)]\n    min_moves = float('inf')\n\n    for corner in corners:\n        x, y = corner\n        # Check if we can reach the corner (x, y)\n        if (abs(x - i) % a == 0) and (abs(y - j) % b == 0):\n            # Calculate the number of moves needed\n            moves_x = abs(x - i) // a\n            moves_y = abs(y - j) // b\n            # Both moves must be even or both must be odd to reach the corner\n            if (moves_x % 2) == (moves_y % 2):\n                min_moves = min(min_moves, max(moves_x, moves_y))\n\n    if min_moves == float('inf'):\n        return \"Poor Inna and pony!\"\n    else:\n        return min_moves\n\n# Read input\nn, m, i, j, a, b = map(int, input().split())\n# Get the result\nresult = min_moves_to_corners(n, m, i, j, a, b)\n# Print the result\nprint(result)"}
{"solution": "def max_removals(s):\n    n = len(s)\n    removed_count = 0\n    can_remove = True\n    \n    while can_remove:\n        can_remove = False\n        to_remove = []\n        \n        for i in range(n):\n            if (i > 0 and s[i] == chr(ord(s[i-1]) + 1)) or (i < n - 1 and s[i] == chr(ord(s[i+1]) + 1)):\n                to_remove.append(i)\n        \n        # Remove characters in reverse order to avoid index shifting issues\n        for i in reversed(to_remove):\n            s = s[:i] + s[i+1:]\n            removed_count += 1\n        \n        n = len(s)  # Update the length of the string\n        if to_remove:\n            can_remove = True  # If we removed something, we can check again\n    \n    return removed_count\n\n# Input reading\nlength_of_s = int(input())\ns = input().strip()\n\n# Output the result\nprint(max_removals(s))"}
{"solution": "def min_bills(n, k, denominations, q, requests):\n    results = []\n    \n    for amount in requests:\n        min_bills_needed = float('inf')\n        \n        # Check all pairs of denominations (including the same denomination)\n        for i in range(n):\n            for j in range(i, n):\n                d1 = denominations[i]\n                d2 = denominations[j]\n                \n                # Try to use d1 and d2 to form the amount\n                for x in range(k + 1):\n                    # x is the number of d1 bills\n                    if x * d1 > amount:\n                        break\n                    \n                    remaining = amount - x * d1\n                    if remaining < 0:\n                        continue\n                    \n                    # Calculate how many d2 bills are needed\n                    if d2 > 0:\n                        y = (remaining + d2 - 1) // d2  # Ceiling division\n                    else:\n                        y = 0\n                    \n                    total_bills = x + y\n                    \n                    if total_bills <= k and remaining >= 0 and y * d2 + x * d1 == amount:\n                        min_bills_needed = min(min_bills_needed, total_bills)\n        \n        if min_bills_needed == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_bills_needed)\n    \n    return results\n\n# Read input\nn, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\nrequests = [int(input()) for _ in range(q)]\n\n# Get results\nresults = min_bills(n, k, denominations, q, requests)\n\n# Print output\nfor result in results:\n    print(result)"}
{"solution": "def minimum_time_to_travel(s, x1, x2, t1, t2, p, d):\n    # Calculate the distance Igor needs to travel\n    distance = abs(x2 - x1)\n    \n    # Time if Igor walks directly to x2\n    time_if_walk = distance * t2\n    \n    # Function to calculate the time for the tram to reach a certain position\n    def tram_time_to_position(position):\n        if d == 1:  # Tram moving towards s\n            if position < p:\n                return float('inf')  # Tram can't go back\n            elif position > s:\n                return float('inf')  # Invalid position\n            else:\n                distance_to_tram = position - p\n                time_to_reach = distance_to_tram * t1\n                return time_to_reach\n        else:  # Tram moving towards 0\n            if position > p:\n                return float('inf')  # Tram can't go forward\n            elif position < 0:\n                return float('inf')  # Invalid position\n            else:\n                distance_to_tram = p - position\n                time_to_reach = distance_to_tram * t1\n                return time_to_reach\n\n    # Calculate the minimum time considering waiting for the tram\n    min_time = time_if_walk  # Start with the time if walking directly\n\n    # Check all possible positions Igor can reach by walking\n    for target in range(s + 1):\n        time_to_target = abs(target - x1) * t2\n        time_for_tram = tram_time_to_position(target)\n        \n        if time_for_tram != float('inf'):\n            total_time = time_to_target + time_for_tram + abs(x2 - target) * t1\n            min_time = min(min_time, total_time)\n\n    return min_time\n\n# Input reading\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Calculate and print the minimum time\nresult = minimum_time_to_travel(s, x1, x2, t1, t2, p, d)\nprint(result)"}
{"solution": "def count_occurrences(n, x):\n    count = 0\n    for i in range(1, n + 1):\n        if x % i == 0:  # Check if i is a divisor of x\n            j = x // i  # Calculate j\n            if j <= n:  # Check if j is within the bounds\n                count += 1\n    return count\n\n# Read input\nn, x = map(int, input().split())\n# Get the result\nresult = count_occurrences(n, x)\n# Print the result\nprint(result)"}
{"solution": "def generate_password(n, k):\n    # Create a list of the first k lowercase letters\n    letters = [chr(i) for i in range(ord('a'), ord('a') + k)]\n    \n    # Initialize the password\n    password = []\n    \n    # Fill the password while ensuring no two consecutive characters are the same\n    for i in range(n):\n        password.append(letters[i % k])\n    \n    # Join the list into a string and return\n    return ''.join(password)\n\n# Read input\nn, k = map(int, input().split())\n\n# Generate and print the password\nprint(generate_password(n, k))"}
{"solution": "def first_collision(n, directions, positions):\n    min_time = float('inf')\n    \n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            # Calculate the time of collision\n            time = (positions[i + 1] - positions[i]) // 2\n            min_time = min(min_time, time)\n    \n    return min_time if min_time != float('inf') else -1\n\n# Input reading\nn = int(input().strip())\ndirections = input().strip()\npositions = list(map(int, input().strip().split()))\n\n# Get the result and print it\nresult = first_collision(n, directions, positions)\nprint(result)"}
{"solution": "def can_fit(w1, h1, w2, h2, a, b):\n    # Check if two seals can fit side by side or one on top of the other\n    return (w1 + w2 <= a and max(h1, h2) <= b) or (max(w1, w2) <= a and h1 + h2 <= b)\n\ndef max_seal_area(n, a, b, seals):\n    max_area = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            # Get dimensions of the first seal\n            x1, y1 = seals[i]\n            # Get dimensions of the second seal\n            x2, y2 = seals[j]\n            \n            # Check all combinations of orientations\n            for w1, h1 in [(x1, y1), (y1, x1)]:\n                for w2, h2 in [(x2, y2), (y2, x2)]:\n                    if can_fit(w1, h1, w2, h2, a, b):\n                        area = w1 * h1 + w2 * h2\n                        max_area = max(max_area, area)\n    \n    return max_area\n\n# Input parsing\nn, a, b = map(int, input().split())\nseals = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the maximum area\nresult = max_seal_area(n, a, b, seals)\nprint(result)"}
{"solution": "from collections import Counter\n\n# Read input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(4 * n + 1)]\n\n# Extract x and y coordinates\nx_coords = [p[0] for p in points]\ny_coords = [p[1] for p in points]\n\n# Determine boundaries\nmin_x = min(x_coords)\nmax_x = max(x_coords)\nmin_y = min(y_coords)\nmax_y = max(y_coords)\n\n# Count occurrences of each coordinate\nx_count = Counter(x_coords)\ny_count = Counter(y_coords)\n\n# Find the outlier point\nfor point in points:\n    x, y = point\n    if (x == min_x or x == max_x) and x_count[x] != n:\n        print(point[0], point[1])\n        break\n    if (y == min_y or y == max_y) and y_count[y] != n:\n        print(point[0], point[1])\n        break"}
{"solution": "def product_of_digits(x):\n    product = 1\n    while x > 0:\n        product *= x % 10\n        x //= 10\n    return product\n\ndef max_product(n):\n    str_n = str(n)\n    max_product_value = product_of_digits(n)  # Start with the product of n itself\n    \n    # Iterate through each digit\n    for i in range(len(str_n)):\n        if str_n[i] == '0':\n            continue  # Skip if the digit is 0\n        \n        # Create a new number by reducing the current digit\n        new_number = str_n[:i]  # Take the part before the current digit\n        new_digit = str(int(str_n[i]) - 1)  # Reduce the current digit by 1\n        new_number += new_digit  # Add the new digit\n        new_number += '9' * (len(str_n) - i - 1)  # Add 9s for the rest\n        \n        # Convert back to integer\n        new_number = int(new_number)\n        \n        # Calculate the product of digits of the new number\n        max_product_value = max(max_product_value, product_of_digits(new_number))\n    \n    return max_product_value\n\n# Input reading\nn = int(input().strip())\nprint(max_product(n))"}
{"solution": "import math\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate total votes for Elodreip\nE = sum(a)\n\n# Calculate the minimum k needed to win\nmin_k = max(math.ceil(2 * E / n), max(a))\n\n# Output the result\nprint(min_k)"}
{"solution": "def count_operations(points):\n    operations = 0\n    while True:\n        to_delete = set()\n        n = len(points)\n        \n        for i in range(n):\n            if (i > 0 and points[i] != points[i - 1]) or (i < n - 1 and points[i] != points[i + 1]):\n                to_delete.add(i)\n        \n        if not to_delete:\n            break\n        \n        operations += 1\n        points = ''.join(points[i] for i in range(n) if i not in to_delete)\n    \n    return operations\n\n# Read input\ninput_points = input().strip()\n# Get the number of operations\nresult = count_operations(input_points)\n# Print the result\nprint(result)"}
{"solution": "from collections import Counter\nfrom math import comb\n\ndef count_min_product_triples(n, a):\n    # Count occurrences of each number\n    count = Counter(a)\n    \n    # Get the three smallest distinct numbers\n    distinct_numbers = sorted(count.keys())\n    \n    if len(distinct_numbers) < 3:\n        # If there are less than 3 distinct numbers, we cannot form a valid triple\n        return 0\n    \n    # The three smallest distinct numbers\n    x1, x2, x3 = distinct_numbers[0], distinct_numbers[1], distinct_numbers[2]\n    \n    # Calculate the minimum product\n    min_product = x1 * x2 * x3\n    \n    # Count the number of ways to form the triples\n    if count[x1] >= 3:\n        # Case where the smallest number appears at least 3 times\n        return comb(count[x1], 3)\n    elif count[x1] >= 2 and count[x2] >= 1:\n        # Case where the smallest number appears at least 2 times and the second smallest at least 1 time\n        return comb(count[x1], 2) * count[x2]\n    elif count[x1] >= 1 and count[x2] >= 2:\n        # Case where the smallest number appears at least 1 time and the second smallest at least 2 times\n        return comb(count[x2], 2) * count[x1]\n    else:\n        # Case where all three smallest numbers appear at least once\n        return count[x1] * count[x2] * count[x3]\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(count_min_product_triples(n, a))"}
{"solution": "def number_of_cuts(n):\n    m = n + 1  # Total number of slices\n    if m % 2 == 0:\n        return m // 2  # If m is even\n    else:\n        return m  # If m is odd\n\nn = int(input().strip())\nprint(number_of_cuts(n))"}
{"solution": "def maximize_bank_account(n):\n    # If the number is positive, return it as is\n    if n >= 0:\n        return n\n    \n    # Convert the number to string to manipulate digits\n    str_n = str(n)\n    \n    # Option 1: Remove the last digit\n    option1 = int(str_n[:-1])\n    \n    # Option 2: Remove the second to last digit\n    option2 = int(str_n[:-2] + str_n[-1]) if len(str_n) > 2 else option1\n    \n    # Return the maximum of the original number, option1, and option2\n    return max(n, option1, option2)\n\n# Read input\nn = int(input().strip())\n# Print the result\nprint(maximize_bank_account(n))"}
{"solution": "def determine_spinner_direction(start, end, n):\n    positions = {'v': 0, '<': 1, '^': 2, '>': 3}\n    \n    start_index = positions[start]\n    end_index = positions[end]\n    \n    # Calculate the ending positions\n    cw_end = (start_index + n) % 4\n    ccw_end = (start_index - n + 4) % 4  # Adding 4 to avoid negative index\n    \n    if cw_end == end_index:\n        return \"cw\"\n    elif ccw_end == end_index:\n        return \"ccw\"\n    else:\n        return \"undefined\"\n\n# Read input\ninput_data = input().strip().splitlines()\nstart, end = input_data[0].split()\nn = int(input_data[1])\n\n# Determine the direction and print the result\nresult = determine_spinner_direction(start, end, n)\nprint(result)"}
{"solution": "def count_standing_dominoes(n, s):\n    # Create a list to represent the final state of the dominoes\n    final_state = list(s)\n    \n    # Process the dominoes from left to right\n    for i in range(n):\n        if final_state[i] == 'R':\n            j = i + 1\n            while j < n and final_state[j] == '.':\n                final_state[j] = 'R'  # Mark as falling to the right\n                j += 1\n            if j < n and final_state[j] == 'L':\n                # We have a conflict between R and L\n                left_count = (j - i - 1) // 2\n                right_count = (j - i - 1) - left_count\n                if (j - i - 1) % 2 == 1:\n                    final_state[i + left_count + 1] = '.'  # One remains standing\n                # All others will fall\n                for k in range(i + left_count + 1, j):\n                    final_state[k] = '.'\n    \n    # Process the dominoes from right to left\n    for i in range(n - 1, -1, -1):\n        if final_state[i] == 'L':\n            j = i - 1\n            while j >= 0 and final_state[j] == '.':\n                final_state[j] = 'L'  # Mark as falling to the left\n                j -= 1\n            if j >= 0 and final_state[j] == 'R':\n                # We have a conflict between L and R\n                left_count = (i - j - 1) // 2\n                right_count = (i - j - 1) - left_count\n                if (i - j - 1) % 2 == 1:\n                    final_state[j + right_count + 1] = '.'  # One remains standing\n                # All others will fall\n                for k in range(j + right_count + 1, i):\n                    final_state[k] = '.'\n\n    # Count the number of standing dominoes\n    standing_count = final_state.count('.')\n    \n    return standing_count\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(count_standing_dominoes(n, s))"}
{"solution": "def restore_permutation(n, m, leaders):\n    a = [0] * n  # Initialize the permutation array\n    used = [False] * (n + 1)  # Track used numbers from 1 to n\n\n    for j in range(m - 1):\n        current_leader = leaders[j] - 1  # Convert to 0-based index\n        next_leader = leaders[j + 1] - 1  # Convert to 0-based index\n        \n        # Calculate the required value for a[current_leader]\n        step = (next_leader - current_leader + n) % n\n        if step == 0:\n            step = n  # If step is 0, it means we count n steps\n        \n        if a[current_leader] == 0:\n            a[current_leader] = step\n            used[step] = True\n        elif a[current_leader] != step:\n            return -1  # Conflict in values\n\n    # Fill in the remaining values\n    for i in range(n):\n        if a[i] == 0:\n            for num in range(1, n + 1):\n                if not used[num]:\n                    a[i] = num\n                    used[num] = True\n                    break\n\n    # Check if we have a valid permutation\n    if len(set(a)) != n:\n        return -1  # Not a valid permutation\n\n    return a\n\n# Read input\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\nresult = restore_permutation(n, m, leaders)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "def maximize_number(a, k):\n    a_str = list(str(a))\n    n = len(a_str)\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        \n        # Find the maximum digit we can bring to position i\n        max_digit = a_str[i]\n        max_index = i\n        \n        # Look ahead up to k positions\n        for j in range(i + 1, min(n, i + k + 1)):\n            if a_str[j] > max_digit:\n                max_digit = a_str[j]\n                max_index = j\n        \n        # If we found a larger digit, we need to swap it to position i\n        if max_index != i:\n            # Calculate how many swaps are needed\n            swaps_needed = max_index - i\n            \n            # If we can afford the swaps\n            if swaps_needed <= k:\n                # Perform the swaps\n                for j in range(max_index, i, -1):\n                    a_str[j], a_str[j - 1] = a_str[j - 1], a_str[j]\n                \n                # Decrease k by the number of swaps used\n                k -= swaps_needed\n    \n    return ''.join(a_str)\n\n# Read input\na, k = map(int, input().split())\n# Print the result\nprint(maximize_number(a, k))"}
{"solution": "def next_in_sequence(nums):\n    a1, a2, a3, a4 = nums\n    \n    # Check for Arithmetic Progression\n    d1 = a2 - a1\n    d2 = a3 - a2\n    d3 = a4 - a3\n    \n    if d1 == d2 == d3:\n        next_ap = a4 + d1\n        return next_ap\n    \n    # Check for Geometric Progression\n    if a1 != 0 and a2 != 0 and a3 != 0 and a4 != 0:\n        q1 = a2 / a1\n        q2 = a3 / a2\n        q3 = a4 / a3\n        \n        if q1 == q2 == q3 and q1 != 1:\n            next_gp = a4 * q1\n            if next_gp.is_integer():\n                return int(next_gp)\n    \n    # If neither progression or next term is not an integer\n    return 42\n\n# Read input\ninput_numbers = list(map(int, input().strip().split()))\nprint(next_in_sequence(input_numbers))"}
{"solution": "def max_distance_between_houses(n, colors):\n    # Dictionary to store the first and last occurrence of each color\n    color_positions = {}\n    \n    for index in range(n):\n        color = colors[index]\n        if color not in color_positions:\n            color_positions[color] = [index, index]  # [first occurrence, last occurrence]\n        else:\n            color_positions[color][1] = index  # Update last occurrence\n    \n    max_distance = 0\n    \n    # Get all unique colors\n    unique_colors = list(color_positions.keys())\n    \n    # Compare distances between first and last occurrences of different colors\n    for i in range(len(unique_colors)):\n        for j in range(i + 1, len(unique_colors)):\n            color1 = unique_colors[i]\n            color2 = unique_colors[j]\n            \n            # Get the positions\n            first1, last1 = color_positions[color1]\n            first2, last2 = color_positions[color2]\n            \n            # Calculate distances\n            distance1 = abs(last1 - first2)  # last of color1 to first of color2\n            distance2 = abs(last2 - first1)  # last of color2 to first of color1\n            \n            # Update max distance\n            max_distance = max(max_distance, distance1, distance2)\n    \n    return max_distance\n\n# Input reading\nn = int(input())\ncolors = list(map(int, input().split()))\n\n# Output the result\nprint(max_distance_between_houses(n, colors))"}
{"solution": "def find_seat(n, m, k):\n    # Calculate the lane number\n    r = (k - 1) // (2 * m) + 1\n    \n    # Calculate the index within the lane\n    index_in_lane = (k - 1) % (2 * m)\n    \n    # Calculate the desk number\n    d = (index_in_lane // 2) + 1\n    \n    # Determine the side (L or R)\n    side = 'L' if index_in_lane % 2 == 0 else 'R'\n    \n    return r, d, side\n\n# Read input\nn, m, k = map(int, input().split())\nresult = find_seat(n, m, k)\nprint(result[0], result[1], result[2])"}
{"solution": "def possible_final_colors(n, s):\n    r = s.count('R')\n    g = s.count('G')\n    b = s.count('B')\n\n    # Determine the parity of each color count\n    r_odd = r % 2\n    g_odd = g % 2\n    b_odd = b % 2\n\n    possible_colors = set()\n\n    # Check the parity conditions to determine possible final colors\n    if r_odd + g_odd + b_odd == 0:  # All even\n        if r > 0 or g > 0 or b > 0:\n            possible_colors.add('R')\n            possible_colors.add('G')\n            possible_colors.add('B')\n    elif r_odd + g_odd + b_odd == 1:  # One odd\n        if r_odd:\n            possible_colors.add('R')\n        if g_odd:\n            possible_colors.add('G')\n        if b_odd:\n            possible_colors.add('B')\n    elif r_odd + g_odd + b_odd == 2:  # Two odd\n        if r_odd:\n            possible_colors.add('G')\n            possible_colors.add('B')\n        if g_odd:\n            possible_colors.add('R')\n            possible_colors.add('B')\n        if b_odd:\n            possible_colors.add('R')\n            possible_colors.add('G')\n    else:  # All odd\n        possible_colors.add('R')\n        possible_colors.add('G')\n        possible_colors.add('B')\n\n    # Return the sorted possible colors as a string\n    return ''.join(sorted(possible_colors))\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(possible_final_colors(n, s))"}
