{"solution": "def max_acordion_length(s):\n    # Initialize variables to track the positions of the first and last brackets\n    first_open = s.find('[')\n    last_close = s.rfind(']')\n    \n    # If there are no opening or closing brackets, return -1\n    if first_open == -1 or last_close == -1 or first_open >= last_close:\n        return -1\n    \n    # Now we need to find the first colon after the first open bracket\n    first_colon_after_open = s.find(':', first_open)\n    \n    # If there's no colon after the first open bracket, return -1\n    if first_colon_after_open == -1 or first_colon_after_open >= last_close:\n        return -1\n    \n    # Now we need to find the last colon before the last closing bracket\n    last_colon_before_close = s.rfind(':', first_colon_after_open, last_close)\n    \n    # If there's no colon before the last closing bracket, return -1\n    if last_colon_before_close == -1:\n        return -1\n    \n    # Count the number of vertical lines between the two colons\n    vertical_lines_count = s[first_colon_after_open + 1:last_colon_before_close].count('|')\n    \n    # The length of the accordion is the length of the brackets and colons plus the vertical lines\n    accordion_length = 4 + vertical_lines_count\n    \n    return accordion_length\n\n# Read input\ns = input().strip()\n# Get the maximum accordion length\nresult = max_acordion_length(s)\n# Print the result\nprint(result)"}
{"solution": "def max_digit_sum_number(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    # Start with the original number\n    max_number = x\n    max_digit_sum = sum(int(d) for d in str_x)\n    \n    # Try to create a number by reducing digits\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit and setting all following digits to '9'\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n        \n        if new_number > 0 and new_number <= x:\n            new_digit_sum = sum(int(d) for d in str(new_number))\n            if new_digit_sum > max_digit_sum or (new_digit_sum == max_digit_sum and new_number > max_number):\n                max_number = new_number\n                max_digit_sum = new_digit_sum\n    \n    return max_number\n\n# Read input\nx = int(input().strip())\n# Get the result\nresult = max_digit_sum_number(x)\n# Print the result\nprint(result)"}
{"solution": "def is_lucky_year(year):\n    # Count the number of non-zero digits in the year\n    non_zero_count = sum(1 for digit in str(year) if digit != '0')\n    return non_zero_count <= 1\n\ndef next_lucky_year(current_year):\n    # Start checking from the next year\n    next_year = current_year + 1\n    while not is_lucky_year(next_year):\n        next_year += 1\n    return next_year\n\ndef years_until_next_lucky(current_year):\n    next_year = next_lucky_year(current_year)\n    return next_year - current_year\n\n# Read input\nn = int(input())\n# Calculate and print the result\nprint(years_until_next_lucky(n))"}
{"solution": "def max_painted_sections(n, q, painters):\n    # Create a list to track the coverage of each section\n    coverage = [0] * (n + 1)\n\n    # Count the coverage for each painter\n    for l, r in painters:\n        for i in range(l, r + 1):\n            coverage[i] += 1\n\n    # Calculate the total painted sections if we hire all painters\n    total_painted = sum(1 for i in range(1, n + 1) if coverage[i] > 0)\n\n    # If we hire q - 2 painters, we need to find the two painters that cover the most sections\n    # We will calculate the contribution of each painter\n    contributions = []\n    for l, r in painters:\n        contribution = sum(1 for i in range(l, r + 1) if coverage[i] == 1)\n        contributions.append(contribution)\n\n    # Sort contributions in descending order\n    contributions.sort(reverse=True)\n\n    # The maximum painted sections will be total painted minus the contributions of the two least contributing painters\n    if len(contributions) > 2:\n        max_painted = total_painted - contributions[-1] - contributions[-2]\n    else:\n        max_painted = total_painted\n\n    return max(max_painted, 0)\n\n# Read input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get the result and print it\nresult = max_painted_sections(n, q, painters)\nprint(result)"}
{"solution": "def is_lucky_time(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef find_min_snooze_presses(x, hh, mm):\n    presses = 0\n    while True:\n        if is_lucky_time(hh, mm):\n            return presses\n        # Decrease the time by x minutes\n        mm -= x\n        if mm < 0:\n            mm += 60\n            hh -= 1\n            if hh < 0:\n                hh += 24\n        presses += 1\n\n# Read input\nx = int(input().strip())\nhh, mm = map(int, input().strip().split())\n\n# Calculate and print the result\nresult = find_min_snooze_presses(x, hh, mm)\nprint(result)"}
{"solution": "def min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0\n    elif l == 1:\n        return abs(pos - r) + 1\n    elif r == n:\n        return abs(pos - l) + 1\n    else:\n        return min(abs(pos - l), abs(pos - r)) + (r - l) + 2\n\n# Read input\nn, pos, l, r = map(int, input().split())\n# Print the result\nprint(min_seconds_to_close_tabs(n, pos, l, r))"}
{"solution": "def min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for i in range(t):\n        n, x = queries[i][0]\n        blows = queries[i][1]\n        \n        # Initialize the best blow values\n        best_d = 0\n        best_h = float('inf')\n        \n        for d, h in blows:\n            if d > best_d:\n                best_d = d\n                best_h = h\n            elif d == best_d:\n                best_h = min(best_h, h)\n        \n        # If the best blow can defeat Zmei in one hit\n        if best_d >= x:\n            results.append(1)\n            continue\n        \n        # If the best blow cannot defeat Zmei and it grows more heads than we can cut\n        if best_h >= best_d:\n            results.append(-1)\n            continue\n        \n        # Calculate the number of blows needed\n        blows_needed = 0\n        while x > 0:\n            blows_needed += 1\n            x -= best_d\n            if x > 0:\n                x += best_h\n        \n        results.append(blows_needed)\n    \n    return results\n\n# Read input\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append(((n, x), blows))\n\n# Get results\nresults = min_blows_to_defeat_zmei(t, queries)\n\n# Print output\nfor result in results:\n    print(result)"}
{"solution": "def find_empty_day(n, m):\n    day = 0\n    current_grains = n\n    \n    while current_grains > 0:\n        day += 1\n        # Add grains to the barn\n        current_grains += m\n        # If the barn is over capacity, it stays full\n        if current_grains > n:\n            current_grains = n\n        # Sparrows eat grains\n        current_grains -= day\n        \n    return day\n\n# Read input\nn, m = map(int, input().split())\n# Get the result\nresult = find_empty_day(n, m)\n# Print the result\nprint(result)"}
{"solution": "def min_draws_to_win(tiles):\n    # Parse the input tiles\n    tile1, tile2, tile3 = tiles.split()\n    \n    # Extract numbers and suits\n    num1, suit1 = int(tile1[0]), tile1[1]\n    num2, suit2 = int(tile2[0]), tile2[1]\n    num3, suit3 = int(tile3[0]), tile3[1]\n    \n    # Check for koutsu (triplet)\n    if tile1 == tile2 == tile3:\n        return 0\n    \n    # Check for shuntsu (sequence)\n    def is_shuntsu(n1, n2, n3):\n        return sorted([n1, n2, n3]) in [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9]]\n    \n    if suit1 == suit2 == suit3 and is_shuntsu(num1, num2, num3):\n        return 0\n    \n    # Check for possible koutsu with one more draw\n    if tile1 == tile2 or tile1 == tile3 or tile2 == tile3:\n        return 1\n    \n    # Check for possible shuntsu with one more draw\n    def needs_one_for_shuntsu(n1, n2):\n        return abs(n1 - n2) == 1 or abs(n1 - n2) == 2\n    \n    if suit1 == suit2 and needs_one_for_shuntsu(num1, num2):\n        return 1\n    if suit1 == suit3 and needs_one_for_shuntsu(num1, num3):\n        return 1\n    if suit2 == suit3 and needs_one_for_shuntsu(num2, num3):\n        return 1\n    \n    # If no koutsu or shuntsu can be formed with one more draw, return 2\n    return 2\n\n# Read input\ntiles = input().strip()\n# Print the output\nprint(min_draws_to_win(tiles))"}
{"solution": "def find_grandpa_sofa(d, n, m, sofas, counts):\n    cnt_l, cnt_r, cnt_t, cnt_b = counts\n    sofa_positions = []\n\n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        sofa_positions.append((x1, y1, x2, y2))\n\n    for i in range(d):\n        x1, y1, x2, y2 = sofa_positions[i]\n        left_count = right_count = top_count = bottom_count = 0\n\n        for j in range(d):\n            if i == j:\n                continue\n            x1_j, y1_j, x2_j, y2_j = sofa_positions[j]\n\n            # Check left\n            if (x1 < x1_j and y1 == y1_j) or (x2 < x1_j and y2 == y1_j):\n                left_count += 1\n            # Check right\n            if (x1 > x2_j and y1 == y1_j) or (x2 > x2_j and y2 == y1_j):\n                right_count += 1\n            # Check top\n            if (y1 < y1_j and x1 == x1_j) or (y2 < y1_j and x2 == y1_j):\n                top_count += 1\n            # Check bottom\n            if (y1 > y2_j and x1 == x1_j) or (y2 > y2_j and x2 == y1_j):\n                bottom_count += 1\n\n        if (left_count == cnt_l and right_count == cnt_r and\n                top_count == cnt_t and bottom_count == cnt_b):\n            return i + 1  # Return 1-based index\n\n    return -1  # No matching sofa found\n\n\n# Input reading\nd = int(input().strip())\nn, m = map(int, input().strip().split())\nsofas = [tuple(map(int, input().strip().split())) for _ in range(d)]\ncounts = tuple(map(int, input().strip().split()))\n\n# Finding the sofa\nresult = find_grandpa_sofa(d, n, m, sofas, counts)\nprint(result)"}
{"solution": "def mars_days_off(n):\n    full_weeks = n // 7\n    remaining_days = n % 7\n    \n    min_days_off = full_weeks * 2\n    max_days_off = full_weeks * 2 + min(remaining_days, 2)\n    \n    return min_days_off, max_days_off\n\nn = int(input())\nmin_days_off, max_days_off = mars_days_off(n)\nprint(min_days_off, max_days_off)"}
{"solution": "def max_chocolates(n, a, b, p, q):\n    # Count the number of tiles that can be painted Red\n    red_count = n // a\n    # Count the number of tiles that can be painted Blue\n    blue_count = n // b\n    # Count the number of tiles that can be painted both Red and Blue\n    both_count = n // (a * b // gcd(a, b))\n    \n    # Calculate the effective counts\n    effective_red_count = red_count - both_count\n    effective_blue_count = blue_count - both_count\n    \n    # Calculate total chocolates\n    total_chocolates = (effective_red_count * p) + (effective_blue_count * q) + (both_count * max(p, q))\n    \n    return total_chocolates\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n# Read input\nn, a, b, p, q = map(int, input().split())\n# Calculate and print the maximum number of chocolates\nprint(max_chocolates(n, a, b, p, q))"}
{"solution": "def max_beauty_after_swap(n, trophies):\n    # Step 1: Find the lengths of contiguous segments of 'G'\n    segments = []\n    current_length = 0\n    \n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n    \n    # Append the last segment if it ends with 'G'\n    if current_length > 0:\n        segments.append(current_length)\n    \n    # If there are no segments of 'G', the answer is 0\n    if not segments:\n        return 0\n    \n    # Step 2: Calculate the maximum length of 'G' segments\n    max_length = max(segments)\n    \n    # Step 3: Check if we can increase the length by swapping\n    if len(segments) > 1:\n        # If there are at least two segments, we can potentially merge them\n        max_length = max(max_length, segments[0] + segments[1] + 1)\n    \n    return max_length\n\n# Input reading\nn = int(input().strip())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_after_swap(n, trophies))"}
{"solution": "from collections import defaultdict, deque\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, k = map(int, data[0].split())\n    main_courses = list(map(int, data[1].split()))\n    \n    dependencies = defaultdict(list)\n    indegree = [0] * (n + 1)\n    \n    for i in range(2, n + 2):\n        line = list(map(int, data[i].split()))\n        t_i = line[0]\n        for j in range(1, t_i + 1):\n            dependencies[line[j]].append(i - 1)  # i - 2 + 1 = i - 1 (1-indexed to 0-indexed)\n            indegree[i - 1] += 1\n    \n    # To track courses that need to be taken\n    courses_to_take = set(main_courses)\n    for course in main_courses:\n        if indegree[course - 1] == 0:\n            courses_to_take.add(course)\n    \n    # Topological sort using Kahn's algorithm\n    queue = deque()\n    for i in range(n):\n        if indegree[i] == 0:\n            queue.append(i + 1)  # Convert back to 1-indexed\n    \n    order = []\n    while queue:\n        current = queue.popleft()\n        order.append(current)\n        \n        for neighbor in dependencies[current]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor + 1)  # Convert back to 1-indexed\n    \n    # Check if we can take all main courses\n    if not all(course in order for course in main_courses):\n        print(-1)\n        return\n    \n    # Collect the courses that need to be taken\n    taken_courses = set()\n    result_order = []\n    \n    for course in order:\n        if course in courses_to_take:\n            taken_courses.add(course)\n            result_order.append(course)\n            if len(taken_courses) == len(courses_to_take):\n                break\n    \n    # Output the result\n    print(len(result_order))\n    print(\" \".join(map(str, result_order)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_stack_sortable(n, k, p):\n    # Initialize the stack and the result array\n    stack = []\n    result = p[:]\n    \n    # Create a set of used elements from the first k elements\n    used = set(p)\n    \n    # The next number we can use to fill the permutation\n    next_num = n\n    \n    # Iterate through the first k elements\n    for i in range(k):\n        # While the stack is not empty and the top of the stack is less than the next number\n        while stack and stack[-1] < next_num:\n            result.append(stack.pop())\n        \n        # If the current number is greater than the next number, we cannot sort\n        if p[i] > next_num:\n            return -1\n        \n        # Push the current number onto the stack\n        stack.append(p[i])\n        \n        # Decrease the next number\n        next_num -= 1\n    \n    # After processing the first k elements, we need to fill the rest of the permutation\n    while next_num > 0:\n        # If the next number is already used, skip it\n        if next_num not in used:\n            # Push the next number onto the stack\n            stack.append(next_num)\n        next_num -= 1\n    \n    # Now pop all remaining elements from the stack to the result\n    while stack:\n        result.append(stack.pop())\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = is_stack_sortable(n, k, p)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "def does_b_appear_in_sequence(a, b, c):\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n# Read input\na, b, c = map(int, input().split())\n# Print the result\nprint(does_b_appear_in_sequence(a, b, c))"}
{"solution": "def can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    # Check if the number of opening brackets can match the number of closing brackets\n    if cnt_1 == cnt_4:\n        # Check if we can maintain proper nesting\n        if cnt_1 + cnt_2 >= cnt_3:\n            return 1\n    return 0\n\n# Read input values\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\n# Print the result\nprint(can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4))"}
{"solution": "def standing_spectators(n, k, t):\n    if t <= k:\n        return t\n    elif t <= n:\n        return k\n    else:\n        return n + k - t\n\n# Read input\nn, k, t = map(int, input().split())\n# Calculate and print the number of standing spectators\nprint(standing_spectators(n, k, t))"}
{"solution": "def lexicographically_minimal_string(s):\n    t = []\n    u = []\n    min_char = min(s)\n    s = list(s)\n    \n    while s or t:\n        if t and (not s or t[-1] <= min_char):\n            u.append(t.pop())\n        else:\n            char = s.pop(0)\n            t.append(char)\n            if s:\n                min_char = min(s)\n    \n    return ''.join(u)\n\n# Read input\ns = input().strip()\n# Print the result\nprint(lexicographically_minimal_string(s))"}
{"solution": "def check_records(test_cases):\n    results = []\n    \n    for case in test_cases:\n        n = case[0]\n        records = case[1]\n        \n        valid = True\n        prev_p, prev_c = 0, 0\n        \n        for p, c in records:\n            if p < prev_p or c < prev_c or c > p:\n                valid = False\n                break\n            if p - prev_p < c - prev_c:\n                valid = False\n                break\n            \n            prev_p, prev_c = p, c\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Read input\nT = int(input())\ntest_cases = []\n\nfor _ in range(T):\n    n = int(input())\n    records = [tuple(map(int, input().split())) for _ in range(n)]\n    test_cases.append((n, records))\n\n# Get results\nresults = check_records(test_cases)\n\n# Print output\nfor result in results:\n    print(result)"}
{"solution": "def is_palindrome(time_str):\n    return time_str == time_str[::-1]\n\ndef next_palindromic_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n        \n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n\ndef main():\n    current_time = input().strip()\n    hh, mm = map(int, current_time.split(':'))\n    result = next_palindromic_time(hh, mm)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_distance_after_swap(n, a):\n    min_index = a.index(1)\n    max_index = a.index(n)\n\n    # Calculate the current distance\n    current_distance = abs(min_index - max_index)\n\n    # Possible new distances after one swap\n    new_distance_1 = abs(min_index - (n - 1))  # Swap min with the last element\n    new_distance_2 = abs(max_index - 0)        # Swap max with the first element\n\n    # The maximum distance we can achieve\n    max_distance = max(current_distance, new_distance_1, new_distance_2)\n\n    return max_distance\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_distance_after_swap(n, a))"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    mid = n // 2\n    if n % 2 == 0:\n        first_half = s[:mid]\n        second_half = s[mid:]\n    else:\n        first_half = s[:mid]\n        second_half = s[mid+1:]\n    \n    if first_half == second_half[::-1]:\n        return \"TAK\"\n    else:\n        return \"NIE\"\n\ns = input().strip()\nprint(is_s_palindrome(s))"}
{"solution": "def max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n\n    # Convert a to string to work with its digits\n    str_a = str(a)\n    str_b = str(b)\n\n    # Generate all unique permutations of the digits of a\n    perm_set = set(permutations(str_a))\n\n    # Filter permutations to find the maximum valid one\n    max_valid = -1\n    for perm in perm_set:\n        # Join the tuple of characters to form a number\n        perm_number = int(''.join(perm))\n        # Check if it is valid (not exceeding b and has the same length as a)\n        if perm_number <= b and len(str(perm_number)) == len(str_a):\n            max_valid = max(max_valid, perm_number)\n\n    return max_valid\n\n# Read input\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result\nresult = max_permutation_not_exceeding(a, b)\n\n# Print the result\nprint(result)"}
{"solution": "def can_alice_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal right, diagonal left\n    n = 10  # size of the board\n\n    def check_win(x, y):\n        for dx, dy in directions:\n            count = 1  # count the current position\n            # Check in the positive direction\n            for step in range(1, 5):\n                nx, ny = x + step * dx, y + step * dy\n                if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                    count += 1\n                else:\n                    break\n            # Check in the negative direction\n            for step in range(1, 5):\n                nx, ny = x - step * dx, y - step * dy\n                if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                    count += 1\n                else:\n                    break\n            if count >= 5:\n                return True\n        return False\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                # Temporarily place an 'X' to check for a win\n                board[i][j] = 'X'\n                if check_win(i, j):\n                    return \"YES\"\n                # Remove the temporary 'X'\n                board[i][j] = '.'\n\n    return \"NO\"\n\n# Read the input\nboard = [input().strip() for _ in range(10)]\n# Output the result\nprint(can_alice_win(board))"}
{"solution": "def create_symmetric_matrix(n, k):\n    # Initialize the matrix with zeros\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Fill the matrix symmetrically\n    for i in range(n):\n        for j in range(i, n):\n            if k >= 2 and i != j:  # We can place 1s in both (i, j) and (j, i)\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 2\n            elif k >= 1 and i == j:  # We can place 1 in the diagonal\n                matrix[i][j] = 1\n                k -= 1\n            \n            if k < 0:  # If we run out of k, return -1\n                return -1\n    \n    # If we still have remaining k, it means we couldn't place all 1s\n    if k > 0:\n        return -1\n    \n    return matrix\n\n# Read input\nn, k = map(int, input().split())\n\n# Get the resulting matrix or -1\nresult = create_symmetric_matrix(n, k)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))"}
{"solution": "import sys\n\n# Read input\nx, y, z = map(float, sys.stdin.readline().strip().split())\n\n# Define the expressions\nexpressions = [\n    (x**(y**z), \"x^y^z\"),\n    (x**(z**y), \"x^z^y\"),\n    ((x**y)**z, \"(x^y)^z\"),\n    ((x**z)**y, \"(x^z)^y\"),\n    (y**(x**z), \"y^x^z\"),\n    (y**(z**x), \"y^z^x\"),\n    ((y**x)**z, \"(y^x)^z\"),\n    ((y**z)**x, \"(y^z)^x\"),\n    (z**(x**y), \"z^x^y\"),\n    (z**(y**x), \"z^y^x\"),\n    ((z**x)**y, \"(z^x)^y\"),\n    ((z**y)**x, \"(z^y)^x\"),\n]\n\n# Find the maximum value and the corresponding expression\nmax_value = -1\nmax_index = -1\n\nfor i, (value, expr) in enumerate(expressions):\n    if value > max_value:\n        max_value = value\n        max_index = i\n\n# Output the corresponding expression\nprint(expressions[max_index][1])"}
{"solution": "def min_operations(n, s):\n    # Initialize the minimum operations to the length of the string (typing all characters)\n    min_ops = n\n    \n    # Check for all possible prefixes of the string\n    for i in range(1, n):\n        # If the prefix can be doubled and still be a part of the string\n        if s[:i] == s[i:2*i]:\n            # Calculate operations: type the prefix + copy + remaining characters\n            operations = i + 1 + (n - 2 * i)\n            min_ops = min(min_ops, operations)\n    \n    return min_ops\n\n# Input reading\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(min_operations(n, s))"}
{"solution": "def rename_files(n, files):\n    examples = []\n    regulars = []\n    \n    # Separate examples and regular tests\n    for name, type_ in files:\n        if type_ == '1':\n            examples.append(name)\n        else:\n            regulars.append(name)\n    \n    # Prepare the moves\n    moves = []\n    # Move examples to their new names\n    for i in range(len(examples)):\n        moves.append(f\"move {examples[i]} {i + 1}\")\n    \n    # Move regular tests to their new names\n    for i in range(len(regulars)):\n        moves.append(f\"move {regulars[i]} {len(examples) + i + 1}\")\n    \n    # Output the result\n    print(len(moves))\n    for move in moves:\n        print(move)\n\n# Read input\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\n# Call the function\nrename_files(n, files)"}
{"solution": "def min_replacements_to_lucky_ticket(ticket):\n    # Split the ticket into two halves\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    # Calculate the sums of both halves\n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    # Calculate the difference\n    diff = sum_first - sum_second\n    \n    # If the ticket is already lucky\n    if diff == 0:\n        return 0\n    \n    # We need to make the sums equal\n    # We can either increase the smaller sum or decrease the larger sum\n    # Calculate the absolute difference\n    abs_diff = abs(diff)\n    \n    # Create a list of possible changes\n    changes = []\n    \n    if diff > 0:\n        # We need to decrease the first half or increase the second half\n        changes += [x for x in first_half]  # Decrease first half\n        changes += [9 - x for x in second_half]  # Increase second half\n    else:\n        # We need to increase the first half or decrease the second half\n        changes += [9 - x for x in first_half]  # Increase first half\n        changes += [x for x in second_half]  # Decrease second half\n    \n    # Sort changes in descending order\n    changes.sort(reverse=True)\n    \n    # Count the minimum number of changes needed\n    count = 0\n    for change in changes:\n        abs_diff -= change\n        count += 1\n        if abs_diff <= 0:\n            break\n    \n    return count\n\n# Read input\nticket = input().strip()\n# Get the result\nresult = min_replacements_to_lucky_ticket(ticket)\n# Print the result\nprint(result)"}
{"solution": "def minimum_traps(m, x):\n    return m - 1\n\nm, x = map(int, input().split())\nprint(minimum_traps(m, x))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef birthday_paradox(n, k):\n    MOD = 10**6 + 3\n    days = 1 << n  # This is 2^n\n\n    if k > days:\n        return 1, 1  # If k > days, probability is 1 (at least two share a birthday)\n\n    # Calculate the probability of no shared birthdays\n    numerator = 1\n    denominator = 1\n\n    for i in range(k):\n        numerator *= (days - i)\n        denominator *= days\n        numerator %= MOD\n        denominator %= MOD\n\n    # Probability of at least two sharing a birthday\n    A = (denominator - numerator) % MOD\n    B = denominator\n\n    # Reduce A/B to its irreducible form\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n\n    return A % MOD, B % MOD\n\n# Read input\nn, k = map(int, input().split())\nA, B = birthday_paradox(n, k)\nprint(A, B)"}
{"solution": "def is_valid_journey(n, journey):\n    current_position = 20000  # Start at the North Pole (20,000 km from the South Pole)\n    \n    for t, direction in journey:\n        if current_position == 0:  # At the South Pole\n            if direction != \"North\":\n                return \"NO\"\n        elif current_position == 20000:  # At the North Pole\n            if direction != \"South\":\n                return \"NO\"\n        \n        if direction == \"South\":\n            current_position -= t\n        elif direction == \"North\":\n            current_position += t\n        elif direction == \"West\" or direction == \"East\":\n            # Moving West or East does not change the position in terms of North/South\n            continue\n        \n        # Check if the position goes out of bounds\n        if current_position < 0 or current_position > 20000:\n            return \"NO\"\n    \n    # Final position must be at the North Pole\n    if current_position == 20000:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Input reading\nn = int(input())\njourney = [tuple(input().split()) for _ in range(n)]\njourney = [(int(t), direction) for t, direction in journey]\n\n# Output the result\nprint(is_valid_journey(n, journey))"}
{"solution": "def count_common_integers(a1, b1, a2, b2, L, R):\n    # Function to find the first valid x in the range [L, R]\n    def first_valid_x(a, b, start):\n        if b >= start:\n            return b\n        if (start - b) % a == 0:\n            return start\n        return start + (a - (start - b) % a) % a\n\n    # Function to find the last valid x in the range [L, R]\n    def last_valid_x(a, b, end):\n        if b > end:\n            return None\n        if (end - b) % a == 0:\n            return end\n        return end - (end - b) % a\n\n    # Find the first and last valid x for both progressions\n    first_x1 = first_valid_x(a1, b1, L)\n    last_x1 = last_valid_x(a1, b1, R)\n    \n    first_x2 = first_valid_x(a2, b2, L)\n    last_x2 = last_valid_x(a2, b2, R)\n\n    # If there are no valid x in either progression, return 0\n    if first_x1 is None or last_x1 is None or first_x2 is None or last_x2 is None:\n        return 0\n\n    # Calculate the range of valid x values\n    common_start = max(first_x1, first_x2)\n    common_end = min(last_x1, last_x2)\n\n    if common_start > common_end:\n        return 0\n\n    # Count the number of valid integers in the common range\n    count = (common_end - common_start) // a1 + 1\n    return count\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Get the result and print it\nresult = count_common_integers(a1, b1, a2, b2, L, R)\nprint(result)"}
{"solution": "def can_distribute(n, a, b, x):\n    # Check if we can distribute at least x pieces on each plate\n    plates_for_a = a // x\n    plates_for_b = b // x\n    return plates_for_a + plates_for_b >= n\n\ndef max_min_pieces(n, a, b):\n    left, right = 1, max(a, b)  # The minimum pieces can be 1, maximum can be the largest cake pieces\n    answer = 0\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if can_distribute(n, a, b, mid):\n            answer = mid  # We can distribute at least mid pieces\n            left = mid + 1  # Try for a larger minimum\n        else:\n            right = mid - 1  # Try for a smaller minimum\n            \n    return answer\n\n# Input reading\nn, a, b = map(int, input().split())\n# Calculate and print the result\nprint(max_min_pieces(n, a, b))"}
{"solution": "def is_valid_flag(n, m, field):\n    # Check if the number of rows is divisible by 3\n    if n % 3 != 0:\n        return \"NO\"\n    \n    stripe_height = n // 3\n    colors = set()\n    \n    # Check horizontal stripes\n    for i in range(3):\n        stripe = field[i * stripe_height:(i + 1) * stripe_height]\n        first_row = stripe[0]\n        \n        # Check if all rows in the stripe are the same\n        if any(row != first_row for row in stripe):\n            return \"NO\"\n        \n        # Check if all characters in the stripe are the same\n        if len(set(first_row)) != 1:\n            return \"NO\"\n        \n        colors.add(first_row[0])\n    \n    # Check if we have exactly 3 different colors\n    if len(colors) != 3:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(is_valid_flag(n, m, field))"}
{"solution": "def hexagonal_spiral(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 1\n\n    # Determine which layer the move n is in\n    while n >= moves_in_layer:\n        n -= moves_in_layer\n        layer += 1\n        moves_in_layer = 6 * layer\n\n    # Calculate the coordinates based on the layer and remaining moves\n    x, y = layer, 0\n    if n > 0:\n        # Each segment of the layer has 1/6 of the moves\n        segment_length = layer\n        segment = n // segment_length\n        position_in_segment = n % segment_length\n\n        # Determine the direction based on the segment\n        if segment == 0:  # Right\n            x += position_in_segment\n        elif segment == 1:  # Top-right\n            x += segment_length\n            y += position_in_segment\n        elif segment == 2:  # Top-left\n            x += segment_length - position_in_segment\n            y += segment_length\n        elif segment == 3:  # Left\n            x -= position_in_segment\n            y += segment_length - position_in_segment\n        elif segment == 4:  # Bottom-left\n            x -= segment_length\n            y -= position_in_segment\n        elif segment == 5:  # Bottom-right\n            x -= segment_length - position_in_segment\n            y -= segment_length\n\n    return (x, y)\n\nn = int(input().strip())\nx, y = hexagonal_spiral(n)\nprint(x, y)"}
{"solution": "import math\n\ndef can_break_shield(a, b, c):\n    # Calculate the greatest common divisor of a and b\n    gcd_ab = math.gcd(a, b)\n    \n    # Check if c is divisible by the gcd of a and b\n    if c % gcd_ab == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input values\na, b, c = map(int, input().split())\n\n# Output the result\nprint(can_break_shield(a, b, c))"}
{"solution": "def can_tracks_coincide(n, L, kefa_barriers, sasha_barriers):\n    # Calculate distances between consecutive barriers for Kefa\n    kefa_distances = [(kefa_barriers[(i + 1) % n] - kefa_barriers[i]) % L for i in range(n)]\n    # Calculate distances between consecutive barriers for Sasha\n    sasha_distances = [(sasha_barriers[(i + 1) % n] - sasha_barriers[i]) % L for i in range(n)]\n    \n    # Double the kefa_distances to handle circular rotation\n    doubled_kefa_distances = kefa_distances + kefa_distances\n    \n    # Check if sasha_distances is a sublist of doubled_kefa_distances\n    for i in range(n):\n        if doubled_kefa_distances[i:i + n] == sasha_distances:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_barriers, sasha_barriers))"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    # If the entire string is not a palindrome, return its length\n    if not is_palindrome(s):\n        return n\n    \n    # If the entire string is a palindrome, check for non-palindromic substrings\n    for i in range(n):\n        for j in range(i + 1, n):\n            if not is_palindrome(s[i:j + 1]):\n                return j - i + 1\n    \n    # If all substrings are palindromes\n    return 0\n\n# Read input\ns = input().strip()\n# Print the result\nprint(longest_non_palindrome_substring(s))"}
{"solution": "def determine_round_rating(n, ratings):\n    # Check if any rating has changed\n    for a, b in ratings:\n        if a != b:\n            return \"rated\"\n    \n    # Check if the standings are in non-increasing order of ratings\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            return \"unrated\"\n    \n    return \"maybe\"\n\n# Input reading\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Determine and print the result\nresult = determine_round_rating(n, ratings)\nprint(result)"}
{"solution": "def nearest_zero_distance(n, arr):\n    distances = [0] * n\n    last_zero_index = -float('inf')\n\n    # Forward pass to find distances to the nearest zero on the left\n    for i in range(n):\n        if arr[i] == 0:\n            last_zero_index = i\n            distances[i] = 0\n        else:\n            distances[i] = i - last_zero_index\n\n    last_zero_index = float('inf')\n\n    # Backward pass to find distances to the nearest zero on the right\n    for i in range(n - 1, -1, -1):\n        if arr[i] == 0:\n            last_zero_index = i\n        else:\n            distances[i] = min(distances[i], last_zero_index - i)\n\n    print(' '.join(map(str, distances)))\n\n# Read input\nn = int(input().strip())\narr = list(map(int, input().strip().split()))\n\n# Call the function\nnearest_zero_distance(n, arr)"}
{"solution": "def count_distinct_cyclical_strings(n, s):\n    from itertools import product\n    \n    def is_substring_in_cyclical_shifts(t, s):\n        t_extended = t + t\n        return any(s in t_extended[i:i+len(t)] for i in range(len(t)))\n    \n    distinct_cyclical_strings = set()\n    \n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if is_substring_in_cyclical_shifts(t, s):\n            distinct_cyclical_strings.add(t)\n    \n    return len(distinct_cyclical_strings)\n\n# Input reading\nn = int(input())\ns = input().strip()\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import sys\nimport math\n\ndef minimal_non_oriented_angle(n, vectors):\n    angles = []\n    \n    for i in range(n):\n        x, y = vectors[i]\n        angle = math.atan2(y, x)\n        angles.append((angle, i + 1))  # Store angle and index (1-based)\n\n    # Sort angles\n    angles.sort()\n\n    # To handle the circular nature of angles, we can duplicate the list with adjusted angles\n    extended_angles = angles + [(angle + 2 * math.pi, idx) for angle, idx in angles]\n\n    min_angle = float('inf')\n    best_pair = (0, 0)\n\n    for i in range(n):\n        angle1, idx1 = extended_angles[i]\n        angle2, idx2 = extended_angles[i + 1]\n        \n        # Calculate the non-oriented angle\n        non_oriented_angle = angle2 - angle1\n        \n        if non_oriented_angle < min_angle:\n            min_angle = non_oriented_angle\n            best_pair = (idx1, idx2)\n\n    return best_pair\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    vectors = [tuple(map(int, line.split())) for line in data[1:n + 1]]\n    \n    result = minimal_non_oriented_angle(n, vectors)\n    print(result[0], result[1])"}
{"solution": "def minimal_time(d, k, a, b, t):\n    if d <= k:\n        return d * a\n    \n    # Full segments\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Time for full segments\n    time_for_full_segments = full_segments * k * a + (full_segments - 1) * t\n    \n    # Time for remaining distance\n    if remaining_distance == 0:\n        return time_for_full_segments\n    else:\n        # Option 1: Drive the remaining distance\n        time_drive_remaining = remaining_distance * a + t\n        # Option 2: Walk the remaining distance\n        time_walk_remaining = remaining_distance * b\n        \n        return time_for_full_segments + min(time_drive_remaining, time_walk_remaining)\n\n# Read input\nd, k, a, b, t = map(int, input().split())\n\n# Calculate and print the minimal time\nprint(minimal_time(d, k, a, b, t))"}
{"solution": "def generate_sequence(n, k):\n    # The minimum sum of the first k positive integers is k * (k + 1) // 2\n    min_sum = k * (k + 1) // 2\n    \n    if n < min_sum:\n        return -1  # Not enough to form a strictly increasing sequence of k numbers\n    \n    # The maximum GCD we can use is the largest integer that divides n\n    # and allows us to form a valid sequence\n    max_gcd = n // k\n    \n    # We can form the sequence by using the first k integers multiplied by max_gcd\n    sequence = [(i + 1) * max_gcd for i in range(k)]\n    \n    # Check if the sum of the sequence equals n\n    if sum(sequence) == n:\n        return sequence\n    else:\n        # If the sum is not equal to n, we need to adjust the last element\n        # to make the sum equal to n\n        sequence[-1] += (n - sum(sequence))\n        return sequence\n\n# Read input\nn, k = map(int, input().split())\n\n# Generate the sequence\nresult = generate_sequence(n, k)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def count_divisible_pairs(n, m):\n    # Count how many numbers in the range 1 to n have each remainder when divided by 5\n    count_x = [0] * 5\n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n\n    # Count how many numbers in the range 1 to m have each remainder when divided by 5\n    count_y = [0] * 5\n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n\n    # Calculate the number of valid pairs (x, y)\n    result = 0\n    for r in range(5):\n        result += count_x[r] * count_y[(5 - r) % 5]\n\n    return result\n\n# Read input\nn, m = map(int, input().split())\n# Get the result\nresult = count_divisible_pairs(n, m)\n# Print the output\nprint(result)"}
{"solution": "def max_beauty_with_multiplication(n, x, a):\n    # Function to calculate the maximum subarray sum using Kadane's algorithm\n    def kadane(arr):\n        max_ending_here = max_so_far = 0\n        for value in arr:\n            max_ending_here = max(0, max_ending_here + value)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    # Calculate the beauty of the original array\n    original_beauty = kadane(a)\n\n    # Calculate the maximum beauty after multiplying a subarray by x\n    max_beauty = original_beauty\n\n    # We will use a prefix sum approach to find the best subarray to multiply\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    # Iterate over all possible subarrays\n    for start in range(n):\n        for end in range(start, n):\n            # Calculate the sum of the subarray a[start:end + 1]\n            subarray_sum = prefix_sum[end + 1] - prefix_sum[start]\n            # Calculate the new beauty if we multiply this subarray by x\n            new_beauty = original_beauty - subarray_sum + (subarray_sum * x)\n            max_beauty = max(max_beauty, new_beauty)\n\n    return max_beauty\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = max_beauty_with_multiplication(n, x, a)\nprint(result)"}
{"solution": "def find_kth_largest(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(m, x // i)\n        return count\n\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_less_equal(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\n# Read input\nn, m, k = map(int, input().split())\n# Print the result\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    length = 1  # Current length of numbers (1 for 1-9, 2 for 10-99, etc.)\n    count = 9   # Count of numbers with the current length\n    start = 1   # Starting number with the current length\n\n    # Determine the length of the number that contains the k-th digit\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # Find the actual number that contains the k-th digit\n    start += (k - 1) // length\n    num_str = str(start)\n    \n    # Find the specific digit in that number\n    return num_str[(k - 1) % length]\n\n# Read input\nk = int(input().strip())\n# Print the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "def max_bourles_after_trading(n, m, r, buy_prices, sell_prices):\n    # Find the minimum buy price\n    min_buy_price = min(buy_prices)\n    \n    # Find the maximum sell price\n    max_sell_price = max(sell_prices)\n    \n    # If the maximum sell price is less than or equal to the minimum buy price,\n    # it's not profitable to buy any shares.\n    if max_sell_price <= min_buy_price:\n        return r\n    \n    # Calculate the maximum number of shares that can be bought\n    max_shares = r // min_buy_price\n    \n    # Calculate the total cost of buying the shares\n    total_cost = max_shares * min_buy_price\n    \n    # Calculate the remaining bourles after buying the shares\n    remaining_bourles = r - total_cost\n    \n    # Calculate the total bourles after selling the shares\n    total_bourles_after_selling = remaining_bourles + (max_shares * max_sell_price)\n    \n    return total_bourles_after_selling\n\n# Read input\nn, m, r = map(int, input().split())\nbuy_prices = list(map(int, input().split()))\nsell_prices = list(map(int, input().split()))\n\n# Get the result\nresult = max_bourles_after_trading(n, m, r, buy_prices, sell_prices)\n\n# Print the result\nprint(result)"}
{"solution": "def find_original_message(t):\n    n = len(t)\n    \n    # \u041f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u0432\u0441\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0434\u043b\u0438\u043d\u044b \u043d\u0430\u043b\u043e\u0436\u0435\u043d\u0438\u044f\n    for overlap in range(1, n // 2 + 1):\n        # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u043c\u043e\u0436\u043d\u043e \u043b\u0438 \u0440\u0430\u0437\u0434\u0435\u043b\u0438\u0442\u044c \u0441\u0442\u0440\u043e\u043a\u0443 t \u043d\u0430 \u0434\u0432\u0435 \u0447\u0430\u0441\u0442\u0438 \u0441 \u043d\u0430\u043b\u043e\u0436\u0435\u043d\u0438\u0435\u043c \u0434\u043b\u0438\u043d\u044b overlap\n        if t[:overlap] == t[-overlap:]:\n            s = t[:-overlap]\n            if s + t[-overlap:] == t and len(s) > 0:\n                return \"YES\", s\n    \n    return \"NO\", None\n\n# \u0427\u0442\u0435\u043d\u0438\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\nt = input().strip()\n\n# \u041f\u043e\u0438\u0441\u043a \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0433\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f s\nresult, s = find_original_message(t)\n\n# \u0412\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\nprint(result)\nif result == \"YES\":\n    print(s)"}
{"solution": "def calculate_games(teams):\n    total_games = 0\n    while teams > 1:\n        if teams % 2 == 0:\n            games = teams // 2\n            total_games += games\n            teams = games\n        else:\n            break\n    if teams > 1:\n        total_games += (teams * (teams - 1)) // 2\n    return total_games\n\ndef find_teams(n):\n    possible_teams = []\n    \n    for i in range(1, n + 1):\n        games = calculate_games(i)\n        if games == n:\n            possible_teams.append(i)\n    \n    if possible_teams:\n        return possible_teams\n    else:\n        return [-1]\n\nn = int(input().strip())\nresult = find_teams(n)\n\nfor res in result:\n    print(res)"}
{"solution": "def max_antipalindromic_beauty(n, s, beauty):\n    from collections import Counter\n\n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # Create a list to store the beauty values for each character\n    beauty_pairs = []\n    for i in range(n):\n        beauty_pairs.append((s[i], beauty[i]))\n    \n    # Sort beauty pairs based on characters\n    beauty_pairs.sort()\n    \n    # Create a list to store the maximum beauty\n    max_beauty = 0\n    \n    # Create a list to store the characters for the antipalindromic string\n    half_length = n // 2\n    left_half = []\n    right_half = []\n    \n    # Fill the left half and right half\n    for char, b in beauty_pairs:\n        count = char_count[char]\n        if count > 0:\n            # We can use half of the count for the left half\n            for _ in range(count // 2):\n                left_half.append((char, b))\n                right_half.append((char, b))\n            # If there's an odd count, we can use one more for the middle\n            if count % 2 == 1:\n                left_half.append((char, b))\n    \n    # Sort left half by beauty descending\n    left_half.sort(key=lambda x: -x[1])\n    \n    # Calculate the maximum beauty\n    for i in range(half_length):\n        if i < len(left_half):\n            max_beauty += left_half[i][1]\n    \n    return max_beauty\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\nbeauty = list(map(int, input().strip().split()))\n\n# Calculate and print the maximum beauty\nresult = max_antipalindromic_beauty(n, s, beauty)\nprint(result)"}
{"solution": "def can_weight_item(w, m):\n    while m > 0:\n        remainder = m % w\n        if remainder > 1:\n            return \"NO\"\n        m //= w\n    return \"YES\"\n\n# Read input\nw, m = map(int, input().split())\n# Print the result\nprint(can_weight_item(w, m))"}
{"solution": "def find_sequence(n, k):\n    # Step 1: Decompose n into powers of 2\n    powers = []\n    for i in range(60):  # 2^60 is greater than 10^18\n        if n & (1 << i):\n            powers.append(i)\n\n    # Step 2: Check if we can form a sequence of length k\n    if len(powers) > k:\n        print(\"No\")\n        return\n\n    # Step 3: Fill the sequence with the powers of 2\n    result = []\n    for power in reversed(powers):\n        result.append(power)\n    \n    # Step 4: If we have less than k elements, we need to split the existing powers\n    while len(result) < k:\n        # Take the largest power and split it\n        largest = result.pop()\n        if largest == 0:\n            print(\"No\")\n            return\n        # Split 2^largest into two 2^(largest-1)\n        result.append(largest - 1)\n        result.append(largest - 1)\n\n    # Step 5: Sort the result in lexicographically largest order\n    result.sort(reverse=True)\n\n    # Step 6: Output the result\n    print(\"Yes\")\n    print(\" \".join(map(str, result)))\n\n# Read input\nn, k = map(int, input().split())\nfind_sequence(n, k)"}
{"solution": "def champagne_pyramid(n, t):\n    # Create a 2D list to represent the glasses in the pyramid\n    glasses = [[0] * (i + 1) for i in range(n)]\n    \n    # Pour champagne into the top glass\n    glasses[0][0] = t\n    \n    # Process the pouring and overflow\n    for i in range(n):\n        for j in range(i + 1):\n            if glasses[i][j] > 1:  # If the glass is more than full\n                overflow = glasses[i][j] - 1  # Calculate overflow\n                glasses[i][j] = 1  # Set the current glass to full\n                if i + 1 < n:  # If there is a row below\n                    glasses[i + 1][j] += overflow / 2  # Distribute to the left glass\n                    glasses[i + 1][j + 1] += overflow / 2  # Distribute to the right glass\n\n    # Count the number of completely full glasses\n    full_glasses = sum(1 for i in range(n) for j in range(i + 1) if glasses[i][j] == 1)\n    \n    return full_glasses\n\n# Read input\nn, t = map(int, input().split())\n# Get the result and print it\nresult = champagne_pyramid(n, t)\nprint(result)"}
{"solution": "def calculate_area(n, vertices):\n    if n == 1:\n        return -1\n    elif n == 2:\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        if x1 != x2 and y1 != y2:\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 3:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 4:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n\n# Read input\nn = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\nprint(calculate_area(n, vertices))"}
{"solution": "def minimal_wooden_bars(n, a, b):\n    # Each door frame requires 2 vertical sides and 1 top side\n    total_length_needed = 2 * (2 * a + b)  # For two doors\n    # Calculate the minimum number of wooden bars needed\n    min_bars = (total_length_needed + n - 1) // n  # Ceiling division\n    return min_bars\n\n# Input reading\nn = int(input())\na = int(input())\nb = int(input())\n\n# Calculate and print the result\nprint(minimal_wooden_bars(n, a, b))"}
{"solution": "def can_sort_array(n, a, swap_string):\n    # Create a list to track the segments where swaps are allowed\n    segments = []\n    start = 0\n\n    # Identify segments based on the swap_string\n    for i in range(n - 1):\n        if swap_string[i] == '0':\n            segments.append((start, i + 1))\n            start = i + 1\n    segments.append((start, n))\n\n    # Check if each segment can be sorted independently\n    for start, end in segments:\n        segment = a[start:end]\n        if segment != sorted(segment):\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nswap_string = input().strip()\n\n# Get the result and print it\nresult = can_sort_array(n, a, swap_string)\nprint(result)"}
{"solution": "def calculate_wait_time(seat_info):\n    # Parse the input\n    n = int(seat_info[:-1])  # Row number\n    s = seat_info[-1]        # Seat letter\n\n    # Determine the time taken to serve rows before row n\n    time_spent = 0\n\n    # Calculate the number of complete cycles of 4 rows before row n\n    complete_cycles = (n - 1) // 4\n    time_spent += complete_cycles * (6 * 4 + 3)  # 6 seconds per row for 4 rows + 3 seconds for moving\n\n    # Calculate the remaining rows after the last complete cycle\n    remaining_rows = (n - 1) % 4\n\n    # Add time for the remaining rows\n    for i in range(remaining_rows + 1):\n        time_spent += 6  # Time to serve the row\n        if i < remaining_rows:  # If not the last row in the remaining\n            time_spent += 1  # Time to move to the next row\n\n    # Determine the seat position\n    seat_order = {'f': 1, 'e': 2, 'd': 3, 'c': 4, 'b': 5, 'a': 6}\n    time_spent += seat_order[s]  # Add time to serve Vasya's seat\n\n    return time_spent\n\n# Read input\nseat_info = input().strip()\n# Calculate and print the wait time\nprint(calculate_wait_time(seat_info))"}
{"solution": "def convert_to_decimal(digits, base):\n    \"\"\"Convert a number represented by its digits in a given base to decimal.\"\"\"\n    decimal_value = 0\n    for digit in digits:\n        decimal_value = decimal_value * base + digit\n    return decimal_value\n\n# Read input for number X\nn, b_x = map(int, input().split())\nx_digits = list(map(int, input().split()))\n\n# Read input for number Y\nm, b_y = map(int, input().split())\ny_digits = list(map(int, input().split()))\n\n# Convert both numbers to decimal\nx_decimal = convert_to_decimal(x_digits, b_x)\ny_decimal = convert_to_decimal(y_digits, b_y)\n\n# Compare the two decimal values and print the result\nif x_decimal < y_decimal:\n    print('<')\nelif x_decimal > y_decimal:\n    print('>')\nelse:\n    print('=')"}
{"solution": "def determine_winner(n, a):\n    # Calculate the nim-sum (XOR of all elements)\n    nim_sum = 0\n    for value in a:\n        nim_sum ^= value\n    \n    # If nim-sum is 0, BitAryo wins, otherwise BitLGM wins\n    return \"BitAryo\" if nim_sum == 0 else \"BitLGM\"\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, a))"}
{"solution": "def count_valid_decks(n, k, a):\n    # Function to calculate the prime factors of a number\n    def prime_factors(x):\n        factors = {}\n        d = 2\n        while d * d <= x:\n            while (x % d) == 0:\n                if d in factors:\n                    factors[d] += 1\n                else:\n                    factors[d] = 1\n                x //= d\n            d += 1\n        if x > 1:\n            factors[x] = 1\n        return factors\n\n    # Get the prime factors of k\n    k_factors = prime_factors(k)\n\n    # Count the number of valid ways\n    valid_count = 0\n    current_factors = {}\n\n    # Initialize the left and right pointers\n    left = 0\n    right = n - 1\n\n    # Function to check if the current factors meet the requirements\n    def is_valid():\n        for prime, count in k_factors.items():\n            if current_factors.get(prime, 0) < count:\n                return False\n        return True\n\n    # Iterate over all possible x values\n    for x in range(n):\n        # Update the current factors with the new card added to the deck\n        for prime, count in prime_factors(a[x]).items():\n            if prime in current_factors:\n                current_factors[prime] += count\n            else:\n                current_factors[prime] = count\n\n        # Now check for all possible y values\n        for y in range(n - x):\n            if is_valid():\n                valid_count += 1\n            # Update the current factors by removing the card from the bottom\n            for prime, count in prime_factors(a[n - 1 - y]).items():\n                if prime in current_factors:\n                    current_factors[prime] -= count\n                    if current_factors[prime] == 0:\n                        del current_factors[prime]\n\n    return valid_count\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result and print it\nresult = count_valid_decks(n, k, a)\nprint(result)"}
{"solution": "def can_distribute_balloons(n, k, s):\n    # Count the frequency of each balloon color\n    color_count = {}\n    for color in s:\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n    \n    # Find the maximum number of balloons of the same color\n    max_balloons_of_one_color = max(color_count.values())\n    \n    # If the maximum number of balloons of one color is greater than the number of friends,\n    # then it's impossible to distribute them without upsetting someone\n    if max_balloons_of_one_color > k:\n        return \"NO\"\n    else:\n        return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Get the result and print it\nresult = can_distribute_balloons(n, k, s)\nprint(result)"}
{"solution": "def find_closest_min_distance(n, arr):\n    min_value = min(arr)\n    last_position = -1\n    min_distance = float('inf')\n\n    for i in range(n):\n        if arr[i] == min_value:\n            if last_position != -1:\n                min_distance = min(min_distance, i - last_position)\n            last_position = i\n\n    return min_distance\n\n# Input reading\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output the result\nprint(find_closest_min_distance(n, arr))"}
{"solution": "import math\n\ndef calculate_probability(t, w, b):\n    # Calculate the maximum steps each athlete can take without falling into the abyss\n    max_steps_willman = t // w\n    max_steps_bolt = t // b\n    \n    # The number of lengths where they tie is the number of common multiples of w and b\n    lcm_wb = (w * b) // math.gcd(w, b)\n    \n    # Count the number of lengths where they tie\n    tie_count = (t // lcm_wb)\n    \n    # The total number of possible lengths is t\n    total_count = t\n    \n    # The probability of a tie as a fraction\n    p = tie_count\n    q = total_count\n    \n    # Reduce the fraction\n    gcd_pq = math.gcd(p, q)\n    p //= gcd_pq\n    q //= gcd_pq\n    \n    return f\"{p}/{q}\"\n\n# Read input\nt, w, b = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_probability(t, w, b))"}
{"solution": "# Read input values\nx, y, z = map(int, input().split())\n\n# Calculate the minimum and maximum possible upvotes\nmin_upvotes = x\nmax_upvotes = x + z\n\n# Calculate the minimum and maximum possible downvotes\nmin_downvotes = y\nmax_downvotes = y + z\n\n# Determine the result\nif max_upvotes < min_downvotes:\n    print(\"-\")\nelif max_downvotes < min_upvotes:\n    print(\"+\")\nelif min_upvotes == max_upvotes and min_downvotes == max_downvotes:\n    print(\"0\")\nelse:\n    print(\"?\")"}
{"solution": "def min_length_to_change(n, operations, target_x, target_y):\n    # Count the number of each operation\n    count_U = operations.count('U')\n    count_D = operations.count('D')\n    count_L = operations.count('L')\n    count_R = operations.count('R')\n\n    # Calculate the required movements\n    required_U = max(0, target_y)\n    required_D = max(0, -target_y)\n    required_L = max(0, -target_x)\n    required_R = max(0, target_x)\n\n    # Check if it's possible to reach the target\n    if required_U > count_U + required_D or required_D > count_D + required_U or \\\n       required_L > count_L + required_R or required_R > count_R + required_L:\n        return -1\n\n    # Calculate the excess movements\n    excess_U = count_U - required_U\n    excess_D = count_D - required_D\n    excess_L = count_L - required_L\n    excess_R = count_R - required_R\n\n    # Calculate the total changes needed\n    changes_needed = 0\n    if excess_U < 0:\n        changes_needed += -excess_U\n    if excess_D < 0:\n        changes_needed += -excess_D\n    if excess_L < 0:\n        changes_needed += -excess_L\n    if excess_R < 0:\n        changes_needed += -excess_R\n\n    # The minimum length of the subsegment to change\n    return changes_needed\n\n# Input reading\nn = int(input().strip())\noperations = input().strip()\nx, y = map(int, input().strip().split())\n\n# Output the result\nprint(min_length_to_change(n, operations, x, y))"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    T = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(T):\n        n, x = map(int, data[index].split())\n        s = data[index + 1]\n        index += 2\n        \n        # Calculate the balance of the string s\n        balance_s = s.count('0') - s.count('1')\n        \n        # Calculate prefix balances\n        prefix_balances = [0] * (n + 1)\n        for i in range(n):\n            prefix_balances[i + 1] = prefix_balances[i] + (1 if s[i] == '0' else -1)\n        \n        if balance_s == 0:\n            if x in prefix_balances:\n                results.append(-1)  # Infinite number of valid prefixes\n            else:\n                results.append(0)  # No valid prefixes\n        else:\n            count = 0\n            for b in prefix_balances:\n                if (x - b) % balance_s == 0 and (x - b) // balance_s >= 0:\n                    count += 1\n            results.append(count)\n    \n    print('\\n'.join(map(str, results)))"}
{"solution": "def min_digits_to_remove(n, k):\n    n_str = str(n)\n    count_zeros = 0\n    digits_to_remove = 0\n\n    # Count the number of zeros and find the position of the last k zeros needed\n    for digit in reversed(n_str):\n        if digit == '0':\n            count_zeros += 1\n        if count_zeros == k:\n            break\n        digits_to_remove += 1\n\n    # If we have found k zeros, we need to remove the digits before the last k zeros\n    if count_zeros == k:\n        # We need to remove all digits before the last k zeros\n        return len(n_str) - (digits_to_remove + k)\n    else:\n        # If we don't have enough zeros, we can only form 0\n        return len(n_str) - 1  # Remove all but one digit to form 0\n\n# Read input\nn, k = map(int, input().split())\n# Get the result\nresult = min_digits_to_remove(n, k)\n# Print the result\nprint(result)"}
{"solution": "def calculate_questions(n, m, k, x, y):\n    # Total number of pupils\n    total_pupils = n * m\n    \n    # Full cycles of asking\n    full_cycles = k // (2 * total_pupils)\n    remaining_questions = k % (2 * total_pupils)\n    \n    # Each pupil is asked in full cycles\n    max_questions = full_cycles\n    min_questions = full_cycles\n    \n    # Count how many times each pupil is asked in the remaining questions\n    questions_count = [[0] * m for _ in range(n)]\n    \n    # Fill the questions count for the first pass\n    for row in range(n):\n        for col in range(m):\n            if remaining_questions > 0:\n                questions_count[row][col] += 1\n                remaining_questions -= 1\n    \n    # Fill the questions count for the second pass (reverse)\n    for row in range(n - 2, -1, -1):\n        for col in range(m):\n            if remaining_questions > 0:\n                questions_count[row][col] += 1\n                remaining_questions -= 1\n    \n    # Calculate the maximum and minimum questions asked\n    for row in range(n):\n        for col in range(m):\n            questions_count[row][col] += full_cycles\n            \n            if questions_count[row][col] > max_questions:\n                max_questions = questions_count[row][col]\n            if questions_count[row][col] < min_questions:\n                min_questions = questions_count[row][col]\n    \n    # Count how many times Sergei is asked\n    sergei_questions = questions_count[x - 1][y - 1]\n    \n    return max_questions, min_questions, sergei_questions\n\n# Input reading\nn, m, k, x, y = map(int, input().split())\nmax_q, min_q, sergei_q = calculate_questions(n, m, k, x, y)\n\n# Output the results\nprint(max_q, min_q, sergei_q)"}
{"solution": "def calculate_max_beauty(n, ribbon):\n    from collections import Counter\n    \n    # Count the frequency of each character in the ribbon\n    frequency = Counter(ribbon)\n    \n    # Find the maximum frequency of any character\n    max_freq = max(frequency.values())\n    \n    # The length of the ribbon\n    length = len(ribbon)\n    \n    # Calculate the maximum beauty after n changes\n    # The maximum beauty can be the minimum of the length of the ribbon and\n    # the maximum frequency plus the number of changes we can make\n    max_beauty = min(length, max_freq + n)\n    \n    return max_beauty\n\ndef determine_winner(n, ribbons):\n    # Calculate the maximum beauty for each ribbon\n    beauties = [calculate_max_beauty(n, ribbon) for ribbon in ribbons]\n    \n    # Determine the maximum beauty and how many have that beauty\n    max_beauty = max(beauties)\n    winners = [i for i, beauty in enumerate(beauties) if beauty == max_beauty]\n    \n    # Determine the result based on the number of winners\n    if len(winners) > 1:\n        return \"Draw\"\n    else:\n        return [\"Kuro\", \"Shiro\", \"Katie\"][winners[0]]\n\n# Read input\nn = int(input().strip())\nribbons = [input().strip() for _ in range(3)]\n\n# Determine and print the winner\nprint(determine_winner(n, ribbons))"}
{"solution": "def days_to_finish_book(c, v0, v1, a, l):\n    days = 0\n    pages_read = 0\n    current_speed = v0\n\n    while pages_read < c:\n        days += 1\n        \n        if days == 1:\n            pages_today = current_speed\n        else:\n            pages_today = min(current_speed, v1) - l\n        \n        pages_read += pages_today\n        \n        if days > 1:\n            current_speed += a\n\n    return days\n\n# Input reading\nc, v0, v1, a, l = map(int, input().split())\n# Output the result\nprint(days_to_finish_book(c, v0, v1, a, l))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_prime_sum(n):\n    if n % 2 == 1:  # n is odd\n        # Check if n itself is prime\n        if is_prime(n):\n            return 1, [n]\n        \n        # Check if n - 2 is prime\n        if is_prime(n - 2):\n            return 2, [2, n - 2]\n        \n        # Otherwise, we can always represent n as the sum of three primes\n        # We can use 3 and two other primes\n        # Since n is odd, n - 3 is even and we can find two primes that sum to n - 3\n        for i in range(2, n):\n            if is_prime(i) and is_prime(n - 3 - i):\n                return 3, [3, i, n - 3 - i]\n\nn = int(input().strip())\nk, primes = find_prime_sum(n)\nprint(k)\nprint(\" \".join(map(str, primes)))"}
{"solution": "def can_wipe_out_walls(n, m, depot):\n    total_walls = sum(row.count('*') for row in depot)\n    \n    row_walls = [0] * n\n    col_walls = [0] * m\n    \n    for i in range(n):\n        for j in range(m):\n            if depot[i][j] == '*':\n                row_walls[i] += 1\n                col_walls[j] += 1\n    \n    for i in range(n):\n        for j in range(m):\n            # Calculate the total walls that would be wiped out if bomb is placed at (i, j)\n            walls_wiped = row_walls[i] + col_walls[j]\n            if depot[i][j] == '*':\n                walls_wiped -= 1  # Overlap at (i, j) if it's a wall\n            \n            if walls_wiped == total_walls:\n                return \"YES\", (i + 1, j + 1)  # Return 1-based index\n    \n    return \"NO\", None\n\n# Read input\nn, m = map(int, input().split())\ndepot = [input().strip() for _ in range(n)]\n\n# Get the result\nresult, coordinates = can_wipe_out_walls(n, m, depot)\n\n# Print output\nprint(result)\nif coordinates:\n    print(coordinates[0], coordinates[1])"}
{"solution": "def minimal_burles(n, m, a, b):\n    remainder = n % m\n    \n    if remainder == 0:\n        return 0\n    \n    # Calculate the cost to build boxes to the next multiple of m\n    boxes_to_build = m - remainder\n    cost_to_build = boxes_to_build * a\n    \n    # Calculate the cost to demolish boxes to the previous multiple of m\n    boxes_to_demolish = remainder\n    cost_to_demolish = boxes_to_demolish * b\n    \n    # Return the minimum cost\n    return min(cost_to_build, cost_to_demolish)\n\n# Read input\nn, m, a, b = map(int, input().split())\n# Output the result\nprint(minimal_burles(n, m, a, b))"}
{"solution": "def max_odd_sum_subsequence(n, arr):\n    total_sum = 0\n    min_odd = float('inf')\n    \n    for num in arr:\n        if num > 0:\n            total_sum += num\n        if num % 2 != 0:\n            min_odd = min(min_odd, abs(num))\n    \n    if total_sum % 2 == 0:\n        total_sum -= min_odd\n    \n    return total_sum\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Get the result and print it\nresult = max_odd_sum_subsequence(n, arr)\nprint(result)"}
{"solution": "def count_playlists(n, T, songs):\n    MOD = 10**9 + 7\n    \n    # dp[time][mask][last_genre] = number of ways to create a playlist of 'time' minutes\n    # using songs represented by 'mask' and ending with a song of 'last_genre'\n    dp = [[[0 for _ in range(4)] for _ in range(1 << n)] for _ in range(T + 1)]\n    \n    # Base case: 0 time, 0 songs used, no last genre\n    dp[0][0][0] = 1\n    \n    for time in range(T + 1):\n        for mask in range(1 << n):\n            for last_genre in range(4):\n                if dp[time][mask][last_genre] == 0:\n                    continue\n                \n                for i in range(n):\n                    song_length, song_genre = songs[i]\n                    if (mask & (1 << i)) == 0:  # if song i is not used\n                        if song_genre != last_genre:  # if genre is different\n                            new_mask = mask | (1 << i)\n                            new_time = time + song_length\n                            if new_time <= T:\n                                dp[new_time][new_mask][song_genre] = (dp[new_time][new_mask][song_genre] + dp[time][mask][last_genre]) % MOD\n    \n    # Sum all valid playlists of length T with any last genre\n    result = 0\n    for mask in range(1 << n):\n        for last_genre in range(1, 4):  # last_genre should be 1, 2, or 3\n            result = (result + dp[T][mask][last_genre]) % MOD\n    \n    return result\n\n# Read input\nn, T = map(int, input().split())\nsongs = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(count_playlists(n, T, songs))"}
{"solution": "def mod_inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef expected_length(m):\n    MOD = 10**9 + 7\n    expected = 0\n    for g in range(1, m + 1):\n        count = m // g\n        expected += count * mod_inverse(count, MOD)\n        expected %= MOD\n    expected = (expected * mod_inverse(m, MOD)) % MOD\n    return expected\n\nm = int(input())\nresult = expected_length(m)\nprint(result)"}
{"solution": "def count_good_pairs(l, r, x, y):\n    if y % x != 0:\n        return 0\n    \n    k = y // x\n    count = 0\n    \n    for i in range(1, int(k**0.5) + 1):\n        if k % i == 0:\n            a1 = i * x\n            b1 = (k // i) * x\n            \n            if l <= a1 <= r and l <= b1 <= r:\n                count += 1 if a1 != b1 else 0\n            \n            a2 = (k // i) * x\n            b2 = i * x\n            \n            if l <= a2 <= r and l <= b2 <= r:\n                count += 1 if a2 != b2 else 0\n    \n    return count\n\n# Read input\nl, r, x, y = map(int, input().split())\n# Output the result\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "import math\n\ndef smallest_k(a, b):\n    if a > b:\n        a, b = b, a\n    \n    # The difference between b and a\n    diff = b - a\n    \n    # If a and b are the same, the best k is 0\n    if diff == 0:\n        return 0\n    \n    # To store the minimum LCM and the corresponding k\n    min_lcm = float('inf')\n    best_k = 0\n    \n    # We will check all divisors of diff\n    for d in range(1, int(math.sqrt(diff)) + 1):\n        if diff % d == 0:\n            # Check both d and diff // d as potential k values\n            for k in (d, diff // d):\n                # Calculate the LCM of (a + k) and (b + k)\n                lcm_value = (a + k) * (b + k) // math.gcd(a + k, b + k)\n                \n                # Update the minimum LCM and best k\n                if lcm_value < min_lcm or (lcm_value == min_lcm and k < best_k):\n                    min_lcm = lcm_value\n                    best_k = k\n    \n    return best_k\n\n# Read input\na, b = map(int, input().split())\n# Get the result\nresult = smallest_k(a, b)\n# Print the result\nprint(result)"}
{"solution": "import math\n\ndef minimal_additional_marks(n, k, marks):\n    current_sum = sum(marks)\n    current_count = n\n    target_average = k\n\n    # We need to find the minimum number of additional marks to reach the target average\n    additional_marks = 0\n\n    while True:\n        # Calculate the new average with the additional marks\n        new_average = (current_sum + additional_marks * k) / (current_count + additional_marks)\n        \n        # Check if the new average rounds to k\n        if math.ceil(new_average) >= target_average:\n            break\n        \n        additional_marks += 1\n\n    return additional_marks\n\n# Input reading\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = minimal_additional_marks(n, k, marks)\nprint(result)"}
{"solution": "import math\n\ndef find_d(n, a):\n    required_positive_count = math.ceil(n / 2)\n    \n    # Check for d = 1\n    positive_count = sum(1 for x in a if x / 1 > 0)\n    if positive_count >= required_positive_count:\n        return 1\n    \n    # Check for d = -1\n    positive_count = sum(1 for x in a if x / -1 > 0)\n    if positive_count >= required_positive_count:\n        return -1\n    \n    # Check for d = 1000\n    positive_count = sum(1 for x in a if x / 1000 > 0)\n    if positive_count >= required_positive_count:\n        return 1000\n    \n    # Check for d = -1000\n    positive_count = sum(1 for x in a if x / -1000 > 0)\n    if positive_count >= required_positive_count:\n        return -1000\n    \n    return 0\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Finding and printing the result\nresult = find_d(n, a)\nprint(result)"}
{"solution": "def count_pairs_with_max_nines(n):\n    # The maximum number of nines at the end of the sum can be determined\n    # by finding pairs (i, j) such that (i + j) % 10 == 9\n    # This means we need to find pairs where the last digits of i and j sum to 9.\n    \n    # Count of pairs that can form a sum ending with 9\n    count = 0\n    \n    # We can iterate through possible last digits\n    for i in range(1, 10):\n        j = 9 - i\n        if j < 1 or j > 9:\n            continue\n        \n        # Count how many numbers have last digit i and j\n        count_i = (n - i) // 10 + 1\n        count_j = (n - j) // 10 + 1\n        \n        # If i and j are the same, we need to choose 2 from count_i\n        if i == j:\n            count += count_i * (count_i - 1) // 2\n        else:\n            count += count_i * count_j\n    \n    return count\n\n# Read input\nn = int(input())\n# Get the result\nresult = count_pairs_with_max_nines(n)\n# Print the output\nprint(result)"}
{"solution": "def can_half(a, b):\n    return a % 2 == 0 or b % 2 == 0\n\ndef can_third(a, b):\n    return a % 3 == 0 or b % 3 == 0\n\ndef possible_sizes(a, b):\n    sizes = set()\n    if can_half(a, b):\n        sizes.add((a // 2, b))\n        sizes.add((a, b // 2))\n    if can_third(a, b):\n        sizes.add((a // 3, b))\n        sizes.add((a, b // 3))\n    return sizes\n\ndef min_minutes(a1, b1, a2, b2):\n    initial_area1 = a1 * b1\n    initial_area2 = a2 * b2\n    \n    if initial_area1 == initial_area2:\n        return 0, (a1, b1), (a2, b2)\n    \n    sizes1 = possible_sizes(a1, b1)\n    sizes2 = possible_sizes(a2, b2)\n    \n    minutes = 0\n    while sizes1 and sizes2:\n        new_sizes1 = set()\n        new_sizes2 = set()\n        \n        for size in sizes1:\n            new_sizes1.update(possible_sizes(size[0], size[1]))\n        \n        for size in sizes2:\n            new_sizes2.update(possible_sizes(size[0], size[1]))\n        \n        sizes1 = new_sizes1\n        sizes2 = new_sizes2\n        \n        minutes += 1\n        \n        if any(size in sizes1 for size in sizes2):\n            common_size = next(size for size in sizes1 if size in sizes2)\n            return minutes, common_size, common_size\n    \n    return -1, None, None\n\n# Input reading\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\n# Calculate the result\nm, size1, size2 = min_minutes(a1, b1, a2, b2)\n\n# Output the result\nif m == -1:\n    print(-1)\nelse:\n    print(m)\n    print(size1[0], size1[1])\n    print(size2[0], size2[1])"}
{"solution": "def determine_winner(x_p, y_p, x_v, y_v):\n    # Calculate the distance to (0, 0) for both players\n    distance_polycarp = x_p + y_p\n    distance_vasiliy = x_v + y_v\n    \n    # Determine the winner based on the distances\n    if distance_polycarp <= distance_vasiliy:\n        return \"Polycarp\"\n    else:\n        return \"Vasiliy\"\n\n# Read input\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Determine and print the winner\nprint(determine_winner(x_p, y_p, x_v, y_v))"}
{"solution": "def number_of_columns(m, d):\n    # Days in each month for a non-leap year\n    days_in_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    # Get the number of days in the given month\n    days = days_in_month[m]\n    \n    # Calculate the number of columns needed\n    # d is the starting weekday (1 = Monday, ..., 7 = Sunday)\n    # We need to find out how many days fit in the first week\n    first_week_days = 8 - d  # Days that can fit in the first week\n    remaining_days = days - first_week_days  # Remaining days after the first week\n    \n    # If there are no remaining days, we only need one column\n    if remaining_days <= 0:\n        return 1\n    \n    # Calculate full weeks from remaining days\n    full_weeks = (remaining_days + 6) // 7  # +6 to round up for any extra days\n    \n    # Total columns is 1 (for the first week) + full weeks\n    return 1 + full_weeks\n\n# Read input\nm, d = map(int, input().split())\n# Print the output\nprint(number_of_columns(m, d))"}
{"solution": "def has_exactly_one_zero_in_binary(n):\n    # Convert the number to binary and check for exactly one '0'\n    binary_representation = bin(n)[2:]  # Get binary representation without '0b' prefix\n    return binary_representation.count('0') == 1\n\ndef count_years_with_one_zero(a, b):\n    count = 0\n    for year in range(a, b + 1):\n        if has_exactly_one_zero_in_binary(year):\n            count += 1\n    return count\n\n# Read input\na, b = map(int, input().split())\n# Get the result\nresult = count_years_with_one_zero(a, b)\n# Print the output\nprint(result)"}
{"solution": "def minimal_layers(N):\n    # The minimal number of layers required is given by the formula:\n    return (N * (N + 1)) // 2\n\n# Read input\nN = int(input())\n# Print the result\nprint(minimal_layers(N))"}
{"solution": "from itertools import combinations\n\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n\ndef count_ways(n, k, S, cubes):\n    total_ways = 0\n    \n    # Generate all possible combinations of cubes\n    for r in range(1, n + 1):\n        for combo in combinations(range(n), r):\n            # For each combination, we can choose to stick exclamation marks or not\n            m = len(combo)\n            for mask in range(1 << m):\n                current_sum = 0\n                used_stickers = 0\n                \n                for i in range(m):\n                    cube_index = combo[i]\n                    if mask & (1 << i):  # If we stick an exclamation mark\n                        current_sum += factorial(cubes[cube_index])\n                        used_stickers += 1\n                    else:  # If we do not stick an exclamation mark\n                        current_sum += cubes[cube_index]\n                \n                if used_stickers <= k and current_sum == S:\n                    total_ways += 1\n    \n    return total_ways\n\n# Input reading\nn, k, S = map(int, input().split())\ncubes = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = count_ways(n, k, S, cubes)\nprint(result)"}
{"solution": "def can_achieve_array(test_cases):\n    results = []\n    \n    for n, k, a in test_cases:\n        # Dictionary to count the occurrences of each value in a\n        count = {}\n        \n        for value in a:\n            if value > 0:\n                if value in count:\n                    count[value] += 1\n                else:\n                    count[value] = 1\n        \n        # We will check if we can achieve the required values\n        powers = []\n        i = 0\n        while True:\n            power = k ** i\n            if power > 10**16:  # No need to go beyond the maximum possible value in a\n                break\n            powers.append(power)\n            i += 1\n        \n        # Now we will try to match the counts with the available powers\n        possible = True\n        \n        for value, needed_count in count.items():\n            # Count how many times we can use this value\n            current_count = 0\n            \n            for power in powers:\n                if power > value:\n                    break\n                if value % power == 0:\n                    current_count += value // power\n            \n            if current_count < needed_count:\n                possible = False\n                break\n        \n        results.append(\"YES\" if possible else \"NO\")\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nT = int(data[0])\ntest_cases = []\n\nfor i in range(T):\n    n, k = map(int, data[2 * i + 1].split())\n    a = list(map(int, data[2 * i + 2].split()))\n    test_cases.append((n, k, a))\n\n# Get results\nresults = can_achieve_array(test_cases)\n\n# Print results\nfor result in results:\n    print(result)"}
{"solution": "def number_of_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count\n\ndef calculate_sum(a, b, c):\n    total_sum = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                total_sum += number_of_divisors(i * j * k)\n                total_sum %= 1073741824  # Modulo operation\n    return total_sum\n\n# Read input\na, b, c = map(int, input().split())\n# Calculate and print the result\nprint(calculate_sum(a, b, c))"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    neighbors = []\n    idx = state.index('X')\n    if idx == 0:\n        neighbors.append(swap(state, 0, 1))\n        neighbors.append(swap(state, 0, 2))\n    elif idx == 1:\n        neighbors.append(swap(state, 1, 0))\n        neighbors.append(swap(state, 1, 3))\n    elif idx == 2:\n        neighbors.append(swap(state, 2, 0))\n        neighbors.append(swap(state, 2, 3))\n    elif idx == 3:\n        neighbors.append(swap(state, 3, 1))\n        neighbors.append(swap(state, 3, 2))\n    return neighbors\n\ndef swap(state, i, j):\n    state = list(state)\n    state[i], state[j] = state[j], state[i]\n    return ''.join(state)\n\ndef bfs(start):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        current = queue.popleft()\n        for neighbor in get_neighbors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return visited\n\ndef can_be_same_configuration(bessie, elsie):\n    bessie_start = ''.join(bessie)\n    elsie_start = ''.join(elsie)\n    \n    bessie_reachable = bfs(bessie_start)\n    elsie_reachable = bfs(elsie_start)\n    \n    return not bessie_reachable.isdisjoint(elsie_reachable)\n\n# Input reading\nbessie = [input().strip() for _ in range(2)]\nelsie = [input().strip() for _ in range(2)]\n\nif can_be_same_configuration(bessie, elsie):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def convert_to_decimal(n, k):\n    decimal_value = 0\n    length = len(k)\n    \n    for i in range(length):\n        digit = int(k[length - 1 - i])  # Get the digit from the end\n        decimal_value += digit * (n ** i)  # Convert to decimal\n    \n    return decimal_value\n\n# Read input values\nn = int(input().strip())\nk = input().strip()\n\n# Calculate the minimum decimal number\nresult = convert_to_decimal(n, k)\n\n# Print the result\nprint(result)"}
{"solution": "def is_unimodal(arr):\n    n = len(arr)\n    if n == 0:\n        return \"NO\"\n\n    i = 0\n\n    # Increasing part\n    while i < n - 1 and arr[i] < arr[i + 1]:\n        i += 1\n\n    # Constant part\n    while i < n - 1 and arr[i] == arr[i + 1]:\n        i += 1\n\n    # Decreasing part\n    while i < n - 1 and arr[i] > arr[i + 1]:\n        i += 1\n\n    # If we reached the end of the array, it's unimodal\n    return \"YES\" if i == n - 1 else \"NO\"\n\n# Input reading\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output the result\nprint(is_unimodal(arr))"}
{"solution": "def max_value_in_k_paths(n, k):\n    # To find the maximum value y such that y is contained in at least k different paths\n    # We will iterate from n down to 1 and count how many paths contain each value\n    count = {}\n    \n    # We will iterate through all numbers from 1 to n\n    for x in range(1, n + 1):\n        current = x\n        while current >= 1:\n            if current in count:\n                count[current] += 1\n            else:\n                count[current] = 1\n            if current == 1:\n                break\n            current = current // 2 if current % 2 == 0 else current - 1\n    \n    # Now we need to find the maximum y that has at least k occurrences\n    max_y = -1\n    for value, occurrences in count.items():\n        if occurrences >= k:\n            max_y = max(max_y, value)\n    \n    return max_y\n\n# Read input\nn, k = map(int, input().split())\n# Get the result\nresult = max_value_in_k_paths(n, k)\n# Print the result\nprint(result)"}
{"solution": "def billiard_pocket(n, m, x, y, v_x, v_y):\n    # Calculate the time to hit the next vertical wall\n    if v_x > 0:\n        time_to_vertical_wall = (n - x) / v_x\n    elif v_x < 0:\n        time_to_vertical_wall = x / -v_x\n    else:\n        time_to_vertical_wall = float('inf')  # No movement in x direction\n\n    # Calculate the time to hit the next horizontal wall\n    if v_y > 0:\n        time_to_horizontal_wall = (m - y) / v_y\n    elif v_y < 0:\n        time_to_horizontal_wall = y / -v_y\n    else:\n        time_to_horizontal_wall = float('inf')  # No movement in y direction\n\n    # Determine the time of the next collision\n    if time_to_vertical_wall < time_to_horizontal_wall:\n        # The ball will hit a vertical wall first\n        time_to_hit = time_to_vertical_wall\n        new_y = y + v_y * time_to_hit\n        if new_y < 0 or new_y > m:\n            return -1  # Out of bounds, should not happen\n        # Determine the pocket based on the wall hit\n        if v_x > 0:\n            return (n, new_y)  # Right wall\n        else:\n            return (0, new_y)  # Left wall\n    else:\n        # The ball will hit a horizontal wall first\n        time_to_hit = time_to_horizontal_wall\n        new_x = x + v_x * time_to_hit\n        if new_x < 0 or new_x > n:\n            return -1  # Out of bounds, should not happen\n        # Determine the pocket based on the wall hit\n        if v_y > 0:\n            return (new_x, m)  # Top wall\n        else:\n            return (new_x, 0)  # Bottom wall\n\n    # If the ball is moving indefinitely\n    return -1\n\n# Read input\nn, m, x, y, v_x, v_y = map(int, input().split())\nresult = billiard_pocket(n, m, x, y, v_x, v_y)\n\n# Print output\nif result == -1:\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    # Check if two rectangles (a2, b2) and (a3, b3) can fit in (a1, b1)\n    def fits(w1, h1, w2, h2, W, H):\n        return (w1 + w2 <= W and max(h1, h2) <= H) or (h1 + h2 <= H and max(w1, w2) <= W)\n    \n    # Check all combinations of orientations\n    if (fits(a2, b2, a3, b3, a1, b1) or fits(b2, a2, a3, b3, a1, b1) or\n        fits(a2, b2, b3, a3, a1, b1) or fits(b2, a2, b3, a3, a1, b1) or\n        fits(a3, b3, a2, b2, a1, b1) or fits(b3, a3, a2, b2, a1, b1) or\n        fits(a3, b3, b2, a2, a1, b1) or fits(b3, a3, b2, a2, a1, b1)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Input reading\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\n# Output the result\nprint(can_place_paintings(a1, b1, a2, b2, a3, b3))"}
{"solution": "def count_geometric_progression_terms(b1, q, l, m, bad_integers):\n    # Convert bad integers to a set for O(1) lookups\n    bad_set = set(bad_integers)\n    \n    # Handle special cases\n    if abs(b1) > l:\n        return 0  # If the first term is out of bounds, return 0\n    \n    if q == 0:\n        # If q is 0, the sequence will be b1, 0, 0, 0, ... (if b1 is not bad)\n        if b1 in bad_set:\n            return 0\n        else:\n            return float('inf')  # Infinite zeros if b1 is not bad\n    \n    if q == 1:\n        # If q is 1, all terms are b1\n        if b1 in bad_set:\n            return 0\n        else:\n            return float('inf')  # Infinite b1 if it's not bad\n    \n    if q == -1:\n        # If q is -1, the sequence alternates between b1 and -b1\n        count = 0\n        if b1 <= l and b1 >= -l and b1 not in bad_set:\n            count += 1\n        if -b1 <= l and -b1 >= -l and -b1 not in bad_set:\n            count += 1\n        return count\n    \n    # General case for |q| > 1\n    count = 0\n    current_term = b1\n    \n    while abs(current_term) <= l:\n        if current_term not in bad_set:\n            count += 1\n        current_term *= q\n    \n    return count\n\n# Read input\nb1, q, l, m = map(int, input().split())\nbad_integers = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = count_geometric_progression_terms(b1, q, l, m, bad_integers)\nif result == float('inf'):\n    print(\"inf\")\nelse:\n    print(result)"}
{"solution": "def find_frame(n, m, monitor):\n    # Initialize boundaries for the frame\n    top, bottom, left, right = n, -1, m, -1\n\n    # Find the boundaries of the white pixels\n    for i in range(n):\n        for j in range(m):\n            if monitor[i][j] == 'w':\n                top = min(top, i)\n                bottom = max(bottom, i)\n                left = min(left, j)\n                right = max(right, j)\n\n    # Check if a valid frame can be formed\n    if top == n or bottom == -1 or left == m or right == -1:\n        return -1\n\n    # Check if the frame can be formed with all white pixels on the border\n    for i in range(top, bottom + 1):\n        for j in range(left, right + 1):\n            if (i == top or i == bottom or j == left or j == right) and monitor[i][j] == '.':\n                continue\n            if (i == top or i == bottom or j == left or j == right) and monitor[i][j] == 'w':\n                continue\n            if (i > top and i < bottom and j > left and j < right) and monitor[i][j] == 'w':\n                return -1\n\n    # Create the output monitor with the frame\n    output_monitor = [list(row) for row in monitor]\n\n    # Draw the frame\n    for j in range(left, right + 1):\n        output_monitor[top][j] = '+'  # Top border\n        output_monitor[bottom][j] = '+'  # Bottom border\n    for i in range(top, bottom + 1):\n        output_monitor[i][left] = '+'  # Left border\n        output_monitor[i][right] = '+'  # Right border\n\n    # Convert list of lists back to strings\n    return [''.join(row) for row in output_monitor]\n\n# Read input\nn, m = map(int, input().split())\nmonitor = [input().strip() for _ in range(n)]\n\n# Find the frame and print the result\nresult = find_frame(n, m, monitor)\nif result == -1:\n    print(-1)\nelse:\n    for line in result:\n        print(line)"}
{"solution": "def can_buy_exactly(n, a, b):\n    for x in range(n // a + 1):\n        remaining = n - x * a\n        if remaining % b == 0:\n            y = remaining // b\n            return \"YES\", x, y\n    return \"NO\",\n\n# Read input\nn = int(input().strip())\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result\nresult = can_buy_exactly(n, a, b)\n\n# Print the output\nif result[0] == \"NO\":\n    print(result[0])\nelse:\n    print(result[0])\n    print(result[1], result[2])"}
{"solution": "def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\ns = int(input())\nprint(number_to_words(s))"}
{"solution": "def max_consecutive_erase(n, a):\n    max_erase = 0\n    \n    # Check the maximum number of consecutive elements that can be erased\n    for i in range(n):\n        for j in range(i, n):\n            # Erase elements from index i to j\n            if i > 0 and j < n - 1:\n                # Check if the remaining elements can still form a valid increasing sequence\n                if a[j + 1] - a[i - 1] > (j - i + 1):\n                    max_erase = max(max_erase, j - i + 1)\n            elif i == 0 and j < n - 1:\n                # If we are erasing from the start\n                if a[j + 1] - 1 > (j - i + 1):\n                    max_erase = max(max_erase, j - i + 1)\n            elif i > 0 and j == n - 1:\n                # If we are erasing till the end\n                if 1000 - a[i - 1] > (j - i + 1):\n                    max_erase = max(max_erase, j - i + 1)\n            else:\n                # If we are erasing the whole array\n                max_erase = max(max_erase, j - i + 1)\n\n    return max_erase\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_consecutive_erase(n, a))"}
{"solution": "def find_equator_day(n, problems):\n    total_problems = sum(problems)\n    half_problems = total_problems / 2\n    cumulative_sum = 0\n    \n    for day in range(n):\n        cumulative_sum += problems[day]\n        if cumulative_sum >= half_problems:\n            return day + 1  # Return the day index (1-based)\n    \n    return -1  # In case no day is found, though it shouldn't happen with valid input\n\n# Input reading\nn = int(input())\nproblems = list(map(int, input().split()))\n\n# Finding the day Polycarp will celebrate the equator\nresult_day = find_equator_day(n, problems)\n\n# Output the result\nprint(result_day)"}
{"solution": "from collections import deque\n\n# Define the possible moves for each piece\nknight_moves = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)]\nbishop_moves = [(-1, -1), (-1, 1), (1, -1), (1, 1)]\nrook_moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n# Function to get all possible moves for a piece from a given position\ndef get_moves(piece, x, y, N):\n    moves = []\n    if piece == 'knight':\n        for dx, dy in knight_moves:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                moves.append((nx, ny))\n    elif piece == 'bishop':\n        for dx, dy in bishop_moves:\n            nx, ny = x, y\n            while True:\n                nx += dx\n                ny += dy\n                if 0 <= nx < N and 0 <= ny < N:\n                    moves.append((nx, ny))\n                else:\n                    break\n    elif piece == 'rook':\n        for dx, dy in rook_moves:\n            nx, ny = x, y\n            while True:\n                nx += dx\n                ny += dy\n                if 0 <= nx < N and 0 <= ny < N:\n                    moves.append((nx, ny))\n                else:\n                    break\n    return moves\n\n# BFS to find the shortest path with minimum replacements\ndef bfs(N, board):\n    positions = {board[i][j]: (i, j) for i in range(N) for j in range(N)}\n    queue = deque()\n    visited = set()\n    \n    # Start with all pieces at position of number 1\n    start_pos = positions[1]\n    for piece in ['knight', 'bishop', 'rook']:\n        queue.append((start_pos[0], start_pos[1], piece, 0, 0, 1))  # (x, y, piece, steps, replacements, current_number)\n        visited.add((start_pos[0], start_pos[1], piece, 1))\n    \n    while queue:\n        x, y, piece, steps, replacements, current_number = queue.popleft()\n        \n        if current_number == N * N:\n            return steps, replacements\n        \n        # Get the next number's position\n        next_number = current_number + 1\n        if next_number in positions:\n            next_x, next_y = positions[next_number]\n            \n            # Try to move with the same piece\n            if (next_x, next_y) not in visited:\n                if (next_x, next_y, piece, next_number) not in visited:\n                    visited.add((next_x, next_y, piece, next_number))\n                    queue.append((next_x, next_y, piece, steps + 1, replacements, next_number))\n            \n            # Try to replace the piece and move\n            for new_piece in ['knight', 'bishop', 'rook']:\n                if new_piece != piece:\n                    if (next_x, next_y, new_piece, next_number) not in visited:\n                        visited.add((next_x, next_y, new_piece, next_number))\n                        queue.append((next_x, next_y, new_piece, steps + 1, replacements + 1, next_number))\n        \n        # Try to move to all possible positions with the current piece\n        for nx, ny in get_moves(piece, x, y, N):\n            if (nx, ny, piece, current_number) not in visited:\n                visited.add((nx, ny, piece, current_number))\n                queue.append((nx, ny, piece, steps + 1, replacements, current_number))\n    \n    return -1, -1  # Should never reach here\n\n# Read input\nN = int(input())\nboard = [list(map(int, input().split())) for _ in range(N)]\n\n# Get the result\nsteps, replacements = bfs(N, board)\n\n# Print the output\nprint(steps, replacements)"}
{"solution": "def apartment_to_position(apartment, n, m, k):\n    total_apartments_per_floor = k\n    total_apartments_per_entrance = m * total_apartments_per_floor\n    \n    entrance = (apartment - 1) // total_apartments_per_entrance + 1\n    floor = ((apartment - 1) % total_apartments_per_entrance) // total_apartments_per_floor + 1\n    return entrance, floor\n\ndef time_to_reach(a, b, n, m, k):\n    entrance_a, floor_a = apartment_to_position(a, n, m, k)\n    entrance_b, floor_b = apartment_to_position(b, n, m, k)\n\n    # Calculate vertical movement time\n    vertical_time = abs(floor_a - 1) * 5  # Time to go to the first floor from floor_a\n\n    # Calculate time to reach entrance_b from entrance_a\n    if entrance_a <= entrance_b:\n        clockwise_distance = entrance_b - entrance_a\n        counter_clockwise_distance = n - clockwise_distance\n    else:\n        counter_clockwise_distance = entrance_a - entrance_b\n        clockwise_distance = n - counter_clockwise_distance\n\n    # Time to move between entrances\n    time_clockwise = clockwise_distance * 15\n    time_counter_clockwise = counter_clockwise_distance * 15\n\n    # Calculate time to go to the target floor in entrance_b\n    time_to_target_floor = abs(floor_b - 1) * 5\n\n    # Total time for both directions\n    total_time_clockwise = vertical_time + time_clockwise + time_to_target_floor\n    total_time_counter_clockwise = vertical_time + time_counter_clockwise + time_to_target_floor\n\n    # Calculate time using the lift\n    lift_time = 10 + abs(floor_a - 1) + abs(floor_b - 1)\n    total_time_using_lift = lift_time + min(time_clockwise, time_counter_clockwise)\n\n    # Return the minimum time\n    return min(total_time_clockwise, total_time_counter_clockwise, total_time_using_lift)\n\n# Input reading\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate and print the minimum time\nprint(time_to_reach(a, b, n, m, k))"}
{"solution": "def can_form_divisible_by_64(s):\n    # To be divisible by 64 in binary, the number must end with at least 6 zeros\n    # and must have at least one '1' before those zeros.\n    \n    # Count the number of zeros and check for at least one '1'\n    count_zeros = 0\n    found_one = False\n    \n    for char in reversed(s):\n        if char == '0':\n            count_zeros += 1\n        elif char == '1':\n            found_one = True\n            break\n    \n    # We need at least one '1' and at least 6 '0's\n    if found_one and count_zeros >= 6:\n        return \"yes\"\n    else:\n        return \"no\"\n\n# Read input\ns = input().strip()\n# Print the result\nprint(can_form_divisible_by_64(s))"}
{"solution": "def make_alphabet_subsequence(s):\n    target = \"abcdefghijklmnopqrstuvwxyz\"\n    target_index = 0\n    result = []\n\n    for char in s:\n        if target_index < len(target) and char <= target[target_index]:\n            result.append(target[target_index])\n            target_index += 1\n        else:\n            result.append(char)\n\n        if target_index == len(target):\n            break\n\n    if target_index < len(target):\n        return \"-1\"\n    \n    return ''.join(result)\n\n# Read input\ns = input().strip()\n# Get the result\nresult = make_alphabet_subsequence(s)\n# Print the result\nprint(result)"}
{"solution": "def max_expected_fishes(n, m, r, k):\n    # Total number of positions the scoop can be placed\n    total_positions = (n - r + 1) * (m - r + 1)\n    \n    # If the number of fishes is less than or equal to the number of positions,\n    # the expected value is simply the number of fishes divided by the number of positions.\n    if k <= total_positions:\n        return k * (r * r) / total_positions\n    else:\n        # If we have more fishes than positions, we can fill all positions\n        # and the expected value will be the maximum possible.\n        return (r * r) * total_positions / total_positions\n\n# Read input\nn, m, r, k = map(int, input().strip().split())\n\n# Calculate the maximum expected number of caught fishes\nresult = max_expected_fishes(n, m, r, k)\n\n# Print the result with the required precision\nprint(f\"{result:.10f}\")"}
{"solution": "def maximize_product(n, a):\n    for i in range(n):\n        if a[i] < -1:\n            a[i] = -a[i] - 1\n        elif a[i] == -1:\n            a[i] = 0\n    \n    # Count the number of negative numbers and zeros\n    negative_count = sum(1 for x in a if x < 0)\n    zero_count = sum(1 for x in a if x == 0)\n\n    # If we have an odd number of negatives and no zeros, we need to flip one negative\n    if negative_count % 2 == 1 and zero_count == 0:\n        # Find the largest negative number to flip\n        max_negative_index = a.index(max(x for x in a if x < 0))\n        a[max_negative_index] = -a[max_negative_index] - 1\n\n    print(\" \".join(map(str, a)))\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Call the function\nmaximize_product(n, a)"}
{"solution": "def kth_smallest_divisor(n, k):\n    divisors = []\n    \n    # Find divisors up to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)  # i is a divisor\n            if i != n // i:\n                divisors.append(n // i)  # n // i is also a divisor\n\n    # Sort the divisors to find the k-th smallest\n    divisors.sort()\n    \n    # Check if k-th smallest divisor exists\n    if k <= len(divisors):\n        return divisors[k - 1]\n    else:\n        return -1\n\n# Read input\nn, k = map(int, input().split())\n# Get the result\nresult = kth_smallest_divisor(n, k)\n# Print the output\nprint(result)"}
{"solution": "def can_form_number(cubes, number):\n    str_num = str(number)\n    if len(str_num) > len(cubes):\n        return False\n    \n    used = [False] * len(cubes)\n    \n    def backtrack(index):\n        if index == len(str_num):\n            return True\n        \n        digit = int(str_num[index])\n        for i in range(len(cubes)):\n            if not used[i] and digit in cubes[i]:\n                used[i] = True\n                if backtrack(index + 1):\n                    return True\n                used[i] = False\n        return False\n    \n    return backtrack(0)\n\ndef max_consecutive_numbers(cubes):\n    x = 0\n    while True:\n        x += 1\n        if not can_form_number(cubes, x):\n            break\n    return x - 1\n\ndef main():\n    n = int(input().strip())\n    cubes = [list(map(int, input().strip().split())) for _ in range(n)]\n    \n    result = max_consecutive_numbers(cubes)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def k_rounding(n, k):\n    # Calculate the factor to make the number end with k zeros\n    factor = 10 ** k\n    \n    # Find the smallest multiple of n that is also a multiple of factor\n    # This can be done by finding the least common multiple (LCM) of n and factor\n    from math import gcd\n    \n    def lcm(a, b):\n        return a * (b // gcd(a, b))\n    \n    result = lcm(n, factor)\n    return result\n\n# Read input\nn, k = map(int, input().split())\n# Calculate and print the k-rounding of n\nprint(k_rounding(n, k))"}
{"solution": "def transform_matrix(n, m, A):\n    operations = []\n    B = [[0] * m for _ in range(n)]\n    \n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                operations.append((i + 1, j + 1))\n                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1\n    \n    for i in range(n):\n        for j in range(m):\n            if A[i][j] != B[i][j]:\n                return -1\n    \n    return operations\n\n# Input reading\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\n# Process the transformation\nresult = transform_matrix(n, m, A)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for x, y in result:\n        print(x, y)"}
{"solution": "def calculate_probabilities(r, s, p):\n    total = r + s + p\n    if total == 0:\n        return (0.0, 0.0, 0.0)\n\n    # Probabilities of each species surviving\n    prob_r = r / total\n    prob_s = s / total\n    prob_p = p / total\n\n    # Adjusting probabilities based on interactions\n    while total > 1:\n        new_r = (r * (s + p) + s * p) / (total * (total - 1))\n        new_s = (s * (p + r) + p * r) / (total * (total - 1))\n        new_p = (p * (r + s) + r * s) / (total * (total - 1))\n\n        r, s, p = new_r, new_s, new_p\n        total = r + s + p\n\n    return (r, s, p)\n\n# Read input\nr, s, p = map(int, input().strip().split())\n\n# Calculate probabilities\nprobabilities = calculate_probabilities(r, s, p)\n\n# Print results with required precision\nprint(f\"{probabilities[0]:.12f} {probabilities[1]:.12f} {probabilities[2]:.12f}\")"}
{"solution": "def calculate_minutes_together(l1, r1, l2, r2, k):\n    # Calculate the overlap between Sonya's awake time and Filya's visiting time\n    start = max(l1, l2)\n    end = min(r1, r2)\n    \n    if start > end:\n        return 0  # No overlap\n    \n    # Calculate the total minutes they can spend together\n    total_minutes = end - start + 1\n    \n    # Check if Sonya is unavailable during minute k\n    if start <= k <= end:\n        total_minutes -= 1  # Subtract the minute when Sonya prinks\n    \n    return total_minutes\n\n# Input reading\nl1, r1, l2, r2, k = map(int, input().split())\n# Calculate and print the result\nprint(calculate_minutes_together(l1, r1, l2, r2, k))"}
{"solution": "def calculate_reachable_area(N, M, north_south_lines, east_west_lines):\n    # Create a list to store the vertical and horizontal lines\n    vertical_lines = []\n    horizontal_lines = []\n\n    # Add north-south lines\n    for A, B, C in north_south_lines:\n        vertical_lines.append((A, B, C))\n\n    # Add east-west lines\n    for D, E, F in east_west_lines:\n        horizontal_lines.append((D, E, F))\n\n    # Sort the lines based on their coordinates\n    vertical_lines.sort()\n    horizontal_lines.sort()\n\n    # Determine the boundaries of the cow's reachable area\n    left_bound = -float('inf')\n    right_bound = float('inf')\n    bottom_bound = -float('inf')\n    top_bound = float('inf')\n\n    # Check vertical lines to adjust left and right bounds\n    for A, B, C in vertical_lines:\n        if C == 0:  # Only consider lines that are at y = 0\n            left_bound = max(left_bound, A)\n            right_bound = min(right_bound, B)\n\n    # Check horizontal lines to adjust top and bottom bounds\n    for D, E, F in horizontal_lines:\n        if D == 0:  # Only consider lines that are at x = 0\n            bottom_bound = max(bottom_bound, E)\n            top_bound = min(top_bound, F)\n\n    # Check if the area is infinite\n    if left_bound < right_bound and bottom_bound < top_bound:\n        return (right_bound - left_bound) * (top_bound - bottom_bound)\n    else:\n        return \"INF\"\n\nimport sys\n\n# Read input\ninput_data = sys.stdin.read().strip().splitlines()\nN, M = map(int, input_data[0].split())\nnorth_south_lines = [tuple(map(int, line.split())) for line in input_data[1:N + 1]]\neast_west_lines = [tuple(map(int, line.split())) for line in input_data[N + 1:N + 1 + M]]\n\n# Calculate the area\nresult = calculate_reachable_area(N, M, north_south_lines, east_west_lines)\n\n# Print the result\nprint(result)"}
{"solution": "def will_bark(t, s, x):\n    if x == t:\n        return \"YES\"\n    \n    if x > t:\n        # Calculate the time since the first bark\n        time_since_first_bark = x - t\n        \n        # Check if x falls into the barking pattern\n        if time_since_first_bark % s == 0 or time_since_first_bark % s == 1:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nt, s, x = map(int, input().split())\n\n# Get the result and print it\nresult = will_bark(t, s, x)\nprint(result)"}
{"solution": "def find_segments_within(n, segments):\n    # Sort segments by their left endpoint, and by right endpoint in descending order if left endpoints are equal\n    indexed_segments = sorted((l, r, i + 1) for i, (l, r) in enumerate(segments))\n    \n    # Initialize variables to track the best segment found so far\n    best_right = -1\n    best_index = -1\n    \n    for l, r, index in indexed_segments:\n        # If the current segment's right endpoint is less than or equal to the best right endpoint found\n        if r <= best_right:\n            # We found a segment that is within the best segment found so far\n            return index, best_index\n        # Update the best right endpoint and index if the current segment's right endpoint is greater\n        if r > best_right:\n            best_right = r\n            best_index = index\n            \n    return -1, -1\n\n# Read input\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Find and print the result\ni, j = find_segments_within(n, segments)\nprint(i, j)"}
{"solution": "def decode_genome(n, s):\n    # Count the occurrences of each nucleotide\n    count_A = s.count('A')\n    count_C = s.count('C')\n    count_G = s.count('G')\n    count_T = s.count('T')\n    count_Q = s.count('?')\n\n    # Calculate the target count for each nucleotide\n    target_count = n // 4\n\n    # Check if it's possible to decode\n    if (count_A > target_count or count_C > target_count or \n        count_G > target_count or count_T > target_count):\n        return \"===\"\n\n    # Calculate how many more of each nucleotide we need\n    needed_A = target_count - count_A\n    needed_C = target_count - count_C\n    needed_G = target_count - count_G\n    needed_T = target_count - count_T\n\n    # If we need more nucleotides than we have '?', it's impossible\n    if (needed_A + needed_C + needed_G + needed_T) > count_Q:\n        return \"===\"\n\n    # Replace '?' with the needed nucleotides\n    result = list(s)\n    for i in range(n):\n        if result[i] == '?':\n            if needed_A > 0:\n                result[i] = 'A'\n                needed_A -= 1\n            elif needed_C > 0:\n                result[i] = 'C'\n                needed_C -= 1\n            elif needed_G > 0:\n                result[i] = 'G'\n                needed_G -= 1\n            elif needed_T > 0:\n                result[i] = 'T'\n                needed_T -= 1\n\n    return ''.join(result)\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(decode_genome(n, s))"}
{"solution": "def can_win_with_one_move(board):\n    # Check all possible winning positions\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                # Temporarily place 'x' in the empty cell\n                board[i][j] = 'x'\n                \n                # Check horizontal\n                if (j > 1 and board[i][j-1] == 'x' and board[i][j-2] == 'x') or \\\n                   (j < 3 and board[i][j+1] == 'x' and board[i][j+2] == 'x') or \\\n                   (j > 0 and j < 3 and board[i][j-1] == 'x' and board[i][j+1] == 'x'):\n                    return \"YES\"\n                \n                # Check vertical\n                if (i > 1 and board[i-1][j] == 'x' and board[i-2][j] == 'x') or \\\n                   (i < 3 and board[i+1][j] == 'x' and board[i+2][j] == 'x') or \\\n                   (i > 0 and i < 3 and board[i-1][j] == 'x' and board[i+1][j] == 'x'):\n                    return \"YES\"\n                \n                # Check diagonal (top-left to bottom-right)\n                if (i > 1 and j > 1 and board[i-1][j-1] == 'x' and board[i-2][j-2] == 'x') or \\\n                   (i < 3 and j < 3 and board[i+1][j+1] == 'x' and board[i+2][j+2] == 'x') or \\\n                   (i > 0 and i < 3 and j > 0 and j < 3 and board[i-1][j-1] == 'x' and board[i+1][j+1] == 'x'):\n                    return \"YES\"\n                \n                # Check diagonal (top-right to bottom-left)\n                if (i > 1 and j < 2 and board[i-1][j+1] == 'x' and board[i-2][j+2] == 'x') or \\\n                   (i < 3 and j > 0 and board[i+1][j-1] == 'x' and board[i+2][j-2] == 'x') or \\\n                   (i > 0 and i < 3 and j > 0 and j < 3 and board[i-1][j+1] == 'x' and board[i+1][j-1] == 'x'):\n                    return \"YES\"\n                \n                # Restore the cell back to empty\n                board[i][j] = '.'\n    \n    return \"NO\"\n\n# Read the board input\nboard = [input().strip() for _ in range(4)]\nresult = can_win_with_one_move(board)\nprint(result)"}
{"solution": "def can_divide_array(n, a):\n    total_sum = sum(a)\n    left_sum = 0\n    \n    for i in range(n):\n        # Calculate the right sum by subtracting the left sum and the current element\n        right_sum = total_sum - left_sum - a[i]\n        \n        # Check if moving a[i] can balance the two parts\n        if left_sum == right_sum or left_sum + a[i] == right_sum + a[i]:\n            return \"YES\"\n        \n        left_sum += a[i]\n    \n    return \"NO\"\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(can_divide_array(n, a))"}
{"solution": "def can_form_non_increasing_sequence(n, k, a, b):\n    # Replace zeros in a with elements from b\n    zero_indices = [i for i in range(n) if a[i] == 0]\n    \n    # Sort b in descending order to maximize the chance of creating a non-increasing sequence\n    b.sort(reverse=True)\n    \n    # Fill the zeros in a with the sorted b\n    for index, value in zip(zero_indices, b):\n        a[index] = value\n    \n    # Check if the resulting sequence is non-increasing\n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            return \"Yes\"\n    \n    return \"No\"\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_form_non_increasing_sequence(n, k, a, b)\nprint(result)"}
{"solution": "def can_distribute_grapes(x, y, z, a, b, c):\n    # Check if Andrew can get enough green grapes\n    if a < x:\n        return \"NO\"\n    \n    # Remaining grapes after Andrew takes his share\n    remaining_green = a - x\n    \n    # Dmitry can take from remaining green and purple grapes\n    # He needs y grapes in total\n    if remaining_green + b < y:\n        return \"NO\"\n    \n    # Remaining grapes after Dmitry takes his share\n    remaining_purple = b - (y - remaining_green) if y > remaining_green else b\n    remaining_black = c\n    \n    # Michal can take from remaining purple and black grapes\n    # He needs z grapes in total\n    if remaining_purple + remaining_black < z:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Output the result\nprint(can_distribute_grapes(x, y, z, a, b, c))"}
{"solution": "def is_accident_possible(traffic_lights):\n    # Check each part for possible accidents\n    for i in range(4):\n        l, s, r, p = traffic_lights[i]\n        \n        # Check if pedestrian light is green\n        if p == 1:\n            # Check if any car light that can hit the pedestrian is green\n            if (l == 1) or (s == 1) or (r == 1):\n                return \"YES\"\n            \n            # Check the previous part (counter-clockwise) for straight and left turns\n            prev_part = (i - 1) % 4\n            if (traffic_lights[prev_part][s] == 1) or (traffic_lights[prev_part][l] == 1):\n                return \"YES\"\n            \n            # Check the next part (clockwise) for right turns\n            next_part = (i + 1) % 4\n            if (traffic_lights[next_part][r] == 1):\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\ntraffic_lights = [list(map(int, input().split())) for _ in range(4)]\n\n# Determine if an accident is possible\nresult = is_accident_possible(traffic_lights)\n\n# Print the result\nprint(result)"}
{"solution": "def get_coordinates(digit):\n    keypad = {\n        '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2),\n        '0': (3, 1)\n    }\n    return keypad[digit]\n\ndef get_vectors(number):\n    vectors = []\n    for i in range(len(number) - 1):\n        x1, y1 = get_coordinates(number[i])\n        x2, y2 = get_coordinates(number[i + 1])\n        vectors.append((x2 - x1, y2 - y1))\n    return vectors\n\ndef is_unique_finger_movement(n, number):\n    original_vectors = get_vectors(number)\n    for i in range(10**(n-1), 10**n):\n        candidate = str(i).zfill(n)\n        if candidate != number:\n            if get_vectors(candidate) == original_vectors:\n                return \"NO\"\n    return \"YES\"\n\n# Input reading\nn = int(input())\nnumber = input().strip()\n\n# Output the result\nprint(is_unique_finger_movement(n, number))"}
{"solution": "def maximize_sales(n, f, sales_data):\n    # Calculate the potential sales for each day without sell-out\n    sales = []\n    for k, l in sales_data:\n        sales.append(min(k, l))\n    \n    # Calculate the additional sales if we double the products on a sell-out day\n    additional_sales = []\n    for i in range(n):\n        k, l = sales_data[i]\n        # If we double the products, the new sales would be the minimum of doubled products or clients\n        new_sales = min(2 * k, l)\n        # The additional sales from this day if it is chosen for sell-out\n        additional_sales.append(new_sales - sales[i])\n    \n    # Sort the additional sales in descending order to choose the best f days\n    additional_sales.sort(reverse=True)\n    \n    # Calculate the total sales\n    total_sales = sum(sales) + sum(additional_sales[:f])\n    \n    return total_sales\n\n# Input reading\nn, f = map(int, input().split())\nsales_data = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = maximize_sales(n, f, sales_data)\nprint(result)"}
{"solution": "def max_messiness(n, k):\n    # The maximum number of inversions in an array of size n is n * (n - 1) // 2\n    max_inversions = n * (n - 1) // 2\n    \n    # The maximum messiness we can achieve is limited by the number of swaps we can make\n    # Each swap can increase the number of inversions by at most 1\n    # Therefore, the maximum messiness is the minimum of max_inversions and k\n    return min(max_inversions, k)\n\n# Read input\nn, k = map(int, input().split())\n# Calculate and print the maximum messiness\nprint(max_messiness(n, k))"}
{"solution": "def minimum_coins(N, M, K, L):\n    # Check if it's possible to satisfy the conditions\n    if M > N or (M * L > N - K + M):\n        return -1\n    \n    # Calculate the minimum number of coins each friend can gift\n    # We need at least L new coins, and each friend must gift the same number of coins\n    # Let x be the number of coins each friend gifts\n    # Then M * x must be at least L + (M - 1) * (x - 1)\n    # Rearranging gives us x >= (L + M - 1) / M\n    # We also need to ensure that M * x <= N\n    # Thus, we need to find the maximum of these two conditions\n    \n    # Minimum coins needed to satisfy the new coins condition\n    min_coins_needed = (L + M - 1) // M\n    \n    # Check if this minimum is feasible\n    if min_coins_needed * M > N:\n        return -1\n    \n    return min_coins_needed\n\n# Read input\nN, M, K, L = map(int, input().split())\n\n# Get the result\nresult = minimum_coins(N, M, K, L)\n\n# Print the result\nprint(result)"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    # Find the bounds of the black cells\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # If no black cells are found\n    if min_row == n:\n        return 1\n    \n    # Calculate the side length of the square\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    \n    # Check if the square can fit within the grid\n    if side_length > n or side_length > m:\n        return -1\n    \n    # Count the number of white cells within the square\n    min_paint = float('inf')\n    for i in range(n - side_length + 1):\n        for j in range(m - side_length + 1):\n            paint_count = 0\n            for x in range(i, i + side_length):\n                for y in range(j, j + side_length):\n                    if grid[x][y] == 'W':\n                        paint_count += 1\n            min_paint = min(min_paint, paint_count)\n    \n    return min_paint\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Get the result and print it\nresult = min_cells_to_paint(n, m, grid)\nprint(result)"}
{"solution": "def can_records_be_consistent(n, x, y):\n    # Calculate the total number of stones in both visits\n    total_x = sum(x)\n    total_y = sum(y)\n    \n    # The records can be consistent if the total number of stones in the second visit\n    # is less than or equal to the total number of stones in the first visit\n    if total_y <= total_x:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input\nn = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_records_be_consistent(n, x, y)\nprint(result)"}
{"solution": "def minimal_difference(n, angles):\n    total_angle = sum(angles)\n    min_diff = total_angle  # Start with the maximum possible difference\n\n    # We will use a prefix sum to calculate the angles of continuous sectors\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + angles[i]\n\n    # Check all possible continuous sectors\n    for start in range(n):\n        for end in range(start, n):\n            sector_angle = prefix_sum[end + 1] - prefix_sum[start]\n            other_sector_angle = total_angle - sector_angle\n            diff = abs(sector_angle - other_sector_angle)\n            min_diff = min(min_diff, diff)\n\n    return min_diff\n\n# Input reading\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Output the result\nprint(minimal_difference(n, angles))"}
{"solution": "def count_ways(n, m):\n    MOD = 10**9 + 7\n    \n    # Calculate (2^m - 1)^n % MOD\n    # 2^m - 1 represents the non-empty subsets of boxes for each present kind\n    # We need to compute (2^m - 1)^n to account for all present kinds\n    power_of_two = pow(2, m, MOD) - 1  # 2^m - 1\n    if power_of_two < 0:\n        power_of_two += MOD  # Ensure it's positive\n    \n    result = pow(power_of_two, n, MOD)  # (2^m - 1)^n % MOD\n    return result\n\n# Read input\nn, m = map(int, input().split())\n# Calculate and print the result\nprint(count_ways(n, m))"}
{"solution": "def find_pythagorean_triple(n):\n    if n <= 0:\n        return -1\n    \n    if n % 2 == 0:\n        # n is even\n        m = (n // 2) ** 2 - 1\n        k = (n // 2) ** 2 + 1\n    else:\n        # n is odd\n        m = (n ** 2 - 1) // 2\n        k = (n ** 2 + 1) // 2\n    \n    if m > 0 and k > 0:\n        return m, k\n    else:\n        return -1\n\nn = int(input().strip())\nresult = find_pythagorean_triple(n)\n\nif result == -1:\n    print(-1)\nelse:\n    print(result[0], result[1])"}
{"solution": "def are_remainders_distinct(n, k):\n    if k > n:\n        # If k is greater than n, all remainders will be distinct\n        return \"Yes\"\n    \n    # Use a set to track seen remainders\n    seen_remainders = set()\n    \n    for i in range(1, k + 1):\n        remainder = n % i\n        if remainder in seen_remainders:\n            return \"No\"\n        seen_remainders.add(remainder)\n    \n    return \"Yes\"\n\n# Read input\nn, k = map(int, input().split())\n# Get the result\nresult = are_remainders_distinct(n, k)\n# Print the result\nprint(result)"}
{"solution": "import sys\n\ndef compare_large_integers():\n    # Read the two lines of input\n    a = sys.stdin.readline().strip()\n    b = sys.stdin.readline().strip()\n    \n    # Remove leading zeros\n    a = a.lstrip('0')\n    b = b.lstrip('0')\n    \n    # Compare lengths first\n    if len(a) > len(b):\n        print(\">\")\n    elif len(a) < len(b):\n        print(\"<\")\n    else:\n        # If lengths are equal, compare lexicographically\n        if a > b:\n            print(\">\")\n        elif a < b:\n            print(\"<\")\n        else:\n            print(\"=\")\n\nif __name__ == \"__main__\":\n    compare_large_integers()"}
{"solution": "def count_ways(n, p, colors):\n    MOD = 10**9 + 7\n    \n    # Count the number of fixed colors and uncolored pieces\n    fixed_black = colors.count(0)\n    fixed_white = colors.count(1)\n    uncolored = colors.count(-1)\n    \n    # Total ways to color uncolored pieces\n    total_colorings = pow(2, uncolored, MOD)\n    \n    # Create a DP table to count paths\n    dp = [[0, 0] for _ in range(n + 1)]\n    dp[0][0] = 1  # 1 way to have an empty path with even score\n    \n    # Calculate the number of paths\n    for i in range(1, n + 1):\n        for j in range(i):\n            # If we can connect j to i\n            if colors[j] != -1 and colors[i - 1] != -1:\n                if colors[j] != colors[i - 1]:  # alternating colors\n                    dp[i][1] = (dp[i][1] + dp[j][0]) % MOD  # even to odd\n                    dp[i][0] = (dp[i][0] + dp[j][1]) % MOD  # odd to even\n            else:\n                # If one of them is uncolored, we can consider both colorings\n                for color1 in range(2):  # 0 or 1 for j\n                    for color2 in range(2):  # 0 or 1 for i\n                        if color1 != color2:  # alternating colors\n                            dp[i][1] = (dp[i][1] + dp[j][0]) % MOD  # even to odd\n                            dp[i][0] = (dp[i][0] + dp[j][1]) % MOD  # odd to even\n    \n    # Total paths with the desired parity\n    total_paths = (dp[n][p] * total_colorings) % MOD\n    \n    return total_paths\n\n# Read input\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Get the result\nresult = count_ways(n, p, colors)\n\n# Print the result\nprint(result)"}
{"solution": "def minimum_rubles(n, a, b, c):\n    # Calculate the remainder when n is divided by 4\n    remainder = n % 4\n    \n    # If n is already divisible by 4, no need to buy any copybooks\n    if remainder == 0:\n        return 0\n    \n    # Calculate the number of additional copybooks needed to make n + k divisible by 4\n    needed = 4 - remainder\n    \n    # Initialize the minimum cost to a large number\n    min_cost = float('inf')\n    \n    # Check all combinations of packs to find the minimum cost\n    for i in range(needed + 1):\n        if i == 1:\n            min_cost = min(min_cost, a)\n        elif i == 2:\n            min_cost = min(min_cost, b)\n        elif i == 3:\n            min_cost = min(min_cost, c)\n    \n    # Check combinations of packs\n    if needed >= 2:\n        min_cost = min(min_cost, 2 * a, b)\n    if needed >= 3:\n        min_cost = min(min_cost, 3 * a, c, a + b)\n    \n    return min_cost\n\n# Read input\nn, a, b, c = map(int, input().split())\n\n# Get the result and print it\nresult = minimum_rubles(n, a, b, c)\nprint(result)"}
{"solution": "def can_make_acyclic(n, m, edges):\n    from collections import defaultdict, deque\n\n    # Create adjacency list and in-degree count\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n\n    for u, v in edges:\n        graph[u].append(v)\n        in_degree[v] += 1\n\n    # Function to perform DFS and detect cycles\n    def has_cycle():\n        visited = [0] * (n + 1)  # 0 = unvisited, 1 = visiting, 2 = visited\n\n        def dfs(node):\n            if visited[node] == 1:  # Found a cycle\n                return True\n            if visited[node] == 2:  # Already processed\n                return False\n\n            visited[node] = 1  # Mark as visiting\n            for neighbor in graph[node]:\n                if dfs(neighbor):\n                    return True\n            visited[node] = 2  # Mark as visited\n            return False\n\n        for i in range(1, n + 1):\n            if visited[i] == 0:  # Unvisited\n                if dfs(i):\n                    return True\n        return False\n\n    # Check if the original graph has a cycle\n    if not has_cycle():\n        return \"YES\"\n\n    # Try removing each edge and check for cycles\n    for u, v in edges:\n        # Temporarily remove the edge u -> v\n        graph[u].remove(v)\n        if not has_cycle():\n            return \"YES\"\n        # Add the edge back\n        graph[u].append(v)\n\n    return \"NO\"\n\n# Input reading\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output the result\nprint(can_make_acyclic(n, m, edges))"}
{"solution": "def min_coins_to_cover(n, m, antennas):\n    # Create a list to track the coverage of positions from 1 to m\n    coverage = [0] * (m + 1)\n\n    # Fill the coverage based on the initial scopes of the antennas\n    for x, s in antennas:\n        left = max(1, x - s)\n        right = min(m, x + s)\n        for i in range(left, right + 1):\n            coverage[i] = 1  # Mark this position as covered\n\n    # Now we need to ensure all positions from 1 to m are covered\n    coins_needed = 0\n    for position in range(1, m + 1):\n        if coverage[position] == 0:  # If this position is not covered\n            # Find the nearest antenna to cover this position\n            min_cost = float('inf')\n            for x, s in antennas:\n                # Calculate the current coverage of this antenna\n                current_left = x - s\n                current_right = x + s\n                if current_right < position:  # Antenna is to the left\n                    cost = position - current_right  # Need to increase scope\n                elif current_left > position:  # Antenna is to the right\n                    cost = current_left - position  # Need to increase scope\n                else:\n                    cost = 0  # This antenna already covers the position\n\n                min_cost = min(min_cost, cost)\n\n            # Increment the total coins needed\n            coins_needed += min_cost\n\n            # Update the coverage for this position\n            for x, s in antennas:\n                # Update the antenna's scope if it was the best option\n                current_left = x - s\n                current_right = x + s\n                if current_right < position:\n                    # Increase the scope of this antenna\n                    s += min_cost\n                elif current_left > position:\n                    # Increase the scope of this antenna\n                    s += min_cost\n\n                # Update coverage\n                left = max(1, x - s)\n                right = min(m, x + s)\n                for i in range(left, right + 1):\n                    coverage[i] = 1  # Mark this position as covered\n\n    return coins_needed\n\n# Read input\nn, m = map(int, input().split())\nantennas = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the minimum coins needed\nresult = min_coins_to_cover(n, m, antennas)\nprint(result)"}
{"solution": "def max_good_subset_weight(W, counts):\n    total_weight = 0\n    \n    for weight in range(1, 9):\n        count = counts[weight - 1]\n        if count > 0:\n            # Calculate the maximum number of items we can take of this weight\n            max_items = min(count, W // weight)\n            total_weight += max_items * weight\n            W -= max_items * weight\n            \n            if W <= 0:\n                break\n    \n    return total_weight\n\n# Read input\nW = int(input().strip())\ncounts = list(map(int, input().strip().split()))\n\n# Calculate and print the result\nresult = max_good_subset_weight(W, counts)\nprint(result)"}
{"solution": "def min_cost_to_buy_lemonade(n, L, costs):\n    # Calculate the volumes of each bottle type\n    volumes = [(1 << i) - 1 for i in range(1, n + 1)]\n    \n    # Initialize a list to store the minimum cost for each volume\n    dp = [float('inf')] * (L + 1)\n    dp[0] = 0  # No cost for 0 liters\n\n    # Dynamic programming to find the minimum cost\n    for i in range(n):\n        volume = volumes[i]\n        cost = costs[i]\n        for j in range(volume, L + 1):\n            dp[j] = min(dp[j], dp[j - volume] + cost)\n\n    # Find the minimum cost for at least L liters\n    min_cost = min(dp[L:])\n    \n    return min_cost\n\n# Input reading\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = min_cost_to_buy_lemonade(n, L, costs)\nprint(result)"}
{"solution": "def max_mex(n, a):\n    a.sort()\n    mex = 1\n    for num in a:\n        if num >= mex:\n            mex += 1\n    return mex\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = max_mex(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(int(digit) for digit in digits)\n    \n    # Try every possible segment sum from 1 to total_sum\n    for segment_sum in range(1, total_sum + 1):\n        if total_sum % segment_sum == 0:\n            current_sum = 0\n            valid_partition = True\n            for digit in digits:\n                current_sum += int(digit)\n                if current_sum > segment_sum:\n                    valid_partition = False\n                    break\n                elif current_sum == segment_sum:\n                    current_sum = 0\n            if valid_partition and current_sum == 0:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn = int(input())\ndigits = input().strip()\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\"\n\nusername = input().strip()\nprint(determine_gender(username))"}
{"solution": "def max_absolute_difference(n, k, tabs):\n    max_difference = 0\n    \n    for b in range(1, n + 1):\n        closed_tabs = set()\n        \n        # Close every k-th tab starting from b\n        for i in range(-n, n + 1):\n            c = b + i * k\n            if 1 <= c <= n:\n                closed_tabs.add(c)\n        \n        # Count remaining tabs\n        e = sum(1 for i in range(1, n + 1) if i not in closed_tabs and tabs[i - 1] == 1)\n        s = sum(1 for i in range(1, n + 1) if i not in closed_tabs and tabs[i - 1] == -1)\n        \n        # Calculate the absolute difference\n        max_difference = max(max_difference, abs(e - s))\n    \n    return max_difference\n\n# Read input\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Get the result and print it\nresult = max_absolute_difference(n, k, tabs)\nprint(result)"}
{"solution": "def minimum_cost(n, c0, c1):\n    # Calculate the number of bits needed to represent n letters\n    # We need to find the smallest k such that 2^k >= n\n    k = 0\n    while (1 << k) < n:\n        k += 1\n    \n    # Calculate the number of '0's and '1's used in the optimal encoding\n    # In a complete binary tree of height k, there are 2^k leaves\n    # The number of '0's and '1's can be calculated based on the distribution\n    total_zeros = (1 << (k - 1)) * (k - 1)  # 2^(k-1) leaves at depth k-1\n    total_ones = (1 << (k - 1)) * (k - 1)   # 2^(k-1) leaves at depth k-1\n    \n    # If we have more letters than the complete binary tree can hold\n    # We need to adjust the counts of '0's and '1's\n    if n > (1 << k):\n        total_zeros += (n - (1 << (k - 1))) * (k - 1)\n        total_ones += (n - (1 << (k - 1))) * (k - 1)\n    \n    # Calculate the total cost\n    total_cost = total_zeros * c0 + total_ones * c1\n    return total_cost\n\n# Read input\nn, c0, c1 = map(int, input().split())\n\n# Calculate and print the minimum cost\nprint(minimum_cost(n, c0, c1))"}
{"solution": "def will_meet(n, a, x, b, y):\n    while a != x and b != y:\n        if a == b:\n            return \"YES\"\n        a = a + 1 if a < n else 1\n        b = b - 1 if b > 1 else n\n    return \"YES\" if a == b else \"NO\"\n\n# Read input\nn, a, x, b, y = map(int, input().split())\n# Print the result\nprint(will_meet(n, a, x, b, y))"}
{"solution": "def find_golden_age_length(x, y, l, r):\n    unlucky_years = set()\n    \n    # Generate all powers of x and y within the range\n    a = 0\n    while True:\n        power_x = x ** a\n        if power_x > r:\n            break\n        b = 0\n        while True:\n            power_y = y ** b\n            if power_x + power_y > r:\n                break\n            unlucky_years.add(power_x + power_y)\n            b += 1\n        a += 1\n\n    # Filter unlucky years to be within the range [l, r]\n    unlucky_years = sorted(year for year in unlucky_years if l <= year <= r)\n\n    # Find the maximum length of the golden age\n    max_length = 0\n    current_start = l\n\n    for year in unlucky_years:\n        if year > current_start:\n            max_length = max(max_length, year - current_start)\n        current_start = year + 1\n\n    # Check the end of the range\n    if current_start <= r:\n        max_length = max(max_length, r - current_start + 1)\n\n    return max_length\n\n# Read input\nx, y, l, r = map(int, input().split())\n# Get the result\nresult = find_golden_age_length(x, y, l, r)\n# Print the output\nprint(result)"}
{"solution": "def minimum_tax(n):\n    # Find the maximum divisor of n that is not equal to n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return n // i\n    return 1  # If no divisors found, return 1 (for prime numbers)\n\nn = int(input())\nprint(minimum_tax(n))"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    n = len(word)\n    result = []\n    i = 0\n    \n    while i < n:\n        result.append(word[i])\n        if word[i] not in vowels:\n            start = i\n            while i < n and word[i] not in vowels:\n                i += 1\n            if i - start >= 3:\n                block = word[start:i]\n                if len(set(block)) > 1:\n                    result.append(' ')\n        i += 1\n    \n    return ''.join(result)\n\n# Read input\ninput_word = input().strip()\n# Process and print the output\nprint(fix_typos(input_word))"}
{"solution": "def min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d):\n    # Initialize the minimum time to prepare potions without any spells\n    min_time = n * x\n    \n    # Check all combinations of spells of the first type\n    for i in range(m):\n        if b[i] <= s:  # If we can afford this spell\n            potion_time = a[i]\n            remaining_potions = n\n            \n            # Check all combinations of spells of the second type\n            for j in range(k):\n                if d[j] + b[i] <= s:  # If we can afford both spells\n                    remaining_potions -= c[j]\n                    if remaining_potions <= 0:\n                        min_time = min(min_time, 0)  # All potions are prepared instantly\n                        break\n                    else:\n                        min_time = min(min_time, remaining_potions * potion_time)\n                else:\n                    # If we can't afford the second spell, just use the first spell\n                    min_time = min(min_time, remaining_potions * potion_time)\n    \n    # Check using only the second type of spells\n    for j in range(k):\n        if d[j] <= s:  # If we can afford this spell\n            remaining_potions = n - c[j]\n            if remaining_potions <= 0:\n                min_time = min(min_time, 0)  # All potions are prepared instantly\n            else:\n                min_time = min(min_time, remaining_potions * x)\n    \n    return min_time\n\n# Read input\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\n# Calculate and print the minimum time\nresult = min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d)\nprint(result)"}
{"solution": "def max_points(n, k, M, t):\n    # Calculate the total time required to complete all subtasks of a task\n    total_time_per_task = sum(t)\n    \n    max_points = 0\n    \n    # Iterate over the number of tasks completed\n    for completed_tasks in range(n + 1):\n        time_spent = completed_tasks * total_time_per_task\n        if time_spent > M:\n            break\n        \n        points = completed_tasks * (k + 1)  # Points for completed tasks\n        \n        remaining_time = M - time_spent\n        \n        # Calculate how many additional subtasks can be solved with the remaining time\n        additional_points = 0\n        for j in range(k):\n            if remaining_time <= 0:\n                break\n            # Time required for the j-th subtask\n            time_for_subtask = t[j]\n            # Maximum subtasks of this type that can be solved\n            max_subtasks = remaining_time // time_for_subtask\n            # We can only solve up to n - completed_tasks subtasks of this type\n            max_subtasks = min(max_subtasks, n - completed_tasks)\n            additional_points += max_subtasks\n            remaining_time -= max_subtasks * time_for_subtask\n        \n        max_points = max(max_points, points + additional_points)\n    \n    return max_points\n\n# Input reading\nn, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Calculate and print the maximum points\nprint(max_points(n, k, M, t))"}
{"solution": "MOD = 998244353\n\ndef count_perfectly_balanced_striped_bst(n):\n    if n % 2 == 1:\n        return 0  # Odd n cannot form a perfectly balanced striped BST\n\n    # Precompute factorials and inverse factorials\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n\n    inv_fact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\n    # Calculate the number of perfectly balanced striped BSTs\n    half_n = n // 2\n    result = (fact[n] * inv_fact[half_n] % MOD * inv_fact[half_n] % MOD) * inv_fact[1] % MOD\n    return result\n\nn = int(input().strip())\nprint(count_perfectly_balanced_striped_bst(n))"}
{"solution": "def lara_position(n, m, k):\n    # Calculate the total number of cells\n    total_cells = n * m\n    \n    # Determine the number of full columns Lara can traverse\n    full_columns = k // (n - 1)\n    remaining_moves = k % (n - 1)\n    \n    # Calculate the current column\n    current_column = full_columns + 1\n    \n    # If the current column exceeds the number of columns, adjust\n    if current_column > m:\n        current_column = m\n        remaining_moves = (n - 1) - (k - (full_columns * (n - 1)))\n    \n    # Determine the current row based on remaining moves\n    if current_column % 2 == 1:  # Odd column\n        current_row = 1 + remaining_moves\n    else:  # Even column\n        current_row = n - remaining_moves\n    \n    return current_row, current_column\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Get the position\nrow, column = lara_position(n, m, k)\n\n# Print the result\nprint(row, column)"}
{"solution": "import math\n\ndef find_min_max_pair(X):\n    min_max_value = float('inf')\n    best_pair = (1, X)\n\n    # Iterate through all possible factors of X\n    for a in range(1, int(math.isqrt(X)) + 1):\n        if X % a == 0:\n            b = X // a\n            # Check if LCM(a, b) == X\n            if (a * b) // math.gcd(a, b) == X:\n                max_value = max(a, b)\n                if max_value < min_max_value:\n                    min_max_value = max_value\n                    best_pair = (a, b)\n\n    return best_pair\n\n# Read input\nX = int(input().strip())\na, b = find_min_max_pair(X)\nprint(a, b)"}
{"solution": "def max_fruits_for_compote(a, b, c):\n    # Calculate the maximum number of complete sets for each fruit type\n    max_sets_lemons = a // 1\n    max_sets_apples = b // 2\n    max_sets_pears = c // 4\n    \n    # Find the limiting factor (minimum number of complete sets)\n    max_complete_sets = min(max_sets_lemons, max_sets_apples, max_sets_pears)\n    \n    # Calculate the total number of fruits used in the compote\n    total_fruits = max_complete_sets * (1 + 2 + 4)\n    \n    return total_fruits\n\n# Input reading\na = int(input())\nb = int(input())\nc = int(input())\n\n# Output the result\nprint(max_fruits_for_compote(a, b, c))"}
{"solution": "def can_divide_teams(n, ratings):\n    ratings.sort()\n    for i in range(n):\n        if ratings[i] >= ratings[i + n]:\n            return \"NO\"\n    return \"YES\"\n\n# Read input\nn = int(input())\nratings = list(map(int, input().split()))\n\n# Output the result\nprint(can_divide_teams(n, ratings))"}
{"solution": "from math import gcd\nfrom sys import stdin, stdout\n\ndef make_coprime_array(n, arr):\n    new_arr = []\n    insertions = 0\n    \n    for i in range(n):\n        new_arr.append(arr[i])\n        if i < n - 1:\n            if gcd(arr[i], arr[i + 1]) != 1:\n                # We need to insert a number between arr[i] and arr[i + 1]\n                # We can insert 1, as it is co-prime with any number\n                new_arr.append(1)\n                insertions += 1\n                \n    return insertions, new_arr\n\ndef main():\n    input = stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    arr = list(map(int, data[1:n + 1]))\n    \n    insertions, new_arr = make_coprime_array(n, arr)\n    \n    stdout.write(f\"{insertions}\\n\")\n    stdout.write(\" \".join(map(str, new_arr)) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\nfrom functools import reduce\nfrom math import gcd\n\ndef compute_gcd_of_list(lst):\n    return reduce(gcd, lst)\n\ndef max_divisor_after_operations(N, K, A):\n    if N == 1:\n        return A[0]\n    \n    # Compute the GCD of the differences between all pairs\n    diffs = [abs(A[i] - A[j]) for i in range(N) for j in range(i + 1, N)]\n    initial_gcd = compute_gcd_of_list(diffs)\n    \n    # The maximum possible divisor we can achieve\n    max_divisor = initial_gcd\n    \n    # Check if we can adjust the elements to make them divisible by max_divisor\n    for d in range(1, initial_gcd + 1):\n        if initial_gcd % d == 0:\n            # Check if we can make all elements divisible by d\n            total_moves_needed = sum((a % d) for a in A)\n            if total_moves_needed <= K:\n                max_divisor = d\n    \n    return max_divisor\n\n# Read input\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Compute and print the result\nprint(max_divisor_after_operations(N, K, A))"}
{"solution": "def cat_furrier_transform(x):\n    operations = []\n    \n    # Function to check if x is a perfect longcat\n    def is_perfect_longcat(num):\n        return (num & (num + 1)) == 0\n    \n    # If x is already a perfect longcat, no operations are needed\n    if is_perfect_longcat(x):\n        print(0)\n        return\n    \n    # Perform operations until we reach a perfect longcat or exceed 40 operations\n    for _ in range(20):  # We can perform at most 20 pairs of operations (40 total)\n        # Find the highest bit that is set in x\n        highest_bit = x.bit_length() - 1\n        \n        # Operation A: Select n as the highest bit + 1\n        n = highest_bit + 1\n        operations.append(n)\n        x ^= (1 << n) - 1  # x = x XOR (2^n - 1)\n        \n        # Check if we reached a perfect longcat\n        if is_perfect_longcat(x):\n            break\n        \n        # Operation B: Increment x by 1\n        x += 1\n        \n        # Check if we reached a perfect longcat\n        if is_perfect_longcat(x):\n            break\n    \n    # Output the number of operations and the n values\n    print(len(operations) * 2)  # Each n corresponds to an A operation\n    print(\" \".join(map(str, operations)))\n\n# Read input\nx = int(input().strip())\ncat_furrier_transform(x)"}
{"solution": "# Read input values\nn, k = map(int, input().split())\nbuckets = list(map(int, input().split()))\n\n# Initialize the minimum hours to a large number\nmin_hours = float('inf')\n\n# Iterate through each bucket length\nfor a in buckets:\n    # Check if the bucket can evenly water the garden\n    if k % a == 0:\n        # Calculate the number of hours needed with this bucket\n        hours = k // a\n        # Update the minimum hours if this is a better option\n        min_hours = min(min_hours, hours)\n\n# Print the minimum number of hours required\nprint(min_hours)"}
{"solution": "def can_grasshopper_reach_insect(n, k, line):\n    g_index = line.index('G')\n    t_index = line.index('T')\n    \n    # Determine the direction of the jump\n    if g_index < t_index:\n        step = k\n    else:\n        step = -k\n    \n    # Check if the grasshopper can reach the insect\n    for i in range(g_index, t_index, step):\n        if line[i] == '#':\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\nline = input().strip()\n\n# Get the result and print it\nresult = can_grasshopper_reach_insect(n, k, line)\nprint(result)"}
{"solution": "def find_aim_point(y1, y2, yw, xb, yb, r):\n    # Calculate the effective y-coordinates for the goalposts considering the radius of the ball\n    y1_eff = y1 + r\n    y2_eff = y2 - r\n\n    # Check if the ball can bounce off the wall and go into the goal\n    if yb + r >= yw or yb - r <= yw:\n        return -1\n\n    # Calculate the potential y-coordinate of the ball after bouncing off the wall\n    # The line from (xb, yb) to (xw, yw) must intersect the goal area\n    # The slope of the line from the ball to the wall\n    slope = (yw - yb) / (xb - 0)\n\n    # The y-coordinate of the ball when it reaches the wall\n    # yw = slope * xw + yb\n    # Rearranging gives us xw = (yw - yb) / slope\n    # We need to find xw such that the ball bounces into the goal area\n    # The y-coordinate of the ball when it reaches the goal\n    # y_goal = slope * 0 + yb\n\n    # The x-coordinate of the wall where the ball should hit\n    xw = (yw - yb) * (xb / (yw - yb)) + xb\n\n    # Check if the y-coordinate of the ball after bouncing is within the goal area\n    y_goal = slope * 0 + yb\n    if y_goal < y1_eff or y_goal > y2_eff:\n        return -1\n\n    return xw\n\n# Read input\ny1, y2, yw, xb, yb, r = map(int, input().split())\n\n# Find the aim point\nresult = find_aim_point(y1, y2, yw, xb, yb, r)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(f\"{result:.10f}\")"}
{"solution": "def min_missed_meals(b, d, s):\n    # Calculate the maximum number of full days based on the meals had\n    max_days = max(b, d, s)\n    \n    # Calculate the total meals that should have been had in those days\n    total_meals = max_days * 3\n    \n    # Calculate the total meals actually had\n    actual_meals = b + d + s\n    \n    # The missed meals are the difference between total meals and actual meals\n    missed_meals = total_meals - actual_meals\n    \n    # Ensure that we do not count missed meals on the arrival and departure days\n    # We can miss at most 2 meals on the first day and 2 meals on the last day\n    # So we need to adjust the missed meals accordingly\n    if max_days > 1:\n        missed_meals = max(0, missed_meals - 2)\n    \n    return missed_meals\n\n# Read input\nb, d, s = map(int, input().split())\n\n# Get the result\nresult = min_missed_meals(b, d, s)\n\n# Print the result\nprint(result)"}
{"solution": "def find_matrix_dimensions(n, path):\n    # Create a set to store the visited cells\n    visited = set()\n    \n    # Store the minimum and maximum values in the path\n    min_val = float('inf')\n    max_val = float('-inf')\n    \n    # Process the path to find min and max values\n    for num in path:\n        visited.add(num)\n        min_val = min(min_val, num)\n        max_val = max(max_val, num)\n    \n    # Calculate the possible dimensions\n    total_cells = max_val\n    x = 0\n    y = 0\n    \n    # We need to find x and y such that x * y >= total_cells\n    for i in range(1, int(total_cells**0.5) + 2):\n        if total_cells % i == 0:\n            j = total_cells // i\n            if i <= 10**9 and j <= 10**9:\n                x, y = i, j\n                break\n    \n    # Check if the path is valid\n    for i in range(len(path) - 1):\n        a = path[i]\n        b = path[i + 1]\n        \n        # Calculate the positions in the matrix\n        a_row = (a - 1) // y\n        a_col = (a - 1) % y\n        b_row = (b - 1) // y\n        b_col = (b - 1) % y\n        \n        # Check if the move is valid\n        if not ((abs(a_row - b_row) == 1 and a_col == b_col) or (abs(a_col - b_col) == 1 and a_row == b_row)):\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(x, y)\n\n# Input reading\nn = int(input().strip())\npath = list(map(int, input().strip().split()))\n\n# Function call\nfind_matrix_dimensions(n, path)"}
{"solution": "def min_removal_subsequence(a, b):\n    n, m = len(a), len(b)\n    \n    # Create a list to store the positions of characters in a\n    pos = {char: [] for char in set(a)}\n    for i in range(n):\n        pos[a[i]].append(i)\n    \n    # Function to check if b can be a subsequence of a after removing a segment\n    def can_form_subsequence(start, end):\n        j = 0  # Pointer for string a\n        for i in range(len(b)):\n            if start <= i <= end:\n                continue  # Skip the segment to be removed\n            while j < n and a[j] != b[i]:\n                j += 1\n            if j == n:  # If we reach the end of a, b cannot be a subsequence\n                return False\n            j += 1  # Move to the next character in a\n        return True\n    \n    best_start, best_end = -1, -1\n    \n    # Try removing every possible segment of b\n    for start in range(m):\n        for end in range(start, m):\n            if can_form_subsequence(start, end):\n                if best_start == -1 or (end - start) < (best_end - best_start):\n                    best_start, best_end = start, end\n    \n    # If no valid segment found, return \"-\"\n    if best_start == -1:\n        return \"-\"\n    \n    # Build the resulting subsequence\n    result = []\n    for i in range(m):\n        if not (best_start <= i <= best_end):\n            result.append(b[i])\n    \n    # Check if the result is empty\n    return ''.join(result) if result else \"-\"\n\n# Input reading\na = input().strip()\nb = input().strip()\n\n# Output the result\nprint(min_removal_subsequence(a, b))"}
{"solution": "def minimal_stones(n, s):\n    current_stones = 0\n    min_stones_needed = 0\n    \n    for char in s:\n        if char == '+':\n            current_stones += 1\n        elif char == '-':\n            current_stones -= 1\n            min_stones_needed = min(min_stones_needed, current_stones)\n    \n    # The minimal possible number of stones is the maximum of 0 and the negation of min_stones_needed\n    return max(0, -min_stones_needed)\n\n# Input reading\nn = int(input())\ns = input().strip()\nprint(minimal_stones(n, s))"}
{"solution": "def max_kefir(n, a, b, c):\n    # Calculate the maximum liters of kefir Kolya can drink\n    max_liters = 0\n    \n    # Option 1: Buy only plastic bottles\n    max_liters = n // a\n    \n    # Option 2: Buy glass bottles and return them\n    if b <= n:\n        # Calculate how many glass bottles can be bought initially\n        initial_glass_bottles = n // b\n        remaining_money = n % b\n        \n        # Total liters from initial glass bottles\n        total_liters = initial_glass_bottles\n        \n        # Now, return the glass bottles and buy more\n        # Each glass bottle gives back c rubles\n        total_money_after_return = initial_glass_bottles * c + remaining_money\n        \n        # Calculate how many more plastic bottles can be bought with the returned money\n        total_liters += total_money_after_return // a\n        \n        # Update max_liters if this option is better\n        max_liters = max(max_liters, total_liters)\n    \n    return max_liters\n\n# Read input\nn = int(input().strip())\na = int(input().strip())\nb = int(input().strip())\nc = int(input().strip())\n\n# Calculate and print the result\nprint(max_kefir(n, a, b, c))"}
{"solution": "from collections import deque\n\ndef card_war(n, soldier1_cards, soldier2_cards):\n    # Initialize the queues for both soldiers\n    soldier1 = deque(soldier1_cards)\n    soldier2 = deque(soldier2_cards)\n    \n    # Set to track seen states to detect infinite loops\n    seen_states = set()\n    \n    fights = 0\n    \n    while soldier1 and soldier2:\n        # Create a state representation\n        state = (tuple(soldier1), tuple(soldier2))\n        if state in seen_states:\n            return -1  # Infinite game detected\n        seen_states.add(state)\n        \n        fights += 1\n        \n        # Draw cards\n        card1 = soldier1.popleft()\n        card2 = soldier2.popleft()\n        \n        if card1 > card2:\n            soldier1.append(card2)\n            soldier1.append(card1)\n        else:\n            soldier2.append(card1)\n            soldier2.append(card2)\n    \n    # Determine the winner\n    if soldier1:\n        return fights, 1  # Soldier 1 wins\n    else:\n        return fights, 2  # Soldier 2 wins\n\n# Input reading\nn = int(input().strip())\nk1_data = list(map(int, input().strip().split()))\nk1 = k1_data[0]\nsoldier1_cards = k1_data[1:]\n\nk2_data = list(map(int, input().strip().split()))\nk2 = k2_data[0]\nsoldier2_cards = k2_data[1:]\n\n# Call the function and print the result\nresult = card_war(n, soldier1_cards, soldier2_cards)\nprint(result[0], result[1]) if result != -1 else print(-1)"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    \n    has_upper = False\n    has_lower = False\n    has_digit = False\n    \n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n    \n    if has_upper and has_lower and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\"\n\n# Read input\npassword = input().strip()\n# Print the result of the complexity check\nprint(check_password_complexity(password))"}
{"solution": "def min_exchanges(n, group_a, group_b):\n    count_a = [0] * 6  # Index 0 will be unused\n    count_b = [0] * 6  # Index 0 will be unused\n\n    # Count the number of students with each performance in both groups\n    for performance in group_a:\n        count_a[performance] += 1\n    for performance in group_b:\n        count_b[performance] += 1\n\n    # Calculate the excess and deficit for each performance level\n    excess_a = [0] * 6\n    excess_b = [0] * 6\n    total_exchanges = 0\n\n    for i in range(1, 6):\n        if count_a[i] > count_b[i]:\n            excess_a[i] = (count_a[i] - count_b[i]) // 2\n        elif count_a[i] < count_b[i]:\n            excess_b[i] = (count_b[i] - count_a[i]) // 2\n\n    # Calculate total excesses\n    total_excess_a = sum(excess_a)\n    total_excess_b = sum(excess_b)\n\n    # The total excesses must be equal for a valid redistribution\n    if total_excess_a != total_excess_b:\n        return -1\n\n    return total_excess_a\n\n# Input reading\nn = int(input())\ngroup_a = list(map(int, input().split()))\ngroup_b = list(map(int, input().split()))\n\n# Get the result and print it\nresult = min_exchanges(n, group_a, group_b)\nprint(result)"}
{"solution": "def can_reach_all_junctions(n, m, horizontal, vertical):\n    # Create a graph representation of the junctions\n    graph = [[False] * m for _ in range(n)]\n    \n    # Mark reachable junctions based on horizontal street directions\n    for i in range(n):\n        if horizontal[i] == '>':\n            for j in range(m):\n                graph[i][j] = True\n        elif horizontal[i] == '<':\n            for j in range(m):\n                graph[i][m - 1 - j] = True\n\n    # Mark reachable junctions based on vertical street directions\n    for j in range(m):\n        if vertical[j] == 'v':\n            for i in range(n):\n                graph[n - 1 - i][j] = True\n        elif vertical[j] == '^':\n            for i in range(n):\n                graph[i][j] = True\n\n    # Check if all junctions are reachable from any junction\n    for i in range(n):\n        for j in range(m):\n            if not graph[i][j]:\n                return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nhorizontal = input().strip()\nvertical = input().strip()\n\n# Get the result and print it\nresult = can_reach_all_junctions(n, m, horizontal, vertical)\nprint(result)"}
{"solution": "def can_make_false(n, args):\n    if n == 1:\n        if args[0] == 0:\n            return True, \"0\"\n        else:\n            return False, \"\"\n    \n    # If there are at least two arguments\n    if n >= 2:\n        # Check if we can create a false expression\n        if 1 in args and 0 in args:\n            # We can create a false expression\n            # We can use the first 1 and the last 0 to create a false implication\n            # Example: (1 -> 0) will be false\n            # We can wrap the whole expression in brackets\n            expression = \"(\" + \"->\".join(map(str, args)) + \")\"\n            return True, expression\n        else:\n            return False, \"\"\n    \n    return False, \"\"\n\n# Read input\nn = int(input().strip())\nargs = list(map(int, input().strip().split()))\n\n# Determine if we can make the expression false\npossible, expression = can_make_false(n, args)\n\n# Print output\nif possible:\n    print(\"YES\")\n    print(expression)\nelse:\n    print(\"NO\")"}
{"solution": "def process_values(a, b):\n    while a > 0 and b > 0:\n        if a >= 2 * b:\n            a = a - 2 * b\n        elif b >= 2 * a:\n            b = b - 2 * a\n        else:\n            break\n    return a, b\n\n# Read input\nn, m = map(int, input().split())\nresult = process_values(n, m)\n\n# Print output\nprint(result[0], result[1])"}
{"solution": "def count_k_divisible(k, a, b):\n    # Calculate the first multiple of k greater than or equal to a\n    if a % k == 0:\n        first = a\n    else:\n        first = a + (k - a % k)\n\n    # Calculate the last multiple of k less than or equal to b\n    if b % k == 0:\n        last = b\n    else:\n        last = b - (b % k)\n\n    # If the first multiple is greater than the last, there are no k-divisible numbers\n    if first > last:\n        return 0\n\n    # Count the number of multiples of k in the range\n    return (last - first) // k + 1\n\n# Read input\nk, a, b = map(int, input().split())\n\n# Get the result and print it\nresult = count_k_divisible(k, a, b)\nprint(result)"}
{"solution": "def find_kth_digit(k):\n    length = 1  # Current length of numbers (1 for 1-9, 2 for 10-99, etc.)\n    count = 9   # Count of numbers with the current length\n    start = 1   # Starting number with the current length\n\n    # Determine the range in which the k-th digit lies\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # Find the actual number that contains the k-th digit\n    start += (k - 1) // length\n    num_str = str(start)\n    \n    # Find the specific digit\n    return num_str[(k - 1) % length]\n\n# Read input\nk = int(input().strip())\n# Print the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "def can_vasya_win(n, s):\n    # Vasya needs to ensure that there is at least one '8' in the first n - 10 characters\n    # because the final string must start with '8' to be a valid telephone number.\n    \n    # Count the number of '8's in the first n - 10 characters\n    count_8s = s[:n - 10].count('8')\n    \n    # Vasya can ensure a win if there is at least one '8' in the first n - 10 characters\n    if count_8s > 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Determine if Vasya has a winning strategy\nresult = can_vasya_win(n, s)\nprint(result)"}
{"solution": "def factorial_mod(n, mod):\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    return fact\n\ndef count_valid_permutations(n, x, pos):\n    mod = 10**9 + 7\n    fact = factorial_mod(n, mod)\n\n    # Count how many numbers are less than x and greater than x\n    less_count = x - 1\n    greater_count = n - x\n\n    # Determine the range of valid positions for numbers less than x\n    left_limit = pos - greater_count\n    right_limit = pos\n\n    if left_limit < 0 or right_limit > less_count:\n        return 0\n\n    # Calculate the number of ways to arrange the less than x numbers\n    ways_to_place_less = fact[less_count] * pow(fact[left_limit], mod - 2, mod) % mod * pow(fact[less_count - left_limit], mod - 2, mod) % mod\n\n    # Calculate the number of ways to arrange the greater than x numbers\n    ways_to_place_greater = fact[greater_count] * pow(fact[greater_count - (pos - left_limit)], mod - 2, mod) % mod\n\n    # Total valid permutations\n    total_permutations = ways_to_place_less * ways_to_place_greater % mod\n\n    return total_permutations\n\n# Read input\nn, x, pos = map(int, input().split())\n# Calculate and print the result\nprint(count_valid_permutations(n, x, pos))"}
{"solution": "def decode_message(encoded_string, k):\n    result = []\n    i = 0\n    n = len(encoded_string)\n\n    while i < n:\n        char = encoded_string[i]\n        result.append(char)  # Add the current character\n\n        # Check for candy cane '?'\n        if i + 1 < n and encoded_string[i + 1] == '?':\n            # We can either keep the character or remove it\n            # So we can choose to not add it to the result\n            # But we will keep it in the result for now\n            pass  # Just move to the next character\n        # Check for snowflake '*'\n        elif i + 1 < n and encoded_string[i + 1] == '*':\n            # We can repeat the character any number of times\n            # For simplicity, we will just add it once and handle it later\n            pass  # Just move to the next character\n\n        # Move to the next character\n        i += 1 if i + 1 >= n or encoded_string[i + 1] not in '?*' else 2\n\n    # Now we have a base result, we need to check if we can form a message of length k\n    base_length = len(result)\n    min_length = base_length\n    max_length = base_length\n\n    # Calculate the minimum and maximum possible lengths\n    for i in range(len(encoded_string)):\n        if encoded_string[i] == '?':\n            max_length += 1  # Candy cane can either keep or remove the previous character\n        elif encoded_string[i] == '*':\n            max_length += 1  # Snowflake can repeat the previous character any number of times\n\n    # Check if k is within the possible range\n    if k < min_length or k > max_length:\n        return \"Impossible\"\n\n    # Now we need to construct a valid message of length k\n    message = []\n    current_length = 0\n\n    for char in result:\n        if current_length < k:\n            message.append(char)\n            current_length += 1\n\n        # If we can still add more characters\n        while current_length < k and (i < n and (encoded_string[i] == '*' or encoded_string[i] == '?')):\n            if encoded_string[i] == '?':\n                # Add the character again\n                message.append(char)\n                current_length += 1\n            elif encoded_string[i] == '*':\n                # Add the character multiple times\n                message.append(char)\n                current_length += 1\n            i += 1\n\n        # Move to the next character\n        if i < n and (encoded_string[i] == '?' or encoded_string[i] == '*'):\n            i += 1  # Skip the special character\n\n    # If we have reached the desired length, return the message\n    if current_length == k:\n        return ''.join(message)\n    else:\n        return \"Impossible\"\n\n# Read input\nencoded_string = input().strip()\nk = int(input().strip())\n\n# Get the result\nresult = decode_message(encoded_string, k)\n\n# Print the result\nprint(result)"}
{"solution": "def min_turns_to_correct_rotation(x):\n    # Normalize the angle to be within [0, 360)\n    normalized_angle = x % 360\n    \n    # Calculate the deviation from vertical for 0, 90, 180, and 270 degrees\n    deviations = [\n        abs(normalized_angle),               # 0 degrees\n        abs((normalized_angle + 90) % 360), # 90 degrees\n        abs((normalized_angle + 180) % 360),# 180 degrees\n        abs((normalized_angle + 270) % 360) # 270 degrees\n    ]\n    \n    # Find the minimum deviation and its corresponding number of 90-degree turns\n    min_deviation = min(deviations)\n    min_turns = deviations.index(min_deviation)\n    \n    return min_turns\n\n# Read input\nx = int(input().strip())\n# Get the result\nresult = min_turns_to_correct_rotation(x)\n# Print the output\nprint(result)"}
{"solution": "def can_transform_spheres(a, b, c, x, y, z):\n    # Calculate the surplus spheres\n    surplus_blue = a - x\n    surplus_violet = b - y\n    surplus_orange = c - z\n\n    # If we have enough spheres of each color, return \"Yes\"\n    if surplus_blue >= 0 and surplus_violet >= 0 and surplus_orange >= 0:\n        return \"Yes\"\n\n    # Calculate the total surplus and the total needed\n    total_surplus = max(0, surplus_blue) + max(0, surplus_violet) + max(0, surplus_orange)\n    total_needed = - (min(0, surplus_blue) + min(0, surplus_violet) + min(0, surplus_orange))\n\n    # Each transformation requires 2 spheres of the same color to create 1 of another color\n    # Therefore, we can convert surplus spheres into needed spheres\n    # Each transformation can convert 2 surplus into 1 needed\n    if total_surplus // 2 >= total_needed:\n        return \"Yes\"\n    \n    return \"No\"\n\n# Read input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Get the result and print it\nresult = can_transform_spheres(a, b, c, x, y, z)\nprint(result)"}
{"solution": "def count_valid_numbers(n, k, m):\n    # Count of valid suffixes that are multiples of k\n    count_suffixes = 0\n    \n    # Iterate through all possible suffixes of length 1 to n\n    for length in range(1, n + 1):\n        # The smallest number with 'length' digits\n        start = 10**(length - 1)\n        # The largest number with 'length' digits\n        end = 10**length - 1\n        \n        # Count multiples of k in the range [start, end]\n        first_multiple = (start + k - 1) // k * k  # First multiple of k >= start\n        if first_multiple > end:\n            continue  # No multiples in this range\n        \n        last_multiple = end // k * k  # Last multiple of k <= end\n        if first_multiple <= last_multiple:\n            count_suffixes += (last_multiple - first_multiple) // k + 1\n    \n    # Total numbers with n digits\n    total_numbers = 9 * (10**(n - 1))  # 1 to 9 for the first digit, 0 to 9 for the rest\n    \n    # Valid numbers are total numbers minus those that do not have valid suffixes\n    valid_numbers = (total_numbers * count_suffixes) % m\n    \n    return valid_numbers\n\n# Read input\nn, k, m = map(int, input().split())\n\n# Get the result\nresult = count_valid_numbers(n, k, m)\n\n# Print the result\nprint(result)"}
{"solution": "def max_team_size(l, r, a):\n    if l > r:\n        l, r = r, l  # Ensure l is always the smaller or equal group\n    \n    # Use ambidexters to balance the difference\n    d = r - l\n    if a >= d:\n        l += d\n        a -= d\n        # Now l == r, distribute remaining ambidexters equally\n        l += a // 2\n        r += a // 2\n    else:\n        l += a\n        # Not enough ambidexters to balance completely, r remains larger\n    \n    # The maximum team size is twice the smaller group\n    return 2 * min(l, r)\n\n# Read input\nl, r, a = map(int, input().split())\n# Calculate and print the maximum team size\nprint(max_team_size(l, r, a))"}
{"solution": "def minimum_moves(n, k):\n    # Calculate the total moves required\n    # Moves to clear all manholes\n    total_moves = 0\n    \n    # For each manhole, we need to throw stones and then pick the coin\n    for i in range(1, n + 1):\n        # Move to the manhole if not at the current position\n        total_moves += abs(k - i)  # Move to the i-th manhole\n        total_moves += 1            # Throw the stone (1 move)\n        total_moves += 1            # Open the manhole and pick the coin (1 move)\n        k = i                        # Update current position to the i-th manhole\n\n    # After picking all coins, we need to return to the starting position\n    total_moves += abs(k - 1)      # Move back to the first manhole\n\n    return total_moves\n\n# Read input\nn, k = map(int, input().split())\n# Print the result\nprint(minimum_moves(n, k))"}
{"solution": "def minimum_tower_height(n, m):\n    # Calculate the maximum height for two-block towers\n    max_height_two_block = n * 2\n    \n    # Calculate the maximum height for three-block towers\n    max_height_three_block = m * 3\n    \n    # The tallest tower will be the maximum of the two heights\n    return max(max_height_two_block, max_height_three_block)\n\n# Read input\nn, m = map(int, input().split())\n\n# Get the result\nresult = minimum_tower_height(n, m)\n\n# Print the output\nprint(result)"}
{"solution": "def fair_game(n, cards):\n    from collections import Counter\n    \n    # Count the occurrences of each number on the cards\n    count = Counter(cards)\n    \n    # We need to find two distinct numbers with the same count\n    pairs = []\n    \n    for number, cnt in count.items():\n        if cnt * 2 == n:\n            pairs.append(number)\n    \n    if len(pairs) >= 2:\n        print(\"YES\")\n        print(pairs[0], pairs[1])\n    else:\n        print(\"NO\")\n\n# Read input\nn = int(input())\ncards = [int(input()) for _ in range(n)]\n\n# Call the function\nfair_game(n, cards)"}
{"solution": "def can_arrange_soldiers(n, k, groups):\n    # Sort the groups in descending order\n    groups.sort(reverse=True)\n    \n    # Calculate the maximum number of soldiers that can be placed in the airplane\n    max_seats = n * 8\n    \n    # Check if the largest group can fit without neighboring another group\n    for group in groups:\n        if group > (n * 4):  # Each row can accommodate at most 4 groups without neighbors\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_arrange_soldiers(n, k, groups)\nprint(result)"}
{"solution": "def min_cost_to_make_sticks_almost_good(n, lengths):\n    min_cost = float('inf')\n    best_t = -1\n\n    for t in range(1, 101):  # t can be any positive integer, we check from 1 to 100\n        cost = 0\n        for length in lengths:\n            if length < t - 1:\n                cost += (t - 1) - length  # cost to increase to t - 1\n            elif length > t + 1:\n                cost += length - (t + 1)  # cost to decrease to t + 1\n            # If t - 1 <= length <= t + 1, cost is 0\n\n        if cost < min_cost:\n            min_cost = cost\n            best_t = t\n\n    return best_t, min_cost\n\n# Input reading\nn = int(input())\nlengths = list(map(int, input().split()))\n\n# Get the result\nt, min_cost = min_cost_to_make_sticks_almost_good(n, lengths)\n\n# Output the result\nprint(t, min_cost)"}
{"solution": "def find_min_square_side(n, m, sky_map):\n    min_x, min_y = n, m\n    max_x, max_y = -1, -1\n\n    for i in range(n):\n        for j in range(m):\n            if sky_map[i][j] == '*':\n                min_x = min(min_x, i)\n                max_x = max(max_x, i)\n                min_y = min(min_y, j)\n                max_y = max(max_y, j)\n\n    length = max(max_x - min_x + 1, max_y - min_y + 1)\n    return length\n\n# Input reading\nn, m = map(int, input().split())\nsky_map = [input().strip() for _ in range(n)]\n\n# Calculate and print the result\nresult = find_min_square_side(n, m, sky_map)\nprint(result)"}
{"solution": "def mod_inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef probability_of_sorted_array(n, k, a):\n    MOD = 10**9 + 7\n    \n    count_0 = a.count(0)\n    count_1 = n - count_0\n    \n    if count_0 == 0 or count_1 == 0:\n        return 1  # Already sorted\n    \n    if count_0 > count_1:\n        return 0  # Impossible to sort\n    \n    total_pairs = n * (n - 1) // 2\n    total_operations = k\n    \n    # If k is less than the number of swaps needed to sort, return 0\n    if total_operations < count_0 * count_1:\n        return 0\n    \n    # Calculate P and Q\n    P = 1\n    Q = pow(total_pairs, total_operations, MOD)\n    \n    # Calculate the number of ways to choose pairs that will sort the array\n    for i in range(count_0):\n        P = P * (count_1 + i) % MOD\n    \n    for i in range(count_1):\n        P = P * (count_0 + i) % MOD\n    \n    # Calculate the result\n    result = P * mod_inverse(Q, MOD) % MOD\n    return result\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nresult = probability_of_sorted_array(n, k, a)\n\n# Print the result\nprint(result)"}
{"solution": "def min_operations_to_devolve_triangle(x, y):\n    # The number of operations needed to reduce the triangle from side length x to y\n    # We can only reduce the sides while maintaining the triangle inequality\n    operations = 0\n    \n    # We need to reduce the sides from x to y\n    while x > y:\n        # Reduce one side at a time\n        if x - 1 >= y:\n            x -= 1\n            operations += 1\n        else:\n            break\n    \n    # After reducing one side, we need to ensure the triangle remains valid\n    # We can reduce the other two sides to match the smallest side\n    # The smallest side is now y, and we need to reduce the other two sides to y\n    # We can do this in two operations for each side\n    operations += (x - y) * 2\n    \n    return operations\n\n# Read input\nx, y = map(int, input().split())\n\n# Calculate and print the result\nprint(min_operations_to_devolve_triangle(x, y))"}
{"solution": "def minimum_norm(a, b, c, d):\n    # Calculate the determinant of matrix A\n    det_A = a * d - b * c\n    \n    # If the determinant is already zero, the matrix is degenerate\n    if det_A == 0:\n        return 0.0\n    \n    # Calculate the minimum possible value of ||A - B||\n    # The formula derived from the problem statement\n    min_norm = abs(det_A) / (max(abs(a), abs(b), abs(c), abs(d)) + 1e-9)\n    \n    return min_norm\n\n# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate and print the result\nresult = minimum_norm(a, b, c, d)\nprint(f\"{result:.10f}\")"}
{"solution": "def restaurant_service(n, a, b, groups):\n    denied_service = 0\n\n    for group in groups:\n        if group == 1:  # Group of one person\n            if a > 0:  # Check for one-seater table\n                a -= 1\n            elif b > 0:  # Check for two-seater table\n                b -= 1\n            elif b > 0:  # Check for two-seater table with one person already seated\n                b -= 1\n            else:  # Deny service\n                denied_service += 1\n        elif group == 2:  # Group of two people\n            if b > 0:  # Check for two-seater table\n                b -= 1\n            else:  # Deny service\n                denied_service += 2\n\n    return denied_service\n\n# Input reading\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Output the result\nprint(restaurant_service(n, a, b, groups))"}
{"solution": "def calculate_students(A, B, C, N):\n    # Calculate the number of students who passed the exam\n    passed_students = A + B - C\n    \n    # Calculate the number of students who didn't pass the exam\n    failed_students = N - passed_students\n    \n    # Check for contradictions\n    if failed_students < 1 or passed_students > N or C > A or C > B:\n        return -1\n    \n    return failed_students\n\n# Read input values\nA, B, C, N = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_students(A, B, C, N)\nprint(result)"}
{"solution": "def expected_dresses(x, k):\n    MOD = 10**9 + 7\n    \n    if k == 0:\n        return (x * 2) % MOD\n    \n    # Calculate the expected number of dresses after k months\n    # The formula derived is: E = (x * 2^(k+1) - (2^k - 1)) / 2\n    # We need to compute this under modulo\n    \n    # Calculate 2^(k+1) % MOD\n    pow_2_k_plus_1 = pow(2, k + 1, MOD)\n    pow_2_k = pow(2, k, MOD)\n    \n    # E = (x * 2^(k+1) - (2^k - 1)) / 2\n    # We need to compute the numerator first\n    numerator = (x * pow_2_k_plus_1 % MOD - (pow_2_k - 1) + MOD) % MOD\n    \n    # Since we are dividing by 2, we need to multiply by the modular inverse of 2\n    # Modular inverse of 2 under MOD is (MOD + 1) // 2\n    inverse_2 = (MOD + 1) // 2\n    \n    # Final result\n    result = (numerator * inverse_2) % MOD\n    \n    return result\n\n# Read input\nx, k = map(int, input().split())\n# Print the expected number of dresses\nprint(expected_dresses(x, k))"}
{"solution": "def mod_inverse(a, p):\n    return pow(a, p - 2, p)\n\ndef calculate_probability(n, ranges):\n    MOD = 998244353\n    total_ways = 1\n    valid_ways = 0\n\n    # Calculate total ways\n    for l, r in ranges:\n        total_ways *= (r - l + 1)\n        total_ways %= MOD\n\n    # Count valid ways (no inversions)\n    def count_valid(index, current):\n        nonlocal valid_ways\n        if index == n:\n            valid_ways += 1\n            valid_ways %= MOD\n            return\n        \n        l, r = ranges[index]\n        for value in range(l, r + 1):\n            if current is None or value >= current:\n                count_valid(index + 1, value)\n\n    count_valid(0, None)\n\n    # Calculate the probability as an irreducible fraction\n    x = valid_ways\n    y = total_ways\n\n    # Reduce x/y\n    gcd = math.gcd(x, y)\n    x //= gcd\n    y //= gcd\n\n    # Calculate y inverse modulo MOD\n    y_inv = mod_inverse(y, MOD)\n\n    # Result is x * y_inv % MOD\n    result = (x * y_inv) % MOD\n    return result\n\nimport sys\nimport math\n\ninput = sys.stdin.read\ndata = input().splitlines()\nn = int(data[0])\nranges = [tuple(map(int, line.split())) for line in data[1:n + 1]]\n\nresult = calculate_probability(n, ranges)\nprint(result)"}
{"solution": "def count_ways_to_split_stick(n):\n    if n % 2 != 0:\n        return 0  # If n is odd, it's impossible to form pairs\n\n    half_n = n // 2\n    count = 0\n\n    # We need to find pairs (a, b) such that a + b = half_n\n    # and a != b to avoid forming a square\n    for a in range(1, half_n // 2 + 1):\n        b = half_n - a\n        if a != b:\n            count += 1\n\n    return count\n\n# Read input\nn = int(input())\n# Calculate and print the result\nprint(count_ways_to_split_stick(n))"}
{"solution": "def max_min_kvass(n, s, volumes):\n    total_kvass = sum(volumes)\n    \n    if total_kvass < s:\n        return -1\n    \n    # Binary search to find the maximum minimum volume in the least keg\n    left, right = 0, min(volumes)\n    \n    while left < right:\n        mid = (left + right + 1) // 2\n        # Calculate how much kvass we can pour while keeping at least `mid` in each keg\n        total_pourable = sum(max(0, v - mid) for v in volumes)\n        \n        if total_pourable >= s:\n            left = mid  # We can afford to keep at least `mid` in each keg\n        else:\n            right = mid - 1  # We need to lower the minimum\n    \n    return left\n\n# Read input\nn, s = map(int, input().split())\nvolumes = list(map(int, input().split()))\n\n# Get the result and print it\nresult = max_min_kvass(n, s, volumes)\nprint(result)"}
{"solution": "def caterpillar_to_apple(h1, h2, a, b):\n    # Initial height of the caterpillar\n    current_height = h1\n    \n    # Time calculations\n    day_hours = 12  # 10 am to 10 pm\n    night_hours = 14  # 10 pm to 10 am\n    \n    # Calculate the height gain during the first day (from 2 pm to 10 pm)\n    initial_day_gain = (day_hours - 4) * a  # 2 pm to 10 pm is 8 hours, but we start at 2 pm\n    current_height += initial_day_gain\n    \n    # Check if the caterpillar reaches the apple on the first day\n    if current_height >= h2:\n        return 0\n    \n    # If the caterpillar slips down more than it climbs during the night\n    if a <= b:\n        return -1\n    \n    # Calculate the net gain per full day (day gain - night slip)\n    net_gain_per_day = (a * day_hours) - (b * night_hours)\n    \n    # Days counter\n    days = 0\n    \n    # Loop until the caterpillar reaches the apple\n    while current_height < h2:\n        days += 1\n        current_height += net_gain_per_day\n        \n        # Check if it reaches the apple during the day\n        if current_height >= h2:\n            return days\n    \n    return -1\n\n# Input reading\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Output the result\nprint(caterpillar_to_apple(h1, h2, a, b))"}
{"solution": "def max_joy_units(C, H_r, H_b, W_r, W_b):\n    # Calculate the maximum number of each type of candy that can be eaten\n    max_red_candies = C // W_r\n    max_blue_candies = C // W_b\n    \n    # Initialize the maximum joy units\n    max_joy = 0\n    \n    # Try all possible numbers of red candies from 0 to max_red_candies\n    for red_candies in range(max_red_candies + 1):\n        # Calculate the remaining weight capacity after eating red candies\n        remaining_capacity = C - (red_candies * W_r)\n        \n        # Calculate the maximum number of blue candies that can be eaten with the remaining capacity\n        blue_candies = remaining_capacity // W_b\n        \n        # Calculate the total joy units for this combination\n        total_joy = (red_candies * H_r) + (blue_candies * H_b)\n        \n        # Update the maximum joy units if this combination is better\n        max_joy = max(max_joy, total_joy)\n    \n    return max_joy\n\n# Read input\nC, H_r, H_b, W_r, W_b = map(int, input().split())\n\n# Calculate and print the maximum joy units\nprint(max_joy_units(C, H_r, H_b, W_r, W_b))"}
{"solution": "# Read the starting coordinates\nx1, y1 = map(int, input().split())\n# Read the finishing coordinates\nx2, y2 = map(int, input().split())\n\n# Calculate the minimal number of steps\nd = max(abs(x2 - x1), abs(y2 - y1))\n\n# Print the result\nprint(d)"}
{"solution": "def predict_vote_outcome(n, employees):\n    # Count the number of employees in each fraction\n    count_D = employees.count('D')\n    count_R = employees.count('R')\n    \n    # The outcome will be determined by the fraction with the majority\n    if count_D > count_R:\n        return 'D'\n    else:\n        return 'R'\n\n# Read input\nn = int(input().strip())\nemployees = input().strip()\n\n# Get the result and print it\nresult = predict_vote_outcome(n, employees)\nprint(result)"}
{"solution": "def count_tv_sets(a, b, x, y):\n    # Calculate the greatest common divisor of x and y\n    from math import gcd\n    g = gcd(x, y)\n    \n    # Reduce x and y by their gcd\n    x //= g\n    y //= g\n    \n    # Initialize the count of valid (w, h) pairs\n    count = 0\n    \n    # Find the maximum k such that (k * x <= a) and (k * y <= b)\n    max_k_width = a // x\n    max_k_height = b // y\n    \n    # The maximum k is the minimum of the two\n    max_k = min(max_k_width, max_k_height)\n    \n    # The number of valid pairs is the maximum k\n    count = max_k\n    \n    return count\n\n# Read input\na, b, x, y = map(int, input().split())\n\n# Get the result\nresult = count_tv_sets(a, b, x, y)\n\n# Print the result\nprint(result)"}
{"solution": "def prime_factors(base):\n    factors = {}\n    d = 2\n    while d * d <= base:\n        while (base % d) == 0:\n            if d in factors:\n                factors[d] += 1\n            else:\n                factors[d] = 1\n            base //= d\n        d += 1\n    if base > 1:\n        factors[base] = 1\n    return factors\n\ndef count_factors_in_factorial(n, p):\n    count = 0\n    power = p\n    while power <= n:\n        count += n // power\n        power *= p\n    return count\n\ndef trailing_zeros_in_base(n, b):\n    factors = prime_factors(b)\n    min_trailing_zeros = float('inf')\n    \n    for prime, exponent in factors.items():\n        count = count_factors_in_factorial(n, prime)\n        min_trailing_zeros = min(min_trailing_zeros, count // exponent)\n    \n    return min_trailing_zeros\n\n# Read input\nn, b = map(int, input().split())\n# Calculate and print the result\nprint(trailing_zeros_in_base(n, b))"}
{"solution": "def sum_of_frog_reach(m, a, b):\n    # Calculate the gcd of a and b\n    from math import gcd\n    g = gcd(a, b)\n\n    # The maximum number of distinct integers the frog can reach\n    # is determined by the number of distinct positions modulo g\n    # and the maximum reachable position.\n    \n    # The number of distinct integers reachable in the range [0, x]\n    def f(x):\n        if x < 0:\n            return 0\n        # Count how many multiples of g are in the range [0, x]\n        return (x // g) + 1\n\n    # Calculate the sum of f(i) for i from 0 to m\n    total_sum = 0\n    for i in range(m + 1):\n        total_sum += f(i)\n\n    return total_sum\n\n# Read input\nm, a, b = map(int, input().split())\n# Calculate and print the result\nprint(sum_of_frog_reach(m, a, b))"}
{"solution": "def can_divide_into_odd_subsegments(n, sequence):\n    # Check if the first and last elements are odd\n    if sequence[0] % 2 == 1 and sequence[-1] % 2 == 1:\n        # Check if the length of the sequence is odd\n        if n % 2 == 1:\n            return \"Yes\"\n        else:\n            return \"No\"\n    else:\n        return \"No\"\n\n# Input reading\nn = int(input().strip())\nsequence = list(map(int, input().strip().split()))\n\n# Output the result\nprint(can_divide_into_odd_subsegments(n, sequence))"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    if x1 == x2:  # Same x-coordinate\n        side_length = abs(y2 - y1)\n        x3, y3 = x1 + side_length, y1\n        x4, y4 = x2 + side_length, y2\n    elif y1 == y2:  # Same y-coordinate\n        side_length = abs(x2 - x1)\n        x3, y3 = x1, y1 + side_length\n        x4, y4 = x2, y2 + side_length\n    elif abs(x2 - x1) == abs(y2 - y1):  # Diagonal points\n        x3, y3 = x1, y2\n        x4, y4 = x2, y1\n    else:\n        return -1  # Not a square\n\n    return x3, y3, x4, y4\n\n# Input reading\nx1, y1, x2, y2 = map(int, input().split())\n\n# Finding the remaining trees\nresult = find_remaining_trees(x1, y1, x2, y2)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def calculate_f_n(x, y, n):\n    MOD = 1000000007\n    \n    # Handle the cases based on the value of n\n    if n == 1:\n        return x % MOD\n    elif n == 2:\n        return y % MOD\n    else:\n        # The sequence follows a pattern based on n % 6\n        # f(n) = f(n % 6)\n        # f(1) = x\n        # f(2) = y\n        # f(3) = y - x\n        # f(4) = -x\n        # f(5) = -y\n        # f(0) = x - y\n        n_mod = n % 6\n        \n        if n_mod == 1:\n            return x % MOD\n        elif n_mod == 2:\n            return y % MOD\n        elif n_mod == 3:\n            return (y - x) % MOD\n        elif n_mod == 4:\n            return (-x) % MOD\n        elif n_mod == 5:\n            return (-y) % MOD\n        else:  # n_mod == 0\n            return (x - y) % MOD\n\n# Read input\nx, y = map(int, input().split())\nn = int(input())\n\n# Calculate and print the result\nresult = calculate_f_n(x, y, n)\nprint(result)"}
{"solution": "n = int(input())\nA = list(map(int, input().split()))\n\ntotal_sum = sum(A)\n\nif total_sum != 0:\n    print(\"YES\")\n    print(1)\n    print(1, n)\nelse:\n    # Check if we can split the array into non-zero sum parts\n    current_sum = 0\n    parts = []\n    start = 1\n\n    for i in range(n):\n        current_sum += A[i]\n        if current_sum != 0:\n            parts.append((start, i + 1))\n            start = i + 2  # next part starts from the next index\n            current_sum = 0  # reset current sum for the next part\n\n    if len(parts) == 0 or (len(parts) == 1 and parts[0][0] == 1 and parts[0][1] == n):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(len(parts))\n        for l, r in parts:\n            print(l, r)"}
{"solution": "def minimum_score(n, m, k):\n    MOD = 1000000009\n    \n    # If m is 0, the score is 0\n    if m == 0:\n        return 0\n    \n    # Calculate the number of wrong answers\n    wrong_answers = n - m\n    \n    # Calculate the number of full groups of k correct answers\n    full_groups = m // k\n    \n    # Calculate the remaining correct answers after full groups\n    remaining_correct = m % k\n    \n    # The minimum score can be calculated as follows:\n    # Each full group contributes 2^1 (1 point for the correct answer, then double)\n    # Each remaining correct answer contributes 1 point\n    score = (full_groups * 2 + remaining_correct) % MOD\n    \n    return score\n\n# Read input\nn, m, k = map(int, input().strip().split())\n\n# Calculate and print the minimum score\nprint(minimum_score(n, m, k))"}
{"solution": "def is_divisible_by_8(n):\n    # Check single digits\n    for digit in n:\n        if int(digit) % 8 == 0:\n            return True, digit\n    \n    # Check pairs of digits\n    for i in range(len(n)):\n        for j in range(i + 1, len(n)):\n            num = n[i] + n[j]\n            if int(num) % 8 == 0:\n                return True, num\n    \n    # Check triplets of digits\n    for i in range(len(n)):\n        for j in range(i + 1, len(n)):\n            for k in range(j + 1, len(n)):\n                num = n[i] + n[j] + n[k]\n                if int(num) % 8 == 0:\n                    return True, num\n    \n    return False, \"\"\n\nn = input().strip()\npossible, result = is_divisible_by_8(n)\n\nif possible:\n    print(\"YES\")\n    print(result)\nelse:\n    print(\"NO\")"}
{"solution": "def find_floor(n, m, memories):\n    possible_floors = set()\n\n    for flats_per_floor in range(1, 101):\n        valid = True\n        for k, f in memories:\n            if (k - 1) // flats_per_floor + 1 != f:\n                valid = False\n                break\n        if valid:\n            possible_floors.add((n - 1) // flats_per_floor + 1)\n\n    if len(possible_floors) == 1:\n        return possible_floors.pop()\n    else:\n        return -1\n\n# Read input\nn, m = map(int, input().split())\nmemories = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get the result\nresult = find_floor(n, m, memories)\n\n# Print the output\nprint(result)"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    board = [[board1[i], board2[i]] for i in range(n)]\n    \n    # Define the four possible shapes of the bishwock\n    bishwock_shapes = [\n        [(0, 0), (0, 1), (1, 0)],  # Original L shape\n        [(0, 0), (0, 1), (1, 1)],  # Rotated 90 degrees\n        [(0, 1), (1, 0), (1, 1)],  # Rotated 180 degrees\n        [(0, 0), (1, 0), (1, 1)]   # Rotated 270 degrees\n    ]\n    \n    def can_place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            if nx >= 2 or ny >= n or board[ny][nx] == 'X':\n                return False\n        return True\n    \n    def place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            board[ny][nx] = 'X'\n    \n    count = 0\n    for y in range(n):\n        for x in range(2):\n            for shape in bishwock_shapes:\n                if can_place_bishwock(x, y, shape):\n                    place_bishwock(x, y, shape)\n                    count += 1\n                    break\n    \n    return count\n\n# Read input\nboard1 = input().strip()\nboard2 = input().strip()\n\n# Output the result\nprint(max_bishwocks(board1, board2))"}
{"solution": "def max_pretty_set_length(n, s):\n    max_length = 0\n    current_set = set()\n    \n    for char in s:\n        if char.islower():\n            current_set.add(char)\n        else:\n            max_length = max(max_length, len(current_set))\n            current_set.clear()\n    \n    # Check the last segment\n    max_length = max(max_length, len(current_set))\n    \n    return max_length\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult = max_pretty_set_length(n, s)\n\n# Print the result\nprint(result)"}
{"solution": "def max_difference(n, a):\n    total_sum = sum(a)\n    max_b_minus_c = total_sum  # If we take all elements in b and c is empty\n    return max_b_minus_c\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = max_difference(n, a)\nprint(result)"}
{"solution": "def min_refuels(a, b, f, k):\n    # Distance for one complete journey (to a and back to 0)\n    journey_distance = 2 * a\n    # Distance to the gas station and back\n    distance_to_station = f + f\n    \n    # If the bus cannot reach the gas station on the first journey\n    if b < f:\n        return -1\n    \n    # If the bus can complete all journeys without refueling\n    if b >= journey_distance * k:\n        return 0\n    \n    # Calculate the number of refuels needed\n    refuels = 0\n    remaining_journeys = k\n    \n    while remaining_journeys > 0:\n        # If the bus can reach the gas station and back\n        if b >= distance_to_station:\n            # Refuel at the gas station\n            refuels += 1\n            # After refueling, the bus can complete the journey\n            remaining_journeys -= 1\n            # Check if it can complete the next journey\n            if remaining_journeys > 0:\n                # Check if it can reach the gas station again\n                if b < distance_to_station:\n                    return -1\n        else:\n            return -1\n        \n        # After each journey, the bus will have used fuel\n        # Calculate the remaining fuel after completing the journey\n        b -= journey_distance\n    \n    return refuels\n\n# Input reading\na, b, f, k = map(int, input().split())\n# Output the result\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    for i in range(n // p + 1):\n        remaining_length = n - i * p\n        if remaining_length % q == 0:\n            j = remaining_length // q\n            result = []\n            result.extend([s[k * p:(k + 1) * p] for k in range(i)])\n            result.extend([s[i * p + k * q:i * p + (k + 1) * q] for k in range(j)])\n            print(len(result))\n            for part in result:\n                print(part)\n            return\n    print(-1)\n\n# Read input\nn, p, q = map(int, input().split())\ns = input().strip()\n\n# Call the function\nsplit_string(n, p, q, s)"}
{"solution": "def can_reach_finish(n, m, s, d, obstacles):\n    obstacles.sort()\n    current_position = 0\n    commands = []\n    \n    for obstacle in obstacles:\n        # Calculate the distance to the next obstacle\n        distance_to_obstacle = obstacle - current_position\n        \n        # Check if we can run to the obstacle\n        if distance_to_obstacle >= s:\n            # We can run directly to the obstacle\n            commands.append(f\"RUN {distance_to_obstacle - d}\")\n            current_position += distance_to_obstacle - d\n            \n            # Now we need to jump over the obstacle\n            commands.append(f\"JUMP {d}\")\n            current_position += d\n        else:\n            # We cannot run directly to the obstacle, we need to run and jump\n            if current_position + s + d < obstacle:\n                print(\"IMPOSSIBLE\")\n                return\n            \n            # Run to the point where we can jump over the obstacle\n            run_distance = s\n            commands.append(f\"RUN {run_distance}\")\n            current_position += run_distance\n            \n            # Jump over the obstacle\n            jump_distance = obstacle - current_position\n            if jump_distance > d:\n                print(\"IMPOSSIBLE\")\n                return\n            \n            commands.append(f\"JUMP {jump_distance}\")\n            current_position += jump_distance\n            \n    # After the last obstacle, we need to reach the finish line\n    distance_to_finish = m - current_position\n    if distance_to_finish > 0:\n        if distance_to_finish < s:\n            print(\"IMPOSSIBLE\")\n            return\n        commands.append(f\"RUN {distance_to_finish}\")\n    \n    # Print the commands\n    for command in commands:\n        print(command)\n\n# Read input\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\n# Call the function\ncan_reach_finish(n, m, s, d, obstacles)"}
{"solution": "def count_ordered_pairs(s, x):\n    # Check if s - x is even\n    if (s - x) % 2 != 0:\n        return 0\n    \n    # Calculate b\n    b = (s - x) // 2\n    a = s - b\n    \n    # Check if both a and b are positive\n    if a <= 0 or b <= 0:\n        return 0\n    \n    # Check if a and b have the same bits where x has 1s\n    if (a & x) != (b & x):\n        return 0\n    \n    # Count the number of valid pairs\n    return 2  # Each valid pair (a, b) can be ordered as (a, b) and (b, a)\n\n# Read input\ns, x = map(int, input().split())\n\n# Get the number of ordered pairs\nresult = count_ordered_pairs(s, x)\n\n# Print the result\nprint(result)"}
{"solution": "def turn_skewers(n, k):\n    actions = []\n    # Start turning skewers from the first one, and then skip the range of turned skewers\n    for i in range(1, n + 1, k + 1):\n        actions.append(i)\n    \n    print(len(actions))\n    print(' '.join(map(str, actions)))\n\n# Read input\nn, k = map(int, input().split())\nturn_skewers(n, k)"}
{"solution": "def min_operations_to_square(n):\n    import math\n    \n    n_str = str(n)\n    n_len = len(n_str)\n    \n    # Generate all possible squares up to the maximum possible value\n    max_square_root = int(math.sqrt(2 * 10**9)) + 1\n    squares = [str(i * i) for i in range(1, max_square_root + 1)]\n    \n    def is_subsequence(small, large):\n        it = iter(large)\n        return all(char in it for char in small)\n    \n    min_deletions = float('inf')\n    \n    for square in squares:\n        if is_subsequence(square, n_str):\n            deletions = n_len - len(square)\n            min_deletions = min(min_deletions, deletions)\n    \n    return min_deletions if min_deletions != float('inf') else -1\n\n# Read input\nn = int(input().strip())\n# Print output\nprint(min_operations_to_square(n))"}
{"solution": "def count_permutations_with_max_f(n):\n    MOD = 1000000007\n\n    # Precompute factorials and their modular inverses\n    factorial = [1] * (n + 1)\n    for i in range(2, n + 1):\n        factorial[i] = factorial[i - 1] * i % MOD\n\n    # The maximum value of f(p) is the number of distinct prime factors of n\n    def count_distinct_prime_factors(x):\n        count = 0\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                count += 1\n                while x % i == 0:\n                    x //= i\n        if x > 1:\n            count += 1\n        return count\n\n    # Calculate f_max(n)\n    f_max = count_distinct_prime_factors(n)\n\n    # The number of permutations with f(p) = f_max is factorial[n] divided by the product of factorials of the counts of each prime factor\n    result = factorial[n]\n    for i in range(2, n + 1):\n        if n % i == 0:\n            count = 0\n            while n % i == 0:\n                n //= i\n                count += 1\n            result = result * pow(factorial[count], MOD - 2, MOD) % MOD\n\n    return result\n\n# Read input\nn = int(input().strip())\n# Output the result\nprint(count_permutations_with_max_f(n))"}
{"solution": "def minimum_jump_ability(s):\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    positions = [-1]  # Start position before the first character\n    \n    # Collect positions of all vowels\n    for i, char in enumerate(s):\n        if char in vowels:\n            positions.append(i)\n    \n    positions.append(len(s))  # End position after the last character\n    \n    # Calculate maximum distance between consecutive positions\n    max_distance = 0\n    for i in range(1, len(positions)):\n        max_distance = max(max_distance, positions[i] - positions[i - 1])\n    \n    return max_distance\n\n# Read input\ninput_string = input().strip()\n# Print output\nprint(minimum_jump_ability(input_string))"}
{"solution": "def can_distribute_equally(a1, a2, a3, a4):\n    total = a1 + a2 + a3 + a4\n    # If the total number of candies is odd, we cannot split them equally\n    if total % 2 != 0:\n        return \"NO\"\n    \n    target = total // 2\n    # Check all combinations of bags to see if we can reach the target\n    bags = [a1, a2, a3, a4]\n    \n    # Check all combinations of 1, 2, or 3 bags\n    for i in range(1, 1 << 4):  # from 1 to 15 (1 << 4 is 16)\n        current_sum = 0\n        for j in range(4):\n            if i & (1 << j):  # if the j-th bag is included\n                current_sum += bags[j]\n        if current_sum == target:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\na1, a2, a3, a4 = map(int, input().split())\n# Output the result\nprint(can_distribute_equally(a1, a2, a3, a4))"}
{"solution": "def optimal_pie_distribution(n, slices):\n    # Initialize the sums for Alice and Bob\n    alice_sum = 0\n    bob_sum = 0\n    \n    # The decider starts with Bob\n    is_bob_turn = True\n    \n    # Iterate through the slices\n    for size in slices:\n        if is_bob_turn:\n            # Bob's turn to decide\n            # Bob will take the larger slice for himself\n            if alice_sum + size > bob_sum + size:\n                # If Alice would get more by taking this slice, Bob gives it to her\n                alice_sum += size\n            else:\n                # Bob takes the slice\n                bob_sum += size\n        else:\n            # Alice's turn to decide\n            # Alice will take the larger slice for herself\n            if bob_sum + size > alice_sum + size:\n                # If Bob would get more by taking this slice, Alice gives it to him\n                bob_sum += size\n            else:\n                # Alice takes the slice\n                alice_sum += size\n        \n        # Switch the decider token\n        is_bob_turn = not is_bob_turn\n    \n    return alice_sum, bob_sum\n\n# Read input\nn = int(input())\nslices = list(map(int, input().split()))\n\n# Get the result\nalice, bob = optimal_pie_distribution(n, slices)\n\n# Print the output\nprint(alice, bob)"}
{"solution": "def min_variables(n, a):\n    # Sort the array to process in increasing order\n    a.sort()\n    \n    # Initialize the number of variables needed\n    m = 0\n    # A set to keep track of the sums we can create\n    possible_sums = set()\n    \n    for value in a:\n        # If the current value is not in the possible sums, we need a new variable\n        if value not in possible_sums:\n            m += 1\n            # Add the new variable's value to the possible sums\n            possible_sums.add(value)\n        \n        # Generate new possible sums using the current value\n        new_sums = set()\n        for s in possible_sums:\n            new_sum = s + value\n            if new_sum <= 10**9:  # Only consider sums within the limit\n                new_sums.add(new_sum)\n        \n        # Update the possible sums with the new sums\n        possible_sums.update(new_sums)\n    \n    return m if m <= n else -1\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Get the result and print it\nresult = min_variables(n, a)\nprint(result)"}
{"solution": "def determine_winner(n, piles):\n    # Count the number of piles with an odd number of stones\n    odd_count = sum(1 for pile in piles if pile % 2 != 0)\n    \n    # If the count of odd piles is even, Alice wins; otherwise, Bob wins\n    return \"Alice\" if odd_count % 2 == 0 else \"Bob\"\n\n# Read input\nn = int(input())\npiles = list(map(int, input().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, piles))"}
{"solution": "def can_make_equal(n, arr):\n    unique_values = set(arr)\n    \n    if len(unique_values) > 3:\n        return \"NO\"\n    elif len(unique_values) == 3:\n        min_val = min(unique_values)\n        max_val = max(unique_values)\n        mid_val = sum(unique_values) - min_val - max_val\n        \n        if mid_val * 2 == min_val + max_val:\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        return \"YES\"\n\n# Input reading\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output the result\nprint(can_make_equal(n, arr))"}
{"solution": "def longest_repeated_substring(S):\n    N = len(S)\n    max_len = 0\n\n    # Create a suffix array\n    suffixes = sorted((S[i:], i) for i in range(N))\n    suffix_array = [suffix[1] for suffix in suffixes]\n\n    # Create a longest common prefix (LCP) array\n    rank = [0] * N\n    for i, suffix_index in enumerate(suffix_array):\n        rank[suffix_index] = i\n\n    lcp = [0] * (N - 1)\n    for i in range(N - 1):\n        if rank[i] < N - 1:\n            j = suffix_array[rank[i] + 1]\n            k = 0\n            while (i + k < N) and (j + k < N) and (S[i + k] == S[j + k]):\n                k += 1\n            lcp[rank[i]] = k\n\n    # Find the maximum length of non-overlapping substrings\n    for i in range(N - 1):\n        if lcp[i] > max_len:\n            # Check for non-overlapping condition\n            if suffix_array[i] + lcp[i] <= suffix_array[i + 1]:\n                max_len = lcp[i]\n\n    return max_len\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nN = int(data[0])\nS = data[1]\n\n# Get the result and print it\nresult = longest_repeated_substring(S)\nprint(result)"}
{"solution": "def minimum_time_to_house(n, a):\n    if a % 2 == 1:\n        # a is odd\n        return (a // 2) + 1\n    else:\n        # a is even\n        return (n - a) // 2 + 1\n\n# Read input\nn, a = map(int, input().split())\n\n# Calculate and print the result\nprint(minimum_time_to_house(n, a))"}
{"solution": "def can_select_jedi(n, m, colors, desired_counts):\n    # Create a count array for the desired counts\n    desired = [0] * (m + 1)\n    for i in range(1, m + 1):\n        desired[i] = desired_counts[i - 1]\n\n    # Sliding window approach\n    left = 0\n    current_count = [0] * (m + 1)\n\n    for right in range(n):\n        current_count[colors[right]] += 1\n\n        # Check if we have met the desired counts\n        while all(current_count[i] >= desired[i] for i in range(1, m + 1)):\n            # If we have a valid window, return YES\n            if all(current_count[i] == desired[i] for i in range(1, m + 1)):\n                return \"YES\"\n            # Move the left pointer to try and reduce the window size\n            current_count[colors[left]] -= 1\n            left += 1\n\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\ndesired_counts = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_select_jedi(n, m, colors, desired_counts)\nprint(result)"}
{"solution": "def determine_winner(n, rounds):\n    mishka_wins = 0\n    chris_wins = 0\n    \n    for round in rounds:\n        m, c = round\n        if m > c:\n            mishka_wins += 1\n        elif c > m:\n            chris_wins += 1\n    \n    if mishka_wins > chris_wins:\n        return \"Mishka\"\n    elif chris_wins > mishka_wins:\n        return \"Chris\"\n    else:\n        return \"Friendship is magic!^^\"\n\n# Read input\nn = int(input())\nrounds = [tuple(map(int, input().split())) for _ in range(n)]\nprint(determine_winner(n, rounds))"}
{"solution": "def is_valid_minesweeper_field(n, m, field):\n    # Directions for the 8 neighboring cells\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),          (0, 1),\n                  (1, -1), (1, 0), (1, 1)]\n    \n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                continue\n            \n            # Count bombs around the current cell\n            bomb_count = 0\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':\n                    bomb_count += 1\n            \n            # Check the validity of the current cell\n            if field[i][j] == '.':\n                if bomb_count != 0:\n                    return \"NO\"\n            elif field[i][j].isdigit():\n                if bomb_count != int(field[i][j]):\n                    return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Validate the Minesweeper field\nresult = is_valid_minesweeper_field(n, m, field)\nprint(result)"}
{"solution": "def can_vasya_eat_half(n, k):\n    total_candies = n\n    vasya_eaten = 0\n    \n    while total_candies > 0:\n        # Vasya eats k candies\n        vasya_eaten += min(k, total_candies)\n        total_candies -= min(k, total_candies)\n        \n        # Petya eats 10% of the remaining candies\n        petya_eaten = total_candies // 10\n        total_candies -= petya_eaten\n    \n    return vasya_eaten >= (n + 1) // 2\n\ndef find_min_k(n):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Read input\nn = int(input().strip())\n\n# Find and print the minimal k\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace(s):\n    p = s.count('o')\n    l = s.count('-')\n    \n    if p == 0 or p == 1:\n        return \"YES\"\n    if l % p == 0:\n        return \"YES\"\n    return \"NO\"\n\n# Read input\ns = input().strip()\n# Print the result\nprint(can_rearrange_necklace(s))"}
{"solution": "def max_pillows(n, m, k):\n    # Binary search to find the maximum number of pillows Frodo can have\n    left, right = 1, m\n    \n    while left < right:\n        mid = (left + right + 1) // 2\n        \n        # Calculate the total pillows needed if Frodo has 'mid' pillows\n        total_needed = mid\n        \n        # Calculate pillows for hobbits to the left of Frodo\n        for i in range(1, k):\n            if mid - i >= 1:\n                total_needed += mid - i\n            else:\n                total_needed += 1\n        \n        # Calculate pillows for hobbits to the right of Frodo\n        for i in range(1, n - k + 1):\n            if mid - i >= 1:\n                total_needed += mid - i\n            else:\n                total_needed += 1\n        \n        # Check if the total needed pillows exceed available pillows\n        if total_needed <= m:\n            left = mid  # Frodo can have at least 'mid' pillows\n        else:\n            right = mid - 1  # Frodo cannot have 'mid' pillows\n    \n    return left\n\n# Read input\nn, m, k = map(int, input().split())\n# Print the result\nprint(max_pillows(n, m, k))"}
{"solution": "import sys\nimport math\n\ndef max_subarray_cost(n, m, k, a):\n    max_cost = 0\n    current_sum = 0\n    prefix_sum = 0\n    \n    for r in range(n):\n        current_sum += a[r]\n        # Calculate the number of elements in the current subarray\n        length = r + 1\n        # Calculate the cost of the current subarray\n        cost = current_sum - k * math.ceil(length / m)\n        # Update the maximum cost found\n        max_cost = max(max_cost, cost)\n        # If the current sum is negative, reset it\n        if current_sum < 0:\n            current_sum = 0\n    \n    return max(max_cost, 0)\n\n# Read input\nn, m, k = map(int, sys.stdin.readline().strip().split())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Get the result and print it\nresult = max_subarray_cost(n, m, k, a)\nprint(result)"}
{"solution": "def longest_polyline(n, m):\n    # The longest polyline can be formed by selecting points at the corners of the rectangle\n    # and then one point in between to maximize the length.\n    \n    # Choosing the four corners of the rectangle\n    p1 = (0, 0)\n    p2 = (n, 0)\n    p3 = (n, m)\n    p4 = (0, m)\n    \n    # Output the points in the order that forms the longest polyline\n    print(p1[0], p1[1])\n    print(p2[0], p2[1])\n    print(p3[0], p3[1])\n    print(p4[0], p4[1])\n\n# Read input\nn, m = map(int, input().split())\nlongest_polyline(n, m)"}
{"solution": "def find_smallest_n(shuffled_string, remembered_substring):\n    from collections import Counter\n\n    # Count the frequency of each digit in the shuffled string\n    count_shuffled = Counter(shuffled_string)\n    \n    # Count the frequency of each digit in the remembered substring\n    count_remembered = Counter(remembered_substring)\n    \n    # Remove the digits of the remembered substring from the shuffled string count\n    for digit in remembered_substring:\n        count_shuffled[digit] -= 1\n        if count_shuffled[digit] == 0:\n            del count_shuffled[digit]\n    \n    # Create the remaining digits list\n    remaining_digits = []\n    for digit, count in count_shuffled.items():\n        remaining_digits.extend([digit] * count)\n    \n    # Sort remaining digits to form the smallest possible number\n    remaining_digits.sort()\n    \n    # We need to insert the remembered substring into the remaining digits\n    # We will try to find the best position to insert it\n    smallest_n = None\n    \n    # Try inserting the remembered substring at every possible position\n    for i in range(len(remaining_digits) + 1):\n        # Create a new list of digits with the remembered substring inserted\n        candidate = remaining_digits[:i] + list(remembered_substring) + remaining_digits[i:]\n        \n        # Convert the list of digits back to a string\n        candidate_str = ''.join(candidate)\n        \n        # Check for leading zeros (except for the case of \"0\")\n        if candidate_str[0] != '0' or candidate_str == '0':\n            if smallest_n is None or candidate_str < smallest_n:\n                smallest_n = candidate_str\n    \n    return smallest_n\n\n# Read input\nshuffled_string = input().strip()\nremembered_substring = input().strip()\n\n# Find and print the smallest integer n\nresult = find_smallest_n(shuffled_string, remembered_substring)\nprint(result)"}
{"solution": "def can_upgrade_temperatures(n, m, min_temp, max_temp, recorded_temperatures):\n    # Check if the current recorded temperatures already satisfy the min and max conditions\n    current_min = min(recorded_temperatures)\n    current_max = max(recorded_temperatures)\n\n    # If the current min is greater than the required min or current max is less than the required max\n    if current_min > min_temp or current_max < max_temp:\n        return \"Incorrect\"\n\n    # Calculate how many temperatures we need to add\n    temperatures_to_add = n - m\n\n    # Check if we can add the required temperatures\n    if temperatures_to_add > 0:\n        # We need at least one temperature equal to min_temp and one equal to max_temp\n        if current_min < min_temp and temperatures_to_add < 1:\n            return \"Incorrect\"\n        if current_max > max_temp and temperatures_to_add < 1:\n            return \"Incorrect\"\n        if current_min == min_temp and current_max == max_temp:\n            return \"Correct\"\n        if current_min < min_temp and current_max < max_temp:\n            return \"Correct\"\n        if current_min > min_temp and current_max > max_temp:\n            return \"Correct\"\n        if current_min == min_temp and current_max < max_temp:\n            return \"Correct\"\n        if current_min < min_temp and current_max == max_temp:\n            return \"Correct\"\n    \n    return \"Correct\"\n\n# Read input\nn, m, min_temp, max_temp = map(int, input().split())\nrecorded_temperatures = list(map(int, input().split()))\n\n# Get the result\nresult = can_upgrade_temperatures(n, m, min_temp, max_temp, recorded_temperatures)\n\n# Print the result\nprint(result)"}
{"solution": "def trailing_zeroes(n):\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count\n\ndef find_numbers_with_trailing_zeroes(m):\n    low, high = 0, 5 * (m + 1)\n    result = []\n\n    while low <= high:\n        mid = (low + high) // 2\n        tz = trailing_zeroes(mid)\n\n        if tz < m:\n            low = mid + 1\n        elif tz > m:\n            high = mid - 1\n        else:\n            result.append(mid)\n            # Check for other numbers with the same trailing zeroes\n            left = mid - 1\n            while trailing_zeroes(left) == m:\n                result.append(left)\n                left -= 1\n            right = mid + 1\n            while trailing_zeroes(right) == m:\n                result.append(right)\n                right += 1\n            break\n\n    result = sorted(result)\n    return result\n\nm = int(input().strip())\nnumbers = find_numbers_with_trailing_zeroes(m)\n\nprint(len(numbers))\nif numbers:\n    print(\" \".join(map(str, numbers)))"}
{"solution": "import sys\nimport heapq\nfrom collections import defaultdict\n\ndef dijkstra_max_cost(n, graph, start):\n    max_cost = [float('inf')] * (n + 1)\n    max_cost[start] = 0\n    priority_queue = [(0, start)]  # (cost, vertex)\n\n    while priority_queue:\n        current_cost, u = heapq.heappop(priority_queue)\n\n        if current_cost > max_cost[u]:\n            continue\n\n        for v, weight in graph[u]:\n            new_cost = max(current_cost, weight)\n            if new_cost < max_cost[v]:\n                max_cost[v] = new_cost\n                heapq.heappush(priority_queue, (new_cost, v))\n\n    return max_cost\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    k = int(data[index + 2])\n    index += 3\n    \n    special_vertices = list(map(int, data[index:index + k]))\n    index += k\n    \n    graph = defaultdict(list)\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        index += 3\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    results = []\n    \n    for sv in special_vertices:\n        max_costs = dijkstra_max_cost(n, graph, sv)\n        max_distance = 0\n        for other_sv in special_vertices:\n            if sv != other_sv:\n                max_distance = max(max_distance, max_costs[other_sv])\n        results.append(max_distance)\n    \n    print(\" \".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def initial_position(n, x):\n    # The position of the ball after n moves can be reversed\n    # We will simulate the moves in reverse\n    for i in range(n, 0, -1):\n        if i % 2 == 1:  # Odd move: swap left (0) and middle (1)\n            if x == 0:\n                x = 1\n            elif x == 1:\n                x = 0\n        else:  # Even move: swap middle (1) and right (2)\n            if x == 1:\n                x = 2\n            elif x == 2:\n                x = 1\n    return x\n\n# Read input\nn = int(input())\nx = int(input())\n\n# Get the initial position of the ball\nresult = initial_position(n, x)\n\n# Print the result\nprint(result)"}
{"solution": "def rectangles_form_square(n, rectangles):\n    # Step 1: Identify the bounding box\n    min_x = min(rect[0] for rect in rectangles)\n    max_x = max(rect[2] for rect in rectangles)\n    min_y = min(rect[1] for rect in rectangles)\n    max_y = max(rect[3] for rect in rectangles)\n\n    # Step 2: Check if the bounding box is a square\n    width = max_x - min_x\n    height = max_y - min_y\n\n    if width != height:\n        return \"NO\"\n\n    # Step 3: Create a grid to mark covered points\n    covered = set()\n    for x1, y1, x2, y2 in rectangles:\n        for x in range(x1, x2):\n            for y in range(y1, y2):\n                covered.add((x, y))\n\n    # Step 4: Check if the area of the bounding box is fully covered\n    expected_area = width * height\n    actual_area = len(covered)\n\n    if actual_area == expected_area:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Input reading\nn = int(input())\nrectangles = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(rectangles_form_square(n, rectangles))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef count_really_big_numbers(n, s):\n    count = 0\n    for x in range(s, n + 1):\n        if x - sum_of_digits(x) >= s:\n            count += 1\n    return count\n\n# Read input\nn, s = map(int, input().split())\n\n# Calculate and print the result\nresult = count_really_big_numbers(n, s)\nprint(result)"}
{"solution": "def can_cover_with_two_lines(points):\n    def check_line(p1, p2, points):\n        # Check how many points are on the line formed by p1 and p2\n        def on_line(p):\n            return (p[1] - p1[1]) * (p2[0] - p1[0]) == (p[0] - p1[0]) * (p2[1] - p1[1])\n        \n        return [p for p in points if on_line(p)]\n\n    if len(points) <= 2:\n        return True\n\n    # Try to use the first two points to form the first line\n    for i in range(2):\n        line_points = check_line(points[0], points[1], points)\n        remaining_points = [p for p in points if p not in line_points]\n\n        if len(remaining_points) <= 2:\n            return True\n\n        # Try to form a second line with the remaining points\n        for j in range(1, len(remaining_points)):\n            line_points2 = check_line(remaining_points[0], remaining_points[j], remaining_points)\n            if len(line_points2) == len(remaining_points):\n                return True\n\n    return False\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\nif can_cover_with_two_lines(points):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_winning_games(a, b, k, t):\n    MOD = 10**9 + 7\n    \n    # The maximum possible score difference after t turns\n    max_diff = t * k\n    \n    # dp[turn][score_diff] = number of ways to achieve score_diff after 'turn' turns\n    dp = [[0] * (2 * max_diff + 1) for _ in range(t + 1)]\n    \n    # Initial condition: at turn 0, the score difference is a - b\n    dp[0][a - b + max_diff] = 1\n    \n    for turn in range(1, t + 1):\n        for score_diff in range(-max_diff, max_diff + 1):\n            for mem_score in range(-k, k + 1):\n                for lexa_score in range(-k, k + 1):\n                    new_diff = score_diff + mem_score - lexa_score\n                    if -max_diff <= new_diff <= max_diff:\n                        dp[turn][new_diff + max_diff] = (dp[turn][new_diff + max_diff] + dp[turn - 1][score_diff + max_diff]) % MOD\n    \n    # Count the number of ways Memory ends with a strictly higher score than Lexa\n    result = 0\n    for score_diff in range(1, max_diff + 1):\n        result = (result + dp[t][score_diff + max_diff]) % MOD\n    \n    return result\n\n# Read input\na, b, k, t = map(int, input().split())\n# Calculate and print the result\nprint(count_winning_games(a, b, k, t))"}
{"solution": "def min_additional_marks(n, l, x, y, marks):\n    # Convert marks to a set for quick lookup\n    mark_set = set(marks)\n    \n    # Check if we can measure x and y\n    can_measure_x = any((mark + x) in mark_set for mark in marks)\n    can_measure_y = any((mark + y) in mark_set for mark in marks)\n    \n    # We need to add marks if we cannot measure x or y\n    additional_marks = []\n    \n    if not can_measure_x:\n        # If we cannot measure x, we need to add a mark that allows us to measure it\n        # We can add either x or (y - x) if it is not already present\n        if x not in mark_set:\n            additional_marks.append(x)\n            mark_set.add(x)\n    \n    if not can_measure_y:\n        # If we cannot measure y, we need to add a mark that allows us to measure it\n        # We can add either y or (y - x) if it is not already present\n        if y not in mark_set:\n            additional_marks.append(y)\n            mark_set.add(y)\n    \n    # Check if we can measure y using x\n    if can_measure_x and not can_measure_y:\n        # We can measure y if we can measure x and we can add (y - x)\n        if (y - x) not in mark_set and (y - x) >= 0:\n            additional_marks.append(y - x)\n    \n    # Check if we can measure x using y\n    if can_measure_y and not can_measure_x:\n        # We can measure x if we can measure y and we can add (y - x)\n        if (y - x) not in mark_set and (y - x) >= 0:\n            additional_marks.append(y - x)\n    \n    # Remove duplicates and sort the additional marks\n    additional_marks = list(set(additional_marks))\n    \n    return len(additional_marks), additional_marks\n\n# Read input\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Get the result\nv, additional_marks = min_additional_marks(n, l, x, y, marks)\n\n# Print output\nprint(v)\nif v > 0:\n    print(\" \".join(map(str, additional_marks)))"}
{"solution": "import sys\nimport math\n\ndef max_cake_volume(n, cakes):\n    # Calculate the volume of each cake and store it with its index\n    volumes = [(math.pi * r * r * h, i) for i, (r, h) in enumerate(cakes)]\n    \n    # Sort cakes by volume\n    volumes.sort()\n    \n    # Dynamic programming array to store the maximum volume ending with each cake\n    dp = [0] * n\n    \n    for i in range(n):\n        dp[i] = volumes[i][0]  # Start with the volume of the cake itself\n        for j in range(i):\n            if volumes[j][0] < volumes[i][0]:  # Cake j can be placed under cake i\n                dp[i] = max(dp[i], dp[j] + volumes[i][0])\n    \n    # The result is the maximum volume we can achieve\n    return max(dp)\n\n# Read input\nn = int(sys.stdin.readline().strip())\ncakes = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n# Calculate and print the maximum volume\nresult = max_cake_volume(n, cakes)\nprint(f\"{result:.9f}\")"}
{"solution": "def min_good_slices(n, k, heights):\n    heights.sort()\n    unique_heights = sorted(set(heights))\n    \n    total_slices = 0\n    current_height = unique_heights[0]\n    \n    for i in range(1, len(unique_heights)):\n        next_height = unique_heights[i]\n        cost = sum(max(0, h - next_height) for h in heights)\n        \n        if cost <= k:\n            total_slices += 1\n            current_height = next_height\n        else:\n            break\n    \n    return total_slices\n\n# Read input\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = min_good_slices(n, k, heights)\nprint(result)"}
{"solution": "def max_score(n, a):\n    # Calculate prefix sums\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n    \n    max_score = float('-inf')\n    \n    # Iterate over all possible segments [l, r]\n    for l in range(n):\n        max_in_segment = float('-inf')\n        for r in range(l, n):\n            # Update the maximum value in the current segment\n            max_in_segment = max(max_in_segment, a[r])\n            # Calculate the sum of the current segment\n            segment_sum = prefix_sum[r + 1] - prefix_sum[l]\n            # Calculate the score after Bob removes the max value\n            score = segment_sum - max_in_segment\n            # Update the maximum score\n            max_score = max(max_score, score)\n    \n    return max(max_score, 0)  # Ensure the score is not negative\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_score(n, a))"}
{"solution": "def can_light_garlands(k1, k2, k3):\n    # Sort the intervals to make it easier to analyze\n    k = sorted([k1, k2, k3])\n    \n    # Check if the sum of the two smallest intervals is greater than or equal to the largest interval\n    if k[0] + k[1] >= k[2]:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nk1, k2, k3 = map(int, input().split())\n\n# Get the result and print it\nresult = can_light_garlands(k1, k2, k3)\nprint(result)"}
{"solution": "def min_operations_to_delete_string(n, s):\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(n)]\n    \n    # Base case: single character substrings\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the DP table for substrings of length greater than 1\n    for length in range(2, n + 1):  # length of the substring\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j-1]\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n    \n    # The result for the entire string\n    return dp[0][n-1]\n\n# Read input\nn = int(input())\ns = input().strip()\n# Output the result\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "def max_pairs(n, boys, m, girls):\n    boys.sort()\n    girls.sort()\n    \n    i, j = 0, 0\n    pairs = 0\n    \n    while i < n and j < m:\n        if abs(boys[i] - girls[j]) <= 1:\n            pairs += 1\n            i += 1\n            j += 1\n        elif boys[i] < girls[j]:\n            i += 1\n        else:\n            j += 1\n            \n    return pairs\n\n# Input reading\nn = int(input())\nboys = list(map(int, input().split()))\nm = int(input())\ngirls = list(map(int, input().split()))\n\n# Output the result\nprint(max_pairs(n, boys, m, girls))"}
{"solution": "def can_team_win(players):\n    # Extracting players' skills\n    a1, b1 = players[0]  # Team 1 Player 1\n    a2, b2 = players[1]  # Team 1 Player 2\n    a3, b3 = players[2]  # Team 2 Player 1\n    a4, b4 = players[3]  # Team 2 Player 2\n\n    # Possible configurations for Team 1\n    team1_configurations = [\n        (a1, b1, a2, b2),  # Player 1 in attack, Player 2 in defense\n        (a2, b2, a1, b1)   # Player 2 in attack, Player 1 in defense\n    ]\n\n    # Possible configurations for Team 2\n    team2_configurations = [\n        (a3, b3, a4, b4),  # Player 1 in attack, Player 2 in defense\n        (a4, b4, a3, b3)   # Player 2 in attack, Player 1 in defense\n    ]\n\n    team1_wins = False\n    team2_wins = False\n\n    # Check all configurations\n    for (def1, att1) in team1_configurations:\n        for (def2, att2) in team2_configurations:\n            if def1 > att2 and att1 > def2:\n                team1_wins = True\n            if def2 > att1 and att2 > def1:\n                team2_wins = True\n\n    if team1_wins and not team2_wins:\n        return \"Team 1\"\n    elif team2_wins and not team1_wins:\n        return \"Team 2\"\n    else:\n        return \"Draw\"\n\n# Read input\nplayers = [tuple(map(int, input().split())) for _ in range(4)]\n# Determine the result\nresult = can_team_win(players)\n# Print the result\nprint(result)"}
{"solution": "import sys\nimport math\nfrom scipy.optimize import minimize\n\ndef time_to_grill(XY, meats):\n    X, Y = XY\n    times = []\n    for x_i, y_i, c_i in meats:\n        time = c_i * math.sqrt((X - x_i) ** 2 + (Y - y_i) ** 2)\n        times.append(time)\n    return times\n\ndef objective(XY, meats, K):\n    times = time_to_grill(XY, meats)\n    times.sort()\n    return times[K - 1]  # We want the K-th smallest time\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N, K = map(int, data[0].split())\n    meats = [tuple(map(int, line.split())) for line in data[1:N + 1]]\n    \n    # Initial guess for the position of the heat source\n    initial_guess = (0.0, 0.0)\n    \n    # Minimize the K-th time\n    result = minimize(objective, initial_guess, args=(meats, K), method='Nelder-Mead')\n    \n    # Print the result with the required precision\n    print(f\"{result.fun:.10f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def determine_winner(n, ticket):\n    half_n = n // 2\n    left_sum = 0\n    right_sum = 0\n    left_questions = 0\n    right_questions = 0\n\n    for i in range(half_n):\n        if ticket[i] == '?':\n            left_questions += 1\n        else:\n            left_sum += int(ticket[i])\n\n    for i in range(half_n, n):\n        if ticket[i] == '?':\n            right_questions += 1\n        else:\n            right_sum += int(ticket[i])\n\n    # The total number of '?' is even, so we can distribute them evenly\n    total_questions = left_questions + right_questions\n\n    # The difference between the two sums\n    diff = abs(left_sum - right_sum)\n\n    # The maximum we can adjust the sums by using the '?' characters\n    max_adjustment = total_questions * 9\n\n    # If the difference can be covered by the maximum adjustment, Bicarp can win\n    if diff <= max_adjustment:\n        return \"Bicarp\"\n    else:\n        return \"Monocarp\"\n\n# Read input\nn = int(input().strip())\nticket = input().strip()\n\n# Determine and print the winner\nprint(determine_winner(n, ticket))"}
{"solution": "def find_bus_route(n, t, bus_routes):\n    earliest_time = float('inf')\n    chosen_route = -1\n    \n    for i in range(n):\n        s_i, d_i = bus_routes[i]\n        \n        if s_i >= t:\n            next_bus_time = s_i\n        else:\n            # Calculate the next bus time after t\n            if (t - s_i) % d_i == 0:\n                next_bus_time = t\n            else:\n                next_bus_time = s_i + ((t - s_i) // d_i + 1) * d_i\n        \n        if next_bus_time < earliest_time:\n            earliest_time = next_bus_time\n            chosen_route = i + 1\n    \n    return chosen_route\n\n# Input reading\nn, t = map(int, input().split())\nbus_routes = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(find_bus_route(n, t, bus_routes))"}
{"solution": "def count_ones_in_binary(x):\n    return bin(x).count('1')\n\ndef find_n(m, k):\n    # We will iterate over possible values of n\n    for n in range(1, 10**18 + 1):\n        count = 0\n        # Check numbers from n + 1 to 2 * n\n        for num in range(n + 1, 2 * n + 1):\n            if count_ones_in_binary(num) == k:\n                count += 1\n        if count == m:\n            return n\n    return -1  # In case no valid n is found, though the problem guarantees a solution\n\n# Read input\nm, k = map(int, input().split())\n\n# Find and print the result\nresult = find_n(m, k)\nprint(result)"}
{"solution": "def is_good_level(n, level):\n    platforms = [i for i in range(n) if level[i] == '*']\n    \n    # Check for sequences of 5 platforms with equal intervals\n    for i in range(len(platforms)):\n        for j in range(i + 1, len(platforms)):\n            d = platforms[j] - platforms[i]  # distance between first two platforms\n            # Check if we can find 5 platforms with this distance\n            count = 2  # We already have two platforms\n            next_platform = platforms[j] + d\n            \n            while next_platform in platforms:\n                count += 1\n                if count == 5:\n                    return \"yes\"\n                next_platform += d\n    \n    return \"no\"\n\n# Input reading\nn = int(input().strip())\nlevel = input().strip()\n\n# Output the result\nprint(is_good_level(n, level))"}
{"solution": "def find_magic_square_value(n, grid):\n    empty_row, empty_col = -1, -1\n    target_sum = 0\n    \n    # Find the empty cell and calculate the target sum from the first complete row\n    for i in range(n):\n        if 0 in grid[i]:\n            empty_row, empty_col = i, grid[i].index(0)\n        else:\n            target_sum = sum(grid[i])\n            break\n    \n    # Calculate the sum of the row and column where the empty cell is located\n    row_sum = sum(grid[empty_row])\n    col_sum = sum(grid[i][empty_col] for i in range(n))\n    \n    # Calculate the sums of the diagonals if the empty cell is on a diagonal\n    diag1_sum = sum(grid[i][i] for i in range(n)) if empty_row == empty_col else 0\n    diag2_sum = sum(grid[i][n - i - 1] for i in range(n)) if empty_row + empty_col == n - 1 else 0\n    \n    # Determine the value to fill in the empty cell\n    x = target_sum - (row_sum - 0)  # 0 is the value in the empty cell\n    if x <= 0:\n        return -1\n    \n    # Check if filling x makes all sums equal\n    new_row_sum = row_sum + x\n    new_col_sum = col_sum + x\n    new_diag1_sum = diag1_sum + x if empty_row == empty_col else diag1_sum\n    new_diag2_sum = diag2_sum + x if empty_row + empty_col == n - 1 else diag2_sum\n    \n    if (new_row_sum == target_sum and\n        new_col_sum == target_sum and\n        new_diag1_sum == target_sum and\n        new_diag2_sum == target_sum):\n        return x\n    else:\n        return -1\n\n# Read input\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = find_magic_square_value(n, grid)\nprint(result)"}
{"solution": "import math\n\n# Read the number of benches\nn = int(input().strip())\n\n# Read the number of additional people\nm = int(input().strip())\n\n# Read the initial number of people on each bench\na = [int(input().strip()) for _ in range(n)]\n\n# Calculate the maximum possible k\nmax_k = max(a) + m\n\n# Calculate the total number of people after adding m\ntotal_people = sum(a) + m\n\n# Calculate the minimum possible k\nmin_k = math.ceil(total_people / n)\n\n# Print the results\nprint(min_k, max_k)"}
{"solution": "def count_boarding_ways(n, m):\n    MOD = 10**9 + 7\n    \n    # Calculate the total number of ways to assign seats and entrances\n    # Each passenger has 2 choices for entrance (F or B) and n choices for seats\n    total_ways = pow(n, m, MOD) * pow(2, m, MOD) % MOD\n    \n    # The result is the total ways modulo 10^9 + 7\n    return total_ways\n\n# Read input\nn, m = map(int, input().split())\n# Calculate and print the result\nprint(count_boarding_ways(n, m))"}
{"solution": "def main():\n    import sys\n    from itertools import combinations\n\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    n, m = map(int, data[0].split())\n    \n    friends_favorites = []\n    for i in range(1, n + 1):\n        line = list(map(int, data[i].split()))\n        friends_favorites.append(set(line[1:]))\n\n    pizzas = []\n    for j in range(n + 1, n + m + 1):\n        line = list(map(int, data[j].split()))\n        price = line[0]\n        ingredients = set(line[2:])\n        pizzas.append((price, ingredients))\n\n    max_friends_pleased = 0\n    best_pair = (0, 0)\n    min_cost = float('inf')\n\n    for (i, (price1, ingredients1)), (j, (price2, ingredients2)) in combinations(enumerate(pizzas), 2):\n        combined_ingredients = ingredients1 | ingredients2\n        friends_pleased = sum(1 for favorites in friends_favorites if favorites.issubset(combined_ingredients))\n        \n        total_cost = price1 + price2\n        \n        if (friends_pleased > max_friends_pleased) or (friends_pleased == max_friends_pleased and total_cost < min_cost):\n            max_friends_pleased = friends_pleased\n            min_cost = total_cost\n            best_pair = (i + 1, j + 1)  # +1 for 1-based index\n\n    print(best_pair[0], best_pair[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_min_max_numbers(m, s):\n    if (s == 0 and m > 1) or (s > 9 * m):\n        return \"-1 -1\"\n\n    # Finding the minimum number\n    min_number = []\n    remaining_sum = s\n\n    for i in range(m):\n        for digit in range(0 if i > 0 else 1, 10):\n            if remaining_sum - digit >= 0 and remaining_sum - digit <= 9 * (m - i - 1):\n                min_number.append(digit)\n                remaining_sum -= digit\n                break\n\n    # Finding the maximum number\n    max_number = []\n    remaining_sum = s\n\n    for i in range(m):\n        for digit in range(9, -1, -1):\n            if remaining_sum - digit >= 0 and remaining_sum - digit <= 9 * (m - i - 1):\n                max_number.append(digit)\n                remaining_sum -= digit\n                break\n\n    return ''.join(map(str, min_number)), ''.join(map(str, max_number))\n\n# Read input\nm, s = map(int, input().strip().split())\nmin_num, max_num = find_min_max_numbers(m, s)\nprint(min_num, max_num)"}
{"solution": "def count_valid_numbers(l, r, k):\n    valid_numbers = []\n    \n    for num in range(l, r + 1):\n        digits = set(str(num))\n        if len(digits) <= k:\n            valid_numbers.append(num)\n    \n    return sum(valid_numbers) % 998244353\n\n# Read input\nl, r, k = map(int, input().split())\n\n# Calculate the result\nresult = count_valid_numbers(l, r, k)\n\n# Print the output\nprint(result)"}
{"solution": "def can_distribute_pencils(n, k, d, saturations):\n    saturations.sort()\n    count = 0\n    i = 0\n\n    while i < n:\n        count += 1\n        start = saturations[i]\n        # Move i to the right as long as the condition is satisfied\n        while i < n and saturations[i] - start <= d:\n            i += 1\n        # Check if the number of pencils in this box is at least k\n        if i - (count - 1) * k < k:\n            return \"NO\"\n\n    return \"YES\"\n\n# Read input\nn, k, d = map(int, input().split())\nsaturations = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_distribute_pencils(n, k, d, saturations)\nprint(result)"}
{"solution": "def count_dead_bulbs(s):\n    # Initialize counts for each color\n    dead_counts = {'R': 0, 'B': 0, 'Y': 0, 'G': 0}\n    \n    # Create a mapping of positions to colors based on the pattern\n    color_pattern = ['R', 'B', 'Y', 'G']\n    \n    # Iterate through the string\n    for i in range(len(s)):\n        if s[i] == '!':\n            # Determine the color that should be in this position\n            color_index = i % 4\n            color = color_pattern[color_index]\n            dead_counts[color] += 1\n    \n    # Print the counts in the order of R, B, Y, G\n    print(dead_counts['R'], dead_counts['B'], dead_counts['Y'], dead_counts['G'])\n\n# Read input\ns = input().strip()\ncount_dead_bulbs(s)"}
{"solution": "def expected_passages(N, M, passages):\n    from collections import defaultdict\n    import sys\n\n    # Create a graph representation\n    graph = defaultdict(list)\n    for s, t in passages:\n        graph[s].append(t)\n\n    # Initialize expected values\n    E = [0.0] * (N + 1)\n    out_degree = [0] * (N + 1)\n\n    # Calculate the out-degree for each room\n    for s in graph:\n        out_degree[s] = len(graph[s])\n\n    # Calculate expected passages using dynamic programming\n    for room in range(N - 1, 0, -1):\n        if out_degree[room] > 0:\n            E[room] = 1 + sum(E[next_room] for next_room in graph[room]) / out_degree[room]\n\n    # Now we need to consider Aoki's blocking strategy\n    min_E = float('inf')\n\n    for next_room in graph[1]:\n        # Temporarily block the passage from Room 1 to next_room\n        out_degree[1] -= 1\n        E_blocked = 1 + sum(E[next_room] for next_room in graph[1] if next_room != next_room) / out_degree[1] if out_degree[1] > 0 else 0\n\n        # Calculate the expected value with this passage blocked\n        current_E = E_blocked\n        for room in range(2, N + 1):\n            if room in graph:\n                current_E += E[room] * (out_degree[room] / (out_degree[room] + 1))\n\n        min_E = min(min_E, current_E)\n\n        # Restore the out-degree\n        out_degree[1] += 1\n\n    return min_E\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN, M = map(int, data[0].split())\npassages = [tuple(map(int, line.split())) for line in data[1:M + 1]]\n\n# Calculate the expected number of passages\nresult = expected_passages(N, M, passages)\n\n# Print the result with the required precision\nprint(f\"{result:.10f}\")"}
{"solution": "n = int(input().strip())\n\n# Calculate the nearest multiples of 10\nlower_multiple = (n // 10) * 10\nupper_multiple = lower_multiple + 10\n\n# Determine which multiple is closer\nif n - lower_multiple < upper_multiple - n:\n    print(lower_multiple)\nelse:\n    print(upper_multiple)"}
{"solution": "def find_swaps(s, t):\n    if len(s) != len(t):\n        return -1\n    \n    mismatches = {}\n    \n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if s[i] in mismatches and mismatches[s[i]] != t[i]:\n                return -1\n            if t[i] in mismatches and mismatches[t[i]] != s[i]:\n                return -1\n            mismatches[s[i]] = t[i]\n            mismatches[t[i]] = s[i]\n    \n    visited = set()\n    swaps = []\n    \n    for key in mismatches:\n        if key not in visited:\n            cycle = []\n            current = key\n            while current not in visited:\n                visited.add(current)\n                cycle.append(current)\n                current = mismatches[current]\n            if len(cycle) != 2:\n                return -1\n            swaps.append((cycle[0], cycle[1]))\n    \n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0], swap[1])\n\n# Read input\ns = input().strip()\nt = input().strip()\nfind_swaps(s, t)"}
{"solution": "def earliest_login(first_name, last_name):\n    # Initialize the earliest login as a very large string\n    earliest = None\n    \n    # Generate all non-empty prefixes of the first name\n    for i in range(1, len(first_name) + 1):\n        first_prefix = first_name[:i]\n        \n        # Generate all non-empty prefixes of the last name\n        for j in range(1, len(last_name) + 1):\n            last_prefix = last_name[:j]\n            \n            # Concatenate the prefixes\n            login = first_prefix + last_prefix\n            \n            # Update the earliest login if necessary\n            if earliest is None or login < earliest:\n                earliest = login\n                \n    return earliest\n\n# Read input\ninput_data = input().strip()\nfirst_name, last_name = input_data.split()\n\n# Get the earliest login and print it\nprint(earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(n, sequence):\n    # Calculate the depth of each bracket\n    depth = []\n    current_depth = 0\n    for char in sequence:\n        if char == '[':\n            current_depth += 1\n            depth.append(current_depth)\n        else:\n            depth.append(current_depth)\n            current_depth -= 1\n\n    max_depth = max(depth)\n\n    # Initialize the output grid\n    output = [[' ' for _ in range(len(sequence) * 4 - 1)] for _ in range(max_depth * 2 + 1)]\n\n    # Fill the output grid with the bracket representation\n    for i, char in enumerate(sequence):\n        if char == '[':\n            # Draw the opening bracket\n            output[max_depth - depth[i] * 2][i * 4] = '+'\n            output[max_depth - depth[i] * 2][i * 4 + 1] = '-'\n            output[max_depth - depth[i] * 2][i * 4 + 2] = '-'\n            output[max_depth - depth[i] * 2][i * 4 + 3] = '+'\n            for j in range(max_depth - depth[i] * 2 + 1, max_depth - depth[i] * 2 + 2):\n                output[j][i * 4 + 1] = '|'\n        else:\n            # Draw the closing bracket\n            output[max_depth - depth[i] * 2][i * 4] = '+'\n            output[max_depth - depth[i] * 2][i * 4 + 1] = '-'\n            output[max_depth - depth[i] * 2][i * 4 + 2] = '-'\n            output[max_depth - depth[i] * 2][i * 4 + 3] = '+'\n            for j in range(max_depth - depth[i] * 2 + 1, max_depth - depth[i] * 2 + 2):\n                output[j][i * 4 + 1] = '|'\n\n    # Print the output\n    for row in output:\n        print(''.join(row).rstrip())\n\n# Read input\nn = int(input().strip())\nsequence = input().strip()\n\n# Draw the brackets\ndraw_brackets(n, sequence)"}
{"solution": "def normalize_golden_number(golden_number):\n    # Convert the golden number string to a list of integers for easier manipulation\n    golden_number = list(map(int, golden_number))\n    n = len(golden_number)\n    \n    # Normalize the number using the property q^2 = q + 1\n    for i in range(n - 1, 0, -1):\n        if golden_number[i] > 1:\n            golden_number[i] -= 2\n            golden_number[i - 1] += 1\n            if i - 2 >= 0:\n                golden_number[i - 2] += 1\n    \n    # Remove leading zeros\n    while len(golden_number) > 1 and golden_number[0] == 0:\n        golden_number.pop(0)\n    \n    return golden_number\n\ndef compare_golden_numbers(num1, num2):\n    # Normalize both numbers\n    norm_num1 = normalize_golden_number(num1)\n    norm_num2 = normalize_golden_number(num2)\n    \n    # Compare lengths first\n    if len(norm_num1) > len(norm_num2):\n        return \">\"\n    elif len(norm_num1) < len(norm_num2):\n        return \"<\"\n    \n    # If lengths are equal, compare digit by digit\n    for digit1, digit2 in zip(norm_num1, norm_num2):\n        if digit1 > digit2:\n            return \">\"\n        elif digit1 < digit2:\n            return \"<\"\n    \n    # If all digits are equal\n    return \"=\"\n\n# Read input\nnum1 = input().strip()\nnum2 = input().strip()\n\n# Compare the numbers and print the result\nresult = compare_golden_numbers(num1, num2)\nprint(result)"}
{"solution": "def find_absent_gems(n, colors):\n    gem_colors = {\n        \"Power\": \"purple\",\n        \"Time\": \"green\",\n        \"Space\": \"blue\",\n        \"Soul\": \"orange\",\n        \"Reality\": \"red\",\n        \"Mind\": \"yellow\"\n    }\n    \n    # Create a set of the colors that are present\n    present_colors = set(colors)\n    \n    # Find absent gems\n    absent_gems = [name for name, color in gem_colors.items() if color not in present_colors]\n    \n    # Output the results\n    print(len(absent_gems))\n    for gem in absent_gems:\n        print(gem)\n\n# Input reading\nn = int(input())\ncolors = [input().strip() for _ in range(n)]\n\n# Find and print absent gems\nfind_absent_gems(n, colors)"}
{"solution": "def find_meeting_round(n, a, b):\n    round_number = 1\n    \n    # Ensure a is the smaller id for easier calculation\n    if a > b:\n        a, b = b, a\n    \n    while n > 1:\n        # Check if a and b are in the same pair\n        if (a // 2) == (b // 2):\n            return round_number\n        \n        # Move to the next round\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n //= 2\n        round_number += 1\n    \n    return \"Final!\"\n\n# Read input\nn, a, b = map(int, input().split())\n# Get the result\nresult = find_meeting_round(n, a, b)\n# Print the result\nprint(result)"}
{"solution": "def min_changes_to_suit_pavel(n, p, b):\n    # Create a visited array to track positions\n    visited = [False] * (n + 1)\n    \n    # Count the number of cycles in the permutation\n    cycle_count = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            cycle_count += 1\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                x = p[x - 1]  # Move to the next position in the permutation\n\n    # Count the number of 1s in b\n    count_b1 = sum(b)\n\n    # To ensure every skewer visits every position in both directions,\n    # we need at least `cycle_count` reversals (1s in b) and `cycle_count` cycles.\n    # The minimum changes required will be the maximum of these two counts.\n    changes_needed = max(cycle_count, n - count_b1)\n\n    return changes_needed\n\n# Input reading\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = min_changes_to_suit_pavel(n, p, b)\nprint(result)"}
{"solution": "def max_path_length(v1, v2, t, d):\n    speeds = [0] * t\n    speeds[0] = v1\n    speeds[-1] = v2\n\n    # Fill the speeds array from the start to the end\n    for i in range(1, t):\n        speeds[i] = speeds[i - 1] + d\n        if speeds[i] > 100:  # Ensure we don't exceed the maximum speed limit\n            speeds[i] = 100\n\n    # Adjust the speeds from the end to the start\n    for i in range(t - 2, -1, -1):\n        if speeds[i] > speeds[i + 1] + d:\n            speeds[i] = speeds[i + 1] + d\n\n    # Calculate the total distance\n    total_distance = sum(speeds)\n    return total_distance\n\n# Input reading\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Calculate and print the maximum possible length of the path\nprint(max_path_length(v1, v2, t, d))"}
{"solution": "from itertools import permutations\nimport sys\n\ndef can_cross_bridge(camels, bridge_parts):\n    for l, v in bridge_parts:\n        current_weight = 0\n        for i in range(len(camels)):\n            current_weight += camels[i]\n            if current_weight > v:\n                return False\n            # The last camel does not count towards the weight in the part\n            if i < len(camels) - 1:\n                current_weight -= camels[i]\n    return True\n\ndef min_distance(camels, bridge_parts):\n    total_length = sum(l for l, v in bridge_parts)\n    return total_length\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N, M = map(int, data[0].split())\n    weights = list(map(int, data[1].split()))\n    bridge_parts = [tuple(map(int, line.split())) for line in data[2:M+2]]\n    \n    # Check if any arrangement of camels can cross the bridge\n    for perm in permutations(weights):\n        if can_cross_bridge(perm, bridge_parts):\n            print(min_distance(perm, bridge_parts))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def last_digit_of_factorial_ratio(a, b):\n    if a == b:\n        return 1  # a! / a! = 1, last digit is 1\n    if a == 0:\n        return 0  # 0! = 1, b! / 0! = b!, last digit of b! is 0 for b >= 5\n\n    # Calculate the last digit of (b! / a!)\n    # This is equivalent to the last digit of (b * (b-1) * ... * (a+1))\n    last_digit = 1\n    for i in range(a + 1, b + 1):\n        last_digit *= i\n        last_digit %= 10  # Keep only the last digit\n\n    return last_digit\n\n# Read input\na, b = map(int, input().split())\n# Get the result\nresult = last_digit_of_factorial_ratio(a, b)\n# Print the result\nprint(result)"}
{"solution": "from collections import deque\n\ndef min_jumps_to_home(n, d, s):\n    queue = deque([(0, 0)])  # (current position, number of jumps)\n    visited = [False] * n\n    visited[0] = True  # starting point is visited\n\n    while queue:\n        position, jumps = queue.popleft()\n\n        # Check if we have reached the last position\n        if position == n - 1:\n            return jumps\n\n        # Try to jump to all possible positions within the jump distance\n        for jump in range(1, d + 1):\n            next_position = position + jump\n            if next_position < n and s[next_position] == '1' and not visited[next_position]:\n                visited[next_position] = True\n                queue.append((next_position, jumps + 1))\n\n    return -1  # If we exhaust the queue without reaching the end\n\n# Read input\nn, d = map(int, input().split())\ns = input().strip()\n\n# Get the result and print it\nresult = min_jumps_to_home(n, d, s)\nprint(result)"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_counterexample(n):\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\n# Read input\nn = int(input().strip())\n\n# Find and print the counterexample\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all_coins(n):\n    house_price = 1234567\n    car_price = 123456\n    computer_price = 1234\n\n    # Check for all possible numbers of houses\n    for a in range(n // house_price + 1):\n        remaining_after_houses = n - a * house_price\n        \n        # Check for all possible numbers of cars with the remaining coins\n        for b in range(remaining_after_houses // car_price + 1):\n            remaining_after_cars = remaining_after_houses - b * car_price\n            \n            # Check if the remaining coins can be spent on computers\n            if remaining_after_cars >= 0 and remaining_after_cars % computer_price == 0:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input().strip())\n# Print the result\nprint(can_spend_all_coins(n))"}
{"solution": "def can_intersect(n, x1, x2, lines):\n    # Sort lines based on their slopes (k_i)\n    lines.sort()\n    \n    # Check for intersections between consecutive lines\n    for i in range(n - 1):\n        k1, b1 = lines[i]\n        k2, b2 = lines[i + 1]\n        \n        # If the slopes are different, they will intersect\n        if k1 != k2:\n            # Calculate the x-coordinate of the intersection\n            x_intersect = (b2 - b1) / (k1 - k2)\n            # Check if the intersection is strictly within the strip\n            if x1 < x_intersect < x2:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\nx1, x2 = map(int, input().split())\nlines = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = can_intersect(n, x1, x2, lines)\nprint(result)"}
{"solution": "def count_different_weights(n):\n    # The number of different weights of splits of n is equal to the number of divisors of n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1  # i is a divisor\n            if i != n // i:\n                count += 1  # n // i is also a divisor\n    return count\n\nn = int(input())\nprint(count_different_weights(n))"}
{"solution": "def find_good_apartments(n, k):\n    if k == 0:\n        min_good = 0\n        max_good = 0\n    else:\n        min_good = 1\n        max_good = min(n - k, 2 * k)\n    \n    return min_good, max_good\n\n# Read input\nn, k = map(int, input().split())\nmin_good, max_good = find_good_apartments(n, k)\nprint(min_good, max_good)"}
{"solution": "import math\n\ndef max_games(n):\n    return math.floor(math.log2(n))\n\nn = int(input())\nprint(max_games(n))"}
{"solution": "def max_vk_occurrences(s):\n    # Function to count occurrences of \"VK\" in the string\n    def count_vk(string):\n        return sum(1 for i in range(len(string) - 1) if string[i:i + 2] == \"VK\")\n\n    # Initial count of \"VK\" in the original string\n    original_count = count_vk(s)\n    max_count = original_count\n\n    # Try changing each character and see if it increases the count of \"VK\"\n    for i in range(len(s)):\n        # Change 'V' to 'K'\n        if s[i] == 'V':\n            new_string = s[:i] + 'K' + s[i + 1:]\n            max_count = max(max_count, count_vk(new_string))\n        # Change 'K' to 'V'\n        else:\n            new_string = s[:i] + 'V' + s[i + 1:]\n            max_count = max(max_count, count_vk(new_string))\n\n    return max_count\n\n# Read input\ns = input().strip()\n# Print the output\nprint(max_vk_occurrences(s))"}
{"solution": "import math\n\ndef min_segments(n):\n    a = int(math.sqrt(n))\n    b = (n + a - 1) // a  # This is equivalent to math.ceil(n / a)\n    return a + b + 2\n\n# Read input\nn = int(input().strip())\nprint(min_segments(n))"}
{"solution": "# Read the weights of Limak and Bob\na, b = map(int, input().split())\n\n# Initialize the number of years\nyears = 0\n\n# Loop until Limak's weight is greater than Bob's weight\nwhile a <= b:\n    a *= 3  # Limak's weight triples\n    b *= 2  # Bob's weight doubles\n    years += 1  # Increment the year count\n\n# Print the number of years it takes for Limak to be strictly heavier than Bob\nprint(years)"}
{"solution": "def count_visited_nodes(h, n):\n    visited = set()\n    current_node = 1\n    visited.add(current_node)\n    command_index = 0\n    skip_count = 0\n    total_visited = 0\n\n    while True:\n        if current_node == n:\n            break\n        \n        command = 'L' if command_index % 2 == 0 else 'R'\n        command_index += 1\n        \n        if command == 'L':\n            next_node = current_node * 2\n        else:\n            next_node = current_node * 2 + 1\n        \n        if next_node > 2 ** h:\n            continue\n        \n        if next_node in visited:\n            skip_count += 1\n            if skip_count == 2:\n                current_node //= 2  # Go back to parent\n                skip_count = 0\n            continue\n        \n        visited.add(next_node)\n        total_visited += 1\n        \n        if next_node == n:\n            break\n        \n        current_node = next_node\n        skip_count = 0\n\n    return total_visited\n\n# Input reading\nh, n = map(int, input().split())\n# Output the result\nprint(count_visited_nodes(h, n))"}
{"solution": "def count_distinct_squares(n, m):\n    total_squares = 0\n    max_square_size = min(n, m)\n    for size in range(1, max_square_size + 1):\n        total_squares += (n - size + 1) * (m - size + 1)\n    return total_squares\n\ndef find_tables_with_exactly_x_squares(x):\n    results = []\n    for n in range(1, int(x**0.5) + 2):\n        for m in range(1, int(x**0.5) + 2):\n            if count_distinct_squares(n, m) == x:\n                results.append((n, m))\n    \n    results.sort()  # Sort by n, then by m\n    return results\n\ndef main():\n    x = int(input().strip())\n    tables = find_tables_with_exactly_x_squares(x)\n    \n    print(len(tables))\n    for n, m in tables:\n        print(n, m)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_valid_gregorian_sequence(n, days):\n    # Days in months for non-leap and leap years\n    months_non_leap = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    months_leap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    # Check for each starting month in both non-leap and leap years\n    for start in range(12):\n        # Check non-leap year\n        if all(days[i] == months_non_leap[(start + i) % 12] for i in range(n)):\n            return \"YES\"\n        # Check leap year\n        if all(days[i] == months_leap[(start + i) % 12] for i in range(n)):\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn = int(input().strip())\ndays = list(map(int, input().strip().split()))\n\n# Output the result\nprint(is_valid_gregorian_sequence(n, days))"}
{"solution": "def find_fractions(n):\n    # The target sum we want to achieve\n    target_sum = 1 - 1/n\n    \n    # List to store the fractions\n    fractions = []\n    \n    # We will iterate over the divisors of n\n    for b in range(2, n):\n        if n % b == 0:  # b is a divisor of n\n            a = b - 1  # We can take a = b - 1 (which is always < b)\n            fractions.append((a, b))\n            target_sum -= a / b\n            \n            # If we have reached the target sum, we can stop\n            if target_sum <= 0:\n                break\n    \n    # Check if we have reached the target sum\n    if abs(target_sum) < 1e-9:\n        print(\"YES\")\n        print(len(fractions))\n        for a, b in fractions:\n            print(a, b)\n    else:\n        print(\"NO\")\n\n# Read input\nn = int(input().strip())\nfind_fractions(n)"}
{"solution": "def min_unattractiveness(n, a, b, heights):\n    # Initialize a DP table\n    dp = [[float('inf')] * (b + 1) for _ in range(a + 1)]\n    dp[0][0] = 0  # No boards painted, no unattractiveness\n\n    for i in range(n):\n        h = heights[i]\n        for red in range(a + 1):\n            for green in range(b + 1):\n                if dp[red][green] == float('inf'):\n                    continue\n                \n                # Paint current board red\n                if red + h <= a:\n                    dp[red + h][green] = min(dp[red + h][green], dp[red][green])\n                \n                # Paint current board green\n                if green + h <= b:\n                    dp[red][green + h] = min(dp[red][green + h], dp[red][green])\n                \n                # Paint current board red and check unattractiveness\n                if i > 0:\n                    if red + h <= a:\n                        dp[red + h][green] = min(dp[red + h][green], dp[red][green] + (heights[i - 1] if (i - 1) % 2 == 0 else 0))\n                    if green + h <= b:\n                        dp[red][green + h] = min(dp[red][green + h], dp[red][green] + (heights[i - 1] if (i - 1) % 2 == 1 else 0))\n\n    # Find the minimum unattractiveness\n    min_unattractiveness_value = float('inf')\n    for red in range(a + 1):\n        for green in range(b + 1):\n            if dp[red][green] != float('inf'):\n                min_unattractiveness_value = min(min_unattractiveness_value, dp[red][green])\n\n    return min_unattractiveness_value if min_unattractiveness_value != float('inf') else -1\n\n# Input reading\nn = int(input().strip())\na, b = map(int, input().strip().split())\nheights = list(map(int, input().strip().split()))\n\n# Calculate and print the result\nresult = min_unattractiveness(n, a, b, heights)\nprint(result)"}
{"solution": "def find_triangle_points(n, m, k):\n    area = (n * m) / k\n    \n    # Check if the area is an integer\n    if area != int(area):\n        print(\"NO\")\n        return\n    \n    area = int(area)\n    \n    # We need to find points such that the area is equal to the calculated area\n    # Area of triangle = 0.5 * base * height\n    # We can choose base = n and height = 2 * area / n\n    # Thus, height must be <= m and 2 * area must be <= n * m\n    \n    if 2 * area > n * m:\n        print(\"NO\")\n        return\n    \n    # We can choose points as follows:\n    # (0, 0), (n, 0), (0, height)\n    height = (2 * area) // n\n    \n    if height > m:\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    print(0, 0)\n    print(n, 0)\n    print(0, height)\n\n# Read input\nn, m, k = map(int, input().split())\nfind_triangle_points(n, m, k)"}
{"solution": "def sasha_wins(n, k):\n    # Calculate the total number of moves that can be made\n    total_moves = n // k\n    \n    # Sasha wins if he makes strictly more moves than Lena\n    if total_moves % 2 == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\n# Print the result\nprint(sasha_wins(n, k))"}
{"solution": "# Read the number of exercises\nn = int(input())\n\n# Read the repetitions for each exercise\nrepetitions = list(map(int, input().split()))\n\n# Initialize counters for each muscle group\nchest = 0\nbiceps = 0\nback = 0\n\n# Iterate through the repetitions and assign them to the corresponding muscle group\nfor i in range(n):\n    if i % 3 == 0:\n        chest += repetitions[i]  # Chest exercise\n    elif i % 3 == 1:\n        biceps += repetitions[i]  # Biceps exercise\n    else:\n        back += repetitions[i]  # Back exercise\n\n# Determine which muscle group received the most exercise\nif chest > biceps and chest > back:\n    print(\"chest\")\nelif biceps > chest and biceps > back:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "def min_redos_to_get_five(n, grades):\n    current_sum = sum(grades)\n    target_sum = n * 4.5\n    \n    if current_sum >= target_sum:\n        return 0\n    \n    grades.sort()\n    redos = 0\n    \n    for grade in grades:\n        if current_sum >= target_sum:\n            break\n        current_sum += (5 - grade)\n        redos += 1\n    \n    return redos\n\n# Input reading\nn = int(input())\ngrades = list(map(int, input().split()))\nprint(min_redos_to_get_five(n, grades))"}
{"solution": "def find_shortest_array(u, v):\n    # Check if the conditions are met\n    if u > v or (u % 2) != (v % 2):\n        return -1\n    \n    # If both u and v are zero, the answer is an empty array\n    if u == 0 and v == 0:\n        return (0, [])\n    \n    # Calculate the two numbers that will form the array\n    x = (v - u) // 2\n    a = x + u\n    b = x\n    \n    # The result array\n    result = []\n    \n    # If a and b are both positive, we can return them\n    if a > 0 and b > 0:\n        result.append(a)\n        result.append(b)\n    elif a > 0:  # If only a is positive\n        result.append(a)\n    elif b > 0:  # If only b is positive\n        result.append(b)\n    \n    # Return the length of the result and the result itself\n    return (len(result), result)\n\n# Read input\nu, v = map(int, input().split())\n\n# Get the result\nresult = find_shortest_array(u, v)\n\n# Print the output\nif result == -1:\n    print(-1)\nelse:\n    print(result[0])\n    print(' '.join(map(str, result[1])))"}
{"solution": "def min_digits_of_one(n):\n    total_ones = 0\n    while n > 0:\n        total_ones += n % 10\n        n //= 10\n    return total_ones\n\nn = int(input().strip())\nprint(min_digits_of_one(n))"}
{"solution": "def can_reach_treasure(x1, y1, x2, y2, x, y):\n    # Calculate the differences in coordinates\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n\n    # Check if both differences are divisible by the respective potion values\n    if dx % x == 0 and dy % y == 0:\n        # Check if the number of moves in x and y directions are both even or both odd\n        if (dx // x) % 2 == (dy // y) % 2:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input values\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\n# Output the result\nprint(can_reach_treasure(x1, y1, x2, y2, x, y))"}
{"solution": "from itertools import permutations\n\ndef count_valid_bus_numbers(n):\n    # Convert the number to a string to extract digits\n    digits = list(str(n))\n    \n    # Generate all unique permutations of the digits\n    all_permutations = set(permutations(digits))\n    \n    # Filter out permutations that start with '0'\n    valid_permutations = set()\n    for perm in all_permutations:\n        if perm[0] != '0':\n            valid_permutations.add(''.join(perm))\n    \n    # Return the count of valid permutations\n    return len(valid_permutations)\n\n# Read input\nn = int(input().strip())\n\n# Get the count of valid bus numbers\nresult = count_valid_bus_numbers(n)\n\n# Print the result\nprint(result)"}
{"solution": "def max_suit_cost(a, b, c, d, e, f):\n    # Calculate the maximum number of suits of each type that can be made\n    max_type1 = min(a, d)  # Ties and jackets for type 1 suits\n    max_type2 = min(b, c, d)  # Scarves, vests, and jackets for type 2 suits\n\n    # Calculate the total cost for both combinations\n    total_cost1 = max_type1 * e + min(b, c, d - max_type1) * f\n    total_cost2 = max_type2 * f + min(a, d - max_type2) * e\n\n    # Return the maximum of the two total costs\n    return max(total_cost1, total_cost2)\n\n# Read input values\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\n# Calculate and print the maximum total cost\nprint(max_suit_cost(a, b, c, d, e, f))"}
{"solution": "def count_valid_n(a, b, p, x):\n    count = 0\n    for n in range(1, min(x, p) + 1):\n        if (n * pow(a, n, p)) % p == b:\n            count += 1\n    return count\n\n# Read input\na, b, p, x = map(int, input().split())\n\n# Get the result\nresult = count_valid_n(a, b, p, x)\n\n# Print the output\nprint(result)"}
{"solution": "def max_sum_of_integers(k2, k3, k5, k6):\n    # Calculate how many 256 can be formed\n    count_256 = min(k5, k6, k2)  # 256 requires 1 of 5, 1 of 6, and 1 of 2\n    # Calculate how many 32 can be formed\n    count_32 = min(k2, k3)  # 32 requires 1 of 3 and 1 of 2\n    \n    # Calculate the total sum\n    total_sum = count_256 * 256 + count_32 * 32\n    return total_sum\n\n# Read input\nk2, k3, k5, k6 = map(int, input().split())\n\n# Get the result\nresult = max_sum_of_integers(k2, k3, k5, k6)\n\n# Print the result\nprint(result)"}
{"solution": "def seconds_until_happy(n, x, y, c):\n    if c == 1:\n        return 0\n    \n    # Calculate the maximum number of cells that can be turned on\n    # in a given number of seconds\n    seconds = 0\n    total_on = 1  # Initially, only one cell is on\n\n    while total_on < c:\n        seconds += 1\n        # Each second, the number of newly turned on cells is equal to the perimeter of the current \"on\" cells\n        # which is 4 * seconds (but we need to consider the boundaries of the grid)\n        new_cells = min(4 * seconds, n * n - total_on)\n        total_on += new_cells\n\n        # If we exceed the total number of cells in the grid, we stop\n        if total_on >= c:\n            break\n\n    return seconds\n\n# Read input\nn, x, y, c = map(int, input().split())\n# Output the result\nprint(seconds_until_happy(n, x, y, c))"}
{"solution": "def max_xor(l, r):\n    # Find the maximum XOR value by determining the highest bit position where l and r differ\n    xor_value = l ^ r\n    max_bit = 0\n    \n    # Find the position of the most significant bit that is set in xor_value\n    while xor_value > 0:\n        max_bit += 1\n        xor_value >>= 1\n    \n    # The maximum XOR value is achieved by setting all bits below the most significant differing bit to 1\n    return (1 << max_bit) - 1\n\n# Read input\nl, r = map(int, input().split())\n# Calculate and print the result\nprint(max_xor(l, r))"}
{"solution": "def minimum_height(n, k):\n    left, right = 1, k  # The height cannot be more than k because the area is k\n    \n    while left < right:\n        mid = (left + right) // 2\n        if n * mid >= k:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Read input\nn, k = map(int, input().split())\n# Calculate and print the minimum height\nprint(minimum_height(n, k))"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    # Calculate the time using stairs\n    stairs_time = abs(x - y) * t1\n    \n    # Calculate the time using the elevator\n    elevator_to_masha_time = abs(z - x) * t2 + t3  # Time for elevator to reach Masha\n    elevator_to_egor_time = abs(x - y) * t2 + 2 * t3  # Time for elevator to take Masha to Egor\n    elevator_time = elevator_to_masha_time + elevator_to_egor_time\n    \n    # Compare the times\n    if elevator_time <= stairs_time:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input values\nx, y, z, t1, t2, t3 = map(int, input().split())\n# Print the result\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "def best_choice(n, m):\n    # Calculate the best choice for Andrew\n    if m <= n // 2:\n        return m + 1  # Choose the next number\n    else:\n        return m - 1  # Choose the previous number\n\n# Read input\nn, m = map(int, input().split())\n# Get the best choice for Andrew\nresult = best_choice(n, m)\n# Print the result\nprint(result)"}
{"solution": "def alena_stays_at_university(n, schedule):\n    # Initialize the count of pairs Alena stays at the university\n    stay_count = 0\n    i = 0\n    \n    # Find the first pair that Alena has\n    while i < n and schedule[i] == 0:\n        i += 1\n    \n    # If there are no pairs, return 0\n    if i == n:\n        return 0\n    \n    # Alena will stay at the university from the first class\n    stay_count += 1\n    \n    # Iterate through the schedule starting from the first class\n    while i < n:\n        if schedule[i] == 1:\n            stay_count += 1\n            i += 1\n        else:\n            # If there's a break, check for consecutive breaks\n            break_length = 0\n            while i < n and schedule[i] == 0:\n                break_length += 1\n                i += 1\n            \n            # If there are at least 2 consecutive breaks, Alena goes home\n            if break_length >= 2:\n                # If there are more pairs after the break, she will return\n                if i < n:\n                    stay_count += 1  # She will stay for the next class\n            else:\n                # If the break is less than 2, she waits for the next class\n                stay_count += 1  # She will stay for the next class if it exists\n    \n    return stay_count\n\n# Input reading\nn = int(input())\nschedule = list(map(int, input().split()))\n\n# Output the result\nprint(alena_stays_at_university(n, schedule))"}
{"solution": "def min_days_to_give_candies(n, k, candies):\n    total_given = 0\n    saved_candies = 0\n\n    for day in range(n):\n        saved_candies += candies[day]\n        # Give Bran at most 8 candies from the saved candies\n        give_today = min(saved_candies, 8)\n        total_given += give_today\n        saved_candies -= give_today\n        \n        # Check if we have given enough candies\n        if total_given >= k:\n            return day + 1  # Return the day index (1-based)\n\n    return -1  # If not enough candies were given by the end of n days\n\n# Input reading\nn, k = map(int, input().split())\ncandies = list(map(int, input().split()))\n\n# Output the result\nprint(min_days_to_give_candies(n, k, candies))"}
{"solution": "def minimum_additional_walks(n, k, a):\n    b = a[:]  # Create a copy of the planned walks\n    additional_walks = 0\n    \n    # We assume that before the first day and after the last day, there are k walks\n    # So we can treat the first day as having k walks before it\n    # and the last day as having k walks after it\n    for i in range(n - 1):\n        # Calculate the required walks for the current and next day\n        required_walks = k - b[i]\n        if b[i] + b[i + 1] < k:\n            # If the current and next day do not meet the requirement\n            needed_walks = k - b[i]\n            b[i + 1] += needed_walks\n            additional_walks += needed_walks\n    \n    return additional_walks, b\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nadditional_walks, b = minimum_additional_walks(n, k, a)\n\n# Print the result\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "def rhombus_cells(n):\n    if n == 1:\n        return 1\n    else:\n        return 2 * n * (n - 1) + 1\n\nn = int(input())\nprint(rhombus_cells(n))"}
{"solution": "def is_pangram(s):\n    # Convert the string to lowercase to handle case insensitivity\n    s = s.lower()\n    # Create a set of all letters in the alphabet\n    alphabet_set = set('abcdefghijklmnopqrstuvwxyz')\n    # Create a set from the input string\n    input_set = set(s)\n    # Check if all alphabet letters are in the input set\n    return alphabet_set.issubset(input_set)\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Check if the string is a pangram and print the result\nif is_pangram(s):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Read the current time in hh:mm format\ncurrent_time = input().strip()\n# Read the number of minutes to add\nminutes_to_add = int(input().strip())\n\n# Split the current time into hours and minutes\nhh, mm = map(int, current_time.split(':'))\n\n# Calculate the total minutes\ntotal_minutes = hh * 60 + mm + minutes_to_add\n\n# Calculate the new hours and minutes\nnew_hh = (total_minutes // 60) % 24\nnew_mm = total_minutes % 60\n\n# Print the result in hh:mm format with leading zeros\nprint(f\"{new_hh:02}:{new_mm:02}\")"}
{"solution": "def can_ignore_switch(n, m, matrix):\n    # Convert the input matrix from strings to a list of lists of integers\n    switches = [[int(char) for char in row] for row in matrix]\n    \n    # Check each switch to see if it can be ignored\n    for ignore in range(n):\n        # Create a set to track which lamps can be turned on\n        lamps_on = [0] * m\n        \n        # Press all switches except the one we are ignoring\n        for i in range(n):\n            if i != ignore:\n                for j in range(m):\n                    lamps_on[j] |= switches[i][j]\n        \n        # Check if all lamps are on\n        if all(lamps_on):\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nmatrix = [input().strip() for _ in range(n)]\n\n# Get the result and print it\nresult = can_ignore_switch(n, m, matrix)\nprint(result)"}
{"solution": "def min_rotations_to_even_sums(n, dominoes):\n    upper_sum = sum(x for x, y in dominoes)\n    lower_sum = sum(y for x, y in dominoes)\n\n    # Check if both sums are already even\n    if upper_sum % 2 == 0 and lower_sum % 2 == 0:\n        return 0\n\n    # Check if it's possible to make both sums even\n    odd_count = sum(1 for x, y in dominoes if (x + y) % 2 != 0)\n\n    # If both sums are odd, we need at least one rotation\n    if upper_sum % 2 != 0 and lower_sum % 2 != 0:\n        if odd_count > 0:\n            return 1\n        else:\n            return -1\n\n    # If one sum is odd and the other is even, we cannot fix it\n    return -1\n\n# Input reading\nn = int(input())\ndominoes = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = min_rotations_to_even_sums(n, dominoes)\nprint(result)"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    results = []\n    \n    for i in range(1, t + 1):\n        a, b = map(int, data[i].split())\n        area = a * a - b * b  # Calculate the area of the remaining cloth\n        if is_prime(area):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_remove_one_point(n, points):\n    positive_count = 0\n    negative_count = 0\n    \n    for x, y in points:\n        if x > 0:\n            positive_count += 1\n        else:\n            negative_count += 1\n    \n    if positive_count <= 1 or negative_count <= 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Reading input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_remove_one_point(n, points))"}
{"solution": "import math\n\n# Read input\nA, B = map(int, input().split())\n\n# The GCD of A! and B! is determined by the smaller of the two numbers\nmin_value = min(A, B)\n\n# Calculate the factorial of the minimum value\ngcd_factorial = math.factorial(min_value)\n\n# Print the result\nprint(gcd_factorial)"}
{"solution": "def is_composite(num):\n    if num < 4:  # The smallest composite number is 4\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return True\n    return False\n\ndef find_composite_pair(n):\n    # Start with a known composite number\n    a = 9  # 9 is composite\n    b = a - n\n    \n    # Ensure both a and b are composite\n    while not (is_composite(a) and is_composite(b)):\n        a += 1\n        b = a - n\n    \n    return a, b\n\nn = int(input())\na, b = find_composite_pair(n)\nprint(a, b)"}
{"solution": "import sys\nimport heapq\n\ndef max_score(N, M, P, edges):\n    graph = [[] for _ in range(N + 1)]\n    \n    for A, B, C in edges:\n        graph[A].append((B, C))\n    \n    # Dijkstra's algorithm to find the maximum coins collected at each vertex\n    max_coins = [-float('inf')] * (N + 1)\n    max_coins[1] = 0\n    pq = [(-max_coins[1], 1)]  # (negative coins, vertex)\n    \n    while pq:\n        current_coins, u = heapq.heappop(pq)\n        current_coins = -current_coins\n        \n        for v, coins in graph[u]:\n            new_coins = current_coins + coins\n            if new_coins > max_coins[v]:\n                max_coins[v] = new_coins\n                heapq.heappush(pq, (-new_coins, v))\n    \n    # Now calculate the maximum score at vertex N\n    max_score = -1\n    for t in range(1, N + 1):\n        if max_coins[N] >= t * P:\n            score = max_coins[N] - t * P\n            max_score = max(max_score, score)\n    \n    return max_score if max_score != -1 else -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N, M, P = map(int, data[0].split())\n    edges = []\n    \n    for i in range(1, M + 1):\n        A, B, C = map(int, data[i].split())\n        edges.append((A, B, C))\n    \n    result = max_score(N, M, P, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef min_cost_to_form_palindrome(n, strings_costs):\n    from collections import defaultdict\n\n    cost_map = defaultdict(lambda: float('inf'))\n    used_pairs = set()\n    total_cost = 0\n\n    for s, c in strings_costs:\n        if is_palindrome(s):\n            cost_map[s] = min(cost_map[s], c)\n        \n        rev_s = s[::-1]\n        if rev_s in cost_map:\n            used_pairs.add((s, rev_s))\n            total_cost += c + cost_map[rev_s]\n\n    min_cost = float('inf')\n    for s, c in strings_costs:\n        if is_palindrome(s):\n            min_cost = min(min_cost, c)\n\n    if total_cost == 0 and min_cost == float('inf'):\n        return -1\n\n    return min(total_cost, min_cost)\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().strip().splitlines()\n    n = int(data[0])\n    strings_costs = [line.split() for line in data[1:n+1]]\n    strings_costs = [(s, int(c)) for s, c in strings_costs]\n    \n    result = min_cost_to_form_palindrome(n, strings_costs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def largest_xor_sum(n, k):\n    # Find the number of bits in n\n    num_bits = n.bit_length()\n    # The largest possible xor-sum\n    max_xor_sum = (1 << num_bits) - 1\n    return max_xor_sum\n\n# Read input\nn, k = map(int, input().split())\n# Output the result\nprint(largest_xor_sum(n, k))"}
{"solution": "def minimum_triangle_side(n, points):\n    max_x = 0\n    max_y = 0\n    \n    for x, y in points:\n        max_x = max(max_x, x)\n        max_y = max(max_y, y)\n    \n    # The minimum length of the shorter side of the triangle\n    return max_x + max_y\n\n# Input reading\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nresult = minimum_triangle_side(n, points)\nprint(result)"}
{"solution": "def max_nineteens(s):\n    from collections import Counter\n    \n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # Define the required frequency of each character in the word \"nineteen\"\n    required_counts = {'n': 3, 'i': 1, 'e': 3, 't': 1}\n    \n    # Calculate the maximum number of \"nineteen\" words that can be formed\n    max_nineteens = float('inf')\n    for char, required in required_counts.items():\n        if char in char_count:\n            max_nineteens = min(max_nineteens, char_count[char] // required)\n        else:\n            return 0  # If any required character is missing, we can't form \"nineteen\"\n    \n    return max_nineteens\n\n# Read input\ns = input().strip()\n# Print the output\nprint(max_nineteens(s))"}
{"solution": "def highest_safe_branch(p, y):\n    # Start from the highest branch y and go downwards\n    for branch in range(y, p, -1):\n        # Check if branch is occupied by grasshoppers\n        if branch % 2 == 0 or branch <= p:\n            continue\n        \n        # Check if branch is reachable by any grasshopper\n        is_reachable = False\n        for i in range(2, int(branch**0.5) + 1):\n            if branch % i == 0:\n                if i <= p or (branch // i) <= p:\n                    is_reachable = True\n                    break\n        \n        if not is_reachable:\n            return branch\n    \n    return -1\n\n# Read input\np, y = map(int, input().split())\n# Get the result\nresult = highest_safe_branch(p, y)\n# Print the result\nprint(result)"}
{"solution": "def minimum_distance_to_affordable_house(n, m, k, prices):\n    min_distance = float('inf')\n    \n    for i in range(n):\n        if prices[i] != 0 and prices[i] <= k:  # Check if the house is unoccupied and affordable\n            distance = abs(m - (i + 1)) * 10  # Calculate distance in meters\n            min_distance = min(min_distance, distance)  # Update minimum distance\n    \n    return min_distance\n\n# Read input\nn, m, k = map(int, input().split())\nprices = list(map(int, input().split()))\n\n# Get the result and print it\nresult = minimum_distance_to_affordable_house(n, m, k, prices)\nprint(result)"}
{"solution": "def can_transform(n, m, A, B):\n    # Create a dictionary to count occurrences of each number in A and B\n    from collections import defaultdict\n    \n    count_A = defaultdict(int)\n    count_B = defaultdict(int)\n    \n    for i in range(n):\n        for j in range(m):\n            count_A[A[i][j]] += 1\n            count_B[B[i][j]] += 1\n    \n    # Compare the counts of each number in both matrices\n    if count_A == count_B:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nB = [list(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = can_transform(n, m, A, B)\nprint(result)"}
{"solution": "def longest_uncommon_subsequence(a: str, b: str) -> int:\n    if a == b:\n        return -1\n    return max(len(a), len(b))\n\n# Read input\na = input().strip()\nb = input().strip()\n\n# Get the result and print it\nresult = longest_uncommon_subsequence(a, b)\nprint(result)"}
{"solution": "def find_first_scream_time(a, b, c, d):\n    # We will use a set to track the scream times of Rick\n    rick_screams = set()\n    \n    # Calculate Rick's scream times\n    for i in range(10000):  # Arbitrarily large limit to ensure we cover enough time\n        rick_time = b + i * a\n        rick_screams.add(rick_time)\n    \n    # Check Morty's scream times against Rick's\n    for j in range(10000):  # Arbitrarily large limit to ensure we cover enough time\n        morty_time = d + j * c\n        if morty_time in rick_screams:\n            return morty_time\n    \n    return -1\n\n# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Get the result and print it\nresult = find_first_scream_time(a, b, c, d)\nprint(result)"}
{"solution": "n = int(input())\n\n# We can use a simple strategy based on the value of n modulo 3\nif n % 3 == 0:\n    # If n is divisible by 3, we can take (n//3 - 1, n//3 - 1, n//3 + 2)\n    a = n // 3 - 1\n    b = n // 3 - 1\n    c = n // 3 + 2\nelif n % 3 == 1:\n    # If n gives a remainder of 1 when divided by 3, we can take (n//3, n//3, n//3 + 1)\n    a = n // 3\n    b = n // 3\n    c = n // 3 + 1\nelse:  # n % 3 == 2\n    # If n gives a remainder of 2 when divided by 3, we can take (n//3, n//3 + 1, n//3 + 1)\n    a = n // 3\n    b = n // 3 + 1\n    c = n // 3 + 1\n\nprint(a, b, c)"}
{"solution": "def count_valid_squares(n, a, b, c, d):\n    # Calculate the sum of the top left 2x2 square\n    S = a + b + c + d\n    \n    # Initialize the count of valid squares\n    count = 0\n    \n    # Iterate through all possible values for the unknown cells\n    for x1 in range(1, n + 1):  # Top left cell\n        for x2 in range(1, n + 1):  # Top right cell\n            for x3 in range(1, n + 1):  # Bottom left cell\n                for x4 in range(1, n + 1):  # Bottom right cell\n                    # Check if the sums of the 2x2 squares are equal\n                    if (x1 + a + x2 + b == S and\n                        b + x3 + d + x4 == S and\n                        a + x2 + c + x4 == S and\n                        x1 + b + x3 + d == S):\n                        count += 1\n    \n    return count\n\n# Read input\nn, a, b, c, d = map(int, input().split())\n\n# Get the result\nresult = count_valid_squares(n, a, b, c, d)\n\n# Print the output\nprint(result)"}
{"solution": "def snowball_weight(w, h, u1, d1, u2, d2):\n    current_weight = w\n    current_height = h\n    \n    # Create a dictionary to store stone weights at their respective heights\n    stones = {d1: u1, d2: u2}\n    \n    while current_height > 0:\n        # Increase weight by the current height\n        current_weight += current_height\n        \n        # Check if there's a stone at the current height\n        if current_height in stones:\n            current_weight -= stones[current_height]\n            # Ensure weight does not go below zero\n            if current_weight < 0:\n                current_weight = 0\n        \n        # Move down one meter\n        current_height -= 1\n    \n    return current_weight\n\n# Read input\nw, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\n# Calculate and print the final weight of the snowball\nprint(snowball_weight(w, h, u1, d1, u2, d2))"}
{"solution": "def find_passing_rate(m, scores, x, y):\n    total_students = sum(scores)\n    \n    for k in range(1, m + 1):\n        beginner_group_size = sum(scores[:k])  # Students with scores < k\n        intermediate_group_size = total_students - beginner_group_size  # Students with scores >= k\n        \n        if x <= beginner_group_size <= y and x <= intermediate_group_size <= y:\n            return k  # Found a valid passing rate\n    \n    return 0  # No valid passing rate found\n\n# Input reading\nm = int(input().strip())\nscores = list(map(int, input().strip().split()))\nx, y = map(int, input().strip().split())\n\n# Finding and printing the passing rate\nresult = find_passing_rate(m, scores, x, y)\nprint(result)"}
{"solution": "def min_coins_to_one(n, k, A, B):\n    total_cost = 0\n    \n    while n > 1:\n        if k > 1 and n % k == 0:\n            # Calculate cost to divide\n            cost_to_divide = B\n            # Calculate cost to subtract to the next divisible number\n            next_divisible = (n // k) * k\n            cost_to_subtract = (n - next_divisible) * A\n            \n            if cost_to_divide < cost_to_subtract:\n                total_cost += cost_to_divide\n                n //= k\n            else:\n                total_cost += cost_to_subtract\n                n = next_divisible\n        else:\n            # If we can't divide, we must subtract\n            total_cost += (n - 1) * A\n            n = 1\n            \n    return total_cost\n\n# Input reading\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\n# Calculate and print the result\nresult = min_coins_to_one(n, k, A, B)\nprint(result)"}
{"solution": "import math\nfrom collections import deque\n\ndef min_value_and_operations(n):\n    # To store the minimum value and the number of operations\n    min_value = n\n    min_operations = 0\n    \n    # A queue for BFS\n    queue = deque([(n, 0)])  # (current value, operations count)\n    visited = set()  # To keep track of visited numbers\n    \n    while queue:\n        current, operations = queue.popleft()\n        \n        # Check if we can update the minimum value\n        if current < min_value:\n            min_value = current\n            min_operations = operations\n        elif current == min_value:\n            min_operations = min(min_operations, operations)\n        \n        # Perform sqrt operation if possible\n        if current > 1:\n            sqrt_value = int(math.isqrt(current))\n            if sqrt_value * sqrt_value == current and sqrt_value not in visited:\n                visited.add(sqrt_value)\n                queue.append((sqrt_value, operations + 1))\n        \n        # Perform multiplication operation with all factors of current\n        for i in range(1, int(math.sqrt(current)) + 1):\n            if current % i == 0:\n                # i is a factor\n                if i not in visited:\n                    visited.add(i)\n                    queue.append((i, operations + 1))\n                # current // i is also a factor\n                if current // i not in visited:\n                    visited.add(current // i)\n                    queue.append((current // i, operations + 1))\n    \n    return min_value, min_operations\n\n# Read input\nn = int(input().strip())\nresult = min_value_and_operations(n)\nprint(result[0], result[1])"}
{"solution": "def max_score(N, K, R, S, P, T):\n    # Initialize a DP array to store the maximum score up to each round\n    dp = [[0] * 3 for _ in range(N + 1)]\n    \n    # Mapping hands to indices\n    hand_index = {'r': 0, 's': 1, 'p': 2}\n    scores = [R, S, P]\n    \n    for i in range(1, N + 1):\n        for j in range(3):\n            # Determine the hand the machine plays in the current round\n            machine_hand = T[i - 1]\n            machine_index = hand_index[machine_hand]\n            \n            # Calculate the score for the current hand\n            current_score = scores[j] if j == (machine_index + 1) % 3 else 0\n            \n            # Update the DP table\n            dp[i][j] = dp[i - 1][j] + current_score\n            \n            # Check previous K rounds to avoid using the same hand\n            for k in range(1, K + 1):\n                if i - k > 0:\n                    for prev_hand in range(3):\n                        if prev_hand != j:  # Ensure we are not using the same hand as (i-K)th round\n                            dp[i][j] = max(dp[i][j], dp[i - k][prev_hand] + current_score)\n\n    # The answer is the maximum score possible after N rounds\n    return max(dp[N])\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN, K = map(int, data[0].split())\nR, S, P = map(int, data[1].split())\nT = data[2].strip()\n\n# Calculate and print the maximum score\nprint(max_score(N, K, R, S, P, T))"}
{"solution": "def max_good_string_length(a, b, c):\n    # Calculate the maximum length of the good string\n    # Each \"ab\" contributes 2 to the length\n    # The remaining \"a\" and \"b\" can be used to alternate\n    # The maximum pairs we can form from a and b\n    pairs = min(a, b)\n    \n    # Total length from pairs of \"ab\" and alternating \"a\" and \"b\"\n    total_length = c * 2 + pairs * 2\n    \n    # If there are remaining \"a\" or \"b\" after pairing\n    remaining_a = a - pairs\n    remaining_b = b - pairs\n    \n    # We can add one more character if we have any remaining\n    if remaining_a > 0 or remaining_b > 0:\n        total_length += 1\n    \n    return total_length\n\n# Input reading\na, b, c = map(int, input().split())\n# Output the result\nprint(max_good_string_length(a, b, c))"}
{"solution": "def determine_marks(n, k, p, x, y, marks):\n    current_sum = sum(marks)\n    remaining_tests = n - k\n    required_median_count = (n // 2) + 1  # To ensure the median is at least y\n\n    # Count how many marks are already >= y\n    count_y_or_more = sum(1 for mark in marks if mark >= y)\n\n    # If we need more marks >= y to satisfy the median condition\n    if count_y_or_more < required_median_count:\n        needed = required_median_count - count_y_or_more\n        # We can use y as the mark for the needed tests\n        marks_to_add = [y] * needed\n    else:\n        marks_to_add = []\n\n    # Fill the rest with the minimum mark (1) if needed\n    if len(marks_to_add) < remaining_tests:\n        marks_to_add += [1] * (remaining_tests - len(marks_to_add))\n\n    # Calculate the new total sum\n    new_sum = current_sum + sum(marks_to_add)\n\n    # Check if the new sum exceeds x\n    if new_sum > x:\n        return -1\n\n    return marks_to_add\n\n# Read input\nn, k, p, x, y = map(int, input().split())\nif k > 0:\n    marks = list(map(int, input().split()))\nelse:\n    marks = []\n\n# Determine the marks Vova should get\nresult = determine_marks(n, k, p, x, y, marks)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def is_berlanese(word):\n    vowels = {'a', 'o', 'u', 'i', 'e'}\n    length = len(word)\n\n    for i in range(length):\n        if word[i] not in vowels:  # If it's a consonant\n            if word[i] != 'n':  # If it's not 'n'\n                if i + 1 >= length or word[i + 1] not in vowels:  # Check next character\n                    return \"NO\"\n    return \"YES\"\n\n# Read input\ns = input().strip()\n# Check if the word is Berlanese and print the result\nprint(is_berlanese(s))"}
{"solution": "def max_dominoes(n, m, edges):\n    from collections import defaultdict\n\n    # Create a graph representation\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Domino types\n    domino_types = [(i, j) for i in range(1, 7) for j in range(i, 7)]\n    domino_count = len(domino_types)\n\n    # To keep track of the maximum dominoes that can be placed\n    max_dominoes = 0\n\n    # Try to place dominoes on the edges\n    def backtrack(used_dominoes, edge_index, current_count):\n        nonlocal max_dominoes\n        if edge_index == m:\n            max_dominoes = max(max_dominoes, current_count)\n            return\n\n        a, b = edges[edge_index]\n        for i in range(domino_count):\n            if not used_dominoes[i]:\n                # Check if we can place this domino on the edge (a, b)\n                domino = domino_types[i]\n                if (domino[0] == domino[1] or (domino[0] != domino[1])):  # Valid placement\n                    # Mark this domino as used\n                    used_dominoes[i] = True\n                    # Recur to the next edge\n                    backtrack(used_dominoes, edge_index + 1, current_count + 1)\n                    # Backtrack\n                    used_dominoes[i] = False\n\n        # Try without placing a domino on this edge\n        backtrack(used_dominoes, edge_index + 1, current_count)\n\n    # Start backtracking\n    used_dominoes = [False] * domino_count\n    backtrack(used_dominoes, 0, 0)\n\n    return max_dominoes\n\n# Input reading\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output the result\nprint(max_dominoes(n, m, edges))"}
{"solution": "def max_points(n, m, prices, auction_indices):\n    # Convert auction indices from 1-based to 0-based\n    auction_indices = [index - 1 for index in auction_indices]\n    \n    # Separate auction and regular questions\n    auction_prices = [prices[i] for i in auction_indices]\n    regular_prices = [prices[i] for i in range(n) if i not in auction_indices]\n    \n    # Sort auction prices in descending order\n    auction_prices.sort(reverse=True)\n    \n    # Sort regular prices in descending order\n    regular_prices.sort(reverse=True)\n    \n    # Calculate the maximum points\n    total_points = 0\n    \n    # First, answer all auction questions\n    for price in auction_prices:\n        total_points += price * 2  # Correct answer gives points equal to price\n    \n    # Then, answer all regular questions\n    for price in regular_prices:\n        total_points += price  # Correct answer gives points equal to price\n    \n    return total_points\n\n# Read input\nn, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauction_indices = list(map(int, input().split()))\n\n# Calculate and print the maximum points\nresult = max_points(n, m, prices, auction_indices)\nprint(result)"}
{"solution": "def calculate_final_score(submission_times, wrong_submissions, successful_hacks, unsuccessful_hacks):\n    max_points = [500, 1000, 1500, 2000, 2500]\n    total_score = 0\n\n    for i in range(5):\n        x = max_points[i]\n        m = submission_times[i]\n        w = wrong_submissions[i]\n        \n        score_for_problem = max(0.3 * x, (1 - m / 250) * x - 50 * w)\n        total_score += score_for_problem\n\n    total_score += 100 * successful_hacks\n    total_score -= 50 * unsuccessful_hacks\n\n    return int(total_score)\n\n# Input reading\nsubmission_times = list(map(int, input().split()))\nwrong_submissions = list(map(int, input().split()))\nsuccessful_hacks, unsuccessful_hacks = map(int, input().split())\n\n# Calculate and print the final score\nfinal_score = calculate_final_score(submission_times, wrong_submissions, successful_hacks, unsuccessful_hacks)\nprint(final_score)"}
{"solution": "def count_valid_grids(n, m, L, R):\n    MOD = 998244353\n    \n    # Total number of cells in the grid\n    total_cells = n * m\n    \n    # The minimum and maximum possible sum of cubes in the grid\n    min_sum = total_cells * L\n    max_sum = total_cells * R\n    \n    # The number of valid total sums that can be achieved\n    valid_sums = max_sum - min_sum + 1\n    \n    # The answer is the number of valid total sums modulo MOD\n    return valid_sums % MOD\n\n# Read input\nn, m, L, R = map(int, input().split())\n\n# Calculate and print the result\nresult = count_valid_grids(n, m, L, R)\nprint(result)"}
{"solution": "def is_possible_to_make_increasing(n, m, matrix_a, matrix_b):\n    for i in range(n):\n        for j in range(m):\n            # Ensure that matrix_a[i][j] is the smaller or equal element\n            if matrix_a[i][j] > matrix_b[i][j]:\n                matrix_a[i][j], matrix_b[i][j] = matrix_b[i][j], matrix_a[i][j]\n    \n    # Check rows for strictly increasing property\n    for i in range(n):\n        for j in range(1, m):\n            if matrix_a[i][j] <= matrix_a[i][j-1] or matrix_b[i][j] <= matrix_b[i][j-1]:\n                return \"Impossible\"\n    \n    # Check columns for strictly increasing property\n    for j in range(m):\n        for i in range(1, n):\n            if matrix_a[i][j] <= matrix_a[i-1][j] or matrix_b[i][j] <= matrix_b[i-1][j]:\n                return \"Impossible\"\n    \n    return \"Possible\"\n\n# Read input\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\nmatrix_b = [list(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = is_possible_to_make_increasing(n, m, matrix_a, matrix_b)\nprint(result)"}
{"solution": "def max_length_string(n, a):\n    # Sort the occurrences in descending order\n    a.sort(reverse=True)\n    \n    # To keep track of the maximum length of the string\n    max_length = 0\n    # To keep track of the last used occurrence count\n    last_used = float('inf')\n    \n    for count in a:\n        # We can use the minimum of the current count and the last used count - 1\n        if last_used > 0:\n            used_count = min(count, last_used)\n            max_length += used_count\n            last_used = used_count  # Update last_used for the next iteration\n        else:\n            break  # No more distinct counts can be used\n    \n    return max_length\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_length_string(n, a))"}
{"solution": "def min_problems_to_solve(n, k, difficulties):\n    difficulties.sort()\n    count = 0\n    \n    for difficulty in difficulties:\n        while k < (difficulty + 1) // 2:\n            k *= 2\n            count += 1\n        k = max(k, difficulty)\n    \n    return count\n\n# Read input\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = min_problems_to_solve(n, k, difficulties)\nprint(result)"}
{"solution": "def distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3):\n    # Start with the minimum required diplomas\n    d1 = min_1\n    d2 = min_2\n    d3 = min_3\n    \n    # Calculate the remaining diplomas to distribute\n    remaining = n - (d1 + d2 + d3)\n    \n    # Try to maximize the first degree diplomas\n    if remaining > 0:\n        additional_d1 = min(max_1 - d1, remaining)\n        d1 += additional_d1\n        remaining -= additional_d1\n    \n    # Try to maximize the second degree diplomas\n    if remaining > 0:\n        additional_d2 = min(max_2 - d2, remaining)\n        d2 += additional_d2\n        remaining -= additional_d2\n    \n    # The rest goes to the third degree diplomas\n    d3 += remaining\n    \n    # Return the result\n    return d1, d2, d3\n\n# Read input\nn = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\n# Get the optimal distribution\nresult = distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3)\n\n# Print the result\nprint(result[0], result[1], result[2])"}
{"solution": "def predict_moon_phase(n, sizes):\n    last_size = sizes[-1]\n    \n    if n == 1:\n        # If there's only one observation, we cannot determine the next phase\n        return -1\n    \n    # Check the trend of the last few days\n    if sizes[-1] > sizes[-2]:\n        # If the last size is greater than the second last, it is increasing\n        if last_size == 15:\n            return \"DOWN\"  # It will go back to 14\n        else:\n            return \"UP\"  # It will continue to increase\n    elif sizes[-1] < sizes[-2]:\n        # If the last size is less than the second last, it is decreasing\n        if last_size == 0:\n            return \"UP\"  # It will go back to 1\n        else:\n            return \"DOWN\"  # It will continue to decrease\n    else:\n        # If the last two sizes are equal, we cannot determine the next phase\n        return -1\n\n# Input reading\nn = int(input())\nsizes = list(map(int, input().split()))\n\n# Output the prediction\nprint(predict_moon_phase(n, sizes))"}
{"solution": "def can_transform(s, t):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    # Check if lengths are the same\n    if len(s) != len(t):\n        return \"No\"\n    \n    # Check each character\n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels) != (char_t in vowels):\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(can_transform(s, t))"}
{"solution": "def pawn_chess_winner(board):\n    # Initialize the minimum steps for both players\n    min_steps_A = float('inf')\n    min_steps_B = float('inf')\n\n    # Calculate the minimum steps for player A (white pawns)\n    for r in range(8):\n        for c in range(8):\n            if board[r][c] == 'W':\n                # Calculate how many steps it takes for this pawn to reach row 1\n                steps = r\n                min_steps_A = min(min_steps_A, steps)\n\n    # Calculate the minimum steps for player B (black pawns)\n    for r in range(8):\n        for c in range(8):\n            if board[r][c] == 'B':\n                # Calculate how many steps it takes for this pawn to reach row 8\n                steps = 7 - r\n                min_steps_B = min(min_steps_B, steps)\n\n    # Determine the winner based on the minimum steps\n    if min_steps_A <= min_steps_B:\n        return 'A'\n    else:\n        return 'B'\n\n# Read the board input\nboard = [input().strip() for _ in range(8)]\n\n# Get the winner and print the result\nwinner = pawn_chess_winner(board)\nprint(winner)"}
{"solution": "def max_equal_length(n, A, m, B):\n    if sum(A) != sum(B):\n        return -1\n    \n    i, j = 0, 0\n    sumA, sumB = 0, 0\n    count = 0\n    \n    while i < n and j < m:\n        sumA += A[i]\n        sumB += B[j]\n        \n        if sumA == sumB:\n            count += 1\n            sumA = 0\n            sumB = 0\n            i += 1\n            j += 1\n        elif sumA < sumB:\n            i += 1\n        else:\n            j += 1\n    \n    return count\n\n# Input reading\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\n# Output the result\nprint(max_equal_length(n, A, m, B))"}
{"solution": "def is_problem_from_contest(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    count = 0\n    \n    for friend in friends:\n        count += problem_name.count(friend)\n    \n    return \"YES\" if count == 1 else \"NO\"\n\n# Read input\nproblem_name = input().strip()\n# Output the result\nprint(is_problem_from_contest(problem_name))"}
{"solution": "def sieve(n):\n    is_prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (is_prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n    is_prime[0], is_prime[1] = False, False  # 0 and 1 are not primes\n    return is_prime\n\ndef count_primes_in_range(is_prime, a, b):\n    prime_count = [0] * (b + 1)\n    for i in range(a, b + 1):\n        prime_count[i] = prime_count[i - 1] + (1 if is_prime[i] else 0)\n    return prime_count\n\ndef min_length_with_k_primes(a, b, k):\n    is_prime = sieve(b)\n    prime_count = count_primes_in_range(is_prime, a, b)\n    \n    def has_k_primes_in_length(l):\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] >= k:\n                return True\n        return False\n    \n    left, right = 1, b - a + 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if has_k_primes_in_length(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\n# Input\na, b, k = map(int, input().split())\n\n# Output\nprint(min_length_with_k_primes(a, b, k))"}
{"solution": "def minimum_x(a, h, w):\n    # Check if it's possible to place at least one photo\n    if a > h or a > w:\n        return -1\n    \n    # Calculate the maximum number of photos that can fit in height and width\n    max_rows = h // a\n    max_cols = w // a\n    \n    # If no photos can fit, return -1\n    if max_rows == 0 or max_cols == 0:\n        return -1\n    \n    # Calculate the remaining space after placing the photos\n    remaining_height = h - (max_rows * a)\n    remaining_width = w - (max_cols * a)\n    \n    # Calculate the minimum distance x\n    x_height = remaining_height / (max_rows + 1)\n    x_width = remaining_width / (max_cols + 1)\n    \n    # The minimum x is the minimum of the two calculated distances\n    min_x = min(x_height, x_width)\n    \n    return min_x\n\n# Input reading\na, h, w = map(int, input().split())\nresult = minimum_x(a, h, w)\n\n# Output the result\nprint(f\"{result:.10f}\" if result != -1 else -1)"}
{"solution": "# Read the number of chapters\nn = int(input())\n\n# Initialize a list to store the chapters' page ranges\nchapters = []\n\n# Read each chapter's page range\nfor _ in range(n):\n    l, r = map(int, input().split())\n    chapters.append((l, r))\n\n# Read the marked page number\nk = int(input())\n\n# Initialize a counter for unread chapters\nunread_chapters = 0\n\n# Determine the number of unread chapters\nfor l, r in chapters:\n    if k <= r:  # If the marked page is within the current chapter\n        unread_chapters += 1  # Count this chapter as unread\n    # If k is greater than r, we can stop checking further chapters\n    else:\n        break\n\n# Print the result\nprint(unread_chapters)"}
{"solution": "def can_form_codeforces(word):\n    target = \"CODEFORCES\"\n    n = len(word)\n    m = len(target)\n    \n    if n < m:\n        return \"NO\"\n    \n    for i in range(m + 1):\n        if word[:i] == target[:i] and word[n - (m - i):] == target[i:]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nword = input().strip()\n# Print the result\nprint(can_form_codeforces(word))"}
{"solution": "def min_weight_triangulation(n):\n    # Create a DP table to store the minimum weights\n    dp = [[0] * n for _ in range(n)]\n    \n    # Fill the DP table\n    for length in range(2, n):  # length of the triangle base\n        for i in range(n - length):  # starting point of the triangle\n            j = i + length  # ending point of the triangle\n            dp[i][j] = float('inf')  # Initialize to infinity\n            \n            # Try every possible vertex k to form a triangle (i, k, j)\n            for k in range(i + 1, j):\n                weight = dp[i][k] + dp[k][j] + (i + 1) * (k + 1) * (j + 1)\n                dp[i][j] = min(dp[i][j], weight)\n    \n    return dp[0][n - 1]\n\n# Read input\nn = int(input())\n# Calculate and print the minimum weight\nprint(min_weight_triangulation(n))"}
{"solution": "def count_digits(n):\n    total_digits = 0\n    length = 1\n    current_range_start = 1\n    \n    while current_range_start <= n:\n        current_range_end = min(n, current_range_start * 10 - 1)\n        count_of_numbers = current_range_end - current_range_start + 1\n        total_digits += count_of_numbers * length\n        \n        length += 1\n        current_range_start *= 10\n    \n    return total_digits\n\nn = int(input())\nprint(count_digits(n))"}
{"solution": "def find_winning_color(n, A, colors):\n    count_A = 0\n    color_count = {}\n    \n    # Count occurrences of each color and track Alice's color count\n    for color in colors:\n        if color == A:\n            count_A += 1\n        else:\n            if color not in color_count:\n                color_count[color] = 0\n            color_count[color] += 1\n    \n    # Check for a color B that can win against A\n    for B, count_B in color_count.items():\n        if count_B >= count_A:\n            # Check if B can maintain the winning condition\n            cnt_A = 0\n            cnt_B = 0\n            can_win = True\n            \n            for color in colors:\n                if color == A:\n                    cnt_A += 1\n                elif color == B:\n                    cnt_B += 1\n                \n                if cnt_B < cnt_A:\n                    can_win = False\n                    break\n            \n            if can_win:\n                return B\n    \n    return -1\n\n# Input reading\nn, A = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Finding the winning color\nresult = find_winning_color(n, A, colors)\n\n# Output the result\nprint(result)"}
{"solution": "def can_form_unique_crossword(n, x, segments):\n    total_length = sum(segments)  # Total length of segments of 1's\n    gaps = n - 1  # Number of gaps between segments of 1's\n\n    # Calculate the minimum required length\n    min_required_length = total_length + gaps\n\n    # Check if the total length matches the required length\n    return min_required_length == x\n\n# Read input\nn, x = map(int, input().split())\nsegments = list(map(int, input().split()))\n\n# Determine if there is exactly one crossword\nif can_form_unique_crossword(n, x, segments):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_coins(n, S):\n    # The maximum coin value we can use is n\n    # To minimize the number of coins, we should use the largest coin value as much as possible\n    return (S + n - 1) // n  # This is equivalent to ceil(S / n)\n\n# Read input\nn, S = map(int, input().split())\n# Calculate and print the result\nprint(min_coins(n, S))"}
{"solution": "def smallest_palindrome(s):\n    from collections import Counter\n\n    # Count the frequency of each character\n    freq = Counter(s)\n    \n    # Prepare to build the first half of the palindrome\n    half_palindrome = []\n    middle_char = ''\n    \n    # Create the first half of the palindrome\n    for char in sorted(freq.keys()):\n        count = freq[char]\n        # Add half of the characters to the half_palindrome\n        half_palindrome.append(char * (count // 2))\n        # If there's an odd count, consider this character for the middle\n        if count % 2 == 1:\n            if middle_char == '' or char < middle_char:\n                middle_char = char\n    \n    # Join the first half\n    first_half = ''.join(half_palindrome)\n    # Create the full palindrome\n    if middle_char:\n        palindrome = first_half + middle_char + first_half[::-1]\n    else:\n        palindrome = first_half + first_half[::-1]\n    \n    return palindrome\n\n# Read input\ns = input().strip()\n# Get the result\nresult = smallest_palindrome(s)\n# Print the result\nprint(result)"}
{"solution": "def calculate_weight(board):\n    piece_weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n    }\n    \n    white_weight = 0\n    black_weight = 0\n    \n    for row in board:\n        for piece in row:\n            if piece in piece_weights:\n                if piece.isupper():\n                    white_weight += piece_weights[piece]\n                else:\n                    black_weight += piece_weights[piece]\n    \n    if white_weight > black_weight:\n        return \"White\"\n    elif black_weight > white_weight:\n        return \"Black\"\n    else:\n        return \"Draw\"\n\n# Read the board input\nboard = [input().strip() for _ in range(8)]\nprint(calculate_weight(board))"}
{"solution": "from collections import deque\n\ndef sugoroku(N, M, S):\n    # BFS setup\n    queue = deque([(0, [])])  # (current square, path taken)\n    visited = [False] * (N + 1)\n    visited[0] = True\n    result = None\n\n    while queue:\n        current_square, path = queue.popleft()\n\n        # If we reached the last square\n        if current_square == N:\n            if result is None or len(path) < len(result) or (len(path) == len(result) and path < result):\n                result = path\n            continue\n\n        # Try all possible moves from 1 to M\n        for move in range(1, M + 1):\n            next_square = current_square + move\n            if next_square <= N and S[next_square] == '0' and not visited[next_square]:\n                visited[next_square] = True\n                queue.append((next_square, path + [move]))\n\n    if result is None:\n        print(-1)\n    else:\n        print(\" \".join(map(str, result)))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nS = data[2]\n\nsugoroku(N, M, S)"}
{"solution": "def can_finish_game(K, X, Y):\n    # Calculate the Manhattan distance from the origin to the target point\n    manhattan_distance = abs(X) + abs(Y)\n    \n    # Check if the game can be finished\n    if manhattan_distance % K != 0 or manhattan_distance < K:\n        return -1\n    \n    # Calculate the number of strokes needed\n    strokes = manhattan_distance // K\n    \n    # If the number of strokes is odd and the distance is even or vice versa, we need to adjust\n    if (strokes % 2) != (manhattan_distance % K == 0):\n        strokes += 1\n    \n    # Prepare the path\n    path = []\n    current_x, current_y = 0, 0\n    \n    for _ in range(strokes):\n        if abs(current_x - X) + abs(current_y - Y) >= K:\n            # Move towards the target\n            if abs(X - current_x) >= K:\n                current_x += K if X > current_x else -K\n            else:\n                current_x = X\n            \n            if abs(Y - current_y) >= K:\n                current_y += K if Y > current_y else -K\n            else:\n                current_y = Y\n        else:\n            # Move in a direction that maintains the distance\n            if current_x < X:\n                current_x += K\n            elif current_x > X:\n                current_x -= K\n            elif current_y < Y:\n                current_y += K\n            elif current_y > Y:\n                current_y -= K\n        \n        path.append((current_x, current_y))\n    \n    return strokes, path\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nK = int(data[0])\nX = int(data[1])\nY = int(data[2])\n\n# Get the result\nresult = can_finish_game(K, X, Y)\n\n# Print the output\nif result == -1:\n    print(-1)\nelse:\n    strokes, path = result\n    print(strokes)\n    for x, y in path:\n        print(x, y)"}
{"solution": "def find_minimum_n(m):\n    # To find the smallest n such that the number of ways to steal chocolates is exactly m\n    # We will iterate over possible values of a (the first thief's chocolates)\n    # and calculate the number of ways for each a until we find the correct m or exceed it.\n\n    ways = 0\n    n = float('inf')\n\n    # Iterate over possible values of a (the first thief's chocolates)\n    for a in range(1, int(1e6)):  # We can limit the range based on practical constraints\n        # Calculate the maximum value of k that keeps the total chocolates <= n\n        # The total chocolates taken by the thieves is a * (1 + k + k^2 + k^3)\n        # This is a geometric series, which sums to a * (k^4 - 1) / (k - 1)\n        # We need to find k such that this sum is <= n\n        \n        total_chocolates = a\n        k = 1\n        while True:\n            k += 1\n            total_chocolates = a * (k**4 - 1) // (k - 1)\n            if total_chocolates > n:\n                break\n            \n            # Check if the number of ways matches m\n            if total_chocolates <= n:\n                ways += 1\n                if ways == m:\n                    n = min(n, total_chocolates)\n\n    return n if n != float('inf') else -1\n\n# Read input\nm = int(input().strip())\n# Get the result\nresult = find_minimum_n(m)\n# Print the output\nprint(result)"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    # Calculate the distance between the centers of the circles\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\n    # No intersection\n    if d >= r1 + r2:\n        return 0.0\n    # One circle is completely inside the other\n    elif d <= abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n\n    # Calculate the area of intersection\n    r1_sq = r1 ** 2\n    r2_sq = r2 ** 2\n\n    # Calculate the angles for the circular segments\n    angle1 = 2 * math.acos((d ** 2 + r1_sq - r2_sq) / (2 * d * r1))\n    angle2 = 2 * math.acos((d ** 2 + r2_sq - r1_sq) / (2 * d * r2))\n\n    # Calculate the area of the circular segments\n    area1 = 0.5 * r1_sq * (angle1 - math.sin(angle1))\n    area2 = 0.5 * r2_sq * (angle2 - math.sin(angle2))\n\n    # Total area of intersection\n    return area1 + area2\n\n# Input reading\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\n# Calculate and print the area of intersection\narea = circle_intersection_area(x1, y1, r1, x2, y2, r2)\nprint(f\"{area:.20f}\")"}
{"solution": "def minimize_n(v):\n    # If v is 1, the minimum value of n is already 1\n    if v == 1:\n        return 1\n    \n    # The minimum value of n can always be reduced to 1\n    return 1\n\n# Read input\nv = int(input().strip())\n# Output the result\nprint(minimize_n(v))"}
{"solution": "def main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    p = list(map(int, data[1:n]))  # p_2 to p_n\n    a = list(map(int, data[n:]))    # a_1 to a_n\n\n    # Create a tree structure\n    tree = defaultdict(list)\n    for i in range(2, n + 1):\n        tree[p[i - 2]].append(i)\n\n    # To store the maximum citizens that can be caught\n    citizens_caught = [0] * (n + 1)\n\n    # DFS function to calculate the maximum citizens caught\n    def dfs(node):\n        total_citizens = a[node - 1]  # citizens in the current square\n        for child in tree[node]:\n            total_citizens += dfs(child)\n        citizens_caught[node] = total_citizens\n        return total_citizens\n\n    # Start DFS from the main square (1)\n    dfs(1)\n\n    # The bandit will catch the maximum citizens from the last square\n    # which is the sum of all citizens in the subtree rooted at node 1\n    print(citizens_caught[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_typo_words(n, S, T):\n    count = 0\n    \n    # Check for each position in the words\n    for i in range(n):\n        # Check if characters before and after the current index are the same\n        if S[i] == T[i]:\n            continue\n        \n        # If characters are different, we can form a word W by inserting either S[i] or T[i]\n        # at the current position in both S and T\n        count += 1\n    \n    # We can also form W by adding a character at the end of either S or T\n    count += 1  # For the case where we add a character at the end\n    \n    return count\n\n# Input reading\nn = int(input())\nS = input().strip()\nT = input().strip()\n\n# Output the result\nprint(count_typo_words(n, S, T))"}
{"solution": "def min_computer_strength(n, strengths, connections):\n    from collections import defaultdict, deque\n\n    # Create an adjacency list for the banks\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Initialize the maximum strength needed\n    max_strength = max(strengths)\n\n    # BFS to determine the minimum strength required\n    visited = [False] * (n + 1)\n    queue = deque()\n    \n    # Start from the bank with the maximum strength\n    for i in range(1, n + 1):\n        if strengths[i - 1] == max_strength:\n            queue.append(i)\n            visited[i] = True\n\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                # Increase the strength of the neighbor bank\n                strengths[neighbor - 1] += 1\n                # If the new strength is greater than the current max_strength, update it\n                max_strength = max(max_strength, strengths[neighbor - 1])\n                queue.append(neighbor)\n\n    return max_strength\n\n# Input reading\nn = int(input())\nstrengths = list(map(int, input().split()))\nconnections = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Output the result\nprint(min_computer_strength(n, strengths, connections))"}
{"solution": "def max_groups(n, m):\n    if m == 0:\n        return 1\n    elif m >= n:\n        return 0\n    else:\n        return min(m, n - m)\n\n# Read input\nn, m = map(int, input().split())\n# Print the result\nprint(max_groups(n, m))"}
{"solution": "k, r = map(int, input().split())\n\nfor n in range(1, 11):\n    total_cost = n * k\n    if total_cost % 10 == 0 or total_cost % 10 == r:\n        print(n)\n        break"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # Dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Check if the bounding box is filled with 'X'\n    for i in range(min_row, max_row + 1):\n        for j in range(min_col, max_col + 1):\n            if grid[i][j] != 'X':\n                return \"NO\"\n    \n    # Check if we can form a rectangle\n    if (height * 2 == n and width <= m) or (width * 2 == m and height <= n):\n        return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "def min_segments(points):\n    x_coords = {point[0] for point in points}\n    y_coords = {point[1] for point in points}\n    \n    if len(x_coords) == 1 or len(y_coords) == 1:\n        return 1\n    elif len(x_coords) == 2 or len(y_coords) == 2:\n        return 2\n    else:\n        return 3\n\n# Read input\npoints = [tuple(map(int, input().split())) for _ in range(3)]\n\n# Calculate and print the minimum number of segments\nprint(min_segments(points))"}
{"solution": "def construct_k_regular_graph(k):\n    if k == 1:\n        # For k = 1, we can only have 2 vertices connected by a single edge\n        print(\"YES\")\n        print(2, 1)\n        print(1, 2)\n        return\n    \n    if k % 2 == 1:\n        # If k is odd and greater than 1, it's impossible to create a k-regular graph with a bridge\n        print(\"NO\")\n        return\n    \n    # For even k >= 2, we can construct a k-regular graph with a bridge\n    n = k + 1  # Number of vertices\n    edges = []\n    \n    # Create a cycle of n vertices\n    for i in range(1, n + 1):\n        edges.append((i, (i % n) + 1))\n    \n    # Add k/2 additional edges to create a bridge\n    for i in range(1, k // 2 + 1):\n        edges.append((i, n))  # Connect first k/2 vertices to the last vertex\n    \n    m = len(edges)  # Number of edges\n    print(\"YES\")\n    print(n, m)\n    for a, b in edges:\n        print(a, b)\n\n# Read input\nk = int(input().strip())\nconstruct_k_regular_graph(k)"}
{"solution": "def count_occurrences(s, t, queries):\n    n = len(s)\n    m = len(t)\n    \n    # Precompute occurrences of t in s\n    occurrences = [0] * (n + 1)\n    \n    for i in range(n - m + 1):\n        if s[i:i + m] == t:\n            occurrences[i + 1] = 1\n    \n    # Create a prefix sum array for occurrences\n    for i in range(1, n + 1):\n        occurrences[i] += occurrences[i - 1]\n    \n    results = []\n    for l, r in queries:\n        # Calculate the number of occurrences of t in s[l-1:r]\n        count = occurrences[r - m + 1] - occurrences[l - 1] if r - m + 1 >= l else 0\n        results.append(count)\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, m, q = map(int, data[0].split())\ns = data[1]\nt = data[2]\nqueries = [tuple(map(int, line.split())) for line in data[3:]]\n\n# Get results\nresults = count_occurrences(s, t, queries)\n\n# Print results\nfor result in results:\n    print(result)"}
{"solution": "def count_paths(n, k, d):\n    MOD = 1000000007\n\n    # dp[i] will store the number of ways to reach weight i without the d constraint\n    dp = [0] * (n + 1)\n    # dp_with_d[i] will store the number of ways to reach weight i with at least one edge of weight >= d\n    dp_with_d = [0] * (n + 1)\n\n    # Base case: There's one way to reach weight 0 (by taking no edges)\n    dp[0] = 1\n\n    # Fill dp for paths without the d constraint\n    for weight in range(1, n + 1):\n        for edge_weight in range(1, k + 1):\n            if weight - edge_weight >= 0:\n                dp[weight] = (dp[weight] + dp[weight - edge_weight]) % MOD\n\n    # Fill dp_with_d for paths with at least one edge of weight >= d\n    for weight in range(1, n + 1):\n        for edge_weight in range(1, k + 1):\n            if weight - edge_weight >= 0:\n                dp_with_d[weight] = (dp_with_d[weight] + dp_with_d[weight - edge_weight]) % MOD\n                if edge_weight >= d:\n                    dp_with_d[weight] = (dp_with_d[weight] + dp[weight - edge_weight]) % MOD\n\n    return dp_with_d[n]\n\n# Read input\nn, k, d = map(int, input().split())\n# Get the result\nresult = count_paths(n, k, d)\n# Print the result\nprint(result)"}
{"solution": "def encrypt_japanese_crossword(n, row):\n    groups = []\n    count = 0\n    \n    for char in row:\n        if char == 'B':\n            count += 1\n        else:\n            if count > 0:\n                groups.append(count)\n                count = 0\n    \n    if count > 0:\n        groups.append(count)\n    \n    print(len(groups))\n    if groups:\n        print(\" \".join(map(str, groups)))\n\n# Input reading\nn = int(input())\nrow = input().strip()\nencrypt_japanese_crossword(n, row)"}
{"solution": "def polycarps_editor(n, m, p, brackets, operations):\n    # Convert the cursor position from 1-based to 0-based\n    cursor = p - 1\n    # Stack to find matching brackets\n    stack = []\n    # To store the index of matching brackets\n    match = [-1] * n\n    \n    # Fill the match array\n    for i in range(n):\n        if brackets[i] == '(':\n            stack.append(i)\n        else:\n            if stack:\n                opening_index = stack.pop()\n                match[opening_index] = i\n                match[i] = opening_index\n    \n    # Convert brackets to a list for mutability\n    brackets = list(brackets)\n    \n    for operation in operations:\n        if operation == 'L':\n            cursor -= 1\n        elif operation == 'R':\n            cursor += 1\n        elif operation == 'D':\n            # Get the matching bracket index\n            to_delete = match[cursor]\n            # Delete the substring from cursor to its matching bracket\n            if to_delete > cursor:\n                del brackets[cursor:to_delete + 1]\n            else:\n                del brackets[to_delete:cursor + 1]\n            # Update cursor position\n            if to_delete > cursor:\n                cursor = min(cursor, len(brackets) - 1)\n            else:\n                cursor = max(0, cursor - 1)\n    \n    # Join the remaining brackets to form the final sequence\n    return ''.join(brackets)\n\n# Read input\nn, m, p = map(int, input().split())\nbrackets = input().strip()\noperations = input().strip()\n\n# Get the result and print it\nresult = polycarps_editor(n, m, p, brackets, operations)\nprint(result)"}
{"solution": "def find_valid_y(n, queries):\n    lower_bound = -2 * 10**9\n    upper_bound = 2 * 10**9\n\n    for sign, x, answer in queries:\n        x = int(x)\n        if answer == 'Y':\n            if sign == '>':\n                lower_bound = max(lower_bound, x + 1)\n            elif sign == '<':\n                upper_bound = min(upper_bound, x - 1)\n            elif sign == '>=':\n                lower_bound = max(lower_bound, x)\n            elif sign == '<=':\n                upper_bound = min(upper_bound, x)\n        else:  # answer == 'N'\n            if sign == '>':\n                upper_bound = min(upper_bound, x)\n            elif sign == '<':\n                lower_bound = max(lower_bound, x)\n            elif sign == '>=':\n                upper_bound = min(upper_bound, x - 1)\n            elif sign == '<=':\n                lower_bound = max(lower_bound, x + 1)\n\n    if lower_bound <= upper_bound:\n        return lower_bound\n    else:\n        return \"Impossible\"\n\n# Read input\nn = int(input())\nqueries = [input().split() for _ in range(n)]\n\n# Get the result\nresult = find_valid_y(n, queries)\n\n# Print the result\nprint(result)"}
{"solution": "def count_different_periods(a, b):\n    # The total length of the string\n    total_length = a + b\n    \n    # The number of different periods is determined by the divisors of total_length\n    # that can be formed by the counts of 'A' and 'B'\n    periods = set()\n    \n    # Check all possible periods from 1 to total_length\n    for k in range(1, total_length + 1):\n        if total_length % k == 0:\n            # Check if we can form a valid string with period k\n            # The number of full cycles of period k\n            cycles = total_length // k\n            \n            # The maximum number of 'A's we can fit in k positions\n            max_A_in_period = min(a, k)\n            # The maximum number of 'B's we can fit in k positions\n            max_B_in_period = min(b, k)\n            \n            # We need to check if we can distribute 'A's and 'B's in cycles\n            if (max_A_in_period * cycles >= a) and (max_B_in_period * cycles >= b):\n                periods.add(k)\n    \n    return len(periods)\n\n# Read input\na, b = map(int, input().split())\n# Calculate and print the number of different periods\nprint(count_different_periods(a, b))"}
{"solution": "def generate_soldier_names(n, k, conditions):\n    # Predefined list of unique names\n    names = [\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Edward\", \"Frank\", \"George\", \"Henry\", \"Isaac\", \"Jack\"]\n    \n    # Initialize the result list with the first k names\n    result = [\"\"] * n\n    \n    # Fill the first k names based on the first condition\n    for i in range(k):\n        result[i] = names[i]\n    \n    # Iterate through the conditions to fill the rest of the names\n    for i in range(1, n - k + 1):\n        if conditions[i - 1] == \"YES\":\n            # If the group should be effective, use a new unique name\n            result[i + k - 1] = names[k + (i - 1) % (len(names) - k)]\n        else:\n            # If the group should not be effective, repeat the last name\n            result[i + k - 1] = result[i + k - 2]\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\nconditions = input().split()\n\n# Generate names\nsoldier_names = generate_soldier_names(n, k, conditions)\n\n# Print the result\nprint(\" \".join(soldier_names))"}
{"solution": "def min_operations_to_equal(a, b):\n    def count_factors(n, factor):\n        count = 0\n        while n % factor == 0:\n            n //= factor\n            count += 1\n        return count, n\n\n    # Count the number of times we can divide by 2, 3, and 5\n    a2, a = count_factors(a, 2)\n    a3, a = count_factors(a, 3)\n    a5, a = count_factors(a, 5)\n    \n    b2, b = count_factors(b, 2)\n    b3, b = count_factors(b, 3)\n    b5, b = count_factors(b, 5)\n    \n    # If the remaining parts are not equal, return -1\n    if a != b:\n        return -1\n    \n    # Calculate the total number of operations needed\n    operations = abs(a2 - b2) + abs(a3 - b3) + abs(a5 - b5)\n    \n    return operations\n\n# Read input\na, b = map(int, input().split())\n# Print the result\nprint(min_operations_to_equal(a, b))"}
{"solution": "def min_cost_palindrome(n, a, b, suits):\n    total_cost = 0\n    for i in range(n // 2):\n        left = suits[i]\n        right = suits[n - 1 - i]\n        \n        if left == 2 and right == 2:\n            # Both suits need to be bought\n            total_cost += 2 * min(a, b)\n        elif left == 2:\n            # Buy suit for left dancer\n            total_cost += a if right == 0 else b\n        elif right == 2:\n            # Buy suit for right dancer\n            total_cost += a if left == 0 else b\n        elif left != right:\n            # Mismatched suits that cannot be changed\n            return -1\n    \n    # If n is odd, check the middle dancer\n    if n % 2 == 1:\n        middle = suits[n // 2]\n        if middle == 2:\n            total_cost += min(a, b)\n    \n    return total_cost\n\n# Read input\nn, a, b = map(int, input().split())\nsuits = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = min_cost_palindrome(n, a, b, suits)\nprint(result)"}
{"solution": "def paint_cube(k):\n    if k == 1:\n        return -1\n    \n    # Create a k x k x k cube initialized with empty strings\n    cube = [[['' for _ in range(k)] for _ in range(k)] for _ in range(k)]\n    \n    # Fill the cube based on the layer index\n    for z in range(k):\n        for x in range(k):\n            for y in range(k):\n                if (x + y + z) % 2 == 0:\n                    cube[z][x][y] = 'b'  # Black cube\n                else:\n                    cube[z][x][y] = 'w'  # White cube\n    \n    return cube\n\ndef print_cube(cube):\n    for layer in cube:\n        for row in layer:\n            print(''.join(row))\n        print()  # Print an empty line between layers\n\nk = int(input().strip())\nresult = paint_cube(k)\n\nif result == -1:\n    print(-1)\nelse:\n    print_cube(result)"}
{"solution": "def largest_lovely_number(n):\n    import math\n    from collections import Counter\n\n    def prime_factors(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            while (n % i) == 0:\n                factors.append(i)\n                n //= i\n            i += 1\n        if n > 1:\n            factors.append(n)\n        return factors\n\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n    \n    lovely_number = 1\n    for prime in factor_counts:\n        lovely_number *= prime\n    \n    return lovely_number\n\nn = int(input())\nprint(largest_lovely_number(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    # Check for adjacent occupied seats\n    for i in range(n - 1):\n        if seating[i] == '1' and seating[i + 1] == '1':\n            return \"No\"\n    \n    # Check for possible additional seating\n    for i in range(n):\n        if seating[i] == '0':\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                return \"No\"\n    \n    return \"Yes\"\n\n# Input reading\nn = int(input())\nseating = input().strip()\nprint(is_maximal_seating(n, seating))"}
{"solution": "def find_possible_lengths(n, a):\n    possible_lengths = []\n\n    for k in range(1, n + 1):\n        valid = True\n        x = [0] * k\n        \n        for i in range(n):\n            # Calculate the index in x based on the current index in a\n            index = i % k\n            # Calculate the expected value of a[i] based on the previous value\n            expected_value = a[i] - (a[i - 1] if i > 0 else 0)\n            \n            if i > 0 and expected_value != x[index]:\n                # If we have already set a value for x[index], it must match\n                if x[index] != 0:\n                    valid = False\n                    break\n                x[index] = expected_value\n        \n        if valid:\n            possible_lengths.append(k)\n\n    return possible_lengths\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Find possible lengths\npossible_lengths = find_possible_lengths(n, a)\n\n# Print output\nprint(len(possible_lengths))\nprint(\" \".join(map(str, possible_lengths)))"}
{"solution": "from itertools import combinations\n\ndef can_form_equal_teams(scores):\n    total_score = sum(scores)\n    \n    # If total score is odd, we cannot split it into two equal parts\n    if total_score % 2 != 0:\n        return \"NO\"\n    \n    target_score = total_score // 2\n    \n    # Check all combinations of 3 participants\n    for team in combinations(scores, 3):\n        if sum(team) == target_score:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nscores = list(map(int, input().strip().split()))\n\n# Output the result\nprint(can_form_equal_teams(scores))"}
{"solution": "def count_2_3_integers(l, r):\n    count = 0\n    power_of_2 = 1\n    \n    while power_of_2 <= r:\n        power_of_3 = 1\n        while power_of_2 * power_of_3 <= r:\n            number = power_of_2 * power_of_3\n            if l <= number <= r:\n                count += 1\n            power_of_3 *= 3\n        power_of_2 *= 2\n    \n    return count\n\n# Read input\nl, r = map(int, input().split())\n# Get the count of 2-3-integers in the range [l, r]\nresult = count_2_3_integers(l, r)\n# Print the result\nprint(result)"}
{"solution": "def candies_eaten(n, k):\n    # The number of candies eaten can be calculated using the formula:\n    # eaten = (n - k) // 2\n    # This is derived from the fact that each time Alya puts candies, she puts one more than the last time,\n    # and for every candy eaten, the total number of actions decreases by 1.\n    \n    eaten = (n - k) // 2\n    return eaten\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(candies_eaten(n, k))"}
{"solution": "def can_form_triangle(n, lengths):\n    # Sort the lengths to easily apply the triangle inequality\n    lengths.sort()\n    \n    # Check for any three consecutive lengths in the sorted list\n    for i in range(n - 2):\n        if lengths[i] + lengths[i + 1] > lengths[i + 2]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn = int(input())\nlengths = list(map(int, input().split()))\n\n# Output the result\nprint(can_form_triangle(n, lengths))"}
{"solution": "def can_achieve_toys(x, y):\n    # The number of original toys must be at least 1 (the initial one)\n    if y < 1:\n        return \"No\"\n    \n    # The total number of original toys must be at least the number of copies\n    # because each original toy can only produce one copy at a time.\n    if y > x + 1:\n        return \"No\"\n    \n    # The number of copies must be even if we want to achieve them from original toys\n    # because each original toy can produce one copy and each copy can produce two copies.\n    if (x - (y - 1)) % 2 != 0:\n        return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nx, y = map(int, input().split())\n# Print the result\nprint(can_achieve_toys(x, y))"}
{"solution": "def max_total_rating(n, k, skills):\n    # Calculate initial total rating\n    total_rating = sum(skill // 10 for skill in skills)\n    \n    # Create a list to store the units needed to reach the next multiple of 10\n    units_needed = []\n    \n    for skill in skills:\n        if skill < 100:\n            next_multiple_of_10 = (skill // 10 + 1) * 10\n            units_needed.append(next_multiple_of_10 - skill)\n    \n    # Sort the units needed in ascending order\n    units_needed.sort()\n    \n    # Use improvement units to increase skills\n    for units in units_needed:\n        if k >= units:\n            k -= units\n            total_rating += 1  # Each time we reach a new multiple of 10, we gain 1 rating\n        else:\n            break  # No more units can be used to increase further\n    \n    # Each skill at 100 contributes 10 to the rating\n    total_rating += (100 // 10) * (n - len(units_needed))  # Remaining skills at 100\n    \n    return total_rating\n\n# Input reading\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Calculate and print the maximum total rating\nprint(max_total_rating(n, k, skills))"}
{"solution": "def find_smallest_pretty_integer(n, m, list1, list2):\n    # Convert lists to sets for faster lookup\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check for common digits\n    common_digits = set1.intersection(set2)\n    if common_digits:\n        return min(common_digits)\n    \n    # If no common digits, find the smallest combination\n    min1 = min(list1)\n    min2 = min(list2)\n    \n    # Form the smallest two-digit number\n    smallest_pretty = min(int(str(min1) + str(min2)), int(str(min2) + str(min1)))\n    return smallest_pretty\n\n# Input reading\nn, m = map(int, input().split())\nlist1 = list(map(int, input().split()))\nlist2 = list(map(int, input().split()))\n\n# Output the result\nprint(find_smallest_pretty_integer(n, m, list1, list2))"}
{"solution": "def max_problems_solved(n, k):\n    total_time = 240 - k  # Total time available for solving problems\n    time_spent = 0\n    problems_solved = 0\n\n    for i in range(1, n + 1):\n        time_needed = 5 * i\n        if time_spent + time_needed <= total_time:\n            time_spent += time_needed\n            problems_solved += 1\n        else:\n            break\n\n    return problems_solved\n\n# Read input\nn, k = map(int, input().split())\n# Calculate and print the result\nprint(max_problems_solved(n, k))"}
{"solution": "def max_teams(n, x, y, a):\n    # \u0421\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u043c\u0430\u0441\u0441\u0438\u0432 a \u0432 \u043f\u043e\u0440\u044f\u0434\u043a\u0435 \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044f\n    a.sort()\n    \n    # \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0434\u043b\u044f \u043e\u0442\u0441\u043b\u0435\u0436\u0438\u0432\u0430\u043d\u0438\u044f \u043e\u0441\u0442\u0430\u0432\u0448\u0438\u0445\u0441\u044f \u043b\u0438\u0441\u0442\u043e\u0432\n    double_sided = x\n    single_sided = y\n    count = 0\n    \n    for pages in a:\n        # \u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c \u043b\u0438\u0441\u0442\u044b \u0441 \u0434\u0432\u0443\u043c\u044f \u0447\u0438\u0441\u0442\u044b\u043c\u0438 \u0441\u0442\u043e\u0440\u043e\u043d\u0430\u043c\u0438\n        double_needed = pages // 2\n        single_needed = pages % 2\n        \n        if double_needed <= double_sided:\n            double_sided -= double_needed\n            if single_needed <= single_sided:\n                single_sided -= single_needed\n                count += 1\n            else:\n                # \u0415\u0441\u043b\u0438 \u043d\u0435 \u0445\u0432\u0430\u0442\u0430\u0435\u0442 \u043b\u0438\u0441\u0442\u043e\u0432 \u0441 \u043e\u0434\u043d\u043e\u0439 \u0447\u0438\u0441\u0442\u043e\u0439 \u0441\u0442\u043e\u0440\u043e\u043d\u043e\u0439\n                double_sided += double_needed  # \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u043b\u0438\u0441\u0442\u044b\n                break\n        else:\n            # \u0415\u0441\u043b\u0438 \u043d\u0435 \u0445\u0432\u0430\u0442\u0430\u0435\u0442 \u043b\u0438\u0441\u0442\u043e\u0432 \u0441 \u0434\u0432\u0443\u043c\u044f \u0447\u0438\u0441\u0442\u044b\u043c\u0438 \u0441\u0442\u043e\u0440\u043e\u043d\u0430\u043c\u0438\n            remaining_pages = pages - 2 * double_sided\n            if remaining_pages <= single_sided:\n                single_sided -= remaining_pages\n                double_sided = 0\n                count += 1\n            else:\n                break\n    \n    return count\n\n# \u0427\u0442\u0435\u043d\u0438\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\n# \u0412\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\nprint(max_teams(n, x, y, a))"}
{"solution": "def count_distinct_values(b):\n    # To find the distinct values of (b / gcd(a, b)), we need to find the divisors of b.\n    divisors = set()\n    for i in range(1, int(b**0.5) + 1):\n        if b % i == 0:\n            divisors.add(i)\n            divisors.add(b // i)\n    return len(divisors)\n\n# Read input\nb = int(input().strip())\n\n# Calculate the number of distinct values\nresult = count_distinct_values(b)\n\n# Print the result\nprint(result)"}
{"solution": "def count_falling_positions(n, bumpers):\n    fall_count = 0\n    \n    # Check positions from the left\n    for i in range(n):\n        if bumpers[i] == '<':\n            fall_count += 1\n        else:\n            break\n    \n    # Check positions from the right\n    for i in range(n - 1, -1, -1):\n        if bumpers[i] == '>':\n            fall_count += 1\n        else:\n            break\n    \n    return fall_count\n\n# Input reading\nn = int(input().strip())\nbumpers = input().strip()\n\n# Calculate and print the result\nresult = count_falling_positions(n, bumpers)\nprint(result)"}
{"solution": "def max_rectangle_area(n, lengths):\n    from collections import Counter\n\n    # Count the occurrences of each length\n    count = Counter(lengths)\n    \n    # Prepare a list to store pairs of lengths that can form rectangles\n    pairs = []\n    \n    # Check for each length and its count\n    for length in sorted(count.keys()):\n        # Calculate how many pairs can be formed with the current length\n        pairs_count = count[length] // 2\n        if pairs_count > 0:\n            pairs.extend([length] * pairs_count)\n        \n        # Check if we can form pairs with the length reduced by 1\n        if length > 1:\n            reduced_length = length - 1\n            pairs_count = count[reduced_length] // 2\n            if pairs_count > 0:\n                pairs.extend([reduced_length] * pairs_count)\n\n    # Now we have a list of lengths that can form pairs\n    total_area = 0\n    # We can form rectangles from pairs of pairs\n    for i in range(0, len(pairs) - 1, 2):\n        total_area += pairs[i] * pairs[i + 1]\n\n    return total_area\n\n# Input reading\nn = int(input())\nlengths = list(map(int, input().split()))\n\n# Calculate and print the maximum total area\nprint(max_rectangle_area(n, lengths))"}
{"solution": "def min_sum_after_restoration(n, strings):\n    from collections import defaultdict\n\n    # To store the weight of each character\n    weight = defaultdict(int)\n    # To track which characters cannot be assigned to '0'\n    cannot_be_zero = set()\n\n    # Calculate the weight of each character based on its position\n    for s in strings:\n        length = len(s)\n        for i, char in enumerate(s):\n            # The weight is determined by the position (10^(length - i - 1))\n            weight[char] += 10 ** (length - i - 1)\n            # The first character of each string cannot be '0'\n            if i == 0:\n                cannot_be_zero.add(char)\n\n    # Sort characters by their weight in descending order\n    sorted_chars = sorted(weight.items(), key=lambda x: -x[1])\n\n    # Assign digits to characters\n    char_to_digit = {}\n    digit_used = set()\n    \n    # Assign the first character (highest weight) a non-zero digit\n    for char, _ in sorted_chars:\n        if char in cannot_be_zero:\n            # Assign the smallest non-zero digit (1)\n            for digit in range(1, 10):\n                if digit not in digit_used:\n                    char_to_digit[char] = digit\n                    digit_used.add(digit)\n                    break\n        else:\n            # Assign the smallest available digit\n            for digit in range(10):\n                if digit not in digit_used:\n                    char_to_digit[char] = digit\n                    digit_used.add(digit)\n                    break\n\n    # Calculate the minimum sum of restored numbers\n    total_sum = 0\n    for s in strings:\n        restored_number = int(''.join(str(char_to_digit[char]) for char in s))\n        total_sum += restored_number\n\n    return total_sum\n\n# Input reading\nn = int(input().strip())\nstrings = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(min_sum_after_restoration(n, strings))"}
{"solution": "def max_teams(n, m):\n    # The maximum number of teams is limited by the total number of participants divided by 3\n    max_possible_teams = (n + m) // 3\n    \n    # The actual number of teams cannot exceed the number of experienced participants or newbies\n    return min(max_possible_teams, n, m)\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    n = len(s)\n    \n    # Check for \"AB\" followed by \"BA\"\n    for i in range(n - 1):\n        if s[i:i+2] == \"AB\":\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"BA\":\n                    print(\"YES\")\n                    return\n    \n    # Check for \"BA\" followed by \"AB\"\n    for i in range(n - 1):\n        if s[i:i+2] == \"BA\":\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"AB\":\n                    print(\"YES\")\n                    return\n    \n    # If neither condition is met\n    print(\"NO\")\n\n# Read input\ns = input().strip()\ncheck_substrings(s)"}
{"solution": "def can_eat_monsters(n, a, k, b):\n    from collections import deque\n\n    # Initialize the queue with the initial weights\n    queue = deque(a)\n    actions = []\n\n    # Process the final weights in reverse order\n    for weight in reversed(b):\n        # Check if we can find a monster in the queue that can match the current weight\n        if not queue or weight > queue[-1]:\n            print(\"NO\")\n            return\n        \n        # Find the monster that can match the current weight\n        while queue and queue[-1] < weight:\n            # The last monster in the queue cannot eat, so we need to remove it\n            last_weight = queue.pop()\n            if queue and last_weight + queue[-1] > weight:\n                # If the last monster can eat the one before it\n                actions.append((len(queue) + 1, 'R'))  # +1 because we need 1-based index\n                queue[-1] += last_weight\n            else:\n                # If it cannot eat, we just remove it\n                continue\n        \n        if queue and queue[-1] == weight:\n            queue.pop()  # Remove the monster that matches the weight\n        else:\n            print(\"NO\")\n            return\n\n    # If we reach here, we have a valid sequence of actions\n    print(\"YES\")\n    for action in reversed(actions):\n        print(action[0], action[1])\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\nk = int(input().strip())\nb = list(map(int, input().strip().split()))\n\n# Call the function with the input values\ncan_eat_monsters(n, a, k, b)"}
{"solution": "def ccw(A, B, C):\n    return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])\n\ndef intersect(A, B, C, D):\n    return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D)\n\ndef can_assign_spaceships(R, B, spaceships, bases):\n    from itertools import permutations\n\n    for perm in permutations(range(B), R):\n        valid = True\n        for i in range(R):\n            for j in range(i + 1, R):\n                if intersect(spaceships[i], bases[perm[i]], spaceships[j], bases[perm[j]]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"Yes\"\n    return \"No\"\n\n# Read input\nR, B = map(int, input().split())\nspaceships = [tuple(map(int, input().split())) for _ in range(R)]\nbases = [tuple(map(int, input().split())) for _ in range(B)]\n\n# Output result\nprint(can_assign_spaceships(R, B, spaceships, bases))"}
{"solution": "def max_power_of_two_and_count(n, a):\n    max_power = 0\n    count = 0\n\n    for number in a:\n        current_power = 0\n        while number % 2 == 0:\n            number //= 2\n            current_power += 1\n        \n        if current_power > max_power:\n            max_power = current_power\n\n    # Count how many numbers are divisible by 2^max_power\n    for number in a:\n        if number % (2 ** max_power) == 0:\n            count += 1\n\n    return 2 ** max_power, count\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Function call and output\nresult = max_power_of_two_and_count(n, a)\nprint(result[0], result[1])"}
{"solution": "def min_clicks(n, m):\n    clicks = 0\n    \n    while n < m:\n        if m % 2 == 0:\n            m //= 2\n        else:\n            m += 1\n        clicks += 1\n    \n    return clicks + (n - m)\n\n# Read input\nn, m = map(int, input().split())\n# Calculate and print the result\nprint(min_clicks(n, m))"}
{"solution": "def is_tree(n, segments):\n    from collections import defaultdict, deque\n\n    # Create a graph using adjacency list\n    graph = defaultdict(list)\n\n    # Check for intersections and build the graph\n    for i in range(n):\n        l1, r1 = segments[i]\n        for j in range(i + 1, n):\n            l2, r2 = segments[j]\n            # Check if segments [l1, r1] and [l2, r2] intersect\n            if l1 < r2 and l2 < r1:  # They intersect\n                # Check if neither segment is fully inside the other\n                if not (l1 < l2 < r1 and l1 < r2 < r1) and not (l2 < l1 < r2 and l2 < r1 < r2):\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n    # Check if the graph is connected and has exactly n-1 edges\n    visited = [False] * n\n    edge_count = 0\n\n    def bfs(start):\n        nonlocal edge_count\n        queue = deque([start])\n        visited[start] = True\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                edge_count += 1\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n\n    # Start BFS from the first node\n    bfs(0)\n\n    # Each edge is counted twice in an undirected graph\n    edge_count //= 2\n\n    # A tree must have exactly n-1 edges and must be connected\n    if edge_count == n - 1 and all(visited):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(is_tree(n, segments))"}
{"solution": "def longest_ddos_period(n, requests):\n    max_length = 0\n\n    for start in range(n):\n        total_requests = 0\n        for end in range(start, n):\n            total_requests += requests[end]\n            time_period = end - start + 1\n            if total_requests > 100 * time_period:\n                max_length = max(max_length, time_period)\n\n    return max_length\n\n# Read input\nn = int(input())\nrequests = list(map(int, input().split()))\n\n# Get the result and print it\nresult = longest_ddos_period(n, requests)\nprint(result)"}
{"solution": "def can_achieve_dissatisfaction(n, k, episodes):\n    # Initialize variables to track the maximum dissatisfaction\n    max_dissatisfaction = 0\n    current_dissatisfaction = 0\n    \n    # Iterate through the episodes\n    for episode in episodes:\n        if episode == 'N':\n            current_dissatisfaction += 1\n        else:\n            # If we encounter 'Y' or '?', we check the current dissatisfaction\n            max_dissatisfaction = max(max_dissatisfaction, current_dissatisfaction)\n            current_dissatisfaction = 0\n    \n    # Final check for the last segment of 'N's\n    max_dissatisfaction = max(max_dissatisfaction, current_dissatisfaction)\n    \n    # Now we need to check if we can achieve exactly k dissatisfaction\n    if max_dissatisfaction < k:\n        return \"NO\"\n    \n    # Check if we can create exactly k dissatisfaction\n    # We can create dissatisfaction of k if we have enough '?' to fill gaps\n    if max_dissatisfaction == k:\n        return \"YES\"\n    \n    # If max_dissatisfaction > k, we need to check if we can reduce it\n    # We can reduce dissatisfaction by converting '?' to 'Y' in the right places\n    # Count the number of '?' in the sequence\n    question_marks = episodes.count('?')\n    \n    # If we have enough '?' to fill the gaps and reduce dissatisfaction to k\n    if max_dissatisfaction > k and (max_dissatisfaction - k) <= question_marks:\n        return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\nepisodes = input().strip()\n\n# Get the result and print it\nresult = can_achieve_dissatisfaction(n, k, episodes)\nprint(result)"}
{"solution": "def possible_values_of_difference(N, X, D):\n    # Calculate the sum of the entire sequence\n    total_sum = N * X + D * (N * (N - 1)) // 2\n    \n    # The number of unique values of S - T can be derived from the properties of the sequence\n    # The difference S - T can take values from -total_sum to total_sum in steps of 2 * D\n    # The number of distinct values is given by the formula:\n    # (total_sum - (-total_sum)) // (2 * D) + 1\n    if D == 0:\n        return 1  # If D is 0, all elements are the same, only one possible value of S - T\n    \n    return (total_sum - (-total_sum)) // (2 * D) + 1\n\n# Read input\nimport sys\ninput = sys.stdin.read\nN, X, D = map(int, input().strip().split())\n\n# Calculate and print the result\nresult = possible_values_of_difference(N, X, D)\nprint(result)"}
{"solution": "def did_anton_perform_good(n, participants):\n    for participant in participants:\n        handle, before, after = participant\n        if before >= 2400 and after > before:\n            return \"YES\"\n    return \"NO\"\n\n# Input reading\nn = int(input())\nparticipants = [input().split() for _ in range(n)]\nparticipants = [(handle, int(before), int(after)) for handle, before, after in participants]\n\n# Output the result\nprint(did_anton_perform_good(n, participants))"}
{"solution": "# Read the binary input\ns_binary = input().strip()\n\n# Convert the binary string to an integer\ns = int(s_binary, 2)\n\n# Initialize the count of missed trains\nmissed_trains = 0\n\n# The departure times are powers of 4: 4^k = (2^2)^k = 2^(2k)\n# We need to count how many powers of 4 are less than s\nk = 0\nwhile True:\n    departure_time = 4 ** k  # This is 2^(2k)\n    if departure_time < s:\n        missed_trains += 1\n    else:\n        break\n    k += 1\n\n# Output the number of missed trains\nprint(missed_trains)"}
{"solution": "def min_rows_for_matrix_b(n, m, a):\n    # Function to check if a given matrix can be formed by mirroring\n    def can_form_by_mirroring(start_row, end_row):\n        for i in range(start_row):\n            if a[i] != a[end_row - 1 - i]:\n                return False\n        return True\n\n    # Start with the maximum possible rows for b\n    for rows in range(1, n + 1):\n        # Check if we can form matrix a by mirroring a matrix b of size rows x m\n        valid = True\n        for start in range(0, n, rows):\n            end = start + rows\n            if end > n:\n                break\n            if not can_form_by_mirroring(rows, end):\n                valid = False\n                break\n        if valid:\n            return rows\n\n# Read input\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\n# Get the minimum number of rows for matrix b\nresult = min_rows_for_matrix_b(n, m, a)\n\n# Print the result\nprint(result)"}
{"solution": "def max_non_overlapping_orders(orders):\n    # Sort orders by their finish times\n    orders.sort(key=lambda x: x[1])\n    \n    count = 0\n    last_end_time = -1\n    \n    for start, end in orders:\n        if start >= last_end_time:\n            count += 1\n            last_end_time = end\n            \n    return count\n\n# Read input\nn = int(input())\norders = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = max_non_overlapping_orders(orders)\nprint(result)"}
{"solution": "def can_rearrange(n, k, tables, formulas):\n    total_tables = sum(tables)\n    total_formulas = sum(formulas)\n\n    # Calculate the maximum number of blocks needed for tables and formulas\n    max_table_blocks = (total_tables + k - 1) // k\n    max_formula_blocks = (total_formulas + k - 1) // k\n\n    # Calculate the total number of pages\n    total_pages = n\n\n    # Check if we can fit the blocks into the pages\n    if max_table_blocks + max_formula_blocks <= total_pages:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\ntables = list(map(int, input().split()))\nformulas = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_rearrange(n, k, tables, formulas)\nprint(result)"}
{"solution": "def can_human_win(n, k, coefficients):\n    # Calculate the current value of the polynomial at x = k\n    current_value = 0\n    unknown_count = 0\n    \n    for i in range(n + 1):\n        if coefficients[i] == '?':\n            unknown_count += 1\n        else:\n            current_value += coefficients[i] * (k ** i)\n    \n    # If there are no unknown coefficients, check if the current value is divisible by (x - k)\n    if unknown_count == 0:\n        return current_value == 0\n    \n    # If there are unknown coefficients, the human can always adjust the polynomial\n    # to make it divisible by (x - k) if they play optimally.\n    return True\n\n# Read input\nn, k = map(int, input().split())\ncoefficients = [input().strip() for _ in range(n + 1)]\n\n# Determine if the human can guarantee a win\nif can_human_win(n, k, coefficients):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def smallest_starting_number(X2):\n    # Function to generate all prime numbers less than a given number using Sieve of Eratosthenes\n    def sieve(n):\n        is_prime = [True] * (n + 1)\n        p = 2\n        while (p * p <= n):\n            if (is_prime[p] == True):\n                for i in range(p * p, n + 1, p):\n                    is_prime[i] = False\n            p += 1\n        return [p for p in range(2, n) if is_prime[p]]\n\n    # Generate all primes less than X2\n    primes = sieve(X2)\n\n    # Initialize the minimum starting number\n    min_X0 = float('inf')\n\n    # Iterate through all primes to find possible X1\n    for p in primes:\n        if p < X2:\n            # Calculate the smallest multiple of p that is >= X2\n            if X2 % p == 0:\n                X1 = X2\n            else:\n                X1 = (X2 // p + 1) * p\n            \n            # Now we need to find the smallest X0 that could lead to this X1\n            for q in primes:\n                if q < X1:\n                    # Calculate the smallest multiple of q that is >= X1\n                    if X1 % q == 0:\n                        X0 = X1\n                    else:\n                        X0 = (X1 // q + 1) * q\n                    \n                    # Update the minimum starting number\n                    min_X0 = min(min_X0, X0)\n\n    return min_X0\n\n# Read input\nX2 = int(input().strip())\n# Output the result\nprint(smallest_starting_number(X2))"}
{"solution": "def min_p_binary_numbers(n, p):\n    # If p is greater than n, we cannot represent n as a sum of p-binary numbers\n    if p > n:\n        return -1\n    \n    # Calculate the adjusted target we need to reach using p-binary numbers\n    adjusted_n = n - p\n    \n    # If adjusted_n is negative, we cannot represent n\n    if adjusted_n < 0:\n        return -1\n    \n    # Count the number of 1s in the binary representation of adjusted_n\n    # This gives us the minimum number of powers of two needed\n    count_of_ones = bin(adjusted_n).count('1')\n    \n    # The total number of summands will be the count of 1s plus the number of times we need to add p\n    # If p is 0, we only need the count of 1s\n    return count_of_ones + (1 if p != 0 else 0)\n\n# Read input\nn, p = map(int, input().split())\n# Get the result\nresult = min_p_binary_numbers(n, p)\n# Print the result\nprint(result)"}
{"solution": "def minimize_number(n, k, S):\n    S = list(S)  # Convert the string to a list of characters for mutability\n    changes = 0\n\n    # Change the first digit if necessary\n    if S[0] != '1':\n        S[0] = '1'\n        changes += 1\n\n    # Change the rest of the digits\n    for i in range(1, n):\n        if changes < k and S[i] != '0':\n            S[i] = '0'\n            changes += 1\n\n    return ''.join(S)\n\n# Read input\nn, k = map(int, input().split())\nS = input().strip()\n\n# Get the result and print it\nresult = minimize_number(n, k, S)\nprint(result)"}
{"solution": "def min_number_to_present(cnt_1, cnt_2, x, y):\n    # Function to count how many numbers from 1 to v are not divisible by prime p\n    def count_not_divisible(v, p):\n        return v - (v // p)\n\n    # Binary search to find the minimum v\n    left, right = 1, 2 * (cnt_1 + cnt_2)  # Start with a reasonable upper bound\n    while left < right:\n        mid = (left + right) // 2\n        # Count numbers not divisible by x and y\n        count_x = count_not_divisible(mid, x)\n        count_y = count_not_divisible(mid, y)\n        \n        # Total distinct numbers available\n        total_available = count_x + count_y\n        \n        # Check if we can satisfy both friends\n        if total_available >= cnt_1 + cnt_2:\n            right = mid  # Try for a smaller v\n        else:\n            left = mid + 1  # Increase v\n\n    return left\n\n# Read input\ncnt_1, cnt_2, x, y = map(int, input().split())\n# Get the result\nresult = min_number_to_present(cnt_1, cnt_2, x, y)\n# Print the result\nprint(result)"}
{"solution": "def bear_final_position(n, sx, sy, dx, dy, t):\n    x, y = sx, sy\n    \n    for _ in range(t):\n        # Calculate the number of bushes in the current cell\n        bushes = x + y\n        \n        # Bear eats bushes and increases speed\n        dx += bushes\n        dy += bushes\n        \n        # Move to the next cell\n        x = (x + dx - 1) % n + 1\n        y = (y + dy - 1) % n + 1\n        \n        # One additional bush grows in each cell\n        # This is already accounted for in the next iteration as bushes = x + y\n        \n    return x, y\n\n# Read input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Get the final position of the bear\nfinal_position = bear_final_position(n, sx, sy, dx, dy, t)\n\n# Print the result\nprint(final_position[0], final_position[1])"}
{"solution": "def is_nice_word_possible(s):\n    n = len(s)\n    if n < 26:\n        return -1\n\n    # Function to check if a substring of length 26 is nice\n    def check_substring(start):\n        seen = set()\n        for i in range(start, start + 26):\n            if s[i] != '?' and s[i] in seen:\n                return False\n            seen.add(s[i])\n        return len(seen) + s[start:start + 26].count('?') == 26\n\n    # Try to find a valid substring of length 26\n    for i in range(n - 25):\n        if check_substring(i):\n            # We found a valid starting point\n            result = list(s)\n            used = set()\n            for j in range(i, i + 26):\n                if result[j] != '?':\n                    used.add(result[j])\n            # Fill in the question marks\n            alphabet = set(chr(c) for c in range(ord('A'), ord('Z') + 1))\n            missing = list(alphabet - used)\n            missing_index = 0\n            \n            for j in range(i, i + 26):\n                if result[j] == '?':\n                    result[j] = missing[missing_index]\n                    missing_index += 1\n            \n            # Replace remaining question marks in the result\n            for k in range(n):\n                if result[k] == '?':\n                    result[k] = 'A'  # Can replace with any letter, here we use 'A'\n            \n            return ''.join(result)\n\n    return -1\n\n# Read input\ns = input().strip()\n# Get the result\nresult = is_nice_word_possible(s)\n# Print the result\nprint(result)"}
{"solution": "def can_divide_apples(n, weights):\n    count_100 = weights.count(100)\n    count_200 = weights.count(200)\n    \n    total_weight = sum(weights)\n    \n    # If the total weight is odd, we cannot split it evenly\n    if total_weight % 2 != 0:\n        return \"NO\"\n    \n    target_weight = total_weight // 2\n    \n    # Check if we can reach the target weight using the available apples\n    for i in range(count_200 + 1):\n        if i * 200 > target_weight:\n            break\n        remaining_weight = target_weight - i * 200\n        if remaining_weight <= count_100 * 100:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn = int(input())\nweights = list(map(int, input().split()))\n\n# Output the result\nprint(can_divide_apples(n, weights))"}
{"solution": "def minimum_time_to_turn_off_lights(n, m, building):\n    total_time = 0\n\n    for floor in range(n):\n        # Get the current floor's room states\n        rooms = building[floor]\n        \n        # Find the leftmost and rightmost rooms with lights on\n        leftmost = rooms.find('1')\n        rightmost = rooms.rfind('1')\n        \n        if leftmost == -1:  # No lights are on in this floor\n            continue\n        \n        # Time to go to the leftmost room and back to the stairs\n        time_to_leftmost = leftmost\n        time_to_rightmost = (rightmost - leftmost) + rightmost\n        \n        # Total time for this floor\n        total_time += time_to_leftmost + time_to_rightmost + 1  # +1 for switching off the last light\n        \n        # If not the last floor, add time to go up to the next floor\n        if floor < n - 1:\n            total_time += 1  # Time to go up to the next floor\n\n    return total_time\n\n# Read input\nn, m = map(int, input().split())\nbuilding = [input().strip() for _ in range(n)]\n\n# Calculate and print the result\nresult = minimum_time_to_turn_off_lights(n, m, building)\nprint(result)"}
{"solution": "def find_min_trap_cost(n, costs, transitions):\n    visited = [False] * n\n    in_stack = [False] * n\n    min_cost = 0\n    stack = []\n    \n    def dfs(node):\n        nonlocal min_cost\n        path = []\n        current = node\n        \n        while True:\n            if visited[current]:\n                if in_stack[current]:\n                    # Found a cycle, calculate the minimum cost in this cycle\n                    cycle_min_cost = float('inf')\n                    while path:\n                        cycle_node = path.pop()\n                        in_stack[cycle_node] = False\n                        cycle_min_cost = min(cycle_min_cost, costs[cycle_node])\n                        if cycle_node == current:\n                            break\n                    min_cost += cycle_min_cost\n                return\n            visited[current] = True\n            in_stack[current] = True\n            path.append(current)\n            current = transitions[current] - 1\n\n        for i in range(n):\n            if not visited[i]:\n                dfs(i)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n\n    return min_cost\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(find_min_trap_cost(n, costs, transitions))"}
{"solution": "# Read input values\nn, a, b = map(int, input().split())\n\n# Calculate the final entrance number\nfinal_entrance = (a + b - 1) % n + 1\n\n# Print the result\nprint(final_entrance)"}
{"solution": "def min_arithmetic_progressions(n, a):\n    # Initialize the number of progressions needed\n    progressions = 0\n    i = 0\n    \n    while i < n:\n        # Start a new progression\n        progressions += 1\n        start = a[i] if a[i] != -1 else None\n        diff = None\n        \n        # Move through the sequence to find the length of the current progression\n        while i < n:\n            if a[i] != -1:\n                if start is None:\n                    start = a[i]\n                else:\n                    if diff is None:\n                        diff = a[i] - start\n                    else:\n                        # Check if the current value can fit in the current progression\n                        if (a[i] - start) % diff != 0:\n                            break\n                # Update start for the next expected value\n                start = a[i]\n            else:\n                # If we encounter -1, we can assume it can be any value\n                # We will just continue to the next element\n                pass\n            \n            i += 1\n        \n        # Move to the next element to start a new progression\n        while i < n and a[i] == -1:\n            i += 1\n    \n    return progressions\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Get the result and print it\nresult = min_arithmetic_progressions(n, a)\nprint(result)"}
{"solution": "def max_beauty(n, k, s):\n    def max_length_with_char(target_char):\n        left = 0\n        max_length = 0\n        count_changes = 0\n        \n        for right in range(n):\n            if s[right] != target_char:\n                count_changes += 1\n            \n            while count_changes > k:\n                if s[left] != target_char:\n                    count_changes -= 1\n                left += 1\n            \n            max_length = max(max_length, right - left + 1)\n        \n        return max_length\n\n    # Calculate the maximum beauty by considering both 'a' and 'b'\n    max_beauty_a = max_length_with_char('a')\n    max_beauty_b = max_length_with_char('b')\n    \n    return max(max_beauty_a, max_beauty_b)\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, a):\n    alice_seats = a[0]\n    total_seats = sum(a)\n    majority = total_seats // 2\n\n    coalition = [1]  # Start with Alice's party\n\n    # Check which parties can be included in the coalition\n    for i in range(1, n):\n        if alice_seats >= 2 * a[i]:  # Alice's party must have at least twice the seats\n            coalition.append(i + 1)  # Store the index (1-based)\n\n    # Calculate the total seats in the coalition\n    coalition_seats = sum(a[i - 1] for i in coalition)\n\n    # Check if the coalition has a strict majority\n    if coalition_seats > majority:\n        print(len(coalition))\n        print(\" \".join(map(str, coalition)))\n    else:\n        print(0)\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find and print the coalition\nfind_coalition(n, a)"}
{"solution": "def max_reward(n):\n    harmonic_sum = 0.0\n    for i in range(1, n + 1):\n        harmonic_sum += 1.0 / i\n    return harmonic_sum\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the maximum reward\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "def distribute_candies(n):\n    k = 0\n    total = 0\n    candies = []\n\n    # Find the maximum k such that the sum of the first k distinct integers is <= n\n    while total + (k + 1) <= n:\n        k += 1\n        total += k\n        candies.append(k)\n\n    # If there are remaining candies, adjust the last element\n    remaining = n - total\n    if remaining > 0:\n        candies[-1] += remaining\n\n    print(k)\n    print(\" \".join(map(str, candies)))\n\n# Read input\nn = int(input())\ndistribute_candies(n)"}
{"solution": "n = int(input())\nm = int(input())\n\n# Calculate 2^n\npower_of_two = 1 << n  # This is equivalent to 2**n using bitwise shift\n\n# Calculate m mod 2^n\nresult = m % power_of_two\n\n# Print the result\nprint(result)"}
{"solution": "def correct_word(s):\n    vowels = set('aeiouy')\n    result = []\n    \n    for char in s:\n        if result and char in vowels and result[-1] in vowels:\n            continue  # Skip the current vowel if the last character in result is also a vowel\n        result.append(char)\n    \n    return ''.join(result)\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Get the corrected word\ncorrected_word = correct_word(s)\n\n# Print the output\nprint(corrected_word)"}
{"solution": "def max_students(n, a, b, seats):\n    segments = []\n    i = 0\n    \n    # Identify segments of empty seats\n    while i < n:\n        if seats[i] == '.':\n            start = i\n            while i < n and seats[i] == '.':\n                i += 1\n            segments.append(i - start)\n        else:\n            i += 1\n    \n    total_students = 0\n    \n    # Place students in each segment\n    for length in segments:\n        # Calculate the number of students that can be placed in this segment\n        if a > b:\n            programmers = (length + 1) // 2\n            athletes = length // 2\n        else:\n            athletes = (length + 1) // 2\n            programmers = length // 2\n        \n        # Place the students\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n        \n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n    \n    return total_students\n\n# Read input\nn, a, b = map(int, input().split())\nseats = input().strip()\n\n# Output the result\nprint(max_students(n, a, b, seats))"}
{"solution": "def find_xy(r):\n    # Iterate over possible values of x\n    for x in range(1, int(r**0.5) + 1):\n        # Calculate the value of y based on the equation H(x, y) = r\n        # H(x, y) = x^2 + 2xy + x + 1\n        # Rearranging gives us: 2xy = r - (x^2 + x + 1)\n        # Therefore, y = (r - (x^2 + x + 1)) / (2x)\n        left_side = r - (x**2 + x + 1)\n        \n        if left_side <= 0:\n            continue\n        \n        if left_side % (2 * x) == 0:\n            y = left_side // (2 * x)\n            if y > 0:\n                return x, y\n    \n    return \"NO\"\n\n# Read input\nr = int(input().strip())\nresult = find_xy(r)\n\n# Print output\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "def divide_balloons(n, a):\n    total_balloons = sum(a)\n    \n    # If there's only one packet, it's impossible to divide\n    if n == 1:\n        return -1\n    \n    # If all packets have the same number of balloons\n    if len(set(a)) == 1:\n        return -1\n    \n    # We can give the first packet to Grigory and the rest to Andrew\n    # This guarantees that they will have different totals\n    grigory_packets = [1]  # 1-based index\n    return (1, grigory_packets)\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = divide_balloons(n, a)\n\n# Print the output\nif result == -1:\n    print(-1)\nelse:\n    k, indices = result\n    print(k)\n    print(' '.join(map(str, indices)))"}
{"solution": "def split_number(n):\n    # We will use the largest digit possible (which is 9) to minimize the number of different digits\n    if n <= 9:\n        # If n is less than or equal to 9, we can just use n itself\n        return [1, [n]]\n    else:\n        # We will use as many 9s as possible\n        count_of_nines = n // 9\n        remainder = n % 9\n        \n        # Prepare the result\n        result = []\n        \n        # Add 9s to the result\n        result.extend([9] * count_of_nines)\n        \n        # If there's a remainder, add it as well\n        if remainder > 0:\n            result.append(remainder)\n        \n        return [len(result), result]\n\n# Read input\nn = int(input().strip())\n\n# Get the result\nk, digits = split_number(n)\n\n# Print the output\nprint(k)\nprint(' '.join(map(str, digits)))"}
{"solution": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef max_simple_subset(arr):\n    n = len(arr)\n    if n == 0:\n        return 0, []\n    \n    # Check if all elements are even or odd\n    odd_count = sum(1 for x in arr if x % 2 != 0)\n    even_count = n - odd_count\n    \n    if odd_count > 0 and even_count > 0:\n        # If we have both odd and even numbers, we can only take one of them\n        if odd_count > even_count:\n            return odd_count, [x for x in arr if x % 2 != 0]\n        else:\n            return even_count, [x for x in arr if x % 2 == 0]\n    elif odd_count > 0:\n        return odd_count, [x for x in arr if x % 2 != 0]\n    else:\n        return even_count, [x for x in arr if x % 2 == 0]\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Finding the maximum simple subset\nm, subset = max_simple_subset(a)\n\n# Output the result\nprint(m)\nprint(' '.join(map(str, subset)))"}
{"solution": "def greatest_beautiful_divisor(n):\n    # Generate beautiful numbers up to the maximum possible value of n\n    beautiful_numbers = []\n    k = 1\n    while True:\n        beautiful_number = (2**k - 1) * (2**k - 1)\n        if beautiful_number > n:\n            break\n        beautiful_numbers.append(beautiful_number)\n        k += 1\n\n    # Find the greatest beautiful divisor of n\n    greatest_divisor = 1\n    for b in beautiful_numbers:\n        if n % b == 0:\n            greatest_divisor = b\n\n    return greatest_divisor\n\n# Read input\nn = int(input().strip())\n# Output the result\nprint(greatest_beautiful_divisor(n))"}
{"solution": "def is_d_magic(num_str, d):\n    # Check if the number is d-magic\n    for i in range(len(num_str)):\n        digit = int(num_str[i])\n        if (i % 2 == 1 and digit != d) or (i % 2 == 0 and digit == d):\n            return False\n    return True\n\ndef count_d_magic_numbers(m, d, a, b):\n    MOD = 10**9 + 7\n    count = 0\n    \n    # Convert a and b to integers\n    a = int(a)\n    b = int(b)\n    \n    # Iterate through the range [a, b]\n    for num in range(a, b + 1):\n        if num % m == 0 and is_d_magic(str(num), d):\n            count = (count + 1) % MOD\n            \n    return count\n\n# Read input\nm, d = map(int, input().split())\na = input().strip()\nb = input().strip()\n\n# Get the result and print it\nresult = count_d_magic_numbers(m, d, a, b)\nprint(result)"}
{"solution": "from collections import deque\n\ndef last_child(n, m, a):\n    queue = deque([(i + 1, a[i]) for i in range(n)])  # (child_index, candies_needed)\n    \n    last_child_index = -1\n    \n    while queue:\n        child_index, candies_needed = queue.popleft()\n        candies_needed -= m\n        \n        if candies_needed > 0:\n            queue.append((child_index, candies_needed))\n        else:\n            last_child_index = child_index\n    \n    return last_child_index\n\n# Input reading\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(last_child(n, m, a))"}
{"solution": "def min_bills(n):\n    denominations = [100, 20, 10, 5, 1]\n    count = 0\n    \n    for bill in denominations:\n        count += n // bill  # Get the number of bills of this denomination\n        n %= bill           # Update n to the remaining amount\n    \n    return count\n\n# Read input\nn = int(input().strip())\n# Output the minimum number of bills\nprint(min_bills(n))"}
{"solution": "def count_permutations(n, k):\n    MOD = 1000000007\n    \n    # dp[i][j] will store the number of permutations of size i with exactly j good positions\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Base case: 1 permutation of size 0 with 0 good positions\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            # Case 1: The last element is not in a good position\n            dp[i][j] = (dp[i - 1][j] * (i - j)) % MOD\n            \n            # Case 2: The last element is in a good position\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n    \n    return dp[n][k]\n\n# Read input\nn, k = map(int, input().split())\n# Calculate and print the result\nprint(count_permutations(n, k))"}
{"solution": "def max_beauty_bouquet(n, k, beauties, colors):\n    from collections import defaultdict\n    \n    # Group roses by color\n    color_groups = defaultdict(list)\n    for beauty, color in zip(beauties, colors):\n        color_groups[color].append(beauty)\n    \n    # Sort each color group in descending order of beauty\n    for color in color_groups:\n        color_groups[color].sort(reverse=True)\n    \n    # Check if we can form a valid bouquet\n    if len(color_groups) < 2:\n        return -1  # Not enough different colors\n    \n    # Prepare to calculate maximum beauty\n    max_beauty = -1\n    \n    # Try combinations of two different colors\n    colors_list = list(color_groups.keys())\n    for i in range(len(colors_list)):\n        for j in range(i + 1, len(colors_list)):\n            color1 = colors_list[i]\n            color2 = colors_list[j]\n            \n            # Get the beauties of the two colors\n            beauties1 = color_groups[color1]\n            beauties2 = color_groups[color2]\n            \n            # We need to take k roses in total\n            for take_from_color1 in range(max(0, k - len(beauties2)), min(k, len(beauties1)) + 1):\n                take_from_color2 = k - take_from_color1\n                \n                if take_from_color2 <= len(beauties2):\n                    total_beauty = sum(beauties1[:take_from_color1]) + sum(beauties2[:take_from_color2])\n                    max_beauty = max(max_beauty, total_beauty)\n    \n    return max_beauty\n\n# Input reading\nn, k = map(int, input().split())\nbeauties = list(map(int, input().split()))\ncolors = input().strip()\n\n# Calculate and print the result\nresult = max_beauty_bouquet(n, k, beauties, colors)\nprint(result)"}
{"solution": "def compare_fractions(p, q, n, a):\n    # Calculate the value of the continued fraction\n    if n == 0:\n        return False\n    \n    # Start from the last element of the continued fraction\n    value = a[-1]\n    \n    # Iterate backwards through the continued fraction\n    for i in range(n - 2, -1, -1):\n        value = a[i] + 1 / value\n    \n    # Convert the continued fraction value to a fraction\n    # value = a_1 + 1/(a_2 + 1/(... + 1/a_n))\n    # We need to express it as a fraction (numerator, denominator)\n    \n    # The value is now a float, we need to convert it to a fraction\n    from fractions import Fraction\n    continued_fraction_value = Fraction(value).limit_denominator()\n    \n    # Compare the two fractions\n    return continued_fraction_value.numerator == p and continued_fraction_value.denominator == q\n\n# Read input\np, q = map(int, input().split())\nn = int(input())\na = list(map(int, input().split()))\n\n# Check if the fractions are equal\nif compare_fractions(p, q, n, a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_sticks(expression):\n    # Split the expression into parts\n    parts = expression.split('+')\n    A = parts[0].count('|')\n    B, C = parts[1].split('=')\n    B = B.count('|')\n    C = C.count('|')\n\n    # Check if the current expression is already correct\n    if A + B == C:\n        return expression\n\n    # Try shifting one stick from A, B, or C\n    for i in range(len(parts[0])):\n        if parts[0][i] == '|':\n            # Shift from A to B\n            new_A = A - 1\n            new_B = B + 1\n            if new_A >= 0 and new_A + new_B == C:\n                return '|' * new_A + '+' + '|' * new_B + '=' + '|' * C\n\n    for i in range(len(parts[1].split('=')[0])):\n        if parts[1].split('=')[0][i] == '|':\n            # Shift from B to A\n            new_B = B - 1\n            new_A = A + 1\n            if new_B >= 0 and new_A + new_B == C:\n                return '|' * new_A + '+' + '|' * new_B + '=' + '|' * C\n\n    for i in range(len(parts[1].split('=')[1])):\n        if parts[1].split('=')[1][i] == '|':\n            # Shift from C to A or B\n            new_C = C - 1\n            if A + B == new_C:\n                return '|' * A + '+' + '|' * B + '=' + '|' * new_C\n\n            new_C = C - 1\n            new_B = B + 1\n            if new_B >= 0 and A + new_B == new_C:\n                return '|' * A + '+' + '|' * new_B + '=' + '|' * new_C\n\n    return \"Impossible\"\n\n# Read input\nexpression = input().strip()\n# Get the result\nresult = count_sticks(expression)\n# Print the result\nprint(result)"}
{"solution": "def count_permutations_with_oddness(n, k):\n    MOD = 10**9 + 7\n    \n    # dp[i][j] will store the number of permutations of {1, 2, ..., i} with oddness j\n    dp = [[0] * (n * n + 1) for _ in range(n + 1)]\n    \n    # Base case: there's one way to arrange 0 elements with oddness 0\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(n * n + 1):\n            # Calculate the oddness contribution for the current element\n            for p in range(1, i + 1):\n                oddness_contribution = abs(p - i)\n                if j >= oddness_contribution:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - oddness_contribution]) % MOD\n    \n    return dp[n][k]\n\n# Read input\nimport sys\ninput = sys.stdin.read\nn, k = map(int, input().strip().split())\n\n# Calculate and print the result\nresult = count_permutations_with_oddness(n, k)\nprint(result)"}
{"solution": "def can_reach_points(N, points):\n    # Calculate the total x and y offsets needed to reach all points\n    total_x = sum(x for x, y in points)\n    total_y = sum(y for x, y in points)\n\n    # The number of sections (m) can be determined by the maximum absolute value of total_x and total_y\n    # We can use 2 sections to reach any point in the coordinate plane\n    m = 2\n    d1 = abs(total_x) + abs(total_y)  # Length of the first section\n    d2 = 0  # Length of the second section can be zero since we can adjust the direction\n\n    # Prepare the output\n    distances = [d1, d2]\n    modes = []\n\n    for x, y in points:\n        # Determine the modes to reach (x, y)\n        mode = []\n        if x > 0:\n            mode.append('R')\n        elif x < 0:\n            mode.append('L')\n        \n        if y > 0:\n            mode.append('U')\n        elif y < 0:\n            mode.append('D')\n\n        # Fill the remaining modes with 'U' or 'D' to ensure we have m modes\n        while len(mode) < m:\n            mode.append('U')  # Arbitrarily choose 'U' for the remaining sections\n\n        modes.append(''.join(mode))\n\n    return m, distances, modes\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN = int(data[0])\npoints = [tuple(map(int, line.split())) for line in data[1:N + 1]]\n\n# Get the result\nresult = can_reach_points(N, points)\n\n# Print the output\nif result:\n    m, distances, modes = result\n    print(m)\n    print(' '.join(map(str, distances)))\n    for mode in modes:\n        print(mode)\nelse:\n    print(-1)"}
{"solution": "def replace_fillers(n, s):\n    filler = \"ogo\"\n    filler_length = len(filler)\n    result = []\n    i = 0\n\n    while i < n:\n        if s[i:i + filler_length] == filler:\n            # Found a filler, replace it with \"***\"\n            result.append(\"***\")\n            # Move index to the end of the current filler\n            while i < n and s[i:i + filler_length] == filler:\n                i += filler_length\n            # Check for additional \"go\" at the end of the filler\n            while i < n and s[i:i + 2] == \"go\":\n                i += 2\n        else:\n            # Not a filler, just add the current character\n            result.append(s[i])\n            i += 1\n\n    # Join the result list into a string and print it\n    print(''.join(result))\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Call the function\nreplace_fillers(n, s)"}
{"solution": "def prime_factors(n):\n    i = 2\n    factors = set()\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.add(i)\n    if n > 1:\n        factors.add(n)\n    return factors\n\ndef g(y, p):\n    count = 0\n    while y % p == 0:\n        y //= p\n        count += 1\n    return p ** count\n\ndef f(x, y):\n    primes = prime_factors(x)\n    product = 1\n    for p in primes:\n        product *= g(y, p)\n        product %= (10**9 + 7)\n    return product\n\ndef modular_exponentiation(base, exp, mod):\n    result = 1\n    base = base % mod\n    while exp > 0:\n        if (exp % 2) == 1:\n            result = (result * base) % mod\n        exp //= 2\n        base = (base * base) % mod\n    return result\n\ndef calculate_result(x, n):\n    mod = 10**9 + 7\n    total_product = 1\n    for i in range(1, n + 1):\n        total_product *= f(x, i)\n        total_product %= mod\n    return total_product\n\n# Input reading\nx, n = map(int, input().split())\n\n# Calculate the result\nresult = calculate_result(x, n)\n\n# Output the result\nprint(result)"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for s in range(1, 82):  # s(x) can be at most 81\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and sum_of_digits(x) == s:\n            solutions.append(x)\n    solutions.sort()\n    return solutions\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find solutions\nsolutions = find_solutions(a, b, c)\n\n# Print results\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "def can_solve_with_one_rotation(cube_state):\n    # Define the positions of the squares on each face of the 2x2x2 cube\n    face_positions = [\n        [0, 1, 2, 3],  # Front face\n        [4, 5, 6, 7],  # Right face\n        [8, 9, 10, 11],  # Back face\n        [12, 13, 14, 15],  # Left face\n        [16, 17, 18, 19],  # Top face\n        [20, 21, 22, 23]   # Bottom face\n    ]\n    \n    # Check each face to see if it can be solved with one rotation\n    for positions in face_positions:\n        colors = [cube_state[i] for i in positions]\n        if colors.count(colors[0]) == 3:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\ncube_state = list(map(int, input().strip().split()))\n\n# Output the result\nprint(can_solve_with_one_rotation(cube_state))"}
{"solution": "def get_tshirt_places(s):\n    i = (s // 50) % 475\n    places = []\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        places.append(26 + i)\n    return sorted(places)\n\ndef min_successful_hacks(p, x, y):\n    # Ensure we have at least y points\n    if x < y:\n        return float('inf')  # Not possible if x < y\n\n    # Check for the minimum successful hacks needed\n    successful_hacks = 0\n    while True:\n        # Calculate the current score\n        current_score = x + successful_hacks * 100 - (0 * 50)  # No unsuccessful hacks yet\n        # Get the places that would receive T-shirts\n        tshirt_places = get_tshirt_places(current_score)\n        # Check if p is in the tshirt places\n        if p in tshirt_places and current_score >= y:\n            return successful_hacks\n        successful_hacks += 1\n\n# Read input\np, x, y = map(int, input().split())\n# Calculate and print the result\nprint(min_successful_hacks(p, x, y))"}
{"solution": "def minimum_distance(n, a, b, c):\n    # If Winnie only needs to eat once, he can do it at Rabbit's house without moving\n    if n == 1:\n        return 0\n    \n    # If Winnie needs to eat more than once, we need to calculate the minimum distance\n    # The possible paths are:\n    # 1. Rabbit -> Owl -> Eeyore (or back)\n    # 2. Rabbit -> Eeyore -> Owl (or back)\n    \n    # The distances for the two main routes:\n    route1_distance = a + c  # Rabbit -> Owl -> Eeyore\n    route2_distance = b + c  # Rabbit -> Eeyore -> Owl\n    \n    # The minimum distance for n meals\n    # Each meal after the first requires a move, so we need (n-1) moves\n    # The minimum distance for (n-1) moves can be calculated as:\n    # (n-1) * min(route1_distance, route2_distance)\n    \n    return (n - 1) * min(route1_distance, route2_distance)\n\n# Read input\nn = int(input().strip())\na = int(input().strip())\nb = int(input().strip())\nc = int(input().strip())\n\n# Calculate and print the minimum distance\nprint(minimum_distance(n, a, b, c))"}
{"solution": "# Read the input values\nx1, x2, x3 = map(int, input().split())\n\n# Sort the positions to find the median\npositions = sorted([x1, x2, x3])\n\n# The optimal meeting point is the median\nmeeting_point = positions[1]\n\n# Calculate the total distance\ntotal_distance = abs(positions[0] - meeting_point) + abs(positions[1] - meeting_point) + abs(positions[2] - meeting_point)\n\n# Print the result\nprint(total_distance)"}
{"solution": "def min_operations_to_equal_elements(n, x, a):\n    # Count occurrences of each element\n    count = {}\n    for num in a:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n\n    # If there are already at least two equal elements\n    for num in count:\n        if count[num] > 1:\n            return 0\n\n    # Create a set to track the transformed values\n    transformed = set()\n    min_operations = float('inf')\n\n    for num in a:\n        transformed_value = num & x\n        # Check if the transformed value already exists\n        if transformed_value in count:\n            # If it exists, we can achieve equality with one operation\n            min_operations = min(min_operations, 1)\n        transformed.add(transformed_value)\n\n    # Check if any original number can be transformed to match another transformed number\n    for num in transformed:\n        if num in count:\n            min_operations = min(min_operations, 1)\n\n    # If we can transform an element to match another, return the minimum operations\n    return min_operations if min_operations != float('inf') else -1\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_operations_to_equal_elements(n, x, a))"}
{"solution": "def has_single_plus_shape(h, w, grid):\n    # Function to check if the grid contains a single \"+\" shape\n    def is_plus_shape(r, c):\n        # Check if the center is valid\n        if grid[r][c] != '*':\n            return False\n        \n        # Count rays in each direction\n        up = down = left = right = 0\n        \n        # Count upward\n        for i in range(r - 1, -1, -1):\n            if grid[i][c] == '*':\n                up += 1\n            else:\n                break\n        \n        # Count downward\n        for i in range(r + 1, h):\n            if grid[i][c] == '*':\n                down += 1\n            else:\n                break\n        \n        # Count leftward\n        for j in range(c - 1, -1, -1):\n            if grid[r][j] == '*':\n                left += 1\n            else:\n                break\n        \n        # Count rightward\n        for j in range(c + 1, w):\n            if grid[r][j] == '*':\n                right += 1\n            else:\n                break\n        \n        # A valid \"+\" shape must have at least one ray in each direction\n        return up > 0 and down > 0 and left > 0 and right > 0\n\n    center_found = False\n    \n    # Scan the grid for potential center of \"+\"\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*':\n                if is_plus_shape(i, j):\n                    if center_found:  # If we already found a center, return NO\n                        return \"NO\"\n                    center_found = True\n                    \n                    # Mark the cells of the found \"+\" shape to check for extra non-empty cells\n                    # Marking the rays\n                    for k in range(1, h):\n                        if i - k >= 0 and grid[i - k][j] == '*':\n                            grid[i - k][j] = '.'\n                        else:\n                            break\n                    for k in range(1, h):\n                        if i + k < h and grid[i + k][j] == '*':\n                            grid[i + k][j] = '.'\n                        else:\n                            break\n                    for k in range(1, w):\n                        if j - k >= 0 and grid[i][j - k] == '*':\n                            grid[i][j - k] = '.'\n                        else:\n                            break\n                    for k in range(1, w):\n                        if j + k < w and grid[i][j + k] == '*':\n                            grid[i][j + k] = '.'\n                        else:\n                            break\n\n    # After checking, ensure there are no remaining '*' in the grid\n    for row in grid:\n        if '*' in row:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nh, w = map(int, input().split())\ngrid = [list(input().strip()) for _ in range(h)]\n\n# Output the result\nprint(has_single_plus_shape(h, w, grid))"}
{"solution": "def create_adjacency_matrix(n, a, b):\n    # Check if the conditions are feasible\n    if a + b > n + 1:\n        return \"NO\"\n    \n    # Initialize the adjacency matrix with zeros\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Create components for the graph\n    components = []\n    for i in range(a):\n        components.append([i])\n    \n    # Fill the first a components with single vertices\n    for i in range(a, n):\n        components[i - a].append(i)\n    \n    # Create edges within each component\n    for component in components:\n        size = len(component)\n        for i in range(size):\n            for j in range(i + 1, size):\n                matrix[component[i]][component[j]] = 1\n                matrix[component[j]][component[i]] = 1\n    \n    # Create the complement components\n    complement_components = []\n    for i in range(b):\n        complement_components.append([i])\n    \n    # Fill the first b components with single vertices\n    for i in range(b, n):\n        complement_components[i - b].append(i)\n    \n    # Create edges within each complement component\n    for component in complement_components:\n        size = len(component)\n        for i in range(size):\n            for j in range(i + 1, size):\n                matrix[component[i]][component[j]] = 0\n                matrix[component[j]][component[i]] = 0\n    \n    return \"YES\", matrix\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Generate the adjacency matrix\nresult = create_adjacency_matrix(n, a, b)\n\n# Print the result\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(''.join(map(str, row)))"}
{"solution": "def min_problems_needed(c, d, n, m, k):\n    total_needed = n * m\n    total_winners = k\n    \n    # Calculate how many more winners are needed\n    remaining_needed = max(0, total_needed - total_winners)\n    \n    # Initialize the minimum problems needed\n    min_problems = float('inf')\n    \n    # Try all possible combinations of main and additional rounds\n    for main_rounds in range(remaining_needed // n + 2):  # +2 to cover the case where we need one more round\n        for additional_rounds in range(remaining_needed + 1):  # +1 to cover the case where we need one more additional round\n            winners_from_main = main_rounds * n\n            winners_from_additional = additional_rounds\n            \n            if winners_from_main + winners_from_additional >= remaining_needed:\n                total_problems = main_rounds * c + additional_rounds * d\n                min_problems = min(min_problems, total_problems)\n    \n    return min_problems\n\n# Read input\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\n# Calculate and print the result\nresult = min_problems_needed(c, d, n, m, k)\nprint(result)"}
{"solution": "def create_grid(s):\n    # Create a 2D grid with 2 rows and 13 columns\n    grid = [[''] * 13 for _ in range(2)]\n    \n    # Fill the grid with the letters from the string\n    letters = list(s)\n    \n    # Check if we can fill the grid\n    if len(set(letters)) > 26:\n        return \"Impossible\"\n    \n    # Place letters in the grid\n    for i in range(2):\n        for j in range(13):\n            if letters:\n                grid[i][j] = letters.pop(0)\n            else:\n                break\n    \n    # Convert grid to string format\n    grid_str = [''.join(row) for row in grid]\n    \n    # Check for path validity\n    if is_valid_path(grid_str, s):\n        return grid_str\n    else:\n        return \"Impossible\"\n\ndef is_valid_path(grid, s):\n    # Create a mapping of letter positions\n    positions = {}\n    for i in range(2):\n        for j in range(13):\n            letter = grid[i][j]\n            if letter not in positions:\n                positions[letter] = []\n            positions[letter].append((i, j))\n    \n    # Check if the path can be formed\n    for i in range(len(s) - 1):\n        current_letter = s[i]\n        next_letter = s[i + 1]\n        \n        if current_letter not in positions or next_letter not in positions:\n            return False\n        \n        # Check adjacency\n        found_adjacent = False\n        for (x1, y1) in positions[current_letter]:\n            for (x2, y2) in positions[next_letter]:\n                if abs(x1 - x2) <= 1 and abs(y1 - y2) <= 1:\n                    found_adjacent = True\n                    break\n            if found_adjacent:\n                break\n        \n        if not found_adjacent:\n            return False\n    \n    return True\n\n# Read input\ns = input().strip()\n\n# Create the grid and print the result\nresult = create_grid(s)\nif result == \"Impossible\":\n    print(result)\nelse:\n    for line in result:\n        print(line)"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<' if y > 1 else '='\n    elif y == 1:\n        return '>' if x > 1 else '='\n    else:\n        # Compute y * log(x) and x * log(y)\n        lhs = y * math.log(x)\n        rhs = x * math.log(y)\n        \n        if lhs < rhs:\n            return '<'\n        elif lhs > rhs:\n            return '>'\n        else:\n            return '='\n\n# Read input\nx, y = map(int, input().split())\n\n# Output the result of the comparison\nprint(compare_powers(x, y))"}
{"solution": "def max_balloons(r, h):\n    # Radius of the balloon\n    balloon_radius = r / 2\n    \n    # Height of the cupboard\n    cupboard_height = h + r\n    \n    # Calculate the maximum number of balloons that can fit in the cupboard\n    # The number of balloons that can fit in height\n    balloons_in_height = cupboard_height // (2 * balloon_radius)\n    \n    # The number of balloons that can fit in width (the semicircle)\n    # The width of the semicircle can be considered as the diameter\n    # The maximum number of balloons that can fit in the semicircle\n    balloons_in_width = r // balloon_radius\n    \n    # Total balloons is the product of the two\n    total_balloons = balloons_in_height * balloons_in_width\n    \n    return total_balloons\n\n# Read input\nr, h = map(int, input().split())\n\n# Calculate and print the result\nprint(max_balloons(r, h))"}
{"solution": "def min_sum_after_discarding(cards):\n    from collections import Counter\n    \n    # Count the occurrences of each card number\n    count = Counter(cards)\n    \n    # Calculate the total sum of the cards\n    total_sum = sum(cards)\n    \n    # Initialize the minimum sum as the total sum (if no cards are discarded)\n    min_sum = total_sum\n    \n    # Check for each unique card number\n    for number, freq in count.items():\n        if freq >= 2:\n            # If we can discard two cards of this number\n            min_sum = min(min_sum, total_sum - 2 * number)\n        if freq >= 3:\n            # If we can discard three cards of this number\n            min_sum = min(min_sum, total_sum - 3 * number)\n    \n    return min_sum\n\n# Read input\ncards = list(map(int, input().split()))\n\n# Get the minimum sum after discarding\nresult = min_sum_after_discarding(cards)\n\n# Print the result\nprint(result)"}
{"solution": "def minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    \n    # If there is only one checkpoint, return the distance to that checkpoint\n    if n == 1:\n        return abs(a - checkpoints[0])\n    \n    # Calculate the distance to visit n-1 checkpoints\n    # We can either skip the first checkpoint or the last checkpoint\n    distance_skip_first = abs(a - checkpoints[1]) + (checkpoints[-1] - checkpoints[1])\n    distance_skip_last = abs(a - checkpoints[-2]) + (checkpoints[-2] - checkpoints[0])\n    \n    # Return the minimum of the two distances\n    return min(distance_skip_first, distance_skip_last)\n\n# Read input\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Calculate and print the minimum distance\nprint(minimum_distance(n, a, checkpoints))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_smallest_root(n):\n    # We will check for possible values of s(x) from 1 to 162 (max sum of digits for 18 digits)\n    for s in range(1, 163):\n        # Calculate the discriminant\n        discriminant = s * s + 4 * n\n        if discriminant < 0:\n            continue\n        \n        sqrt_discriminant = int(discriminant**0.5)\n        if sqrt_discriminant * sqrt_discriminant != discriminant:\n            continue\n        \n        # Calculate the two possible values for x\n        x1 = (-s + sqrt_discriminant) // 2\n        x2 = (-s - sqrt_discriminant) // 2\n        \n        # We only care about positive integers\n        if x1 > 0 and sum_of_digits(x1) == s:\n            return x1\n        if x2 > 0 and sum_of_digits(x2) == s:\n            return x2\n    \n    return -1\n\n# Read input\nn = int(input().strip())\n# Find and print the smallest root\nprint(find_smallest_root(n))"}
{"solution": "def time_to_bed(current_time, sleep_duration):\n    # Split the input times into hours and minutes\n    current_hours, current_minutes = map(int, current_time.split(':'))\n    sleep_hours, sleep_minutes = map(int, sleep_duration.split(':'))\n\n    # Convert current time and sleep duration to total minutes\n    total_current_minutes = current_hours * 60 + current_minutes\n    total_sleep_minutes = sleep_hours * 60 + sleep_minutes\n\n    # Calculate the time when George went to bed in total minutes\n    total_bed_time_minutes = total_current_minutes - total_sleep_minutes\n\n    # If the result is negative, it means he went to bed the previous day\n    if total_bed_time_minutes < 0:\n        total_bed_time_minutes += 24 * 60\n\n    # Convert back to hours and minutes\n    bed_hours = total_bed_time_minutes // 60\n    bed_minutes = total_bed_time_minutes % 60\n\n    # Format the output to ensure two digits for hours and minutes\n    return f\"{bed_hours:02}:{bed_minutes:02}\"\n\n# Read input\ncurrent_time = input().strip()\nsleep_duration = input().strip()\n\n# Get the time George went to bed and print it\nprint(time_to_bed(current_time, sleep_duration))"}
{"solution": "def longest_max_mean_subsegment(n, a):\n    max_value = max(a)\n    longest_length = 0\n    current_length = 0\n    \n    for value in a:\n        if value == max_value:\n            current_length += 1\n        else:\n            longest_length = max(longest_length, current_length)\n            current_length = 0\n            \n    longest_length = max(longest_length, current_length)\n    \n    return longest_length\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Function call and output\nprint(longest_max_mean_subsegment(n, a))"}
{"solution": "def count_painting_ways(n, m, k):\n    MOD = 998244353\n    \n    # If k is 0, all bricks must be the same color\n    if k == 0:\n        return m % MOD\n    \n    # If k is greater than n-1, it's impossible\n    if k > n - 1:\n        return 0\n    \n    # Calculate the number of ways to paint the bricks\n    # The first brick can be painted in m ways\n    # The next k bricks must be different from the previous one\n    # The remaining (n - k - 1) bricks can be painted in m ways\n    ways = m * (m - 1) ** k % MOD * pow(m, n - k - 1, MOD) % MOD\n    \n    return ways\n\n# Read input\nn, m, k = map(int, input().split())\n# Calculate and print the result\nprint(count_painting_ways(n, m, k))"}
{"solution": "import re\n\ndef is_magic_number(n):\n    # Define the regular expression pattern for magic numbers\n    pattern = re.compile(r'^(1|14|144)+$')\n    \n    # Check if the entire number matches the pattern\n    if pattern.match(str(n)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\nn = int(input())\nprint(is_magic_number(n))"}
{"solution": "def min_moves_to_corners(n, m, i, j, a, b):\n    # Check if it's possible to reach any corner\n    def can_reach(x, y):\n        return (x - i) % a == 0 and (y - j) % b == 0 and (x - i) // a % 2 == (y - j) // b % 2\n\n    corners = [(1, 1), (1, m), (n, 1), (n, m)]\n    min_moves = float('inf')\n\n    for x, y in corners:\n        if can_reach(x, y):\n            moves = max(abs(x - i) // a, abs(y - j) // b)\n            min_moves = min(min_moves, moves)\n\n    return min_moves if min_moves != float('inf') else \"Poor Inna and pony!\"\n\n# Read input\nn, m, i, j, a, b = map(int, input().split())\n# Get the result\nresult = min_moves_to_corners(n, m, i, j, a, b)\n# Print the result\nprint(result)"}
{"solution": "def max_removals(s):\n    n = len(s)\n    removed_count = 0\n    can_remove = True\n\n    while can_remove:\n        can_remove = False\n        to_remove = []\n\n        for i in range(n):\n            if (i > 0 and ord(s[i]) - ord(s[i - 1]) == 1) or (i < n - 1 and ord(s[i]) - ord(s[i + 1]) == 1):\n                to_remove.append(i)\n\n        if to_remove:\n            can_remove = True\n            for index in reversed(to_remove):\n                s = s[:index] + s[index + 1:]\n                removed_count += 1\n            n = len(s)\n\n    return removed_count\n\n# Read input\nlength = int(input().strip())\ns = input().strip()\n\n# Get the result and print it\nresult = max_removals(s)\nprint(result)"}
{"solution": "def min_bills(n, k, denominations, q, requests):\n    results = []\n    \n    # Iterate through each request\n    for amount in requests:\n        min_bills_needed = float('inf')\n        \n        # Check all pairs of denominations (including the same denomination)\n        for i in range(n):\n            for j in range(i, n):\n                d1 = denominations[i]\n                d2 = denominations[j]\n                \n                # Try to find the minimum number of bills for this pair\n                for x in range(k + 1):\n                    for y in range(k + 1 - x):\n                        total = x * d1 + y * d2\n                        if total == amount:\n                            min_bills_needed = min(min_bills_needed, x + y)\n        \n        # If we found a valid combination, add it to results, otherwise -1\n        if min_bills_needed <= k:\n            results.append(min_bills_needed)\n        else:\n            results.append(-1)\n    \n    return results\n\n# Read input\nn, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\nrequests = [int(input()) for _ in range(q)]\n\n# Get results\nresults = min_bills(n, k, denominations, q, requests)\n\n# Print results\nfor result in results:\n    print(result)"}
{"solution": "def minimum_time_to_reach_destination(s, x1, x2, t1, t2, p, d):\n    from math import ceil\n\n    # Calculate the distance Igor needs to cover\n    distance = abs(x2 - x1)\n\n    # Time if Igor walks directly to x2\n    time_if_walk = distance * t2\n\n    # Function to calculate the time for tram to reach a certain position\n    def tram_time_to_position(position):\n        if d == 1:  # Tram moving towards s\n            if position < p:\n                return float('inf')  # Tram can't go back\n            else:\n                distance_to_position = position - p\n                time_to_position = distance_to_position * t1\n                return time_to_position + (s - p) * t1 if position >= s else time_to_position\n        else:  # Tram moving towards 0\n            if position > p:\n                return float('inf')  # Tram can't go back\n            else:\n                distance_to_position = p - position\n                time_to_position = distance_to_position * t1\n                return time_to_position + p * t1 if position <= 0 else time_to_position\n\n    # Check all possible scenarios\n    min_time = time_if_walk\n\n    # Check if Igor can catch the tram at any point\n    for target in range(s + 1):\n        time_to_target = tram_time_to_position(target)\n        if time_to_target < float('inf'):\n            # Time for Igor to reach the target point\n            time_for_igor_to_target = abs(x1 - target) * t2\n            total_time = time_for_igor_to_target + time_to_target + abs(target - x2) * t1\n            min_time = min(min_time, total_time)\n\n    return min_time\n\n# Input reading\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Calculate and print the minimum time\nresult = minimum_time_to_reach_destination(s, x1, x2, t1, t2, p, d)\nprint(result)"}
{"solution": "def count_occurrences(n, x):\n    count = 0\n    for i in range(1, n + 1):\n        if x % i == 0:  # Check if i is a divisor of x\n            j = x // i  # Calculate the corresponding j\n            if 1 <= j <= n:  # Check if j is within the bounds of the table\n                count += 1\n    return count\n\n# Read input\nn, x = map(int, input().split())\n# Get the result\nresult = count_occurrences(n, x)\n# Print the output\nprint(result)"}
{"solution": "def generate_password(n, k):\n    # Create a list of the first k lowercase letters\n    letters = [chr(i) for i in range(ord('a'), ord('a') + k)]\n    \n    # Initialize the password\n    password = []\n    \n    # Fill the password ensuring no two consecutive characters are the same\n    for i in range(n):\n        password.append(letters[i % k])\n    \n    # Join the list into a string and return\n    return ''.join(password)\n\n# Read input\nn, k = map(int, input().split())\n\n# Generate and print the password\nprint(generate_password(n, k))"}
{"solution": "def first_collision_time(n, directions, positions):\n    min_time = float('inf')\n    collision_found = False\n    \n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            collision_time = (positions[i + 1] - positions[i]) // 2\n            min_time = min(min_time, collision_time)\n            collision_found = True\n    \n    if collision_found:\n        return min_time\n    else:\n        return -1\n\n# Read input\nn = int(input().strip())\ndirections = input().strip()\npositions = list(map(int, input().strip().split()))\n\n# Get the result and print it\nresult = first_collision_time(n, directions, positions)\nprint(result)"}
{"solution": "def can_fit(w1, h1, w2, h2, a, b):\n    # Check if two rectangles can fit in the paper without overlapping\n    return (w1 + w2 <= a and max(h1, h2) <= b) or (max(w1, w2) <= a and h1 + h2 <= b)\n\ndef max_area(n, a, b, seals):\n    max_area = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            w1, h1 = seals[i]\n            w2, h2 = seals[j]\n            \n            # Check all combinations of orientations\n            if can_fit(w1, h1, w2, h2, a, b):\n                max_area = max(max_area, w1 * h1 + w2 * h2)\n            if can_fit(w1, h1, h2, w2, a, b):\n                max_area = max(max_area, w1 * h1 + w2 * h2)\n            if can_fit(h1, w1, w2, h2, a, b):\n                max_area = max(max_area, w1 * h1 + w2 * h2)\n            if can_fit(h1, w1, h2, w2, a, b):\n                max_area = max(max_area, w1 * h1 + w2 * h2)\n    \n    return max_area\n\n# Input reading\nn, a, b = map(int, input().split())\nseals = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the maximum area\nresult = max_area(n, a, b, seals)\nprint(result)"}
{"solution": "def find_outlier_point(n, points):\n    # Create a set to store the points\n    point_set = set(points)\n    \n    # Determine the boundaries of the square\n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n    \n    min_x = min(x_coords)\n    max_x = max(x_coords)\n    min_y = min(y_coords)\n    max_y = max(y_coords)\n    \n    # Generate the expected boundary points\n    boundary_points = set()\n    \n    # Add points on the left and right sides\n    for y in range(min_y, max_y + 1):\n        boundary_points.add((min_x, y))\n        boundary_points.add((max_x, y))\n    \n    # Add points on the top and bottom sides\n    for x in range(min_x, max_x + 1):\n        boundary_points.add((x, min_y))\n        boundary_points.add((x, max_y))\n    \n    # The outlier point is the one that is not in the boundary points\n    outlier_point = point_set - boundary_points\n    return outlier_point.pop()\n\n# Read input\nn = int(input().strip())\npoints = [tuple(map(int, input().strip().split())) for _ in range(4 * n + 1)]\n\n# Find and print the outlier point\noutlier = find_outlier_point(n, points)\nprint(outlier[0], outlier[1])"}
{"solution": "def product_of_digits(x):\n    product = 1\n    while x > 0:\n        product *= x % 10\n        x //= 10\n    return product\n\ndef max_product(n):\n    str_n = str(n)\n    max_product_value = product_of_digits(n)\n    \n    for i in range(len(str_n)):\n        if str_n[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit by 1 and setting all following digits to 9\n        new_number = str_n[:i] + str(int(str_n[i]) - 1) + '9' * (len(str_n) - i - 1)\n        max_product_value = max(max_product_value, product_of_digits(int(new_number)))\n    \n    return max_product_value\n\nn = int(input().strip())\nprint(max_product(n))"}
{"solution": "def smallest_winning_k(n, votes):\n    # Calculate total votes for Elodreip\n    total_votes_elodreip = sum(votes)\n    \n    # The minimum k must be at least the maximum votes given to Elodreip\n    max_votes = max(votes)\n    \n    # Start with k as the maximum votes\n    k = max_votes\n    \n    # Increment k until Awruk's votes exceed Elodreip's votes\n    while True:\n        # Calculate Awruk's total votes\n        total_votes_awruk = n * k - total_votes_elodreip\n        \n        # Check if Awruk's votes are strictly greater than Elodreip's\n        if total_votes_awruk > total_votes_elodreip:\n            return k\n        \n        # Increment k for the next iteration\n        k += 1\n\n# Read input\nn = int(input())\nvotes = list(map(int, input().split()))\n\n# Get the result and print it\nresult = smallest_winning_k(n, votes)\nprint(result)"}
{"solution": "def count_operations(points):\n    operations = 0\n    while True:\n        to_delete = set()\n        n = len(points)\n        \n        for i in range(n):\n            if (i > 0 and points[i] != points[i - 1]) or (i < n - 1 and points[i] != points[i + 1]):\n                to_delete.add(i)\n        \n        if not to_delete:\n            break\n        \n        points = ''.join(points[i] for i in range(n) if i not in to_delete)\n        operations += 1\n    \n    return operations\n\n# Read input\ninput_points = input().strip()\n# Get the number of operations\nresult = count_operations(input_points)\n# Print the result\nprint(result)"}
{"solution": "def count_min_product_triples(n, a):\n    # Sort the array to easily find the smallest three distinct elements\n    a.sort()\n    \n    # The minimum product will be from the three smallest elements\n    min_product = a[0] * a[1] * a[2]\n    \n    # Count occurrences of the smallest elements\n    count = {}\n    for num in a:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Get the smallest three distinct elements\n    distinct_elements = list(count.keys())\n    distinct_elements.sort()\n    \n    if len(distinct_elements) < 3:\n        # If there are less than 3 distinct elements, we cannot form a valid triple\n        return 0\n    \n    # Get the counts of the three smallest distinct elements\n    c1 = count[distinct_elements[0]]\n    c2 = count[distinct_elements[1]]\n    c3 = count[distinct_elements[2]]\n    \n    # Calculate the number of valid triples based on the counts\n    if c1 > 1 and c2 > 0 and c3 > 0:\n        # Case where the smallest element appears at least twice\n        return (c1 * (c1 - 1) // 2) * c2\n    elif c1 > 0 and c2 > 1 and c3 > 0:\n        # Case where the second smallest element appears at least twice\n        return (c2 * (c2 - 1) // 2) * c1\n    elif c1 > 0 and c2 > 0 and c3 > 1:\n        # Case where the third smallest element appears at least twice\n        return (c3 * (c3 - 1) // 2) * c1\n    else:\n        # All three elements are distinct\n        return c1 * c2 * c3\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(count_min_product_triples(n, a))"}
{"solution": "def minimum_cuts(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n % 2 == 0:\n        return n // 2 + 1\n    else:\n        return n\n\n# Read input\nn = int(input().strip())\n# Calculate and print the result\nprint(minimum_cuts(n))"}
{"solution": "def maximize_account_balance(n):\n    # If the account balance is non-negative, return it as is\n    if n >= 0:\n        return n\n    \n    # Convert the number to string to manipulate digits\n    n_str = str(n)\n    \n    # Option 1: Remove the last digit\n    option1 = int(n_str[:-1])\n    \n    # Option 2: Remove the second last digit\n    option2 = int(n_str[:-2] + n_str[-1]) if len(n_str) > 2 else option1\n    \n    # Return the maximum of the original, option1, and option2\n    return max(n, option1, option2)\n\n# Read input\nn = int(input().strip())\n# Print the result\nprint(maximize_account_balance(n))"}
{"solution": "def determine_spinner_direction(start, end, n):\n    positions = ['v', '<', '^', '>']\n    \n    start_index = positions.index(start)\n    end_index = positions.index(end)\n    \n    # Calculate the resulting position after n seconds for both directions\n    cw_position = (start_index + n) % 4\n    ccw_position = (start_index - n) % 4\n    \n    if cw_position == end_index and ccw_position == end_index:\n        return \"undefined\"\n    elif cw_position == end_index:\n        return \"cw\"\n    elif ccw_position == end_index:\n        return \"ccw\"\n    else:\n        return \"undefined\"\n\n# Read input\ninput_data = input().strip().split()\nstart_position = input_data[0]\nend_position = input_data[1]\nn_seconds = int(input().strip())\n\n# Determine and print the direction\nresult = determine_spinner_direction(start_position, end_position, n_seconds)\nprint(result)"}
{"solution": "def count_standing_dominoes(n, s):\n    # Create a list to represent the state of each domino\n    dominoes = list(s)\n    \n    # Process the dominoes from left to right\n    for i in range(n):\n        if dominoes[i] == 'R':\n            j = i + 1\n            while j < n and dominoes[j] == '.':\n                dominoes[j] = 'R'\n                j += 1\n            if j < n and dominoes[j] == 'L':\n                # If we encounter an 'L', we need to determine the balance\n                left_count = j - (i + 1)  # Count of '.' between 'R' and 'L'\n                if left_count % 2 == 0:\n                    # If even, they will balance out\n                    dominoes[i + 1:j] = ['.'] * left_count\n                else:\n                    # If odd, the leftmost will fall to the left and the rest to the right\n                    dominoes[i + 1:j] = ['R'] * (left_count // 2) + ['.'] + ['L'] * (left_count // 2)\n    \n    # Process the dominoes from right to left\n    for i in range(n - 1, -1, -1):\n        if dominoes[i] == 'L':\n            j = i - 1\n            while j >= 0 and dominoes[j] == '.':\n                dominoes[j] = 'L'\n                j -= 1\n            if j >= 0 and dominoes[j] == 'R':\n                # If we encounter an 'R', we need to determine the balance\n                right_count = (i - 1) - j  # Count of '.' between 'R' and 'L'\n                if right_count % 2 == 0:\n                    # If even, they will balance out\n                    dominoes[j + 1:i] = ['.'] * right_count\n                else:\n                    # If odd, the rightmost will fall to the right and the rest to the left\n                    dominoes[j + 1:i] = ['L'] * (right_count // 2) + ['.'] + ['R'] * (right_count // 2)\n\n    # Count the number of standing dominoes\n    standing_count = dominoes.count('.')\n    \n    return standing_count\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Get the result and print it\nresult = count_standing_dominoes(n, s)\nprint(result)"}
{"solution": "def restore_permutation(n, m, leaders):\n    # Initialize the permutation array with None\n    permutation = [None] * n\n    \n    # To track the number of times each position is pointed to\n    count = [0] * n\n    \n    # Fill the permutation based on the leaders\n    for i in range(m - 1):\n        current_leader = leaders[i] - 1  # Convert to 0-based index\n        next_leader = leaders[i + 1] - 1  # Convert to 0-based index\n        \n        # Calculate the number of steps taken\n        steps = (next_leader - current_leader + n) % n\n        \n        # If the current position is already filled, we can't determine the value\n        if permutation[current_leader] is not None:\n            # Calculate the expected value\n            expected_value = steps\n            if expected_value <= 0 or expected_value > n or count[expected_value - 1] > 0:\n                return -1\n            permutation[current_leader] = expected_value\n            count[expected_value - 1] += 1\n        else:\n            # If not filled, we can set it\n            if steps <= 0 or steps > n or count[steps - 1] > 0:\n                return -1\n            permutation[current_leader] = steps\n            count[steps - 1] += 1\n    \n    # Fill the remaining None values with unused numbers\n    unused_numbers = [i + 1 for i in range(n) if count[i] == 0]\n    \n    for i in range(n):\n        if permutation[i] is None:\n            if not unused_numbers:\n                return -1\n            permutation[i] = unused_numbers.pop()\n    \n    return permutation\n\n# Read input\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\n# Get the result\nresult = restore_permutation(n, m, leaders)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "def max_number_after_swaps(a, k):\n    a = list(str(a))  # Convert the number to a list of digits\n    n = len(a)\n\n    for i in range(n):\n        if k <= 0:\n            break\n        \n        # Find the maximum digit we can bring to the current position\n        max_digit = a[i]\n        max_index = i\n        \n        # Look ahead up to k positions\n        for j in range(i + 1, min(i + k + 1, n)):\n            if a[j] > max_digit:\n                max_digit = a[j]\n                max_index = j\n        \n        # If we found a larger digit, we need to swap it to the current position\n        if max_index != i:\n            # Calculate how many swaps we need\n            swaps_needed = max_index - i\n            \n            # Perform the swaps\n            for j in range(max_index, i, -1):\n                a[j] = a[j - 1]\n            \n            a[i] = max_digit\n            \n            # Decrease k by the number of swaps we just used\n            k -= swaps_needed\n\n    return ''.join(a)\n\n# Read input\na, k = map(int, input().split())\n# Get the result\nresult = max_number_after_swaps(a, k)\n# Print the result\nprint(result)"}
{"solution": "def next_number(sequence):\n    a1, a2, a3, a4 = sequence\n    \n    # Check for arithmetic progression\n    d = a2 - a1\n    if a3 - a2 == d and a4 - a3 == d:\n        return a4 + d\n    \n    # Check for geometric progression\n    if a1 != 0 and a2 != 0 and a3 != 0 and a4 != 0:\n        if a2 / a1 == a3 / a2 == a4 / a3:\n            q = a2 // a1\n            if a2 % a1 == 0 and a3 % a2 == 0 and a4 % a3 == 0:\n                return a4 * q\n    \n    # If neither progression, return 42\n    return 42\n\n# Read input\nsequence = list(map(int, input().split()))\n# Get the result\nresult = next_number(sequence)\n# Print the result\nprint(result)"}
{"solution": "def max_distance(n, colors):\n    # Find the first and last occurrence of each color\n    first_occurrence = {}\n    last_occurrence = {}\n    \n    for i in range(n):\n        color = colors[i]\n        if color not in first_occurrence:\n            first_occurrence[color] = i\n        last_occurrence[color] = i\n    \n    # Get the list of unique colors\n    unique_colors = list(first_occurrence.keys())\n    \n    # Calculate the maximum distance\n    max_dist = 0\n    \n    # Compare distances from the first house to the last house of a different color\n    for color in unique_colors:\n        if colors[0] != color:\n            max_dist = max(max_dist, last_occurrence[color])\n        if colors[-1] != color:\n            max_dist = max(max_dist, n - 1 - first_occurrence[color])\n    \n    return max_dist\n\n# Read input\nn = int(input())\ncolors = list(map(int, input().split()))\n\n# Print the result\nprint(max_distance(n, colors))"}
{"solution": "def find_santa_place(n, m, k):\n    # Each lane has 2 * m places\n    places_per_lane = 2 * m\n    \n    # Determine the lane (1-indexed)\n    lane = (k - 1) // places_per_lane + 1\n    \n    # Determine the position within the lane\n    position_in_lane = (k - 1) % places_per_lane\n    \n    # Determine the desk (1-indexed)\n    desk = position_in_lane // 2 + 1\n    \n    # Determine the side (L or R)\n    side = 'L' if position_in_lane % 2 == 0 else 'R'\n    \n    return lane, desk, side\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Get the result\nlane, desk, side = find_santa_place(n, m, k)\n\n# Print the output\nprint(lane, desk, side)"}
{"solution": "def possible_final_colors(n, s):\n    count_B = s.count('B')\n    count_G = s.count('G')\n    count_R = s.count('R')\n\n    # Determine the parity of each color count\n    parity_B = count_B % 2\n    parity_G = count_G % 2\n    parity_R = count_R % 2\n\n    # Determine possible final colors based on parity\n    possible_colors = set()\n\n    if parity_B == 0 and parity_G == 0 and parity_R == 0:\n        possible_colors.update(['B', 'G', 'R'])\n    elif parity_B == 1 and parity_G == 0 and parity_R == 0:\n        possible_colors.add('B')\n    elif parity_B == 0 and parity_G == 1 and parity_R == 0:\n        possible_colors.add('G')\n    elif parity_B == 0 and parity_G == 0 and parity_R == 1:\n        possible_colors.add('R')\n    elif parity_B == 1 and parity_G == 1 and parity_R == 0:\n        possible_colors.update(['B', 'G'])\n    elif parity_B == 1 and parity_G == 0 and parity_R == 1:\n        possible_colors.update(['B', 'R'])\n    elif parity_B == 0 and parity_G == 1 and parity_R == 1:\n        possible_colors.update(['G', 'R'])\n    elif parity_B == 1 and parity_G == 1 and parity_R == 1:\n        possible_colors.update(['B', 'G', 'R'])\n\n    # Return the possible colors in alphabetical order\n    return ''.join(sorted(possible_colors))\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(possible_final_colors(n, s))"}
