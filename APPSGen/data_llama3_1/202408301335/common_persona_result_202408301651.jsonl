{"solution": "def max_accordion_length(s):\n    max_length = -1\n    opening_bracket_index = -1\n    colon_count = 0\n    vertical_line_count = 0\n\n    for i, char in enumerate(s):\n        if char == '[':\n            opening_bracket_index = i\n            colon_count = 0\n            vertical_line_count = 0\n        elif char == ':' and opening_bracket_index!= -1:\n            if colon_count == 0:\n                colon_count += 1\n            else:\n                max_length = max(max_length, 4 + vertical_line_count)\n                opening_bracket_index = -1\n                colon_count = 0\n                vertical_line_count = 0\n        elif char == '|' and opening_bracket_index!= -1 and colon_count == 1:\n            vertical_line_count += 1\n        elif char == ']' and opening_bracket_index!= -1 and colon_count == 1:\n            max_length = max(max_length, 4 + vertical_line_count)\n            opening_bracket_index = -1\n            colon_count = 0\n            vertical_line_count = 0\n\n    return max_length\n\ns = input()\nprint(max_accordion_length(s))"}
{"solution": "def max_digit_sum(x):\n    x_str = str(x)\n    max_sum = sum(int(digit) for digit in x_str)\n    max_num = x\n\n    for i in range(len(x_str) - 1, -1, -1):\n        if x_str[i]!= '9':\n            new_num_str = x_str[:i] + str(int(x_str[i]) - 1) + '9' * (len(x_str) - i - 1)\n            new_num = int(new_num_str)\n            new_sum = sum(int(digit) for digit in new_num_str)\n            if new_sum >= max_sum:\n                max_sum = new_sum\n                max_num = new_num\n            break\n\n    return max_num\n\nx = int(input())\nprint(max_digit_sum(x))"}
{"solution": "def is_lucky_year(year):\n    \"\"\"Check if a year is lucky.\"\"\"\n    return sum(1 for digit in str(year) if digit!= '0') <= 1\n\n\ndef next_lucky_year(current_year):\n    \"\"\"Find the next lucky year after the given year.\"\"\"\n    next_year = current_year + 1\n    while not is_lucky_year(next_year):\n        next_year += 1\n    return next_year\n\n\ndef main():\n    \"\"\"Read the current year and print the years until the next lucky year.\"\"\"\n    current_year = int(input())\n    next_year = next_lucky_year(current_year)\n    print(next_year - current_year)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, q = read_ints()\n    painters = [tuple(read_ints()) for _ in range(q)]\n\n    dp = [[[-1] * (q + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n\n    def solve(l, r, p):\n        if l > r:\n            return 0\n        if dp[l][r][p]!= -1:\n            return dp[l][r][p]\n        if p == 0:\n            return 0\n\n        max_val = 0\n        for i in range(q):\n            li, ri = painters[i]\n            if li <= l and ri >= r:\n                max_val = max(max_val, solve(l, r, p - 1))\n            elif li >= l and ri <= r:\n                max_val = max(max_val, ri - li + 1 + solve(l, li - 1, p - 1) + solve(ri + 1, r, p - 1))\n            elif li <= l and ri <= r:\n                max_val = max(max_val, ri - l + 1 + solve(ri + 1, r, p - 1))\n            elif li >= l and ri >= r:\n                max_val = max(max_val, r - li + 1 + solve(l, li - 1, p - 1))\n\n        dp[l][r][p] = max_val\n        return max_val\n\n    print(solve(1, n, q - 2))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_lucky(time):\n    \"\"\"Check if a time is lucky.\"\"\"\n    return '7' in time\n\ndef find_lucky_time(x, hh, mm):\n    \"\"\"Find the smallest number of times Jamie needs to press the snooze button.\"\"\"\n    minutes = hh * 60 + mm\n    y = 0\n    while True:\n        minutes -= x\n        if minutes < 0:\n            minutes += 24 * 60\n        lucky_time = f\"{minutes // 60:02d}{minutes % 60:02d}\"\n        if is_lucky(lucky_time):\n            return y\n        y += 1\n\nx = int(input())\nhh, mm = map(int, input().split())\nprint(find_lucky_time(x, hh, mm))"}
{"solution": "n, pos, l, r = map(int, input().split())\n\nif l == 1 and r == n:\n    print(0)\nelif l == 1:\n    print(abs(pos - r) + 1)\nelif r == n:\n    print(abs(pos - l) + 1)\nelse:\n    left_cost = abs(pos - l) + 1 + max(0, l - 2)\n    right_cost = abs(pos - r) + 1 + max(0, n - r - 1)\n    print(min(left_cost, right_cost) + 1)"}
{"solution": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    d = []\n    h = []\n    for _ in range(n):\n        di, hi = map(int, sys.stdin.readline().split())\n        d.append(di)\n        h.append(hi)\n\n    best = -1\n    for i in range(n):\n        if d[i] > h[i]:\n            best = i\n            break\n\n    if best == -1:\n        print(-1)\n        return\n\n    ans = 0\n    while x > 0:\n        if d[best] >= x:\n            ans += 1\n            break\n        else:\n            x = x - d[best] + h[best]\n            ans += 1\n\n    print(ans)\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    solve()"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    day = 0\n    while True:\n        day += 1\n        n += m\n        if n > 10**18:\n            n = 10**18\n        if n < day:\n            break\n        n -= day\n    print(day)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": ""}
{"solution": ""}
{"solution": "n = int(input())\nfull_weeks = n // 7\nremaining_days = n % 7\n\nmin_days_off = full_weeks * 2\nmax_days_off = full_weeks * 2 + min(remaining_days, 2)\n\nprint(min_days_off, max_days_off)"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nn, a, b, p, q = map(int, input().split())\n\nred = n // a\nblue = n // b\nboth = n // lcm(a, b)\n\nchocolates = max(red * p + (blue - both) * q, blue * q + (red - both) * p)\n\nprint(chocolates)"}
{"solution": "def max_golden_trophies(n, trophies):\n    max_length = 0\n    current_length = 0\n    first_silver = -1\n    last_silver = -1\n    silver_count = 0\n\n    for i in range(n):\n        if trophies[i] == 'G':\n            current_length += 1\n        else:\n            silver_count += 1\n            if first_silver == -1:\n                first_silver = i\n            last_silver = i\n            current_length = 0\n        max_length = max(max_length, current_length)\n\n    if silver_count == 0:\n        return max_length\n\n    if silver_count == 1:\n        return max_length + 1\n\n    if silver_count == 2:\n        return max_length + 2\n\n    max_length_with_swap = max_length\n    if first_silver - 1 >= 0 and last_silver + 1 < n:\n        max_length_with_swap = max(max_length_with_swap, max_length + 2)\n    elif first_silver - 1 >= 0:\n        max_length_with_swap = max(max_length_with_swap, max_length + 1)\n    elif last_silver + 1 < n:\n        max_length_with_swap = max(max_length_with_swap, max_length + 1)\n\n    return max_length_with_swap\n\n\nn = int(input())\ntrophies = input()\nprint(max_golden_trophies(n, trophies))"}
{"solution": "from collections import defaultdict, deque\n\ndef main():\n    n, k = map(int, input().split())\n    main_courses = list(map(int, input().split()))\n\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        dependencies = list(map(int, input().split()))\n        in_degree[i] = dependencies[0]\n        if dependencies[0] > 0:\n            for dependency in dependencies[1:]:\n                graph[dependency].append(i)\n\n    queue = deque([course for course in main_courses if in_degree[course] == 0])\n    result = []\n\n    while queue:\n        course = queue.popleft()\n        result.append(course)\n\n        for neighbor in graph[course]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(result)!= k:\n        print(-1)\n        return\n\n    queue = deque([course for course in range(1, n + 1) if in_degree[course] == 0])\n    while queue:\n        course = queue.popleft()\n        if course not in result:\n            result.append(course)\n\n        for neighbor in graph[course]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    print(len(result))\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve(n, k, p):\n    s = []\n    for i in range(k):\n        while s and s[-1] < p[i]:\n            s.pop()\n        if s and s[-1] > p[i]:\n            return [-1]\n        s.append(p[i])\n    remaining = set(range(1, n + 1)) - set(p)\n    remaining = sorted(list(remaining), reverse=True)\n    for i in range(k, n):\n        while s and s[-1] < remaining[-1]:\n            s.pop()\n        if s and s[-1] > remaining[-1]:\n            return [-1]\n        if not s or s[-1] < p[i - 1]:\n            s.append(remaining.pop())\n        else:\n            s.append(p[i])\n    return p + remaining\n\nn, k = map(int, input().split())\np = list(map(int, input().split()))\nprint(*solve(n, k, p))"}
{"solution": "def does_b_appear_in_sequence(a, b, c):\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\na, b, c = map(int, input().split())\nprint(does_b_appear_in_sequence(a, b, c))"}
{"solution": "def can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    if cnt_1 == cnt_4:\n        return 1\n    elif cnt_1 + cnt_2 == cnt_3 + cnt_4:\n        return 1\n    else:\n        return 0\n\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\nprint(can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4))"}
{"solution": "def mexican_wave(n, k, t):\n    if t <= k:\n        return min(t, n)\n    elif t <= n:\n        return k\n    else:\n        return k - (t - n)\n\nn, k, t = map(int, input().split())\nprint(mexican_wave(n, k, t))"}
{"solution": "def lexicographically_minimal_string(s):\n    t = []\n    u = []\n    min_char = min(s)\n    s = list(s)\n    \n    while s or t:\n        if t and (not s or t[-1] <= min_char):\n            u.append(t.pop())\n        else:\n            char = s.pop(0)\n            t.append(char)\n            if s:\n                min_char = min(s)\n    \n    return ''.join(u)\n\ns = input().strip()\nprint(lexicographically_minimal_string(s))"}
{"solution": "def check_records(n, records):\n    for i in range(1, n):\n        plays_diff = records[i][0] - records[i-1][0]\n        clears_diff = records[i][1] - records[i-1][1]\n        \n        if plays_diff < 0 or clears_diff < 0:\n            return \"NO\"\n        \n        if clears_diff > plays_diff:\n            return \"NO\"\n    \n    return \"YES\"\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    records = [list(map(int, input().split())) for _ in range(n)]\n    \n    print(check_records(n, records))"}
{"solution": "def is_palindrome(time):\n    \"\"\"Check if a given time is a palindrome.\"\"\"\n    return time == time[::-1]\n\n\ndef next_palindrome(time):\n    \"\"\"Find the next palindrome time.\"\"\"\n    hours, minutes = map(int, time.split(':'))\n    minutes += 1\n    if minutes == 60:\n        minutes = 0\n        hours += 1\n        if hours == 24:\n            hours = 0\n    return f\"{hours:02d}:{minutes:02d}\"\n\n\ndef minutes_until_palindrome(time):\n    \"\"\"Calculate the minimum number of minutes until the next palindrome time.\"\"\"\n    minutes = 0\n    while not is_palindrome(time):\n        time = next_palindrome(time)\n        minutes += 1\n    return minutes\n\n\ndef main():\n    time = input()\n    print(minutes_until_palindrome(time))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_distance(n, arr):\n    min_idx = arr.index(1)\n    max_idx = arr.index(n)\n    \n    # Calculate the distance if we swap the minimum element with the first element\n    dist1 = abs(max_idx - 0)\n    \n    # Calculate the distance if we swap the minimum element with the last element\n    dist2 = abs(max_idx - (n - 1))\n    \n    # Calculate the distance if we swap the maximum element with the first element\n    dist3 = abs(min_idx - 0)\n    \n    # Calculate the distance if we swap the maximum element with the last element\n    dist4 = abs(min_idx - (n - 1))\n    \n    # Return the maximum distance\n    return max(dist1, dist2, dist3, dist4)\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(max_distance(n, arr))"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    mid = n // 2\n    if n % 2 == 0:\n        first_half = s[:mid]\n        second_half = s[mid:]\n    else:\n        first_half = s[:mid]\n        second_half = s[mid+1:]\n    \n    if first_half.lower() == second_half.lower()[::-1]:\n        return \"TAK\"\n    else:\n        return \"NIE\"\n\ns = input().strip()\nprint(is_s_palindrome(s))"}
{"solution": "from collections import Counter\n\ndef max_permutation(a, b):\n    a_count = Counter(a)\n    b = list(b)\n    result = []\n\n    # Try to use the largest possible digits from b\n    for digit in b:\n        if digit in a_count and a_count[digit] > 0:\n            result.append(digit)\n            a_count[digit] -= 1\n        else:\n            # If we can't use the current digit from b, try to use the next largest digit from a\n            for d in sorted(a_count.keys(), reverse=True):\n                if a_count[d] > 0:\n                    result.append(d)\n                    a_count[d] -= 1\n                    break\n\n    # Fill in the remaining digits from a\n    for digit, count in sorted(a_count.items()):\n        result.extend([digit] * count)\n\n    # Ensure the result does not start with 0\n    if result[0] == '0':\n        for i in range(1, len(result)):\n            if result[i]!= '0':\n                result[0], result[i] = result[i], result[0]\n                break\n\n    return ''.join(result)\n\na = input()\nb = input()\nprint(max_permutation(a, b))"}
{"solution": "def check_win(matrix, i, j):\n    # Check horizontal\n    count = 0\n    for k in range(max(0, j-4), min(10, j+5)):\n        if matrix[i][k] == 'X':\n            count += 1\n            if count >= 5:\n                return True\n        else:\n            count = 0\n\n    # Check vertical\n    count = 0\n    for k in range(max(0, i-4), min(10, i+5)):\n        if matrix[k][j] == 'X':\n            count += 1\n            if count >= 5:\n                return True\n        else:\n            count = 0\n\n    # Check diagonal (top-left to bottom-right)\n    count = 0\n    for k in range(max(0, i-4), min(10, i+5)):\n        for col in range(max(0, j-4), min(10, j+5)):\n            if k - i == col - j and matrix[k][col] == 'X':\n                count += 1\n                if count >= 5:\n                    return True\n            else:\n                count = 0\n\n    # Check diagonal (bottom-left to top-right)\n    count = 0\n    for k in range(max(0, i-4), min(10, i+5)):\n        for col in range(max(0, j-4), min(10, j+5)):\n            if k - i == j - col and matrix[k][col] == 'X':\n                count += 1\n                if count >= 5:\n                    return True\n            else:\n                count = 0\n\n    return False\n\n\ndef check_win_in_one_move(matrix):\n    for i in range(10):\n        for j in range(10):\n            if matrix[i][j] == '.':\n                matrix[i] = matrix[i][:j] + 'X' + matrix[i][j+1:]\n                if check_win(matrix, i, j):\n                    return True\n                matrix[i] = matrix[i][:j] + '.' + matrix[i][j+1:]\n    return False\n\n\nmatrix = [input() for _ in range(10)]\nif check_win_in_one_move(matrix):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def solve(n, k):\n    if k > n * (n + 1) // 2:\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            if k > 0:\n                matrix[i][j] = matrix[j][i] = 1\n                k -= 1\n\n    return matrix\n\n\ndef print_matrix(matrix):\n    if matrix == -1:\n        print(-1)\n    else:\n        for row in matrix:\n            print(' '.join(map(str, row)))\n\n\nn, k = map(int, input().split())\nmatrix = solve(n, k)\nprint_matrix(matrix)"}
{"solution": "import math\n\nx, y, z = map(float, input().split())\n\nexpressions = [\n    (x ** (y ** z), f\"x^{y}^{z}\"),\n    (x ** (z ** y), f\"x^{z}^{y}\"),\n    ((x ** y) ** z, f\"(x^{y})^{z}\"),\n    ((x ** z) ** y, f\"(x^{z})^{y}\"),\n    (y ** (x ** z), f\"y^{x}^{z}\"),\n    (y ** (z ** x), f\"y^{z}^{x}\"),\n    ((y ** x) ** z, f\"(y^{x})^{z}\"),\n    ((y ** z) ** x, f\"(y^{z})^{x}\"),\n    (z ** (x ** y), f\"z^{x}^{y}\"),\n    (z ** (y ** x), f\"z^{y}^{x}\"),\n    ((z ** x) ** y, f\"(z^{x})^{y}\"),\n    ((z ** y) ** x, f\"(z^{y})^{x}\"),\n]\n\nmax_value, max_expression = max(expressions, key=lambda x: x[0])\n\nprint(max_expression)"}
{"solution": "def min_operations(n, s):\n    \"\"\"\n    Calculate the minimum number of operations to type a string.\n\n    Args:\n    n (int): The length of the string.\n    s (str): The string to be typed.\n\n    Returns:\n    int: The minimum number of operations.\n    \"\"\"\n    # Initialize the minimum number of operations as the length of the string\n    min_ops = n\n\n    # Iterate over the possible lengths of the first part of the string\n    for i in range(1, n // 2 + 1):\n        # Check if the string can be divided into two equal parts\n        if s[:i] * (n // i) == s[:n // i * i]:\n            # Calculate the number of operations for this case\n            ops = i + (n // i - 1) + (n % i)\n            # Update the minimum number of operations\n            min_ops = min(min_ops, ops)\n\n    return min_ops\n\n\n# Read the input\nn = int(input())\ns = input()\n\n# Calculate and print the minimum number of operations\nprint(min_operations(n, s))"}
{"solution": "import sys\n\ndef read_input():\n    n = int(sys.stdin.readline())\n    files = []\n    for _ in range(n):\n        name, type = sys.stdin.readline().split()\n        files.append((name, int(type)))\n    return n, files\n\ndef solve(n, files):\n    examples = [file for file in files if file[1] == 1]\n    regulars = [file for file in files if file[1] == 0]\n\n    e = len(examples)\n    moves = []\n\n    # Move examples to correct positions\n    for i, file in enumerate(examples):\n        if file[0]!= str(i + 1):\n            moves.append((file[0], str(i + 1)))\n\n    # Move regulars to correct positions\n    for i, file in enumerate(regulars):\n        if file[0]!= str(e + i + 1):\n            moves.append((file[0], str(e + i + 1)))\n\n    # Handle conflicts\n    temp_files = set()\n    for i in range(1, n + 1):\n        temp_files.add(str(i))\n\n    for file in files:\n        if file[0] in temp_files:\n            temp_files.remove(file[0])\n\n    temp_index = 0\n    for i in range(len(moves)):\n        if moves[i][1] in [file[0] for file in files]:\n            temp_file = list(temp_files)[temp_index]\n            temp_index += 1\n            moves.insert(i, (moves[i][1], temp_file))\n            moves[i] = (moves[i][0], temp_file)\n\n    return moves\n\ndef print_output(moves):\n    print(len(moves))\n    for move in moves:\n        print(f\"move {move[0]} {move[1]}\")\n\ndef main():\n    n, files = read_input()\n    moves = solve(n, files)\n    print_output(moves)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_replacements(ticket):\n    \"\"\"\n    Calculate the minimum number of digits Luba needs to replace to make the ticket lucky.\n    \n    A ticket is considered lucky if the sum of the first three digits equals the sum of the last three digits.\n    \n    Parameters:\n    ticket (str): A string consisting of 6 characters (all characters are digits from 0 to 9) \u2014 this string denotes Luba's ticket.\n    \n    Returns:\n    int: The minimum possible number of digits Luba needs to replace to make the ticket lucky.\n    \"\"\"\n    \n    # Calculate the sum of the first three digits\n    sum_first_half = sum(int(digit) for digit in ticket[:3])\n    \n    # Calculate the sum of the last three digits\n    sum_second_half = sum(int(digit) for digit in ticket[3:])\n    \n    # Calculate the difference between the two sums\n    difference = abs(sum_first_half - sum_second_half)\n    \n    # If the difference is 0, the ticket is already lucky\n    if difference == 0:\n        return 0\n    \n    # If the difference is less than or equal to 9, we can make the ticket lucky by replacing one digit\n    if difference <= 9:\n        return 1\n    \n    # If the difference is greater than 9, we need to replace at least two digits\n    return 2\n\n\n# Read the ticket from the input\nticket = input()\n\n# Print the minimum number of replacements needed\nprint(min_replacements(ticket))"}
{"solution": "import math\n\nm, x = map(int, input().split())\n\ndef minimum_traps(m, x):\n    return m - 1 if m > 2 else 1\n\nprint(minimum_traps(m, x))"}
{"solution": "def mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef solve(n, k):\n    mod = 10**6 + 3\n    total_days = pow(2, n, mod)\n    prob = 1\n    for i in range(1, k):\n        prob = (prob * (total_days - i)) % mod\n        prob = (prob * mod_inverse(total_days, mod)) % mod\n    prob = (1 - prob) % mod\n    return prob, total_days\n\nn, k = map(int, input().split())\na, b = solve(n, k)\nprint(a, b)"}
{"solution": "def check_journey(n, journey):\n    \"\"\"\n    Checks if Limak's journey satisfies the given conditions.\n\n    Args:\n    n (int): The number of parts in the journey.\n    journey (list): A list of tuples, where each tuple contains the distance and direction of a part of the journey.\n\n    Returns:\n    bool: True if the journey satisfies the conditions, False otherwise.\n    \"\"\"\n    position = 0  # Initialize position at the North Pole (0)\n\n    for distance, direction in journey:\n        if position == 0 and direction!= \"South\":\n            return False  # Can't move from North Pole in any direction other than South\n        elif position == -20000 and direction!= \"North\":\n            return False  # Can't move from South Pole in any direction other than North\n\n        if direction == \"North\":\n            position += distance\n        elif direction == \"South\":\n            position -= distance\n        # Ignore East and West directions as they don't affect the North-South position\n\n        if position > 20000 or position < -20000:\n            return False  # Position is outside the valid range\n\n    return position == 0  # Journey must end at the North Pole\n\n\nn = int(input())\njourney = []\nfor _ in range(n):\n    distance, direction = input().split()\n    journey.append((int(distance), direction))\n\nif check_journey(n, journey):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_common_terms(a1, b1, a2, b2, L, R):\n    # Calculate the LCM of a1 and a2\n    lcm_value = lcm(a1, a2)\n    \n    # Calculate the first common term\n    first_common_term = (b2 - b1) // gcd(a1, a2) * a1 + b1\n    first_common_term = first_common_term + (lcm_value - first_common_term % lcm_value) % lcm_value\n    \n    # Calculate the number of common terms\n    count = 0\n    current_term = first_common_term\n    while current_term <= R:\n        if L <= current_term:\n            count += 1\n        current_term += lcm_value\n    \n    return count\n\na1, b1, a2, b2, L, R = map(int, input().split())\nprint(count_common_terms(a1, b1, a2, b2, L, R))"}
{"solution": "def max_min_pieces(n, a, b):\n    \"\"\"\n    Calculate the maximum possible number x such that Ivan can distribute the cakes \n    according to the aforementioned conditions, and each plate will contain at least x pieces of cake.\n\n    Args:\n        n (int): The number of plates.\n        a (int): The number of pieces of the first cake.\n        b (int): The number of pieces of the second cake.\n\n    Returns:\n        int: The maximum possible number x.\n    \"\"\"\n    # Calculate the total number of pieces\n    total_pieces = a + b\n    \n    # Calculate the minimum number of pieces per plate\n    min_pieces_per_plate = total_pieces // n\n    \n    # Calculate the maximum number of pieces per plate\n    max_pieces_per_plate = min_pieces_per_plate + (total_pieces % n > 0)\n    \n    # Initialize the maximum possible number x\n    max_x = 0\n    \n    # Iterate over all possible values of x\n    for x in range(min_pieces_per_plate, max_pieces_per_plate + 1):\n        # Calculate the number of plates with x pieces of the first cake\n        plates_with_x_pieces_of_first_cake = min(a // x, n)\n        \n        # Calculate the number of plates with x pieces of the second cake\n        plates_with_x_pieces_of_second_cake = min(b // x, n - plates_with_x_pieces_of_first_cake)\n        \n        # Check if it's possible to distribute the cakes with x pieces per plate\n        if plates_with_x_pieces_of_first_cake + plates_with_x_pieces_of_second_cake >= n:\n            # Update the maximum possible number x\n            max_x = x\n    \n    return max_x\n\n# Read the input\nn, a, b = map(int, input().split())\n\n# Calculate and print the maximum possible number x\nprint(max_min_pieces(n, a, b))"}
{"solution": "def is_valid_flag(n, m, field):\n    # Check if the number of unique colors is 3\n    colors = set()\n    for row in field:\n        for char in row:\n            colors.add(char)\n    if len(colors)!= 3:\n        return False\n\n    # Check if the field can be divided into three equal parts\n    if n % 3!= 0 or m % 3!= 0:\n        return False\n\n    # Check if each part has the same color\n    part_height = n // 3\n    for i in range(3):\n        color = field[i * part_height][0]\n        for j in range(part_height):\n            for k in range(m):\n                if field[i * part_height + j][k]!= color:\n                    return False\n\n    return True\n\n\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\nif is_valid_flag(n, m, field):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\ndef hex_spiral(n):\n    if n == 0:\n        return 0, 0\n\n    layer = math.ceil((math.sqrt(3 * n + 1) - 1) / 2)\n    start = 3 * (layer - 1) * layer + 1\n    pos = (n - start) % (6 * layer)\n\n    if pos < 2 * layer:\n        x = layer - pos // 2\n        y = pos // 2 + layer\n    elif pos < 4 * layer:\n        x = -layer + (pos - 2 * layer) // 2\n        y = layer + (pos - 2 * layer) // 2\n    else:\n        x = -layer - (pos - 4 * layer) // 2\n        y = -layer + (pos - 4 * layer) // 2\n\n    return x, y\n\nn = int(input())\nx, y = hex_spiral(n)\nprint(x, y)"}
{"solution": "import math\n\ndef can_break_shield(a, b, c):\n    gcd_ab = math.gcd(a, b)\n    if c % gcd_ab == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\na, b, c = map(int, input().split())\nprint(can_break_shield(a, b, c))"}
{"solution": "def can_tracks_coincide(n, L, kefa_barriers, sasha_barriers):\n    # Calculate distances between consecutive barriers for Kefa\n    kefa_distances = [(kefa_barriers[(i + 1) % n] - kefa_barriers[i]) % L for i in range(n)]\n    # Calculate distances between consecutive barriers for Sasha\n    sasha_distances = [(sasha_barriers[(i + 1) % n] - sasha_barriers[i]) % L for i in range(n)]\n    \n    # Double the kefa_distances to handle circular rotation\n    doubled_kefa_distances = kefa_distances + kefa_distances\n    \n    # Check if sasha_distances is a sublist of doubled_kefa_distances\n    for i in range(n):\n        if doubled_kefa_distances[i:i + n] == sasha_distances:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_barriers, sasha_barriers))"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome(s):\n    max_length = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if not is_palindrome(substring):\n                max_length = max(max_length, len(substring))\n    return max_length\n\ns = input()\nprint(longest_non_palindrome(s))"}
{"solution": "def is_round_rated(n, ratings):\n    \"\"\"\n    Determine if the current round is rated, unrated, or it's impossible to determine whether it is rated or not.\n\n    Args:\n    n (int): The number of round participants.\n    ratings (list): A list of tuples, where each tuple contains the rating of a participant before and after the round.\n\n    Returns:\n    str: \"rated\" if the round is rated for sure, \"unrated\" if the round is unrated for sure, \"maybe\" if it's impossible to determine.\n    \"\"\"\n\n    # Check if at least one participant's rating has changed\n    if any(before!= after for before, after in ratings):\n        return \"rated\"\n\n    # Check if the round was rated and a participant with lower rating took a better place in the standings\n    if any(ratings[i][0] < ratings[i+1][0] for i in range(n-1)):\n        return \"unrated\"\n\n    # If none of the above conditions are met, it's impossible to determine whether the round is rated or not\n    return \"maybe\"\n\n\n# Read the input\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Print the output\nprint(is_round_rated(n, ratings))"}
{"solution": "def nearest_zero(n, arr):\n    zeros = [i for i, x in enumerate(arr) if x == 0]\n    result = []\n\n    for i in range(n):\n        result.append(min([abs(i - zero) for zero in zeros]))\n\n    return result\n\nn = int(input())\narr = list(map(int, input().split()))\n\nprint(*nearest_zero(n, arr))"}
{"solution": "def count_distinct_cyclical_strings(n, s):\n    def is_substring_in_cyclical_shifts(t, s):\n        t_extended = t + t\n        return any(s in t_extended[i:i+len(t)] for i in range(len(t)))\n    \n    distinct_cyclical_strings = set()\n    \n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if is_substring_in_cyclical_shifts(t, s):\n            distinct_cyclical_strings.add(t)\n    \n    return len(distinct_cyclical_strings)\n\nfrom itertools import product\nn = int(input())\ns = input().strip()\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import math\n\ndef polar_angle(x, y):\n    \"\"\"Calculate the polar angle of a vector.\"\"\"\n    return math.atan2(y, x)\n\ndef angle_between_vectors(a, b):\n    \"\"\"Calculate the non-oriented angle between two vectors.\"\"\"\n    return min(math.pi - abs(a - b), abs(a - b))\n\ndef main():\n    n = int(input())\n    vectors = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        vectors.append((x, y, i + 1))\n\n    # Sort vectors by polar angle\n    vectors.sort(key=lambda v: polar_angle(v[0], v[1]))\n\n    min_angle = math.pi\n    min_indices = (0, 0)\n    for i in range(n - 1):\n        angle = angle_between_vectors(polar_angle(vectors[i][0], vectors[i][1]), polar_angle(vectors[i + 1][0], vectors[i + 1][1]))\n        if angle < min_angle:\n            min_angle = angle\n            min_indices = (vectors[i][2], vectors[i + 1][2])\n\n    # Check the angle between the first and last vectors\n    angle = angle_between_vectors(polar_angle(vectors[0][0], vectors[0][1]), polar_angle(vectors[-1][0], vectors[-1][1]))\n    if angle < min_angle:\n        min_angle = angle\n        min_indices = (vectors[0][2], vectors[-1][2])\n\n    print(*min_indices)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nd, k, a, b, t = map(int, sys.stdin.readline().split())\n\nif d <= k:\n    print(d * a)\nelse:\n    full_segments = d // k\n    remaining_distance = d % k\n\n    time_for_full_segments = full_segments * k * a + (full_segments - 1) * t\n\n    if remaining_distance == 0:\n        print(time_for_full_segments + t)\n    else:\n        time_drive_remaining = remaining_distance * a + t\n        time_walk_remaining = remaining_distance * b\n\n        print(time_for_full_segments + min(time_drive_remaining, time_walk_remaining))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(n, k):\n    if n < k:\n        return -1\n    if n % k == 0:\n        return [n // k] * k\n    if k == 1:\n        return [n]\n    if k == 2:\n        for i in range(1, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return [i, n - i]\n    gcd_val = n // k\n    if n % k!= 0:\n        gcd_val += 1\n    seq = list(range(gcd_val, gcd_val + k))\n    if sum(seq) == n:\n        return seq\n    return -1\n\nn, k = map(int, input().split())\nresult = solve(n, k)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def count_pairs(n, m):\n    \"\"\"\n    Counts the number of pairs of integers (x, y) such that 1 \u2264 x \u2264 n, 1 \u2264 y \u2264 m and (x + y) is divisible by 5.\n    \n    Args:\n        n (int): The upper limit of the first column.\n        m (int): The upper limit of the second column.\n    \n    Returns:\n        int: The number of pairs of integers (x, y) such that 1 \u2264 x \u2264 n, 1 \u2264 y \u2264 m and (x + y) is divisible by 5.\n    \"\"\"\n    count = 0\n    for i in range(5):\n        count += (n - i) // 5 * (m - (5 - i)) // 5\n        if (n - i) % 5 >= (5 - i):\n            count += (n - i) % 5 - (5 - i) + 1\n    return count\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))"}
{"solution": "import sys\n\ndef max_subarray_sum(arr):\n    max_sum = float('-inf')\n    current_sum = 0\n    for num in arr:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef max_subarray_sum_with_x(arr, x):\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n\n    max_sum = float('-inf')\n    for i in range(n):\n        for j in range(i, n):\n            subarray_sum = prefix_sum[j + 1] - prefix_sum[i]\n            max_sum = max(max_sum, subarray_sum * x + prefix_sum[n] - subarray_sum)\n\n    return max_sum\n\ndef main():\n    n, x = map(int, sys.stdin.readline().split())\n    arr = list(map(int, sys.stdin.readline().split()))\n\n    if x == 1:\n        print(max_subarray_sum(arr))\n    elif x == -1:\n        print(max(max_subarray_sum(arr), max_subarray_sum_with_x(arr, x)))\n    else:\n        print(max_subarray_sum_with_x(arr, x))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_kth_largest(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(m, x // i)\n        return count\n\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_less_equal(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\nn, m, k = map(int, input().split())\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    start += (k - 1) // length\n    return str(start)[(k - 1) % length]\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "def max_bourles(n, m, r, s, b):\n    max_bourles = r\n    for buy_price in s:\n        for sell_price in b:\n            if buy_price < sell_price:\n                shares = r // buy_price\n                bourles = shares * sell_price\n                max_bourles = max(max_bourles, bourles + r % buy_price)\n    return max_bourles\n\nn, m, r = map(int, input().split())\ns = sorted(map(int, input().split()))\nb = sorted(map(int, input().split()))\n\nprint(max_bourles(n, m, r, s, b))"}
{"solution": "def find_original_message(t):\n    n = len(t)\n    \n    # \u041f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u0432\u0441\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0434\u043b\u0438\u043d\u044b \u043d\u0430\u043b\u043e\u0436\u0435\u043d\u0438\u044f\n    for overlap in range(1, n // 2 + 1):\n        # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u043c\u043e\u0436\u043d\u043e \u043b\u0438 \u0440\u0430\u0437\u0434\u0435\u043b\u0438\u0442\u044c \u0441\u0442\u0440\u043e\u043a\u0443 t \u043d\u0430 \u0434\u0432\u0435 \u0447\u0430\u0441\u0442\u0438 \u0441 \u043d\u0430\u043b\u043e\u0436\u0435\u043d\u0438\u0435\u043c \u0434\u043b\u0438\u043d\u044b overlap\n        if t[:overlap] == t[-overlap:]:\n            s = t[:-overlap]\n            if s + t[-overlap:] == t and len(s) > overlap:\n                return \"YES\", s\n    \n    return \"NO\", None\n\n# \u0427\u0442\u0435\u043d\u0438\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\nt = input().strip()\n\n# \u041f\u043e\u0438\u0441\u043a \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0433\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f s\nresult, s = find_original_message(t)\n\n# \u0412\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\nprint(result)\nif result == \"YES\":\n    print(s)"}
{"solution": "import math\n\ndef calculate_teams(n):\n    teams = []\n    for i in range(1, int(math.sqrt(2 * n)) + 1):\n        if (i * (i - 1)) // 2 <= n:\n            remaining_games = n - (i * (i - 1)) // 2\n            if remaining_games == 0 or (remaining_games & (remaining_games - 1) == 0):\n                teams.append(i + 2 * remaining_games)\n    return teams\n\nn = int(input())\nteams = calculate_teams(n)\nif len(teams) == 0:\n    print(-1)\nelse:\n    for team in sorted(teams):\n        print(team)"}
{"solution": "def max_beauty(n, s, b):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    beauty = 0\n    for i in range(n // 2):\n        max_beauty = 0\n        for char in char_count:\n            if char_count[char] > 0:\n                char_count[char] -= 1\n                if s[i]!= char and s[n - i - 1]!= char:\n                    max_beauty = max(max_beauty, b[i] + b[n - i - 1])\n                char_count[char] += 1\n        beauty += max_beauty\n\n    return beauty\n\n\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\nprint(max_beauty(n, s, b))"}
{"solution": "def can_be_weighted(w, m):\n    \"\"\"\n    Determine whether an item of mass m can be weighed using the given weights in a balanced manner.\n\n    Args:\n    w (int): The number defining the masses of the weights.\n    m (int): The mass of the item.\n\n    Returns:\n    bool: True if the item can be weighted, False otherwise.\n    \"\"\"\n    # Calculate the maximum weight that can be represented using the given weights\n    max_weight = (w ** 101 - 1) // (w - 1)\n\n    # Check if the mass of the item is within the range of representable weights\n    if m > max_weight:\n        return False\n\n    # Check if the mass of the item can be represented as a sum of powers of w\n    for i in range(101):\n        # Calculate the remainder of m divided by w^i\n        remainder = m % (w ** i)\n\n        # If the remainder is not a multiple of w^i, then the mass cannot be represented\n        if remainder!= 0 and remainder!= (w ** i) - 1:\n            return False\n\n        # Subtract the remainder from the mass\n        m -= remainder\n\n    return True\n\n\ndef main():\n    # Read the input\n    w, m = map(int, input().split())\n\n    # Check if the item can be weighted\n    if can_be_weighted(w, m):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve(n, k):\n    if k > n:\n        return [-1] * k\n\n    powers = []\n    i = 0\n    while n > 0:\n        if n & 1:\n            powers.append(i)\n        n >>= 1\n        i += 1\n\n    if len(powers) < k:\n        return None\n\n    powers.sort(reverse=True)\n    powers = powers[:k]\n\n    return powers\n\n\ndef main():\n    n, k = map(int, input().split())\n    result = solve(n, k)\n\n    if result is None:\n        print(\"No\")\n    else:\n        print(\"Yes\")\n        print(*result)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def champagne_pyramid(n, t):\n    pyramid = [[0.0] * i for i in range(1, n + 1)]\n    pyramid[0][0] = t\n\n    for i in range(n):\n        for j in range(len(pyramid[i])):\n            if pyramid[i][j] > 1:\n                excess = (pyramid[i][j] - 1) / 2\n                pyramid[i][j] = 1\n                if i < n - 1:\n                    pyramid[i + 1][j] += excess\n                    pyramid[i + 1][j + 1] += excess\n\n    return sum(1 for row in pyramid for glass in row if glass >= 1)\n\n\nn, t = map(int, input().split())\nprint(champagne_pyramid(n, t))"}
{"solution": "n = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\n\nif n == 1:\n    print(-1)\nelif n == 2:\n    x1, y1 = vertices[0]\n    x2, y2 = vertices[1]\n    if x1!= x2 and y1!= y2:\n        print(abs(x1 - x2) * abs(y1 - y2))\n    else:\n        print(-1)\nelif n == 3:\n    x_coords = set()\n    y_coords = set()\n    for x, y in vertices:\n        x_coords.add(x)\n        y_coords.add(y)\n    if len(x_coords) == 2 and len(y_coords) == 2:\n        x1, x2 = x_coords\n        y1, y2 = y_coords\n        print(abs(x1 - x2) * abs(y1 - y2))\n    else:\n        print(-1)\nelif n == 4:\n    x_coords = set()\n    y_coords = set()\n    for x, y in vertices:\n        x_coords.add(x)\n        y_coords.add(y)\n    if len(x_coords) == 2 and len(y_coords) == 2:\n        x1, x2 = x_coords\n        y1, y2 = y_coords\n        print(abs(x1 - x2) * abs(y1 - y2))\n    else:\n        print(-1)"}
{"solution": "import math\n\nn = int(input())\na = int(input())\nb = int(input())\n\nvertical_length = 2 * a\nhorizontal_length = b\ntotal_length = 2 * (vertical_length + horizontal_length)\n\nif total_length <= n:\n    print(1)\nelse:\n    bars_needed = math.ceil(total_length / n)\n    print(bars_needed)"}
{"solution": "def can_sort_array(n, a, swaps):\n    \"\"\"\n    Determine if an array can be sorted in ascending order by swapping adjacent elements.\n\n    Args:\n    n (int): The number of elements in the array.\n    a (list): The array of integers.\n    swaps (str): A string of 0s and 1s indicating whether adjacent elements can be swapped.\n\n    Returns:\n    bool: True if the array can be sorted, False otherwise.\n    \"\"\"\n    # Initialize a list to store the maximum value that can be placed at each position\n    max_values = [0] * n\n\n    # Iterate over the array from right to left\n    for i in range(n - 1, -1, -1):\n        # If the current element can be swapped with the next element, update the maximum value\n        if i < n - 1 and swaps[i] == '1':\n            max_values[i] = max_values[i + 1]\n        # Otherwise, the maximum value is the current element\n        else:\n            max_values[i] = a[i]\n\n    # Iterate over the array from left to right\n    for i in range(n):\n        # If the current element is greater than the maximum value that can be placed at this position, return False\n        if a[i] > max_values[i]:\n            return False\n\n    # If we have not returned False, the array can be sorted\n    return True\n\n\n# Read the input\nn = int(input())\na = list(map(int, input().split()))\nswaps = input()\n\n# Print the result\nprint(\"YES\" if can_sort_array(n, a, swaps) else \"NO\")"}
{"solution": "def calculate_time(row, seat):\n    # Calculate the number of rows the attendants need to move\n    rows_to_move = (row - 1) // 3 * 4 + (row - 1) % 3\n\n    # Calculate the time it takes to move the rows\n    time_to_move = rows_to_move\n\n    # Calculate the time it takes to serve the rows\n    time_to_serve = (row - 1) // 3 * 12 + (row - 1) % 3 * 6\n\n    # Calculate the time it takes to serve the current row\n    if seat in 'def':\n        time_to_serve_current_row = 3\n    else:\n        time_to_serve_current_row = 6\n\n    # Calculate the time it takes to serve the current seat\n    if seat == 'f':\n        time_to_serve_current_seat = 1\n    elif seat == 'e':\n        time_to_serve_current_seat = 2\n    elif seat == 'd':\n        time_to_serve_current_seat = 3\n    elif seat == 'c':\n        time_to_serve_current_seat = 4\n    elif seat == 'b':\n        time_to_serve_current_seat = 5\n    else:\n        time_to_serve_current_seat = 6\n\n    # Calculate the total time\n    total_time = time_to_move + time_to_serve + time_to_serve_current_row - 6 + time_to_serve_current_seat\n\n    return total_time\n\n\ndef main():\n    input_str = input()\n    row = int(input_str[:-1])\n    seat = input_str[-1]\n\n    print(calculate_time(row, seat))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def convert_to_decimal(digits, base):\n    decimal = 0\n    for i, digit in enumerate(reversed(digits)):\n        decimal += digit * (base ** i)\n    return decimal\n\ndef compare_numbers():\n    n, bx = map(int, input().split())\n    x_digits = list(map(int, input().split()))\n\n    m, by = map(int, input().split())\n    y_digits = list(map(int, input().split()))\n\n    x_decimal = convert_to_decimal(x_digits, bx)\n    y_decimal = convert_to_decimal(y_digits, by)\n\n    if x_decimal < y_decimal:\n        return '<'\n    elif x_decimal > y_decimal:\n        return '>'\n    else:\n        return '='\n\nprint(compare_numbers())"}
{"solution": "def mex(arr):\n    arr.sort()\n    mex = 0\n    for num in arr:\n        if num == mex:\n            mex += 1\n    return mex\n\ndef nim_sum(arr):\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    if n == 1:\n        if arr[0] == 0:\n            print(\"BitAryo\")\n        else:\n            print(\"BitLGM\")\n    elif n == 2:\n        if arr[0] == arr[1]:\n            print(\"BitLGM\")\n        else:\n            print(\"BitAryo\")\n    else:\n        if mex(arr) == min(arr):\n            print(\"BitAryo\")\n        else:\n            print(\"BitLGM\")\n\nsolve()"}
{"solution": "import math\nfrom collections import defaultdict\n\ndef prime_factors(n):\n    factors = defaultdict(int)\n    while n % 2 == 0:\n        factors[2] += 1\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            factors[i] += 1\n            n = n / i\n    if n > 2:\n        factors[n] += 1\n    return factors\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    k_factors = prime_factors(k)\n    prefix_factors = [defaultdict(int) for _ in range(n + 1)]\n    suffix_factors = [defaultdict(int) for _ in range(n + 1)]\n\n    for i in range(n):\n        factors = prime_factors(a[i])\n        for p, c in factors.items():\n            prefix_factors[i + 1][p] = prefix_factors[i][p] + c\n            suffix_factors[n - i - 1][p] = suffix_factors[n - i][p] + c\n\n    count = 0\n    for i in range(n + 1):\n        for j in range(n + 1):\n            if i + j > n:\n                break\n            valid = True\n            for p, c in k_factors.items():\n                if prefix_factors[i][p] + suffix_factors[j][p] < c:\n                    valid = False\n                    break\n            if valid and i + j < n:\n                count += 1\n\n    print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_distribute_balloons(n, k, s):\n    color_counts = {}\n    for color in s:\n        if color in color_counts:\n            color_counts[color] += 1\n        else:\n            color_counts[color] = 1\n\n    for count in color_counts.values():\n        if count > k:\n            return \"NO\"\n\n    return \"YES\"\n\nn, k = map(int, input().split())\ns = input().strip()\n\nprint(can_distribute_balloons(n, k, s))"}
{"solution": "def find_distance_between_minima():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    min_val = min(a)\n    min_indices = [i for i, x in enumerate(a) if x == min_val]\n\n    min_distance = float('inf')\n    for i in range(len(min_indices) - 1):\n        distance = min_indices[i + 1] - min_indices[i]\n        min_distance = min(min_distance, distance)\n\n    print(min_distance)\n\nfind_distance_between_minima()"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef main():\n    t, w, b = map(int, input().split())\n    g = gcd(w, b)\n    lcm = w * b // g\n    count = t // lcm\n    gcd_count_t = gcd(count, t)\n    gcd_lcm_t = gcd(lcm, t)\n    print(f\"{count // gcd_count_t}/{t // gcd_lcm_t}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def determine_vote_result(x, y, z):\n    \"\"\"\n    Determine the result of Nauuo's comment based on the number of upvotes, downvotes, and unknown votes.\n\n    Args:\n        x (int): The number of upvotes.\n        y (int): The number of downvotes.\n        z (int): The number of unknown votes.\n\n    Returns:\n        str: The result of Nauuo's comment, either \"+\", \"-\", \"0\", or \"?\".\n    \"\"\"\n\n    # Calculate the difference between upvotes and downvotes\n    diff = x - y\n\n    # If the difference is greater than the number of unknown votes, the result is certain\n    if diff > z:\n        return \"+\"\n    elif diff < -z:\n        return \"-\"\n    elif diff == 0 and z == 0:\n        return \"0\"\n    else:\n        return \"?\"\n\n\n# Read the input\nx, y, z = map(int, input().split())\n\n# Determine and print the result\nprint(determine_vote_result(x, y, z))"}
{"solution": "def min_length_changed_subsegment(n, operations, x, y):\n    # Calculate the initial position after performing all operations\n    initial_x = operations.count('R') - operations.count('L')\n    initial_y = operations.count('U') - operations.count('D')\n\n    # Calculate the difference between the target position and the initial position\n    dx = x - initial_x\n    dy = y - initial_y\n\n    # If the target position is not reachable, return -1\n    if abs(dx) > n or abs(dy) > n:\n        return -1\n\n    # Initialize the minimum length of the changed subsegment\n    min_length = n\n\n    # Check all possible subsegments\n    for i in range(n):\n        for j in range(i, n):\n            # Calculate the number of operations to change in the subsegment\n            change_x = min(j - i + 1, abs(dx))\n            change_y = min(j - i + 1, abs(dy))\n\n            # Calculate the number of operations to change outside the subsegment\n            outside_x = abs(dx) - change_x\n            outside_y = abs(dy) - change_y\n\n            # If the target position is reachable by changing the subsegment and the outside operations, update the minimum length\n            if (outside_x <= operations[:i].count('R') + operations[j+1:].count('L') and\n                outside_x <= operations[:i].count('L') + operations[j+1:].count('R') and\n                outside_y <= operations[:i].count('U') + operations[j+1:].count('D') and\n                outside_y <= operations[:i].count('D') + operations[j+1:].count('U')):\n                min_length = min(min_length, j - i + 1)\n\n    # Return the minimum length of the changed subsegment\n    return min_length if min_length!= n else -1\n\n\nn = int(input())\noperations = input()\nx, y = map(int, input().split())\n\nprint(min_length_changed_subsegment(n, operations, x, y))"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.readline\n\n    T = int(input())\n    results = []\n\n    for _ in range(T):\n        n, x = map(int, input().split())\n        s = input().strip()\n\n        balance_s = s.count('0') - s.count('1')\n        prefix_balances = [0] * (n + 1)\n\n        for i in range(n):\n            prefix_balances[i + 1] = prefix_balances[i] + (1 if s[i] == '0' else -1)\n\n        if balance_s == 0:\n            if x in prefix_balances:\n                results.append(-1)\n            else:\n                results.append(0)\n        else:\n            count = 0\n            for b in prefix_balances:\n                if (x - b) % balance_s == 0 and (x - b) // balance_s >= 0:\n                    count += 1\n            results.append(count)\n\n    for result in results:\n        print(result)\n\nsolve()"}
{"solution": "def min_digits_to_delete(n, k):\n    n_str = str(n)\n    k_str = '0' * k\n    min_deletions = float('inf')\n\n    for i in range(len(n_str)):\n        for j in range(i + 1, len(n_str) + 1):\n            substr = n_str[i:j]\n            if substr.endswith(k_str):\n                deletions = len(n_str) - len(substr)\n                min_deletions = min(min_deletions, deletions)\n\n    if min_deletions == float('inf'):\n        min_deletions = len(n_str) - k\n\n    return min_deletions\n\nn, k = map(int, input().split())\nprint(min_digits_to_delete(n, k))"}
{"solution": "def calculate_max_min_sergei(n, m, k, x, y):\n    if n == 1:\n        max_val = k // m + (k % m > 0)\n        min_val = k // m + (k % m > 0 and k % m!= y)\n        sergei_val = k // m + (k % m >= y)\n    else:\n        cycle_length = 2 * n - 2\n        full_cycles = k // (cycle_length * m)\n        remaining_questions = k % (cycle_length * m)\n        max_val = full_cycles * (cycle_length // 2 + 1) + (remaining_questions // m + (remaining_questions % m > 0))\n        min_val = full_cycles * (cycle_length // 2) + (remaining_questions // m + (remaining_questions % m > 0 and remaining_questions % m!= 1))\n        sergei_val = full_cycles * ((x - 1) // (n - 1) + 1) + (remaining_questions // m + (remaining_questions % m >= y and (x - 1) % (n - 1) == remaining_questions // m % (n - 1)))\n    return max_val, min_val, sergei_val\n\nn, m, k, x, y = map(int, input().split())\nmax_val, min_val, sergei_val = calculate_max_min_sergei(n, m, k, x, y)\nprint(max_val, min_val, sergei_val)"}
{"solution": "def calculate_beauty(ribbon, n):\n    max_beauty = 0\n    for char in set(ribbon):\n        beauty = ribbon.count(char) + min(n, len(ribbon) - ribbon.count(char))\n        max_beauty = max(max_beauty, beauty)\n    return max_beauty\n\ndef main():\n    n = int(input())\n    ribbons = [input() for _ in range(3)]\n    beauty_values = [calculate_beauty(ribbon, n) for ribbon in ribbons]\n    max_beauty = max(beauty_values)\n    winners = [\"Kuro\", \"Shiro\", \"Katie\"]\n    if beauty_values.count(max_beauty) > 1:\n        print(\"Draw\")\n    else:\n        print(winners[beauty_values.index(max_beauty)])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_days(c, v0, v1, a, l):\n    \"\"\"\n    Calculate the number of days Mister B needs to finish the book.\n\n    Args:\n    c (int): The length of the book in pages.\n    v0 (int): The initial reading speed.\n    v1 (int): The maximum reading speed.\n    a (int): The acceleration in reading speed.\n    l (int): The number of pages for rereading.\n\n    Returns:\n    int: The number of days Mister B needs to finish the book.\n    \"\"\"\n    days = 0\n    pages_read = 0\n\n    while pages_read < c:\n        # Calculate the number of pages Mister B can read today\n        pages_today = min(v0 + days * a, v1)\n\n        # If Mister B needs to reread pages, subtract them from the total pages read\n        if days > 0:\n            pages_today -= l\n\n        # Update the total pages read\n        pages_read += pages_today\n\n        # Increment the number of days\n        days += 1\n\n    return days\n\n\n# Read the input\nc, v0, v1, a, l = map(int, input().split())\n\n# Calculate and print the number of days\nprint(calculate_days(c, v0, v1, a, l))"}
{"solution": "def is_prime(num):\n    \"\"\"Check if a number is prime.\"\"\"\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef find_primes(n):\n    \"\"\"Find a set of primes that sum up to n.\"\"\"\n    if is_prime(n):\n        return [n]\n    for i in range(2, n):\n        if is_prime(i) and is_prime(n - i):\n            return [i, n - i]\n    for i in range(2, n):\n        if is_prime(i):\n            remaining = n - i\n            for j in range(2, remaining):\n                if is_prime(j) and is_prime(remaining - j):\n                    return [i, j, remaining - j]\n\ndef main():\n    n = int(input())\n    primes = find_primes(n)\n    print(len(primes))\n    print(*primes)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_walls(grid):\n    \"\"\"Count the number of walls in each row and column.\"\"\"\n    row_walls = [row.count('*') for row in grid]\n    col_walls = [sum(1 for row in grid if row[i] == '*') for i in range(len(grid[0]))]\n    return row_walls, col_walls\n\ndef find_bomb_location(grid):\n    \"\"\"Find the location where the bomb should be placed.\"\"\"\n    row_walls, col_walls = count_walls(grid)\n    total_walls = sum(row_walls)\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if row_walls[i] + col_walls[j] - (grid[i][j] == '*') == total_walls:\n                return i + 1, j + 1\n    return None\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n)]\n    \n    bomb_location = find_bomb_location(grid)\n    if bomb_location:\n        print(\"YES\")\n        print(*bomb_location)\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\nn, m, a, b = map(int, input().split())\n\ndef min_cost(n, m, a, b):\n    remainder = n % m\n    if remainder == 0:\n        return 0\n    else:\n        cost_to_build = (m - remainder) * a\n        cost_to_demolish = remainder * b\n        return min(cost_to_build, cost_to_demolish)\n\nprint(min_cost(n, m, a, b))"}
{"solution": "def max_odd_sum_subsequence(n, sequence):\n    \"\"\"\n    This function calculates the maximum odd sum subsequence from a given sequence.\n\n    Args:\n    n (int): The length of the sequence.\n    sequence (list): A list of integers representing the sequence.\n\n    Returns:\n    int: The maximum odd sum of a subsequence.\n    \"\"\"\n    # Initialize variables to store the maximum odd and even sums\n    max_odd_sum = float('-inf')\n    max_even_sum = 0\n\n    # Iterate over the sequence\n    for num in sequence:\n        # If the current number is odd, update max_odd_sum and max_even_sum\n        if num % 2!= 0:\n            max_odd_sum, max_even_sum = max(max_odd_sum + num, max_even_sum + num), max(max_odd_sum, max_even_sum)\n        # If the current number is even, update max_even_sum\n        else:\n            max_even_sum = max(max_even_sum + num, max_even_sum)\n\n    # Return the maximum odd sum\n    return max_odd_sum\n\n\n# Read the input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Calculate and print the maximum odd sum subsequence\nprint(max_odd_sum_subsequence(n, sequence))"}
{"solution": "from collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef solve():\n    n, T = map(int, input().split())\n    songs = []\n    for _ in range(n):\n        t, g = map(int, input().split())\n        songs.append((t, g))\n\n    dp = defaultdict(lambda: [0, 0, 0])\n    for t, g in songs:\n        new_dp = defaultdict(lambda: [0, 0, 0])\n        for prev_g in range(3):\n            for prev_t in range(T + 1):\n                if prev_t + t > T:\n                    continue\n                for new_g in range(3):\n                    if new_g == g and prev_g == g:\n                        continue\n                    new_dp[(prev_t + t, new_g)][g] += dp[(prev_t, prev_g)][new_g]\n                    new_dp[(prev_t + t, new_g)][g] %= MOD\n        for key, value in new_dp.items():\n            dp[key] = value\n\n    ans = 0\n    for prev_t in range(T + 1):\n        if prev_t!= T:\n            continue\n        for prev_g in range(3):\n            ans += sum(dp[(prev_t, prev_g)])\n            ans %= MOD\n\n    print(ans)\n\nsolve()"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef totient(n):\n    \"\"\"Compute Euler's totient function\"\"\"\n    result = n\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            while n % p == 0:\n                n //= p\n            result -= result // p\n        p += 1\n    if n > 1:\n        result -= result // n\n    return result\n\ndef main():\n    m = int(input())\n    if m == 1:\n        print(1)\n        return\n\n    result = 1\n    for i in range(2, m + 1):\n        if totient(i)!= 0:\n            result += mod_inverse(totient(i), MOD)\n    result %= MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef count_good_pairs(l, r, x, y):\n    if x > y or y % x!= 0 or y < x * x:\n        return 0\n\n    count = 0\n    for a in range(x, y + 1, x):\n        if a * a > y:\n            break\n        if y % a == 0:\n            b = y // a\n            if b * x > r:\n                break\n            if a * x >= l:\n                count += (r // (a * x)) - ((l - 1) // (a * x))\n            if b * x >= l and a!= b:\n                count += (r // (b * x)) - ((l - 1) // (b * x))\n\n    return count\n\nl, r, x, y = map(int, input().split())\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef main():\n    a, b = map(int, input().split())\n    if a > b:\n        a, b = b, a\n    k = 0\n    if a!= b:\n        k = b - gcd(a, b)\n    print(k)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_additional_marks(n, k, marks):\n    \"\"\"\n    Calculate the minimal number of additional marks needed to achieve a final mark of k.\n\n    Args:\n    n (int): The number of marks received by Noora.\n    k (int): The value of the highest possible mark.\n    marks (list): A list of marks received by Noora before Leha's hack.\n\n    Returns:\n    int: The minimal number of additional marks needed.\n    \"\"\"\n    total_marks = sum(marks)\n    additional_marks = 0\n\n    while True:\n        average = (total_marks + additional_marks) / (n + additional_marks)\n        if average >= k - 0.5:\n            break\n        additional_marks += 1\n\n    return additional_marks\n\n\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\nadditional_marks = calculate_additional_marks(n, k, marks)\nprint(additional_marks)"}
{"solution": "import math\n\ndef find_d(n, arr):\n    for d in range(-1000, 1001):\n        if d == 0:\n            continue\n        positive_count = sum(1 for num in arr if num / d > 0)\n        if positive_count >= math.ceil(n / 2):\n            return d\n    return 0\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(find_d(n, arr))"}
{"solution": "def count_pairs(n):\n    if n < 10:\n        return n // 2\n    elif n % 10 == 9:\n        return 1\n    else:\n        return (n // 10) * 10 + (n % 10) // 2\n\nn = int(input())\nprint(count_pairs(n))"}
{"solution": "from collections import deque\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(a1, b1, a2, b2):\n    queue = deque([(a1, b1, 0)])\n    visited = set((a1, b1))\n    while queue:\n        a, b, steps = queue.popleft()\n        if a * b == a2 * b2:\n            return steps, (a, b), (a2, b2)\n        if a % 2 == 0 and (a // 2, b) not in visited:\n            queue.append((a // 2, b, steps + 1))\n            visited.add((a // 2, b))\n        if b % 2 == 0 and (a, b // 2) not in visited:\n            queue.append((a, b // 2, steps + 1))\n            visited.add((a, b // 2))\n        if a % 3 == 0 and (a // 3, b) not in visited:\n            queue.append((a // 3, b, steps + 1))\n            visited.add((a // 3, b))\n        if b % 3 == 0 and (a, b // 3) not in visited:\n            queue.append((a, b // 3, steps + 1))\n            visited.add((a, b // 3))\n    return -1, None, None\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\nif a1 * b1 < a2 * b2:\n    a1, b1, a2, b2 = a2, b2, a1, b1\nsteps, (a, b), (c, d) = solve(a1, b1, a2, b2)\nif steps == -1:\n    print(-1)\nelse:\n    print(steps)\n    print(a, b)\n    print(c, d)"}
{"solution": "def determine_winner(x_p, y_p, x_v, y_v):\n    \"\"\"\n    Determine the winner of the game given the starting coordinates of both pawns.\n\n    Args:\n    x_p (int): Polycarp's x-coordinate.\n    y_p (int): Polycarp's y-coordinate.\n    x_v (int): Vasiliy's x-coordinate.\n    y_v (int): Vasiliy's y-coordinate.\n\n    Returns:\n    str: The name of the winner, either \"Polycarp\" or \"Vasiliy\".\n    \"\"\"\n    # Calculate the minimum number of moves for Polycarp to reach (0, 0)\n    polycarp_moves = max(x_p, y_p)\n\n    # Calculate the minimum number of moves for Vasiliy to reach (0, 0)\n    vasiliy_moves = max(x_v + y_v - min(x_v, y_v), min(x_v, y_v))\n\n    # If Polycarp can reach (0, 0) in less moves, he wins\n    if polycarp_moves < vasiliy_moves:\n        return \"Polycarp\"\n    # If Vasiliy can reach (0, 0) in less moves, he wins\n    elif polycarp_moves > vasiliy_moves:\n        return \"Vasiliy\"\n    # If both can reach (0, 0) in the same number of moves, Polycarp wins because he starts first\n    else:\n        return \"Polycarp\"\n\n\n# Read the input coordinates\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Determine and print the winner\nprint(determine_winner(x_p, y_p, x_v, y_v))"}
{"solution": "def calculate_columns(month, weekday):\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    total_days = days_in_month[month - 1]\n    remaining_days = total_days - (7 - weekday + 1)\n    columns = 1\n    while remaining_days > 0:\n        columns += 1\n        remaining_days -= 7\n    return columns\n\nmonth, weekday = map(int, input().split())\nprint(calculate_columns(month, weekday))"}
{"solution": "def count_years_with_one_zero_in_binary(a, b):\n    def count_years_with_one_zero_in_binary_up_to(n):\n        count = 0\n        for i in range(1, n.bit_length() + 1):\n            count += 2 ** (i - 1)\n        for i in range(n.bit_length() - 1):\n            if (n >> i) & 1 == 0:\n                break\n            count += 1\n        if n.bit_length() > 1 and (n >> (n.bit_length() - 1)) & 1 == 0:\n            count -= 1\n        return count\n\n    return count_years_with_one_zero_in_binary_up_to(b) - count_years_with_one_zero_in_binary_up_to(a - 1)\n\n\na, b = map(int, input().split())\nprint(count_years_with_one_zero_in_binary(a, b))"}
{"solution": "import math\n\ndef minimal_layers(N):\n    return math.ceil((N + 1) / 2)\n\nN = int(input())\nprint(minimal_layers(N))"}
{"solution": "import math\n\ndef calculate_factorials(nums):\n    factorials = {}\n    for num in nums:\n        if num not in factorials:\n            factorials[num] = math.factorial(num)\n    return factorials\n\ndef solve(n, k, S, nums):\n    factorials = calculate_factorials(nums)\n    dp = [[0] * (k + 1) for _ in range(S + 1)]\n    dp[0][0] = 1\n\n    for num in nums:\n        for i in range(S, num - 1, -1):\n            for j in range(k + 1):\n                dp[i][j] += dp[i - num][j]\n                if j < k:\n                    dp[i][j] += dp[i - factorials[num]][j + 1]\n\n    return dp[S][k]\n\nn, k, S = map(int, input().split())\nnums = list(map(int, input().split()))\n\nprint(solve(n, k, S, nums))"}
{"solution": "def solve(n, k, a):\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        p = 0\n        while a[i] > 0:\n            if a[i] % k == 0:\n                a[i] //= k\n                p += 1\n            else:\n                return \"NO\"\n        if p > 60:\n            return \"NO\"\n    return \"YES\"\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(solve(n, k, a))"}
{"solution": "def count_divisors(n):\n    \"\"\"Count the number of divisors of a positive integer n.\"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef main():\n    \"\"\"Calculate the sum of divisors for all combinations of i, j, and k.\"\"\"\n    a, b, c = map(int, input().split())\n    total = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                total += count_divisors(i * j * k)\n    print(total % (2**30))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    neighbors = []\n    idx = state.index('X')\n    if idx == 0:\n        neighbors.append(swap(state, 0, 1))\n        neighbors.append(swap(state, 0, 2))\n    elif idx == 1:\n        neighbors.append(swap(state, 1, 0))\n        neighbors.append(swap(state, 1, 3))\n    elif idx == 2:\n        neighbors.append(swap(state, 2, 0))\n        neighbors.append(swap(state, 2, 3))\n    elif idx == 3:\n        neighbors.append(swap(state, 3, 1))\n        neighbors.append(swap(state, 3, 2))\n    return neighbors\n\ndef swap(state, i, j):\n    state = list(state)\n    state[i], state[j] = state[j], state[i]\n    return ''.join(state)\n\ndef bfs(start):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        current = queue.popleft()\n        for neighbor in get_neighbors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return visited\n\ndef can_be_same_configuration(bessie, elsie):\n    bessie_start = ''.join(bessie)\n    elsie_start = ''.join(elsie)\n    \n    bessie_reachable = bfs(bessie_start)\n    elsie_reachable = bfs(elsie_start)\n    \n    return not bessie_reachable.isdisjoint(elsie_reachable)\n\ndef main():\n    bessie = [input().strip() for _ in range(2)]\n    elsie = [input().strip() for _ in range(2)]\n\n    if can_be_same_configuration(bessie, elsie):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def convert_to_decimal(n, k):\n    decimal = 0\n    power = 0\n    for digit in reversed(k):\n        decimal += int(digit) * (n ** power)\n        power += 1\n    return decimal\n\nn = int(input())\nk = input()\n\nprint(convert_to_decimal(n, k))"}
{"solution": "def is_unimodal(arr):\n    increasing = decreasing = False\n    constant = True\n\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            if decreasing:\n                return False\n            increasing = True\n            constant = False\n        elif arr[i] < arr[i - 1]:\n            if increasing:\n                decreasing = True\n            constant = False\n        else:\n            if decreasing:\n                return False\n\n    return True\n\n\nn = int(input())\narr = list(map(int, input().split()))\n\nif is_unimodal(arr):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def solve(n, k):\n    if n == k:\n        return 1\n\n    def count(y):\n        if y == 1:\n            return n - y + 1\n        elif y % 2 == 1:\n            return count(y - 1)\n        else:\n            return count(y // 2) + count(y - 1)\n\n    lo, hi = 1, n\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if count(mid) >= k:\n            lo = mid\n        else:\n            hi = mid - 1\n    return lo\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve():\n    n, m, x, y, vx, vy = map(int, input().split())\n\n    if vx == 0:\n        if vy > 0:\n            return f\"{x} {m}\"\n        else:\n            return f\"{x} 0\"\n\n    if vy == 0:\n        if vx > 0:\n            return f\"{n} {y}\"\n        else:\n            return f\"0 {y}\"\n\n    dx = n - x if vx > 0 else x\n    dy = m - y if vy > 0 else y\n\n    g = gcd(dx, dy)\n\n    if dx // g!= dy // g:\n        return \"-1\"\n\n    if vx > 0:\n        x = n\n    else:\n        x = 0\n\n    if vy > 0:\n        y = m\n    else:\n        y = 0\n\n    return f\"{x} {y}\"\n\nprint(solve())"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    def fits(w1, h1, w2, h2, W, H):\n        return (w1 + w2 <= W and max(h1, h2) <= H) or (h1 + h2 <= H and max(w1, w2) <= W)\n    \n    if (fits(a2, b2, a3, b3, a1, b1) or fits(b2, a2, a3, b3, a1, b1) or\n        fits(a2, b2, b3, a3, a1, b1) or fits(b2, a2, b3, a3, a1, b1) or\n        fits(a3, b3, a2, b2, a1, b1) or fits(b3, a3, a2, b2, a1, b1) or\n        fits(a3, b3, b2, a2, a1, b1) or fits(b3, a3, b2, a2, a1, b1)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\nprint(can_place_paintings(a1, b1, a2, b2, a3, b3))"}
{"solution": "def calculate_written_numbers(b1, q, limit, bad_numbers):\n    \"\"\"\n    Calculate the number of progression terms that will be written on the board.\n\n    Args:\n    b1 (int): The initial term of the progression.\n    q (int): The common ratio of the progression.\n    limit (int): The absolute value of the maximal number that can be written on the board.\n    bad_numbers (list): A list of distinct integers that will never be written on the board.\n\n    Returns:\n    int or str: The number of progression terms that will be written on the board if it is finite, or \"inf\" otherwise.\n    \"\"\"\n    if q == 1:\n        # If the common ratio is 1, the progression is constant\n        if b1 in bad_numbers:\n            return 0\n        elif abs(b1) <= limit:\n            return \"inf\"\n        else:\n            return 0\n\n    if q == 0:\n        # If the common ratio is 0, the progression is constant after the first term\n        if b1 in bad_numbers:\n            return 0\n        elif abs(b1) <= limit:\n            return 1\n        else:\n            return 0\n\n    if q == -1:\n        # If the common ratio is -1, the progression alternates between two values\n        if b1 in bad_numbers:\n            if -b1 in bad_numbers:\n                return 0\n            elif abs(-b1) <= limit:\n                return \"inf\"\n            else:\n                return 0\n        elif abs(b1) <= limit:\n            if -b1 in bad_numbers:\n                return 1\n            elif abs(-b1) <= limit:\n                return \"inf\"\n            else:\n                return 1\n        else:\n            return 0\n\n    written_numbers = 0\n    current_term = b1\n\n    while abs(current_term) <= limit:\n        if current_term not in bad_numbers:\n            written_numbers += 1\n        current_term *= q\n\n    if abs(current_term) > limit:\n        return written_numbers\n    else:\n        return \"inf\"\n\n\n# Read input\nb1, q, limit, _ = map(int, input().split())\nbad_numbers = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = calculate_written_numbers(b1, q, limit, bad_numbers)\nprint(result)"}
{"solution": ""}
{"solution": "def extended_gcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x, y = extended_gcd(b % a, a)\n        return gcd, y - (b // a) * x, x\n\ndef solve(n, a, b):\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd!= 0:\n        return None\n    x *= n // gcd\n    y *= n // gcd\n    if x < 0:\n        k = -x // (b // gcd)\n        x += k * (b // gcd)\n        y -= k * (a // gcd)\n    if y < 0:\n        k = -y // (a // gcd)\n        x -= k * (b // gcd)\n        y += k * (a // gcd)\n    return x, y\n\nn = int(input())\na = int(input())\nb = int(input())\n\nsolution = solve(n, a, b)\nif solution is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(*solution)"}
{"solution": "def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\ns = int(input())\nprint(number_to_words(s))"}
{"solution": "def max_consecutive_elements_to_erase(n, array):\n    \"\"\"\n    This function calculates the maximum number of consecutive elements that can be erased from the array.\n    \n    Parameters:\n    n (int): The number of elements in the array.\n    array (list): The array of integers.\n    \n    Returns:\n    int: The maximum number of consecutive elements that can be erased.\n    \"\"\"\n    \n    # Initialize the maximum number of consecutive elements to erase\n    max_erase = 0\n    \n    # Iterate over the array\n    for i in range(n):\n        # Calculate the number of consecutive elements that can be erased from the left\n        left_erase = min(array[i] - 1, i)\n        \n        # Calculate the number of consecutive elements that can be erased from the right\n        right_erase = min(1000 - array[i] + 1, n - i - 1)\n        \n        # Update the maximum number of consecutive elements to erase\n        max_erase = max(max_erase, left_erase + right_erase)\n    \n    # Return the maximum number of consecutive elements to erase\n    return max_erase\n\n\n# Read the number of elements in the array\nn = int(input())\n\n# Read the array of integers\narray = list(map(int, input().split()))\n\n# Calculate and print the maximum number of consecutive elements to erase\nprint(max_consecutive_elements_to_erase(n, array))"}
{"solution": "def find_equator_day(n, problems):\n    \"\"\"\n    Determine the index of day when Polycarp will celebrate the equator.\n\n    Args:\n    n (int): The number of days to prepare for the programming contests.\n    problems (list): A sequence of the number of problems Polycarp will solve each day.\n\n    Returns:\n    int: The index of the day when Polycarp will celebrate the equator.\n    \"\"\"\n    total_problems = sum(problems)\n    cumulative_sum = 0\n\n    for i, problems_solved in enumerate(problems):\n        cumulative_sum += problems_solved\n        if cumulative_sum >= total_problems / 2:\n            return i + 1\n\nn = int(input())\nproblems = list(map(int, input().split()))\n\nprint(find_equator_day(n, problems))"}
{"solution": ""}
{"solution": ""}
{"solution": "def is_divisible_by_64(s):\n    \"\"\"\n    Checks if it's possible to remove some digits from a binary string\n    to get a number divisible by 64 in the binary numerical system.\n\n    Args:\n        s (str): A non-empty binary string.\n\n    Returns:\n        bool: True if it's possible to get a number divisible by 64, False otherwise.\n    \"\"\"\n    # Check if the string has at least 6 digits (minimum for a binary number to be divisible by 64)\n    if len(s) < 6:\n        return False\n\n    # Check if the string ends with '000000' (a binary number divisible by 64 must end with 6 zeros)\n    if not s.endswith('0' * 6):\n        # If not, check if it's possible to remove some digits to get a string ending with '000000'\n        if '000000' not in s:\n            return False\n\n    # If the string ends with '000000' or it's possible to remove some digits to get such a string,\n    # check if there's at least one '1' before the '000000' (a binary number divisible by 64 must have at least one '1')\n    if '1' not in s[:-6]:\n        return False\n\n    return True\n\n\ndef main():\n    s = input()\n    print('yes' if is_divisible_by_64(s) else 'no')\n\n\nif __name__ == '__main__':\n    main()"}
{"solution": "def transform_string(s):\n    result = []\n    target = 'abcdefghijklmnopqrstuvwxyz'\n    target_index = 0\n\n    for char in s:\n        if char >= target[target_index]:\n            result.append(char)\n            while target_index < len(target) and char == target[target_index]:\n                target_index += 1\n        else:\n            next_char = chr(ord(char) + 1)\n            if next_char > 'z':\n                return '-1'\n            result.append(next_char)\n\n    if target_index < len(target):\n        return '-1'\n\n    return ''.join(result)\n\ns = input()\nprint(transform_string(s))"}
{"solution": "import math\n\ndef calculate_expected_value(n, m, r, k):\n    total_positions = (n - r + 1) * (m - r + 1)\n    max_fish = min(n * m, k)\n    max_expected_value = 0\n\n    for i in range(1, max_fish + 1):\n        expected_value = (i * (i - 1) * (r ** 2)) / (2 * total_positions)\n        expected_value += (i * (n * m - i * (r ** 2) + (r ** 2) - 1)) / (2 * total_positions)\n        max_expected_value = max(max_expected_value, expected_value)\n\n    return max_expected_value\n\nn, m, r, k = map(int, input().split())\nprint(calculate_expected_value(n, m, r, k))"}
{"solution": "def maximize_product(n, arr):\n    \"\"\"\n    This function maximizes the product of an array by applying the operation a_i := -a_i - 1.\n    \n    Parameters:\n    n (int): The number of elements in the array.\n    arr (list): The input array.\n    \n    Returns:\n    list: The array with the maximal possible product of elements.\n    \"\"\"\n    \n    # Count the number of zeros in the array\n    zero_count = arr.count(0)\n    \n    # Count the number of negative numbers in the array\n    negative_count = sum(1 for num in arr if num < 0)\n    \n    # If there are an odd number of negative numbers, we need to make one of them positive\n    # to maximize the product. We choose the smallest negative number to make positive.\n    if negative_count % 2!= 0:\n        min_negative_index = arr.index(min(arr))\n        arr[min_negative_index] = -arr[min_negative_index] - 1\n    \n    # If there are no zeros and an even number of negative numbers, we can make all\n    # numbers negative to maximize the product.\n    if zero_count == 0 and negative_count % 2 == 0:\n        arr = [-num - 1 if num >= 0 else num for num in arr]\n    \n    return arr\n\n# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Maximize the product and print the result\nresult = maximize_product(n, arr)\nprint(*result)"}
{"solution": "import math\n\ndef find_kth_smallest_divisor(n, k):\n    \"\"\"\n    Find the k-th smallest divisor of n.\n\n    Args:\n    n (int): The number to find divisors for.\n    k (int): The position of the divisor to find.\n\n    Returns:\n    int: The k-th smallest divisor of n, or -1 if it doesn't exist.\n    \"\"\"\n    # Initialize a set to store unique divisors\n    divisors = set()\n\n    # Iterate over all numbers up to the square root of n\n    for i in range(1, int(math.sqrt(n)) + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # Add i and n // i to the set of divisors\n            divisors.add(i)\n            divisors.add(n // i)\n\n    # If the number of divisors is less than k, return -1\n    if len(divisors) < k:\n        return -1\n\n    # Sort the divisors and return the k-th smallest one\n    return sorted(divisors)[k - 1]\n\n# Read input from the user\nn, k = map(int, input().split())\n\n# Find and print the k-th smallest divisor\nprint(find_kth_smallest_divisor(n, k))"}
{"solution": "from collections import defaultdict\nfrom itertools import permutations\n\ndef get_digits(cube):\n    digits = set()\n    for i in range(6):\n        for j in range(i+1, 6):\n            if cube[i] == cube[j]:\n                continue\n            if (cube[i] == 6 and cube[j] == 9) or (cube[i] == 9 and cube[j] == 6):\n                continue\n            digits.add(cube[i])\n            digits.add(cube[j])\n    return digits\n\ndef get_all_digits(cubes):\n    all_digits = set()\n    for cube in cubes:\n        all_digits.update(get_digits(cube))\n    return all_digits\n\ndef get_max_number(cubes):\n    all_digits = get_all_digits(cubes)\n    if 1 not in all_digits:\n        return 0\n    if len(cubes) == 1:\n        return max(all_digits)\n    if len(cubes) == 2:\n        max_num = 0\n        for i in range(1, 10):\n            if i in all_digits:\n                max_num = i\n            else:\n                break\n        return max_num\n    max_num = 0\n    for i in range(1, 100):\n        str_i = str(i)\n        if len(str_i) > len(cubes):\n            break\n        if len(str_i) < len(cubes):\n            continue\n        digits = [int(x) for x in str_i]\n        if set(digits).issubset(all_digits):\n            max_num = i\n        else:\n            break\n    return max_num\n\nn = int(input())\ncubes = []\nfor _ in range(n):\n    cube = list(map(int, input().split()))\n    cubes.append(cube)\n\nprint(get_max_number(cubes))"}
{"solution": "import math\n\ndef k_rounding(n, k):\n    \"\"\"\n    Calculate the k-rounding of a given positive integer n.\n\n    Args:\n    n (int): The input number.\n    k (int): The number of zeros.\n\n    Returns:\n    int: The k-rounding of n.\n    \"\"\"\n    # Calculate the multiplier to get k zeros\n    multiplier = 10 ** k\n    \n    # Calculate the least common multiple of n and multiplier\n    lcm = (n * multiplier) // math.gcd(n, multiplier)\n    \n    return lcm\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the k-rounding of n\nprint(k_rounding(n, k))"}
{"solution": ""}
{"solution": "import sys\n\ndef read_input():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef calculate_probabilities(r, s, p):\n    total = r + s + p\n    probabilities = [0.0, 0.0, 0.0]\n\n    if total == 3:\n        probabilities[0] = r / total\n        probabilities[1] = s / total\n        probabilities[2] = p / total\n    else:\n        if r == 0:\n            probabilities[1] = s / (s + p)\n            probabilities[2] = p / (s + p)\n        elif s == 0:\n            probabilities[0] = r / (r + p)\n            probabilities[2] = p / (r + p)\n        elif p == 0:\n            probabilities[0] = r / (r + s)\n            probabilities[1] = s / (r + s)\n        else:\n            probabilities[0] = (r * (s + p)) / ((r + s) * (r + p))\n            probabilities[1] = (s * (r + p)) / ((r + s) * (s + p))\n            probabilities[2] = (p * (r + s)) / ((r + p) * (s + p))\n\n    return probabilities\n\ndef main():\n    r, s, p = read_input()\n    probabilities = calculate_probabilities(r, s, p)\n    print(' '.join(map(str, probabilities)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_time_together(l1, r1, l2, r2, k):\n    \"\"\"\n    Calculate the number of minutes Sonya and Filya will be able to spend together.\n\n    Args:\n        l1 (int): The start minute of Sonya's awake time.\n        r1 (int): The end minute of Sonya's awake time.\n        l2 (int): The start minute of Filya's visit time.\n        r2 (int): The end minute of Filya's visit time.\n        k (int): The minute when Sonya prinks.\n\n    Returns:\n        int: The number of minutes Sonya and Filya will be able to spend together.\n    \"\"\"\n\n    # Calculate the overlap between Sonya's awake time and Filya's visit time\n    overlap_start = max(l1, l2)\n    overlap_end = min(r1, r2)\n\n    # If there is no overlap, return 0\n    if overlap_start > overlap_end:\n        return 0\n\n    # Calculate the total overlap time\n    total_overlap = overlap_end - overlap_start + 1\n\n    # If Sonya prinks during the overlap time, subtract 1 from the total overlap time\n    if overlap_start <= k <= overlap_end:\n        total_overlap -= 1\n\n    return total_overlap\n\n\n# Read the input values\nl1, r1, l2, r2, k = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_time_together(l1, r1, l2, r2, k)\nprint(result)"}
{"solution": ""}
{"solution": "def will_pineapple_bark(t, s, x):\n    \"\"\"\n    Determine if the pineapple will bark at time x.\n\n    Args:\n    t (int): The time the pineapple barks for the first time.\n    s (int): The pineapple barking interval.\n    x (int): The time Barney wants to eat the pineapple.\n\n    Returns:\n    bool: True if the pineapple will bark at time x, False otherwise.\n    \"\"\"\n    # Calculate the number of intervals that have passed\n    intervals = (x - t) // s\n    \n    # Check if the pineapple will bark at time x\n    # If x is equal to t plus an integer multiple of s, or\n    # if x is equal to t plus an integer multiple of s plus 1\n    return (x == t + intervals * s) or (x == t + intervals * s + 1)\n\n\n# Read input\nt, s, x = map(int, input().split())\n\n# Check if the pineapple will bark at time x\nif will_pineapple_bark(t, s, x):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef find_nested_segments(n, segments):\n    sorted_segments = sorted(enumerate(segments), key=lambda x: (x[1][0], -x[1][1]))\n    max_right = -sys.maxsize\n    max_index = -1\n\n    for i, (left, right) in sorted_segments:\n        if right <= max_right:\n            return f\"{i + 1} {max_index + 1}\"\n        max_right = max(max_right, right)\n        max_index = i if max_right == right else max_index\n\n    return \"-1 -1\"\n\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\nprint(find_nested_segments(n, segments))"}
{"solution": "def decode_genome(n, s):\n    counts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\n    unknowns = 0\n\n    for char in s:\n        if char in counts:\n            counts[char] += 1\n        elif char == '?':\n            unknowns += 1\n\n    target_count = (n + 3) // 4\n\n    for char in counts:\n        if counts[char] > target_count:\n            return \"===\"\n\n    remaining = {}\n    for char in counts:\n        remaining[char] = target_count - counts[char]\n\n    result = list(s)\n    for i in range(n):\n        if result[i] == '?':\n            for char in remaining:\n                if remaining[char] > 0:\n                    result[i] = char\n                    remaining[char] -= 1\n                    break\n\n    if any(count > 0 for count in remaining.values()):\n        return \"===\"\n\n    return \"\".join(result)\n\n\nn = int(input())\ns = input()\nprint(decode_genome(n, s))"}
{"solution": "def check_win(board, symbol):\n    # Check rows\n    for row in board:\n        if row.count(symbol) == 3 and '.' in row:\n            return True\n\n    # Check columns\n    for col in range(4):\n        column = [row[col] for row in board]\n        if column.count(symbol) == 3 and '.' in column:\n            return True\n\n    # Check diagonals\n    diagonal1 = [board[i][i] for i in range(4)]\n    diagonal2 = [board[i][3-i] for i in range(4)]\n    if (diagonal1.count(symbol) == 3 and '.' in diagonal1) or (diagonal2.count(symbol) == 3 and '.' in diagonal2):\n        return True\n\n    return False\n\n\ndef main():\n    board = [input() for _ in range(4)]\n    print(\"YES\" if check_win(board, 'x') else \"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_divide_array(n, a):\n    total_sum = sum(a)\n    if total_sum % 2!= 0:\n        return False\n\n    target_sum = total_sum // 2\n    prefix_sum = 0\n    for i in range(n):\n        if prefix_sum == target_sum:\n            return True\n        prefix_sum += a[i]\n\n    for i in range(n):\n        new_prefix_sum = prefix_sum - a[i]\n        if new_prefix_sum == target_sum:\n            return True\n        new_prefix_sum += a[i]\n\n    return False\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nif can_divide_array(n, a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def can_recover(n, k, a, b):\n    zeros = [i for i, x in enumerate(a) if x == 0]\n    b.sort(reverse=True)\n\n    for i in zeros:\n        if i > 0 and a[i-1] < b[0]:\n            a[i] = b.pop(0)\n        else:\n            a[i] = b.pop()\n\n    return 'Yes' if a!= sorted(a) else 'No'\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(can_recover(n, k, a, b))"}
{"solution": "def can_distribute_grapes(x, y, z, a, b, c):\n    # Check if Andrew can eat enough green grapes\n    if x > a:\n        return False\n\n    # Calculate the remaining green grapes after Andrew eats\n    remaining_green = a - x\n\n    # Check if Dmitry can eat enough grapes\n    if y > remaining_green + b:\n        return False\n\n    # Calculate the remaining grapes after Andrew and Dmitry eat\n    remaining_grapes = remaining_green + b - (y - remaining_green)\n    remaining_grapes += c\n\n    # Check if Michal can eat enough grapes\n    if z > remaining_grapes:\n        return False\n\n    return True\n\n\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\nif can_distribute_grapes(x, y, z, a, b, c):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def is_accident_possible(traffic_lights):\n    for i in range(4):\n        if traffic_lights[i][3] == 1 and (traffic_lights[i][0] == 1 or traffic_lights[i][1] == 1 or traffic_lights[i][2] == 1):\n            return True\n        if traffic_lights[i][3] == 1 and i < 3 and (traffic_lights[i+1][0] == 1 or traffic_lights[i+1][1] == 1 or traffic_lights[i+1][2] == 1):\n            return True\n        if traffic_lights[i][3] == 1 and i == 3 and (traffic_lights[0][0] == 1 or traffic_lights[0][1] == 1 or traffic_lights[0][2] == 1):\n            return True\n    return False\n\ntraffic_lights = []\nfor _ in range(4):\n    traffic_lights.append(list(map(int, input().split())))\n\nif is_accident_possible(traffic_lights):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def get_coordinates(digit):\n    keypad = {\n        '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2),\n        '0': (3, 1)\n    }\n    return keypad[digit]\n\ndef get_vectors(number):\n    vectors = []\n    for i in range(len(number) - 1):\n        x1, y1 = get_coordinates(number[i])\n        x2, y2 = get_coordinates(number[i + 1])\n        vectors.append((x2 - x1, y2 - y1))\n    return vectors\n\ndef is_unique_finger_movement(n, number):\n    original_vectors = get_vectors(number)\n    for i in range(10**(n-1), 10**n):\n        candidate = str(i).zfill(n)\n        if candidate!= number:\n            if get_vectors(candidate) == original_vectors:\n                return \"NO\"\n    return \"YES\"\n\nn = int(input())\nnumber = input().strip()\nprint(is_unique_finger_movement(n, number))"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, f = read_ints()\n    days = []\n    for _ in range(n):\n        k, l = read_ints()\n        days.append((k, l))\n\n    days.sort(key=lambda x: min(x[0], x[1]) - min(x[0]*2, x[1]), reverse=True)\n\n    total_sold = 0\n    for i, (k, l) in enumerate(days):\n        if i < f:\n            total_sold += min(k*2, l)\n        else:\n            total_sold += min(k, l)\n\n    print(total_sold)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef calculate_messiness(n, k):\n    max_swaps = min(k, n // 2)\n    return (n * (n - 1)) // 2 - max_swaps * (max_swaps - 1)\n\nn, k = map(int, input().split())\nprint(calculate_messiness(n, k))"}
{"solution": "import math\n\ndef min_coins(N, M, K, L):\n    if M > N:\n        return -1\n\n    max_new_coins = N - K\n    if max_new_coins < L:\n        return -1\n\n    min_coins_per_friend = math.ceil(L / M)\n    if min_coins_per_friend > N // M:\n        return -1\n\n    return min_coins_per_friend\n\nN, M, K, L = map(int, input().split())\nprint(min_coins(N, M, K, L))"}
{"solution": "n, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\nmin_row, max_row = n, -1\nmin_col, max_col = m, -1\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 'B':\n            min_row = min(min_row, i)\n            max_row = max(max_row, i)\n            min_col = min(min_col, j)\n            max_col = max(max_col, j)\n\nif min_row == n:\n    print(1)\nelse:\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    if side_length > n or side_length > m:\n        print(-1)\n    else:\n        min_paint = float('inf')\n        for i in range(n - side_length + 1):\n            for j in range(m - side_length + 1):\n                paint_count = 0\n                for x in range(i, i + side_length):\n                    for y in range(j, j + side_length):\n                        if grid[x][y] == 'W':\n                            paint_count += 1\n                min_paint = min(min_paint, paint_count)\n        print(min_paint)"}
{"solution": "def can_transform_stones(n, x, y):\n    \"\"\"\n    Determine if the stones in the garden can be transformed from one state to another.\n\n    Args:\n    n (int): The number of piles with stones in the garden.\n    x (list): The initial number of stones in each pile.\n    y (list): The final number of stones in each pile.\n\n    Returns:\n    bool: True if the stones can be transformed, False otherwise.\n    \"\"\"\n    # Calculate the total number of stones in the initial and final states\n    total_x = sum(x)\n    total_y = sum(y)\n\n    # If the total number of stones is different, it's impossible to transform\n    if total_x!= total_y:\n        return False\n\n    # Sort the initial and final states\n    x.sort()\n    y.sort()\n\n    # Compare the sorted states\n    for i in range(n):\n        # If the difference between the two states is more than 1, it's impossible to transform\n        if abs(x[i] - y[i]) > 1:\n            return False\n\n    # If all checks pass, it's possible to transform the stones\n    return True\n\n\n# Read the input\nn = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Determine if the stones can be transformed\nif can_transform_stones(n, x, y):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def min_angle_diff(n, angles):\n    total_angle = sum(angles)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + angles[i]\n    \n    min_diff = float('inf')\n    for i in range(n):\n        left_angle = prefix_sum[i]\n        right_angle = total_angle - left_angle\n        diff = abs(left_angle - right_angle)\n        min_diff = min(min_diff, diff)\n    \n    return min_diff\n\nn = int(input())\nangles = list(map(int, input().split()))\nprint(min_angle_diff(n, angles))"}
{"solution": "MOD = 10**9 + 7\n\ndef pow_mod(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef main():\n    n, m = map(int, input().split())\n    if n > m:\n        print(0)\n        return\n    result = 0\n    for i in range(n + 1):\n        result += ((-1) ** i) * pow_mod(m - i, n) * pow_mod(m, i) * pow_mod(m - i, MOD - 2)\n        result %= MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef pythagorean_triple(n):\n    for m in range(1, n):\n        k = math.sqrt(n**2 + m**2)\n        if k == int(k):\n            return m, int(k)\n    for k in range(n, n**2):\n        m = math.sqrt(k**2 - n**2)\n        if m == int(m):\n            return int(m), k\n    return -1\n\nn = int(input())\nresult = pythagorean_triple(n)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def check_remainders(n, k):\n    \"\"\"\n    Checks if all remainders of n divided by integers from 1 to k are distinct.\n\n    Args:\n        n (int): The number to check remainders for.\n        k (int): The upper limit for the range of divisors.\n\n    Returns:\n        bool: True if all remainders are distinct, False otherwise.\n    \"\"\"\n    remainders = set()\n    for i in range(1, k + 1):\n        remainder = n % i\n        if remainder in remainders:\n            return False\n        remainders.add(remainder)\n    return True\n\n\ndef main():\n    n, k = map(int, input().split())\n    if check_remainders(n, k):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def compare_integers(a, b):\n    # Remove leading zeroes\n    a = a.lstrip('0')\n    b = b.lstrip('0')\n\n    # Compare lengths\n    if len(a) > len(b):\n        return '>'\n    elif len(a) < len(b):\n        return '<'\n\n    # Compare lexicographically\n    if a > b:\n        return '>'\n    elif a < b:\n        return '<'\n    else:\n        return '='\n\n# Read input\na = input()\nb = input()\n\n# Print output\nprint(compare_integers(a, b))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, p, c):\n    dp = [[[[0, 0] for _ in range(2)] for _ in range(2)] for _ in range(n + 1)]\n    dp[0][0][0][0] = 1\n\n    for i in range(n):\n        for j in range(2):\n            for k in range(2):\n                for l in range(2):\n                    if dp[i][j][k][l] == 0:\n                        continue\n                    if c[i] == -1:\n                        for x in range(2):\n                            for y in range(i + 1, n + 1):\n                                dp[y][j | (x ^ k)][k][l ^ (x ^ k)] += dp[i][j][k][l]\n                                dp[y][j | (x ^ k)][k][l ^ (x ^ k)] %= MOD\n                    elif c[i] == 0:\n                        for y in range(i + 1, n + 1):\n                            dp[y][j | (k ^ 0)][k][l ^ (k ^ 0)] += dp[i][j][k][l]\n                            dp[y][j | (k ^ 0)][k][l ^ (k ^ 0)] %= MOD\n                    else:\n                        for y in range(i + 1, n + 1):\n                            dp[y][j | (k ^ 1)][k][l ^ (k ^ 1)] += dp[i][j][k][l]\n                            dp[y][j | (k ^ 1)][k][l ^ (k ^ 1)] %= MOD\n\n    ans = 0\n    for i in range(2):\n        for j in range(2):\n            ans += dp[n][i][j][p]\n            ans %= MOD\n\n    return ans\n\nn, p = map(int, input().split())\nc = list(map(int, input().split()))\n\nprint(solve(n, p, c))"}
{"solution": "def min_rubles(n, a, b, c):\n    remainder = n % 4\n    if remainder == 0:\n        return 0\n    elif remainder == 1:\n        return min(a, b + c, 4 * c)\n    elif remainder == 2:\n        return min(2 * a, b, 3 * c)\n    else:\n        return min(3 * a, 2 * b, 4 * c)\n\nn, a, b, c = map(int, input().split())\nprint(min_rubles(n, a, b, c))"}
{"solution": "from collections import defaultdict\n\ndef dfs(graph, visited, stack, vertex):\n    visited[vertex] = True\n    stack[vertex] = True\n\n    for neighbor in graph[vertex]:\n        if not visited[neighbor]:\n            if dfs(graph, visited, stack, neighbor):\n                return True\n        elif stack[neighbor]:\n            return True\n\n    stack[vertex] = False\n    return False\n\ndef is_acyclic(graph, n):\n    visited = [False] * n\n    stack = [False] * n\n\n    for vertex in range(n):\n        if not visited[vertex]:\n            if dfs(graph, visited, stack, vertex):\n                return False\n\n    return True\n\ndef remove_edge(graph, u, v):\n    graph[u].remove(v)\n\ndef add_edge(graph, u, v):\n    graph[u].append(v)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n\n    for _ in range(m):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n\n    if is_acyclic(graph, n):\n        print(\"YES\")\n        return\n\n    for u in range(n):\n        for v in graph[u]:\n            remove_edge(graph, u, v)\n            if is_acyclic(graph, n):\n                print(\"YES\")\n                return\n            add_edge(graph, u, v)\n\n    print(\"NO\")\n\nsolve()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, m = read_ints()\n    antennas = []\n    for _ in range(n):\n        x, s = read_ints()\n        antennas.append((x, s))\n\n    antennas.sort()\n\n    dp = [float('inf')] * (m + 1)\n    dp[0] = 0\n\n    for x, s in antennas:\n        for i in range(m, -1, -1):\n            if i - s - 1 >= 0:\n                dp[i] = min(dp[i], dp[i - s - 1] + max(0, i - (x + s)))\n            if i + s + 1 <= m:\n                dp[i] = min(dp[i], dp[i + s + 1] + max(0, (x - s) - i))\n\n    print(dp[m])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_weight_subset(W, weights):\n    \"\"\"\n    Calculate the maximum possible weight of a good subset of items.\n\n    Args:\n    W (int): The maximum total weight of a good subset.\n    weights (list): A list of integers representing the number of items having weight i in the set.\n\n    Returns:\n    int: The maximum possible weight of a good subset of items.\n    \"\"\"\n    max_weight = 0\n    for i in range(8, 0, -1):\n        max_weight += min(W // i, weights[8 - i]) * i\n        W -= min(W // i, weights[8 - i]) * i\n    return max_weight\n\n\nW = int(input())\nweights = list(map(int, input().split()))\nprint(max_weight_subset(W, weights))"}
{"solution": "def min_cost(n, L, costs):\n    volumes = [2**i - 1 for i in range(1, n + 1)]\n    dp = [float('inf')] * (L + 1)\n    dp[0] = 0\n\n    for i in range(1, L + 1):\n        for j in range(n):\n            if volumes[j] <= i:\n                dp[i] = min(dp[i], dp[i - volumes[j]] + costs[j])\n\n    return dp[L]\n\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\nprint(min_cost(n, L, costs))"}
{"solution": "def max_mex(n, a):\n    a.sort()\n    mex = 1\n    for num in a:\n        if num >= mex:\n            mex += 1\n    return mex\n\nn = int(input())\na = list(map(int, input().split()))\nresult = max_mex(n, a)\nprint(result)"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(int(digit) for digit in digits)\n    \n    # Try every possible segment sum from 1 to total_sum\n    for segment_sum in range(1, total_sum + 1):\n        if total_sum % segment_sum == 0:\n            current_sum = 0\n            valid_partition = True\n            for digit in digits:\n                current_sum += int(digit)\n                if current_sum > segment_sum:\n                    valid_partition = False\n                    break\n                elif current_sum == segment_sum:\n                    current_sum = 0\n            if valid_partition and current_sum == 0 and total_sum // segment_sum > 1:\n                return \"YES\"\n    \n    return \"NO\"\n\nn = int(input())\ndigits = input().strip()\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\"\n\nusername = input().strip()\nprint(determine_gender(username))"}
{"solution": "def calculate_max_difference(n, k, tabs):\n    max_difference = 0\n    for b in range(1, n + 1):\n        closed_tabs = set()\n        i = 0\n        while True:\n            c = b + i * k\n            if 1 <= c <= n:\n                closed_tabs.add(c)\n                i += 1\n            else:\n                break\n        e = 0\n        s = 0\n        for i in range(1, n + 1):\n            if i not in closed_tabs:\n                if tabs[i - 1] == 1:\n                    e += 1\n                else:\n                    s += 1\n        max_difference = max(max_difference, abs(e - s))\n    return max_difference\n\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\nprint(calculate_max_difference(n, k, tabs))"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n, c0, c1 = map(int, read_input().split())\n\n    if c0 == c1:\n        print(n * c0 * (n.bit_length() - 1))\n        return\n\n    if c0 < c1:\n        cost = 0\n        while n > 1:\n            cost += n // 2 * c0\n            n -= n // 2\n            cost += n * c1\n            n -= n\n        print(cost)\n    else:\n        cost = 0\n        while n > 1:\n            cost += n // 2 * c1\n            n -= n // 2\n            cost += n * c0\n            n -= n\n        print(cost)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def will_meet(n, a, x, b, y):\n    if a < x:\n        dan_stations = list(range(a, x + 1))\n    else:\n        dan_stations = list(range(a, n + 1)) + list(range(1, x + 1))\n\n    if b > y:\n        vlad_stations = list(range(b, y - 1, -1))\n    else:\n        vlad_stations = list(range(b, 0, -1)) + list(range(n, y - 1, -1))\n\n    dan_stations_set = set(dan_stations)\n    vlad_stations_set = set(vlad_stations)\n\n    common_stations = dan_stations_set.intersection(vlad_stations_set)\n\n    return \"YES\" if common_stations else \"NO\"\n\nn, a, x, b, y = map(int, input().split())\nprint(will_meet(n, a, x, b, y))"}
{"solution": "import math\n\ndef is_unlucky(x, y, n):\n    \"\"\"Check if a number is unlucky.\"\"\"\n    a = 0\n    while x ** a <= n:\n        b = 0\n        while x ** a + y ** b <= n:\n            if x ** a + y ** b == n:\n                return True\n            b += 1\n        a += 1\n    return False\n\ndef max_golden_age(x, y, left, right):\n    \"\"\"Find the maximum length of The Golden Age.\"\"\"\n    max_length = 0\n    current_length = 0\n    for i in range(left, right + 1):\n        if is_unlucky(x, y, i):\n            max_length = max(max_length, current_length)\n            current_length = 0\n        else:\n            current_length += 1\n    return max(max_length, current_length)\n\nx, y, left, right = map(int, input().split())\nprint(max_golden_age(x, y, left, right))"}
{"solution": "def min_tax(n):\n    if n % 2 == 0:\n        return 2\n    elif n % 3 == 0:\n        return 3\n    elif n % 3 == 1:\n        return 2\n    else:\n        return 3\n\nn = int(input())\nprint(min_tax(n))"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    n = len(word)\n    result = []\n    i = 0\n    \n    while i < n:\n        result.append(word[i])\n        if word[i] not in vowels:\n            start = i\n            while i < n and word[i] not in vowels:\n                i += 1\n            if i - start >= 3:\n                block = word[start:i]\n                if len(set(block)) > 1:\n                    result.append(' ')\n        i += 1\n    \n    return ''.join(result)\n\nword = input()\nprint(fix_typos(word))"}
{"solution": "import sys\n\nn, m, k = map(int, sys.stdin.readline().split())\nx, s = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\nb = list(map(int, sys.stdin.readline().split()))\nc = list(map(int, sys.stdin.readline().split()))\nd = list(map(int, sys.stdin.readline().split()))\n\nmin_time = float('inf')\n\n# No spell of the first type\nfor j in range(k):\n    if d[j] <= s:\n        time = max(0, n - c[j]) * x\n        min_time = min(min_time, time)\n\n# Spell of the first type\nfor i in range(m):\n    if b[i] <= s:\n        for j in range(k):\n            if d[j] <= s - b[i]:\n                time = max(0, n - c[j]) * a[i]\n                min_time = min(min_time, time)\n\n# No spell of the second type\nfor i in range(m):\n    if b[i] <= s:\n        time = n * a[i]\n        min_time = min(min_time, time)\n\nprint(min_time)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, k, M = read_ints()\n    t = list(read_ints())\n\n    t.sort()\n\n    task_times = [sum(t[:i+1]) for i in range(k)]\n\n    dp = [0] * (n * k + 1)\n    for i in range(1, n * k + 1):\n        dp[i] = dp[i-1] + t[(i-1) % k]\n        if i >= k:\n            dp[i] = max(dp[i], dp[i-k] + task_times[k-1])\n\n    ans = 0\n    for i in range(n * k + 1):\n        if dp[i] <= M:\n            ans = max(ans, i + (i // k))\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 998244353\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef mod_binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    numerator = mod_factorial(n)\n    denominator = (mod_factorial(k) * mod_factorial(n - k)) % MOD\n    return (numerator * mod_inverse(denominator, MOD)) % MOD\n\ndef mod_catalan(n):\n    if n % 2 == 1:\n        return 0\n    n = n // 2\n    return (mod_binomial_coefficient(2 * n, n) * mod_inverse(n + 1, MOD)) % MOD\n\ndef solve(n):\n    if n % 2 == 1:\n        return 0\n    n = n // 2\n    return (mod_catalan(n) * mod_catalan(n)) % MOD\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def lara_croft_path(n, m, k):\n    # Calculate the total number of cells\n    total_cells = n * m\n\n    # Calculate the number of full rows Lara can traverse\n    full_rows = k // (m - 1)\n\n    # Calculate the remaining moves after full rows\n    remaining_moves = k % (m - 1)\n\n    # Calculate the current row\n    current_row = (full_rows % n) * 2 + 1\n\n    # If the remaining moves are even, Lara is moving up\n    if remaining_moves % 2 == 0:\n        current_row -= 1\n        if current_row == 0:\n            current_row = n\n    else:\n        current_row += 1\n        if current_row > n:\n            current_row = 1\n\n    # Calculate the current column\n    current_column = remaining_moves // 2 + 1\n\n    return current_row, current_column\n\n\nn, m, k = map(int, input().split())\ncurrent_row, current_column = lara_croft_path(n, m, k)\nprint(current_row, current_column)"}
{"solution": "import math\n\ndef prime_factors(n):\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef solve():\n    x = int(input())\n    factors = prime_factors(x)\n    a = 1\n    b = x\n    for factor in set(factors):\n        if factors.count(factor) > 1:\n            a *= factor\n            b //= factor\n    print(a, b)\n\nsolve()"}
{"solution": "def max_fruits_for_compote(a, b, c):\n    # Calculate the maximum number of complete sets for each fruit type\n    max_sets_lemons = a // 1\n    max_sets_apples = b // 2\n    max_sets_pears = c // 4\n    \n    # Find the limiting factor (minimum number of complete sets)\n    max_complete_sets = min(max_sets_lemons, max_sets_apples, max_sets_pears)\n    \n    # Calculate the total number of fruits used in the compote\n    total_fruits = max_complete_sets * (1 + 2 + 4)\n    \n    return total_fruits\n\na = int(input())\nb = int(input())\nc = int(input())\n\nprint(max_fruits_for_compote(a, b, c))"}
{"solution": "n = int(input())\nratings = list(map(int, input().split()))\nratings.sort()\nfor i in range(n):\n    if ratings[i] >= ratings[i + n]:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef is_coprime(a, b):\n    return gcd(a, b) == 1\n\ndef make_coprime_array(arr):\n    result = [arr[0]]\n    for i in range(1, len(arr)):\n        if is_coprime(result[-1], arr[i]):\n            result.append(arr[i])\n        else:\n            for j in range(2, arr[i]):\n                if is_coprime(result[-1], j) and is_coprime(j, arr[i]):\n                    result.append(j)\n                    break\n            result.append(arr[i])\n    return result\n\nn = int(input())\narr = list(map(int, input().split()))\n\nnew_arr = make_coprime_array(arr)\nprint(len(new_arr) - n)\nprint(*new_arr)"}
{"solution": "import math\nfrom functools import reduce\nfrom math import gcd\n\ndef compute_gcd_of_list(lst):\n    return reduce(gcd, lst)\n\ndef max_divisor_after_operations(N, K, A):\n    if N == 1:\n        return A[0]\n    \n    # Compute the GCD of the differences between all pairs\n    diffs = [abs(A[i] - A[j]) for i in range(N) for j in range(i + 1, N)]\n    initial_gcd = compute_gcd_of_list(diffs)\n    \n    # Check all divisors of the initial GCD\n    max_divisor = 1\n    for d in range(1, initial_gcd + 1):\n        if initial_gcd % d == 0:\n            # Check if we can make all elements divisible by d\n            if all((a % d) <= K for a in A):\n                max_divisor = d\n    \n    return max_divisor\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\nprint(max_divisor_after_operations(N, K, A))"}
{"solution": "import math\n\ndef solve():\n    x = int(input())\n    if (x & (x + 1) == 0):\n        print(0)\n        return\n    n = int(math.log2(x + 1))\n    ans = []\n    for i in range(n, 0, -1):\n        ans.append(i)\n        x ^= (1 << i) - 1\n        x += 1\n    ans.append(n + 1)\n    print(len(ans))\n    print(*ans)\n\nsolve()"}
{"solution": "import math\n\ndef min_hours_to_water_garden(n, k, bucket_lengths):\n    min_hours = float('inf')\n    \n    for length in bucket_lengths:\n        if k % length == 0:\n            hours = k // length\n            min_hours = min(min_hours, hours)\n    \n    return min_hours\n\nn, k = map(int, input().split())\nbucket_lengths = list(map(int, input().split()))\n\nprint(min_hours_to_water_garden(n, k, bucket_lengths))"}
{"solution": "from collections import deque\n\ndef can_reach_insect(n, k, line):\n    # Find the positions of the grasshopper and the insect\n    grasshopper_pos = line.index('G')\n    insect_pos = line.index('T')\n\n    # Create a queue for BFS and add the grasshopper's position\n    queue = deque([grasshopper_pos])\n\n    # Create a set to store visited positions\n    visited = set([grasshopper_pos])\n\n    while queue:\n        pos = queue.popleft()\n\n        # If the grasshopper has reached the insect, return True\n        if pos == insect_pos:\n            return True\n\n        # Calculate the next possible positions\n        next_pos = [pos - k, pos + k]\n\n        for np in next_pos:\n            # Check if the next position is within the line and is not an obstacle\n            if 0 <= np < n and line[np]!= '#':\n                # If the next position has not been visited, add it to the queue and mark it as visited\n                if np not in visited:\n                    queue.append(np)\n                    visited.add(np)\n\n    # If the grasshopper cannot reach the insect, return False\n    return False\n\nn, k = map(int, input().split())\nline = input().strip()\n\nif can_reach_insect(n, k, line):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": ""}
{"solution": "def calculate_missed_meals(breakfasts, dinners, suppers):\n    meals = [breakfasts, dinners, suppers]\n    meals.sort()\n    missed_meals = 0\n\n    if meals[0] == meals[2]:\n        return 0\n    elif meals[0] == meals[1]:\n        missed_meals = meals[2] - meals[0]\n    else:\n        missed_meals = meals[2] - meals[0] - 1\n\n    return missed_meals\n\nbreakfasts, dinners, suppers = map(int, input().split())\nprint(calculate_missed_meals(breakfasts, dinners, suppers))"}
{"solution": "import math\n\ndef find_dimensions(n, path):\n    min_x = 1\n    max_x = 10**9\n    min_y = 1\n    max_y = 10**9\n\n    for i in range(n - 1):\n        a = path[i]\n        b = path[i + 1]\n        if b - a == 1:\n            min_y = max(min_y, 2)\n            max_x = min(max_x, 10**9)\n        elif b - a > 1:\n            min_x = max(min_x, (b - a) // (b - a - 1) + 1)\n            max_y = min(max_y, b - a)\n        elif b - a == -1:\n            min_y = max(min_y, 2)\n            max_x = min(max_x, 10**9)\n        elif b - a < -1:\n            min_x = max(min_x, (a - b) // (a - b - 1) + 1)\n            max_y = min(max_y, a - b)\n\n    for x in range(min_x, max_x + 1):\n        y = math.ceil(max(path) / x)\n        if y >= min_y and y <= max_y:\n            if all(1 <= a <= x * y for a in path):\n                if all(abs(path[i] - path[i + 1]) in [1, x, -1, -x] for i in range(n - 1)):\n                    return x, y\n\n    return None\n\nn = int(input())\npath = list(map(int, input().split()))\n\ndimensions = find_dimensions(n, path)\n\nif dimensions is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(*dimensions)"}
{"solution": "def longest_subsequence(a, b):\n    i, j = 0, 0\n    result = []\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            result.append(a[i])\n            i += 1\n            j += 1\n        else:\n            i += 1\n    if not result:\n        return '-'\n    return ''.join(result)\n\na = input()\nb = input()\nprint(longest_subsequence(a, b))"}
{"solution": "def minimal_stones(n, s):\n    current_stones = 0\n    min_stones = 0\n    \n    for char in s:\n        if char == '+':\n            current_stones += 1\n        elif char == '-':\n            current_stones -= 1\n            if current_stones < min_stones:\n                min_stones = current_stones\n    return max(0, current_stones)\n\nn = int(input())\ns = input().strip()\nprint(minimal_stones(n, s))"}
{"solution": "def max_kefir(n, a, b, c):\n    \"\"\"\n    Calculate the maximum number of liters of kefir Kolya can drink.\n\n    Parameters:\n    n (int): The number of rubles Kolya has at the beginning.\n    a (int): The cost of one plastic liter bottle.\n    b (int): The cost of one glass liter bottle.\n    c (int): The money one can get back by returning an empty glass bottle.\n\n    Returns:\n    int: The maximum number of liters of kefir Kolya can drink.\n    \"\"\"\n    # Calculate the maximum number of plastic bottles Kolya can buy\n    max_plastic = n // a\n    \n    # Calculate the maximum number of glass bottles Kolya can buy\n    max_glass = n // (b - c)\n    \n    # Calculate the remaining money after buying the maximum number of glass bottles\n    remaining = n - max_glass * (b - c)\n    \n    # Calculate the additional glass bottles Kolya can buy with the remaining money\n    additional_glass = remaining // b\n    \n    # Return the total number of liters of kefir Kolya can drink\n    return max(max_plastic, max_glass + additional_glass)\n\n\n# Read the input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Print the output\nprint(max_kefir(n, a, b, c))"}
{"solution": "def play_game(deck1, deck2):\n    seen = set()\n    rounds = 0\n    while deck1 and deck2:\n        rounds += 1\n        card1 = deck1.pop(0)\n        card2 = deck2.pop(0)\n        if (tuple(deck1), tuple(deck2)) in seen:\n            return -1\n        seen.add((tuple(deck1), tuple(deck2)))\n        if card1 > card2:\n            deck1.extend([card2, card1])\n        else:\n            deck2.extend([card1, card2])\n    return rounds, 1 if deck1 else 2\n\nn = int(input())\nk1 = int(input().split()[0])\ndeck1 = list(map(int, input().split()[1:]))\nk2 = int(input().split()[0])\ndeck2 = list(map(int, input().split()[1:]))\n\nresult = play_game(deck1, deck2)\nif result == -1:\n    print(-1)\nelse:\n    print(result[0], result[1])"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    \n    has_upper = False\n    has_lower = False\n    has_digit = False\n    \n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n    \n    if has_upper and has_lower and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\"\n\npassword = input().strip()\nprint(check_password_complexity(password))"}
{"solution": "def min_exchanges(n, a, b):\n    count_a = [0] * 5\n    count_b = [0] * 5\n\n    for i in range(n):\n        count_a[a[i] - 1] += 1\n        count_b[b[i] - 1] += 1\n\n    exchanges = 0\n    for i in range(5):\n        diff = abs(count_a[i] - count_b[i])\n        if diff % 2!= 0:\n            return -1\n        exchanges += diff // 2\n\n    return exchanges\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(min_exchanges(n, a, b))"}
{"solution": "from collections import deque\n\ndef is_reachable(n, m, horizontal_streets, vertical_streets):\n    # Create a graph to represent the grid\n    graph = {}\n    for i in range(n - 1):\n        for j in range(m - 1):\n            graph[(i, j)] = []\n\n    # Add edges to the graph based on street directions\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if horizontal_streets[i] == '<':\n                if j > 0:\n                    graph[(i, j)].append((i, j - 1))\n                if j < m - 2:\n                    graph[(i, j)].append((i, j + 1))\n            else:\n                if j > 0:\n                    graph[(i, j - 1)].append((i, j))\n                if j < m - 2:\n                    graph[(i, j + 1)].append((i, j))\n\n            if vertical_streets[j] == '^':\n                if i > 0:\n                    graph[(i, j)].append((i - 1, j))\n                if i < n - 2:\n                    graph[(i, j)].append((i + 1, j))\n            else:\n                if i > 0:\n                    graph[(i - 1, j)].append((i, j))\n                if i < n - 2:\n                    graph[(i + 1, j)].append((i, j))\n\n    # Perform BFS to check if all junctions are reachable\n    visited = set()\n    queue = deque([(0, 0)])\n    visited.add((0, 0))\n\n    while queue:\n        x, y = queue.popleft()\n        for neighbor in graph[(x, y)]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n\n    return len(visited) == (n - 1) * (m - 1)\n\n\nn, m = map(int, input().split())\nhorizontal_streets = input()\nvertical_streets = input()\n\nif is_reachable(n, m, horizontal_streets, vertical_streets):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    if a[0] == 0:\n        print(\"YES\")\n        print(\"0\" if n == 1 else \"0->\" + \"->\".join(map(str, a[1:])))\n        return\n\n    for i in range(1, n):\n        if a[i] == 0:\n            print(\"YES\")\n            print(\"(\" + \"->\".join(map(str, a[:i])) + \")->\" + \"->\".join(map(str, a[i:])))\n            return\n\n    print(\"NO\")\n\nsolve()"}
{"solution": "def calculate_final_values(a, b):\n    while True:\n        if a == 0 or b == 0:\n            break\n        elif a >= 2 * b:\n            a -= 2 * b\n        elif b >= 2 * a:\n            b -= 2 * a\n        else:\n            break\n    return a, b\n\na, b = map(int, input().split())\nfinal_a, final_b = calculate_final_values(a, b)\nprint(final_a, final_b)"}
{"solution": "def count_k_divisible_numbers(k, a, b):\n    \"\"\"\n    Calculate the number of k-divisible numbers in the segment [a, b].\n    \n    Parameters:\n    k (int): The divisor.\n    a (int): The start of the segment.\n    b (int): The end of the segment.\n    \n    Returns:\n    int: The number of k-divisible numbers in the segment [a, b].\n    \"\"\"\n    # Calculate the first k-divisible number in the segment [a, b]\n    first_divisible = (a + k - 1) // k * k\n    \n    # Calculate the last k-divisible number in the segment [a, b]\n    last_divisible = b // k * k\n    \n    # If the first divisible number is greater than the last divisible number, \n    # it means there are no k-divisible numbers in the segment [a, b]\n    if first_divisible > last_divisible:\n        return 0\n    \n    # Calculate the number of k-divisible numbers in the segment [a, b]\n    count = (last_divisible - first_divisible) // k + 1\n    \n    return count\n\n# Read input\nk, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(count_k_divisible_numbers(k, a, b))"}
{"solution": "def find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    start += (k - 1) // length\n    return str(start)[(k - 1) % length]\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "def can_vasya_win(n, s):\n    # Calculate the number of moves each player will make\n    moves_each = (n - 11) // 2\n    \n    # Count the number of '8's in the string\n    count_8s = s.count('8')\n    \n    # If there are no '8's, Vasya cannot win\n    if count_8s == 0:\n        return \"NO\"\n    \n    # If there is only one '8', Vasya can only win if it's in the first position\n    if count_8s == 1:\n        return \"YES\" if s[0] == '8' else \"NO\"\n    \n    # If there are multiple '8's, Vasya can win if there are more '8's than the number of moves Petya can make\n    # plus the number of non-'8's that Vasya needs to remove to make the first '8' the first character\n    first_8_index = s.find('8')\n    non_8s_before_first_8 = first_8_index\n    return \"YES\" if count_8s > moves_each + non_8s_before_first_8 else \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Determine if Vasya has a winning strategy\nresult = can_vasya_win(n, s)\nprint(result)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_factorial(n, m):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % m\n    return result\n\ndef mod_choose(n, k, m):\n    if k > n:\n        return 0\n    result = mod_factorial(n, m)\n    result = (result * mod_inverse(mod_factorial(k, m), m)) % m\n    result = (result * mod_inverse(mod_factorial(n - k, m), m)) % m\n    return result\n\ndef solve(n, x, pos):\n    m = 10**9 + 7\n    if pos == 0:\n        return mod_factorial(n - 1, m)\n    elif pos == n - 1:\n        return mod_factorial(n - 1, m)\n    else:\n        result = 0\n        for i in range(pos):\n            if x - 1 > i:\n                left_permutations = mod_factorial(i, m)\n                right_permutations = mod_factorial(n - pos - 1, m)\n                result = (result + left_permutations * right_permutations * mod_choose(n - pos - 1, x - i - 1, m)) % m\n        return result\n\nn, x, pos = read_ints()\nprint(solve(n, x, pos))"}
{"solution": "def solve():\n    s = input()\n    k = int(input())\n\n    dp = [[False] * (k + 1) for _ in range(len(s) + 1)]\n    dp[0][0] = True\n\n    for i in range(len(s)):\n        if s[i].isalpha():\n            for j in range(k + 1):\n                if dp[i][j]:\n                    dp[i + 1][j] = True\n                    if j < k:\n                        dp[i + 1][j + 1] = True\n        elif s[i] == '?':\n            for j in range(k + 1):\n                if dp[i - 1][j]:\n                    dp[i + 1][j] = True\n                    if j < k:\n                        dp[i + 1][j + 1] = True\n        elif s[i] == '*':\n            for j in range(k + 1):\n                if dp[i - 1][j]:\n                    dp[i + 1][j] = True\n                    if j < k:\n                        dp[i + 1][j + 1] = True\n                        if j + 1 < k:\n                            dp[i + 1][j + 2] = True\n\n    if not dp[-1][k]:\n        print(\"Impossible\")\n        return\n\n    res = []\n    i, j = len(s), k\n    while i > 0 and j > 0:\n        if s[i - 1].isalpha():\n            res.append(s[i - 1])\n            i -= 1\n            j -= 1\n        elif s[i - 1] == '*':\n            if j > 1 and dp[i - 2][j - 2]:\n                res.append(s[i - 2])\n                res.append(s[i - 2])\n                i -= 2\n                j -= 2\n            elif dp[i - 2][j - 1]:\n                res.append(s[i - 2])\n                i -= 2\n                j -= 1\n            else:\n                i -= 2\n        elif s[i - 1] == '?':\n            if dp[i - 2][j - 1]:\n                res.append(s[i - 2])\n                i -= 2\n                j -= 1\n            else:\n                i -= 2\n\n    print(''.join(reversed(res)))\n\nsolve()"}
{"solution": "def min_turns(angle):\n    angle = (angle + 360) % 360  # Normalize angle to [0, 360)\n    if angle == 0:\n        return 0\n    elif angle < 90:\n        return 1\n    elif angle < 180:\n        return 2\n    elif angle < 270:\n        return 3\n    else:\n        return 1\n\nangle = int(input())\nprint(min_turns(angle))"}
{"solution": "def can_transform_spheres(a, b, c, x, y, z):\n    # Calculate the total number of spheres\n    total_spheres = a + b + c\n    \n    # Calculate the total number of spheres needed\n    total_needed = x + y + z\n    \n    # If the total number of spheres needed is more than the total number of spheres available, return False\n    if total_needed > total_spheres:\n        return False\n    \n    # Calculate the parity of the total number of spheres and the total number of spheres needed\n    parity_spheres = total_spheres % 2\n    parity_needed = total_needed % 2\n    \n    # If the parity of the total number of spheres and the total number of spheres needed is different, return False\n    if parity_spheres!= parity_needed:\n        return False\n    \n    # Calculate the maximum number of spheres that can be transformed\n    max_transformed = (a // 2) + (b // 2) + (c // 2)\n    \n    # Calculate the number of spheres that need to be transformed\n    needed_transformed = max(0, x - a) + max(0, y - b) + max(0, z - c)\n    \n    # If the number of spheres that need to be transformed is more than the maximum number of spheres that can be transformed, return False\n    if needed_transformed > max_transformed:\n        return False\n    \n    # If all conditions are met, return True\n    return True\n\n# Read the input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Print the output\nif can_transform_spheres(a, b, c, x, y, z):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def solve(n, k, m):\n    dp = [[0] * k for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(k):\n            for d in range(10):\n                next_j = (j * 10 + d) % k\n                dp[i][next_j] = (dp[i][next_j] + dp[i - 1][j]) % m\n\n    ans = sum(dp[n][j] for j in range(1, k)) % m\n    return ans\n\nn, k, m = map(int, input().split())\nprint(solve(n, k, m))"}
{"solution": "def max_team_size():\n    l, r, a = map(int, input().split())\n    \n    if l > r:\n        l, r = r, l  # Ensure l is always the smaller or equal group\n    \n    # Use ambidexters to balance the difference\n    d = r - l\n    if a >= d:\n        l += d\n        a -= d\n        # Now l == r, distribute remaining ambidexters equally\n        l += a // 2\n        r += a // 2\n    else:\n        l += a\n        # Not enough ambidexters to balance completely, r remains larger\n    \n    # The maximum team size is twice the smaller group\n    return 2 * min(l, r)\n\nprint(max_team_size())"}
{"solution": "def min_moves(n, k):\n    k -= 1\n    moves = 0\n    for i in range(n):\n        if i < k:\n            moves += 2 * (k - i) + 1\n        elif i > k:\n            moves += 2 * (i - k) + 1\n    return moves\n\nn, k = map(int, input().split())\nprint(min_moves(n, k))"}
{"solution": "def min_tower_height(n, m):\n    \"\"\"\n    Calculate the minimum height necessary for the tallest of the students' towers.\n\n    Args:\n    n (int): The number of students using two-block pieces.\n    m (int): The number of students using three-block pieces.\n\n    Returns:\n    int: The minimum possible height of the tallest tower.\n    \"\"\"\n    # Initialize the current height for two-block and three-block towers\n    two_block_height = 0\n    three_block_height = 0\n\n    # Initialize the count of used heights\n    used_heights = set()\n\n    # Generate heights for two-block towers\n    for _ in range(n):\n        two_block_height += 2\n        # If the generated height is already used, increment it by 1\n        while two_block_height in used_heights:\n            two_block_height += 1\n        used_heights.add(two_block_height)\n\n    # Generate heights for three-block towers\n    for _ in range(m):\n        three_block_height += 3\n        # If the generated height is already used, increment it by 1\n        while three_block_height in used_heights:\n            three_block_height += 1\n        used_heights.add(three_block_height)\n\n    # Return the maximum height\n    return max(two_block_height, three_block_height)\n\n\n# Read input\nn, m = map(int, input().split())\n\n# Print the result\nprint(min_tower_height(n, m))"}
{"solution": "from collections import Counter\n\nn = int(input())\nnumbers = [int(input()) for _ in range(n)]\n\ncounts = Counter(numbers)\neven_counts = [num for num, count in counts.items() if count % 2 == 0 and count!= 0]\n\nif len(even_counts) < 2:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(even_counts[0], even_counts[1])"}
{"solution": "def can_place_soldiers(n, k, groups):\n    total_seats = n * 8\n    total_soldiers = sum(groups)\n\n    if total_soldiers > total_seats:\n        return False\n\n    groups.sort(reverse=True)\n\n    for i in range(k):\n        if groups[i] > 4:\n            if i == 0:\n                if groups[i] > total_seats:\n                    return False\n                total_seats -= groups[i]\n            else:\n                return False\n\n    for i in range(k):\n        if groups[i] == 4:\n            if total_seats < 4:\n                return False\n            total_seats -= 4\n\n    for i in range(k):\n        if groups[i] == 3:\n            if total_seats < 4:\n                return False\n            total_seats -= 4\n\n    for i in range(k):\n        if groups[i] == 2:\n            if total_seats < 2:\n                return False\n            total_seats -= 2\n\n    for i in range(k):\n        if groups[i] == 1:\n            if total_seats < 1:\n                return False\n            total_seats -= 1\n\n    return True\n\n\nn, k = map(int, input().split())\ngroups = list(map(int, input().split()))\n\nif can_place_soldiers(n, k, groups):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def calculate_cost(sticks, t):\n    return sum(min(abs(stick - t), abs(stick - (t - 1)), abs(stick - (t + 1))) for stick in sticks)\n\ndef main():\n    n = int(input())\n    sticks = list(map(int, input().split()))\n\n    min_cost = float('inf')\n    optimal_t = None\n\n    for t in range(1, 101):\n        cost = calculate_cost(sticks, t)\n        if cost < min_cost:\n            min_cost = cost\n            optimal_t = t\n\n    print(optimal_t, min_cost)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n, m = map(int, input().split())\nmin_x, max_x, min_y, max_y = float('inf'), float('-inf'), float('inf'), float('-inf')\n\nfor i in range(n):\n    row = input()\n    for j in range(m):\n        if row[j] == '*':\n            min_x, max_x = min(min_x, i), max(max_x, i)\n            min_y, max_y = min(min_y, j), max(max_y, j)\n\nside = max(max_x - min_x + 1, max_y - min_y + 1)\nprint(side)"}
{"solution": "import sys\n\nMOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef mod_binomial_coefficient(n, k):\n    numerator = mod_factorial(n)\n    denominator = (mod_factorial(k) * mod_factorial(n - k)) % MOD\n    return (numerator * mod_inverse(denominator, MOD)) % MOD\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    ones = a.count(1)\n    zeros = n - ones\n\n    if ones == 0 or zeros == 0:\n        print(1)\n        return\n\n    if k < ones * zeros:\n        print(0)\n        return\n\n    result = 0\n    for i in range(ones + 1):\n        for j in range(zeros + 1):\n            if i + j > n:\n                break\n            if i * (n - j) < ones:\n                continue\n            if (i * (n - j) - ones) % 2!= 0:\n                continue\n            delta = (i * (n - j) - ones) // 2\n            if delta > k:\n                continue\n            coefficient = mod_binomial_coefficient(ones, i) * mod_binomial_coefficient(zeros, j)\n            coefficient %= MOD\n            result += coefficient * mod_binomial_coefficient(k, delta)\n            result %= MOD\n\n    denominator = mod_binomial_coefficient(n, 2) ** k\n    denominator %= MOD\n    result *= mod_inverse(denominator, MOD)\n    result %= MOD\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_seconds(x, y):\n    return x - y + max(0, (x - y) // 2)\n\nx, y = map(int, input().split())\nprint(min_seconds(x, y))"}
{"solution": "import math\n\ndef calculate_determinant(a, b, c, d):\n    return a * d - b * c\n\ndef calculate_norm(a, b, c, d):\n    return max(abs(a), abs(b), abs(c), abs(d))\n\ndef calculate_min_norm(a, b, c, d):\n    det = calculate_determinant(a, b, c, d)\n    if det == 0:\n        return 0\n\n    norm = calculate_norm(a, b, c, d)\n    if norm == 0:\n        return 0\n\n    x = abs(det) / (abs(a) + abs(b) + abs(c) + abs(d))\n    return x\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\nmin_norm = calculate_min_norm(a, b, c, d)\nprint(format(min_norm, \".10f\"))"}
{"solution": "def restaurant_denials(n, a, b, groups):\n    \"\"\"\n    Calculate the total number of people the restaurant denies service to.\n\n    Args:\n    n (int): The number of groups coming to the restaurant.\n    a (int): The number of one-seater tables.\n    b (int): The number of two-seater tables.\n    groups (list): A list of integers representing the size of each group.\n\n    Returns:\n    int: The total number of people the restaurant denies service to.\n    \"\"\"\n    one_seater_tables = a\n    two_seater_tables = b\n    occupied_seats = 0\n    denials = 0\n\n    for group in groups:\n        if group == 1:\n            if one_seater_tables > 0:\n                one_seater_tables -= 1\n            elif two_seater_tables > 0:\n                two_seater_tables -= 1\n                occupied_seats += 1\n            elif occupied_seats > 0:\n                occupied_seats -= 1\n            else:\n                denials += 1\n        else:\n            if two_seater_tables > 0:\n                two_seater_tables -= 1\n                occupied_seats += 2\n            else:\n                denials += 2\n\n    return denials\n\n\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\nprint(restaurant_denials(n, a, b, groups))"}
{"solution": "def calculate_students(a, b, c, n):\n    \"\"\"\n    Calculate the number of students who didn't pass the exam.\n\n    Args:\n    a (int): The number of students who visited BugDonalds.\n    b (int): The number of students who visited BeaverKing.\n    c (int): The number of students who visited both restaurants.\n    n (int): The total number of students in the group.\n\n    Returns:\n    int: The number of students who didn't pass the exam, or -1 if the data is contradictory.\n    \"\"\"\n    # Calculate the total number of students who visited at least one restaurant\n    total_visited = a + b - c\n    \n    # Check if the total number of students who visited at least one restaurant exceeds the total number of students\n    if total_visited > n:\n        return -1\n    \n    # Calculate the number of students who didn't pass the exam\n    didnt_pass = n - total_visited\n    \n    # Check if at least one student didn't pass the exam\n    if didnt_pass < 1:\n        return -1\n    \n    return didnt_pass\n\n\n# Read the input values\na, b, c, n = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_students(a, b, c, n)\nprint(result)"}
{"solution": "def power(base, exponent, mod):\n    result = 1\n    base %= mod\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % mod\n        exponent //= 2\n        base = (base * base) % mod\n    return result\n\ndef solve():\n    x, k = map(int, input().split())\n    mod = 10**9 + 7\n    result = x\n    for _ in range(k):\n        result = (result * 2 + (power(2, _, mod) - 1)) % mod\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "MOD = 998244353\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_multiply(a, b):\n    return (a * b) % MOD\n\ndef mod_add(a, b):\n    return (a + b) % MOD\n\ndef mod_subtract(a, b):\n    return (a - b) % MOD\n\ndef calculate_probability(n, problems):\n    total_probability = 1\n    for i in range(n):\n        total_probability = mod_multiply(total_probability, mod_subtract(problems[i][1], problems[i][0]) + 1)\n    for i in range(1, n + 1):\n        total_probability = mod_multiply(total_probability, mod_inverse(i, MOD))\n    for i in range(n):\n        for j in range(i + 1, n):\n            l1, r1 = problems[i]\n            l2, r2 = problems[j]\n            if l1 > r2 or l2 > r1:\n                continue\n            intersection_length = min(r1, r2) - max(l1, l2) + 1\n            if intersection_length <= 0:\n                continue\n            probability = mod_multiply(intersection_length, mod_multiply(mod_inverse(r1 - l1 + 1, MOD), mod_inverse(r2 - l2 + 1, MOD)))\n            total_probability = mod_subtract(total_probability, probability)\n    return total_probability\n\nn = int(input())\nproblems = []\nfor _ in range(n):\n    l, r = map(int, input().split())\n    problems.append((l, r))\n\nprobability = calculate_probability(n, problems)\nprint(mod_multiply(probability, mod_inverse(mod_multiply(1, mod_multiply(998244351, 1)), MOD)))"}
{"solution": "def count_ways(n):\n    count = 0\n    for a in range(1, n // 4 + 1):\n        for b in range(a, (n - a) // 3 + 1):\n            c = n - 2 * a - b\n            if c >= b and a + b + c == n and 2 * a!= b and 2 * a!= c and 2 * b!= c:\n                count += 1\n            if c < b:\n                break\n    return count\n\nn = int(input())\nprint(count_ways(n))"}
{"solution": "def fair_nut(n, s, v):\n    v.sort()\n    total_volume = sum(v)\n    if total_volume < s:\n        return -1\n\n    low, high = 0, v[-1]\n    while low < high:\n        mid = (low + high + 1) // 2\n        required_volume = sum(min(mid, vi) for vi in v)\n        if required_volume > s:\n            high = mid - 1\n        else:\n            low = mid\n    return low\n\nn, s = map(int, input().split())\nv = list(map(int, input().split()))\nprint(fair_nut(n, s, v))"}
{"solution": "def calculate_days(h1, h2, a, b):\n    \"\"\"\n    Calculate the number of days it takes for the caterpillar to reach the apple.\n\n    Args:\n    h1 (int): The initial height of the caterpillar.\n    h2 (int): The height of the apple.\n    a (int): The distance the caterpillar moves up during the day.\n    b (int): The distance the caterpillar slips down during the night.\n\n    Returns:\n    int: The number of days it takes for the caterpillar to reach the apple, or -1 if it's impossible.\n    \"\"\"\n    # Calculate the total distance the caterpillar needs to cover\n    total_distance = h2 - h1\n\n    # Calculate the net distance the caterpillar covers in a day\n    net_distance_per_day = 12 * a - 14 * b\n\n    # If the caterpillar slips down more than it moves up, it's impossible to reach the apple\n    if net_distance_per_day <= 0:\n        return -1\n\n    # Calculate the number of days it takes to cover the total distance\n    days = total_distance // net_distance_per_day\n\n    # If there's still some distance left, add one more day\n    if total_distance % net_distance_per_day!= 0:\n        days += 1\n\n    # Calculate the remaining distance after the last full day\n    remaining_distance = total_distance - (days - 1) * net_distance_per_day\n\n    # If the caterpillar can reach the apple during the day, subtract one day\n    if remaining_distance <= 12 * a:\n        days -= 1\n\n    return days\n\n\n# Read the input\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_days(h1, h2, a, b))"}
{"solution": "def calculate_max_joy_units():\n    C, Hr, Hb, Wr, Wb = map(int, input().split())\n\n    max_joy_units = 0\n\n    for r in range(C // Wr + 1):\n        remaining_weight = C - r * Wr\n        b = remaining_weight // Wb\n\n        joy_units = r * Hr + b * Hb\n\n        max_joy_units = max(max_joy_units, joy_units)\n\n    print(max_joy_units)\n\ncalculate_max_joy_units()"}
{"solution": "def calculate_min_steps(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the minimal number of steps the robot should make to get the finish position.\n\n    Args:\n        x1 (int): The x-coordinate of the start position.\n        y1 (int): The y-coordinate of the start position.\n        x2 (int): The x-coordinate of the finish position.\n        y2 (int): The y-coordinate of the finish position.\n\n    Returns:\n        int: The minimal number of steps to get the finish position.\n    \"\"\"\n    # Calculate the absolute difference between the x-coordinates\n    dx = abs(x2 - x1)\n    \n    # Calculate the absolute difference between the y-coordinates\n    dy = abs(y2 - y1)\n    \n    # The minimal number of steps is the maximum of dx and dy\n    # This is because the robot can move diagonally, so it can cover the maximum difference in one step\n    return max(dx, dy)\n\n\n# Read the start position coordinates\nx1, y1 = map(int, input().split())\n\n# Read the finish position coordinates\nx2, y2 = map(int, input().split())\n\n# Calculate and print the minimal number of steps\nprint(calculate_min_steps(x1, y1, x2, y2))"}
{"solution": "def predict_outcome(n, fractions):\n    \"\"\"\n    Predict the outcome of the vote based on the given fractions and their optimal behavior.\n\n    Args:\n    n (int): The number of employees.\n    fractions (str): A string of 'D's and 'R's representing the fractions of the employees.\n\n    Returns:\n    str: The predicted outcome of the vote, either 'D' or 'R'.\n    \"\"\"\n    # Initialize the counts of 'D's and 'R's\n    d_count = fractions.count('D')\n    r_count = n - d_count\n\n    # If the number of 'D's is greater than the number of 'R's, 'D' will win\n    if d_count > r_count:\n        return 'D'\n    # If the number of 'R's is greater than the number of 'D's, 'R' will win\n    elif r_count > d_count:\n        return 'R'\n    # If the number of 'D's and 'R's is equal, the outcome depends on the last employee\n    else:\n        # If the last employee is 'D', 'D' will win\n        if fractions[-1] == 'D':\n            return 'D'\n        # If the last employee is 'R', 'R' will win\n        else:\n            return 'R'\n\n# Read the input\nn = int(input())\nfractions = input()\n\n# Predict and print the outcome\nprint(predict_outcome(n, fractions))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_tv_sets(a, b, x, y):\n    g = gcd(x, y)\n    x //= g\n    y //= g\n\n    max_w = a // x\n    max_h = b // y\n\n    min_w = math.ceil(1 / x)\n    min_h = math.ceil(1 / y)\n\n    max_wh = min(max_w, max_h)\n    min_wh = max(min_w, min_h)\n\n    return max(0, max_wh - min_wh + 1)\n\na, b, x, y = map(int, input().split())\nprint(count_tv_sets(a, b, x, y))"}
{"solution": "import math\n\ndef prime_factors(n):\n    \"\"\"Returns a dictionary of prime factors and their powers\"\"\"\n    factors = {}\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors[i] = factors.get(i, 0) + 1\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef count_trailing_zeros(n, b):\n    \"\"\"Returns the number of trailing zeros in the base b representation of n!\"\"\"\n    factors = prime_factors(b)\n    min_count = float('inf')\n    for p in factors:\n        count = 0\n        i = p\n        while i <= n:\n            count += n // i\n            i *= p\n        count //= factors[p]\n        min_count = min(min_count, count)\n    return min_count\n\nn, b = map(int, input().split())\nprint(count_trailing_zeros(n, b))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nm, a, b = map(int, input().split())\n\nif a > b:\n    a, b = b, a\n\nif a == b:\n    print((m + 1) * (m + 2) // 2)\nelse:\n    c = lcm(a, b)\n    ans = 0\n    for i in range(0, m + 1, c):\n        ans += (i // a + 1) * (min(m, i + c - 1) - i + 1)\n    print(ans)"}
{"solution": "def can_divide_into_odd_subsegments(n, sequence):\n    \"\"\"\n    Decide whether it is possible to divide the sequence into an odd number of non-empty subsegments,\n    each of which has an odd length and begins and ends with odd numbers.\n\n    Args:\n        n (int): The length of the sequence.\n        sequence (list): The elements of the sequence.\n\n    Returns:\n        bool: True if it's possible to fulfill the requirements, False otherwise.\n    \"\"\"\n    # Initialize a variable to track the number of subsegments\n    subsegments = 0\n\n    # Initialize a variable to track the current subsegment length\n    current_length = 0\n\n    # Iterate over the sequence\n    for i, num in enumerate(sequence):\n        # If the number is odd, it could be the start or end of a subsegment\n        if num % 2!= 0:\n            # If this is the start of a new subsegment, increment the subsegment count\n            if current_length == 0:\n                subsegments += 1\n            # Increment the current subsegment length\n            current_length += 1\n        else:\n            # If the number is even, it can't be the start or end of a subsegment\n            # If the current subsegment length is odd, it's a valid subsegment\n            if current_length % 2!= 0:\n                # Reset the current subsegment length\n                current_length = 0\n            else:\n                # If the current subsegment length is even, it's not a valid subsegment\n                # Return False\n                return False\n\n    # If the last subsegment is valid, return True if the total number of subsegments is odd\n    return subsegments % 2!= 0 and current_length % 2!= 0\n\n\n# Read the input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Print the output\nprint(\"Yes\" if can_divide_into_odd_subsegments(n, sequence) else \"No\")"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    # Calculate the side length of the square\n    side_length = abs(x2 - x1)\n    if side_length == 0:\n        side_length = abs(y2 - y1)\n\n    # Check if the points form a square\n    if (x2 - x1) ** 2 + (y2 - y1) ** 2!= 2 * side_length ** 2:\n        return -1\n\n    # Calculate the coordinates of the remaining trees\n    x3, y3 = x1, y2\n    x4, y4 = x2, y1\n\n    # Check if the points are distinct\n    if (x3, y3) in [(x1, y1), (x2, y2)] or (x4, y4) in [(x1, y1), (x2, y2)]:\n        return -1\n\n    return x3, y3, x4, y4\n\n\n# Read the input\nx1, y1, x2, y2 = map(int, input().split())\n\n# Find and print the coordinates of the remaining trees\nresult = find_remaining_trees(x1, y1, x2, y2)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def matrix_multiply(a, b, mod):\n    c = [[0, 0], [0, 0]]\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                c[i][j] += a[i][k] * b[k][j]\n            c[i][j] %= mod\n    return c\n\ndef matrix_power(matrix, n, mod):\n    if n == 1:\n        return matrix\n    if n % 2 == 0:\n        half_pow = matrix_power(matrix, n // 2, mod)\n        return matrix_multiply(half_pow, half_pow, mod)\n    else:\n        half_pow = matrix_power(matrix, n // 2, mod)\n        return matrix_multiply(matrix_multiply(half_pow, half_pow, mod), matrix, mod)\n\ndef calculate_f_n(x, y, n, mod):\n    if n == 1:\n        return x\n    if n == 2:\n        return y\n    matrix = [[1, 1], [1, 0]]\n    result_matrix = matrix_power(matrix, n - 2, mod)\n    return (result_matrix[0][0] * y - result_matrix[1][0] * x) % mod\n\nmod = 10**9 + 7\nx, y = map(int, input().split())\nn = int(input())\nprint(calculate_f_n(x, y, n, mod))"}
{"solution": "def split_array(n, arr):\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n\n    if prefix_sum[n] == 0:\n        return \"NO\"\n\n    result = []\n    start = 0\n    for i in range(1, n + 1):\n        if prefix_sum[i]!= 0 and prefix_sum[i]!= prefix_sum[n]:\n            result.append((start + 1, i))\n            start = i\n\n    result.append((start + 1, n))\n    return \"YES\\n\" + str(len(result)) + \"\\n\" + \"\\n\".join(map(lambda x: \"{} {}\".format(x[0], x[1]), result))\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(split_array(n, arr))"}
{"solution": "def min_score(n, m, k):\n    MOD = 10**9 + 9\n    if m < n // 2 + 1:\n        return m\n    else:\n        score = n - m\n        score += (m - score) // (k - 1) * (k - 1)\n        score += (m - score) % (k - 1)\n        score *= 2 ** ((m - score) // (k - 1))\n        return score % MOD\n\nn, m, k = map(int, input().split())\nprint(min_score(n, m, k))"}
{"solution": "def is_divisible_by_8(num):\n    return num % 8 == 0\n\ndef find_divisible_by_8(num_str):\n    for i in range(len(num_str)):\n        for j in range(i + 1, len(num_str) + 1):\n            substr = num_str[i:j]\n            if substr[0]!= '0' and is_divisible_by_8(int(substr)):\n                return substr\n    return None\n\ndef main():\n    num_str = input()\n    divisible_num = find_divisible_by_8(num_str)\n    if divisible_num is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(divisible_num)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_floor(n, m, flats):\n    min_flats_per_floor = 1\n    max_flats_per_floor = n\n\n    for flat, floor in flats:\n        min_flats_per_floor = max(min_flats_per_floor, (flat - 1) // (floor - 1) + 1)\n        max_flats_per_floor = min(max_flats_per_floor, (flat - 1) // (floor - 1) + 1)\n\n    for flats_per_floor in range(min_flats_per_floor, max_flats_per_floor + 1):\n        if (n - 1) // flats_per_floor + 1!= (flat - 1) // flats_per_floor + 1:\n            max_flats_per_floor = flats_per_floor - 1\n            break\n\n    if min_flats_per_floor == max_flats_per_floor:\n        return (n - 1) // min_flats_per_floor + 1\n    else:\n        return -1\n\n\nn, m = map(int, input().split())\nflats = [tuple(map(int, input().split())) for _ in range(m)]\n\nprint(find_floor(n, m, flats))"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    board = [[board1[i], board2[i]] for i in range(n)]\n    \n    # Define the four possible shapes of the bishwock\n    bishwock_shapes = [\n        [(0, 0), (0, 1), (1, 0)],  # Original L shape\n        [(0, 0), (0, 1), (1, 1)],  # Rotated 90 degrees\n        [(0, 1), (1, 0), (1, 1)],  # Rotated 180 degrees\n        [(0, 0), (1, 0), (1, 1)]   # Rotated 270 degrees\n    ]\n    \n    def can_place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            if nx >= 2 or ny >= n or board[ny][nx] == 'X':\n                return False\n        return True\n    \n    def place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            board[ny][nx] = 'X'\n    \n    count = 0\n    for y in range(n):\n        for x in range(2):\n            for shape in bishwock_shapes:\n                if can_place_bishwock(x, y, shape):\n                    place_bishwock(x, y, shape)\n                    count += 1\n                    break\n    \n    return count\n\nboard1 = input()\nboard2 = input()\nprint(max_bishwocks(board1, board2))"}
{"solution": "def max_pretty_set_length(n, s):\n    max_length = 0\n    current_set = set()\n    \n    for char in s:\n        if char.islower():\n            current_set.add(char)\n        else:\n            max_length = max(max_length, len(current_set))\n            current_set.clear()\n    \n    # Check the last segment\n    max_length = max(max_length, len(current_set))\n    \n    return max_length\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult = max_pretty_set_length(n, s)\n\n# Print the result\nprint(result)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\na.sort(reverse=True)\nB = sum(a)\nprint(B)"}
{"solution": "def min_refuel(a, b, f, k):\n    if 2 * a * k > b:\n        return -1\n\n    if f * 2 > b:\n        return -1\n\n    if (a - f) * 2 > b:\n        return -1\n\n    if (a - f) * 2 <= b and f * 2 <= b:\n        return 0\n\n    if (a - f) * 2 <= b and f * 2 > b:\n        return k\n\n    if (a - f) * 2 > b and f * 2 <= b:\n        return k\n\n    if (a - f) * 2 > b and f * 2 > b:\n        return k * 2\n\n    if (2 * a) % b == 0:\n        return (2 * a * k) // b\n\n    return (2 * a * k) // b + 1\n\n\na, b, f, k = map(int, input().split())\nprint(min_refuel(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    result = []\n    i = 0\n    while i < n:\n        if i + q <= n:\n            result.append(s[i:i+q])\n            i += q\n        elif i + p <= n:\n            result.append(s[i:i+p])\n            i += p\n        else:\n            return \"-1\"\n    return str(len(result)) + \"\\n\" + \"\\n\".join(result)\n\nn, p, q = map(int, input().split())\ns = input()\nprint(split_string(n, p, q, s))"}
{"solution": "import sys\n\ndef solve(n, m, s, d, obstacles):\n    obstacles.sort()\n    i = 0\n    pos = 0\n    while i < n:\n        if obstacles[i] - pos < s:\n            if obstacles[i] + d >= m:\n                print(\"RUN\", obstacles[i] - pos)\n                pos = obstacles[i]\n                print(\"JUMP\", m - pos)\n                return\n            else:\n                return print(\"IMPOSSIBLE\")\n        else:\n            print(\"RUN\", s)\n            pos += s\n            print(\"JUMP\", min(d, obstacles[i] - pos))\n            pos = obstacles[i] + min(d, obstacles[i] - pos)\n        i += 1\n    if pos < m:\n        print(\"RUN\", m - pos)\n\nn, m, s, d = map(int, sys.stdin.readline().split())\nobstacles = list(map(int, sys.stdin.readline().split()))\nsolve(n, m, s, d, obstacles)"}
{"solution": "def solve(s, x):\n    if (s - x) % 2!= 0:\n        return 0\n    b = (s - x) // 2\n    a = s - b\n    if a > 0 and b > 0 and a!= b:\n        return 4\n    elif a > 0 and b > 0 and a == b:\n        return 2\n    else:\n        return 0\n\ns, x = map(int, input().split())\nprint(solve(s, x))"}
{"solution": "def solve(n, k):\n    if n <= 2 * k:\n        return [1]\n    elif n == 2 * k + 1:\n        return [1, n]\n    else:\n        result = []\n        i = 1\n        while i <= n:\n            result.append(i)\n            i += 2 * k + 1\n        if i - 2 * k <= n:\n            result.append(n)\n        return result\n\nn, k = map(int, input().split())\nresult = solve(n, k)\nprint(len(result))\nprint(*result)"}
{"solution": "import math\n\nn = input().strip()\nn_len = len(n)\n\nmax_square_root = int(math.sqrt(2 * 10**9)) + 1\nsquares = [str(i * i) for i in range(1, max_square_root + 1)]\n\ndef is_subsequence(small, large):\n    it = iter(large)\n    return all(char in it for char in small)\n\nmin_deletions = float('inf')\n\nfor square in squares:\n    if is_subsequence(square, n):\n        deletions = n_len - len(square)\n        min_deletions = min(min_deletions, deletions)\n\nprint(min_deletions if min_deletions!= float('inf') else -1)"}
{"solution": "import math\n\nMOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, y = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef mod_permutations(n, k):\n    return (mod_factorial(n) * mod_inverse(mod_factorial(n - k), MOD)) % MOD\n\ndef count_permutations(n):\n    if n <= 2:\n        return 1\n    elif n == 3:\n        return 4\n    else:\n        max_value = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                max_value += 1\n        if max_value == 2:\n            return mod_permutations(n - 1, n - 2)\n        else:\n            return (mod_permutations(n - 1, n - 2) * (n - 2)) % MOD\n\nn = int(input())\nprint(count_permutations(n))"}
{"solution": "def minimum_jump_ability(s):\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    positions = [-1]  # Start position before the first character\n    \n    # Collect positions of all vowels\n    for i, char in enumerate(s):\n        if char in vowels:\n            positions.append(i)\n    \n    positions.append(len(s))  # End position after the last character\n    \n    # Calculate maximum distance between consecutive positions\n    max_distance = 0\n    for i in range(1, len(positions)):\n        max_distance = max(max_distance, positions[i] - positions[i - 1])\n    \n    return max_distance\n\ns = input()\nprint(minimum_jump_ability(s))"}
{"solution": "def can_distribute_equally(a):\n    total_sum = sum(a)\n    if total_sum % 2!= 0:\n        return False\n\n    target_sum = total_sum // 2\n    a.sort(reverse=True)\n\n    def dfs(index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(a):\n            return False\n\n        return dfs(index + 1, current_sum + a[index]) or dfs(index + 1, current_sum)\n\n    return dfs(0, 0)\n\n\na = list(map(int, input().split()))\nprint(\"YES\" if can_distribute_equally(a) else \"NO\")"}
{"solution": "def calculate_pie_sums(n, pie_sizes):\n    alice_sum = 0\n    bob_sum = 0\n    alice_turn = False\n\n    for i in range(n - 1, -1, -1):\n        if alice_turn:\n            if pie_sizes[i] >= pie_sizes[i - 1]:\n                alice_sum += pie_sizes[i]\n                alice_turn = False\n            else:\n                alice_sum += pie_sizes[i - 1]\n                alice_turn = False\n        else:\n            if pie_sizes[i] >= pie_sizes[i - 1]:\n                bob_sum += pie_sizes[i - 1]\n                alice_turn = True\n            else:\n                bob_sum += pie_sizes[i]\n                alice_turn = True\n\n    return alice_sum, bob_sum\n\n\nn = int(input())\npie_sizes = list(map(int, input().split()))\n\nalice_sum, bob_sum = calculate_pie_sums(n, pie_sizes)\n\nprint(alice_sum, bob_sum)"}
{"solution": "def min_variables(n, a):\n    a = [0] + a\n    dp = [[False] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if a[i] - a[j] in a[:j]:\n                dp[i][j] = True\n            if j > 0 and dp[i - 1][j - 1]:\n                dp[i][j] = True\n            if j > 0 and dp[i - 1][j]:\n                dp[i][j] = True\n\n    for i in range(1, n + 1):\n        if dp[n][i]:\n            return i\n\n    return -1\n\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_variables(n, a))"}
{"solution": "def determine_winner(n, piles):\n    odd_count = sum(1 for pile in piles if pile % 2!= 0)\n    if odd_count % 2 == 0:\n        return \"Alice\" if min(piles) % 2!= 0 else \"Bob\"\n    else:\n        return \"Alice\"\n\nn = int(input())\npiles = list(map(int, input().split()))\n\nprint(determine_winner(n, piles))"}
{"solution": "def can_make_equal(n, a):\n    if n == 1:\n        return \"YES\"\n    \n    a.sort()\n    diff = a[-1] - a[0]\n    \n    if diff == 0:\n        return \"YES\"\n    \n    for i in range(1, n - 1):\n        if (a[i] - a[0]) % diff!= 0:\n            return \"NO\"\n    \n    return \"YES\"\n\nn = int(input())\na = list(map(int, input().split()))\n\nprint(can_make_equal(n, a))"}
{"solution": "def longest_repeated_substring(n, s):\n    max_length = 0\n    for length in range(1, n // 2 + 1):\n        for i in range(n - length):\n            substring = s[i:i + length]\n            if s.find(substring, i + length)!= -1:\n                max_length = max(max_length, length)\n    return max_length\n\nn = int(input())\ns = input()\nprint(longest_repeated_substring(n, s))"}
{"solution": "def minimum_time_to_house(n, a):\n    if a % 2 == 1:\n        # a is odd\n        return (a + 1) // 2\n    else:\n        # a is even\n        return (n - a + 2) // 2\n\nn, a = map(int, input().split())\nprint(minimum_time_to_house(n, a))"}
{"solution": "def find_interval(n, m, colors, counts):\n    \"\"\"\n    Find if there exists a contiguous interval of Jedi Knights with prescribed color counts.\n\n    Args:\n    n (int): The number of Jedi Knights.\n    m (int): The number of possible colors.\n    colors (list): A list of colors of the lightsabers of the Jedi Knights.\n    counts (list): A list of desired counts of lightsabers of each color.\n\n    Returns:\n    bool: True if an interval with prescribed color counts exists, False otherwise.\n    \"\"\"\n    # Initialize a dictionary to store the current counts of each color\n    current_counts = {i: 0 for i in range(1, m + 1)}\n\n    # Initialize the left and right pointers of the sliding window\n    left = 0\n    right = 0\n\n    # Initialize a flag to check if the current window meets the required counts\n    meets_counts = False\n\n    # Expand the right pointer to include more elements in the window\n    while right < n:\n        # Add the color at the right pointer to the current counts\n        current_counts[colors[right]] += 1\n\n        # Check if the current window meets the required counts\n        meets_counts = all(current_counts[i] == counts[i - 1] for i in range(1, m + 1))\n\n        # If the current window meets the required counts, return True\n        if meets_counts:\n            return True\n\n        # If the current window exceeds the required counts, move the left pointer\n        while any(current_counts[i] > counts[i - 1] for i in range(1, m + 1)):\n            # Remove the color at the left pointer from the current counts\n            current_counts[colors[left]] -= 1\n\n            # Move the left pointer to the right\n            left += 1\n\n            # Check if the current window meets the required counts\n            meets_counts = all(current_counts[i] == counts[i - 1] for i in range(1, m + 1))\n\n            # If the current window meets the required counts, return True\n            if meets_counts:\n                return True\n\n        # Move the right pointer to the right\n        right += 1\n\n    # If no valid window is found, return False\n    return False\n\n\n# Read the input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\ncounts = list(map(int, input().split()))\n\n# Find if an interval with prescribed color counts exists\nresult = find_interval(n, m, colors, counts)\n\n# Print the result\nprint(\"YES\" if result else \"NO\")"}
{"solution": "def determine_winner():\n    n = int(input())\n    mishka_wins = 0\n    chris_wins = 0\n    \n    for _ in range(n):\n        m, c = map(int, input().split())\n        if m > c:\n            mishka_wins += 1\n        elif c > m:\n            chris_wins += 1\n    \n    if mishka_wins > chris_wins:\n        print(\"Mishka\")\n    elif chris_wins > mishka_wins:\n        print(\"Chris\")\n    else:\n        print(\"Friendship is magic!^^\")\n\ndetermine_winner()"}
{"solution": "def is_valid_field(n, m, field):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                continue\n\n            if field[i][j] == '.':\n                for direction in directions:\n                    ni, nj = i + direction[0], j + direction[1]\n                    if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':\n                        return False\n            else:\n                count = 0\n                for direction in directions:\n                    ni, nj = i + direction[0], j + direction[1]\n                    if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':\n                        count += 1\n                if count!= int(field[i][j]):\n                    return False\n\n    return True\n\n\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\nif is_valid_field(n, m, field):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def can_vasya_eat_half(n, k):\n    total_candies = n\n    vasya_eaten = 0\n    \n    while total_candies > 0:\n        # Vasya eats k candies\n        vasya_eaten += min(k, total_candies)\n        total_candies -= min(k, total_candies)\n        \n        # Petya eats 10% of the remaining candies\n        petya_eaten = total_candies // 10\n        total_candies -= petya_eaten\n    \n    return vasya_eaten >= (n + 1) // 2\n\ndef find_min_k(n):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\nn = int(input().strip())\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace(s):\n    p = s.count('o')\n    l = s.count('-')\n    \n    if p == 0 or p == 1:\n        return \"YES\"\n    if l % p == 0:\n        return \"YES\"\n    return \"NO\"\n\ns = input()\nprint(can_rearrange_necklace(s))"}
{"solution": "def max_pillows(n, m, k):\n    \"\"\"\n    Calculate the maximum number of pillows Frodo can have.\n\n    Args:\n    n (int): The number of hobbits.\n    m (int): The number of pillows.\n    k (int): The position of Frodo's bed.\n\n    Returns:\n    int: The maximum number of pillows Frodo can have.\n    \"\"\"\n    # Calculate the number of pillows that can be distributed equally\n    equal_pillows = m // n\n    \n    # Calculate the remaining pillows after equal distribution\n    remaining_pillows = m % n\n    \n    # If Frodo is at the edge, he can take all the remaining pillows\n    if k == 1 or k == n:\n        return equal_pillows + remaining_pillows\n    \n    # If Frodo is not at the edge, he can take at most one more pillow than his neighbors\n    else:\n        # Calculate the maximum number of pillows Frodo can have\n        max_frodo_pillows = equal_pillows + min(remaining_pillows, 1)\n        \n        # If Frodo takes one more pillow, his neighbors will have one less\n        # So, we need to check if this will hurt any hobbit\n        if max_frodo_pillows - equal_pillows > 1:\n            return equal_pillows + 1\n        else:\n            return max_frodo_pillows\n\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Print output\nprint(max_pillows(n, m, k))"}
{"solution": "import math\n\ndef max_subarray_cost(n, m, k, a):\n    max_cost = 0\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    for length in range(1, m + 1):\n        dp = [float('-inf')] * (n + 1)\n        for i in range(length, n + 1):\n            dp[i] = max(dp[i - 1], prefix_sum[i] - prefix_sum[i - length] - k * math.ceil(length / m))\n            max_cost = max(max_cost, dp[i])\n\n    return max_cost\n\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\nprint(max_subarray_cost(n, m, k, a))"}
{"solution": "import math\n\ndef distance(p1, p2):\n    \"\"\"Calculate the Euclidean distance between two points.\"\"\"\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef longest_polyline(n, m):\n    \"\"\"Find the longest possible polyline on a rectangular grid.\"\"\"\n    # Define the four points of the polyline\n    points = [(0, 0), (n, 0), (n, m), (0, m)]\n    \n    # Calculate the total length of the polyline\n    total_length = sum(distance(points[i], points[i+1]) for i in range(3))\n    \n    # If the grid is a square, the longest polyline is a diagonal\n    if n == m:\n        points = [(0, 0), (n, 0), (0, m), (n, m)]\n    # If the grid is taller than it is wide, the longest polyline is a zigzag\n    elif m > n:\n        points = [(0, 0), (0, m), (n, 0), (n, m)]\n    # If the grid is wider than it is tall, the longest polyline is a zigzag\n    else:\n        points = [(0, 0), (n, 0), (0, m), (n, m)]\n    \n    return points\n\ndef main():\n    n, m = map(int, input().split())\n    points = longest_polyline(n, m)\n    for point in points:\n        print(*point)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_smallest_number(shuffled_string, remembered_substring):\n    # Find the length of the original number\n    for i in range(len(shuffled_string) - 1, -1, -1):\n        if shuffled_string[i].isdigit():\n            original_length = int(shuffled_string[i])\n            break\n\n    # Remove the length from the shuffled string\n    shuffled_string = shuffled_string[:i]\n\n    # Initialize the result with the remembered substring\n    result = remembered_substring\n\n    # Initialize a set of used digits\n    used_digits = set(remembered_substring)\n\n    # Initialize a counter for the number of digits in the result\n    result_length = len(remembered_substring)\n\n    # Iterate over the shuffled string\n    for digit in shuffled_string:\n        # If the digit is not in the used digits and adding it to the result does not exceed the original length\n        if digit not in used_digits and result_length < original_length:\n            # Add the digit to the result\n            result += digit\n            # Add the digit to the used digits\n            used_digits.add(digit)\n            # Increment the result length\n            result_length += 1\n\n    # If the result length is less than the original length, add the remaining digits from the shuffled string\n    if result_length < original_length:\n        for digit in shuffled_string:\n            if digit not in used_digits:\n                result += digit\n                used_digits.add(digit)\n                result_length += 1\n                if result_length == original_length:\n                    break\n\n    # If the result starts with a zero, remove the leading zeros\n    if result[0] == '0' and len(result) > 1:\n        result = result.lstrip('0')\n\n    # If the result is empty, return '0'\n    if not result:\n        return '0'\n\n    return result\n\nshuffled_string = input()\nremembered_substring = input()\nprint(find_smallest_number(shuffled_string, remembered_substring))"}
{"solution": "def check_temperature_consistency(n, m, min_temp, max_temp, temperatures):\n    \"\"\"\n    Checks if the given temperatures can be extended to meet the minimum and maximum constraints.\n\n    Args:\n        n (int): The total number of temperatures.\n        m (int): The number of temperatures reported by the assistant.\n        min_temp (int): The minimum temperature.\n        max_temp (int): The maximum temperature.\n        temperatures (list): The list of temperatures reported by the assistant.\n\n    Returns:\n        bool: True if the temperatures can be extended, False otherwise.\n    \"\"\"\n    # Check if the minimum temperature is already present in the reported temperatures\n    if min_temp not in temperatures:\n        # If not, we need to add it\n        temperatures.append(min_temp)\n        m += 1\n\n    # Check if the maximum temperature is already present in the reported temperatures\n    if max_temp not in temperatures:\n        # If not, we need to add it\n        temperatures.append(max_temp)\n        m += 1\n\n    # Check if we have exceeded the total number of temperatures\n    if m > n:\n        return False\n\n    # Check if we can add the remaining temperatures without violating the constraints\n    remaining_temps = n - m\n    for temp in temperatures:\n        if temp < min_temp or temp > max_temp:\n            return False\n\n    # If we have not returned False by now, it means the temperatures can be extended\n    return True\n\n\n# Read the input\nn, m, min_temp, max_temp = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\n# Check the temperature consistency\nif check_temperature_consistency(n, m, min_temp, max_temp, temperatures):\n    print(\"Correct\")\nelse:\n    print(\"Incorrect\")"}
{"solution": "import math\n\ndef find_trailing_zeroes(m):\n    start = 5 * m\n    end = 5 * (m + 1)\n    count = 0\n    result = []\n\n    for i in range(start, end):\n        zeroes = 0\n        j = i\n        while j % 5 == 0:\n            j //= 5\n            zeroes += 1\n        if zeroes == m:\n            count += 1\n            result.append(i)\n\n    print(count)\n    print(*result)\n\nm = int(input())\nfind_trailing_zeroes(m)"}
{"solution": "import sys\nimport heapq\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_int_list():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n, m, k = read_ints()\n    special_vertices = read_int_list()\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v, w = read_ints()\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    distances = [0] * (n + 1)\n    for start in special_vertices:\n        pq = [(-float('inf'), start)]\n        visited = set()\n        while pq:\n            dist, node = heapq.heappop(pq)\n            if node in visited:\n                continue\n            visited.add(node)\n            distances[node] = max(distances[node], -dist)\n            for neighbor, weight in graph[node]:\n                if neighbor not in visited:\n                    heapq.heappush(pq, (min(dist, -weight), neighbor))\n\n    max_distances = [0] * k\n    for i, vertex in enumerate(special_vertices):\n        max_distances[i] = max(distances[vertex] for j, vertex in enumerate(special_vertices) if i!= j)\n\n    print(*max_distances)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def initial_shell_position():\n    n = int(input())\n    x = int(input())\n\n    if n % 2 == 0:\n        if x == 0:\n            return 2\n        elif x == 2:\n            return 0\n        else:\n            return 1\n    else:\n        if x == 0:\n            return 1\n        elif x == 1:\n            return 0\n        else:\n            return 2\n\nprint(initial_shell_position())"}
{"solution": "def is_square(rectangles):\n    # Calculate the bounding box\n    min_x = min(rect[0] for rect in rectangles)\n    max_x = max(rect[2] for rect in rectangles)\n    min_y = min(rect[1] for rect in rectangles)\n    max_y = max(rect[3] for rect in rectangles)\n\n    # Check if the bounding box is a square\n    if max_x - min_x!= max_y - min_y:\n        return False\n\n    # Check if the rectangles cover the entire bounding box\n    covered = [[False] * (max_x - min_x) for _ in range(max_y - min_y)]\n    for x1, y1, x2, y2 in rectangles:\n        for x in range(x1, x2):\n            for y in range(y1, y2):\n                if min_x <= x < max_x and min_y <= y < max_y:\n                    covered[y - min_y][x - min_x] = True\n\n    # Check if all points in the bounding box are covered\n    for row in covered:\n        for cell in row:\n            if not cell:\n                return False\n\n    return True\n\n\nn = int(input())\nrectangles = [list(map(int, input().split())) for _ in range(n)]\n\nif is_square(rectangles):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def digit_sum(x):\n    return sum(int(digit) for digit in str(x))\n\ndef count_big_numbers(n, s):\n    count = 0\n    for i in range(1, n + 1):\n        if i - digit_sum(i) >= s:\n            count += 1\n    return count\n\nn, s = map(int, input().split())\nprint(count_big_numbers(n, s))"}
{"solution": "from collections import defaultdict\nfrom math import gcd\n\ndef slope(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    dx = x2 - x1\n    dy = y2 - y1\n    if dx == 0:\n        return float('inf')\n    g = gcd(dx, dy)\n    return (dx // g, dy // g)\n\ndef solve(points):\n    n = len(points)\n    if n <= 2:\n        return True\n\n    slopes = defaultdict(set)\n    for i in range(n):\n        for j in range(i + 1, n):\n            s = slope(points[i], points[j])\n            slopes[s].add(i)\n            slopes[s].add(j)\n\n    for s in slopes.values():\n        if len(s) == n:\n            return True\n\n    for s1 in slopes.values():\n        for s2 in slopes.values():\n            if s1.isdisjoint(s2) and len(s1) + len(s2) == n:\n                return True\n\n    return False\n\nn = int(input())\npoints = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\nif solve(points):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def mod_inverse(a, m):\n    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_power(base, exponent, mod):\n    \"\"\"Compute base^exponent modulo mod\"\"\"\n    result = 1\n    base = base % mod\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % mod\n        exponent = exponent >> 1\n        base = (base * base) % mod\n    return result\n\ndef mod_multiply(a, b, mod):\n    \"\"\"Compute a*b modulo mod\"\"\"\n    return (a * b) % mod\n\ndef mod_add(a, b, mod):\n    \"\"\"Compute a+b modulo mod\"\"\"\n    return (a + b) % mod\n\ndef mod_subtract(a, b, mod):\n    \"\"\"Compute a-b modulo mod\"\"\"\n    return (a - b) % mod\n\ndef calculate_combinations(n, k, mod):\n    \"\"\"Compute the number of combinations of n items taken k at a time modulo mod\"\"\"\n    if k > n - k:\n        k = n - k\n    result = 1\n    for i in range(k):\n        result = mod_multiply(result, (n - i), mod)\n        result = mod_multiply(result, mod_inverse(i + 1, mod), mod)\n    return result\n\ndef calculate_winning_games(a, b, k, t, mod):\n    \"\"\"Compute the number of possible games where Memory wins\"\"\"\n    total_games = mod_power(2 * k + 1, 2 * t, mod)\n    losing_games = 0\n    for diff in range(-t * k, t * k + 1):\n        if diff >= 0:\n            combinations = calculate_combinations(2 * t, t + diff, mod)\n        else:\n            combinations = calculate_combinations(2 * t, t - diff, mod)\n        losing_games = mod_add(losing_games, combinations, mod)\n    winning_games = mod_subtract(total_games, losing_games, mod)\n    if a > b:\n        return winning_games\n    elif a == b:\n        return mod_subtract(winning_games, calculate_combinations(2 * t, t, mod), mod)\n    else:\n        return 0\n\ndef main():\n    mod = 10**9 + 7\n    a, b, k, t = map(int, input().split())\n    winning_games = calculate_winning_games(a, b, k, t, mod)\n    print(winning_games)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_measure(distances, target):\n    for i in range(len(distances)):\n        for j in range(i, len(distances)):\n            if distances[j] - distances[i] == target:\n                return True\n    return False\n\ndef find_additional_marks(n, l, x, y, distances):\n    if can_measure(distances, x) and can_measure(distances, y):\n        return 0, []\n    elif can_measure(distances, x):\n        return 1, [y]\n    elif can_measure(distances, y):\n        return 1, [x]\n    else:\n        for i in range(len(distances)):\n            for j in range(i, len(distances)):\n                if distances[j] - distances[i] == x:\n                    return 1, [y]\n                elif distances[j] - distances[i] == y:\n                    return 1, [x]\n        return 2, [x, y]\n\nn, l, x, y = map(int, input().split())\ndistances = list(map(int, input().split()))\n\nadditional_marks_count, additional_marks = find_additional_marks(n, l, x, y, distances)\n\nprint(additional_marks_count)\nif additional_marks_count > 0:\n    print(*additional_marks)"}
{"solution": "import math\n\ndef calculate_volume(radius, height):\n    \"\"\"Calculate the volume of a cylinder.\"\"\"\n    return math.pi * radius ** 2 * height\n\ndef find_max_volume(n, cakes):\n    \"\"\"Find the maximum volume of the cake that can be made.\"\"\"\n    # Sort the cakes based on their volumes in descending order\n    cakes.sort(key=lambda x: calculate_volume(x[0], x[1]), reverse=True)\n\n    # Initialize a list to store the maximum volume that can be achieved at each step\n    max_volumes = [0] * n\n\n    # The maximum volume that can be achieved with the first cake is its own volume\n    max_volumes[0] = calculate_volume(cakes[0][0], cakes[0][1])\n\n    # Iterate over the cakes\n    for i in range(1, n):\n        # Initialize the maximum volume that can be achieved with the current cake to its own volume\n        max_volume = calculate_volume(cakes[i][0], cakes[i][1])\n\n        # Iterate over the previous cakes\n        for j in range(i):\n            # If the current cake can be placed on top of the previous cake\n            if cakes[i][0] < cakes[j][0] and cakes[i][1] < cakes[j][1]:\n                # Update the maximum volume that can be achieved with the current cake\n                max_volume = max(max_volume, max_volumes[j] + calculate_volume(cakes[i][0], cakes[i][1]))\n\n        # Update the maximum volume that can be achieved at the current step\n        max_volumes[i] = max_volume\n\n    # Return the maximum volume that can be achieved\n    return max(max_volumes)\n\n# Read the number of cakes\nn = int(input())\n\n# Read the radius and height of each cake\ncakes = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Find and print the maximum volume\nprint(find_max_volume(n, cakes))"}
{"solution": "import sys\nimport math\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, input().split())\n\ndef read_int_list():\n    return list(map(int, input().split()))\n\ndef solve():\n    n, k = read_ints()\n    heights = read_int_list()\n    heights.sort()\n\n    def can_slice(target_height):\n        total_cost = 0\n        for height in heights:\n            total_cost += max(0, height - target_height)\n        return total_cost <= k\n\n    def binary_search(low, high):\n        while low < high:\n            mid = (low + high) // 2\n            if can_slice(mid):\n                high = mid\n            else:\n                low = mid + 1\n        return low\n\n    min_slices = math.inf\n    for i in range(n):\n        target_height = heights[i]\n        slices = binary_search(target_height, heights[-1] + 1)\n        min_slices = min(min_slices, slices - target_height)\n\n    return min_slices\n\nprint(solve())"}
{"solution": "def max_score(n, a):\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    max_score = float('-inf')\n\n    for l in range(n):\n        max_in_segment = float('-inf')\n        for r in range(l, n):\n            max_in_segment = max(max_in_segment, a[r])\n            segment_sum = prefix_sum[r + 1] - prefix_sum[l]\n            score = segment_sum - max_in_segment\n            max_score = max(max_score, score)\n\n    return max_score\n\nn = int(input())\na = list(map(int, input().split()))\nprint(max_score(n, a))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve():\n    k1, k2, k3 = map(int, input().split())\n    if lcm(k1, lcm(k2, k3)) > max(k1, k2, k3) * 2:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n\nsolve()"}
{"solution": "def min_operations_to_delete_string(n, s):\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = 1\n    \n    for length in range(2, n + 1):  \n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j-1]\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n    \n    return dp[0][n-1]\n\nn = int(input())\ns = input().strip()\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "def max_pairs(boys, girls):\n    boys.sort()\n    girls.sort()\n    i = j = pairs = 0\n    while i < len(boys) and j < len(girls):\n        if abs(boys[i] - girls[j]) <= 1:\n            pairs += 1\n            i += 1\n            j += 1\n        elif boys[i] < girls[j]:\n            i += 1\n        else:\n            j += 1\n    return pairs\n\nn = int(input())\nboys = list(map(int, input().split()))\nm = int(input())\ngirls = list(map(int, input().split()))\n\nprint(max_pairs(boys, girls))"}
{"solution": "def determine_winner():\n    # Read the skills of each player\n    skills = [list(map(int, input().split())) for _ in range(4)]\n\n    # Calculate the maximum attack and defence for each team\n    team1_attack = max(skills[0][1], skills[1][1])\n    team1_defence = max(skills[0][0], skills[1][0])\n    team2_attack = max(skills[2][1], skills[3][1])\n    team2_defence = max(skills[2][0], skills[3][0])\n\n    # Check if team 1 can win\n    if team1_defence > team2_attack and team1_attack > team2_defence:\n        return \"Team 1\"\n\n    # Check if team 2 can win\n    elif team2_defence > team1_attack and team2_attack > team1_defence:\n        return \"Team 2\"\n\n    # If neither team can win, it's a draw\n    else:\n        return \"Draw\"\n\nprint(determine_winner())"}
{"solution": "import math\nimport sys\n\ndef dist(x1, y1, x2, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef check(x, y, k, arr):\n    times = []\n    for i in range(len(arr)):\n        times.append(arr[i][2] * dist(x, y, arr[i][0], arr[i][1]))\n    times.sort()\n    return times[k - 1]\n\ndef solve():\n    n, k = map(int, input().split())\n    arr = []\n    for _ in range(n):\n        x, y, c = map(int, input().split())\n        arr.append([x, y, c])\n\n    min_x, max_x = min([x for x, _, _ in arr]), max([x for x, _, _ in arr])\n    min_y, max_y = min([y for _, y, _ in arr]), max([y for _, y, _ in arr])\n\n    step = 0.000001\n    ans = sys.maxsize\n    for x in [i * step for i in range(int(min_x / step), int(max_x / step) + 1)]:\n        for y in [i * step for i in range(int(min_y / step), int(max_y / step) + 1)]:\n            ans = min(ans, check(x, y, k, arr))\n\n    print(ans)\n\nsolve()"}
{"solution": "def calculate_difference(s, n):\n    \"\"\"Calculate the difference between the sum of the first half and the sum of the second half.\"\"\"\n    first_half_sum = sum(int(s[i]) for i in range(n // 2) if s[i]!= '?')\n    second_half_sum = sum(int(s[i]) for i in range(n // 2, n) if s[i]!= '?')\n    return first_half_sum - second_half_sum\n\n\ndef can_make_happy(s, n, difference):\n    \"\"\"Check if it's possible to make the ticket happy.\"\"\"\n    first_half_blanks = sum(1 for i in range(n // 2) if s[i] == '?')\n    second_half_blanks = sum(1 for i in range(n // 2, n) if s[i] == '?')\n    \n    if difference > 0:\n        # Monocarp's turn, try to make the ticket unhappy\n        if first_half_blanks >= difference // 9 + (difference % 9!= 0):\n            return False\n    else:\n        # Bicarp's turn, try to make the ticket happy\n        if second_half_blanks >= abs(difference) // 9 + (abs(difference) % 9!= 0):\n            return True\n    return True\n\n\ndef main():\n    n = int(input())\n    s = input()\n    difference = calculate_difference(s, n)\n    if can_make_happy(s, n, difference):\n        print(\"Bicarp\")\n    else:\n        print(\"Monocarp\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_bus_route():\n    n, t = map(int, input().split())\n    earliest_time = float('inf')\n    chosen_route = -1\n\n    for i in range(n):\n        s_i, d_i = map(int, input().split())\n\n        if s_i >= t:\n            next_bus_time = s_i\n        else:\n            if (t - s_i) % d_i == 0:\n                next_bus_time = t\n            else:\n                next_bus_time = s_i + ((t - s_i) // d_i + 1) * d_i\n\n        if next_bus_time < earliest_time:\n            earliest_time = next_bus_time\n            chosen_route = i + 1\n\n    print(chosen_route)\n\nfind_bus_route()"}
{"solution": "def count_ones(n):\n    \"\"\"Count the number of ones in the binary representation of n.\"\"\"\n    return bin(n).count('1')\n\ndef find_n(m, k):\n    \"\"\"Find the smallest n such that there are exactly m numbers between n+1 and 2n (inclusive) with k ones in their binary representation.\"\"\"\n    n = 1\n    while True:\n        count = sum(1 for i in range(n+1, 2*n+1) if count_ones(i) == k)\n        if count == m:\n            return n\n        n += 1\n\nm, k = map(int, input().split())\nprint(find_n(m, k))"}
{"solution": "def is_good_level(level):\n    \"\"\"\n    Checks if a level is good, i.e., if it's possible to perform a sequence of four jumps of the same length.\n\n    Args:\n        level (str): A string representing the level, where '*' is a platform and '.' is a pit.\n\n    Returns:\n        bool: True if the level is good, False otherwise.\n    \"\"\"\n    n = len(level)\n    for i in range(n):\n        for jump in range(1, n // 4 + 1):\n            if all(level[i + j * jump] == '*' for j in range(5)):\n                return True\n    return False\n\n\ndef main():\n    \"\"\"\n    Reads the input, checks if the level is good, and prints the result.\n    \"\"\"\n    n = int(input())\n    level = input()\n    print(\"yes\" if is_good_level(level) else \"no\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_magic_number(n, grid):\n    # Find the position of the empty cell\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                empty_row, empty_col = i, j\n\n    # Calculate the expected sum of each row, column, and diagonal\n    expected_sum = sum(grid[0])\n\n    # Check if the expected sum is consistent across all rows and columns\n    for i in range(1, n):\n        if sum(grid[i])!= expected_sum:\n            return -1\n\n    for j in range(n):\n        col_sum = sum(grid[k][j] for k in range(n))\n        if col_sum!= expected_sum:\n            return -1\n\n    # Calculate the sum of the main diagonal\n    main_diagonal_sum = sum(grid[k][k] for k in range(n))\n    if main_diagonal_sum!= expected_sum:\n        return -1\n\n    # Calculate the sum of the secondary diagonal\n    secondary_diagonal_sum = sum(grid[k][n - k - 1] for k in range(n))\n    if secondary_diagonal_sum!= expected_sum:\n        return -1\n\n    # Calculate the sum of the row and column containing the empty cell\n    row_sum = sum(grid[empty_row])\n    col_sum = sum(grid[k][empty_col] for k in range(n))\n\n    # Calculate the magic number\n    magic_number = expected_sum - row_sum + grid[empty_row][empty_col]\n    if magic_number <= 0:\n        return -1\n\n    return magic_number\n\n\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\nprint(find_magic_number(n, grid))"}
{"solution": "import math\n\nn = int(input())\nm = int(input())\na = [int(input()) for _ in range(n)]\n\nmax_k = max(a) + m\ntotal_people = sum(a) + m\nmin_k = math.ceil(total_people / n)\n\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_power(a, b, m):\n    result = 1\n    while b > 0:\n        if b % 2 == 1:\n            result = (result * a) % m\n        a = (a * a) % m\n        b //= 2\n    return result\n\ndef mod_factorial(n, m):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % m\n    return result\n\ndef mod_binomial_coefficient(n, k, m):\n    return (mod_factorial(n, m) * mod_inverse(mod_factorial(k, m) * mod_factorial(n - k, m) % m, m)) % m\n\ndef solve(n, m):\n    if m > n:\n        return 0\n    result = 0\n    for k in range(m + 1):\n        result = (result + mod_binomial_coefficient(m, k, MOD) * mod_power(2, k, MOD) * mod_power(2, m - k, MOD) * mod_binomial_coefficient(n - 1, m - k, MOD)) % MOD\n    return result\n\nn, m = map(int, input().split())\nprint(solve(n, m))"}
{"solution": "from collections import defaultdict\nfrom itertools import combinations\n\ndef solve():\n    n, m = map(int, input().split())\n\n    friends = []\n    for _ in range(n):\n        f, *b = map(int, input().split())\n        friends.append(set(b))\n\n    pizzas = []\n    for j in range(m):\n        c, r, *a = map(int, input().split())\n        pizzas.append((c, set(a), j + 1))\n\n    pizzas.sort()\n\n    max_friends = 0\n    min_cost = float('inf')\n    best_pizzas = None\n\n    for (c1, a1, j1), (c2, a2, j2) in combinations(pizzas, 2):\n        friends_pleased = sum(1 for b in friends if b.issubset(a1 | a2))\n        if friends_pleased > max_friends or (friends_pleased == max_friends and c1 + c2 < min_cost):\n            max_friends = friends_pleased\n            min_cost = c1 + c2\n            best_pizzas = (j1, j2)\n\n    print(*best_pizzas)\n\nsolve()"}
{"solution": "def find_min_max(m, s):\n    if s == 0 and m > 1:\n        return -1, -1\n    if s < m or s > 9 * m:\n        return -1, -1\n\n    min_num = ''\n    max_num = ''\n\n    # Construct the minimum number\n    if s < 9:\n        min_num = str(s)\n        min_num += '0' * (m - 1)\n    else:\n        min_num = '1'\n        s -= 1\n        while s > 9:\n            min_num += '9'\n            s -= 9\n        if s > 0:\n            min_num += str(s)\n        min_num += '0' * (m - len(min_num))\n\n    # Construct the maximum number\n    if s < 9:\n        max_num = str(s)\n        max_num += '0' * (m - 1)\n    else:\n        max_num = ''\n        while s > 9:\n            max_num += '9'\n            s -= 9\n        if s > 0:\n            max_num += str(s)\n        max_num += '0' * (m - len(max_num))\n\n    return min_num, max_num\n\n\nm, s = map(int, input().split())\nmin_num, max_num = find_min_max(m, s)\nprint(min_num, max_num)"}
{"solution": "MOD = 998244353\n\ndef count_numbers_with_at_most_k_digits(n, k):\n    count = 0\n    for i in range(1, len(str(n)) + 1):\n        for j in range(1, min(i + 1, k + 1)):\n            count += 9 * pow(10, i - j - 1) * pow(j, i - 1) * pow(k - j + 1, j)\n            count %= MOD\n    return count\n\ndef sum_of_numbers_with_at_most_k_digits(n, k):\n    count = count_numbers_with_at_most_k_digits(n, k)\n    sum_of_numbers = (n * (n + 1)) // 2 - (count * (count + 1)) // 2\n    return sum_of_numbers % MOD\n\ndef main():\n    l, r, k = map(int, input().split())\n    sum_r = sum_of_numbers_with_at_most_k_digits(r, k)\n    sum_l = sum_of_numbers_with_at_most_k_digits(l - 1, k)\n    result = (sum_r - sum_l) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef main():\n    n, k, d = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] - a[i] <= d:\n            j += 1\n        if j - i >= k:\n            i = j\n        else:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_dead_bulbs(garland):\n    colors = ['R', 'B', 'Y', 'G']\n    dead_bulbs = {color: 0 for color in colors}\n\n    for i in range(len(garland)):\n        if garland[i] == '!':\n            possible_colors = [color for color in colors if color not in garland[i-1:i+3]]\n            if len(possible_colors) == 1:\n                dead_bulbs[possible_colors[0]] += 1\n\n    return dead_bulbs\n\ngarland = input()\ndead_bulbs = count_dead_bulbs(garland)\nprint(dead_bulbs['R'], dead_bulbs['B'], dead_bulbs['Y'], dead_bulbs['G'])"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    n, m = map(int, sys.stdin.readline().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        s, t = map(int, sys.stdin.readline().split())\n        graph[s].append(t)\n    return n, graph\n\ndef calculate_expected_values(n, graph):\n    expected_values = [0.0] * (n + 1)\n    expected_values[n] = 0.0\n    for i in range(n - 1, 0, -1):\n        total = 0.0\n        for j in graph[i]:\n            total += expected_values[j] + 1.0\n        expected_values[i] = total / len(graph[i])\n    return expected_values\n\ndef calculate_min_expected_value(n, graph, expected_values):\n    min_expected_value = float('inf')\n    for i in range(1, n):\n        if len(graph[i]) > 1:\n            total = 0.0\n            for j in graph[i]:\n                total += expected_values[j] + 1.0\n            new_expected_value = total / (len(graph[i]) - 1)\n            min_expected_value = min(min_expected_value, new_expected_value)\n    return min_expected_value\n\ndef main():\n    n, graph = read_input()\n    expected_values = calculate_expected_values(n, graph)\n    min_expected_value = calculate_min_expected_value(n, graph, expected_values)\n    print(min_expected_value)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def round_to_nearest_multiple_of_ten(n):\n    remainder = n % 10\n    if remainder <= 4:\n        return n - remainder\n    else:\n        return n + (10 - remainder)\n\nn = int(input())\nprint(round_to_nearest_multiple_of_ten(n))"}
{"solution": "def find_swaps(s, t):\n    if len(s)!= len(t):\n        print(-1)\n        return\n    \n    mismatches = {}\n    \n    for i in range(len(s)):\n        if s[i]!= t[i]:\n            if s[i] in mismatches and mismatches[s[i]]!= t[i]:\n                print(-1)\n                return\n            if t[i] in mismatches and mismatches[t[i]]!= s[i]:\n                print(-1)\n                return\n            mismatches[s[i]] = t[i]\n            mismatches[t[i]] = s[i]\n    \n    visited = set()\n    swaps = []\n    \n    for key in mismatches:\n        if key not in visited:\n            cycle = []\n            current = key\n            while current not in visited:\n                visited.add(current)\n                cycle.append(current)\n                current = mismatches[current]\n            if len(cycle)!= 2:\n                print(-1)\n                return\n            swaps.append((cycle[0], cycle[1]))\n    \n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0], swap[1])\n\ns = input()\nt = input()\nfind_swaps(s, t)"}
{"solution": "def generate_login(first_name, last_name):\n    \"\"\"\n    Generate the alphabetically earliest possible login from the given first and last names.\n    \n    Parameters:\n    first_name (str): The user's first name.\n    last_name (str): The user's last name.\n    \n    Returns:\n    str: The alphabetically earliest possible login.\n    \"\"\"\n    # Initialize the earliest login with the full first name and the full last name\n    earliest_login = first_name + last_name\n    \n    # Iterate over all possible prefixes of the first name\n    for i in range(1, len(first_name)):\n        # Iterate over all possible prefixes of the last name\n        for j in range(1, len(last_name)):\n            # Generate the current login\n            current_login = first_name[:i] + last_name[:j]\n            # If the current login is alphabetically earlier than the earliest login, update the earliest login\n            if current_login < earliest_login:\n                earliest_login = current_login\n    \n    return earliest_login\n\n# Read the input\nfirst_name, last_name = input().split()\n\n# Generate and print the alphabetically earliest possible login\nprint(generate_login(first_name, last_name))"}
{"solution": "def draw_brackets(n, brackets):\n    stack = []\n    max_height = 0\n    for bracket in brackets:\n        if bracket == '[':\n            stack.append(bracket)\n            max_height = max(max_height, len(stack))\n        else:\n            stack.pop()\n\n    lines = [''] * max_height\n    stack = []\n    for bracket in brackets:\n        if bracket == '[':\n            stack.append(bracket)\n            height = len(stack)\n            lines[height - 1] += '+' + '-' * (max_height - height)\n            for i in range(height - 2, -1, -1):\n                lines[i] += '|' +'' * (max_height - height)\n        else:\n            height = len(stack)\n            lines[height - 1] += '-' * (max_height - height) + '+'\n            for i in range(height - 2, -1, -1):\n                lines[i] +='' * (max_height - height) + '|'\n            stack.pop()\n\n    for i in range(max_height):\n        if i > 0:\n            lines[i] ='' * (max_height - i - 1) + lines[i]\n        lines[i] = lines[i].rstrip()\n        if i < max_height - 1:\n            lines[i] +=''\n    return '\\n'.join(lines)\n\n\nn = int(input())\nbrackets = input()\nprint(draw_brackets(n, brackets))"}
{"solution": "def normalize_golden_number(golden_number):\n    golden_number = list(map(int, golden_number))\n    n = len(golden_number)\n    \n    for i in range(n - 1, 0, -1):\n        if golden_number[i] > 1:\n            golden_number[i] -= 2\n            golden_number[i - 1] += 1\n            if i - 2 >= 0:\n                golden_number[i - 2] += 1\n    \n    while len(golden_number) > 1 and golden_number[0] == 0:\n        golden_number.pop(0)\n    \n    return golden_number\n\ndef compare_golden_numbers(num1, num2):\n    norm_num1 = normalize_golden_number(num1)\n    norm_num2 = normalize_golden_number(num2)\n    \n    if len(norm_num1) > len(norm_num2):\n        return \">\"\n    elif len(norm_num1) < len(norm_num2):\n        return \"<\"\n    \n    for digit1, digit2 in zip(norm_num1, norm_num2):\n        if digit1 > digit2:\n            return \">\"\n        elif digit1 < digit2:\n            return \"<\"\n    \n    return \"=\"\n\nnum1 = input().strip()\nnum2 = input().strip()\n\nresult = compare_golden_numbers(num1, num2)\nprint(result)"}
{"solution": "def find_absent_gems():\n    gems = {\n        \"purple\": \"Power\",\n        \"green\": \"Time\",\n        \"blue\": \"Space\",\n        \"orange\": \"Soul\",\n        \"red\": \"Reality\",\n        \"yellow\": \"Mind\"\n    }\n\n    n = int(input())\n    present_gems = [input() for _ in range(n)]\n\n    absent_gems = [gems[color] for color in gems if color not in present_gems]\n\n    print(len(absent_gems))\n    for gem in absent_gems:\n        print(gem)\n\nfind_absent_gems()"}
{"solution": "def find_meeting_round(n, a, b):\n    \"\"\"\n    Determine the round in which two teams can meet in a play-off system.\n\n    Args:\n    n (int): The total number of teams.\n    a (int): The id of the first team.\n    b (int): The id of the second team.\n\n    Returns:\n    str or int: The round in which the teams can meet, or \"Final!\" if they can meet in the final.\n    \"\"\"\n    # Initialize the round number\n    round_num = 1\n\n    # Continue until the teams meet\n    while True:\n        # Calculate the position of each team in the current round\n        pos_a = (a - 1) // (2 ** (round_num - 1)) + 1\n        pos_b = (b - 1) // (2 ** (round_num - 1)) + 1\n\n        # If the teams are in the same position, they meet in this round\n        if pos_a == pos_b:\n            # If this is the last round, return \"Final!\"\n            if 2 ** (round_num - 1) == n // 2:\n                return \"Final!\"\n            # Otherwise, return the round number\n            else:\n                return round_num\n\n        # If the teams do not meet in this round, move to the next round\n        round_num += 1\n\n\n# Read the input\nn, a, b = map(int, input().split())\n\n# Find and print the meeting round\nprint(find_meeting_round(n, a, b))"}
{"solution": "def min_changes(n, p, b):\n    # Calculate the number of cycles in the permutation\n    cycles = 0\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            cycles += 1\n            j = i\n            while not visited[j]:\n                visited[j] = True\n                j = p[j] - 1\n\n    # Calculate the number of ones in the sequence\n    ones = sum(b)\n\n    # If the number of cycles is 1, we need to change at least one element in the sequence\n    if cycles == 1:\n        return 1 if ones == 0 or ones == n else 0\n\n    # If the number of cycles is greater than 1, we need to change at least one element in the permutation\n    # and make the number of ones in the sequence odd\n    return (cycles - 1) + (1 if ones % 2 == 0 else 0)\n\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(min_changes(n, p, b))"}
{"solution": "def calculate_max_distance(v1, v2, t, d):\n    \"\"\"\n    Calculate the maximum possible length of the path section in meters.\n\n    Args:\n    v1 (int): The speed in meters per second at the beginning of the segment.\n    v2 (int): The speed in meters per second at the end of the segment.\n    t (int): The time when the car moves along the segment in seconds.\n    d (int): The maximum value of the speed change between adjacent seconds.\n\n    Returns:\n    int: The maximum possible length of the path section in meters.\n    \"\"\"\n    # Calculate the maximum possible speed change\n    max_speed_change = min(d, abs(v2 - v1))\n\n    # Calculate the number of seconds required to reach the maximum speed\n    seconds_to_max_speed = min(t - 1, abs(v2 - v1) // max_speed_change)\n\n    # Calculate the remaining seconds\n    remaining_seconds = t - seconds_to_max_speed - 1\n\n    # Calculate the maximum speed\n    max_speed = v1 + max_speed_change * seconds_to_max_speed\n\n    # Calculate the minimum speed\n    min_speed = v2 - max_speed_change * seconds_to_max_speed\n\n    # Calculate the total distance\n    total_distance = (v1 + max_speed) * (seconds_to_max_speed + 1) // 2 + \\\n                     (max_speed + min_speed) * remaining_seconds // 2 + \\\n                     (min_speed + v2) * (seconds_to_max_speed + 1) // 2\n\n    return total_distance\n\n\n# Read input\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Calculate and print the maximum possible length of the path section\nprint(calculate_max_distance(v1, v2, t, d))"}
{"solution": "import sys\nimport itertools\n\ndef check_order(weights, order, lengths, capacities):\n    total_length = 0\n    for i in range(len(lengths)):\n        length = lengths[i]\n        capacity = capacities[i]\n        total_weight = 0\n        for j in range(len(order)):\n            if j > 0 and total_length + length >= total_length + (j - 1) * length:\n                total_weight += weights[order[j - 1]]\n            if j < len(order) - 1 and total_length + length >= total_length + j * length:\n                total_weight += weights[order[j + 1]]\n            if total_weight > capacity:\n                return False\n        total_length += length\n    return True\n\ndef main():\n    input = sys.stdin.readline\n    N, M = map(int, input().split())\n    weights = list(map(int, input().split()))\n    lengths = []\n    capacities = []\n    for _ in range(M):\n        length, capacity = map(int, input().split())\n        lengths.append(length)\n        capacities.append(capacity)\n    min_distance = float('inf')\n    for order in itertools.permutations(range(N)):\n        if check_order(weights, order, lengths, capacities):\n            min_distance = min(min_distance, sum(lengths))\n    if min_distance == float('inf'):\n        print(-1)\n    else:\n        print(min_distance)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def last_digit_factorial(n):\n    \"\"\"Calculate the last digit of n!\"\"\"\n    if n < 5:\n        return 1\n    else:\n        return 0\n\ndef last_digit_division(a, b):\n    \"\"\"Calculate the last digit of b! / a!\"\"\"\n    if a >= 5:\n        return 0\n    else:\n        return (last_digit_factorial(b) // last_digit_factorial(a)) % 10\n\na, b = map(int, input().split())\nprint(last_digit_division(a, b))"}
{"solution": "from collections import deque\n\ndef min_jumps(n, d, s):\n    queue = deque([(1, 0)])\n    visited = set([1])\n\n    while queue:\n        pos, jumps = queue.popleft()\n\n        if pos == n:\n            return jumps\n\n        for jump in range(1, min(d + 1, n - pos + 1)):\n            new_pos = pos + jump\n\n            if s[new_pos - 1] == '1' and new_pos not in visited:\n                queue.append((new_pos, jumps + 1))\n                visited.add(new_pos)\n\n    return -1\n\nn, d = map(int, input().split())\ns = input()\n\nprint(min_jumps(n, d, s))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_counterexample(n):\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\nn = int(input().strip())\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all_coins(n):\n    \"\"\"\n    Checks if it's possible to spend all initial game-coins buying only houses, cars and computers.\n\n    Args:\n        n (int): Kolya's initial game-coin score.\n\n    Returns:\n        bool: True if it's possible to spend all coins, False otherwise.\n    \"\"\"\n    house_cost = 1234567\n    car_cost = 123456\n    computer_cost = 1234\n\n    for a in range(n // house_cost + 1):\n        remaining_coins = n - a * house_cost\n        if remaining_coins < 0:\n            break\n        for b in range(remaining_coins // car_cost + 1):\n            remaining_coins_after_cars = remaining_coins - b * car_cost\n            if remaining_coins_after_cars < 0:\n                break\n            if remaining_coins_after_cars % computer_cost == 0:\n                return True\n\n    return False\n\n\ndef main():\n    n = int(input())\n    if can_spend_all_coins(n):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n = int(read_input())\n    x1, x2 = read_ints()\n    lines = []\n    for _ in range(n):\n        k, b = read_ints()\n        lines.append((k, b))\n\n    lines.sort(key=lambda x: x[0])\n\n    for i in range(n - 1):\n        k1, b1 = lines[i]\n        k2, b2 = lines[i + 1]\n        if k1 == k2:\n            continue\n        x = (b2 - b1) / (k1 - k2)\n        if x1 < x < x2:\n            print(\"Yes\")\n            return\n\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef count_weights(n):\n    weights = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            weights.add(i)\n            weights.add(n // i)\n    return len(weights)\n\nn = int(input())\nprint(count_weights(n))"}
{"solution": "n, k = map(int, input().split())\n\nif k == 0:\n    min_good = 0\n    max_good = 0\nelse:\n    min_good = 1\n    max_good = min(n - k, 2 * k - (k == 1))\n\nprint(min_good, max_good)"}
{"solution": "import math\n\ndef max_games(n):\n    \"\"\"\n    Calculate the maximum number of games the winner of a knockout tournament can play.\n\n    Args:\n    n (int): The number of players in the tournament.\n\n    Returns:\n    int: The maximum number of games the winner can play.\n    \"\"\"\n    # Initialize the Fibonacci sequence\n    a, b = 1, 1\n    \n    # Initialize the number of games\n    games = 1\n    \n    # Continue generating Fibonacci numbers until we exceed the number of players\n    while b < n:\n        # Generate the next Fibonacci number\n        a, b = b, a + b\n        \n        # Increment the number of games\n        games += 1\n    \n    # Return the maximum number of games the winner can play\n    return games - 1\n\n# Read the number of players from the input\nn = int(input())\n\n# Calculate and print the maximum number of games the winner can play\nprint(max_games(n))"}
{"solution": "def max_vk(s):\n    vk_count = s.count(\"VK\")\n    v_count = s.count(\"V\")\n    k_count = s.count(\"K\")\n\n    # Check if changing a 'V' to a 'K' would increase the count\n    vk_increase = min(v_count - 1, k_count)\n\n    # Check if changing a 'K' to a 'V' would increase the count\n    kv_increase = min(k_count - 1, v_count)\n\n    # Return the maximum possible count\n    return max(vk_count, vk_count + vk_increase, vk_count + kv_increase)\n\ns = input()\nprint(max_vk(s))"}
{"solution": "import math\n\ndef min_segments(n):\n    a = int(math.sqrt(n))\n    b = (n + a - 1) // a  \n    return a + b + 2\n\nn = int(input().strip())\nprint(min_segments(n))"}
{"solution": "def years_until_larger(a, b):\n    years = 0\n    while a <= b:\n        a *= 3\n        b *= 2\n        years += 1\n    return years\n\na, b = map(int, input().split())\nprint(years_until_larger(a, b))"}
{"solution": "def calculate_nodes_to_visit(h, n):\n    # Calculate the total number of nodes in the tree\n    total_nodes = 2 ** (h + 1) - 1\n\n    # Calculate the number of nodes to visit before reaching the exit\n    nodes_to_visit = total_nodes - 1\n\n    # Calculate the number of nodes to visit in the left subtree of the exit node\n    left_subtree_nodes = 2 ** (h - 1) - 1\n\n    # Calculate the number of nodes to visit in the right subtree of the exit node\n    right_subtree_nodes = 2 ** (h - 1) - 1\n\n    # If the exit node is in the left half of the tree\n    if n <= 2 ** h // 2:\n        # Subtract the nodes in the right subtree from the total nodes to visit\n        nodes_to_visit -= right_subtree_nodes\n    else:\n        # Subtract the nodes in the left subtree from the total nodes to visit\n        nodes_to_visit -= left_subtree_nodes\n\n    # If the exit node is not at the root level\n    if h > 1:\n        # Calculate the number of nodes to visit in the path from the root to the exit node\n        path_nodes = 2 * (h - 1)\n\n        # Subtract the nodes in the path from the total nodes to visit\n        nodes_to_visit -= path_nodes\n\n    return nodes_to_visit\n\n\nh, n = map(int, input().split())\nprint(calculate_nodes_to_visit(h, n))"}
{"solution": "import math\n\ndef find_pairs(x):\n    pairs = []\n    for n in range(1, int(math.sqrt(x)) + 1):\n        for m in range(n, x // n + 1):\n            total_squares = sum(min(n, m - i) for i in range(n))\n            if total_squares == x:\n                pairs.append((n, m))\n                if n!= m:\n                    pairs.append((m, n))\n    return pairs\n\nx = int(input())\npairs = find_pairs(x)\nprint(len(pairs))\nfor pair in sorted(pairs):\n    print(pair[0], pair[1])"}
{"solution": "def is_leap_year(year):\n    return year % 4 == 0 and (year % 100!= 0 or year % 400 == 0)\n\ndef get_month_days(year, month):\n    if month == 2:\n        return 29 if is_leap_year(year) else 28\n    elif month in [1, 3, 5, 7, 8, 10, 12]:\n        return 31\n    else:\n        return 30\n\ndef check_sequence(sequence):\n    for year in range(2000, 2100):\n        for month in range(1, 13):\n            if sequence == [get_month_days(year, m) for m in range(month, month + len(sequence))]:\n                return True\n    return False\n\nn = int(input())\nsequence = list(map(int, input().split()))\n\nif check_sequence(sequence):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def find_sequence(n):\n    sequence = []\n    for i in range(2, n):\n        if n % i == 0:\n            sequence.append((1, i))\n            sequence.append((i - 1, i))\n    if len(sequence) > 0:\n        print(\"YES\")\n        print(len(sequence))\n        for a, b in sequence:\n            print(a, b)\n    else:\n        print(\"NO\")\n\nn = int(input())\nfind_sequence(n)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n = read_int()\n    a, b = read_ints()\n    h = read_ints()\n\n    total_height = sum(h)\n    if a < min(h) or b < min(h) or a + b < total_height:\n        return -1\n\n    dp = [[float('inf')] * (b + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(b + 1):\n            if j >= h[i - 1]:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j - h[i - 1]])\n            if j + h[i - 1] <= b and a >= h[i - 1]:\n                dp[i][j + h[i - 1]] = min(dp[i][j + h[i - 1]], dp[i - 1][j] + h[i - 1])\n\n    min_unattractiveness = float('inf')\n    for j in range(b + 1):\n        if a + j >= total_height:\n            min_unattractiveness = min(min_unattractiveness, dp[n][j])\n\n    return min_unattractiveness\n\nprint(solve())"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef find_points(n, m, k):\n    target_area = (n * m) / k\n    if target_area!= int(target_area):\n        return None\n\n    target_area = int(target_area)\n\n    for x1 in range(1, n + 1):\n        for y1 in range(1, m + 1):\n            for x2 in range(x1 + 1, n + 1):\n                y2 = y1\n                area = 0.5 * abs(x1 * y2 - x2 * y1)\n                if area == target_area:\n                    return [(x1, y1), (x2, y2), (x1, y2)]\n\n                y2 = m - y1 + 1\n                area = 0.5 * abs(x1 * y2 - x2 * y1)\n                if area == target_area:\n                    return [(x1, y1), (x2, y2), (x1, y2)]\n\n    g = gcd(n, m)\n    if target_area * 2 % g!= 0:\n        return None\n\n    x1, y1 = 0, 0\n    x2, y2 = n, 0\n    x3, y3 = 0, m\n\n    if target_area * 2 % n == 0:\n        y3 = target_area * 2 // n\n    elif target_area * 2 % m == 0:\n        x3 = target_area * 2 // m\n    else:\n        return None\n\n    return [(x1, y1), (x2, y2), (x3, y3)]\n\nn, m, k = map(int, input().split())\npoints = find_points(n, m, k)\n\nif points is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for point in points:\n        print(*point)"}
{"solution": "def sasha_game(n, k):\n    if n % (2 * k) == 0:\n        return \"NO\"\n    else:\n        return \"YES\"\n\nn, k = map(int, input().split())\nprint(sasha_game(n, k))"}
{"solution": "n = int(input())\nexercises = list(map(int, input().split()))\n\nmuscle_groups = [\"chest\", \"biceps\", \"back\"]\nmuscle_repetitions = [0, 0, 0]\n\nfor i, repetition in enumerate(exercises):\n    muscle_repetitions[i % 3] += repetition\n\nmax_repetition = max(muscle_repetitions)\nmax_index = muscle_repetitions.index(max_repetition)\n\nprint(muscle_groups[max_index])"}
{"solution": "def min_redos_to_get_five(n, grades):\n    current_sum = sum(grades)\n    target_sum = n * 4.5\n    \n    if current_sum >= target_sum:\n        return 0\n    \n    grades.sort()\n    redos = 0\n    \n    for grade in grades:\n        if current_sum >= target_sum:\n            break\n        current_sum += (5 - grade)\n        redos += 1\n    \n    return redos\n\nn = int(input())\ngrades = list(map(int, input().split()))\nprint(min_redos_to_get_five(n, grades))"}
{"solution": "def solve(u, v):\n    if u > v:\n        return None\n    if u % 2!= v % 2:\n        return None\n    if u == 0 and v == 0:\n        return []\n    if u == v:\n        return [u]\n    if u == 0:\n        if v % 2 == 0:\n            return [v // 2, v // 2]\n        else:\n            return [1, v - 1, 1]\n    if v % 2 == 0:\n        return [u ^ (v - u) // 2, (v - u) // 2]\n    return [1, u ^ (v - 1) // 2, (v - 1) // 2]\n\nu, v = map(int, input().split())\nresult = solve(u, v)\nif result is None:\n    print(-1)\nelse:\n    print(len(result))\n    print(*result)"}
{"solution": "def min_ones(n):\n    \"\"\"Return the minimum number of digits '1' in the sum of addends containing only '1'.\"\"\"\n    result = 0\n    i = 1\n    while n > 0:\n        if n >= i:\n            n -= i\n            result += len(str(i))\n        i *= 10\n    return result\n\nn = int(input())\nprint(min_ones(n))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\ndx = abs(x2 - x1)\ndy = abs(y2 - y1)\n\nif dx == 0 and dy % y == 0:\n    print(\"YES\")\nelif dy == 0 and dx % x == 0:\n    print(\"YES\")\nelif dx == 0 or dy == 0 or gcd(dx, x) == gcd(dy, y):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "from itertools import permutations\nfrom collections import Counter\n\ndef count_valid_bus_numbers(n):\n    # Convert the number to a string to extract digits\n    digits = list(str(n))\n    \n    # Count the frequency of each digit\n    digit_counts = Counter(digits)\n    \n    # Initialize the count of valid permutations\n    count = 0\n    \n    # Generate all possible lengths of permutations\n    for r in range(1, len(digits) + 1):\n        # Generate all permutations of the given length\n        for perm in permutations(digits, r):\n            # Check if the permutation starts with '0'\n            if perm[0] == '0':\n                continue\n            \n            # Count the frequency of each digit in the permutation\n            perm_counts = Counter(perm)\n            \n            # Check if the permutation is valid\n            if all(perm_counts[digit] <= digit_counts[digit] for digit in perm_counts):\n                count += 1\n                \n    return count\n\n# Read input\nn = int(input().strip())\n\n# Get the count of valid bus numbers\nresult = count_valid_bus_numbers(n)\n\n# Print the result\nprint(result)"}
{"solution": "def calculate_max_cost():\n    a = int(input())\n    b = int(input())\n    c = int(input())\n    d = int(input())\n    e = int(input())\n    f = int(input())\n\n    # Calculate the maximum number of suits of the first type\n    max_suits_first_type = min(a, d)\n\n    # Calculate the maximum number of suits of the second type\n    max_suits_second_type = min(b, c, d)\n\n    # Initialize the maximum cost\n    max_cost = 0\n\n    # Iterate over all possible combinations of suits\n    for suits_first_type in range(max_suits_first_type + 1):\n        remaining_jackets = d - suits_first_type\n        suits_second_type = min(remaining_jackets, b, c)\n        cost = suits_first_type * e + suits_second_type * f\n        max_cost = max(max_cost, cost)\n\n    print(max_cost)\n\ncalculate_max_cost()"}
{"solution": "def pow_mod(a, n, p):\n    \"\"\"Compute a^n mod p\"\"\"\n    res = 1\n    while n > 0:\n        if n % 2 == 1:\n            res = (res * a) % p\n        a = (a * a) % p\n        n //= 2\n    return res\n\ndef discrete_log(a, b, p):\n    \"\"\"Find the discrete logarithm of b with base a mod p\"\"\"\n    m = int(p ** 0.5) + 1\n    a_pow = [pow_mod(a, i, p) for i in range(m)]\n    a_inv = pow_mod(a, p - 2, p)\n    b_pow = pow_mod(a_inv, m, p)\n    b_cur = b\n    for i in range(m):\n        if b_cur in a_pow:\n            return i * m + a_pow.index(b_cur)\n        b_cur = (b_cur * b_pow) % p\n    return -1\n\ndef solve(a, b, p, x):\n    \"\"\"Solve the congruence equation\"\"\"\n    if a == 1:\n        return 1 if b == 1 else 0\n    phi = p - 1\n    d = discrete_log(a, b, p)\n    if d == -1:\n        return 0\n    return (x // phi) + (1 if x % phi >= d else 0)\n\na, b, p, x = map(int, input().split())\nprint(solve(a, b, p, x))"}
{"solution": "def calculate_max_sum(k_2, k_3, k_5, k_6):\n    max_256 = min(k_2, k_5, k_6)\n    remaining_2 = max(0, k_2 - max_256)\n    max_32 = min(remaining_2, k_3)\n    return max_256 * 256 + max_32 * 32\n\nk_2, k_3, k_5, k_6 = map(int, input().split())\nprint(calculate_max_sum(k_2, k_3, k_5, k_6))"}
{"solution": "import math\n\ndef calculate_seconds(n, x, y, c):\n    if c == 1:\n        return 0\n\n    if c > n * n:\n        return -1\n\n    if x == 1 or x == n:\n        if y == 1 or y == n:\n            return math.ceil(math.log2(c)) - 1\n        else:\n            return math.ceil(math.log2(c / 2)) - 1\n    elif y == 1 or y == n:\n        return math.ceil(math.log2(c / 2)) - 1\n    else:\n        return math.ceil(math.log2(c / 4)) - 1\n\nn, x, y, c = map(int, input().split())\nprint(calculate_seconds(n, x, y, c))"}
{"solution": "def find_max_xor(l, r):\n    max_xor = 0\n    for i in range(63, -1, -1):\n        max_xor <<= 1\n        if (l >> i)!= (r >> i):\n            max_xor |= 1\n            break\n        elif (l >> i) & 1:\n            max_xor |= 1\n    return max_xor\n\nl, r = map(int, input().split())\nprint(find_max_xor(l, r))"}
{"solution": "def minimum_height():\n    n, k = map(int, input().split())\n    left, right = 1, k\n    \n    while left < right:\n        mid = (left + right) // 2\n        if n * mid >= k:\n            right = mid\n        else:\n            left = mid + 1\n    \n    print(left)\n\nminimum_height()"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    stairs_time = abs(x - y) * t1\n    \n    elevator_to_masha_time = abs(z - x) * t2 + t3\n    elevator_to_egor_time = abs(x - y) * t2 + 2 * t3\n    elevator_time = elevator_to_masha_time + elevator_to_egor_time\n    \n    if stairs_time < elevator_time:\n        return \"NO\"\n    else:\n        return \"YES\"\n\nx, y, z, t1, t2, t3 = map(int, input().split())\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "def calculate_a(n, m):\n    \"\"\"\n    Calculate the optimal value of a to maximize Andrew's winning probability.\n\n    Args:\n    n (int): The upper limit of the range.\n    m (int): Misha's chosen number.\n\n    Returns:\n    int: The optimal value of a.\n    \"\"\"\n    # If m is at one of the extremes, a should be at the other extreme\n    if m == 1:\n        return n\n    elif m == n:\n        return 1\n\n    # If m is closer to the lower end, a should be closer to the upper end\n    if m < n // 2 + 1:\n        return m + 1\n    # If m is closer to the upper end, a should be closer to the lower end\n    else:\n        return m - 1\n\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the optimal value of a\nprint(calculate_a(n, m))"}
{"solution": "def count_pairs(n, schedule):\n    \"\"\"\n    Calculate the number of pairs Alena will stay at the university.\n\n    Args:\n    n (int): The number of lessons at the university.\n    schedule (list): A list of 0s and 1s representing the schedule.\n\n    Returns:\n    int: The number of pairs Alena will stay at the university.\n    \"\"\"\n    pairs = 0\n    i = 0\n    while i < n:\n        # If the current pair has a class, increment the pairs count\n        if schedule[i] == 1:\n            pairs += 1\n            # If the current pair is not the last pair, check the next pair\n            if i < n - 1:\n                # If the next pair is a break, check the pair after that\n                if schedule[i + 1] == 0:\n                    # If the pair after that is a class, increment the pairs count\n                    if i < n - 2 and schedule[i + 2] == 1:\n                        pairs += 1\n        # Move to the next pair\n        i += 1\n    return pairs\n\n# Read the input\nn = int(input())\nschedule = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_pairs(n, schedule))"}
{"solution": "def min_days_to_give_candies(n, k, candies):\n    total_candies = 0\n    days = 0\n    for candy in candies:\n        total_candies += candy\n        days += 1\n        if total_candies >= k:\n            return days\n        total_candies -= min(candy, 8)\n    return -1 if total_candies < k else days\n\nn, k = map(int, input().split())\ncandies = list(map(int, input().split()))\n\nprint(min_days_to_give_candies(n, k, candies))"}
{"solution": "def minimum_additional_walks(n, k, a):\n    b = a[:]\n    additional_walks = 0\n    \n    # Consider the day before the first day\n    if b[0] < k:\n        needed_walks = k - b[0]\n        b[0] += needed_walks\n        additional_walks += needed_walks\n    \n    for i in range(n - 1):\n        if b[i] + b[i + 1] < k:\n            needed_walks = k - (b[i] + b[i + 1])\n            b[i + 1] += needed_walks\n            additional_walks += needed_walks\n    \n    # Consider the day after the n-th day\n    if b[-1] < k:\n        needed_walks = k - b[-1]\n        b[-1] += needed_walks\n        additional_walks += needed_walks\n    \n    return additional_walks, b\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nadditional_walks, b = minimum_additional_walks(n, k, a)\n\n# Print the result\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "def calculate_rhombus_cells(n):\n    \"\"\"\n    Calculate the number of cells in an n-th order rhombus.\n\n    Args:\n        n (int): The order of the rhombus.\n\n    Returns:\n        int: The number of cells in the rhombus.\n    \"\"\"\n    return 2 * n ** 2 - 2 * n + 1\n\n\ndef main():\n    n = int(input())\n    print(calculate_rhombus_cells(n))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_pangram(n, s):\n    alphabet = set('abcdefghijklmnopqrstuvwxyz')\n    return 'YES' if set(s.lower()) >= alphabet else 'NO'\n\nn = int(input())\ns = input()\nprint(is_pangram(n, s))"}
{"solution": "def calculate_time(time_str, minutes):\n    hours, mins = map(int, time_str.split(':'))\n    total_mins = hours * 60 + mins + minutes\n    new_hours = (total_mins // 60) % 24\n    new_mins = total_mins % 60\n    return f\"{new_hours:02d}:{new_mins:02d}\"\n\ntime_str = input()\nminutes = int(input())\nprint(calculate_time(time_str, minutes))"}
{"solution": "def can_ignore_switch(n, m, switches):\n    \"\"\"\n    Determine if there exists a switch that can be ignored and still turn on all lamps.\n\n    Args:\n    n (int): The number of switches.\n    m (int): The number of lamps.\n    switches (list): A list of strings representing the switches and lamps.\n\n    Returns:\n    bool: True if a switch can be ignored, False otherwise.\n    \"\"\"\n    # Convert the switches to a binary matrix for easier manipulation\n    binary_switches = [[int(bit) for bit in switch] for switch in switches]\n\n    # Iterate over each switch\n    for i in range(n):\n        # Create a copy of the binary switches without the current switch\n        remaining_switches = [switch for j, switch in enumerate(binary_switches) if j!= i]\n\n        # Check if all lamps can be turned on without the current switch\n        if all(any(switch[j] for switch in remaining_switches) for j in range(m)):\n            return True\n\n    return False\n\n\n# Read the input\nn, m = map(int, input().split())\nswitches = [input() for _ in range(n)]\n\n# Print the result\nprint(\"YES\" if can_ignore_switch(n, m, switches) else \"NO\")"}
{"solution": "def min_time_to_rotate(n, dominoes):\n    upper_sum = sum(x for x, y in dominoes)\n    lower_sum = sum(y for x, y in dominoes)\n\n    if upper_sum % 2 == 0 and lower_sum % 2 == 0:\n        return 0\n    elif upper_sum % 2!= 0 and lower_sum % 2!= 0:\n        odd_upper = sum(1 for x, y in dominoes if x % 2!= 0 and y % 2!= 0)\n        odd_lower = sum(1 for x, y in dominoes if x % 2 == 0 and y % 2 == 0)\n        return min(odd_upper, odd_lower) if odd_upper > 0 or odd_lower > 0 else -1\n    else:\n        return -1\n\nn = int(input())\ndominoes = [tuple(map(int, input().split())) for _ in range(n)]\nprint(min_time_to_rotate(n, dominoes))"}
{"solution": "import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    sqrt_n = math.isqrt(n)\n    for i in range(5, sqrt_n + 1, 6):\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n    return True\n\ndef solve():\n    a, b = map(int, input().split())\n    area = (a - b) * (a + b)\n    if is_prime(area):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nt = int(input())\nfor _ in range(t):\n    solve()"}
{"solution": "def can_remove_one_point(n, points):\n    positive_count = 0\n    negative_count = 0\n    \n    for x, y in points:\n        if x > 0:\n            positive_count += 1\n        else:\n            negative_count += 1\n    \n    if positive_count <= 1 or negative_count <= 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\nprint(can_remove_one_point(n, points))"}
{"solution": "import math\n\ndef calculate_gcd_factorial():\n    a, b = map(int, input().split())\n    min_val = min(a, b)\n    gcd_factorial = math.factorial(min_val)\n    print(gcd_factorial)\n\ncalculate_gcd_factorial()"}
{"solution": "def find_composite_numbers(n):\n    if n % 2 == 0:\n        a = n + 4\n        b = 4\n    else:\n        a = n + 9\n        b = 9\n    return a, b\n\nn = int(input())\na, b = find_composite_numbers(n)\nprint(a, b)"}
{"solution": "import sys\nfrom collections import deque\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_list():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n, m, p = read_ints()\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, c = read_ints()\n        a -= 1\n        b -= 1\n        adj[a].append((b, c))\n\n    dist = [float('inf')] * n\n    dist[0] = 0\n    q = deque([0])\n    while q:\n        u = q.popleft()\n        for v, c in adj[u]:\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                q.append(v)\n\n    if dist[-1] == float('inf'):\n        print(-1)\n        return\n\n    dp = [[-float('inf')] * (n + 1) for _ in range(n)]\n    dp[-1][dist[-1]] = 0\n    for u in range(n - 1, -1, -1):\n        for t in range(n + 1):\n            for v, c in adj[u]:\n                if t + 1 <= n:\n                    dp[u][t + 1] = max(dp[u][t + 1], dp[v][t] + c)\n            if u == 0:\n                dp[u][t] = max(dp[u][t], dp[u][t] - p * t)\n\n    ans = -float('inf')\n    for t in range(n + 1):\n        ans = max(ans, dp[0][t])\n    print(ans)\n\nsolve()"}
{"solution": "import sys\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef can_make_palindrome(s, strings):\n    for string in strings:\n        if is_palindrome(s + string):\n            return True\n    return False\n\ndef min_cost_to_palindrome(strings, costs):\n    n = len(strings)\n    dp = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = costs[i] if is_palindrome(strings[i]) else float('inf')\n        for j in range(i + 1, n):\n            if is_palindrome(strings[i] + strings[j]):\n                dp[i][j] = costs[i] + costs[j]\n            else:\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])\n    return dp[0][n - 1]\n\ndef main():\n    n = int(sys.stdin.readline())\n    strings = []\n    costs = []\n    for _ in range(n):\n        s, c = sys.stdin.readline().split()\n        strings.append(s)\n        costs.append(int(c))\n    min_cost = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_palindrome(strings[i] + strings[j]):\n                min_cost = min(min_cost, costs[i] + costs[j])\n            elif can_make_palindrome(strings[i], strings[:i] + strings[i + 1:j] + strings[j + 1:]):\n                min_cost = min(min_cost, costs[i] + min_cost_to_palindrome(strings[:i] + strings[i + 1:j] + strings[j + 1:], costs[:i] + costs[i + 1:j] + costs[j + 1:]))\n            elif can_make_palindrome(strings[j], strings[:i] + strings[i + 1:j] + strings[j + 1:]):\n                min_cost = min(min_cost, costs[j] + min_cost_to_palindrome(strings[:i] + strings[i + 1:j] + strings[j + 1:], costs[:i] + costs[i + 1:j] + costs[j + 1:]))\n    if min_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_cost)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n, k = map(int, input().split())\nnum_bits = n.bit_length()\nmax_xor_sum = (1 << num_bits) - 1\nprint(max_xor_sum)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef solve():\n    n = read_int()\n    points = [tuple(read_ints()) for _ in range(n)]\n\n    max_x = max(x for x, y in points)\n    max_y = max(y for x, y in points)\n\n    def check(side):\n        if side >= max_x and side >= max_y:\n            return True\n        if side < max_x and side < max_y:\n            return False\n        if side >= max_x:\n            return all(y <= side * x / max_x for x, y in points)\n        else:\n            return all(y <= max_y * x / side for x, y in points)\n\n    low, high = 0, max(max_x, max_y)\n    while low < high:\n        mid = (low + high) // 2\n        if check(mid):\n            high = mid\n        else:\n            low = mid + 1\n\n    return low\n\nprint(solve())"}
{"solution": "def max_nineteens(s):\n    from collections import Counter\n    \n    char_count = Counter(s)\n    required_counts = {'n': 3, 'i': 1, 'e': 3, 't': 1}\n    \n    max_nineteens = float('inf')\n    for char, required in required_counts.items():\n        if char in char_count:\n            max_nineteens = min(max_nineteens, char_count[char] // required)\n        else:\n            return 0\n    \n    return max_nineteens\n\ns = input()\nprint(max_nineteens(s))"}
{"solution": "def highest_unreachable_branch(p, y):\n    \"\"\"\n    Find the highest branch that cannot be reached by any of the grasshoppers.\n\n    Args:\n    p (int): The highest branch occupied by a grasshopper.\n    y (int): The total number of branches.\n\n    Returns:\n    int: The highest branch that cannot be reached by any grasshopper, or -1 if no such branch exists.\n    \"\"\"\n    # Initialize the highest unreachable branch to -1\n    highest_branch = -1\n\n    # Iterate over all branches from y down to 2\n    for branch in range(y, 1, -1):\n        # Assume the current branch is unreachable\n        unreachable = True\n\n        # Check if the current branch can be reached by any grasshopper\n        for grasshopper in range(2, p + 1):\n            # If the grasshopper can reach the current branch, it's not unreachable\n            if branch % grasshopper == 0 and branch // grasshopper <= y // grasshopper:\n                unreachable = False\n                break\n\n        # If the current branch is unreachable, update the highest unreachable branch\n        if unreachable:\n            highest_branch = branch\n            break\n\n    return highest_branch\n\n\n# Read the input\np, y = map(int, input().split())\n\n# Find and print the highest unreachable branch\nprint(highest_unreachable_branch(p, y))"}
{"solution": "def min_distance(n, m, k, houses):\n    \"\"\"\n    Calculate the minimum distance from the girl's house to a house Zane can afford.\n\n    Args:\n    n (int): The number of houses in the village.\n    m (int): The house where the girl lives.\n    k (int): The amount of money Zane has.\n    houses (list): A list of integers representing the availability and prices of the houses.\n\n    Returns:\n    int: The minimum distance from the girl's house to a house Zane can afford.\n    \"\"\"\n    min_distance = float('inf')\n\n    # Check houses to the left of the girl's house\n    for i in range(m - 1, -1, -1):\n        if houses[i]!= 0 and houses[i] <= k:\n            min_distance = min(min_distance, (m - i - 1) * 10)\n\n    # Check houses to the right of the girl's house\n    for i in range(m, n):\n        if houses[i]!= 0 and houses[i] <= k:\n            min_distance = min(min_distance, (i - m) * 10)\n\n    return min_distance\n\n\n# Read input\nn, m, k = map(int, input().split())\nhouses = list(map(int, input().split()))\n\n# Calculate and print the minimum distance\nprint(min_distance(n, m, k, houses))"}
{"solution": "from collections import defaultdict\n\ndef solve():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    b = [list(map(int, input().split())) for _ in range(n)]\n\n    rows = defaultdict(list)\n    cols = defaultdict(list)\n\n    for i in range(n):\n        for j in range(m):\n            rows[a[i][j]].append(i)\n            cols[a[i][j]].append(j)\n\n    for i in range(n):\n        for j in range(m):\n            if rows[b[i][j]]!= sorted(rows[b[i][j]]) or cols[b[i][j]]!= sorted(cols[b[i][j]]):\n                print(\"NO\")\n                return\n\n    print(\"YES\")\n\nsolve()"}
{"solution": "def longest_uncommon_subsequence(a, b):\n    if a == b:\n        return -1\n    else:\n        return max(len(a), len(b))\n\na = input()\nb = input()\n\nprint(longest_uncommon_subsequence(a, b))"}
{"solution": "def find_intersection(a, b, c, d):\n    \"\"\"\n    Find the first time Rick and Morty will scream at the same time.\n\n    Args:\n    a (int): The interval at which Rick screams.\n    b (int): The initial time at which Rick screams.\n    c (int): The interval at which Morty screams.\n    d (int): The initial time at which Morty screams.\n\n    Returns:\n    int: The first time Rick and Morty will scream at the same time, or -1 if they will never scream at the same time.\n    \"\"\"\n    # Calculate the least common multiple of a and c\n    lcm = (a * c) // gcd(a, c)\n\n    # Initialize the time at which Rick screams\n    rick_time = b\n\n    # Iterate through the times at which Rick screams\n    while rick_time <= lcm:\n        # Check if Morty screams at the same time\n        if (rick_time - d) % c == 0:\n            return rick_time\n        # Increment the time at which Rick screams\n        rick_time += a\n\n    # If no intersection is found, check if there is a common time after lcm\n    if (lcm - d) % c == 0:\n        return lcm\n    else:\n        # If no intersection is found, return -1\n        return -1\n\n\ndef gcd(a, b):\n    \"\"\"\n    Calculate the greatest common divisor of two numbers.\n\n    Args:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: The greatest common divisor of a and b.\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\n\n# Read the input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Find and print the intersection\nprint(find_intersection(a, b, c, d))"}
{"solution": "def split_number(n):\n    if n % 3 == 0:\n        return [1, (n - 1) // 3, (n - 1) // 3 + 1]\n    elif n % 3 == 1:\n        return [(n - 1) // 3, (n - 1) // 3, (n - 1) // 3 + 1]\n    else:\n        return [(n - 2) // 3 + 1, (n - 2) // 3 + 1, (n - 2) // 3]\n\nn = int(input())\nprint(*split_number(n))"}
{"solution": "def calculate_squares(n, a, b, c, d):\n    \"\"\"\n    Calculate the number of distinct squares satisfying the conditions.\n\n    Args:\n    n (int): Maximum possible value of an integer in the cell.\n    a (int): Value of the top-right cell.\n    b (int): Value of the middle-left cell.\n    c (int): Value of the middle-right cell.\n    d (int): Value of the bottom-left cell.\n\n    Returns:\n    int: Number of distinct squares satisfying the conditions.\n    \"\"\"\n    # Calculate the sum of the top-left 2x2 square\n    sum_2x2 = a + b + c + d\n\n    # Initialize count of distinct squares\n    count = 0\n\n    # Iterate over possible values for the top-left cell\n    for x in range(1, n + 1):\n        # Calculate the value of the middle cell\n        middle = sum_2x2 - x - a - b\n\n        # Check if the middle cell value is valid\n        if 1 <= middle <= n:\n            # Calculate the value of the bottom-right cell\n            bottom_right = sum_2x2 - x - d\n\n            # Check if the bottom-right cell value is valid\n            if 1 <= bottom_right <= n:\n                # Calculate the value of the top-right cell\n                top_right = sum_2x2 - b - c\n\n                # Check if the top-right cell value is valid\n                if 1 <= top_right <= n:\n                    # Calculate the value of the bottom-left cell\n                    bottom_left = sum_2x2 - a - c\n\n                    # Check if the bottom-left cell value is valid\n                    if 1 <= bottom_left <= n:\n                        # Increment count of distinct squares\n                        count += 1\n\n    return count\n\n\n# Read input values\nn, a, b, c, d = map(int, input().split())\n\n# Calculate and print the number of distinct squares\nprint(calculate_squares(n, a, b, c, d))"}
{"solution": "def calculate_snowball_weight():\n    # Read initial snowball weight and height\n    w, h = map(int, input().split())\n\n    # Read stone weights and heights\n    u1, d1 = map(int, input().split())\n    u2, d2 = map(int, input().split())\n\n    # Initialize current height\n    current_height = h\n\n    # Simulate snowball's descent\n    while current_height > 0:\n        # Increase snowball's weight by current height\n        w += current_height\n\n        # Check if snowball hits a stone\n        if current_height == d1:\n            w -= u1\n            if w < 0:\n                w = 0\n        elif current_height == d2:\n            w -= u2\n            if w < 0:\n                w = 0\n\n        # Move snowball one meter down\n        current_height -= 1\n\n    # Print final snowball weight\n    print(w)\n\ncalculate_snowball_weight()"}
{"solution": "def find_passing_rate(m, scores, x, y):\n    total_students = sum(scores)\n    prefix_sum = [0] * (m + 1)\n    for i in range(m):\n        prefix_sum[i + 1] = prefix_sum[i] + scores[i]\n\n    for k in range(1, m + 1):\n        beginner_group_size = prefix_sum[k]\n        intermediate_group_size = total_students - beginner_group_size\n        if x <= beginner_group_size <= y and x <= intermediate_group_size <= y:\n            return k\n\n    return 0\n\n\nm = int(input())\nscores = list(map(int, input().split()))\nx, y = map(int, input().split())\n\nprint(find_passing_rate(m, scores, x, y))"}
{"solution": "import math\n\ndef min_coins(n, k, A, B):\n    if k == 1:\n        return (n - 1) * A\n    coins = 0\n    while n > 1:\n        if n % k == 0:\n            if (n - 1) * A < B:\n                n -= 1\n                coins += A\n            else:\n                n //= k\n                coins += B\n        else:\n            if (k - (n % k)) * A < B:\n                n -= (n % k)\n                coins += (n % k) * A\n            else:\n                n -= 1\n                coins += A\n    return coins\n\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\nprint(min_coins(n, k, A, B))"}
{"solution": "import math\n\ndef prime_factors(n):\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef solve(n):\n    factors = prime_factors(n)\n    unique_factors = set(factors)\n    min_n = 1\n    for factor in unique_factors:\n        if factors.count(factor) % 2 == 1:\n            min_n *= factor\n    operations = 0\n    while n!= min_n:\n        sqrt_n = math.isqrt(n)\n        if sqrt_n * sqrt_n == n:\n            n = sqrt_n\n            operations += 1\n        else:\n            n *= min_n\n            operations += 1\n    return min_n, operations\n\nn = int(input())\nmin_n, operations = solve(n)\nprint(min_n, operations)"}
{"solution": "def get_score(N, K, R, S, P, T):\n    scores = {'r': P,'s': R, 'p': S}\n    last_used = {'r': -1,'s': -1, 'p': -1}\n    total_score = 0\n\n    for i in range(N):\n        machine_hand = T[i]\n        best_hand = max([hand for hand in scores if last_used[hand] < i - K], key=lambda hand: scores[hand] if hand!= machine_hand else 0)\n        total_score += scores[best_hand]\n        last_used[best_hand] = i\n\n    return total_score\n\n\nN, K = map(int, input().split())\nR, S, P = map(int, input().split())\nT = input()\n\nprint(get_score(N, K, R, S, P, T))"}
{"solution": "def longest_good_string(a, b, c):\n    # Calculate the total number of 'ab' pairs\n    pairs = min(a, b) + c\n    \n    # Calculate the remaining 'a's and 'b's\n    remaining_a = a - pairs\n    remaining_b = b - pairs\n    \n    # The maximum length is the sum of the pairs (each pair contributes 2 to the length)\n    # and the remaining 'a's and 'b's (each contributes 1 to the length)\n    max_length = pairs * 2 + remaining_a + remaining_b\n    \n    # If there are more 'ab' pairs than remaining 'a's and 'b's, we can add 1 to the length\n    # for each extra pair\n    extra_pairs = c - min(a, b)\n    max_length += extra_pairs * 2\n    \n    return max_length\n\na, b, c = map(int, input().split())\nprint(longest_good_string(a, b, c))"}
{"solution": "def solve(n, k, p, x, y, a):\n    a.sort()\n    remaining_tests = n - k\n    total_marks = sum(a)\n    max_total_marks = x - total_marks\n    max_marks_per_test = max_total_marks // remaining_tests\n    if max_marks_per_test < 1:\n        return [-1]\n    median_index = (n + 1) // 2\n    median_marks = [y] * (median_index - k)\n    if len(median_marks) > remaining_tests:\n        return [-1]\n    remaining_marks = max_total_marks - sum(median_marks)\n    if remaining_marks < 0:\n        return [-1]\n    remaining_tests_marks = [min(max_marks_per_test, p)] * (remaining_tests - len(median_marks))\n    if sum(remaining_tests_marks) > remaining_marks:\n        return [-1]\n    return median_marks + remaining_tests_marks\n\nn, k, p, x, y = map(int, input().split())\na = list(map(int, input().split()))\nresult = solve(n, k, p, x, y, a)\nprint(*result)"}
{"solution": "def is_berlanese(word):\n    vowels = 'aeiou'\n    for i in range(len(word) - 1):\n        if word[i] not in vowels and word[i]!= 'n' and word[i + 1] not in vowels:\n            return 'NO'\n        if word[i] in vowels and word[i + 1] not in vowels + 'n' and i == len(word) - 2:\n            return 'NO'\n    if word[-1]!= 'n' and word[-1] not in vowels:\n        return 'NO'\n    return 'YES'\n\nword = input()\nprint(is_berlanese(word))"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_int():\n    return int(read_input())\n\ndef solve():\n    n, m = read_ints()\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = read_ints()\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def check(x):\n        for i in range(n):\n            if len(graph[i]) % 2!= 0:\n                return False\n            if len(graph[i]) > 6:\n                return False\n            if len(graph[i]) == 6:\n                if i!= x:\n                    return False\n        return True\n\n    def dfs(u, x, used):\n        if len(graph[u]) == 0:\n            return 1\n        for v in graph[u]:\n            if used[u][v] == 0:\n                used[u][v] = 1\n                used[v][u] = 1\n                res = dfs(v, x, used)\n                if res > 0:\n                    return res + 1\n                used[u][v] = 0\n                used[v][u] = 0\n        return 0\n\n    ans = 0\n    for i in range(n):\n        if check(i):\n            used = [[0] * n for _ in range(n)]\n            res = dfs(i, i, used)\n            ans = max(ans, res // 2)\n\n    print(ans)\n\nsolve()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, m = read_ints()\n    prices = list(read_ints())\n    auction_questions = list(read_ints())\n\n    auction_questions = [q - 1 for q in auction_questions]\n    auction_questions.sort(key=lambda q: prices[q], reverse=True)\n\n    points = 0\n    for i in range(n):\n        if i in auction_questions:\n            points += prices[i]\n            prices[i] = points\n        else:\n            points += prices[i]\n\n    print(points)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_score(max_points, submission_time, wrong_submissions):\n    \"\"\"\n    Calculate the score for a single problem.\n\n    Args:\n    max_points (int): The maximum point value of the problem.\n    submission_time (int): The time of the last submission in minutes.\n    wrong_submissions (int): The number of wrong submissions.\n\n    Returns:\n    int: The score for the problem.\n    \"\"\"\n    score = max(0.3 * max_points, (1 - submission_time / 250) * max_points - 50 * wrong_submissions)\n    return int(score)\n\n\ndef main():\n    # Read the submission times\n    submission_times = list(map(int, input().split()))\n\n    # Read the wrong submissions\n    wrong_submissions = list(map(int, input().split()))\n\n    # Read the successful and unsuccessful hacks\n    successful_hacks, unsuccessful_hacks = map(int, input().split())\n\n    # Define the maximum point values for each problem\n    max_points = [500, 1000, 1500, 2000, 2500]\n\n    # Calculate the total score\n    total_score = sum(calculate_score(max_points[i], submission_times[i], wrong_submissions[i]) for i in range(5))\n\n    # Add the score from hacks\n    total_score += 100 * successful_hacks - 50 * unsuccessful_hacks\n\n    print(total_score)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 998244353\n\ndef pow_mod(a, b):\n    res = 1\n    while b:\n        if b & 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b >>= 1\n    return res\n\ndef inv(a):\n    return pow_mod(a, MOD - 2)\n\ndef main():\n    n, m, L, R = map(int, input().split())\n    if (n * m) % 2 == 1:\n        print(0)\n        return\n    if n % 2 == 1 and m % 2 == 1:\n        print(0)\n        return\n    if n % 2 == 1:\n        n, m = m, n\n    if m % 2 == 1:\n        print(0)\n        return\n    ans = 0\n    for i in range(L, R + 1, 2):\n        ans = (ans + pow_mod(R - i + 1, n * m // 2)) % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_possible_to_make_increasing(n, m, matrix_a, matrix_b):\n    for i in range(n):\n        for j in range(m):\n            # Ensure that matrix_a[i][j] is the smaller or equal element\n            if matrix_a[i][j] > matrix_b[i][j]:\n                matrix_a[i][j], matrix_b[i][j] = matrix_b[i][j], matrix_a[i][j]\n    \n    # Check rows for strictly increasing property\n    for i in range(n):\n        for j in range(1, m):\n            if matrix_a[i][j] <= matrix_a[i][j-1] or matrix_b[i][j] <= matrix_b[i][j-1]:\n                return \"Impossible\"\n    \n    # Check columns for strictly increasing property\n    for j in range(m):\n        for i in range(1, n):\n            if matrix_a[i][j] <= matrix_a[i-1][j] or matrix_b[i][j] <= matrix_b[i-1][j]:\n                return \"Impossible\"\n    \n    return \"Possible\"\n\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\nmatrix_b = [list(map(int, input().split())) for _ in range(n)]\n\nprint(is_possible_to_make_increasing(n, m, matrix_a, matrix_b))"}
{"solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    a.sort(reverse=True)\n    ans = 0\n    used = set()\n    for i in range(n):\n        for j in range(a[i], -1, -1):\n            if j not in used:\n                ans += j\n                used.add(j)\n                break\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import heapq\n\ndef min_problems_to_solve(n, k, difficulties):\n    \"\"\"\n    Calculate the minimum number of problems Makes should solve on other judges\n    in order to solve all the chosen problems from Decoforces.\n\n    Args:\n    n (int): The number of problems to solve on Decoforces.\n    k (int): The maximum difficulty of problems already solved.\n    difficulties (list): A list of difficulties of problems to solve on Decoforces.\n\n    Returns:\n    int: The minimum number of problems to solve on other judges.\n    \"\"\"\n    # Create a priority queue to store the difficulties of problems to solve\n    pq = []\n    for difficulty in difficulties:\n        heapq.heappush(pq, difficulty)\n\n    # Initialize the count of problems to solve on other judges\n    count = 0\n\n    # While there are still problems to solve\n    while pq:\n        # Get the difficulty of the next problem to solve\n        difficulty = heapq.heappop(pq)\n\n        # If the difficulty is greater than the maximum difficulty already solved\n        if difficulty > k:\n            # Calculate the minimum difficulty required to solve the problem\n            required_difficulty = (difficulty + 1) // 2\n\n            # If the required difficulty is greater than the maximum difficulty already solved\n            if required_difficulty > k:\n                # Increment the count of problems to solve on other judges\n                count += 1\n\n                # Update the maximum difficulty already solved\n                k = required_difficulty\n\n            # Push the problem back into the priority queue\n            heapq.heappush(pq, difficulty)\n\n    return count\n\n# Read the input\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Calculate and print the minimum number of problems to solve on other judges\nprint(min_problems_to_solve(n, k, difficulties))"}
{"solution": "def calculate_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3):\n    \"\"\"\n    Calculate the optimal distribution of diplomas.\n\n    Args:\n    n (int): The total number of participants.\n    min_1 (int): The minimum number of first-degree diplomas.\n    max_1 (int): The maximum number of first-degree diplomas.\n    min_2 (int): The minimum number of second-degree diplomas.\n    max_2 (int): The maximum number of second-degree diplomas.\n    min_3 (int): The minimum number of third-degree diplomas.\n    max_3 (int): The maximum number of third-degree diplomas.\n\n    Returns:\n    tuple: A tuple containing the optimal number of first-degree, second-degree, and third-degree diplomas.\n    \"\"\"\n    # Calculate the maximum possible number of first-degree diplomas\n    first_degree = min(max_1, n - min_2 - min_3)\n\n    # Calculate the remaining participants after distributing first-degree diplomas\n    remaining = n - first_degree\n\n    # Calculate the maximum possible number of second-degree diplomas\n    second_degree = min(max_2, remaining - min_3)\n\n    # Calculate the number of third-degree diplomas\n    third_degree = n - first_degree - second_degree\n\n    return first_degree, second_degree, third_degree\n\n\n# Read input\nn = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\n# Calculate and print the optimal distribution of diplomas\nfirst_degree, second_degree, third_degree = calculate_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3)\nprint(first_degree, second_degree, third_degree)"}
{"solution": "def moon_phase(n, observations):\n    moon_cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    current_index = moon_cycle.index(observations[0])\n    next_index = (current_index + n) % len(moon_cycle)\n    next_moon_size = moon_cycle[next_index]\n    current_moon_size = observations[-1]\n\n    if next_moon_size > current_moon_size:\n        return \"UP\"\n    elif next_moon_size < current_moon_size:\n        return \"DOWN\"\n    else:\n        # Check if the sequence is increasing or decreasing\n        if all(observations[i] < observations[i + 1] for i in range(len(observations) - 1)):\n            return \"UP\"\n        elif all(observations[i] > observations[i + 1] for i in range(len(observations) - 1)):\n            return \"DOWN\"\n        else:\n            return \"-1\"\n\n\nn = int(input())\nobservations = list(map(int, input().split()))\nprint(moon_phase(n, observations))"}
{"solution": "def can_transform(s, t):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    # Check if lengths are the same\n    if len(s)!= len(t):\n        return \"No\"\n    \n    # Check each character\n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels)!= (char_t in vowels):\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(can_transform(s, t))"}
{"solution": "def determine_winner(board):\n    min_white_steps = float('inf')\n    min_black_steps = float('inf')\n\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'W':\n                min_white_steps = min(min_white_steps, 8 - i - 1)\n            elif board[i][j] == 'B':\n                min_black_steps = min(min_black_steps, i)\n\n    return 'A' if min_white_steps <= min_black_steps else 'B'\n\n\ndef main():\n    board = [input() for _ in range(8)]\n    print(determine_winner(board))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_equal_length(n, A, m, B):\n    if sum(A)!= sum(B):\n        return -1\n    \n    i, j = 0, 0\n    sumA, sumB = 0, 0\n    count = 0\n    \n    while i < n and j < m:\n        sumA += A[i]\n        sumB += B[j]\n        \n        if sumA == sumB:\n            count += 1\n            sumA = 0\n            sumB = 0\n            i += 1\n            j += 1\n        elif sumA < sumB:\n            i += 1\n        else:\n            j += 1\n    \n    return count\n\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\nprint(max_equal_length(n, A, m, B))"}
{"solution": "def is_contest_problem(problem_name):\n    friends_names = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    count = 0\n\n    for friend_name in friends_names:\n        if problem_name.count(friend_name) == 1:\n            count += 1\n\n    return \"YES\" if count == 1 else \"NO\"\n\n\nproblem_name = input()\nprint(is_contest_problem(problem_name))"}
{"solution": "def sieve(n):\n    is_prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (is_prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n    is_prime[0], is_prime[1] = False, False  # 0 and 1 are not primes\n    return is_prime\n\ndef count_primes_in_range(is_prime, a, b):\n    prime_count = [0] * (b + 1)\n    for i in range(a, b + 1):\n        prime_count[i] = prime_count[i - 1] + (1 if is_prime[i] else 0)\n    return prime_count\n\ndef min_length_with_k_primes(a, b, k):\n    is_prime = sieve(b)\n    prime_count = count_primes_in_range(is_prime, a, b)\n    \n    def has_k_primes_in_length(l):\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] >= k:\n                return True\n        return False\n    \n    left, right = 1, b - a + 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if has_k_primes_in_length(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\na, b, k = map(int, input().split())\nprint(min_length_with_k_primes(a, b, k))"}
{"solution": "import math\n\ndef calculate_x(a, h, w):\n    min_x = float('inf')\n\n    for n in range(1, math.ceil(w / a) + 1):\n        m = math.floor((w - n * a) / (n + 1))\n        if m < 0:\n            continue\n        x = (w - n * a - m) / (n + 1)\n\n        if x >= 0 and h >= a + 2 * x:\n            min_x = min(min_x, x)\n\n    for m in range(1, math.ceil(h / a) + 1):\n        n = math.floor((h - m * a) / (m + 1))\n        if n < 0:\n            continue\n        x = (h - m * a - n) / (m + 1)\n\n        if x >= 0 and w >= a + 2 * x:\n            min_x = min(min_x, x)\n\n    if min_x == float('inf'):\n        return -1\n    else:\n        return min_x\n\na, h, w = map(int, input().split())\nprint(calculate_x(a, h, w))"}
{"solution": "def count_unread_chapters():\n    n = int(input())\n    chapters = [list(map(int, input().split())) for _ in range(n)]\n    k = int(input())\n\n    unread_chapters = 0\n    for i in range(n):\n        if chapters[i][0] >= k:\n            unread_chapters += 1\n        elif chapters[i][1] >= k:\n            unread_chapters += 1\n            break\n\n    print(unread_chapters)\n\ncount_unread_chapters()"}
{"solution": "def can_form_codeforces(word):\n    target = \"CODEFORCES\"\n    n = len(word)\n    m = len(target)\n    \n    if n < m:\n        return \"NO\"\n    \n    for i in range(m + 1):\n        if word[:i] == target[:i] and word[n - (m - i):] == target[i:]:\n            return \"YES\"\n    \n    return \"NO\"\n\nword = input()\nprint(can_form_codeforces(word))"}
{"solution": "import sys\n\ndef min_weight(n):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][i] = 0\n        dp[i][i + 1] = i * (i + 1) * (i + 2) % 1000000007\n    for length in range(3, n + 1):\n        for i in range(1, n - length + 2):\n            j = i + length - 1\n            dp[i][j] = sys.maxsize\n            for k in range(i + 1, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + i * j * k)\n    return dp[1][n]\n\nn = int(input())\nprint(min_weight(n))"}
{"solution": "def count_digits(n):\n    length = len(str(n))\n    total_digits = 0\n    for i in range(1, length):\n        total_digits += i * (10 ** (i - 1)) * 9\n    total_digits += length * (n - (10 ** (length - 1)) + 1)\n    return total_digits\n\nn = int(input())\nprint(count_digits(n))"}
{"solution": "def find_winning_color(n, A, colors):\n    \"\"\"\n    Find a color that Bob can choose to win the game.\n\n    Args:\n    n (int): The number of cars.\n    A (int): The color chosen by Alice.\n    colors (list): A list of colors of the cars in the order of their appearance.\n\n    Returns:\n    int: A color that Bob can choose to win the game, or -1 if no such color exists.\n    \"\"\"\n    # Initialize a dictionary to store the count of each color\n    color_count = {}\n    # Initialize a variable to store the count of Alice's color\n    alice_count = 0\n\n    # Iterate over the colors of the cars\n    for i, color in enumerate(colors):\n        # If the color is Alice's color, increment her count\n        if color == A:\n            alice_count += 1\n        # If the color is not in the dictionary, add it with a count of 1\n        elif color not in color_count:\n            color_count[color] = 1\n        # If the color is already in the dictionary, increment its count\n        else:\n            color_count[color] += 1\n\n        # If the count of any color is greater than Alice's count, return that color\n        if any(count > alice_count for count in color_count.values()):\n            return max(color_count, key=color_count.get)\n\n    # If no color has a count greater than Alice's count, return -1\n    return -1\n\n\n# Read the input\nn, A = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Find and print the winning color\nprint(find_winning_color(n, A, colors))"}
{"solution": "def is_unique_crossword(n, x, a):\n    total_length = sum(a)\n    if total_length > x:\n        return False\n    if total_length == x:\n        return n == 1\n    if n == 1:\n        return False\n    if x - total_length - (n - 1) > 1:\n        return False\n    return True\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\nif is_unique_crossword(n, x, a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\nn, S = map(int, input().split())\n\nprint(math.ceil(S / n) if S % n!= 0 else S // n)"}
{"solution": "def lexicographically_smallest_palindrome(s):\n    \"\"\"\n    This function generates the lexicographically smallest palindrome \n    that can be obtained with the minimal number of changes from the input string.\n\n    Parameters:\n    s (str): The input string consisting of lowercase Latin letters.\n\n    Returns:\n    str: The lexicographically smallest palindrome.\n    \"\"\"\n    # Count the frequency of each character in the string\n    char_freq = {}\n    for char in s:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n    # Initialize variables to store the middle character and the first half of the palindrome\n    mid_char = ''\n    first_half = ''\n\n    # Initialize a variable to store the number of characters with odd frequency\n    odd_count = 0\n\n    # Iterate over the characters and their frequencies\n    for char, freq in sorted(char_freq.items()):\n        # If the frequency is odd, increment the odd count and update the middle character\n        if freq % 2!= 0:\n            odd_count += 1\n            mid_char = char\n        # Add the character to the first half of the palindrome, repeating it freq // 2 times\n        first_half += char * (freq // 2)\n\n    # If there are more than one characters with odd frequency, it's impossible to form a palindrome\n    if odd_count > 1:\n        raise ValueError(\"Impossible to form a palindrome\")\n\n    # Return the lexicographically smallest palindrome\n    return first_half + mid_char + first_half[::-1]\n\n\n# Read the input string\ns = input()\n\n# Print the lexicographically smallest palindrome\nprint(lexicographically_smallest_palindrome(s))"}
{"solution": "piece_weights = {\n    'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n    'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n}\n\nwhite_weight = 0\nblack_weight = 0\n\nfor _ in range(8):\n    row = input()\n    for piece in row:\n        if piece in piece_weights:\n            if piece.isupper():\n                white_weight += piece_weights[piece]\n            else:\n                black_weight += piece_weights[piece]\n\nif white_weight > black_weight:\n    print(\"White\")\nelif black_weight > white_weight:\n    print(\"Black\")\nelse:\n    print(\"Draw\")"}
{"solution": "import heapq\n\ndef solve(N, M, S):\n    S = [int(x) for x in S]\n    dist = [float('inf')] * (N + 1)\n    prev = [-1] * (N + 1)\n    dist[0] = 0\n    queue = [(0, 0)]\n    while queue:\n        d, u = heapq.heappop(queue)\n        if d > dist[u]:\n            continue\n        for v in range(u + 1, min(u + M + 1, N + 1)):\n            if S[v] == 1:\n                continue\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                prev[v] = u\n                heapq.heappush(queue, (dist[v], v))\n    if dist[N] == float('inf'):\n        return -1\n    path = []\n    u = N\n    while u!= 0:\n        path.append(u - prev[u])\n        u = prev[u]\n    return''.join(map(str, reversed(path)))\n\nN, M = map(int, input().split())\nS = input()\nprint(solve(N, M, S))"}
{"solution": "def calculate_distance(x1, y1, x2, y2):\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef find_path(k, x, y):\n    if calculate_distance(0, 0, x, y) % k!= 0:\n        return -1\n\n    path = []\n    current_x, current_y = 0, 0\n\n    while (current_x, current_y)!= (x, y):\n        if abs(x - current_x) >= k:\n            new_x = current_x + k if x > current_x else current_x - k\n            new_y = current_y\n        else:\n            new_x = x\n            new_y = current_y + (k - abs(x - current_x)) if y > current_y else current_y - (k - abs(x - current_x))\n\n        path.append((new_x, new_y))\n        current_x, current_y = new_x, new_y\n\n    return path\n\ndef main():\n    k = int(input())\n    x, y = map(int, input().split())\n\n    result = find_path(k, x, y)\n\n    if result == -1:\n        print(-1)\n    else:\n        print(len(result))\n        for point in result:\n            print(*point)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef find_smallest_n(m):\n    n = 1\n    while True:\n        count = 0\n        for k in range(2, int(math.sqrt(n)) + 2):\n            a = 1\n            for _ in range(3):\n                a *= k\n                if a > n:\n                    break\n            else:\n                count += 1\n        if count == m:\n            return n\n        n += 1\n        if n > 10**6:\n            return -1\n\nm = int(input())\nprint(find_smallest_n(m))"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    \n    if d >= r1 + r2:\n        return 0\n    \n    if d <= abs(r1 - r2):\n        r_min = min(r1, r2)\n        return math.pi * r_min ** 2\n    \n    a = (r1 ** 2 - r2 ** 2 + d ** 2) / (2 * d)\n    h = math.sqrt(r1 ** 2 - a ** 2)\n    area = 0.5 * math.pi * h * (r1 + r2 - d)\n    area += 0.5 * r1 ** 2 * math.acos(a / r1) - 0.5 * r2 ** 2 * math.acos((d - a) / r2)\n    return area\n\nx1, y1, r1 = map(float, input().split())\nx2, y2, r2 = map(float, input().split())\n\nprint(circle_intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "def min_value(n):\n    if n == 1:\n        return 1\n    elif n % 2 == 0:\n        return 1 if n > 4 else n\n    else:\n        return 1 if n > 3 else n\n\nv = int(input())\nprint(min_value(v))"}
{"solution": "from collections import defaultdict\n\ndef dfs(node, graph, a, dp):\n    if dp[node]!= -1:\n        return dp[node]\n    if not graph[node]:\n        dp[node] = a[node]\n        return dp[node]\n    total = 0\n    for child in graph[node]:\n        total += dfs(child, graph, a, dp)\n    dp[node] = max(total, a[node])\n    return dp[node]\n\ndef solve():\n    n = int(input())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    graph = defaultdict(list)\n    for i in range(n-1):\n        graph[p[i]].append(i+2)\n    dp = [-1] * (n + 1)\n    print(dfs(1, graph, a, dp))\n\nsolve()"}
{"solution": "def count_typo_words(n, S, T):\n    count = 0\n    for i in range(n + 1):\n        # Construct W by inserting a character at position i in both S and T\n        if i == 0:\n            W1 = S[0] + S\n            W2 = T[0] + T\n        elif i == n:\n            W1 = S + S[-1]\n            W2 = T + T[-1]\n        else:\n            W1 = S[:i] + S[i] + S[i:]\n            W2 = T[:i] + T[i] + T[i:]\n        \n        # Check if the constructed words are the same\n        if W1 == W2:\n            count += 1\n    \n    return count\n\nn = int(input())\nS = input().strip()\nT = input().strip()\nprint(count_typo_words(n, S, T))"}
{"solution": "import sys\nfrom collections import deque\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(input())\n\ndef read_ints():\n    return map(int, input().split())\n\ndef solve():\n    n = read_int()\n    a = list(read_ints())\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = read_ints()\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def get_max(a, graph):\n        max_a = max(a)\n        max_diff = [0] * n\n        queue = deque()\n        for i in range(n):\n            if len(graph[i]) == 1:\n                queue.append(i)\n        while queue:\n            u = queue.popleft()\n            for v in graph[u]:\n                if max_diff[v] < max_diff[u] + 1:\n                    max_diff[v] = max_diff[u] + 1\n                    queue.append(v)\n        for i in range(n):\n            max_a = max(max_a, a[i] + max_diff[i])\n        return max_a\n\n    max_a = get_max(a, graph)\n    for i in range(n):\n        a[i] = -a[i]\n    max_a = max(max_a, -get_max(a, graph))\n    return max_a\n\nprint(solve())"}
{"solution": "n, m = map(int, input().split())\nprint(min(m, n - m) if m!= n else 0)"}
{"solution": "def min_shovels(k, r):\n    \"\"\"\n    Calculate the minimum number of shovels Polycarp needs to buy to pay without any change.\n\n    Args:\n    k (int): The price of one shovel.\n    r (int): The denomination of the coin in Polycarp's pocket that is different from \"10-burle coins\".\n\n    Returns:\n    int: The minimum number of shovels Polycarp needs to buy.\n    \"\"\"\n    for i in range(1, 11):\n        total_cost = i * k\n        remainder = total_cost % 10\n        if remainder == r or remainder == 0:\n            return i\n    return 10\n\nk, r = map(int, input().split())\nprint(min_shovels(k, r))"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # Dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Extract the bounding box\n    piece = []\n    for i in range(min_row, max_row + 1):\n        piece.append(grid[i][min_col:max_col + 1])\n    \n    # Check horizontal placement\n    if width * 2 == m:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j]!= piece[i][j + width]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    # Check vertical placement\n    if height * 2 == n:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j]!= piece[i + height][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "def min_segments():\n    points = [list(map(int, input().split())) for _ in range(3)]\n\n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n\n    if len(set(x_coords)) == 1 or len(set(y_coords)) == 1:\n        return 1\n    elif len(set(x_coords)) == 2 and len(set(y_coords)) == 2:\n        return 2\n    else:\n        return 3\n\nprint(min_segments())"}
{"solution": "def construct_k_regular_graph(k):\n    if k == 1:\n        return 2, [(1, 2)]\n    elif k == 2:\n        return \"NO\"\n    else:\n        n = 2 * k\n        edges = []\n        for i in range(1, k + 1):\n            edges.append((i, i + k))\n            for j in range(1, k):\n                edges.append((i, i + j))\n                edges.append((i + k, i + k + j))\n        edges.append((1, k + 1))\n        return n, edges\n\n\ndef main():\n    k = int(input())\n    result = construct_k_regular_graph(k)\n    if result == \"NO\":\n        print(\"NO\")\n    else:\n        n, edges = result\n        m = len(edges)\n        print(\"YES\")\n        print(n, m)\n        for edge in edges:\n            print(*edge)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def kmp(s, t):\n    n, m = len(s), len(t)\n    lps = [0] * m\n    j = 0\n    for i in range(1, m):\n        while j > 0 and t[i]!= t[j]:\n            j = lps[j - 1]\n        if t[i] == t[j]:\n            j += 1\n        lps[i] = j\n    j = 0\n    count = 0\n    for i in range(n):\n        while j > 0 and s[i]!= t[j]:\n            j = lps[j - 1]\n        if s[i] == t[j]:\n            j += 1\n        if j == m:\n            count += 1\n            j = lps[j - 1]\n    return count\n\ndef solve():\n    n, m, q = map(int, input().split())\n    s = input()\n    t = input()\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + kmp(s[:i + 1], t)\n    for _ in range(q):\n        l, r = map(int, input().split())\n        print(prefix[r] - prefix[l - 1])\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "MOD = 1000000007\n\ndef count_paths(n, k, d):\n    dp = [[[0 for _ in range(k + 1)] for _ in range(n + 1)] for _ in range(2)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            for l in range(1, k + 1):\n                dp[i % 2][j][l] = 0\n                for m in range(1, k + 1):\n                    if m >= l:\n                        dp[i % 2][j][l] += dp[(i - 1) % 2][j - m][min(m, d - 1)]\n                    else:\n                        dp[i % 2][j][l] += dp[(i - 1) % 2][j - m][0]\n                    dp[i % 2][j][l] %= MOD\n\n    ans = 0\n    for i in range(d, k + 1):\n        ans += dp[n % 2][n][i]\n        ans %= MOD\n\n    return ans\n\nn, k, d = map(int, input().split())\nprint(count_paths(n, k, d))"}
{"solution": "def encrypt_japanese_crossword(n, row):\n    groups = []\n    count = 0\n    \n    for char in row:\n        if char == 'B':\n            count += 1\n        else:\n            if count > 0:\n                groups.append(count)\n                count = 0\n    \n    if count > 0:\n        groups.append(count)\n    \n    print(len(groups))\n    if groups:\n        print(\" \".join(map(str, groups)))\n\nn = int(input())\nrow = input().strip()\nencrypt_japanese_crossword(n, row)"}
{"solution": "import sys\n\ndef main():\n    n, m, p = map(int, sys.stdin.readline().split())\n    s = sys.stdin.readline().strip()\n    operations = sys.stdin.readline().strip()\n\n    stack = []\n    pairs = {}\n\n    for i, c in enumerate(s):\n        if c == '(':\n            stack.append(i)\n        else:\n            pairs[stack.pop()] = i\n            pairs[i] = stack[-1]\n\n    cursor = p - 1\n\n    for op in operations:\n        if op == 'L':\n            cursor -= 1\n        elif op == 'R':\n            cursor += 1\n        elif op == 'D':\n            left = min(cursor, pairs[cursor])\n            right = max(cursor, pairs[cursor])\n\n            for i in range(left, right + 1):\n                if i in pairs:\n                    del pairs[i]\n\n            if left in pairs.values():\n                for k, v in pairs.items():\n                    if v == left:\n                        del pairs[k]\n                        break\n\n            if right in pairs.values():\n                for k, v in pairs.items():\n                    if v == right:\n                        del pairs[k]\n                        break\n\n            if cursor in pairs:\n                del pairs[cursor]\n\n            if cursor > left:\n                cursor = left\n            else:\n                cursor = right + 1\n\n            while cursor < n and cursor not in pairs:\n                cursor += 1\n\n            if cursor == n:\n                cursor = n - 1\n                while cursor >= 0 and cursor not in pairs:\n                    cursor -= 1\n\n    result = ['(' if i in pairs else ')' if i in pairs.values() else '' for i in range(n)]\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_y():\n    n = int(input())\n    min_val = -2 * 10**9\n    max_val = 2 * 10**9\n\n    for _ in range(n):\n        sign, x, answer = input().split()\n        x = int(x)\n\n        if sign == \">\":\n            if answer == \"Y\":\n                min_val = max(min_val, x + 1)\n            else:\n                max_val = min(max_val, x)\n        elif sign == \"<\":\n            if answer == \"Y\":\n                max_val = min(max_val, x - 1)\n            else:\n                min_val = max(min_val, x)\n        elif sign == \">=\":\n            if answer == \"Y\":\n                min_val = max(min_val, x)\n            else:\n                max_val = min(max_val, x - 1)\n        elif sign == \"<=\":\n            if answer == \"Y\":\n                max_val = min(max_val, x)\n            else:\n                min_val = max(min_val, x + 1)\n\n    if min_val <= max_val:\n        return min_val\n    else:\n        return \"Impossible\"\n\nprint(find_y())"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_periods(a, b):\n    if a > b:\n        a, b = b, a\n    if a == b:\n        return a + 1\n    g = gcd(a, b)\n    return sum(math.gcd(g, i) == g for i in range(g, a + b + 1, g))\n\na, b = map(int, input().split())\nprint(count_periods(a, b))"}
{"solution": "def generate_names(n, k, conditions):\n    names = []\n    counter = 0\n    for i in range(n):\n        if i < k - 1:\n            names.append(f\"A{chr(97 + i)}\")\n        else:\n            if conditions[i - k + 1] == \"YES\":\n                counter += 1\n                names.append(f\"A{chr(97 + counter)}\")\n            else:\n                names.append(names[i - 1])\n    return names\n\nn, k = map(int, input().split())\nconditions = input().split()\n\nnames = generate_names(n, k, conditions)\nprint(\" \".join(names))"}
{"solution": "def min_operations_to_equal(a, b):\n    def count_factors(n, factor):\n        count = 0\n        while n % factor == 0:\n            n //= factor\n            count += 1\n        return count, n\n\n    # Count the number of times we can divide by 2, 3, and 5\n    a2, a = count_factors(a, 2)\n    a3, a = count_factors(a, 3)\n    a5, a = count_factors(a, 5)\n    \n    b2, b = count_factors(b, 2)\n    b3, b = count_factors(b, 3)\n    b5, b = count_factors(b, 5)\n    \n    # If the remaining parts are not equal, return -1\n    if a!= b:\n        return -1\n    \n    # Calculate the total number of operations needed\n    operations = abs(a2 - b2) + abs(a3 - b3) + abs(a5 - b5)\n    \n    return operations\n\na, b = map(int, input().split())\nprint(min_operations_to_equal(a, b))"}
{"solution": "def calculate_min_cost(n, a, b, colors):\n    \"\"\"\n    Calculate the minimum cost to form a palindrome.\n\n    Args:\n    n (int): The number of dancers.\n    a (int): The cost of a white suit.\n    b (int): The cost of a black suit.\n    colors (list): A list of integers representing the color of each dancer's suit.\n\n    Returns:\n    int: The minimum cost to form a palindrome, or -1 if it's not possible.\n    \"\"\"\n    total_cost = 0\n    for i in range(n // 2):\n        if colors[i] == colors[n - i - 1]:\n            if colors[i] == 2:\n                total_cost += min(a, b)\n        elif colors[i] == 2:\n            if colors[n - i - 1] == 0:\n                total_cost += a\n            else:\n                total_cost += b\n        elif colors[n - i - 1] == 2:\n            if colors[i] == 0:\n                total_cost += a\n            else:\n                total_cost += b\n        else:\n            return -1\n\n    if n % 2 == 1 and colors[n // 2] == 2:\n        total_cost += min(a, b)\n\n    return total_cost\n\n\nn, a, b = map(int, input().split())\ncolors = list(map(int, input().split()))\n\nprint(calculate_min_cost(n, a, b, colors))"}
{"solution": "def paint_cube(k):\n    if k == 1:\n        return -1\n\n    cube = []\n    for i in range(k):\n        layer = []\n        for j in range(k):\n            row = []\n            for z in range(k):\n                if (i + j + z) % 2 == 0:\n                    row.append('b')\n                else:\n                    row.append('w')\n            layer.append(''.join(row))\n        cube.append(layer)\n\n    for layer in cube:\n        for row in layer:\n            print(row)\n        print()\n\nk = int(input())\nresult = paint_cube(k)\nif result == -1:\n    print(-1)"}
{"solution": "import math\nfrom collections import Counter\n\ndef largest_lovely_number(n):\n    def prime_factors(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            while (n % i) == 0:\n                factors.append(i)\n                n //= i\n            i += 1\n        if n > 1:\n            factors.append(n)\n        return factors\n\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n    \n    lovely_number = 1\n    for prime, count in factor_counts.items():\n        lovely_number *= prime ** min(count, 1)\n    \n    return lovely_number\n\nn = int(input())\nprint(largest_lovely_number(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    # Check for adjacent occupied seats\n    for i in range(n - 1):\n        if seating[i] == '1' and seating[i + 1] == '1':\n            return \"No\"\n    \n    # Check for possible additional seating\n    for i in range(n):\n        if seating[i] == '0':\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                return \"No\"\n    \n    return \"Yes\"\n\nn = int(input())\nseating = input().strip()\nprint(is_maximal_seating(n, seating))"}
{"solution": "def find_possible_k(n, a):\n    possible_k = []\n    for k in range(1, n + 1):\n        x = [a[i] - a[i - 1] for i in range(1, k + 1)]\n        valid = True\n        for i in range(k + 1, n + 1):\n            if a[i] - a[i - 1]!= x[(i - 1) % k]:\n                valid = False\n                break\n        if valid:\n            possible_k.append(k)\n    return possible_k\n\n\nn = int(input())\na = list(map(int, input().split()))\npossible_k = find_possible_k(n, a)\nprint(len(possible_k))\nprint(*possible_k)"}
{"solution": "def can_form_equal_teams(scores):\n    total_score = sum(scores)\n    if total_score % 2!= 0:\n        return False\n\n    target_score = total_score // 2\n    scores.sort(reverse=True)\n\n    def dfs(index, current_score, count):\n        if count == 3:\n            return current_score == target_score\n        if current_score > target_score or index >= len(scores):\n            return False\n\n        return dfs(index + 1, current_score + scores[index], count + 1) or dfs(index + 1, current_score, count)\n\n    return dfs(0, 0, 0)\n\n\nscores = list(map(int, input().split()))\nprint(\"YES\" if can_form_equal_teams(scores) else \"NO\")"}
{"solution": "def count_2_3_integers(left, right):\n    \"\"\"\n    Counts the number of 2-3-integers in the given range [left, right].\n    \n    A 2-3-integer is a positive integer that is equal to 2^x * 3^y for some non-negative integers x and y.\n    \n    Args:\n        left (int): The start of the range (inclusive).\n        right (int): The end of the range (inclusive).\n    \n    Returns:\n        int: The number of 2-3-integers in the given range.\n    \"\"\"\n    def count_2_3_integers_up_to(n):\n        \"\"\"\n        Counts the number of 2-3-integers up to n.\n        \n        Args:\n            n (int): The upper limit (inclusive).\n        \n        Returns:\n            int: The number of 2-3-integers up to n.\n        \"\"\"\n        count = 0\n        x = 1\n        while x <= n:\n            y = 1\n            while x * y <= n:\n                count += 1\n                y *= 3\n            x *= 2\n        return count\n    \n    return count_2_3_integers_up_to(right) - count_2_3_integers_up_to(left - 1)\n\n\nleft, right = map(int, input().split())\nprint(count_2_3_integers(left, right))"}
{"solution": "def calculate_eaten_candies(n, k):\n    \"\"\"\n    Calculate the total number of candies Alya ate.\n\n    Args:\n    n (int): The total number of moves.\n    k (int): The number of candies in the box at the end.\n\n    Returns:\n    int: The total number of candies Alya ate.\n    \"\"\"\n    # Initialize the number of candies put and eaten\n    put = 0\n    eaten = 0\n\n    # Calculate the number of candies put and eaten\n    for i in range(1, n + 1):\n        if k - put - i >= 0:\n            put += i\n        else:\n            eaten += 1\n            k += 1\n\n    # Return the total number of candies eaten\n    return eaten\n\n\n# Read the input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(n - 1 - (k - 1) // ((n + 1) // 2))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\nfor i in range(n - 2):\n    if a[i] + a[i + 1] > a[i + 2]:\n        print(\"YES\")\n        sys.exit()\n\nprint(\"NO\")"}
{"solution": "def solve(x, y):\n    if x == 0:\n        return y == 1\n    if y == 1:\n        return x == 0\n    if x % 2 == 0:\n        return False\n    return solve(x - 1, y - 1) or solve(x // 2, y - 1)\n\nx, y = map(int, input().split())\nprint(\"Yes\" if solve(x, y) else \"No\")"}
{"solution": "import math\n\ndef calculate_total_rating(n, k, skills):\n    total_rating = sum(math.floor(skill / 10) for skill in skills)\n    improvements = sorted([(10 - (skill % 10), skill) for skill in skills if skill < 100])\n    \n    for improvement in improvements:\n        if k >= improvement[0]:\n            k -= improvement[0]\n            total_rating += 1\n        else:\n            break\n    \n    return total_rating\n\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\nprint(calculate_total_rating(n, k, skills))"}
{"solution": "def find_smallest_pretty_integer():\n    n, m = map(int, input().split())\n    list1 = list(map(int, input().split()))\n    list2 = list(map(int, input().split()))\n\n    set1 = set(list1)\n    set2 = set(list2)\n\n    common_digits = set1.intersection(set2)\n    if common_digits:\n        return min(common_digits)\n\n    min1 = min(list1)\n    min2 = min(list2)\n\n    smallest_pretty = min(int(str(min1) + str(min2)), int(str(min2) + str(min1)))\n    return smallest_pretty\n\nprint(find_smallest_pretty_integer())"}
{"solution": "def calculate_problems(n, k):\n    \"\"\"\n    Calculate the maximum number of problems Limak can solve before leaving for the party.\n\n    Args:\n    n (int): The number of problems in the contest.\n    k (int): The number of minutes Limak needs to get to the party from his house.\n\n    Returns:\n    int: The maximum number of problems Limak can solve.\n    \"\"\"\n    total_time = 240  # Total time available in minutes\n    time_left = total_time - k  # Time left for solving problems\n    problem_time = 0  # Time spent solving problems\n    problems_solved = 0  # Number of problems solved\n\n    for i in range(1, n + 1):\n        problem_time += 5 * i  # Calculate time required for the current problem\n        if problem_time <= time_left:\n            problems_solved += 1  # Increment the number of problems solved\n        else:\n            break  # Exit the loop if time runs out\n\n    return problems_solved\n\n\nn, k = map(int, input().split())\nprint(calculate_problems(n, k))"}
{"solution": ""}
{"solution": "import math\n\ndef count_divisors(n):\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            if i!= n // i:\n                divisors.add(n // i)\n        i += 1\n    return len(divisors)\n\nb = int(input().strip())\nresult = count_divisors(b)\nprint(result)"}
{"solution": "def pinball_game(n, bumpers):\n    \"\"\"\n    Calculate the number of positions such that the ball will eventually fall from the game field if it starts at that position.\n\n    Args:\n        n (int): The length of the sequence of bumpers.\n        bumpers (str): A string representing the bumpers' types.\n\n    Returns:\n        int: The number of positions in the sequence such that the ball will eventually fall from the game field if it starts at that position.\n    \"\"\"\n    # Initialize a list to store the direction of each bumper\n    directions = [1 if bumper == '>' else -1 for bumper in bumpers]\n\n    # Initialize a list to store the number of positions that will eventually fall from the game field\n    fall_positions = [0] * n\n\n    # Initialize the current position and the number of positions that will eventually fall from the game field\n    current_position = 0\n    fall_count = 0\n\n    # Iterate over the bumpers\n    while current_position < n:\n        # If the current position is at the edge of the game field, increment the fall count\n        if current_position == 0 and directions[current_position] == -1:\n            fall_count += 1\n            current_position += 1\n        elif current_position == n - 1 and directions[current_position] == 1:\n            fall_count += 1\n            current_position += 1\n        # If the current position will eventually fall from the game field, mark it and move to the next position\n        elif fall_positions[current_position] == 1:\n            current_position += 1\n        # If the current position will not eventually fall from the game field, mark it and move to the next position\n        else:\n            next_position = current_position + directions[current_position]\n            if next_position < 0 or next_position >= n:\n                fall_count += 1\n                fall_positions[current_position] = 1\n                current_position += 1\n            else:\n                fall_positions[current_position] = fall_positions[next_position]\n                current_position += 1\n\n    return fall_count\n\n\n# Read the input\nn = int(input())\nbumpers = input()\n\n# Print the output\nprint(pinball_game(n, bumpers))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    n = int(sys.stdin.readline())\n    sticks = list(map(int, sys.stdin.readline().split()))\n\n    sticks.sort()\n    stick_counts = defaultdict(int)\n    for stick in sticks:\n        stick_counts[stick] += 1\n\n    total_area = 0\n    for length, count in stick_counts.items():\n        if count >= 2:\n            pairs = count // 2\n            total_area += pairs * length * length\n            stick_counts[length - 1] += count % 2\n\n    for length, count in stick_counts.items():\n        if length > 0 and count >= 2:\n            pairs = count // 2\n            total_area += pairs * length * length\n\n    print(total_area)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import defaultdict\n\ndef restore_numbers(n, numbers):\n    # Create a dictionary to store the frequency of each letter\n    freq = defaultdict(int)\n    for num in numbers:\n        for char in num:\n            freq[char] += 1\n\n    # Sort the letters by frequency in descending order\n    sorted_letters = sorted(freq, key=freq.get, reverse=True)\n\n    # Create a dictionary to store the mapping of letters to digits\n    mapping = {}\n    for i, letter in enumerate(sorted_letters):\n        mapping[letter] = str(i)\n\n    # Replace the letters with digits in the numbers\n    restored_numbers = []\n    for num in numbers:\n        restored_num = ''.join(mapping[char] for char in num)\n        restored_numbers.append(int(restored_num))\n\n    # Return the sum of the restored numbers\n    return sum(restored_numbers)\n\n# Read the input\nn = int(input())\nnumbers = [input() for _ in range(n)]\n\n# Print the output\nprint(restore_numbers(n, numbers))"}
{"solution": "def max_teams(n, m):\n    # Calculate the maximum number of teams of type 1 (1 XP, 2 NB)\n    t1 = min(n, m // 2)\n    \n    # Calculate the remaining newbies after forming type 1 teams\n    remaining_nb = m - 2 * t1\n    \n    # Calculate the maximum number of teams of type 2 (2 XP, 1 NB) using the remaining newbies\n    t2 = min((n - t1) // 2, remaining_nb)\n    \n    # Return the total number of teams\n    return t1 + t2\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    n = len(s)\n    \n    # Check for \"AB\" followed by \"BA\"\n    found_AB = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"AB\":\n            found_AB = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"BA\":\n                    print(\"YES\")\n                    return\n            break\n    \n    # Check for \"BA\" followed by \"AB\"\n    found_BA = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"BA\":\n            found_BA = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"AB\":\n                    print(\"YES\")\n                    return\n            break\n    \n    # If neither condition is met\n    print(\"NO\")\n\ns = input().strip()\ncheck_substrings(s)"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    k = int(input())\n    b = list(map(int, input().split()))\n\n    if sum(a)!= sum(b):\n        print(\"NO\")\n        return\n\n    ans = []\n    for i in range(n - k):\n        for j in range(len(a) - 1):\n            if a[j] < a[j + 1]:\n                a[j + 1] += a[j]\n                ans.append((j + 1, 'L'))\n                a.pop(j)\n                break\n        else:\n            for j in range(len(a) - 1, 0, -1):\n                if a[j] > a[j - 1]:\n                    a[j - 1] += a[j]\n                    ans.append((j, 'R'))\n                    a.pop(j)\n                    break\n            else:\n                print(\"NO\")\n                return\n\n    if a!= b:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    for x, c in ans:\n        print(x, c)\n\nsolve()"}
{"solution": "import sys\n\ndef read_input():\n    lines = sys.stdin.readlines()\n    R, B = map(int, lines[0].split())\n    points = []\n    for line in lines[1:]:\n        x, y = map(int, line.split())\n        points.append((x, y))\n    return R, B, points\n\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # Collinear\n    elif val > 0:\n        return 1  # Clockwise\n    else:\n        return 2  # Counterclockwise\n\ndef intersect(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if (o1!= o2 and o3!= o4):\n        return True\n\n    if (o1 == 0 and on_segment(p1, p2, q1)):\n        return True\n\n    if (o2 == 0 and on_segment(p1, q2, q1)):\n        return True\n\n    if (o3 == 0 and on_segment(p2, p1, q2)):\n        return True\n\n    if (o4 == 0 and on_segment(p2, q1, q2)):\n        return True\n\n    return False\n\ndef on_segment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n        q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\ndef solve(R, B, points):\n    if R!= B:\n        return \"No\"\n\n    for i in range(R):\n        for j in range(i + 1, R):\n            for k in range(R):\n                for l in range(k + 1, R):\n                    if intersect(points[i], points[R + k], points[j], points[R + l]):\n                        return \"No\"\n\n    return \"Yes\"\n\nR, B, points = read_input()\nprint(solve(R, B, points))"}
{"solution": "import math\n\nn = int(input())\na = list(map(int, input().split()))\n\nmax_power = 0\ncount = 0\n\nfor num in a:\n    power = 0\n    while num % 2 == 0:\n        power += 1\n        num //= 2\n    if power > max_power:\n        max_power = power\n        count = 1\n    elif power == max_power:\n        count += 1\n\nprint(2 ** max_power, count)"}
{"solution": "def min_clicks(n, m):\n    clicks = 0\n    while m > n:\n        if m % 2 == 0:\n            m //= 2\n        else:\n            m -= 1\n        clicks += 1\n    return clicks + (n - m)\n\nn, m = map(int, input().split())\nprint(min_clicks(n, m))"}
{"solution": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x]!= x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x!= root_y:\n            if self.rank[root_x] > self.rank[root_y]:\n                self.parent[root_y] = root_x\n            elif self.rank[root_x] < self.rank[root_y]:\n                self.parent[root_x] = root_y\n            else:\n                self.parent[root_y] = root_x\n                self.rank[root_x] += 1\n\n\ndef solve():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, input().split())\n        segments.append((l, r))\n\n    events = []\n    for i, (l, r) in enumerate(segments):\n        events.append((l, 1, i))\n        events.append((r, -1, i))\n    events.sort()\n\n    uf = UnionFind(n)\n    edges = 0\n    for _, type, i in events:\n        if type == 1:\n            for j in range(i + 1, n):\n                if segments[j][0] < segments[i][1] and segments[i][0] < segments[j][1]:\n                    if uf.find(i)!= uf.find(j):\n                        uf.union(i, j)\n                        edges += 1\n    if edges == n - 1 and len(set(uf.find(i) for i in range(n))) == 1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def longest_ddos_period(n, requests):\n    max_length = 0\n    for i in range(n):\n        total_requests = 0\n        for j in range(i, n):\n            total_requests += requests[j]\n            if total_requests > 100 * (j - i + 1):\n                max_length = max(max_length, j - i + 1)\n    return max_length\n\nn = int(input())\nrequests = list(map(int, input().split()))\nprint(longest_ddos_period(n, requests))"}
{"solution": "def check_dissatisfaction(n, k, episodes):\n    max_dissatisfaction = 0\n    current_dissatisfaction = 0\n\n    for episode in episodes:\n        if episode == 'N' or episode == '?':\n            current_dissatisfaction += 1\n            max_dissatisfaction = max(max_dissatisfaction, current_dissatisfaction)\n        else:\n            current_dissatisfaction = 0\n\n    if max_dissatisfaction == k:\n        return \"YES\"\n    elif max_dissatisfaction > k:\n        return \"NO\"\n    else:\n        # Check if we can make the dissatisfaction equal to k\n        # by assuming '?' as 'N'\n        current_dissatisfaction = 0\n        for episode in episodes:\n            if episode == 'N':\n                current_dissatisfaction += 1\n            elif episode == '?':\n                current_dissatisfaction += 1\n                if current_dissatisfaction == k:\n                    return \"YES\"\n                if current_dissatisfaction > k:\n                    current_dissatisfaction -= 1\n            else:\n                current_dissatisfaction = 0\n        return \"NO\"\n\n\nn, k = map(int, input().split())\nepisodes = input()\n\nprint(check_dissatisfaction(n, k, episodes))"}
{"solution": "def calculate_possible_values(n, x, d):\n    \"\"\"\n    Calculate the number of possible values of S - T.\n\n    Args:\n    n (int): The length of the sequence.\n    x (int): The first element of the sequence.\n    d (int): The common difference of the sequence.\n\n    Returns:\n    int: The number of possible values of S - T.\n    \"\"\"\n    # Calculate the sum of the sequence\n    total_sum = n * (2 * x + (n - 1) * d) // 2\n\n    # If the total sum is odd, the number of possible values is 2 * n - 1\n    if total_sum % 2!= 0:\n        return 2 * n - 1\n\n    # If the total sum is even, the number of possible values is 2 * n\n    # However, we need to subtract 1 if the sequence has an even number of elements\n    # and the common difference is even, because in this case, the sum of the sequence\n    # is divisible by 4, and the difference between the sums of the two parts\n    # will always be even\n    if n % 2 == 0 and d % 2 == 0:\n        return 2 * n - 1\n    else:\n        return 2 * n\n\n\n# Read the input\nn, x, d = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_possible_values(n, x, d)\nprint(result)"}
{"solution": "def did_anton_perform_good():\n    n = int(input())\n    participants = [input().split() for _ in range(n)]\n    participants = [(handle, int(before), int(after)) for handle, before, after in participants]\n\n    for participant in participants:\n        handle, before, after = participant\n        if before >= 2400 and after > before:\n            return \"YES\"\n    return \"NO\"\n\nprint(did_anton_perform_good())"}
{"solution": "def count_missed_trains(s):\n    \"\"\"\n    Calculate the number of trains that have departed strictly before time s.\n\n    Args:\n    s (str): A binary number representing the time.\n\n    Returns:\n    int: The number of trains that have departed strictly before time s.\n    \"\"\"\n    # Convert binary string to integer\n    s_int = int(s, 2)\n    \n    # Initialize the number of missed trains\n    missed_trains = 0\n    \n    # Initialize the current train departure time\n    current_time = 1\n    \n    # Loop until the current train departure time exceeds the given time\n    while current_time <= s_int:\n        # If the current train departure time is less than the given time,\n        # increment the number of missed trains\n        if current_time < s_int:\n            missed_trains += 1\n        \n        # Update the current train departure time to the next power of 4\n        current_time *= 4\n    \n    return missed_trains\n\n# Read the binary time from input\ns = input().strip()\n\n# Calculate and print the number of missed trains\nprint(count_missed_trains(s))"}
{"solution": "def min_rows(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n    for i in range(n // 2):\n        if matrix[i]!= matrix[n - i - 1]:\n            return n - i\n    return n // 2 if n % 2 == 0 else n // 2 + 1\n\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\nprint(min_rows(matrix))"}
{"solution": "def max_non_overlapping_orders():\n    n = int(input())\n    orders = []\n    for _ in range(n):\n        l, r = map(int, input().split())\n        orders.append((l, r))\n\n    orders.sort(key=lambda x: x[1])\n\n    count = 0\n    end_time = -1\n    for l, r in orders:\n        if l > end_time:\n            count += 1\n            end_time = r\n\n    print(count)\n\nmax_non_overlapping_orders()"}
{"solution": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    x = list(map(int, sys.stdin.readline().split()))\n    y = list(map(int, sys.stdin.readline().split()))\n\n    x_sum = 0\n    y_sum = 0\n    x_prev = 0\n    y_prev = 0\n\n    for i in range(n):\n        x_sum += x[i]\n        y_sum += y[i]\n\n        if x_sum > k * (i + 1) or y_sum > k * (i + 1):\n            print(\"NO\")\n            return\n\n        if x[i] > k or y[i] > k:\n            print(\"NO\")\n            return\n\n        if x_prev + x[i] > k or y_prev + y[i] > k:\n            x_prev = x[i]\n            y_prev = y[i]\n        else:\n            x_prev += x[i]\n            y_prev += y[i]\n\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def can_human_win(n, k, coefficients):\n    # Calculate the value of P(k)\n    p_k = sum(coefficients[i] * (k ** (n - i)) for i in range(n + 1))\n\n    # If P(k) is already 0, human has won\n    if p_k == 0:\n        return True\n\n    # If the number of unknown coefficients is odd, human can make it 0\n    unknown_count = sum(1 for coeff in coefficients if coeff == '?')\n    if unknown_count % 2 == 1:\n        return True\n\n    # If the number of unknown coefficients is even, human can't make it 0\n    return False\n\n\ndef main():\n    n, k = map(int, input().split())\n    coefficients = [input().strip() for _ in range(n + 1)]\n\n    # Replace '?' with 0 for easier calculation\n    coefficients = [int(coeff) if coeff!= '?' else 0 for coeff in coefficients]\n\n    if can_human_win(n, k, coefficients):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def sieve_of_eratosthenes(n):\n    \"\"\"Generate all prime numbers up to n.\"\"\"\n    sieve = [True] * (n + 1)\n    sieve[0:2] = [False, False]\n    for current_prime in range(2, int(n**0.5) + 1):\n        if sieve[current_prime]:\n            for multiple in range(current_prime**2, n + 1, current_prime):\n                sieve[multiple] = False\n    return [num for num, is_prime in enumerate(sieve) if is_prime]\n\n\ndef smallest_starting_number(x2):\n    \"\"\"Find the smallest possible starting number X_0 given X_2.\"\"\"\n    primes = sieve_of_eratosthenes(x2)\n    min_x0 = x2\n\n    for p in primes:\n        if p >= x2 - 1:\n            break\n        x1 = x2 - x2 % p + p\n        if x1 < x2:\n            for q in primes:\n                if q >= x1 - 1:\n                    break\n                x0 = x1 - x1 % q + q\n                if x0 < x1 and x0 >= 3:\n                    min_x0 = min(min_x0, x0)\n\n    return min_x0\n\n\nx2 = int(input())\nprint(smallest_starting_number(x2))"}
{"solution": "def min_p_binary_numbers(n, p):\n    for k in range(1, n + 1):\n        if (n - k * p) < k or bin(n - k * p).count('1') > k:\n            continue\n        return k\n    return -1\n\nn, p = map(int, input().split())\nprint(min_p_binary_numbers(n, p))"}
{"solution": "def minimize_integer(n, k, s):\n    s = list(s)\n    if k == 0:\n        return ''.join(s)\n    if n == 1:\n        return '0'\n    if s[0]!= '1':\n        s[0] = '1'\n        k -= 1\n    for i in range(1, n):\n        if k > 0 and s[i]!= '0':\n            s[i] = '0'\n            k -= 1\n    return ''.join(s)\n\nn, k = map(int, input().split())\ns = input()\nprint(minimize_integer(n, k, s))"}
{"solution": "def min_presents(cnt_1, cnt_2, x, y):\n    def lcm(a, b):\n        from math import gcd\n        return a * b // gcd(a, b)\n\n    def count_multiples(v, x):\n        return v // x\n\n    def count_multiples_xy(v, lcm_xy):\n        return v // lcm_xy\n\n    lcm_xy = lcm(x, y)\n    v = 0\n    while True:\n        v += 1\n        multiples_x = count_multiples(v, x)\n        multiples_y = count_multiples(v, y)\n        multiples_xy = count_multiples_xy(v, lcm_xy)\n        free = v - (multiples_x + multiples_y - multiples_xy)\n        if free >= cnt_1 + cnt_2:\n            break\n\n    return v\n\n\ncnt_1, cnt_2, x, y = map(int, input().split())\nprint(min_presents(cnt_1, cnt_2, x, y))"}
{"solution": "def calculate_bear_position(n, sx, sy, dx, dy, t):\n    \"\"\"\n    Calculate the bear's position after t seconds.\n\n    Args:\n    n (int): The size of the checkered field.\n    sx (int): The initial x-coordinate of the bear.\n    sy (int): The initial y-coordinate of the bear.\n    dx (int): The initial x-component of the bear's speed.\n    dy (int): The initial y-component of the bear's speed.\n    t (int): The time the bear spends on the field.\n\n    Returns:\n    tuple: The final x and y coordinates of the bear.\n    \"\"\"\n    # Calculate the initial speed increase\n    speed_increase = sx + sy\n\n    # Update the bear's speed\n    dx += speed_increase\n    dy += speed_increase\n\n    # Calculate the bear's new position\n    sx = ((sx + dx - 1) % n) + 1\n    sy = ((sy + dy - 1) % n) + 1\n\n    # Calculate the number of times the bear's speed will increase\n    speed_increase_count = t - 1\n\n    # Calculate the total speed increase\n    total_speed_increase = speed_increase_count * n * 2\n\n    # Update the bear's speed\n    dx += total_speed_increase\n    dy += total_speed_increase\n\n    # Calculate the bear's final position\n    sx = ((sx + dx - 1) % n) + 1\n    sy = ((sy + dy - 1) % n) + 1\n\n    return sx, sy\n\n\n# Read the input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Calculate the bear's final position\nfinal_sx, final_sy = calculate_bear_position(n, sx, sy, dx, dy, t)\n\n# Print the output\nprint(final_sx, final_sy)"}
{"solution": "def solve(s):\n    n = len(s)\n    if n < 26:\n        return -1\n\n    for i in range(n - 26 + 1):\n        window = s[i:i + 26]\n        missing = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ') - set(window.replace('?', ''))\n        unknown = window.count('?')\n\n        if len(missing) > unknown:\n            continue\n\n        result = list(window)\n        for j, c in enumerate(result):\n            if c == '?':\n                if missing:\n                    result[j] = missing.pop()\n                else:\n                    for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                        if c not in result:\n                            result[j] = c\n                            break\n\n        if set(result) == set('ABCDEFGHIJKLMNOPQRSTUVWXYZ'):\n            s = list(s)\n            s[i:i + 26] = result\n            return ''.join(s)\n\n    return -1\n\n\ns = input()\nprint(solve(s))"}
{"solution": "def can_divide_apples(n, weights):\n    total_weight = sum(weights)\n    if total_weight % 2!= 0:\n        return \"NO\"\n    \n    target_weight = total_weight // 2\n    num_200g_apples = weights.count(200)\n    num_100g_apples = n - num_200g_apples\n    \n    if target_weight % 100 == 0:\n        if target_weight // 100 <= num_100g_apples:\n            return \"YES\"\n        elif (target_weight - 200) // 100 <= num_100g_apples and num_200g_apples >= 2:\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        if (target_weight - 100) // 100 <= num_100g_apples - 1 and num_200g_apples >= 1:\n            return \"YES\"\n        else:\n            return \"NO\"\n\nn = int(input())\nweights = list(map(int, input().split()))\nprint(can_divide_apples(n, weights))"}
{"solution": "import sys\n\ndef min_time_to_turn_off_lights(n, m, building):\n    total_time = 0\n    for i in range(n):\n        floor = building[i]\n        left_index = 1\n        right_index = m\n        while left_index <= right_index:\n            if floor[left_index] == '1':\n                total_time += left_index - 1\n                left_index += 1\n            elif floor[right_index] == '1':\n                total_time += m - right_index + 1\n                right_index -= 1\n            else:\n                left_index += 1\n                right_index -= 1\n        if i < n - 1:\n            total_time += 1\n    return total_time\n\nn, m = map(int, sys.stdin.readline().split())\nbuilding = [sys.stdin.readline().strip() for _ in range(n)]\n\nprint(min_time_to_turn_off_lights(n, m, building))"}
{"solution": "def find_min_trap_cost(n, costs, transitions):\n    visited = [False] * n\n    in_stack = [False] * n\n    min_cost = 0\n\n    def dfs(node):\n        stack = []\n        while True:\n            if visited[node]:\n                if in_stack[node]:\n                    # Found a cycle, calculate the minimum cost in this cycle\n                    cycle_min_cost = float('inf')\n                    while stack:\n                        cycle_node = stack.pop()\n                        in_stack[cycle_node] = False\n                        cycle_min_cost = min(cycle_min_cost, costs[cycle_node])\n                        if cycle_node == node:\n                            break\n                    return cycle_min_cost\n                else:\n                    return 0\n            visited[node] = True\n            in_stack[node] = True\n            stack.append(node)\n            node = transitions[node] - 1\n\n    for i in range(n):\n        if not visited[i]:\n            min_cost += dfs(i)\n\n    return min_cost\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(find_min_trap_cost(n, costs, transitions))"}
{"solution": "def calculate_final_entrance(n, a, b):\n    \"\"\"\n    Calculate the final entrance number after Vasya's walk.\n\n    Args:\n    n (int): The total number of entrances.\n    a (int): The initial entrance number.\n    b (int): The length of Vasya's walk.\n\n    Returns:\n    int: The final entrance number.\n    \"\"\"\n    # Calculate the final entrance number by adding the walk length to the initial entrance number\n    # and taking the modulus of the total number of entrances to handle circular movement\n    final_entrance = (a + b - 1) % n + 1\n    \n    return final_entrance\n\n\n# Read input from the user\nn, a, b = map(int, input().split())\n\n# Calculate and print the final entrance number\nprint(calculate_final_entrance(n, a, b))"}
{"solution": "def min_arithmetic_progressions(n, sequence):\n    \"\"\"\n    Calculate the minimum number of arithmetic progressions needed to represent a given sequence.\n\n    Args:\n    n (int): The number of elements in the sequence.\n    sequence (list): A list of integers representing the sequence.\n\n    Returns:\n    int: The minimum number of arithmetic progressions.\n    \"\"\"\n    if n == 1:\n        return 1\n\n    progressions = 1\n    diff = None\n    prev = None\n    count_unknown = 0\n\n    for i in range(n):\n        if sequence[i] == -1:\n            count_unknown += 1\n            continue\n\n        if prev is not None:\n            new_diff = sequence[i] - prev\n            if diff is None:\n                diff = new_diff\n            elif new_diff!= diff:\n                if count_unknown == 0:\n                    progressions += 1\n                    diff = new_diff\n                else:\n                    count_unknown = 0\n                    diff = new_diff\n        else:\n            diff = None\n\n        prev = sequence[i]\n\n    # Handle the case where the last progression has unknown values\n    if count_unknown > 0 and sequence[-1]!= -1:\n        progressions += 1\n\n    return progressions\n\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Calculate and print the minimum number of arithmetic progressions\nprint(min_arithmetic_progressions(n, sequence))"}
{"solution": "def max_beauty(n, k, s):\n    def max_beauty_with_char(c):\n        max_len = 0\n        left = 0\n        k_left = k\n        for right in range(n):\n            if s[right]!= c:\n                k_left -= 1\n            while k_left < 0:\n                if s[left]!= c:\n                    k_left += 1\n                left += 1\n            max_len = max(max_len, right - left + 1)\n        return max_len\n\n    return max(max_beauty_with_char('a'), max_beauty_with_char('b'))\n\nn, k = map(int, input().split())\ns = input().strip()\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, seats):\n    total_seats = sum(seats)\n    alice_seats = seats[0]\n    majority = (total_seats + 1) // 2\n\n    if alice_seats >= majority:\n        return [1]\n\n    coalition = [1]\n    seats = sorted((seat, i + 1) for i, seat in enumerate(seats[1:]))\n\n    for seat, party in seats:\n        if alice_seats >= 2 * seat:\n            coalition.append(party)\n            alice_seats += seat\n            if alice_seats >= majority:\n                break\n\n    return coalition if alice_seats >= majority else []\n\nn = int(input())\nseats = list(map(int, input().split()))\n\ncoalition = find_coalition(n, seats)\n\nif coalition:\n    print(len(coalition))\n    print(*coalition)\nelse:\n    print(0)"}
{"solution": "def max_reward(n):\n    harmonic_sum = 0.0\n    for i in range(1, n + 1):\n        harmonic_sum += 1.0 / i\n    return harmonic_sum\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the maximum reward\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "import math\n\ndef find_max_children(n):\n    k = int((math.sqrt(8 * n + 1) - 1) / 2)\n    remaining_candies = n - k * (k + 1) // 2\n    candies = list(range(1, k + 1))\n    candies[-1] += remaining_candies\n    return k, candies\n\nn = int(input())\nk, candies = find_max_children(n)\nprint(k)\nprint(*candies)"}
{"solution": "n = int(input())\nm = int(input())\n\nprint(m % (1 << n))"}
{"solution": "def correct_word(word):\n    vowels = set('aeiouy')\n    stack = []\n    \n    for char in word:\n        if char in vowels and stack and stack[-1] in vowels:\n            stack.pop()\n        else:\n            stack.append(char)\n    \n    return ''.join(stack)\n\nn = int(input())\nword = input()\n\nprint(correct_word(word))"}
{"solution": "def max_students(n, a, b, seats):\n    segments = []\n    i = 0\n    \n    # Identify segments of empty seats\n    while i < n:\n        if seats[i] == '.':\n            start = i\n            while i < n and seats[i] == '.':\n                i += 1\n            segments.append(i - start)\n        else:\n            i += 1\n    \n    total_students = 0\n    \n    # Place students in each segment\n    for length in segments:\n        # Calculate the number of students that can be placed in this segment\n        # We will place students in an alternating fashion\n        if a > b:\n            # Start with a student-programmer if more student-programmers are available\n            programmers = (length + 1) // 2\n            athletes = length // 2\n        else:\n            # Start with a student-athlete if more student-athletes are available\n            athletes = (length + 1) // 2\n            programmers = length // 2\n        \n        # Place the students\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n        \n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n    \n    return total_students\n\nn, a, b = map(int, input().split())\nseats = input()\nprint(max_students(n, a, b, seats))"}
{"solution": "import math\n\ndef find_xy(r):\n    for x in range(1, int(math.sqrt(r)) + 1):\n        discriminant = 4 * (r - x**2 - x - 1)\n        if discriminant >= 0:\n            y = (2 * x + 1 + math.sqrt(discriminant)) / 2\n            if y == int(y) and y > 0:\n                return x, int(y)\n    return None\n\nr = int(input())\nresult = find_xy(r)\nif result is None:\n    print(\"NO\")\nelse:\n    print(*result)"}
{"solution": "def divide_packets(n, packets):\n    total_balloons = sum(packets)\n    if n == 1 or total_balloons % 2 == 0 and len(set(packets)) == 1:\n        return -1\n\n    grigory_packets = []\n    andrew_packets = []\n    packets.sort(reverse=True)\n\n    for i, packet in enumerate(packets):\n        if sum(grigory_packets) <= sum(andrew_packets):\n            grigory_packets.append(packet)\n        else:\n            andrew_packets.append(packet)\n\n    if sum(grigory_packets) == sum(andrew_packets):\n        if len(grigory_packets) > 1:\n            andrew_packets.append(grigory_packets.pop())\n        elif len(andrew_packets) > 1:\n            grigory_packets.append(andrew_packets.pop())\n        else:\n            return -1\n\n    grigory_indices = [i + 1 for i, packet in enumerate(packets) if packet in grigory_packets]\n    return len(grigory_indices), grigory_indices\n\n\nn = int(input())\npackets = list(map(int, input().split()))\n\nresult = divide_packets(n, packets)\nif result == -1:\n    print(-1)\nelse:\n    print(result[0])\n    print(*result[1])"}
{"solution": "def min_diverse_digits(n):\n    if n < 10:\n        return [n]\n\n    for i in range(9, 0, -1):\n        if n % i == 0:\n            return [i] * (n // i)\n\n    for i in range(9, 0, -1):\n        if n > i and n % i!= 0:\n            return [i] + min_diverse_digits(n - i)\n\n\nn = int(input())\nresult = min_diverse_digits(n)\nprint(len(result))\nprint(*result)"}
{"solution": "def sieve_of_eratosthenes(n):\n    \"\"\"Generate all prime numbers up to n.\"\"\"\n    sieve = [True] * (n + 1)\n    sieve[0:2] = [False, False]  # 0 and 1 are not prime numbers\n    for current_prime in range(2, int(n**0.5) + 1):\n        if sieve[current_prime]:\n            for multiple in range(current_prime*2, n + 1, current_prime):\n                sieve[multiple] = False\n    return [num for num, is_prime in enumerate(sieve) if is_prime]\n\n\ndef find_simple_subset(arr):\n    \"\"\"Find a simple subset of the array with the maximum size.\"\"\"\n    primes = set(sieve_of_eratosthenes(2 * 10**6))\n    count = {}\n    for num in arr:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n\n    # Sort the array by frequency and value\n    sorted_arr = sorted(count.items(), key=lambda x: (x[1], x[0]), reverse=True)\n\n    simple_subset = []\n    for num, freq in sorted_arr:\n        if freq > 0:\n            if not simple_subset:\n                simple_subset.extend([num] * freq)\n            else:\n                for _ in range(freq):\n                    if all(num + other in primes for other in simple_subset):\n                        simple_subset.append(num)\n                    else:\n                        break\n\n    return simple_subset\n\n\ndef main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    simple_subset = find_simple_subset(arr)\n    print(len(simple_subset))\n    print(*simple_subset)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef is_beautiful(n):\n    \"\"\"Check if a number is beautiful.\"\"\"\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    # Check if the binary representation consists of k + 1 consecutive ones and then k consecutive zeroes\n    for k in range(1, len(binary) // 2 + 1):\n        pattern = '1' * (k + 1) + '0' * k\n        if binary == pattern:\n            return True\n    return False\n\ndef greatest_beautiful_divisor(n):\n    \"\"\"Find the greatest beautiful divisor of a number.\"\"\"\n    # Start from the square root of the number and go down to 1\n    for i in range(math.isqrt(n), 0, -1):\n        # Check if the current number is a divisor of n\n        if n % i == 0:\n            # Check if the divisor is beautiful\n            if is_beautiful(i):\n                return i\n    return 1\n\n# Read the input number\nn = int(input())\n\n# Find and print the greatest beautiful divisor\nprint(greatest_beautiful_divisor(n))"}
{"solution": "def count_magic_numbers(m, d, a, b):\n    MOD = 10**9 + 7\n    n = len(a)\n    dp = [[0] * m for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(m):\n            for k in range(10):\n                if (i - 1) % 2 == 0 and k!= d:\n                    dp[i][(j + k * (10**(n - i))) % m] += dp[i - 1][j]\n                    dp[i][(j + k * (10**(n - i))) % m] %= MOD\n                elif (i - 1) % 2 == 1 and k == d:\n                    dp[i][(j + k * (10**(n - i))) % m] += dp[i - 1][j]\n                    dp[i][(j + k * (10**(n - i))) % m] %= MOD\n\n    def get_value(x):\n        res = 0\n        for i in range(len(x)):\n            res += int(x[i]) * (10**(len(x) - i - 1))\n        return res\n\n    a_value = get_value(a)\n    b_value = get_value(b)\n\n    res = 0\n    for i in range(m):\n        if (b_value - i) % m == 0:\n            res += dp[n][i]\n        if (a_value - i) % m == 0:\n            res -= dp[n][i]\n    res %= MOD\n    if res < 0:\n        res += MOD\n    return res\n\nm, d = map(int, input().split())\na = input()\nb = input()\nprint(count_magic_numbers(m, d, a, b))"}
{"solution": "from collections import deque\n\ndef last_child(n, m, candies):\n    queue = deque(range(1, n + 1))\n    index = 0\n    while queue:\n        child = queue.popleft()\n        candies[index] -= m\n        if candies[index] > 0:\n            queue.append(child)\n        index = (index + 1) % n\n    return child\n\nn, m = map(int, input().split())\ncandies = list(map(int, input().split()))\nprint(last_child(n, m, candies))"}
{"solution": "def min_bills(n):\n    denominations = [100, 20, 10, 5, 1]\n    bills = 0\n\n    for denomination in denominations:\n        bills += n // denomination\n        n %= denomination\n\n    return bills\n\nn = int(input())\nprint(min_bills(n))"}
{"solution": "MOD = 1000000007\n\ndef count_permutations(n, k):\n    if k > n or (n - k) % 2!= 0:\n        return 0\n\n    dp = [[[0 for _ in range(k + 1)] for _ in range(n + 1)] for _ in range(2)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(min(i, k) + 1):\n            dp[i % 2][i][j] = dp[(i - 1) % 2][i - 1][j]\n            if j > 0:\n                dp[i % 2][i][j] += dp[(i - 1) % 2][i - 1][j - 1]\n            if j > 0 and i > 1:\n                dp[i % 2][i][j] += dp[(i - 1) % 2][i - 2][j - 1]\n            dp[i % 2][i][j] %= MOD\n\n    return dp[n % 2][n][k]\n\nn, k = map(int, input().split())\nprint(count_permutations(n, k))"}
{"solution": "import sys\n\ndef max_beauty(n, k, beauty, colors):\n    roses = {'R': [], 'O': [], 'W': []}\n    for i in range(n):\n        roses[colors[i]].append(beauty[i])\n\n    for color in roses:\n        roses[color].sort(reverse=True)\n\n    max_total_beauty = -1\n    for color1 in roses:\n        for color2 in roses:\n            if color1 == color2:\n                continue\n            if len(roses[color1]) + len(roses[color2]) < k:\n                continue\n            if color1 == 'R' and color2 == 'W':\n                continue\n            if color1 == 'W' and color2 == 'R':\n                continue\n\n            total_beauty = 0\n            roses1 = roses[color1]\n            roses2 = roses[color2]\n            i = 0\n            j = 0\n            while i < len(roses1) and j < len(roses2) and i + j < k:\n                if roses1[i] >= roses2[j]:\n                    total_beauty += roses1[i]\n                    i += 1\n                else:\n                    total_beauty += roses2[j]\n                    j += 1\n            while i + j < k:\n                if i < len(roses1):\n                    total_beauty += roses1[i]\n                    i += 1\n                else:\n                    total_beauty += roses2[j]\n                    j += 1\n            max_total_beauty = max(max_total_beauty, total_beauty)\n\n    return max_total_beauty\n\nn, k = map(int, sys.stdin.readline().split())\nbeauty = list(map(int, sys.stdin.readline().split()))\ncolors = sys.stdin.readline().strip()\n\nprint(max_beauty(n, k, beauty, colors))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef simplify_fraction(numerator, denominator):\n    common_divisor = gcd(numerator, denominator)\n    return numerator // common_divisor, denominator // common_divisor\n\ndef evaluate_continued_fraction(coefficients):\n    numerator, denominator = coefficients[-1], 1\n    for coefficient in reversed(coefficients[:-1]):\n        numerator, denominator = coefficient * numerator + denominator, numerator\n    return numerator, denominator\n\ndef main():\n    p, q = map(int, input().split())\n    n = int(input())\n    coefficients = list(map(int, input().split()))\n\n    p, q = simplify_fraction(p, q)\n    cf_numerator, cf_denominator = evaluate_continued_fraction(coefficients)\n    cf_numerator, cf_denominator = simplify_fraction(cf_numerator, cf_denominator)\n\n    print(\"YES\" if (p, q) == (cf_numerator, cf_denominator) else \"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_sticks(expression):\n    sticks = expression.replace('+','').replace('=','').split()\n    return [len(stick) for stick in sticks]\n\ndef is_correct(expression):\n    sticks = count_sticks(expression)\n    return sticks[0] + sticks[1] == sticks[2]\n\ndef shift_stick(expression, from_index, to_index):\n    sticks = expression.replace('+','').replace('=','').split()\n    stick = sticks[from_index][-1]\n    sticks[from_index] = sticks[from_index][:-1]\n    sticks[to_index] += stick\n    return ''.join(sticks).replace(' ', '+').replace('=', '=')\n\ndef solve(expression):\n    if is_correct(expression):\n        return expression\n\n    for i in range(3):\n        for j in range(3):\n            if i!= j:\n                new_expression = shift_stick(expression, i, j)\n                if is_correct(new_expression):\n                    return new_expression\n\n    return \"Impossible\"\n\nexpression = input()\nprint(solve(expression))"}
{"solution": "MOD = 10**9 + 7\n\ndef main():\n    n, k = map(int, input().split())\n    dp = [[[0] * (n * n + 1) for _ in range(n + 1)] for _ in range(2)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            for odd in range(i * i + 1):\n                if odd - i >= 0:\n                    dp[i % 2][j][odd] = (dp[i % 2][j][odd] + dp[(i - 1) % 2][j][odd - i]) % MOD\n                if j - 1 >= 0 and odd - i + 1 >= 0:\n                    dp[i % 2][j][odd] = (dp[i % 2][j][odd] + dp[(i - 1) % 2][j - 1][odd - i + 1]) % MOD\n                if j + 1 <= i and odd - i - 1 >= 0:\n                    dp[i % 2][j][odd] = (dp[i % 2][j][odd] + dp[(i - 1) % 2][j + 1][odd - i - 1]) % MOD\n\n    print(dp[n % 2][0][k])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": ""}
{"solution": "import re\n\nn = int(input())\ns = input()\n\npattern = r'ogo(go)*'\ns = re.sub(pattern, '***', s)\n\nprint(s)"}
{"solution": "def prime_factors(n):\n    \"\"\"Returns a dictionary of prime factors and their powers\"\"\"\n    factors = {}\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors[i] = factors.get(i, 0) + 1\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef g(y, p):\n    \"\"\"Returns the maximum possible integer p^k where k is an integer such that y is divisible by p^k\"\"\"\n    k = 0\n    while y % p == 0:\n        y //= p\n        k += 1\n    return p ** k\n\ndef f(x, y):\n    \"\"\"Returns the product of g(y, p) for all p in prime(x)\"\"\"\n    factors = prime_factors(x)\n    result = 1\n    for p in factors:\n        result = (result * g(y, p)) % (10**9 + 7)\n    return result\n\ndef main():\n    x, n = map(int, input().split())\n    factors = prime_factors(x)\n    result = 1\n    for p in factors:\n        k = factors[p]\n        sum_p_k = (p ** k * (n // p ** k) + (p ** (k - 1) * (n // p ** (k - 1)) - (p ** k * (n // p ** k))) % (10**9 + 7)\n        result = (result * sum_p_k) % (10**9 + 7)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = set()\n    for s in range(1, 82):  # s(x) can be at most 81\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and sum_of_digits(x) == s:\n            solutions.add(x)\n    return sorted(list(solutions))\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find solutions\nsolutions = find_solutions(a, b, c)\n\n# Print results\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "def is_solved(face):\n    return len(set(face)) == 1\n\ndef is_possible_to_solve(cube):\n    for i in range(0, 24, 4):\n        face = cube[i:i+4]\n        if is_solved(face):\n            return True\n\n    for i in range(4):\n        face = [cube[i], cube[i+4], cube[i+8], cube[i+12]]\n        if is_solved(face):\n            return True\n\n    for i in range(4):\n        face = [cube[i], cube[i+4], cube[i+8], cube[i+12]]\n        face = [face[0], face[3], face[2], face[1]]\n        if is_solved(face):\n            return True\n\n    for i in range(4):\n        face = [cube[i], cube[i+4], cube[i+8], cube[i+12]]\n        face = [face[0], face[2], face[3], face[1]]\n        if is_solved(face):\n            return True\n\n    return False\n\ncube = list(map(int, input().split()))\nif is_possible_to_solve(cube):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def get_score(s):\n    i = (s // 50) % 475\n    scores = []\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        scores.append(26 + i)\n    return scores\n\ndef solve():\n    p, x, y = map(int, input().split())\n    min_hacks = float('inf')\n    for s in range(x, y + 1):\n        scores = get_score(s)\n        if p in scores:\n            hacks = (s - x + 99) // 100\n            min_hacks = min(min_hacks, hacks)\n    print(min_hacks)\n\nsolve()"}
{"solution": "def min_distance(n, a, b, c):\n    if n == 1:\n        return 0\n    elif n == 2:\n        return min(a, b, c)\n    else:\n        return min(a + c, b + c, a + b) + (n - 2) * min(a, b, c)\n\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nprint(min_distance(n, a, b, c))"}
{"solution": "def min_distance(x1, x2, x3):\n    \"\"\"\n    Calculate the minimum total distance three friends need to travel to meet at a point.\n\n    Args:\n        x1 (int): The coordinate of the first friend's house.\n        x2 (int): The coordinate of the second friend's house.\n        x3 (int): The coordinate of the third friend's house.\n\n    Returns:\n        int: The minimum total distance the friends need to travel.\n    \"\"\"\n    # Sort the coordinates in ascending order\n    coordinates = sorted([x1, x2, x3])\n\n    # The optimal meeting point is the middle coordinate\n    meeting_point = coordinates[1]\n\n    # Calculate the total distance\n    total_distance = abs(x1 - meeting_point) + abs(x2 - meeting_point) + abs(x3 - meeting_point)\n\n    return total_distance\n\n\n# Read the input coordinates\nx1, x2, x3 = map(int, input().split())\n\n# Calculate and print the minimum total distance\nprint(min_distance(x1, x2, x3))"}
{"solution": "def solve(n, x, a):\n    seen = set()\n    for i in range(n):\n        if a[i] & x in seen:\n            return 0\n        seen.add(a[i] & x)\n\n    if len(seen) < n:\n        return 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] & x) == (a[j] & x):\n                return 1\n\n    return -1\n\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\nprint(solve(n, x, a))"}
{"solution": "def check_plus(grid, center):\n    h, w = len(grid), len(grid[0])\n    cx, cy = center\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for dx, dy in directions:\n        x, y = cx + dx, cy + dy\n        while 0 <= x < h and 0 <= y < w and grid[x][y] == '*':\n            x += dx\n            y += dy\n        if (x, y)!= (cx + dx, cy + dy):\n            return False\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*' and (i, j) not in [(cx + dx, cy + dy) for dx, dy in directions]:\n                return False\n    return True\n\n\ndef solve():\n    h, w = map(int, input().split())\n    grid = [list(input()) for _ in range(h)]\n    centers = [(i, j) for i in range(h) for j in range(w) if grid[i][j] == '*']\n    for center in centers:\n        if check_plus(grid, center):\n            return 'YES'\n    return 'NO'\n\n\nprint(solve())"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, a, b = read_ints()\n\n    if a == 1 and b == 1:\n        print(\"NO\")\n        return\n\n    if a == 1:\n        b -= 1\n    else:\n        a -= 1\n\n    if b > a + 1 or b < a:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n\n    matrix = [[\"0\"] * n for _ in range(n)]\n\n    for i in range(a):\n        for j in range(i + 1, a + 1):\n            matrix[i][j] = matrix[j][i] = \"1\"\n\n    if b > a:\n        for i in range(a, a + b - a):\n            for j in range(i + 1, n):\n                matrix[i][j] = matrix[j][i] = \"1\"\n\n    for row in matrix:\n        print(\"\".join(row))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_problems(c, d, n, m, k):\n    \"\"\"\n    Calculate the minimum number of problems needed for the finals.\n\n    Args:\n    c (int): Number of problems in the main elimination rounds.\n    d (int): Number of problems in the additional elimination rounds.\n    n (int): Number of winners in each main elimination round.\n    m (int): Number of main elimination rounds.\n    k (int): Number of pre-chosen winners.\n\n    Returns:\n    int: The minimum number of problems needed for the finals.\n    \"\"\"\n    total_winners_needed = n * m - k\n    if total_winners_needed <= 0:\n        return 0\n\n    main_rounds = total_winners_needed // n\n    additional_winners_needed = total_winners_needed % n\n\n    main_problems = main_rounds * c\n    additional_problems = additional_winners_needed * d\n\n    # If the number of additional problems is more than the number of problems in a main round,\n    # it's better to have another main round\n    if additional_problems > c:\n        main_problems += c\n    else:\n        main_problems += additional_problems\n\n    return main_problems\n\n\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\nprint(min_problems(c, d, n, m, k))"}
{"solution": "from collections import defaultdict\n\ndef find_grid(s):\n    graph = defaultdict(list)\n    for i in range(26):\n        for j in range(i + 1, 26):\n            if abs(i - j) == 1 or abs(i - j) == 13:\n                graph[chr(65 + i)].append(chr(65 + j))\n                graph[chr(65 + j)].append(chr(65 + i))\n\n    def dfs(node, path):\n        if len(path) == 27:\n            return path\n        for neighbor in graph[node]:\n            if neighbor not in path:\n                new_path = dfs(neighbor, path + neighbor)\n                if new_path:\n                    return new_path\n        return None\n\n    for i in range(26):\n        path = dfs(chr(65 + i), chr(65 + i))\n        if path and path == s:\n            grid = [''] * 2\n            for j in range(26):\n                if j < 13:\n                    grid[0] += path[j]\n                else:\n                    grid[1] += path[j]\n            return grid\n\n    return None\n\ns = input()\ngrid = find_grid(s)\nif grid:\n    print(grid[0])\n    print(grid[1])\nelse:\n    print(\"Impossible\")"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<' if y > 1 else '='\n    elif y == 1:\n        return '>' if x > 1 else '='\n    else:\n        # Compute y * log(x) and x * log(y)\n        lhs = y * math.log(x)\n        rhs = x * math.log(y)\n        \n        if lhs < rhs:\n            return '<'\n        elif lhs > rhs:\n            return '>'\n        else:\n            return '='\n\n# Read input\nx, y = map(int, input().split())\n\n# Output the result of the comparison\nprint(compare_powers(x, y))"}
{"solution": "import math\n\ndef calculate_max_balloons():\n    r, h = map(int, input().split())\n    max_balloons_in_height = math.floor((h + r) / r)\n    max_balloons_in_width = math.floor((2 * r) / r)\n    max_balloons_in_arc = math.floor(math.pi * r / (2 * (r / 2)))\n    max_balloons = max_balloons_in_height * max_balloons_in_width + max_balloons_in_arc\n    return max_balloons\n\nprint(calculate_max_balloons())"}
{"solution": "import sys\n\n# Read input from stdin\nnumbers = list(map(int, sys.stdin.readline().split()))\n\n# Sort the numbers in ascending order\nnumbers.sort()\n\n# Initialize minimum sum\nmin_sum = sum(numbers)\n\n# Check if we can discard two or three cards with the same number\nif numbers[0] == numbers[1] == numbers[2]:\n    min_sum = min(min_sum, sum(numbers[3:]))\nelif numbers[0] == numbers[1]:\n    min_sum = min(min_sum, sum(numbers[2:]))\nelif numbers[1] == numbers[2] == numbers[3]:\n    min_sum = min(min_sum, sum(numbers[:1]) + sum(numbers[4:]))\nelif numbers[2] == numbers[3] == numbers[4]:\n    min_sum = min(min_sum, sum(numbers[:2]))\n\n# Print the minimum sum\nprint(min_sum)"}
{"solution": "import sys\n\ndef min_distance(n, a, checkpoints):\n    checkpoints.sort()\n    left, right = 0, n - 1\n    while left < n and checkpoints[left] <= a:\n        left += 1\n    while right >= 0 and checkpoints[right] >= a:\n        right -= 1\n\n    if left == 0:\n        return sum(abs(checkpoints[i] - checkpoints[i - 1]) for i in range(1, n))\n    elif right == n - 1:\n        return sum(abs(checkpoints[i] - checkpoints[i + 1]) for i in range(n - 1))\n    else:\n        left_distance = sum(abs(checkpoints[i] - checkpoints[i - 1]) for i in range(1, left + 1)) + abs(a - checkpoints[left])\n        right_distance = sum(abs(checkpoints[i] - checkpoints[i + 1]) for i in range(right, n - 1)) + abs(a - checkpoints[right])\n        return min(left_distance, right_distance)\n\nn, a = map(int, sys.stdin.readline().split())\ncheckpoints = list(map(int, sys.stdin.readline().split()))\n\nprint(min_distance(n, a, checkpoints))"}
{"solution": "def sum_of_digits(x):\n    \"\"\"Calculate the sum of digits of a number.\"\"\"\n    return sum(int(digit) for digit in str(x))\n\ndef solve_equation(n):\n    \"\"\"Find the smallest positive integer root of the equation x^2 + s(x)*x - n = 0.\"\"\"\n    x = 1\n    while True:\n        s_x = sum_of_digits(x)\n        if x**2 + s_x*x - n == 0:\n            return x\n        elif x**2 + s_x*x > n:\n            return -1\n        x += 1\n\nn = int(input())\nprint(solve_equation(n))"}
{"solution": "def calculate_bed_time(current_time, sleep_time):\n    current_hours, current_minutes = map(int, current_time.split(':'))\n    sleep_hours, sleep_minutes = map(int, sleep_time.split(':'))\n\n    total_minutes = current_hours * 60 + current_minutes - (sleep_hours * 60 + sleep_minutes)\n    if total_minutes < 0:\n        total_minutes += 24 * 60\n\n    bed_hours = total_minutes // 60 % 24\n    bed_minutes = total_minutes % 60\n\n    return f\"{bed_hours:02d}:{bed_minutes:02d}\"\n\ncurrent_time = input()\nsleep_time = input()\n\nprint(calculate_bed_time(current_time, sleep_time))"}
{"solution": "def max_subsegment_length(n, a):\n    max_sum = float('-inf')\n    current_sum = 0\n    max_length = 0\n    current_length = 0\n\n    for num in a:\n        if current_sum <= 0:\n            current_sum = num\n            current_length = 1\n        else:\n            current_sum += num\n            current_length += 1\n\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_length = current_length\n        elif current_sum == max_sum:\n            max_length = max(max_length, current_length)\n\n    return max_length\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nprint(max_subsegment_length(n, a))"}
{"solution": "MOD = 998244353\n\ndef main():\n    n, m, k = map(int, input().split())\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[1][0] = m\n\n    for i in range(2, n + 1):\n        for j in range(min(i, k) + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] * (m - 1) % MOD\n            else:\n                dp[i][j] = (dp[i - 1][j - 1] * (m - 1) + dp[i - 1][j]) % MOD\n\n    ans = 0\n    for i in range(k + 1):\n        ans = (ans + dp[n][i]) % MOD\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import re\n\ndef is_magic_number(n):\n    pattern = re.compile(r'^(1|14|144)+$')\n    if pattern.match(str(n)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\nn = int(input())\nprint(is_magic_number(n))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef min_moves(n, m, i, j, a, b):\n    moves = float('inf')\n    for x, y in [(1, m), (n, 1), (n, m), (1, 1)]:\n        dx, dy = abs(x - i), abs(y - j)\n        if dx % a!= 0 or dy % b!= 0:\n            continue\n        moves = min(moves, dx // a + dy // b)\n    return moves if moves!= float('inf') else -1\n\ndef main():\n    n, m, i, j, a, b = map(int, input().split())\n    moves = min_moves(n, m, i, j, a, b)\n    if moves == -1:\n        print(\"Poor Inna and pony!\")\n    else:\n        print(moves)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_removals(n, s):\n    dp = [[0] * 26 for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(26):\n            if ord(s[i - 1]) - ord('a') == j:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + 1)\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return max(dp[n])\n\nn = int(input())\ns = input()\nprint(max_removals(n, s))"}
{"solution": "def min_bills(n, k, denominations, q, requests):\n    results = []\n    for request in requests:\n        min_bills = float('inf')\n        for i in range(n):\n            for j in range(i, n):\n                bills = 0\n                remaining = request\n                while remaining > 0 and bills <= k:\n                    if remaining >= denominations[j]:\n                        remaining -= denominations[j]\n                        bills += 1\n                    elif remaining >= denominations[i]:\n                        remaining -= denominations[i]\n                        bills += 1\n                    else:\n                        break\n                if remaining == 0 and bills < min_bills:\n                    min_bills = bills\n        if min_bills == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_bills)\n    return results\n\n\nn, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\nrequests = [int(input()) for _ in range(q)]\n\nresults = min_bills(n, k, denominations, q, requests)\nfor result in results:\n    print(result)"}
{"solution": "import math\n\ndef calculate_time(s, x1, x2, t1, t2, p, d):\n    # Calculate the time it takes for Igor to walk from x1 to x2\n    walk_time = abs(x2 - x1) * t2\n\n    # Calculate the time it takes for the tram to reach x1\n    tram_time_to_x1 = abs(p - x1) * t1\n\n    # Calculate the time it takes for the tram to reach x2 after reaching x1\n    tram_time_to_x2 = abs(x2 - x1) * t1\n\n    # Calculate the total time it takes for Igor to take the tram\n    tram_time = tram_time_to_x1 + tram_time_to_x2\n\n    # Calculate the time it takes for Igor to take the tram and walk\n    tram_walk_time = tram_time_to_x1 + (abs(x2 - p) * t2)\n\n    # Calculate the minimum time\n    min_time = min(walk_time, tram_time, tram_walk_time)\n\n    # If the tram is moving towards x2, calculate the time it takes for Igor to take the tram\n    if (x1 < x2 and d == 1) or (x1 > x2 and d == -1):\n        tram_time = tram_time_to_x1 + (abs(x2 - p) * t1)\n        min_time = min(min_time, tram_time)\n\n    return min_time\n\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\nprint(calculate_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "import math\n\ndef count_cells(n, x):\n    count = 0\n    for i in range(1, min(n, int(math.sqrt(x))) + 1):\n        if x % i == 0:\n            j = x // i\n            if j <= n:\n                count += 1\n            if j!= i and i <= n:\n                count += 1\n    return count\n\nn, x = map(int, input().split())\nprint(count_cells(n, x))"}
{"solution": "import string\n\nn, k = map(int, input().split())\npassword = string.ascii_lowercase[:k]\n\nif n <= k:\n    print(password[:n])\nelse:\n    repeated_password = password * (n // k)\n    remaining_chars = password[:n % k]\n    print(repeated_password + remaining_chars)"}
{"solution": "n = int(input())\ndirections = input()\npositions = list(map(int, input().split()))\n\nmin_time = float('inf')\ncollision_found = False\n\nfor i in range(n - 1):\n    if directions[i] == 'R' and directions[i + 1] == 'L':\n        collision_time = (positions[i + 1] - positions[i]) // 2\n        min_time = min(min_time, collision_time)\n        collision_found = True\n\nif collision_found:\n    print(min_time)\nelse:\n    print(-1)"}
{"solution": "def max_area(seals, paper):\n    max_area = 0\n    for i in range(len(seals)):\n        for j in range(i + 1, len(seals)):\n            seal1 = seals[i]\n            seal2 = seals[j]\n            # Check if both seals can fit in the paper without rotating\n            if seal1[0] <= paper[0] and seal1[1] <= paper[1] and seal2[0] <= paper[0] and seal2[1] <= paper[1]:\n                area = seal1[0] * seal1[1] + seal2[0] * seal2[1]\n                max_area = max(max_area, area)\n            # Check if both seals can fit in the paper with one seal rotated\n            if seal1[0] <= paper[0] and seal1[1] <= paper[1] and seal2[1] <= paper[0] and seal2[0] <= paper[1]:\n                area = seal1[0] * seal1[1] + seal2[1] * seal2[0]\n                max_area = max(max_area, area)\n            if seal1[1] <= paper[0] and seal1[0] <= paper[1] and seal2[0] <= paper[0] and seal2[1] <= paper[1]:\n                area = seal1[1] * seal1[0] + seal2[0] * seal2[1]\n                max_area = max(max_area, area)\n            if seal1[1] <= paper[0] and seal1[0] <= paper[1] and seal2[1] <= paper[0] and seal2[0] <= paper[1]:\n                area = seal1[1] * seal1[0] + seal2[1] * seal2[0]\n                max_area = max(max_area, area)\n    return max_area\n\nn, a, b = map(int, input().split())\nseals = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    seals.append((x, y))\n\nprint(max_area(seals, (a, b)))"}
{"solution": "def find_point():\n    n = int(input())\n    points = [list(map(int, input().split())) for _ in range(4*n + 1)]\n\n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n\n    x_min, x_max = min(x_coords), max(x_coords)\n    y_min, y_max = min(y_coords), max(y_coords)\n\n    for point in points:\n        if x_min < point[0] < x_max and y_min < point[1] < y_max:\n            return point\n\n    return None\n\npoint = find_point()\nprint(*point)"}
{"solution": "def max_digit_product(n):\n    max_product = 1\n    for i in range(1, n + 1):\n        product = 1\n        for digit in str(i):\n            product *= int(digit)\n        max_product = max(max_product, product)\n    return max_product\n\ndef max_digit_product_optimized(n):\n    max_product = 1\n    digits = [int(d) for d in str(n)]\n    digits.sort(reverse=True)\n    for digit in digits:\n        if digit > 1:\n            max_product *= digit\n        else:\n            break\n    return max_product\n\ndef max_digit_product_further_optimized(n):\n    max_product = 1\n    n_str = str(n)\n    n_len = len(n_str)\n    if n_len > 3:\n        max_product = 9 ** (n_len - 3)\n        max_product *= int(n_str[-3:]) // 10\n    else:\n        max_product = max(int(d) for d in n_str)\n    return max_product\n\nn = int(input())\nprint(max_digit_product_further_optimized(n))"}
{"solution": "def smallest_winning_k(n, votes):\n    \"\"\"\n    Calculate the smallest k that guarantees Awruk's win.\n\n    Args:\n    n (int): The number of students in the school.\n    votes (list): A list of votes each student gives to Elodreip.\n\n    Returns:\n    int: The smallest k that guarantees Awruk's win.\n    \"\"\"\n    # Calculate the total votes for Elodreip\n    elodreip_votes = sum(votes)\n    \n    # Initialize k as the maximum vote\n    k = max(votes)\n    \n    # Calculate Awruk's votes for the current k\n    awruk_votes = sum(k - vote for vote in votes)\n    \n    # While Awruk's votes are not more than Elodreip's votes, increment k\n    while awruk_votes <= elodreip_votes:\n        k += 1\n        awruk_votes = sum(k - vote for vote in votes)\n    \n    return k\n\n# Read the number of students\nn = int(input())\n\n# Read the votes for Elodreip\nvotes = list(map(int, input().split()))\n\n# Calculate and print the smallest winning k\nprint(smallest_winning_k(n, votes))"}
{"solution": "def min_operations(s):\n    stack = []\n    operations = 0\n\n    for color in s:\n        if stack and stack[-1][0]!= color:\n            while stack and stack[-1][0]!= color:\n                stack.pop()\n            if stack:\n                stack[-1][1] += 1\n        else:\n            stack.append([color, 1])\n\n    while stack:\n        if stack[-1][1] > 1:\n            stack[-1][1] -= 1\n        else:\n            stack.pop()\n        if stack and stack[-1][1] > 1:\n            operations += 1\n            while stack and stack[-1][1] > 1:\n                stack.pop()\n        else:\n            break\n\n    return operations\n\n\ns = input()\nprint(min_operations(s))"}
{"solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n\n    min_product = a[0] * a[1] * a[2]\n    min_product_count = 1\n\n    for i in range(3, n):\n        if a[0] * a[1] * a[i] < min_product:\n            min_product = a[0] * a[1] * a[i]\n            min_product_count = 1\n        elif a[0] * a[1] * a[i] == min_product:\n            min_product_count += 1\n\n    if a[0] == a[1] == a[2]:\n        print((n - 2) * (n - 1) * n // 6)\n    elif a[0] == a[1]:\n        print(min_product_count * (n - 2))\n    else:\n        print(min_product_count)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef min_cuts(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 2\n    elif n == 4:\n        return 5\n    else:\n        return math.ceil(math.sqrt(n + 1))\n\nn = int(input())\nprint(min_cuts(n))"}
{"solution": "def maximize_balance(n):\n    n_str = str(n)\n    if n_str[0] == '-':\n        n_str = n_str[1:]\n        if len(n_str) > 1:\n            return -int(n_str[:-1]) if int(n_str[-1]) > int(n_str[-2]) else -int(n_str[:-2] + n_str[-1])\n        else:\n            return 0\n    else:\n        if len(n_str) > 1:\n            return int(n_str[:-1]) if int(n_str[-1]) < int(n_str[-2]) else int(n_str[:-2] + n_str[-1])\n        else:\n            return n\n\nn = int(input())\nprint(maximize_balance(n))"}
{"solution": "def spinner_direction(start, end, n):\n    positions = ['v', '<', '^', '>']\n    start_index = positions.index(start)\n    end_index = positions.index(end)\n    \n    clockwise_diff = (end_index - start_index) % 4\n    counter_clockwise_diff = (start_index - end_index) % 4\n    \n    if n % 4 == clockwise_diff:\n        return 'cw'\n    elif n % 4 == counter_clockwise_diff:\n        return 'ccw'\n    else:\n        return 'undefined'\n\nstart, end = input().split()\nn = int(input())\nprint(spinner_direction(start, end, n))"}
{"solution": "def count_vertical_dominoes(n, s):\n    \"\"\"\n    Count the number of dominoes left standing vertically at the end of the process.\n\n    Args:\n    n (int): The number of dominoes in the line.\n    s (str): A character string representing the initial directions of the dominoes.\n\n    Returns:\n    int: The number of dominoes left standing vertically.\n    \"\"\"\n    count = 0\n    i = 0\n    while i < n:\n        if s[i] == '.':\n            # Count the number of consecutive '.' characters\n            j = i + 1\n            while j < n and s[j] == '.':\n                j += 1\n            # If the sequence of '.' characters is between two 'L' or two 'R' characters,\n            # or if it's at the beginning or end of the string, count all the '.' characters\n            if (i == 0 or s[i - 1] == s[j] if j < n else True) or (j == n or s[i - 1] == s[j]):\n                count += j - i\n            # If the sequence of '.' characters is between an 'L' and an 'R' character,\n            # count the middle '.' characters\n            else:\n                count += (j - i - 1) // 2 + 1\n            i = j\n        else:\n            i += 1\n    return count\n\nn = int(input())\ns = input()\nprint(count_vertical_dominoes(n, s))"}
{"solution": "def restore_permutation(n, leaders):\n    permutation = [0] * n\n    for i in range(n):\n        permutation[i] = i + 1\n\n    for i in range(len(leaders) - 1):\n        leader_index = leaders[i] - 1\n        next_leader_index = leaders[i + 1] - 1\n        diff = (next_leader_index - leader_index) % n\n        if diff == 0:\n            diff = n\n        permutation[leader_index] = diff\n\n    if leaders[-1]!= 1 and permutation[leaders[-1] - 1] == n:\n        return -1\n\n    return permutation\n\n\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\nresult = restore_permutation(n, leaders)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def max_number(a, k):\n    a = list(str(a))\n    n = len(a)\n    max_a = a[:]\n    for i in range(n):\n        for j in range(i + 1, min(i + k + 1, n)):\n            if a[j] > a[i]:\n                a[i], a[j] = a[j], a[i]\n                k -= j - i\n                if a > max_a:\n                    max_a = a[:]\n                a[i], a[j] = a[j], a[i]\n    return ''.join(max_a)\n\na, k = input().split()\na, k = int(a), int(k)\nprint(max_number(a, k))"}
{"solution": "def is_arithmetic_progression(sequence):\n    \"\"\"Check if a sequence is an arithmetic progression.\"\"\"\n    diff = sequence[1] - sequence[0]\n    for i in range(2, len(sequence)):\n        if sequence[i] - sequence[i-1]!= diff:\n            return False\n    return True\n\n\ndef is_geometric_progression(sequence):\n    \"\"\"Check if a sequence is a geometric progression.\"\"\"\n    ratio = sequence[1] / sequence[0]\n    for i in range(2, len(sequence)):\n        if sequence[i] / sequence[i-1]!= ratio:\n            return False\n    return True\n\n\ndef next_arithmetic_progression(sequence):\n    \"\"\"Find the next element in an arithmetic progression.\"\"\"\n    diff = sequence[1] - sequence[0]\n    return sequence[-1] + diff\n\n\ndef next_geometric_progression(sequence):\n    \"\"\"Find the next element in a geometric progression.\"\"\"\n    ratio = sequence[1] / sequence[0]\n    return sequence[-1] * ratio\n\n\ndef main():\n    sequence = list(map(int, input().split()))\n    \n    if is_arithmetic_progression(sequence):\n        next_element = next_arithmetic_progression(sequence)\n        if next_element == int(next_element):\n            print(int(next_element))\n        else:\n            print(42)\n    elif is_geometric_progression(sequence):\n        next_element = next_geometric_progression(sequence)\n        if next_element == int(next_element):\n            print(int(next_element))\n        else:\n            print(42)\n    else:\n        print(42)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_distance(n, colors):\n    # Find the first and last occurrence of each color\n    first_occurrence = {}\n    last_occurrence = {}\n    \n    for i in range(n):\n        color = colors[i]\n        if color not in first_occurrence:\n            first_occurrence[color] = i\n        last_occurrence[color] = i\n    \n    # Get the list of unique colors\n    unique_colors = list(first_occurrence.keys())\n    \n    # Calculate the maximum distance\n    max_dist = 0\n    \n    # Compare distances from the first house to the last house of a different color\n    for color in unique_colors:\n        if colors[0]!= color:\n            max_dist = max(max_dist, last_occurrence[color])\n        if colors[-1]!= color:\n            max_dist = max(max_dist, n - 1 - first_occurrence[color])\n    \n    # Check if the maximum distance can be obtained by walking from the first house of a color to the last house of the same color\n    for color in unique_colors:\n        max_dist = max(max_dist, last_occurrence[color] - first_occurrence[color])\n    \n    return max_dist\n\nn = int(input())\ncolors = list(map(int, input().split()))\nprint(max_distance(n, colors))"}
{"solution": "n, m, k = map(int, input().split())\n\nlane = (k - 1) // (2 * m) + 1\ndesk = ((k - 1) % (2 * m)) // 2 + 1\nside = 'L' if (k - 1) % 2 == 0 else 'R'\n\nprint(lane, desk, side)"}
{"solution": "def possible_final_colors(n, s):\n    color_counts = {'B': 0, 'G': 0, 'R': 0}\n    for color in s:\n        color_counts[color] += 1\n\n    possible_colors = []\n    if color_counts['B'] % 2 == 1:\n        possible_colors.append('B')\n    if color_counts['G'] % 2 == 1:\n        possible_colors.append('G')\n    if color_counts['R'] % 2 == 1:\n        possible_colors.append('R')\n\n    if len(possible_colors) == 0 or len(possible_colors) == 3:\n        return 'BGR'\n    else:\n        return ''.join(sorted(possible_colors))\n\nn = int(input())\ns = input()\nprint(possible_final_colors(n, s))"}
