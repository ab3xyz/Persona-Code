{"solution": "def max_accordion_length(s):\n    max_length = -1\n    opening_bracket_index = -1\n    max_vertical_lines = 0\n\n    for i, char in enumerate(s):\n        if char == '[':\n            opening_bracket_index = i\n        elif char == ':' and opening_bracket_index!= -1:\n            max_vertical_lines = 0\n            for j in range(i + 1, len(s)):\n                if s[j] == '|':\n                    max_vertical_lines += 1\n                elif s[j] == ':':\n                    max_length = max(max_length, 4 + 2 * max_vertical_lines)\n                    break\n                elif s[j] == ']':\n                    max_length = max(max_length, 4 + 2 * max_vertical_lines)\n                    opening_bracket_index = -1\n                    break\n        elif char == ']' and opening_bracket_index!= -1:\n            max_length = max(max_length, 4)\n            opening_bracket_index = -1\n\n    return max_length\n\ns = input()\nprint(max_accordion_length(s))"}
{"solution": "def max_digit_sum(x):\n    x_str = str(x)\n    max_sum = sum(int(digit) for digit in x_str)\n    max_num = x\n\n    for i in range(len(x_str) - 1, 0, -1):\n        if x_str[i]!= '9':\n            new_num = int(x_str[:i] + str(int(x_str[i]) - 1) + '9' * (len(x_str) - i - 1))\n            new_sum = sum(int(digit) for digit in str(new_num))\n            if new_sum >= max_sum:\n                max_sum = new_sum\n                max_num = new_num\n            break\n\n    return max_num\n\nx = int(input())\nprint(max_digit_sum(x))"}
{"solution": "def is_lucky_year(year):\n    \"\"\"Check if a year is lucky.\"\"\"\n    return sum(1 for digit in str(year) if digit!= '0') <= 1\n\n\ndef next_lucky_year(current_year):\n    \"\"\"Find the next lucky year.\"\"\"\n    next_year = current_year + 1\n    while not is_lucky_year(next_year):\n        next_year += 1\n    return next_year\n\n\ndef main():\n    current_year = int(input())\n    next_year = next_lucky_year(current_year)\n    print(next_year - current_year)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, q = read_ints()\n    painters = [tuple(read_ints()) for _ in range(q)]\n\n    dp = [[[0] * (q + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, q + 1):\n            l, r = painters[j - 1]\n            if l > i:\n                dp[i][i][j] = dp[i - 1][i - 1][j]\n            elif r < i:\n                dp[i][i][j] = dp[i - 1][i - 1][j]\n            else:\n                dp[i][i][j] = max(dp[i - 1][i - 1][j], 1 + dp[l - 1][i - 1][j - 1])\n\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            for k in range(1, q + 1):\n                l, r = painters[k - 1]\n                if l > j or r < i:\n                    dp[i][j][k] = dp[i][j][k - 1]\n                else:\n                    dp[i][j][k] = max(dp[i][j][k - 1], dp[i][l - 1][k - 1] + dp[r + 1][j][k - 1])\n\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            ans = max(ans, dp[i][j][q - 2])\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_lucky(time):\n    return '7' in time\n\ndef find_lucky_time(x, target_time):\n    minutes = int(target_time[:2]) * 60 + int(target_time[3:])\n    y = 0\n    while True:\n        minutes -= x\n        if minutes < 0:\n            minutes += 24 * 60\n        hours = minutes // 60\n        mins = minutes % 60\n        time = f\"{hours:02d}:{mins:02d}\"\n        if is_lucky(time):\n            return y\n        y += 1\n\nx = int(input())\ntarget_time = input()\nprint(find_lucky_time(x, target_time))"}
{"solution": "n, pos, l, r = map(int, input().split())\n\nif l == 1 and r == n:\n    print(0)\nelif l == 1:\n    print(abs(pos - r) + 1)\nelif r == n:\n    print(abs(pos - l) + 1)\nelse:\n    left_time = abs(pos - l) + (l - 1) + abs(r - n)\n    right_time = abs(pos - r) + (n - r) + abs(l - 1)\n    print(min(left_time, right_time) + 1)"}
{"solution": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    blows = []\n    for _ in range(n):\n        d, h = map(int, sys.stdin.readline().split())\n        blows.append((d, h))\n\n    blows.sort(key=lambda x: x[1])\n\n    ans = 0\n    for d, h in blows:\n        if h >= d:\n            break\n        if x <= d:\n            return ans + 1\n        cnt = x // (d - h)\n        if x % (d - h)!= 0:\n            cnt += 1\n        ans += cnt\n        x = x - cnt * (d - h)\n\n    return -1\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    print(solve())"}
{"solution": "def solve(n, m):\n    day = 0\n    while True:\n        day += 1\n        n += m\n        if n > 10**18:\n            n = 10**18\n        if n < day:\n            return day\n        n -= day\n\nn, m = map(int, input().split())\nprint(solve(n, m))"}
{"solution": "def min_draws_to_win():\n    tiles = input().split()\n    \n    # Extract numbers and suits\n    num1, suit1 = int(tiles[0][0]), tiles[0][1]\n    num2, suit2 = int(tiles[1][0]), tiles[1][1]\n    num3, suit3 = int(tiles[2][0]), tiles[2][1]\n    \n    # Check for koutsu (triplet)\n    if tiles[0] == tiles[1] == tiles[2]:\n        return 0\n    \n    # Check for shuntsu (sequence)\n    def is_shuntsu(n1, n2, n3):\n        return sorted([n1, n2, n3]) in [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9]]\n    \n    if suit1 == suit2 == suit3 and is_shuntsu(num1, num2, num3):\n        return 0\n    \n    # Check for possible koutsu with one more draw\n    if tiles[0] == tiles[1] or tiles[0] == tiles[2] or tiles[1] == tiles[2]:\n        return 1\n    \n    # Check for possible shuntsu with one more draw\n    def needs_one_for_shuntsu(n1, n2):\n        return abs(n1 - n2) == 1 or abs(n1 - n2) == 2\n    \n    if suit1 == suit2 and needs_one_for_shuntsu(num1, num2):\n        return 1\n    if suit1 == suit3 and needs_one_for_shuntsu(num1, num3):\n        return 1\n    if suit2 == suit3 and needs_one_for_shuntsu(num2, num3):\n        return 1\n    \n    # If no koutsu or shuntsu can be formed with one more draw, return 2\n    return 2\n\nprint(min_draws_to_win())"}
{"solution": "def count_sofas(d, n, m, sofas, cnt):\n    left = [0] * d\n    right = [0] * d\n    top = [0] * d\n    bottom = [0] * d\n\n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        if x1 == x2:\n            if y1 < y2:\n                for j in range(d):\n                    if sofas[j][0] == x1 and sofas[j][1] < y1:\n                        top[i] += 1\n                    if sofas[j][0] == x1 and sofas[j][1] > y2:\n                        bottom[i] += 1\n            else:\n                for j in range(d):\n                    if sofas[j][0] == x1 and sofas[j][1] < y2:\n                        top[i] += 1\n                    if sofas[j][0] == x1 and sofas[j][1] > y1:\n                        bottom[i] += 1\n        else:\n            if x1 < x2:\n                for j in range(d):\n                    if sofas[j][1] == y1 and sofas[j][0] < x1:\n                        left[i] += 1\n                    if sofas[j][1] == y1 and sofas[j][0] > x2:\n                        right[i] += 1\n            else:\n                for j in range(d):\n                    if sofas[j][1] == y1 and sofas[j][0] < x2:\n                        left[i] += 1\n                    if sofas[j][1] == y1 and sofas[j][0] > x1:\n                        right[i] += 1\n\n    for i in range(d):\n        if left[i] == cnt[0] and right[i] == cnt[1] and top[i] == cnt[2] and bottom[i] == cnt[3]:\n            return i + 1\n\n    return -1\n\n\nd = int(input())\nn, m = map(int, input().split())\nsofas = [list(map(int, input().split())) for _ in range(d)]\ncnt = list(map(int, input().split()))\n\nprint(count_sofas(d, n, m, sofas, cnt))"}
{"solution": "n = int(input())\nfull_weeks = n // 7\nremaining_days = n % 7\n\nmin_days_off = full_weeks * 2\nif remaining_days <= 2:\n    max_days_off = full_weeks * 2 + remaining_days\nelse:\n    max_days_off = full_weeks * 2 + 2\n\nprint(min_days_off, max_days_off)"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nn, a, b, p, q = map(int, input().split())\n\nred = n // a\nblue = n // b\nboth = n // lcm(a, b)\n\nmax_chocolates = max(red * p + (blue - both) * q, blue * q + (red - both) * p)\n\nprint(max_chocolates)"}
{"solution": "def max_golden_trophies(n, trophies):\n    max_length = 0\n    current_length = 0\n    first_silver = -1\n    last_silver = -1\n    silver_count = 0\n\n    for i in range(n):\n        if trophies[i] == 'G':\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            if first_silver == -1:\n                first_silver = i\n            last_silver = i\n            silver_count += 1\n            current_length = 0\n\n    if silver_count == 0:\n        return max_length\n    elif silver_count == 1:\n        return max_length + 1\n    else:\n        max_length_with_swap = max_length\n        if first_silver > 0 and last_silver < n - 1:\n            max_length_with_swap = max(max_length_with_swap, max_length + 2)\n        return max_length_with_swap\n\n\nn = int(input())\ntrophies = input()\nprint(max_golden_trophies(n, trophies))"}
{"solution": "from collections import defaultdict, deque\n\ndef main():\n    n, k = map(int, input().split())\n    main_courses = list(map(int, input().split()))\n\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        dependencies = list(map(int, input().split()))\n        in_degree[i] = dependencies[0]\n        if dependencies[0] > 0:\n            for dependency in dependencies[1:]:\n                graph[dependency].append(i)\n\n    queue = deque([course for course in main_courses if in_degree[course] == 0])\n\n    result = []\n    while queue:\n        course = queue.popleft()\n        result.append(course)\n\n        for neighbor in graph[course]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(result)!= k:\n        print(-1)\n        return\n\n    queue = deque([course for course in range(1, n + 1) if in_degree[course] == 0])\n\n    while queue:\n        course = queue.popleft()\n        if course not in result:\n            result.append(course)\n\n        for neighbor in graph[course]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    print(len(result))\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve(n, k, p):\n    s = []\n    for i in range(k):\n        while s and s[-1] < p[i]:\n            s.pop()\n        if s and s[-1] > p[i]:\n            return [-1]\n        s.append(p[i])\n    remaining = set(range(1, n + 1)) - set(p)\n    remaining = sorted(list(remaining), reverse=True)\n    for i in range(k, n):\n        while s and s[-1] < remaining[-1]:\n            s.pop()\n        if s and s[-1] > remaining[-1]:\n            return [-1]\n        if not s or s[-1] < p[i - 1]:\n            s.append(remaining.pop())\n        else:\n            s.append(p[i])\n    return p + remaining\n\nn, k = map(int, input().split())\np = list(map(int, input().split()))\nprint(*solve(n, k, p))"}
{"solution": "def does_b_appear_in_sequence(a, b, c):\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\na, b, c = map(int, input().split())\nprint(does_b_appear_in_sequence(a, b, c))"}
{"solution": "def can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    if cnt_1 == cnt_4:\n        return 1\n    elif cnt_1 + cnt_2 == cnt_3 + cnt_4:\n        return 1\n    else:\n        return 0\n\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\nprint(can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4))"}
{"solution": "def mexican_wave(n, k, t):\n    if t <= k:\n        return min(t, n)\n    elif t <= n:\n        return k\n    else:\n        return k - (t - n)\n\nn, k, t = map(int, input().split())\nprint(mexican_wave(n, k, t))"}
{"solution": "def lexicographically_minimal_string(s):\n    t = []\n    u = []\n    min_char = min(s)\n    s = list(s)\n    \n    while s or t:\n        if t and (not s or t[-1] <= min_char):\n            u.append(t.pop())\n        else:\n            char = s.pop(0)\n            t.append(char)\n            if s:\n                min_char = min(s)\n    \n    return ''.join(u)\n\ns = input().strip()\nprint(lexicographically_minimal_string(s))"}
{"solution": "def check_records(n, records):\n    for i in range(1, n):\n        plays_diff = records[i][0] - records[i-1][0]\n        clears_diff = records[i][1] - records[i-1][1]\n        \n        if plays_diff < 0 or clears_diff < 0:\n            return \"NO\"\n        \n        if clears_diff > plays_diff:\n            return \"NO\"\n    \n    return \"YES\"\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    records = [list(map(int, input().split())) for _ in range(n)]\n    \n    print(check_records(n, records))"}
{"solution": "def is_palindrome(time):\n    \"\"\"Check if a time string is a palindrome.\"\"\"\n    return time == time[::-1]\n\n\ndef next_palindrome(time):\n    \"\"\"Find the next palindrome time.\"\"\"\n    hours, minutes = map(int, time.split(':'))\n    minutes += 1\n    if minutes == 60:\n        minutes = 0\n        hours = (hours + 1) % 24\n    return f\"{hours:02d}:{minutes:02d}\"\n\n\ndef minutes_until_palindrome(time):\n    \"\"\"Calculate the minimum number of minutes until the next palindrome time.\"\"\"\n    minutes = 0\n    while not is_palindrome(time):\n        time = next_palindrome(time)\n        minutes += 1\n    return minutes\n\n\ndef main():\n    time = input()\n    print(minutes_until_palindrome(time))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_distance(n, arr):\n    min_idx = arr.index(1)\n    max_idx = arr.index(n)\n    \n    # Calculate the distance if we swap the minimum element with the first element\n    dist1 = abs(max_idx - 0)\n    \n    # Calculate the distance if we swap the minimum element with the last element\n    dist2 = abs(max_idx - (n - 1))\n    \n    # Calculate the distance if we swap the maximum element with the first element\n    dist3 = abs(min_idx - 0)\n    \n    # Calculate the distance if we swap the maximum element with the last element\n    dist4 = abs(min_idx - (n - 1))\n    \n    # Return the maximum distance\n    return max(dist1, dist2, dist3, dist4)\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(max_distance(n, arr))"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    mid = n // 2\n    if n % 2 == 0:\n        first_half = s[:mid]\n        second_half = s[mid:]\n    else:\n        first_half = s[:mid]\n        second_half = s[mid+1:]\n    \n    if first_half.lower() == second_half.lower()[::-1]:\n        return \"TAK\"\n    else:\n        return \"NIE\"\n\ns = input().strip()\nprint(is_s_palindrome(s))"}
{"solution": "from collections import Counter\n\ndef max_permutation(a, b):\n    a_count = Counter(a)\n    b = list(b)\n    result = []\n\n    # Try to use the largest possible digit from b\n    for i in range(len(b)):\n        for digit in range(9, -1, -1):\n            if a_count[str(digit)] > 0 and int(''.join(b[:i] + [str(digit)] + b[i+1:])) <= int(''.join(b)):\n                result.append(str(digit))\n                a_count[str(digit)] -= 1\n                break\n\n    # Fill the rest of the result with the remaining digits from a\n    for digit, count in a_count.items():\n        result.extend([digit] * count)\n\n    return ''.join(result)\n\na = input()\nb = input()\nprint(max_permutation(a, b))"}
{"solution": "def check_win(matrix, i, j):\n    # Check horizontal\n    count = 0\n    for k in range(max(0, j-4), min(10, j+5)):\n        if matrix[i][k] == 'X':\n            count += 1\n        else:\n            count = 0\n        if count >= 5:\n            return True\n\n    # Check vertical\n    count = 0\n    for k in range(max(0, i-4), min(10, i+5)):\n        if matrix[k][j] == 'X':\n            count += 1\n        else:\n            count = 0\n        if count >= 5:\n            return True\n\n    # Check diagonal (top-left to bottom-right)\n    count = 0\n    for k in range(max(0, i-4), min(10, i+5)):\n        for col in range(max(0, j-4), min(10, j+5)):\n            if k - i == col - j and matrix[k][col] == 'X':\n                count += 1\n            else:\n                count = 0\n            if count >= 5:\n                return True\n\n    # Check diagonal (bottom-left to top-right)\n    count = 0\n    for k in range(max(0, i-4), min(10, i+5)):\n        for col in range(max(0, j-4), min(10, j+5)):\n            if k - i == j - col and matrix[k][col] == 'X':\n                count += 1\n            else:\n                count = 0\n            if count >= 5:\n                return True\n\n    return False\n\n\ndef can_win(matrix):\n    for i in range(10):\n        for j in range(10):\n            if matrix[i][j] == '.':\n                matrix[i] = matrix[i][:j] + 'X' + matrix[i][j+1:]\n                if check_win(matrix, i, j):\n                    return True\n                matrix[i] = matrix[i][:j] + '.' + matrix[i][j+1:]\n    return False\n\n\nmatrix = [input() for _ in range(10)]\nif can_win(matrix):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def solve(n, k):\n    if k > n * (n + 1) // 2:\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            if k > 0:\n                matrix[i][j] = matrix[j][i] = 1\n                k -= 1\n\n    return matrix\n\n\ndef print_matrix(matrix):\n    if matrix == -1:\n        print(-1)\n    else:\n        for row in matrix:\n            print(' '.join(map(str, row)))\n\n\nn, k = map(int, input().split())\nmatrix = solve(n, k)\nprint_matrix(matrix)"}
{"solution": "import math\n\nx, y, z = map(float, input().split())\n\nexpressions = [\n    (x ** y) ** z,\n    (x ** z) ** y,\n    (x ** (y ** z)),\n    (x ** (z ** y)),\n    (y ** x) ** z,\n    (y ** z) ** x,\n    (y ** (x ** z)),\n    (y ** (z ** x)),\n    (z ** x) ** y,\n    (z ** y) ** x,\n    (z ** (x ** y)),\n    (z ** (y ** x)),\n]\n\nmax_value = max(expressions)\nmax_index = expressions.index(max_value)\n\noptions = [\n    f\"x^{y}^{z}\",\n    f\"x^{z}^{y}\",\n    f\"(x^{y})^{z}\",\n    f\"(x^{z})^{y}\",\n    f\"y^{x}^{z}\",\n    f\"y^{z}^{x}\",\n    f\"(y^{x})^{z}\",\n    f\"(y^{z})^{x}\",\n    f\"z^{x}^{y}\",\n    f\"z^{y}^{x}\",\n    f\"(z^{x})^{y}\",\n    f\"(z^{y})^{x}\",\n]\n\nprint(options[max_index])"}
{"solution": "def min_operations(n, s):\n    \"\"\"\n    Calculate the minimum number of operations to type a string.\n\n    Args:\n    n (int): The length of the string.\n    s (str): The string to be typed.\n\n    Returns:\n    int: The minimum number of operations.\n    \"\"\"\n    # Initialize the minimum number of operations as the length of the string\n    min_ops = n\n\n    # Iterate over all possible prefixes of the string\n    for i in range(1, n // 2 + 1):\n        # Check if the string can be formed by repeating the prefix\n        if s[:i] * (n // i) == s[:n // i * i]:\n            # Update the minimum number of operations\n            min_ops = min(min_ops, i + (n // i - 1) + (n % i))\n\n    return min_ops\n\n\n# Read the input\nn = int(input())\ns = input()\n\n# Calculate and print the minimum number of operations\nprint(min_operations(n, s))"}
{"solution": "import sys\n\ndef read_input():\n    n = int(sys.stdin.readline())\n    files = []\n    for _ in range(n):\n        name, type = sys.stdin.readline().split()\n        files.append((name, int(type)))\n    return n, files\n\ndef solve(n, files):\n    examples = [file for file in files if file[1] == 1]\n    regulars = [file for file in files if file[1] == 0]\n\n    e = len(examples)\n    moves = []\n\n    # Move examples to correct positions\n    for i, file in enumerate(examples):\n        if file[0]!= str(i + 1):\n            moves.append((file[0], str(i + 1)))\n\n    # Move regulars to correct positions\n    for i, file in enumerate(regulars):\n        if file[0]!= str(i + e + 1):\n            moves.append((file[0], str(i + e + 1)))\n\n    # Handle conflicts\n    temp_files = set()\n    for i in range(1, n + 1):\n        temp_files.add(str(i))\n\n    for file in files:\n        if file[0] in temp_files:\n            temp_files.remove(file[0])\n\n    temp_index = 0\n    for i in range(len(moves)):\n        if moves[i][1] in [file[0] for file in files]:\n            temp_file = list(temp_files)[temp_index]\n            temp_index += 1\n            moves.insert(i, (moves[i][1], temp_file))\n            moves[i] = (moves[i][0], temp_file)\n\n    return moves\n\ndef print_output(moves):\n    print(len(moves))\n    for move in moves:\n        print(f\"move {move[0]} {move[1]}\")\n\ndef main():\n    n, files = read_input()\n    moves = solve(n, files)\n    print_output(moves)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_replacements(ticket):\n    \"\"\"\n    Calculate the minimum number of digits Luba needs to replace to make the ticket lucky.\n\n    Args:\n    ticket (str): A string consisting of 6 characters (all characters are digits from 0 to 9)\n\n    Returns:\n    int: The minimum possible number of digits Luba needs to replace to make the ticket lucky\n    \"\"\"\n    # Calculate the sum of the first three digits\n    sum_first_half = sum(int(digit) for digit in ticket[:3])\n    \n    # Calculate the sum of the last three digits\n    sum_second_half = sum(int(digit) for digit in ticket[3:])\n    \n    # Calculate the difference between the two sums\n    difference = abs(sum_first_half - sum_second_half)\n    \n    # The minimum number of replacements is the minimum between the difference and 3\n    # This is because we can replace at most 3 digits to make the sums equal\n    min_replacements = min(difference, 3)\n    \n    # If the difference is 0, we don't need to replace any digits\n    if difference == 0:\n        return 0\n    # If the difference is 1 or 2, we need to replace at least 1 digit\n    elif difference <= 2:\n        return 1\n    # If the difference is 3 or more, we need to replace at least 2 digits\n    else:\n        return 2\n\n# Read the input\nticket = input()\n\n# Print the output\nprint(min_replacements(ticket))"}
{"solution": "import math\n\nm, x = map(int, input().split())\nprint(m - 1 if m % 2 == 0 else m // 2)"}
{"solution": "def power(base, exponent, mod):\n    result = 1\n    base %= mod\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % mod\n        exponent //= 2\n        base = (base * base) % mod\n    return result\n\ndef gcd(a, b):\n    while b!= 0:\n        a, b = b, a % b\n    return a\n\ndef main():\n    n, k = map(int, input().split())\n    mod = 10**6 + 3\n    total_days = power(2, n, mod)\n    denominator = 1\n    for i in range(1, k):\n        denominator = (denominator * (total_days - i + 1)) % mod\n        denominator = (denominator * power(i, mod - 2, mod)) % mod\n    numerator = (power(total_days, k, mod) - denominator) % mod\n    if numerator < 0:\n        numerator += mod\n    common_divisor = gcd(numerator, denominator)\n    numerator //= common_divisor\n    denominator //= common_divisor\n    print(numerator, denominator)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def check_journey(n, journey):\n    \"\"\"\n    Checks if Limak's journey description is valid.\n\n    Args:\n    n (int): The number of parts in the journey.\n    journey (list): A list of tuples containing the distance and direction of each part of the journey.\n\n    Returns:\n    bool: True if the journey description is valid, False otherwise.\n    \"\"\"\n    position = 0  # Start at the North Pole\n\n    for distance, direction in journey:\n        if position == 0 and direction!= \"South\":\n            return False  # Can only move South from the North Pole\n        elif position == -20000 and direction!= \"North\":\n            return False  # Can only move North from the South Pole\n\n        if direction == \"North\":\n            position += distance\n        elif direction == \"South\":\n            position -= distance\n        # Ignore East and West directions as they don't affect the North-South position\n\n        if position > 20000:\n            position = 20000  # Can't move further North than the North Pole\n        elif position < -20000:\n            position = -20000  # Can't move further South than the South Pole\n\n    return position == 0  # Journey must end at the North Pole\n\n\nn = int(input())\njourney = []\nfor _ in range(n):\n    distance, direction = input().split()\n    journey.append((int(distance), direction))\n\nif check_journey(n, journey):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_common_elements(a1, b1, a2, b2, L, R):\n    # Calculate the LCM of a1 and a2\n    lcm_value = lcm(a1, a2)\n    \n    # Calculate the first common element\n    first_common = (b2 - b1) // lcm_value * a1 + b1\n    if (b2 - b1) % lcm_value!= 0 or first_common < L:\n        return 0\n    \n    # Calculate the number of common elements\n    count = (R - first_common) // lcm_value + 1\n    if first_common + lcm_value * count > R:\n        count -= 1\n    \n    return count\n\na1, b1, a2, b2, L, R = map(int, input().split())\nprint(count_common_elements(a1, b1, a2, b2, L, R))"}
{"solution": "def max_min_pieces(n, a, b):\n    \"\"\"\n    Calculate the maximum possible number x such that Ivan can distribute the cakes \n    according to the aforementioned conditions, and each plate will contain at least x pieces of cake.\n\n    Args:\n        n (int): The number of plates.\n        a (int): The number of pieces of the first cake.\n        b (int): The number of pieces of the second cake.\n\n    Returns:\n        int: The maximum possible number x.\n    \"\"\"\n    # Calculate the total number of pieces\n    total_pieces = a + b\n    \n    # Initialize the minimum and maximum possible number of pieces per plate\n    low = 1\n    high = total_pieces // n\n    \n    # Perform binary search to find the maximum possible number of pieces per plate\n    while low <= high:\n        mid = (low + high) // 2\n        \n        # Calculate the number of plates required for the current number of pieces per plate\n        plates_required = (a + mid - 1) // mid + (b + mid - 1) // mid\n        \n        # If the number of plates required is less than or equal to the total number of plates,\n        # update the minimum possible number of pieces per plate\n        if plates_required <= n:\n            low = mid + 1\n        # Otherwise, update the maximum possible number of pieces per plate\n        else:\n            high = mid - 1\n    \n    # The maximum possible number of pieces per plate is the last value of low that resulted in\n    # a number of plates required greater than the total number of plates\n    return low - 1\n\n\n# Read the input\nn, a, b = map(int, input().split())\n\n# Calculate and print the maximum possible number of pieces per plate\nprint(max_min_pieces(n, a, b))"}
{"solution": "def is_valid_flag(n, m, field):\n    # Check if the number of rows is a multiple of 3\n    if n % 3!= 0:\n        return False\n\n    # Calculate the height of each stripe\n    stripe_height = n // 3\n\n    # Initialize a set to store the colors of the stripes\n    colors = set()\n\n    # Iterate over the rows of the field\n    for i in range(n):\n        # Get the color of the current row\n        row_color = field[i][0]\n\n        # Check if the color of the current row is the same as the color of the first row of the current stripe\n        if i % stripe_height!= 0 and field[i][0]!= field[i - 1][0]:\n            return False\n\n        # Check if the color of the current row is consistent across the row\n        if not all(cell == row_color for cell in field[i]):\n            return False\n\n        # Add the color of the current stripe to the set of colors\n        if i % stripe_height == 0:\n            colors.add(row_color)\n\n    # Check if the number of colors is 3\n    if len(colors)!= 3:\n        return False\n\n    return True\n\n\n# Read the input\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\n# Check if the field is a valid flag\nif is_valid_flag(n, m, field):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\nn = int(input())\n\nlayer = math.floor(math.sqrt(n))\nif layer % 2 == 0:\n    layer += 1\n    if layer * (layer - 1) // 2 > n:\n        layer -= 2\n\nstart = layer * (layer - 1) // 2\nx, y = layer // 2, -layer // 2\nif layer % 2 == 0:\n    for _ in range(n - start):\n        x -= 1\n        if x == -layer // 2 - 1:\n            x = layer // 2\n            y += 1\nelse:\n    for _ in range(n - start):\n        y += 1\n        if y == layer // 2 + 1:\n            y = -layer // 2\n            x -= 1\n\nprint(x, y)"}
{"solution": "import math\n\ndef can_break_shield(a, b, c):\n    # Calculate the greatest common divisor of a and b\n    gcd_ab = math.gcd(a, b)\n    \n    # Check if c is divisible by the gcd of a and b\n    if c % gcd_ab == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input values\na, b, c = map(int, input().split())\n\n# Output the result\nprint(can_break_shield(a, b, c))"}
{"solution": "def can_tracks_coincide(n, L, kefa_barriers, sasha_barriers):\n    # Calculate distances between consecutive barriers for Kefa\n    kefa_distances = [(kefa_barriers[(i + 1) % n] - kefa_barriers[i]) % L for i in range(n)]\n    # Calculate distances between consecutive barriers for Sasha\n    sasha_distances = [(sasha_barriers[(i + 1) % n] - sasha_barriers[i]) % L for i in range(n)]\n    \n    # Double the kefa_distances to handle circular rotation\n    doubled_kefa_distances = kefa_distances + kefa_distances\n    \n    # Check if sasha_distances is a sublist of doubled_kefa_distances\n    for i in range(n):\n        if doubled_kefa_distances[i:i + n] == sasha_distances:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_barriers, sasha_barriers))"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome(s):\n    max_length = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if not is_palindrome(substring):\n                max_length = max(max_length, len(substring))\n    return max_length\n\ns = input()\nprint(longest_non_palindrome(s))"}
{"solution": "def is_round_rated(n, ratings):\n    \"\"\"\n    Determine if the current round is rated, unrated, or it's impossible to determine whether it is rated or not.\n\n    Args:\n    n (int): The number of round participants.\n    ratings (list): A list of tuples, where each tuple contains the rating of a participant before and after the round.\n\n    Returns:\n    str: \"rated\" if the round is rated for sure, \"unrated\" if the round is unrated for sure, \"maybe\" if it's impossible to determine whether the round is rated or not.\n    \"\"\"\n\n    # Check if any participant's rating has changed\n    if any(before!= after for before, after in ratings):\n        return \"rated\"\n\n    # Check if the participants took places in non-increasing order of their rating\n    if all(before >= after for (before, _), (_, after) in zip(ratings, ratings[1:])):\n        return \"maybe\"\n\n    return \"unrated\"\n\n\ndef main():\n    n = int(input())\n    ratings = [tuple(map(int, input().split())) for _ in range(n)]\n    print(is_round_rated(n, ratings))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def nearest_zero(n, arr):\n    \"\"\"\n    Calculate the distance to the nearest zero for each element in the array.\n\n    Args:\n    n (int): The length of the array.\n    arr (list): The input array.\n\n    Returns:\n    list: A list of distances to the nearest zero for each element.\n    \"\"\"\n    # Initialize a list to store the distances\n    distances = [float('inf')] * n\n\n    # Initialize the distance to the previous zero\n    prev_zero = float('-inf')\n\n    # Iterate over the array from left to right\n    for i in range(n):\n        # If the current element is zero, update the previous zero index\n        if arr[i] == 0:\n            prev_zero = i\n        # If the previous zero index is not negative infinity, update the distance\n        elif prev_zero!= float('-inf'):\n            distances[i] = i - prev_zero\n\n    # Initialize the distance to the next zero\n    next_zero = float('inf')\n\n    # Iterate over the array from right to left\n    for i in range(n - 1, -1, -1):\n        # If the current element is zero, update the next zero index\n        if arr[i] == 0:\n            next_zero = i\n        # If the next zero index is not positive infinity, update the distance\n        elif next_zero!= float('inf'):\n            distances[i] = min(distances[i], next_zero - i)\n\n    return distances\n\n\n# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate and print the distances\nprint(*nearest_zero(n, arr))"}
{"solution": "def count_distinct_cyclical_strings(n, s):\n    def is_substring_in_cyclical_shifts(t, s):\n        t_extended = t + t\n        return any(s in t_extended[i:i+len(t)] for i in range(len(t)))\n    \n    distinct_cyclical_strings = set()\n    \n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if is_substring_in_cyclical_shifts(t, s):\n            distinct_cyclical_strings.add(t)\n    \n    return len(distinct_cyclical_strings)\n\nfrom itertools import product\nn = int(input())\ns = input().strip()\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import math\n\ndef polar_angle(x, y):\n    \"\"\"Calculate the polar angle of a vector.\"\"\"\n    return math.atan2(y, x)\n\ndef angle_between_vectors(a, b):\n    \"\"\"Calculate the non-oriented angle between two vectors.\"\"\"\n    return min(math.pi - abs(a - b), abs(a - b))\n\ndef main():\n    n = int(input())\n    vectors = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        vectors.append((x, y, i + 1))\n\n    # Sort vectors by polar angle\n    vectors.sort(key=lambda v: polar_angle(v[0], v[1]))\n\n    min_angle = math.pi\n    min_indices = (0, 0)\n    for i in range(n - 1):\n        angle = angle_between_vectors(polar_angle(vectors[i][0], vectors[i][1]), polar_angle(vectors[i + 1][0], vectors[i + 1][1]))\n        if angle < min_angle:\n            min_angle = angle\n            min_indices = (vectors[i][2], vectors[i + 1][2])\n\n    # Check the angle between the first and last vectors\n    angle = angle_between_vectors(polar_angle(vectors[0][0], vectors[0][1]), polar_angle(vectors[-1][0], vectors[-1][1]))\n    if angle < min_angle:\n        min_angle = angle\n        min_indices = (vectors[0][2], vectors[-1][2])\n\n    print(*min_indices)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nd, k, a, b, t = map(int, sys.stdin.readline().split())\n\nif d <= k:\n    print(d * a)\nelse:\n    full_segments = d // k\n    remaining_distance = d % k\n\n    time_for_full_segments = full_segments * k * a + (full_segments - 1) * t\n\n    if remaining_distance == 0:\n        print(time_for_full_segments + t)\n    else:\n        time_drive_remaining = remaining_distance * a + t\n        time_walk_remaining = remaining_distance * b\n\n        print(time_for_full_segments + min(time_drive_remaining, time_walk_remaining))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(n, k):\n    if n < k:\n        return -1\n    if n % k == 0:\n        return [n // k] * k\n    gcd_val = n // k\n    if n % gcd_val == 0:\n        return [gcd_val] * k\n    gcd_val -= 1\n    seq = []\n    while n > 0 and len(seq) < k:\n        num = gcd_val\n        while n - num < k - len(seq) - 1:\n            num -= 1\n        seq.append(num)\n        n -= num\n    if len(seq) < k:\n        return -1\n    return seq\n\nn, k = map(int, input().split())\nresult = solve(n, k)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def count_pairs(n, m):\n    \"\"\"\n    Counts the number of pairs of integers (x, y) such that 1 \u2264 x \u2264 n, 1 \u2264 y \u2264 m and (x + y) is divisible by 5.\n    \n    Args:\n        n (int): The upper limit of the first column.\n        m (int): The upper limit of the second column.\n    \n    Returns:\n        int: The number of pairs of integers (x, y) such that 1 \u2264 x \u2264 n, 1 \u2264 y \u2264 m and (x + y) is divisible by 5.\n    \"\"\"\n    count = 0\n    for i in range(5):\n        count += (n - i) // 5 * (m - (5 - i)) // 5\n        if (n - i) % 5 >= (m - (5 - i)) % 5:\n            count += (n - i) % 5 - (m - (5 - i)) % 5\n    return count\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))"}
{"solution": "import sys\n\ndef max_beauty(n, x, a):\n    if x == 1:\n        return max_subarray_sum(a)\n\n    max_sum = max_subarray_sum(a)\n    max_sum_with_x = max_subarray_sum_with_x(a, x)\n\n    return max(max_sum, max_sum_with_x)\n\n\ndef max_subarray_sum(a):\n    max_sum = 0\n    current_sum = 0\n\n    for num in a:\n        current_sum = max(0, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\n\ndef max_subarray_sum_with_x(a, x):\n    prefix_sum = [0] * (len(a) + 1)\n    for i in range(len(a)):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    max_sum = float('-inf')\n    min_prefix_sum = 0\n\n    for i in range(len(a)):\n        max_sum = max(max_sum, prefix_sum[i + 1] - min_prefix_sum)\n        min_prefix_sum = min(min_prefix_sum, prefix_sum[i + 1] - x * a[i])\n\n    return max_sum * x\n\n\ndef main():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    print(max_beauty(n, x, a))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_kth_largest(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(m, x // i)\n        return count\n\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_less_equal(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\nn, m, k = map(int, input().split())\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    start += (k - 1) // length\n    return str(start)[(k - 1) % length]\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "def max_bourles(n, m, r, s, b):\n    max_bourles = r\n    for buy_price in s:\n        for sell_price in b:\n            if buy_price < sell_price:\n                shares = r // buy_price\n                bourles = shares * sell_price\n                max_bourles = max(max_bourles, bourles + r % buy_price)\n    return max_bourles\n\nn, m, r = map(int, input().split())\ns = sorted(map(int, input().split()))\nb = sorted(map(int, input().split()))\n\nprint(max_bourles(n, m, r, s, b))"}
{"solution": "def find_original_message(t):\n    n = len(t)\n    \n    # \u041f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u0432\u0441\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0434\u043b\u0438\u043d\u044b \u043d\u0430\u043b\u043e\u0436\u0435\u043d\u0438\u044f\n    for overlap in range(1, n // 2 + 1):\n        # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u043c\u043e\u0436\u043d\u043e \u043b\u0438 \u0440\u0430\u0437\u0434\u0435\u043b\u0438\u0442\u044c \u0441\u0442\u0440\u043e\u043a\u0443 t \u043d\u0430 \u0434\u0432\u0435 \u0447\u0430\u0441\u0442\u0438 \u0441 \u043d\u0430\u043b\u043e\u0436\u0435\u043d\u0438\u0435\u043c \u0434\u043b\u0438\u043d\u044b overlap\n        if t[:overlap] == t[-overlap:]:\n            s = t[:-overlap]\n            if s + t[-overlap:] == t and len(s) > overlap:\n                return \"YES\", s\n    \n    return \"NO\", None\n\n# \u0427\u0442\u0435\u043d\u0438\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\nt = input().strip()\n\n# \u041f\u043e\u0438\u0441\u043a \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0433\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f s\nresult, s = find_original_message(t)\n\n# \u0412\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\nprint(result)\nif result == \"YES\":\n    print(s)"}
{"solution": "import math\n\ndef solve(n):\n    result = []\n    for i in range(1, int(math.sqrt(2 * n)) + 1):\n        x = 2 * n // i - i + 1\n        if x % 2 == 1 and x // 2 >= i:\n            t = x\n            games = 0\n            while t % 2 == 0:\n                games += t // 2\n                t //= 2\n            games += i * (i - 1) // 2\n            if games == n:\n                result.append(x)\n    return result\n\nn = int(input())\nresult = solve(n)\nif not result:\n    print(-1)\nelse:\n    for x in result:\n        print(x)"}
{"solution": "def calculate_max_beauty(n, s, b):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    max_beauty = 0\n    for i in range(n // 2):\n        char1 = s[i]\n        char2 = s[n - i - 1]\n        if char1 == char2:\n            if char_count[char1] > 2:\n                max_beauty += b[i] + b[n - i - 1]\n                char_count[char1] -= 2\n            else:\n                max_beauty += max(b[i], b[n - i - 1])\n                char_count[char1] -= 1\n        else:\n            max_beauty += b[i] + b[n - i - 1]\n            char_count[char1] -= 1\n            char_count[char2] -= 1\n\n    return max_beauty\n\n\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\nprint(calculate_max_beauty(n, s, b))"}
{"solution": "def can_be_weighted(w, m):\n    \"\"\"\n    Determine whether an item of mass m can be weighed using the given weights in a balanced manner.\n\n    Args:\n    w (int): The number defining the masses of the weights.\n    m (int): The mass of the item.\n\n    Returns:\n    bool: True if the item can be weighted, False otherwise.\n    \"\"\"\n    # Calculate the maximum weight that can be represented using the given weights\n    max_weight = (w ** 101 - 1) // (w - 1)\n\n    # Check if the mass of the item is within the range of representable weights\n    if m > max_weight:\n        return False\n\n    # Check if the mass of the item can be represented as a sum of powers of w\n    for i in range(101):\n        # Calculate the remainder of the mass after subtracting the current power of w\n        remainder = m % (w ** (i + 1))\n\n        # If the remainder is not a multiple of w, the mass cannot be represented\n        if remainder % w!= 0:\n            return False\n\n        # Update the mass by subtracting the current power of w\n        m -= remainder\n\n    return True\n\n\ndef main():\n    # Read the input values\n    w, m = map(int, input().split())\n\n    # Determine whether the item can be weighted\n    if can_be_weighted(w, m):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve(n, k):\n    if k > n:\n        return [-1] * k\n\n    powers = []\n    i = 0\n    while n > 0:\n        if n & 1:\n            powers.append(i)\n        n >>= 1\n        i += 1\n\n    if len(powers) < k:\n        return None\n\n    powers.sort(reverse=True)\n    result = powers[:k]\n    return result\n\n\nn, k = map(int, input().split())\nresult = solve(n, k)\nif result is None:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    print(*result)"}
{"solution": "def champagne_pyramid(n, t):\n    pyramid = [[0.0] * i for i in range(1, n + 1)]\n    pyramid[0][0] = t\n\n    for i in range(n):\n        for j in range(len(pyramid[i])):\n            if pyramid[i][j] > 1:\n                excess = (pyramid[i][j] - 1) / 2\n                pyramid[i][j] = 1\n                if i < n - 1:\n                    pyramid[i + 1][j] += excess\n                    pyramid[i + 1][j + 1] += excess\n\n    return sum(1 for row in pyramid for glass in row if glass >= 1)\n\n\nn, t = map(int, input().split())\nprint(champagne_pyramid(n, t))"}
{"solution": "n = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\n\nif n == 1:\n    print(-1)\nelif n == 2:\n    x1, y1 = vertices[0]\n    x2, y2 = vertices[1]\n    if x1!= x2 and y1!= y2:\n        print(abs(x1 - x2) * abs(y1 - y2))\n    else:\n        print(-1)\nelif n == 3:\n    x_coords = set()\n    y_coords = set()\n    for x, y in vertices:\n        x_coords.add(x)\n        y_coords.add(y)\n    if len(x_coords) == 2 and len(y_coords) == 2:\n        x1, x2 = x_coords\n        y1, y2 = y_coords\n        print(abs(x1 - x2) * abs(y1 - y2))\n    else:\n        print(-1)\nelif n == 4:\n    x_coords = set()\n    y_coords = set()\n    for x, y in vertices:\n        x_coords.add(x)\n        y_coords.add(y)\n    if len(x_coords) == 2 and len(y_coords) == 2:\n        x1, x2 = x_coords\n        y1, y2 = y_coords\n        print(abs(x1 - x2) * abs(y1 - y2))\n    else:\n        print(-1)"}
{"solution": "import math\n\nn = int(input())\na = int(input())\nb = int(input())\n\nvertical_length = 2 * a\nhorizontal_length = b\ntotal_length = 2 * (vertical_length + horizontal_length)\n\nif total_length <= n:\n    print(1)\nelse:\n    bars_needed = math.ceil(total_length / n)\n    print(bars_needed)"}
{"solution": "def can_sort_array(n, a, swaps):\n    \"\"\"\n    Determine if an array can be sorted in ascending order by swapping adjacent elements.\n\n    Args:\n    n (int): The number of elements in the array.\n    a (list): The array of integers.\n    swaps (str): A string of 0s and 1s indicating whether adjacent elements can be swapped.\n\n    Returns:\n    bool: True if the array can be sorted, False otherwise.\n    \"\"\"\n    # Initialize a list to store the maximum value that can be placed at each position\n    max_values = [0] * n\n\n    # Iterate over the array from right to left\n    for i in range(n - 1, -1, -1):\n        # If the current element is the maximum value, update the maximum value for this position\n        if i == n - 1 or a[i] > max_values[i + 1]:\n            max_values[i] = a[i]\n        # If the current element is not the maximum value and swapping is allowed, use the maximum value from the next position\n        elif swaps[i] == '1':\n            max_values[i] = max_values[i + 1]\n        # If the current element is not the maximum value and swapping is not allowed, return False\n        else:\n            return False\n\n    # If the maximum values are in ascending order, the array can be sorted\n    return all(max_values[i] <= max_values[i + 1] for i in range(n - 1))\n\n\ndef main():\n    # Read the number of elements in the array\n    n = int(input())\n\n    # Read the array of integers\n    a = list(map(int, input().split()))\n\n    # Read the string of swaps\n    swaps = input()\n\n    # Determine if the array can be sorted\n    if can_sort_array(n, a, swaps):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_time(row, seat):\n    # Calculate the number of rows the attendants need to move\n    rows_to_move = (row + 1) // 2\n\n    # Calculate the time spent moving rows\n    time_spent_moving = rows_to_move - 1\n\n    # Calculate the time spent serving rows\n    time_spent_serving = 6 * (rows_to_move - 1)\n\n    # Calculate the time spent serving the current row\n    if row % 2 == 1:\n        # First attendant serves the row\n        if seat in 'fefd':\n            time_spent_serving_current_row = 'fefd'.index(seat) + 1\n        else:\n            time_spent_serving_current_row = 3 + 'cba'.index(seat) + 1\n    else:\n        # Second attendant serves the row\n        if seat in 'fefd':\n            time_spent_serving_current_row = 'fefd'.index(seat) + 1\n        else:\n            time_spent_serving_current_row = 3 + 'cba'.index(seat) + 1\n\n    # Calculate the total time\n    total_time = time_spent_moving + time_spent_serving + time_spent_serving_current_row\n\n    return total_time\n\n\ndef main():\n    input_str = input()\n    row = int(input_str[:-1])\n    seat = input_str[-1]\n\n    print(calculate_time(row, seat))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def convert_to_decimal(digits, base):\n    decimal = 0\n    for i, digit in enumerate(reversed(digits)):\n        decimal += digit * (base ** i)\n    return decimal\n\ndef compare_numbers():\n    n, bx = map(int, input().split())\n    x_digits = list(map(int, input().split()))\n\n    m, by = map(int, input().split())\n    y_digits = list(map(int, input().split()))\n\n    x_decimal = convert_to_decimal(x_digits, bx)\n    y_decimal = convert_to_decimal(y_digits, by)\n\n    if x_decimal < y_decimal:\n        print('<')\n    elif x_decimal > y_decimal:\n        print('>')\n    else:\n        print('=')\n\ncompare_numbers()"}
{"solution": "def mex(arr):\n    arr.sort()\n    mex = 0\n    for num in arr:\n        if num == mex:\n            mex += 1\n    return mex\n\ndef nim_sum(arr):\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    if n == 1:\n        print(\"BitLGM\" if arr[0] > 0 else \"BitAryo\")\n    elif n == 2:\n        if arr[0] == arr[1]:\n            print(\"BitLGM\" if arr[0] % 2 == 1 else \"BitAryo\")\n        else:\n            print(\"BitAryo\")\n    else:\n        print(\"BitLGM\" if nim_sum(arr)!= 0 else \"BitAryo\")\n\nsolve()"}
{"solution": "import math\nimport sys\n\ndef prime_factors(n):\n    factors = {}\n    while n % 2 == 0:\n        factors[2] = factors.get(2, 0) + 1\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            factors[i] = factors.get(i, 0) + 1\n            n = n // i\n    if n > 2:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    k_factors = prime_factors(k)\n    prefix_factors = [{} for _ in range(n + 1)]\n    suffix_factors = [{} for _ in range(n + 1)]\n\n    for i in range(n):\n        factors = prime_factors(a[i])\n        for p, c in factors.items():\n            prefix_factors[i + 1][p] = prefix_factors[i].get(p, 0) + c\n            suffix_factors[n - i - 1][p] = suffix_factors[n - i].get(p, 0) + c\n\n    ans = 0\n    for i in range(n + 1):\n        for j in range(n + 1):\n            if i + j > n:\n                break\n            valid = True\n            for p, c in k_factors.items():\n                if prefix_factors[i].get(p, 0) + suffix_factors[j].get(p, 0) < c:\n                    valid = False\n                    break\n            if valid and i + j < n:\n                ans += 1\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_distribute_balloons(n, k, s):\n    color_counts = {}\n    for color in s:\n        if color in color_counts:\n            color_counts[color] += 1\n        else:\n            color_counts[color] = 1\n\n    for count in color_counts.values():\n        if count > k:\n            return \"NO\"\n\n    return \"YES\"\n\nn, k = map(int, input().split())\ns = input().strip()\n\nprint(can_distribute_balloons(n, k, s))"}
{"solution": "def find_distance_between_minima():\n    n = int(input())\n    array = list(map(int, input().split()))\n\n    min_value = min(array)\n    min_indices = [i for i, x in enumerate(array) if x == min_value]\n\n    min_distance = float('inf')\n    for i in range(len(min_indices) - 1):\n        distance = min_indices[i + 1] - min_indices[i]\n        min_distance = min(min_distance, distance)\n\n    print(min_distance)\n\nfind_distance_between_minima()"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef main():\n    t, w, b = map(int, input().split())\n    g = gcd(w, b)\n    lcm = (w * b) // g\n    count = t // lcm\n    if t % lcm == 0:\n        count -= 1\n    numerator = count + 1\n    denominator = t\n    common_divisor = gcd(numerator, denominator)\n    print(f\"{numerator // common_divisor}/{denominator // common_divisor}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def determine_result(x, y, z):\n    if x > y and x + z > y:\n        return \"+\"\n    elif x < y and x + z < y:\n        return \"-\"\n    elif x == y:\n        return \"0\"\n    else:\n        return \"?\"\n\n\nx, y, z = map(int, input().split())\nprint(determine_result(x, y, z))"}
{"solution": "def min_length_of_changed_subsegment(n, operations, x, y):\n    # Calculate the total movement in the x and y directions\n    total_x = operations.count('R') - operations.count('L')\n    total_y = operations.count('U') - operations.count('D')\n\n    # If the total movement is already equal to the target coordinates, return 0\n    if total_x == x and total_y == y:\n        return 0\n\n    # Initialize variables to keep track of the minimum length of the changed subsegment\n    min_length = float('inf')\n\n    # Iterate over all possible subsegments\n    for i in range(n):\n        for j in range(i, n):\n            # Calculate the movement in the x and y directions for the current subsegment\n            subsegment_x = operations[i:j+1].count('R') - operations[i:j+1].count('L')\n            subsegment_y = operations[i:j+1].count('U') - operations[i:j+1].count('D')\n\n            # Calculate the movement in the x and y directions for the remaining operations\n            remaining_x = total_x - subsegment_x\n            remaining_y = total_y - subsegment_y\n\n            # Check if it's possible to change the current subsegment to reach the target coordinates\n            if remaining_x + (j - i + 1) >= x and remaining_x - (j - i + 1) <= x and \\\n               remaining_y + (j - i + 1) >= y and remaining_y - (j - i + 1) <= y:\n                # Update the minimum length of the changed subsegment\n                min_length = min(min_length, j - i + 1)\n\n    # If no possible subsegment is found, return -1\n    if min_length == float('inf'):\n        return -1\n    else:\n        return min_length\n\n\nn = int(input())\noperations = input()\nx, y = map(int, input().split())\n\nprint(min_length_of_changed_subsegment(n, operations, x, y))"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.readline\n\n    T = int(input())\n    results = []\n\n    for _ in range(T):\n        n, x = map(int, input().split())\n        s = input().strip()\n\n        balance_s = s.count('0') - s.count('1')\n        prefix_balances = [0] * (n + 1)\n\n        for i in range(n):\n            prefix_balances[i + 1] = prefix_balances[i] + (1 if s[i] == '0' else -1)\n\n        if balance_s == 0:\n            if x in prefix_balances:\n                results.append(-1)\n            else:\n                results.append(0)\n        else:\n            count = 0\n            for b in prefix_balances:\n                if (x - b) % balance_s == 0 and (x - b) // balance_s >= 0:\n                    count += 1\n            results.append(count)\n\n    for result in results:\n        print(result)\n\nsolve()"}
{"solution": "def min_digits_to_delete(n, k):\n    n_str = str(n)\n    k_str = '0' * k\n    min_deletions = float('inf')\n\n    for i in range(len(n_str)):\n        for j in range(i + 1, len(n_str) + 1):\n            substr = n_str[i:j]\n            if substr.endswith(k_str):\n                deletions = len(n_str) - len(substr)\n                min_deletions = min(min_deletions, deletions)\n\n    if min_deletions == float('inf'):\n        min_deletions = len(n_str) - k\n\n    return min_deletions\n\nn, k = map(int, input().split())\nprint(min_digits_to_delete(n, k))"}
{"solution": "def calculate_max_min_sergei(n, m, k, x, y):\n    if n == 1:\n        max_val = (k + m - 1) // m\n        min_val = (k + m - 1) // m - 1 if k % m!= 0 else (k + m - 1) // m\n        sergei_val = (k + y - 1) // m\n    else:\n        full_cycles = (k - 1) // (2 * n * m - 2 * m) + 1\n        remaining_questions = k - (full_cycles - 1) * (2 * n * m - 2 * m)\n        max_val = full_cycles * 2 - 1 + min(remaining_questions, 2 * n * m - 2 * m) // (2 * m)\n        min_val = full_cycles * 2 - 1 if remaining_questions <= n * m else full_cycles * 2\n        sergei_val = full_cycles * 2 - 1 + min(remaining_questions, 2 * n * m - 2 * m) // (2 * m) if x <= n - (remaining_questions - 1) // m else full_cycles * 2 - 1\n\n    return max_val, min_val, sergei_val\n\n\nn, m, k, x, y = map(int, input().split())\nmax_val, min_val, sergei_val = calculate_max_min_sergei(n, m, k, x, y)\nprint(max_val, min_val, sergei_val)"}
{"solution": "def calculate_beauty(ribbon, n):\n    max_beauty = 0\n    for char in set(ribbon):\n        beauty = ribbon.count(char) + min(n, len(ribbon) - ribbon.count(char))\n        max_beauty = max(max_beauty, beauty)\n    return max_beauty\n\ndef main():\n    n = int(input())\n    ribbons = [input() for _ in range(3)]\n    beauty_values = [calculate_beauty(ribbon, n) for ribbon in ribbons]\n    max_beauty = max(beauty_values)\n    if beauty_values.count(max_beauty) > 1:\n        print(\"Draw\")\n    else:\n        winner_index = beauty_values.index(max_beauty)\n        winners = [\"Kuro\", \"Shiro\", \"Katie\"]\n        print(winners[winner_index])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_days(c, v0, v1, a, l):\n    \"\"\"\n    Calculate the number of days Mister B needs to finish the book.\n\n    Args:\n    c (int): The length of the book in pages.\n    v0 (int): The initial reading speed.\n    v1 (int): The maximum reading speed.\n    a (int): The acceleration in reading speed.\n    l (int): The number of pages for rereading.\n\n    Returns:\n    int: The number of days Mister B needs to finish the book.\n    \"\"\"\n    days = 0\n    pages_read = 0\n    current_speed = v0\n\n    while pages_read < c:\n        # Calculate the number of pages to read today\n        pages_to_read = min(current_speed, v1)\n        if pages_read + pages_to_read > c:\n            pages_to_read = c - pages_read\n\n        # Update the number of pages read\n        pages_read += pages_to_read - l\n\n        # Update the current speed\n        current_speed = min(current_speed + a, v1)\n\n        # Increment the number of days\n        days += 1\n\n    return days\n\n\n# Read the input\nc, v0, v1, a, l = map(int, input().split())\n\n# Calculate and print the number of days\nprint(calculate_days(c, v0, v1, a, l))"}
{"solution": "def is_prime(num):\n    \"\"\"Check if a number is prime.\"\"\"\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef find_primes(n):\n    \"\"\"Find a set of primes that sum up to n.\"\"\"\n    # Check if n is prime\n    if is_prime(n):\n        return [n]\n\n    # Check if n can be represented as the sum of two primes\n    for i in range(2, n):\n        if is_prime(i) and is_prime(n - i):\n            return [i, n - i]\n\n    # If not, try to find three primes\n    for i in range(2, n):\n        if is_prime(i):\n            for j in range(i, n - i):\n                if is_prime(j) and is_prime(n - i - j):\n                    return [i, j, n - i - j]\n\ndef main():\n    n = int(input())\n    primes = find_primes(n)\n    print(len(primes))\n    print(*primes)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_walls(grid):\n    \"\"\"Count the number of walls in each row and column.\"\"\"\n    row_walls = [row.count('*') for row in grid]\n    col_walls = [sum(1 for row in grid if row[i] == '*') for i in range(len(grid[0]))]\n    return row_walls, col_walls\n\ndef find_bomb_location(grid):\n    \"\"\"Find the location where the bomb should be placed.\"\"\"\n    row_walls, col_walls = count_walls(grid)\n    total_walls = sum(row_walls)\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if row_walls[i] + col_walls[j] - (grid[i][j] == '*') == total_walls:\n                return (i + 1, j + 1)\n    \n    return None\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n)]\n    \n    bomb_location = find_bomb_location(grid)\n    \n    if bomb_location:\n        print(\"YES\")\n        print(*bomb_location)\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\nn, m, a, b = map(int, input().split())\n\ndef min_cost(n, m, a, b):\n    remainder = n % m\n    if remainder == 0:\n        return 0\n    else:\n        cost_to_build = (m - remainder) * a\n        cost_to_demolish = remainder * b\n        return min(cost_to_build, cost_to_demolish)\n\nprint(min_cost(n, m, a, b))"}
{"solution": "def max_odd_subsequence_sum(n, sequence):\n    \"\"\"\n    This function calculates the maximum sum of a subsequence with an odd sum.\n\n    Args:\n    n (int): The length of the sequence.\n    sequence (list): A list of integers representing the sequence.\n\n    Returns:\n    int: The maximum sum of a subsequence with an odd sum.\n    \"\"\"\n    # Initialize variables to store the maximum sum of subsequences with odd and even sums\n    max_odd_sum = float('-inf')\n    max_even_sum = 0\n\n    # Iterate over the sequence\n    for num in sequence:\n        # If the current number is odd, update max_odd_sum and max_even_sum accordingly\n        if num % 2!= 0:\n            max_odd_sum, max_even_sum = max(max_odd_sum + num, max_even_sum), max(max_even_sum + num, max_odd_sum)\n        # If the current number is even, update max_odd_sum and max_even_sum accordingly\n        else:\n            max_odd_sum, max_even_sum = max(max_odd_sum, max_even_sum + num), max(max_even_sum, max_odd_sum + num)\n\n    # Return the maximum sum of a subsequence with an odd sum\n    return max_odd_sum\n\n\n# Read the input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Calculate and print the maximum sum of a subsequence with an odd sum\nprint(max_odd_subsequence_sum(n, sequence))"}
{"solution": "from collections import defaultdict\nfrom functools import lru_cache\n\nMOD = 10**9 + 7\n\ndef main():\n    n, T = map(int, input().split())\n    songs = [tuple(map(int, input().split())) for _ in range(n)]\n\n    @lru_cache(None)\n    def dp(i, t, last_genre):\n        if t == 0:\n            return 1\n        if t < 0 or i == n:\n            return 0\n\n        total = 0\n        for j in range(n):\n            if j!= i and songs[j][1]!= last_genre:\n                total += dp(j, t - songs[j][0], songs[j][1])\n                total %= MOD\n\n        return total\n\n    total = 0\n    for i in range(n):\n        total += dp(i, T - songs[i][0], songs[i][1])\n        total %= MOD\n\n    print(total)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef phi(n):\n    result = n\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            while n % p == 0:\n                n //= p\n            result -= result // p\n        p += 1\n    if n > 1:\n        result -= result // n\n    return result\n\ndef solve(m):\n    if m == 1:\n        return 1\n    else:\n        result = 0\n        for i in range(2, m + 1):\n            if phi(i) == 1:\n                result += 1\n        return (m * (m - result) + result * m * mod_inverse(m - result, MOD)) % MOD\n\nm = int(input())\nprint(solve(m))"}
{"solution": "import math\n\ndef count_good_pairs(l, r, x, y):\n    if x > y or y % x!= 0 or y < x * x:\n        return 0\n\n    count = 0\n    for k in range(1, int(math.sqrt(y // x)) + 1):\n        if (y // x) % k == 0:\n            a = x * k\n            b = x * (y // x) // k\n            if l <= a <= r and l <= b <= r:\n                count += 2\n            if a == b:\n                count -= 1\n    return count\n\nl, r, x, y = map(int, input().split())\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve():\n    a, b = map(int, input().split())\n    if a > b:\n        a, b = b, a\n    k = 0\n    if a!= b:\n        k = b - gcd(a, b)\n    print(k)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def calculate_additional_marks(n, k, marks):\n    \"\"\"\n    Calculate the minimal number of additional marks needed to achieve a final mark of k.\n\n    Args:\n        n (int): The number of marks received by Noora.\n        k (int): The value of the highest possible mark.\n        marks (list): A list of marks received by Noora before Leha's hack.\n\n    Returns:\n        int: The minimal number of additional marks needed.\n    \"\"\"\n    total_marks = sum(marks)\n    additional_marks = 0\n\n    while True:\n        average = (total_marks + additional_marks) / (n + additional_marks)\n        if average >= k - 0.5:\n            break\n        additional_marks += 1\n\n    return additional_marks\n\n\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\nadditional_marks = calculate_additional_marks(n, k, marks)\nprint(additional_marks)"}
{"solution": "import math\n\ndef find_d(n, a):\n    for d in range(-1000, 1001):\n        if d == 0:\n            continue\n        positive_count = sum(1 for x in a if x / d > 0)\n        if positive_count >= math.ceil(n / 2):\n            return d\n    return 0\n\nn = int(input())\na = list(map(int, input().split()))\nprint(find_d(n, a))"}
{"solution": "def count_pairs(n):\n    if n < 10:\n        return n // 2\n    elif n % 10 == 9:\n        return 1\n    else:\n        return (n // 10) * 10 + (n % 10) // 2\n\nn = int(input())\nprint(count_pairs(n))"}
{"solution": "from collections import deque\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(a, b, c, d):\n    queue = deque([(a, b, 0)])\n    visited = set((a, b))\n    while queue:\n        x, y, minutes = queue.popleft()\n        if x * y == c * d:\n            return minutes, (x, y), (c, d)\n        if x % 2 == 0 and (x // 2, y) not in visited:\n            queue.append((x // 2, y, minutes + 1))\n            visited.add((x // 2, y))\n        if y % 2 == 0 and (x, y // 2) not in visited:\n            queue.append((x, y // 2, minutes + 1))\n            visited.add((x, y // 2))\n        if x % 3 == 0 and (x // 3, y) not in visited:\n            queue.append((x // 3, y, minutes + 1))\n            visited.add((x // 3, y))\n        if y % 3 == 0 and (x, y // 3) not in visited:\n            queue.append((x, y // 3, minutes + 1))\n            visited.add((x, y // 3))\n    return -1, None, None\n\ndef main():\n    a, b = map(int, input().split())\n    c, d = map(int, input().split())\n    if a * b < c * d:\n        a, b, c, d = c, d, a, b\n    minutes, (x, y), (z, w) = solve(a, b, c, d)\n    if minutes == -1:\n        print(-1)\n    else:\n        print(minutes)\n        print(x, y)\n        print(z, w)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def determine_winner(x_p, y_p, x_v, y_v):\n    \"\"\"\n    Determine the winner of the game given the starting coordinates of both pawns.\n\n    Args:\n    x_p (int): Polycarp's x-coordinate.\n    y_p (int): Polycarp's y-coordinate.\n    x_v (int): Vasiliy's x-coordinate.\n    y_v (int): Vasiliy's y-coordinate.\n\n    Returns:\n    str: The name of the winner, either \"Polycarp\" or \"Vasiliy\".\n    \"\"\"\n    # Calculate the minimum number of moves for Polycarp to reach (0, 0)\n    polycarp_moves = max(x_p, y_p)\n\n    # Calculate the minimum number of moves for Vasiliy to reach (0, 0)\n    vasiliy_moves = max(x_v + y_v - min(x_v, y_v), min(x_v, y_v))\n\n    # If Polycarp can reach (0, 0) in less moves, he wins\n    if polycarp_moves < vasiliy_moves:\n        return \"Polycarp\"\n    # If Vasiliy can reach (0, 0) in less moves, he wins\n    elif polycarp_moves > vasiliy_moves:\n        return \"Vasiliy\"\n    # If both can reach (0, 0) in the same number of moves, Polycarp wins because he starts first\n    else:\n        return \"Polycarp\"\n\n\n# Read the input coordinates\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Determine and print the winner\nprint(determine_winner(x_p, y_p, x_v, y_v))"}
{"solution": "def calculate_columns(month, weekday):\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    first_day_offset = weekday - 1\n    total_days = days_in_month[month - 1] + first_day_offset\n    columns = (total_days + 6) // 7\n    return columns\n\nmonth, weekday = map(int, input().split())\nprint(calculate_columns(month, weekday))"}
{"solution": "def count_years_with_one_zero(a, b):\n    def count_years_with_one_zero_up_to(n):\n        count = 0\n        for i in range(1, n.bit_length() + 1):\n            count += 2 ** (i - 1)\n        for i in range(n.bit_length() - 1, -1, -1):\n            if (n >> i) & 1:\n                count += 2 ** i\n                if i > 0:\n                    count -= 1\n            else:\n                break\n        return count\n\n    return count_years_with_one_zero_up_to(b) - count_years_with_one_zero_up_to(a - 1)\n\n\na, b = map(int, input().split())\nprint(count_years_with_one_zero(a, b))"}
{"solution": "def minimal_layers(N):\n    layers = 0\n    for i in range(1, N + 1):\n        layers = max(layers, i + (N - i) // 2)\n    return layers\n\nN = int(input())\nprint(minimal_layers(N))"}
{"solution": "import math\nimport sys\n\ndef read_input():\n    n, k, S = map(int, input().split())\n    a = list(map(int, input().split()))\n    return n, k, S, a\n\ndef solve(n, k, S, a):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n            dp[i][j] += dp[i - 1][j]\n\n            if a[i - 1] <= S:\n                for l in range(j + 1):\n                    if a[i - 1] * math.factorial(l) <= S:\n                        dp[i][j] += dp[i - 1][j - l]\n\n    return dp[n][k]\n\ndef main():\n    n, k, S, a = read_input()\n    print(solve(n, k, S, a))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    for i in range(n):\n        x = a[i]\n        j = 0\n        while x > 0:\n            if x % k == 0:\n                x //= k\n                j += 1\n            else:\n                if x % k!= 1:\n                    print(\"NO\")\n                    return\n                x -= 1\n                j += 1\n        a[i] = j\n\n    for i in range(n):\n        if a[i] > 0:\n            for j in range(i + 1, n):\n                a[j] -= a[i]\n                if a[j] < 0:\n                    print(\"NO\")\n                    return\n\n    print(\"YES\")\n\nt = int(input())\nfor _ in range(t):\n    solve()"}
{"solution": "def get_divisors(n):\n    \"\"\"Return the number of divisors of n.\"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef main():\n    \"\"\"Calculate the sum of divisors for all combinations of i, j, and k.\"\"\"\n    a, b, c = map(int, input().split())\n    total = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                total += get_divisors(i * j * k)\n    print(total % (2**30))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    neighbors = []\n    idx = state.index('X')\n    if idx == 0:\n        neighbors.append(swap(state, 0, 1))\n        neighbors.append(swap(state, 0, 2))\n    elif idx == 1:\n        neighbors.append(swap(state, 1, 0))\n        neighbors.append(swap(state, 1, 3))\n    elif idx == 2:\n        neighbors.append(swap(state, 2, 0))\n        neighbors.append(swap(state, 2, 3))\n    elif idx == 3:\n        neighbors.append(swap(state, 3, 1))\n        neighbors.append(swap(state, 3, 2))\n    return neighbors\n\ndef swap(state, i, j):\n    state = list(state)\n    state[i], state[j] = state[j], state[i]\n    return ''.join(state)\n\ndef bfs(start):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        current = queue.popleft()\n        for neighbor in get_neighbors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return visited\n\ndef can_be_same_configuration(bessie, elsie):\n    bessie_start = ''.join(bessie)\n    elsie_start = ''.join(elsie)\n    \n    bessie_reachable = bfs(bessie_start)\n    elsie_reachable = bfs(elsie_start)\n    \n    return not bessie_reachable.isdisjoint(elsie_reachable)\n\nbessie = [input().strip() for _ in range(2)]\nelsie = [input().strip() for _ in range(2)]\n\nif can_be_same_configuration(bessie, elsie):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def convert_to_decimal(n, k):\n    decimal = 0\n    power = 0\n    for digit in reversed(k):\n        decimal += int(digit) * (n ** power)\n        power += 1\n    return decimal\n\nn = int(input())\nk = input()\n\nprint(convert_to_decimal(n, k))"}
{"solution": "def is_unimodal(arr):\n    increasing = decreasing = False\n    constant = True\n\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            if decreasing:\n                return False\n            increasing = True\n            constant = False\n        elif arr[i] < arr[i - 1]:\n            if increasing:\n                decreasing = True\n            constant = False\n        else:\n            if decreasing:\n                return False\n\n    return True\n\n\nn = int(input())\narr = list(map(int, input().split()))\n\nprint(\"YES\" if is_unimodal(arr) else \"NO\")"}
{"solution": "def solve(n, k):\n    if n == k:\n        return 1\n\n    def check(x):\n        if x > n:\n            return 0\n        if x == 1:\n            return n - x + 1\n        if x % 2 == 0:\n            return check(x // 2) + (n - x + 1) // 2\n        else:\n            return check(x - 1)\n\n    left, right = 1, n\n    while left < right:\n        mid = (left + right + 1) // 2\n        if check(mid) >= k:\n            left = mid\n        else:\n            right = mid - 1\n    return left\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve():\n    n, m, x, y, vx, vy = map(int, input().split())\n\n    if vx == 0:\n        if vy > 0:\n            return f\"{x} {m}\"\n        else:\n            return f\"{x} 0\"\n\n    if vy == 0:\n        if vx > 0:\n            return f\"{n} {y}\"\n        else:\n            return f\"0 {y}\"\n\n    dx = n - x if vx > 0 else x\n    dy = m - y if vy > 0 else y\n\n    g = gcd(dx, dy)\n\n    if dx // g!= dy // g:\n        return \"-1\"\n\n    if vx > 0:\n        x = n\n    else:\n        x = 0\n\n    if vy > 0:\n        y = m\n    else:\n        y = 0\n\n    return f\"{x} {y}\"\n\nprint(solve())"}
{"solution": "def can_place_paintings():\n    a1, b1 = map(int, input().split())\n    a2, b2 = map(int, input().split())\n    a3, b3 = map(int, input().split())\n\n    def fits(w1, h1, w2, h2, W, H):\n        return (w1 + w2 <= W and max(h1, h2) <= H) or (h1 + h2 <= H and max(w1, w2) <= W)\n\n    if (fits(a2, b2, a3, b3, a1, b1) or fits(b2, a2, a3, b3, a1, b1) or\n        fits(a2, b2, b3, a3, a1, b1) or fits(b2, a2, b3, a3, a1, b1) or\n        fits(a3, b3, a2, b2, a1, b1) or fits(b3, a3, a2, b2, a1, b1) or\n        fits(a3, b3, b2, a2, a1, b1) or fits(b3, a3, b2, a2, a1, b1)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\ncan_place_paintings()"}
{"solution": "def calculate_written_numbers(b1, q, limit, bad_numbers):\n    \"\"\"\n    Calculate the number of progression terms that will be written on the board.\n\n    Args:\n    b1 (int): The initial term of the geometric progression.\n    q (int): The common ratio of the geometric progression.\n    limit (int): The absolute value of the maximal number that can be written on the board.\n    bad_numbers (list): A list of distinct integers that will never be written on the board.\n\n    Returns:\n    int or str: The number of progression terms that will be written on the board if it is finite, or \"inf\" otherwise.\n    \"\"\"\n    if q == 1:\n        # If the common ratio is 1, the progression is constant\n        if b1 in bad_numbers:\n            return 0\n        elif abs(b1) <= limit:\n            return \"inf\"\n        else:\n            return 0\n\n    if q == 0:\n        # If the common ratio is 0, the progression is constant after the first term\n        if b1 in bad_numbers:\n            return 0\n        elif abs(b1) <= limit:\n            return 1\n        else:\n            return 0\n\n    if q == -1:\n        # If the common ratio is -1, the progression alternates between two values\n        if b1 in bad_numbers:\n            if -b1 in bad_numbers:\n                return 0\n            elif abs(-b1) <= limit:\n                return \"inf\"\n            else:\n                return 0\n        elif abs(b1) <= limit:\n            if -b1 in bad_numbers:\n                return \"inf\"\n            elif abs(-b1) <= limit:\n                return \"inf\"\n            else:\n                return 1\n        else:\n            return 0\n\n    written_numbers = 0\n    current_term = b1\n\n    while abs(current_term) <= limit:\n        if current_term not in bad_numbers:\n            written_numbers += 1\n        current_term *= q\n\n    if abs(current_term) > limit:\n        return written_numbers\n    else:\n        return \"inf\"\n\n\n# Read input\nb1, q, limit, _ = map(int, input().split())\nbad_numbers = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = calculate_written_numbers(b1, q, limit, bad_numbers)\nprint(result)"}
{"solution": "def find_frame(n, m, screen):\n    min_x, max_x, min_y, max_y = float('inf'), float('-inf'), float('inf'), float('-inf')\n    \n    for i in range(n):\n        for j in range(m):\n            if screen[i][j] == 'w':\n                min_x, max_x = min(min_x, j), max(max_x, j)\n                min_y, max_y = min(min_y, i), max(max_y, i)\n    \n    size = max(max_x - min_x, max_y - min_y) + 1\n    \n    if size == 1:\n        if screen[min_y][min_x] == 'w':\n            screen[min_y][min_x] = '+'\n        return screen\n    \n    for i in range(min_y, max_y + 1):\n        if screen[i][min_x]!= 'w':\n            screen[i] = screen[i][:min_x] + '+' + screen[i][min_x + 1:]\n        if screen[i][max_x]!= 'w':\n            screen[i] = screen[i][:max_x] + '+' + screen[i][max_x + 1:]\n    \n    for j in range(min_x, max_x + 1):\n        if screen[min_y][j]!= 'w':\n            screen[min_y] = screen[min_y][:j] + '+' + screen[min_y][j + 1:]\n        if screen[max_y][j]!= 'w':\n            screen[max_y] = screen[max_y][:j] + '+' + screen[max_y][j + 1:]\n    \n    return screen\n\n\nn, m = map(int, input().split())\nscreen = [list(input()) for _ in range(n)]\n\nmin_size = float('inf')\nbest_frame = None\n\nfor i in range(n):\n    for j in range(m):\n        for size in range(1, min(n, m) + 1):\n            if i + size > n or j + size > m:\n                break\n            frame = [row[:] for row in screen]\n            for x in range(i, i + size):\n                if frame[x][j]!= 'w':\n                    frame[x][j] = '+'\n                if frame[x][j + size - 1]!= 'w':\n                    frame[x][j + size - 1] = '+'\n            for y in range(j, j + size):\n                if frame[i][y]!= 'w':\n                    frame[i][y] = '+'\n                if frame[i + size - 1][y]!= 'w':\n                    frame[i + size - 1][y] = '+'\n            valid = True\n            for x in range(n):\n                for y in range(m):\n                    if frame[x][y] == 'w' and (x < i or x >= i + size or y < j or y >= j + size):\n                        valid = False\n                        break\n                if not valid:\n                    break\n            if valid and size < min_size:\n                min_size = size\n                best_frame = frame\n\nif best_frame is None:\n    print(-1)\nelse:\n    for row in best_frame:\n        print(''.join(row))"}
{"solution": "def extended_gcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x, y = extended_gcd(b % a, a)\n        return gcd, y - (b // a) * x, x\n\ndef solve(n, a, b):\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd!= 0:\n        return None\n    x *= n // gcd\n    y *= n // gcd\n    if x < 0:\n        k = (-x) // (b // gcd)\n        x += k * (b // gcd)\n        y -= k * (a // gcd)\n    if y < 0:\n        k = (-y) // (a // gcd)\n        x -= k * (b // gcd)\n        y += k * (a // gcd)\n    return x, y\n\nn = int(input())\na = int(input())\nb = int(input())\n\nsolution = solve(n, a, b)\nif solution is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(*solution)"}
{"solution": "def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\ns = int(input())\nprint(number_to_words(s))"}
{"solution": "def max_consecutive_elements_to_erase(n, array):\n    \"\"\"\n    Calculate the maximum number of consecutive elements that can be erased from the array.\n\n    Args:\n    n (int): The number of elements in the array.\n    array (list): The array of integers.\n\n    Returns:\n    int: The maximum number of consecutive elements that can be erased.\n    \"\"\"\n    if n <= 2:\n        return n - 1\n\n    max_erase = 0\n    for i in range(n - 1):\n        # Calculate the difference between the current element and the next element\n        diff = array[i + 1] - array[i]\n        \n        # If the difference is greater than 1, it means we can erase elements in between\n        if diff > 1:\n            # Calculate the number of elements that can be erased\n            erase = diff - 1\n            \n            # Update the maximum number of elements that can be erased\n            max_erase = max(max_erase, erase)\n\n    # Check if we can erase elements from the start or end of the array\n    max_erase = max(max_erase, array[0] - 1, 1000 - array[-1] + 1)\n\n    return max_erase\n\n\n# Read the input\nn = int(input())\narray = list(map(int, input().split()))\n\n# Calculate and print the maximum number of consecutive elements that can be erased\nprint(max_consecutive_elements_to_erase(n, array))"}
{"solution": "def find_equator_day(n, problems):\n    \"\"\"\n    Determine the index of day when Polycarp will celebrate the equator.\n\n    Args:\n    n (int): The number of days to prepare for the programming contests.\n    problems (list): A sequence of the number of problems Polycarp will solve each day.\n\n    Returns:\n    int: The index of the day when Polycarp will celebrate the equator.\n    \"\"\"\n    total_problems = sum(problems)\n    cumulative_sum = 0\n\n    for i, problems_solved in enumerate(problems):\n        cumulative_sum += problems_solved\n        if cumulative_sum >= total_problems / 2:\n            return i + 1\n\nn = int(input())\nproblems = list(map(int, input().split()))\nprint(find_equator_day(n, problems))"}
{"solution": "import sys\nfrom collections import deque\n\ndef read_input():\n    n = int(sys.stdin.readline())\n    board = []\n    for _ in range(n):\n        row = list(map(int, sys.stdin.readline().split()))\n        board.append(row)\n    return n, board\n\ndef find_position(board, target):\n    n = len(board)\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == target:\n                return (i, j)\n    return None\n\ndef knight_moves(position):\n    i, j = position\n    moves = []\n    for di, dj in [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]:\n        ni, nj = i + di, j + dj\n        if 0 <= ni < 8 and 0 <= nj < 8:\n            moves.append((ni, nj))\n    return moves\n\ndef bishop_moves(position):\n    i, j = position\n    moves = []\n    for di, dj in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:\n        ni, nj = i + di, j + dj\n        while 0 <= ni < 8 and 0 <= nj < 8:\n            moves.append((ni, nj))\n            ni += di\n            nj += dj\n    return moves\n\ndef rook_moves(position):\n    i, j = position\n    moves = []\n    for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        ni, nj = i + di, j + dj\n        while 0 <= ni < 8 and 0 <= nj < 8:\n            moves.append((ni, nj))\n            ni += di\n            nj += dj\n    return moves\n\ndef bfs(n, board):\n    queue = deque([(find_position(board, 1), 0, 0, None)])\n    visited = set([find_position(board, 1)])\n    while queue:\n        position, steps, replacements, piece = queue.popleft()\n        if board[position[0]][position[1]] == n * n:\n            return steps, replacements\n        for new_piece in ['knight', 'bishop', 'rook']:\n            if new_piece!= piece:\n                new_replacements = replacements + 1\n            else:\n                new_replacements = replacements\n            if new_piece == 'knight':\n                moves = knight_moves(position)\n            elif new_piece == 'bishop':\n                moves = bishop_moves(position)\n            else:\n                moves = rook_moves(position)\n            for move in moves:\n                if move not in visited:\n                    visited.add(move)\n                    queue.append((move, steps + 1, new_replacements, new_piece))\n    return None\n\ndef main():\n    n, board = read_input()\n    result = bfs(n, board)\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_time(n, m, k, a, b):\n    # Calculate the position of Edward's and Natasha's apartments\n    edward_pod = (a - 1) // (m * k) + 1\n    edward_et = ((a - 1) % (m * k)) // k + 1\n    natasha_pod = (b - 1) // (m * k) + 1\n    natasha_et = ((b - 1) % (m * k)) // k + 1\n\n    # Calculate the distance between the two apartments\n    pod_distance = abs(edward_pod - natasha_pod)\n    if pod_distance > n // 2:\n        pod_distance = n - pod_distance\n\n    # Calculate the time to move between the two apartments\n    time = 0\n    if edward_et > 1:\n        time += 10 + (edward_et - 1)\n    time += min(pod_distance * 15, (n - pod_distance) * 15)\n    if natasha_et > 1:\n        time += 5 * (natasha_et - 1)\n\n    # Calculate the time to move between the two apartments using the stairs\n    time_stairs = 0\n    if edward_et > 1:\n        time_stairs += 5 * (edward_et - 1)\n    time_stairs += min(pod_distance * 15, (n - pod_distance) * 15)\n    if natasha_et > 1:\n        time_stairs += 5 * (natasha_et - 1)\n\n    # Return the minimum time\n    return min(time, time_stairs)\n\n\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\nprint(calculate_time(n, m, k, a, b))"}
{"solution": "def is_divisible_by_64(s):\n    \"\"\"\n    Checks if it's possible to remove some digits from a binary string\n    to get a number divisible by 64 in the binary numerical system.\n    \n    Args:\n    s (str): A non-empty binary string.\n    \n    Returns:\n    bool: True if it's possible to get a number divisible by 64, False otherwise.\n    \"\"\"\n    # Check if the string has at least 6 digits (minimum for a binary number divisible by 64)\n    if len(s) < 6:\n        return False\n    \n    # Check if the string ends with '000000' (a binary number divisible by 64 must end with 6 zeros)\n    if not s.endswith('0' * 6):\n        # If not, check if there are at least 6 zeros in the string\n        if s.count('0') < 6:\n            return False\n        \n        # If there are at least 6 zeros, check if there is a '1' before the last 6 zeros\n        if '1' not in s[:-6]:\n            return False\n    \n    # If all checks pass, it's possible to get a number divisible by 64\n    return True\n\n# Read the input string\ns = input()\n\n# Print the result\nprint('yes' if is_divisible_by_64(s) else 'no')"}
{"solution": "def transform_string(s):\n    result = []\n    target = 'abcdefghijklmnopqrstuvwxyz'\n    target_index = 0\n\n    for char in s:\n        if char >= target[target_index]:\n            result.append(char)\n            if char == target[target_index]:\n                target_index += 1\n                if target_index == len(target):\n                    break\n\n    if target_index < len(target):\n        return -1\n\n    remaining_chars = list(target[target_index:])\n    result.extend(remaining_chars)\n\n    for i in range(len(result)):\n        if result[i] == 'z':\n            continue\n        next_char = chr(ord(result[i]) + 1)\n        if next_char in target:\n            result[i] = next_char\n\n    return ''.join(result)\n\n\ns = input()\nprint(transform_string(s))"}
{"solution": "import math\n\ndef calculate_expected_value(n, m, r, k):\n    total_positions = (n - r + 1) * (m - r + 1)\n    max_fish_in_scoop = min(r * r, k)\n\n    if k <= max_fish_in_scoop:\n        return (k * (max_fish_in_scoop - 1) + (total_positions - (n - r + 1) * (m - r + 1) + k)) / total_positions\n\n    expected_value = 0\n    for i in range(1, max_fish_in_scoop + 1):\n        expected_value += (i * (i - 1) * math.comb(max_fish_in_scoop, i) * math.comb(k - i, max_fish_in_scoop - i)) / math.comb(k, max_fish_in_scoop)\n\n    return expected_value / total_positions\n\nn, m, r, k = map(int, input().split())\nprint(calculate_expected_value(n, m, r, k))"}
{"solution": "def maximize_product(n, arr):\n    \"\"\"\n    This function maximizes the product of an array by applying the operation a_i := -a_i - 1.\n    \n    Parameters:\n    n (int): The number of elements in the array.\n    arr (list): The input array.\n    \n    Returns:\n    list: The array with the maximal possible product of elements.\n    \"\"\"\n    \n    # Count the number of zeros in the array\n    zero_count = arr.count(0)\n    \n    # Count the number of negative numbers in the array\n    negative_count = sum(1 for num in arr if num < 0)\n    \n    # If there are an odd number of negative numbers, we need to make one of them positive\n    # to maximize the product. We choose the smallest negative number to make positive.\n    if negative_count % 2!= 0:\n        min_negative_index = arr.index(min(arr))\n        arr[min_negative_index] = -arr[min_negative_index] - 1\n    \n    # If there are no zeros and an even number of negative numbers, we can make all\n    # numbers negative to maximize the product.\n    if zero_count == 0 and negative_count % 2 == 0:\n        arr = [-num - 1 if num >= 0 else num for num in arr]\n    \n    return arr\n\n# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Maximize the product and print the result\nresult = maximize_product(n, arr)\nprint(*result)"}
{"solution": "import math\n\ndef kth_smallest_divisor(n, k):\n    divisors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    divisors = sorted(list(divisors))\n    if k > len(divisors):\n        return -1\n    else:\n        return divisors[k - 1]\n\nn, k = map(int, input().split())\nprint(kth_smallest_divisor(n, k))"}
{"solution": "from collections import defaultdict\nfrom itertools import permutations\n\ndef get_digits(cube):\n    digits = set()\n    for i in range(6):\n        for j in range(i+1, 6):\n            if cube[i] == cube[j]:\n                continue\n            if (cube[i] == 6 and cube[j] == 9) or (cube[i] == 9 and cube[j] == 6):\n                continue\n            digits.add(cube[i])\n            digits.add(cube[j])\n    return digits\n\ndef get_all_digits(cubes):\n    all_digits = set()\n    for cube in cubes:\n        all_digits.update(get_digits(cube))\n    return all_digits\n\ndef get_max_number(cubes):\n    all_digits = get_all_digits(cubes)\n    if 0 not in all_digits:\n        return 0\n    if len(cubes) == 1:\n        return max(all_digits)\n    if len(cubes) == 2:\n        max_num = 0\n        for i in range(10):\n            if i not in all_digits:\n                continue\n            for j in range(10):\n                if j not in all_digits:\n                    continue\n                if i == 0 and j == 0:\n                    continue\n                max_num = max(max_num, i*10 + j)\n        return max_num\n    max_num = 0\n    for i in range(10):\n        if i not in all_digits:\n            continue\n        for j in range(10):\n            if j not in all_digits:\n                continue\n            for k in range(10):\n                if k not in all_digits:\n                    continue\n                if i == 0 and j == 0 and k == 0:\n                    continue\n                max_num = max(max_num, i*100 + j*10 + k)\n    return max_num\n\ndef main():\n    n = int(input())\n    cubes = []\n    for _ in range(n):\n        cube = list(map(int, input().split()))\n        cubes.append(cube)\n    max_num = get_max_number(cubes)\n    print(max_num)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef k_rounding(n, k):\n    \"\"\"\n    Calculate the k-rounding of a given positive integer n.\n    \n    The k-rounding of n is the minimum positive integer x, such that x ends with k or more zeros in base 10 and is divisible by n.\n    \n    Parameters:\n    n (int): The input number.\n    k (int): The number of trailing zeros.\n    \n    Returns:\n    int: The k-rounding of n.\n    \"\"\"\n    \n    # Calculate the number of trailing zeros needed\n    trailing_zeros = 10 ** k\n    \n    # Calculate the least common multiple of n and the number of trailing zeros\n    lcm = (n * trailing_zeros) // math.gcd(n, trailing_zeros)\n    \n    return lcm\n\n# Read the input\nn, k = map(int, input().split())\n\n# Calculate and print the k-rounding of n\nprint(k_rounding(n, k))"}
{"solution": "def transform_matrix(n, m, A):\n    operations = []\n    B = [[0] * m for _ in range(n)]\n    \n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                operations.append((i + 1, j + 1))\n                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1\n    \n    for i in range(n):\n        for j in range(m):\n            if A[i][j] == 1 and B[i][j] == 0:\n                return -1\n    \n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 0 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 0:\n                return -1\n            if A[i][j] == 1 and A[i][j + 1] == 0 and A[i + 1][j] == 0 and A[i + 1][j + 1] == 1:\n                return -1\n    \n    return operations\n\n# Input reading\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\n# Process the transformation\nresult = transform_matrix(n, m, A)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for x, y in result:\n        print(x, y)"}
{"solution": "import sys\n\ndef read_input():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef calculate_probabilities(r, s, p):\n    total = r + s + p\n    probabilities = [0.0, 0.0, 0.0]\n\n    if total == 3:\n        probabilities[0] = r / total\n        probabilities[1] = s / total\n        probabilities[2] = p / total\n    else:\n        if r == 0:\n            probabilities[1] = s / (s + p)\n            probabilities[2] = p / (s + p)\n        elif s == 0:\n            probabilities[0] = r / (r + p)\n            probabilities[2] = p / (r + p)\n        elif p == 0:\n            probabilities[0] = r / (r + s)\n            probabilities[1] = s / (r + s)\n        else:\n            probabilities[0] = (r * (s + p)) / ((r + s) * (r + p))\n            probabilities[1] = (s * (r + p)) / ((r + s) * (s + p))\n            probabilities[2] = (p * (r + s)) / ((r + p) * (s + p))\n\n    return probabilities\n\ndef main():\n    r, s, p = read_input()\n    probabilities = calculate_probabilities(r, s, p)\n    print(' '.join(map(str, probabilities)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_time_together(l1, r1, l2, r2, k):\n    \"\"\"\n    Calculate the number of minutes Sonya and Filya will be able to spend together.\n\n    Args:\n        l1 (int): The start minute of Sonya's awake time.\n        r1 (int): The end minute of Sonya's awake time.\n        l2 (int): The start minute of Filya's visit time.\n        r2 (int): The end minute of Filya's visit time.\n        k (int): The minute when Sonya prinks.\n\n    Returns:\n        int: The number of minutes Sonya and Filya will be able to spend together.\n    \"\"\"\n    # Calculate the overlap between Sonya's awake time and Filya's visit time\n    overlap_start = max(l1, l2)\n    overlap_end = min(r1, r2)\n\n    # If there is no overlap, return 0\n    if overlap_start > overlap_end:\n        return 0\n\n    # Calculate the total overlap time\n    total_overlap = overlap_end - overlap_start + 1\n\n    # If Sonya prinks during the overlap time, subtract 1 from the total overlap time\n    if overlap_start <= k <= overlap_end:\n        total_overlap -= 1\n\n    return total_overlap\n\n\n# Read the input values\nl1, r1, l2, r2, k = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_time_together(l1, r1, l2, r2, k)\nprint(result)"}
{"solution": "import sys\n\ndef main():\n    N, M = map(int, sys.stdin.readline().split())\n\n    A = []\n    B = []\n    C = []\n    D = []\n    E = []\n    F = []\n\n    for _ in range(N):\n        a, b, c = map(int, sys.stdin.readline().split())\n        A.append(a)\n        B.append(b)\n        C.append(c)\n\n    for _ in range(M):\n        d, e, f = map(int, sys.stdin.readline().split())\n        D.append(d)\n        E.append(e)\n        F.append(f)\n\n    def check(x, y):\n        for i in range(N):\n            if A[i] <= x <= B[i] and C[i] == y:\n                return False\n        for i in range(M):\n            if E[i] <= y <= F[i] and D[i] == x:\n                return False\n        return True\n\n    def check_range(x1, x2, y):\n        if x1 > x2:\n            x1, x2 = x2, x1\n        for i in range(N):\n            if A[i] <= x1 <= B[i] <= x2 and C[i] == y:\n                return False\n        return True\n\n    def check_range2(y1, y2, x):\n        if y1 > y2:\n            y1, y2 = y2, y1\n        for i in range(M):\n            if E[i] <= y1 <= F[i] <= y2 and D[i] == x:\n                return False\n        return True\n\n    def calc(x, y):\n        if not check(x, y):\n            return 0\n        if x > 0 and not check_range(0, x, y):\n            return 0\n        if x < 0 and not check_range(x, 0, y):\n            return 0\n        if y > 0 and not check_range2(0, y, x):\n            return 0\n        if y < 0 and not check_range2(y, 0, x):\n            return 0\n        return 1\n\n    ans = 0\n    for x in range(-1000000000, 1000000001):\n        if not check_range2(-1000000000, 1000000000, x):\n            continue\n        l = -1000000000\n        r = 1000000000\n        while l < r:\n            m = (l + r + 1) // 2\n            if calc(x, m):\n                l = m\n            else:\n                r = m - 1\n        u = l\n        l = -1000000000\n        r = 1000000000\n        while l < r:\n            m = (l + r) // 2\n            if calc(x, m):\n                r = m\n            else:\n                l = m + 1\n        d = l\n        if u > d:\n            u, d = d, u\n        ans += d - u + 1\n        if ans > 1000000000000000000:\n            print(\"INF\")\n            return\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def will_pineapple_bark(t, s, x):\n    \"\"\"\n    Determine if the pineapple will bark at time x.\n\n    Args:\n    t (int): The time the pineapple barks for the first time.\n    s (int): The pineapple barking interval.\n    x (int): The time Barney wants to eat the pineapple.\n\n    Returns:\n    bool: True if the pineapple will bark at time x, False otherwise.\n    \"\"\"\n    # Calculate the number of intervals that have passed\n    intervals = (x - t) // s\n    \n    # Check if the pineapple will bark at time x\n    # If x is equal to t plus an integer multiple of s, or\n    # if x is equal to t plus an integer multiple of s plus 1\n    return (x == t + intervals * s) or (x == t + intervals * s + 1)\n\n\n# Read input\nt, s, x = map(int, input().split())\n\n# Check if the pineapple will bark at time x\nif will_pineapple_bark(t, s, x):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef find_nested_segments(n, segments):\n    sorted_segments = sorted(enumerate(segments), key=lambda x: (x[1][0], -x[1][1]))\n    max_right = -1\n    max_right_index = -1\n    for i, (left, right) in sorted_segments:\n        if right <= max_right:\n            return f\"{i + 1} {max_right_index + 1}\"\n        if right > max_right:\n            max_right = right\n            max_right_index = i\n    return \"-1 -1\"\n\nn = int(sys.stdin.readline())\nsegments = []\nfor _ in range(n):\n    left, right = map(int, sys.stdin.readline().split())\n    segments.append((left, right))\n\nprint(find_nested_segments(n, segments))"}
{"solution": "def decode_genome(n, s):\n    counts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\n    unknowns = 0\n\n    for char in s:\n        if char in counts:\n            counts[char] += 1\n        elif char == '?':\n            unknowns += 1\n\n    target_count = (n + 3) // 4\n\n    for char in counts:\n        if counts[char] > target_count:\n            return \"===\"\n\n    remaining = {}\n    for char in counts:\n        remaining[char] = target_count - counts[char]\n\n    result = list(s)\n    for i in range(n):\n        if result[i] == '?':\n            for char in remaining:\n                if remaining[char] > 0:\n                    result[i] = char\n                    remaining[char] -= 1\n                    break\n\n    if any(count > 0 for count in remaining.values()):\n        return \"===\"\n\n    return \"\".join(result)\n\n\nn = int(input())\ns = input()\nprint(decode_genome(n, s))"}
{"solution": "def check_win(board, row, col, char):\n    # Check horizontal\n    if board[row].count(char) == 3 and '.' in board[row]:\n        return True\n\n    # Check vertical\n    vertical = [board[i][col] for i in range(4)]\n    if vertical.count(char) == 3 and '.' in vertical:\n        return True\n\n    # Check main diagonal\n    if row == col:\n        diagonal = [board[i][i] for i in range(4)]\n        if diagonal.count(char) == 3 and '.' in diagonal:\n            return True\n\n    # Check anti-diagonal\n    if row + col == 3:\n        anti_diagonal = [board[i][3-i] for i in range(4)]\n        if anti_diagonal.count(char) == 3 and '.' in anti_diagonal:\n            return True\n\n    return False\n\n\ndef check_win_by_placing(board, row, col, char):\n    # Check horizontal\n    if board[row].count(char) == 2 and board[row].count('.') == 1:\n        return True\n\n    # Check vertical\n    vertical = [board[i][col] for i in range(4)]\n    if vertical.count(char) == 2 and vertical.count('.') == 1:\n        return True\n\n    # Check main diagonal\n    if row == col:\n        diagonal = [board[i][i] for i in range(4)]\n        if diagonal.count(char) == 2 and diagonal.count('.') == 1:\n            return True\n\n    # Check anti-diagonal\n    if row + col == 3:\n        anti_diagonal = [board[i][3-i] for i in range(4)]\n        if anti_diagonal.count(char) == 2 and anti_diagonal.count('.') == 1:\n            return True\n\n    return False\n\n\ndef can_win(board):\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                board[i] = board[i][:j] + 'x' + board[i][j+1:]\n                if check_win_by_placing(board, i, j, 'x'):\n                    return True\n                board[i] = board[i][:j] + '.' + board[i][j+1:]\n    return False\n\n\nboard = [input() for _ in range(4)]\nif can_win(board):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def can_divide_array(n, a):\n    total_sum = sum(a)\n    if total_sum % 2!= 0:\n        return False\n\n    target_sum = total_sum // 2\n    prefix_sum = 0\n    for i in range(n):\n        prefix_sum += a[i]\n        if prefix_sum == target_sum:\n            return True\n        if prefix_sum > target_sum and prefix_sum - a[i] == target_sum - (total_sum - prefix_sum + a[i]):\n            return True\n        if prefix_sum < target_sum and prefix_sum + (total_sum - prefix_sum - a[i]) == target_sum - a[i]:\n            return True\n\n    return False\n\nn = int(input())\na = list(map(int, input().split()))\n\nif can_divide_array(n, a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def can_recover(n, k, a, b):\n    zeros = [i for i, x in enumerate(a) if x == 0]\n    b.sort(reverse=True)\n    a_copy = a[:]\n\n    for i, zero in enumerate(zeros):\n        a_copy[zero] = b[i]\n\n    for i in range(1, n):\n        if a_copy[i] < a_copy[i - 1]:\n            return \"Yes\"\n\n    return \"No\"\n\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(can_recover(n, k, a, b))"}
{"solution": "def can_distribute_grapes(x, y, z, a, b, c):\n    # Check if Andrew can eat enough green grapes\n    if x > a:\n        return False\n\n    # Calculate the remaining green grapes after Andrew eats\n    remaining_green = a - x\n\n    # Calculate the total grapes available for Dmitry and Michal\n    total_available = remaining_green + b + c\n\n    # Check if Dmitry and Michal can eat enough grapes\n    if total_available < y + z:\n        return False\n\n    # Check if Dmitry can eat enough grapes\n    if y > remaining_green + b:\n        return False\n\n    return True\n\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\nif can_distribute_grapes(x, y, z, a, b, c):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def is_accident_possible(traffic_lights):\n    for i in range(4):\n        if traffic_lights[i][3] == 1 and (traffic_lights[i][0] == 1 or traffic_lights[i][1] == 1 or traffic_lights[i][2] == 1):\n            return True\n        if traffic_lights[i][3] == 1 and i == 0 and (traffic_lights[3][0] == 1 or traffic_lights[3][1] == 1 or traffic_lights[3][2] == 1):\n            return True\n        if traffic_lights[i][3] == 1 and i == 3 and (traffic_lights[0][0] == 1 or traffic_lights[0][1] == 1 or traffic_lights[0][2] == 1):\n            return True\n    return False\n\ntraffic_lights = []\nfor _ in range(4):\n    traffic_lights.append(list(map(int, input().split())))\n\nif is_accident_possible(traffic_lights):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def get_coordinates(digit):\n    keypad = {\n        '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2),\n        '0': (3, 1)\n    }\n    return keypad[digit]\n\ndef get_vectors(number):\n    vectors = []\n    for i in range(len(number) - 1):\n        x1, y1 = get_coordinates(number[i])\n        x2, y2 = get_coordinates(number[i + 1])\n        vectors.append((x2 - x1, y2 - y1))\n    return vectors\n\ndef is_unique_finger_movement(n, number):\n    original_vectors = get_vectors(number)\n    for i in range(10**(n-1), 10**n):\n        candidate = str(i).zfill(n)\n        if candidate!= number:\n            if get_vectors(candidate) == original_vectors:\n                return \"NO\"\n    return \"YES\"\n\nn = int(input())\nnumber = input().strip()\nprint(is_unique_finger_movement(n, number))"}
{"solution": "import sys\n\ndef main():\n    n, f = map(int, sys.stdin.readline().split())\n    days = []\n    for _ in range(n):\n        k, l = map(int, sys.stdin.readline().split())\n        days.append((k, l))\n\n    days.sort(key=lambda x: min(x[0], x[1]) - min(x[0]*2, x[1]), reverse=True)\n\n    sold = 0\n    for i in range(n):\n        if i < f:\n            sold += min(days[i][0]*2, days[i][1])\n        else:\n            sold += min(days[i][0], days[i][1])\n\n    print(sold)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef calculate_messiness(n, k):\n    max_swaps = min(k, n // 2)\n    return (n * (n - 1)) // 2 - max_swaps * (max_swaps - 1)\n\nn, k = map(int, input().split())\nprint(calculate_messiness(n, k))"}
{"solution": "import math\n\ndef min_coins(N, M, K, L):\n    if M > N:\n        return -1\n\n    max_new_coins = N - K\n    min_coins_per_friend = math.ceil(L / M)\n\n    if min_coins_per_friend > max_new_coins:\n        return -1\n\n    return min_coins_per_friend\n\nN, M, K, L = map(int, input().split())\nprint(min_coins(N, M, K, L))"}
{"solution": "n, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\nmin_row, max_row = n, -1\nmin_col, max_col = m, -1\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 'B':\n            min_row = min(min_row, i)\n            max_row = max(max_row, i)\n            min_col = min(min_col, j)\n            max_col = max(max_col, j)\n\nif min_row == n:\n    print(1)\nelse:\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    if side_length > n or side_length > m:\n        print(-1)\n    else:\n        min_paint = float('inf')\n        for i in range(n - side_length + 1):\n            for j in range(m - side_length + 1):\n                paint_count = 0\n                for x in range(i, i + side_length):\n                    for y in range(j, j + side_length):\n                        if grid[x][y] == 'W':\n                            paint_count += 1\n                min_paint = min(min_paint, paint_count)\n        print(min_paint)"}
{"solution": "def can_transform_stones(n, x, y):\n    \"\"\"\n    Determine if the stones in the garden can be transformed from one state to another.\n\n    Args:\n    n (int): The number of piles with stones in the garden.\n    x (list): The initial number of stones in each pile.\n    y (list): The final number of stones in each pile.\n\n    Returns:\n    bool: True if the stones can be transformed, False otherwise.\n    \"\"\"\n    # Calculate the total number of stones in the initial and final states\n    total_x = sum(x)\n    total_y = sum(y)\n\n    # If the total number of stones is different, it's impossible to transform\n    if total_x!= total_y:\n        return False\n\n    # Sort the initial and final states\n    x.sort()\n    y.sort()\n\n    # Compare the sorted states\n    for i in range(n):\n        # If the difference between the two states is more than 1, it's impossible to transform\n        if abs(x[i] - y[i]) > 1:\n            return False\n\n    # If all checks pass, it's possible to transform the stones\n    return True\n\n\n# Read the input\nn = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Determine if the stones can be transformed\nif can_transform_stones(n, x, y):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def min_angle_diff(n, angles):\n    total_angle = sum(angles)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + angles[i]\n    \n    min_diff = float('inf')\n    for i in range(n):\n        left_angle = prefix_sum[i]\n        right_angle = total_angle - left_angle\n        min_diff = min(min_diff, abs(left_angle - right_angle))\n    \n    return min_diff\n\nn = int(input())\nangles = list(map(int, input().split()))\nprint(min_angle_diff(n, angles))"}
{"solution": "def mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_power(a, b, m):\n    result = 1\n    while b > 0:\n        if b % 2 == 1:\n            result = (result * a) % m\n        a = (a * a) % m\n        b //= 2\n    return result\n\ndef mod_factorial(n, m):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % m\n    return result\n\ndef mod_combination(n, k, m):\n    if k > n:\n        return 0\n    numerator = mod_factorial(n, m)\n    denominator = (mod_factorial(k, m) * mod_factorial(n - k, m)) % m\n    return (numerator * mod_inverse(denominator, m)) % m\n\ndef solve(n, m):\n    mod = 10**9 + 7\n    result = 0\n    for i in range(n + 1):\n        combination = mod_combination(n, i, mod)\n        power = mod_power(m - i + 1, i, mod)\n        result = (result + combination * power) % mod\n    return result\n\nn, m = map(int, input().split())\nprint(solve(n, m))"}
{"solution": "import math\n\ndef pythagorean_triple(n):\n    if n == 1:\n        return -1\n    elif n % 2 == 1:\n        m = (n**2 - 1) // 2\n        k = m + 1\n    else:\n        m = n**2 // 4 - 1\n        k = m + 2\n    return m, k\n\nn = int(input())\nm, k = pythagorean_triple(n)\nif m == -1:\n    print(-1)\nelse:\n    print(m, k)"}
{"solution": "def check_remainders(n, k):\n    \"\"\"\n    Checks if all remainders of n divided by integers from 1 to k are distinct.\n\n    Args:\n        n (int): The number to check remainders for.\n        k (int): The upper limit for the range of divisors.\n\n    Returns:\n        bool: True if all remainders are distinct, False otherwise.\n    \"\"\"\n    remainders = set()\n    for i in range(1, k + 1):\n        remainder = n % i\n        if remainder in remainders:\n            return False\n        remainders.add(remainder)\n    return True\n\n\ndef main():\n    n, k = map(int, input().split())\n    if check_remainders(n, k):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef compare_long_integers(a, b):\n    a = a.lstrip('0') or '0'\n    b = b.lstrip('0') or '0'\n\n    if len(a) > len(b):\n        return '>'\n    elif len(a) < len(b):\n        return '<'\n    else:\n        return '>' if a > b else '<' if a < b else '='\n\na = sys.stdin.readline().strip()\nb = sys.stdin.readline().strip()\n\nprint(compare_long_integers(a, b))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, p, c):\n    dp = [[[[0, 0] for _ in range(2)] for _ in range(2)] for _ in range(n + 1)]\n    dp[0][0][0][0] = 1\n\n    for i in range(n):\n        for j in range(2):\n            for k in range(2):\n                for l in range(2):\n                    if dp[i][j][k][l] == 0:\n                        continue\n                    if c[i] == -1:\n                        for m in range(2):\n                            for x in range(2):\n                                nj = j | (m ^ k)\n                                nk = m\n                                nl = (l + x * (m ^ k)) % 2\n                                dp[i + 1][nj][nk][nl] = (dp[i + 1][nj][nk][nl] + dp[i][j][k][l]) % MOD\n                    elif c[i] == 0:\n                        nj = j | (0 ^ k)\n                        nk = 0\n                        nl = (l + (0 ^ k)) % 2\n                        dp[i + 1][nj][nk][nl] = (dp[i + 1][nj][nk][nl] + dp[i][j][k][l]) % MOD\n                    else:\n                        nj = j | (1 ^ k)\n                        nk = 1\n                        nl = (l + (1 ^ k)) % 2\n                        dp[i + 1][nj][nk][nl] = (dp[i + 1][nj][nk][nl] + dp[i][j][k][l]) % MOD\n\n    ans = 0\n    for j in range(2):\n        for k in range(2):\n            ans = (ans + dp[n][j][k][p]) % MOD\n    return ans\n\nn, p = map(int, input().split())\nc = list(map(int, input().split()))\nprint(solve(n, p, c))"}
{"solution": "def min_rubles(n, a, b, c):\n    remainder = n % 4\n    if remainder == 0:\n        return 0\n    elif remainder == 1:\n        return min(a, b + c, 4 * c)\n    elif remainder == 2:\n        return min(2 * a, b, 3 * c)\n    else:\n        return min(3 * a, 2 * b, 4 * c)\n\nn, a, b, c = map(int, input().split())\nprint(min_rubles(n, a, b, c))"}
{"solution": "from collections import defaultdict\n\ndef dfs(graph, visited, stack, vertex):\n    visited[vertex] = True\n    stack[vertex] = True\n\n    for neighbor in graph[vertex]:\n        if not visited[neighbor]:\n            if dfs(graph, visited, stack, neighbor):\n                return True\n        elif stack[neighbor]:\n            return True\n\n    stack[vertex] = False\n    return False\n\ndef is_acyclic(graph, n):\n    visited = [False] * n\n    stack = [False] * n\n\n    for vertex in range(n):\n        if not visited[vertex]:\n            if dfs(graph, visited, stack, vertex):\n                return False\n\n    return True\n\ndef remove_edge(graph, u, v):\n    graph[u].remove(v)\n\ndef add_edge(graph, u, v):\n    graph[u].append(v)\n\ndef can_make_acyclic(graph, n, m):\n    for u in range(n):\n        for v in graph[u]:\n            remove_edge(graph, u, v)\n            if is_acyclic(graph, n):\n                return True\n            add_edge(graph, u, v)\n\n    return False\n\nn, m = map(int, input().split())\ngraph = defaultdict(list)\n\nfor _ in range(m):\n    u, v = map(int, input().split())\n    u -= 1\n    v -= 1\n    graph[u].append(v)\n\nif can_make_acyclic(graph, n, m):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, m = read_ints()\n    antennas = []\n    for _ in range(n):\n        x, s = read_ints()\n        antennas.append((x, s))\n\n    antennas.sort()\n\n    dp = [float('inf')] * (m + 1)\n    dp[0] = 0\n\n    for x, s in antennas:\n        for i in range(m, -1, -1):\n            if i - s - 1 >= 0:\n                dp[i] = min(dp[i], dp[i - s - 1] + max(0, i - x))\n            if i + s + 1 <= m:\n                dp[i] = min(dp[i], dp[i + s + 1] + max(0, x - i))\n\n    print(dp[m])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_weight_subset(W, weights):\n    \"\"\"\n    Calculate the maximum possible weight of a good subset of items.\n\n    Args:\n    W (int): The maximum total weight of a good subset.\n    weights (list): A list of integers representing the number of items having weight i in the set.\n\n    Returns:\n    int: The maximum possible weight of a good subset of items.\n    \"\"\"\n    total_weight = 0\n    for i, cnt in enumerate(weights, start=1):\n        # Calculate the maximum number of items of weight i that can be included\n        num_items = min(cnt, W // i)\n        total_weight += num_items * i\n        W -= num_items * i\n    return total_weight\n\n\n# Read input\nW = int(input())\nweights = list(map(int, input().split()))\n\n# Calculate and print the maximum possible weight of a good subset\nprint(max_weight_subset(W, weights))"}
{"solution": "def min_cost(n, L, costs):\n    volumes = [2**i - 1 for i in range(1, n + 1)]\n    dp = [float('inf')] * (L + 1)\n    dp[0] = 0\n\n    for i in range(1, L + 1):\n        for j in range(n):\n            if volumes[j] <= i:\n                dp[i] = min(dp[i], dp[i - volumes[j]] + costs[j])\n\n    return dp[L]\n\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\nprint(min_cost(n, L, costs))"}
{"solution": "def max_mex(n, a):\n    a.sort()\n    mex = 1\n    for num in a:\n        if num >= mex:\n            mex += 1\n    return mex\n\nn = int(input())\na = list(map(int, input().split()))\n\nresult = max_mex(n, a)\n\nprint(result)"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(int(digit) for digit in digits)\n    \n    # Try every possible segment sum from 1 to total_sum\n    for segment_sum in range(1, total_sum + 1):\n        if total_sum % segment_sum == 0:\n            current_sum = 0\n            valid_partition = True\n            for digit in digits:\n                current_sum += int(digit)\n                if current_sum > segment_sum:\n                    valid_partition = False\n                    break\n                elif current_sum == segment_sum:\n                    current_sum = 0\n            if valid_partition and current_sum == 0 and total_sum // segment_sum > 1:\n                return \"YES\"\n    \n    return \"NO\"\n\nn = int(input())\ndigits = input().strip()\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\"\n\nusername = input().strip()\nprint(determine_gender(username))"}
{"solution": "def calculate_max_difference(n, k, tabs):\n    max_difference = 0\n    for b in range(1, n + 1):\n        closed_tabs = set()\n        i = 0\n        while True:\n            c = b + i * k\n            if 1 <= c <= n:\n                closed_tabs.add(c)\n                i += 1\n            else:\n                break\n        e = 0\n        s = 0\n        for i in range(1, n + 1):\n            if i not in closed_tabs:\n                if tabs[i - 1] == 1:\n                    e += 1\n                else:\n                    s += 1\n        max_difference = max(max_difference, abs(e - s))\n    return max_difference\n\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\nprint(calculate_max_difference(n, k, tabs))"}
{"solution": "import sys\n\ndef min_cost_encoding(n, c0, c1):\n    if c0 > c1:\n        c0, c1 = c1, c0\n\n    total_cost = 0\n    nodes = 1\n    depth = 0\n\n    while nodes < n:\n        total_cost += nodes * c0\n        nodes *= 2\n        depth += 1\n\n    remaining_nodes = n - (nodes // 2)\n    total_cost += remaining_nodes * (depth * c0 + c1)\n\n    if nodes // 2!= remaining_nodes:\n        total_cost += (nodes // 2 - remaining_nodes) * (depth * c0 + c1)\n\n    return total_cost\n\nn, c0, c1 = map(int, sys.stdin.readline().split())\nprint(min_cost_encoding(n, c0, c1))"}
{"solution": "def will_meet(n, a, x, b, y):\n    if a < x:\n        dan_stations = list(range(a, x + 1))\n    else:\n        dan_stations = list(range(a, n + 1)) + list(range(1, x + 1))\n\n    if b > y:\n        vlad_stations = list(range(b, y - 1, -1))\n    else:\n        vlad_stations = list(range(b, 0, -1)) + list(range(n, y - 1, -1))\n\n    dan_stations_set = set(dan_stations)\n    vlad_stations_set = set(vlad_stations)\n\n    common_stations = dan_stations_set.intersection(vlad_stations_set)\n\n    return \"YES\" if common_stations else \"NO\"\n\nn, a, x, b, y = map(int, input().split())\nprint(will_meet(n, a, x, b, y))"}
{"solution": "import math\n\ndef is_unlucky(x, y, n):\n    \"\"\"Check if a number is unlucky.\"\"\"\n    a = 0\n    while x ** a <= n:\n        b = 0\n        while x ** a + y ** b <= n:\n            if x ** a + y ** b == n:\n                return True\n            b += 1\n        a += 1\n    return False\n\ndef max_golden_age(x, y, left, right):\n    \"\"\"Find the maximum length of The Golden Age.\"\"\"\n    max_length = 0\n    current_length = 0\n    for i in range(left, right + 1):\n        if is_unlucky(x, y, i):\n            max_length = max(max_length, current_length)\n            current_length = 0\n        else:\n            current_length += 1\n    return max(max_length, current_length)\n\nx, y, left, right = map(int, input().split())\nprint(max_golden_age(x, y, left, right))"}
{"solution": "def min_tax(n):\n    if n % 2 == 0:\n        return 2\n    elif n % 3 == 0:\n        return 3\n    elif n % 3 == 1:\n        return 2\n    else:\n        return 3\n\nn = int(input())\nprint(min_tax(n))"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    n = len(word)\n    result = []\n    i = 0\n    \n    while i < n:\n        result.append(word[i])\n        if word[i] not in vowels:\n            start = i\n            while i < n and word[i] not in vowels:\n                i += 1\n            if i - start >= 3:\n                block = word[start:i]\n                if len(set(block)) > 1:\n                    result.append(' ')\n        i += 1\n    \n    return ''.join(result)\n\nword = input()\nprint(fix_typos(word))"}
{"solution": "import sys\n\nn, m, k = map(int, sys.stdin.readline().split())\nx, s = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\nb = list(map(int, sys.stdin.readline().split()))\nc = list(map(int, sys.stdin.readline().split()))\nd = list(map(int, sys.stdin.readline().split()))\n\nmin_time = float('inf')\n\n# No spell of the first type\nfor j in range(k):\n    if d[j] <= s:\n        time = max(0, n - c[j]) * x\n        min_time = min(min_time, time)\n\n# Spell of the first type\nfor i in range(m):\n    if b[i] <= s:\n        for j in range(k):\n            if d[j] <= s - b[i]:\n                time = max(0, n - c[j]) * a[i]\n                min_time = min(min_time, time)\n\n# No spell of the second type\nfor i in range(m):\n    if b[i] <= s:\n        time = n * a[i]\n        min_time = min(min_time, time)\n\nprint(min_time)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, k, M = read_ints()\n    t = list(read_ints())\n\n    t.sort()\n    task_times = [sum(t[:i+1]) for i in range(k)]\n\n    dp = [0] * (n * k + 1)\n    for i in range(1, n * k + 1):\n        for j in range(1, min(i, k) + 1):\n            dp[i] = max(dp[i], dp[i-j] + task_times[j-1] + (1 if j == k else 0))\n\n    ans = 0\n    for i in range(n * k + 1):\n        if dp[i] <= M:\n            ans = max(ans, i + (dp[i] == task_times[k-1]))\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 998244353\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef mod_binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    else:\n        numerator = mod_factorial(n)\n        denominator = (mod_factorial(k) * mod_factorial(n - k)) % MOD\n        return (numerator * mod_inverse(denominator, MOD)) % MOD\n\ndef mod_catalan(n):\n    if n % 2 == 1:\n        return 0\n    else:\n        return (mod_binomial_coefficient(n, n // 2) * mod_inverse(n // 2 + 1, MOD)) % MOD\n\ndef main():\n    n = int(input())\n    if n % 2 == 1:\n        print(0)\n    else:\n        print((mod_catalan(n) * mod_factorial(n // 2) * mod_factorial(n // 2)) % MOD)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def lara_croft_path(n, m, k):\n    # Calculate the total number of cells\n    total_cells = n * m\n\n    # Calculate the number of full rows\n    full_rows = (total_cells - n) // (2 * n) + 1\n\n    # Calculate the remaining cells after full rows\n    remaining_cells = k - (full_rows - 1) * n\n\n    # Calculate the row and column\n    if remaining_cells < n:\n        row = remaining_cells + 1\n        col = 1\n    else:\n        remaining_cells -= n\n        row = n - remaining_cells % n\n        col = remaining_cells // n + 2\n\n    return row, col\n\n\nn, m, k = map(int, input().split())\nrow, col = lara_croft_path(n, m, k)\nprint(row, col)"}
{"solution": "import math\n\ndef prime_factors(n):\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef solve():\n    x = int(input())\n    factors = prime_factors(x)\n    a = 1\n    b = x\n    for factor in factors:\n        if b % factor == 0:\n            b //= factor\n        else:\n            a *= factor\n    print(a, b)\n\nsolve()"}
{"solution": "def max_fruits_for_compote(a, b, c):\n    # Calculate the maximum number of complete sets for each fruit type\n    max_sets_lemons = a // 1\n    max_sets_apples = b // 2\n    max_sets_pears = c // 4\n    \n    # Find the limiting factor (minimum number of complete sets)\n    max_complete_sets = min(max_sets_lemons, max_sets_apples, max_sets_pears)\n    \n    # Calculate the total number of fruits used in the compote\n    total_fruits = max_complete_sets * (1 + 2 + 4)\n    \n    return total_fruits\n\na = int(input())\nb = int(input())\nc = int(input())\n\nprint(max_fruits_for_compote(a, b, c))"}
{"solution": "n = int(input())\nratings = list(map(int, input().split()))\nratings.sort()\nfor i in range(n):\n    if ratings[i] >= ratings[i + n]:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef is_coprime(a, b):\n    return gcd(a, b) == 1\n\ndef make_coprime_array(arr):\n    result = [arr[0]]\n    for i in range(1, len(arr)):\n        if is_coprime(result[-1], arr[i]):\n            result.append(arr[i])\n        else:\n            for j in range(2, arr[i]):\n                if is_coprime(result[-1], j) and is_coprime(j, arr[i]):\n                    result.append(j)\n                    break\n            result.append(arr[i])\n    return result\n\nn = int(input())\narr = list(map(int, input().split()))\n\nnew_arr = make_coprime_array(arr)\nprint(len(new_arr) - n)\nprint(*new_arr)"}
{"solution": "import math\nfrom functools import reduce\nfrom math import gcd\n\ndef compute_gcd_of_list(lst):\n    return reduce(gcd, lst)\n\ndef max_divisor_after_operations(N, K, A):\n    if N == 1:\n        return A[0]\n    \n    # Compute the GCD of the differences between all pairs\n    diffs = [abs(A[i] - A[j]) for i in range(N) for j in range(i + 1, N)]\n    initial_gcd = compute_gcd_of_list(diffs)\n    \n    # Check all divisors of the initial GCD\n    max_divisor = 1\n    for d in range(1, initial_gcd + 1):\n        if initial_gcd % d == 0:\n            # Check if we can make all elements divisible by d\n            if all((a % d) <= K for a in A):\n                max_divisor = d\n    \n    return max_divisor\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\nprint(max_divisor_after_operations(N, K, A))"}
{"solution": "import math\n\ndef get_next_power_of_two(x):\n    return 2 ** math.ceil(math.log2(x + 1))\n\ndef get_operations(x):\n    operations = []\n    while x!= get_next_power_of_two(x) - 1:\n        next_power_of_two = get_next_power_of_two(x)\n        n = int(math.log2(next_power_of_two))\n        operations.append(n)\n        x ^= (1 << n) - 1\n        x += 1\n    return operations\n\nx = int(input())\noperations = get_operations(x)\nprint(len(operations) * 2)\nfor i in range(0, len(operations), 2):\n    print(operations[i], end=' ')\n    if i + 1 < len(operations):\n        print(operations[i + 1], end=' ')\nprint()"}
{"solution": "def min_hours_to_water_garden(n, k, bucket_lengths):\n    \"\"\"\n    Calculate the minimum number of hours required to water the garden.\n\n    Args:\n    n (int): The number of buckets.\n    k (int): The length of the garden.\n    bucket_lengths (list): A list of integers representing the length of the segment that can be watered by each bucket in one hour.\n\n    Returns:\n    int: The minimum number of hours required to water the garden.\n    \"\"\"\n    # Initialize the minimum hours to infinity\n    min_hours = float('inf')\n\n    # Iterate over each bucket length\n    for length in bucket_lengths:\n        # Check if the garden length is divisible by the bucket length\n        if k % length == 0:\n            # Calculate the hours required to water the garden with this bucket\n            hours = k // length\n            # Update the minimum hours if this bucket requires fewer hours\n            min_hours = min(min_hours, hours)\n\n    # Return the minimum hours required to water the garden\n    return min_hours\n\n\n# Read the input\nn, k = map(int, input().split())\nbucket_lengths = list(map(int, input().split()))\n\n# Calculate and print the minimum hours to water the garden\nprint(min_hours_to_water_garden(n, k, bucket_lengths))"}
{"solution": "from collections import deque\n\ndef can_grasshopper_reach_insect(n, k, cells):\n    \"\"\"\n    Determine whether the grasshopper can reach the insect by jumping over obstacles.\n\n    Args:\n    n (int): The number of cells in the line.\n    k (int): The length of one grasshopper's jump.\n    cells (str): A string of length n consisting of characters '.', '#', 'G', and 'T'.\n\n    Returns:\n    bool: True if the grasshopper can reach the insect, False otherwise.\n    \"\"\"\n    # Find the initial position of the grasshopper and the insect\n    grasshopper_position = cells.index('G')\n    insect_position = cells.index('T')\n\n    # Create a queue for BFS and add the initial position of the grasshopper\n    queue = deque([grasshopper_position])\n\n    # Create a set to store visited positions\n    visited = set([grasshopper_position])\n\n    while queue:\n        # Dequeue the current position\n        current_position = queue.popleft()\n\n        # If the current position is the insect's position, return True\n        if current_position == insect_position:\n            return True\n\n        # Calculate the next possible positions\n        next_positions = [current_position - k, current_position + k]\n\n        # Iterate over the next possible positions\n        for next_position in next_positions:\n            # Check if the next position is within the bounds and is not an obstacle\n            if 0 <= next_position < n and cells[next_position]!= '#':\n                # If the next position has not been visited, mark it as visited and add it to the queue\n                if next_position not in visited:\n                    visited.add(next_position)\n                    queue.append(next_position)\n\n    # If the insect's position is not reachable, return False\n    return False\n\n\n# Read the input\nn, k = map(int, input().split())\ncells = input()\n\n# Print the output\nprint(\"YES\" if can_grasshopper_reach_insect(n, k, cells) else \"NO\")"}
{"solution": "import math\n\ndef calculate_xw(y1, y2, yw, xb, yb, r):\n    # Calculate the slope of the line from the ball to the wall\n    m = (yw - yb) / (xb - 0)\n\n    # Calculate the y-coordinate of the point where the ball hits the wall\n    y_hit = (y1 + y2) / 2\n\n    # Calculate the x-coordinate of the point where the ball hits the wall\n    xw = (y_hit - yb + m * xb) / (m + 1 / m)\n\n    # Check if the ball hits the wall within the goal\n    if y1 <= y_hit - r and y_hit + r <= y2:\n        return xw\n    else:\n        return -1\n\n# Read the input\ny1, y2, yw, xb, yb, r = map(float, input().split())\n\n# Calculate and print the result\nresult = calculate_xw(y1, y2, yw, xb, yb, r)\nprint(result)"}
{"solution": "def calculate_missed_meals(b, d, s):\n    meals = [b, d, s]\n    meals.sort()\n    missed_meals = 0\n\n    if meals[0] == meals[2]:\n        return 0\n    elif meals[0] == 0:\n        return meals[1] + meals[2] - 1\n    else:\n        missed_meals += meals[2] - meals[0]\n        if meals[1] < meals[0]:\n            missed_meals += meals[0] - meals[1]\n        return missed_meals\n\nb, d, s = map(int, input().split())\nprint(calculate_missed_meals(b, d, s))"}
{"solution": "import math\n\ndef find_dimensions(n, path):\n    max_value = max(path)\n    min_x = math.ceil(math.sqrt(max_value))\n    min_y = math.ceil(max_value / min_x)\n\n    for x in range(min_x, 1000000001):\n        y = math.ceil(max_value / x)\n        if x * y < max_value:\n            continue\n        if is_valid_path(x, y, path):\n            return x, y\n\n    return None\n\ndef is_valid_path(x, y, path):\n    for i in range(1, len(path)):\n        a = path[i - 1]\n        b = path[i]\n        a_row = math.ceil(a / y)\n        a_col = a - (a_row - 1) * y\n        b_row = math.ceil(b / y)\n        b_col = b - (b_row - 1) * y\n        if abs(a_row - b_row) + abs(a_col - b_col)!= 1:\n            return False\n    return True\n\nn = int(input())\npath = list(map(int, input().split()))\n\ndimensions = find_dimensions(n, path)\n\nif dimensions is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(dimensions[0], dimensions[1])"}
{"solution": "def longest_subsequence(a, b):\n    i, j = 0, 0\n    result = []\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            result.append(a[i])\n            i += 1\n            j += 1\n        else:\n            i += 1\n    if not result:\n        return '-'\n    return ''.join(result)\n\na = input()\nb = input()\nprint(longest_subsequence(a, b))"}
{"solution": "def minimal_stones(n, s):\n    current_stones = 0\n    min_stones = 0\n    \n    for char in s:\n        if char == '+':\n            current_stones += 1\n        elif char == '-':\n            current_stones -= 1\n            if current_stones < min_stones:\n                min_stones = current_stones\n    return max(0, current_stones)\n\nn = int(input())\ns = input().strip()\nprint(minimal_stones(n, s))"}
{"solution": "def max_kefir(n, a, b, c):\n    \"\"\"\n    Calculate the maximum number of liters of kefir Kolya can drink.\n\n    Parameters:\n    n (int): The number of rubles Kolya has at the beginning.\n    a (int): The cost of one plastic liter bottle.\n    b (int): The cost of one glass liter bottle.\n    c (int): The money one can get back by returning an empty glass bottle.\n\n    Returns:\n    int: The maximum number of liters of kefir Kolya can drink.\n    \"\"\"\n    # Calculate the maximum number of plastic bottles Kolya can buy\n    max_plastic = n // a\n\n    # Calculate the maximum number of glass bottles Kolya can buy\n    max_glass = n // (b - c)\n\n    # Calculate the remaining money after buying the maximum number of glass bottles\n    remaining = n - max_glass * (b - c)\n\n    # Calculate the additional glass bottles Kolya can buy with the remaining money\n    additional_glass = remaining // b\n\n    # Calculate the total number of liters of kefir Kolya can drink\n    total_kefir = max(max_plastic, max_glass + additional_glass)\n\n    return total_kefir\n\n\n# Read the input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate and print the maximum number of liters of kefir Kolya can drink\nprint(max_kefir(n, a, b, c))"}
{"solution": "def play_game(deck1, deck2):\n    seen = set()\n    rounds = 0\n    while deck1 and deck2:\n        rounds += 1\n        card1 = deck1.pop(0)\n        card2 = deck2.pop(0)\n        if (tuple(deck1), tuple(deck2)) in seen:\n            return -1\n        seen.add((tuple(deck1), tuple(deck2)))\n        if card1 > card2:\n            deck1.extend([card2, card1])\n        else:\n            deck2.extend([card1, card2])\n    return rounds, 1 if deck1 else 2\n\nn = int(input())\nk1 = int(input().split()[0])\ndeck1 = list(map(int, input().split()[1:]))\ndeck2 = list(map(int, input().split()[1:]))\n\nresult = play_game(deck1, deck2)\nprint(*result)"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    \n    has_upper = False\n    has_lower = False\n    has_digit = False\n    \n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n    \n    if has_upper and has_lower and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\"\n\npassword = input().strip()\nprint(check_password_complexity(password))"}
{"solution": "def min_exchanges(n, a, b):\n    count_a = [0] * 5\n    count_b = [0] * 5\n\n    for i in range(n):\n        count_a[a[i] - 1] += 1\n        count_b[b[i] - 1] += 1\n\n    exchanges = 0\n    for i in range(5):\n        diff = abs(count_a[i] - count_b[i])\n        if diff % 2!= 0:\n            return -1\n        exchanges += diff // 2\n\n    return exchanges\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(min_exchanges(n, a, b))"}
{"solution": "from collections import deque\n\ndef is_reachable(n, m, horizontal_streets, vertical_streets):\n    # Create a graph with all intersections as nodes\n    graph = {}\n    for i in range(n - 1):\n        for j in range(m - 1):\n            graph[(i, j)] = []\n\n    # Add edges to the graph based on street directions\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if horizontal_streets[i] == '<':\n                if j > 0:\n                    graph[(i, j)].append((i, j - 1))\n                    graph[(i, j - 1)].append((i, j))\n            else:\n                if j < m - 2:\n                    graph[(i, j)].append((i, j + 1))\n                    graph[(i, j + 1)].append((i, j))\n\n            if vertical_streets[j] == '^':\n                if i > 0:\n                    graph[(i, j)].append((i - 1, j))\n                    graph[(i - 1, j)].append((i, j))\n            else:\n                if i < n - 2:\n                    graph[(i, j)].append((i + 1, j))\n                    graph[(i + 1, j)].append((i, j))\n\n    # Perform BFS to check if all nodes are reachable from a given node\n    visited = set()\n    queue = deque([(0, 0)])\n    visited.add((0, 0))\n\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n\n    return len(visited) == (n - 1) * (m - 1)\n\n\nn, m = map(int, input().split())\nhorizontal_streets = input()\nvertical_streets = input()\n\nif is_reachable(n, m, horizontal_streets, vertical_streets):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    if a[0] == 0:\n        print(\"YES\")\n        print(\"0\" if n == 1 else \"0->\" + \"->\".join(map(str, a[1:])))\n        return\n\n    for i in range(1, n):\n        if a[i] == 0:\n            print(\"YES\")\n            print(\"(\" + \"->\".join(map(str, a[:i])) + \")->\" + \"->\".join(map(str, a[i:])))\n            return\n\n    print(\"NO\")\n\nsolve()"}
{"solution": "def calculate_final_values(a, b):\n    while True:\n        if a == 0 or b == 0:\n            break\n        elif a >= 2 * b:\n            a -= 2 * b\n        elif b >= 2 * a:\n            b -= 2 * a\n        else:\n            break\n    return a, b\n\na, b = map(int, input().split())\nfinal_a, final_b = calculate_final_values(a, b)\nprint(final_a, final_b)"}
{"solution": "def count_k_divisible_numbers(k, a, b):\n    \"\"\"\n    Calculate the number of k-divisible numbers in the segment [a, b].\n    \n    Parameters:\n    k (int): The divisor.\n    a (int): The start of the segment.\n    b (int): The end of the segment.\n    \n    Returns:\n    int: The number of k-divisible numbers in the segment [a, b].\n    \"\"\"\n    # Calculate the first k-divisible number in the segment [a, b]\n    first_divisible = (a + k - 1) // k * k\n    \n    # Calculate the last k-divisible number in the segment [a, b]\n    last_divisible = b // k * k\n    \n    # If the last divisible number is less than the first divisible number, \n    # it means there are no k-divisible numbers in the segment [a, b]\n    if last_divisible < first_divisible:\n        return 0\n    \n    # Calculate the number of k-divisible numbers in the segment [a, b]\n    count = (last_divisible - first_divisible) // k + 1\n    \n    return count\n\n# Read input\nk, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(count_k_divisible_numbers(k, a, b))"}
{"solution": "def find_kth_digit(k):\n    \"\"\"\n    Find the k-th digit in the infinite sequence of concatenated positive integers.\n\n    Args:\n    k (int): The position of the digit to find (1-based index).\n\n    Returns:\n    int: The k-th digit in the sequence.\n    \"\"\"\n    length = 0\n    count = 0\n    num_digits = 1\n\n    # Calculate the number of digits in the sequence up to the k-th digit\n    while length < k:\n        count += 9 * (10 ** (num_digits - 1)) * num_digits\n        length += 9 * (10 ** (num_digits - 1)) * num_digits\n        num_digits += 1\n\n    # Adjust the count and length to account for the last number\n    count -= length - k\n    length -= length - k\n\n    # Calculate the number that contains the k-th digit\n    num = 10 ** (num_digits - 1) + (count // num_digits)\n\n    # Calculate the position of the k-th digit within the number\n    pos = (k - length - 1) % num_digits\n\n    # Return the k-th digit\n    return int(str(num)[pos])\n\n# Read the input\nk = int(input())\n\n# Print the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "def can_vasya_win(n, s):\n    # Calculate the number of moves each player will make\n    moves_each = (n - 11) // 2\n    \n    # Count the number of '8's in the string\n    count_8s = s.count('8')\n    \n    # If there are no '8's, Vasya cannot win\n    if count_8s == 0:\n        return \"NO\"\n    \n    # If there is only one '8', Vasya can only win if it's in the first position\n    if count_8s == 1:\n        return \"YES\" if s[0] == '8' else \"NO\"\n    \n    # If there are multiple '8's, Vasya can win if there are more '8's than the number of moves Petya can make\n    # plus the number of non-'8's that Vasya needs to remove to make the first '8' the first character\n    first_8_index = s.find('8')\n    non_8s_before_first_8 = first_8_index\n    return \"YES\" if count_8s > moves_each + non_8s_before_first_8 else \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Determine if Vasya has a winning strategy\nresult = can_vasya_win(n, s)\nprint(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef modmul(a, b):\n    return (a * b) % MOD\n\ndef modpow(a, b):\n    if b == 0:\n        return 1\n    if b % 2 == 0:\n        return modpow(modmul(a, a), b // 2)\n    return modmul(a, modpow(a, b - 1))\n\ndef modinv(a):\n    return modpow(a, MOD - 2)\n\ndef moddiv(a, b):\n    return modmul(a, modinv(b))\n\ndef comb(n, k):\n    if k < 0 or k > n:\n        return 0\n    return modmul(modmul(fact[n], invfact[k]), invfact[n - k])\n\ndef solve():\n    n, x, pos = map(int, input().split())\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = modmul(fact[i - 1], i)\n        invfact[i] = modinv(fact[i])\n\n    if pos == 0:\n        return modmul(comb(n - 1, x - 1), fact[n - 1])\n\n    if pos == n - 1:\n        return modmul(comb(n - 1, x - 1), fact[n - 1])\n\n    if x == 1:\n        return 0\n\n    if pos < n // 2:\n        return modmul(comb(pos, x - 1), modmul(fact[pos], modmul(comb(n - pos - 1, n - x), fact[n - pos - 1])))\n\n    return modmul(comb(n - pos - 1, n - x), modmul(fact[n - pos - 1], modmul(comb(pos, x - 2), fact[pos])))\n\nprint(solve())"}
{"solution": "def solve(s, k):\n    n = len(s)\n    dp = [[False] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(n):\n        if s[i].isalpha():\n            for j in range(k + 1):\n                if dp[i][j]:\n                    dp[i + 1][j] = True\n                    if j < k:\n                        dp[i + 1][j + 1] = True\n        elif s[i] == '*':\n            for j in range(k + 1):\n                if dp[i - 1][j]:\n                    dp[i + 1][j] = True\n                    if j < k:\n                        dp[i + 1][j + 1] = True\n                        for l in range(j + 2, k + 1):\n                            dp[i + 1][l] = True\n        elif s[i] == '?':\n            for j in range(k + 1):\n                if dp[i - 1][j]:\n                    dp[i + 1][j] = True\n                    if j < k:\n                        dp[i + 1][j + 1] = True\n\n    if not dp[n][k]:\n        return \"Impossible\"\n\n    result = []\n    i, j = n, k\n    while i > 0 and j > 0:\n        if s[i - 1].isalpha():\n            result.append(s[i - 1])\n            i -= 1\n            j -= 1\n        elif s[i - 1] == '*':\n            if j > 1 and dp[i - 2][j - 2]:\n                result.append(s[i - 2] * (j - (j - 2)))\n                i -= 2\n                j -= (j - (j - 2))\n            elif dp[i - 2][j - 1]:\n                result.append(s[i - 2])\n                i -= 2\n                j -= 1\n            else:\n                i -= 2\n        elif s[i - 1] == '?':\n            if dp[i - 2][j - 1]:\n                result.append(s[i - 2])\n                i -= 2\n                j -= 1\n            else:\n                i -= 2\n\n    return ''.join(reversed(result))\n\ns = input()\nk = int(input())\nprint(solve(s, k))"}
{"solution": "def min_turns(angle):\n    \"\"\"\n    Calculate the minimum number of 90 degrees clockwise turns necessary to get a picture in which up direction deviation from vertical is minimum.\n\n    Args:\n        angle (int): Camera angle in degrees. Positive value denotes clockwise camera rotation, negative \u2014 counter-clockwise.\n\n    Returns:\n        int: The minimum required number of 90 degrees clockwise turns.\n    \"\"\"\n    # Normalize the angle to the range [0, 360)\n    angle = angle % 360\n\n    # If the angle is negative, add 360 to get the equivalent positive angle\n    if angle < 0:\n        angle += 360\n\n    # Calculate the minimum number of 90 degrees clockwise turns\n    turns = (360 - angle) // 90 % 4\n\n    return turns\n\n\n# Read the input angle\nangle = int(input())\n\n# Calculate and print the minimum number of turns\nprint(min_turns(angle))"}
{"solution": "def can_transform_spheres(a, b, c, x, y, z):\n    # Calculate the total number of spheres\n    total_spheres = a + b + c\n    \n    # Calculate the total number of spheres needed\n    total_needed = x + y + z\n    \n    # If the total number of spheres needed is more than the total number of spheres available, return False\n    if total_needed > total_spheres:\n        return False\n    \n    # Calculate the number of spheres that can be transformed\n    transformable_spheres = (a // 2) + (b // 2) + (c // 2)\n    \n    # Calculate the number of spheres that need to be transformed\n    needed_transformations = max(0, x - a) + max(0, y - b) + max(0, z - c)\n    \n    # If the number of spheres that can be transformed is greater than or equal to the number of spheres that need to be transformed, return True\n    return transformable_spheres >= needed_transformations\n\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\nif can_transform_spheres(a, b, c, x, y, z):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def solve():\n    n, k, m = map(int, input().split())\n    dp = [0] * k\n    for i in range(1, 10):\n        dp[i % k] += 1\n    for _ in range(n - 1):\n        new_dp = [0] * k\n        for i in range(k):\n            for j in range(10):\n                new_dp[(i * 10 + j) % k] += dp[i]\n        dp = new_dp\n    ans = sum(dp) % m\n    print(ans)\n\nsolve()"}
{"solution": "def max_team_size():\n    l, r, a = map(int, input().split())\n    \n    if l > r:\n        l, r = r, l  # Ensure l is always the smaller or equal group\n    \n    # Use ambidexters to balance the difference\n    d = r - l\n    if a >= d:\n        l += d\n        a -= d\n        # Now l == r, distribute remaining ambidexters equally\n        l += a // 2\n        r += a // 2\n    else:\n        l += a\n        # Not enough ambidexters to balance completely, r remains larger\n    \n    # The maximum team size is twice the smaller group\n    return 2 * min(l, r)\n\nprint(max_team_size())"}
{"solution": "def min_moves(n, k):\n    if k == 1:\n        return sum(2 * i + 1 for i in range(n - 1))\n    elif k == n:\n        return sum(2 * i + 1 for i in range(n - 1, 0, -1))\n    else:\n        return min(\n            sum(2 * i + 1 for i in range(k - 1)) + \n            sum(2 * i + 1 for i in range(n - k, 0, -1)),\n            sum(2 * i + 1 for i in range(n - k)) + \n            sum(2 * i + 1 for i in range(k - 1, 0, -1))\n        )\n\nn, k = map(int, input().split())\nprint(min_moves(n, k))"}
{"solution": "def min_tower_height(n, m):\n    \"\"\"\n    Calculate the minimum height necessary for the tallest of the students' towers.\n\n    :param n: The number of students using two-block pieces.\n    :param m: The number of students using three-block pieces.\n    :return: The minimum possible height of the tallest tower.\n    \"\"\"\n    # Initialize the current height for two-block and three-block towers\n    two_block_height = 0\n    three_block_height = 0\n\n    # Initialize the count of used heights\n    used_heights = set()\n\n    # Generate heights for two-block towers\n    for _ in range(n):\n        two_block_height += 2\n        while two_block_height in used_heights:\n            two_block_height += 2\n\n    # Generate heights for three-block towers\n    for _ in range(m):\n        three_block_height += 3\n        while three_block_height in used_heights:\n            three_block_height += 3\n        used_heights.add(three_block_height)\n\n    # Return the maximum height\n    return max(two_block_height, three_block_height)\n\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the minimum tower height\nprint(min_tower_height(n, m))"}
{"solution": "from collections import Counter\n\nn = int(input())\nnumbers = [int(input()) for _ in range(n)]\n\ncounts = Counter(numbers)\neven_counts = [num for num, count in counts.items() if count % 2 == 0 and count!= 0]\n\nif len(even_counts) < 2:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(even_counts[0], even_counts[1])"}
{"solution": "def solve(n, k, groups):\n    groups.sort(reverse=True)\n    seats = [0] * 8\n    for group in groups:\n        placed = False\n        for i in range(8):\n            if seats[i] == 0:\n                if i == 0 or seats[i-1]!= groups.index(group):\n                    seats[i] = groups.index(group)\n                    placed = True\n                    break\n                elif i == 7 or seats[i+1]!= groups.index(group):\n                    seats[i] = groups.index(group)\n                    placed = True\n                    break\n        if not placed:\n            return \"NO\"\n        if group == 1:\n            continue\n        for i in range(8):\n            if seats[i] == groups.index(group):\n                if i < 7 and seats[i+1] == 0:\n                    seats[i+1] = groups.index(group)\n                    group -= 1\n                elif i > 0 and seats[i-1] == 0:\n                    seats[i-1] = groups.index(group)\n                    group -= 1\n                else:\n                    return \"NO\"\n    return \"YES\"\n\nn, k = map(int, input().split())\ngroups = list(map(int, input().split()))\nprint(solve(n, k, groups))"}
{"solution": "def calculate_cost(sticks, t):\n    return sum(min(abs(stick - t), abs(stick - (t - 1)), abs(stick - (t + 1))) for stick in sticks)\n\ndef solve(sticks):\n    min_cost = float('inf')\n    optimal_t = None\n    for t in range(1, 101):\n        cost = calculate_cost(sticks, t)\n        if cost < min_cost:\n            min_cost = cost\n            optimal_t = t\n    return optimal_t, min_cost\n\nn = int(input())\nsticks = list(map(int, input().split()))\nt, cost = solve(sticks)\nprint(t, cost)"}
{"solution": "n, m = map(int, input().split())\nmin_x, max_x, min_y, max_y = float('inf'), float('-inf'), float('inf'), float('-inf')\n\nfor i in range(n):\n    row = input()\n    for j in range(m):\n        if row[j] == '*':\n            min_x, max_x = min(min_x, i), max(max_x, i)\n            min_y, max_y = min(min_y, j), max(max_y, j)\n\nside = max(max_x - min_x + 1, max_y - min_y + 1)\nprint(side)"}
{"solution": "import sys\n\nMOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_comb(n, k):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return (mod_fact(n) * mod_inverse(mod_fact(k), MOD) * mod_inverse(mod_fact(n - k), MOD)) % MOD\n\ndef mod_fact(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    ones = sum(a)\n    zeros = n - ones\n\n    if ones == 0 or zeros == 0:\n        print(1)\n        return\n\n    if k < ones * zeros:\n        print(0)\n        return\n\n    k = min(k, ones * zeros)\n\n    result = 0\n    for i in range(k + 1):\n        result = (result + mod_comb(ones * zeros, i) * mod_comb(ones * zeros - i, k - i) * mod_inverse(mod_comb(n * (n - 1) // 2, k), MOD)) % MOD\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_seconds(x, y):\n    \"\"\"\n    Calculate the minimum number of seconds required to transform an equilateral triangle of side length x into an equilateral triangle of side length y.\n\n    Args:\n        x (int): The initial side length of the equilateral triangle.\n        y (int): The target side length of the equilateral triangle.\n\n    Returns:\n        int: The minimum number of seconds required for the transformation.\n    \"\"\"\n    # Calculate the difference between the initial and target side lengths\n    diff = x - y\n    \n    # If the difference is even, we can reduce the side length by 1 in each step\n    if diff % 2 == 0:\n        return diff\n    else:\n        # If the difference is odd, we need to reduce the side length by 1 in each step, but we need to make an extra step to adjust the side length\n        return diff + 1\n\n# Read the input\nx, y = map(int, input().split())\n\n# Calculate and print the minimum number of seconds\nprint(min_seconds(x, y))"}
{"solution": "import math\n\ndef calculate_determinant(a, b, c, d):\n    return a * d - b * c\n\ndef calculate_norm(a, b, c, d):\n    return max(abs(a), abs(b), abs(c), abs(d))\n\ndef calculate_min_norm(a, b, c, d):\n    det = calculate_determinant(a, b, c, d)\n    if det == 0:\n        return 0\n\n    norm = calculate_norm(a, b, c, d)\n    if norm == 0:\n        return 0\n\n    x = abs(det) / (abs(a) + abs(c))\n    y = abs(det) / (abs(b) + abs(d))\n    z = abs(det) / (abs(a) + abs(b))\n    w = abs(det) / (abs(c) + abs(d))\n\n    return min(x, y, z, w)\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\nmin_norm = calculate_min_norm(a, b, c, d)\nprint(min_norm)"}
{"solution": "def restaurant_denials(n, a, b, groups):\n    \"\"\"\n    Calculate the total number of people the restaurant denies service to.\n\n    Args:\n    n (int): The number of groups coming to the restaurant.\n    a (int): The number of one-seater tables.\n    b (int): The number of two-seater tables.\n    groups (list): A list of integers representing the size of each group.\n\n    Returns:\n    int: The total number of people the restaurant denies service to.\n    \"\"\"\n    one_seaters = a\n    two_seaters = b\n    occupied_seats = 0\n    denials = 0\n\n    for group in groups:\n        if group == 1:\n            if one_seaters > 0:\n                one_seaters -= 1\n            elif two_seaters > 0:\n                two_seaters -= 1\n                occupied_seats += 1\n            elif occupied_seats > 0:\n                occupied_seats -= 1\n            else:\n                denials += 1\n        else:\n            if two_seaters > 0:\n                two_seaters -= 1\n            else:\n                denials += 2\n\n    return denials\n\n\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\nprint(restaurant_denials(n, a, b, groups))"}
{"solution": "def calculate_students(a, b, c, n):\n    \"\"\"\n    Calculate the number of students who didn't pass the exam.\n\n    Args:\n    a (int): The number of students who visited BugDonalds.\n    b (int): The number of students who visited BeaverKing.\n    c (int): The number of students who visited both restaurants.\n    n (int): The total number of students in the group.\n\n    Returns:\n    int: The number of students who didn't pass the exam, or -1 if the data is contradictory.\n    \"\"\"\n    # Calculate the total number of students who visited at least one restaurant\n    total_visited = a + b - c\n    \n    # Check if the total number of students who visited at least one restaurant is greater than the total number of students\n    if total_visited > n:\n        return -1\n    \n    # Calculate the number of students who didn't pass the exam\n    didnt_pass = n - total_visited\n    \n    # Check if at least one student didn't pass the exam\n    if didnt_pass < 1:\n        return -1\n    \n    return didnt_pass\n\n# Read the input\na, b, c, n = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_students(a, b, c, n)\nprint(result)"}
{"solution": "def power(base, exponent, mod):\n    \"\"\"Compute base^exponent modulo mod\"\"\"\n    result = 1\n    base %= mod\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % mod\n        exponent //= 2\n        base = (base * base) % mod\n    return result\n\ndef solve():\n    \"\"\"Solve the problem\"\"\"\n    x, k = map(int, input().split())\n    mod = 10**9 + 7\n    result = x\n    for _ in range(k):\n        result = (result * 2 + (power(2, _, mod) - 1)) % mod\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "MOD = 998244353\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_multiply(a, b, m):\n    return (a * b) % m\n\ndef mod_add(a, b, m):\n    return (a + b) % m\n\ndef mod_subtract(a, b, m):\n    return (a - b) % m\n\ndef calculate_probability(n, problems):\n    total_probability = 1\n    for i in range(n):\n        total_probability = mod_multiply(total_probability, (problems[i][1] - problems[i][0] + 1), MOD)\n    for i in range(n):\n        for j in range(i + 1, n):\n            l1, r1 = problems[i]\n            l2, r2 = problems[j]\n            overlap = max(0, min(r1, r2) - max(l1, l2) + 1)\n            if overlap > 0:\n                total_probability = mod_multiply(total_probability, mod_inverse(overlap, MOD), MOD)\n    return total_probability\n\nn = int(input())\nproblems = []\nfor _ in range(n):\n    l, r = map(int, input().split())\n    problems.append((l, r))\n\nprobability = calculate_probability(n, problems)\nprint(probability)"}
{"solution": "def count_ways(n):\n    count = 0\n    for a in range(1, n // 4 + 1):\n        for b in range(a, (n - a) // 3 + 1):\n            c = n - 2 * a - b\n            if c >= b and a + b!= c and 2 * a!= c and 2 * b!= c:\n                count += 1\n            if c < b:\n                break\n    return count\n\nn = int(input())\nprint(count_ways(n))"}
{"solution": "def binary_search(arr, s):\n    left, right = 0, min(min(arr), s)\n    while left <= right:\n        mid = (left + right) // 2\n        total = sum(min(mid, v) for v in arr)\n        if total == s:\n            return mid\n        elif total < s:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\nn, s = map(int, input().split())\nvolumes = list(map(int, input().split()))\n\nprint(binary_search(volumes, s))"}
{"solution": "def caterpillar_reach_apple(h1, h2, a, b):\n    \"\"\"\n    Calculate the number of days it takes for the caterpillar to reach the apple.\n\n    Args:\n    h1 (int): The initial height of the caterpillar.\n    h2 (int): The height of the apple.\n    a (int): The distance the caterpillar goes up by day.\n    b (int): The distance the caterpillar slips down by night.\n\n    Returns:\n    int: The number of days it takes for the caterpillar to reach the apple. Returns -1 if it's impossible.\n    \"\"\"\n    # Calculate the total distance the caterpillar needs to cover\n    total_distance = h2 - h1\n\n    # Calculate the daily progress of the caterpillar\n    daily_progress = 12 * a - 10 * b\n\n    # If the caterpillar slips down more than it goes up, it's impossible to reach the apple\n    if daily_progress <= 0:\n        return -1\n\n    # Calculate the number of days it takes to cover the total distance\n    days = total_distance // daily_progress\n\n    # If there's a remaining distance, add one more day\n    if total_distance % daily_progress!= 0:\n        days += 1\n\n    # If the caterpillar reaches the apple on the same day, return 0\n    if days == 0:\n        return 0\n\n    # Calculate the remaining distance after the last full day\n    remaining_distance = total_distance - (days - 1) * daily_progress\n\n    # Calculate the number of hours it takes to cover the remaining distance\n    hours = remaining_distance // a\n\n    # If the caterpillar reaches the apple before 6 pm, return the current day\n    if hours <= 6:\n        return days - 1\n\n    # Otherwise, return the next day\n    return days\n\n\n# Read the input\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Print the output\nprint(caterpillar_reach_apple(h1, h2, a, b))"}
{"solution": "def calculate_max_joy_units():\n    # Read input values\n    C, Hr, Hb, Wr, Wb = map(int, input().split())\n\n    # Calculate maximum number of red candies\n    max_red_candies = C // Wr\n\n    # Calculate maximum number of blue candies\n    max_blue_candies = C // Wb\n\n    # Initialize maximum joy units\n    max_joy_units = 0\n\n    # Iterate over possible number of red candies\n    for red_candies in range(max_red_candies + 1):\n        # Calculate remaining weight for blue candies\n        remaining_weight = C - red_candies * Wr\n\n        # Calculate number of blue candies that can fit in remaining weight\n        blue_candies = remaining_weight // Wb\n\n        # Calculate total joy units for current combination\n        total_joy_units = red_candies * Hr + blue_candies * Hb\n\n        # Update maximum joy units if current combination is better\n        max_joy_units = max(max_joy_units, total_joy_units)\n\n    # Print maximum joy units\n    print(max_joy_units)\n\ncalculate_max_joy_units()"}
{"solution": "def calculate_min_steps(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the minimal number of steps for the robot to move from (x1, y1) to (x2, y2).\n    \n    The robot can move in one of the 8 directions by changing any of its coordinates by one.\n    \n    :param x1: The x-coordinate of the start position.\n    :param y1: The y-coordinate of the start position.\n    :param x2: The x-coordinate of the finish position.\n    :param y2: The y-coordinate of the finish position.\n    :return: The minimal number of steps to get the finish position.\n    \"\"\"\n    # Calculate the absolute difference in x and y coordinates\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    \n    # The minimal number of steps is the maximum of dx and dy\n    # This is because the robot can move diagonally, so it can cover the maximum difference in one step\n    return max(dx, dy)\n\n\n# Read the start and finish positions from the input\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\n# Calculate and print the minimal number of steps\nprint(calculate_min_steps(x1, y1, x2, y2))"}
{"solution": "def predict_outcome(n, fractions):\n    \"\"\"\n    Predict the outcome of the vote based on the given fractions and their optimal behavior.\n\n    Args:\n    n (int): The number of employees.\n    fractions (str): A string of 'D's and 'R's representing the fractions of the employees.\n\n    Returns:\n    str: The predicted outcome of the vote, either 'D' or 'R'.\n    \"\"\"\n    # Initialize the counts of 'D's and 'R's\n    d_count = fractions.count('D')\n    r_count = n - d_count\n\n    # If the number of 'D's is greater than the number of 'R's, 'D' will win\n    if d_count > r_count:\n        return 'D'\n    # If the number of 'R's is greater than the number of 'D's, 'R' will win\n    elif r_count > d_count:\n        return 'R'\n    # If the number of 'D's and 'R's is equal, the outcome depends on the last employee\n    else:\n        # If the last employee is 'D', 'D' will win\n        if fractions[-1] == 'D':\n            return 'D'\n        # If the last employee is 'R', 'R' will win\n        else:\n            return 'R'\n\n# Read the input\nn = int(input())\nfractions = input()\n\n# Predict and print the outcome\nprint(predict_outcome(n, fractions))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_tv_sets(a, b, x, y):\n    g = gcd(x, y)\n    x //= g\n    y //= g\n\n    max_w = a // x\n    max_h = b // y\n\n    min_w = math.ceil(1 / x)\n    min_h = math.ceil(1 / y)\n\n    max_wh = min(max_w, max_h)\n    min_wh = max(min_w, min_h)\n\n    return max(0, max_wh - min_wh + 1)\n\na, b, x, y = map(int, input().split())\nprint(count_tv_sets(a, b, x, y))"}
{"solution": "import math\n\ndef prime_factors(n):\n    \"\"\"Returns a dictionary of prime factors and their powers\"\"\"\n    factors = {}\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors[i] = factors.get(i, 0) + 1\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef count_trailing_zeros(n, b):\n    \"\"\"Returns the number of trailing zeros in the b-ary representation of n!\"\"\"\n    factors = prime_factors(b)\n    min_count = float('inf')\n    for p in factors:\n        count = 0\n        i = p\n        while i <= n:\n            count += n // i\n            i *= p\n        count //= factors[p]\n        min_count = min(min_count, count)\n    return min_count\n\nn, b = map(int, input().split())\nprint(count_trailing_zeros(n, b))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nm, a, b = map(int, input().split())\ng = gcd(a, b)\nif a > b:\n    a, b = b, a\nif a == b:\n    print((m + 1) * (m + 2) // 2)\nelse:\n    print((m // b + 1) * (m // b + 2) // 2 * b + (m % b) // a * (m // b + 1) + (m % b) // g)"}
{"solution": "def can_divide_into_odd_subsegments(n, sequence):\n    \"\"\"\n    Decide whether it is possible to divide the given sequence into an odd number of non-empty subsegments,\n    each of which has an odd length and begins and ends with odd numbers.\n\n    Args:\n        n (int): The length of the sequence.\n        sequence (list): The elements of the sequence.\n\n    Returns:\n        bool: True if it's possible to fulfill the requirements, False otherwise.\n    \"\"\"\n    # Initialize a variable to track the number of subsegments\n    subsegments = 0\n\n    # Initialize a variable to track the current subsegment length\n    current_length = 0\n\n    # Iterate over the sequence\n    for i, num in enumerate(sequence):\n        # If the number is odd, it could be the start or end of a subsegment\n        if num % 2!= 0:\n            # If this is the start of a new subsegment, increment the subsegment count\n            if current_length == 0:\n                subsegments += 1\n            # Increment the current subsegment length\n            current_length += 1\n        else:\n            # If the number is even, it can't be the start or end of a subsegment\n            # If the current subsegment length is odd, it's a valid subsegment\n            if current_length % 2!= 0:\n                # Reset the current subsegment length\n                current_length = 0\n            else:\n                # If the current subsegment length is even, it's not a valid subsegment\n                # Return False\n                return False\n\n    # If the last subsegment is valid, return True if the total number of subsegments is odd\n    return subsegments % 2!= 0 and current_length % 2!= 0\n\n\n# Read the input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Print the output\nprint(\"Yes\" if can_divide_into_odd_subsegments(n, sequence) else \"No\")"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    # Calculate the distance between the two given points\n    distance = abs(x2 - x1)\n\n    # Check if the points are on the same x or y axis\n    if x1 == x2:\n        # If the points are on the same x axis, the remaining points will be on the same y axis\n        x3, y3 = x1 + distance, y2\n        x4, y4 = x1 + distance, y1\n    elif y1 == y2:\n        # If the points are on the same y axis, the remaining points will be on the same x axis\n        x3, y3 = x2, y1 + distance\n        x4, y4 = x1, y1 + distance\n    else:\n        # If the points are not on the same x or y axis, there is no solution\n        return -1\n\n    return x3, y3, x4, y4\n\n\n# Read the input\nx1, y1, x2, y2 = map(int, input().split())\n\n# Find the remaining trees\nresult = find_remaining_trees(x1, y1, x2, y2)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def matrix_multiply(a, b, mod):\n    c = [[0, 0], [0, 0]]\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                c[i][j] += a[i][k] * b[k][j]\n            c[i][j] %= mod\n    return c\n\ndef matrix_power(matrix, n, mod):\n    if n == 1:\n        return matrix\n    if n % 2 == 0:\n        half_pow = matrix_power(matrix, n // 2, mod)\n        return matrix_multiply(half_pow, half_pow, mod)\n    else:\n        half_pow = matrix_power(matrix, n // 2, mod)\n        return matrix_multiply(matrix_multiply(half_pow, half_pow, mod), matrix, mod)\n\ndef calculate_f_n(x, y, n, mod):\n    if n == 1:\n        return x\n    if n == 2:\n        return y\n    matrix = [[1, 1], [1, 0]]\n    result_matrix = matrix_power(matrix, n - 2, mod)\n    return (result_matrix[0][0] * y - result_matrix[0][1] * x) % mod\n\nmod = 10**9 + 7\nx, y = map(int, input().split())\nn = int(input())\nprint(calculate_f_n(x, y, n, mod))"}
{"solution": "def split_array(n, arr):\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n\n    if prefix_sum[n] == 0:\n        return \"NO\"\n\n    result = []\n    start = 0\n    for i in range(1, n + 1):\n        if prefix_sum[i]!= 0 and prefix_sum[i]!= prefix_sum[n]:\n            result.append((start + 1, i))\n            start = i\n\n    result.append((start + 1, n))\n    return \"YES\\n\" + str(len(result)) + \"\\n\" + \"\\n\".join(map(lambda x: \"{} {}\".format(x[0], x[1]), result))\n\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(split_array(n, arr))"}
{"solution": "def min_score(n, m, k):\n    mod = 10**9 + 9\n    if m < n // k * (k - 1) + n % k:\n        return m\n    else:\n        return (n // k - 1) * (k - 1) + n % k + (m - (n // k - 1) * (k - 1) - n % k) // k * 2 + (m - (n // k - 1) * (k - 1) - n % k) % k\n\nn, m, k = map(int, input().split())\nprint(min_score(n, m, k) % (10**9 + 9))"}
{"solution": "def is_divisible_by_8(num):\n    return num % 8 == 0\n\ndef find_divisible_by_8(num_str):\n    for i in range(len(num_str)):\n        for j in range(i + 1, len(num_str) + 1):\n            substr = num_str[i:j]\n            if substr[0]!= '0' and is_divisible_by_8(int(substr)):\n                return substr\n    return None\n\ndef main():\n    num_str = input()\n    divisible_str = find_divisible_by_8(num_str)\n    if divisible_str is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(divisible_str)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_floor(n, m, flats):\n    min_flats_per_floor = 1\n    max_flats_per_floor = n\n\n    for flat, floor in flats:\n        min_flats_per_floor = max(min_flats_per_floor, (flat - 1) // (floor - 1) + 1)\n        max_flats_per_floor = min(max_flats_per_floor, (flat - 1) // (floor - 1) + 1)\n\n    if min_flats_per_floor == max_flats_per_floor:\n        return (n - 1) // min_flats_per_floor + 1\n    else:\n        return -1\n\n\nn, m = map(int, input().split())\nflats = [tuple(map(int, input().split())) for _ in range(m)]\n\nprint(find_floor(n, m, flats))"}
{"solution": "def max_bishwocks():\n    board1 = input()\n    board2 = input()\n    n = len(board1)\n    board = [[board1[i], board2[i]] for i in range(n)]\n    \n    bishwock_shapes = [\n        [(0, 0), (0, 1), (1, 0)],  \n        [(0, 0), (0, 1), (1, 1)],  \n        [(0, 1), (1, 0), (1, 1)],  \n        [(0, 0), (1, 0), (1, 1)]   \n    ]\n    \n    def can_place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            if nx >= 2 or ny >= n or board[ny][nx] == 'X':\n                return False\n        return True\n    \n    def place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            board[ny][nx] = 'X'\n    \n    count = 0\n    for y in range(n):\n        for x in range(2):\n            for shape in bishwock_shapes:\n                if can_place_bishwock(x, y, shape):\n                    place_bishwock(x, y, shape)\n                    count += 1\n                    break\n    \n    return count\n\nprint(max_bishwocks())"}
{"solution": "def max_pretty_set_length(n, s):\n    max_length = 0\n    current_set = set()\n    \n    for char in s:\n        if char.islower():\n            current_set.add(char)\n        else:\n            max_length = max(max_length, len(current_set))\n            current_set.clear()\n    \n    # Check the last segment\n    max_length = max(max_length, len(current_set))\n    \n    return max_length\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult = max_pretty_set_length(n, s)\n\n# Print the result\nprint(result)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\na.sort(reverse=True)\nprint(sum(a))"}
{"solution": "def min_refuel(a, b, f, k):\n    if 2 * a * k > b:\n        return -1\n\n    if f * 2 > b:\n        return -1\n\n    if (a - f) * 2 > b:\n        return -1\n\n    if (a - f) * 2 <= b and f * 2 <= b:\n        return 0\n\n    if (a - f) * 2 <= b:\n        return k\n\n    if f * 2 <= b:\n        return k\n\n    return k * 2\n\n\na, b, f, k = map(int, input().split())\nprint(min_refuel(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    result = []\n    i = 0\n    while i < n:\n        if i + q <= n:\n            result.append(s[i:i+q])\n            i += q\n        elif i + p <= n:\n            result.append(s[i:i+p])\n            i += p\n        else:\n            return \"-1\"\n    return str(len(result)) + \"\\n\" + \"\\n\".join(result)\n\nn, p, q = map(int, input().split())\ns = input()\nprint(split_string(n, p, q, s))"}
{"solution": "def solve(n, m, s, d, obstacles):\n    obstacles.sort()\n    current_position = 0\n    result = []\n    for obstacle in obstacles:\n        if obstacle - current_position < s:\n            return \"IMPOSSIBLE\"\n        result.append(f\"RUN {min(s, obstacle - current_position)}\")\n        current_position += min(s, obstacle - current_position)\n        if current_position + d >= obstacle + 1:\n            result.append(f\"JUMP {min(d, m - current_position)}\")\n            current_position += min(d, m - current_position)\n        else:\n            return \"IMPOSSIBLE\"\n    if current_position < m:\n        result.append(f\"RUN {m - current_position}\")\n    return \"\\n\".join(result)\n\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\nprint(solve(n, m, s, d, obstacles))"}
{"solution": "def solve(s, x):\n    if (s - x) % 2!= 0:\n        return 0\n    b = (s - x) // 2\n    a = s - b\n    if a > 0 and b > 0 and a!= b:\n        return 4\n    elif a > 0 and b > 0 and a == b:\n        return 2\n    else:\n        return 0\n\ns, x = map(int, input().split())\nprint(solve(s, x))"}
{"solution": "def solve(n, k):\n    if n <= 2 * k:\n        return [1]\n    elif n == 2 * k + 1:\n        return [1, n]\n    else:\n        result = []\n        i = 1\n        while i <= n:\n            result.append(i)\n            i += 2 * k + 1\n        if i - 2 * k > n:\n            result[-1] = n\n        return result\n\nn, k = map(int, input().split())\nresult = solve(n, k)\nprint(len(result))\nprint(*result)"}
{"solution": "import math\n\nn = input().strip()\nn_len = len(n)\n\nmax_square_root = int(math.sqrt(2 * 10**9)) + 1\nsquares = [str(i * i) for i in range(1, max_square_root + 1)]\n\ndef is_subsequence(small, large):\n    it = iter(large)\n    return all(char in it for char in small)\n\nmin_deletions = float('inf')\n\nfor square in squares:\n    if is_subsequence(square, n):\n        deletions = n_len - len(square)\n        min_deletions = min(min_deletions, deletions)\n\nprint(min_deletions if min_deletions!= float('inf') else -1)"}
{"solution": "import math\n\nMOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef mod_permutations(n, k):\n    return (mod_factorial(n) * mod_inverse(mod_factorial(n - k), MOD)) % MOD\n\ndef main():\n    n = int(input())\n    if n <= 3:\n        print(mod_permutations(n, n))\n    else:\n        print((mod_permutations(n - 1, n - 1) * (n - 1)) % MOD)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def minimum_jump_ability():\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    s = input()\n    positions = [-1]  # Start position before the first character\n    \n    # Collect positions of all vowels\n    for i, char in enumerate(s):\n        if char in vowels:\n            positions.append(i)\n    \n    positions.append(len(s))  # End position after the last character\n    \n    # Calculate maximum distance between consecutive positions\n    max_distance = 0\n    for i in range(1, len(positions)):\n        max_distance = max(max_distance, positions[i] - positions[i - 1])\n    \n    print(max_distance)\n\nminimum_jump_ability()"}
{"solution": "def can_distribute_equally(a):\n    total_sum = sum(a)\n    if total_sum % 2!= 0:\n        return False\n\n    target_sum = total_sum // 2\n    a.sort(reverse=True)\n\n    def dfs(index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(a):\n            return False\n\n        return dfs(index + 1, current_sum + a[index]) or dfs(index + 1, current_sum)\n\n    return dfs(0, 0)\n\n\na = list(map(int, input().split()))\nprint(\"YES\" if can_distribute_equally(a) else \"NO\")"}
{"solution": "def calculate_pie_sums(n, pie_sizes):\n    alice_sum = 0\n    bob_sum = 0\n    alice_turn = False\n\n    for i in range(n - 1, -1, -1):\n        if alice_turn:\n            if pie_sizes[i] >= pie_sizes[i - 1]:\n                alice_sum += pie_sizes[i]\n                alice_turn = False\n            else:\n                alice_sum += pie_sizes[i - 1]\n                alice_turn = False\n        else:\n            if pie_sizes[i] >= pie_sizes[i - 1]:\n                bob_sum += pie_sizes[i - 1]\n                alice_turn = True\n            else:\n                bob_sum += pie_sizes[i]\n                alice_turn = True\n\n    return alice_sum, bob_sum\n\n\nn = int(input())\npie_sizes = list(map(int, input().split()))\n\nalice_sum, bob_sum = calculate_pie_sums(n, pie_sizes)\n\nprint(alice_sum, bob_sum)"}
{"solution": "def min_variables(n, sequence):\n    max_num = max(sequence)\n    max_bits = max_num.bit_length()\n    max_mask = (1 << max_bits) - 1\n\n    dp = [0] * (max_mask + 1)\n    dp[0] = 1\n\n    for num in sequence:\n        new_dp = dp[:]\n        for mask in range(max_mask + 1):\n            if dp[mask] == 0:\n                continue\n            for i in range(max_bits):\n                if (mask >> i) & 1:\n                    for j in range(max_bits):\n                        if (mask >> j) & 1:\n                            new_mask = mask ^ (1 << i) ^ (1 << j) ^ (1 << num.bit_length() - 1)\n                            new_dp[new_mask] = 1\n        dp = new_dp\n\n    for i in range(max_mask + 1):\n        if dp[i] == 1 and bin(i).count('1') == num.bit_length():\n            return bin(i).count('1')\n\n    return -1\n\n\nn = int(input())\nsequence = list(map(int, input().split()))\nprint(min_variables(n, sequence))"}
{"solution": "def determine_winner(n, piles):\n    odd_count = sum(1 for pile in piles if pile % 2!= 0)\n    if odd_count % 2 == 0:\n        return \"Alice\" if min(piles) % 2!= 0 else \"Bob\"\n    else:\n        return \"Alice\"\n\nn = int(input())\npiles = list(map(int, input().split()))\n\nprint(determine_winner(n, piles))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(\"YES\")\n    exit()\n\ng = 0\nfor i in range(1, n):\n    g = gcd(g, abs(a[i] - a[0]))\n\nif g == 0:\n    print(\"YES\")\nelse:\n    for i in range(n):\n        if abs(a[i] - a[0]) % g!= 0:\n            print(\"NO\")\n            exit()\n    print(\"YES\")"}
{"solution": "def longest_repeated_substring(n, s):\n    max_length = 0\n    for length in range(1, n // 2 + 1):\n        for i in range(n - length):\n            substring = s[i:i + length]\n            if s.find(substring, i + length)!= -1:\n                max_length = max(max_length, length)\n    return max_length\n\nn = int(input())\ns = input()\nprint(longest_repeated_substring(n, s))"}
{"solution": "def minimum_time_to_house(n, a):\n    if a % 2 == 1:\n        # a is odd\n        return (a + 1) // 2\n    else:\n        # a is even\n        return (n - a + 2) // 2\n\n# Read input\nn, a = map(int, input().split())\n\n# Calculate and print the result\nprint(minimum_time_to_house(n, a))"}
{"solution": "def find_interval(n, m, colors, counts):\n    \"\"\"\n    Find if there exists a contiguous interval of Jedi Knights with prescribed color counts.\n\n    Args:\n    n (int): The number of Jedi Knights.\n    m (int): The number of possible colors.\n    colors (list): A list of colors of the lightsabers of the Jedi Knights.\n    counts (list): A list of desired counts of lightsabers of each color.\n\n    Returns:\n    bool: True if an interval with prescribed color counts exists, False otherwise.\n    \"\"\"\n    # Initialize a dictionary to store the current counts of each color\n    current_counts = {i: 0 for i in range(1, m + 1)}\n\n    # Initialize the left and right pointers of the sliding window\n    left = 0\n    right = 0\n\n    # Initialize a flag to check if the current window meets the required counts\n    meets_counts = False\n\n    # Expand the right pointer to include more elements in the window\n    while right < n:\n        # Add the color at the right pointer to the current counts\n        current_counts[colors[right]] += 1\n\n        # Check if the current window meets the required counts\n        meets_counts = all(current_counts[i] == counts[i - 1] for i in range(1, m + 1))\n\n        # If the current window meets the required counts, return True\n        if meets_counts:\n            return True\n\n        # If the current window exceeds the required counts, move the left pointer\n        while any(current_counts[i] > counts[i - 1] for i in range(1, m + 1)):\n            # Remove the color at the left pointer from the current counts\n            current_counts[colors[left]] -= 1\n\n            # Move the left pointer to the right\n            left += 1\n\n            # Check if the current window meets the required counts\n            meets_counts = all(current_counts[i] == counts[i - 1] for i in range(1, m + 1))\n\n            # If the current window meets the required counts, return True\n            if meets_counts:\n                return True\n\n        # Move the right pointer to the right\n        right += 1\n\n    # If no valid window is found, return False\n    return False\n\n\n# Read the input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\ncounts = list(map(int, input().split()))\n\n# Find if an interval with prescribed color counts exists\nresult = find_interval(n, m, colors, counts)\n\n# Print the result\nprint(\"YES\" if result else \"NO\")"}
{"solution": "def determine_winner():\n    n = int(input())\n    mishka_wins = 0\n    chris_wins = 0\n    \n    for _ in range(n):\n        m, c = map(int, input().split())\n        if m > c:\n            mishka_wins += 1\n        elif c > m:\n            chris_wins += 1\n    \n    if mishka_wins > chris_wins:\n        return \"Mishka\"\n    elif chris_wins > mishka_wins:\n        return \"Chris\"\n    else:\n        return \"Friendship is magic!^^\"\n\nprint(determine_winner())"}
{"solution": "def is_valid_field(n, m, field):\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                continue\n\n            if field[i][j] == '.':\n                for d in directions:\n                    ni, nj = i + d[0], j + d[1]\n                    if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':\n                        return False\n            else:\n                count = 0\n                for d in directions:\n                    ni, nj = i + d[0], j + d[1]\n                    if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':\n                        count += 1\n                if count!= int(field[i][j]):\n                    return False\n\n    return True\n\n\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\nprint(\"YES\" if is_valid_field(n, m, field) else \"NO\")"}
{"solution": "def can_vasya_eat_half(n, k):\n    total_candies = n\n    vasya_eaten = 0\n    \n    while total_candies > 0:\n        # Vasya eats k candies\n        vasya_eaten += min(k, total_candies)\n        total_candies -= min(k, total_candies)\n        \n        # Petya eats 10% of the remaining candies\n        petya_eaten = total_candies // 10\n        total_candies -= petya_eaten\n    \n    return vasya_eaten >= (n + 1) // 2\n\ndef find_min_k(n):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\nn = int(input().strip())\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace():\n    s = input()\n    p = s.count('o')\n    l = s.count('-')\n    \n    if p == 0 or p == 1:\n        print(\"YES\")\n    elif l % p == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\ncan_rearrange_necklace()"}
{"solution": "def max_pillows(n, m, k):\n    # Calculate the number of pillows that can be distributed equally\n    equal_pillows = m // n\n    \n    # Calculate the number of remaining pillows\n    remaining_pillows = m % n\n    \n    # If Frodo is at the edge, he can have one more pillow than the others\n    if k == 1 or k == n:\n        return equal_pillows + remaining_pillows\n    \n    # If Frodo is in the middle, he can have at most one more pillow than the others\n    # But we need to make sure that the hobbits on either side of him don't have two fewer pillows\n    # So we need to distribute the remaining pillows to the hobbits on either side of him\n    # We can do this by giving one extra pillow to the hobbit on the side with the most pillows\n    # This way, the difference in pillows between Frodo and his neighbors is at most one\n    return equal_pillows + min(remaining_pillows, 1)\n\nn, m, k = map(int, input().split())\nprint(max_pillows(n, m, k))"}
{"solution": "import math\n\ndef max_subarray_cost(n, m, k, a):\n    max_cost = 0\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    for length in range(1, m + 1):\n        dp = [float('-inf')] * (n + 1)\n        for i in range(length, n + 1):\n            dp[i] = max(dp[i - 1], prefix_sum[i] - prefix_sum[i - length] - k * math.ceil(length / m))\n            max_cost = max(max_cost, dp[i])\n\n    return max_cost\n\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\nprint(max_subarray_cost(n, m, k, a))"}
{"solution": "import math\n\ndef distance(p1, p2):\n    \"\"\"Calculate the Euclidean distance between two points.\"\"\"\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef longest_polyline(n, m):\n    \"\"\"Find the longest possible polyline on a rectangular grid.\"\"\"\n    points = [(0, 0), (n, 0), (n, m), (0, m)]\n    max_length = 0\n    best_points = None\n\n    for p1 in points:\n        for p2 in points:\n            if p1 == p2:\n                continue\n            for p3 in points:\n                if p3 in (p1, p2):\n                    continue\n                for p4 in points:\n                    if p4 in (p1, p2, p3):\n                        continue\n                    length = distance(p1, p2) + distance(p2, p3) + distance(p3, p4)\n                    if length > max_length:\n                        max_length = length\n                        best_points = [p1, p2, p3, p4]\n\n    return best_points\n\ndef main():\n    n, m = map(int, input().split())\n    points = longest_polyline(n, m)\n    for point in points:\n        print(*point)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_smallest_number(shuffled_string, remembered_substring):\n    # Find the length of the original number\n    for i in range(len(shuffled_string) - 1, -1, -1):\n        if shuffled_string[i].isdigit():\n            original_length = int(shuffled_string[i])\n            break\n\n    # Remove the length from the shuffled string\n    shuffled_string = shuffled_string[:i]\n\n    # Initialize the result with the remembered substring\n    result = remembered_substring\n\n    # Initialize a set of used digits\n    used_digits = set(remembered_substring)\n\n    # Initialize a counter for the number of digits in the result\n    result_length = len(remembered_substring)\n\n    # Iterate over the shuffled string\n    for digit in shuffled_string:\n        # If the digit is not in the used digits and adding it to the result does not exceed the original length\n        if digit not in used_digits and result_length < original_length:\n            # Add the digit to the result and the used digits\n            result += digit\n            used_digits.add(digit)\n            result_length += 1\n\n    # If the result is still shorter than the original length, add the remaining digits from the shuffled string\n    if result_length < original_length:\n        for digit in shuffled_string:\n            if digit not in used_digits:\n                result += digit\n                used_digits.add(digit)\n                result_length += 1\n                if result_length == original_length:\n                    break\n\n    # Remove any leading zeroes from the result\n    result = result.lstrip('0') or '0'\n\n    return result\n\n\nshuffled_string = input()\nremembered_substring = input()\nprint(find_smallest_number(shuffled_string, remembered_substring))"}
{"solution": "def check_temperature_consistency(n, m, min_temp, max_temp, temperatures):\n    \"\"\"\n    Checks if the given temperatures can be extended to meet the minimum and maximum constraints.\n\n    Args:\n        n (int): The total number of temperatures.\n        m (int): The number of temperatures reported by the assistant.\n        min_temp (int): The minimum temperature.\n        max_temp (int): The maximum temperature.\n        temperatures (list): The list of temperatures reported by the assistant.\n\n    Returns:\n        bool: True if the temperatures can be extended, False otherwise.\n    \"\"\"\n    # Check if the minimum temperature is already present in the reported temperatures\n    if min_temp not in temperatures:\n        # If not, we need to add it\n        temperatures.append(min_temp)\n        m += 1\n\n    # Check if the maximum temperature is already present in the reported temperatures\n    if max_temp not in temperatures:\n        # If not, we need to add it\n        temperatures.append(max_temp)\n        m += 1\n\n    # Check if we have exceeded the total number of temperatures\n    if m > n:\n        return False\n\n    # Check if we can add the remaining temperatures without violating the constraints\n    remaining_temps = n - m\n    if remaining_temps > 0:\n        # We can add the remaining temperatures as long as they are within the range\n        # [min_temp, max_temp]\n        return True\n\n    # If we have not returned False by now, it means the temperatures can be extended\n    return True\n\n\ndef main():\n    # Read the input\n    n, m, min_temp, max_temp = map(int, input().split())\n    temperatures = list(map(int, input().split()))\n\n    # Check if the temperatures can be extended\n    if check_temperature_consistency(n, m, min_temp, max_temp, temperatures):\n        print(\"Correct\")\n    else:\n        print(\"Incorrect\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef find_trailing_zeroes(m):\n    \"\"\"\n    Find the number of positive integers n, such that the factorial of n ends with exactly m zeroes.\n\n    Args:\n    m (int): The required number of trailing zeroes in factorial.\n\n    Returns:\n    list: A list containing the count of numbers and the numbers themselves.\n    \"\"\"\n    count = 0\n    numbers = []\n\n    # Calculate the upper limit for n\n    upper_limit = m * 5\n\n    # Iterate over the possible values of n\n    for n in range(5, upper_limit + 1):\n        # Calculate the number of trailing zeroes in n!\n        trailing_zeroes = 0\n        i = 5\n        while n // i >= 1:\n            trailing_zeroes += n // i\n            i *= 5\n\n        # Check if the number of trailing zeroes is equal to m\n        if trailing_zeroes == m:\n            count += 1\n            numbers.append(n)\n\n    return [count] + numbers\n\n# Read the input\nm = int(input())\n\n# Find the numbers with exactly m trailing zeroes\nresult = find_trailing_zeroes(m)\n\n# Print the result\nprint(result[0])\nif result[0] > 0:\n    print(*result[1:])"}
{"solution": "import sys\nimport heapq\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef dijkstra(graph, start, special_vertices):\n    distances = [float('inf')] * len(graph)\n    distances[start] = 0\n    queue = [(0, start)]\n\n    while queue:\n        current_distance, current_vertex = heapq.heappop(queue)\n\n        if current_distance > distances[current_vertex]:\n            continue\n\n        for neighbor, weight in graph[current_vertex]:\n            distance = max(current_distance, weight)\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return [distances[vertex] for vertex in special_vertices]\n\ndef main():\n    n, m, k = read_ints()\n    special_vertices = list(read_ints())\n    graph = [[] for _ in range(n + 1)]\n\n    for _ in range(m):\n        u, v, w = read_ints()\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    max_distances = [0] * k\n\n    for i, vertex in enumerate(special_vertices):\n        distances = dijkstra(graph, vertex, special_vertices)\n        max_distances[i] = max(distances[:i] + distances[i + 1:])\n\n    print(*max_distances)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def initial_shell_position(n, x):\n    \"\"\"\n    Calculate the initial position of the ball in the shell game.\n\n    Parameters:\n    n (int): The number of movements made by the operator.\n    x (int): The index of the shell where the ball was found after n movements.\n\n    Returns:\n    int: The index of the shell where the ball was initially placed.\n    \"\"\"\n    # Calculate the remainder of n divided by 3\n    remainder = n % 3\n    \n    # If the remainder is 0, the ball is in the same position as the initial position\n    if remainder == 0:\n        return x\n    \n    # If the remainder is 1, the ball is in the position that is one to the left of the initial position\n    elif remainder == 1:\n        if x == 0:\n            return 2\n        else:\n            return x - 1\n    \n    # If the remainder is 2, the ball is in the position that is one to the right of the initial position\n    else:\n        if x == 2:\n            return 0\n        else:\n            return x + 1\n\n\n# Read the input\nn = int(input())\nx = int(input())\n\n# Calculate and print the initial shell position\nprint(initial_shell_position(n, x))"}
{"solution": "def is_square(rectangles):\n    # Calculate the bounding box\n    min_x = min(rectangle[0] for rectangle in rectangles)\n    max_x = max(rectangle[2] for rectangle in rectangles)\n    min_y = min(rectangle[1] for rectangle in rectangles)\n    max_y = max(rectangle[3] for rectangle in rectangles)\n\n    # Check if the bounding box is a square\n    if max_x - min_x!= max_y - min_y:\n        return False\n\n    # Check if the rectangles cover the entire bounding box\n    covered = [[False] * (max_x - min_x) for _ in range(max_y - min_y)]\n    for x1, y1, x2, y2 in rectangles:\n        for x in range(x1, x2):\n            for y in range(y1, y2):\n                if min_x <= x < max_x and min_y <= y < max_y:\n                    covered[y - min_y][x - min_x] = True\n\n    # Check if all points in the bounding box are covered\n    for row in covered:\n        for cell in row:\n            if not cell:\n                return False\n\n    return True\n\n\nn = int(input())\nrectangles = [list(map(int, input().split())) for _ in range(n)]\n\nif is_square(rectangles):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def digit_sum(x):\n    return sum(int(digit) for digit in str(x))\n\ndef count_big_numbers(n, s):\n    count = 0\n    for i in range(1, n + 1):\n        if i - digit_sum(i) >= s:\n            count += 1\n    return count\n\nn, s = map(int, input().split())\nprint(count_big_numbers(n, s))"}
{"solution": "from collections import defaultdict\nfrom math import gcd\nfrom functools import reduce\n\ndef get_slope(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    if x1 == x2:\n        return float('inf')\n    return (y2 - y1) / (x2 - x1)\n\ndef get_gcd(a, b):\n    return reduce(gcd, [a, b])\n\ndef get_slope_gcd(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    dx = x2 - x1\n    dy = y2 - y1\n    g = get_gcd(dx, dy)\n    return (dx // g, dy // g)\n\ndef solve(points):\n    n = len(points)\n    if n <= 2:\n        return True\n\n    slopes = defaultdict(set)\n    for i in range(n):\n        for j in range(i + 1, n):\n            slope = get_slope_gcd(points[i], points[j])\n            slopes[slope].add(i)\n            slopes[slope].add(j)\n\n    max_cover = 0\n    for slope in slopes:\n        max_cover = max(max_cover, len(slopes[slope]))\n\n    return max_cover >= n - 2\n\ndef main():\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    if solve(points):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def mod_inverse(a, m):\n    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_power(base, exponent, mod):\n    \"\"\"Compute base^exponent modulo mod\"\"\"\n    result = 1\n    base = base % mod\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % mod\n        exponent = exponent >> 1\n        base = (base * base) % mod\n    return result\n\ndef mod_multiply(a, b, mod):\n    \"\"\"Compute a*b modulo mod\"\"\"\n    return (a * b) % mod\n\ndef mod_add(a, b, mod):\n    \"\"\"Compute a+b modulo mod\"\"\"\n    return (a + b) % mod\n\ndef mod_subtract(a, b, mod):\n    \"\"\"Compute a-b modulo mod\"\"\"\n    return (a - b) % mod\n\ndef calculate_combinations(n, k, mod):\n    \"\"\"Compute the number of combinations of n items taken k at a time modulo mod\"\"\"\n    if k > n - k:\n        k = n - k\n    result = 1\n    for i in range(k):\n        result = mod_multiply(result, (n - i), mod)\n        result = mod_multiply(result, mod_inverse(i + 1, mod), mod)\n    return result\n\ndef calculate_winning_games(a, b, k, t, mod):\n    \"\"\"Compute the number of games where Memory wins\"\"\"\n    total_games = mod_power(2 * k + 1, 2 * t, mod)\n    losing_games = 0\n    for diff in range(-t * k, t * k + 1):\n        if diff + b - a < 0:\n            continue\n        if diff + b - a > t * k:\n            continue\n        losing_games = mod_add(losing_games, calculate_combinations(t * k + t * k, diff + b - a + t * k, mod), mod)\n    winning_games = mod_subtract(total_games, losing_games, mod)\n    return winning_games\n\ndef main():\n    mod = 10**9 + 7\n    a, b, k, t = map(int, input().split())\n    winning_games = calculate_winning_games(a, b, k, t, mod)\n    print(winning_games)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_measure(a, x):\n    for i in range(len(a)):\n        for j in range(i, len(a)):\n            if a[j] - a[i] == x:\n                return True\n    return False\n\ndef solve(n, l, x, y, a):\n    if can_measure(a, x) and can_measure(a, y):\n        return 0, []\n    elif can_measure(a, x):\n        if y in a:\n            return 0, []\n        else:\n            return 1, [y]\n    elif can_measure(a, y):\n        if x in a:\n            return 0, []\n        else:\n            return 1, [x]\n    else:\n        if y - x in a:\n            return 1, [y - x + x]\n        elif x + y in a:\n            return 1, [x + y - x]\n        elif y - x in [a[i] - a[j] for i in range(len(a)) for j in range(i)]:\n            return 1, [y]\n        elif x + y in [a[i] - a[j] for i in range(len(a)) for j in range(i)]:\n            return 1, [x]\n        else:\n            return 2, [x, y]\n\nn, l, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\nv, p = solve(n, l, x, y, a)\nprint(v)\nprint(*p)"}
{"solution": "import math\n\ndef calculate_volume(radius, height):\n    return math.pi * radius * radius * height\n\ndef solve():\n    n = int(input())\n    cakes = []\n    for _ in range(n):\n        radius, height = map(int, input().split())\n        cakes.append((radius, height, calculate_volume(radius, height)))\n\n    cakes.sort(key=lambda x: x[2])\n\n    dp = [0] * n\n    dp[0] = cakes[0][2]\n\n    for i in range(1, n):\n        max_volume = 0\n        for j in range(i):\n            if cakes[i][0] > cakes[j][0] and cakes[i][2] > cakes[j][2]:\n                max_volume = max(max_volume, dp[j])\n        dp[i] = max(max_volume + cakes[i][2], dp[i-1])\n\n    return dp[-1]\n\nprint(solve())"}
{"solution": "import math\n\ndef min_slices(n, k, heights):\n    heights.sort()\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + heights[i]\n\n    def cost(height):\n        return prefix_sum[n] - prefix_sum[heights.index(height)] - height * (n - heights.index(height))\n\n    def can_slice(height, slices):\n        if slices == 1:\n            return cost(height) <= k\n        else:\n            return cost(height) <= k * slices\n\n    def binary_search(low, high, slices):\n        while low < high:\n            mid = (low + high) // 2\n            if can_slice(heights[mid], slices):\n                low = mid + 1\n            else:\n                high = mid\n        return low\n\n    min_slices = math.ceil(math.log2(n))\n    for slices in range(1, min_slices + 1):\n        index = binary_search(0, n, slices)\n        if index == n:\n            return slices\n\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\nprint(min_slices(n, k, heights))"}
{"solution": "def max_score(n, a):\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    max_score = float('-inf')\n\n    for l in range(n):\n        max_in_segment = float('-inf')\n        for r in range(l, n):\n            max_in_segment = max(max_in_segment, a[r])\n            segment_sum = prefix_sum[r + 1] - prefix_sum[l]\n            score = segment_sum - max_in_segment\n            max_score = max(max_score, score)\n\n    return max_score\n\nn = int(input())\na = list(map(int, input().split()))\nprint(max_score(n, a))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve():\n    k1, k2, k3 = map(int, input().split())\n    if lcm(k1, lcm(k2, k3)) > max(k1, k2, k3) * 2:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n\nsolve()"}
{"solution": "def min_operations_to_delete_string(n, s):\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = 1\n    \n    for length in range(2, n + 1):  \n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j-1]\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n    \n    return dp[0][n-1]\n\nn = int(input())\ns = input().strip()\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "def max_pairs(boys, girls):\n    boys.sort()\n    girls.sort()\n    i, j = 0, 0\n    pairs = 0\n    while i < len(boys) and j < len(girls):\n        if abs(boys[i] - girls[j]) <= 1:\n            pairs += 1\n            i += 1\n            j += 1\n        elif boys[i] < girls[j]:\n            i += 1\n        else:\n            j += 1\n    return pairs\n\nn = int(input())\nboys = list(map(int, input().split()))\nm = int(input())\ngirls = list(map(int, input().split()))\n\nprint(max_pairs(boys, girls))"}
{"solution": "def determine_winner():\n    team1 = [list(map(int, input().split())) for _ in range(2)]\n    team2 = [list(map(int, input().split())) for _ in range(2)]\n\n    team1_defence = max(team1[0][0], team1[1][0])\n    team1_attack = min(team1[0][1], team1[1][1])\n\n    team2_defence = max(team2[0][0], team2[1][0])\n    team2_attack = min(team2[0][1], team2[1][1])\n\n    if team1_defence > team2_attack and team1_attack > team2_defence:\n        return \"Team 1\"\n    elif team2_defence > team1_attack and team2_attack > team1_defence:\n        return \"Team 2\"\n    else:\n        return \"Draw\"\n\nprint(determine_winner())"}
{"solution": "import math\nimport sys\n\ndef dist(x1, y1, x2, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef check(x, y, k, arr):\n    times = []\n    for x_i, y_i, c_i in arr:\n        times.append(c_i * dist(x, y, x_i, y_i))\n    times.sort()\n    return times[k - 1]\n\ndef solve():\n    n, k = map(int, input().split())\n    arr = []\n    for _ in range(n):\n        x_i, y_i, c_i = map(int, input().split())\n        arr.append((x_i, y_i, c_i))\n\n    min_x, max_x = min(x for x, _, _ in arr), max(x for x, _, _ in arr)\n    min_y, max_y = min(y for _, y, _ in arr), max(y for _, y, _ in arr)\n\n    step = 0.1\n    ans = sys.maxsize\n    for x in [i * step for i in range(int(min_x / step), int(max_x / step) + 1)]:\n        for y in [i * step for i in range(int(min_y / step), int(max_y / step) + 1)]:\n            ans = min(ans, check(x, y, k, arr))\n\n    print(round(ans, 6))\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def calculate_difference(s, n):\n    \"\"\"Calculate the difference between the sum of the first half and the sum of the second half.\"\"\"\n    first_half_sum = sum(int(s[i]) for i in range(n // 2) if s[i]!= '?')\n    second_half_sum = sum(int(s[i]) for i in range(n // 2, n) if s[i]!= '?')\n    return first_half_sum - second_half_sum\n\n\ndef can_monocarp_win(s, n):\n    \"\"\"Determine if Monocarp can win.\"\"\"\n    difference = calculate_difference(s, n)\n    first_half_unknown = s[:n // 2].count('?')\n    second_half_unknown = s[n // 2:].count('?')\n    \n    # If the difference is not a multiple of 9, Monocarp can win.\n    if difference % 9!= 0:\n        return True\n    \n    # If the number of unknown digits in both halves is not equal, Monocarp can win.\n    if first_half_unknown!= second_half_unknown:\n        return True\n    \n    # If the number of unknown digits in both halves is odd, Monocarp can win.\n    if first_half_unknown % 2!= 0:\n        return True\n    \n    return False\n\n\ndef main():\n    n = int(input())\n    s = input()\n    \n    if can_monocarp_win(s, n):\n        print(\"Monocarp\")\n    else:\n        print(\"Bicarp\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_bus_route():\n    n, t = map(int, input().split())\n    earliest_time = float('inf')\n    chosen_route = -1\n    \n    for i in range(n):\n        s_i, d_i = map(int, input().split())\n        \n        if s_i >= t:\n            next_bus_time = s_i\n        else:\n            # Calculate the next bus time after t\n            if (t - s_i) % d_i == 0:\n                next_bus_time = t\n            else:\n                next_bus_time = s_i + ((t - s_i) // d_i + 1) * d_i\n        \n        if next_bus_time < earliest_time:\n            earliest_time = next_bus_time\n            chosen_route = i + 1\n    \n    print(chosen_route)\n\nfind_bus_route()"}
{"solution": "def count_ones(n):\n    \"\"\"Count the number of ones in the binary representation of n.\"\"\"\n    return bin(n).count('1')\n\ndef find_n(m, k):\n    \"\"\"Find the smallest n such that there are exactly m numbers in the range [n+1, 2n] with k ones in their binary representation.\"\"\"\n    n = 1\n    while True:\n        count = sum(1 for i in range(n + 1, 2 * n + 1) if count_ones(i) == k)\n        if count == m:\n            return n\n        n += 1\n\nm, k = map(int, input().split())\nprint(find_n(m, k))"}
{"solution": "def is_good_level(level):\n    platforms = [i for i, x in enumerate(level) if x == '*']\n    for i in range(len(platforms) - 4):\n        interval = platforms[i + 1] - platforms[i]\n        if all(platforms[i + j + 1] - platforms[i + j] == interval for j in range(3)):\n            return True\n    return False\n\nn = int(input())\nlevel = input().strip()\n\nprint('yes' if is_good_level(level) else 'no')"}
{"solution": "def find_magic_number(n, grid):\n    # Find the position of the empty cell\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                empty_row, empty_col = i, j\n\n    # Calculate the expected sum of each row, column, and diagonal\n    expected_sum = sum(grid[0])\n\n    # Check if the expected sum is consistent across all rows and columns\n    for i in range(1, n):\n        if sum(grid[i])!= expected_sum:\n            return -1\n\n    for j in range(n):\n        col_sum = sum(grid[k][j] for k in range(n))\n        if col_sum!= expected_sum:\n            return -1\n\n    # Calculate the sum of the main diagonal\n    main_diagonal_sum = sum(grid[k][k] for k in range(n))\n    if main_diagonal_sum!= expected_sum:\n        return -1\n\n    # Calculate the sum of the secondary diagonal\n    secondary_diagonal_sum = sum(grid[k][n - k - 1] for k in range(n))\n    if secondary_diagonal_sum!= expected_sum:\n        return -1\n\n    # Calculate the sum of the row and column containing the empty cell\n    row_sum = sum(grid[empty_row])\n    col_sum = sum(grid[k][empty_col] for k in range(n))\n\n    # Calculate the magic number\n    magic_number = expected_sum - row_sum + grid[empty_row][empty_col]\n    if magic_number <= 0:\n        return -1\n\n    return magic_number\n\n\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\nprint(find_magic_number(n, grid))"}
{"solution": "import math\n\n# Read the number of benches\nn = int(input())\n\n# Read the number of additional people\nm = int(input())\n\n# Initialize a list to store the initial number of people on each bench\na = []\n\n# Read the initial number of people on each bench\nfor _ in range(n):\n    a.append(int(input()))\n\n# Calculate the maximum possible k\nmax_k = max(a) + m\n\n# Calculate the total number of people after adding m people\ntotal_people = sum(a) + m\n\n# Calculate the minimum possible k\nmin_k = math.ceil(total_people / n)\n\n# Print the minimum and maximum possible k\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef pow_mod(a, b):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = (res * a) % MOD\n        a = (a * a) % MOD\n        b >>= 1\n    return res\n\ndef inv_mod(a):\n    return pow_mod(a, MOD - 2)\n\ndef main():\n    n, m = map(int, input().split())\n    if m > n:\n        print(0)\n        return\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n\n    inv_fact = [1] * (n + 1)\n    inv_fact[n] = inv_mod(fact[n])\n    for i in range(n - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD\n\n    def choose(a, b):\n        return (fact[a] * inv_fact[b] * inv_fact[a - b]) % MOD\n\n    res = 0\n    for k in range(m + 1):\n        res = (res + choose(n, k) * pow_mod(2, k) * pow_mod(2, m - k) * choose(m, k) * choose(n - k, m - k)) % MOD\n\n    print(res)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import defaultdict\nfrom itertools import combinations\n\ndef solve():\n    n, m = map(int, input().split())\n    friends = []\n    for _ in range(n):\n        f = list(map(int, input().split()))[1:]\n        friends.append(set(f))\n\n    pizzas = []\n    for _ in range(m):\n        c, r, *a = map(int, input().split())\n        pizzas.append((c, set(a)))\n\n    max_friends = 0\n    min_cost = float('inf')\n    best_pizzas = None\n\n    for i, (c1, p1) in enumerate(pizzas):\n        for j, (c2, p2) in enumerate(pizzas[i+1:], i+1):\n            if c1 + c2 > min_cost:\n                continue\n            pleased_friends = sum(1 for f in friends if f.issubset(p1 | p2))\n            if pleased_friends > max_friends or (pleased_friends == max_friends and c1 + c2 < min_cost):\n                max_friends = pleased_friends\n                min_cost = c1 + c2\n                best_pizzas = (i+1, j+1)\n\n    print(*best_pizzas)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def find_min_max(m, s):\n    if s == 0:\n        if m == 1:\n            return \"0 0\"\n        else:\n            return \"-1 -1\"\n    if m * 9 < s or s < m:\n        return \"-1 -1\"\n\n    min_num = ''\n    max_num = ''\n\n    # Construct the minimum number\n    for _ in range(m):\n        if s > 9:\n            min_num += '9'\n            s -= 9\n        else:\n            if _ == 0 and s > 0:\n                min_num += str(s)\n            else:\n                min_num += '0'\n            s = 0\n\n    # Construct the maximum number\n    for _ in range(m):\n        if s > 9:\n            max_num = '9' + max_num\n            s -= 9\n        else:\n            if _ == 0 and s > 0:\n                max_num = str(s) + max_num\n            else:\n                max_num = '0' + max_num\n            s = 0\n\n    return min_num +'' + max_num\n\n\nm, s = map(int, input().split())\nprint(find_min_max(m, s))"}
{"solution": "MOD = 998244353\n\ndef count_numbers_with_at_most_k_digits(n, k):\n    if k == 0:\n        return 0\n    if k == 1:\n        return sum(i * (10 ** (len(str(i)) - 1)) for i in range(1, 10))\n\n    dp = [[0] * 11 for _ in range(20)]\n    for i in range(10):\n        dp[0][i] = i\n\n    for i in range(1, len(str(n)) + 1):\n        for j in range(1, 11):\n            for d in range(10):\n                if j > 1:\n                    dp[i][j] += dp[i - 1][j - 1] * (10 ** (i - 1))\n                dp[i][j] += dp[i - 1][j] * (10 ** (i - 1)) * (10 - j + 1)\n                dp[i][j] %= MOD\n\n    res = 0\n    for i in range(1, len(str(n)) + 1):\n        for j in range(1, k + 1):\n            res += dp[i][j]\n            res %= MOD\n\n    return res\n\ndef sum_of_numbers_with_at_most_k_digits(l, r, k):\n    return (count_numbers_with_at_most_k_digits(r, k) - count_numbers_with_at_most_k_digits(l - 1, k) + MOD) % MOD\n\nl, r, k = map(int, input().split())\nprint(sum_of_numbers_with_at_most_k_digits(l, r, k))"}
{"solution": "import sys\n\ndef main():\n    n, k, d = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] - a[i] <= d:\n            j += 1\n        if j - i >= k:\n            i = j\n        else:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_dead_bulbs(garland):\n    colors = ['R', 'B', 'Y', 'G']\n    dead_bulbs = {color: 0 for color in colors}\n\n    for i in range(len(garland)):\n        if garland[i] == '!':\n            possible_colors = [color for color in colors if color not in garland[i-1:i+3] and color!= garland[(i-4) % len(garland)]]\n            dead_bulbs[possible_colors[0]] += 1\n\n    return dead_bulbs\n\ngarland = input()\ndead_bulbs = count_dead_bulbs(garland)\nprint(dead_bulbs['R'], dead_bulbs['B'], dead_bulbs['Y'], dead_bulbs['G'])"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_list():\n    return list(map(int, read_input().split()))\n\ndef read_matrix(n):\n    return [read_list() for _ in range(n)]\n\ndef read_graph(n, m):\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = read_ints()\n        graph[u].append(v)\n    return graph\n\ndef solve():\n    n, m = read_ints()\n    graph = read_graph(n, m)\n    out_degree = [len(graph[i]) for i in range(1, n + 1)]\n    expected = [0] * (n + 1)\n    expected[n] = 0\n\n    for _ in range(n - 1):\n        for i in range(1, n + 1):\n            if i == n:\n                continue\n            total = 0\n            for j in graph[i]:\n                total += expected[j] + 1\n            expected[i] = total / out_degree[i]\n\n    min_expected = float('inf')\n    for i in range(1, n + 1):\n        if i == n:\n            continue\n        for j in graph[i]:\n            new_expected = 0\n            for k in graph[i]:\n                if k == j:\n                    continue\n                new_expected += expected[k] + 1\n            new_expected /= (out_degree[i] - 1)\n            min_expected = min(min_expected, new_expected)\n\n    print(min_expected)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def round_to_nearest_multiple_of_ten(n):\n    remainder = n % 10\n    if remainder <= 4:\n        return n - remainder\n    else:\n        return n + (10 - remainder)\n\nn = int(input())\nprint(round_to_nearest_multiple_of_ten(n))"}
{"solution": "def find_swaps(s, t):\n    if len(s)!= len(t):\n        print(-1)\n        return\n    \n    mismatches = {}\n    \n    for i in range(len(s)):\n        if s[i]!= t[i]:\n            if s[i] in mismatches and mismatches[s[i]]!= t[i]:\n                print(-1)\n                return\n            if t[i] in mismatches and mismatches[t[i]]!= s[i]:\n                print(-1)\n                return\n            mismatches[s[i]] = t[i]\n            mismatches[t[i]] = s[i]\n    \n    visited = set()\n    swaps = []\n    \n    for key in mismatches:\n        if key not in visited:\n            cycle = []\n            current = key\n            while current not in visited:\n                visited.add(current)\n                cycle.append(current)\n                current = mismatches[current]\n            if len(cycle)!= 2:\n                print(-1)\n                return\n            swaps.append((cycle[0], cycle[1]))\n    \n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0], swap[1])\n\ns = input()\nt = input()\nfind_swaps(s, t)"}
{"solution": "def earliest_login(first_name, last_name):\n    earliest = first_name[0] + last_name[0]\n    for i in range(1, len(first_name)):\n        for j in range(1, len(last_name)):\n            login = first_name[:i+1] + last_name[:j+1]\n            if login < earliest:\n                earliest = login\n    return earliest\n\nfirst_name, last_name = input().split()\nprint(earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(n, brackets):\n    stack = []\n    max_height = 0\n    for bracket in brackets:\n        if bracket == '[':\n            stack.append(bracket)\n            max_height = max(max_height, len(stack))\n        else:\n            stack.pop()\n\n    lines = [''] * max_height\n    stack = []\n    for bracket in brackets:\n        if bracket == '[':\n            stack.append(bracket)\n            height = len(stack)\n            lines[height - 1] += '+'\n            for i in range(height - 2, -1, -1):\n                lines[i] += '|'\n        else:\n            height = len(stack)\n            lines[height - 1] += '-'\n            for i in range(height - 2, -1, -1):\n                lines[i] += '|'\n            stack.pop()\n\n    for i in range(max_height):\n        if i == 0:\n            print(lines[i].replace('||', '| |'))\n        else:\n            print(lines[i].replace('||', '| |'))\n\nn = int(input())\nbrackets = input()\ndraw_brackets(n, brackets)"}
{"solution": "def normalize_golden_number(golden_number):\n    golden_number = list(map(int, golden_number))\n    n = len(golden_number)\n    \n    for i in range(n - 1, 0, -1):\n        if golden_number[i] > 1:\n            golden_number[i] -= 2\n            golden_number[i - 1] += 1\n            if i - 2 >= 0:\n                golden_number[i - 2] += 1\n    \n    while len(golden_number) > 1 and golden_number[0] == 0:\n        golden_number.pop(0)\n    \n    return golden_number\n\ndef compare_golden_numbers(num1, num2):\n    norm_num1 = normalize_golden_number(num1)\n    norm_num2 = normalize_golden_number(num2)\n    \n    if len(norm_num1) > len(norm_num2):\n        return \">\"\n    elif len(norm_num1) < len(norm_num2):\n        return \"<\"\n    \n    for digit1, digit2 in zip(norm_num1, norm_num2):\n        if digit1 > digit2:\n            return \">\"\n        elif digit1 < digit2:\n            return \"<\"\n    \n    return \"=\"\n\nnum1 = input().strip()\nnum2 = input().strip()\n\nresult = compare_golden_numbers(num1, num2)\nprint(result)"}
{"solution": "def find_absent_gems():\n    gems = {\n        \"purple\": \"Power\",\n        \"green\": \"Time\",\n        \"blue\": \"Space\",\n        \"orange\": \"Soul\",\n        \"red\": \"Reality\",\n        \"yellow\": \"Mind\"\n    }\n\n    n = int(input())\n    present_gems = [input() for _ in range(n)]\n\n    absent_gems = [gems[gem] for gem in gems if gem not in present_gems]\n\n    print(len(absent_gems))\n    for gem in absent_gems:\n        print(gem)\n\nfind_absent_gems()"}
{"solution": "def find_meeting_round(n, a, b):\n    \"\"\"\n    Determine the round in which two teams with ids a and b can meet in a play-off system.\n\n    Args:\n    n (int): The total number of teams.\n    a (int): The id of the first team.\n    b (int): The id of the second team.\n\n    Returns:\n    str or int: The round in which the teams can meet, or \"Final!\" if they can meet in the final.\n    \"\"\"\n    # Initialize the round number\n    round_num = 1\n\n    # Continue until the teams meet\n    while True:\n        # Calculate the position of each team in the current round\n        a_pos = (a - 1) // (n // 2) + 1\n        b_pos = (b - 1) // (n // 2) + 1\n\n        # If the teams are in the same position, they meet in this round\n        if a_pos == b_pos:\n            # If there are only two teams left, they meet in the final\n            if n == 2:\n                return \"Final!\"\n            else:\n                return round_num\n\n        # Move to the next round\n        n //= 2\n        round_num += 1\n\n\n# Read the input\nn, a, b = map(int, input().split())\n\n# Find and print the meeting round\nprint(find_meeting_round(n, a, b))"}
{"solution": "def min_changes(n, p, b):\n    # Find the number of cycles in the permutation\n    cycles = 0\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            cycles += 1\n            j = i\n            while not visited[j]:\n                visited[j] = True\n                j = p[j] - 1\n\n    # Calculate the minimum number of changes\n    changes = 0\n    if cycles > 1:\n        changes += cycles - 1\n    if sum(b) % 2 == 0:\n        changes += 1\n    return changes\n\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(min_changes(n, p, b))"}
{"solution": "def calculate_max_distance(v1, v2, t, d):\n    \"\"\"\n    Calculate the maximum possible length of the path section in meters.\n\n    Args:\n    v1 (int): The speed in meters per second at the beginning of the segment.\n    v2 (int): The speed in meters per second at the end of the segment.\n    t (int): The time when the car moves along the segment in seconds.\n    d (int): The maximum value of the speed change between adjacent seconds.\n\n    Returns:\n    int: The maximum possible length of the path section in meters.\n    \"\"\"\n    # Calculate the total distance if the car accelerates or decelerates uniformly\n    if v1 < v2:\n        # Calculate the number of seconds the car accelerates\n        accelerate_seconds = min((v2 - v1) // d, t - 1)\n        # Calculate the remaining seconds\n        remaining_seconds = t - accelerate_seconds - 1\n        # Calculate the speed at the end of the acceleration phase\n        end_accelerate_speed = v1 + accelerate_seconds * d\n        # Calculate the total distance\n        total_distance = (v1 + end_accelerate_speed) * accelerate_seconds // 2 + end_accelerate_speed * remaining_seconds + v2\n    elif v1 > v2:\n        # Calculate the number of seconds the car decelerates\n        decelerate_seconds = min((v1 - v2) // d, t - 1)\n        # Calculate the remaining seconds\n        remaining_seconds = t - decelerate_seconds - 1\n        # Calculate the speed at the end of the deceleration phase\n        end_decelerate_speed = v1 - decelerate_seconds * d\n        # Calculate the total distance\n        total_distance = (v1 + end_decelerate_speed) * decelerate_seconds // 2 + end_decelerate_speed * remaining_seconds + v2\n    else:\n        # If the initial and final speeds are the same, the car moves at a constant speed\n        total_distance = v1 * t\n\n    return total_distance\n\n\n# Read the input\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Calculate and print the maximum possible length of the path section\nprint(calculate_max_distance(v1, v2, t, d))"}
{"solution": "import sys\nimport itertools\n\ndef check_order(order, weights, parts):\n    total_length = 0\n    for i, part in enumerate(parts):\n        length, capacity = part\n        total_length += length\n        max_weight = 0\n        for j in range(len(order)):\n            if j > 0 and total_length - length < sum(weights[order[k]] for k in range(j)):\n                max_weight = max(max_weight, sum(weights[order[k]] for k in range(j, len(order)) if total_length - length < sum(weights[order[k]] for k in range(j, len(order))) < total_length))\n        if max_weight > capacity:\n            return False\n    return True\n\ndef main():\n    input_lines = sys.stdin.readlines()\n    n, m = map(int, input_lines[0].split())\n    weights = list(map(int, input_lines[1].split()))\n    parts = [list(map(int, line.split())) for line in input_lines[2:]]\n\n    min_distance = float('inf')\n    for order in itertools.permutations(range(n)):\n        if check_order(order, weights, parts):\n            min_distance = min(min_distance, sum(part[0] for part in parts))\n\n    if min_distance == float('inf'):\n        print(-1)\n    else:\n        print(min_distance)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def last_digit_factorial(n):\n    \"\"\"Calculate the last digit of n!\"\"\"\n    if n < 5:\n        result = 1\n        for i in range(1, n + 1):\n            result *= i\n        return result % 10\n    else:\n        return 0\n\ndef last_digit_division(a, b):\n    \"\"\"Calculate the last digit of b! / a!\"\"\"\n    if a >= 5:\n        return 0\n    else:\n        return last_digit_factorial(b) // last_digit_factorial(a)\n\na, b = map(int, input().split())\nprint(last_digit_division(a, b))"}
{"solution": "from collections import deque\n\ndef min_jumps(n, d, s):\n    queue = deque([(1, 0)])\n    visited = set([1])\n\n    while queue:\n        pos, jumps = queue.popleft()\n\n        if pos == n:\n            return jumps\n\n        for jump in range(1, min(d + 1, n - pos + 1)):\n            new_pos = pos + jump\n\n            if s[new_pos - 1] == '1' and new_pos not in visited:\n                queue.append((new_pos, jumps + 1))\n                visited.add(new_pos)\n\n    return -1\n\nn, d = map(int, input().split())\ns = input()\n\nprint(min_jumps(n, d, s))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_counterexample(n):\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\nn = int(input().strip())\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all_coins(n):\n    \"\"\"\n    Checks if it's possible to spend all initial game-coins buying houses, cars, and computers.\n\n    Args:\n    n (int): The initial game-coin score.\n\n    Returns:\n    bool: True if it's possible to spend all coins, False otherwise.\n    \"\"\"\n    house_cost = 1234567\n    car_cost = 123456\n    computer_cost = 1234\n\n    # Check if n is a multiple of the greatest common divisor of the costs\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    gcd_cost = gcd(gcd(house_cost, car_cost), computer_cost)\n    if n % gcd_cost!= 0:\n        return False\n\n    # Try to find a combination of houses, cars, and computers that sums up to n\n    for houses in range(n // house_cost + 1):\n        remaining_coins = n - houses * house_cost\n        for cars in range(remaining_coins // car_cost + 1):\n            remaining_coins_after_cars = remaining_coins - cars * car_cost\n            if remaining_coins_after_cars % computer_cost == 0:\n                return True\n\n    return False\n\n\nn = int(input())\nprint(\"YES\" if can_spend_all_coins(n) else \"NO\")"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n = int(read_input())\n    x1, x2 = read_ints()\n    lines = []\n    for _ in range(n):\n        k, b = read_ints()\n        lines.append((k, b))\n\n    lines.sort(key=lambda x: x[0])\n\n    for i in range(n - 1):\n        k1, b1 = lines[i]\n        k2, b2 = lines[i + 1]\n        if k1 == k2:\n            continue\n        x = (b2 - b1) / (k1 - k2)\n        if x1 < x < x2:\n            print(\"Yes\")\n            return\n\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef count_weights(n):\n    weights = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            weights.add(i)\n            weights.add(n // i)\n    return len(weights)\n\nn = int(input())\nprint(count_weights(n))"}
{"solution": "n, k = map(int, input().split())\n\nif k == 0:\n    min_good = 0\n    max_good = 0\nelse:\n    min_good = 1\n    max_good = min(n - k, 2 * k - (k == 1))\n\nprint(min_good, max_good)"}
{"solution": "import math\n\ndef max_games(n):\n    \"\"\"\n    Calculate the maximum number of games the winner of a knockout tournament can play.\n    \n    Parameters:\n    n (int): The number of players in the tournament.\n    \n    Returns:\n    int: The maximum number of games the winner can play.\n    \"\"\"\n    # Initialize the Fibonacci sequence\n    a, b = 1, 1\n    \n    # Initialize the number of games\n    games = 1\n    \n    # Continue generating Fibonacci numbers until we exceed the number of players\n    while b < n:\n        # Generate the next Fibonacci number\n        a, b = b, a + b\n        \n        # Increment the number of games\n        games += 1\n    \n    # Return the maximum number of games the winner can play\n    return games - 1\n\n# Read the number of players from the input\nn = int(input())\n\n# Calculate and print the maximum number of games the winner can play\nprint(max_games(n))"}
{"solution": "def max_vk(s):\n    vk_count = s.count(\"VK\")\n    v_count = s.count(\"V\")\n    k_count = s.count(\"K\")\n\n    if v_count > 1 and k_count > 1:\n        vk_count += 1\n    elif v_count > 1:\n        vk_count += 1\n    elif k_count > 1:\n        vk_count += 1\n\n    return vk_count\n\ns = input()\nprint(max_vk(s))"}
{"solution": "import math\n\ndef min_segments(n):\n    a = int(math.sqrt(n))\n    b = (n + a - 1) // a  \n    return a + b + 2\n\nn = int(input().strip())\nprint(min_segments(n))"}
{"solution": "def years_until_larger(a, b):\n    years = 0\n    while a <= b:\n        a *= 3\n        b *= 2\n        years += 1\n    return years\n\na, b = map(int, input().split())\nprint(years_until_larger(a, b))"}
{"solution": "def calculate_nodes_to_visit(h, n):\n    # Calculate the total number of nodes in the tree\n    total_nodes = 2 ** (h + 1) - 1\n\n    # Calculate the number of nodes to visit before reaching the exit\n    nodes_to_visit = total_nodes - 1\n\n    # If the exit is at an even position, we need to subtract the number of nodes in the right subtree\n    if n % 2 == 0:\n        right_subtree_nodes = 2 ** (h - 1) - 1\n        nodes_to_visit -= right_subtree_nodes\n\n    # If the exit is at an odd position, we need to subtract the number of nodes in the left subtree\n    else:\n        left_subtree_nodes = 2 ** (h - 1) - 1\n        nodes_to_visit -= left_subtree_nodes\n\n    # Adjust the number of nodes to visit based on the position of the exit\n    if n > 2 ** (h - 1):\n        nodes_to_visit += 2 * (n - 2 ** (h - 1)) - 1\n    else:\n        nodes_to_visit += 2 * (2 ** (h - 1) - n) - 1\n\n    return nodes_to_visit\n\n\nh, n = map(int, input().split())\nprint(calculate_nodes_to_visit(h, n))"}
{"solution": "import math\n\ndef find_pairs(x):\n    pairs = []\n    for n in range(1, int(math.sqrt(x)) + 1):\n        for m in range(n, x // n + 1):\n            if (n + 1) * (m + 1) - 1 == x:\n                pairs.append((n, m))\n                if n!= m:\n                    pairs.append((m, n))\n    return pairs\n\nx = int(input())\npairs = find_pairs(x)\nprint(len(pairs))\nfor pair in sorted(pairs):\n    print(pair[0], pair[1])"}
{"solution": "def is_leap_year(year):\n    \"\"\"Check if a year is a leap year.\"\"\"\n    return year % 4 == 0 and (year % 100!= 0 or year % 400 == 0)\n\n\ndef get_month_days(year, month):\n    \"\"\"Get the number of days in a month.\"\"\"\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return 31\n    elif month == 2:\n        return 29 if is_leap_year(year) else 28\n    else:\n        return 30\n\n\ndef check_sequence(sequence):\n    \"\"\"Check if a sequence of days can be consecutive months.\"\"\"\n    for year in range(2000, 2025):  # arbitrary range, can be adjusted\n        for month in range(1, 13):\n            if get_month_days(year, month) == sequence[0]:\n                match = True\n                for i in range(1, len(sequence)):\n                    next_month = (month + i) % 12 + 1\n                    next_year = year + (month + i - 1) // 12\n                    if get_month_days(next_year, next_month)!= sequence[i]:\n                        match = False\n                        break\n                if match:\n                    return True\n    return False\n\n\ndef main():\n    n = int(input())\n    sequence = list(map(int, input().split()))\n    if check_sequence(sequence):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve(n):\n    if n == 2:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n\n    factors = []\n    for i in range(2, n):\n        if n % i == 0:\n            factors.append(i)\n\n    sequence = []\n    remaining = 1 - 1 / n\n\n    for factor in factors:\n        if factor > 2:\n            a = factor - 1\n            b = factor\n            sequence.append((a, b))\n            remaining -= a / b\n            if remaining < 0:\n                break\n\n    if remaining > 0:\n        a = 1\n        b = 2\n        sequence.append((a, b))\n        remaining -= a / b\n\n    print(len(sequence))\n    for a, b in sequence:\n        print(a, b)\n\n\nn = int(input())\nsolve(n)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n = read_int()\n    a, b = read_ints()\n    h = read_ints()\n\n    total_height = sum(h)\n    if a < min(h) or b < min(h) or a + b < total_height:\n        return -1\n\n    dp = [[float('inf')] * (b + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(b + 1):\n            if j >= h[i - 1]:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j - h[i - 1]])\n            if j + h[i - 1] <= b and i > 1:\n                dp[i][j + h[i - 1]] = min(dp[i][j + h[i - 1]], dp[i - 1][j] + h[i - 1] + h[i - 2])\n\n    min_unattractiveness = float('inf')\n    for j in range(b + 1):\n        if a >= j and dp[n][j]!= float('inf'):\n            min_unattractiveness = min(min_unattractiveness, dp[n][j])\n\n    return min_unattractiveness\n\nprint(solve())"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef main():\n    n, m, k = map(int, input().split())\n    area = n * m / k\n\n    if area!= int(area):\n        print(\"NO\")\n        return\n\n    area = int(area)\n\n    for x1 in range(1, n + 1):\n        for y1 in range(m + 1):\n            for x2 in range(x1 + 1, n + 1):\n                y2 = y1\n                x3 = x1\n                y3 = m - y1\n\n                s1 = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2)\n                if s1 == area:\n                    print(\"YES\")\n                    print(x1, y1)\n                    print(x2, y2)\n                    print(x3, y3)\n                    return\n\n                s2 = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2)\n                x3 = x2\n                y3 = m - y1\n                if s2 == area:\n                    print(\"YES\")\n                    print(x1, y1)\n                    print(x2, y2)\n                    print(x3, y3)\n                    return\n\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def sasha_game(n, k):\n    if n % (2 * k) == 0:\n        return \"NO\"\n    else:\n        return \"YES\"\n\nn, k = map(int, input().split())\nprint(sasha_game(n, k))"}
{"solution": "n = int(input())\nexercises = list(map(int, input().split()))\n\nmuscle_groups = [\"chest\", \"biceps\", \"back\"]\nmuscle_repetitions = [0, 0, 0]\n\nfor i, repetition in enumerate(exercises):\n    muscle_repetitions[i % 3] += repetition\n\nmax_repetition = max(muscle_repetitions)\nmax_index = muscle_repetitions.index(max_repetition)\n\nprint(muscle_groups[max_index])"}
{"solution": "def min_redos_to_get_five(n, grades):\n    current_sum = sum(grades)\n    target_sum = n * 4.5\n    \n    if current_sum >= target_sum:\n        return 0\n    \n    grades.sort()\n    redos = 0\n    \n    for grade in grades:\n        if current_sum >= target_sum:\n            break\n        current_sum += (5 - grade)\n        redos += 1\n    \n    return redos\n\nn = int(input())\ngrades = list(map(int, input().split()))\nprint(min_redos_to_get_five(n, grades))"}
{"solution": "def solve(u, v):\n    if u > v:\n        return None\n    if u % 2!= v % 2:\n        return None\n    if u == 0 and v == 0:\n        return []\n    if u == v:\n        return [u]\n    if u == 0:\n        if v % 2 == 0:\n            return [v // 2, v // 2]\n        else:\n            return [1, v - 1, 1]\n    if v % 2 == 0:\n        return [u ^ (v - u) // 2, (v - u) // 2]\n    return [1, u ^ (v - 1) // 2, (v - 1) // 2]\n\nu, v = map(int, input().split())\nresult = solve(u, v)\nif result is None:\n    print(-1)\nelse:\n    print(len(result))\n    print(*result)"}
{"solution": "def min_ones(n):\n    \"\"\"Return the minimum number of digits '1' in the sum representation of n.\"\"\"\n    result = 0\n    while n > 0:\n        # Calculate the largest power of 10 that is less than or equal to n\n        power = 10 ** len(str(n))\n        # Calculate the number of '1's in the largest power of 10\n        ones = len(str(power)) * (n // power)\n        # Update the result and n\n        result += ones\n        n %= power\n    return result\n\nn = int(input())\nprint(min_ones(n))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\ndx = abs(x2 - x1)\ndy = abs(y2 - y1)\n\nif dx == 0 and dy % y == 0:\n    print(\"YES\")\nelif dy == 0 and dx % x == 0:\n    print(\"YES\")\nelif dx == 0 or dy == 0 or gcd(dx, x) == gcd(dy, y):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "from itertools import permutations\nfrom collections import Counter\n\ndef count_valid_bus_numbers(n):\n    # Convert the number to a string to extract digits\n    digits = list(str(n))\n    \n    # Count the frequency of each digit\n    digit_counts = Counter(digits)\n    \n    # Initialize the count of valid permutations\n    valid_permutations = 0\n    \n    # Generate all unique permutations of the digits\n    for perm in permutations(digits):\n        # Check if the permutation starts with '0'\n        if perm[0]!= '0':\n            # Count the frequency of each digit in the permutation\n            perm_counts = Counter(perm)\n            \n            # Check if the permutation is a sub-permutation of the original digits\n            if all(perm_counts[digit] <= digit_counts[digit] for digit in perm_counts):\n                valid_permutations += 1\n    \n    # Return the count of valid permutations\n    return valid_permutations\n\n# Read input\nn = int(input().strip())\n\n# Get the count of valid bus numbers\nresult = count_valid_bus_numbers(n)\n\n# Print the result\nprint(result)"}
{"solution": "def calculate_max_cost():\n    a = int(input())\n    b = int(input())\n    c = int(input())\n    d = int(input())\n    e = int(input())\n    f = int(input())\n\n    # Calculate the maximum number of suits of the first type\n    max_suits_first_type = min(a, d)\n\n    # Calculate the maximum number of suits of the second type\n    max_suits_second_type = min(b, c, d)\n\n    # Initialize the maximum cost\n    max_cost = 0\n\n    # Iterate over all possible combinations of suits\n    for suits_first_type in range(max_suits_first_type + 1):\n        remaining_jackets = d - suits_first_type\n        suits_second_type = min(remaining_jackets, b, c)\n        cost = suits_first_type * e + suits_second_type * f\n        max_cost = max(max_cost, cost)\n\n    print(max_cost)\n\ncalculate_max_cost()"}
{"solution": "def mod_inverse(a, p):\n    \"\"\"Compute the modular inverse of a modulo p.\"\"\"\n    return pow(a, p - 2, p)\n\ndef discrete_logarithm(a, b, p):\n    \"\"\"Compute the discrete logarithm of b with base a modulo p.\"\"\"\n    if b == 1:\n        return 0\n    if a == 1:\n        return float('inf')\n    if pow(a, (p - 1) // 2, p) == 1:\n        return discrete_logarithm(a, b, (p - 1) // 2)\n    if pow(a, (p - 1) // 2, p) == p - 1:\n        return discrete_logarithm(a, b * mod_inverse(a, p), (p - 1) // 2) + (p - 1) // 2\n    return discrete_logarithm(a, b * mod_inverse(a, p), p)\n\ndef solve(a, b, p, x):\n    \"\"\"Solve the congruence n * a^n \u2261 b (mod p) for 1 \u2264 n \u2264 x.\"\"\"\n    if b == 0:\n        return 1 if a == 0 else 0\n    if a == 1:\n        return 1 if b == 1 else 0\n    if pow(a, p - 1, p)!= 1:\n        return 0\n    if pow(a, (p - 1) // 2, p) == 1:\n        return solve(a, b, (p - 1) // 2, x)\n    if pow(a, (p - 1) // 2, p) == p - 1:\n        return solve(a, b * mod_inverse(a, p), (p - 1) // 2, x) + solve(a, b, (p - 1) // 2, x)\n    k = discrete_logarithm(a, b * mod_inverse(a, p), p)\n    if k == float('inf'):\n        return 0\n    return sum(1 for n in range(k, x + 1, p - 1) if n * pow(a, n, p) % p == b)\n\na, b, p, x = map(int, input().split())\nprint(solve(a, b, p, x))"}
{"solution": "def calculate_max_sum(k_2, k_3, k_5, k_6):\n    max_256 = min(k_2, k_5, k_6)\n    remaining_2 = max(0, k_2 - max_256)\n    max_32 = min(remaining_2, k_3)\n    return max_256 * 256 + max_32 * 32\n\nk_2, k_3, k_5, k_6 = map(int, input().split())\nprint(calculate_max_sum(k_2, k_3, k_5, k_6))"}
{"solution": "import math\n\nn, x, y, c = map(int, input().split())\n\nif c == 1:\n    print(0)\nelse:\n    if n == 1:\n        print(-1)\n    else:\n        if x == 1 or x == n:\n            if y == 1 or y == n:\n                print(math.ceil((math.sqrt(c) - 1) / 2))\n            else:\n                print(math.ceil((math.sqrt(c) - 2) / 2))\n        elif y == 1 or y == n:\n            print(math.ceil((math.sqrt(c) - 2) / 2))\n        else:\n            print(math.ceil((math.sqrt(c) - 3) / 2))"}
{"solution": "def max_xor(l, r):\n    if l == r:\n        return 0\n\n    max_val = 0\n    bit = 1\n    while bit <= r:\n        if l >= bit:\n            max_val |= bit\n        bit <<= 1\n\n    return max_val\n\nl, r = map(int, input().split())\nprint(max_xor(l, r))"}
{"solution": "def minimum_height():\n    n, k = map(int, input().split())\n    left, right = 1, k\n    \n    while left < right:\n        mid = (left + right) // 2\n        if n * mid >= k:\n            right = mid\n        else:\n            left = mid + 1\n    \n    print(left)\n\nminimum_height()"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    stairs_time = abs(x - y) * t1\n    \n    elevator_to_masha_time = abs(z - x) * t2 + t3\n    elevator_to_egor_time = abs(x - y) * t2 + 2 * t3\n    elevator_time = elevator_to_masha_time + elevator_to_egor_time\n    \n    if stairs_time < elevator_time:\n        return \"NO\"\n    else:\n        return \"YES\"\n\nx, y, z, t1, t2, t3 = map(int, input().split())\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "def calculate_a(n, m):\n    \"\"\"\n    Calculate the optimal value of a to maximize the probability of Andrew's victory.\n\n    Args:\n    n (int): The range of numbers in the game.\n    m (int): The number selected by Misha.\n\n    Returns:\n    int: The optimal value of a.\n    \"\"\"\n    # If m is at one of the extremes, a should be at the other extreme\n    if m == 1:\n        return n\n    elif m == n:\n        return 1\n    # If m is closer to one end, a should be closer to the other end\n    elif m < (n + 1) // 2:\n        return m + 1\n    else:\n        return m - 1\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the optimal value of a\nprint(calculate_a(n, m))"}
{"solution": "def count_pairs(n, schedule):\n    \"\"\"\n    Calculate the number of pairs Alena will stay at the university.\n\n    Args:\n    n (int): The number of lessons at the university.\n    schedule (list): A list of 0s and 1s representing the schedule.\n\n    Returns:\n    int: The number of pairs Alena will stay at the university.\n    \"\"\"\n    pairs = 0\n    i = 0\n    while i < n:\n        # If the current pair is not empty, increment the pairs count\n        if schedule[i] == 1:\n            pairs += 1\n            # If the current pair is not the last one, check the next pair\n            if i < n - 1:\n                # If the next pair is empty, check the pair after that\n                if schedule[i + 1] == 0:\n                    # If the pair after that is not empty, increment the pairs count\n                    if i < n - 2 and schedule[i + 2] == 1:\n                        pairs += 1\n        # Move to the next pair\n        i += 1\n    return pairs\n\n# Read the input\nn = int(input())\nschedule = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_pairs(n, schedule))"}
{"solution": "def min_days_to_give_candies(n, k, candies):\n    total_candies = 0\n    days = 0\n    for candy in candies:\n        total_candies += candy\n        days += 1\n        if total_candies >= k:\n            return days\n        total_candies -= min(candy, 8)\n    return -1 if total_candies < k else days\n\n\nn, k = map(int, input().split())\ncandies = list(map(int, input().split()))\nprint(min_days_to_give_candies(n, k, candies))"}
{"solution": "def minimum_additional_walks(n, k, a):\n    b = a[:]\n    additional_walks = 0\n    \n    # Consider the day before the first day\n    if b[0] < k:\n        needed_walks = k - b[0]\n        b[0] += needed_walks\n        additional_walks += needed_walks\n    \n    for i in range(n - 1):\n        if b[i] + b[i + 1] < k:\n            needed_walks = k - (b[i] + b[i + 1])\n            b[i + 1] += needed_walks\n            additional_walks += needed_walks\n    \n    # Consider the day after the n-th day\n    if b[-1] < k:\n        needed_walks = k - b[-1]\n        b[-1] += needed_walks\n        additional_walks += needed_walks\n    \n    return additional_walks, b\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nadditional_walks, b = minimum_additional_walks(n, k, a)\n\n# Print the result\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "def calculate_rhombus_cells(n):\n    return 2 * n**2 - 2 * n + 1\n\nn = int(input())\nprint(calculate_rhombus_cells(n))"}
{"solution": "def is_pangram(n, s):\n    alphabet = set('abcdefghijklmnopqrstuvwxyz')\n    return 'YES' if set(s.lower()).issuperset(alphabet) else 'NO'\n\nn = int(input())\ns = input()\nprint(is_pangram(n, s))"}
{"solution": "def calculate_time(time_str, minutes):\n    hours, mins = map(int, time_str.split(':'))\n    total_mins = hours * 60 + mins + minutes\n    new_hours = (total_mins // 60) % 24\n    new_mins = total_mins % 60\n    return f\"{new_hours:02d}:{new_mins:02d}\"\n\ntime_str = input()\nminutes = int(input())\nprint(calculate_time(time_str, minutes))"}
{"solution": "def can_ignore_switch(n, m, switches):\n    # Create a set to store the lamps that each switch can turn on\n    switch_lamps = [set() for _ in range(n)]\n    \n    # Populate the switch_lamps set\n    for i in range(n):\n        for j in range(m):\n            if switches[i][j] == '1':\n                switch_lamps[i].add(j)\n    \n    # Check if there is a switch that can be ignored\n    for i in range(n):\n        # Create a set to store the lamps that can be turned on by the other switches\n        other_lamps = set()\n        for j in range(n):\n            if i!= j:\n                other_lamps.update(switch_lamps[j])\n        \n        # If all lamps can be turned on by the other switches, return True\n        if len(other_lamps) == m:\n            return True\n    \n    # If no switch can be ignored, return False\n    return False\n\n# Read the input\nn, m = map(int, input().split())\nswitches = [input() for _ in range(n)]\n\n# Check if a switch can be ignored\nif can_ignore_switch(n, m, switches):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_time_to_rotate_dominoes(n, dominoes):\n    \"\"\"\n    Calculate the minimum time required to rotate dominoes to make the sum of the numbers on the upper halves and the sum of the numbers on the lower halves even.\n\n    Args:\n    n (int): The number of dominoes.\n    dominoes (list): A list of tuples, where each tuple contains two integers representing the numbers on the upper and lower halves of a domino.\n\n    Returns:\n    int: The minimum time required to rotate dominoes. If it's impossible to make the sums even, return -1.\n    \"\"\"\n\n    # Initialize variables to store the sums of the numbers on the upper and lower halves\n    upper_sum = 0\n    lower_sum = 0\n\n    # Initialize variables to store the counts of odd numbers on the upper and lower halves\n    upper_odd_count = 0\n    lower_odd_count = 0\n\n    # Iterate over the dominoes to calculate the sums and counts of odd numbers\n    for upper, lower in dominoes:\n        upper_sum += upper\n        lower_sum += lower\n        if upper % 2!= 0:\n            upper_odd_count += 1\n        if lower % 2!= 0:\n            lower_odd_count += 1\n\n    # If the sums are already even, no rotation is needed\n    if upper_sum % 2 == 0 and lower_sum % 2 == 0:\n        return 0\n\n    # If the counts of odd numbers are different, it's impossible to make the sums even\n    if upper_odd_count % 2!= lower_odd_count % 2:\n        return -1\n\n    # If the counts of odd numbers are both even, we need to rotate half of the dominoes with odd numbers\n    if upper_odd_count % 2 == 0:\n        return upper_odd_count // 2\n\n    # If the counts of odd numbers are both odd, we need to rotate one domino with an odd number on the upper half and one domino with an odd number on the lower half\n    return 1\n\n\n# Read the input\nn = int(input())\ndominoes = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the minimum time required to rotate dominoes\nprint(min_time_to_rotate_dominoes(n, dominoes))"}
{"solution": "import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    sqrt_n = math.isqrt(n)\n    for i in range(5, sqrt_n + 1, 6):\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n    return True\n\ndef solve():\n    a, b = map(int, input().split())\n    area = (a - b) * (a + b)\n    if is_prime(area):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nt = int(input())\nfor _ in range(t):\n    solve()"}
{"solution": "def can_remove_one_point(n, points):\n    positive_count = 0\n    negative_count = 0\n    \n    for x, y in points:\n        if x > 0:\n            positive_count += 1\n        else:\n            negative_count += 1\n    \n    if positive_count <= 1 or negative_count <= 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Reading input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_remove_one_point(n, points))"}
{"solution": "import math\n\ndef calculate_gcd_of_factorials():\n    a, b = map(int, input().split())\n    min_value = min(a, b)\n    gcd = math.factorial(min_value)\n    print(gcd)\n\ncalculate_gcd_of_factorials()"}
{"solution": "def find_composite_numbers(n):\n    if n % 2 == 0:\n        return n + 4, 4\n    else:\n        return n + 9, 9\n\nn = int(input())\na, b = find_composite_numbers(n)\nprint(a, b)"}
{"solution": "import sys\nimport heapq\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_list():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n, m, p = read_ints()\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, c = read_ints()\n        a -= 1\n        b -= 1\n        adj[a].append((b, c))\n\n    dist = [float('inf')] * n\n    dist[0] = 0\n    pq = [(0, 0)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, c in adj[u]:\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                heapq.heappush(pq, (dist[v], v))\n\n    if dist[-1] == float('inf'):\n        print(-1)\n        return\n\n    dp = [0] * n\n    for u in range(n):\n        for v, c in adj[u]:\n            dp[v] = max(dp[v], dp[u] + c)\n\n    ans = 0\n    for i in range(1, dist[-1] + 1):\n        coins = dp[-1] * i - p * i\n        if coins > ans:\n            ans = coins\n\n    print(ans)\n\nif __name__ == '__main__':\n    solve()"}
{"solution": "import sys\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef min_cost_to_palindrome(n, strings, costs):\n    min_cost = float('inf')\n    odd_count = 0\n    odd_cost = 0\n    even_cost = 0\n    for s, c in zip(strings, costs):\n        if len(s) % 2 == 1:\n            odd_count += 1\n            odd_cost += c\n        if is_palindrome(s):\n            even_cost += c\n    if odd_count > 1:\n        min_cost = min(min_cost, odd_cost)\n    for i in range(n):\n        for j in range(i + 1, n):\n            s1, s2 = strings[i], strings[j]\n            if len(s1) == len(s2) and s1 == s2[::-1]:\n                min_cost = min(min_cost, costs[i] + costs[j])\n            if len(s1) + len(s2) >= 2 and s1[1:] == s2[:-1][::-1]:\n                min_cost = min(min_cost, costs[i] + costs[j])\n            if len(s1) + len(s2) >= 2 and s1[:-1] == s2[1:][::-1]:\n                min_cost = min(min_cost, costs[i] + costs[j])\n    if min_cost == float('inf'):\n        return -1\n    return min_cost\n\nn = int(input())\nstrings = []\ncosts = []\nfor _ in range(n):\n    s, c = input().split()\n    strings.append(s)\n    costs.append(int(c))\nprint(min_cost_to_palindrome(n, strings, costs))"}
{"solution": "def largest_xor_sum(n, k):\n    # Find the number of bits in n\n    num_bits = n.bit_length()\n    # The largest possible xor-sum\n    max_xor_sum = (1 << num_bits) - 1\n    return max_xor_sum\n\nn, k = map(int, input().split())\nprint(largest_xor_sum(n, k))"}
{"solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    points = []\n    for _ in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x, y))\n\n    max_x = max(x for x, y in points)\n    max_y = max(y for x, y in points)\n\n    def check(side):\n        if side >= max_x and side >= max_y:\n            return True\n        if side < max_x and side < max_y:\n            return False\n        if side >= max_x:\n            return all(y <= side * x / max_x for x, y in points)\n        else:\n            return all(y <= max_y * x / side for x, y in points)\n\n    lo, hi = 0, max(max_x, max_y)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if check(mid):\n            hi = mid\n        else:\n            lo = mid + 1\n\n    print(lo)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_nineteens(s):\n    from collections import Counter\n    \n    char_count = Counter(s)\n    required_counts = {'n': 3, 'i': 1, 'e': 3, 't': 1}\n    \n    max_nineteens = float('inf')\n    for char, required in required_counts.items():\n        if char in char_count:\n            max_nineteens = min(max_nineteens, char_count[char] // required)\n        else:\n            return 0\n    \n    return max_nineteens\n\ns = input()\nprint(max_nineteens(s))"}
{"solution": "def highest_branch(p, y):\n    \"\"\"\n    Find the highest branch that cannot be reached by any of the grasshoppers.\n\n    Args:\n    p (int): The highest branch occupied by a grasshopper.\n    y (int): The total number of branches.\n\n    Returns:\n    int: The number of the highest suitable branch. If there are none, returns -1.\n    \"\"\"\n    # Initialize the highest branch to y\n    highest = y\n\n    # Iterate over each branch occupied by a grasshopper\n    for x in range(2, p + 1):\n        # Calculate the highest branch that can be reached by the grasshopper\n        reachable = x * (y // x)\n\n        # If the highest branch is reachable, update it\n        if reachable >= highest:\n            highest = reachable - 1\n\n    # If the highest branch is less than 2, return -1\n    if highest < 2:\n        return -1\n\n    return highest\n\n\n# Read the input\np, y = map(int, input().split())\n\n# Print the output\nprint(highest_branch(p, y))"}
{"solution": "def min_distance(n, m, k, houses):\n    \"\"\"\n    Calculate the minimum distance from the girl's house to a house Zane can afford.\n\n    Args:\n    n (int): The number of houses in the village.\n    m (int): The house where the girl lives.\n    k (int): The amount of money Zane has.\n    houses (list): A list of integers representing the availability and prices of the houses.\n\n    Returns:\n    int: The minimum distance from the girl's house to a house Zane can afford.\n    \"\"\"\n    min_distance = float('inf')\n\n    # Check houses to the left of the girl's house\n    for i in range(m - 1, -1, -1):\n        if houses[i]!= 0 and houses[i] <= k:\n            min_distance = min(min_distance, (m - i - 1) * 10)\n\n    # Check houses to the right of the girl's house\n    for i in range(m, n):\n        if houses[i]!= 0 and houses[i] <= k:\n            min_distance = min(min_distance, (i - m) * 10)\n\n    return min_distance\n\n\n# Read input\nn, m, k = map(int, input().split())\nhouses = list(map(int, input().split()))\n\n# Calculate and print the minimum distance\nprint(min_distance(n, m, k, houses))"}
{"solution": "from collections import defaultdict\n\ndef solve():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    b = [list(map(int, input().split())) for _ in range(n)]\n\n    rows = defaultdict(list)\n    cols = defaultdict(list)\n\n    for i in range(n):\n        for j in range(m):\n            rows[a[i][j]].append(i)\n            cols[a[i][j]].append(j)\n\n    for i in range(n):\n        for j in range(m):\n            if rows[b[i][j]]!= sorted(rows[b[i][j]]) or cols[b[i][j]]!= sorted(cols[b[i][j]]):\n                print(\"NO\")\n                return\n\n    print(\"YES\")\n\nsolve()"}
{"solution": "def longest_uncommon_subsequence(a, b):\n    if a == b:\n        return -1\n    else:\n        return max(len(a), len(b))\n\na = input()\nb = input()\n\nprint(longest_uncommon_subsequence(a, b))"}
{"solution": "def find_intersection(a, b, c, d):\n    \"\"\"\n    Find the first time Rick and Morty will scream at the same time.\n\n    Args:\n    a (int): The interval at which Rick screams.\n    b (int): The initial time at which Rick screams.\n    c (int): The interval at which Morty screams.\n    d (int): The initial time at which Morty screams.\n\n    Returns:\n    int: The first time Rick and Morty will scream at the same time, or -1 if they will never scream at the same time.\n    \"\"\"\n    # Calculate the least common multiple (LCM) of a and c\n    lcm = (a * c) // gcd(a, c)\n\n    # Initialize the time at which Rick screams\n    rick_time = b\n\n    # Initialize the time at which Morty screams\n    morty_time = d\n\n    # Loop until we find a common time or we exceed the maximum possible time\n    while rick_time <= 10000 and morty_time <= 10000:\n        # Check if Rick and Morty scream at the same time\n        if rick_time == morty_time:\n            return rick_time\n\n        # Update the time at which Rick screams\n        if rick_time < morty_time:\n            rick_time += lcm\n        # Update the time at which Morty screams\n        else:\n            morty_time += lcm\n\n    # If we exit the loop without finding a common time, return -1\n    return -1\n\n\ndef gcd(a, b):\n    \"\"\"\n    Calculate the greatest common divisor (GCD) of two numbers.\n\n    Args:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: The GCD of a and b.\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\n\n# Read the input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Find and print the first time Rick and Morty will scream at the same time\nprint(find_intersection(a, b, c, d))"}
{"solution": "def split_number(n):\n    if n % 3 == 0:\n        return [1, (n - 1) // 3, (n - 1) // 3 + 1]\n    elif n % 3 == 1:\n        return [(n - 1) // 3, (n - 1) // 3, (n - 1) // 3 + 1]\n    else:\n        return [(n - 2) // 3 + 1, (n - 2) // 3 + 1, (n - 2) // 3]\n\nn = int(input())\nprint(*split_number(n))"}
{"solution": "def calculate_squares(n, a, b, c, d):\n    \"\"\"\n    Calculate the number of distinct squares that satisfy all conditions.\n\n    Args:\n    n (int): Maximum possible value of an integer in the cell.\n    a (int): Value of the top right cell.\n    b (int): Value of the middle left cell.\n    c (int): Value of the middle right cell.\n    d (int): Value of the bottom left cell.\n\n    Returns:\n    int: Number of distinct squares that satisfy all conditions.\n    \"\"\"\n    # Calculate the sum of the top left 2x2 square\n    s = a + b + c + d\n\n    # Check if the sum is even\n    if s % 2!= 0:\n        return 0\n\n    # Calculate the sum of each 2x2 square\n    s //= 2\n\n    # Initialize the count of distinct squares\n    count = 0\n\n    # Iterate over all possible values for the top left cell\n    for x in range(1, n + 1):\n        # Calculate the value of the top middle cell\n        y = s - a - x\n\n        # Check if the value is within the range\n        if y < 1 or y > n:\n            continue\n\n        # Calculate the value of the middle left cell\n        z = s - b - x\n\n        # Check if the value is within the range\n        if z < 1 or z > n:\n            continue\n\n        # Calculate the value of the bottom middle cell\n        t = s - d - y\n\n        # Check if the value is within the range\n        if t < 1 or t > n:\n            continue\n\n        # Calculate the value of the bottom right cell\n        u = s - c - z\n\n        # Check if the value is within the range\n        if u < 1 or u > n:\n            continue\n\n        # Check if the sum of the bottom left 2x2 square is equal to the sum of the top left 2x2 square\n        if x + y + z + t == s * 2:\n            count += 1\n\n    return count\n\n\n# Read the input\nn, a, b, c, d = map(int, input().split())\n\n# Calculate and print the number of distinct squares\nprint(calculate_squares(n, a, b, c, d))"}
{"solution": "def calculate_snowball_weight():\n    # Read initial snowball weight and height\n    w, h = map(int, input().split())\n\n    # Read stone weights and heights\n    u1, d1 = map(int, input().split())\n    u2, d2 = map(int, input().split())\n\n    # Sort stones by height in descending order\n    stones = sorted([(d1, u1), (d2, u2)], reverse=True)\n\n    # Simulate snowball movement\n    for i in range(h, 0, -1):\n        # Increase snowball weight by current height\n        w += i\n\n        # Check if snowball hits a stone\n        for j, stone in enumerate(stones):\n            if stone[0] == i:\n                # Decrease snowball weight by stone weight\n                w -= stone[1]\n                # Remove stone from list\n                stones.pop(j)\n                # Ensure snowball weight is not negative\n                w = max(w, 0)\n                break\n\n    return w\n\nprint(calculate_snowball_weight())"}
{"solution": "def find_passing_rate(m, scores, x, y):\n    total_students = sum(scores)\n    prefix_sum = [0] * (m + 1)\n    \n    for i in range(m):\n        prefix_sum[i + 1] = prefix_sum[i] + scores[i]\n    \n    for k in range(1, m + 1):\n        beginner_group_size = prefix_sum[k]\n        intermediate_group_size = total_students - beginner_group_size\n        \n        if x <= beginner_group_size <= y and x <= intermediate_group_size <= y:\n            return k\n    \n    return 0\n\nm = int(input())\nscores = list(map(int, input().split()))\nx, y = map(int, input().split())\n\nprint(find_passing_rate(m, scores, x, y))"}
{"solution": "import math\n\ndef min_coins(n, k, A, B):\n    if k == 1:\n        return (n - 1) * A\n\n    coins = 0\n    while n > 1:\n        if n % k == 0:\n            if (n - 1) * A < B:\n                n -= 1\n                coins += A\n            else:\n                n //= k\n                coins += B\n        else:\n            if (k - (n % k)) * A < B:\n                n -= (n % k)\n                coins += (n % k) * A\n            else:\n                n -= 1\n                coins += A\n\n    return coins\n\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\nprint(min_coins(n, k, A, B))"}
{"solution": "import math\n\ndef prime_factors(n):\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef solve(n):\n    factors = prime_factors(n)\n    min_n = 1\n    for factor in set(factors):\n        count = factors.count(factor)\n        if count % 2 == 1:\n            min_n *= factor\n    operations = 0\n    while n > min_n:\n        sqrt_n = math.isqrt(n)\n        if sqrt_n ** 2 == n:\n            n = sqrt_n\n            operations += 1\n        else:\n            break\n    return min_n, operations\n\nn = int(input())\nmin_n, operations = solve(n)\nprint(min_n, operations)"}
{"solution": "def get_score(N, K, R, S, P, T):\n    scores = {'r': P,'s': R, 'p': S}\n    last_used = {'r': -1,'s': -1, 'p': -1}\n    total_score = 0\n\n    for i in range(N):\n        machine_hand = T[i]\n        player_hand = None\n        max_score = 0\n\n        for hand in 'rsp':\n            if hand!= machine_hand and last_used[hand] < i - K:\n                score = scores[hand]\n                if score > max_score:\n                    max_score = score\n                    player_hand = hand\n\n        if player_hand:\n            total_score += max_score\n            last_used[player_hand] = i\n\n    return total_score\n\n\nN, K = map(int, input().split())\nR, S, P = map(int, input().split())\nT = input()\n\nprint(get_score(N, K, R, S, P, T))"}
{"solution": "def longest_good_string(a, b, c):\n    # Calculate the total number of 'ab' pairs\n    pairs = min(a, b) + c\n    \n    # Calculate the remaining 'a's and 'b's\n    remaining_a = a - pairs\n    remaining_b = b - pairs\n    \n    # The maximum length is the sum of the pairs (each pair contributes 2 to the length)\n    # and the remaining 'a's and 'b's (each contributes 1 to the length)\n    max_length = pairs * 2 + remaining_a + remaining_b\n    \n    # If there are more 'ab' pairs than remaining 'a's and 'b's, we can add 1 to the length\n    # for each extra pair\n    extra_pairs = c - min(a, b)\n    max_length += extra_pairs * 2\n    \n    return max_length\n\na, b, c = map(int, input().split())\nprint(longest_good_string(a, b, c))"}
{"solution": "def solve(n, k, p, x, y, marks):\n    remaining_tests = n - k\n    total_marks = sum(marks)\n    max_total_marks = x - total_marks\n    min_median_index = (n + 1) // 2\n    min_median_marks = sorted(marks + [0] * remaining_tests)\n    min_median_marks[min_median_index - 1] = y\n\n    if sum(min_median_marks) > x:\n        return [-1]\n\n    remaining_marks = max_total_marks - sum(min_median_marks)\n    if remaining_marks < 0:\n        return [-1]\n\n    result = []\n    for i in range(remaining_tests):\n        if i < min_median_index - k - 1:\n            result.append(y)\n        elif i == min_median_index - k - 1:\n            result.append(min(y, min_median_marks[min_median_index - 1]))\n        else:\n            result.append(min(p, min_median_marks[min_median_index + i - k]))\n\n    remaining_marks -= sum(result) - sum(min_median_marks[:min_median_index - k - 1] + [min(y, min_median_marks[min_median_index - 1])] + min_median_marks[min_median_index + remaining_tests - k - 1:])\n\n    if remaining_marks > 0:\n        for i in range(remaining_tests - 1, -1, -1):\n            if result[i] < p:\n                increment = min(remaining_marks, p - result[i])\n                result[i] += increment\n                remaining_marks -= increment\n                if remaining_marks == 0:\n                    break\n\n    return result\n\n\nn, k, p, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\nresult = solve(n, k, p, x, y, marks)\nprint(*result)"}
{"solution": "def is_berlanese(word):\n    vowels = 'aeiou'\n    for i in range(len(word) - 1):\n        if word[i] not in vowels and word[i]!= 'n' and word[i + 1] not in vowels:\n            return 'NO'\n        if word[i] in vowels and word[i + 1] not in vowels + 'n' and i == len(word) - 2:\n            return 'NO'\n    if word[-1] not in vowels and word[-1]!= 'n':\n        return 'NO'\n    return 'YES'\n\nword = input()\nprint(is_berlanese(word))"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef solve():\n    n, m = read_ints()\n    edges = [read_ints() for _ in range(m)]\n\n    max_dominoes = 0\n    for i in range(1, n + 1):\n        graph = [[] for _ in range(n + 1)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        degrees = [len(graph[j]) for j in range(n + 1)]\n        dominoes = 0\n        for j in range(1, n + 1):\n            if degrees[j] > 0:\n                degrees[j] -= 1\n                for k in graph[j]:\n                    if degrees[k] > 0 and (k, j) not in edges:\n                        degrees[k] -= 1\n                        dominoes += 1\n        max_dominoes = max(max_dominoes, dominoes)\n\n    print(max_dominoes)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, m = read_ints()\n    prices = list(read_ints())\n    auction_questions = list(read_ints())\n\n    auction_questions = [q - 1 for q in auction_questions]\n    auction_questions.sort(key=lambda q: prices[q], reverse=True)\n\n    points = 0\n    for i in range(n):\n        if i in auction_questions:\n            points += prices[i]\n            prices[i] = points\n        else:\n            points += prices[i]\n\n    print(points)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_score(max_points, submission_time, wrong_submissions):\n    \"\"\"\n    Calculate the score for a single problem.\n\n    Args:\n    max_points (int): The maximum point value of the problem.\n    submission_time (int): The time of the last submission in minutes.\n    wrong_submissions (int): The number of wrong submissions.\n\n    Returns:\n    int: The score for the problem.\n    \"\"\"\n    score = max(0.3 * max_points, (1 - submission_time / 250) * max_points - 50 * wrong_submissions)\n    return int(score)\n\n\ndef main():\n    # Read the submission times\n    submission_times = list(map(int, input().split()))\n\n    # Read the wrong submissions\n    wrong_submissions = list(map(int, input().split()))\n\n    # Read the successful and unsuccessful hacks\n    successful_hacks, unsuccessful_hacks = map(int, input().split())\n\n    # Define the maximum point values for each problem\n    max_points = [500, 1000, 1500, 2000, 2500]\n\n    # Calculate the total score\n    total_score = sum(calculate_score(max_points[i], submission_times[i], wrong_submissions[i]) for i in range(5))\n\n    # Add the score for successful and unsuccessful hacks\n    total_score += 100 * successful_hacks - 50 * unsuccessful_hacks\n\n    print(total_score)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 998244353\n\ndef pow_mod(a, b):\n    res = 1\n    while b:\n        if b & 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b >>= 1\n    return res\n\ndef inv(a):\n    return pow_mod(a, MOD - 2)\n\ndef main():\n    n, m, L, R = map(int, input().split())\n    if (n * m) % 2 == 1:\n        print(0)\n        return\n    if n % 2 == 1 and m % 2 == 1:\n        print(0)\n        return\n    if n % 2 == 1:\n        n, m = m, n\n    if m % 2 == 1:\n        print(0)\n        return\n    ans = 0\n    for i in range(L, R + 1, 2):\n        ans = (ans + pow_mod(R - i + 1, n * m // 2)) % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_possible_to_make_increasing(n, m, matrix_a, matrix_b):\n    for i in range(n):\n        for j in range(m):\n            # Ensure that matrix_a[i][j] is the smaller or equal element\n            if matrix_a[i][j] > matrix_b[i][j]:\n                matrix_a[i][j], matrix_b[i][j] = matrix_b[i][j], matrix_a[i][j]\n    \n    # Check rows for strictly increasing property\n    for i in range(n):\n        for j in range(1, m):\n            if matrix_a[i][j] <= matrix_a[i][j-1] or matrix_b[i][j] <= matrix_b[i][j-1]:\n                return \"Impossible\"\n    \n    # Check columns for strictly increasing property\n    for j in range(m):\n        for i in range(1, n):\n            if matrix_a[i][j] <= matrix_a[i-1][j] or matrix_b[i][j] <= matrix_b[i-1][j]:\n                return \"Impossible\"\n    \n    return \"Possible\"\n\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\nmatrix_b = [list(map(int, input().split())) for _ in range(n)]\n\nprint(is_possible_to_make_increasing(n, m, matrix_a, matrix_b))"}
{"solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    a.sort(reverse=True)\n\n    ans = 0\n    used = set()\n    for i in range(n):\n        for j in range(a[i], -1, -1):\n            if j not in used:\n                ans += j\n                used.add(j)\n                break\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import heapq\n\ndef min_problems_to_solve(n, k, difficulties):\n    difficulties.sort()\n    heap = []\n    heapq.heappush(heap, -k)\n\n    for difficulty in difficulties:\n        if -heap[0] < difficulty / 2:\n            heapq.heappush(heap, -difficulty)\n            heapq.heappop(heap)\n            heapq.heappush(heap, -difficulty)\n        else:\n            heapq.heappush(heap, -difficulty)\n\n    return len(heap) - 1\n\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\nprint(min_problems_to_solve(n, k, difficulties))"}
{"solution": "def optimal_diploma_distribution(n, min_1, max_1, min_2, max_2, min_3, max_3):\n    \"\"\"\n    Calculate the optimal distribution of diplomas.\n\n    Args:\n    n (int): The total number of participants.\n    min_1, max_1 (int): The minimum and maximum limits for first-degree diplomas.\n    min_2, max_2 (int): The minimum and maximum limits for second-degree diplomas.\n    min_3, max_3 (int): The minimum and maximum limits for third-degree diplomas.\n\n    Returns:\n    tuple: A tuple containing the optimal number of first-degree, second-degree, and third-degree diplomas.\n    \"\"\"\n    # Calculate the maximum possible number of first-degree diplomas\n    first_degree = min(max_1, n - min_2 - min_3)\n\n    # Calculate the remaining participants after distributing first-degree diplomas\n    remaining = n - first_degree\n\n    # Calculate the maximum possible number of second-degree diplomas\n    second_degree = min(max_2, remaining - min_3)\n\n    # Calculate the number of third-degree diplomas\n    third_degree = n - first_degree - second_degree\n\n    return first_degree, second_degree, third_degree\n\n\n# Read input\nn = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\n# Calculate and print the optimal diploma distribution\nfirst_degree, second_degree, third_degree = optimal_diploma_distribution(n, min_1, max_1, min_2, max_2, min_3, max_3)\nprint(first_degree, second_degree, third_degree)"}
{"solution": "def moon_phase(n, observations):\n    moon_cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    current_index = moon_cycle.index(observations[0])\n    next_index = (current_index + n) % len(moon_cycle)\n    next_moon_size = moon_cycle[next_index]\n    current_moon_size = observations[-1]\n    \n    if next_moon_size > current_moon_size:\n        return \"UP\"\n    elif next_moon_size < current_moon_size:\n        return \"DOWN\"\n    else:\n        # Check if the sequence is increasing or decreasing\n        if all(observations[i] < observations[i+1] for i in range(len(observations)-1)):\n            return \"UP\"\n        elif all(observations[i] > observations[i+1] for i in range(len(observations)-1)):\n            return \"DOWN\"\n        else:\n            return \"-1\"\n\nn = int(input())\nobservations = list(map(int, input().split()))\nprint(moon_phase(n, observations))"}
{"solution": "def can_transform(s, t):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    # Check if lengths are the same\n    if len(s)!= len(t):\n        return \"No\"\n    \n    # Check each character\n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels)!= (char_t in vowels):\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(can_transform(s, t))"}
{"solution": "def determine_winner(board):\n    min_white_distance = float('inf')\n    min_black_distance = float('inf')\n\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'W':\n                min_white_distance = min(min_white_distance, 8 - i - 1)\n            elif board[i][j] == 'B':\n                min_black_distance = min(min_black_distance, i)\n\n    return 'A' if min_white_distance <= min_black_distance else 'B'\n\n\ndef main():\n    board = [input() for _ in range(8)]\n    print(determine_winner(board))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_equal_length():\n    n = int(input())\n    A = list(map(int, input().split()))\n    m = int(input())\n    B = list(map(int, input().split()))\n\n    if sum(A)!= sum(B):\n        return -1\n\n    prefix_sum_A = [0] * (n + 1)\n    prefix_sum_B = [0] * (m + 1)\n\n    for i in range(n):\n        prefix_sum_A[i + 1] = prefix_sum_A[i] + A[i]\n\n    for i in range(m):\n        prefix_sum_B[i + 1] = prefix_sum_B[i] + B[i]\n\n    i, j = 0, 0\n    count = 0\n\n    while i < n and j < m:\n        target = prefix_sum_A[i] + prefix_sum_B[j]\n        found = False\n\n        for k in range(i + 1, n + 1):\n            if prefix_sum_A[k] - prefix_sum_A[i] == target - prefix_sum_B[j]:\n                for l in range(j + 1, m + 1):\n                    if prefix_sum_B[l] - prefix_sum_B[j] == target and prefix_sum_A[k] - prefix_sum_A[i] == prefix_sum_B[l] - prefix_sum_B[j]:\n                        i, j = k, l\n                        count += 1\n                        found = True\n                        break\n                if found:\n                    break\n\n        if not found:\n            return -1\n\n    return count\n\nprint(max_equal_length())"}
{"solution": "def is_friend_name_in_problem(problem_name):\n    friends_names = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    for friend_name in friends_names:\n        if problem_name.count(friend_name) == 1:\n            return True\n    return False\n\nproblem_name = input()\nprint(\"YES\" if is_friend_name_in_problem(problem_name) else \"NO\")"}
{"solution": "def sieve(n):\n    is_prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (is_prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n    is_prime[0], is_prime[1] = False, False  # 0 and 1 are not primes\n    return is_prime\n\ndef count_primes_in_range(is_prime, a, b):\n    prime_count = [0] * (b + 1)\n    for i in range(a, b + 1):\n        prime_count[i] = prime_count[i - 1] + (1 if is_prime[i] else 0)\n    return prime_count\n\ndef min_length_with_k_primes(a, b, k):\n    is_prime = sieve(b)\n    prime_count = count_primes_in_range(is_prime, a, b)\n    \n    def has_k_primes_in_length(l):\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] >= k:\n                return True\n        return False\n    \n    left, right = 1, b - a + 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if has_k_primes_in_length(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\na, b, k = map(int, input().split())\nprint(min_length_with_k_primes(a, b, k))"}
{"solution": "import math\n\ndef calculate_x(a, h, w):\n    min_x = float('inf')\n\n    for n in range(1, math.ceil(w / a) + 1):\n        m = math.floor((w - n * a) / (n + 1))\n        if m < 0:\n            continue\n        x = (w - n * a - m) / (n + 1)\n        if x < 0:\n            continue\n        if h >= a + x and h - a - x >= m:\n            min_x = min(min_x, x)\n\n    for m in range(1, math.ceil(h / a) + 1):\n        n = math.floor((h - m * a) / (m + 1))\n        if n < 0:\n            continue\n        x = (h - m * a - n) / (m + 1)\n        if x < 0:\n            continue\n        if w >= a + x and w - a - x >= n:\n            min_x = min(min_x, x)\n\n    if min_x == float('inf'):\n        return -1\n    else:\n        return min_x\n\na, h, w = map(int, input().split())\nprint(calculate_x(a, h, w))"}
{"solution": "def count_unread_chapters():\n    n = int(input())\n    chapters = [list(map(int, input().split())) for _ in range(n)]\n    k = int(input())\n\n    unread_chapters = 0\n    for start, end in chapters:\n        if start >= k:\n            unread_chapters += 1\n        elif end >= k:\n            unread_chapters += 1\n            break\n\n    print(unread_chapters)\n\ncount_unread_chapters()"}
{"solution": "def can_form_codeforces(word):\n    target = \"CODEFORCES\"\n    n = len(word)\n    m = len(target)\n    \n    if n < m:\n        return \"NO\"\n    \n    for i in range(m + 1):\n        if word[:i] == target[:i] and word[n - (m - i):] == target[i:]:\n            return \"YES\"\n    \n    return \"NO\"\n\nword = input()\nprint(can_form_codeforces(word))"}
{"solution": "import sys\n\ndef min_weight(n):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][i] = 0\n        dp[i][i + 1] = i * (i + 1) * (i + 2)\n    for length in range(3, n + 1):\n        for i in range(1, n + 1 - length + 1):\n            j = i + length - 1\n            dp[i][j] = sys.maxsize\n            for k in range(i + 1, j + 1):\n                dp[i][j] = min(dp[i][j], dp[i][k - 1] + dp[k + 1][j] + i * k * j)\n    return dp[1][n]\n\nn = int(input())\nprint(min_weight(n))"}
{"solution": "def count_digits(n):\n    digits = 0\n    i = 1\n    while i <= n:\n        digits += len(str(i))\n        i += 1\n    return digits\n\nn = int(input())\nprint(count_digits(n))"}
{"solution": "def find_winning_color(n, A, colors):\n    \"\"\"\n    Find a color that Bob can choose to win the game.\n\n    Args:\n    n (int): The number of cars.\n    A (int): The color chosen by Alice.\n    colors (list): A list of colors of the cars in the order of their appearance.\n\n    Returns:\n    int: A color that Bob can choose to win the game, or -1 if no such color exists.\n    \"\"\"\n    # Initialize a dictionary to store the count of each color\n    color_count = {}\n    # Initialize a variable to store the count of Alice's color\n    alice_count = 0\n\n    # Iterate over the colors\n    for i, color in enumerate(colors):\n        # If the color is Alice's color, increment the count\n        if color == A:\n            alice_count += 1\n        # If the color is not in the dictionary, add it with a count of 1\n        elif color not in color_count:\n            color_count[color] = 1\n        # If the color is already in the dictionary, increment its count\n        else:\n            color_count[color] += 1\n\n        # If the count of any color is greater than or equal to Alice's count, return that color\n        if any(count >= alice_count for count in color_count.values()):\n            return next(color for color, count in color_count.items() if count >= alice_count)\n\n    # If no winning color is found, return -1\n    return -1\n\n\n# Read the input\nn, A = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Find and print the winning color\nprint(find_winning_color(n, A, colors))"}
{"solution": "def is_unique_crossword(n, x, a):\n    total_length = sum(a)\n    if total_length > x:\n        return False\n    if total_length == x:\n        return n == 1\n    if n == 1:\n        return False\n    if x - total_length - (n - 1) > 1:\n        return False\n    return True\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\nif is_unique_crossword(n, x, a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\nn, S = map(int, input().split())\n\nprint(math.ceil(S / n) if S % n!= 0 else S // n)"}
{"solution": "def lexicographically_smallest_palindrome(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    mid_char = ''\n    first_half = ''\n    for char in sorted(char_count.keys()):\n        count = char_count[char]\n        if count % 2 == 1:\n            if mid_char:\n                first_half += char * (count // 2)\n            else:\n                mid_char = char\n                first_half += char * (count // 2)\n        else:\n            first_half += char * (count // 2)\n\n    return first_half + mid_char + first_half[::-1]\n\ns = input()\nprint(lexicographically_smallest_palindrome(s))"}
{"solution": "piece_weights = {\n    'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n    'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n}\n\nwhite_weight = 0\nblack_weight = 0\n\nfor _ in range(8):\n    row = input()\n    for piece in row:\n        if piece in piece_weights:\n            if piece.isupper():\n                white_weight += piece_weights[piece]\n            else:\n                black_weight += piece_weights[piece]\n\nif white_weight > black_weight:\n    print(\"White\")\nelif black_weight > white_weight:\n    print(\"Black\")\nelse:\n    print(\"Draw\")"}
{"solution": "import heapq\n\ndef solve(N, M, S):\n    S = [int(x) for x in S]\n    dist = [float('inf')] * (N + 1)\n    prev = [-1] * (N + 1)\n    dist[0] = 0\n    queue = [(0, 0)]\n    while queue:\n        d, u = heapq.heappop(queue)\n        if d > dist[u]:\n            continue\n        for v in range(u + 1, min(u + M + 1, N + 1)):\n            if S[v] == 1:\n                continue\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                prev[v] = u\n                heapq.heappush(queue, (dist[v], v))\n    if dist[N] == float('inf'):\n        return -1\n    path = []\n    u = N\n    while u!= 0:\n        path.append(u - prev[u])\n        u = prev[u]\n    return''.join(map(str, reversed(path)))\n\nN, M = map(int, input().split())\nS = input()\nprint(solve(N, M, S))"}
{"solution": "import math\n\ndef calculate_distance(x1, y1, x2, y2):\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef find_path(k, x, y):\n    if calculate_distance(0, 0, x, y) % k!= 0:\n        return -1\n\n    steps = []\n    current_x, current_y = 0, 0\n\n    while (current_x, current_y)!= (x, y):\n        if abs(x - current_x) >= k:\n            new_x = current_x + k if x > current_x else current_x - k\n            new_y = current_y\n        else:\n            new_x = x\n            new_y = current_y + (k - abs(x - current_x)) if y > current_y else current_y - (k - abs(x - current_x))\n\n        steps.append((new_x, new_y))\n        current_x, current_y = new_x, new_y\n\n    return steps\n\ndef main():\n    k = int(input())\n    x, y = map(int, input().split())\n\n    result = find_path(k, x, y)\n\n    if result == -1:\n        print(-1)\n    else:\n        print(len(result))\n        for step in result:\n            print(step[0], step[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef find_smallest_n(m):\n    n = 1\n    while True:\n        count = 0\n        for k in range(2, int(math.sqrt(n)) + 2):\n            a = 1\n            for _ in range(3):\n                a *= k\n                if a > n:\n                    break\n            else:\n                count += 1\n        if count == m:\n            return n\n        n += 1\n        if n > m * 100:\n            return -1\n\nm = int(input())\nprint(find_smallest_n(m))"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    if d >= r1 + r2:\n        return 0\n    elif d <= abs(r1 - r2):\n        r_min = min(r1, r2)\n        return math.pi * r_min ** 2\n    else:\n        a = (r1 ** 2 - r2 ** 2 + d ** 2) / (2 * d)\n        h = math.sqrt(r1 ** 2 - a ** 2)\n        area = r1 ** 2 * math.acos(a / r1) - a * h + r2 ** 2 * math.acos((d - a) / r2) - (d - a) * h\n        return area\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\nprint(circle_intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "def min_value(n):\n    if n == 1:\n        return 1\n    elif n % 2 == 0:\n        return 1 if n > 4 else n\n    else:\n        return 1 if n > 3 else n\n\nv = int(input())\nprint(min_value(v))"}
{"solution": "from collections import defaultdict\n\ndef dfs(node, graph, a, dp):\n    if dp[node]!= -1:\n        return dp[node]\n    if not graph[node]:\n        dp[node] = a[node]\n        return dp[node]\n    min_val = float('inf')\n    for child in graph[node]:\n        min_val = min(min_val, dfs(child, graph, a, dp))\n    dp[node] = a[node] + min_val\n    return dp[node]\n\ndef solve():\n    n = int(input())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    graph = defaultdict(list)\n    for i in range(n-1):\n        graph[p[i]].append(i+2)\n    dp = [-1]*(n+1)\n    print(dfs(1, graph, a, dp))\n\nsolve()"}
{"solution": "def count_typo_words(n, S, T):\n    count = 0\n    for i in range(n + 1):\n        # Construct W by inserting a character at position i in both S and T\n        if i == 0:\n            W1 = S[0] + S\n            W2 = T[0] + T\n        elif i == n:\n            W1 = S + S[-1]\n            W2 = T + T[-1]\n        else:\n            W1 = S[:i] + S[i] + S[i:]\n            W2 = T[:i] + T[i] + T[i:]\n        \n        # Check if the constructed words are the same\n        if W1 == W2:\n            count += 1\n    \n    return count\n\nn = int(input())\nS = input().strip()\nT = input().strip()\nprint(count_typo_words(n, S, T))"}
{"solution": "import sys\nfrom collections import deque\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(input())\n\ndef read_ints():\n    return map(int, input().split())\n\ndef solve():\n    n = read_int()\n    a = list(read_ints())\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = read_ints()\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def get_max_strength():\n        max_strength = 0\n        queue = deque()\n        visited = [False] * n\n        for i in range(n):\n            if len(graph[i]) == 1:\n                queue.append(i)\n                visited[i] = True\n        while queue:\n            u = queue.popleft()\n            max_strength = max(max_strength, a[u])\n            for v in graph[u]:\n                if not visited[v]:\n                    a[v] += 1\n                    visited[v] = True\n                    queue.append(v)\n        return max_strength\n\n    return get_max_strength()\n\nprint(solve())"}
{"solution": "n, m = map(int, input().split())\nprint(min(m, n - m) if m!= n else 0)"}
{"solution": "def min_shovels(k, r):\n    \"\"\"\n    Calculate the minimum number of shovels Polycarp needs to buy to pay without any change.\n\n    Args:\n    k (int): The price of one shovel.\n    r (int): The denomination of the coin in Polycarp's pocket that is different from \"10-burle coins\".\n\n    Returns:\n    int: The minimum number of shovels Polycarp needs to buy.\n    \"\"\"\n    for i in range(1, 11):\n        total_cost = i * k\n        if total_cost % 10 == r:\n            return i\n    return 10\n\n\nk, r = map(int, input().split())\nprint(min_shovels(k, r))"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # Dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Extract the bounding box\n    piece = []\n    for i in range(min_row, max_row + 1):\n        piece.append(grid[i][min_col:max_col + 1])\n    \n    # Check horizontal placement\n    if width * 2 == m:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j]!= piece[i][j + width]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    # Check vertical placement\n    if height * 2 == n:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j]!= piece[i + height][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "def min_segments():\n    points = [list(map(int, input().split())) for _ in range(3)]\n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n\n    if len(set(x_coords)) == 1 or len(set(y_coords)) == 1:\n        return 1\n    elif len(set(x_coords)) == 2 and len(set(y_coords)) == 2:\n        return 2\n    else:\n        return 3\n\nprint(min_segments())"}
{"solution": "def construct_k_regular_graph(k):\n    if k == 1:\n        return 2, [(1, 2)]\n    elif k == 2:\n        return \"NO\"\n    else:\n        n = 2 * k\n        edges = []\n        for i in range(1, k + 1):\n            edges.append((i, i + k))\n            for j in range(1, k):\n                edges.append((i, i + j))\n                edges.append((i + k, i + k + j))\n        edges.append((1, k + 1))\n        return n, edges\n\n\ndef main():\n    k = int(input())\n    result = construct_k_regular_graph(k)\n    if result == \"NO\":\n        print(\"NO\")\n    else:\n        n, edges = result\n        m = len(edges)\n        print(\"YES\")\n        print(n, m)\n        for edge in edges:\n            print(*edge)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def kmp(s, t):\n    n, m = len(s), len(t)\n    lps = [0] * m\n    j = 0\n    for i in range(1, m):\n        while j > 0 and t[i]!= t[j]:\n            j = lps[j - 1]\n        if t[i] == t[j]:\n            j += 1\n        lps[i] = j\n    j = 0\n    count = 0\n    for i in range(n):\n        while j > 0 and s[i]!= t[j]:\n            j = lps[j - 1]\n        if s[i] == t[j]:\n            j += 1\n        if j == m:\n            count += 1\n            j = lps[j - 1]\n    return count\n\ndef solve():\n    n, m, q = map(int, input().split())\n    s = input()\n    t = input()\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + kmp(s[:i + 1], t)\n    for _ in range(q):\n        l, r = map(int, input().split())\n        print(prefix[r] - prefix[l - 1])\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "MOD = 1000000007\n\ndef count_paths(n, k, d):\n    dp = [[[0 for _ in range(k + 1)] for _ in range(n + 1)] for _ in range(2)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            for x in range(1, k + 1):\n                if i - x >= 0:\n                    dp[i % 2][i - x][j] = (dp[i % 2][i - x][j] + dp[(i - 1) % 2][i - x][min(j, x)]) % MOD\n\n    res = sum(dp[n % 2][0][d:]) % MOD\n    return res\n\nn, k, d = map(int, input().split())\nprint(count_paths(n, k, d))"}
{"solution": "def encrypt_japanese_crossword(n, row):\n    groups = []\n    count = 0\n    \n    for char in row:\n        if char == 'B':\n            count += 1\n        else:\n            if count > 0:\n                groups.append(count)\n                count = 0\n    \n    if count > 0:\n        groups.append(count)\n    \n    print(len(groups))\n    if groups:\n        print(\" \".join(map(str, groups)))\n\nn = int(input())\nrow = input().strip()\nencrypt_japanese_crossword(n, row)"}
{"solution": "import sys\n\ndef main():\n    n, m, p = map(int, sys.stdin.readline().split())\n    s = sys.stdin.readline().strip()\n    operations = sys.stdin.readline().strip()\n\n    stack = []\n    pairs = {}\n\n    for i, c in enumerate(s):\n        if c == '(':\n            stack.append(i)\n        else:\n            pairs[stack.pop()] = i\n            pairs[i] = stack[-1]\n\n    cursor = p - 1\n\n    for op in operations:\n        if op == 'L':\n            cursor -= 1\n        elif op == 'R':\n            cursor += 1\n        elif op == 'D':\n            left = min(cursor, pairs[cursor])\n            right = max(cursor, pairs[cursor])\n\n            for i in range(left, right + 1):\n                if i in pairs:\n                    del pairs[i]\n\n            if left in pairs.values():\n                del pairs[left]\n\n            if right in pairs.values():\n                del pairs[right]\n\n            if cursor in pairs:\n                del pairs[cursor]\n\n            if cursor < left:\n                cursor = left - 1\n            else:\n                cursor = left\n\n            while cursor in pairs:\n                cursor += 1\n\n            if cursor >= len(s):\n                cursor = len(s) - 1\n                while cursor in pairs:\n                    cursor -= 1\n\n    result = [''] * len(s)\n    for i in range(len(s)):\n        if i not in pairs:\n            result[i] = s[i]\n\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_y():\n    n = int(input())\n    lower_bound = -2 * 10**9\n    upper_bound = 2 * 10**9\n\n    for _ in range(n):\n        sign, x, answer = input().split()\n        x = int(x)\n\n        if sign == \">\":\n            if answer == \"Y\":\n                lower_bound = max(lower_bound, x + 1)\n            else:\n                upper_bound = min(upper_bound, x)\n        elif sign == \"<\":\n            if answer == \"Y\":\n                upper_bound = min(upper_bound, x - 1)\n            else:\n                lower_bound = max(lower_bound, x)\n        elif sign == \">=\":\n            if answer == \"Y\":\n                lower_bound = max(lower_bound, x)\n            else:\n                upper_bound = min(upper_bound, x - 1)\n        elif sign == \"<=\":\n            if answer == \"Y\":\n                upper_bound = min(upper_bound, x)\n            else:\n                lower_bound = max(lower_bound, x + 1)\n\n    if lower_bound <= upper_bound:\n        return lower_bound\n    else:\n        return \"Impossible\"\n\nprint(find_y())"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_periods(a, b):\n    if a > b:\n        a, b = b, a\n    if a == b:\n        return a + 1\n    g = gcd(a, b)\n    return b // g + min(a % g, 1)\n\na, b = map(int, input().split())\nprint(count_periods(a, b))"}
{"solution": "def generate_names(n, k, conditions):\n    names = []\n    name_index = 0\n    for i in range(n):\n        if i < k - 1:\n            names.append(get_name(name_index))\n            name_index += 1\n        else:\n            if conditions[i - k + 1] == \"YES\":\n                names.append(get_name(name_index))\n                name_index += 1\n            else:\n                names.append(names[i - k + 1])\n    return names\n\ndef get_name(index):\n    first_letter = chr(ord('A') + index // 26)\n    rest = str(index % 26)\n    return first_letter + rest\n\nn, k = map(int, input().split())\nconditions = input().split()\n\nnames = generate_names(n, k, conditions)\nprint(\" \".join(names))"}
{"solution": "def min_operations_to_equal(a, b):\n    def count_factors(n, factor):\n        count = 0\n        while n % factor == 0:\n            n //= factor\n            count += 1\n        return count, n\n\n    # Count the number of times we can divide by 2, 3, and 5\n    a2, a = count_factors(a, 2)\n    a3, a = count_factors(a, 3)\n    a5, a = count_factors(a, 5)\n    \n    b2, b = count_factors(b, 2)\n    b3, b = count_factors(b, 3)\n    b5, b = count_factors(b, 5)\n    \n    # If the remaining parts are not equal, return -1\n    if a!= b:\n        return -1\n    \n    # Calculate the total number of operations needed\n    operations = abs(a2 - b2) + abs(a3 - b3) + abs(a5 - b5)\n    \n    return operations\n\na, b = map(int, input().split())\nprint(min_operations_to_equal(a, b))"}
{"solution": "def calculate_min_cost(n, a, b, colors):\n    \"\"\"\n    Calculate the minimum cost to form a palindrome.\n\n    Args:\n    n (int): The number of dancers.\n    a (int): The cost of a white suit.\n    b (int): The cost of a black suit.\n    colors (list): A list of integers representing the color of each dancer's suit.\n\n    Returns:\n    int: The minimum cost to form a palindrome, or -1 if it's not possible.\n    \"\"\"\n    total_cost = 0\n    for i in range(n // 2):\n        if colors[i] == colors[n - i - 1]:\n            if colors[i] == 2:\n                total_cost += min(a, b)\n        elif colors[i] == 2:\n            if colors[n - i - 1] == 0:\n                total_cost += a\n            else:\n                total_cost += b\n        elif colors[n - i - 1] == 2:\n            if colors[i] == 0:\n                total_cost += a\n            else:\n                total_cost += b\n        else:\n            return -1\n    if n % 2 == 1 and colors[n // 2] == 2:\n        total_cost += min(a, b)\n    return total_cost\n\n\nn, a, b = map(int, input().split())\ncolors = list(map(int, input().split()))\nprint(calculate_min_cost(n, a, b, colors))"}
{"solution": "def paint_cube(k):\n    if k == 1:\n        return -1\n\n    cube = []\n    for i in range(k):\n        layer = []\n        for j in range(k):\n            row = []\n            for z in range(k):\n                if (i + j + z) % 2 == 0:\n                    row.append('b')\n                else:\n                    row.append('w')\n            layer.append(''.join(row))\n        cube.append(layer)\n\n    for layer in cube:\n        for row in layer:\n            print(row)\n        print()\n\nk = int(input())\nresult = paint_cube(k)\nif result == -1:\n    print(-1)"}
{"solution": "import math\nfrom collections import Counter\n\ndef largest_lovely_number(n):\n    def prime_factors(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            while (n % i) == 0:\n                factors.append(i)\n                n //= i\n            i += 1\n        if n > 1:\n            factors.append(n)\n        return factors\n\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n    \n    lovely_number = 1\n    for prime, count in factor_counts.items():\n        lovely_number *= prime ** min(count, 1)\n    \n    return lovely_number\n\nn = int(input())\nprint(largest_lovely_number(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    # Check for adjacent occupied seats\n    for i in range(n - 1):\n        if seating[i] == '1' and seating[i + 1] == '1':\n            return \"No\"\n    \n    # Check for possible additional seating\n    for i in range(n):\n        if seating[i] == '0':\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                return \"No\"\n    \n    return \"Yes\"\n\nn = int(input())\nseating = input().strip()\nprint(is_maximal_seating(n, seating))"}
{"solution": "def find_possible_k(n, a):\n    possible_k = []\n    for k in range(1, n + 1):\n        x = [a[i] - a[i - 1] for i in range(1, k + 1)]\n        if all(a[i] == sum(x[(i - 1) % k] for i in range(1, j + 1)) for j in range(k, n + 1)):\n            possible_k.append(k)\n    return possible_k\n\n\nn = int(input())\na = list(map(int, input().split()))\npossible_k = find_possible_k(n, a)\nprint(len(possible_k))\nprint(*possible_k)"}
{"solution": "def can_form_equal_teams(scores):\n    total_score = sum(scores)\n    if total_score % 2!= 0:\n        return False\n\n    target_score = total_score // 2\n    scores.sort(reverse=True)\n\n    def dfs(index, current_score, count):\n        if count == 3:\n            return current_score == target_score\n        if current_score > target_score or index >= len(scores):\n            return False\n\n        return dfs(index + 1, current_score + scores[index], count + 1) or dfs(index + 1, current_score, count)\n\n    return dfs(0, 0, 0)\n\n\nscores = list(map(int, input().split()))\nprint(\"YES\" if can_form_equal_teams(scores) else \"NO\")"}
{"solution": "def count_2_3_integers(left, right):\n    \"\"\"\n    Counts the number of 2-3-integers in the given range [left, right].\n    \n    A 2-3-integer is a positive integer that is equal to 2^x * 3^y for some non-negative integers x and y.\n    \n    Args:\n        left (int): The lower bound of the range (inclusive).\n        right (int): The upper bound of the range (inclusive).\n    \n    Returns:\n        int: The number of 2-3-integers in the given range.\n    \"\"\"\n    def count_2_3_integers_up_to(n):\n        \"\"\"\n        Counts the number of 2-3-integers up to n.\n        \n        Args:\n            n (int): The upper bound (inclusive).\n        \n        Returns:\n            int: The number of 2-3-integers up to n.\n        \"\"\"\n        count = 0\n        x = 1\n        while x <= n:\n            y = 1\n            while x * y <= n:\n                count += 1\n                y *= 3\n            x *= 2\n        return count\n\n    return count_2_3_integers_up_to(right) - count_2_3_integers_up_to(left - 1)\n\n\nleft, right = map(int, input().split())\nprint(count_2_3_integers(left, right))"}
{"solution": "def calculate_eaten_candies(n, k):\n    \"\"\"\n    Calculate the total number of candies Alya ate.\n\n    Args:\n    n (int): The total number of moves.\n    k (int): The number of candies in the box at the end.\n\n    Returns:\n    int: The total number of candies Alya ate.\n    \"\"\"\n    # Initialize the number of candies put and eaten\n    put = 0\n    eaten = 0\n\n    # Initialize the number of candies in the box\n    box = 0\n\n    # Iterate over the moves\n    for i in range(n):\n        # If the box is empty, put candies\n        if box == 0:\n            put += 1\n            box += put\n        # If the box is not empty, decide whether to put or eat candies\n        else:\n            # If the number of candies in the box is less than or equal to the number of candies put,\n            # eat candies to avoid exceeding the target number of candies\n            if box <= put:\n                box -= 1\n                eaten += 1\n            # If the number of candies in the box is greater than the number of candies put,\n            # put candies to reach the target number of candies\n            else:\n                put += 1\n                box += put\n\n    # Adjust the number of eaten candies based on the final number of candies in the box\n    eaten += put - k\n\n    return eaten\n\n\n# Read the input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_eaten_candies(n, k))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\nfor i in range(n - 2):\n    if a[i] + a[i + 1] > a[i + 2]:\n        print(\"YES\")\n        sys.exit()\n\nprint(\"NO\")"}
{"solution": "def solve(x, y):\n    if x == 0:\n        return y == 1\n    if y == 1:\n        return x == 0\n    if y > x + 1:\n        return False\n    return solve(x - (y - 1), y - 1) or solve(x - 2 * (y - 1), y - 1)\n\nx, y = map(int, input().split())\nprint(\"Yes\" if solve(x, y) else \"No\")"}
{"solution": "import math\n\ndef calculate_total_rating(n, k, skills):\n    total_rating = sum(math.floor(skill / 10) for skill in skills)\n    improvements = sorted((10 - (skill % 10), i) for i, skill in enumerate(skills) if skill < 100)\n    \n    for improvement in improvements:\n        if k >= improvement[0]:\n            k -= improvement[0]\n            skills[improvement[1]] += improvement[0]\n        else:\n            break\n    \n    return sum(math.floor(skill / 10) for skill in skills)\n\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\nprint(calculate_total_rating(n, k, skills))"}
{"solution": "def find_smallest_pretty_integer():\n    n, m = map(int, input().split())\n    list1 = list(map(int, input().split()))\n    list2 = list(map(int, input().split()))\n\n    set1 = set(list1)\n    set2 = set(list2)\n\n    common_digits = set1.intersection(set2)\n    if common_digits:\n        return min(common_digits)\n\n    min1 = min(list1)\n    min2 = min(list2)\n\n    smallest_pretty = min(int(str(min1) + str(min2)), int(str(min2) + str(min1)))\n    return smallest_pretty\n\nprint(find_smallest_pretty_integer())"}
{"solution": "def calculate_problems(n, k):\n    \"\"\"\n    Calculate the maximum number of problems Limak can solve before leaving for the party.\n\n    Args:\n    n (int): The number of problems in the contest.\n    k (int): The number of minutes Limak needs to get to the party from his house.\n\n    Returns:\n    int: The maximum number of problems Limak can solve.\n    \"\"\"\n    total_time = 240  # Total time available in minutes\n    time_left = total_time - k  # Time left for solving problems\n    problems_solved = 0\n    time_spent = 0\n\n    for i in range(1, n + 1):\n        time_required = 5 * i  # Time required to solve the current problem\n        if time_spent + time_required <= time_left:\n            problems_solved += 1\n            time_spent += time_required\n        else:\n            break\n\n    return problems_solved\n\n\nn, k = map(int, input().split())\nprint(calculate_problems(n, k))"}
{"solution": "n, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\ndouble_sided = x\nsingle_sided = y\ncount = 0\n\nfor pages in a:\n    double_needed = pages // 2\n    single_needed = pages % 2\n\n    if double_needed <= double_sided:\n        double_sided -= double_needed\n        if single_needed <= single_sided:\n            single_sided -= single_needed\n            count += 1\n        else:\n            double_sided += double_needed\n            break\n    else:\n        remaining_pages = pages - 2 * double_sided\n        if remaining_pages <= single_sided:\n            single_sided -= remaining_pages\n            double_sided = 0\n            count += 1\n        else:\n            break\n\nprint(count)"}
{"solution": "import math\n\ndef count_divisors(n):\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return len(divisors)\n\nb = int(input().strip())\nresult = count_divisors(b)\nprint(result)"}
{"solution": "def pinball_game(n, bumpers):\n    \"\"\"\n    Calculate the number of positions such that the ball will eventually fall from the game field if it starts at that position.\n\n    Args:\n    n (int): The length of the sequence of bumpers.\n    bumpers (str): A string representing the bumpers' types.\n\n    Returns:\n    int: The number of positions in the sequence such that the ball will eventually fall from the game field if it starts at that position.\n    \"\"\"\n    # Initialize a list to store the direction of each bumper\n    directions = [1 if bumper == '>' else -1 for bumper in bumpers]\n\n    # Initialize a list to store the number of positions that will eventually fall from the game field\n    fall_positions = [0] * n\n\n    # Initialize the current position and the number of positions that will eventually fall from the game field\n    current_position = 0\n    fall_count = 0\n\n    # Iterate over the bumpers\n    while current_position < n:\n        # If the current position is at the edge of the game field, the ball will fall\n        if current_position == 0 and directions[current_position] == -1:\n            fall_count += 1\n            fall_positions[current_position] = 1\n            current_position += 1\n        elif current_position == n - 1 and directions[current_position] == 1:\n            fall_count += 1\n            fall_positions[current_position] = 1\n            current_position += 1\n        # If the current position is not at the edge of the game field, move to the next position\n        else:\n            next_position = current_position + directions[current_position]\n            # If the next position is at the edge of the game field, the ball will fall\n            if next_position < 0 or next_position >= n:\n                fall_count += 1\n                fall_positions[current_position] = 1\n                current_position += 1\n            # If the next position is not at the edge of the game field, move to the next position\n            else:\n                # If the next position is in a cycle, the ball will not fall\n                if fall_positions[next_position] == 1:\n                    fall_count += 1\n                    fall_positions[current_position] = 1\n                    current_position += 1\n                else:\n                    current_position = next_position\n\n    return fall_count\n\n\n# Read the input\nn = int(input())\nbumpers = input()\n\n# Print the output\nprint(pinball_game(n, bumpers))"}
{"solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    sticks = list(map(int, sys.stdin.readline().split()))\n\n    sticks.sort()\n    counts = {}\n    for stick in sticks:\n        counts[stick] = counts.get(stick, 0) + 1\n\n    total_area = 0\n    for length, count in counts.items():\n        if count >= 2:\n            pairs = count // 2\n            total_area += pairs * length * length\n            counts[length] -= pairs * 2\n\n            if counts[length] > 0 and length - 1 in counts and counts[length - 1] > 0:\n                pairs = min(counts[length], counts[length - 1])\n                total_area += pairs * (length - 1) * length\n                counts[length] -= pairs\n                counts[length - 1] -= pairs\n\n            if counts[length] > 0 and length - 1 in counts and counts[length - 1] >= 2:\n                pairs = counts[length] // 2\n                total_area += pairs * (length - 1) * (length - 1)\n                counts[length] -= pairs * 2\n\n    print(total_area)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import defaultdict\n\ndef restore_numbers(n, numbers):\n    # Create a dictionary to store the frequency of each letter\n    freq = defaultdict(int)\n    for num in numbers:\n        for letter in num:\n            freq[letter] += 1\n\n    # Sort the letters by frequency in descending order\n    sorted_letters = sorted(freq, key=freq.get, reverse=True)\n\n    # Create a dictionary to store the mapping of letters to digits\n    mapping = {}\n    for i, letter in enumerate(sorted_letters):\n        mapping[letter] = str(i)\n\n    # Replace the letters with digits in the numbers\n    restored_numbers = []\n    for num in numbers:\n        restored_num = ''.join(mapping[letter] for letter in num)\n        restored_numbers.append(int(restored_num))\n\n    # Return the sum of the restored numbers\n    return sum(restored_numbers)\n\n# Read the input\nn = int(input())\nnumbers = [input() for _ in range(n)]\n\n# Print the output\nprint(restore_numbers(n, numbers))"}
{"solution": "def max_teams(n, m):\n    # Calculate the maximum number of teams of type 1 (1 XP, 2 NB)\n    t1 = min(n, m // 2)\n    \n    # Calculate the remaining newbies after forming type 1 teams\n    remaining_nb = m - 2 * t1\n    \n    # Calculate the maximum number of teams of type 2 (2 XP, 1 NB) using the remaining newbies\n    t2 = min((n - t1) // 2, remaining_nb)\n    \n    # Return the total number of teams\n    return t1 + t2\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    n = len(s)\n    \n    # Check for \"AB\" followed by \"BA\"\n    found_AB = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"AB\":\n            found_AB = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"BA\":\n                    print(\"YES\")\n                    return\n            break\n    \n    # Check for \"BA\" followed by \"AB\"\n    found_BA = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"BA\":\n            found_BA = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"AB\":\n                    print(\"YES\")\n                    return\n            break\n    \n    # If neither condition is met\n    print(\"NO\")\n\ns = input().strip()\ncheck_substrings(s)"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    k = int(input())\n    b = list(map(int, input().split()))\n\n    if sum(a)!= sum(b):\n        print(\"NO\")\n        return\n\n    ans = []\n    for i in range(k):\n        if a[i]!= b[i]:\n            j = i\n            while a[j]!= b[i]:\n                if j > i and a[j] > a[j - 1]:\n                    ans.append((j, 'L'))\n                    a[j] += a[j - 1]\n                    a.pop(j - 1)\n                elif j < len(a) - 1 and a[j] > a[j + 1]:\n                    ans.append((j, 'R'))\n                    a[j] += a[j + 1]\n                    a.pop(j + 1)\n                else:\n                    print(\"NO\")\n                    return\n    print(\"YES\")\n    for x, y in ans:\n        print(x + 1, y)\n\nsolve()"}
{"solution": "import sys\n\ndef read_input():\n    lines = sys.stdin.readlines()\n    R, B = map(int, lines[0].split())\n    points = []\n    for line in lines[1:]:\n        x, y = map(int, line.split())\n        points.append((x, y))\n    return R, B, points\n\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # Collinear\n    elif val > 0:\n        return 1  # Clockwise\n    else:\n        return 2  # Counterclockwise\n\ndef intersect(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if (o1!= o2 and o3!= o4):\n        return True\n\n    if (o1 == 0 and on_segment(p1, p2, q1)):\n        return True\n\n    if (o2 == 0 and on_segment(p1, q2, q1)):\n        return True\n\n    if (o3 == 0 and on_segment(p2, p1, q2)):\n        return True\n\n    if (o4 == 0 and on_segment(p2, q1, q2)):\n        return True\n\n    return False\n\ndef on_segment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n        q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\ndef solve(R, B, points):\n    if R!= B:\n        return \"No\"\n\n    for i in range(R):\n        for j in range(i + 1, R):\n            for k in range(R):\n                for l in range(k + 1, R):\n                    if intersect(points[i], points[R + k], points[j], points[R + l]):\n                        return \"No\"\n\n    return \"Yes\"\n\nR, B, points = read_input()\nprint(solve(R, B, points))"}
{"solution": "import math\n\nn = int(input())\na = list(map(int, input().split()))\n\nmax_power = 0\ncount = 0\n\nfor num in a:\n    power = 0\n    while num % 2 == 0:\n        power += 1\n        num //= 2\n    if power > max_power:\n        max_power = power\n        count = 1\n    elif power == max_power:\n        count += 1\n\nprint(2 ** max_power, count)"}
{"solution": "def min_clicks(n, m):\n    clicks = 0\n    while m > n:\n        if m % 2 == 0:\n            m //= 2\n        else:\n            m -= 1\n        clicks += 1\n    return clicks + (n - m)\n\nn, m = map(int, input().split())\nprint(min_clicks(n, m))"}
{"solution": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x]!= x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x!= root_y:\n            if self.rank[root_x] > self.rank[root_y]:\n                self.parent[root_y] = root_x\n            elif self.rank[root_x] < self.rank[root_y]:\n                self.parent[root_x] = root_y\n            else:\n                self.parent[root_y] = root_x\n                self.rank[root_x] += 1\n\n\ndef solve():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, input().split())\n        segments.append((l, r))\n\n    events = []\n    for i, (l, r) in enumerate(segments):\n        events.append((l, 1, i))\n        events.append((r, -1, i))\n    events.sort()\n\n    uf = UnionFind(n)\n    edges = 0\n    for _, type, i in events:\n        if type == 1:\n            for j in range(i + 1, n):\n                if segments[j][0] < segments[i][1] and segments[i][0] < segments[j][1]:\n                    if uf.find(i)!= uf.find(j):\n                        uf.union(i, j)\n                        edges += 1\n    if edges == n - 1 and len(set(uf.find(i) for i in range(n))) == 1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def longest_ddos_period(n, requests):\n    max_length = 0\n    for i in range(n):\n        total_requests = 0\n        for j in range(i, n):\n            total_requests += requests[j]\n            if total_requests > 100 * (j - i + 1):\n                max_length = max(max_length, j - i + 1)\n    return max_length\n\nn = int(input())\nrequests = list(map(int, input().split()))\nprint(longest_ddos_period(n, requests))"}
{"solution": "def check_dissatisfaction(n, k, episodes):\n    max_dissatisfaction = 0\n    current_dissatisfaction = 0\n\n    for episode in episodes:\n        if episode == 'N' or episode == '?':\n            current_dissatisfaction += 1\n            max_dissatisfaction = max(max_dissatisfaction, current_dissatisfaction)\n        else:\n            current_dissatisfaction = 0\n\n    if max_dissatisfaction == k:\n        return \"YES\"\n    elif max_dissatisfaction > k:\n        return \"NO\"\n    else:\n        # Check if we can make the dissatisfaction equal to k\n        # by assuming '?' as 'N'\n        current_dissatisfaction = 0\n        for episode in episodes:\n            if episode == 'N':\n                current_dissatisfaction += 1\n            elif episode == '?':\n                current_dissatisfaction += 1\n                if current_dissatisfaction == k:\n                    return \"YES\"\n                if current_dissatisfaction > k:\n                    current_dissatisfaction -= 1\n            else:\n                current_dissatisfaction = 0\n        return \"NO\"\n\nn, k = map(int, input().split())\nepisodes = input()\n\nprint(check_dissatisfaction(n, k, episodes))"}
{"solution": "def calculate_possible_values(n, x, d):\n    \"\"\"\n    Calculate the number of possible values of S - T.\n\n    Args:\n    n (int): The length of the sequence.\n    x (int): The first element of the sequence.\n    d (int): The common difference of the sequence.\n\n    Returns:\n    int: The number of possible values of S - T.\n    \"\"\"\n    # Calculate the sum of the sequence\n    total_sum = n * (2 * x + (n - 1) * d) // 2\n\n    # If d is zero, there is only one possible value of S - T\n    if d == 0:\n        return 1\n\n    # Calculate the maximum possible value of S - T\n    max_value = total_sum\n\n    # Calculate the minimum possible value of S - T\n    min_value = -total_sum\n\n    # Calculate the number of possible values of S - T\n    possible_values = max_value - min_value + 1\n\n    # If n is odd, the number of possible values is doubled\n    if n % 2 == 1:\n        possible_values *= 2\n\n    # Subtract 1 because we counted the value 0 twice\n    possible_values -= 1\n\n    return possible_values\n\n\n# Read input from standard input\nn, x, d = map(int, input().split())\n\n# Calculate and print the number of possible values of S - T\nprint(calculate_possible_values(n, x, d))"}
{"solution": "def did_anton_perform_good():\n    n = int(input())\n    for _ in range(n):\n        handle, before, after = input().split()\n        before, after = int(before), int(after)\n        if before >= 2400 and after > before:\n            return \"YES\"\n    return \"NO\"\n\nprint(did_anton_perform_good())"}
{"solution": "def count_missed_trains(s):\n    \"\"\"\n    Calculate the number of trains that have departed strictly before time s.\n\n    Args:\n    s (str): A binary number representing the time.\n\n    Returns:\n    int: The number of trains that have departed strictly before time s.\n    \"\"\"\n    # Convert binary string to integer\n    s_int = int(s, 2)\n    \n    # Initialize the number of trains and the current time\n    num_trains = 0\n    current_time = 1\n    \n    # Loop until the current time is greater than s\n    while current_time <= s_int:\n        # If the current time is less than s, increment the number of trains\n        if current_time < s_int:\n            num_trains += 1\n        # Update the current time to the next train departure time\n        current_time *= 4\n    \n    return num_trains\n\n# Read the binary number from input\ns = input()\n\n# Calculate and print the number of missed trains\nprint(count_missed_trains(s))"}
{"solution": "def min_rows(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n    for i in range(n // 2):\n        if matrix[i]!= matrix[n - i - 1]:\n            return n - i\n    return n // 2 if n % 2 == 0 else n // 2 + 1\n\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\nprint(min_rows(matrix))"}
{"solution": "def max_non_overlapping_orders(n, orders):\n    \"\"\"\n    This function calculates the maximum number of non-overlapping orders that can be accepted.\n\n    Parameters:\n    n (int): The number of orders.\n    orders (list): A list of tuples, where each tuple contains the start and end time of an order.\n\n    Returns:\n    int: The maximum number of non-overlapping orders.\n    \"\"\"\n    # Sort the orders based on their end times\n    orders.sort(key=lambda x: x[1])\n\n    # Initialize the count of non-overlapping orders with 1 (the first order)\n    count = 1\n\n    # Initialize the end time of the last accepted order\n    last_end_time = orders[0][1]\n\n    # Iterate through the orders starting from the second order\n    for start, end in orders[1:]:\n        # If the current order does not overlap with the last accepted order, increment the count and update the last end time\n        if start > last_end_time:\n            count += 1\n            last_end_time = end\n\n    return count\n\n\n# Read the number of orders\nn = int(input())\n\n# Read the orders\norders = []\nfor _ in range(n):\n    start, end = map(int, input().split())\n    orders.append((start, end))\n\n# Calculate and print the maximum number of non-overlapping orders\nprint(max_non_overlapping_orders(n, orders))"}
{"solution": "def solve():\n    n, k = map(int, input().split())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n\n    total_tables = sum(x)\n    total_formulas = sum(y)\n\n    if total_tables > total_formulas:\n        x, y = y, x\n\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + x[i]\n\n    for i in range(n):\n        if prefix_sum[i] % (k + 1) == 0 and prefix_sum[i + 1] > prefix_sum[i] + k:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n\nsolve()"}
{"solution": "def can_human_win(n, k, coefficients):\n    # Calculate the value of P(k)\n    p_k = sum(int(coeff) * (k ** i) for i, coeff in enumerate(coefficients) if coeff!= '?')\n\n    # Count the number of unknown coefficients\n    unknown_count = sum(1 for coeff in coefficients if coeff == '?')\n\n    # If the number of unknown coefficients is odd, human can win\n    if unknown_count % 2 == 1:\n        return True\n\n    # If P(k) is not divisible by the number of unknown coefficients, human can win\n    if p_k % unknown_count!= 0:\n        return True\n\n    # Otherwise, human cannot win\n    return False\n\n\nn, k = map(int, input().split())\ncoefficients = [input().strip() for _ in range(n + 1)]\n\nif can_human_win(n, k, coefficients):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def sieve_of_eratosthenes(n):\n    \"\"\"Generate all prime numbers up to n.\"\"\"\n    sieve = [True] * (n + 1)\n    sieve[0:2] = [False, False]\n    for current_prime in range(2, int(n**0.5) + 1):\n        if sieve[current_prime]:\n            for multiple in range(current_prime**2, n + 1, current_prime):\n                sieve[multiple] = False\n    return [num for num, is_prime in enumerate(sieve) if is_prime]\n\n\ndef smallest_starting_number(x2):\n    \"\"\"Find the smallest possible starting number X_0 given X_2.\"\"\"\n    primes = sieve_of_eratosthenes(x2)\n    min_x0 = x2\n\n    for p in primes:\n        if p >= x2 - 1:\n            break\n        x1 = x2 - x2 % p + p\n        if x1 < x2:\n            for q in primes:\n                if q >= x1 - 1:\n                    break\n                x0 = x1 - x1 % q + q\n                if x0 < x1 and x0 >= 3:\n                    min_x0 = min(min_x0, x0)\n\n    return min_x0\n\n\nx2 = int(input())\nprint(smallest_starting_number(x2))"}
{"solution": "def min_p_binary_numbers(n, p):\n    for k in range(1, n + 1):\n        if (n - k * p) < k or bin(n - k * p).count('1') > k:\n            continue\n        return k\n    return -1\n\nn, p = map(int, input().split())\nprint(min_p_binary_numbers(n, p))"}
{"solution": "def minimize_integer(n, k, s):\n    s = list(s)\n    if k == 0:\n        return ''.join(s)\n    if n == 1:\n        return '0'\n    if s[0]!= '1':\n        s[0] = '1'\n        k -= 1\n    for i in range(1, n):\n        if k > 0 and s[i]!= '0':\n            s[i] = '0'\n            k -= 1\n    return ''.join(s)\n\nn, k = map(int, input().split())\ns = input()\nprint(minimize_integer(n, k, s))"}
{"solution": "def min_presents(cnt_1, cnt_2, x, y):\n    def count_multiples(n, limit):\n        return limit // n\n\n    def count_multiples_xy(limit):\n        return limit // (x * y)\n\n    v = 0\n    while True:\n        v += 1\n        total_multiples_x = count_multiples(x, v)\n        total_multiples_y = count_multiples(y, v)\n        total_multiples_xy = count_multiples_xy(v)\n        total_multiples = total_multiples_x + total_multiples_y - total_multiples_xy\n        available = v - total_multiples\n        if available >= cnt_1 + cnt_2:\n            return v\n\n        # Try to find a better distribution\n        multiples_x = count_multiples(x, v)\n        multiples_y = count_multiples(y, v)\n        xy_multiples = count_multiples_xy(v)\n        if multiples_x >= cnt_1:\n            remaining = multiples_x - cnt_1\n            available_y = v - multiples_y + remaining - xy_multiples\n            if available_y >= cnt_2:\n                return v\n        if multiples_y >= cnt_2:\n            remaining = multiples_y - cnt_2\n            available_x = v - multiples_x + remaining - xy_multiples\n            if available_x >= cnt_1:\n                return v\n\ncnt_1, cnt_2, x, y = map(int, input().split())\nprint(min_presents(cnt_1, cnt_2, x, y))"}
{"solution": "def calculate_position(n, sx, sy, dx, dy, t):\n    x, y = sx, sy\n    for _ in range(min(t, 2 * n + 2)):\n        k = x + y\n        dx += k\n        dy += k\n        x = ((x + dx - 1) % n) + 1\n        y = ((y + dy - 1) % n) + 1\n    if t > 2 * n + 2:\n        period = 2 * n + 2\n        t %= period\n        x, y = sx, sy\n        dx, dy = dx, dy\n        for _ in range(t):\n            k = x + y\n            dx += k\n            dy += k\n            x = ((x + dx - 1) % n) + 1\n            y = ((y + dy - 1) % n) + 1\n    return x, y\n\nn, sx, sy, dx, dy, t = map(int, input().split())\nx, y = calculate_position(n, sx, sy, dx, dy, t)\nprint(x, y)"}
{"solution": "def solve(s):\n    n = len(s)\n    if n < 26:\n        return -1\n\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    alphabet_set = set(alphabet)\n\n    for i in range(n - 25):\n        window = s[i:i+26]\n        window_set = set(window.replace('?', ''))\n        missing_letters = alphabet_set - window_set\n        if len(missing_letters) > window.count('?'):\n            continue\n\n        result = list(window)\n        j = 0\n        for k in range(26):\n            if result[k] == '?':\n                result[k] = missing_letters.pop()\n        if set(result) == alphabet_set:\n            s = list(s)\n            s[i:i+26] = result\n            s = ''.join(s)\n            break\n\n    if '?' in s:\n        for i, c in enumerate(s):\n            if c == '?':\n                for letter in alphabet:\n                    if letter not in s:\n                        s = s[:i] + letter + s[i+1:]\n                        break\n\n    if any(s.count(letter) > 1 for letter in alphabet):\n        return -1\n\n    return s\n\ns = input()\nresult = solve(s)\nif result == -1:\n    print(-1)\nelse:\n    print(result)"}
{"solution": "def can_divide_apples(n, weights):\n    total_weight = sum(weights)\n    if total_weight % 2!= 0:\n        return \"NO\"\n    \n    target_weight = total_weight // 2\n    num_200g_apples = weights.count(200)\n    num_100g_apples = n - num_200g_apples\n    \n    if target_weight % 100 == 0:\n        if target_weight // 100 <= num_100g_apples:\n            return \"YES\"\n        elif target_weight // 100 <= num_100g_apples + num_200g_apples * 2:\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        if (target_weight - 200) // 100 <= num_100g_apples and num_200g_apples >= 1:\n            return \"YES\"\n        else:\n            return \"NO\"\n\nn = int(input())\nweights = list(map(int, input().split()))\nprint(can_divide_apples(n, weights))"}
{"solution": "def min_time_to_turn_off_lights(n, m, building):\n    total_time = 0\n    for i in range(n):\n        floor = building[i]\n        left_index = 1\n        right_index = m\n        while left_index <= right_index:\n            if floor[left_index] == '1':\n                total_time += left_index - 1\n                left_index += 1\n            elif floor[right_index] == '1':\n                total_time += m - right_index + 1\n                right_index -= 1\n            else:\n                left_index += 1\n                right_index -= 1\n        total_time += 1  # Move to the next floor\n    return total_time\n\n\nn, m = map(int, input().split())\nbuilding = [input() for _ in range(n)]\nprint(min_time_to_turn_off_lights(n, m, building))"}
{"solution": "def find_min_trap_cost(n, costs, transitions):\n    visited = [False] * n\n    in_stack = [False] * n\n    min_cost = 0\n\n    def dfs(node):\n        stack = []\n        while True:\n            if visited[node]:\n                if in_stack[node]:\n                    # Found a cycle, calculate the minimum cost in this cycle\n                    cycle_min_cost = float('inf')\n                    while stack:\n                        cycle_node = stack.pop()\n                        in_stack[cycle_node] = False\n                        cycle_min_cost = min(cycle_min_cost, costs[cycle_node])\n                        if cycle_node == node:\n                            break\n                    return cycle_min_cost\n                else:\n                    return 0\n            visited[node] = True\n            in_stack[node] = True\n            stack.append(node)\n            node = transitions[node] - 1\n\n    for i in range(n):\n        if not visited[i]:\n            min_cost += dfs(i)\n\n    return min_cost\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(find_min_trap_cost(n, costs, transitions))"}
{"solution": "def calculate_final_entrance(n, a, b):\n    \"\"\"\n    Calculate the final entrance number after Vasya's walk.\n\n    Args:\n    n (int): The total number of entrances.\n    a (int): The initial entrance number.\n    b (int): The length of Vasya's walk.\n\n    Returns:\n    int: The final entrance number.\n    \"\"\"\n    # Calculate the final entrance number by adding the walk length to the initial entrance number\n    # and taking the modulus of the total number of entrances to handle circular movement\n    final_entrance = (a + b - 1) % n + 1\n    \n    return final_entrance\n\n# Read input values\nn, a, b = map(int, input().split())\n\n# Calculate and print the final entrance number\nprint(calculate_final_entrance(n, a, b))"}
{"solution": "def min_arithmetic_progressions(n, sequence):\n    \"\"\"\n    Calculate the minimum number of arithmetic progressions needed to represent a given sequence.\n\n    Args:\n    n (int): The number of elements in the sequence.\n    sequence (list): A list of integers representing the sequence.\n\n    Returns:\n    int: The minimum number of arithmetic progressions.\n    \"\"\"\n    if n == 1:\n        return 1\n\n    progressions = 1\n    prev_diff = None\n    prev_prev_value = None\n    prev_value = None\n\n    for i in range(n):\n        value = sequence[i]\n        if value == -1:\n            continue\n\n        if prev_value is not None:\n            curr_diff = value - prev_value\n            if prev_prev_value is not None and prev_diff is not None:\n                if curr_diff!= prev_diff:\n                    progressions += 1\n                    prev_diff = None\n                    prev_prev_value = None\n            else:\n                prev_diff = curr_diff\n            prev_prev_value = prev_value\n        prev_value = value\n\n    return progressions\n\n\nn = int(input())\nsequence = list(map(int, input().split()))\nprint(min_arithmetic_progressions(n, sequence))"}
{"solution": "def max_beauty(n, k, s):\n    def max_beauty_helper(s, target):\n        left = 0\n        changes = 0\n        max_length = 0\n\n        for right in range(n):\n            if s[right]!= target:\n                changes += 1\n\n            while changes > k:\n                if s[left]!= target:\n                    changes -= 1\n                left += 1\n\n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n\n    return max(max_beauty_helper(s, 'a'), max_beauty_helper(s, 'b'))\n\nn, k = map(int, input().split())\ns = input().strip()\n\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, seats):\n    total_seats = sum(seats)\n    alice_seats = seats[0]\n    majority_seats = (total_seats + 1) // 2\n\n    if alice_seats >= majority_seats:\n        return [1]\n\n    coalition = [1]\n    seats = sorted((seat, i + 1) for i, seat in enumerate(seats[1:]))\n\n    for seat, party in seats:\n        if seat * 2 <= alice_seats and sum(seat for seat, _ in seats[:seats.index((seat, party)) + 1]) + alice_seats >= majority_seats:\n            coalition.append(party)\n        if sum(seat for seat, _ in seats[:seats.index((seat, party)) + 1]) + alice_seats >= majority_seats:\n            break\n\n    if sum(seat for seat, _ in seats[:len(coalition) - 1]) + alice_seats >= majority_seats:\n        return coalition\n    else:\n        return [0]\n\n\nn = int(input())\nseats = list(map(int, input().split()))\n\ncoalition = find_coalition(n, seats)\n\nif coalition == [0]:\n    print(0)\nelse:\n    print(len(coalition))\n    print(*coalition)"}
{"solution": "def max_reward(n):\n    harmonic_sum = 0.0\n    for i in range(1, n + 1):\n        harmonic_sum += 1.0 / i\n    return harmonic_sum\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the maximum reward\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "import math\n\ndef find_max_children(n):\n    k = int((math.sqrt(8 * n + 1) - 1) / 2)\n    remaining_candies = n - k * (k + 1) // 2\n    candies = list(range(1, k + 1))\n    candies[-1] += remaining_candies\n    return k, candies\n\nn = int(input())\nk, candies = find_max_children(n)\nprint(k)\nprint(*candies)"}
{"solution": "n = int(input())\nm = int(input())\n\nprint(m % (1 << n))"}
{"solution": "def correct_word(word):\n    vowels = 'aeiouy'\n    stack = []\n    \n    for char in word:\n        if char in vowels and stack and stack[-1] in vowels:\n            stack.pop()\n        else:\n            stack.append(char)\n    \n    return ''.join(stack)\n\nn = int(input())\nword = input()\n\nprint(correct_word(word))"}
{"solution": "def max_students(n, a, b, seats):\n    segments = []\n    i = 0\n    \n    # Identify segments of empty seats\n    while i < n:\n        if seats[i] == '.':\n            start = i\n            while i < n and seats[i] == '.':\n                i += 1\n            segments.append(i - start)\n        else:\n            i += 1\n    \n    total_students = 0\n    \n    # Place students in each segment\n    for length in segments:\n        # Calculate the number of students that can be placed in this segment\n        # We will place students in an alternating fashion\n        if a > b:\n            # Start with a student-programmer if more student-programmers are available\n            programmers = (length + 1) // 2\n            athletes = length // 2\n        else:\n            # Start with a student-athlete if more student-athletes are available\n            athletes = (length + 1) // 2\n            programmers = length // 2\n        \n        # Place the students\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n        \n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n    \n    return total_students\n\nn, a, b = map(int, input().split())\nseats = input()\nprint(max_students(n, a, b, seats))"}
{"solution": "import math\n\ndef find_xy(r):\n    for x in range(1, int(math.sqrt(r)) + 1):\n        discriminant = 4 * x**2 - 4 * (r - x**2 - x - 1)\n        if discriminant >= 0:\n            y = (2 * x + math.sqrt(discriminant)) / 2\n            if y == int(y) and y > 0:\n                return x, int(y)\n    return None\n\nr = int(input())\nresult = find_xy(r)\nif result is None:\n    print(\"NO\")\nelse:\n    print(*result)"}
{"solution": "def divide_packets(n, packets):\n    total_balloons = sum(packets)\n    if n == 1 or total_balloons % 2 == 0 and len(set(packets)) == 1:\n        return -1\n\n    grigory_packets = []\n    andrew_packets = []\n    packets.sort(reverse=True)\n\n    for i, packet in enumerate(packets):\n        if sum(grigory_packets) <= sum(andrew_packets):\n            grigory_packets.append(packet)\n        else:\n            andrew_packets.append(packet)\n\n    if sum(grigory_packets) == sum(andrew_packets):\n        if len(grigory_packets) > 1:\n            andrew_packets.append(grigory_packets.pop())\n        elif len(andrew_packets) > 1:\n            grigory_packets.append(andrew_packets.pop())\n        else:\n            return -1\n\n    grigory_indices = [i + 1 for i, packet in enumerate(packets) if packet in grigory_packets]\n    return len(grigory_indices), grigory_indices\n\n\nn = int(input())\npackets = list(map(int, input().split()))\n\nresult = divide_packets(n, packets)\nif result == -1:\n    print(-1)\nelse:\n    print(result[0])\n    print(*result[1])"}
{"solution": "def min_diverse_digits(n):\n    if n < 10:\n        return [n]\n\n    for i in range(9, 0, -1):\n        if n % i == 0:\n            return [i] * (n // i)\n\n    for i in range(9, 0, -1):\n        if n > i and n % i!= 0:\n            return [i] + min_diverse_digits(n - i)\n\n\nn = int(input())\nresult = min_diverse_digits(n)\nprint(len(result))\nprint(*result)"}
{"solution": "def sieve_of_eratosthenes(n):\n    \"\"\"Generate all prime numbers up to n.\"\"\"\n    sieve = [True] * (n + 1)\n    sieve[0:2] = [False, False]\n    for current_prime in range(2, int(n**0.5) + 1):\n        if sieve[current_prime]:\n            for multiple in range(current_prime*2, n + 1, current_prime):\n                sieve[multiple] = False\n    return [num for num, is_prime in enumerate(sieve) if is_prime]\n\n\ndef is_prime(n, primes):\n    \"\"\"Check if a number is prime.\"\"\"\n    return n in primes\n\n\ndef find_simple_subset(nums, primes):\n    \"\"\"Find a simple subset of the array with the maximum size.\"\"\"\n    max_size = 0\n    max_subset = []\n    for num in nums:\n        if num == 1:\n            continue\n        current_subset = [num]\n        for other_num in nums:\n            if other_num == num:\n                continue\n            if is_prime(num + other_num, primes):\n                current_subset.append(other_num)\n        if len(current_subset) > max_size:\n            max_size = len(current_subset)\n            max_subset = current_subset\n    return max_size, max_subset\n\n\ndef main():\n    n = int(input())\n    nums = list(map(int, input().split()))\n    primes = set(sieve_of_eratosthenes(2 * 10**6))\n    max_size, max_subset = find_simple_subset(nums, primes)\n    print(max_size)\n    print(*max_subset)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef greatest_beautiful_divisor(n):\n    max_k = int(math.log2(math.sqrt(n))) + 1\n    max_beautiful_divisor = 1\n\n    for k in range(1, max_k + 1):\n        beautiful_number = (2 ** k - 1) ** 2\n        if n % beautiful_number == 0:\n            max_beautiful_divisor = max(max_beautiful_divisor, beautiful_number)\n\n    return max_beautiful_divisor\n\nn = int(input())\nprint(greatest_beautiful_divisor(n))"}
{"solution": "def count_magic_numbers(m, d, a, b):\n    MOD = 10**9 + 7\n    n = len(a)\n    a = int(a)\n    b = int(b)\n\n    def count_magic_numbers_with_length(length):\n        if length == 0:\n            return 1 if 0 % m == 0 else 0\n\n        count = 0\n        for first_digit in range(1, 10):\n            if length % 2 == 1:\n                if first_digit == d:\n                    continue\n                count += pow(10, length - 1, MOD) * count_magic_numbers_with_length(length - 1)\n            else:\n                if first_digit!= d:\n                    continue\n                count += pow(10, length - 1, MOD) * count_magic_numbers_with_length(length - 1)\n            count %= MOD\n\n        return count\n\n    def count_magic_numbers_multiple_of_m_with_length(length):\n        count = 0\n        for first_digit in range(1, 10):\n            if length % 2 == 1:\n                if first_digit == d:\n                    continue\n                count += pow(10, length - 1, MOD) * count_magic_numbers_multiple_of_m_with_length(length - 1)\n            else:\n                if first_digit!= d:\n                    continue\n                count += pow(10, length - 1, MOD) * count_magic_numbers_multiple_of_m_with_length(length - 1)\n            count %= MOD\n\n        if length == 0:\n            return 1 if 0 % m == 0 else 0\n        else:\n            return count * pow(m, MOD - 2, MOD) % MOD\n\n    def count_magic_numbers_multiple_of_m_in_range(start, end):\n        count = 0\n        for length in range(1, len(str(end)) + 1):\n            count += count_magic_numbers_multiple_of_m_with_length(length)\n            count %= MOD\n\n        for i in range(len(str(start))):\n            if i % 2 == 0:\n                if str(start)[i]!= str(d):\n                    continue\n            else:\n                if str(start)[i] == str(d):\n                    continue\n            count -= count_magic_numbers_multiple_of_m_with_length(len(str(start)) - i - 1)\n            count %= MOD\n\n        for i in range(len(str(end))):\n            if i % 2 == 0:\n                if str(end)[i]!= str(d):\n                    continue\n            else:\n                if str(end)[i] == str(d):\n                    continue\n            count -= count_magic_numbers_multiple_of_m_with_length(len(str(end)) - i - 1)\n            count %= MOD\n\n        return count\n\n    return count_magic_numbers_multiple_of_m_in_range(a, b)\n\nm, d = map(int, input().split())\na = input()\nb = input()\nprint(count_magic_numbers(m, d, a, b))"}
{"solution": "from collections import deque\n\ndef last_child(n, m, candies):\n    queue = deque(range(1, n + 1))\n    index = 0\n    while queue:\n        child = queue.popleft()\n        candies[index] -= m\n        if candies[index] > 0:\n            queue.append(child)\n        index = (index + 1) % n\n    return child\n\nn, m = map(int, input().split())\ncandies = list(map(int, input().split()))\nprint(last_child(n, m, candies))"}
{"solution": "def min_bills(n):\n    denominations = [100, 20, 10, 5, 1]\n    bills = 0\n\n    for denomination in denominations:\n        bills += n // denomination\n        n %= denomination\n\n    return bills\n\nn = int(input())\nprint(min_bills(n))"}
{"solution": "MOD = 1000000007\n\ndef count_permutations(n, k):\n    if k > n or (n - k) % 2!= 0:\n        return 0\n\n    dp = [[[0 for _ in range(k + 1)] for _ in range(n + 1)] for _ in range(2)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(min(i, k) + 1):\n            dp[i % 2][i][j] = dp[(i - 1) % 2][i - 1][j]\n            if j > 0:\n                dp[i % 2][i][j] += dp[(i - 1) % 2][i - 1][j - 1]\n            if i >= 2 and j > 0:\n                dp[i % 2][i][j] += dp[(i - 1) % 2][i - 2][j - 1]\n            dp[i % 2][i][j] %= MOD\n\n    return dp[n % 2][n][k]\n\nn, k = map(int, input().split())\nprint(count_permutations(n, k))"}
{"solution": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    b = list(map(int, sys.stdin.readline().split()))\n    c = sys.stdin.readline().strip()\n\n    red = []\n    white = []\n    orange = []\n\n    for i in range(n):\n        if c[i] == 'R':\n            red.append(b[i])\n        elif c[i] == 'W':\n            white.append(b[i])\n        else:\n            orange.append(b[i])\n\n    red.sort(reverse=True)\n    white.sort(reverse=True)\n    orange.sort(reverse=True)\n\n    max_beauty = -1\n\n    if len(red) > 0 and len(orange) > 0:\n        for i in range(1, min(len(red), k) + 1):\n            if k - i <= len(orange):\n                max_beauty = max(max_beauty, sum(red[:i]) + sum(orange[:k - i]))\n\n    if len(white) > 0 and len(orange) > 0:\n        for i in range(1, min(len(white), k) + 1):\n            if k - i <= len(orange):\n                max_beauty = max(max_beauty, sum(white[:i]) + sum(orange[:k - i]))\n\n    print(max_beauty)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef simplify_fraction(numerator, denominator):\n    common_divisor = gcd(numerator, denominator)\n    return numerator // common_divisor, denominator // common_divisor\n\ndef evaluate_continued_fraction(coefficients):\n    numerator, denominator = coefficients[-1], 1\n    for coefficient in coefficients[-2::-1]:\n        numerator, denominator = coefficient * numerator + denominator, numerator\n    return numerator, denominator\n\np, q = map(int, input().split())\nn = int(input())\ncoefficients = list(map(int, input().split()))\n\nfraction_numerator, fraction_denominator = evaluate_continued_fraction(coefficients)\nfraction_numerator, fraction_denominator = simplify_fraction(fraction_numerator, fraction_denominator)\n\np, q = simplify_fraction(p, q)\n\nif (p, q) == (fraction_numerator, fraction_denominator):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_sticks(expression):\n    sticks = expression.replace('+','').replace('=','').split()\n    return [len(stick) for stick in sticks]\n\ndef is_correct(expression):\n    sticks = count_sticks(expression)\n    return sticks[0] + sticks[1] == sticks[2]\n\ndef shift_stick(expression, from_index, to_index):\n    sticks = expression.replace('+','').replace('=','').split()\n    stick = sticks[from_index][-1]\n    sticks[from_index] = sticks[from_index][:-1]\n    sticks[to_index] += stick\n    return ''.join(sticks).replace(' ', '+').replace('=', '=')\n\ndef solve(expression):\n    if is_correct(expression):\n        return expression\n\n    for i in range(3):\n        for j in range(3):\n            if i!= j:\n                new_expression = shift_stick(expression, i, j)\n                if is_correct(new_expression):\n                    return new_expression\n\n    return \"Impossible\"\n\nexpression = input()\nprint(solve(expression))"}
{"solution": "MOD = 10**9 + 7\n\ndef main():\n    n, k = map(int, input().split())\n    dp = [[[0] * (n * n + 1) for _ in range(n + 1)] for _ in range(2)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            for odd in range(i * i + 1):\n                if odd - i >= 0:\n                    dp[i % 2][j][odd] += dp[(i - 1) % 2][j][odd - i]\n                if j > 0 and odd - i + 1 >= 0:\n                    dp[i % 2][j][odd] += j * dp[(i - 1) % 2][j - 1][odd - i + 1]\n                dp[i % 2][j][odd] %= MOD\n\n    print(dp[n % 2][n][k])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef solve():\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    def get_config(x, y):\n        config = []\n        if x < 0:\n            config.append('L')\n            x = -x\n        else:\n            config.append('R')\n        if y < 0:\n            config.append('D')\n            y = -y\n        else:\n            config.append('U')\n        return config, x, y\n\n    def get_path(x, y):\n        path = []\n        while x > 0 or y > 0:\n            if x > 0 and y > 0:\n                if x > y:\n                    path.append('R')\n                    x -= 1\n                else:\n                    path.append('U')\n                    y -= 1\n            elif x > 0:\n                path.append('R')\n                x -= 1\n            else:\n                path.append('U')\n                y -= 1\n        return path\n\n    configs = []\n    for x, y in points:\n        config, x, y = get_config(x, y)\n        path = get_path(x, y)\n        configs.append(config + path)\n\n    max_len = max(len(config) for config in configs)\n    for config in configs:\n        while len(config) < max_len:\n            config.append('R')\n\n    m = max_len\n    d = [1] * m\n    print(m)\n    print(*d)\n    for config in configs:\n        print(''.join(config))\n\nif __name__ == '__main__':\n    solve()"}
{"solution": "import re\n\nn = int(input())\ns = input()\n\npattern = r'ogo(go)*'\ns = re.sub(pattern, '***', s)\n\nprint(s)"}
{"solution": "def prime_factors(n):\n    \"\"\"Returns a dictionary of prime factors and their powers\"\"\"\n    factors = {}\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors[i] = factors.get(i, 0) + 1\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef g(y, p):\n    \"\"\"Returns the maximum possible integer p^k where k is an integer such that y is divisible by p^k\"\"\"\n    k = 0\n    while y % p == 0:\n        y //= p\n        k += 1\n    return p ** k\n\ndef f(x, y):\n    \"\"\"Returns the product of g(y, p) for all p in prime(x)\"\"\"\n    factors = prime_factors(x)\n    result = 1\n    for p in factors:\n        result = (result * g(y, p)) % (10**9 + 7)\n    return result\n\ndef main():\n    x, n = map(int, input().split())\n    factors = prime_factors(x)\n    result = 1\n    for p in factors:\n        k = factors[p]\n        sum_p_k = (p ** k * (n // p ** k) + (p ** (k - 1) * (n // p ** (k - 1) - n // p ** k))) % (10**9 + 7)\n        result = (result * sum_p_k) % (10**9 + 7)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = set()\n    for s in range(1, 82):  # s(x) can be at most 81\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and sum_of_digits(x) == s:\n            solutions.add(x)\n    return sorted(list(solutions))\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find solutions\nsolutions = find_solutions(a, b, c)\n\n# Print results\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "def is_solved(face):\n    return len(set(face)) == 1\n\ndef is_solvable(cube):\n    for i in range(0, 24, 4):\n        face = cube[i:i+4]\n        if is_solved(face):\n            return True\n    return False\n\ndef rotate_face(cube, face_index):\n    face = cube[face_index:face_index+4]\n    rotated_face = [face[3], face[0], face[1], face[2]]\n    return cube[:face_index] + rotated_face + cube[face_index+4:]\n\ndef is_cube_solvable(cube):\n    for i in range(0, 24, 4):\n        rotated_cube = rotate_face(cube, i)\n        if is_solvable(rotated_cube):\n            return True\n    return False\n\ncube = list(map(int, input().split()))\nif is_cube_solvable(cube):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def get_score(s):\n    i = (s // 50) % 475\n    scores = set()\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        scores.add(26 + i)\n    return scores\n\ndef solve(p, x, y):\n    min_hacks = float('inf')\n    for s in range(y, 20001):\n        scores = get_score(s)\n        if p in scores:\n            hacks = (s - x + 99) // 100\n            min_hacks = min(min_hacks, hacks)\n    return min_hacks\n\np, x, y = map(int, input().split())\nprint(solve(p, x, y))"}
{"solution": "def min_distance(n, a, b, c):\n    if n == 1:\n        return 0\n    elif n == 2:\n        return min(a, b, c)\n    else:\n        return min(a + c, b + c, a + b) + (n - 2) * min(a, b, c)\n\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nprint(min_distance(n, a, b, c))"}
{"solution": "def min_distance(x1, x2, x3):\n    return sum(abs(x - sorted([x1, x2, x3])[1]) for x in [x1, x2, x3])\n\nx1, x2, x3 = map(int, input().split())\nprint(min_distance(x1, x2, x3))"}
{"solution": "def solve():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    seen = set()\n    ans = float('inf')\n\n    for i in a:\n        if i & x in seen:\n            ans = 0\n            break\n        seen.add(i & x)\n\n    if ans == 0:\n        print(ans)\n        return\n\n    for i in a:\n        j = i & x\n        while j!= 0:\n            if j in seen:\n                ans = min(ans, i ^ j)\n            j = (j - 1) & i\n        seen.add(i)\n\n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(1)\n\nsolve()"}
{"solution": "def check_plus(grid, center):\n    h, w = len(grid), len(grid[0])\n    cx, cy = center\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for dx, dy in directions:\n        x, y = cx + dx, cy + dy\n        while 0 <= x < h and 0 <= y < w and grid[x][y] == '*':\n            x += dx\n            y += dy\n        if (x, y)!= (cx + dx, cy + dy):\n            return False\n    return True\n\n\ndef check_unique(grid, center):\n    h, w = len(grid), len(grid[0])\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*' and (i, j) not in [(center[0] + dx, center[1] + dy) for dx in range(-1, 2) for dy in range(-1, 2)]:\n                return False\n    return True\n\n\ndef check_empty(grid, center):\n    h, w = len(grid), len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for dx, dy in directions:\n        x, y = center[0] + dx, center[1] + dy\n        while 0 <= x < h and 0 <= y < w and grid[x][y] == '*':\n            x += dx\n            y += dy\n        if 0 <= x < h and 0 <= y < w and grid[x][y] == '*':\n            return False\n    return True\n\n\ndef solve():\n    h, w = map(int, input().split())\n    grid = [list(input()) for _ in range(h)]\n    centers = [(i, j) for i in range(h) for j in range(w) if grid[i][j] == '*']\n    for center in centers:\n        if check_plus(grid, center) and check_unique(grid, center) and check_empty(grid, center):\n            return \"YES\"\n    return \"NO\"\n\n\nprint(solve())"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, a, b = read_ints()\n\n    if a == 1 and b == 1:\n        print(\"NO\")\n        return\n\n    if a + b > n + 1:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n\n    matrix = [[0] * n for _ in range(n)]\n\n    if a > 1:\n        for i in range(a - 1):\n            matrix[i][i + 1] = matrix[i + 1][i] = 1\n\n    if b > 1:\n        for i in range(n - 1, n - b, -1):\n            matrix[i][i - 1] = matrix[i - 1][i] = 0\n\n    for row in matrix:\n        print(''.join(map(str, row)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_problems(c, d, n, m, k):\n    \"\"\"\n    Calculate the minimum number of problems needed for the finals.\n\n    Args:\n    c (int): Number of problems in the main elimination rounds.\n    d (int): Number of problems in the additional elimination rounds.\n    n (int): Number of winners in the main elimination rounds.\n    m (int): Number of main elimination rounds.\n    k (int): Number of pre-chosen winners.\n\n    Returns:\n    int: The minimum number of problems needed for the finals.\n    \"\"\"\n    total_winners = n * m - k\n    if total_winners <= 0:\n        return 0\n\n    main_rounds = total_winners // n\n    additional_winners = total_winners % n\n    additional_rounds = additional_winners if additional_winners > 0 else 0\n\n    return main_rounds * c + additional_rounds * d\n\n\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\nprint(min_problems(c, d, n, m, k))"}
{"solution": "from collections import defaultdict\n\ndef find_grid(s):\n    graph = defaultdict(list)\n    for i in range(26):\n        for j in range(i + 1, 26):\n            if abs(i - j) == 1 or abs(i - j) == 13:\n                graph[chr(65 + i)].append(chr(65 + j))\n                graph[chr(65 + j)].append(chr(65 + i))\n\n    def dfs(node, path):\n        if len(path) == 27:\n            return path\n        for neighbor in graph[node]:\n            if neighbor not in path:\n                new_path = dfs(neighbor, path + neighbor)\n                if new_path:\n                    return new_path\n        return None\n\n    for i in range(26):\n        path = dfs(chr(65 + i), chr(65 + i))\n        if path and path == s:\n            grid = [[''for _ in range(13)] for _ in range(2)]\n            for i, char in enumerate(path):\n                grid[i // 13][i % 13] = char\n            return '\\n'.join(''.join(row) for row in grid)\n\n    return \"Impossible\"\n\ns = input()\nprint(find_grid(s))"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<' if y > 1 else '='\n    elif y == 1:\n        return '>' if x > 1 else '='\n    else:\n        # Compute y * log(x) and x * log(y)\n        lhs = y * math.log(x)\n        rhs = x * math.log(y)\n        \n        if lhs < rhs:\n            return '<'\n        elif lhs > rhs:\n            return '>'\n        else:\n            return '='\n\n# Read input\nx, y = map(int, input().split())\n\n# Output the result of the comparison\nprint(compare_powers(x, y))"}
{"solution": "import math\n\ndef calculate_max_balloons():\n    r, h = map(int, input().split())\n    max_balloons_in_height = math.floor((h + r) / r)\n    max_balloons_in_width = math.floor((2 * r) / r)\n    max_balloons_in_base = math.floor(math.pi * r * r / (2 * math.pi * (r / 2) ** 2))\n    return max_balloons_in_height * max_balloons_in_width * max_balloons_in_base\n\nprint(calculate_max_balloons())"}
{"solution": "def min_sum_of_remaining_cards():\n    # Read the input\n    cards = list(map(int, input().split()))\n\n    # Sort the cards in ascending order\n    cards.sort()\n\n    # Initialize the minimum sum\n    min_sum = sum(cards)\n\n    # Check if we can discard two or three cards with the same number\n    for i in range(len(cards) - 2):\n        if cards[i] == cards[i + 1] == cards[i + 2]:\n            # Discard three cards with the same number\n            min_sum = min(min_sum, sum(cards[:i]) + sum(cards[i + 3:]))\n        elif cards[i] == cards[i + 1]:\n            # Discard two cards with the same number\n            min_sum = min(min_sum, sum(cards[:i]) + sum(cards[i + 2:]))\n\n    # Check if we can discard two cards with the same number at the end\n    if len(cards) > 2 and cards[-1] == cards[-2]:\n        min_sum = min(min_sum, sum(cards[:-2]))\n\n    # Print the minimum sum\n    print(min_sum)\n\nmin_sum_of_remaining_cards()"}
{"solution": "import sys\n\ndef min_distance(n, a, x):\n    x.sort()\n    idx = x.index(min(x, key=lambda y: abs(y - a)))\n    left = x[:idx]\n    right = x[idx + 1:]\n    left_distance = sum(abs(y - a) for y in left) if left else 0\n    right_distance = sum(abs(y - a) for y in right) if right else 0\n    if len(left) > len(right):\n        return left_distance + min(abs(x[idx] - a), abs(x[-1] - a)) + sum(abs(x[i] - x[i - 1]) for i in range(idx + 1, n))\n    else:\n        return right_distance + min(abs(x[idx] - a), abs(x[0] - a)) + sum(abs(x[i] - x[i + 1]) for i in range(idx, n - 1))\n\nn, a = map(int, sys.stdin.readline().split())\nx = list(map(int, sys.stdin.readline().split()))\nprint(min_distance(n, a, x))"}
{"solution": "def sum_of_digits(x):\n    \"\"\"Calculate the sum of digits of a number.\"\"\"\n    return sum(int(digit) for digit in str(x))\n\ndef solve_equation(n):\n    \"\"\"Find the smallest positive integer root of the equation x^2 + s(x)*x - n = 0.\"\"\"\n    x = 1\n    while True:\n        s_x = sum_of_digits(x)\n        if x**2 + s_x*x - n == 0:\n            return x\n        elif x**2 + s_x*x > n:\n            return -1\n        x += 1\n\nn = int(input())\nprint(solve_equation(n))"}
{"solution": "def calculate_bed_time(current_time, sleep_time):\n    current_hours, current_minutes = map(int, current_time.split(':'))\n    sleep_hours, sleep_minutes = map(int, sleep_time.split(':'))\n\n    total_minutes = current_hours * 60 + current_minutes - (sleep_hours * 60 + sleep_minutes)\n    if total_minutes < 0:\n        total_minutes += 24 * 60\n\n    bed_hours = total_minutes // 60 % 24\n    bed_minutes = total_minutes % 60\n\n    return f\"{bed_hours:02d}:{bed_minutes:02d}\"\n\ncurrent_time = input()\nsleep_time = input()\n\nprint(calculate_bed_time(current_time, sleep_time))"}
{"solution": "def find_longest_subsegment(n, a):\n    max_sum = float('-inf')\n    current_sum = 0\n    max_length = 0\n    current_length = 0\n\n    for num in a:\n        if current_sum <= 0:\n            current_sum = num\n            current_length = 1\n        else:\n            current_sum += num\n            current_length += 1\n\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_length = current_length\n        elif current_sum == max_sum:\n            max_length = max(max_length, current_length)\n\n    return max_length\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nprint(find_longest_subsegment(n, a))"}
{"solution": "MOD = 998244353\n\ndef main():\n    n, m, k = map(int, input().split())\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[1][0] = m\n\n    for i in range(2, n + 1):\n        for j in range(min(i, k) + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = (dp[i - 1][j - 1] * (m - 1)) % MOD\n            dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD\n\n    ans = 0\n    for j in range(k + 1):\n        ans = (ans + dp[n][j]) % MOD\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import re\n\ndef is_magic_number(n):\n    pattern = re.compile(r'^(1|14|144)+$')\n    if pattern.match(str(n)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\nn = int(input())\nprint(is_magic_number(n))"}
{"solution": "import math\n\ndef min_moves(n, m, i, j, a, b):\n    moves = []\n    moves.append(math.ceil((i - 1) / a) + math.ceil((m - j) / b))\n    moves.append(math.ceil((n - i) / a) + math.ceil((m - j) / b))\n    moves.append(math.ceil((i - 1) / a) + math.ceil((j - 1) / b))\n    moves.append(math.ceil((n - i) / a) + math.ceil((j - 1) / b))\n\n    min_move = min(moves)\n    if min_move == float('inf'):\n        return \"Poor Inna and pony!\"\n    else:\n        return min_move\n\nn, m, i, j, a, b = map(int, input().split())\nprint(min_moves(n, m, i, j, a, b))"}
{"solution": "def max_removals(s):\n    n = len(s)\n    dp = [[0] * 26 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(26):\n            if j == ord(s[i - 1]) - ord('a'):\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + 1)\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return max(dp[n])\n\nn = int(input())\ns = input()\nprint(max_removals(s))"}
{"solution": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    denominations = list(map(int, sys.stdin.readline().split()))\n    q = int(sys.stdin.readline())\n\n    for _ in range(q):\n        x = int(sys.stdin.readline())\n        min_bills = float('inf')\n\n        for i in range(n):\n            for j in range(i, n):\n                bills = 0\n                remaining = x\n\n                while remaining > 0 and bills <= k:\n                    if remaining >= denominations[j]:\n                        remaining -= denominations[j]\n                    elif remaining >= denominations[i]:\n                        remaining -= denominations[i]\n                    else:\n                        break\n                    bills += 1\n\n                if remaining == 0 and bills < min_bills:\n                    min_bills = bills\n\n        if min_bills == float('inf'):\n            print(-1)\n        else:\n            print(min_bills)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import math\n\ndef calculate_time(s, x1, x2, t1, t2, p, d):\n    # Calculate the time it takes for Igor to walk from x1 to x2\n    walk_time = abs(x2 - x1) * t2\n\n    # Calculate the time it takes for the tram to reach x1\n    tram_time_to_x1 = abs(p - x1) * t1\n\n    # Calculate the time it takes for the tram to reach x2 after reaching x1\n    tram_time_to_x2 = abs(x2 - x1) * t1\n\n    # Calculate the total time it takes for Igor to take the tram\n    tram_time = tram_time_to_x1 + tram_time_to_x2\n\n    # Calculate the time it takes for Igor to take the tram and walk\n    tram_walk_time = tram_time_to_x1 + (abs(x2 - p) * t2)\n\n    # Calculate the minimum time\n    min_time = min(walk_time, tram_time, tram_walk_time)\n\n    # If the tram is moving towards x2, calculate the time it takes for Igor to take the tram\n    if (x1 < x2 and d == 1) or (x1 > x2 and d == -1):\n        tram_time = abs(p - x1) * t1 + (abs(x2 - p) * t1)\n        min_time = min(min_time, tram_time)\n\n    return min_time\n\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\nprint(calculate_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "import math\n\ndef count_occurrences(n, x):\n    count = 0\n    for i in range(1, min(n, int(math.sqrt(x))) + 1):\n        if x % i == 0:\n            j = x // i\n            if j <= n:\n                count += 1\n            if i!= j and i <= n:\n                count += 1\n    return count\n\nn, x = map(int, input().split())\nprint(count_occurrences(n, x))"}
{"solution": "import string\n\nn, k = map(int, input().split())\npassword = string.ascii_lowercase[:k]\n\nif n % 2 == 0:\n    password = (password * (n // 2))[:n]\nelse:\n    password = (password * (n // 2))[:n] + password[0]\n\nprint(password)"}
{"solution": "n = int(input())\ndirections = input()\npositions = list(map(int, input().split()))\n\nmin_time = float('inf')\ncollision_found = False\n\nfor i in range(n - 1):\n    if directions[i] == 'R' and directions[i + 1] == 'L':\n        collision_time = (positions[i + 1] - positions[i]) // 2\n        min_time = min(min_time, collision_time)\n        collision_found = True\n\nif collision_found:\n    print(min_time)\nelse:\n    print(-1)"}
{"solution": "def max_area(seals, paper):\n    max_area = 0\n    for i in range(len(seals)):\n        for j in range(i + 1, len(seals)):\n            area1 = seals[i][0] * seals[i][1]\n            area2 = seals[j][0] * seals[j][1]\n            if seals[i][0] <= paper[0] and seals[i][1] <= paper[1] and seals[j][0] <= paper[0] and seals[j][1] <= paper[1]:\n                max_area = max(max_area, area1 + area2)\n            elif seals[i][0] <= paper[0] and seals[j][1] <= paper[1] and seals[i][1] <= paper[1] and seals[j][0] <= paper[0]:\n                max_area = max(max_area, area1 + area2)\n            elif seals[i][1] <= paper[0] and seals[j][0] <= paper[1] and seals[i][0] <= paper[1] and seals[j][1] <= paper[0]:\n                max_area = max(max_area, area1 + area2)\n            elif seals[i][1] <= paper[0] and seals[j][1] <= paper[1] and seals[i][0] <= paper[1] and seals[j][0] <= paper[0]:\n                max_area = max(max_area, area1 + area2)\n    return max_area\n\nn, a, b = map(int, input().split())\nseals = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    seals.append([x, y])\nprint(max_area(seals, [a, b]))"}
{"solution": "def find_outlier_point(n, points):\n    \"\"\"\n    Find the point that does not lie on the boundary of an axis-aligned square.\n\n    Args:\n    n (int): The number of points on each side of the square.\n    points (list): A list of tuples representing the coordinates of the points.\n\n    Returns:\n    tuple: The coordinates of the point that is not on the boundary of the square.\n    \"\"\"\n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n\n    # Find the minimum and maximum x and y coordinates\n    min_x = min(x_coords)\n    max_x = max(x_coords)\n    min_y = min(y_coords)\n    max_y = max(y_coords)\n\n    # Initialize counters for points on each side of the square\n    left_side = 0\n    right_side = 0\n    top_side = 0\n    bottom_side = 0\n\n    # Count points on each side of the square\n    for point in points:\n        if point[0] == min_x:\n            left_side += 1\n        elif point[0] == max_x:\n            right_side += 1\n        if point[1] == min_y:\n            bottom_side += 1\n        elif point[1] == max_y:\n            top_side += 1\n\n    # Find the side with less than n points\n    if left_side < n:\n        return (min_x, max_y)\n    elif right_side < n:\n        return (max_x, max_y)\n    elif top_side < n:\n        return (max_x, max_y)\n    elif bottom_side < n:\n        return (max_x, min_y)\n\n    # If no side has less than n points, find the point that is not on the boundary\n    for point in points:\n        if point[0]!= min_x and point[0]!= max_x and point[1]!= min_y and point[1]!= max_y:\n            return point\n\n# Read input\nn = int(input())\npoints = []\nfor _ in range(4 * n + 1):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\n# Find and print the outlier point\noutlier_point = find_outlier_point(n, points)\nprint(outlier_point[0], outlier_point[1])"}
{"solution": "def max_digit_product(n):\n    max_product = 1\n    for i in range(1, n + 1):\n        product = 1\n        for digit in str(i):\n            product *= int(digit)\n        max_product = max(max_product, product)\n    return max_product\n\ndef max_digit_product_optimized(n):\n    max_product = 1\n    digits = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n    for digit in str(n):\n        if int(digit) < 9:\n            digits = digits[:digits.index(int(digit))]\n            break\n    for digit in digits:\n        max_product *= digit\n    return max_product\n\nn = int(input())\nprint(max_digit_product_optimized(n))"}
{"solution": "def smallest_winning_k(n, votes):\n    \"\"\"\n    Calculate the smallest k that guarantees Awruk's win.\n\n    Args:\n    n (int): The number of students in the school.\n    votes (list): A list of votes each student gives to Elodreip.\n\n    Returns:\n    int: The smallest k that guarantees Awruk's win.\n    \"\"\"\n    # Calculate the total votes for Elodreip\n    total_votes_elodreip = sum(votes)\n\n    # Initialize k as the maximum vote\n    k = max(votes)\n\n    # Calculate the total votes for Awruk\n    total_votes_awruk = sum(k - vote for vote in votes)\n\n    # While Awruk's votes are not more than Elodreip's votes, increment k\n    while total_votes_awruk <= total_votes_elodreip:\n        k += 1\n        total_votes_awruk = sum(k - vote for vote in votes)\n\n    return k\n\n\n# Read the number of students\nn = int(input())\n\n# Read the votes for Elodreip\nvotes = list(map(int, input().split()))\n\n# Calculate and print the smallest winning k\nprint(smallest_winning_k(n, votes))"}
{"solution": "def min_operations(s):\n    stack = []\n    operations = 0\n\n    for color in s:\n        if stack and stack[-1][0]!= color:\n            while stack and stack[-1][0]!= color:\n                stack.pop()\n            if stack:\n                stack[-1][1] += 1\n        else:\n            stack.append([color, 1])\n\n    while stack:\n        if len(stack) > 1 and stack[-1][1] == 1 and stack[-2][1] == 1:\n            stack.pop()\n            stack.pop()\n            operations += 1\n        else:\n            break\n\n    while stack:\n        if stack[-1][1] > 1:\n            stack[-1][1] -= 1\n            operations += 1\n        else:\n            break\n\n    return operations\n\ns = input()\nprint(min_operations(s))"}
{"solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n\n    min_product = a[0] * a[1] * a[2]\n    min_product_count = 1\n\n    for i in range(3, n):\n        if a[0] * a[1] * a[i] == min_product:\n            min_product_count += 1\n        elif a[0] * a[1] * a[i] < min_product:\n            min_product = a[0] * a[1] * a[i]\n            min_product_count = 1\n\n    if a[0] == a[1] == a[2]:\n        print(n * (n - 1) * (n - 2) // 6)\n    elif a[0] == a[1]:\n        print((n - 2) * (n - 3) // 2)\n    else:\n        print(min_product_count)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef min_cuts(n):\n    if n < 4:\n        return n\n    else:\n        return math.ceil(math.sqrt(n + 1))\n\nn = int(input())\nprint(min_cuts(n))"}
{"solution": "def maximize_balance(n):\n    n_str = str(n)\n    if n_str[0] == '-':\n        n_str = n_str[1:]\n        if len(n_str) > 1:\n            return -int(n_str[:-1]) if int(n_str[-1]) > int(n_str[-2]) else -int(n_str[:-2] + n_str[-1])\n        else:\n            return 0\n    else:\n        if len(n_str) > 1:\n            return int(n_str[:-1]) if int(n_str[-1]) < int(n_str[-2]) else int(n_str[:-2] + n_str[-1])\n        else:\n            return n\n\nn = int(input())\nprint(maximize_balance(n))"}
{"solution": "def spinner_direction(start, end, n):\n    positions = ['v', '<', '^', '>']\n    start_index = positions.index(start)\n    end_index = positions.index(end)\n    n = n % 4\n\n    if (end_index - start_index) % 4 == n:\n        return 'cw'\n    elif (start_index - end_index) % 4 == n:\n        return 'ccw'\n    else:\n        return 'undefined'\n\nstart, end = input().split()\nn = int(input())\nprint(spinner_direction(start, end, n))"}
{"solution": "def count_vertical_dominoes(n, s):\n    \"\"\"\n    Calculate the number of dominoes left standing vertically at the end of the process.\n\n    Args:\n    n (int): The number of dominoes in the line.\n    s (str): A character string representing the initial directions of the dominoes.\n\n    Returns:\n    int: The number of dominoes left standing vertically.\n    \"\"\"\n    count = 0\n    i = 0\n    while i < n:\n        if s[i] == '.':\n            j = i + 1\n            while j < n and s[j] == '.':\n                j += 1\n            if j == n:\n                count += n - i\n                break\n            else:\n                if (j - i) % 2 == 1:\n                    count += 1\n                i = j\n        else:\n            i += 1\n    return count\n\n\nn = int(input())\ns = input()\nprint(count_vertical_dominoes(n, s))"}
{"solution": "def restore_permutation(n, leaders):\n    permutation = [0] * n\n    for i in range(n):\n        permutation[i] = i + 1\n\n    for i in range(len(leaders) - 1):\n        leader_index = leaders[i] - 1\n        next_leader_index = leaders[i + 1] - 1\n        diff = (next_leader_index - leader_index) % n\n        if diff == 0:\n            diff = n\n        permutation[leader_index] = diff\n\n    if leaders[-1]!= leaders[0]:\n        permutation[leaders[-1] - 1] = n\n\n    for i in range(len(leaders) - 1):\n        leader_index = leaders[i] - 1\n        next_leader_index = leaders[i + 1] - 1\n        diff = (next_leader_index - leader_index) % n\n        if diff == 0:\n            diff = n\n        if permutation[leader_index]!= diff:\n            return [-1]\n\n    return permutation\n\n\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\nresult = restore_permutation(n, leaders)\nprint(*result)"}
{"solution": "def max_number(a, k):\n    a = list(str(a))\n    n = len(a)\n    max_a = a[:]\n    for i in range(n):\n        for j in range(i + 1, min(i + k + 1, n)):\n            if a[j] > a[i]:\n                a[i], a[j] = a[j], a[i]\n                k -= j - i\n                if a > max_a:\n                    max_a = a[:]\n                a[i], a[j] = a[j], a[i]\n                k += j - i\n    return ''.join(max_a)\n\na, k = input().split()\na, k = int(a), int(k)\nprint(max_number(a, k))"}
{"solution": "def is_arithmetic_progression(sequence):\n    \"\"\"Check if a sequence is an arithmetic progression.\"\"\"\n    diff = sequence[1] - sequence[0]\n    for i in range(2, len(sequence)):\n        if sequence[i] - sequence[i - 1]!= diff:\n            return False\n    return True\n\n\ndef is_geometric_progression(sequence):\n    \"\"\"Check if a sequence is a geometric progression.\"\"\"\n    ratio = sequence[1] / sequence[0]\n    for i in range(2, len(sequence)):\n        if sequence[i] / sequence[i - 1]!= ratio:\n            return False\n    return True\n\n\ndef next_arithmetic_progression(sequence):\n    \"\"\"Find the next element in an arithmetic progression.\"\"\"\n    diff = sequence[1] - sequence[0]\n    return sequence[-1] + diff\n\n\ndef next_geometric_progression(sequence):\n    \"\"\"Find the next element in a geometric progression.\"\"\"\n    ratio = sequence[1] / sequence[0]\n    return sequence[-1] * ratio\n\n\ndef main():\n    sequence = list(map(int, input().split()))\n    if is_arithmetic_progression(sequence):\n        next_element = next_arithmetic_progression(sequence)\n        if next_element == int(next_element):\n            print(int(next_element))\n        else:\n            print(42)\n    elif is_geometric_progression(sequence):\n        next_element = next_geometric_progression(sequence)\n        if next_element == int(next_element):\n            print(int(next_element))\n        else:\n            print(42)\n    else:\n        print(42)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_distance(n, colors):\n    # Find the first and last occurrence of each color\n    first_occurrence = {}\n    last_occurrence = {}\n    \n    for i in range(n):\n        color = colors[i]\n        if color not in first_occurrence:\n            first_occurrence[color] = i\n        last_occurrence[color] = i\n    \n    # Get the list of unique colors\n    unique_colors = list(first_occurrence.keys())\n    \n    # Calculate the maximum distance\n    max_dist = 0\n    \n    # Compare distances from the first house to the last house of a different color\n    for color in unique_colors:\n        if colors[0]!= color:\n            max_dist = max(max_dist, last_occurrence[color])\n        if colors[-1]!= color:\n            max_dist = max(max_dist, n - 1 - first_occurrence[color])\n    \n    # Check if the maximum distance can be obtained by walking from the first house of a color to the last house of the same color\n    for color in unique_colors:\n        max_dist = max(max_dist, last_occurrence[color] - first_occurrence[color])\n    \n    return max_dist\n\nn = int(input())\ncolors = list(map(int, input().split()))\nprint(max_distance(n, colors))"}
{"solution": "n, m, k = map(int, input().split())\n\nlane = (k - 1) // (2 * m) + 1\ndesk = ((k - 1) % (2 * m)) // 2 + 1\nside = 'L' if (k - 1) % 2 == 0 else 'R'\n\nprint(lane, desk, side)"}
{"solution": "def possible_final_colors(n, s):\n    color_counts = {'B': 0, 'G': 0, 'R': 0}\n    for color in s:\n        color_counts[color] += 1\n\n    possible_colors = set()\n    for color, count in color_counts.items():\n        if count % 2 == 1:\n            possible_colors.add(color)\n\n    if len(possible_colors) == 0:\n        possible_colors = set('BGR')\n    elif len(possible_colors) == 2:\n        for color in 'BGR':\n            if color not in possible_colors:\n                possible_colors.add(color)\n                break\n\n    return ''.join(sorted(possible_colors))\n\nn = int(input())\ns = input()\nprint(possible_final_colors(n, s))"}
