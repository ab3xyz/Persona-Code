{"solution": "import sys\n\ndef is_accordion(s):\n    if len(s) < 4:\n        return False\n    if s[0]!= '[' or s[-1]!= ']':\n        return False\n    if s[1]!= ':' or s[-2]!= ':':\n        return False\n    if s.count('|') > 1:\n        return False\n    return True\n\ndef remove_chars(s):\n    if not is_accordion(s):\n        return -1\n    i = 2\n    while i < len(s) - 2:\n        if s[i] == '|':\n            s = s[:i] + s[i+1:]\n        i += 1\n    return len(s)\n\ns = sys.stdin.readline().strip()\nprint(remove_chars(s))"}
{"solution": "import math\n\ndef get_max_sum_of_digits(x):\n    # Find the maximum sum of digits for the given integer x\n    max_sum = 0\n    for i in range(1, int(math.log10(x)) + 1):\n        # Iterate through the digits of x and find the maximum sum of digits\n        current_sum = 0\n        for j in range(i, x + 1):\n            current_sum += int(j % 10)\n            if current_sum > max_sum:\n                max_sum = current_sum\n    return max_sum\n\nx = int(input())\nprint(get_max_sum_of_digits(x))"}
{"solution": "def find_next_lucky_year(current_year):\n    lucky_years = [1, 5, 10, 100, 1000, 5000, 10000, 50000, 100000, 500000, 1000000]\n    for year in lucky_years:\n        if year > current_year:\n            return year - current_year\n    return 1000000 - current_year\n\ncurrent_year = int(input())\nprint(find_next_lucky_year(current_year))"}
{"solution": "import sys\n\nn, q = map(int, input().split())\npainters = []\nfor i in range(q):\n    l, r = map(int, input().split())\n    painters.append((l, r))\n\n# Sort painters by their left endpoint\npainters.sort(key=lambda x: x[0])\n\n# Initialize the number of painted sections to 0\npainted_sections = 0\n\n# Iterate through the painters and check if they overlap\nfor i in range(q - 2):\n    # Check if the current painter overlaps with the previous painter\n    if painters[i][1] >= painters[i + 1][0]:\n        # If they overlap, merge them into a single painter\n        painters[i] = (painters[i][0], max(painters[i][1], painters[i + 1][1]))\n        # Remove the second painter from the list\n        del painters[i + 1]\n        # Increment the number of painted sections\n        painted_sections += 1\n\n# Print the maximum number of painted sections\nprint(painted_sections)"}
{"solution": "import datetime\n\ndef get_lucky_time(hh, mm, x):\n    # Convert the input time to a datetime object\n    time = datetime.time(hh, mm)\n\n    # Calculate the time difference between the input time and the wake-up time\n    time_diff = datetime.timedelta(minutes=x)\n\n    # Subtract the time difference from the input time to get the wake-up time\n    wake_up_time = time - time_diff\n\n    # Check if the wake-up time contains the digit '7'\n    if str(wake_up_time).find('7')!= -1:\n        return 0\n\n    # Calculate the number of snooze intervals needed\n    num_snoozes = (wake_up_time.hour * 60 + wake_up_time.minute) // x\n\n    return num_snoozes\n\n# Test the function with some examples\nprint(get_lucky_time(11, 23, 3))  # Should print 2\nprint(get_lucky_time(01, 07, 5))  # Should print 0"}
{"solution": "n, pos, l, r = map(int, input().split())\n\n# Check if the segment [l, r] covers the entire range of tabs\nif l == 1 and r == n:\n    print(0)\n    exit()\n\n# Check if the left boundary (l) is greater than 1\nif l > 1:\n    # Move the cursor to the left boundary\n    pos = l\n    # Close the tabs to the left\n    for i in range(l, pos):\n        print(abs(pos - i) + 1)\n\n# Check if the right boundary (r) is less than n\nif r < n:\n    # Move the cursor to the right boundary\n    pos = r\n    # Close the tabs to the right\n    for i in range(pos, r):\n        print(abs(pos - i) + 1)\n\n# Print the total time required\nprint(sum(range(l, r + 1)))"}
{"solution": "import sys\n\ndef get_min_blows(n, x, d, h):\n    # Initialize variables\n    cur_x = x\n    min_blows = 0\n    while cur_x > 0:\n        # Deal the first blow\n        cur_x -= d\n        if cur_x <= 0:\n            break\n        # Grow new heads\n        cur_x += h\n        min_blows += 1\n    return min_blows\n\n# Read the number of queries\nt = int(input())\n\n# Loop through each query\nfor _ in range(t):\n    # Read the number of possible types of blows and the number of heads\n    n, x = map(int, input().split())\n    # Initialize the minimum number of blows to defeat Zmei Gorynich\n    min_blows = sys.maxsize\n    # Loop through each type of blow\n    for _ in range(n):\n        # Read the description of the blow\n        d, h = map(int, input().split())\n        # Calculate the minimum number of blows to defeat Zmei Gorynich for this type of blow\n        cur_min_blows = get_min_blows(n, x, d, h)\n        # Update the minimum number of blows if necessary\n        if cur_min_blows < min_blows:\n            min_blows = cur_min_blows\n    # Print the minimum number of blows\n    print(min_blows)"}
{"solution": "n, m = map(int, input().split())\n\n# Initialize the number of grains in the barn\ngrains = n\n\n# Initialize the number of sparrows that have eaten grain\nsparrows = 0\n\n# Initialize the number of days\ndays = 0\n\n# Loop until the barn is empty\nwhile grains > 0:\n    # Bring m grains to the barn\n    grains += m\n\n    # If the barn becomes full, remove one grain\n    if grains > n:\n        grains -= 1\n\n    # Increment the number of sparrows that have eaten grain\n    sparrows += 1\n\n    # Increment the number of days\n    days += 1\n\n    # If the barn is empty, break the loop\n    if grains == 0:\n        break\n\n# Print the number of the day when the barn becomes empty\nprint(days)"}
{"solution": "def min_draws_to_win(tiles):\n    # Parse the input tiles\n    tile1, tile2, tile3 = tiles.split()\n    \n    # Extract numbers and suits\n    num1, suit1 = int(tile1[0]), tile1[1]\n    num2, suit2 = int(tile2[0]), tile2[1]\n    num3, suit3 = int(tile3[0]), tile3[1]\n    \n    # Check for koutsu (triplet)\n    if tile1 == tile2 == tile3:\n        return 0\n    \n    # Check for shuntsu (sequence)\n    def is_shuntsu(n1, n2, n3):\n        return sorted([n1, n2, n3]) in [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9]]\n    \n    if suit1 == suit2 == suit3 and is_shuntsu(num1, num2, num3):\n        return 0\n    \n    # Check for possible koutsu with one more draw\n    if tile1 == tile2 or tile1 == tile3 or tile2 == tile3:\n        return 1\n    \n    # Check for possible shuntsu with one more draw\n    def needs_one_for_shuntsu(n1, n2):\n        return abs(n1 - n2) == 1 or abs(n1 - n2) == 2\n    \n    if suit1 == suit2 and needs_one_for_shuntsu(num1, num2):\n        return 1\n    if suit1 == suit3 and needs_one_for_shuntsu(num1, num3):\n        return 1\n    if suit2 == suit3 and needs_one_for_shuntsu(num2, num3):\n        return 1\n    \n    # If no koutsu or shuntsu can be formed with one more draw, return 2\n    return 2"}
{"solution": "import sys\n\ndef find_sofa(n, m, d, x, y, cnt_l, cnt_r, cnt_t, cnt_b):\n    # Initialize a matrix to store the sofas\n    sofas = [[0] * m for _ in range(n)]\n\n    # Populate the matrix with the sofas\n    for i in range(d):\n        sofas[x[i] - 1][y[i] - 1] = i + 1\n\n    # Find the sofa that matches the conditions\n    for i in range(d):\n        if sofas[x[i] - 1][y[i] - 1] == i + 1:\n            if cnt_l[i] == 0 and cnt_r[i] == 0 and cnt_t[i] == 0 and cnt_b[i] == 0:\n                return i + 1\n\n    # If no sofa matches the conditions, return -1\n    return -1\n\nif __name__ == \"__main__\":\n    n, m, d = map(int, input().split())\n    x = [int(x) for x in input().split()]\n    y = [int(y) for y in input().split()]\n    cnt_l = [int(cnt_l) for cnt_l in input().split()]\n    cnt_r = [int(cnt_r) for cnt_r in input().split()]\n    cnt_t = [int(cnt_t) for cnt_t in input().split()]\n    cnt_b = [int(cnt_b) for cnt_b in input().split()]\n    print(find_sofa(n, m, d, x, y, cnt_l, cnt_r, cnt_t, cnt_b))"}
{"solution": "def mars_days_off(n):\n    full_weeks = n // 7\n    remaining_days = n % 7\n    \n    min_days_off = full_weeks * 2\n    max_days_off = full_weeks * 2 + min(remaining_days, 2)\n    \n    return min_days_off, max_days_off\n\nn = int(input())\nmin_days_off, max_days_off = mars_days_off(n)\nprint(min_days_off, max_days_off)"}
{"solution": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nlong long int getMaxChocolates(long long int n, long long int a, long long int b, long long int p, long long int q) {\n    long long int redTiles = 0, blueTiles = 0, bothTiles = 0;\n    for (long long int i = 1; i <= n; i++) {\n        if (i % a == 0 && i % b == 0) {\n            bothTiles++;\n        } else if (i % a == 0) {\n            redTiles++;\n        } else if (i % b == 0) {\n            blueTiles++;\n        }\n    }\n    long long int totalChocolates = redTiles * p + blueTiles * q + bothTiles * (p + q);\n    return totalChocolates;\n}\n\nint main() {\n    long long int n, a, b, p, q;\n    cin >> n >> a >> b >> p >> q;\n    cout << getMaxChocolates(n, a, b, p, q) << endl;\n    return 0;\n}"}
{"solution": "  import sys\n\nn = int(input())\ntrophies = input()\n\n# Initialize the maximum length of the longest subsegment of golden trophies to 0\nmax_length = 0\n\n# Iterate through the trophies and check if the current trophy is golden\nfor i in range(n):\n    if trophies[i] == 'G':\n        # If the current trophy is golden, check if the length of the longest subsegment of golden trophies is greater than the current maximum length\n        if i - max_length > 0:\n            # If the length of the longest subsegment of golden trophies is greater than the current maximum length, update the maximum length\n            max_length = i\n\n# Print the maximum possible length of the longest subsegment of golden trophies\nprint(max_length)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\nmain_courses = set(map(int, input().split()))\n\ncourses = []\nfor i in range(n):\n    t, *deps = map(int, input().split())\n    courses.append((t, deps))\n\n# Sort courses by number of dependencies\ncourses.sort(key=lambda x: x[0])\n\n# Initialize a set to keep track of passed courses\npassed_courses = set()\n\n# Initialize a list to keep track of the optimal order of courses\noptimal_order = []\n\n# Iterate through the courses and add them to the optimal order if they are not dependent on any passed courses\nfor course in courses:\n    if not passed_courses.intersection(course[1]):\n        optimal_order.append(course[0])\n        passed_courses.add(course[0])\n\n# If the number of passed courses is less than the number of main courses, there is no solution\nif len(passed_courses) < k:\n    print(-1)\n    sys.exit()\n\n# Print the minimum number of courses and the optimal order of courses\nprint(len(passed_courses))\nprint(*optimal_order)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Check if the first k elements of p are pairwise distinct\nif len(set(p[:k]))!= k:\n    print(-1)\n    sys.exit()\n\n# Initialize the stack and the remaining elements of the permutation\nstack = []\nremaining = [i for i in range(1, n + 1) if i not in p[:k]]\n\n# Perform the operations until the stack is empty\nwhile stack:\n    # Take the top element from the stack and append it to the end of the permutation\n    top = stack.pop()\n    p.append(top)\n    # Remove the top element from the stack and add it to the remaining elements of the permutation\n    remaining.append(top)\n    # If the remaining elements of the permutation are sorted in non-descending order, break the loop\n    if remaining == sorted(remaining):\n        break\n\n# Print the lexicographically maximal permutation\nprint(p)"}
{"solution": "def does_b_appear_in_sequence(a, b, c):\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n# Example usage:\na, b, c = map(int, input().split())\nprint(does_b_appear_in_sequence(a, b, c))"}
{"solution": "def can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    total_opening_brackets = 2 * cnt_1 + cnt_2\n    total_closing_brackets = 2 * cnt_4 + cnt_2\n    if total_opening_brackets == total_closing_brackets:\n        return 1\n    else:\n        return 0"}
{"solution": "import sys\n\nn, k, t = map(int, sys.stdin.readline().split())\n\n# Initialize the number of standing spectators to 0\nstanding_spectators = 0\n\n# Iterate through the time steps\nfor i in range(t):\n    # If the current time step is a multiple of k, increase the number of standing spectators\n    if i % k == 0:\n        standing_spectators += 1\n\n# Print the number of standing spectators at time t\nprint(standing_spectators)"}
{"solution": "def lexicographically_minimal_string(s):\n    t = []\n    u = []\n    min_char = min(s)\n    s = list(s)\n    \n    while s or t:\n        if t and (not s or t[-1] <= min_char):\n            u.append(t.pop())\n        else:\n            char = s.pop(0)\n            t.append(char)\n            if s:\n                min_char = min(s)\n    \n    return ''.join(u)\n\n# Example usage:\ns = input().strip()\nprint(lexicographically_minimal_string(s))"}
{"solution": "import sys\n\ndef is_correct_sequence(stats):\n    # Check if the number of plays and clears are consistent\n    for i in range(len(stats) - 1):\n        if stats[i][0]!= stats[i + 1][0] and stats[i][1]!= stats[i + 1][1]:\n            return False\n    return True\n\ndef main():\n    num_test_cases = int(input())\n    for _ in range(num_test_cases):\n        num_moments = int(input())\n        stats = []\n        for _ in range(num_moments):\n            stats.append(list(map(int, input().split())))\n        if is_correct_sequence(stats):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import re\n\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef get_next_palindrome(time):\n    h, m = map(int, time.split(':'))\n    for i in range(m, 60):\n        if is_palindrome(str(i)):\n            return f'{h:02d}:{i:02d}'\n    for i in range(h+1, 24):\n        if is_palindrome(str(i)):\n            return f'{i:02d}:00'\n    return '00:00'\n\ndef get_minutes_to_sleep(time):\n    next_palindrome = get_next_palindrome(time)\n    h, m = map(int, time.split(':'))\n    next_h, next_m = map(int, next_palindrome.split(':'))\n    return (next_h - h) * 60 + (next_m - m)\n\ntime = input()\nprint(get_minutes_to_sleep(time))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Find the minimum and maximum elements\nmin_idx = a.index(min(a))\nmax_idx = a.index(max(a))\n\n# Find the optimal swap\nswap_idx = min_idx\nfor i in range(n):\n    if a[i] > a[swap_idx]:\n        swap_idx = i\n\n# Perform the swap\na[min_idx], a[swap_idx] = a[swap_idx], a[min_idx]\n\n# Calculate the distance\ndistance = abs(min_idx - max_idx)\n\nprint(distance)"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    mid = n // 2\n    if n % 2 == 0:\n        first_half = s[:mid]\n        second_half = s[mid:]\n    else:\n        first_half = s[:mid]\n        second_half = s[mid+1:]\n    \n    if first_half == second_half[::-1]:\n        return \"TAK\"\n    else:\n        return \"NIE\"\n\n# Example usage:\ns = input().strip()\nprint(is_s_palindrome(s))"}
{"solution": "import sys\n\na, b = map(int, sys.stdin.readline().split())\n\n# Convert a to a list of digits\na_digits = [int(digit) for digit in str(a)]\n\n# Sort the digits in descending order\na_digits.sort(reverse=True)\n\n# Create a new list to store the permutations\npermutations = []\n\n# Iterate through the digits of a and create permutations\nfor i in range(len(a_digits)):\n    permutation = a_digits[:i] + a_digits[i+1:]\n    permutations.append(permutation)\n\n# Sort the permutations in descending order\npermutations.sort(reverse=True)\n\n# Find the first permutation that is not greater than b\nfor permutation in permutations:\n    if permutation <= b:\n        print(permutation)\n        break\nelse:\n    print(-1)"}
{"solution": "def check_win(matrix):\n    # Check if there is a horizontal line of length 5 or more\n    for i in range(10):\n        for j in range(10):\n            if matrix[i][j] == 'X' and matrix[i][j+1] == 'X' and matrix[i][j+2] == 'X' and matrix[i][j+3] == 'X' and matrix[i][j+4] == 'X':\n                return 'YES'\n    \n    # Check if there is a vertical line of length 5 or more\n    for i in range(10):\n        for j in range(10):\n            if matrix[i][j] == 'X' and matrix[i+1][j] == 'X' and matrix[i+2][j] == 'X' and matrix[i+3][j] == 'X' and matrix[i+4][j] == 'X':\n                return 'YES'\n    \n    # Check if there is a diagonal line of length 5 or more\n    for i in range(10):\n        for j in range(10):\n            if matrix[i][j] == 'X' and matrix[i+1][j+1] == 'X' and matrix[i+2][j+2] == 'X' and matrix[i+3][j+3] == 'X' and matrix[i+4][j+4] == 'X':\n                return 'YES'\n    \n    # Check if there is a diagonal line of length 5 or more\n    for i in range(10):\n        for j in range(10):\n            if matrix[i][j] == 'X' and matrix[i+1][j-1] == 'X' and matrix[i+2][j-2] == 'X' and matrix[i+3][j-3] == 'X' and matrix[i+4][j-4] == 'X':\n                return 'YES'\n    \n    return 'NO'"}
{"solution": "def solve(n, k):\n    # Initialize the matrix with zeroes\n    matrix = [[0] * n for _ in range(n)]\n\n    # Place the k ones in the matrix symmetrically and lexicographically maximally\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            elif i + j == n - 1:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n\n    # Check if the resulting matrix is symmetrical with respect to the main diagonal\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j]!= matrix[j][i]:\n                return -1\n\n    # Check if the resulting matrix is lexicographically maximal\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] > matrix[j][i]:\n                return -1\n\n    return matrix"}
{"solution": "import math\n\ndef get_max_expression(x, y, z):\n    expressions = [\n        x**y**z,\n        x**z**y,\n        (x**y)**z,\n        (x**z)**y,\n        y**x**z,\n        y**z**x,\n        (y**x)**z,\n        (y**z)**x,\n        z**x**y,\n        z**y**x,\n        (z**x)**y,\n        (z**y)**x\n    ]\n    return max(expressions)\n\ndef get_expression_string(expression):\n    if expression == x**y**z:\n        return \"x^y^z\"\n    elif expression == x**z**y:\n        return \"x^z^y\"\n    elif expression == (x**y)**z:\n        return \"(x^y)^z\"\n    elif expression == (x**z)**y:\n        return \"(x^z)^y\"\n    elif expression == y**x**z:\n        return \"y^x^z\"\n    elif expression == y**z**x:\n        return \"y^z^x\"\n    elif expression == (y**x)**z:\n        return \"(y^x)^z\"\n    elif expression == (y**z)**x:\n        return \"(y^z)^x\"\n    elif expression == z**x**y:\n        return \"z^x^y\"\n    elif expression == z**y**x:\n        return \"z^y^x\"\n    elif expression == (z**x)**y:\n        return \"(z^x)^y\"\n    elif expression == (z**y)**x:\n        return \"(z^y)^x\"\n\nx, y, z = map(float, input().split())\nexpression = get_max_expression(x, y, z)\nexpression_string = get_expression_string(expression)\nprint(expression_string)"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize variables\noperations = 0\ncopy_count = 0\n\n# Iterate through the string\nfor i in range(n):\n    # If the current character is the same as the previous character, increment the copy count\n    if i > 0 and s[i] == s[i-1]:\n        copy_count += 1\n    # Otherwise, increment the operation count\n    else:\n        operations += 1\n\n# If the copy count is greater than 0, add the copy operation to the total operations\nif copy_count > 0:\n    operations += 1\n\nprint(operations)"}
{"solution": "import sys\n\nn = int(input())\nfiles = []\n\nfor i in range(n):\n    name, type = input().split()\n    files.append((name, int(type)))\n\n# Sort the files by type\nfiles.sort(key=lambda x: x[1])\n\n# Initialize the output variables\noutput = []\ne = 0\n\n# Iterate through the files and rename them\nfor i, (name, type) in enumerate(files):\n    if type == 1:\n        e += 1\n        output.append(f\"move {name} {e}\")\n    else:\n        output.append(f\"move {name} {e + 1}\")\n\nprint(len(output))\nprint(\"\\n\".join(output))"}
{"solution": "def get_min_replacements(ticket):\n    # Initialize variables\n    first_sum = 0\n    last_sum = 0\n    replacements = 0\n\n    # Calculate the sum of the first three digits\n    for i in range(3):\n        first_sum += int(ticket[i])\n\n    # Calculate the sum of the last three digits\n    for i in range(3, 6):\n        last_sum += int(ticket[i])\n\n    # Check if the sums are equal\n    if first_sum == last_sum:\n        return 0\n\n    # If the sums are not equal, calculate the minimum number of replacements needed\n    for i in range(6):\n        if ticket[i] == '0':\n            replacements += 1\n        elif ticket[i]!= '0' and first_sum > last_sum:\n            replacements += 1\n            first_sum -= int(ticket[i])\n            last_sum += int(ticket[i])\n        elif ticket[i]!= '0' and first_sum < last_sum:\n            replacements += 1\n            first_sum += int(ticket[i])\n            last_sum -= int(ticket[i])\n\n    return replacements"}
{"solution": "def minimum_traps(m, x):\n    return m - 1"}
{"solution": "  import math\n\ndef birthday_paradox(n, k):\n    # Calculate the probability of at least two people having the same birthday\n    probability = 1 - math.factorial(2**n) / (math.factorial(2**n - k) * math.factorial(k))\n\n    # Calculate the values of A and B\n    A = int(probability * (10**6 + 3))\n    B = int(10**6 + 3)\n\n    # Return the values of A and B\n    return A, B\n\n# Test the function with the given input\nn = 3\nk = 2\nprint(birthday_paradox(n, k))\n# Output: (1, 8)\n\nn = 1\nk = 3\nprint(birthday_paradox(n, k))\n# Output: (1, 1)\n\nn = 4\nk = 3\nprint(birthday_paradox(n, k))\n# Output: (23, 128)"}
{"solution": "n = int(input())\n\n# Initialize the position of Limak as the North Pole\nposition = \"North\"\n\n# Iterate through the n parts of the journey\nfor i in range(n):\n    # Get the length and direction of the i-th part of the journey\n    t, dir = map(int, input().split())\n    \n    # Check if Limak is on the North or South Pole\n    if position == \"North\":\n        # Limak is on the North Pole, so he can only move South\n        if dir == \"South\":\n            # Update the position and move the required distance\n            position = \"South\"\n            t -= 20000\n        else:\n            # Limak cannot move North from the North Pole\n            print(\"NO\")\n            break\n    elif position == \"South\":\n        # Limak is on the South Pole, so he can only move North\n        if dir == \"North\":\n            # Update the position and move the required distance\n            position = \"North\"\n            t -= 20000\n        else:\n            # Limak cannot move South from the South Pole\n            print(\"NO\")\n            break\n    \n    # Check if the journey ends on the North Pole\n    if position == \"North\" and t == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "import sys\n\ndef solve(a1, b1, a2, b2, L, R):\n    # Find the common elements in the two progressions\n    common_elements = set(range(L, R+1)).intersection(set(a1*k + b1 for k in range(L, R+1)))\n    common_elements = set(common_elements).intersection(set(a2*l + b2 for l in range(L, R+1)))\n\n    # Return the number of common elements\n    return len(common_elements)\n\nif __name__ == \"__main__\":\n    a1, b1, a2, b2, L, R = map(int, sys.stdin.readline().split())\n    print(solve(a1, b1, a2, b2, L, R))"}
{"solution": "n, a, b = map(int, input().split())\n\n# Initialize the number of pieces on each plate to 0\nplates = [0] * n\n\n# Initialize the number of pieces of each cake to 0\ncake1 = 0\ncake2 = 0\n\n# Loop through each plate\nfor i in range(n):\n    # If the current plate is not full, add a piece of cake to it\n    if plates[i] < a:\n        plates[i] += 1\n        cake1 += 1\n    # If the current plate is full, add a piece of cake to the next plate\n    else:\n        plates[i+1] += 1\n        cake2 += 1\n\n# Print the maximum number of pieces on each plate\nprint(max(plates))"}
{"solution": "n, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\n# Check if the field is rectangular\nif len(set(map(len, field)))!= 1:\n    print(\"NO\")\n    exit()\n\n# Check if the field has three colors\nif len(set(field[0]))!= 3:\n    print(\"NO\")\n    exit()\n\n# Check if the stripes are equal in width and height\nif not all(len(row) == len(field[0]) for row in field):\n    print(\"NO\")\n    exit()\n\n# Check if each color is used exactly once\nif not all(len(row) == len(set(row)) for row in field):\n    print(\"NO\")\n    exit()\n\n# Check if the stripes are parralel to each other and to the sides of the flag\nif not all(row[0] == row[-1] for row in field):\n    print(\"NO\")\n    exit()\n\nprint(\"YES\")"}
{"solution": "import math\n\ndef spiral_moves(n):\n    # Calculate the number of moves in each direction\n    num_moves_right = int(math.ceil(n / 2))\n    num_moves_left = int(math.floor(n / 2))\n    num_moves_up = int(math.ceil((n - num_moves_right) / 2))\n    num_moves_down = int(math.floor((n - num_moves_right) / 2))\n\n    # Calculate the current position\n    x = num_moves_right - num_moves_left\n    y = num_moves_up - num_moves_down\n\n    return x, y\n\nn = int(input())\nx, y = spiral_moves(n)\nprint(x, y)"}
{"solution": "import math\n\ndef can_break_shield(a, b, c):\n    # Calculate the greatest common divisor of a and b\n    gcd_ab = math.gcd(a, b)\n    \n    # Check if c is divisible by the gcd of a and b\n    if c % gcd_ab == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input values\na, b, c = map(int, input().split())\n\n# Output the result\nprint(can_break_shield(a, b, c))"}
{"solution": "def can_tracks_coincide(n, L, kefa_barriers, sasha_barriers):\n    # Calculate distances between consecutive barriers for Kefa\n    kefa_distances = [(kefa_barriers[(i + 1) % n] - kefa_barriers[i]) % L for i in range(n)]\n    # Calculate distances between consecutive barriers for Sasha\n    sasha_distances = [(sasha_barriers[(i + 1) % n] - sasha_barriers[i]) % L for i in range(n)]\n    \n    # Double the kefa_distances to handle circular rotation\n    doubled_kefa_distances = kefa_distances + kefa_distances\n    \n    # Check if sasha_distances is a sublist of doubled_kefa_distances\n    for i in range(n):\n        if doubled_kefa_distances[i:i + n] == sasha_distances:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_barriers, sasha_barriers))"}
{"solution": "import re\n\ndef longest_non_palindromic_substring(s):\n    # find all substrings that are not palindromes\n    substrings = re.findall(r\"(.+?)(?<!^)(?!$)\", s)\n\n    # find the longest substring that is not a palindrome\n    longest_substring = \"\"\n    for substring in substrings:\n        if not is_palindrome(substring):\n            if len(substring) > len(longest_substring):\n                longest_substring = substring\n\n    return len(longest_substring)\n\ndef is_palindrome(s):\n    # check if a string is a palindrome\n    return s == s[::-1]\n\ns = input()\nprint(longest_non_palindromic_substring(s))"}
{"solution": "n = int(input())\na = [int(input()) for _ in range(n)]\nb = [int(input()) for _ in range(n)]\n\nif any(a[i]!= b[i] for i in range(n)):\n    print(\"rated\")\nelif all(a[i] == b[i] for i in range(n)):\n    print(\"unrated\")\nelse:\n    print(\"maybe\")"}
{"solution": "def find_nearest_zero(arr):\n    n = len(arr)\n    d = [0] * n\n    for i in range(n):\n        if arr[i] == 0:\n            d[i] = 0\n        else:\n            for j in range(i+1, n):\n                if arr[j] == 0:\n                    d[i] = j - i\n                    break\n    return d\n\narr = [2, 1, 0, 3, 0, 0, 3, 2, 4]\nprint(find_nearest_zero(arr))"}
{"solution": "def count_distinct_cyclical_strings(n, s):\n    from itertools import product\n    \n    def is_substring_in_cyclical_shifts(t, s):\n        t_extended = t + t\n        return any(s in t_extended[i:i+len(t)] for i in range(len(t)))\n    \n    distinct_cyclical_strings = set()\n    \n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if is_substring_in_cyclical_shifts(t, s):\n            distinct_cyclical_strings.add(t)\n    \n    return len(distinct_cyclical_strings)\n\n# Example usage\nn = int(input())\ns = input().strip()\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import sys\n\nn = int(input())\nvectors = []\n\nfor i in range(n):\n    x, y = map(int, input().split())\n    vectors.append((x, y))\n\n# Calculate the angle between each pair of vectors\nangles = []\nfor i in range(n):\n    for j in range(i+1, n):\n        angle = calculate_angle(vectors[i], vectors[j])\n        angles.append((i, j, angle))\n\n# Find the pair with the minimal non-oriented angle\nmin_angle = float('inf')\nmin_pair = None\nfor pair in angles:\n    if pair[2] < min_angle:\n        min_angle = pair[2]\n        min_pair = pair\n\n# Print the indices of the vectors with the minimal non-oriented angle\nprint(min_pair[0], min_pair[1])\n\ndef calculate_angle(v1, v2):\n    # Calculate the dot product of the two vectors\n    dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n\n    # Calculate the magnitude of the two vectors\n    mag1 = (v1[0] ** 2 + v1[1] ** 2) ** 0.5\n    mag2 = (v2[0] ** 2 + v2[1] ** 2) ** 0.5\n\n    # Calculate the cosine of the angle between the two vectors\n    cos_angle = dot_product / (mag1 * mag2)\n\n    # Calculate the angle between the two vectors\n    angle = math.acos(cos_angle)\n\n    return angle"}
{"solution": "def minimal_time(d, k, a, b, t):\n    if d <= k:\n        return d * a\n    \n    # Full segments\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Time for full segments\n    time_for_full_segments = full_segments * k * a + (full_segments - 1) * t\n    \n    # Time for remaining distance\n    if remaining_distance == 0:\n        return time_for_full_segments\n    else:\n        # Option 1: Drive the remaining distance\n        time_drive_remaining = remaining_distance * a + t\n        # Option 2: Walk the remaining distance\n        time_walk_remaining = remaining_distance * b\n        \n        return time_for_full_segments + min(time_drive_remaining, time_walk_remaining)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\n# Initialize the sequence with the first element\nsequence = [1]\n\n# Loop through the remaining elements\nfor i in range(1, k):\n    # Find the next element in the sequence\n    next_element = find_next_element(sequence, n)\n    \n    # If the next element is not found, return -1\n    if next_element == -1:\n        print(-1)\n        break\n    \n    # Add the next element to the sequence\n    sequence.append(next_element)\n\n# Print the sequence\nprint(\" \".join(map(str, sequence)))\n\ndef find_next_element(sequence, n):\n    # Find the greatest common divisor of the sequence\n    gcd = find_gcd(sequence)\n    \n    # Find the next element in the sequence\n    next_element = find_next_element_helper(sequence, n, gcd)\n    \n    return next_element\n\ndef find_gcd(sequence):\n    # Initialize the greatest common divisor to 1\n    gcd = 1\n    \n    # Loop through the elements of the sequence\n    for element in sequence:\n        # Find the greatest common divisor of the element and the current gcd\n        gcd = find_gcd_helper(element, gcd)\n    \n    return gcd\n\ndef find_gcd_helper(element, gcd):\n    # Find the greatest common divisor of the element and the current gcd\n    gcd = gcd if element % gcd == 0 else find_gcd_helper(element, gcd + 1)\n    \n    return gcd\n\ndef find_next_element_helper(sequence, n, gcd):\n    # Initialize the next element to 1\n    next_element = 1\n    \n    # Loop through the elements of the sequence\n    for element in sequence:\n        # Find the next element in the sequence\n        next_element = find_next_element_helper_helper(element, next_element, n, gcd)\n    \n    return next_element\n\ndef find_next_element_helper_helper(element, next_element, n, gcd):\n    # Find the next element in the sequence\n    next_element = next_element if element % next_element == 0 else find_next_element_helper_helper(element, next_element + 1, n, gcd)\n    \n    return next_element"}
{"solution": "import sys\n\nn, m = map(int, input().split())\n\ncount = 0\nfor x in range(1, n+1):\n    for y in range(1, m+1):\n        if (x + y) % 5 == 0:\n            count += 1\n\nprint(count)"}
{"solution": "import sys\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize the maximum beauty of the array to 0\nmax_beauty = 0\n\n# Iterate over all possible subarrays\nfor i in range(n):\n    for j in range(i, n):\n        # Calculate the sum of the subarray\n        subarray_sum = sum(a[i:j+1])\n        # Multiply the subarray by x\n        subarray_sum *= x\n        # Calculate the beauty of the subarray\n        subarray_beauty = max(subarray_sum, 0)\n        # Update the maximum beauty of the array\n        max_beauty = max(max_beauty, subarray_beauty)\n\n# Print the maximum beauty of the array\nprint(max_beauty)"}
{"solution": "def find_kth_largest(n, m, k):\n    # Initialize the low and high variables\n    low, high = 1, n * m\n\n    # Perform binary search to find the k-th largest number\n    while low < high:\n        # Calculate the midpoint\n        mid = (low + high) // 2\n\n        # Count the number of elements less than or equal to mid\n        count = count_less_equal(mid, n, m)\n\n        # If the count is less than k, adjust the low variable\n        if count < k:\n            low = mid + 1\n        # Otherwise, adjust the high variable\n        else:\n            high = mid\n\n    # Return the low variable, which is the k-th largest number\n    return low\n\n# Count the number of elements less than or equal to x in the n \u00d7 m multiplication table\ndef count_less_equal(x, n, m):\n    count = 0\n    for i in range(1, n + 1):\n        count += min(m, x // i)\n    return count\n\n# Example usage\nn, m, k = map(int, input().split())\nprint(find_kth_largest(n, m, k))"}
{"solution": "import sys\n\nk = int(sys.stdin.readline())\n\n# Initialize the sequence with the first 10 numbers\nsequence = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# Calculate the next 10 numbers in the sequence\nfor i in range(10):\n    sequence.append(sequence[i] + sequence[i+1])\n\n# Print the k-th digit of the sequence\nprint(sequence[k-1])"}
{"solution": "import sys\n\nn, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculate the maximum number of bourles that can be held after the evening\nmax_bourles = 0\nfor i in range(n):\n    for j in range(m):\n        if s[i] <= b[j]:\n            max_bourles = max(max_bourles, r + s[i] * (j + 1) - b[j] * (n - i))\n\nprint(max_bourles)"}
{"solution": "def find_original_message(t):\n    n = len(t)\n    \n    # \u041f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u0432\u0441\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0434\u043b\u0438\u043d\u044b \u043d\u0430\u043b\u043e\u0436\u0435\u043d\u0438\u044f\n    for overlap in range(1, n // 2 + 1):\n        # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0441\u043e\u0432\u043f\u0430\u0434\u0430\u044e\u0442 \u043b\u0438 \u043d\u0430\u0447\u0430\u043b\u043e \u0441\u0442\u0440\u043e\u043a\u0438 t \u0434\u043b\u0438\u043d\u043e\u0439 overlap \u0438 \u043a\u043e\u043d\u0435\u0446 \u0441\u0442\u0440\u043e\u043a\u0438 t \u0434\u043b\u0438\u043d\u043e\u0439 overlap\n        if t[:overlap] == t[-overlap:]:\n            s = t[:-overlap]\n            if s + t[-overlap:] == t:\n                return \"YES\", s\n    \n    return \"NO\", None\n\n# \u0427\u0442\u0435\u043d\u0438\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\nt = input().strip()\n\n# \u041f\u043e\u0438\u0441\u043a \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0433\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f s\nresult, s = find_original_message(t)\n\n# \u0412\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\nprint(result)\nif result == \"YES\":\n    print(s)"}
{"solution": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int teams = 1;\n    int games = 0;\n\n    while (games < n) {\n        if (teams % 2 == 0) {\n            games += teams / 2;\n        } else {\n            games += (teams - 1) / 2;\n        }\n        teams++;\n    }\n\n    if (games == n) {\n        cout << teams << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n    return 0;\n}"}
{"solution": "import sys\n\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\n# Initialize the maximum beauty as 0\nmax_beauty = 0\n\n# Iterate through each permutation of the string\nfor perm in permutations(s):\n    # Check if the permutation is antipalindromic\n    if is_antipalindromic(perm):\n        # Calculate the beauty of the permutation\n        beauty = sum(b[i] for i in range(n) if perm[i] == s[i])\n        # Update the maximum beauty if necessary\n        if beauty > max_beauty:\n            max_beauty = beauty\n\n# Print the maximum beauty\nprint(max_beauty)\n\n# Function to check if a string is antipalindromic\ndef is_antipalindromic(s):\n    # Check if the length of the string is even\n    if len(s) % 2 == 0:\n        # Iterate through each character in the string\n        for i in range(len(s)):\n            # Check if the character at position i is not equal to the character at position len(s) - i\n            if s[i]!= s[len(s) - i]:\n                # If the characters are not equal, return False\n                return False\n        # If all characters are equal, return True\n        return True\n    # If the length of the string is odd, return False\n    return False"}
{"solution": "import sys\n\ndef can_weight(weights, item_mass):\n    # Initialize a dictionary to store the weights and their counts\n    weight_counts = {}\n    for weight in weights:\n        if weight not in weight_counts:\n            weight_counts[weight] = 1\n        else:\n            weight_counts[weight] += 1\n\n    # Initialize a set to store the weights that have been used\n    used_weights = set()\n\n    # Iterate through the weights and their counts\n    for weight, count in weight_counts.items():\n        # If the weight has not been used and the item mass is divisible by the weight,\n        # add the weight to the used weights set and subtract the weight from the item mass\n        if weight not in used_weights and item_mass % weight == 0:\n            used_weights.add(weight)\n            item_mass -= weight\n\n    # If all the weights have been used and the item mass is 0, return True\n    if len(used_weights) == len(weights) and item_mass == 0:\n        return True\n    else:\n        return False\n\nif __name__ == \"__main__\":\n    weights = [int(x) for x in input().split()]\n    item_mass = int(input())\n    print(can_weight(weights, item_mass))"}
{"solution": "  import sys\n\nn, k = map(int, input().split())\n\ndef find_sequence(n, k):\n    # Initialize the sequence with the largest possible value\n    sequence = [10**18] * k\n    \n    # Start from the largest power of 2 that is less than or equal to n\n    power = 2**(k-1)\n    \n    # Iterate through the powers of 2 in descending order\n    for i in range(k-2, -1, -1):\n        # If the current power of 2 is less than or equal to n, add it to the sequence\n        if power <= n:\n            sequence[i] = power\n            n -= power\n        \n        # Update the power of 2 for the next iteration\n        power //= 2\n    \n    # If there is still some value left, it cannot be represented as a sum of powers of 2\n    if n > 0:\n        return None\n    \n    # Return the sequence\n    return sequence\n\nsequence = find_sequence(n, k)\n\n# If there is no sequence that satisfies the conditions, print \"No\"\nif sequence is None:\n    print(\"No\")\n# Otherwise, print \"Yes\" and the sequence\nelse:\n    print(\"Yes\")\n    print(*sequence)"}
{"solution": "import sys\n\nn, t = map(int, input().split())\n\n# Initialize the pyramid with n levels and the top level consisting of 1 glass\npyramid = [[1]]\n\n# Initialize the number of completely full glasses\ncompletely_full_glasses = 0\n\n# Iterate over the number of seconds\nfor i in range(t):\n    # Iterate over the levels of the pyramid\n    for level in range(n):\n        # Iterate over the glasses on the current level\n        for glass in range(len(pyramid[level])):\n            # Check if the glass is full\n            if pyramid[level][glass] == 1:\n                # Increment the number of completely full glasses\n                completely_full_glasses += 1\n            # Check if the glass is overflowing\n            elif pyramid[level][glass] > 1:\n                # Distribute the overflowed champagne equally among the two glasses underneath\n                pyramid[level - 1][glass] += pyramid[level][glass] // 2\n                pyramid[level - 1][glass + 1] += pyramid[level][glass] // 2\n                # Set the current glass to empty\n                pyramid[level][glass] = 0\n\n# Print the number of completely full glasses\nprint(completely_full_glasses)"}
{"solution": "n = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\n\nif n == 1:\n    return -1\nelif n == 2:\n    x1, y1 = vertices[0]\n    x2, y2 = vertices[1]\n    if x1!= x2 and y1!= y2:\n        return abs(x1 - x2) * abs(y1 - y2)\n    else:\n        return -1\nelif n == 3:\n    x_coords = set()\n    y_coords = set()\n    for x, y in vertices:\n        x_coords.add(x)\n        y_coords.add(y)\n    if len(x_coords) == 2 and len(y_coords) == 2:\n        x1, x2 = x_coords\n        y1, y2 = y_coords\n        return abs(x1 - x2) * abs(y1 - y2)\n    else:\n        return -1\nelif n == 4:\n    x_coords = set()\n    y_coords = set()\n    for x, y in vertices:\n        x_coords.add(x)\n        y_coords.add(y)\n    if len(x_coords) == 2 and len(y_coords) == 2:\n        x1, x2 = x_coords\n        y1, y2 = y_coords\n        return abs(x1 - x2) * abs(y1 - y2)\n    else:\n        return -1"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\n\n# Calculate the total length of all sides of the frames\ntotal_length = 2 * a + 2 * b\n\n# Calculate the number of wooden bars needed\nnum_bars = total_length // n\n\n# Print the output\nprint(num_bars)"}
{"solution": "import sys\n\nn = int(input())\narr = list(map(int, input().split()))\nswap_str = input()\n\n# Check if the array is already sorted\nif arr == sorted(arr):\n    print(\"YES\")\n    sys.exit()\n\n# Check if the swap string is valid\nif len(swap_str)!= n - 1:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the swap string contains only 0s and 1s\nif not all(c in \"01\" for c in swap_str):\n    print(\"NO\")\n    sys.exit()\n\n# Check if the swap string is consistent with the array\nif not all(arr[i]!= arr[i + 1] for i in range(n - 1) if swap_str[i] == \"1\"):\n    print(\"NO\")\n    sys.exit()\n\n# Check if the array can be sorted using the swap string\nif not all(arr[i] <= arr[i + 1] for i in range(n - 1) if swap_str[i] == \"1\"):\n    print(\"NO\")\n    sys.exit()\n\n# If we reach this point, the array can be sorted using the swap string\nprint(\"YES\")"}
{"solution": "import sys\n\ndef get_wait_time(seat):\n    row, col = seat\n    row = int(row)\n    col = ord(col) - ord('a') + 1\n    if col == 1 or col == 3:\n        return row\n    elif col == 2 or col == 4:\n        return row + 1\n    else:\n        return row + 2\n\nseat = sys.stdin.readline().strip()\nprint(get_wait_time(seat))"}
{"solution": "def compare_numbers(x, y):\n    x_base = x[1]\n    y_base = y[1]\n    x_digits = x[0]\n    y_digits = y[0]\n\n    if x_base == y_base:\n        if x_digits == y_digits:\n            return '='\n        elif x_digits < y_digits:\n            return '<'\n        else:\n            return '>'\n    else:\n        x_value = 0\n        y_value = 0\n        for i in range(len(x_digits)):\n            x_value += x_digits[i] * (x_base ** (len(x_digits) - i - 1))\n            y_value += y_digits[i] * (y_base ** (len(y_digits) - i - 1))\n        if x_value < y_value:\n            return '<'\n        elif x_value > y_value:\n            return '>'\n        else:\n            return '='\n\nx = [101111, 2]\ny = [47, 10]\nprint(compare_numbers(x, y))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the game state\ngame_state = {\n    \"a\": a,\n    \"turn\": \"BitLGM\",\n    \"winner\": None\n}\n\n# Play the game until a winner is determined\nwhile game_state[\"winner\"] is None:\n    # Get the current player's move\n    if game_state[\"turn\"] == \"BitLGM\":\n        move = \"take\"\n    else:\n        move = \"decrease\"\n\n    # Apply the move to the game state\n    if move == \"take\":\n        # Take one of the integers\n        i = game_state[\"a\"].index(max(game_state[\"a\"]))\n        x = game_state[\"a\"][i]\n        game_state[\"a\"][i] = 0\n    else:\n        # Decrease all integers by the minimum value\n        x = min(game_state[\"a\"])\n        for i in range(len(game_state[\"a\"])):\n            game_state[\"a\"][i] -= x\n\n    # Check if the game is over\n    if all(a == 0 for a in game_state[\"a\"]):\n        game_state[\"winner\"] = game_state[\"turn\"]\n\n    # Switch turns\n    if game_state[\"turn\"] == \"BitLGM\":\n        game_state[\"turn\"] = \"BitAryo\"\n    else:\n        game_state[\"turn\"] = \"BitLGM\"\n\n# Print the winner\nprint(game_state[\"winner\"])"}
{"solution": "import sys\n\nn, k = map(int, input().split())\ncards = list(map(int, input().split()))\n\n# Initialize the number of ways to choose x and y to 0\nx_ways = 0\ny_ways = 0\n\n# Iterate over all possible values of x and y\nfor x in range(n):\n    for y in range(n):\n        # Check if the resulting deck is valid\n        if is_valid_deck(cards, x, y, k):\n            # Increment the number of ways to choose x and y\n            x_ways += 1\n            y_ways += 1\n\n# Print the number of ways to choose x and y\nprint(x_ways, y_ways)\n\ndef is_valid_deck(cards, x, y, k):\n    # Calculate the product of all numbers written on the cards in the resulting deck\n    product = 1\n    for i in range(x, n - y):\n        product *= cards[i]\n\n    # Check if the product is divisible by k\n    return product % k == 0"}
{"solution": "n, k = map(int, input().split())\ns = input()\n\n# Initialize a dictionary to keep track of the number of balloons of each color\nballoons = {}\nfor i in range(n):\n    balloons[s[i]] = balloons.get(s[i], 0) + 1\n\n# Initialize a set to keep track of the colors that have been given to friends\ngiven_colors = set()\n\n# Iterate through the balloons and check if the color has already been given to a friend\nfor color in balloons:\n    if color in given_colors:\n        print(\"NO\")\n        return\n    given_colors.add(color)\n\n# If all balloons have been given to friends, print \"YES\"\nprint(\"YES\")"}
{"solution": "import sys\n\nn = int(input())\narr = list(map(int, input().split()))\n\n# find the positions of the minimum values in the array\nmin_positions = []\nfor i in range(n):\n    if arr[i] == min(arr[i:n]):\n        min_positions.append(i)\n\n# calculate the distance between the two closest minimums\nmin_distance = sys.maxsize\nfor i in range(len(min_positions)):\n    for j in range(i+1, len(min_positions)):\n        distance = abs(min_positions[i] - min_positions[j])\n        if distance < min_distance:\n            min_distance = distance\n\nprint(min_distance)"}
{"solution": "import random\n\ndef get_probability(t, w, b):\n    total_steps = t // min(w, b)\n    tied_steps = total_steps // 2\n    return tied_steps / total_steps\n\nt = int(input())\nw = int(input())\nb = int(input())\n\nprobability = get_probability(t, w, b)\nprint(f\"{probability:.6f}\")"}
{"solution": "import sys\n\ndef get_result(x, y, z):\n    if x > y:\n        return \"-\"\n    elif x < y:\n        return \"+\"\n    else:\n        return \"0\"\n\ndef main():\n    x, y, z = map(int, sys.stdin.readline().split())\n    result = get_result(x, y, z)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve(n, operations, x, y):\n    # Initialize the minimum length of the changed subsegment as -1\n    min_length = -1\n\n    # Loop through each operation in the sequence\n    for i in range(n):\n        # If the current operation is not the same as the target operation, continue to the next iteration\n        if operations[i]!= \"R\":\n            continue\n\n        # If the current operation is the target operation, calculate the length of the changed subsegment\n        length = i - min_length\n\n        # If the length of the changed subsegment is less than the current minimum length, update the minimum length\n        if length < min_length or min_length == -1:\n            min_length = length\n\n    # Return the minimum length of the changed subsegment\n    return min_length"}
{"solution": "import sys\n\ndef solve():\n    T = int(input())\n    results = []\n\n    for _ in range(T):\n        n, x = map(int, input().split())\n        s = input()\n\n        balance_s = s.count('0') - s.count('1')\n        prefix_balances = [0] * (n + 1)\n\n        for i in range(n):\n            prefix_balances[i + 1] = prefix_balances[i] + (1 if s[i] == '0' else -1)\n\n        if balance_s == 0:\n            if x in prefix_balances:\n                results.append(-1)\n            else:\n                results.append(0)\n        else:\n            count = 0\n            for b in prefix_balances:\n                if (x - b) % balance_s == 0 and (x - b) // balance_s >= 0:\n                    count += 1\n            results.append(count)\n\n    for result in results:\n        print(result)\n\nsolve()"}
{"solution": "import math\n\ndef get_min_digits_to_delete(n, k):\n    # Convert the number to a string\n    n_str = str(n)\n    \n    # Find the length of the number\n    n_len = len(n_str)\n    \n    # Initialize the minimum number of digits to delete\n    min_digits = 0\n    \n    # Iterate through the digits of the number\n    for i in range(n_len):\n        # Get the current digit\n        digit = int(n_str[i])\n        \n        # Check if the digit is divisible by 10^k\n        if digit % (10 ** k) == 0:\n            # If it is, increment the minimum number of digits to delete\n            min_digits += 1\n    \n    # Return the minimum number of digits to delete\n    return min_digits\n\n# Test the function\nn = 30020\nk = 3\nprint(get_min_digits_to_delete(n, k))"}
{"solution": "import sys\n\nn, m, k, x, y = map(int, sys.stdin.readline().split())\n\n# Calculate the maximum number of questions a particular pupil is asked\nmax_questions = 0\nfor i in range(n):\n    for j in range(m):\n        if i == x and j == y:\n            continue\n        max_questions = max(max_questions, k // (n * m - 1))\n\n# Calculate the minimum number of questions a particular pupil is asked\nmin_questions = k // (n * m - 1)\n\n# Calculate how many times the teacher asked Sergei\nsergei_questions = k % (n * m - 1)\n\nprint(max_questions, min_questions, sergei_questions)"}
{"solution": "n = int(input())\n\nribbon_kuro = input()\nribbon_shiro = input()\nribbon_katie = input()\n\ndef get_beauty(ribbon):\n    beauty = 0\n    for i in range(len(ribbon)):\n        if ribbon[i] == ribbon[i-1]:\n            beauty += 1\n    return beauty\n\ndef get_max_beauty(ribbon, n):\n    max_beauty = 0\n    for i in range(len(ribbon)):\n        if ribbon[i] == ribbon[i-1]:\n            max_beauty = max(max_beauty, get_beauty(ribbon[i:]))\n    return max_beauty\n\ndef get_optimal_changes(ribbon, n):\n    optimal_changes = []\n    for i in range(len(ribbon)):\n        if ribbon[i] == ribbon[i-1]:\n            optimal_changes.append(i)\n    return optimal_changes\n\ndef get_winner(ribbon_kuro, ribbon_shiro, ribbon_katie, n):\n    beauty_kuro = get_max_beauty(ribbon_kuro, n)\n    beauty_shiro = get_max_beauty(ribbon_shiro, n)\n    beauty_katie = get_max_beauty(ribbon_katie, n)\n    if beauty_kuro > beauty_shiro and beauty_kuro > beauty_katie:\n        return \"Kuro\"\n    elif beauty_shiro > beauty_kuro and beauty_shiro > beauty_katie:\n        return \"Shiro\"\n    elif beauty_katie > beauty_kuro and beauty_katie > beauty_shiro:\n        return \"Katie\"\n    else:\n        return \"Draw\"\n\nprint(get_winner(ribbon_kuro, ribbon_shiro, ribbon_katie, n))"}
{"solution": "  import sys\n\ndef calculate_days(c, v_0, v_1, a, l):\n    days = 0\n    pages_read = 0\n    while pages_read < c:\n        pages_read += v_0\n        v_0 += a\n        if v_0 > v_1:\n            v_0 = v_1\n        days += 1\n        if pages_read - l >= 0:\n            pages_read -= l\n    return days\n\nif __name__ == '__main__':\n    c, v_0, v_1, a, l = map(int, sys.stdin.readline().split())\n    print(calculate_days(c, v_0, v_1, a, l))"}
{"solution": "import math\n\ndef represent_as_sum_of_primes(n):\n    if n % 2 == 0 or n < 3:\n        return -1\n\n    primes = []\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            primes.append(i)\n            n //= i\n\n    if n > 1:\n        primes.append(n)\n\n    return len(primes), primes\n\nn = int(input())\nk, primes = represent_as_sum_of_primes(n)\nprint(k)\nprint(*primes)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nfield = [list(input()) for _ in range(n)]\n\n# Count the number of walls in each row and column\nrow_walls = [0] * n\ncol_walls = [0] * m\nfor i in range(n):\n    for j in range(m):\n        if field[i][j] == '*':\n            row_walls[i] += 1\n            col_walls[j] += 1\n\n# Check if there exists a cell (x, y) such that the sum of walls in row x and column y equals the total number of walls\nfor i in range(n):\n    for j in range(m):\n        if row_walls[i] + col_walls[j] == sum(row_walls) + sum(col_walls):\n            print(\"YES\")\n            print(i, j)\n            sys.exit()\n\nprint(\"NO\")"}
{"solution": "import sys\n\nn, m, a, b = map(int, sys.stdin.readline().split())\n\n# Initialize the number of boxes to be divisible by m\nnum_boxes = m\n\n# Initialize the total cost to be 0\ntotal_cost = 0\n\n# While the number of boxes is not divisible by m\nwhile num_boxes % m!= 0:\n    # If the number of boxes is less than m\n    if num_boxes < m:\n        # Build m - num_boxes boxes\n        total_cost += (m - num_boxes) * a\n        num_boxes += m - num_boxes\n    # If the number of boxes is greater than m\n    else:\n        # Demolish num_boxes - m boxes\n        total_cost += (num_boxes - m) * b\n        num_boxes -= num_boxes - m\n\nprint(total_cost)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum odd sum subsequence\nmax_sum = 0\nfor i in range(n):\n    for j in range(i, n):\n        sum = 0\n        for k in range(i, j+1):\n            sum += a[k]\n        if sum % 2 == 1 and sum > max_sum:\n            max_sum = sum\n\nprint(max_sum)"}
{"solution": "import sys\n\ndef count_valid_playlists(n, T, songs):\n    # Initialize a dictionary to store the number of valid playlists for each song\n    valid_playlists = {}\n\n    # Iterate over each song and calculate the number of valid playlists for that song\n    for i in range(n):\n        # Calculate the number of valid playlists for the current song\n        valid_playlists[i] = count_valid_playlists_helper(i, T, songs)\n\n    # Return the sum of the valid playlists for all songs\n    return sum(valid_playlists.values())\n\ndef count_valid_playlists_helper(i, T, songs):\n    # Base case: if the current song is the last song, return 1 if the total duration is valid, otherwise return 0\n    if i == n - 1:\n        return 1 if T == songs[i][0] else 0\n\n    # Recursive case: calculate the number of valid playlists for the current song and the remaining songs\n    valid_playlists = 0\n    for j in range(i + 1, n):\n        # If the current song and the next song have the same genre, skip this combination\n        if songs[i][1] == songs[j][1]:\n            continue\n\n        # Calculate the number of valid playlists for the current song and the next song\n        valid_playlists += count_valid_playlists_helper(j, T - songs[i][0], songs)\n\n    return valid_playlists\n\nif __name__ == \"__main__\":\n    n, T = map(int, input().split())\n    songs = []\n    for i in range(n):\n        t, g = map(int, input().split())\n        songs.append((t, g))\n    print(count_valid_playlists(n, T, songs))"}
{"solution": "import math\n\ndef solve(m):\n    # Initialize variables\n    a = []\n    x = 0\n    gcd = 0\n    P = 0\n    Q = 0\n\n    # Perform the algorithm\n    while True:\n        # Select a random integer x uniformly in range from 1 to m\n        x = random.randint(1, m)\n\n        # Append x to the end of a\n        a.append(x)\n\n        # Compute the greatest common divisor of integers in a\n        gcd = math.gcd(a)\n\n        # If gcd equals to 1, break\n        if gcd == 1:\n            break\n\n    # Compute the expected length of a\n    expected_length = 0\n    for i in range(1, len(a)):\n        expected_length += (len(a) - i) / math.factorial(i)\n\n    # Compute P and Q\n    P = math.floor(expected_length)\n    Q = math.floor(1000000007 / math.gcd(P, 1000000007))\n\n    # Print the value of P * Q^-1 mod 1000000007\n    print(P * Q ** -1 % 1000000007)\n\n# Test the function\nsolve(1)\nsolve(2)\nsolve(4)"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b!= 0:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_good_pairs(l, r, x, y):\n    count = 0\n    for a in range(l, r + 1):\n        for b in range(a, r + 1):\n            if gcd(a, b) == x and lcm(a, b) == y:\n                count += 1\n    return count\n\nl, r, x, y = map(int, input().split())\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "  import sys\n\ndef get_lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    else:\n        i = 1\n        while True:\n            if i % a == 0 and i % b == 0:\n                return i\n            i += 1\n\ndef get_k(a, b):\n    lcm = get_lcm(a, b)\n    gcd = get_gcd(a, b)\n    k = lcm // gcd\n    return k\n\ndef get_gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return get_gcd(b, a % b)\n\ndef main():\n    a, b = map(int, input().split())\n    k = get_k(a, b)\n    print(k)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate the current average mark\ncurrent_average = sum(marks) / len(marks)\n\n# Calculate the number of marks needed to reach the desired average\nneeded_marks = k - current_average\n\n# Round up the number of marks needed to the nearest integer\nneeded_marks = int(math.ceil(needed_marks))\n\n# Print the number of marks needed to add\nprint(needed_marks)"}
{"solution": "import sys\n\nn = int(input())\narr = list(map(int, input().split()))\n\n# Initialize the number of positive numbers to 0\npositive_count = 0\n\n# Iterate through the array and count the number of positive numbers\nfor i in range(n):\n    if arr[i] > 0:\n        positive_count += 1\n\n# Find the value of d that satisfies the condition\nd = 0\nwhile positive_count < n / 2:\n    d += 1\n    for i in range(n):\n        arr[i] /= d\n        if arr[i] > 0:\n            positive_count += 1\n\n# Print the value of d\nprint(d)"}
{"solution": "import sys\n\nn = int(input())\n\n# Initialize a dictionary to store the number of pairs for each number of nines\nnum_pairs = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0}\n\n# Iterate through all possible pairs of shovels\nfor i in range(n):\n    for j in range(i+1, n):\n        # Calculate the sum of the costs of the two shovels\n        cost = i + j\n        \n        # Calculate the number of nines at the end of the sum\n        num_nines = 0\n        while cost % 10 == 9:\n            num_nines += 1\n            cost //= 10\n        \n        # Increment the number of pairs for the corresponding number of nines\n        num_pairs[num_nines] += 1\n\n# Print the number of pairs for the maximum number of nines\nprint(num_pairs[max(num_pairs)])"}
{"solution": "import math\n\ndef solve(a1, b1, a2, b2):\n    # Calculate the total number of squares in both bars\n    total_squares_1 = a1 * b1\n    total_squares_2 = a2 * b2\n\n    # Calculate the difference between the total number of squares in both bars\n    diff = abs(total_squares_1 - total_squares_2)\n\n    # Initialize the minimum number of minutes required to make the bars have the same number of squares\n    m = 0\n\n    # Loop through all possible combinations of breaking the bars in half or in thirds\n    for i in range(1, math.ceil(diff / 2) + 1):\n        # Calculate the number of squares that can be removed from each bar in i minutes\n        squares_removed_1 = i * (a1 + b1)\n        squares_removed_2 = i * (a2 + b2)\n\n        # Calculate the new total number of squares in both bars after i minutes\n        new_total_squares_1 = total_squares_1 - squares_removed_1\n        new_total_squares_2 = total_squares_2 - squares_removed_2\n\n        # Check if the new total number of squares in both bars is equal\n        if new_total_squares_1 == new_total_squares_2:\n            # If the new total number of squares in both bars is equal, then the minimum number of minutes required to make the bars have the same number of squares is i\n            m = i\n            break\n\n    # If the minimum number of minutes required to make the bars have the same number of squares is not found, then print -1\n    if m == 0:\n        print(-1)\n    else:\n        # Print the minimum number of minutes required to make the bars have the same number of squares\n        print(m)\n        # Print the possible sizes of the bars after they are leveled in m minutes\n        print(a1 - m * (a1 + b1), b1)\n        print(a2 - m * (a2 + b2), b2)\n\nsolve(2, 6, 2, 3)\nsolve(36, 5, 10, 16)\nsolve(3, 5, 2, 1)"}
{"solution": "import sys\n\ndef solve(x_p, y_p, x_v, y_v):\n    # Initialize the winner as None\n    winner = None\n\n    # While the pawns are not in the same cell\n    while x_p!= x_v or y_p!= y_v:\n        # If Polycarp's pawn is in the cell (0, 0)\n        if x_p == 0 and y_p == 0:\n            # The winner is Polycarp\n            winner = \"Polycarp\"\n            break\n\n        # If Vasiliy's pawn is in the cell (0, 0)\n        if x_v == 0 and y_v == 0:\n            # The winner is Vasiliy\n            winner = \"Vasiliy\"\n            break\n\n        # If Polycarp's pawn is in the cell (x_p - 1, y_p) or (x_p, y_p - 1)\n        if x_p - 1 == x_v and y_p == y_v or x_p == x_v and y_p - 1 == y_v:\n            # Move Polycarp's pawn to (x_p - 1, y_p - 1)\n            x_p -= 1\n            y_p -= 1\n\n        # If Vasiliy's pawn is in the cell (x_v - 1, y_v) or (x_v, y_v - 1)\n        if x_v - 1 == x_p and y_v == y_p or x_v == x_p and y_v - 1 == y_p:\n            # Move Vasiliy's pawn to (x_v - 1, y_v - 1)\n            x_v -= 1\n            y_v -= 1\n\n    # Return the winner\n    return winner\n\n# Read the input\nx_p, y_p, x_v, y_v = map(int, sys.stdin.readline().split())\n\n# Solve the problem\nwinner = solve(x_p, y_p, x_v, y_v)\n\n# Print the output\nprint(winner)"}
{"solution": "import sys\n\ndef get_number_of_columns(month, weekday):\n    # Calculate the number of days in the month\n    days_in_month = 31\n    if month in [4, 6, 9, 11]:\n        days_in_month = 30\n    elif month == 2:\n        days_in_month = 28\n\n    # Calculate the number of weeks in the month\n    weeks_in_month = days_in_month // 7\n    if days_in_month % 7!= 0:\n        weeks_in_month += 1\n\n    # Calculate the number of columns needed\n    columns = weeks_in_month\n    if weekday!= 1:\n        columns += 1\n\n    return columns\n\nif __name__ == \"__main__\":\n    month, weekday = map(int, sys.stdin.readline().split())\n    print(get_number_of_columns(month, weekday))"}
{"solution": "import sys\n\ndef count_years_with_one_zero(a, b):\n    count = 0\n    for year in range(a, b+1):\n        binary_rep = bin(year)[2:]\n        if binary_rep.count(\"0\") == 1:\n            count += 1\n    return count\n\na, b = map(int, sys.stdin.readline().split())\nprint(count_years_with_one_zero(a, b))"}
{"solution": "def minimal_layers(N):\n    return (N * (N + 1)) // 2\n\nN = int(input())\nprint(minimal_layers(N))"}
{"solution": "import itertools\n\ndef solve(n, k, S, a):\n    # Calculate the factorial of each number\n    factorials = [1] * (n + 1)\n    for i in range(2, n + 1):\n        factorials[i] = factorials[i - 1] * i\n\n    # Calculate the sum of the factorials of the numbers\n    sum_factorials = sum(factorials[a[i]] for i in range(n))\n\n    # Check if the sum of the factorials is equal to S\n    if sum_factorials == S:\n        return 1\n\n    # If the sum of the factorials is not equal to S, then we need to find all possible combinations of cubes and stickers\n    combinations = itertools.combinations(range(n), k)\n    total_ways = 0\n    for combination in combinations:\n        # Calculate the sum of the factorials of the chosen cubes\n        chosen_sum = sum(factorials[a[i]] for i in combination)\n\n        # Check if the sum of the factorials is equal to S\n        if chosen_sum == S:\n            total_ways += 1\n\n    return total_ways\n\nn, k, S = map(int, input().split())\na = list(map(int, input().split()))\nprint(solve(n, k, S, a))"}
{"solution": "import sys\n\ndef can_make_array(v, a, k):\n    # Initialize the array with zeroes\n    v = [0] * len(v)\n    \n    # Loop through each element of the array\n    for i in range(len(v)):\n        # If the element is not zero, skip it\n        if v[i]!= 0:\n            continue\n        \n        # Choose a position and increase the value by k^i\n        pos = i + 1\n        v[pos] += k**i\n        \n        # If the element is equal to the target value, return True\n        if v[i] == a[i]:\n            return True\n    \n    # If we reach this point, return False\n    return False\n\nif __name__ == \"__main__\":\n    # Read the input from stdin\n    T = int(input())\n    for _ in range(T):\n        n, k = map(int, input().split())\n        a = list(map(int, input().split()))\n        \n        # Call the can_make_array function and print the result\n        print(\"YES\" if can_make_array(a, n, k) else \"NO\")"}
{"solution": "import sys\n\ndef calculate_sum(a, b, c):\n    sum = 0\n    for i in range(1, a+1):\n        for j in range(1, b+1):\n            for k in range(1, c+1):\n                sum += d(i*j*k)\n    return sum % (2**30)\n\ndef d(n):\n    divisors = 0\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors += 2\n    if n**0.5 == int(n**0.5):\n        divisors -= 1\n    return divisors\n\nif __name__ == '__main__':\n    a, b, c = map(int, sys.stdin.readline().split())\n    print(calculate_sum(a, b, c))"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    neighbors = []\n    idx = state.index('X')\n    if idx == 0:\n        neighbors.append(swap(state, 0, 1))\n        neighbors.append(swap(state, 0, 2))\n    elif idx == 1:\n        neighbors.append(swap(state, 1, 0))\n        neighbors.append(swap(state, 1, 3))\n    elif idx == 2:\n        neighbors.append(swap(state, 2, 0))\n        neighbors.append(swap(state, 2, 3))\n    elif idx == 3:\n        neighbors.append(swap(state, 3, 1))\n        neighbors.append(swap(state, 3, 2))\n    return neighbors\n\ndef swap(state, i, j):\n    state = list(state)\n    state[i], state[j] = state[j], state[i]\n    return ''.join(state)\n\ndef bfs(start):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        current = queue.popleft()\n        for neighbor in get_neighbors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return visited\n\ndef can_be_same_configuration(bessie, elsie):\n    bessie_start = ''.join(bessie)\n    elsie_start = ''.join(elsie)\n    \n    bessie_reachable = bfs(bessie_start)\n    elsie_reachable = bfs(elsie_start)\n    \n    return not bessie_reachable.isdisjoint(elsie_reachable)\n\n# Input reading\nbessie = [input().strip() for _ in range(2)]\nelsie = [input().strip() for _ in range(2)]\n\nif can_be_same_configuration(bessie, elsie):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\nk = int(sys.stdin.readline().strip())\n\ndef convert_to_base_n(num, base):\n    result = \"\"\n    while num > 0:\n        result = str(num % base) + result\n        num //= base\n    return result\n\ndef find_min_decimal_number(base, num):\n    min_num = 0\n    for i in range(1, num+1):\n        if convert_to_base_n(i, base) == num:\n            min_num = i\n            break\n    return min_num\n\nprint(find_min_decimal_number(n, k))"}
{"solution": "n = int(input())\narr = list(map(int, input().split()))\n\n# Check if the array is unimodal\nif len(arr) < 3:\n    print(\"NO\")\nelse:\n    # Check if the first block is strictly increasing\n    if arr[0] < arr[1]:\n        for i in range(1, len(arr) - 1):\n            if arr[i] < arr[i + 1]:\n                pass\n            else:\n                print(\"NO\")\n                break\n        else:\n            print(\"YES\")\n    # Check if the last block is strictly decreasing\n    if arr[-1] > arr[-2]:\n        for i in range(len(arr) - 2, 0, -1):\n            if arr[i] > arr[i - 1]:\n                pass\n            else:\n                print(\"NO\")\n                break\n        else:\n            print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\ndef f(x):\n    if x % 2 == 0:\n        return x // 2\n    else:\n        return x - 1\n\ndef path(x):\n    if x == 1:\n        return [1]\n    else:\n        return [x] + path(f(x))\n\npaths = [path(x) for x in range(1, n + 1)]\n\nmax_value = 0\nfor value in range(1, n + 1):\n    if paths.count(value) >= k:\n        max_value = max(max_value, value)\n\nprint(max_value)"}
{"solution": "import sys\n\nn, m, x, y, vx, vy = map(int, sys.stdin.readline().split())\n\n# Check if the ball is initially in a pocket\nif x in range(n) and y in range(m):\n    print(x, y)\n    sys.exit()\n\n# Check if the ball will move indefinitely\nif vx == 0 and vy == 0:\n    print(-1)\n    sys.exit()\n\n# Check if the ball will fall into a pocket\npocket_x = [0, n, 0, n]\npocket_y = [0, 0, m, m]\n\nfor i in range(4):\n    if x == pocket_x[i] and y == pocket_y[i]:\n        print(x, y)\n        sys.exit()\n\n# Check if the ball will move along a side\nif vx == 0 or vy == 0:\n    print(-1)\n    sys.exit()\n\n# Check if the ball will move diagonally\nif vx!= 0 and vy!= 0:\n    print(-1)\n    sys.exit()\n\n# Check if the ball will move horizontally\nif vx!= 0:\n    if x + vx in range(n):\n        print(x + vx, y)\n    else:\n        print(-1)\n    sys.exit()\n\n# Check if the ball will move vertically\nif vy!= 0:\n    if y + vy in range(m):\n        print(x, y + vy)\n    else:\n        print(-1)\n    sys.exit()"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    # Check if two rectangles (a2, b2) and (a3, b3) can fit in (a1, b1)\n    def fits(w1, h1, w2, h2, W, H):\n        return (w1 + w2 <= W and max(h1, h2) <= H) or (h1 + h2 <= H and max(w1, w2) <= W)\n    \n    # Check all combinations of orientations\n    if (fits(a2, b2, a3, b3, a1, b1) or fits(b2, a2, a3, b3, a1, b1) or\n        fits(a2, b2, b3, a3, a1, b1) or fits(b2, a2, b3, a3, a1, b1) or\n        fits(a3, b3, a2, b2, a1, b1) or fits(b3, a3, a2, b2, a1, b1) or\n        fits(a3, b3, b2, a2, a1, b1) or fits(b3, a3, b2, a2, a1, b1)):\n        return \"YES\"\n    else:\n        return \"NO\""}
{"solution": "import sys\n\ndef solve(b_1, q, l, m, a):\n    # Initialize variables\n    count = 0\n    current = b_1\n    while abs(current) <= l:\n        # Check if current term is not a \"bad\" integer\n        if current not in a:\n            count += 1\n        # Update current term\n        current = current - q\n    # Return result\n    if count == 0:\n        return \"inf\"\n    else:\n        return count\n\n# Read input\nb_1, q, l, m = map(int, input().split())\na = set(map(int, input().split()))\n\n# Solve the problem\nresult = solve(b_1, q, l, m, a)\n\n# Print output\nprint(result)"}
{"solution": "import sys\n\ndef find_frame(n, m, pixels):\n    # Initialize the frame size to 1\n    frame_size = 1\n    # Initialize the frame position to (0, 0)\n    frame_position = (0, 0)\n    # Initialize the minimum frame size to infinity\n    min_frame_size = float('inf')\n    # Iterate over all possible frame positions\n    for i in range(n - frame_size + 1):\n        for j in range(m - frame_size + 1):\n            # Check if the frame is within the borders of the screen\n            if i + frame_size <= n and j + frame_size <= m:\n                # Check if all white pixels are located on the frame\n                if all(pixels[i + k][j + l] == 'w' for k in range(frame_size) for l in range(frame_size)):\n                    # Check if the frame size is smaller than the minimum frame size\n                    if frame_size < min_frame_size:\n                        # Update the minimum frame size and position\n                        min_frame_size = frame_size\n                        frame_position = (i, j)\n    # If the required frame doesn't exist, return -1\n    if min_frame_size == float('inf'):\n        return -1\n    # Otherwise, return the frame position and size\n    return (frame_position, frame_size)\n\n# Read the input\nn, m = map(int, input().split())\npixels = [input() for _ in range(n)]\n\n# Find the frame\nframe = find_frame(n, m, pixels)\n\n# Print the output\nif frame == -1:\n    print(-1)\nelse:\n    for i in range(n):\n        for j in range(m):\n            if pixels[i][j] == 'w':\n                print('w', end='')\n            elif i >= frame[0][0] and i < frame[0][0] + frame[1] and j >= frame[0][1] and j < frame[0][1] + frame[1]:\n                print('+', end='')\n            else:\n                print('.', end='')\n        print()"}
{"solution": "import sys\n\nn, a, b = map(int, sys.stdin.readline().split())\n\nif n % a == 0 and n % b == 0:\n    x = n // a\n    y = n // b\n    print(\"YES\")\n    print(x, y)\nelse:\n    print(\"NO\")"}
{"solution": "def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\n# Example usage:\ns = int(input())\nprint(number_to_words(s))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Find the longest consecutive sequence of elements that can be erased\nmax_sequence = 0\ncurrent_sequence = 0\nfor i in range(n - 1):\n    if a[i + 1] - a[i] == 1:\n        current_sequence += 1\n    else:\n        max_sequence = max(max_sequence, current_sequence)\n        current_sequence = 0\n\n# Print the maximum number of consecutive elements that can be erased\nprint(max_sequence)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Calculate the cumulative sum of problems solved each day\ncumulative_sum = [0]\nfor i in range(n):\n    cumulative_sum.append(cumulative_sum[i] + a[i])\n\n# Find the day when Polycarp will celebrate the equator\nfor i in range(n):\n    if cumulative_sum[i] >= (n - i) / 2:\n        print(i + 1)\n        break\nelse:\n    print(-1)"}
{"solution": "import sys\n\nN = int(input())\nboard = []\nfor i in range(N):\n    board.append(list(map(int, input().split())))\n\n# Initialize the starting piece as a knight\nstarting_piece = 'K'\n\n# Initialize the number of steps and replacements\nnum_steps = 0\nnum_replacements = 0\n\n# Initialize the current position as (1, 1)\ncurrent_position = (1, 1)\n\n# Initialize the visited squares as an empty set\nvisited_squares = set()\n\n# Initialize the possible moves for each piece as a dictionary\npossible_moves = {\n    'K': [(2, 1), (1, 2)],\n    'B': [(1, 1), (1, -1), (-1, 1), (-1, -1)],\n    'R': [(1, 0), (0, 1), (-1, 0), (0, -1)]\n}\n\n# Initialize the current piece as the starting piece\ncurrent_piece = starting_piece\n\n# While the current position is not (N, N)\nwhile current_position!= (N, N):\n    # If the current position is not in the visited squares set, add it to the visited squares set\n    if current_position not in visited_squares:\n        visited_squares.add(current_position)\n\n    # If the current position is the destination position, increment the number of steps and break\n    if current_position == (N, N):\n        num_steps += 1\n        break\n\n    # If the current position is not the destination position, determine the possible moves for the current piece\n    possible_moves_for_current_piece = possible_moves[current_piece]\n\n    # If there are no possible moves for the current piece, replace the current piece with the next piece in the sequence (K, B, R)\n    if not possible_moves_for_current_piece:\n        current_piece = 'K' if current_piece == 'R' else 'B' if current_piece == 'K' else 'R'\n        num_replacements += 1\n        continue\n\n    # If there are possible moves for the current piece, determine the next move\n    next_move = possible_moves_for_current_piece[0]\n\n    # If the next move is not in the visited squares set, move to the next move and increment the number of steps\n    if next_move not in visited_squares:\n        current_position = next_move\n        num_steps += 1\n\n# Print the number of steps and replacements\nprint(num_steps, num_replacements)"}
{"solution": "n, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Initialize the time variables\ntime_to_reach_a = 0\ntime_to_reach_b = 0\n\n# Calculate the time to reach a from the current floor\nif a // k!= 0:\n    time_to_reach_a += (a // k - 1) * 15\nif a % k!= 0:\n    time_to_reach_a += (a % k - 1) * 5\n\n# Calculate the time to reach b from the current floor\nif b // k!= 0:\n    time_to_reach_b += (b // k - 1) * 15\nif b % k!= 0:\n    time_to_reach_b += (b % k - 1) * 5\n\n# Calculate the minimum time to reach b from a\nmin_time = min(time_to_reach_a, time_to_reach_b)\n\n# Print the minimum time\nprint(min_time)"}
{"solution": "import sys\n\ndef is_divisible_by_64(binary_string):\n    # Convert the binary string to an integer\n    num = int(binary_string, 2)\n    # Check if the number is divisible by 64\n    if num % 64 == 0:\n        return \"yes\"\n    else:\n        return \"no\"\n\nif __name__ == \"__main__\":\n    binary_string = sys.stdin.readline().strip()\n    print(is_divisible_by_64(binary_string))"}
{"solution": "def get_subsequence(s):\n    # Initialize a list to store the characters of the input string\n    chars = list(s)\n    # Initialize a list to store the characters of the output string\n    output = []\n    # Iterate through the characters of the input string\n    for char in chars:\n        # If the character is not 'z', replace it with the next character in the alphabet\n        if char!= 'z':\n            char = chr(ord(char) + 1)\n        # Add the character to the output list\n        output.append(char)\n    # Join the characters of the output list into a string\n    output = ''.join(output)\n    # Return the output string if it contains the English alphabet as a subsequence, otherwise return '-1'\n    if 'abcdefghijklmnopqrstuvwxyz' in output:\n        return output\n    else:\n        return '-1'"}
{"solution": "import math\n\ndef get_expected_value(n, m, r, k):\n    # Calculate the total number of cells in the pond\n    total_cells = n * m\n    \n    # Calculate the number of cells that the scoop-net can cover\n    scoop_cells = (n - r + 1) * (m - r + 1)\n    \n    # Calculate the number of fishes that can be caught in each cell\n    fishes_per_cell = k // total_cells\n    \n    # Calculate the expected value of the number of caught fishes\n    expected_value = fishes_per_cell * scoop_cells\n    \n    return expected_value\n\nn, m, r, k = map(int, input().split())\nprint(get_expected_value(n, m, r, k))"}
{"solution": "  import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the maximum product to 0\nmax_product = 0\n\n# Iterate through all possible indices\nfor i in range(n):\n    # Calculate the product of the array elements after applying the operation to index i\n    product = 1\n    for j in range(n):\n        if j == i:\n            product *= -a[j] - 1\n        else:\n            product *= a[j]\n    \n    # If the product is greater than the maximum product, update the maximum product and the corresponding array\n    if product > max_product:\n        max_product = product\n        max_array = a.copy()\n        max_array[i] = -a[i] - 1\n\n# Print the array with the maximum product\nprint(*max_array)"}
{"solution": "n, k = map(int, input().split())\n\ndivisors = []\nfor i in range(1, n+1):\n    if n % i == 0:\n        divisors.append(i)\n\nif len(divisors) < k:\n    print(-1)\nelse:\n    print(divisors[k-1])"}
{"solution": "n = int(input())\ncubes = []\nfor i in range(n):\n    cube = []\n    for j in range(6):\n        cube.append(int(input()))\n    cubes.append(cube)\n\n# Initialize the maximum number x to 0\nx = 0\n\n# Iterate through all possible combinations of digits on the cubes\nfor i in range(10):\n    for j in range(10):\n        for k in range(10):\n            for l in range(10):\n                for m in range(10):\n                    for n in range(10):\n                        # Check if the current combination forms a consecutive number\n                        if i * 100000 + j * 10000 + k * 1000 + l * 100 + m * 10 + n == x + 1:\n                            # If it does, update the maximum number x\n                            x = x + 1\n                            break\n\n# Print the maximum number x\nprint(x)"}
{"solution": "import math\n\ndef k_rounding(n, k):\n    # Calculate the minimum positive integer x such that x ends with k or more zeros and is divisible by n\n    x = int(math.ceil(n / 10**k) * 10**k)\n    \n    # Return the k-rounded value of n\n    return x\n\n# Test the function with different inputs\nprint(k_rounding(375, 4))  # 30000\nprint(k_rounding(10000, 1))  # 10000\nprint(k_rounding(38101, 0))  # 38101\nprint(k_rounding(123456789, 8))  # 12345678900000000"}
{"solution": "def transform_matrix(n, m, A):\n    operations = []\n    B = [[0] * m for _ in range(n)]\n    \n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                operations.append((i + 1, j + 1))\n                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1\n    \n    for i in range(n):\n        for j in range(m):\n            if A[i][j]!= B[i][j]:\n                return -1\n    \n    return operations"}
{"solution": "import math\n\ndef get_probabilities(r, s, p):\n    # Calculate the probability of each species being the sole survivor\n    prob_rock = (r * (s + p)) / (r + s + p)\n    prob_scissors = (s * (r + p)) / (r + s + p)\n    prob_paper = (p * (r + s)) / (r + s + p)\n\n    # Round the probabilities to 9 decimal places\n    prob_rock = round(prob_rock, 9)\n    prob_scissors = round(prob_scissors, 9)\n    prob_paper = round(prob_paper, 9)\n\n    return prob_rock, prob_scissors, prob_paper\n\n# Test the function with some examples\nprint(get_probabilities(2, 2, 2))  # Output: 0.333333333333 0.333333333333 0.333333333333\nprint(get_probabilities(2, 1, 2))  # Output: 0.150000000000 0.300000000000 0.550000000000\nprint(get_probabilities(1, 1, 3))  # Output: 0.057142857143 0.657142857143 0.285714285714"}
{"solution": "import sys\n\ndef get_overlapping_minutes(l1, r1, l2, r2, k):\n    # Calculate the number of minutes they will be able to spend together\n    minutes_together = 0\n\n    # Check if Sonya is available during the time Filya wants to visit\n    if l2 <= k <= r2:\n        # If Sonya is available, calculate the number of minutes they can spend together\n        minutes_together = min(r2, k) - max(l2, k) + 1\n    elif l1 <= k <= r1:\n        # If Sonya is not available, calculate the number of minutes they can spend together during the overlapping time\n        minutes_together = min(r1, r2) - max(l1, l2) + 1\n\n    return minutes_together\n\nif __name__ == '__main__':\n    l1, r1, l2, r2, k = map(int, sys.stdin.readline().split())\n    print(get_overlapping_minutes(l1, r1, l2, r2, k))"}
{"solution": "import sys\n\ndef get_area(N, M, A, B, C, D, E, F):\n    # Initialize the area as 0\n    area = 0\n\n    # Iterate over each north-south line\n    for i in range(N):\n        # Calculate the area of the triangle formed by the line and the cow's starting point\n        triangle_area = abs(A[i] * C[i] - B[i] * C[i]) / 2\n\n        # Add the area of the triangle to the total area\n        area += triangle_area\n\n    # Iterate over each east-west line\n    for j in range(M):\n        # Calculate the area of the triangle formed by the line and the cow's starting point\n        triangle_area = abs(D[j] * F[j] - E[j] * F[j]) / 2\n\n        # Add the area of the triangle to the total area\n        area += triangle_area\n\n    # Return the total area\n    return area\n\n# Read the input from stdin\nN, M = map(int, input().split())\nA = [int(x) for x in input().split()]\nB = [int(x) for x in input().split()]\nC = [int(x) for x in input().split()]\nD = [int(x) for x in input().split()]\nE = [int(x) for x in input().split()]\nF = [int(x) for x in input().split()]\n\n# Calculate the area of the region the cow can reach\narea = get_area(N, M, A, B, C, D, E, F)\n\n# Print the output\nprint(area)"}
{"solution": "import sys\n\nt, s, x = map(int, sys.stdin.readline().split())\n\nif (x - t) % (s + 1) == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn = int(input())\nsegments = []\n\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nfor i in range(n):\n    for j in range(i+1, n):\n        if segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            print(i, j)\n            sys.exit()\n\nprint(-1, -1)"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize a dictionary to keep track of the number of each nucleotide\nnucleotides = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\n\n# Iterate through the string and increment the corresponding nucleotide count\nfor nucleotide in s:\n    if nucleotide in nucleotides:\n        nucleotides[nucleotide] += 1\n\n# Check if the number of each nucleotide is equal\nif len(set(nucleotides.values())) == 1:\n    # If the number of each nucleotide is equal, print the decoded genome\n    print(s)\nelse:\n    # If the number of each nucleotide is not equal, print three equals signs\n    print(\"===\")"}
{"solution": "def check_winning_move(board):\n    # Check for horizontal and vertical winning moves\n    for row in range(4):\n        for col in range(4):\n            if board[row][col] == 'x' and board[row][col+1] == 'x' and board[row][col+2] == 'x':\n                return True\n            if board[col][row] == 'x' and board[col+1][row] == 'x' and board[col+2][row] == 'x':\n                return True\n    \n    # Check for diagonal winning moves\n    for row in range(4):\n        for col in range(4):\n            if board[row][col] == 'x' and board[row+1][col+1] == 'x' and board[row+2][col+2] == 'x':\n                return True\n            if board[row][col] == 'x' and board[row+1][col-1] == 'x' and board[row+2][col-2] == 'x':\n                return True\n    \n    return False\n\ndef main():\n    board = []\n    for _ in range(4):\n        board.append(input().split())\n    \n    if check_winning_move(board):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Check if the sum of the first half of the array is equal to the sum of the second half\nif sum(a[:n//2]) == sum(a[n//2:]):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Check if the number of lost elements in a is equal to the length of b\nif k!= len(b):\n    print(\"No\")\n    sys.exit()\n\n# Check if the elements in b are unique\nif len(set(b))!= len(b):\n    print(\"No\")\n    sys.exit()\n\n# Check if the elements in a are unique\nif len(set(a))!= len(a):\n    print(\"No\")\n    sys.exit()\n\n# Check if the elements in a are all non-zero\nif 0 in a:\n    print(\"No\")\n    sys.exit()\n\n# Check if the elements in b are all non-zero\nif 0 in b:\n    print(\"No\")\n    sys.exit()\n\n# Check if the elements in a can be replaced with elements in b\ncan_replace = True\nfor i in range(n):\n    if a[i]!= 0 and b[i]!= 0:\n        can_replace = False\n        break\nif not can_replace:\n    print(\"No\")\n    sys.exit()\n\n# Check if the resulting sequence is not increasing\nresult = [a[i] if a[i]!= 0 else b[i] for i in range(n)]\nif result[i] > result[i+1] for i in range(n-1):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "x, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\nif a >= x and b >= y and c >= z:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def is_accident_possible(lights):\n    # Initialize variables to keep track of the number of green lights\n    num_green_lights = 0\n    num_green_pedestrian_lights = 0\n\n    # Iterate through the lights and count the number of green lights\n    for light in lights:\n        if light == 1:\n            num_green_lights += 1\n        elif light == 4:\n            num_green_pedestrian_lights += 1\n\n    # If there are more than one green light, an accident is possible\n    if num_green_lights > 1 or num_green_pedestrian_lights > 1:\n        return \"YES\"\n    else:\n        return \"NO\""}
{"solution": "n = int(input())\nnumber = input().strip()\n\n# Convert each digit in the input number to its corresponding coordinates\ncoordinates = [get_coordinates(digit) for digit in number]\n\n# Calculate the sequence of vectors (movements) between consecutive digits\nvectors = [coordinates[i] - coordinates[i-1] for i in range(1, len(coordinates))]\n\n# Check if any other number of the same length can produce the same sequence of vectors\nfor i in range(10**(n-1), 10**n):\n    candidate = str(i).zfill(n)\n    if candidate!= number:\n        if get_vectors(candidate) == vectors:\n            print(\"NO\")\n            break\nelse:\n    print(\"YES\")"}
{"solution": "import sys\n\nn, f = map(int, input().split())\nk = [0] * n\nl = [0] * n\n\nfor i in range(n):\n    k[i], l[i] = map(int, input().split())\n\n# Calculate the number of products that can be sold on each day\nproducts_sold = [0] * n\nfor i in range(n):\n    products_sold[i] = k[i] * l[i]\n\n# Choose the f days with the highest number of products sold\nchosen_days = sorted(range(n), key=lambda i: products_sold[i], reverse=True)[:f]\n\n# Calculate the total number of products that can be sold\ntotal_products_sold = sum(products_sold[i] for i in chosen_days)\n\nprint(total_products_sold)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\n# Initialize an array to store the labels of the cows\ncows = [i for i in range(1, n + 1)]\n\n# Initialize a variable to store the maximum messiness\nmax_messiness = 0\n\n# Iterate over each minute\nfor i in range(k):\n    # Choose two distinct stalls and swap the cows occupying those stalls\n    stall1, stall2 = random.sample(range(n), 2)\n    cows[stall1], cows[stall2] = cows[stall2], cows[stall1]\n\n    # Calculate the messiness of the current arrangement\n    messiness = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if cows[i] > cows[j]:\n                messiness += 1\n\n    # Update the maximum messiness if necessary\n    if messiness > max_messiness:\n        max_messiness = messiness\n\n# Print the maximum messiness\nprint(max_messiness)"}
{"solution": "import sys\n\ndef get_min_coins(N, M, K, L):\n    # Initialize variables\n    min_coins = 0\n    new_coins = 0\n\n    # Iterate through each friend\n    for i in range(M):\n        # Calculate the number of new coins\n        new_coins = N - K\n\n        # Check if the number of new coins is greater than or equal to L\n        if new_coins >= L:\n            # Increment the minimum number of coins\n            min_coins += 1\n        else:\n            # Return -1 if it is not possible to meet all the conditions\n            return -1\n\n    # Return the minimum number of coins\n    return min_coins\n\n# Get input from stdin\nN, M, K, L = map(int, input().split())\n\n# Get the minimum number of coins\nmin_coins = get_min_coins(N, M, K, L)\n\n# Print the output\nprint(min_coins)"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    # Find the bounds of the black cells\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # If no black cells are found\n    if min_row == n:\n        return 1\n    \n    # Calculate the side length of the square\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    \n    # Check if the square can fit within the grid\n    if side_length > n or side_length > m:\n        return -1\n    \n    # Count the number of white cells within the square\n    min_paint = float('inf')\n    for i in range(n - side_length + 1):\n        for j in range(m - side_length + 1):\n            paint_count = 0\n            for x in range(i, i + side_length):\n                for y in range(j, j + side_length):\n                    if grid[x][y] == 'W':\n                        paint_count += 1\n            min_paint = min(min_paint, paint_count)\n    \n    return min_paint"}
{"solution": "import sys\n\nn = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\nif len(x)!= len(y):\n    print(\"No\")\n    sys.exit()\n\nfor i in range(len(x)):\n    if x[i]!= y[i]:\n        print(\"No\")\n        sys.exit()\n\nprint(\"Yes\")"}
{"solution": "import sys\n\nn = int(input())\nangles = [int(x) for x in input().split()]\n\n# Calculate the sum of all angles\ntotal_angle = sum(angles)\n\n# Initialize the minimum difference between angles\nmin_diff = 360\n\n# Iterate through all possible combinations of angles\nfor i in range(n):\n    for j in range(i+1, n):\n        # Calculate the difference between the two sectors\n        diff = abs(angles[i] + angles[j] - total_angle)\n\n        # Update the minimum difference if necessary\n        if diff < min_diff:\n            min_diff = diff\n\n# Print the minimum difference\nprint(min_diff)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\n\ndef count_ways(n, m):\n    # Base case: if there are no presents or boxes, return 1\n    if n == 0 or m == 0:\n        return 1\n    \n    # Recursive case: count the number of ways to pack the presents\n    # by considering each present as a separate box\n    return (count_ways(n-1, m) + count_ways(n, m-1)) % (10**9 + 7)\n\nprint(count_ways(n, m))"}
{"solution": "import math\n\ndef find_pythagorean_triple(n):\n    for m in range(1, 10**18):\n        for k in range(1, 10**18):\n            if m**2 + k**2 == n**2:\n                return m, k\n    return -1\n\nn = int(input())\nm, k = find_pythagorean_triple(n)\nprint(m, k)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\nremainders = []\nfor i in range(1, k+1):\n    remainders.append(n % i)\n\nif len(remainders) == len(set(remainders)):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "a = input()\nb = input()\n\nif a < b:\n    print(\"<\")\nelif a > b:\n    print(\">\")\nelse:\n    print(\"=\")"}
{"solution": "import sys\n\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Initialize the number of valid configurations to 0\nvalid_configurations = 0\n\n# Iterate over all possible configurations of arrows and colors\nfor i in range(n):\n    for j in range(i+1, n):\n        # Check if the configuration is valid\n        if colors[i]!= colors[j] and (colors[i] == -1 or colors[j] == -1):\n            # Increment the number of valid configurations\n            valid_configurations += 1\n\n# Print the number of valid configurations modulo 10^9 + 7\nprint(valid_configurations % (10**9 + 7))"}
{"solution": "import sys\n\nn, a, b, c = map(int, sys.stdin.readline().split())\n\n# Calculate the minimum number of additional copybooks needed\nk = 4 - (n % 4)\n\n# Calculate the cost of the additional copybooks\ncost = k * min(a, b, c)\n\n# Print the minimum amount of rubles Alyona should pay\nprint(cost)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nedges = []\n\nfor i in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if the graph is acyclic\nacyclic = True\nfor edge in edges:\n    if edge[0] == edge[1]:\n        acyclic = False\n        break\n\n# Check if the graph can be made acyclic by removing at most one edge\nif acyclic:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef get_min_coins(n, m, x_list, s_list):\n    # Initialize variables\n    coins_spent = 0\n    covered_positions = set()\n\n    # Sort the antennas by their position\n    sorted_x_list = sorted(x_list)\n\n    # Iterate through the antennas and cover the positions\n    for i in range(n):\n        x = sorted_x_list[i]\n        s = s_list[i]\n        covered_positions.update(range(x - s, x + s + 1))\n\n    # Calculate the minimum number of coins needed to cover all positions\n    for i in range(1, m + 1):\n        if i not in covered_positions:\n            coins_spent += 1\n\n    return coins_spent\n\n# Read input from stdin\nn, m = map(int, input().split())\nx_list = []\ns_list = []\nfor i in range(n):\n    x, s = map(int, input().split())\n    x_list.append(x)\n    s_list.append(s)\n\n# Get the minimum number of coins needed to cover all positions\nmin_coins = get_min_coins(n, m, x_list, s_list)\n\n# Print the output\nprint(min_coins)"}
{"solution": "import sys\n\ndef get_max_weight(W, cnt):\n    # Initialize the maximum weight as 0\n    max_weight = 0\n\n    # Iterate through the input and calculate the maximum weight\n    for i in range(8):\n        # Calculate the weight of the current item\n        weight = i * cnt[i]\n\n        # Check if the weight is less than or equal to the maximum weight\n        if weight <= W:\n            # Update the maximum weight if necessary\n            max_weight = max(max_weight, weight)\n\n    # Return the maximum weight\n    return max_weight\n\n# Read the input from stdin\nW, cnt = map(int, input().split())\n\n# Calculate the maximum weight\nmax_weight = get_max_weight(W, cnt)\n\n# Print the output to stdout\nprint(max_weight)"}
{"solution": "import sys\n\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Sort the costs in descending order\ncosts.sort(reverse=True)\n\n# Initialize the total cost and the number of bottles bought\ntotal_cost = 0\nnum_bottles = 0\n\n# Loop through the costs and buy bottles until the required amount of lemonade is reached\nfor i in range(n):\n    # Calculate the number of bottles that can be bought with the current cost\n    num_bottles_i = L // (costs[i] - 1)\n    \n    # Update the total cost and the number of bottles bought\n    total_cost += num_bottles_i * costs[i]\n    num_bottles += num_bottles_i\n    \n    # Update the required amount of lemonade\n    L -= num_bottles_i * (costs[i] - 1)\n    \n    # If the required amount of lemonade is reached, break the loop\n    if L == 0:\n        break\n\n# Print the total cost\nprint(total_cost)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmex = 1\nfor i in range(n):\n    if a[i] >= mex:\n        mex += 1\n\nprint(mex)"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(int(digit) for digit in digits)\n    \n    # Try every possible segment sum from 1 to total_sum\n    for segment_sum in range(1, total_sum + 1):\n        if total_sum % segment_sum == 0:\n            current_sum = 0\n            valid_partition = True\n            for digit in digits:\n                current_sum += int(digit)\n                if current_sum > segment_sum:\n                    valid_partition = False\n                    break\n                elif current_sum == segment_sum:\n                    current_sum = 0\n            if valid_partition and current_sum == 0:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Example usage:\nn = int(input())\ndigits = input().strip()\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\"\n\n# Example usage:\nusername = input().strip()\nprint(determine_gender(username))"}
{"solution": "import sys\n\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Initialize the variables\ne = 0\ns = 0\n\n# Iterate through the tabs and count the number of test and social network tabs\nfor i in range(n):\n    if tabs[i] == 1:\n        e += 1\n    else:\n        s += 1\n\n# Calculate the absolute difference between the amounts of remaining tabs of different types\nabs_diff = abs(e - s)\n\n# Print the maximum absolute difference\nprint(abs_diff)"}
{"solution": "import sys\n\nn, c0, c1 = map(int, input().split())\n\n# Initialize the cost of each letter as infinity\ncost = [float('inf')] * n\n\n# Initialize the prefixes of each letter as empty\nprefixes = [[] for _ in range(n)]\n\n# Initialize the number of letters with each prefix as 0\nnum_letters = [0] * n\n\n# Loop through each letter\nfor i in range(n):\n    # Loop through each prefix\n    for j in range(i):\n        # If the prefix of the current letter is the same as the prefix of the previous letter\n        if prefixes[i] == prefixes[j]:\n            # Increment the number of letters with the current prefix\n            num_letters[j] += 1\n            # Update the cost of the current letter\n            cost[i] = min(cost[i], cost[j] + num_letters[j] * c1)\n        else:\n            # Update the cost of the current letter\n            cost[i] = min(cost[i], cost[j] + num_letters[j] * c0)\n\n# Print the minimum total cost\nprint(min(cost))"}
{"solution": "def will_meet(n, a, x, b, y):\n    while a!= x and b!= y:\n        if a == b:\n            return \"YES\"\n        a = a + 1 if a < n else 1\n        b = b - 1 if b > 1 else n\n    return \"YES\" if a == b else \"NO\""}
{"solution": "import math\n\ndef is_unlucky(n, x, y):\n    a = int(math.log(n, x))\n    b = int(math.log(n, y))\n    return a + b == n\n\ndef find_golden_age(x, y, l, r):\n    unlucky_years = set()\n    for i in range(l, r+1):\n        if is_unlucky(i, x, y):\n            unlucky_years.add(i)\n\n    max_length = 0\n    for i in range(l, r+1):\n        if i not in unlucky_years:\n            length = 1\n            while i+length in unlucky_years:\n                length += 1\n            max_length = max(max_length, length)\n\n    return max_length\n\nx, y, l, r = map(int, input().split())\nprint(find_golden_age(x, y, l, r))"}
{"solution": "n = int(input())\n\n# Calculate the maximum divisor of n\nmax_divisor = 1\nwhile n % max_divisor == 0:\n    max_divisor += 1\n\n# Calculate the minimum number of burles that Mr. Funt has to pay\nmin_burles = max_divisor - 1\n\nprint(min_burles)"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    n = len(word)\n    result = []\n    i = 0\n    \n    while i < n:\n        result.append(word[i])\n        if word[i] not in vowels:\n            start = i\n            while i < n and word[i] not in vowels:\n                i += 1\n            if i - start >= 3:\n                block = word[start:i]\n                if len(set(block)) > 1:\n                    result.append(' ')\n        i += 1\n    \n    return ''.join(result)"}
{"solution": "import sys\n\ndef get_optimal_time(n, m, k, x, s, a, b, c, d):\n    # Initialize the optimal time to the initial preparation time\n    optimal_time = x\n    \n    # Loop through each spell of the first type\n    for i in range(m):\n        # Calculate the new preparation time using the current spell\n        new_time = a[i]\n        \n        # Check if the new preparation time is less than the current optimal time\n        if new_time < optimal_time:\n            # Update the optimal time and the number of manapoints spent\n            optimal_time = new_time\n            manapoints_spent = b[i]\n            \n            # Check if the number of manapoints spent is less than the total number of manapoints available\n            if manapoints_spent <= s:\n                # Use the current spell and update the number of manapoints spent\n                manapoints_spent += b[i]\n                \n                # Check if the number of manapoints spent is still less than the total number of manapoints available\n                if manapoints_spent <= s:\n                    # Use the second spell of the second type to prepare the remaining potions\n                    for j in range(k):\n                        # Calculate the number of potions that can be prepared using the current spell\n                        num_potions = min(c[j], s - manapoints_spent)\n                        \n                        # Update the number of manapoints spent and the optimal time\n                        manapoints_spent += d[j] * num_potions\n                        optimal_time += num_potions * new_time\n    \n    return optimal_time\n\nif __name__ == \"__main__\":\n    n, m, k = map(int, input().split())\n    x, s = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    d = list(map(int, input().split()))\n    \n    print(get_optimal_time(n, m, k, x, s, a, b, c, d))"}
{"solution": "n, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Initialize the maximum number of points to 0\nmax_points = 0\n\n# Iterate over all possible combinations of tasks\nfor i in range(1, n+1):\n    for j in range(1, k+1):\n        # Calculate the time required to solve the subtask\n        time_required = t[j-1]\n        \n        # Check if the time required is less than or equal to the available time\n        if time_required <= M:\n            # Increment the maximum number of points\n            max_points += 1\n            \n            # Decrement the available time\n            M -= time_required\n            \n            # Break out of the inner loop if the maximum number of points has been reached\n            if max_points == n:\n                break\n            \n        # Break out of the outer loop if the maximum number of points has been reached\n        if max_points == n:\n            break\n            \n# Print the maximum number of points\nprint(max_points)"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\n# Initialize the number of perfectly balanced striped binary search trees to 0\nnum_trees = 0\n\n# Iterate over all possible keys for the root node\nfor root_key in range(1, n + 1):\n    # Check if the root node is even or odd\n    if root_key % 2 == 0:\n        # If the root node is even, the left subtree must have an odd key\n        left_key = root_key - 1\n    else:\n        # If the root node is odd, the left subtree must have an even key\n        left_key = root_key + 1\n\n    # Check if the left subtree is a perfectly balanced striped binary search tree\n    if is_perfectly_balanced_striped_bst(left_key, n):\n        # If the left subtree is a perfectly balanced striped binary search tree,\n        # check if the right subtree is a perfectly balanced striped binary search tree\n        right_key = root_key + 2\n        if is_perfectly_balanced_striped_bst(right_key, n):\n            # If the right subtree is a perfectly balanced striped binary search tree,\n            # increment the number of perfectly balanced striped binary search trees\n            num_trees += 1\n\n# Print the number of perfectly balanced striped binary search trees modulo 998244353\nprint(num_trees % 998244353)\n\ndef is_perfectly_balanced_striped_bst(key, n):\n    # Check if the key is between 1 and n, inclusive\n    if not 1 <= key <= n:\n        return False\n\n    # Check if the key is even or odd\n    if key % 2 == 0:\n        # If the key is even, the left subtree must have an odd key\n        left_key = key - 1\n    else:\n        # If the key is odd, the left subtree must have an even key\n        left_key = key + 1\n\n    # Check if the left subtree is a perfectly balanced striped binary search tree\n    if not is_perfectly_balanced_striped_bst(left_key, n):\n        return False\n\n    # Check if the right subtree is a perfectly balanced striped binary search tree\n    right_key = key + 2\n    if not is_perfectly_balanced_striped_bst(right_key, n):\n        return False\n\n    # If the left and right subtrees are both perfectly balanced striped binary search trees,\n    # return True\n    return True"}
{"solution": "import sys\n\nn, m, k = map(int, sys.stdin.readline().split())\n\n# Calculate the current position of Lara\ncurrent_row = 1\ncurrent_col = 1\n\n# Move down to the bottom left corner\nfor i in range(n - 1):\n    current_row += 1\n\n# Move to the right, one cell up, then to the left to the cell in the 2nd column, one cell up\nfor i in range(m - 1):\n    current_col += 1\n    current_row -= 1\n\n# Move until she runs out of non-visited cells\nwhile current_row > 1 and current_col > 1:\n    current_row -= 1\n    current_col -= 1\n\n# Print the current position of Lara\nprint(current_row, current_col)"}
{"solution": "  import math\n\ndef find_min_max(X):\n    # Initialize the minimum possible value of max(a, b) to infinity\n    min_max = math.inf\n    # Initialize the pair (a, b) that minimizes max(a, b) to None\n    min_pair = None\n    \n    # Iterate through all possible factors of X\n    for a in range(1, int(math.sqrt(X)) + 1):\n        if X % a == 0:\n            b = X // a\n            # Calculate the value of max(a, b)\n            max_ab = max(a, b)\n            # If the value of max(a, b) is less than the minimum possible value, update the minimum possible value and the pair (a, b) that minimizes max(a, b)\n            if max_ab < min_max:\n                min_max = max_ab\n                min_pair = (a, b)\n    \n    return min_pair\n\nX = int(input())\nprint(find_min_max(X))"}
{"solution": "def max_fruits_for_compote(a, b, c):\n    # Calculate the maximum number of complete sets for each fruit type\n    max_sets_lemons = a // 1\n    max_sets_apples = b // 2\n    max_sets_pears = c // 4\n    \n    # Find the limiting factor (minimum number of complete sets)\n    max_complete_sets = min(max_sets_lemons, max_sets_apples, max_sets_pears)\n    \n    # Calculate the total number of fruits used in the compote\n    total_fruits = max_complete_sets * (1 + 2 + 4)\n    \n    return total_fruits"}
{"solution": "def can_divide_teams(n, ratings):\n    ratings.sort()\n    for i in range(n):\n        if ratings[i] >= ratings[i + n]:\n            return \"NO\"\n    return \"YES\""}
{"solution": "import sys\n\nn = int(input())\narr = list(map(int, input().split()))\n\n# Initialize the number of insertions needed\nk = 0\n\n# Iterate through the array and check if any two adjacent elements are co-prime\nfor i in range(n - 1):\n    if gcd(arr[i], arr[i + 1])!= 1:\n        # If not co-prime, find the least common multiple and insert it into the array\n        lcm = arr[i] * arr[i + 1] // gcd(arr[i], arr[i + 1])\n        arr.insert(i + 1, lcm)\n        k += 1\n\n# Print the number of insertions needed and the updated array\nprint(k)\nprint(*arr)"}
{"solution": "import math\nfrom functools import reduce\nfrom math import gcd\n\ndef compute_gcd_of_list(lst):\n    return reduce(gcd, lst)\n\ndef max_divisor_after_operations(N, K, A):\n    if N == 1:\n        return A[0]\n    \n    # Compute the GCD of the differences between all pairs\n    diffs = [abs(A[i] - A[j]) for i in range(N) for j in range(i + 1, N)]\n    initial_gcd = compute_gcd_of_list(diffs)\n    \n    # Check all divisors of the initial GCD\n    max_divisor = 1\n    for d in range(1, initial_gcd + 1):\n        if initial_gcd % d == 0:\n            # Check if we can make all elements divisible by d\n            if all((a % d) <= K for a in A):\n                max_divisor = d\n    \n    return max_divisor\n\n# Read input\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Compute and print the result\nprint(max_divisor_after_operations(N, K, A))"}
{"solution": "import sys\n\ndef main():\n    x = int(sys.stdin.readline().strip())\n    t = 0\n    n = 0\n    while x < 2**30:\n        t += 1\n        n = (t-1)//2\n        x = x ^ (2**n - 1)\n        x += 1\n    print(t)\n    for i in range(t//2):\n        print(n)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Find the minimum number of hours required to water the garden\nmin_hours = 1000000000\nfor i in range(n):\n    if k % a[i] == 0:\n        min_hours = min(min_hours, k // a[i])\n\nprint(min_hours)"}
{"solution": "def can_grasshopper_reach_insect(line, k):\n    # Initialize variables\n    n = len(line)\n    start_index = line.index(\"G\")\n    end_index = line.index(\"T\")\n    jumps = 0\n\n    # Check if the grasshopper can reach the insect\n    while start_index!= end_index:\n        # Check if the grasshopper can make a jump\n        if start_index + k <= n - 1 and line[start_index + k] == \".\":\n            start_index += k\n            jumps += 1\n        else:\n            break\n\n    # Return the result\n    if jumps > 0:\n        return \"YES\"\n    else:\n        return \"NO\""}
{"solution": "import math\n\ndef get_point_of_aiming(y1, y2, yw, xb, yb, r):\n    # Calculate the angle of incidence\n    angle = math.atan((yb - yw) / (xb - yw))\n    \n    # Calculate the distance from the center of the ball to the point of aiming\n    distance = math.sqrt((xb - yw) ** 2 + (yb - yw) ** 2)\n    \n    # Calculate the abscissa of the point of aiming\n    xw = xb + distance * math.cos(angle)\n    \n    # Check if the point of aiming is within the bounds of the field\n    if xw >= 0 and xw <= 10 ** 6:\n        return xw\n    else:\n        return -1\n\n# Test the function with the given examples\nprint(get_point_of_aiming(4, 10, 13, 10, 3, 1))  # Output: 4.3750000000\nprint(get_point_of_aiming(1, 4, 6, 2, 2, 1))  # Output: -1\nprint(get_point_of_aiming(3, 10, 15, 17, 9, 2))  # Output: 11.3333333333"}
{"solution": "import sys\n\ndef get_min_missed_meals(b, d, s):\n    # Initialize variables\n    missed_meals = 0\n    arrival_day = 0\n    departure_day = 0\n\n    # Check if Vasiliy arrived before breakfast\n    if b > 0:\n        arrival_day = 1\n        missed_meals += 1\n\n    # Check if Vasiliy had breakfast\n    if b > 1:\n        missed_meals += 1\n\n    # Check if Vasiliy had dinner\n    if d > 0:\n        missed_meals += 1\n\n    # Check if Vasiliy had supper\n    if s > 0:\n        missed_meals += 1\n\n    # Check if Vasiliy left after supper\n    if s > 1:\n        departure_day = 1\n        missed_meals += 1\n\n    # Return the minimum number of missed meals\n    return missed_meals\n\n# Read input from stdin\nb, d, s = map(int, sys.stdin.readline().split())\n\n# Get the minimum number of missed meals\nmissed_meals = get_min_missed_meals(b, d, s)\n\n# Print the output to stdout\nprint(missed_meals)"}
{"solution": "import sys\n\ndef solve(n, a):\n    x, y = 0, 0\n    for i in range(n):\n        if a[i] == x * y + 1:\n            x += 1\n        elif a[i] == x * y + y + 1:\n            y += 1\n        else:\n            return \"NO\"\n    return \"YES\\n\" + str(x) + \" \" + str(y)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(solve(n, a))"}
{"solution": "import sys\n\ndef get_subsequence(a, b):\n    # Initialize variables\n    subsequence = \"\"\n    i, j = 0, 0\n\n    # Loop through both strings\n    while i < len(a) and j < len(b):\n        # If the current character in a is the same as the current character in b, add it to the subsequence\n        if a[i] == b[j]:\n            subsequence += a[i]\n            i += 1\n            j += 1\n        # If the current character in a is not the same as the current character in b, move on to the next character in a\n        else:\n            i += 1\n\n    # Return the subsequence\n    return subsequence\n\n# Get input from stdin\na = sys.stdin.readline().strip()\nb = sys.stdin.readline().strip()\n\n# Get the subsequence\nsubsequence = get_subsequence(a, b)\n\n# Print the subsequence\nprint(subsequence)"}
{"solution": "def minimal_stones(n, s):\n    current_stones = 0\n    min_stones = 0\n    \n    for char in s:\n        if char == '+':\n            current_stones += 1\n        elif char == '-':\n            current_stones -= 1\n        min_stones = min(min_stones, current_stones)\n    \n    return max(0, -min_stones)\n\n# Example usage:\nn = int(input())\ns = input().strip()\nprint(minimal_stones(n, s))"}
{"solution": "n = int(input())\na, b, c = map(int, input().split())\n\n# Calculate the maximum number of liters of kefir that Kolya can drink\nmax_liters = n // b\n\n# If the number of liters is not a whole number, round it up\nif n % b!= 0:\n    max_liters += 1\n\n# If the number of liters is greater than the number of plastic bottles,\n# then the maximum number of liters is the number of plastic bottles\nif max_liters > a:\n    max_liters = a\n\n# If the number of liters is greater than the number of glass bottles,\n# then the maximum number of liters is the number of glass bottles\nif max_liters > b:\n    max_liters = b\n\n# Print the maximum number of liters of kefir that Kolya can drink\nprint(max_liters)"}
{"solution": "n = int(input())\nk1 = int(input())\nk2 = int(input())\n\n# Initialize the stacks\nstack1 = [int(x) for x in input().split()]\nstack2 = [int(x) for x in input().split()]\n\n# Initialize the number of fights\nfights = 0\n\n# While both stacks are not empty\nwhile stack1 and stack2:\n    # Get the top card from each stack\n    card1 = stack1.pop()\n    card2 = stack2.pop()\n    \n    # If the cards are equal, continue the game\n    if card1 == card2:\n        continue\n    \n    # If the first card is greater, add it to the bottom of the second stack\n    if card1 > card2:\n        stack2.append(card1)\n        stack2.append(card2)\n    \n    # If the second card is greater, add it to the bottom of the first stack\n    else:\n        stack1.append(card2)\n        stack1.append(card1)\n    \n    # Increment the number of fights\n    fights += 1\n\n# If the game ends, print the number of fights and the winner\nif not stack1 and not stack2:\n    print(fights, 1)\n\n# If the game won't end, print -1\nelse:\n    print(-1)"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    \n    has_upper = False\n    has_lower = False\n    has_digit = False\n    \n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n    \n    if has_upper and has_lower and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\"\n\n# Example usage\npassword = input().strip()\nprint(check_password_complexity(password))"}
{"solution": "def solve(n, a, b):\n    # Initialize the number of exchanges to 0\n    exchanges = 0\n\n    # Create a dictionary to store the number of students with each academic performance\n    performance_count = {}\n    for i in range(1, 6):\n        performance_count[i] = 0\n\n    # Loop through the students in group A and increment the count for their academic performance\n    for i in range(n):\n        performance_count[a[i]] += 1\n\n    # Loop through the students in group B and increment the count for their academic performance\n    for i in range(n):\n        performance_count[b[i]] += 1\n\n    # Loop through the academic performances and find the minimum number of exchanges needed to balance the groups\n    for i in range(1, 6):\n        # If the number of students with the current academic performance is not equal in both groups, increment the number of exchanges\n        if performance_count[i]!= n / 2:\n            exchanges += abs(performance_count[i] - n / 2)\n\n    # Return the minimum number of exchanges\n    return exchanges"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nhorizontal_streets = input()\nvertical_streets = input()\n\n# Check if the pattern meets the mayor's criteria\nif len(horizontal_streets)!= n or len(vertical_streets)!= m:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the horizontal streets are one-way\nif not all(horizontal_streets[i] in [\"<\", \">\"] for i in range(n)):\n    print(\"NO\")\n    sys.exit()\n\n# Check if the vertical streets are one-way\nif not all(vertical_streets[i] in [\"^\", \"v\"] for i in range(m)):\n    print(\"NO\")\n    sys.exit()\n\n# Check if the streets are connected\nif not all(horizontal_streets[i] == \"<\" and horizontal_streets[i + 1] == \">\" for i in range(n - 1)):\n    print(\"NO\")\n    sys.exit()\n\nif not all(vertical_streets[i] == \"^\" and vertical_streets[i + 1] == \"v\" for i in range(m - 1)):\n    print(\"NO\")\n    sys.exit()\n\n# Check if the junctions are reachable\nreachable = set()\nfor i in range(n):\n    for j in range(m):\n        if horizontal_streets[i] == \"<\" and vertical_streets[j] == \"^\":\n            reachable.add((i, j))\n\nfor i in range(n):\n    for j in range(m):\n        if horizontal_streets[i] == \">\" and vertical_streets[j] == \"v\":\n            reachable.add((i, j))\n\nif len(reachable)!= n * m:\n    print(\"NO\")\n    sys.exit()\n\nprint(\"YES\")"}
{"solution": "  import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Check if the expression is possible to make false\nif a[0] == 1 and a[1] == 0:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 0 and a[1] == 1:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 1 and a[1] == 1:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 0 and a[1] == 0:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 1 and a[1] == 0 and a[2] == 1:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 0 and a[1] == 1 and a[2] == 0:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 1 and a[1] == 1 and a[2] == 0:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 0 and a[1] == 0 and a[2] == 1:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 1 and a[1] == 0 and a[2] == 1 and a[3] == 0:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 0 and a[1] == 1 and a[2] == 0 and a[3] == 1:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 1 and a[1] == 1 and a[2] == 0 and a[3] == 1:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 0 and a[1] == 0 and a[2] == 1 and a[3] == 0:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 1 and a[1] == 0 and a[2] == 1 and a[3] == 0 and a[4] == 1:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 0 and a[1] == 1 and a[2] == 0 and a[3] == 1 and a[4] == 0:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 1 and a[1] == 1 and a[2] == 0 and a[3] == 1 and a[4] == 0:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 0 and a[1] == 0 and a[2] == 1 and a[3] == 0 and a[4] == 1:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 1 and a[1] == 0 and a[2] == 1 and a[3] == 0 and a[4] == 1 and a[5] == 0:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 0 and a[1] == 1 and a[2] == 0 and a[3] == 1 and a[4] == 0 and a[5] == 1:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 1 and a[1] == 1 and a[2] == 0 and a[3] == 1 and a[4] == 0 and a[5] == 1:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 0 and a[1] == 0 and a[2] == 1 and a[3] == 0 and a[4] == 1 and a[5] == 0:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 1 and a[1] == 0 and a[2] == 1 and a[3] == 0 and a[4] == 1 and a[5] == 0 and a[6] == 1:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 0 and a[1] == 1 and a[2] == 0 and a[3] == 1 and a[4] == 0 and a[5] == 1 and a[6] == 0:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the expression is possible to make false\nif a[0] == 1 and a[1] == 1 and a[2] == 0 and a[3] == 1 and a["}
{"solution": "import sys\n\nn, m = map(int, sys.stdin.readline().split())\n\na = n\nb = m\n\nwhile a!= 0 and b!= 0:\n    if a >= 2 * b:\n        a -= 2 * b\n    elif b >= 2 * a:\n        b -= 2 * a\n    else:\n        break\n\nprint(a, b)"}
{"solution": "  import sys\n\ndef find_k_divisible_numbers(k, a, b):\n    count = 0\n    for x in range(a, b+1):\n        if x % k == 0:\n            count += 1\n    return count\n\nif __name__ == '__main__':\n    k, a, b = map(int, sys.stdin.readline().split())\n    print(find_k_divisible_numbers(k, a, b))"}
{"solution": "import sys\n\nk = int(sys.stdin.readline())\n\n# Calculate the position of the digit in the sequence\nposition = (k - 1) * 10\n\n# Calculate the digit\ndigit = (position // 10) % 10\n\nprint(digit)"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\ns = sys.stdin.readline().strip()\n\n# Calculate the number of moves each player will make\nmoves_each = (n - 11) // 2\n\n# Count the number of '8's in the first n - 10 characters\ncount_8s = s[:n - 10].count('8')\n\n# Vasya wins if there are more '8's than the number of moves Petya can make\nif count_8s > moves_each:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "  import sys\n\nn, x, pos = map(int, sys.stdin.readline().split())\n\n# Initialize the number of valid permutations to 0\nvalid_permutations = 0\n\n# Iterate over all possible permutations of size n\nfor i in range(n):\n    # Initialize the permutation array\n    permutation = [0] * n\n    \n    # Fill the permutation array with the numbers 1 to n\n    for j in range(n):\n        permutation[j] = j + 1\n    \n    # Swap the elements at positions pos and i\n    permutation[pos], permutation[i] = permutation[i], permutation[pos]\n    \n    # Check if the permutation contains x at position pos\n    if permutation[pos] == x:\n        valid_permutations += 1\n\n# Print the remainder of the division of the number of valid permutations by 10^9+7\nprint(valid_permutations % (10**9 + 7))"}
{"solution": "import re\n\ndef can_encode_message(string, k):\n    # Check if the string contains only lowercase letters, snowflakes, and candy canes\n    if not re.match(r'^[a-z*?]+$', string):\n        return False\n    \n    # Check if the string has the required length\n    if len(string)!= k:\n        return False\n    \n    # Check if the string can be decoded as a message\n    message = decode_message(string)\n    if len(message)!= k:\n        return False\n    \n    # Check if the message is valid\n    if not re.match(r'^[a-z]+$', message):\n        return False\n    \n    return True\n\ndef decode_message(string):\n    # Initialize the decoded message\n    message = ''\n    \n    # Iterate over the characters in the string\n    for i in range(len(string)):\n        # If the current character is a letter, add it to the message\n        if string[i].isalpha():\n            message += string[i]\n        # If the current character is a snowflake, remove the previous letter\n        elif string[i] == '*':\n            message = message[:-1]\n        # If the current character is a candy cane, leave the previous letter\n        elif string[i] == '?':\n            pass\n    \n    return message\n\ndef main():\n    string, k = input().split()\n    k = int(k)\n    \n    if can_encode_message(string, k):\n        message = decode_message(string)\n        print(message)\n    else:\n        print('Impossible')\n\nif __name__ == '__main__':\n    main()"}
{"solution": "import math\n\ndef get_min_turns(x):\n    # Convert the angle to radians\n    angle = math.radians(x)\n\n    # Calculate the deviation from \"true up\"\n    deviation = abs(angle - math.pi / 2)\n\n    # Calculate the minimum number of turns required\n    turns = int(deviation / (math.pi / 2))\n\n    return turns\n\n# Test the function\nprint(get_min_turns(60))  # Should print 1\nprint(get_min_turns(-60))  # Should print 3"}
{"solution": "def can_get_spheres(blue, violet, orange, x, y, z):\n    # Initialize the number of spheres to be transformed\n    num_spheres_to_transform = 0\n\n    # Initialize the number of spheres to be obtained\n    num_spheres_to_obtain = x + y + z\n\n    # While there are still spheres to be obtained\n    while num_spheres_to_obtain > 0:\n        # If there are still blue spheres to be obtained\n        if blue > 0 and num_spheres_to_obtain > 0:\n            # Transform as many blue spheres as possible into violet spheres\n            num_spheres_to_transform = min(blue, num_spheres_to_obtain)\n            blue -= num_spheres_to_transform\n            violet += num_spheres_to_transform\n            num_spheres_to_obtain -= num_spheres_to_transform\n\n        # If there are still violet spheres to be obtained\n        if violet > 0 and num_spheres_to_obtain > 0:\n            # Transform as many violet spheres as possible into orange spheres\n            num_spheres_to_transform = min(violet, num_spheres_to_obtain)\n            violet -= num_spheres_to_transform\n            orange += num_spheres_to_transform\n            num_spheres_to_obtain -= num_spheres_to_transform\n\n        # If there are still orange spheres to be obtained\n        if orange > 0 and num_spheres_to_obtain > 0:\n            # Transform as many orange spheres as possible into blue spheres\n            num_spheres_to_transform = min(orange, num_spheres_to_obtain)\n            orange -= num_spheres_to_transform\n            blue += num_spheres_to_transform\n            num_spheres_to_obtain -= num_spheres_to_transform\n\n    # If all the required spheres have been obtained, return \"Yes\"\n    if num_spheres_to_obtain == 0:\n        return \"Yes\"\n    # Otherwise, return \"No\"\n    else:\n        return \"No\"\n\n# Test the function with the given input\nblue, violet, orange, x, y, z = map(int, input().split())\nprint(can_get_spheres(blue, violet, orange, x, y, z))"}
{"solution": "def solve(n, k, m):\n    count = 0\n    for x in range(1, 10**n):\n        if str(x).count(\"0\") == n:\n            for y in range(1, 10**k):\n                if y % k == 0 and str(y)[-n:] == str(x):\n                    count += 1\n    return count % m"}
{"solution": "def max_team_size(l, r, a):\n    if l > r:\n        l, r = r, l  # Ensure l is always the smaller or equal group\n    \n    # Use ambidexters to balance the difference\n    d = r - l\n    if a >= d:\n        l += d\n        a -= d\n        # Now l == r, distribute remaining ambidexters equally\n        l += a // 2\n        r += a // 2\n    else:\n        l += a\n        # Not enough ambidexters to balance completely, r remains larger\n    \n    # The maximum team size is twice the smaller group\n    return 2 * min(l, r)\n\n# Example usage\nprint(max_team_size(1, 4, 2))  # Output: 6\nprint(max_team_size(5, 5, 5))  # Output: 14\nprint(max_team_size(0, 2, 0))  # Output: 0"}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\n# Initialize the number of moves as 0\nmoves = 0\n\n# Initialize the number of stones on each manhole as 1\nstones = [1] * n\n\n# Initialize the number of coins on each manhole as 1\ncoins = [1] * n\n\n# Initialize the current position as the k-th manhole from the left\ncurrent_position = k\n\n# While there are still stones on the manholes\nwhile stones.count(1) > 0:\n    # If the current position is not the leftmost manhole\n    if current_position > 0:\n        # Throw a stone from the current position to the leftmost manhole\n        stones[current_position] -= 1\n        stones[0] += 1\n        moves += 1\n    # If the current position is the leftmost manhole\n    else:\n        # Open the current position and pick the coin\n        coins[current_position] -= 1\n        moves += 1\n        # If there are still stones on the manhole\n        if stones[current_position] > 0:\n            # Throw a stone from the current position to the rightmost manhole\n            stones[current_position] -= 1\n            stones[n - 1] += 1\n            moves += 1\n        # If there are no stones on the manhole\n        else:\n            # Close the current position\n            moves += 1\n            # Move to the rightmost manhole\n            current_position = n - 1\n\n# Print the minimum number of moves\nprint(moves)"}
{"solution": "def get_tallest_tower(n, m):\n    # Initialize variables\n    two_block_heights = []\n    three_block_heights = []\n    tallest_tower = 0\n\n    # Get the heights of the towers made with two-block pieces\n    for i in range(n):\n        two_block_heights.append(i * 2 + 2)\n\n    # Get the heights of the towers made with three-block pieces\n    for i in range(m):\n        three_block_heights.append(i * 3 + 3)\n\n    # Find the tallest tower\n    for two_block_height in two_block_heights:\n        for three_block_height in three_block_heights:\n            if two_block_height + three_block_height > tallest_tower:\n                tallest_tower = two_block_height + three_block_height\n\n    return tallest_tower"}
{"solution": ""}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Check if the total number of soldiers is less than or equal to the number of seats\nif sum(a) <= 8 * n:\n    # Initialize a list to store the seats for each group\n    seats = [[] for _ in range(k)]\n    # Initialize a set to store the occupied seats\n    occupied_seats = set()\n    # Loop through each group\n    for i in range(k):\n        # Loop through each seat in the current row\n        for j in range(8):\n            # If the seat is not occupied, add it to the current group's seats\n            if j not in occupied_seats:\n                seats[i].append(j)\n                occupied_seats.add(j)\n                break\n        # If the current group has no seats, the arrangement is not possible\n        if not seats[i]:\n            print(\"NO\")\n            break\n    else:\n        print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\ndef solve(n, a):\n    # Calculate the cost of changing each stick's length\n    costs = [abs(a[i] - a[i-1]) for i in range(1, n)]\n\n    # Find the minimum cost and the corresponding value of t\n    min_cost = math.inf\n    t = 0\n    for i in range(1, n):\n        cost = costs[i-1]\n        if cost < min_cost:\n            min_cost = cost\n            t = i\n\n    # Print the value of t and the minimum cost\n    print(t, min_cost)\n\nn = int(input())\na = list(map(int, input().split()))\nsolve(n, a)"}
{"solution": "n, m = map(int, input().split())\n\n# Initialize a 2D array to store the map\nmap = [['.' for _ in range(m)] for _ in range(n)]\n\n# Read the map and store the coordinates of the stars\nstars = []\nfor i in range(n):\n    for j in range(m):\n        if map[i][j] == '*':\n            stars.append((i, j))\n\n# Find the minimum and maximum coordinates of the stars\nmin_x, min_y = min(stars, key=lambda x: x[0]), min(stars, key=lambda x: x[1])\nmax_x, max_y = max(stars, key=lambda x: x[0]), max(stars, key=lambda x: x[1])\n\n# Calculate the length and width of the rectangle that covers all the stars\nlength = max_x - min_x + 1\nwidth = max_y - min_y + 1\n\n# Find the maximum of the length and width\nmax_side = max(length, width)\n\n# Print the minimum possible side of the square that covers all the stars\nprint(max_side)"}
{"solution": "import math\n\ndef get_probability(n, k, a):\n    # Calculate the number of possible permutations of the array\n    num_permutations = math.factorial(n)\n    \n    # Calculate the number of permutations that result in a sorted array\n    num_sorted_permutations = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] <= a[j]:\n                num_sorted_permutations += 1\n    \n    # Calculate the probability that the array is sorted after k operations\n    probability = num_sorted_permutations / num_permutations\n    \n    # Raise the probability to the k-th power\n    probability = probability ** k\n    \n    # Calculate the modular inverse of the probability\n    modular_inverse = math.inverse_mod(probability, 1000000007)\n    \n    # Return the product of the probability and its modular inverse\n    return probability * modular_inverse\n\nn = int(input())\nk = int(input())\na = list(map(int, input().split()))\n\nprint(get_probability(n, k, a))"}
{"solution": "import sys\n\ndef get_min_seconds(x, y):\n    # Initialize variables\n    current_side_length = x\n    seconds = 0\n\n    # Loop until the current side length is equal to the target side length\n    while current_side_length!= y:\n        # Calculate the new side length based on the current side length\n        new_side_length = calculate_new_side_length(current_side_length)\n\n        # Update the current side length and increment the number of seconds\n        current_side_length = new_side_length\n        seconds += 1\n\n    # Return the minimum number of seconds required to reach the target side length\n    return seconds\n\ndef calculate_new_side_length(current_side_length):\n    # Calculate the new side length based on the current side length\n    new_side_length = current_side_length - 1\n\n    # If the new side length is less than 3, set it to 3\n    if new_side_length < 3:\n        new_side_length = 3\n\n    return new_side_length\n\n# Read the input from stdin\nx, y = map(int, input().split())\n\n# Calculate the minimum number of seconds required to reach the target side length\nresult = get_min_seconds(x, y)\n\n# Print the result to stdout\nprint(result)"}
{"solution": "import math\n\ndef get_degenerate_matrix(A):\n    a, b, c, d = A[0], A[1], A[2], A[3]\n    det = a*d - b*c\n    if det == 0:\n        return A\n    else:\n        return [a, b, c, d]\n\ndef get_norm(A):\n    return math.sqrt(A[0]**2 + A[1]**2 + A[2]**2 + A[3]**2)\n\ndef get_min_norm(A):\n    degenerate_matrix = get_degenerate_matrix(A)\n    return get_norm(degenerate_matrix)\n\nif __name__ == \"__main__\":\n    a, b, c, d = map(int, input().split())\n    A = [a, b, c, d]\n    print(get_min_norm(A))"}
{"solution": "n, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Initialize variables\none_seater_tables = a\ntwo_seater_tables = b\ndenied_service = 0\n\n# Iterate through the groups\nfor i, group in enumerate(groups):\n    # If the group consists of one person\n    if group == 1:\n        # If there is a vacant one-seater table\n        if one_seater_tables > 0:\n            # Seat the group at the vacant table\n            one_seater_tables -= 1\n        # If there are no vacant one-seater tables\n        else:\n            # If there is a vacant two-seater table\n            if two_seater_tables > 0:\n                # Seat the group at the vacant table\n                two_seater_tables -= 1\n            # If there are no vacant two-seater tables\n            else:\n                # Deny service to the group\n                denied_service += 1\n    # If the group consists of two people\n    else:\n        # If there is a vacant two-seater table\n        if two_seater_tables > 0:\n            # Seat the group at the vacant table\n            two_seater_tables -= 1\n        # If there are no vacant two-seater tables\n        else:\n            # Deny service to the group\n            denied_service += 1\n\n# Print the total number of people the restaurant denies service to\nprint(denied_service)"}
{"solution": "def solve(A, B, C, N):\n    if A + B + C!= N:\n        return -1\n    if A + B + C < N:\n        return -1\n    if A + B + C > N:\n        return -1\n    if A + B + C == N:\n        return N - (A + B + C)\n\nA, B, C, N = map(int, input().split())\nprint(solve(A, B, C, N))"}
{"solution": "  import math\n\ndef solve(x, k):\n    # Calculate the expected number of dresses after one year\n    expected_dresses = x * math.pow(2, k)\n    \n    # Calculate the expected number of dresses after one year, considering the probability of the wardrobe eating a dress\n    expected_dresses_with_probability = expected_dresses * (1 - 0.5)\n    \n    # Return the expected number of dresses modulo 10^9 + 7\n    return expected_dresses_with_probability % (10**9 + 7)\n\n# Test the function with the given examples\nassert solve(2, 0) == 4\nassert solve(2, 1) == 7\nassert solve(3, 2) == 21\n\n# Test the function with random inputs\nfor i in range(100):\n    x = random.randint(0, 10**18)\n    k = random.randint(0, 10**18)\n    expected_dresses = x * math.pow(2, k)\n    expected_dresses_with_probability = expected_dresses * (1 - 0.5)\n    assert solve(x, k) == expected_dresses_with_probability % (10**9 + 7)"}
{"solution": "import math\n\ndef calculate_probability(n, l, r):\n    # Calculate the probability of no inversions\n    probability = 1\n    for i in range(n):\n        probability *= (r[i] - l[i] + 1) / (r[i] - l[i] + 2)\n    return probability\n\nn = int(input())\nl = []\nr = []\nfor i in range(n):\n    l.append(int(input()))\n    r.append(int(input()))\n\nprobability = calculate_probability(n, l, r)\n\n# Calculate the value of xy^-1 modulo 998244353\nx = int(probability * 998244353)\ny = int(math.gcd(x, 998244353))\nxy_inv = x * y_inv\n\nprint(xy_inv)"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\ndef count_ways(n):\n    # Initialize a dictionary to store the number of ways to cut the stick\n    ways = {1: 1}\n\n    # Iterate from 2 to n\n    for i in range(2, n + 1):\n        # Initialize a variable to store the number of ways to cut the stick with length i\n        num_ways = 0\n\n        # Iterate over the keys in the dictionary\n        for j in ways:\n            # If the key is less than i, add the number of ways to cut the stick with length j to the number of ways to cut the stick with length i\n            if j < i:\n                num_ways += ways[j]\n\n        # Add the number of ways to cut the stick with length i to the dictionary\n        ways[i] = num_ways\n\n    # Return the number of ways to cut the stick with length n\n    return ways[n]\n\nprint(count_ways(n))"}
{"solution": "import sys\n\nn, s = map(int, input().split())\nvolumes = list(map(int, input().split()))\n\n# Initialize the minimum volume in each keg to the maximum possible value\nmin_volumes = [sys.maxsize] * n\n\n# Iterate through each keg and calculate the minimum volume\nfor i in range(n):\n    min_volumes[i] = min(volumes[i], s // n)\n\n# Find the minimum volume in all kegs\nmin_volume = min(min_volumes)\n\n# Check if the Fair Nut can pour his glass by the desired amount\nif min_volume * n < s:\n    print(-1)\nelse:\n    print(min_volume)"}
{"solution": "import math\n\ndef solve(h1, h2, a, b):\n    # Calculate the total distance the caterpillar needs to travel\n    total_distance = h2 - h1\n\n    # Calculate the number of days it takes the caterpillar to travel the total distance\n    days = total_distance / (a + b)\n\n    # Calculate the number of hours the caterpillar spends on the ground\n    hours_on_ground = days * b\n\n    # Calculate the number of hours the caterpillar spends in the air\n    hours_in_air = days * a\n\n    # Calculate the number of hours the caterpillar spends on the tree\n    hours_on_tree = 24 - hours_on_ground - hours_in_air\n\n    # Calculate the number of days Gabriel needs to wait to see the caterpillar get the apple\n    days_to_wait = math.ceil(hours_on_tree / 10)\n\n    return days_to_wait\n\nh1, h2, a, b = map(int, input().split())\nprint(solve(h1, h2, a, b))"}
{"solution": "import sys\n\ndef get_maximum_joy_units(candies, red_candy_weight, blue_candy_weight, red_candy_joy_units, blue_candy_joy_units):\n    # Initialize variables\n    total_joy_units = 0\n    red_candy_count = 0\n    blue_candy_count = 0\n\n    # Loop through the candies and calculate the maximum number of joy units\n    for candy in candies:\n        if candy == \"red\":\n            red_candy_count += 1\n            total_joy_units += red_candy_joy_units\n        elif candy == \"blue\":\n            blue_candy_count += 1\n            total_joy_units += blue_candy_joy_units\n\n    # Calculate the maximum number of joy units that can be obtained by eating a whole candy\n    max_joy_units = total_joy_units + (red_candy_count * red_candy_weight + blue_candy_count * blue_candy_weight)\n\n    return max_joy_units\n\n# Read input from stdin\ncandies, red_candy_weight, blue_candy_weight, red_candy_joy_units, blue_candy_joy_units = map(int, input().split())\n\n# Calculate the maximum number of joy units\nmax_joy_units = get_maximum_joy_units(candies, red_candy_weight, blue_candy_weight, red_candy_joy_units, blue_candy_joy_units)\n\n# Print the maximum number of joy units\nprint(max_joy_units)"}
{"solution": "import sys\n\ndef get_min_steps(start_pos, finish_pos):\n    x1, y1 = start_pos\n    x2, y2 = finish_pos\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    if dx > dy:\n        return dx\n    else:\n        return dy\n\nif __name__ == \"__main__\":\n    x1, y1 = map(int, input().split())\n    x2, y2 = map(int, input().split())\n    print(get_min_steps((x1, y1), (x2, y2)))"}
{"solution": "import sys\n\nn = int(input())\nfractions = input()\n\n# Initialize variables\ndepublicans = 0\nremocrats = 0\ndenied_votes = 0\n\n# Iterate through each employee and their fraction\nfor i in range(n):\n    if fractions[i] == 'D':\n        depublicans += 1\n    elif fractions[i] == 'R':\n        remocrats += 1\n\n# Iterate through each employee and their statements\nfor i in range(n):\n    # If the employee has no right to vote, skip their turn\n    if denied_votes > 0:\n        denied_votes -= 1\n        continue\n\n    # If the employee is from the depublicans fraction, deny the vote of the remocrats\n    if fractions[i] == 'D':\n        remocrats -= 1\n\n    # If the employee is from the remocrats fraction, deny the vote of the depublicans\n    elif fractions[i] == 'R':\n        depublicans -= 1\n\n    # If the vote is denied, add it to the list of denied votes\n    denied_votes += 1\n\n# Print the outcome of the vote\nif depublicans > remocrats:\n    print('D')\nelse:\n    print('R')"}
{"solution": "import sys\n\ndef solve(a, b, x, y):\n    count = 0\n    for w in range(1, a+1):\n        for h in range(1, b+1):\n            if w/h == x/y and w <= a and h <= b:\n                count += 1\n    return count\n\nif __name__ == \"__main__\":\n    a, b, x, y = map(int, sys.stdin.readline().split())\n    print(solve(a, b, x, y))"}
{"solution": "import math\n\ndef trailing_zeros(n, b):\n    # Calculate the factorial of n\n    factorial = math.factorial(n)\n    \n    # Convert the factorial to the given base\n    factorial_base = int(factorial, b)\n    \n    # Count the number of trailing zeros in the base representation of the factorial\n    trailing_zeros = 0\n    while factorial_base % b == 0:\n        trailing_zeros += 1\n        factorial_base //= b\n    \n    return trailing_zeros\n\nn, b = map(int, input().split())\nprint(trailing_zeros(n, b))"}
{"solution": "import sys\n\ndef frog(m, a, b):\n    # Initialize a dictionary to store the number of distinct integers the frog can reach at each position\n    f = {0: 1}\n\n    # Iterate through the positions from 1 to m\n    for i in range(1, m+1):\n        # If the frog can reach the current position, add it to the dictionary\n        if i-a >= 0 and i+b <= m:\n            f[i] = f[i-a] + f[i+b]\n        # If the frog can't reach the current position, set its value to 0\n        else:\n            f[i] = 0\n\n    # Return the sum of the values in the dictionary\n    return sum(f.values())\n\nif __name__ == '__main__':\n    m, a, b = map(int, sys.stdin.readline().split())\n    print(frog(m, a, b))"}
{"solution": "import sys\n\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Check if the length of the sequence is odd\nif n % 2 == 1:\n    # Check if the first and last elements of the sequence are odd\n    if sequence[0] % 2 == 1 and sequence[-1] % 2 == 1:\n        # Check if the sequence can be divided into an odd number of subsegments\n        subsegments = []\n        for i in range(n):\n            if sequence[i] % 2 == 1:\n                subsegments.append(sequence[i])\n        if len(subsegments) % 2 == 1:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n    else:\n        print(\"No\")\nelse:\n    print(\"No\")"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    # Find the slope of the line between the two given trees\n    slope = (y2 - y1) / (x2 - x1)\n\n    # Find the x-coordinate of the third tree\n    x3 = (slope ** 2 - 1) / (slope ** 2 + 1)\n\n    # Find the y-coordinate of the third tree\n    y3 = slope * (x3 - x1) + y1\n\n    # Find the x-coordinate of the fourth tree\n    x4 = 1 - x3\n\n    # Find the y-coordinate of the fourth tree\n    y4 = slope * (x4 - x1) + y1\n\n    return x3, y3, x4, y4"}
{"solution": "import sys\n\ndef calculate_f_n(x, y, n):\n    if n == 1:\n        return x\n    elif n == 2:\n        return y\n    else:\n        return (calculate_f_n(x, y, n - 1) + calculate_f_n(x, y, n + 1)) % 1000000007\n\nif __name__ == \"__main__\":\n    x, y = map(int, input().split())\n    n = int(input())\n    print(calculate_f_n(x, y, n))"}
{"solution": "n = int(input())\narr = list(map(int, input().split()))\n\n# Initialize the number of new arrays to 0\nk = 0\n\n# Iterate through the array and check if the sum of elements in each subarray is not zero\nfor i in range(n):\n    subarray_sum = 0\n    for j in range(i, n):\n        subarray_sum += arr[j]\n        if subarray_sum == 0:\n            break\n    if subarray_sum!= 0:\n        k += 1\n\n# Print \"YES\" if the number of new arrays is greater than 0\nif k > 0:\n    print(\"YES\")\n    print(k)\n    for i in range(k):\n        print(i + 1, i + 2)\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn, m, k = map(int, input().split())\n\n# Initialize the minimum score to 0\nmin_score = 0\n\n# Iterate through the questions\nfor i in range(n):\n    # If the question is answered correctly, add 1 point to the score\n    if i in m:\n        min_score += 1\n    # If the question is answered incorrectly, reset the score to 0\n    else:\n        min_score = 0\n    # If the counter reaches k, double the score\n    if min_score == k:\n        min_score *= 2\n\n# Print the remainder of the minimum score modulo 1000000009\nprint(min_score % 1000000009)"}
{"solution": ""}
{"solution": "n, m = map(int, input().split())\nflats = [int(input()) for _ in range(m)]\n\n# Sort the flats in ascending order\nflats.sort()\n\n# Initialize the floor number\nfloor = 1\n\n# Iterate through the flats and increment the floor number\n# if the flat is not on the current floor\nfor flat in flats:\n    if flat!= floor:\n        floor += 1\n\n# Print the floor number\nprint(floor)"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    board = [[board1[i], board2[i]] for i in range(n)]\n    \n    # Define the four possible shapes of the bishwock\n    bishwock_shapes = [\n        [(0, 0), (0, 1), (1, 0)],  # Original L shape\n        [(0, 0), (0, 1), (1, 1)],  # Rotated 90 degrees\n        [(0, 1), (1, 0), (1, 1)],  # Rotated 180 degrees\n        [(0, 0), (1, 0), (1, 1)]   # Rotated 270 degrees\n    ]\n    \n    def can_place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            if nx >= 2 or ny >= n or board[ny][nx] == 'X':\n                return False\n        return True\n    \n    def place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            board[ny][nx] = 'X'\n    \n    count = 0\n    for y in range(n):\n        for x in range(2):\n            for shape in bishwock_shapes:\n                if can_place_bishwock(x, y, shape):\n                    place_bishwock(x, y, shape)\n                    count += 1\n                    break\n    \n    return count\n\n# Example usage\nboard1 = \"00X00X0XXX0\"\nboard2 = \"0XXX0X00X00\"\nprint(max_bishwocks(board1, board2))  # Output: 4"}
{"solution": "n = int(input())\ns = input().strip()\n\nmax_length = 0\ncurrent_set = set()\n\nfor char in s:\n    if char.islower():\n        current_set.add(char)\n    else:\n        max_length = max(max_length, len(current_set))\n        current_set.clear()\n\nmax_length = max(max_length, len(current_set))\n\nprint(max_length)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize b and c as empty sequences\nb = []\nc = []\n\n# Partition the sequence a into b and c\nfor i in range(n):\n    if a[i] % 2 == 0:\n        b.append(a[i])\n    else:\n        c.append(a[i])\n\n# Calculate the sum of elements in b and c\nB = sum(b)\nC = sum(c)\n\n# Print the maximum possible value of B - C\nprint(B - C)"}
{"solution": "import sys\n\ndef get_min_refuels(a, b, f, k):\n    # Initialize variables\n    curr_pos = 0\n    curr_fuel = b\n    refuels = 0\n\n    # Iterate through each journey\n    for i in range(k):\n        # Calculate the distance to the next refueling point\n        dist_to_refuel = f - curr_pos\n\n        # Check if the bus can make the journey without refueling\n        if dist_to_refuel <= curr_fuel:\n            # Update the current position and fuel level\n            curr_pos = f\n            curr_fuel = b\n\n            # Increment the number of refuels\n            refuels += 1\n\n        # Check if the bus can make the journey with refueling\n        elif dist_to_refuel > curr_fuel:\n            # Update the current position and fuel level\n            curr_pos = f\n            curr_fuel = b\n\n            # Increment the number of refuels\n            refuels += 1\n\n            # Calculate the distance to the next refueling point\n            dist_to_refuel = f - curr_pos\n\n            # Check if the bus can make the journey with refueling\n            if dist_to_refuel > curr_fuel:\n                return -1\n\n    return refuels\n\n# Read input from stdin\na, b, f, k = map(int, input().split())\n\n# Get the minimum number of refuels\nmin_refuels = get_min_refuels(a, b, f, k)\n\n# Print the minimum number of refuels\nprint(min_refuels)"}
{"solution": "n, p, q = map(int, input().split())\ns = input()\n\nif len(s) % (p + q)!= 0:\n    print(-1)\n    exit()\n\nk = len(s) // (p + q)\nresult = []\nfor i in range(k):\n    result.append(s[i * (p + q):i * (p + q) + p])\n    result.append(s[i * (p + q) + p:i * (p + q) + p + q])\n\nprint(k)\nfor r in result:\n    print(r)"}
{"solution": "import sys\n\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\n# Initialize the starting point\nx = 0\n\n# Initialize the jump length\njump_length = 0\n\n# Initialize the run length\nrun_length = 0\n\n# Initialize the jump count\njump_count = 0\n\n# Initialize the run count\nrun_count = 0\n\n# Initialize the finish flag\nfinish = False\n\n# Loop through the obstacles\nfor i in range(n):\n    # Check if the obstacle is within the minimum run length\n    if obstacles[i] - x < s:\n        # Increment the run length\n        run_length += obstacles[i] - x\n        # Increment the run count\n        run_count += 1\n        # Set the starting point to the obstacle\n        x = obstacles[i]\n    # Check if the obstacle is within the maximum jump length\n    elif obstacles[i] - x > d:\n        # Increment the jump length\n        jump_length += obstacles[i] - x\n        # Increment the jump count\n        jump_count += 1\n        # Set the starting point to the obstacle\n        x = obstacles[i]\n    # Check if the obstacle is within the minimum run length and maximum jump length\n    else:\n        # Increment the run length\n        run_length += obstacles[i] - x\n        # Increment the run count\n        run_count += 1\n        # Set the starting point to the obstacle\n        x = obstacles[i]\n\n# Check if the athlete can reach the finish point\nif x < m:\n    # Increment the run length\n    run_length += m - x\n    # Increment the run count\n    run_count += 1\n    # Set the finish flag to True\n    finish = True\n\n# Print the output\nif finish:\n    print(\"RUN\", run_length)\n    print(\"JUMP\", jump_length)\n    print(\"RUN\", run_length)\n    print(\"JUMP\", jump_length)\nelse:\n    print(\"IMPOSSIBLE\")"}
{"solution": "import sys\n\ns, x = map(int, input().split())\n\n# Check if s - x is even\nif (s - x) % 2 == 0:\n    # Check if b is positive\n    b = (s - x) // 2\n    if b > 0:\n        # Check if a is positive\n        a = s - b\n        if a > 0:\n            # Print the number of solutions\n            print(2)\n        else:\n            print(0)\n    else:\n        print(0)\nelse:\n    print(0)"}
{"solution": "n, k = map(int, input().split())\n\n# Initialize the skewers as initially turned over\nskewers = [True] * n\n\n# Initialize the number of actions as 0\nactions = 0\n\n# Iterate through each skewer\nfor i in range(n):\n    # If the skewer is initially turned over, turn it over again\n    if skewers[i]:\n        skewers[i] = False\n        actions += 1\n\n    # Turn over the k closest skewers from each side of the current skewer\n    for j in range(max(0, i - k), min(n, i + k + 1)):\n        if j!= i and skewers[j]:\n            skewers[j] = False\n            actions += 1\n\n# Print the number of actions\nprint(actions)\n\n# Print the skewers to be turned over\nfor i in range(n):\n    if skewers[i]:\n        print(i + 1)"}
{"solution": "import math\n\ndef min_operations_to_square(n):\n    n_str = str(n)\n    n_len = len(n_str)\n    \n    # Generate all possible squares up to the maximum possible value\n    max_square_root = int(math.sqrt(2 * 10**9)) + 1\n    squares = [str(i * i) for i in range(1, max_square_root + 1)]\n    \n    def is_subsequence(small, large):\n        it = iter(large)\n        return all(char in it for char in small)\n    \n    min_deletions = float('inf')\n    \n    for square in squares:\n        if is_subsequence(square, n_str):\n            deletions = n_len - len(square)\n            min_deletions = min(min_deletions, deletions)\n    \n    return min_deletions if min_deletions!= float('inf') else -1\n\n# Example usage:\nprint(min_operations_to_square(8314))  # Output: 2\nprint(min_operations_to_square(625))   # Output: 0\nprint(min_operations_to_square(333))   # Output: -1"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\ndef f(p):\n    gcds = []\n    for i in range(len(p)):\n        gcds.append(gcd(p[i], p[i+1]))\n    return len(set(gcds))\n\ndef gcd(a, b):\n    while b!= 0:\n        a, b = b, a % b\n    return a\n\ndef count_permutations(n):\n    permutations = []\n    for i in range(n):\n        for j in range(i+1, n):\n            permutations.append([i, j])\n    return len(permutations)\n\ndef solve(n):\n    max_f = 0\n    count = 0\n    for i in range(count_permutations(n)):\n        p = permutations[i]\n        f_value = f(p)\n        if f_value > max_f:\n            max_f = f_value\n            count = 1\n        elif f_value == max_f:\n            count += 1\n    return count\n\npermutations = []\nfor i in range(n):\n    for j in range(i+1, n):\n        permutations.append([i, j])\n\nprint(solve(n))"}
{"solution": "def minimum_jump_ability(s):\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    positions = [-1]  # Start position before the first character\n    \n    # Collect positions of all vowels\n    for i, char in enumerate(s):\n        if char in vowels:\n            positions.append(i)\n    \n    positions.append(len(s))  # End position after the last character\n    \n    # Calculate maximum distance between consecutive positions\n    max_distance = 0\n    for i in range(1, len(positions)):\n        max_distance = max(max_distance, positions[i] - positions[i - 1])\n    \n    return max_distance"}
{"solution": "def can_distribute_candies(a1, a2, a3, a4):\n    # Calculate the sum of candies in each bag\n    sum1 = a1 + a2\n    sum2 = a3 + a4\n\n    # Check if the sums are equal\n    if sum1 == sum2:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Test the function with the given input\nprint(can_distribute_candies(1, 7, 11, 5))\nprint(can_distribute_candies(7, 3, 2, 5))"}
{"solution": "import sys\n\ndef solve(N, pie_sizes):\n    # Initialize the sums of the slices eaten by Alice and Bob\n    alice_sum = 0\n    bob_sum = 0\n\n    # Iterate through the pies in the order given\n    for i in range(N):\n        # If the current pie is odd, Alice eats it\n        if pie_sizes[i] % 2 == 1:\n            alice_sum += pie_sizes[i]\n        # If the current pie is even, Bob eats it\n        else:\n            bob_sum += pie_sizes[i]\n\n    # Return the sums of the slices eaten by Alice and Bob\n    return alice_sum, bob_sum\n\nif __name__ == \"__main__\":\n    N = int(input())\n    pie_sizes = list(map(int, input().split()))\n    alice_sum, bob_sum = solve(N, pie_sizes)\n    print(alice_sum, bob_sum)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize variables\nm = 0\nb = [0] * n\n\n# Iterate through the sequence\nfor i in range(n):\n    # Find the minimum number of variables needed to perform the operation\n    min_vars = 1\n    for j in range(i):\n        if a[i] - a[j] in b:\n            min_vars += 1\n    # Update the minimum number of variables needed\n    if min_vars > m:\n        m = min_vars\n\n# Print the minimum number of variables needed\nprint(m)"}
{"solution": "n = int(input())\npiles = list(map(int, input().split()))\n\n# Count the number of piles with an odd number of stones\nodd_count = sum(1 for pile in piles if pile % 2!= 0)\n\n# Determine the winner\nif odd_count % 2 == 0:\n    print(\"Alice\")\nelse:\n    print(\"Bob\")"}
{"solution": "import sys\n\nn = int(input())\narr = list(map(int, input().split()))\n\n# Check if all elements are equal\nif len(set(arr)) == 1:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of all elements is divisible by n\nif sum(arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the product of all elements is divisible by n\nif reduce(lambda x, y: x * y, arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the squares of all elements is divisible by n\nif sum(x**2 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the cubes of all elements is divisible by n\nif sum(x**3 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the fourth powers of all elements is divisible by n\nif sum(x**4 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the fifth powers of all elements is divisible by n\nif sum(x**5 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the sixth powers of all elements is divisible by n\nif sum(x**6 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the seventh powers of all elements is divisible by n\nif sum(x**7 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the eighth powers of all elements is divisible by n\nif sum(x**8 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the ninth powers of all elements is divisible by n\nif sum(x**9 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the tenth powers of all elements is divisible by n\nif sum(x**10 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\nprint(\"NO\")"}
{"solution": "import sys\n\nN = int(input())\nS = input()\n\n# Initialize the maximum length of a non-empty string that occurs twice or more in S as contiguous substrings without overlapping\nmax_len = 0\n\n# Iterate through each substring of length 1 to N-1\nfor i in range(1, N):\n    # Initialize the number of occurrences of the current substring\n    occurrences = 0\n    \n    # Iterate through each position in S\n    for j in range(N-i):\n        # Check if the current substring occurs at the current position\n        if S[j:j+i] == S[j+1:j+i+1]:\n            # Increment the number of occurrences\n            occurrences += 1\n            \n            # If the number of occurrences is greater than 1, update the maximum length\n            if occurrences > 1:\n                max_len = i\n                break\n                \n    # If the maximum length has been updated, break the loop\n    if max_len > 0:\n        break\n\n# Print the maximum length\nprint(max_len)"}
{"solution": "n, a = map(int, input().split())\n\nif a % 2 == 1:\n    # a is odd\n    return (a + 1) // 2\nelse:\n    # a is even\n    return (n - a + 2) // 2\n\nprint(minimum_time_to_house(n, a))"}
{"solution": "  import sys\n\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\ncounts = list(map(int, input().split()))\n\n# Initialize the counters for each color\ncounters = [0] * m\n\n# Initialize the left and right pointers for the sliding window\nleft = 0\nright = 0\n\n# Initialize the result\nresult = \"NO\"\n\n# Expand and contract the window\nwhile right < n:\n    # Add the current color to the counters\n    counters[colors[right]] += 1\n    \n    # Check if the window meets the required counts\n    if all(counters[i] == counts[i] for i in range(m)):\n        result = \"YES\"\n        break\n    \n    # Move the right pointer to the next element\n    right += 1\n    \n    # If the window exceeds the required counts, move the left pointer to reduce the window size\n    if counters[colors[left]] > counts[colors[left]]:\n        counters[colors[left]] -= 1\n        left += 1\n\nprint(result)"}
{"solution": "n = int(input())\nrounds = []\nfor i in range(n):\n    m, c = map(int, input().split())\n    rounds.append((m, c))\n\nmishka_wins = 0\nchris_wins = 0\nfor round in rounds:\n    m, c = round\n    if m > c:\n        mishka_wins += 1\n    elif c > m:\n        chris_wins += 1\n\nif mishka_wins > chris_wins:\n    print(\"Mishka\")\nelif chris_wins > mishka_wins:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\n# Check if the field is valid\nfor i in range(n):\n    for j in range(m):\n        if field[i][j]!= '.':\n            # Check if the cell has a bomb\n            if field[i][j] == '*':\n                # Check if the cell has the correct number of bombs around it\n                if not check_bombs(i, j, field):\n                    print(\"NO\")\n                    sys.exit()\n            # Check if the cell is empty\n            elif field[i][j] == '.':\n                # Check if the cell has no bombs around it\n                if not check_empty(i, j, field):\n                    print(\"NO\")\n                    sys.exit()\n\n# Check if the cell has the correct number of bombs around it\ndef check_bombs(i, j, field):\n    bombs = 0\n    for x in range(i-1, i+2):\n        for y in range(j-1, j+2):\n            if x >= 0 and x < n and y >= 0 and y < m:\n                if field[x][y] == '*':\n                    bombs += 1\n    return bombs == int(field[i][j])\n\n# Check if the cell has no bombs around it\ndef check_empty(i, j, field):\n    for x in range(i-1, i+2):\n        for y in range(j-1, j+2):\n            if x >= 0 and x < n and y >= 0 and y < m:\n                if field[x][y] == '*':\n                    return False\n    return True\n\nprint(\"YES\")"}
{"solution": "n = int(input())\nk = 1\nwhile k < n:\n    if n % k == 0:\n        break\n    k += 1\nprint(k)"}
{"solution": "def can_rearrange_necklace(s):\n    p = s.count('o')\n    l = s.count('-')\n    \n    if p == 0 or p == 1:\n        return \"YES\"\n    if l % p == 0:\n        return \"YES\"\n    return \"NO\""}
{"solution": "n, m, k = map(int, input().split())\n\n# Initialize variables\nmax_pillows = 0\nhobbits = [0] * n\n\n# Loop through each hobbit\nfor i in range(n):\n    # Calculate the number of pillows for each hobbit\n    hobbits[i] = m - i\n\n    # Check if the hobbit has at least one pillow\n    if hobbits[i] < 1:\n        hobbits[i] = 1\n\n    # Check if the hobbit has at least two pillows less than some neighbor\n    for j in range(i + 1, n):\n        if hobbits[i] - hobbits[j] < 2:\n            hobbits[i] = hobbits[j] + 2\n\n    # Update the maximum number of pillows\n    max_pillows = max(max_pillows, hobbits[i])\n\n# Print the maximum number of pillows\nprint(max_pillows)"}
{"solution": "import sys\n\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndef get_cost(l, r):\n    return sum(a[l:r+1]) - k * ceil((r - l + 1) / m)\n\ndef solve():\n    max_cost = 0\n    for i in range(n):\n        for j in range(i, n):\n            cost = get_cost(i, j)\n            if cost > max_cost:\n                max_cost = cost\n    return max_cost\n\nprint(solve())"}
{"solution": "import sys\n\nn, m = map(int, input().split())\n\n# Initialize a 2D array to store the length of the polyline for each point\npolyline_length = [[0] * (m + 1) for _ in range(n + 1)]\n\n# Initialize a 2D array to store the previous point for each point\nprevious_point = [[(0, 0)] * (m + 1) for _ in range(n + 1)]\n\n# Initialize the maximum length of the polyline\nmax_length = 0\n\n# Initialize the starting point of the polyline\nstart_point = (0, 0)\n\n# Iterate over each point in the grid\nfor i in range(n + 1):\n    for j in range(m + 1):\n        # Calculate the length of the polyline for the current point\n        length = polyline_length[i - 1][j - 1] + 1\n\n        # If the length is greater than the maximum length, update the maximum length and the starting point\n        if length > max_length:\n            max_length = length\n            start_point = (i, j)\n\n        # Update the previous point for the current point\n        previous_point[i][j] = (i - 1, j - 1)\n\n# Initialize the end point of the polyline\nend_point = (n, m)\n\n# Initialize the points of the polyline\npoints = [start_point]\n\n# Iterate over each point in the polyline\nwhile start_point!= end_point:\n    # Get the previous point for the current point\n    previous_point = points[-1]\n\n    # Add the previous point to the list of points\n    points.append(previous_point)\n\n    # Update the current point to the previous point\n    start_point = previous_point\n\n# Print the points of the polyline in order\nfor point in points:\n    print(point[0], point[1])"}
{"solution": "def find_smallest_n(shuffled_string, remembered_substring):\n    # Initialize the smallest possible integer n\n    n = 0\n\n    # Iterate through the digits of the shuffled string\n    for digit in shuffled_string:\n        # If the current digit is in the remembered substring, add it to n\n        if digit in remembered_substring:\n            n = n * 10 + int(digit)\n\n    # Return the smallest possible integer n\n    return n"}
{"solution": ""}
{"solution": "import sys\n\nm = int(sys.stdin.readline().strip())\n\n# Calculate the number of trailing zeroes in m!\nk = 0\nwhile m % 5 == 0:\n    m //= 5\n    k += 1\n\n# Print the number of values of n such that n! ends with m zeroes\nprint(k)\n\n# Print the values of n in increasing order\nfor i in range(1, k+1):\n    print(i)"}
{"solution": "import sys\n\nn, m, k = map(int, input().split())\nx = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    u, v, w = map(int, input().split())\n    graph[u].append((v, w))\n    graph[v].append((u, w))\n\ndist = [0] * (n + 1)\nfor i in range(1, n + 1):\n    if i not in x:\n        continue\n    for j in range(1, n + 1):\n        if j not in x:\n            continue\n        if i == j:\n            dist[i] = 0\n        else:\n            dist[i] = max(dist[i], dist[j] + graph[j][i][1])\n\nprint(*dist[x])"}
{"solution": "def solve(n, x):\n    # Initialize the initial position of the ball as the middle shell\n    initial_position = 1\n\n    # Iterate through the number of movements made by the operator\n    for i in range(n):\n        # If the current movement is odd, swap the left shell with the middle shell\n        if i % 2 == 1:\n            initial_position = (initial_position + 1) % 3\n        # If the current movement is even, swap the middle shell with the right shell\n        else:\n            initial_position = (initial_position + 2) % 3\n\n    # Return the initial position of the ball\n    return initial_position"}
{"solution": "def is_square(rectangles):\n    # Step 1: Calculate the minimum and maximum x and y coordinates among all rectangles to determine the bounding box that encompasses all rectangles.\n    x_min = min(rectangle[0] for rectangle in rectangles)\n    x_max = max(rectangle[2] for rectangle in rectangles)\n    y_min = min(rectangle[1] for rectangle in rectangles)\n    y_max = max(rectangle[3] for rectangle in rectangles)\n    bounding_box = (x_min, y_min, x_max, y_max)\n\n    # Step 2: Check if the width and height of the bounding box are equal, which is a necessary condition for the rectangles to form a square.\n    if bounding_box[2] - bounding_box[0]!= bounding_box[3] - bounding_box[1]:\n        return \"NO\"\n\n    # Step 3: Verify that the union of all rectangles exactly covers the area of the bounding box without any gaps or overlaps.\n    covered_points = set()\n    for rectangle in rectangles:\n        for x in range(rectangle[0], rectangle[2] + 1):\n            for y in range(rectangle[1], rectangle[3] + 1):\n                covered_points.add((x, y))\n    if len(covered_points)!= (bounding_box[2] - bounding_box[0] + 1) * (bounding_box[3] - bounding_box[1] + 1):\n        return \"NO\"\n\n    # Step 4: Handle edge cases where rectangles touch at edges or corners but do not overlap.\n    for rectangle in rectangles:\n        for x in range(rectangle[0], rectangle[2] + 1):\n            for y in range(rectangle[1], rectangle[3] + 1):\n                if (x, y) not in covered_points:\n                    return \"NO\"\n\n    return \"YES\""}
{"solution": "import sys\n\nn, s = map(int, input().split())\n\n# Initialize a counter for the number of really big numbers\ncount = 0\n\n# Iterate through all numbers up to n\nfor i in range(1, n+1):\n    # Calculate the difference between the number and its sum of digits\n    diff = i - sum(int(digit) for digit in str(i))\n    \n    # If the difference is greater than or equal to s, increment the counter\n    if diff >= s:\n        count += 1\n\nprint(count)"}
{"solution": "import sys\n\nn = int(input())\npoints = []\n\nfor i in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\n# Sort the points by their x-coordinate\npoints.sort(key=lambda x: x[0])\n\n# Initialize the left and right endpoints of the lines\nleft_endpoint = points[0]\nright_endpoint = points[-1]\n\n# Initialize the number of points covered by each line\nnum_points_covered_by_left_line = 1\nnum_points_covered_by_right_line = 1\n\n# Iterate through the points and check if they can be covered by the lines\nfor i in range(1, n):\n    point = points[i]\n    if point[0] < left_endpoint[0]:\n        left_endpoint = point\n        num_points_covered_by_left_line += 1\n    elif point[0] > right_endpoint[0]:\n        right_endpoint = point\n        num_points_covered_by_right_line += 1\n    else:\n        # The point is between the left and right endpoints, so it can be covered by both lines\n        num_points_covered_by_left_line += 1\n        num_points_covered_by_right_line += 1\n\n# Check if all points are covered by at least one line\nif num_points_covered_by_left_line == n and num_points_covered_by_right_line == n:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef get_possible_games(a, b, k, t):\n    # Initialize the number of possible games to 0\n    possible_games = 0\n\n    # Iterate through all possible scores for Memory and Lexa\n    for memory_score in range(a, a + k + 1):\n        for lexa_score in range(b, b + k + 1):\n            # Check if the scores are different\n            if memory_score!= lexa_score:\n                # Increment the number of possible games\n                possible_games += 1\n\n    # Return the number of possible games modulo 10^9 + 7\n    return possible_games % (10**9 + 7)\n\n# Read the input from stdin\na, b, k, t = map(int, sys.stdin.readline().split())\n\n# Get the number of possible games\npossible_games = get_possible_games(a, b, k, t)\n\n# Print the number of possible games\nprint(possible_games)"}
{"solution": "import sys\n\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Find the minimum number of additional marks needed\nv = 0\nfor i in range(n):\n    if marks[i] + x <= l:\n        v += 1\n    if marks[i] + y <= l:\n        v += 1\n\n# Print the minimum number of additional marks needed\nprint(v)\n\n# Print the positions of the additional marks\nfor i in range(v):\n    print(marks[i] + x, marks[i] + y)"}
{"solution": "import math\n\ndef get_max_volume(n, cakes):\n    # Sort the cakes by their heights in descending order\n    cakes.sort(key=lambda x: x[1], reverse=True)\n\n    # Initialize the maximum volume and the current volume\n    max_volume = 0\n    current_volume = 0\n\n    # Iterate through the cakes and calculate the volume of the stack\n    for i in range(n):\n        current_volume += cakes[i][0] * cakes[i][1]\n        max_volume = max(max_volume, current_volume)\n\n    return max_volume\n\nn = int(input())\ncakes = []\nfor i in range(n):\n    r, h = map(int, input().split())\n    cakes.append((r, h))\n\nprint(get_max_volume(n, cakes))"}
{"solution": "import sys\n\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Initialize the minimum number of slices to infinity\nmin_slices = sys.maxsize\n\n# Iterate over all possible slice heights\nfor slice_height in range(1, max(heights)):\n    # Initialize the number of slices to 0\n    num_slices = 0\n\n    # Iterate over all towers\n    for tower_height in heights:\n        # If the tower height is greater than the slice height, increment the number of slices\n        if tower_height > slice_height:\n            num_slices += 1\n\n    # If the number of slices is less than or equal to k, update the minimum number of slices\n    if num_slices <= k:\n        min_slices = min(min_slices, num_slices)\n\nprint(min_slices)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate prefix sums\nprefix_sum = [0] * (n + 1)\nfor i in range(n):\n    prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\nmax_score = float('-inf')\n\n# Iterate over all possible segments [l, r]\nfor l in range(n):\n    max_in_segment = float('-inf')\n    for r in range(l, n):\n        # Update the maximum value in the current segment\n        max_in_segment = max(max_in_segment, a[r])\n        # Calculate the sum of the current segment\n        segment_sum = prefix_sum[r + 1] - prefix_sum[l]\n        # Calculate the score after Bob removes the max value\n        score = segment_sum - max_in_segment\n        # Update the maximum score\n        max_score = max(max_score, score)\n\nprint(max_score)"}
{"solution": "import sys\n\ndef is_possible(k1, k2, k3):\n    # Check if k1, k2, and k3 are all positive\n    if k1 <= 0 or k2 <= 0 or k3 <= 0:\n        return \"NO\"\n    \n    # Check if k1, k2, and k3 are all less than or equal to 1500\n    if k1 > 1500 or k2 > 1500 or k3 > 1500:\n        return \"NO\"\n    \n    # Check if k1, k2, and k3 are all coprime\n    if k1 % 2 == 0 or k2 % 2 == 0 or k3 % 2 == 0:\n        return \"NO\"\n    \n    # Check if k1, k2, and k3 are all odd\n    if k1 % 2 == 1 and k2 % 2 == 1 and k3 % 2 == 1:\n        return \"YES\"\n    \n    # Check if k1, k2, and k3 are all even\n    if k1 % 2 == 0 and k2 % 2 == 0 and k3 % 2 == 0:\n        return \"YES\"\n    \n    # If none of the above conditions are met, return \"NO\"\n    return \"NO\"\n\nif __name__ == \"__main__\":\n    k1, k2, k3 = map(int, sys.stdin.readline().split())\n    print(is_possible(k1, k2, k3))"}
{"solution": "def min_operations_to_delete_string(n, s):\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(n)]\n    \n    # Base case: single character substrings\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the DP table for substrings of length greater than 1\n    for length in range(2, n + 1):  # length of the substring\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j-1]\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n    \n    # The result for the entire string\n    return dp[0][n-1]\n\n# Example usage\nn = int(input())\ns = input().strip()\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "def get_max_pairs(n, a, m, b):\n    # Sort the lists of boys and girls by their dancing skills\n    a.sort()\n    b.sort()\n    \n    # Initialize the maximum number of pairs as 0\n    max_pairs = 0\n    \n    # Iterate through the lists of boys and girls\n    for i in range(n):\n        for j in range(m):\n            # Check if the dancing skills of the current boy and girl differ by at most one\n            if abs(a[i] - b[j]) <= 1:\n                # Increment the maximum number of pairs\n                max_pairs += 1\n    \n    # Return the maximum number of pairs\n    return max_pairs"}
{"solution": "def determine_winner(a, b, c, d):\n    # Calculate the defence and attack skills of each team\n    team_1_defence = a + b\n    team_1_attack = c + d\n    team_2_defence = a + c\n    team_2_attack = b + d\n\n    # Check if one team is guaranteed to win\n    if team_1_defence > team_2_attack and team_1_attack > team_2_defence:\n        return \"Team 1\"\n    elif team_2_defence > team_1_attack and team_2_attack > team_1_defence:\n        return \"Team 2\"\n    else:\n        return \"Draw\""}
{"solution": "import math\n\ndef solve(N, K, x_coords, y_coords, c_values):\n    # Initialize the minimum time required to have K or more pieces of meat ready\n    min_time = float('inf')\n    # Initialize the optimal position for the heat source\n    optimal_position = None\n\n    # Iterate over all possible positions for the heat source\n    for x in range(-1000, 1001):\n        for y in range(-1000, 1001):\n            # Calculate the time required to have K or more pieces of meat ready at this position\n            time = 0\n            for i in range(N):\n                time += c_values[i] * math.sqrt((x - x_coords[i]) ** 2 + (y - y_coords[i]) ** 2)\n\n            # If the time required is less than the minimum time, update the minimum time and the optimal position\n            if time < min_time:\n                min_time = time\n                optimal_position = (x, y)\n\n    # Return the optimal position for the heat source\n    return optimal_position\n\n# Read the input from Standard Input\nN, K = map(int, input().split())\nx_coords = []\ny_coords = []\nc_values = []\nfor i in range(N):\n    x, y, c = map(int, input().split())\n    x_coords.append(x)\n    y_coords.append(y)\n    c_values.append(c)\n\n# Solve the problem and print the output\nprint(solve(N, K, x_coords, y_coords, c_values))"}
{"solution": "import sys\n\nn = int(input())\nticket = input()\n\n# Replace erased digits with '0'\nticket = ticket.replace('?', '0')\n\n# Calculate the sum of the first half of the ticket\nfirst_half_sum = sum(int(digit) for digit in ticket[:n//2])\n\n# Calculate the sum of the second half of the ticket\nsecond_half_sum = sum(int(digit) for digit in ticket[n//2:])\n\n# Check if the ticket is happy\nif first_half_sum == second_half_sum:\n    print(\"Bicarp\")\nelse:\n    print(\"Monocarp\")"}
{"solution": "def find_bus_route(n, t, bus_routes):\n    earliest_time = float('inf')\n    chosen_route = -1\n    \n    for i in range(n):\n        s_i, d_i = bus_routes[i]\n        \n        if s_i >= t:\n            next_bus_time = s_i\n        else:\n            # Calculate the next bus time after t\n            if (t - s_i) % d_i == 0:\n                next_bus_time = t\n            else:\n                next_bus_time = s_i + ((t - s_i) // d_i + 1) * d_i\n        \n        if next_bus_time < earliest_time:\n            earliest_time = next_bus_time\n            chosen_route = i + 1\n    \n    return chosen_route"}
{"solution": "import sys\n\ndef solve(m, k):\n    # Initialize variables\n    n = 1\n    count = 0\n    binary_repr = ''\n\n    # Loop through numbers from n + 1 to 2n\n    while n <= 2 * m:\n        # Convert number to binary representation\n        binary_repr = bin(n)[2:]\n\n        # Count the number of digits one in the binary representation\n        count = binary_repr.count('1')\n\n        # If the number of digits one is equal to k, return the number\n        if count == k:\n            return n\n\n        # Increment n\n        n += 1\n\n    # If no number is found, return -1\n    return -1\n\n# Read input from stdin\nm, k = map(int, sys.stdin.readline().split())\n\n# Solve the problem\nresult = solve(m, k)\n\n# Print the result\nprint(result)"}
{"solution": "import sys\n\nn = int(input())\nscheme = input()\n\n# Check if the level is good\nif len(scheme) == n and scheme.count('*') == n:\n    # Check if there is a sequence of four jumps of the same length\n    for i in range(n - 3):\n        if scheme[i] == '*' and scheme[i + 1] == '*' and scheme[i + 2] == '*' and scheme[i + 3] == '*':\n            print(\"yes\")\n            sys.exit()\n\nprint(\"no\")"}
{"solution": "n = int(input())\ngrid = []\nfor i in range(n):\n    grid.append([int(x) for x in input().split()])\n\n# Check if the grid is a magic square\nif not is_magic_square(grid):\n    print(-1)\n    exit()\n\n# Find the missing number\nmissing_number = find_missing_number(grid)\n\n# Fill in the missing number\ngrid[missing_number[0]][missing_number[1]] = missing_number[2]\n\n# Check if the grid is still a magic square\nif not is_magic_square(grid):\n    print(-1)\n    exit()\n\n# Print the result\nprint(missing_number[2])\n\ndef is_magic_square(grid):\n    # Check if the grid is a square\n    if len(grid)!= len(grid[0]):\n        return False\n\n    # Check if the grid is a magic square\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j]!= grid[i][0] + i or grid[i][j]!= grid[0][j] + j:\n                return False\n\n    return True\n\ndef find_missing_number(grid):\n    # Find the missing number\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 0:\n                return (i, j, find_missing_number_helper(grid, i, j))\n\n    return None\n\ndef find_missing_number_helper(grid, i, j):\n    # Find the missing number\n    missing_number = 0\n    for k in range(len(grid)):\n        for l in range(len(grid[0])):\n            if grid[k][l]!= 0:\n                missing_number += grid[k][l]\n\n    return missing_number"}
{"solution": "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate the maximum possible k\nmax_k = max(a) + m\n\n# Calculate the total number of people after adding m people\ntotal_people = sum(a) + m\n\n# Calculate the minimum possible k\nmin_k = ceil(total_people / n)\n\nprint(min_k, max_k)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\n\n# Initialize a 2D array to store the number of ways to assign tickets\nways = [[0] * (n + 1) for _ in range(m + 1)]\n\n# Base case: when there are no passengers or no seats\nways[0][0] = 1\n\n# Iterate over the number of passengers\nfor i in range(1, m + 1):\n    # Iterate over the number of seats\n    for j in range(1, n + 1):\n        # If the passenger is assigned to the first seat\n        if j == 1:\n            # They can only come from the front entrance\n            ways[i][j] = ways[i - 1][j - 1]\n        # If the passenger is assigned to any other seat\n        else:\n            # They can come from either the front or back entrance\n            ways[i][j] = ways[i - 1][j - 1] + ways[i - 1][j - 2]\n\n# Print the number of ways modulo 10^9 + 7\nprint(ways[m][n] % (10**9 + 7))"}
{"solution": "import itertools\n\ndef get_pizza_combinations(n, m, friends, pizzas):\n    # Initialize an empty list to store the combinations\n    combinations = []\n\n    # Iterate over each friend and their favorite ingredients\n    for friend in friends:\n        # Get the favorite ingredients of the current friend\n        favorite_ingredients = friend[1]\n\n        # Iterate over each pizza and its ingredients\n        for pizza in pizzas:\n            # Get the ingredients of the current pizza\n            pizza_ingredients = pizza[1]\n\n            # Check if the current pizza satisfies the current friend's preferences\n            if set(favorite_ingredients).issubset(pizza_ingredients):\n                # Add the current pizza to the combinations list\n                combinations.append((friend[0], pizza[0]))\n\n    # Return the combinations list\n    return combinations\n\ndef get_optimal_combination(combinations):\n    # Initialize the optimal combination as the first element of the combinations list\n    optimal_combination = combinations[0]\n\n    # Iterate over each combination in the combinations list\n    for combination in combinations:\n        # Check if the current combination has a higher number of satisfied preferences than the current optimal combination\n        if len(combination[0]) > len(optimal_combination[0]):\n            # Update the optimal combination to the current combination\n            optimal_combination = combination\n\n    # Return the optimal combination\n    return optimal_combination\n\ndef main():\n    # Read the input from stdin\n    n, m = map(int, input().split())\n    friends = [tuple(map(int, input().split())) for _ in range(n)]\n    pizzas = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Get the combinations of pizzas that satisfy each friend's preferences\n    combinations = get_pizza_combinations(n, m, friends, pizzas)\n\n    # Get the optimal combination of pizzas that satisfy the maximum number of friends' preferences\n    optimal_combination = get_optimal_combination(combinations)\n\n    # Print the indices of the optimal combination\n    print(optimal_combination[0], optimal_combination[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_smallest_largest_numbers(m, s):\n    # Initialize variables\n    smallest_number = -1\n    largest_number = -1\n\n    # Iterate through all possible numbers with length m\n    for i in range(10**(m-1), 10**m):\n        # Check if the number has the required sum of digits\n        if sum(int(j) for j in str(i)) == s:\n            # Check if the number is smaller than the current smallest number\n            if smallest_number == -1 or i < smallest_number:\n                smallest_number = i\n            # Check if the number is larger than the current largest number\n            if largest_number == -1 or i > largest_number:\n                largest_number = i\n\n    # Return the smallest and largest numbers\n    return smallest_number, largest_number\n\n# Test the function\nprint(find_smallest_largest_numbers(2, 15)) # Should print (69, 96)\nprint(find_smallest_largest_numbers(3, 0)) # Should print (-1, -1)"}
{"solution": "import sys\n\ndef solve(l, r, k):\n    # Initialize the sum to 0\n    sum = 0\n\n    # Iterate from l to r\n    for i in range(l, r+1):\n        # Check if the number of digits in i is less than or equal to k\n        if len(str(i)) <= k:\n            # Add i to the sum\n            sum += i\n\n    # Return the sum modulo 998244353\n    return sum % 998244353\n\n# Read the input from stdin\nl, r, k = map(int, input().split())\n\n# Solve the problem\nresult = solve(l, r, k)\n\n# Print the result\nprint(result)"}
{"solution": "import sys\n\nn, k, d = map(int, input().split())\na = list(map(int, input().split()))\n\n# Check if it's possible to distribute all the pencils into boxes\nif len(a) < k:\n    print(\"NO\")\n    sys.exit()\n\n# Sort the pencils by saturation\na.sort()\n\n# Initialize the boxes\nboxes = [[] for _ in range(k)]\n\n# Distribute the pencils into the boxes\nfor i in range(len(a)):\n    # Find the box with the smallest number of pencils\n    smallest_box = 0\n    for j in range(1, k):\n        if len(boxes[j]) < len(boxes[smallest_box]):\n            smallest_box = j\n\n    # Add the pencil to the smallest box\n    boxes[smallest_box].append(a[i])\n\n# Check if the conditions are met\nfor i in range(k):\n    # Check if the box is not empty\n    if len(boxes[i]) == 0:\n        print(\"NO\")\n        sys.exit()\n\n    # Check if the box has at least k pencils\n    if len(boxes[i]) < k:\n        print(\"NO\")\n        sys.exit()\n\n    # Check if the pencils in the box have a difference in saturation of at most d\n    for j in range(len(boxes[i]) - 1):\n        if abs(boxes[i][j] - boxes[i][j + 1]) > d:\n            print(\"NO\")\n            sys.exit()\n\nprint(\"YES\")"}
{"solution": "def count_dead_bulbs(s):\n    colors = ['R', 'B', 'Y', 'G']\n    dead_bulbs = {color: 0 for color in colors}\n    for i in range(len(s)):\n        if s[i] == '!':\n            dead_bulbs[s[i-1]] += 1\n    return''.join(str(dead_bulbs[color]) for color in colors)"}
{"solution": "import sys\n\ndef solve(N, M, s_i, t_i):\n    # Initialize the expected number of passages\n    E = 0\n\n    # Loop through each passage\n    for i in range(M):\n        # Calculate the probability of taking the passage\n        probability = 1 / (N - 1)\n\n        # Calculate the expected number of passages for this passage\n        expected_passages = probability * (N - 1)\n\n        # Add the expected number of passages to the total\n        E += expected_passages\n\n    # Return the expected number of passages\n    return E\n\n# Read the input from stdin\nN, M = map(int, input().split())\ns_i, t_i = map(int, input().split())\n\n# Solve the problem\nE = solve(N, M, s_i, t_i)\n\n# Print the output to stdout\nprint(E)"}
{"solution": "n = int(input())\n\nif n % 10 == 0:\n    print(n)\nelse:\n    lower_multiple = n // 10 * 10\n    higher_multiple = (n // 10 + 1) * 10\n    if abs(n - lower_multiple) < abs(n - higher_multiple):\n        print(lower_multiple)\n    else:\n        print(higher_multiple)"}
{"solution": "def find_swaps(s, t):\n    if len(s)!= len(t):\n        return -1\n    \n    mismatches = {}\n    \n    for i in range(len(s)):\n        if s[i]!= t[i]:\n            if s[i] in mismatches and mismatches[s[i]]!= t[i]:\n                return -1\n            if t[i] in mismatches and mismatches[t[i]]!= s[i]:\n                return -1\n            mismatches[s[i]] = t[i]\n            mismatches[t[i]] = s[i]\n    \n    visited = set()\n    swaps = []\n    \n    for key in mismatches:\n        if key not in visited:\n            cycle = []\n            current = key\n            while current not in visited:\n                visited.add(current)\n                cycle.append(current)\n                current = mismatches[current]\n            if len(cycle)!= 2:\n                return -1\n            swaps.append((cycle[0], cycle[1]))\n    \n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0], swap[1])"}
{"solution": "def get_alphabetically_earliest_login(first_name, last_name):\n    # Identify prefixes of first and last names\n    first_name_prefixes = [first_name[i:] for i in range(len(first_name))]\n    last_name_prefixes = [last_name[i:] for i in range(len(last_name))]\n\n    # Generate combinations of prefixes\n    combinations = []\n    for first_prefix in first_name_prefixes:\n        for last_prefix in last_name_prefixes:\n            combinations.append(first_prefix + last_prefix)\n\n    # Compare combinations alphabetically and return the earliest one\n    combinations.sort()\n    return combinations[0]"}
{"solution": "import sys\n\nn = int(input())\nsequence = input()\n\n# Initialize the output string\noutput = \"\"\n\n# Iterate through the sequence and draw the brackets\nfor i in range(n):\n    if sequence[i] == \"[\":\n        output += \"+\"\n    else:\n        output += \"-\"\n\n# Add the vertical bars\nfor i in range(n):\n    if sequence[i] == \"[\":\n        output += \"|\"\n    else:\n        output += \" \"\n\n# Add the horizontal bars\nfor i in range(n):\n    if sequence[i] == \"[\":\n        output += \"+\"\n    else:\n        output += \"-\"\n\n# Add the closing brackets\nfor i in range(n):\n    if sequence[i] == \"[\":\n        output += \"|\"\n    else:\n        output += \" \"\n\n# Print the output\nprint(output)"}
{"solution": "def compare_golden_numbers(num1, num2):\n    # Normalize both numbers\n    norm_num1 = normalize_golden_number(num1)\n    norm_num2 = normalize_golden_number(num2)\n    \n    # Compare lengths first\n    if len(norm_num1) > len(norm_num2):\n        return \">\"\n    elif len(norm_num1) < len(norm_num2):\n        return \"<\"\n    \n    # If lengths are equal, compare digit by digit\n    for digit1, digit2 in zip(norm_num1, norm_num2):\n        if digit1 > digit2:\n            return \">\"\n        elif digit1 < digit2:\n            return \"<\"\n    \n    # If all digits are equal\n    return \"=\""}
{"solution": "n = int(input())\ncolors = []\nfor i in range(n):\n    colors.append(input().lower())\n\nabsent_gems = []\nfor gem in [\"power\", \"time\", \"space\", \"soul\", \"reality\", \"mind\"]:\n    if gem.lower() not in colors:\n        absent_gems.append(gem)\n\nprint(len(absent_gems))\nfor gem in absent_gems:\n    print(gem.title())"}
{"solution": "import sys\n\nn, a, b = map(int, sys.stdin.readline().split())\n\nif a == b:\n    print(\"Final!\")\nelse:\n    for i in range(1, n):\n        if (a - 1) // 2 == (b - 1) // 2:\n            print(i)\n            break\n        a = (a - 1) // 2 + 1\n        b = (b - 1) // 2 + 1\n    else:\n        print(\"Final!\")"}
{"solution": "import sys\n\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Initialize the minimum number of changes required\nmin_changes = 0\n\n# Initialize the permutation and sequence\nperm = p\nseq = b\n\n# Iterate through each skewer\nfor i in range(n):\n    # If the skewer is not in its original position, move it to its original position\n    if perm[i]!= i + 1:\n        perm[i] = i + 1\n        min_changes += 1\n\n    # If the skewer is not in its reversed position, move it to its reversed position\n    if seq[i] == 1 and perm[i]!= n - i:\n        perm[i] = n - i\n        min_changes += 1\n\n# Print the minimum number of changes required\nprint(min_changes)"}
{"solution": ""}
{"solution": "import sys\n\ndef solve(N, M, w, l, v):\n    # Initialize variables\n    camels = [Camel(i, w[i-1]) for i in range(1, N+1)]\n    parts = [Part(i, l[i-1], v[i-1]) for i in range(1, M+1)]\n    distances = [0] * (N-1)\n    min_distance = sys.maxsize\n\n    # Try all possible arrangements of camels\n    for arrangement in itertools.permutations(camels):\n        # Calculate the distance between each adjacent pair of camels\n        for i in range(N-1):\n            distances[i] = arrangement[i+1].position - arrangement[i].position\n\n        # Check if the bridge will collapse\n        if will_collapse(parts, distances):\n            continue\n\n        # Calculate the minimum distance between the first and last camels\n        min_distance = min(min_distance, distances[0] + distances[-1])\n\n    # Print the minimum distance\n    print(min_distance)\n\ndef will_collapse(parts, distances):\n    # Check if the bridge will collapse\n    for part in parts:\n        if part.weight_capacity < sum(camel.weight for camel in part.camels):\n            return True\n    return False\n\nclass Camel:\n    def __init__(self, id, weight):\n        self.id = id\n        self.weight = weight\n        self.position = 0\n\nclass Part:\n    def __init__(self, id, length, weight_capacity):\n        self.id = id\n        self.length = length\n        self.weight_capacity = weight_capacity\n        self.camels = []\n\n    def add_camel(self, camel):\n        self.camels.append(camel)\n\n    def remove_camel(self, camel):\n        self.camels.remove(camel)\n\n# Read input\nN, M = map(int, input().split())\nw = list(map(int, input().split()))\nl = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Solve the problem\nsolve(N, M, w, l, v)"}
{"solution": "import math\n\ndef get_last_digit(a, b):\n    if a == 0:\n        return 1\n    else:\n        factorial = math.factorial(a)\n        return str(factorial)[-1]\n\na, b = map(int, input().split())\nprint(get_last_digit(b, a))"}
{"solution": "def frog_jump(n, d, s):\n    # Initialize the queue with the starting point (1) and set the number of jumps to 0\n    queue = [(1, 0)]\n\n    # Initialize the visited array to keep track of the points that have been visited\n    visited = [False] * (n + 1)\n\n    # Loop until the queue is empty\n    while queue:\n        # Dequeue the front element\n        current_position, current_jumps = queue.pop(0)\n\n        # Check if the current position is the destination point (n)\n        if current_position == n:\n            return current_jumps + 1\n\n        # Check if the current position has not been visited before\n        if not visited[current_position]:\n            # Mark the current position as visited\n            visited[current_position] = True\n\n            # Check if the current position has a lily and the destination point is within the maximum jump distance\n            if s[current_position] == '1' and current_position + d <= n:\n                # Enqueue the next position and increment the number of jumps\n                queue.append((current_position + d, current_jumps + 1))\n\n    # If the queue is empty and the destination point has not been reached, return -1\n    return -1"}
{"solution": "n = int(input())\n\nfor m in range(1, 1001):\n    if not is_prime(n * m + 1):\n        print(m)\n        break\nelse:\n    print(-1)"}
{"solution": "n = int(input())\n\n# Check if n is a multiple of 1234\nif n % 1234 == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn = int(input())\nx1, x2 = map(int, input().split())\nlines = []\n\nfor i in range(n):\n    k, b = map(int, input().split())\n    lines.append((k, b))\n\n# Check if there are any intersections inside the strip\nfor i in range(n):\n    for j in range(i+1, n):\n        k1, b1 = lines[i]\n        k2, b2 = lines[j]\n        if k1!= k2:\n            x = (b2 - b1) / (k1 - k2)\n            if x1 < x < x2:\n                print(\"Yes\")\n                sys.exit()\n\nprint(\"No\")"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\n# Initialize a dictionary to store the weights of the splits\nweights = {}\n\n# Iterate through all possible splits of n\nfor i in range(1, n+1):\n    for j in range(i, n+1):\n        # Check if the current split is a valid split of n\n        if i + j == n:\n            # Get the weight of the current split\n            weight = 1\n            for k in range(i, j):\n                if i == k:\n                    weight += 1\n            # Add the weight to the dictionary\n            if weight not in weights:\n                weights[weight] = 1\n            else:\n                weights[weight] += 1\n\n# Print the number of different weights of splits\nprint(len(weights))"}
{"solution": "def find_good_apartments(n, k):\n    if k == 0:\n        min_good = 0\n        max_good = 0\n    else:\n        min_good = 1\n        max_good = min(n - k, 2 * k)\n    \n    return min_good, max_good\n\nn, k = 6, 3\nmin_good, max_good = find_good_apartments(n, k)\nprint(min_good, max_good)  # Output: 1 3"}
{"solution": "  import math\n\ndef get_max_games(n):\n    return math.floor(math.log2(n))\n\nn = int(input())\nprint(get_max_games(n))"}
{"solution": "def max_vk_occurrences(s):\n    # Initialize variables\n    vk_count = 0\n    v_count = 0\n    k_count = 0\n\n    # Iterate through the string\n    for i in range(len(s)):\n        # Check if the current character is 'V'\n        if s[i] == 'V':\n            # Increment the 'V' count\n            v_count += 1\n\n            # Check if the next character is 'K'\n            if i + 1 < len(s) and s[i + 1] == 'K':\n                # Increment the 'VK' count\n                vk_count += 1\n\n        # Check if the current character is 'K'\n        elif s[i] == 'K':\n            # Increment the 'K' count\n            k_count += 1\n\n    # Check if the string ends with 'V'\n    if s[-1] == 'V':\n        # Increment the 'V' count\n        v_count += 1\n\n    # Check if the string ends with 'K'\n    if s[-1] == 'K':\n        # Increment the 'K' count\n        k_count += 1\n\n    # Return the maximum number of occurrences of 'VK'\n    return max(vk_count, v_count, k_count)"}
{"solution": "  import math\n\ndef min_segments(n):\n    a = int(math.sqrt(n))\n    b = (n + a - 1) // a  # This is equivalent to math.ceil(n / a)\n    return a + b + 2\n\n# Read input\nn = int(input().strip())\nprint(min_segments(n))"}
{"solution": "  # Importing necessary libraries\nimport math\n\ndef main():\n    # Reading the input\n    a, b = map(int, input().split())\n\n    # Calculating the number of years\n    years = 0\n    while a <= b:\n        a *= 3\n        b *= 2\n        years += 1\n\n    # Printing the output\n    print(years)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve(h, n):\n    # Initialize variables\n    visited_nodes = set()\n    current_node = 1\n    skipped_commands = 0\n\n    # Iterate through the command string\n    for command in \"LRLRLRLRL...\":\n        # If the current node is not the exit, move to the left or right child\n        if current_node!= n:\n            if command == \"L\":\n                current_node = current_node * 2\n            else:\n                current_node = current_node * 2 + 1\n\n        # If the current node is the exit, return the number of visited nodes\n        if current_node == n:\n            return len(visited_nodes)\n\n        # If the current node is already visited, skip the command\n        if current_node in visited_nodes:\n            skipped_commands += 1\n            continue\n\n        # Add the current node to the set of visited nodes\n        visited_nodes.add(current_node)\n\n        # If two consecutive commands are skipped, go back to the parent node\n        if skipped_commands == 2:\n            current_node = current_node // 2\n            skipped_commands = 0\n\n    # If the exit is not found, return the number of visited nodes\n    return len(visited_nodes)"}
{"solution": "import math\n\ndef find_distinct_squares(x):\n    k = 0\n    for n in range(1, math.ceil(math.sqrt(x)) + 1):\n        for m in range(1, math.ceil(math.sqrt(x)) + 1):\n            if n * m == x:\n                k += 1\n                print(n, m)\n    return k\n\nx = int(input())\nk = find_distinct_squares(x)\nprint(k)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Check if the sum of the days in each month is equal to the total number of days\nif sum(a) == 365:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\nif n < 2 or n > 10**9:\n    print(\"NO\")\n    sys.exit()\n\n# Initialize the sequence with the first fraction\na = 1\nb = n\nk = 1\n\n# Iterate until the sum of the fractions is 1 - 1/n\nwhile a/b!= 1 - 1/n:\n    # Find the next fraction\n    a, b = find_next_fraction(a, b)\n    k += 1\n\n# Print the sequence\nprint(\"YES\")\nprint(k)\nprint(f\"{a} {b}\")\nfor i in range(k-1):\n    print(f\"{a+i} {b+i}\")\n\ndef find_next_fraction(a, b):\n    # Find the next fraction that satisfies the constraints\n    while True:\n        a += 1\n        b += 1\n        if a % b == 0 and a < b and b < n:\n            break\n    return a, b"}
{"solution": "import sys\n\nn, a, b = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Initialize the minimum unattractiveness value to -1\nmin_unattractiveness = -1\n\n# Iterate through each board and calculate the unattractiveness value\nfor i in range(n):\n    # Calculate the unattractiveness value for the current board\n    unattractiveness = 0\n    if i > 0:\n        unattractiveness += min(heights[i], heights[i-1])\n    if i < n-1:\n        unattractiveness += min(heights[i], heights[i+1])\n    \n    # Update the minimum unattractiveness value\n    if unattractiveness < min_unattractiveness or min_unattractiveness == -1:\n        min_unattractiveness = unattractiveness\n\n# Print the minimum unattractiveness value\nprint(min_unattractiveness)"}
{"solution": "import math\n\ndef find_triangle_points(n, m, k):\n    # Calculate the area of the triangle\n    area = n * m / k\n\n    # Find the points that form the triangle\n    for x1 in range(n + 1):\n        for y1 in range(m + 1):\n            for x2 in range(x1 + 1, n + 1):\n                for y2 in range(y1 + 1, m + 1):\n                    for x3 in range(x2 + 1, n + 1):\n                        for y3 in range(y2 + 1, m + 1):\n                            if (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) == 0:\n                                return \"YES\", x1, y1, x2, y2, x3, y3\n\n    return \"NO\"\n\nn, m, k = map(int, input().split())\nprint(find_triangle_points(n, m, k))"}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\nif n < k:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize the repetition counts for each muscle group\nchest_rep = 0\nbiceps_rep = 0\nback_rep = 0\n\n# Iterate through the list of exercises and increment the corresponding repetition count\nfor i in range(n):\n    if i % 3 == 0:\n        chest_rep += a[i]\n    elif i % 3 == 1:\n        biceps_rep += a[i]\n    else:\n        back_rep += a[i]\n\n# Determine which muscle group has the most repetitions\nif chest_rep > biceps_rep and chest_rep > back_rep:\n    print(\"chest\")\nelif biceps_rep > chest_rep and biceps_rep > back_rep:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "n = int(input())\ngrades = list(map(int, input().split()))\n\ncurrent_sum = sum(grades)\ntarget_sum = n * 4.5\n\nif current_sum >= target_sum:\n    print(0)\nelse:\n    grades.sort()\n    redos = 0\n\n    for grade in grades:\n        if current_sum >= target_sum:\n            break\n        current_sum += (5 - grade)\n        redos += 1\n\n    print(redos)"}
{"solution": "import sys\n\ndef solve(u, v):\n    # Initialize the array with the first element\n    arr = [u]\n    # Loop until the sum of the elements is equal to v\n    while sum(arr)!= v:\n        # Add the next element to the array\n        arr.append(u)\n        # XOR the elements of the array\n        xor = 0\n        for i in range(len(arr)):\n            xor ^= arr[i]\n        # If the XOR is not equal to u, then the array is not valid\n        if xor!= u:\n            return -1\n    # Return the array\n    return arr\n\nif __name__ == \"__main__\":\n    u, v = map(int, sys.stdin.readline().split())\n    print(solve(u, v))"}
{"solution": "n = int(input())\n\n# Initialize the number of digits 1 to 0\nnum_ones = 0\n\n# Initialize the sum to 0\nsum = 0\n\n# Iterate through the digits of n\nfor digit in str(n):\n    # If the digit is 1, increment the number of digits 1\n    if digit == '1':\n        num_ones += 1\n    # If the digit is not 1, add it to the sum\n    else:\n        sum += int(digit)\n\n# Print the expected minimal number of digits 1\nprint(num_ones)"}
{"solution": "import sys\n\ndef solve(x1, y1, x2, y2, x, y):\n    # Analyze the moves\n    moves = [(x1, y1), (x1 + x, y1 + y), (x1 + x, y1 - y), (x1 - x, y1 + y), (x1 - x, y1 - y)]\n\n    # Mathematical reasoning\n    if x1 + x == x2 and y1 + y == y2:\n        return \"YES\"\n    elif x1 + x == x2 and y1 - y == y2:\n        return \"YES\"\n    elif x1 - x == x2 and y1 + y == y2:\n        return \"YES\"\n    elif x1 - x == x2 and y1 - y == y2:\n        return \"YES\"\n    else:\n        return \"NO\"\n\nif __name__ == \"__main__\":\n    x1, y1, x2, y2 = map(int, input().split())\n    x, y = map(int, input().split())\n    print(solve(x1, y1, x2, y2, x, y))"}
{"solution": "import itertools\n\ndef count_valid_bus_numbers(n):\n    # Convert the number to a string to extract digits\n    digits = list(str(n))\n    \n    # Generate all unique permutations of the digits\n    all_permutations = set(itertools.permutations(digits))\n    \n    # Filter out permutations that start with '0'\n    valid_permutations = set()\n    for perm in all_permutations:\n        if perm[0]!= '0':\n            valid_permutations.add(perm)\n    \n    # Return the count of valid permutations\n    return len(valid_permutations)\n\n# Read input\nn = int(input().strip())\n\n# Get the count of valid bus numbers\nresult = count_valid_bus_numbers(n)\n\n# Print the result\nprint(result)"}
{"solution": "import sys\n\na, b, c, d, e, f = map(int, sys.stdin.readline().split())\n\n# Calculate the maximum number of suits of each type that can be made\nmax_suits_1 = a // 2\nmax_suits_2 = (b + c + d) // 3\n\n# Calculate the total cost of each type of suit\ncost_1 = e * max_suits_1\ncost_2 = f * max_suits_2\n\n# Calculate the maximum total cost of some set of suits\nmax_cost = max(cost_1, cost_2)\n\nprint(max_cost)"}
{"solution": "import math\n\ndef solve(a, b, p, x):\n    count = 0\n    for n in range(1, x+1):\n        if pow(a, n, p) == b:\n            count += 1\n    return count\n\na, b, p, x = map(int, input().split())\nprint(solve(a, b, p, x))"}
{"solution": "import sys\n\ndef get_max_sum(k2, k3, k5, k6):\n    # Initialize variables to store the number of digits used\n    num_2 = 0\n    num_3 = 0\n    num_5 = 0\n    num_6 = 0\n\n    # Initialize variables to store the sum of the integers\n    sum_256 = 0\n    sum_32 = 0\n\n    # Loop through the input and check if the digit is used\n    for digit in [k2, k3, k5, k6]:\n        if digit == 2:\n            num_2 += 1\n        elif digit == 3:\n            num_3 += 1\n        elif digit == 5:\n            num_5 += 1\n        elif digit == 6:\n            num_6 += 1\n\n    # Calculate the sum of the integers\n    sum_256 = num_2 * 256 + num_3 * 256 + num_5 * 256 + num_6 * 256\n    sum_32 = num_2 * 32 + num_3 * 32 + num_5 * 32 + num_6 * 32\n\n    # Return the maximum sum\n    return max(sum_256, sum_32)\n\n# Read the input from stdin\nk2, k3, k5, k6 = map(int, sys.stdin.readline().split())\n\n# Get the maximum sum\nmax_sum = get_max_sum(k2, k3, k5, k6)\n\n# Print the output to stdout\nprint(max_sum)"}
{"solution": "import sys\n\nn, x, y, c = map(int, sys.stdin.readline().split())\n\n# Initialize the grid with the initial cell switched on\ngrid = [[0] * n for _ in range(n)]\ngrid[x - 1][y - 1] = 1\n\n# Simulate the propagation process\nfor i in range(n * n):\n    # Check if the condition is met\n    if sum(sum(row) for row in grid) >= c:\n        break\n    \n    # Switch on the cells that are off but have the side-adjacent cells that are on\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0 and any(grid[i - 1][j], grid[i + 1][j], grid[i][j - 1], grid[i][j + 1]):\n                grid[i][j] = 1\n\n# Print the answer\nprint(i)"}
{"solution": "import sys\n\ndef get_max_xor(l, r):\n    max_xor = 0\n    for a in range(l, r+1):\n        for b in range(a, r+1):\n            xor = a ^ b\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\nif __name__ == '__main__':\n    l, r = map(int, sys.stdin.readline().split())\n    print(get_max_xor(l, r))"}
{"solution": "def minimum_height(n, k):\n    left, right = 1, k\n    while left < right:\n        mid = (left + right) // 2\n        if n * mid >= k:\n            right = mid\n        else:\n            left = mid + 1\n    return left"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    stairs_time = abs(x - y) * t1\n    elevator_to_masha_time = abs(z - x) * t2 + t3\n    elevator_to_egor_time = abs(x - y) * t2 + 2 * t3\n    elevator_time = elevator_to_masha_time + elevator_to_egor_time\n    if stairs_time < elevator_time:\n        return \"NO\"\n    else:\n        return \"YES\"\n\n# Example usage:\nx, y, z, t1, t2, t3 = map(int, input().split())\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "import random\n\ndef get_optimal_a(n, m):\n    # Initialize the optimal value of a as the minimum value\n    optimal_a = 1\n    # Initialize the maximum probability as 0\n    max_probability = 0\n\n    # Iterate through all possible values of a\n    for a in range(1, n + 1):\n        # Calculate the probability of winning for the current value of a\n        probability = abs(a - m) / n\n\n        # If the probability is greater than the maximum probability, update the optimal value of a and the maximum probability\n        if probability > max_probability:\n            optimal_a = a\n            max_probability = probability\n\n    return optimal_a\n\nn = int(input())\nm = int(input())\n\nprint(get_optimal_a(n, m))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize variables\npairs_at_university = 0\npairs_at_home = 0\n\n# Iterate through the list of pairs\nfor i in range(n):\n    # If Alena has the current pair, increment the number of pairs at the university\n    if a[i] == 1:\n        pairs_at_university += 1\n    # If Alena doesn't have the current pair, increment the number of pairs at home\n    else:\n        pairs_at_home += 1\n\n# If there are at least two consecutive pairs at home, Alena will stay at home for those pairs\nif pairs_at_home >= 2:\n    pairs_at_university -= pairs_at_home\n\n# Print the number of pairs at the university\nprint(pairs_at_university)"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize the minimum number of days to give Bran k candies\nmin_days = -1\n\n# Iterate through each day\nfor i in range(n):\n    # If Arya has enough candies to give Bran k candies on this day\n    if a[i] >= k:\n        # Update the minimum number of days to give Bran k candies\n        min_days = i\n        break\n\n# Print the minimum number of days to give Bran k candies\nprint(min_days)"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize the number of additional walks to 0\nadditional_walks = 0\n\n# Initialize the adjusted walks array\nb = a[:]\n\n# Iterate through the days\nfor i in range(n - 1):\n    # If the sum of walks on day i and day i+1 is less than k, increase the walks on day i+1\n    if b[i] + b[i + 1] < k:\n        needed_walks = k - (b[i] + b[i + 1])\n        b[i + 1] += needed_walks\n        additional_walks += needed_walks\n\n# Print the total number of additional walks\nprint(additional_walks)\n\n# Print the adjusted walks array\nprint(' '.join(map(str, b)))"}
{"solution": "n = int(input())\n\n# Initialize the number of cells to 1\ncells = 1\n\n# Iterate from 2 to n\nfor i in range(2, n+1):\n    # Calculate the number of cells in the current rhombus\n    cells += (i * (i+1)) // 2\n\nprint(cells)"}
{"solution": "import set\n\ndef is_pangram(string):\n    # Convert the string to a consistent case\n    string = string.lower()\n\n    # Create a set to track the unique letters found in the string\n    letters = set()\n\n    # Iterate through the string and add each letter to the set\n    for char in string:\n        letters.add(char)\n\n    # Check if the set contains all 26 letters of the alphabet\n    if len(letters) == 26:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Test the solution with various inputs\nprint(is_pangram(\"toosmallword\"))  # NO\nprint(is_pangram(\"TheQuickBrownFoxJumpsOverTheLazyDog\"))  # YES"}
{"solution": "import datetime\n\ndef get_time_after_minutes(current_time, minutes):\n    current_time = datetime.datetime.strptime(current_time, '%H:%M')\n    time_after_minutes = current_time + datetime.timedelta(minutes=minutes)\n    return time_after_minutes.strftime('%H:%M')\n\ncurrent_time = input()\nminutes = int(input())\nprint(get_time_after_minutes(current_time, minutes))"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().strip())) for _ in range(n)]\n\n# Initialize a set to store the indices of the switches that are not used\nunused_switches = set(range(n))\n\n# Iterate over each lamp and check if it can be turned on by pressing all n - 1 switches\nfor lamp in range(m):\n    # Initialize a set to store the indices of the switches that are connected to this lamp\n    connected_switches = set()\n    \n    # Iterate over each switch and check if it is connected to this lamp\n    for switch in range(n):\n        if matrix[switch][lamp] == 1:\n            connected_switches.add(switch)\n    \n    # If the number of connected switches is less than n - 1, then this lamp cannot be turned on by pressing all n - 1 switches\n    if len(connected_switches) < n - 1:\n        print(\"NO\")\n        sys.exit()\n    \n    # Remove the indices of the switches that are connected to this lamp from the set of unused switches\n    unused_switches -= connected_switches\n\n# If all lamps can be turned on by pressing all n - 1 switches, then there is a switch that can be ignored\nif len(unused_switches) == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\n\n# Initialize the sums of the upper and lower halves\nupper_sum = 0\nlower_sum = 0\n\n# Iterate through each domino piece\nfor i in range(n):\n    # Get the numbers written on the upper and lower halves\n    x, y = map(int, input().split())\n    \n    # Add the numbers to the respective sums\n    upper_sum += x\n    lower_sum += y\n\n# Calculate the minimum number of rotations needed to achieve even sums\nmin_rotations = 0\nif upper_sum % 2!= 0:\n    min_rotations += 1\nif lower_sum % 2!= 0:\n    min_rotations += 1\n\n# Print the minimum required number of seconds\nprint(min_rotations)"}
{"solution": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef solve(a, b):\n    area = (a - b) * (a + b)\n    return \"YES\" if is_prime(area) else \"NO\"\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        a, b = map(int, input().split())\n        print(solve(a, b))"}
{"solution": "n = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\npositive_count = 0\nnegative_count = 0\n\nfor x, y in points:\n    if x > 0:\n        positive_count += 1\n    else:\n        negative_count += 1\n\nif positive_count <= 1 or negative_count <= 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "import math\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result\n\ndef main():\n    a, b = map(int, input().split())\n    a_factorial = factorial(a)\n    b_factorial = factorial(b)\n    gcd_value = gcd(a_factorial, b_factorial)\n    print(gcd_value)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef find_composite_integers(n):\n    # Find the prime factors of n\n    prime_factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            prime_factors.append(i)\n    if n > 1:\n        prime_factors.append(n)\n\n    # Find the two composite integers a and b such that a - b = n\n    a = 1\n    b = 1\n    for prime in prime_factors:\n        a *= prime\n        b *= prime - 1\n    return a, b\n\nn = int(input())\na, b = find_composite_integers(n)\nprint(a, b)"}
{"solution": "import sys\n\ndef get_max_score(graph, start, end, time_limit):\n    # Initialize the maximum score to 0\n    max_score = 0\n\n    # Initialize the current score to 0\n    current_score = 0\n\n    # Initialize the current vertex to the start vertex\n    current_vertex = start\n\n    # Initialize the time elapsed to 0\n    time_elapsed = 0\n\n    # Loop through the edges of the graph\n    for edge in graph:\n        # If the current vertex is the start vertex, set the current score to 0\n        if current_vertex == start:\n            current_score = 0\n\n        # Add the coins on the current edge to the current score\n        current_score += edge.coins\n\n        # If the current vertex is the end vertex, set the maximum score to the current score\n        if current_vertex == end:\n            max_score = current_score\n\n        # If the time elapsed is greater than the time limit, break the loop\n        if time_elapsed > time_limit:\n            break\n\n        # Increment the time elapsed by 1\n        time_elapsed += 1\n\n        # Set the current vertex to the next vertex in the edge\n        current_vertex = edge.next_vertex\n\n    # Return the maximum score\n    return max_score\n\n# Read the input from Standard Input\nn, m, p = map(int, input().split())\ngraph = []\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    graph.append((a, b, c))\n\n# Call the get_max_score function and print the result\nprint(get_max_score(graph, 1, n, p))"}
{"solution": "import sys\n\ndef get_min_cost(strings, costs):\n    # Initialize the minimum cost to -1\n    min_cost = -1\n\n    # Loop through each string and its cost\n    for string, cost in zip(strings, costs):\n        # If the string is a palindrome, return its cost\n        if string == string[::-1]:\n            return cost\n\n        # If the string is not a palindrome, check if it can be made into a palindrome by concatenating it with another string\n        for other_string in strings:\n            # If the other string is a palindrome, concatenate it with the current string and return the cost\n            if other_string == other_string[::-1]:\n                return cost + other_string\n\n    # If no palindrome can be made, return -1\n    return -1\n\n# Get the number of strings and their costs from the input\nN = int(input())\nstrings = []\ncosts = []\nfor i in range(N):\n    string, cost = input().split()\n    strings.append(string)\n    costs.append(int(cost))\n\n# Get the minimum cost to make a palindrome\nmin_cost = get_min_cost(strings, costs)\n\n# Print the minimum cost\nprint(min_cost)"}
{"solution": "def largest_xor_sum(n, k):\n    # Find the number of bits in n\n    num_bits = n.bit_length()\n    # The largest possible xor-sum\n    max_xor_sum = (1 << num_bits) - 1\n    return max_xor_sum\n\n# Example usage:\nn, k = map(int, input().split())\nprint(largest_xor_sum(n, k))"}
{"solution": "import math\n\ndef solve(n, points):\n    # Sort the points by their x-coordinate\n    sorted_points = sorted(points, key=lambda x: x[0])\n\n    # Initialize the minimum length of the shorter side of the triangle\n    min_length = math.inf\n\n    # Iterate through the points and find the optimal placement of the triangle\n    for i in range(n):\n        # Calculate the length of the side of the triangle that is parallel to the x-axis\n        side_length = sorted_points[i][0] - sorted_points[i - 1][0]\n\n        # Calculate the length of the side of the triangle that is parallel to the y-axis\n        side_length_y = sorted_points[i][1] - sorted_points[i - 1][1]\n\n        # Calculate the length of the shorter side of the triangle\n        shorter_side_length = min(side_length, side_length_y)\n\n        # Update the minimum length of the shorter side of the triangle\n        min_length = min(min_length, shorter_side_length)\n\n    return min_length\n\nn = int(input())\npoints = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\nprint(solve(n, points))"}
{"solution": "def max_nineteens(s):\n    from collections import Counter\n    \n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # Define the required frequency of each character in the word \"nineteen\"\n    required_counts = {'n': 3, 'i': 1, 'e': 3, 't': 1}\n    \n    # Calculate the maximum number of \"nineteen\" words that can be formed\n    max_nineteens = float('inf')\n    for char, required in required_counts.items():\n        if char in char_count:\n            max_nineteens = min(max_nineteens, char_count[char] // required)\n        else:\n            return 0  # If any required character is missing, we can't form \"nineteen\"\n    \n    return max_nineteens"}
{"solution": "import sys\n\ndef main():\n    p, y = map(int, sys.stdin.readline().split())\n    if p > y:\n        print(-1)\n        return\n\n    # Find the highest branch that is not a multiple of any number from 2 to p\n    for i in range(p, y + 1):\n        if i % p!= 0:\n            print(i)\n            return\n\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nn, m, k = map(int, input().split())\nprices = list(map(int, input().split()))\n\n# Initialize the minimum distance to a large value\nmin_distance = sys.maxsize\n\n# Iterate through the houses and check if they are available and within budget\nfor i in range(n):\n    if prices[i] <= k and i!= m:\n        distance = abs(m - i) * 10\n        if distance < min_distance:\n            min_distance = distance\n\nprint(min_distance)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nA = [[int(x) for x in input().split()] for _ in range(n)]\nB = [[int(x) for x in input().split()] for _ in range(n)]\n\n# Initialize a matrix C to store the result of the transformation\nC = [[0] * m for _ in range(n)]\n\n# Iterate through each row of A and perform the transformation\nfor i in range(n):\n    for j in range(m):\n        # Find the square submatrix of size k that contains the element A[i][j]\n        k = 1\n        while k <= min(n - i, m - j):\n            # Check if the submatrix is a square\n            if k * k == (n - i) * (m - j):\n                # Transpose the submatrix and store the result in C\n                for x in range(i, i + k):\n                    for y in range(j, j + k):\n                        C[x][y] = A[x][y]\n                break\n            k += 1\n\n# Check if C is equal to B\nif C == B:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\na = sys.stdin.readline().strip()\nb = sys.stdin.readline().strip()\n\n# Initialize variables\nlongest_uncommon_subsequence = -1\n\n# Iterate over each character in a\nfor i in range(len(a)):\n    # Check if the character is not in b\n    if a[i] not in b:\n        # If it's not in b, it's an uncommon subsequence\n        longest_uncommon_subsequence = max(longest_uncommon_subsequence, len(a[i:]))\n\n# Iterate over each character in b\nfor i in range(len(b)):\n    # Check if the character is not in a\n    if b[i] not in a:\n        # If it's not in a, it's an uncommon subsequence\n        longest_uncommon_subsequence = max(longest_uncommon_subsequence, len(b[i:]))\n\n# Print the longest uncommon subsequence\nprint(longest_uncommon_subsequence)"}
{"solution": "import sys\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate the least common multiple (LCM) of a and c\nlcm = a * c // gcd(a, c)\n\n# Calculate the first time Rick and Morty will scream at the same time\ntime = (lcm // a) * b + (lcm // c) * d\n\n# Print the output\nprint(time)"}
{"solution": "n = int(input())\n\n# Initialize variables\na = 0\nb = 0\nc = 0\n\n# Find a solution\nwhile a + b + c!= n:\n    a += 1\n    b += 1\n    c += 1\n\n# Check if a, b, or c is a multiple of 3\nif a % 3 == 0 or b % 3 == 0 or c % 3 == 0:\n    a -= 1\n    b -= 1\n    c -= 1\n\n# Print the solution\nprint(a, b, c)"}
{"solution": "import itertools\n\ndef get_distinct_squares(n, a, b, c, d):\n    # Initialize an empty list to store the distinct squares\n    distinct_squares = []\n\n    # Iterate over all possible combinations of integers in the square\n    for combination in itertools.combinations(range(1, n+1), 9):\n        # Check if the current combination satisfies all the conditions\n        if satisfies_conditions(combination, a, b, c, d):\n            # Add the current combination to the list of distinct squares\n            distinct_squares.append(combination)\n\n    # Return the list of distinct squares\n    return distinct_squares\n\ndef satisfies_conditions(combination, a, b, c, d):\n    # Check if the sum of integers in each of four squares 2 \u00d7 2 is equal to the sum of integers in the top left square 2 \u00d7 2\n    if sum(combination[0:4])!= sum(combination[4:8]):\n        return False\n\n    # Check if the sum of integers in each of four squares 2 \u00d7 2 is equal to the sum of integers in the top right square 2 \u00d7 2\n    if sum(combination[0:4])!= sum(combination[6:8]):\n        return False\n\n    # Check if the sum of integers in each of four squares 2 \u00d7 2 is equal to the sum of integers in the bottom left square 2 \u00d7 2\n    if sum(combination[2:4])!= sum(combination[4:6]):\n        return False\n\n    # Check if the sum of integers in each of four squares 2 \u00d7 2 is equal to the sum of integers in the bottom right square 2 \u00d7 2\n    if sum(combination[2:4])!= sum(combination[6:8]):\n        return False\n\n    # If all conditions are satisfied, return True\n    return True\n\n# Test the function\nn = 3\na = 3\nb = 1\nc = 2\nd = 3\ndistinct_squares = get_distinct_squares(n, a, b, c, d)\nprint(distinct_squares)"}
{"solution": "def snowball_weight(w, h, u1, d1, u2, d2):\n    # Initialize the snowball's weight and height\n    snowball_weight = w\n    snowball_height = h\n\n    # Loop through each second of the snowball's descent\n    for i in range(h):\n        # Increase the snowball's weight by its current height\n        snowball_weight += snowball_height\n\n        # Check if the snowball has hit a stone\n        if snowball_height in [d1, d2]:\n            # If so, decrease the snowball's weight by the weight of the stone\n            snowball_weight -= u1 if snowball_height == d1 else u2\n\n        # Move the snowball one meter down\n        snowball_height -= 1\n\n    # Return the final weight of the snowball\n    return snowball_weight"}
{"solution": "import sys\n\ndef get_passing_rate(scores, x, y):\n    # Sort the scores in descending order\n    sorted_scores = sorted(scores, reverse=True)\n\n    # Initialize the passing rate to the highest score\n    passing_rate = sorted_scores[0]\n\n    # Loop through the scores and find the first score that satisfies the size constraints\n    for score in sorted_scores:\n        if score >= x and score <= y:\n            passing_rate = score\n            break\n\n    return passing_rate\n\nif __name__ == \"__main__\":\n    m = int(input())\n    scores = list(map(int, input().split()))\n    x, y = map(int, input().split())\n\n    passing_rate = get_passing_rate(scores, x, y)\n\n    if passing_rate == 0:\n        print(\"0\")\n    else:\n        print(passing_rate)"}
{"solution": "def solve(n, k, A, B):\n    x = n\n    cost = 0\n    while x > 1:\n        if x % k == 0:\n            x //= k\n            cost += B\n        else:\n            x -= 1\n            cost += A\n    return cost"}
{"solution": "  import math\n\ndef solve(n):\n    # Initialize the minimum value and the minimum number of operations\n    min_value = math.inf\n    min_ops = math.inf\n    \n    # Loop through all possible values of x\n    for x in range(1, int(math.sqrt(n)) + 1):\n        # Calculate the new value after applying the mul operation\n        new_value = n * x\n        \n        # If the new value is less than the minimum value, update the minimum value and the minimum number of operations\n        if new_value < min_value:\n            min_value = new_value\n            min_ops = 1\n        \n        # If the new value is equal to the minimum value, update the minimum number of operations\n        elif new_value == min_value:\n            min_ops = 1\n    \n    # Loop through all possible values of y\n    for y in range(1, int(math.sqrt(min_value)) + 1):\n        # Calculate the new value after applying the sqrt operation\n        new_value = math.sqrt(min_value)\n        \n        # If the new value is less than the minimum value, update the minimum value and the minimum number of operations\n        if new_value < min_value:\n            min_value = new_value\n            min_ops = 2\n        \n        # If the new value is equal to the minimum value, update the minimum number of operations\n        elif new_value == min_value:\n            min_ops = 2\n    \n    # Return the minimum value and the minimum number of operations\n    return min_value, min_ops\n\nn = int(input())\nprint(solve(n))"}
{"solution": "import sys\n\ndef get_max_score(N, K, R, S, P, T):\n    # Initialize variables\n    max_score = 0\n    hand_history = []\n    current_hand = None\n\n    # Iterate through each round\n    for i in range(N):\n        # Get the machine's hand for this round\n        machine_hand = T[i]\n\n        # If this is the first K rounds, choose any hand\n        if i < K:\n            current_hand = \"r\" if machine_hand == \"s\" else \"s\" if machine_hand == \"p\" else \"p\"\n\n        # Otherwise, choose the hand that will give the highest score\n        else:\n            # Get the previous K hands played by the machine\n            previous_hands = hand_history[-K:]\n\n            # If the machine played the same hand as the previous K rounds, choose the other hand\n            if machine_hand in previous_hands:\n                current_hand = \"r\" if machine_hand == \"s\" else \"s\" if machine_hand == \"p\" else \"p\"\n\n            # Otherwise, choose the hand that will give the highest score\n            else:\n                # Get the score for each hand\n                r_score = R if machine_hand == \"r\" else 0\n                s_score = S if machine_hand == \"s\" else 0\n                p_score = P if machine_hand == \"p\" else 0\n\n                # Choose the hand with the highest score\n                current_hand = \"r\" if r_score > s_score and r_score > p_score else \"s\" if s_score > r_score and s_score > p_score else \"p\"\n\n        # Add the current hand to the hand history\n        hand_history.append(current_hand)\n\n        # Get the score for this round\n        score = R if current_hand == \"r\" else S if current_hand == \"s\" else P\n\n        # Update the maximum score\n        max_score += score\n\n    # Return the maximum score\n    return max_score\n\n# Read input from stdin\nN, K, R, S, P = map(int, input().split())\nT = input()\n\n# Get the maximum score\nmax_score = get_max_score(N, K, R, S, P, T)\n\n# Print the maximum score\nprint(max_score)"}
{"solution": "import sys\n\ndef get_longest_good_string(a, b, c):\n    # Initialize variables\n    longest_good_string = \"\"\n    current_string = \"\"\n    current_string_length = 0\n\n    # Iterate through the strings\n    for i in range(a):\n        current_string += \"a\"\n        current_string_length += 1\n        if current_string_length > len(longest_good_string):\n            longest_good_string = current_string\n\n    for i in range(b):\n        current_string += \"b\"\n        current_string_length += 1\n        if current_string_length > len(longest_good_string):\n            longest_good_string = current_string\n\n    for i in range(c):\n        current_string += \"ab\"\n        current_string_length += 2\n        if current_string_length > len(longest_good_string):\n            longest_good_string = current_string\n\n    return longest_good_string\n\n# Read input from stdin\na, b, c = map(int, input().split())\n\n# Get the longest good string\nlongest_good_string = get_longest_good_string(a, b, c)\n\n# Print the output\nprint(len(longest_good_string))"}
{"solution": "import math\n\ndef get_marks(n, k, p, x, y, a):\n    # Calculate the sum of marks for the remaining tests\n    sum_marks = x - sum(a)\n\n    # Calculate the median point\n    median = math.floor(sum_marks / 2)\n\n    # Check if the median point is less than y\n    if median < y:\n        return -1\n\n    # Calculate the number of tests needed to reach the desired sum of marks\n    num_tests = math.ceil(sum_marks / p)\n\n    # Calculate the marks needed for each test\n    marks = [math.ceil(sum_marks / num_tests)] * num_tests\n\n    # Check if the marks are within the allowed range\n    if any(mark > p for mark in marks):\n        return -1\n\n    return marks\n\n\nif __name__ == \"__main__\":\n    n, k, p, x, y = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(*get_marks(n, k, p, x, y, a))"}
{"solution": "def is_berlanese(s):\n    vowels = [\"a\", \"o\", \"u\", \"i\", \"e\"]\n    consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    for i in range(len(s)):\n        if s[i] in consonants:\n            if i == len(s) - 1 or s[i + 1] not in vowels:\n                return \"NO\"\n        elif s[i] in vowels:\n            if i == len(s) - 1 or s[i + 1] in consonants:\n                return \"NO\"\n    return \"YES\""}
{"solution": "import sys\n\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Initialize a dictionary to store the number of dominoes placed on each vertex\ndominoes = {i: 0 for i in range(1, n + 1)}\n\n# Iterate through the edges and place dominoes on them\nfor edge in edges:\n    # Get the vertices of the edge\n    v1, v2 = edge\n    \n    # Check if the vertices have the same number of dominoes placed on them\n    if dominoes[v1] == dominoes[v2]:\n        # If they do, place a domino on the edge\n        dominoes[v1] += 1\n        dominoes[v2] += 1\n\n# Print the maximum number of dominoes placed on the edges\nprint(max(dominoes.values()))"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauction_questions = set(map(int, input().split()))\n\ndef calculate_points(prices, auction_questions):\n    points = 0\n    for i, price in enumerate(prices):\n        if i in auction_questions:\n            points += price\n        else:\n            points += price\n    return points\n\nprint(calculate_points(prices, auction_questions))"}
{"solution": "import math\n\ndef compute_score(submission_times, wrong_submissions, successful_hacks, unsuccessful_hacks):\n    scores = []\n    for i in range(len(submission_times)):\n        time = submission_times[i]\n        wrong = wrong_submissions[i]\n        max_points = 500 * (i + 1)\n        score = max(0.3 * max_points, (1 - time / 250) * max_points - 50 * wrong)\n        scores.append(score)\n    total_score = sum(scores)\n    total_score += successful_hacks * 100\n    total_score -= unsuccessful_hacks * 50\n    return total_score\n\nsubmission_times = [20, 40, 60, 80, 100]\nwrong_submissions = [0, 1, 2, 3, 4]\nsuccessful_hacks = 1\nunsuccessful_hacks = 0\n\nprint(compute_score(submission_times, wrong_submissions, successful_hacks, unsuccessful_hacks))"}
{"solution": "import sys\n\nn, m, L, R = map(int, input().split())\n\n# Initialize a 2D array to store the number of cubes in each cell\ngrid = [[0] * m for _ in range(n)]\n\n# Initialize a set to store the visited states\nvisited = set()\n\n# Initialize a queue to store the states to be processed\nqueue = [(0, 0)]\n\n# Initialize a variable to store the number of states that can be reached\ncount = 0\n\n# Loop until the queue is empty\nwhile queue:\n    # Dequeue a state from the queue\n    state = queue.pop(0)\n\n    # If the state is not visited before, mark it as visited and increment the count\n    if state not in visited:\n        visited.add(state)\n        count += 1\n\n        # If the state is a goal state, add it to the queue\n        if is_goal_state(state):\n            queue.append(state)\n\n# Print the number of states that can be reached\nprint(count % 998244353)\n\n# Define a function to check if a state is a goal state\ndef is_goal_state(state):\n    # Check if all cells have the same number of cubes\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j]!= grid[0][0]:\n                return False\n\n    # Check if all cells are within the given range\n    for i in range(n):\n        for j in range(m):\n            if not L <= grid[i][j] <= R:\n                return False\n\n    return True"}
{"solution": "def is_possible_to_make_increasing(n, m, matrix_a, matrix_b):\n    for i in range(n):\n        for j in range(m):\n            # Ensure that matrix_a[i][j] is the smaller or equal element\n            if matrix_a[i][j] > matrix_b[i][j]:\n                matrix_a[i][j], matrix_b[i][j] = matrix_b[i][j], matrix_a[i][j]\n    \n    # Check rows for strictly increasing property\n    for i in range(n):\n        for j in range(1, m):\n            if matrix_a[i][j] <= matrix_a[i][j-1] or matrix_b[i][j] <= matrix_b[i][j-1]:\n                return \"Impossible\"\n    \n    # Check columns for strictly increasing property\n    for j in range(m):\n        for i in range(1, n):\n            if matrix_a[i][j] <= matrix_a[i-1][j] or matrix_b[i][j] <= matrix_b[i-1][j]:\n                return \"Impossible\"\n    \n    return \"Possible\""}
{"solution": ""}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate the minimum number of problems to solve on other judges\nmin_problems = 0\nfor i in range(n):\n    if a[i] > k:\n        min_problems += 1\n\nprint(min_problems)"}
{"solution": "n = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\n# Calculate the maximum number of diplomas that can be given to each degree\nmax_1_diplomas = max_1 - min_1 + 1\nmax_2_diplomas = max_2 - min_2 + 1\nmax_3_diplomas = max_3 - min_3 + 1\n\n# Initialize the number of diplomas for each degree to 0\nnum_1_diplomas = 0\nnum_2_diplomas = 0\nnum_3_diplomas = 0\n\n# Loop through each student and assign a diploma based on their performance\nfor i in range(n):\n    # Determine the student's performance based on their rank\n    rank = i + 1\n    if rank <= max_1:\n        num_1_diplomas += 1\n    elif rank <= max_2:\n        num_2_diplomas += 1\n    else:\n        num_3_diplomas += 1\n\n# Print the number of diplomas for each degree\nprint(num_1_diplomas, num_2_diplomas, num_3_diplomas)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Check if the size of the moon is increasing or decreasing\nif a[n-1] < a[n-2]:\n    print(\"DOWN\")\nelif a[n-1] > a[n-2]:\n    print(\"UP\")\nelse:\n    print(-1)"}
{"solution": "s = input().strip()\nt = input().strip()\n\nvowels = {'a', 'e', 'i', 'o', 'u'}\n\nif len(s)!= len(t):\n    print(\"No\")\n    exit()\n\nfor char_s, char_t in zip(s, t):\n    if (char_s in vowels)!= (char_t in vowels):\n        print(\"No\")\n        exit()\n\nprint(\"Yes\")"}
{"solution": "def pawn_chess(board):\n    # Initialize variables\n    player_a_pawns = []\n    player_b_pawns = []\n    winner = None\n\n    # Parse the board\n    for row in range(8):\n        for col in range(8):\n            if board[row][col] == 'B':\n                player_b_pawns.append((row, col))\n            elif board[row][col] == 'W':\n                player_a_pawns.append((row, col))\n\n    # Check if either player has won\n    for pawn in player_a_pawns:\n        if pawn[0] == 1:\n            winner = 'A'\n            break\n    if winner is None:\n        for pawn in player_b_pawns:\n            if pawn[0] == 8:\n                winner = 'B'\n                break\n\n    # Return the winner\n    return winner"}
{"solution": "n = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\nif sum(A)!= sum(B):\n    print(-1)\n    exit()\n\ni, j = 0, 0\nsumA, sumB = 0, 0\ncount = 0\n\nwhile i < n and j < m:\n    sumA += A[i]\n    sumB += B[j]\n    \n    if sumA == sumB:\n        count += 1\n        sumA = 0\n        sumB = 0\n        i += 1\n        j += 1\n    elif sumA < sumB:\n        i += 1\n    else:\n        j += 1\n\nprint(count)"}
{"solution": "def is_from_contest(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    for friend in friends:\n        if friend in problem_name:\n            return \"YES\"\n    return \"NO\""}
{"solution": "def min_length_with_k_primes(a, b, k):\n    is_prime = sieve(b)\n    prime_count = count_primes_in_range(is_prime, a, b)\n    \n    def has_k_primes_in_length(l):\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] >= k:\n                return True\n        return False\n    \n    left, right = 1, b - a + 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if has_k_primes_in_length(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result"}
{"solution": "import math\n\ndef solve(a, h, w):\n    # Calculate the minimum value of x\n    x = min(a, h, w) / 2\n\n    # Check if the photos can be arranged in a rectangular grid\n    if a * h!= w * w:\n        return -1\n\n    # Calculate the number of rows and columns\n    rows = h // a\n    cols = w // a\n\n    # Check if the distances between neighboring vertically and horizontally photos and also the distances between outside rows and columns of photos to the nearest bound of the wall are equal to x\n    if not all(i % x == 0 for i in range(1, rows + 1)):\n        return -1\n    if not all(i % x == 0 for i in range(1, cols + 1)):\n        return -1\n\n    return x\n\na, h, w = map(int, input().split())\nprint(solve(a, h, w))"}
{"solution": "n = int(input())\nchapters = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    chapters.append((l, r))\nk = int(input())\n\nnot_read_chapters = 0\nfor chapter in chapters:\n    if chapter[0] <= k <= chapter[1]:\n        not_read_chapters += 1\n\nprint(not_read_chapters)"}
{"solution": "def can_form_codeforces(word):\n    target = \"CODEFORCES\"\n    n = len(word)\n    m = len(target)\n    \n    if n < m:\n        return \"NO\"\n    \n    for i in range(m + 1):\n        if word[:i] == target[:i] and word[n - (m - i):] == target[i:]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Example usage:\nprint(can_form_codeforces(\"CODEWAITFORITFORCES\"))  # Output: YES\nprint(can_form_codeforces(\"BOTTOMCODER\"))          # Output: NO\nprint(can_form_codeforces(\"DECODEFORCES\"))         # Output: YES\nprint(can_form_codeforces(\"DOGEFORCES\"))           # Output: NO"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\n# Calculate the minimum weight among all triangulations of the polygon\nmin_weight = 0\n\n# Iterate over all possible triangulations of the polygon\nfor i in range(1, n):\n    for j in range(i + 1, n):\n        for k in range(j + 1, n):\n            # Calculate the weight of the current triangulation\n            weight = i * j * k\n\n            # Update the minimum weight if necessary\n            if weight < min_weight or min_weight == 0:\n                min_weight = weight\n\n# Print the minimum weight\nprint(min_weight)"}
{"solution": "n = int(input())\n\n# Calculate the number of digits needed to number all the books\ndigits = 1\nwhile n > 0:\n    n //= 10\n    digits += 1\n\nprint(digits)"}
{"solution": "import sys\n\nn, A = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Initialize the counts for Alice and Bob\ncnt_A = [0] * (n + 1)\ncnt_B = [0] * (n + 1)\n\n# Set the initial count for Alice's color\ncnt_A[0] = 1\n\n# Iterate through the colors and update the counts\nfor i in range(1, n + 1):\n    cnt_A[i] = cnt_A[i - 1] + (colors[i - 1] == A)\n    cnt_B[i] = cnt_B[i - 1] + (colors[i - 1]!= A)\n\n# Find the color that gives Bob the highest count\nmax_cnt_B = max(cnt_B)\ncolor_B = colors[cnt_B.index(max_cnt_B)]\n\n# Print the output\nprint(color_B)"}
{"solution": "import sys\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Check if the encoding is valid\nif len(a)!= n:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the encoding is unique\nif len(set(a))!= len(a):\n    print(\"NO\")\n    sys.exit()\n\n# Check if the encoding forms a crossword of the correct length\nif sum(a)!= x:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the encoding forms a crossword with no intersecting segments\nfor i in range(n - 1):\n    if a[i] > 0 and a[i + 1] > 0:\n        print(\"NO\")\n        sys.exit()\n\nprint(\"YES\")"}
{"solution": "import sys\n\nn, S = map(int, sys.stdin.readline().split())\n\ncoins = [i for i in range(1, n+1)]\n\ndef get_min_coins(coins, S):\n    if not coins:\n        return 0\n    if coins[0] == S:\n        return 1\n    if coins[0] > S:\n        return get_min_coins(coins[1:], S)\n    return 1 + get_min_coins(coins[1:], S-coins[0])\n\nprint(get_min_coins(coins, S))"}
{"solution": "import sys\n\ndef get_lexicographically_smallest_palindrome(s):\n    # Initialize variables\n    changes = 0\n    palindrome = \"\"\n    # Loop through the string and count the number of changes needed\n    for i in range(len(s)):\n        if s[i]!= s[-i-1]:\n            changes += 1\n            palindrome += s[i]\n    # If the string is already a palindrome, return it\n    if changes == 0:\n        return s\n    # If the string is not a palindrome, find the lexicographically smallest palindrome\n    else:\n        # Loop through the string and find the lexicographically smallest palindrome\n        for i in range(len(s)):\n            if s[i]!= s[-i-1]:\n                if s[i] < s[-i-1]:\n                    palindrome = s[:i] + s[i] + s[i+1:] + s[i] + s[:i]\n                else:\n                    palindrome = s[:i] + s[-i-1] + s[i+1:] + s[-i-1] + s[:i]\n        return palindrome\n\n# Get the input string\ns = sys.stdin.readline().strip()\n\n# Get the lexicographically smallest palindrome\npalindrome = get_lexicographically_smallest_palindrome(s)\n\n# Print the output\nprint(palindrome)"}
{"solution": "def calculate_weight(board):\n    piece_weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n    }\n    \n    white_weight = 0\n    black_weight = 0\n    \n    for row in board:\n        for piece in row:\n            if piece in piece_weights:\n                if piece.isupper():\n                    white_weight += piece_weights[piece]\n                else:\n                    black_weight += piece_weights[piece]\n    \n    if white_weight > black_weight:\n        return \"White\"\n    elif black_weight > white_weight:\n        return \"Black\"\n    else:\n        return \"Draw\""}
{"solution": "import sys\n\ndef solve(N, M, S):\n    # Initialize the sequence of numbers coming up in the roulette\n    sequence = []\n\n    # Initialize the current square\n    current_square = 0\n\n    # Initialize the number of turns taken\n    turns_taken = 0\n\n    # While the current square is not Square N\n    while current_square!= N:\n        # Spin the roulette\n        number = roulette(M)\n\n        # Add the number to the sequence\n        sequence.append(number)\n\n        # Move to the next square\n        current_square += number\n\n        # If the current square is a Game Over Square, break\n        if S[current_square] == 1:\n            break\n\n        # Increment the number of turns taken\n        turns_taken += 1\n\n    # If the current square is Square N, return the sequence\n    if current_square == N:\n        return sequence\n\n    # Otherwise, return -1\n    return -1\n\ndef roulette(M):\n    # Return a random number between 1 and M\n    return random.randint(1, M)\n\nif __name__ == \"__main__\":\n    # Read the input from stdin\n    N, M, S = map(int, sys.stdin.readline().split())\n\n    # Solve the problem\n    sequence = solve(N, M, S)\n\n    # Print the output\n    if sequence == -1:\n        print(-1)\n    else:\n        print(\" \".join(map(str, sequence)))"}
{"solution": "import math\n\ndef manhattan_distance(x1, y1, x2, y2):\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef find_lowest_score_path(k, x, y):\n    # Initialize the position of the ball as (0, 0)\n    position = (0, 0)\n    # Initialize the score as 0\n    score = 0\n    # Initialize the path as an empty list\n    path = []\n\n    # While the position of the ball is not the goal\n    while position!= (x, y):\n        # Find the next position of the ball based on the Manhattan distance constraint\n        next_position = find_next_position(position, k)\n        # Calculate the Manhattan distance between the current position and the next position\n        distance = manhattan_distance(position[0], position[1], next_position[0], next_position[1])\n        # Update the score based on the Manhattan distance\n        score += distance\n        # Add the next position to the path\n        path.append(next_position)\n        # Update the position of the ball to the next position\n        position = next_position\n\n    # Return the lowest score and the path\n    return score, path\n\ndef find_next_position(position, k):\n    # Find the possible positions that are within the Manhattan distance constraint\n    possible_positions = [(position[0] + i, position[1] + j) for i in range(-k, k + 1) for j in range(-k, k + 1)]\n    # Filter out the positions that are not valid\n    valid_positions = [position for position in possible_positions if position[0] >= 0 and position[1] >= 0 and position[0] <= x and position[1] <= y]\n    # Return the first valid position\n    return valid_positions[0]\n\n# Test case 1\nk = 11\nx = 2\ny = 10\nscore, path = find_lowest_score_path(k, x, y)\nprint(score)\nprint(path)\n\n# Test case 2\nk = 11\nx = -1\ny = 2\nscore, path = find_lowest_score_path(k, x, y)\nprint(score)\nprint(path)"}
{"solution": ""}
{"solution": "import math\n\ndef get_intersection_area(circle1, circle2):\n    x1, y1, r1 = circle1\n    x2, y2, r2 = circle2\n    d = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    if d > r1 + r2:\n        return 0\n    if d < abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n    h = (r1 ** 2 - r2 ** 2 + d ** 2) / (2 * d)\n    return math.acos(h / r1) * r1 ** 2\n\nif __name__ == \"__main__\":\n    circle1 = tuple(map(int, input().split()))\n    circle2 = tuple(map(int, input().split()))\n    print(get_intersection_area(circle1, circle2))"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\n# Initialize the minimum value of n to n itself\nmin_n = n\n\n# Iterate through all possible values of x\nfor x in range(1, n):\n    # If x is not a divisor of n, subtract x from n and update the minimum value\n    if n % x!= 0:\n        min_n = min(min_n, n - x)\n\nprint(min_n)"}
{"solution": "import sys\n\nn = int(input())\np = list(map(int, input().split()))\na = list(map(int, input().split()))\n\n# Initialize the number of citizens caught by the bandit to 0\ncaught = 0\n\n# Iterate through each square\nfor i in range(n):\n    # If the square has no outgoing roads, the bandit can't move from it\n    if p[i] == 0:\n        continue\n    \n    # If the square has outgoing roads, the bandit can move from it\n    # Increment the number of citizens caught by the bandit\n    caught += a[i]\n\n# Print the number of citizens caught by the bandit\nprint(caught)"}
{"solution": "n = int(input())\nS = input().strip()\nT = input().strip()\n\ncount = 0\nfor i in range(n + 1):\n    # Construct W by inserting a character at position i in both S and T\n    if i == 0:\n        W1 = S[0] + S\n        W2 = T[0] + T\n    elif i == n:\n        W1 = S + S[-1]\n        W2 = T + T[-1]\n    else:\n        W1 = S[:i] + S[i] + S[i:]\n        W2 = T[:i] + T[i] + T[i:]\n    \n    # Check if the constructed words are the same\n    if W1 == W2:\n        count += 1\n\nprint(count)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\nwires = []\nfor i in range(n - 1):\n    u, v = map(int, input().split())\n    wires.append((u, v))\n\n# Initialize the strength of the computer\ncomputer_strength = 0\n\n# Initialize the list of banks to be hacked\nbanks_to_hack = []\n\n# Add the first bank to be hacked\nbanks_to_hack.append(1)\n\n# Loop through the banks to be hacked\nwhile len(banks_to_hack) < n:\n    # Get the current bank to be hacked\n    current_bank = banks_to_hack[-1]\n\n    # Find the next bank to be hacked\n    next_bank = None\n    for bank in range(1, n + 1):\n        if bank not in banks_to_hack and (current_bank, bank) in wires:\n            next_bank = bank\n            break\n\n    # Add the next bank to be hacked\n    banks_to_hack.append(next_bank)\n\n# Calculate the minimum strength of the computer\nfor bank in banks_to_hack:\n    computer_strength = max(computer_strength, a[bank - 1])\n\nprint(computer_strength)"}
{"solution": "n, m = map(int, input().split())\nprint(min(m, n - m))"}
{"solution": "import sys\n\ndef main():\n    k, r = map(int, sys.stdin.readline().split())\n    shovels = 0\n    while k * shovels < 10 * r:\n        shovels += 1\n    print(shovels)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # Dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Extract the bounding box\n    piece = []\n    for i in range(min_row, max_row + 1):\n        piece.append(grid[i][min_col:max_col + 1])\n    \n    # Check horizontal placement\n    if width * 2 == m:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j]!= piece[i][j + width]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    # Check vertical placement\n    if height * 2 == n:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j]!= piece[i + height][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "def get_min_segments(x1, y1, x2, y2, x3, y3):\n    # Check for collinearity on the same axis\n    if x1 == x2 == x3 or y1 == y2 == y3:\n        return 1\n\n    # Check for two points sharing the same coordinate\n    if (x1 == x2 and x3!= x2) or (y1 == y2 and y3!= y2):\n        return 2\n\n    # General case\n    return 3\n\nif __name__ == \"__main__\":\n    x1, y1 = map(int, input().split())\n    x2, y2 = map(int, input().split())\n    x3, y3 = map(int, input().split())\n    print(get_min_segments(x1, y1, x2, y2, x3, y3))"}
{"solution": "import sys\n\ndef is_k_regular(graph, k):\n    for vertex in graph:\n        if len(graph[vertex])!= k:\n            return False\n    return True\n\ndef is_connected(graph):\n    visited = set()\n    queue = [0]\n    while queue:\n        vertex = queue.pop(0)\n        if vertex not in visited:\n            visited.add(vertex)\n            queue.extend(graph[vertex])\n    return len(visited) == len(graph)\n\ndef is_bridge(graph, edge):\n    graph[edge[0]].remove(edge[1])\n    graph[edge[1]].remove(edge[0])\n    connected = is_connected(graph)\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n    return not connected\n\ndef find_bridge(graph):\n    for edge in graph:\n        if is_bridge(graph, edge):\n            return edge\n    return None\n\ndef construct_graph(k):\n    graph = {}\n    for i in range(k):\n        graph[i] = []\n    for i in range(k):\n        for j in range(i+1, k):\n            graph[i].append(j)\n            graph[j].append(i)\n    bridge = find_bridge(graph)\n    if bridge is None:\n        print(\"NO\")\n        return\n    print(\"YES\")\n    print(k, k-1)\n    for i in range(k):\n        for j in range(i+1, k):\n            if (i, j) == bridge:\n                print(i, j)\n            elif (j, i) == bridge:\n                print(j, i)\n\nif __name__ == \"__main__\":\n    k = int(sys.stdin.readline().strip())\n    construct_graph(k)"}
{"solution": "import sys\n\nn, m, q = map(int, input().split())\ns = input()\nt = input()\n\n# Initialize a dictionary to store the occurrences of t in s\noccurrences = {}\n\n# Iterate through each substring of s and count the occurrences of t\nfor i in range(n - m + 1):\n    substring = s[i:i+m]\n    if substring not in occurrences:\n        occurrences[substring] = 0\n    if t in substring:\n        occurrences[substring] += 1\n\n# Print the number of occurrences for each query\nfor _ in range(q):\n    l, r = map(int, input().split())\n    print(occurrences[s[l:r+1]])"}
{"solution": "  import sys\n\nn, k, d = map(int, sys.stdin.readline().split())\n\n# Initialize the dp array with 0s\ndp = [0] * (n + 1)\n\n# Base case: dp[0] = 1\ndp[0] = 1\n\n# Fill the dp array\nfor i in range(1, n + 1):\n    for j in range(1, k + 1):\n        if i - j >= 0:\n            dp[i] = (dp[i] + dp[i - j]) % 1000000007\n\n# Print the answer\nprint(dp[n])"}
{"solution": "def encrypt_japanese_crossword(n, row):\n    groups = []\n    count = 0\n    \n    for char in row:\n        if char == 'B':\n            count += 1\n        else:\n            if count > 0:\n                groups.append(count)\n                count = 0\n    \n    if count > 0:\n        groups.append(count)\n    \n    print(len(groups))\n    if groups:\n        print(\" \".join(map(str, groups)))\n\n# Example usage:\nn = int(input())\nrow = input().strip()\nencrypt_japanese_crossword(n, row)"}
{"solution": "import sys\n\nn, m, p = map(int, input().split())\nsequence = input()\noperations = input()\n\n# Initialize the cursor position\ncursor = p\n\n# Iterate through the operations\nfor operation in operations:\n    if operation == \"L\":\n        # Move the cursor to the left\n        cursor -= 1\n    elif operation == \"R\":\n        # Move the cursor to the right\n        cursor += 1\n    elif operation == \"D\":\n        # Delete the bracket at the cursor position\n        sequence = sequence[:cursor] + sequence[cursor + 1:]\n        # Update the cursor position\n        cursor = cursor - 1\n\n# Print the resulting sequence\nprint(sequence)"}
{"solution": "def guess_a_number(questions):\n    # Initialize y to a random integer between -2000000000 and 2000000000\n    y = random.randint(-2000000000, 2000000000)\n\n    # Iterate through the questions and answers\n    for question, answer in questions:\n        # If the question is \"Is it true that y is strictly larger than number x?\", check if y is larger than x\n        if question == \">\":\n            if y <= x:\n                return \"Impossible\"\n        # If the question is \"Is it true that y is strictly smaller than number x?\", check if y is smaller than x\n        elif question == \"<\":\n            if y >= x:\n                return \"Impossible\"\n        # If the question is \"Is it true that y is larger than or equal to number x?\", check if y is larger than or equal to x\n        elif question == \">=\":\n            if y < x:\n                return \"Impossible\"\n        # If the question is \"Is it true that y is smaller than or equal to number x?\", check if y is smaller than or equal to x\n        elif question == \"<=\":\n            if y > x:\n                return \"Impossible\"\n\n    # If all questions are answered correctly, return y\n    return y"}
{"solution": "import sys\n\ndef get_periods(a, b):\n    periods = set()\n    for i in range(1, a+b+1):\n        if i % 2 == 0:\n            periods.add(i)\n    return periods\n\na, b = map(int, input().split())\nperiods = get_periods(a, b)\nprint(len(periods))"}
{"solution": "def generate_names(n, k, conditions):\n    # Predefined list of unique names\n    names = [\"Adam\", \"Bob\", \"Charlie\", \"David\", \"Edward\", \"Frank\", \"George\", \"Henry\", \"Isaac\", \"Jack\"]\n    \n    # Initialize the result list with the first k names\n    result = names[:k]\n    \n    for i in range(1, n - k + 1):\n        if conditions[i - 1] == \"YES\":\n            # If the group should be effective, add a new unique name\n            result.append(names[k + i - 1])\n        else:\n            # If the group should not be effective, repeat the last name\n            result.append(result[-1])\n    \n    return result\n\n# Example input\nn = 8\nk = 3\nconditions = [\"NO\", \"NO\", \"YES\", \"YES\", \"YES\", \"NO\"]\n\n# Generate and print the names\nnames = generate_names(n, k, conditions)\nprint(\" \".join(names))"}
{"solution": "def min_operations_to_equal(a, b):\n    # Prime factorization of a and b\n    a_factors = prime_factors(a)\n    b_factors = prime_factors(b)\n\n    # Count the number of times each factor appears in a and b\n    a_counts = Counter(a_factors)\n    b_counts = Counter(b_factors)\n\n    # Calculate the minimum number of operations needed to make the pieces equal\n    operations = 0\n    for factor, count in a_counts.items():\n        if factor in b_counts:\n            operations += abs(count - b_counts[factor])\n        else:\n            operations += count\n\n    return operations\n\ndef prime_factors(n):\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n //= 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n    if n > 1:\n        factors.append(n)\n    return factors"}
{"solution": "def solve(n, a, b, c):\n    # Initialize variables\n    cost = 0\n    palindrome = True\n    leftmost_color = c[0]\n    rightmost_color = c[-1]\n\n    # Check if the colors form a palindrome\n    for i in range(n):\n        if c[i]!= c[n-i-1]:\n            palindrome = False\n            break\n\n    # If the colors form a palindrome, return the cost\n    if palindrome:\n        return cost\n\n    # If the colors don't form a palindrome, find the optimal solution\n    for i in range(n):\n        # If the leftmost dancer's suit is already bought, skip it\n        if c[i]!= 2:\n            continue\n\n        # If the rightmost dancer's suit is already bought, skip it\n        if c[n-i-1]!= 2:\n            continue\n\n        # If the leftmost dancer's suit is white and the rightmost dancer's suit is black, buy a black suit for the leftmost dancer and a white suit for the rightmost dancer\n        if c[i] == 0 and c[n-i-1] == 1:\n            cost += b\n            c[i] = 1\n            c[n-i-1] = 0\n\n        # If the leftmost dancer's suit is black and the rightmost dancer's suit is white, buy a white suit for the leftmost dancer and a black suit for the rightmost dancer\n        elif c[i] == 1 and c[n-i-1] == 0:\n            cost += a\n            c[i] = 0\n            c[n-i-1] = 1\n\n    # Return the cost\n    return cost"}
{"solution": "import sys\n\ndef paint_cube(k):\n    # Initialize the cube with all unit cubes white\n    cube = [[0] * k for _ in range(k)]\n\n    # Paint the cube layer by layer\n    for layer in range(k):\n        for row in range(k):\n            for col in range(k):\n                # If the current unit cube is white, check if it has exactly 2 white neighbors\n                if cube[layer][row][col] == 0:\n                    num_white_neighbors = 0\n                    for neighbor in get_neighbors(layer, row, col):\n                        if neighbor[0] == 0:\n                            num_white_neighbors += 1\n\n                    # If the current unit cube has exactly 2 white neighbors, paint it black\n                    if num_white_neighbors == 2:\n                        cube[layer][row][col] = 1\n\n    # Print the painted cube\n    for layer in range(k):\n        for row in range(k):\n            for col in range(k):\n                if cube[layer][row][col] == 0:\n                    print(\"w\", end=\"\")\n                else:\n                    print(\"b\", end=\"\")\n            print()\n        print()\n\ndef get_neighbors(layer, row, col):\n    # Get the neighbors of the current unit cube\n    neighbors = []\n    for i in range(layer - 1, layer + 2):\n        for j in range(row - 1, row + 2):\n            for k in range(col - 1, col + 2):\n                if i!= layer or j!= row or k!= col:\n                    neighbors.append((cube[i][j][k], i, j, k))\n    return neighbors\n\nif __name__ == \"__main__\":\n    k = int(input())\n    paint_cube(k)"}
{"solution": "import math\n\ndef largest_lovely_number(n):\n    prime_factors = []\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            prime_factors.append(i)\n            n //= i\n    if n > 1:\n        prime_factors.append(n)\n    lovely_number = 1\n    for prime in prime_factors:\n        lovely_number *= prime\n    return lovely_number\n\nn = int(input())\nprint(largest_lovely_number(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    # Check for adjacent occupied seats\n    for i in range(n - 1):\n        if seating[i] == '1' and seating[i + 1] == '1':\n            return \"No\"\n    \n    # Check for possible additional seating\n    for i in range(n):\n        if seating[i] == '0':\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                return \"No\"\n    \n    return \"Yes\""}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the possible values of k\nk_values = set(range(1, n + 1))\n\n# Iterate through each value of k\nfor k in k_values:\n    # Check if the length of the array is correct\n    if len(a)!= k:\n        # If the length is not correct, remove the value of k from the set\n        k_values.remove(k)\n        continue\n\n    # Check if the array is an arithmetic progression\n    for i in range(1, n):\n        if a[i]!= a[i - 1] + k:\n            # If the array is not an arithmetic progression, remove the value of k from the set\n            k_values.remove(k)\n            break\n\n# Print the number of possible values of k\nprint(len(k_values))\n\n# Print the possible values of k in increasing order\nprint(*sorted(k_values))"}
{"solution": "def can_build_teams_with_equal_score(scores):\n    # Sort the scores in descending order\n    sorted_scores = sorted(scores, reverse=True)\n\n    # Initialize the team scores to 0\n    team_scores = [0, 0]\n\n    # Iterate through the scores and add them to the teams\n    for score in sorted_scores:\n        # If the score is not already in a team, add it to the team with the lowest score\n        if score not in team_scores:\n            team_scores[team_scores.index(min(team_scores))] += score\n\n    # If the team scores are equal, return \"YES\"\n    if team_scores[0] == team_scores[1]:\n        return \"YES\"\n    # Otherwise, return \"NO\"\n    else:\n        return \"NO\"\n\n# Test the function with the given input\nscores = [1, 3, 2, 1, 2, 1]\nprint(can_build_teams_with_equal_score(scores))"}
{"solution": "import math\n\ndef count_23_integers(l, r):\n    count = 0\n    for i in range(l, r+1):\n        if is_23_integer(i):\n            count += 1\n    return count\n\ndef is_23_integer(n):\n    if n == 1:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    for i in range(2, int(math.sqrt(n))+1):\n        if n % i == 0:\n            return False\n    return True\n\nl, r = map(int, input().split())\nprint(count_23_integers(l, r))"}
{"solution": "n, k = map(int, input().split())\n\n# Initialize variables\nactions = 0\ncandies = 0\n\n# Iterate through the number of actions\nfor i in range(n):\n    # If the box is empty, put one candy in the box\n    if candies == 0:\n        candies += 1\n    # If the box is not empty, take one candy out and eat it\n    else:\n        candies -= 1\n        actions += 1\n\n# Print the number of candies eaten\nprint(actions)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Check if the sum of any three lengths is greater than the sum of the other lengths\nif sum(a[0:3]) > sum(a[3:]):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef is_possible(x, y):\n    if x == 0 and y == 0:\n        return \"Yes\"\n    if x < 0 or y < 0:\n        return \"No\"\n    if x == 1 and y == 1:\n        return \"Yes\"\n    if x == 1 and y > 1:\n        return \"No\"\n    if x > 1 and y == 1:\n        return \"No\"\n    if x > 1 and y > 1:\n        return \"Yes\"\n\nx, y = map(int, sys.stdin.readline().split())\nprint(is_possible(x, y))"}
{"solution": "import math\n\ndef get_maximum_total_rating(n, k, a):\n    # Calculate the initial total rating\n    total_rating = sum(math.floor(ai / 10) for ai in a)\n\n    # Identify improvement opportunities\n    improvement_opportunities = [(ai, math.ceil(ai / 10) * 10 - ai) for ai in a]\n\n    # Prioritize improvements\n    improvement_opportunities.sort(key=lambda x: x[1], reverse=True)\n\n    # Allocate units\n    for ai, improvement in improvement_opportunities:\n        if k == 0:\n            break\n        ai += improvement\n        k -= 1\n\n    # Recalculate total rating\n    total_rating = sum(math.floor(ai / 10) for ai in a)\n\n    return total_rating\n\nn = int(input())\nk = int(input())\na = list(map(int, input().split()))\nprint(get_maximum_total_rating(n, k, a))"}
{"solution": "def find_smallest_pretty_integer(n, m, list1, list2):\n    # Convert lists to sets for faster lookup\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check for common digits\n    common_digits = set1.intersection(set2)\n    if common_digits:\n        return min(common_digits)\n    \n    # If no common digits, find the smallest combination\n    min1 = min(list1)\n    min2 = min(list2)\n    \n    # Form the smallest two-digit number\n    smallest_pretty = min(int(str(min1) + str(min2)), int(str(min2) + str(min1)))\n    return smallest_pretty"}
{"solution": "n, k = map(int, input().split())\n\n# Calculate the total time needed to solve each problem\ntotal_time = [5 * i for i in range(1, n + 1)]\n\n# Calculate the maximum number of problems that can be solved within the time limit\nmax_problems = 0\nfor i in range(n):\n    if total_time[i] + k <= 240:\n        max_problems += 1\n\nprint(max_problems)"}
{"solution": "import sys\n\ndef max_teams(n, x, y, a):\n    # Sort the array a in ascending order\n    a.sort()\n    \n    # Initialize variables to track remaining sheets\n    double_sided = x\n    single_sided = y\n    count = 0\n    \n    for pages in a:\n        # First use sheets with two clean sides\n        double_needed = pages // 2\n        single_needed = pages % 2\n        \n        if double_needed <= double_sided:\n            double_sided -= double_needed\n            if single_needed <= single_sided:\n                single_sided -= single_needed\n                count += 1\n            else:\n                # If not enough sheets with one clean side\n                double_sided += double_needed  # Return used sheets\n                break\n        else:\n            # If not enough sheets with two clean sides\n            remaining_pages = pages - 2 * double_sided\n            if remaining_pages <= single_sided:\n                single_sided -= remaining_pages\n                double_sided = 0\n                count += 1\n            else:\n                break\n    \n    return count\n\n# Read input\nn, x, y = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\n\n# Print output\nprint(max_teams(n, x, y, a))"}
{"solution": "b = int(input())\n\ndef count_distinct_values(b):\n    divisors = set()\n    for i in range(1, int(b**0.5) + 1):\n        if b % i == 0:\n            divisors.add(i)\n            divisors.add(b // i)\n    return len(divisors)\n\nprint(count_distinct_values(b))"}
{"solution": "import sys\n\nn = int(input())\nbumpers = input()\n\n# Initialize a list to store the positions where the ball will fall from the field\nfalling_positions = []\n\n# Iterate through the bumpers and determine the positions where the ball will fall from the field\nfor i in range(n):\n    # If the bumper is a '<' bumper, the ball will move to the left\n    if bumpers[i] == '<':\n        # If the ball is at position 1, it will fall from the field\n        if i == 1:\n            falling_positions.append(1)\n        # If the ball is at any other position, it will move to the left and fall from the field if it reaches position 1\n        else:\n            falling_positions.append(i - 1)\n    # If the bumper is a '>' bumper, the ball will move to the right\n    else:\n        # If the ball is at position n, it will fall from the field\n        if i == n:\n            falling_positions.append(n)\n        # If the ball is at any other position, it will move to the right and fall from the field if it reaches position n\n        else:\n            falling_positions.append(i + 1)\n\n# Print the number of positions where the ball will fall from the field\nprint(len(falling_positions))"}
{"solution": "import sys\n\nn = int(input())\nsticks = [int(x) for x in input().split()]\n\n# Sort the sticks in descending order\nsticks.sort(reverse=True)\n\n# Initialize the maximum area\nmax_area = 0\n\n# Iterate through the sticks and form rectangles\nfor i in range(n):\n    for j in range(i+1, n):\n        # Check if the rectangle can be formed with the current stick lengths\n        if sticks[i] <= sticks[j]:\n            # Calculate the area of the rectangle\n            area = sticks[i] * sticks[j]\n            \n            # Check if the area is greater than the current maximum area\n            if area > max_area:\n                max_area = area\n                \n            # Break out of the inner loop if the maximum area has been reached\n            if max_area == 10000800015:\n                break\n                \n    # Break out of the outer loop if the maximum area has been reached\n    if max_area == 10000800015:\n        break\n        \n# Print the maximum area\nprint(max_area)"}
{"solution": "n = int(input())\n\n# Dictionary to map letters to digits\nletter_to_digit = {\n    'a': 1,\n    'b': 0,\n    'c': 2,\n    'd': 3,\n    'e': 4,\n    'f': 5,\n    'g': 6,\n    'h': 7,\n    'i': 8,\n    'j': 9\n}\n\n# List to store the restored numbers\nrestored_numbers = []\n\n# Loop through each string\nfor i in range(n):\n    # Get the current string\n    current_string = input()\n    \n    # Initialize the restored number to 0\n    restored_number = 0\n    \n    # Loop through each character in the string\n    for j in range(len(current_string)):\n        # Get the current character\n        current_character = current_string[j]\n        \n        # Get the digit corresponding to the character\n        digit = letter_to_digit[current_character]\n        \n        # Add the digit to the restored number\n        restored_number += digit * (10 ** (len(current_string) - j - 1))\n    \n    # Add the restored number to the list\n    restored_numbers.append(restored_number)\n\n# Print the minimum sum of the restored numbers\nprint(min(restored_numbers))"}
{"solution": "n, m = map(int, input().split())\n\n# Calculate the maximum number of teams that can be formed\nmax_teams = min(n, m, (n + m) // 3)\n\n# Print the result\nprint(max_teams)"}
{"solution": "def check_substrings(s):\n    n = len(s)\n    found_AB = False\n    found_BA = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"AB\":\n            found_AB = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"BA\":\n                    print(\"YES\")\n                    return\n            break\n        if s[i:i+2] == \"BA\":\n            found_BA = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"AB\":\n                    print(\"YES\")\n                    return\n            break\n    if not found_AB and not found_BA:\n        print(\"NO\")"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\nk = int(input())\nb = list(map(int, input().split()))\n\n# Check if the input is valid\nif n < 1 or n > 500:\n    print(\"NO\")\n    sys.exit()\nif k < 1 or k > n:\n    print(\"NO\")\n    sys.exit()\nif len(a)!= n:\n    print(\"NO\")\n    sys.exit()\nif len(b)!= k:\n    print(\"NO\")\n    sys.exit()\n\n# Initialize the queue with the initial weights\nqueue = a\n\n# Loop through the queue and check if the weights match\nfor i in range(n):\n    if queue[i]!= b[i]:\n        print(\"NO\")\n        sys.exit()\n\n# If the weights match, print the sequence of eatings\nprint(\"YES\")\nfor i in range(n - k):\n    if queue[i] > queue[i + 1]:\n        print(str(i + 1) + \" L\")\n    else:\n        print(str(i + 1) + \" R\")\n    queue[i] += queue[i + 1]\n    del queue[i + 1]"}
{"solution": "import sys\n\ndef is_perfect_matching(R, B, x, y):\n    # Initialize a graph with R nodes and B nodes\n    graph = {}\n    for i in range(R):\n        graph[i] = set()\n    for j in range(B):\n        graph[j + R] = set()\n\n    # Add edges between nodes based on the coordinates\n    for i in range(R):\n        for j in range(B):\n            if x[i] == x[j + R] or y[i] == y[j + R]:\n                graph[i].add(j + R)\n                graph[j + R].add(i)\n\n    # Check if there is a perfect matching\n    matching = []\n    for i in range(R):\n        if len(graph[i]) == 1:\n            matching.append(i)\n            graph[i].clear()\n            graph[i + R].clear()\n\n    return len(matching) == R\n\n\nif __name__ == \"__main__\":\n    R, B = map(int, input().split())\n    x = [int(x) for x in input().split()]\n    y = [int(y) for y in input().split()]\n    print(\"Yes\" if is_perfect_matching(R, B, x, y) else \"No\")"}
{"solution": "  def solve(n, a):\n    # Initialize the maximum power of 2 and the count of numbers that divide it\n    max_power = 0\n    count = 0\n    \n    # Iterate through the input array\n    for num in a:\n        # Find the maximum power of 2 that divides the current number\n        power = 0\n        while num % 2 == 0:\n            num //= 2\n            power += 1\n        \n        # If the current power is greater than the maximum power, update the count and maximum power\n        if power > max_power:\n            count = 1\n            max_power = power\n        # If the current power is equal to the maximum power, increment the count\n        elif power == max_power:\n            count += 1\n    \n    # Return the maximum power and count\n    return max_power, count"}
{"solution": "n, m = map(int, input().split())\n\n# Initialize the number of clicks to 0\nclicks = 0\n\n# While the number is not equal to m\nwhile n!= m:\n    # If the number is even\n    if n % 2 == 0:\n        # Double the number\n        n *= 2\n        # Increment the number of clicks\n        clicks += 1\n    # If the number is odd\n    else:\n        # Subtract 1 from the number\n        n -= 1\n        # Increment the number of clicks\n        clicks += 1\n\n# Print the minimum number of clicks required to get the number m\nprint(clicks)"}
{"solution": "import sys\n\nn = int(input())\nsegments = []\n\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append([l, r])\n\n# Check if the graph is connected\nif not is_connected(segments):\n    print(\"NO\")\n    sys.exit()\n\n# Check if there are exactly n-1 edges\nif not is_tree(segments):\n    print(\"NO\")\n    sys.exit()\n\n# Check if there are no cycles\nif not is_acyclic(segments):\n    print(\"NO\")\n    sys.exit()\n\nprint(\"YES\")\n\ndef is_connected(segments):\n    # Implement this function to check if the graph is connected\n    return True\n\ndef is_tree(segments):\n    # Implement this function to check if there are exactly n-1 edges\n    return True\n\ndef is_acyclic(segments):\n    # Implement this function to check if there are no cycles\n    return True"}
{"solution": "import sys\n\nn = int(input())\nrequests = list(map(int, input().split()))\n\n# Calculate the total number of requests in the given time segment\ntotal_requests = sum(requests)\n\n# Check if the total number of requests exceeds the threshold\nif total_requests > 100 * n:\n    # Find the longest continuous period of time with at least one request\n    longest_period = 0\n    current_period = 0\n    for i in range(n):\n        if requests[i] > 0:\n            current_period += 1\n            if current_period > longest_period:\n                longest_period = current_period\n        else:\n            current_period = 0\n\n    print(longest_period)\nelse:\n    print(0)"}
{"solution": "n, k = map(int, input().split())\nsequence = input()\n\n# Check if the sequence contains only 'Y', 'N', and '?'\nif not all(c in ['Y', 'N', '?'] for c in sequence):\n    print(\"NO\")\n    exit()\n\n# Initialize variables\nconsecutive_n = 0\nmax_consecutive_n = 0\n\n# Iterate through the sequence\nfor c in sequence:\n    if c == 'N':\n        consecutive_n += 1\n    elif c == 'Y':\n        consecutive_n = 0\n    elif c == '?':\n        # If the symbol is '?', check if the previous symbol is 'N'\n        if sequence[i-1] == 'N':\n            consecutive_n += 1\n        else:\n            consecutive_n = 0\n\n    # Update the maximum consecutive 'N's\n    if consecutive_n > max_consecutive_n:\n        max_consecutive_n = consecutive_n\n\n# Check if the maximum consecutive 'N's is equal to k\nif max_consecutive_n == k:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef solve(N, X, D):\n    # Initialize the sequence with the first element\n    A = [X]\n\n    # Generate the remaining elements of the sequence\n    for i in range(1, N):\n        A.append(A[i-1] + D)\n\n    # Initialize the sum of the elements taken by Takahashi and Aoki\n    S = 0\n    T = 0\n\n    # Iterate over the elements of the sequence and calculate the sum of the elements taken by Takahashi and Aoki\n    for i in range(N):\n        if i % 2 == 0:\n            S += A[i]\n        else:\n            T += A[i]\n\n    # Calculate the number of possible values of S - T\n    num_values = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if A[i] + A[j] == S - T:\n                num_values += 1\n\n    return num_values\n\nif __name__ == \"__main__\":\n    N, X, D = map(int, input().split())\n    print(solve(N, X, D))"}
{"solution": "n = int(input())\nparticipants = [input().split() for _ in range(n)]\nparticipants = [(handle, int(before), int(after)) for handle, before, after in participants]\n\nfor participant in participants:\n    handle, before, after = participant\n    if before >= 2400 and after > before:\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef main():\n    s = sys.stdin.readline().strip()\n    s = int(s, 2)\n    count = 0\n    for i in range(1, s):\n        if s % i == 0:\n            count += 1\n    print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nn, m = map(int, input().split())\na = [[int(x) for x in input().split()] for _ in range(n)]\n\n# Initialize the minimum number of rows to be the number of rows in the input matrix\nmin_rows = n\n\n# Iterate over all possible mirroring operations\nfor i in range(n):\n    # Check if the current row is a mirror of the previous row\n    if a[i] == a[i-1][::-1]:\n        # If it is, update the minimum number of rows\n        min_rows = min(min_rows, i+1)\n\n# Print the minimum number of rows\nprint(min_rows)"}
{"solution": "import sys\n\nn = int(input())\norders = []\n\nfor i in range(n):\n    l, r = map(int, input().split())\n    orders.append((l, r))\n\norders.sort(key=lambda x: x[1])\n\nmax_orders = 0\ncurrent_time = 0\n\nfor order in orders:\n    if order[0] >= current_time:\n        max_orders += 1\n        current_time = order[1]\n\nprint(max_orders)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Initialize the number of tables and formulas in each page\nnum_tables = [0] * n\nnum_formulas = [0] * n\n\n# Iterate through each page and count the number of tables and formulas\nfor i in range(n):\n    num_tables[i] = x[i]\n    num_formulas[i] = y[i]\n\n# Check if there are more than k tables or formulas in a row\nfor i in range(n - 1):\n    if num_tables[i] + num_tables[i + 1] > k or num_formulas[i] + num_formulas[i + 1] > k:\n        print(\"NO\")\n        sys.exit()\n\n# If we reach this point, then we can rearrange the tables and formulas\nprint(\"YES\")"}
{"solution": "import sys\n\nn, k = map(int, input().split())\ncoefficients = [int(input()) for _ in range(n + 1)]\n\n# Check if the human has a winning strategy\nif coefficients[0] == -1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def find_smallest_starting_number(x_2):\n    # Initialize the smallest possible starting number as x_2 - 1\n    x_0 = x_2 - 1\n    \n    # Find the prime factors of x_2 - 1\n    prime_factors = []\n    for i in range(2, int(x_2 ** 0.5) + 1):\n        if x_2 - 1 % i == 0:\n            prime_factors.append(i)\n    \n    # Find the minimum multiple of each prime factor that is not smaller than x_2 - 1\n    for prime in prime_factors:\n        multiple = (x_2 - 1) // prime\n        if multiple < x_0:\n            x_0 = multiple\n    \n    return x_0"}
{"solution": "import sys\n\nn, p = map(int, input().split())\n\nif p == 0:\n    print(2)\nelif p == 1:\n    print(3)\nelif p == -1:\n    print(4)\nelse:\n    print(-1)"}
{"solution": "def solve(n, k, S):\n    # Initialize the minimum value of S\n    min_S = 0\n    # Initialize the number of changes made\n    changes_made = 0\n    # Iterate through the digits of S\n    for i in range(n):\n        # If the current digit is not 0, change it to 0\n        if S[i]!= 0:\n            S[i] = 0\n            changes_made += 1\n        # If the current digit is 0 and the number of changes made is less than k, change it to 1\n        elif changes_made < k:\n            S[i] = 1\n            changes_made += 1\n    # If the number of changes made is greater than k, return -1\n    if changes_made > k:\n        return -1\n    # Return the resulting integer\n    return int(\"\".join(map(str, S)))"}
{"solution": "import sys\n\ndef solve(cnt_1, cnt_2, x, y):\n    # Initialize the minimum number of presents as 1\n    v = 1\n\n    # Loop through the numbers from 2 to v\n    for i in range(2, v + 1):\n        # If the number is not divisible by x or y, add it to the set of presents\n        if i % x!= 0 and i % y!= 0:\n            presents.add(i)\n\n    # If the number of presents for the first friend is less than cnt_1, add more presents\n    if len(presents) < cnt_1:\n        v += 1\n\n    # If the number of presents for the second friend is less than cnt_2, add more presents\n    if len(presents) < cnt_2:\n        v += 1\n\n    # Return the minimum number of presents\n    return v\n\nif __name__ == \"__main__\":\n    cnt_1, cnt_2, x, y = map(int, sys.stdin.readline().split())\n    print(solve(cnt_1, cnt_2, x, y))"}
{"solution": "import sys\n\nn, sx, sy, dx, dy, t = map(int, sys.stdin.readline().split())\n\n# Initialize the bear's position and speed\nx = sx\ny = sy\nspeed_x = dx\nspeed_y = dy\n\n# Loop for t seconds\nfor i in range(t):\n    # Eat the raspberry bushes in the current cell\n    x += speed_x\n    y += speed_y\n    \n    # Increase the speed by the number of raspberry bushes eaten\n    speed_x += x\n    speed_y += y\n    \n    # Move to the next cell\n    x = (x + speed_x - 1) % n + 1\n    y = (y + speed_y - 1) % n + 1\n    \n    # Increase the number of raspberry bushes by 1\n    x += 1\n    y += 1\n\n# Print the final position of the bear\nprint(x, y)"}
{"solution": "import re\n\ndef is_nice(word):\n    # Check if the word has length less than 26\n    if len(word) < 26:\n        return False\n    \n    # Check if the word contains all letters of the English alphabet\n    if not re.match(r'^[A-Z]{26}$', word):\n        return False\n    \n    # Check if the word contains all unique letters\n    if len(set(word))!= 26:\n        return False\n    \n    return True\n\ndef fill_missing_letters(word):\n    # Replace all question marks with uppercase letters\n    word = re.sub(r'\\?', lambda m: chr(ord('A') + m.start()), word)\n    \n    # Check if the resulting word is nice\n    if is_nice(word):\n        return word\n    else:\n        return -1\n\nif __name__ == '__main__':\n    word = input()\n    print(fill_missing_letters(word))"}
{"solution": "n = int(input())\nweights = [int(input()) for _ in range(n)]\n\n# Check if all weights are either 100 or 200\nif not all(weight in [100, 200] for weight in weights):\n    print(\"NO\")\n    exit()\n\n# Check if the total weight is divisible by 2\nif sum(weights) % 2!= 0:\n    print(\"NO\")\n    exit()\n\n# Check if the weights can be divided equally\nif len(set(weights))!= 1:\n    print(\"NO\")\n    exit()\n\n# Check if the weights can be divided into two equal groups\nif len(weights) % 2!= 0:\n    print(\"NO\")\n    exit()\n\n# If all checks pass, print \"YES\"\nprint(\"YES\")"}
{"solution": "n, m = map(int, input().split())\n\n# Initialize the building description\nbuilding = []\nfor i in range(n):\n    building.append(list(map(int, input())))\n\n# Initialize the minimum total time\nmin_time = 0\n\n# Loop through each floor\nfor i in range(n):\n    # Loop through each room in the current floor\n    for j in range(m):\n        # If the light is on, turn it off and add the time it takes to go to the next floor\n        if building[i][j] == 1:\n            building[i][j] = 0\n            min_time += 1\n            if i < n - 1:\n                min_time += 1\n            else:\n                min_time += 2\n\n# Print the minimum total time\nprint(min_time)"}
{"solution": "def find_min_trap_cost(n, costs, transitions):\n    visited = [False] * n\n    in_stack = [False] * n\n    min_cost = 0\n\n    def dfs(node):\n        stack = []\n        while True:\n            if visited[node]:\n                if in_stack[node]:\n                    # Found a cycle, calculate the minimum cost in this cycle\n                    cycle_min_cost = float('inf')\n                    while stack:\n                        cycle_node = stack.pop()\n                        in_stack[cycle_node] = False\n                        cycle_min_cost = min(cycle_min_cost, costs[cycle_node])\n                        if cycle_node == node:\n                            break\n                    return cycle_min_cost\n                else:\n                    return 0\n            visited[node] = True\n            in_stack[node] = True\n            stack.append(node)\n            node = transitions[node] - 1\n\n    for i in range(n):\n        if not visited[i]:\n            min_cost += dfs(i)\n\n    return min_cost\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(find_min_trap_cost(n, costs, transitions))"}
{"solution": "n, a, b = map(int, input().split())\n\nif b < 0:\n    b = -b\n    direction = \"decreasing\"\nelse:\n    direction = \"increasing\"\n\nif direction == \"increasing\":\n    k = (a + b - 1) % n + 1\nelse:\n    k = (a - b - 1) % n + 1\n\nprint(k)"}
{"solution": "def find_min_progressions(a):\n    n = len(a)\n    progressions = []\n    for i in range(n):\n        if a[i] == -1:\n            progressions.append(i)\n        else:\n            progressions.append(a[i])\n    \n    min_progressions = 1\n    for i in range(n-1):\n        if progressions[i] + 1 == progressions[i+1]:\n            min_progressions += 1\n        else:\n            min_progressions = max(min_progressions, 1)\n    \n    return min_progressions"}
{"solution": "import sys\n\nn, k = map(int, input().split())\ns = input()\n\n# Initialize the maximum beauty as 0\nmax_beauty = 0\n\n# Iterate through the string and check if the substring is equal to 'a' or 'b'\nfor i in range(n - k + 1):\n    substring = s[i:i+k]\n    if substring.count('a') == k or substring.count('b') == k:\n        max_beauty = max(max_beauty, len(substring))\n\nprint(max_beauty)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum number of seats among all parties\nmax_seats = max(a)\n\n# Find the party with the maximum number of seats\nmax_seats_party = a.index(max_seats) + 1\n\n# Check if the party with the maximum number of seats has at least twice the seats of any other party\nif max_seats >= 2 * max(a[max_seats_party + 1:]) and max_seats >= 2 * max(a[:max_seats_party]):\n    # If the party with the maximum number of seats has at least twice the seats of any other party, print the party's index\n    print(max_seats_party)\nelse:\n    # If the party with the maximum number of seats does not have at least twice the seats of any other party, print 0\n    print(0)"}
{"solution": "import math\n\ndef max_reward(n):\n    harmonic_sum = 0.0\n    for i in range(1, n + 1):\n        harmonic_sum += 1.0 / i\n    return harmonic_sum\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the maximum reward\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\n# Calculate the sum of the first k integers\ndef sum_of_first_k_integers(k):\n    return k * (k + 1) // 2\n\n# Find the largest k such that S_k <= n\nk = 1\nwhile sum_of_first_k_integers(k) <= n:\n    k += 1\n\n# Distribute the remaining candies\nremaining_candies = n - sum_of_first_k_integers(k - 1)\ndistribution = [1] * (k - 1) + [remaining_candies]\n\n# Print the output\nprint(k)\nprint(*distribution)"}
{"solution": "import math\n\ndef calculate_mod(n, m):\n    # Calculate 2^n\n    power_of_two = 1\n    for i in range(n):\n        power_of_two *= 2\n    \n    # Calculate m mod 2^n\n    remainder = m % power_of_two\n    \n    return remainder\n\nn = int(input())\nm = int(input())\n\nprint(calculate_mod(n, m))"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize a list to store the corrected word\ncorrected_word = []\n\n# Iterate through the word and check for consecutive vowels\nfor i in range(n):\n    if s[i] in \"aeiouy\":\n        # If the current letter is a vowel, check if the next letter is also a vowel\n        if i < n-1 and s[i+1] in \"aeiouy\":\n            # If the next letter is also a vowel, remove the current letter\n            corrected_word.append(s[i+1])\n        else:\n            # If the next letter is not a vowel, keep the current letter\n            corrected_word.append(s[i])\n    else:\n        # If the current letter is not a vowel, keep it\n        corrected_word.append(s[i])\n\n# Join the corrected word and print it\nprint(\"\".join(corrected_word))"}
{"solution": "def max_students(n, a, b, seats):\n    segments = []\n    i = 0\n    \n    # Identify segments of empty seats\n    while i < n:\n        if seats[i] == '.':\n            start = i\n            while i < n and seats[i] == '.':\n                i += 1\n            segments.append(i - start)\n        else:\n            i += 1\n    \n    total_students = 0\n    \n    # Place students in each segment\n    for length in segments:\n        # Calculate the number of students that can be placed in this segment\n        # We will place students in an alternating fashion\n        if a > b:\n            # Start with a student-programmer if more student-programmers are available\n            programmers = (length + 1) // 2\n            athletes = length // 2\n        else:\n            # Start with a student-athlete if more student-athletes are available\n            athletes = (length + 1) // 2\n            programmers = length // 2\n        \n        # Place the students\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n        \n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n    \n    return total_students"}
{"solution": "import sys\n\ndef hash_function(x, y):\n    return x**2 + 2*x*y + x + 1\n\ndef is_reversible(r):\n    for x in range(1, r):\n        for y in range(1, r):\n            if hash_function(x, y) == r:\n                return (x, y)\n    return \"NO\"\n\nif __name__ == \"__main__\":\n    r = int(sys.stdin.readline().strip())\n    print(is_reversible(r))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Check if it's possible to divide the balloons\nif sum(a) % 2 == 1:\n    print(-1)\n    exit()\n\n# Divide the balloons\nk = sum(a) // 2\nb = [0] * n\nfor i in range(n):\n    b[i] = a[i] // 2\n    if a[i] % 2 == 1:\n        b[i] += 1\n\n# Print the result\nprint(k)\nprint(*[i + 1 for i in range(n) if b[i] > 0], sep=' ')"}
{"solution": "n = int(input())\n\n# Initialize the minimum number of different digits as 10\nmin_diff_digits = 10\n\n# Initialize the partition with the minimum number of different digits\npartition = [1]\n\n# Iterate through all possible partitions of the number n into digits\nfor i in range(1, n):\n    # Check if the current partition has the minimum number of different digits\n    if len(set(partition)) < min_diff_digits:\n        # Update the minimum number of different digits\n        min_diff_digits = len(set(partition))\n        # Update the partition with the minimum number of different digits\n        partition = [i]\n\n# Print the number of digits in the partition\nprint(len(partition))\n\n# Print the partition\nprint(*partition)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the maximum size of the simple subset to 0\nm = 0\n\n# Iterate over all possible subsets of the array\nfor i in range(1, 2**n):\n    # Convert the binary representation of i to a list of indices\n    indices = [j for j in range(n) if i & (1 << j)]\n\n    # Check if the subset is simple\n    if is_simple(a, indices):\n        # Update the maximum size of the simple subset\n        m = max(m, len(indices))\n\n# Print the maximum size of the simple subset\nprint(m)\n\n# Print the elements of the simple subset with the maximum size\nprint(*[a[i] for i in indices])\n\ndef is_simple(a, indices):\n    # Check if the subset is simple\n    for i in range(len(indices)):\n        for j in range(i+1, len(indices)):\n            if a[indices[i]] + a[indices[j]] not in prime_numbers:\n                return False\n    return True\n\n# Initialize the list of prime numbers\nprime_numbers = [2]\n\n# Iterate over all possible prime numbers\nfor i in range(3, 10**6, 2):\n    # Check if the number is prime\n    if is_prime(i):\n        # Add the prime number to the list\n        prime_numbers.append(i)\n\ndef is_prime(n):\n    # Check if the number is prime\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"solution": "def find_greatest_beautiful_divisor(n):\n    # Find the greatest beautiful divisor of n\n    divisor = 1\n    while divisor <= n:\n        if is_beautiful_number(divisor):\n            return divisor\n        divisor += 1\n    return 1\n\ndef is_beautiful_number(n):\n    # Check if n is a beautiful number\n    k = 1\n    while k <= n:\n        if n == (2**k - 1) * (2**k - 1):\n            return True\n        k += 1\n    return False\n\nn = int(input())\nprint(find_greatest_beautiful_divisor(n))"}
{"solution": "import sys\n\ndef is_d_magic(n, d):\n    count = 0\n    while n > 0:\n        if n % 10 == d:\n            count += 1\n        n //= 10\n    return count\n\ndef count_d_magic_numbers(a, b, m, d):\n    count = 0\n    for i in range(a, b+1):\n        if i % m == 0 and is_d_magic(i, d):\n            count += 1\n    return count\n\nif __name__ == '__main__':\n    m, d = map(int, input().split())\n    a, b = map(int, input().split())\n    print(count_d_magic_numbers(a, b, m, d) % (10**9 + 7))"}
{"solution": "import sys\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Implement the algorithm to distribute candies and manage the queue\nqueue = [i for i in range(1, n + 1)]\nwhile queue:\n    child = queue.pop(0)\n    if a[child - 1] <= m:\n        a[child - 1] -= m\n        if a[child - 1] == 0:\n            print(child)\n            break\n        else:\n            queue.append(child)\n    else:\n        a[child - 1] -= m\n        queue.append(child)\n        m = a[child - 1]\n        a[child - 1] = 0\n        print(child)\n        break"}
{"solution": "n = int(input())\n\n# Initialize the minimum number of bills to 0\nmin_bills = 0\n\n# Loop through the denominations\nfor denomination in [1, 5, 10, 20, 100]:\n    # Calculate the number of bills for this denomination\n    num_bills = n // denomination\n\n    # If the number of bills is greater than the current minimum, update the minimum\n    if num_bills > min_bills:\n        min_bills = num_bills\n\n    # Update the remaining amount\n    n = n % denomination\n\n# Print the minimum number of bills\nprint(min_bills)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\n# Initialize the number of permutations with exactly k good positions to 0\ncount = 0\n\n# Iterate over all permutations of size n\nfor i in range(1, n + 1):\n    for j in range(1, n + 1):\n        for k in range(1, n + 1):\n            # Check if the current permutation has exactly k good positions\n            if abs(i - j) == 1 and abs(j - k) == 1 and abs(k - i) == 1:\n                count += 1\n\n# Print the number of permutations with exactly k good positions modulo 1000000007\nprint(count % 1000000007)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\nbeauty = list(map(int, input().split()))\ncolors = input()\n\n# Initialize the maximum total beauty to -1\nmax_beauty = -1\n\n# Iterate through all possible combinations of k roses\nfor i in range(n - k + 1):\n    # Check if the combination of roses satisfies the constraints\n    if colors[i]!= colors[i + k - 1] and colors[i]!= colors[i + k - 2]:\n        # Calculate the total beauty of the bouquet\n        total_beauty = sum(beauty[i:i + k])\n        # Update the maximum total beauty if necessary\n        if total_beauty > max_beauty:\n            max_beauty = total_beauty\n\n# Print the maximum total beauty\nprint(max_beauty)"}
{"solution": "  #include <iostream>\nusing namespace std;\n\nint main() {\n    long long p, q, n;\n    cin >> p >> q >> n;\n\n    long long a[n];\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    long long numerator = p * a[0];\n    long long denominator = q * a[0];\n\n    for (int i = 1; i < n; i++) {\n        numerator = numerator * a[i] + q;\n        denominator = denominator * a[i] + p;\n    }\n\n    if (numerator == denominator) {\n        cout << \"YES\";\n    } else {\n        cout << \"NO\";\n    }\n\n    return 0;\n}"}
{"solution": "def solve(expression):\n    # Split the expression into its components\n    A, B, C = expression.split(\"+\")[0], expression.split(\"+\")[1], expression.split(\"=\")[1]\n\n    # Check if the expression is already arithmetically correct\n    if A + B == C:\n        return expression\n\n    # Check if we can shift a stick from the third group to the first group\n    if A[2] == \"|\" and B[0] == \"|\":\n        A[2] = \" \"\n        B[0] = \"|\"\n        return \"\".join(A) + \"+\" + \"\".join(B) + \"=\" + \"\".join(C)\n\n    # Check if we can shift a stick from the second group to the third group\n    if B[1] == \"|\" and C[0] == \"|\":\n        B[1] = \" \"\n        C[0] = \"|\"\n        return \"\".join(A) + \"+\" + \"\".join(B) + \"=\" + \"\".join(C)\n\n    # If no shift is possible, return \"Impossible\"\n    return \"Impossible\""}
{"solution": "import sys\n\nn, k = map(int, sys.stdin.readline().split())\n\ndef count_permutations(n, k):\n    # Initialize a 2D array to store the results\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    # Base case: only one permutation of length 1\n    for i in range(1, n + 1):\n        dp[i][0] = 1\n\n    # Iterate over the length of the permutation\n    for len in range(1, n + 1):\n        # Iterate over the value of the permutation\n        for val in range(1, n + 1):\n            # Calculate the number of permutations with the current value and length\n            dp[len][val] = (dp[len - 1][val - 1] + dp[len - 1][val + 1]) % (10**9 + 7)\n\n    # Return the result for the given length and value\n    return dp[n][k]\n\nprint(count_permutations(n, k))"}
{"solution": "import sys\n\ndef main():\n    N = int(input())\n    points = []\n    for i in range(N):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    # Your code to find the robot arm configuration and bring Joint m to each point goes here\n\n    # Print the output\n    print(m)\n    print(*d_i, sep=' ')\n    for w_j in w_j_list:\n        print(w_j)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "import re\n\ndef replace_filler_words(s):\n    # find all filler words in the string\n    filler_words = re.findall(r'ogo+', s)\n\n    # replace each filler word with three asterisks\n    for filler_word in filler_words:\n        s = s.replace(filler_word, '***')\n\n    return s\n\n\ns = input()\nprint(replace_filler_words(s))"}
{"solution": "import math\n\ndef f(x, y):\n    prime_factors = []\n    for i in range(2, int(math.sqrt(x)) + 1):\n        if x % i == 0:\n            prime_factors.append(i)\n            if x // i!= i:\n                prime_factors.append(x // i)\n    return math.prod(prime_factors)\n\ndef g(x, p):\n    k = 0\n    while x % p == 0:\n        k += 1\n        x //= p\n    return p ** k\n\ndef calculate_product(x, n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= f(x, i)\n    return result % (10 ** 9 + 7)\n\nx, n = map(int, input().split())\nprint(calculate_product(x, n))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for s in range(1, 82):  # s(x) can be at most 81\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and sum_of_digits(x) == s:\n            solutions.append(x)\n    solutions.sort()\n    return solutions\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find solutions\nsolutions = find_solutions(a, b, c)\n\n# Print results\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "import sys\n\ndef is_solvable(cube):\n    # Check if all faces of the cube are the same color\n    if len(set(cube)) == 1:\n        return \"YES\"\n\n    # Check if the cube can be solved with one rotation\n    for i in range(len(cube)):\n        if cube[i] == cube[(i + 1) % len(cube)]:\n            return \"YES\"\n\n    return \"NO\"\n\nif __name__ == \"__main__\":\n    cube = list(map(int, sys.stdin.readline().split()))\n    print(is_solvable(cube))"}
{"solution": "import sys\n\ndef get_min_hacks(p, x, y):\n    # Calculate the number of successful hacks needed to win the round\n    num_hacks = (y - x) // 100\n    \n    # Calculate the number of places where the T-shirts will be given\n    places = []\n    i = (x // 50) % 475\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        places.append(26 + i)\n    \n    # Check if the current place is one of the places where the T-shirts will be given\n    if p in places:\n        return num_hacks\n    else:\n        return num_hacks + 1\n\nif __name__ == \"__main__\":\n    p, x, y = map(int, sys.stdin.readline().split())\n    print(get_min_hacks(p, x, y))"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Initialize variables\ndistance = 0\ncurrent_house = 1\nmeals_left = n\n\n# Loop through each house\nwhile meals_left > 0:\n    # If Winnie has not had a meal, he goes to the next house\n    if meals_left > 0:\n        # Calculate the distance to the next house\n        if current_house == 1:\n            distance += a\n        elif current_house == 2:\n            distance += b\n        else:\n            distance += c\n\n        # Decrement the number of meals left\n        meals_left -= 1\n\n    # If Winnie has had a meal, he goes back to the previous house\n    else:\n        # Calculate the distance to the previous house\n        if current_house == 1:\n            distance += a\n        elif current_house == 2:\n            distance += b\n        else:\n            distance += c\n\n        # Increment the number of meals left\n        meals_left += 1\n\n    # Update the current house\n    current_house = (current_house + 1) % 3\n\n# Print the minimum distance\nprint(distance)"}
{"solution": "def min_distance(x1, x2, x3):\n    # Find the midpoint between the first two friends\n    midpoint = (x1 + x2) // 2\n\n    # Find the distance between the midpoint and the third friend\n    distance = abs(midpoint - x3)\n\n    # Return the minimum distance\n    return distance"}
{"solution": "import sys\n\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Initialize the number of operations to 0\noperations = 0\n\n# Iterate through the array and check if there are any equal elements\nfor i in range(n):\n    for j in range(i+1, n):\n        if arr[i] == arr[j]:\n            # If there are any equal elements, return the number of operations\n            return operations\n\n# If there are no equal elements, apply the operation to the last element\narr[n-1] &= x\noperations += 1\n\n# Check if there are any equal elements after applying the operation\nfor i in range(n-1):\n    for j in range(i+1, n-1):\n        if arr[i] == arr[j]:\n            # If there are any equal elements, return the number of operations\n            return operations\n\n# If there are no equal elements after applying the operation, return -1\nreturn -1"}
{"solution": "def has_single_plus_shape(picture):\n    w, h = picture.shape\n    for i in range(w):\n        for j in range(h):\n            if picture[i, j] == '*':\n                if not is_valid_center(picture, i, j):\n                    return False\n    return True\n\ndef is_valid_center(picture, i, j):\n    w, h = picture.shape\n    for k in range(w):\n        if picture[i, k] == '*' and k!= j:\n            return False\n    for k in range(h):\n        if picture[k, j] == '*' and k!= i:\n            return False\n    return True"}
{"solution": "  import numpy as np\n\ndef solve(n, a, b):\n    # Initialize an empty adjacency matrix\n    adj_matrix = np.zeros((n, n), dtype=int)\n\n    # Initialize a list to store the components\n    components = []\n\n    # Initialize a list to store the complement components\n    complement_components = []\n\n    # Loop through each vertex\n    for i in range(n):\n        # Loop through each vertex again\n        for j in range(i+1, n):\n            # If the vertices are not connected, continue\n            if adj_matrix[i, j] == 0:\n                continue\n\n            # If the vertices are connected, check if they are in the same component\n            if adj_matrix[i, j] == 1 and adj_matrix[j, i] == 1:\n                # If they are in the same component, continue\n                continue\n\n            # If they are not in the same component, add them to the complement components\n            complement_components.append((i, j))\n\n    # If the number of components is not equal to a, return \"NO\"\n    if len(components)!= a:\n        return \"NO\"\n\n    # If the number of complement components is not equal to b, return \"NO\"\n    if len(complement_components)!= b:\n        return \"NO\"\n\n    # If the number of components is equal to a and the number of complement components is equal to b, return \"YES\"\n    return \"YES\"\n\n# Test case 1\nn = 3\na = 1\nb = 2\nprint(solve(n, a, b))\n\n# Test case 2\nn = 3\na = 3\nb = 3\nprint(solve(n, a, b))\n\n# Test case 3\nn = 4\na = 2\nb = 2\nprint(solve(n, a, b))\n\n# Test case 4\nn = 5\na = 3\nb = 2\nprint(solve(n, a, b))\n\n# Test case 5\nn = 6\na = 4\nb = 3\nprint(solve(n, a, b))\n\n# Test case 6\nn = 7\na = 5\nb = 4\nprint(solve(n, a, b))\n\n# Test case 7\nn = 8\na = 6\nb = 5\nprint(solve(n, a, b))\n\n# Test case 8\nn = 9\na = 7\nb = 6\nprint(solve(n, a, b))\n\n# Test case 9\nn = 10\na = 8\nb = 7\nprint(solve(n, a, b))\n\n# Test case 10\nn = 11\na = 9\nb = 8\nprint(solve(n, a, b))\n\n# Test case 11\nn = 12\na = 10\nb = 9\nprint(solve(n, a, b))\n\n# Test case 12\nn = 13\na = 11\nb = 10\nprint(solve(n, a, b))\n\n# Test case 13\nn = 14\na = 12\nb = 11\nprint(solve(n, a, b))\n\n# Test case 14\nn = 15\na = 13\nb = 12\nprint(solve(n, a, b))\n\n# Test case 15\nn = 16\na = 14\nb = 13\nprint(solve(n, a, b))\n\n# Test case 16\nn = 17\na = 15\nb = 14\nprint(solve(n, a, b))\n\n# Test case 17\nn = 18\na = 16\nb = 15\nprint(solve(n, a, b))\n\n# Test case 18\nn = 19\na = 17\nb = 16\nprint(solve(n, a, b))\n\n# Test case 19\nn = 20\na = 18\nb = 17\nprint(solve(n, a, b))\n\n# Test case 20\nn = 21\na = 19\nb = 18\nprint(solve(n, a, b))\n\n# Test case 21\nn = 22\na = 20\nb = 19\nprint(solve(n, a, b))\n\n# Test case 22\nn = 23\na = 21\nb = 20\nprint(solve(n, a, b))\n\n# Test case 23\nn = 24\na = 22\nb = 21\nprint(solve(n, a, b))\n\n# Test case 24\nn = 25\na = 23\nb = 22\nprint(solve(n, a, b))\n\n# Test case 25\nn = 26\na = 24\nb = 23\nprint(solve(n, a, b))\n\n# Test case 26\nn = 27\na = 25\nb = 24\nprint(solve(n, a, b))\n\n# Test case 27\nn = 28\na = 26\nb = 25\nprint(solve(n, a, b))\n\n# Test case 28\nn = 29\na = 27\nb = 26\nprint(solve(n, a, b))\n\n# Test case 29\nn = 30\na = 28\nb = 27\nprint(solve(n, a, b))\n\n# Test case 30\nn = 31\na = 29\nb = 28\nprint(solve(n, a, b))\n\n# Test case 31\nn = 32\na = 30\nb = 29\nprint(solve(n, a, b))\n\n# Test case 32\nn = 33\na = 31\nb = 30\nprint(solve(n, a, b))\n\n# Test case 33\nn = 34\na = 32\nb = 31\nprint(solve(n, a, b))\n\n# Test case 34\nn = 35\na = 33\nb = 32\nprint(solve(n, a, b))\n\n# Test case 35\nn = 36\na = 34\nb = 33\nprint(solve(n, a, b))\n\n# Test case 36\nn = 37\na = 35\nb = 34\nprint(solve(n, a, b))\n\n# Test case 37\nn = 38\na = 36\nb = 35"}
{"solution": "import sys\n\ndef get_min_problems(c, d, n, m, k):\n    # Calculate the total number of finalists\n    total_finalists = n * m + k\n    \n    # Calculate the number of problems needed in each round\n    main_problems = c * n\n    additional_problems = d * m\n    \n    # Calculate the minimum number of problems needed\n    min_problems = main_problems + additional_problems\n    \n    return min_problems\n\nif __name__ == '__main__':\n    c, d, n, m, k = map(int, sys.stdin.readline().split())\n    print(get_min_problems(c, d, n, m, k))"}
{"solution": "def find_grid(s):\n    # Initialize a 2D array to store the grid\n    grid = [[0] * 13 for _ in range(2)]\n\n    # Iterate through the string and assign each letter to a tile in the grid\n    for i, letter in enumerate(s):\n        row = i // 13\n        col = i % 13\n        grid[row][col] = letter\n\n    # Check if the grid contains a path that forms the given string\n    for row in range(2):\n        for col in range(13):\n            if grid[row][col]!= s[row * 13 + col]:\n                return \"Impossible\"\n\n    # If the grid contains a path, return the grid\n    return grid"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<' if y > 1 else '='\n    elif y == 1:\n        return '>' if x > 1 else '='\n    else:\n        # Compute y * log(x) and x * log(y)\n        lhs = y * math.log(x)\n        rhs = x * math.log(y)\n        \n        if lhs < rhs:\n            return '<'\n        elif lhs > rhs:\n            return '>'\n        else:\n            return '='\n\n# Read input\nx, y = map(int, input().split())\n\n# Output the result of the comparison\nprint(compare_powers(x, y))"}
{"solution": "import math\n\ndef get_max_balloons(r, h):\n    # Calculate the volume of the cupboard\n    cupboard_volume = math.pi * r * (r + h)\n\n    # Calculate the volume of a single balloon\n    balloon_volume = (4 / 3) * math.pi * (r / 2) ** 3\n\n    # Calculate the maximum number of balloons that can fit in the cupboard\n    max_balloons = int(cupboard_volume / balloon_volume)\n\n    return max_balloons\n\n# Test the function with some examples\nprint(get_max_balloons(1, 1))  # 3\nprint(get_max_balloons(1, 2))  # 5\nprint(get_max_balloons(2, 1))  # 2"}
{"solution": "def solve(numbers):\n    # sort the numbers in descending order\n    numbers.sort(reverse=True)\n\n    # initialize the sum of remaining numbers\n    sum = 0\n\n    # iterate through the numbers and discard two or three cards with the same number\n    for i in range(len(numbers)):\n        if numbers[i] == numbers[i-1] or numbers[i] == numbers[i-2]:\n            numbers.pop(i)\n            numbers.pop(i-1)\n            if len(numbers) > 2:\n                numbers.pop(i-2)\n            break\n\n    # calculate the sum of remaining numbers\n    for num in numbers:\n        sum += num\n\n    return sum"}
{"solution": "import sys\n\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Calculate the distance between each checkpoint and the starting point\ndistances = [abs(checkpoint - a) for checkpoint in checkpoints]\n\n# Sort the distances in ascending order\ndistances.sort()\n\n# Calculate the minimum distance Vasya has to travel\nmin_distance = sum(distances)\n\nprint(min_distance)"}
{"solution": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    long long n;\n    cin >> n;\n\n    // Find the smallest positive integer root of the equation\n    long long x = 1;\n    while (x * x + s(x) * x - n!= 0) {\n        x++;\n    }\n\n    // Print the smallest positive integer root\n    cout << x << endl;\n\n    return 0;\n}\n\n// Function to calculate the sum of digits of a number\nint s(long long x) {\n    int sum = 0;\n    while (x > 0) {\n        sum += x % 10;\n        x /= 10;\n    }\n    return sum;\n}"}
{"solution": "import datetime\n\ndef get_bedtime(current_time, sleep_duration):\n    current_time = datetime.datetime.strptime(current_time, \"%H:%M\")\n    sleep_duration = datetime.timedelta(hours=int(sleep_duration[:2]), minutes=int(sleep_duration[3:]))\n    bedtime = current_time - sleep_duration\n    return bedtime.strftime(\"%H:%M\")\n\nprint(get_bedtime(\"05:50\", \"05:44\"))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum arithmetic mean of the subsegment\ndef find_max_mean(a, l, r):\n    if l > r:\n        return 0\n    mean = sum(a[l:r+1]) / (r - l + 1)\n    return max(mean, find_max_mean(a, l+1, r), find_max_mean(a, l, r-1))\n\n# Find the longest subsegment with maximum arithmetic mean\ndef find_longest_subsegment(a):\n    max_mean = 0\n    longest_subsegment = []\n    for i in range(len(a)):\n        for j in range(i, len(a)):\n            mean = find_max_mean(a, i, j)\n            if mean > max_mean:\n                max_mean = mean\n                longest_subsegment = a[i:j+1]\n    return longest_subsegment\n\n# Print the length of the longest subsegment\nprint(len(find_longest_subsegment(a)))"}
{"solution": "import sys\n\nn, m, k = map(int, sys.stdin.readline().split())\n\n# Initialize a 2D array to store the number of ways to color each brick\nways = [[0] * (n + 1) for _ in range(m + 1)]\n\n# Base case: if there are no bricks, there is only one way to color them\nways[0][0] = 1\n\n# Iterate over the number of bricks\nfor i in range(1, n + 1):\n    # Iterate over the number of colors\n    for j in range(1, m + 1):\n        # If the current brick is the same color as the previous brick,\n        # the number of ways to color it is the same as the previous brick\n        if i == 1 or j == 1:\n            ways[i][j] = ways[i - 1][j - 1]\n        # If the current brick is different from the previous brick,\n        # the number of ways to color it is the sum of the number of ways\n        # to color the previous brick with the current color,\n        # and the number of ways to color the previous brick with the previous color\n        else:\n            ways[i][j] = (ways[i - 1][j - 1] + ways[i - 1][j]) % 998244353\n\n# Print the number of ways to color the bricks modulo 998244353\nprint(ways[n][m])"}
{"solution": "  import re\n\ndef is_magic_number(n):\n    pattern = re.compile(r'^(1|14|144)+$')\n    if pattern.match(str(n)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\nn = int(input())\nprint(is_magic_number(n))"}
{"solution": "import sys\n\nn, m, i, j, a, b = map(int, sys.stdin.readline().split())\n\n# Initialize the chessboard with the candy in position (i, j)\nchessboard = [[0] * m for _ in range(n)]\nchessboard[i - 1][j - 1] = 1\n\n# Initialize the number of moves to 0\nmoves = 0\n\n# Initialize the current position of the candy\ncurrent_position = (i, j)\n\n# While the candy is not in a corner square\nwhile current_position not in [(1, m), (n, 1), (n, m), (1, 1)]:\n    # Find the next position of the candy\n    next_position = (current_position[0] + a, current_position[1] + b)\n\n    # If the next position is outside the chessboard, print \"Poor Inna and pony!\" and exit\n    if next_position[0] < 1 or next_position[0] > n or next_position[1] < 1 or next_position[1] > m:\n        print(\"Poor Inna and pony!\")\n        sys.exit()\n\n    # Move the candy to the next position\n    chessboard[next_position[0] - 1][next_position[1] - 1] = 1\n    chessboard[current_position[0] - 1][current_position[1] - 1] = 0\n    current_position = next_position\n\n    # Increment the number of moves\n    moves += 1\n\n# Print the minimum number of moves needed to get the candy to a corner square\nprint(moves)"}
{"solution": "import sys\n\ndef get_previous_letter(letter):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    index = alphabet.index(letter)\n    if index == 0:\n        return \"\"\n    else:\n        return alphabet[index - 1]\n\ndef get_next_letter(letter):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    index = alphabet.index(letter)\n    if index == 25:\n        return \"\"\n    else:\n        return alphabet[index + 1]\n\ndef get_adjacent_letters(string, index):\n    if index == 0:\n        return [get_next_letter(string[index])]\n    elif index == len(string) - 1:\n        return [get_previous_letter(string[index - 1])]\n    else:\n        return [get_previous_letter(string[index - 1]), get_next_letter(string[index])]\n\ndef remove_character(string, index):\n    return string[:index] + string[index + 1:]\n\ndef get_maximum_removable_characters(string):\n    max_removable_characters = 0\n    for i in range(len(string)):\n        adjacent_letters = get_adjacent_letters(string, i)\n        if adjacent_letters[0]!= \"\" and adjacent_letters[1]!= \"\":\n            max_removable_characters += 1\n            string = remove_character(string, i)\n    return max_removable_characters\n\nif __name__ == \"__main__\":\n    string = sys.stdin.readline().strip()\n    print(get_maximum_removable_characters(string))"}
{"solution": "import sys\n\nn, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\n\ndef get_min_bills(x):\n    min_bills = -1\n    for i in range(n):\n        if x % denominations[i] == 0:\n            min_bills = x // denominations[i]\n            break\n    return min_bills\n\nfor _ in range(q):\n    x = int(input())\n    min_bills = get_min_bills(x)\n    if min_bills == -1:\n        print(-1)\n    else:\n        print(min_bills)"}
{"solution": "import math\n\ndef get_min_time(s, x1, x2, t1, t2, p, d):\n    # Calculate the distance between x1 and x2\n    distance = abs(x2 - x1)\n    \n    # Calculate the time it takes for Igor to walk the distance\n    walk_time = distance / t2\n    \n    # Calculate the time it takes for the tram to travel the distance\n    tram_time = distance / t1\n    \n    # Calculate the time it takes for Igor to wait for the tram\n    wait_time = abs(p - x1) / t1\n    \n    # Calculate the minimum time it takes for Igor to get from x1 to x2\n    min_time = min(walk_time, tram_time, wait_time)\n    \n    return min_time\n\ns = 4\nx1 = 2\nx2 = 4\nt1 = 3\nt2 = 4\np = 1\nd = 1\n\nprint(get_min_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "import sys\n\nn, x = map(int, input().split())\n\ncount = 0\nfor i in range(1, n+1):\n    for j in range(1, n+1):\n        if i * j == x:\n            count += 1\n\nprint(count)"}
{"solution": "  import random\n\ndef generate_password(n, k):\n    password = \"\"\n    while len(password) < n:\n        symbol = chr(random.randint(97, 122))\n        if symbol not in password:\n            password += symbol\n    return password\n\nn, k = map(int, input().split())\npassword = generate_password(n, k)\nprint(password)"}
{"solution": "def first_collision_time(n, directions, positions):\n    min_time = float('inf')\n    collision_found = False\n    \n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            collision_time = (positions[i + 1] - positions[i]) // 2\n            min_time = min(min_time, collision_time)\n            collision_found = True\n    \n    if collision_found:\n        return min_time\n    else:\n        return -1"}
{"solution": "import sys\n\nn, a, b = map(int, input().split())\nseals = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    seals.append((x, y))\n\n# Sort seals by area in descending order\nseals.sort(key=lambda x: x[0] * x[1], reverse=True)\n\n# Initialize the maximum area as 0\nmax_area = 0\n\n# Iterate through all possible combinations of seals\nfor i in range(n):\n    for j in range(i+1, n):\n        # Calculate the area of the current combination\n        area = seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1]\n\n        # Check if the current combination fits on the paper\n        if area <= a * b:\n            # Update the maximum area if necessary\n            max_area = max(max_area, area)\n\nprint(max_area)"}
{"solution": "import sys\n\nn = int(input())\npoints = []\n\nfor i in range(4*n+1):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\n# Find the point that is not on the boundary of the square\nfor point in points:\n    if point not in [(0, 0), (0, 2), (2, 0), (2, 2)]:\n        print(point[0], point[1])\n        break\nelse:\n    print(\"No point found\")"}
{"solution": "import math\n\ndef get_max_product(n):\n    max_product = 0\n    for i in range(1, n+1):\n        product = 1\n        for digit in str(i):\n            product *= int(digit)\n        max_product = max(max_product, product)\n    return max_product\n\nn = int(input())\nprint(get_max_product(n))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Calculate the total number of votes for Elodreip\ntotal_votes = sum(a)\n\n# Determine the minimum value of k that ensures a win\nk = max(a)\nwhile total_votes > sum(a[i] for i in range(n) if a[i] > k):\n    k += 1\n\nprint(k)"}
{"solution": "def solve(colors):\n    # Initialize variables\n    num_operations = 0\n    points_to_delete = []\n\n    # Iterate through the colors\n    for i in range(len(colors)):\n        # Check if the current point has a neighbor of a different color\n        if i > 0 and i < len(colors) - 1 and colors[i]!= colors[i - 1] and colors[i]!= colors[i + 1]:\n            # Add the current point to the list of points to delete\n            points_to_delete.append(i)\n\n    # Iterate through the list of points to delete\n    for point in points_to_delete:\n        # Delete the point and its neighbors\n        del colors[point - 1:point + 2]\n        num_operations += 1\n\n    return num_operations"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Sort the array in non-decreasing order\na.sort()\n\n# Initialize the minimum product to infinity\nmin_product = float('inf')\n\n# Initialize the count of triples to 0\ncount = 0\n\n# Iterate over the array and find the minimum product\nfor i in range(n - 2):\n    for j in range(i + 1, n - 1):\n        for k in range(j + 1, n):\n            product = a[i] * a[j] * a[k]\n            if product < min_product:\n                min_product = product\n                count += 1\n\nprint(count)"}
{"solution": "  import math\n\ndef solve(n):\n    return int(math.ceil((n + 1) / 2))\n\nn = int(input())\nprint(solve(n))"}
{"solution": "n = int(input())\n\n# Check if the input is a negative number\nif n < 0:\n    # If the input is negative, remove the last digit\n    n = n // 10\n\n# Check if the input is a positive number\nif n > 0:\n    # If the input is positive, remove the digit before the last\n    n = n - (n % 10)\n\n# Print the maximum state of the bank account\nprint(n)"}
{"solution": "def solve(start_pos, end_pos, n):\n    # Check if the starting position is the same as the ending position\n    if start_pos == end_pos:\n        return \"undefined\"\n    \n    # Check if the spinner was spun in the clockwise direction\n    if start_pos == \">\" and end_pos == \"^\":\n        return \"cw\"\n    \n    # Check if the spinner was spun in the counter-clockwise direction\n    if start_pos == \"<\" and end_pos == \"v\":\n        return \"ccw\"\n    \n    # If the spinner was spun in both directions, return \"undefined\"\n    return \"undefined\""}
{"solution": "def domino_show(n, s):\n    # Initialize variables\n    standing_dominoes = 0\n    falling_dominoes = 0\n    left_pushed_dominoes = 0\n    right_pushed_dominoes = 0\n\n    # Iterate through the dominoes\n    for i in range(n):\n        # Check if the domino has been pushed to the left\n        if s[i] == \"L\":\n            left_pushed_dominoes += 1\n        # Check if the domino has been pushed to the right\n        elif s[i] == \"R\":\n            right_pushed_dominoes += 1\n        # Check if the domino has not been pushed\n        else:\n            standing_dominoes += 1\n\n    # Iterate through the dominoes again\n    for i in range(n):\n        # Check if the domino is standing vertically\n        if standing_dominoes > 0:\n            standing_dominoes -= 1\n        # Check if the domino is falling to the left\n        elif left_pushed_dominoes > 0:\n            left_pushed_dominoes -= 1\n            falling_dominoes += 1\n        # Check if the domino is falling to the right\n        elif right_pushed_dominoes > 0:\n            right_pushed_dominoes -= 1\n            falling_dominoes += 1\n\n    # Return the number of standing dominoes\n    return standing_dominoes"}
{"solution": "def restore_permutation(n, m, leaders):\n    # Initialize a list to store the permutation\n    permutation = [0] * n\n\n    # Initialize a dictionary to store the indices of the leaders\n    leader_indices = {}\n    for i in range(m):\n        leader_indices[leaders[i]] = i\n\n    # Initialize a variable to store the current leader\n    current_leader = leaders[0]\n\n    # Iterate through the leaders and update the permutation\n    for i in range(m):\n        # Get the index of the current leader\n        leader_index = leader_indices[current_leader]\n\n        # Update the permutation\n        permutation[leader_index] = current_leader\n\n        # Get the next leader\n        next_leader = (current_leader + leaders[i]) % n\n\n        # Update the current leader\n        current_leader = next_leader\n\n    # Return the permutation\n    return permutation"}
{"solution": "import sys\n\ndef get_max_number(a, k):\n    # Convert the number to a list of digits\n    digits = [int(d) for d in str(a)]\n\n    # Iterate through the digits\n    for i in range(len(digits)):\n        # Determine the best possible digit to swap with within the allowed range of k swaps\n        best_swap = None\n        for j in range(i+1, min(i+k+1, len(digits))):\n            if digits[j] > digits[i]:\n                best_swap = j\n                break\n\n        # Perform the swap\n        if best_swap is not None:\n            digits[i], digits[best_swap] = digits[best_swap], digits[i]\n            k -= 1\n\n    # Repeat until k swaps are used or no more beneficial swaps are possible\n    while k > 0 and any(digits[i] < digits[i+1] for i in range(len(digits)-1)):\n        for i in range(len(digits)-1):\n            if digits[i] < digits[i+1]:\n                digits[i], digits[i+1] = digits[i+1], digits[i]\n                k -= 1\n                break\n\n    # Convert the list of digits back to a number\n    return int(\"\".join(str(d) for d in digits))\n\nif __name__ == \"__main__\":\n    a, k = map(int, input().split())\n    print(get_max_number(a, k))"}
{"solution": "import math\n\ndef is_arithmetic_progression(seq):\n    # Check if the sequence is arithmetic\n    for i in range(1, len(seq)):\n        if seq[i] - seq[i-1]!= seq[1] - seq[0]:\n            return False\n    return True\n\ndef is_geometric_progression(seq):\n    # Check if the sequence is geometric\n    for i in range(1, len(seq)):\n        if seq[i] / seq[i-1]!= seq[1] / seq[0]:\n            return False\n    return True\n\ndef find_next_number(seq):\n    # Find the next number in the sequence\n    if is_arithmetic_progression(seq):\n        return seq[-1] + (seq[1] - seq[0])\n    elif is_geometric_progression(seq):\n        return seq[-1] * (seq[1] / seq[0])\n    else:\n        return 42\n\nseq = [int(x) for x in input().split()]\nprint(find_next_number(seq))"}
{"solution": "n = int(input())\ncolors = list(map(int, input().split()))\n\n# Find the first and last occurrences of each color\nfirst_occurrence = {}\nlast_occurrence = {}\n\nfor i in range(n):\n    color = colors[i]\n    if color not in first_occurrence:\n        first_occurrence[color] = i\n    last_occurrence[color] = i\n\n# Get the list of unique colors\nunique_colors = list(first_occurrence.keys())\n\n# Calculate the maximum distance\nmax_dist = 0\n\n# Compare distances from the first house to the last house of a different color\nfor color in unique_colors:\n    if colors[0]!= color:\n        max_dist = max(max_dist, last_occurrence[color])\n    if colors[-1]!= color:\n        max_dist = max(max_dist, n - 1 - first_occurrence[color])\n\nprint(max_dist)"}
{"solution": "import sys\n\nn, m, k = map(int, sys.stdin.readline().split())\n\n# Calculate the lane and desk numbers\nlane = k // m\ndesk = k % m\n\n# Determine the side of the desk\nif k % 2 == 0:\n    side = \"L\"\nelse:\n    side = \"R\"\n\n# Print the output\nprint(lane, desk, side)"}
{"solution": "import sys\n\nn = int(input())\ns = input()\n\n# Count the number of each color\nb_count = s.count('B')\ng_count = s.count('G')\nr_count = s.count('R')\n\n# Determine the parity of each color\nb_parity = 'even' if b_count % 2 == 0 else 'odd'\ng_parity = 'even' if g_count % 2 == 0 else 'odd'\nr_parity = 'even' if r_count % 2 == 0 else 'odd'\n\n# Determine the possible final colors\nif b_parity == 'even' and g_parity == 'even' and r_parity == 'even':\n    final_colors = 'BGR'\nelif b_parity == 'odd' and g_parity == 'even' and r_parity == 'even':\n    final_colors = 'BG'\nelif b_parity == 'even' and g_parity == 'odd' and r_parity == 'even':\n    final_colors = 'GB'\nelif b_parity == 'even' and g_parity == 'even' and r_parity == 'odd':\n    final_colors = 'GR'\nelif b_parity == 'odd' and g_parity == 'odd' and r_parity == 'even':\n    final_colors = 'B'\nelif b_parity == 'even' and g_parity == 'odd' and r_parity == 'odd':\n    final_colors = 'G'\nelif b_parity == 'odd' and g_parity == 'even' and r_parity == 'odd':\n    final_colors = 'R'\nelse:\n    final_colors = 'BRG'\n\nprint(final_colors)"}
