{"solution": "def find_longest_accordion(s):\n    stack = []\n    max_length = 0\n    current_length = 0\n\n    for char in s:\n        if char == '[':\n            stack.append(char)\n            current_length += 1\n        elif char == ':':\n            if stack and stack[-1] == '[':\n                stack.pop()\n                current_length += 1\n            else:\n                current_length = 0\n                stack.clear()\n        elif char == '|':\n            if stack and stack[-1] == ':':\n                current_length += 1\n            else:\n                current_length = 0\n                stack.clear()\n        elif char == ']':\n            if stack and stack[-1] == ':':\n                stack.pop()\n                current_length += 1\n                max_length = max(max_length, current_length)\n            else:\n                current_length = 0\n                stack.clear()\n\n    if max_length >= 4:\n        return max_length\n    else:\n        return -1\n\n# Reading input\ns = input()\n\n# Calculating and printing the result\nprint(find_longest_accordion(s))"}
{"solution": "def max_digit_sum(x):\n    x_str = str(x)\n    length = len(x_str)\n    \n    # Check if the number is all 9s or not\n    if set(x_str) == {'9'}:\n        return x\n    \n    # Find the position where the first non-9 digit is located\n    for i in range(length):\n        if x_str[i] != '9':\n            break\n    \n    # Calculate the new number with the maximum digit sum\n    new_number = int(x_str[:i] + str(int(x_str[i]) - 1) + '9' * (length - i - 1))\n    \n    # If the new number is smaller than x and has a higher digit sum, return it\n    if new_number < x:\n        return new_number\n    else:\n        # Otherwise, check if decrementing the first non-9 digit by 1 results in a number smaller than x\n        # If so, return that number with 9s appended\n        if int(x_str[:i] + str(int(x_str[i]) - 1) + '9' * (length - i - 1)) <= x:\n            return int(x_str[:i] + str(int(x_str[i]) - 1) + '9' * (length - i - 1))\n        else:\n            # Otherwise, return x itself if it has the highest digit sum\n            return x\n\n# Read input\nx = int(input())\n\n# Print the result\nprint(max_digit_sum(x))"}
{"solution": "def is_lucky_year(year):\n    return sum(1 for digit in str(year) if digit != '0') <= 1\n\ndef find_next_lucky_year(current_year):\n    next_year = current_year + 1\n    while not is_lucky_year(next_year):\n        next_year += 1\n    return next_year - current_year\n\ncurrent_year = int(input())\nprint(find_next_lucky_year(current_year))"}
{"solution": "from itertools import combinations\n\ndef max_painted_sections(n, q, painters):\n    def merge_intervals(intervals):\n        merged = []\n        for interval in sorted(intervals, key=lambda x: x[0]):\n            if merged and merged[-1][1] >= interval[0] - 1:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n            else:\n                merged.append(list(interval))\n        return merged\n\n    def count_covered(merged):\n        covered = 0\n        last = 0\n        for start, end in merged:\n            if start > last:\n                last = start\n            covered += end - last + 1\n            last = end\n        return covered\n\n    painter_intervals = [tuple(painter) for painter in painters]\n    all_combinations = list(combinations(painter_intervals, q - 2))\n    \n    max_covered = 0\n    for combo in all_combinations:\n        merged_intervals = merge_intervals(combo)\n        covered = count_covered(merged_intervals)\n        max_covered = max(max_covered, covered)\n\n    return max_covered\n\n# Reading input\nn, q = map(int, input().split())\npainters = [list(map(int, input().split())) for _ in range(q)]\n\n# Calculating and printing output\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def contains_seven(time_str):\n    return '7' in time_str\n\ndef find_lucky_time(snooze_interval, wake_hour, wake_minute):\n    current_hour, current_minute = 23, 59\n    minute_diff = (wake_hour * 60 + wake_minute) - (current_hour * 60 + current_minute)\n    \n    # If the wake-up time is before midnight, adjust the starting point\n    if minute_diff > 0:\n        current_hour, current_minute = 0, 0\n    \n    presses = 0\n    while True:\n        current_minute -= snooze_interval\n        if current_minute < 0:\n            current_minute += 60\n            current_hour -= 1\n            if current_hour < 0:\n                current_hour = 23\n        \n        time_str = f\"{current_hour:02d}:{current_minute:02d}\"\n        if contains_seven(time_str):\n            break\n        \n        presses += 1\n    \n    return presses\n\n# Input\nsnooze_interval = int(input())\nwake_hour, wake_minute = map(int, input().split())\n\n# Output\nprint(find_lucky_time(snooze_interval, wake_hour, wake_minute))"}
{"solution": "def min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0\n    elif l == 1:\n        return abs(pos - r) + 1\n    elif r == n:\n        return abs(pos - l) + 1\n    else:\n        return min(abs(pos - l), abs(pos - r)) + (r - l) + 2\n\n# Reading input\nn, pos, l, r = map(int, input().split())\n\n# Printing the result\nprint(min_seconds_to_close_tabs(n, pos, l, r))"}
{"solution": "from typing import List\n\ndef min_blows_to_defeat(zmei_heads: int, blows: List[List[int]]) -> int:\n    \"\"\"\n    Calculates the minimum number of blows to defeat Zmei Gorynich.\n    \n    :param zmei_heads: Initial number of heads Zmei Gorynich has.\n    :param blows: A list of blows where each blow is represented as [damage, regrowth].\n    :return: Minimum number of blows to defeat Zmei Gorynich or -1 if impossible.\n    \"\"\"\n    blows.sort(reverse=True)\n    dp = [float('inf')] * (zmei_heads + 1)\n    dp[0] = 0\n    for damage, regrowth in blows:\n        for heads in range(zmei_heads, damage - 1, -1):\n            new_heads = max(0, heads - damage + regrowth)\n            dp[new_heads] = min(dp[new_heads], dp[heads] + 1)\n    return dp[0] if dp[0] != float('inf') else -1\n\n# Reading input\nt = int(input())\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Calculating and printing the result\n    print(min_blows_to_defeat(x, blows))"}
{"solution": "import math\n\ndef find_day_barn_empty(n, m):\n    if m == 0:\n        return n\n    # Calculate the day when the barn becomes empty\n    # Using the formula derived from the problem statement\n    # We need to find the smallest x such that the sum of grains eaten by sparrows\n    # is greater than or equal to the total grains in the barn.\n    # The sum of grains eaten by sparrows up to day x is x*(x+1)/2.\n    # We also need to account for the daily addition of m grains.\n    # The total grains in the barn on day x without considering the eaten grains is:\n    # n + m * (x - 1)\n    # We need to solve for x in the inequality:\n    # x * (x + 1) / 2 >= n + m * (x - 1)\n    # We use the quadratic formula to solve for x.\n    # The discriminant of the quadratic equation is: sqrt(m**2 + 2*m*n)\n    # The positive root of the equation is used since the number of days cannot be negative.\n    x = (-m + math.sqrt(m**2 + 2*m*n)) / 2\n    # Since x might not be an integer, we take the ceiling of x to get the first day\n    # when the barn becomes empty.\n    return math.ceil(x)\n\n# Reading input\nn, m = map(int, input().split())\n\n# Calculating and printing the result\nprint(find_day_barn_empty(n, m))"}
{"solution": "def min_draws_to_win(tiles):\n    tile1, tile2, tile3 = tiles.split()\n    \n    num1, suit1 = int(tile1[0]), tile1[1]\n    num2, suit2 = int(tile2[0]), tile2[1]\n    num3, suit3 = int(tile3[0]), tile3[1]\n    \n    if tile1 == tile2 == tile3:\n        return 0\n    \n    if suit1 == suit2 == suit3 and sorted([num1, num2, num3]) in [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9]]:\n        return 0\n    \n    if tile1 == tile2 or tile1 == tile3 or tile2 == tile3:\n        return 1\n    \n    if suit1 == suit2 and abs(num1 - num2) <= 2 or suit1 == suit3 and abs(num1 - num3) <= 2 or suit2 == suit3 and abs(num2 - num3) <= 2:\n        return 1\n    \n    return 2\n\n# Example usage\nprint(min_draws_to_win(\"1s 2s 3s\"))  # Output: 0\nprint(min_draws_to_win(\"9m 9m 9m\"))  # Output: 0\nprint(min_draws_to_win(\"3p 9m 2p\"))  # Output: 1"}
{"solution": "import sys\n\ndef find_grandpas_sofa(d, n, m, sofas, cnt):\n    def compare_sofas(sofa1, sofa2):\n        x1, y1, _, _ = sofa1\n        x2, y2, _, _ = sofa2\n        return (y1 < y2, y1 > y2, x1 < x2, x1 > x2)\n\n    def count_relations(sofa, sofas):\n        left, right, top, bottom = 0, 0, 0, 0\n        for other in sofas:\n            if other == sofa:\n                continue\n            l, r, t, b = compare_sofas(sofa, other)\n            if l: left += 1\n            elif r: right += 1\n            if t: top += 1\n            elif b: bottom += 1\n        return (left, right, top, bottom)\n\n    for i, sofa in enumerate(sofas, start=1):\n        counts = count_relations(sofa, sofas)\n        if counts == cnt:\n            return i\n    return -1\n\n# Reading input\nd = int(input())\nn, m = map(int, input().split())\nsofas = [tuple(map(int, input().split())) for _ in range(d)]\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\ncnt = (cnt_l, cnt_r, cnt_t, cnt_b)\n\n# Finding Grandpa Maks's sofa\nresult = find_grandpas_sofa(d, n, m, sofas, cnt)\nprint(result)"}
{"solution": "def mars_days_off(n):\n    full_weeks = n // 7\n    remaining_days = n % 7\n    \n    min_days_off = full_weeks * 2\n    max_days_off = full_weeks * 2 + min(remaining_days, 2)\n    \n    return min_days_off, max_days_off\n\nn = int(input())\nmin_days_off, max_days_off = mars_days_off(n)\nprint(min_days_off, max_days_off)"}
{"solution": "def max_chocolates(n, a, b, p, q):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    def lcm(x, y):\n        return x * y // gcd(x, y)\n\n    lcm_ab = lcm(a, b)\n    red_only = (n // a) - (n // lcm_ab)\n    blue_only = (n // b) - (n // lcm_ab)\n    both = n // lcm_ab\n\n    # If p >= q, prioritize red, else prioritize blue\n    if p >= q:\n        total_chocolates = (red_only + both) * p + blue_only * q\n    else:\n        total_chocolates = (blue_only + both) * q + red_only * p\n\n    return total_chocolates\n\n# Reading input\nn, a, b, p, q = map(int, input().split())\n\n# Calculating and printing the result\nprint(max_chocolates(n, a, b, p, q))"}
{"solution": "from collections import defaultdict\n\ndef max_golden_segment(trophies):\n    n = len(trophies)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + (1 if trophies[i] == 'G' else 0)\n\n    golden_segments = []\n    left = 0\n    for right in range(n):\n        if trophies[right] == 'S':\n            segment_length = prefix_sum[right] - prefix_sum[left]\n            golden_segments.append((left, right, segment_length))\n            left = right + 1\n    segment_length = prefix_sum[n] - prefix_sum[left]\n    if left < n:\n        golden_segments.append((left, n, segment_length))\n\n    max_beauty = max(segment[2] for segment in golden_segments)\n\n    for i in range(len(golden_segments) - 1):\n        left1, right1, length1 = golden_segments[i]\n        left2, right2, length2 = golden_segments[i + 1]\n\n        beauty_with_swap_left = length1 + length2 + min(right1 - left1 + 1, right2 - left2 + 1) - 1\n        beauty_with_swap_right = length1 + length2 + min(right1 - left1 + 1, right2 - left2 + 1) - 1\n\n        max_beauty = max(max_beauty, beauty_with_swap_left, beauty_with_swap_right)\n\n    return max_beauty\n\n# Read input\nn = int(input())\ntrophies = input().strip()\n\n# Calculate and print the result\nprint(max_golden_segment(trophies))"}
{"solution": "from collections import defaultdict, deque\n\ndef topological_sort(n, k, prerequisites):\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    specialty_courses = set(map(int, input().split()))\n\n    # Build the graph and calculate in-degrees\n    for course in range(1, n + 1):\n        _, *deps = map(int, input().split())\n        for dep in deps:\n            graph[dep].append(course)\n            in_degree[course] += 1\n\n    # Queue for courses with no prerequisites\n    queue = deque([i for i in range(1, n + 1) if in_degree[i] == 0])\n    visited = []\n    required_courses = 0\n\n    while queue:\n        course = queue.popleft()\n        visited.append(course)\n        if course in specialty_courses:\n            required_courses += 1\n        for next_course in graph[course]:\n            in_degree[next_course] -= 1\n            if in_degree[next_course] == 0:\n                queue.append(next_course)\n\n    if required_courses < k:\n        return -1\n    else:\n        return len(visited), ' '.join(map(str, visited))\n\n# Read input\nn, k = map(int, input().split())\nresult = topological_sort(n, k, [])\nprint(result[0] if isinstance(result, tuple) else result)\nif isinstance(result, tuple):\n    print(result[1])"}
{"solution": "from typing import List\n\ndef is_stack_sortable(arr: List[int]) -> bool:\n    stack = []\n    sorted_arr = []\n    for item in arr:\n        stack.append(item)\n        while stack and max(stack) <= min(sorted_arr + arr[len(stack):]):\n            sorted_arr.append(max(stack))\n            stack.remove(max(stack))\n    return not stack\n\ndef restore_permutation(n: int, k: int, arr: List[int]) -> List[int]:\n    if not is_stack_sortable(arr):\n        return [-1]\n    \n    available = set(range(1, n + 1)) - set(arr)\n    result = arr[:]\n    stack = []\n    \n    for i in range(k, n):\n        while stack and max(stack) <= min(available):\n            result.append(max(stack))\n            stack.remove(max(stack))\n        if not stack or max(stack) > min(available):\n            result.append(max(available))\n            available.remove(max(available))\n        else:\n            stack.append(arr[i])\n    \n    while stack:\n        result.append(max(stack))\n        stack.remove(max(stack))\n    \n    return result\n\ndef read_input():\n    n, k = map(int, input().split())\n    arr = list(map(int, input().split()))\n    return n, k, arr\n\nn, k, arr = read_input()\nresult = restore_permutation(n, k, arr)\nprint(*result)"}
{"solution": "def does_b_appear_in_sequence(a, b, c):\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n# Reading input directly for the solution\na, b, c = map(int, input().split())\nprint(does_b_appear_in_sequence(a, b, c))"}
{"solution": "def can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    if cnt_1 == cnt_4:\n        return 1\n    else:\n        return 0\n\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\nprint(can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4))"}
{"solution": "def standing_spectators(n, k, t):\n    \"\"\"\n    Calculates the number of standing spectators at time t.\n    \n    Parameters:\n    n (int): Total number of spectators.\n    k (int): The pattern repeats every k spectators.\n    t (int): The time at which to count standing spectators.\n    \n    Returns:\n    int: Number of standing spectators at time t.\n    \"\"\"\n    full_cycles, extra_time = divmod(t, k)\n    standing = min(n, (full_cycles + 1) * k - (t - extra_time))\n    return max(0, standing - full_cycles * n)\n\n# Reading input\nn, k, t = map(int, input().split())\n\n# Calculating and printing the result\nprint(standing_spectators(n, k, t))"}
{"solution": "def lexicographically_minimal_string(s):\n    t = []\n    u = []\n    s = list(s)\n    min_char_index = 0\n    \n    while s or t:\n        # If t is not empty and either s is empty or the last character of t\n        # is less than or equal to the smallest remaining character in s,\n        # then pop from t and append to u.\n        if t and (not s or t[-1] <= s[min_char_index]):\n            u.append(t.pop())\n        else:\n            # Otherwise, append the first character of s to t.\n            t.append(s.pop(0))\n            # Update the index of the smallest remaining character in s.\n            while min_char_index < len(s) and s[min_char_index] == s[0]:\n                min_char_index += 1\n    \n    return ''.join(u)\n\n# Reading input\ns = input().strip()\n# Printing the output\nprint(lexicographically_minimal_string(s))"}
{"solution": "def check_stats(stats):\n    previous_plays, previous_clears = 0, 0\n    for plays, clears in stats:\n        if plays < previous_plays or clears < previous_clears:\n            return \"NO\"\n        if clears > previous_clears and plays == previous_plays:\n            return \"NO\"\n        previous_plays, previous_clears = plays, clears\n    return \"YES\"\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        stats = [tuple(map(int, input().split())) for _ in range(n)]\n        print(check_stats(stats))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from datetime import datetime, timedelta\n\ndef is_palindrome(time_str):\n    return time_str == time_str[::-1]\n\ndef next_palindromic_time(current_time):\n    time = datetime.strptime(current_time, '%H:%M')\n    while True:\n        time += timedelta(minutes=1)\n        time_str = time.strftime('%H:%M')\n        if is_palindrome(time_str.replace(\":\", \"\")):\n            return time_str\n\ndef minutes_until_next_palindrome(current_time):\n    next_time = next_palindromic_time(current_time)\n    current = datetime.strptime(current_time, '%H:%M')\n    next_palindrome = datetime.strptime(next_time, '%H:%M')\n    return int((next_palindrome - current).total_seconds() / 60)\n\n# Example usage\ncurrent_time = input().strip()\nprint(minutes_until_next_palindrome(current_time))"}
{"solution": "def max_distance_after_swap(n, arr):\n    min_pos, max_pos = None, None\n    for i, value in enumerate(arr):\n        if value == 1:\n            min_pos = i\n        elif value == n:\n            max_pos = i\n    \n    # Case when min is on the left and max is on the right\n    max_distance = max_pos - min_pos\n    \n    # Potential swaps to increase distance\n    # Swap min with an element to its right\n    distance_swap_min_right = n - 1 - min_pos\n    # Swap max with an element to its left\n    distance_swap_max_left = max_pos - 0\n    \n    return max(max_distance, distance_swap_min_right, distance_swap_max_left)\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(max_distance_after_swap(n, arr))"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    mid = n // 2\n    if n % 2 == 0:\n        first_half = s[:mid]\n        second_half = s[mid:]\n    else:\n        first_half = s[:mid]\n        second_half = s[mid+1:]\n    \n    if first_half == second_half[::-1]:\n        return \"TAK\"\n    else:\n        return \"NIE\"\n\n# Example usage:\ns = input().strip()\nprint(is_s_palindrome(s))"}
{"solution": "from collections import Counter\n\ndef max_permutation(a, b):\n    a_str, b_str = str(a), str(b)\n    a_len, b_len = len(a_str), len(b_str)\n    \n    if a_len > b_len or (a_len == b_len and a > b):\n        return -1\n    \n    a_count = Counter(a_str)\n    b_count = Counter(b_str)\n    \n    result = []\n    i = 0\n    while a_count:\n        found = False\n        for d in range(9, -1, -1):\n            d = str(d)\n            if a_count[d] > 0 and (i == 0 or result[-1] != '0') and (i < b_len or (d <= b_str[i] and (i == 0 or result[-1] != '0'))):\n                result.append(d)\n                a_count[d] -= 1\n                found = True\n                break\n        i += 1\n        \n    return ''.join(result)\n\na = int(input())\nb = int(input())\n\nprint(max_permutation(a, b))"}
{"solution": "def check_win(matrix):\n    def check_line(line):\n        count = 0\n        for char in line:\n            if char == 'X':\n                count += 1\n                if count >= 5:\n                    return True\n            else:\n                count = 0\n        return False\n\n    # Check rows and columns\n    for i in range(10):\n        if check_line(matrix[i]) or check_line(matrix[j][i] for j in range(10)):\n            return True\n\n    # Check diagonals\n    for i in range(-5, 6):\n        if check_line(matrix[min(9, max(0, i + j))][min(9, max(0, -i + j))] for j in range(10)) or \\\n           check_line(matrix[min(9, max(0, i - j))][min(9, max(0, i + j))] for j in range(10)):\n            return True\n\n    return False\n\ndef can_win(matrix):\n    for i in range(10):\n        for j in range(10):\n            if matrix[i][j] == '.':\n                matrix[i] = matrix[i][:j] + 'X' + matrix[i][j+1:]\n                if not check_win(matrix):\n                    matrix[i] = matrix[i][:j] + 'O' + matrix[i][j+1:]\n                    if not check_win(matrix):\n                        matrix[i] = matrix[i][:j] + 'X' + matrix[i][j+1:]\n                        return \"YES\"\n                matrix[i] = matrix[i][:j] + '.' + matrix[i][j+1:]\n    return \"NO\"\n\n# Read input\nmatrix = [input().strip() for _ in range(10)]\n\n# Output result\nprint(can_win(matrix))"}
{"solution": "def print_matrix(matrix):\n    for row in matrix:\n        print(' '.join(map(str, row)))\n\ndef place_ones(n, k):\n    matrix = [[0] * n for _ in range(n)]\n    placed = 0\n    for i in range(n):\n        for j in range(i, n):\n            if placed < k and (i == j or placed + (n - i - 1) * 2 >= k):\n                matrix[i][j] = 1\n                if i != j:\n                    matrix[j][i] = 1\n                placed += 1\n            if placed == k:\n                break\n        if placed == k:\n            break\n    if placed == k:\n        print_matrix(matrix)\n    else:\n        print(-1)\n\ndef solve():\n    n, k = map(int, input().split())\n    place_ones(n, k)\n\nsolve()"}
{"solution": "from math import pow\n\nx, y, z = map(float, input().split())\n\nexpressions = [\n    pow(pow(x, y), z),\n    pow(pow(x, z), y),\n    pow(x, pow(y, z)),\n    pow(x, pow(z, y)),\n    pow(pow(y, x), z),\n    pow(pow(y, z), x),\n    pow(y, pow(x, z)),\n    pow(y, pow(z, x)),\n    pow(pow(z, x), y),\n    pow(pow(z, y), x),\n    pow(z, pow(x, y)),\n    pow(z, pow(y, x))\n]\n\nmax_value = max(expressions)\n\nif max_value == expressions[0]:\n    print(\"x^y^z\")\nelif max_value == expressions[1]:\n    print(\"(x^y)^z\")\nelif max_value == expressions[2]:\n    print(\"x^z^y\")\nelif max_value == expressions[3]:\n    print(\"(x^z)^y\")\nelif max_value == expressions[4]:\n    print(\"y^x^z\")\nelif max_value == expressions[5]:\n    print(\"(y^x)^z\")\nelif max_value == expressions[6]:\n    print(\"y^z^x\")\nelif max_value == expressions[7]:\n    print(\"(y^z)^x\")\nelif max_value == expressions[8]:\n    print(\"z^x^y\")\nelif max_value == expressions[9]:\n    print(\"(z^x)^y\")\nelif max_value == expressions[10]:\n    print(\"z^y^x\")\nelse:\n    print(\"(z^y)^x\")"}
{"solution": "def min_operations(n, s):\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = i\n        for j in range(1, i // 2 + 1):\n            if s[:i - j] == s[j:i]:\n                dp[i] = min(dp[i], dp[i - j] + 1)\n    return dp[n]\n\nn = int(input())\ns = input().strip()\nprint(min_operations(n, s))"}
{"solution": "from collections import defaultdict\n\ndef min_script_lines(tests):\n    examples = [name for name, typ in tests if typ == '1']\n    regulars = [name for name, typ in tests if typ == '0']\n    examples.sort()\n    regulars.sort()\n    \n    e = len(examples)\n    n = len(tests)\n    script = []\n    \n    # Rename examples\n    for i, example in enumerate(examples):\n        script.append(f\"move {example} {i+1}\")\n    \n    # Rename regular tests\n    for i, regular in enumerate(regulars):\n        script.append(f\"move {regular} {e+i+1}\")\n    \n    return len(script), script\n\n# Read input\nn = int(input())\ntests = [input().split() for _ in range(n)]\n\n# Solve\nlines, script = min_script_lines(tests)\n\n# Output\nprint(lines)\nfor line in script:\n    print(line)"}
{"solution": "from collections import Counter\n\ndef min_replacements_to_make_lucky_ticket(ticket):\n    left_sum = sum(int(digit) for digit in ticket[:3])\n    right_sum = sum(int(digit) for digit in ticket[3:])\n    digit_counts = Counter(ticket)\n    \n    replacements = abs(left_sum - right_sum)\n    \n    for digit, count in digit_counts.items():\n        digit_value = int(digit)\n        if digit_value > 0:\n            excess_left = max(0, (digit_counts[digit] - count) // 2)\n            replacements -= min(excess_left, (left_sum - digit_value * count) // digit_value)\n            \n            excess_right = max(0, (digit_counts[digit] - count) // 2)\n            replacements -= min(excess_right, (right_sum - digit_value * count) // digit_value)\n            \n            if replacements < 0:\n                replacements = 0\n                break\n    \n    return replacements\n\n# Read input\nticket = input()\n\n# Calculate and print the result\nprint(min_replacements_to_make_lucky_ticket(ticket))"}
{"solution": "from math import gcd\n\ndef minimum_traps(m, x):\n    return m - gcd(m, x)\n\n# Reading input\nm, x = map(int, input().split())\n\n# Calculating and printing the output\nprint(minimum_traps(m, x))"}
{"solution": "from math import gcd\n\nMOD = 10**6 + 3\n\ndef mod_inverse(x):\n    return pow(x, MOD - 2, MOD)\n\ndef calculate_probability(n, k):\n    n = pow(2, n, (MOD - 1))\n    total_days = pow(n, k, MOD)\n    unique_birthday_product = 1\n    remaining_days = n\n    \n    for _ in range(k):\n        unique_birthday_product *= remaining_days\n        unique_birthday_product %= MOD\n        remaining_days -= 1\n    \n    probability_no_same_birthday = unique_birthday_product * mod_inverse(total_days) % MOD\n    probability_same_birthday = (MOD - probability_no_same_birthday) % MOD\n    \n    # Ensure the fraction is in its simplest form\n    common_divisor = gcd(probability_same_birthday, MOD - 1)\n    probability_same_birthday //= common_divisor\n    total_days //= common_divisor\n    \n    return probability_same_birthday, total_days % MOD\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating and printing the result\nA, B = calculate_probability(n, k)\nprint(A, B)"}
{"solution": "def check_journey(n, journey):\n    latitude = 0\n    longitude = 0\n    on_north_pole = True\n    \n    for t, direction in journey:\n        if on_north_pole and direction != \"South\":\n            return \"NO\"\n        if latitude == -20000 and direction != \"North\":\n            return \"NO\"\n        \n        if direction == \"North\":\n            latitude += t\n        elif direction == \"South\":\n            latitude -= t\n        elif direction == \"East\":\n            longitude += t\n        else:  # direction == \"West\"\n            longitude -= t\n        \n        on_north_pole = latitude == 0\n        if latitude < -20000 or latitude > 0:\n            return \"NO\"\n    \n    return \"YES\" if on_north_pole else \"NO\"\n\nif __name__ == \"__main__\":\n    n = int(input())\n    journey = []\n    for _ in range(n):\n        t, direction = input().split()\n        journey.append((int(t), direction))\n    print(check_journey(n, journey))"}
{"solution": "from math import gcd\n\ndef find_common_elements(a1, b1, a2, b2, L, R):\n    # Calculate the common difference that will be used to find the intersection\n    common_diff = a1 * a2 // gcd(a1, a2)\n    \n    # Find the smallest x within the range [L, R] that satisfies both progressions\n    def find_smallest_x():\n        nonlocal L\n        while True:\n            if (L - b1) % a1 == 0 and (L - b2) % a2 == 0:\n                return L\n            L += 1\n            if L > R:\n                return -1\n    \n    # Find the largest x within the range [L, R] that satisfies both progressions\n    def find_largest_x():\n        nonlocal R\n        while True:\n            if (R - b1) % a1 == 0 and (R - b2) % a2 == 0:\n                return R\n            R -= 1\n            if R < L:\n                return -1\n    \n    smallest_x = find_smallest_x()\n    largest_x = find_largest_x()\n    \n    if smallest_x == -1 or largest_x == -1 or smallest_x > largest_x:\n        return 0\n    \n    # Calculate the number of valid x values\n    return ((largest_x - smallest_x) // common_diff) + 1\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Output the result\nprint(find_common_elements(a1, b1, a2, b2, L, R))"}
{"solution": "def max_pieces_per_plate(n, a, b):\n    \"\"\"\n    Determines the maximum number of pieces of cake that can be placed on each plate\n    such that no plate has pieces from both cakes and each plate has at least that many pieces.\n    \n    :param n: Number of plates\n    :param a: Number of pieces of the first cake\n    :param b: Number of pieces of the second cake\n    :return: Maximum number of pieces per plate\n    \"\"\"\n    # Initialize low and high for binary search\n    low, high = 1, max(a, b)\n    \n    while low < high:\n        mid = (low + high + 1) // 2\n        # Calculate if it's possible to distribute with mid pieces per plate\n        possible = (a // mid) + (b // mid) >= n\n        \n        if possible:\n            low = mid\n        else:\n            high = mid - 1\n            \n    return low\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Output result\nprint(max_pieces_per_plate(n, a, b))"}
{"solution": "def check_flag(n, m, flag):\n    def is_valid_stripe(stripe):\n        return len(set(stripe)) == 1\n\n    if n < 3 or m % 3 != 0:\n        return \"NO\"\n\n    stripe_width = m // 3\n    stripes = [\"\" for _ in range(3)]\n\n    for i in range(n):\n        for j in range(m):\n            if j < stripe_width:\n                stripes[0] += flag[i][j]\n            elif j < 2 * stripe_width:\n                stripes[1] += flag[i][j]\n            else:\n                stripes[2] += flag[i][j]\n\n    if not all(is_valid_stripe(stripe) for stripe in stripes):\n        return \"NO\"\n\n    colors = set(''.join(stripes))\n    if len(colors) != 3:\n        return \"NO\"\n\n    return \"YES\"\n\n# Reading input\nn, m = map(int, input().split())\nflag = [input() for _ in range(n)]\n\n# Checking the flag and printing the result\nprint(check_flag(n, m, flag))"}
{"solution": "def hex_spiral(n):\n    if n == 0:\n        return (0, 0)\n    \n    # Determine the side length of the outermost square the point lies on\n    side_length = int(((8 * n + 1) ** 0.5 - 1) / 4)\n    \n    # Calculate the starting point of the current layer\n    start = (side_length * (side_length - 1)) // 2\n    \n    # Determine the side and position within the side\n    side = n - start\n    if side < side_length:\n        return (-side_length, side - side_length)\n    elif side < 2 * side_length:\n        return (-side_length + (side - side_length * 2), side_length)\n    elif side < 3 * side_length:\n        return (side - side_length * 3, side_length)\n    else:\n        return (side_length, side_length - (side - side_length * 3))\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the result\nx, y = hex_spiral(n)\nprint(x, y)"}
{"solution": "import math\n\ndef can_break_shield(a, b, c):\n    # Calculate the greatest common divisor of a and b\n    gcd_ab = math.gcd(a, b)\n    \n    # Check if c is divisible by the gcd of a and b\n    if c % gcd_ab == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input values\na, b, c = map(int, input().split())\n\n# Output the result\nprint(can_break_shield(a, b, c))"}
{"solution": "def can_tracks_coincide(n, L, kefa_barriers, sasha_barriers):\n    # Calculate distances between consecutive barriers for Kefa\n    kefa_distances = [(kefa_barriers[(i + 1) % n] - kefa_barriers[i]) % L for i in range(n)]\n    # Calculate distances between consecutive barriers for Sasha\n    sasha_distances = [(sasha_barriers[(i + 1) % n] - sasha_barriers[i]) % L for i in range(n)]\n    \n    # Double the kefa_distances to handle circular rotation\n    doubled_kefa_distances = kefa_distances + kefa_distances\n    \n    # Check if sasha_distances is a sublist of doubled_kefa_distances\n    for i in range(n):\n        if doubled_kefa_distances[i:i + n] == sasha_distances:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_barriers, sasha_barriers))"}
{"solution": "def longest_non_palindromic_substring(s):\n    def is_palindrome(sub):\n        return sub == sub[::-1]\n\n    max_length = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if not is_palindrome(s[i:j]):\n                max_length = max(max_length, j-i)\n    return max_length\n\n# Example usage\ns = input().strip()\nprint(longest_non_palindromic_substring(s))"}
{"solution": "def is_it_rated(n, ratings):\n    changed = False\n    consistent = True\n    \n    for i in range(n - 1):\n        if ratings[i][0] != ratings[i][1]:\n            changed = True\n        if ratings[i][0] < ratings[i + 1][0] and ratings[i][1] > ratings[i + 1][1]:\n            consistent = False\n            break\n    \n    if changed:\n        return \"rated\"\n    elif not consistent:\n        return \"unrated\"\n    else:\n        return \"maybe\"\n\n# Reading input\nn = int(input())\nratings = []\nfor _ in range(n):\n    a, b = map(int, input().split())\n    ratings.append((a, b))\n\n# Printing output\nprint(is_it_rated(n, ratings))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nzeros = [-1] * n\nprev_zero = -1\n\n# Forward pass to find the nearest zero on the left\nfor i in range(n):\n    if a[i] == 0:\n        prev_zero = i\n    zeros[i] = prev_zero\n\n# Backward pass to find the nearest zero on the right and calculate distances\nfor i in range(n - 1, -1, -1):\n    if zeros[i] == -1:\n        next_zero = n  # Initialize with max possible index\n        for j in range(i + 1, n):\n            if a[j] == 0:\n                next_zero = j\n                break\n        zeros[i] = min(abs(i - zeros[i]), abs(next_zero - i))\n\nprint(' '.join(str(abs(i - pos)) for i, pos in enumerate(zeros)))"}
{"solution": "from itertools import product\n\ndef is_substring_in_cyclical_shifts(t, s):\n    t_extended = t + t\n    return any(s in t_extended[i:i+len(t)] for i in range(len(t)))\n\ndef count_distinct_cyclical_strings(n, s):\n    distinct_cyclical_strings = set()\n    \n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if is_substring_in_cyclical_shifts(t, s):\n            distinct_cyclical_strings.add(t)\n    \n    return len(distinct_cyclical_strings)\n\n# Reading input\nn = int(input())\ns = input().strip()\n\n# Printing output\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import math\n\ndef find_min_angle_pair(vectors):\n    def angle(x, y):\n        return math.atan2(y, x)\n\n    def non_oriented_angle(a1, a2):\n        diff = abs(a1 - a2)\n        return min(diff, math.pi - diff)\n\n    n = len(vectors)\n    vectors_with_angles = []\n    for i in range(n):\n        x, y = vectors[i]\n        vectors_with_angles.append((angle(x, y), i))\n\n    vectors_with_angles.sort()\n    min_angle = math.pi\n    index_pair = None\n\n    for i in range(n):\n        current_angle = vectors_with_angles[i][0]\n        next_angle = vectors_with_angles[(i + 1) % n][0]\n        angle_between = non_oriented_angle(current_angle, next_angle)\n        if angle_between < min_angle:\n            min_angle = angle_between\n            index_pair = (vectors_with_angles[i][1] + 1, vectors_with_angles[(i + 1) % n][1] + 1)\n\n    return index_pair\n\nn = int(input())\nvectors = [tuple(map(int, input().split())) for _ in range(n)]\n\nresult = find_min_angle_pair(vectors)\nprint(*result)"}
{"solution": "def minimal_time(d, k, a, b, t):\n    if d <= k:\n        return d * a\n    \n    full_segments = d // k\n    remaining_distance = d % k\n    \n    time_for_full_segments = full_segments * k * a + (full_segments - 1) * t\n    \n    if remaining_distance == 0:\n        return time_for_full_segments\n    else:\n        time_drive_remaining = remaining_distance * a + t\n        time_walk_remaining = remaining_distance * b\n        \n        return time_for_full_segments + min(time_drive_remaining, time_walk_remaining)\n\n# Example usage\nprint(minimal_time(5, 2, 1, 4, 10))  # Output: 14\nprint(minimal_time(5, 2, 1, 4, 5))   # Output: 13"}
{"solution": "from math import gcd\n\ndef find_sequence(n, k):\n    if n < k:\n        return [-1]\n    \n    sequence = [1] * k\n    current_sum = k\n    remaining = n - current_sum\n    \n    for i in range(k - 1, -1, -1):\n        needed = (n - current_sum) // (k - i)\n        if needed > sequence[i]:\n            sequence[i] = needed\n            current_sum += needed\n            remaining -= needed\n        else:\n            sequence[i] += remaining\n            break\n    \n    max_gcd = sequence[0]\n    for num in sequence:\n        max_gcd = gcd(max_gcd, num)\n    \n    if sum(sequence) != n:\n        return [-1]\n    \n    return sequence\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating and printing output\nresult = find_sequence(n, k)\nprint(' '.join(map(str, result)))"}
{"solution": "n, m = map(int, input().split())\n\ndef count_pairs(n, m):\n    # Calculate the number of complete cycles of 5 in n and m\n    full_cycles_n = n // 5\n    full_cycles_m = m // 5\n    \n    # Calculate the remainder part for n and m\n    rem_n = n % 5\n    rem_m = m % 5\n    \n    # Count pairs within full cycles\n    count = (full_cycles_n * (m - rem_m)) + (full_cycles_m * (n - rem_n))\n    \n    # Count pairs involving the remainder part\n    # For each remainder, find matching pairs\n    for r in range(rem_n):\n        if (5 - r) <= rem_m:\n            count += 1\n        elif (5 - r) + 5 <= rem_m:\n            count += 1\n    \n    return count\n\nprint(count_pairs(n, m))"}
{"solution": "import sys\n\ndef max_beauty(a, x):\n    max_ending_here = max_so_far = max_with_x = 0\n    for value in a:\n        max_ending_here = max(0, value, max_ending_here + value)\n        max_with_x = max(max_with_x, max_ending_here + x * value)\n        max_so_far = max(max_so_far, max_with_x, max_ending_here)\n    return max_so_far\n\n# Reading input\ninput_data = sys.stdin.read().split('\\n')\nn, x = map(int, input_data[0].split())\na = list(map(int, input_data[1].split()))\n\n# Calculating and printing the result\nprint(max_beauty(a, x))"}
{"solution": "def find_kth_largest(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(m, x // i)\n        return count\n\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_less_equal(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\n# Reading input directly\nn, m, k = map(int, input().split())\nprint(find_kth_largest(n, m, k))"}
{"solution": "import math\n\nk = int(input())\n\n# Calculate the number of digits in the range [1, 10^power]\ndef num_digits_in_range(power):\n    return 9 * (10 ** (power - 1)) * power\n\n# Find the range where the k-th digit is located\ntotal_digits = 0\npower = 1\nwhile total_digits < k:\n    digits_in_range = num_digits_in_range(power)\n    if total_digits + digits_in_range >= k:\n        break\n    total_digits += digits_in_range\n    power += 1\n\n# Calculate the offset within the current range\noffset = k - total_digits - 1\n\n# Find the actual number that contains the k-th digit\nnumber = 10 ** (power - 1) + (offset // power)\n\n# Find the exact digit within the number\ndigit_index = offset % power\ndigit = int(str(number)[digit_index])\n\nprint(digit)"}
{"solution": "def max_bourles(n, m, r, buy_prices, sell_prices):\n    min_buy = min(buy_prices)\n    max_sell = max(sell_prices)\n    \n    if max_sell <= min_buy:\n        return r\n    \n    shares_bought = r // min_buy\n    total_bourles = (shares_bought * max_sell) + (r % min_buy)\n    return total_bourles\n\n# Reading input\nn, m, r = map(int, input().split())\nbuy_prices = list(map(int, input().split()))\nsell_prices = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(max_bourles(n, m, r, buy_prices, sell_prices))"}
{"solution": "def find_original_message(t):\n    n = len(t)\n    for overlap in range(1, n // 2 + 1):\n        if t[:overlap] == t[-overlap:]:\n            s = t[:-overlap]\n            if s + t[-overlap:] == t or s == '':\n                return \"YES\", s\n    return \"NO\", None\n\nt = input().strip()\nresult, s = find_original_message(t)\nprint(result)\nif result == \"YES\":\n    print(s)"}
{"solution": "def find_teams(n):\n    possible_teams = []\n    while n > 0:\n        # Check if current n can be achieved by the round-robin formula\n        # Solve the quadratic equation x^2 - x - 2*n = 0\n        discriminant = 1 + 8 * n\n        if discriminant >= 0 and (discriminant ** 0.5).is_integer():\n            x = int((1 + discriminant ** 0.5) // 2)\n            possible_teams.append(x)\n            n -= x * (x - 1) // 2\n        else:\n            # Subtract the next power of 2 from n\n            power_of_2 = 1\n            while power_of_2 <= n:\n                power_of_2 *= 2\n            power_of_2 //= 2\n            n -= power_of_2\n    if possible_teams:\n        return sorted(possible_teams)\n    else:\n        return [-1]\n\n# Read input\nn = int(input())\n\n# Calculate and print results\nresults = find_teams(n)\nfor team_count in results:\n    print(team_count)"}
{"solution": "def max_beauty(n, s, b):\n    from collections import Counter\n    \n    # Count the frequency of each character in s\n    char_count = Counter(s)\n    \n    # Check if the string can be rearranged into an antipalindromic string\n    if any(freq % 2 != 0 for freq in char_count.values()):\n        return 0  # Not possible to form an antipalindromic string\n    \n    # Sort the beauties and the counts of characters in descending order\n    sorted_b = sorted(b, reverse=True)\n    sorted_char_count = sorted(char_count.items(), key=lambda x: -x[1])\n    \n    result = 0\n    half_n = n // 2\n    char_index = 0\n    \n    for i in range(half_n):\n        # Assign the character with the highest count to the current position\n        # and the corresponding beauty\n        result += sorted_b[i] * 2\n        char_index += 1\n    \n    # Adjust for the case where the same character cannot be placed at mirrored positions\n    for i in range(half_n, n):\n        result -= sorted_b[i]\n        char_index += 1\n    \n    return result\n\n# Reading input\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(max_beauty(n, s, b))"}
{"solution": "def can_weigh(w, m):\n    # Initialize the list to store the powers of w\n    weights = [1]\n    for i in range(1, 101):\n        next_weight = weights[-1] * w\n        if next_weight > 10**9:\n            break\n        weights.append(next_weight)\n    \n    # Dynamic programming approach\n    dp = [False] * (m + 1)\n    dp[0] = True\n    \n    for weight in weights:\n        for j in range(m, weight - 1, -1):\n            dp[j] = dp[j] or dp[j - weight]\n            if j > weight:\n                dp[j] = dp[j] or (not dp[j - weight])\n    \n    return \"YES\" if dp[m] else \"NO\"\n\n# Read input\nw, m = map(int, input().split())\n\n# Output result\nprint(can_weigh(w, m))"}
{"solution": "import heapq\n\ndef find_sequence(n, k):\n    if n.bit_length() - 1 < k:\n        return \"No\"\n    \n    bits = []\n    while n > 0:\n        bits.append(n & -n)\n        n -= n & -n\n    \n    if len(bits) > k:\n        return \"No\"\n    \n    result = [-1] * k\n    bit_index = 0\n    for i in range(k):\n        if bit_index < len(bits):\n            result[i] = bits[bit_index].bit_length() - 1\n            bit_index += 1\n        else:\n            result[i] = result[-1] - 1\n    \n    # Ensure the sequence sums up to n and is lexicographically largest\n    current_sum = sum(1 << x for x in result)\n    diff = current_sum - n\n    for i in range(k - 1, -1, -1):\n        if diff == 0:\n            break\n        if result[i] >= 0:\n            if 1 << result[i] <= diff:\n                diff -= 1 << result[i]\n                result[i] = -10**18\n            else:\n                result[i] -= 1\n                diff -= 1\n    \n    return [\"Yes\", *result] if diff == 0 else \"No\"\n\nn, k = map(int, input().split())\nprint('\\n'.join(map(str, find_sequence(n, k))))"}
{"solution": "def pour_champagne(n, t):\n    pyramid = [[0] * (i + 1) for i in range(n)]\n    poured = 0\n    level = 0\n    \n    while poured < t:\n        needed_for_level = (level + 1) * (level + 2) // 2 - sum(sum(row) for row in pyramid)\n        if poured + needed_for_level <= t:\n            pyramid[level] = [1] * (level + 1)\n            poured += needed_for_level\n            level += 1\n        else:\n            remaining = t - poured\n            current = pyramid[level]\n            for i in range(level + 1):\n                if remaining > 0:\n                    current[i] = min(1, current[i] + remaining / (level + 1))\n                    remaining -= remaining / (level + 1)\n            break\n    \n    full_glasses = sum(1 for row in pyramid for glass in row if glass == 1)\n    return full_glasses\n\n# Example usage\nn, t = map(int, input().split())\nprint(pour_champagne(n, t))"}
{"solution": "def calculate_area(n, vertices):\n    if n == 1:\n        return -1\n    elif n == 2:\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        if x1 != x2 and y1 != y2:\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 3:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 4:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n\nn = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\nprint(calculate_area(n, vertices))"}
{"solution": "def min_wooden_bars(n, a, b):\n    total_length_needed = 2 * (2 * a + b)\n    return -(-total_length_needed // n)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = int(input())\n    b = int(input())\n    \n    print(min_wooden_bars(n, a, b))"}
{"solution": "def can_sort(n, a, swaps):\n    def find_group(start):\n        group = [start]\n        i = start\n        while i < n - 1 and swaps[i] == '1':\n            i += 1\n            group.append(i)\n        return group\n\n    groups = []\n    i = 0\n    while i < n - 1:\n        if swaps[i] == '0':\n            i += 1\n        else:\n            group = find_group(i)\n            groups.append(group)\n            i = group[-1] + 1\n\n    # Check if each group can be sorted individually\n    for group in groups:\n        if len(group) > 1:\n            # Extract the elements of the current group\n            elements = [a[i] for i in group]\n            # Check if the extracted elements are already sorted\n            if elements != sorted(elements):\n                return \"NO\"\n    \n    # Check if the elements between groups are in ascending order\n    last_element = 0\n    for group in groups:\n        if group[0] > 0 and a[group[0]] < last_element:\n            return \"NO\"\n        last_element = a[group[-1]]\n    \n    return \"YES\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nswaps = input()\n\n# Output result\nprint(can_sort(n, a, swaps))"}
{"solution": "def calculate_waiting_time(seat_info):\n    row, seat = seat_info[:-1], seat_info[-1]\n    row = int(row)\n    sequence_position = (row + 1) // 2\n    if row % 2 == 0:\n        # For even rows, the second attendant serves, starting from 'f'\n        seat_order = {'f': 1, 'e': 2, 'd': 3, 'c': 4, 'b': 5, 'a': 6}\n    else:\n        # For odd rows, the first attendant serves, starting from 'f'\n        seat_order = {'f': 1, 'e': 2, 'd': 3, 'c': 1, 'b': 2, 'a': 3}\n    \n    # Calculate the time taken to reach the row\n    time_to_row = sum(range(1, sequence_position * 2, 2)) + sum(range(3, sequence_position * 2, 2))\n    if row % 2 == 0:\n        # Adjust for the movement of the second attendant\n        time_to_row += sequence_position - 1\n    \n    # Add the time to serve previous passengers in the row\n    waiting_time = time_to_row + seat_order[seat] - 1\n    return waiting_time\n\n# Read input\nseat_info = input().strip()\n\n# Calculate and print the waiting time\nprint(calculate_waiting_time(seat_info))"}
{"solution": "def convert_to_decimal(digits, base):\n    digit_map = {str(i): i for i in range(10)}\n    for char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n        digit_map[char] = 10 + ord(char) - ord('A')\n    \n    decimal_value = 0\n    for i, digit in enumerate(reversed(digits)):\n        decimal_value += digit_map[digit] * (base ** i)\n    return decimal_value\n\ndef compare_numbers(n, bx, nx, m, by, ny):\n    nx_decimal = convert_to_decimal(nx, bx)\n    ny_decimal = convert_to_decimal(ny, by)\n    \n    if nx_decimal == ny_decimal:\n        return '='\n    elif nx_decimal < ny_decimal:\n        return '<'\n    else:\n        return '>'\n\nimport sys\ninput = sys.stdin.readline\n\nn, bx = map(int, input().split())\nnx = input().strip().split()\nm, by = map(int, input().split())\nny = input().strip().split()\n\nprint(compare_numbers(n, bx, nx, m, by, ny))"}
{"solution": "from functools import lru_cache\n\ndef game_winner(n, a):\n    @lru_cache(maxsize=None)\n    def grundy(x, y, z):\n        if x == 0 and y == 0 and z == 0:\n            return 0\n        options = set()\n        min_val = min(x, y, z)\n        \n        # Option 1: Decrease one element by x\n        if x > 0:\n            options.add(grundy(x-1, y, z))\n        if y > 0:\n            options.add(grundy(x, y-1, z))\n        if z > 0:\n            options.add(grundy(x, y, z-1))\n        \n        # Option 2: Decrease all elements by x\n        for x_decr in range(1, min_val + 1):\n            options.add(grundy(x - x_decr, y - x_decr, z - x_decr))\n        \n        mex = 0\n        while mex in options:\n            mex += 1\n        return mex\n    \n    # Handle the case of n=1 separately\n    if n == 1:\n        return \"BitLGM\" if a[0] % 2 == 1 else \"BitAryo\"\n    \n    # Calculate Grundy numbers for each element\n    if n == 2:\n        g1, g2 = grundy(a[0], a[1], 0), grundy(a[0], 0, 0)\n    elif n == 3:\n        g1, g2, g3 = grundy(a[0], a[1], a[2]), grundy(a[0], a[1], 0), grundy(a[0], 0, 0)\n    \n    # XOR the Grundy numbers to determine the winner\n    xor_result = g1 ^ g2\n    if n == 3:\n        xor_result ^= g3\n    \n    return \"BitLGM\" if xor_result != 0 else \"BitAryo\"\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Printing the output\nprint(game_winner(n, a))"}
{"solution": "from math import gcd\n\ndef prefix_gcd(arr):\n    prefix = [0] * len(arr)\n    prefix[0] = arr[0]\n    for i in range(1, len(arr)):\n        prefix[i] = gcd(prefix[i-1], arr[i])\n    return prefix\n\ndef suffix_gcd(arr):\n    suffix = [0] * len(arr)\n    suffix[-1] = arr[-1]\n    for i in range(len(arr) - 2, -1, -1):\n        suffix[i] = gcd(suffix[i+1], arr[i])\n    return suffix\n\ndef count_valid_decks(n, k, nums):\n    prefix = prefix_gcd(nums)\n    suffix = suffix_gcd(nums)\n\n    count = 0\n    for i in range(n):\n        if i == 0:\n            current_gcd = suffix[i + 1] if i + 1 < n else 1\n        elif i == n - 1:\n            current_gcd = prefix[i - 1] if i - 1 >= 0 else 1\n        else:\n            current_gcd = gcd(prefix[i - 1], suffix[i + 1])\n\n        if current_gcd * nums[i] % k == 0:\n            count += 1\n\n    # Add cases where the entire deck is removed except for one card\n    for num in nums:\n        if num % k == 0:\n            count += 1\n\n    return count\n\n# Reading input\nn, k = map(int, input().split())\nnums = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(count_valid_decks(n, k, nums))"}
{"solution": "from collections import Counter\n\ndef can_distribute_balloons(n, k, s):\n    # Count the frequency of each balloon color\n    color_count = Counter(s)\n    \n    # Find the maximum frequency among all colors\n    max_color_count = max(color_count.values())\n    \n    # Check if it's possible to distribute the balloons without upsetting any friend\n    if max_color_count > n // k + (n % k > 0):\n        return \"NO\"\n    else:\n        return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ns = input()\n\n# Print the result\nprint(can_distribute_balloons(n, k, s))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmin_value = min(a)\nfirst_pos = -1\nsecond_pos = -1\ndistance = float('inf')\n\nfor i, value in enumerate(a):\n    if value == min_value:\n        if first_pos == -1:\n            first_pos = i\n        else:\n            second_pos = i\n            distance = min(distance, second_pos - first_pos)\n            first_pos = second_pos\n\nprint(distance)"}
{"solution": "from math import gcd\n\ndef find_tie_probability(t, w, b):\n    numerator = 0\n    lcm = (w * b) // gcd(w, b)\n    \n    for i in range(1, t + 1):\n        if i % w == 0 and i % b == 0:\n            numerator += 1\n        elif (i % w == 0 or (i + w) % w == 0) and (i % b == 0 or (i + b) % b == 0):\n            if ((i // w) * w == i and ((i + b) // b) * b == i + b) or (((i + w) // w) * w == i + w and (i // b) * b == i):\n                numerator += 1\n    \n    denominator = t\n    common_divisor = gcd(numerator, denominator)\n    return f\"{numerator // common_divisor}/{denominator // common_divisor}\"\n\nt, w, b = map(int, input().split())\nprint(find_tie_probability(t, w, b))"}
{"solution": "def determine_outcome(x, y, z):\n    if z == 0:\n        if x > y:\n            return \"+\"\n        elif y > x:\n            return \"-\"\n        else:\n            return \"0\"\n    else:\n        if x + z < y or y + z < x:\n            return \"?\"\n        elif x > y + z or y > x + z:\n            return \"+\" if x > y else \"-\"\n        elif x + z == y or y + z == x:\n            return \"0\"\n        else:\n            return \"?\"\n\ndef main():\n    x, y, z = map(int, input().split())\n    result = determine_outcome(x, y, z)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import defaultdict\n\ndef min_changes_to_reach_target(n, ops, target):\n    x, y = target\n    dx, dy = 0, 0\n    max_dx, min_dx, max_dy, min_dy = 0, 0, 0, 0\n    dx_changes, dy_changes = defaultdict(int), defaultdict(int)\n    \n    for i, op in enumerate(ops):\n        if op == 'R':\n            dx += 1\n            max_dx = max(max_dx, dx)\n            dx_changes[dx] = i\n        elif op == 'L':\n            dx -= 1\n            min_dx = min(min_dx, dx)\n            dx_changes[dx] = i\n        elif op == 'U':\n            dy += 1\n            max_dy = max(max_dy, dy)\n            dy_changes[dy] = i\n        else:\n            dy -= 1\n            min_dy = min(min_dy, dy)\n            dy_changes[dy] = i\n    \n    if dx != x or dy != y:\n        return -1\n    \n    min_change_len = float('inf')\n    for dx_val in range(min_dx, max_dx + 1):\n        for dy_val in range(min_dy, max_dy + 1):\n            if dx_val + dy_val == x + y:\n                start_idx = max(dx_changes.get(dx_val, -1), dy_changes.get(dy_val, -1))\n                if start_idx == -1:\n                    continue\n                end_idx = max(dx_changes.get(x - (y - dy_val), -1), dy_changes.get(y - (x - dx_val), -1))\n                if end_idx == -1:\n                    continue\n                min_change_len = min(min_change_len, end_idx - start_idx + 1)\n    \n    return min_change_len if min_change_len != float('inf') else -1\n\n# Reading input\nn = int(input())\nops = input()\ntarget_x, target_y = map(int, input().split())\n\n# Printing output\nprint(min_changes_to_reach_target(n, ops, (target_x, target_y)))"}
{"solution": "from collections import defaultdict\n\ndef solve():\n    import sys\n    input = sys.stdin.readline\n    data = input().split()\n    \n    T = int(data[0])\n    \n    for _ in range(T):\n        n, x = map(int, input().split())\n        s = input().strip()\n        \n        balance_s = s.count('0') - s.count('1')\n        prefix_balances = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix_balances[i + 1] = prefix_balances[i] + (1 if s[i] == '0' else -1)\n        \n        if balance_s == 0:\n            if x == 0:\n                print(-1)\n            else:\n                print(0)\n        else:\n            count = 0\n            seen = defaultdict(int)\n            for b in prefix_balances:\n                if (x - b) % balance_s == 0 and (x - b) // balance_s >= 0:\n                    count += 1\n                seen[b] += 1\n            \n            # Check if there's an infinite loop\n            if x in seen:\n                print(-1)\n            else:\n                print(count)\n\nsolve()"}
{"solution": "n, k = map(int, input().split())\n\nnum_str = str(n)\nzeros_needed = k\ndeletions = 0\n\nfor i in range(len(num_str)):\n    if zeros_needed > 0:\n        if num_str[i] == '0':\n            zeros_needed -= 1\n        else:\n            deletions += 1\n    else:\n        if num_str[i] != '0':\n            break\n        deletions += 1\n\nif zeros_needed > 0:\n    deletions += zeros_needed\n\nprint(deletions)"}
{"solution": "def calculate_questions(n, m, k, x, y):\n    def cycle_length(n, m):\n        return (n * m * 2) - (2 * m) if n > 1 else m\n\n    def max_min_questions(n, m, k):\n        cycle = cycle_length(n, m)\n        full_cycles, remainder = divmod(k, cycle)\n        max_questions = full_cycles + (1 if n == 1 else 0)\n        min_questions = full_cycles\n        if remainder > 0:\n            if remainder <= n * m:\n                max_questions += 1\n            else:\n                min_questions += 1\n        return max_questions, min_questions\n\n    def sergie_questions(n, m, k, x, y):\n        cycle = cycle_length(n, m)\n        full_cycles, remainder = divmod(k, cycle)\n        sergie_questions = full_cycles * (2 if n > 1 else 1)\n        if remainder > 0:\n            if remainder <= x * m + y:\n                sergie_questions += 1\n            elif remainder <= (n * m) + ((n - x) * m + m - y):\n                sergie_questions += 1\n        return sergie_questions\n\n    max_questions, min_questions = max_min_questions(n, m, k)\n    sergie_questions = sergie_questions(n, m, k, x, y)\n    return max_questions, min_questions, sergie_questions\n\n# Example usage\nif __name__ == \"__main__\":\n    n, m, k, x, y = map(int, input().split())\n    result = calculate_questions(n, m, k, x, y)\n    print(*result)"}
{"solution": "from collections import Counter\n\ndef max_beauty_after_changes(s, n):\n    counter = Counter(s)\n    most_common = counter.most_common(1)[0][1]\n    others = len(s) - most_common\n    max_beauty = most_common + min(others, n)\n    return max_beauty\n\ndef determine_winner(n, ribbons):\n    max_beauties = [max_beauty_after_changes(ribbon, n) for ribbon in ribbons]\n    max_beauty = max(max_beauties)\n    winners = [names[i] for i, beauty in enumerate(max_beauties) if beauty == max_beauty]\n    \n    if len(winners) > 1:\n        return \"Draw\"\n    else:\n        return winners[0]\n\nnames = [\"Kuro\", \"Shiro\", \"Katie\"]\nribbons = []\n\nn = int(input())\nfor _ in range(3):\n    ribbons.append(input())\n\nprint(determine_winner(n, ribbons))"}
{"solution": "def calculate_reading_days(c, v0, v1, a, l):\n    total_pages_read = 0\n    current_speed = v0\n    days = 0\n    \n    while total_pages_read < c:\n        days += 1\n        if days > 1:\n            total_pages_read -= min(l, total_pages_read)\n        if current_speed + a <= v1:\n            current_speed += a\n        else:\n            current_speed = v1\n        pages_read_today = min(current_speed, c - total_pages_read + (l if days > 1 else 0))\n        total_pages_read += pages_read_today\n    \n    return days\n\n# Reading input\nc, v0, v1, a, l = map(int, input().split())\n\n# Calculating and printing the result\nprint(calculate_reading_days(c, v0, v1, a, l))"}
{"solution": "from math import sqrt\n\ndef is_prime(num):\n    if num <= 1:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(sqrt(num)) + 1, 2):\n        if num % i == 0:\n            return False\n    return True\n\ndef find_prime_representation(n):\n    if n == 3:\n        print(1)\n        print(3)\n        return\n    # Check if n - 2 is prime\n    if is_prime(n - 2):\n        print(2)\n        print(2, n - 2)\n    else:\n        # Find two primes that sum up to n - 2\n        for i in range(2, (n - 2) // 2 + 1):\n            if is_prime(i) and is_prime(n - 2 - i):\n                print(3)\n                print(2, i, n - 2 - i)\n                return\n\n# Read input\nn = int(input())\n\n# Find and print the prime representation\nfind_prime_representation(n)"}
{"solution": "from collections import defaultdict\n\ndef can_destroy_all_walls(grid):\n    n, m = len(grid), len(grid[0])\n    \n    # Count walls in each row and column\n    row_walls = [0] * n\n    col_walls = [0] * m\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*':\n                row_walls[i] += 1\n                col_walls[j] += 1\n    \n    total_walls = sum(row_walls)\n    \n    # Check each cell\n    for i in range(n):\n        for j in range(m):\n            if (row_walls[i] + col_walls[j] - (grid[i][j] == '*')) == total_walls:\n                return \"YES\", i + 1, j + 1  # 1-indexed coordinates\n    \n    return \"NO\", None, None\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Solve and print output\nresult, x, y = can_destroy_all_walls(grid)\nprint(result)\nif result == \"YES\":\n    print(x, y)"}
{"solution": "from math import gcd\n\ndef min_cost(n, m, a, b):\n    if a > b:\n        a, b = b, a\n    \n    lcm = (n * m) // gcd(n, m)\n    remainder = n % m\n    cost_to_build = (m - remainder) * a if remainder else float('inf')\n    cost_to_demolish = remainder * b if remainder else float('inf')\n\n    if cost_to_build < cost_to_demolish:\n        return cost_to_build\n    else:\n        return cost_to_demolish\n\n# Reading input\nn, m, a, b = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_cost(n, m, a, b))"}
{"solution": "def max_odd_subsequence_sum(n, arr):\n    max_odd = float('-inf')\n    max_even = float('-inf')\n    total_sum = 0\n    has_odd = False\n    \n    for num in arr:\n        total_sum += num\n        if num % 2 == 1:\n            has_odd = True\n            max_odd = max(max_odd, num)\n        else:\n            max_even = max(max_even, num)\n\n    if not has_odd:\n        # If there are no odd numbers, subtract the largest even number\n        return total_sum - max_even\n    else:\n        # If there is at least one odd number, the total sum is already odd or can be made odd\n        return total_sum\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(max_odd_subsequence_sum(n, arr))"}
{"solution": "from collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_playlists(n, T, songs):\n    dp = [[[[-1 for _ in range(4)] for _ in range(T + 1)] for _ in range(n + 1)] for _ in range(4)]\n    \n    def dfs(prev_genre, current_duration, used_songs, last_song_genre):\n        if current_duration == T:\n            return 1 if used_songs == n else 0\n        \n        if used_songs == n:\n            return 0\n        \n        if dp[prev_genre][current_duration][used_songs][last_song_genre] != -1:\n            return dp[prev_genre][current_duration][used_songs][last_song_genre]\n        \n        total = 0\n        for i, (duration, genre) in enumerate(songs):\n            if i not in used_songs and genre != last_song_genre:\n                next_used_songs = used_songs | (1 << i)\n                total += dfs(genre, current_duration + duration, next_used_songs, genre)\n                total %= MOD\n        \n        dp[prev_genre][current_duration][used_songs][last_song_genre] = total\n        return total\n\n    result = dfs(0, 0, 0, 0)\n    return result\n\n# Reading input\nn, T = map(int, input().split())\nsongs = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculating and printing the result\nprint(count_playlists(n, T, songs))"}
{"solution": "from math import gcd\nMOD = 10**9 + 7\n\ndef mod_inverse(x):\n    return pow(x, MOD - 2, MOD)\n\ndef solve(m):\n    dp = [0] * (m + 1)\n    dp[1] = 1\n    total = 1\n    for x in range(2, m + 1):\n        for y in range(x, m + 1, x):\n            dp[y] += 1\n            total = (total + dp[y] * mod_inverse(dp[y])) % MOD\n    return (total * mod_inverse(m)) % MOD\n\nm = int(input())\nprint(solve(m))"}
{"solution": "import math\n\ndef count_good_pairs(l, r, x, y):\n    def is_valid_pair(x, y, k):\n        return x * k <= y and y % (x * k) == 0\n    \n    def count_valid_a(x, y, limit):\n        count = 0\n        k = 1\n        while x * k <= limit:\n            if is_valid_pair(x, y, k):\n                count += min(math.ceil(y // (x * k)), limit // (x * k)) - max(1, k) + 1\n            k += 1\n        return count\n    \n    count_l_to_r = count_valid_a(x, y, r) - count_valid_a(x, y, l - 1)\n    return count_l_to_r\n\n# Reading input\nl, r, x, y = map(int, input().split())\n\n# Calculating and printing the result\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "from math import gcd\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef find_optimal_k(a, b):\n    if a > b:\n        a, b = b, a\n    \n    # Ensure a is always the smaller number\n    if a > b:\n        a, b = b, a\n    \n    # If a divides b, then the optimal k is b - a\n    if b % a == 0:\n        return b - a\n    \n    # Calculate the initial LCM\n    initial_lcm = lcm(a, b)\n    \n    # Check if k = 0 is optimal\n    optimal_k = 0\n    optimal_lcm = initial_lcm\n    \n    # Check for k in the range [1, b-a]\n    for k in range(1, b - a + 1):\n        current_lcm = lcm(a + k, b + k)\n        \n        # Update optimal_k and optimal_lcm if a new minimum is found\n        if current_lcm < optimal_lcm:\n            optimal_lcm = current_lcm\n            optimal_k = k\n    \n    return optimal_k\n\n# Reading input\na, b = map(int, input().split())\n\n# Calculating and printing the result\nprint(find_optimal_k(a, b))"}
{"solution": "from math import ceil\n\ndef min_hack_marks(n, k, marks):\n    current_sum = sum(marks)\n    target_final_mark = k\n    # Calculate the minimum sum required to round up to k\n    min_required_sum = ceil((n + 1) * k / 2) * 2 - 1 if ((n + 1) * k) % 2 == 0 else (n + 1) * k\n    # Calculate the minimum number of hacks required\n    min_hacks = max(0, (min_required_sum - current_sum) // k)\n    return min_hacks\n\n# Reading input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(min_hack_marks(n, k, marks))"}
{"solution": "from math import ceil\n\ndef find_divisor(arr):\n    n = len(arr)\n    half = ceil(n / 2)\n    pos_count = sum(1 for num in arr if num > 0)\n    \n    if pos_count >= half:\n        return 1  # Already meets the condition, can divide by 1\n    \n    for d in range(-1000, 1001):\n        if d == 0:\n            continue\n        new_pos_count = sum(1 for num in arr if num / d > 0)\n        if new_pos_count >= half:\n            return d\n    \n    return 0\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(find_divisor(arr))"}
{"solution": "def max_nines_pairs(n):\n    \"\"\"\n    Finds the number of pairs of shovels such that their total cost ends with the maximum possible number of nines.\n    \n    :param n: int - the number of shovels in Polycarp's shop.\n    :return: int - the number of pairs of shovels with the maximum number of nines at the end of their total cost.\n    \"\"\"\n    # The maximum number of nines at the end of the sum is limited by the number of digits in n\n    max_nines = 0\n    while n % 10 == 0:\n        n //= 10\n    while n % 5 == 0:\n        n //= 5\n        max_nines += 1\n    \n    # If there are no nines at the end, return n * (n - 1) / 2\n    if max_nines == 0:\n        return n * (n - 1) // 2\n    \n    # Counting pairs for each possible number of nines\n    pairs = [0] * (max_nines + 1)\n    for i in range(1, n + 1):\n        for j in range(max_nines):\n            if (i + j) % 10 ** (j + 1) == 10 ** (j + 1) - 1:\n                pairs[j + 1] += 1\n    \n    result = 0\n    for k in range(1, max_nines + 1):\n        pairs_k = pairs[k]\n        result += pairs_k * (pairs_k - 1) // 2\n        complement = n - pairs_k\n        result += pairs_k * complement\n    \n    return result\n\n# Read input\nn = int(input())\n\n# Compute and print the result\nprint(max_nines_pairs(n))"}
{"solution": "from math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(a1, b1, a2, b2):\n    area1 = a1 * b1\n    area2 = a2 * b2\n    lcm_area = lcm(area1, area2)\n    \n    result = []\n    for area in [area1, area2]:\n        steps = 0\n        while area != lcm_area:\n            if area % 2 == 0:\n                area //= 2\n            elif area % 3 == 0:\n                area = (2 * area) // 3\n            else:\n                return -1, [], []\n            steps += 1\n        result.append(steps)\n    \n    if result[0] == -1 or result[1] == -1:\n        return -1\n    \n    # Calculate final dimensions\n    final_a1, final_b1 = a1, b1\n    final_a2, final_b2 = a2, b2\n    for _ in range(result[0]):\n        if final_a1 * final_b1 % 2 == 0:\n            final_a1 *= 2\n        else:\n            final_a1 *= 3 // 2\n    for _ in range(result[1]):\n        if final_a2 * final_b2 % 2 == 0:\n            final_a2 *= 2\n        else:\n            final_a2 *= 3 // 2\n    \n    return result[0], (final_a1, final_b1), (final_a2, final_b2)\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\nsteps, final1, final2 = solve(a1, b1, a2, b2)\n\nif steps == -1:\n    print(-1)\nelse:\n    print(steps)\n    print(*final1)\n    print(*final2)"}
{"solution": "def determine_winner(x_p, y_p, x_v, y_v):\n    # Polycarp's optimal strategy is to always move towards (0, 0).\n    # Vasiliy's optimal strategy is to block Polycarp when possible or move closer to (0, 0).\n    # If Polycarp can reach (0, 0) without being blocked by Vasiliy, he wins.\n    # Otherwise, Vasiliy wins.\n    \n    # Calculate the minimum moves for Polycarp and Vasiliy to reach (0, 0)\n    moves_p = x_p + y_p\n    moves_v = x_v + y_v\n    \n    # Check if Polycarp can reach (0, 0) before Vasiliy can block him\n    if moves_p < moves_v:\n        return \"Polycarp\"\n    else:\n        # Check if Vasiliy can block Polycarp\n        # Vasiliy can block Polycarp if he reaches (1, 0) or (0, 1) before Polycarp reaches (0, 0)\n        if min(x_v, y_v) <= 1 and (moves_v - 1) < moves_p:\n            return \"Vasiliy\"\n        else:\n            return \"Polycarp\"\n\n# Read input\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Determine and print the winner\nprint(determine_winner(x_p, y_p, x_v, y_v))"}
{"solution": "def calculate_calendar_columns(month, start_day):\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    # Calculate the number of days in the first partial week\n    first_partial_week = 7 - start_day if start_day != 1 else 0\n    # Calculate the total number of days in the month\n    total_days = days_in_month[month - 1]\n    # Calculate the total number of days including the first partial week\n    total_days_including_partial = first_partial_week + total_days\n    # Calculate the number of full weeks\n    full_weeks = total_days_including_partial // 7\n    # Check if there is an additional partial week at the end\n    additional_partial_week = 1 if total_days_including_partial % 7 != 0 else 0\n    # Calculate the total number of columns needed\n    columns_needed = full_weeks + additional_partial_week\n    return columns_needed\n\n# Read input\nm, d = map(int, input().split())\n\n# Calculate and print the output\nprint(calculate_calendar_columns(m, d))"}
{"solution": "def count_years_with_single_zero(start, end):\n    def count_trailing_ones(n):\n        trailing_zeros_count = 0\n        while n & 1 == 0:\n            n >>= 1\n            trailing_zeros_count += 1\n        return trailing_zeros_count\n\n    def next_year_with_single_zero(year):\n        trailing_zeros = count_trailing_ones(year)\n        if trailing_zeros == 0:\n            return year + (1 << (count_trailing_ones(year + 1) + 1)) - 1\n        else:\n            return year + (1 << trailing_zeros) - 1\n\n    def prev_year_with_single_zero(year):\n        trailing_zeros = count_trailing_ones(year)\n        if trailing_zeros == 0:\n            return year - (1 << (count_trailing_ones(year - 1) + 1)) + 1\n        else:\n            return year - (1 << trailing_zeros) + 1\n\n    count = 0\n    current_year = max(1, prev_year_with_single_zero(start))\n    while current_year <= end:\n        if current_year >= start:\n            count += 1\n        current_year = next_year_with_single_zero(current_year)\n\n    return count\n\n# Reading input\na, b = map(int, input().split())\n\n# Calculating and printing the result\nprint(count_years_with_single_zero(a, b))"}
{"solution": "def minimal_layers(N):\n    return (N * (N + 1)) // 2\n\n# Reading input\nN = int(input())\nprint(minimal_layers(N))"}
{"solution": "from math import factorial\nfrom itertools import combinations\n\ndef calculate_ways(n, k, S, cubes):\n    # Pre-calculate factorials for efficiency\n    fact = [factorial(i) for i in range(max(cubes) + 1)]\n    \n    def dfs(index, remaining_k, current_sum):\n        if current_sum == S and remaining_k >= 0:\n            return 1\n        if index == len(cubes) or remaining_k < 0 or current_sum > S:\n            return 0\n        \n        # Skip current cube\n        ways = dfs(index + 1, remaining_k, current_sum)\n        \n        # Use current cube without sticker\n        ways += dfs(index + 1, remaining_k, current_sum + cubes[index])\n        \n        # Use current cube with sticker if stickers remain\n        if remaining_k > 0:\n            ways += dfs(index + 1, remaining_k - 1, current_sum + fact[cubes[index]])\n        \n        return ways\n    \n    return dfs(0, k, 0)\n\n# Read input\nn, k, S = map(int, input().split())\ncubes = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(calculate_ways(n, k, S, cubes))"}
{"solution": "from collections import defaultdict\n\ndef can_achieve_array(n, k, a):\n    power_sum = defaultdict(int)\n    \n    for i in range(n):\n        val = a[i]\n        while val > 0:\n            power_of_k = next((p for p in sorted(power_sum.keys(), reverse=True) if val >= k**p), -1)\n            if power_of_k == -1:\n                if val < k**0:\n                    return False\n                power_sum[0] += 1\n                val -= k**0\n            else:\n                val -= k**power_of_k\n                power_sum[power_of_k] -= 1\n                if val > 0:\n                    next_power = power_of_k + 1\n                    while next_power in power_sum and power_sum[next_power] == 0:\n                        next_power += 1\n                    power_sum[next_power] += 1\n    \n    return all(v == 0 for v in power_sum.values())\n\n# Reading input\nT = int(input())\nfor _ in range(T):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    # Printing output\n    if can_achieve_array(n, k, a):\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "MOD = 1073741824\n\ndef divisors(n):\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            count += 2\n            if i * i == n:\n                count -= 1\n        i += 1\n    return count\n\ndef calculate_sum(a, b, c):\n    total_sum = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                total_sum += divisors(i * j * k)\n                total_sum %= MOD\n    return total_sum\n\na, b, c = map(int, input().split())\nresult = calculate_sum(a, b, c)\nprint(result)"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    neighbors = []\n    idx = state.index('X')\n    if idx == 0:\n        neighbors.append(swap(state, 0, 1))\n        neighbors.append(swap(state, 0, 2))\n    elif idx == 1:\n        neighbors.append(swap(state, 1, 0))\n        neighbors.append(swap(state, 1, 3))\n    elif idx == 2:\n        neighbors.append(swap(state, 2, 0))\n        neighbors.append(swap(state, 2, 3))\n    elif idx == 3:\n        neighbors.append(swap(state, 3, 1))\n        neighbors.append(swap(state, 3, 2))\n    return neighbors\n\ndef swap(state, i, j):\n    state = list(state)\n    state[i], state[j] = state[j], state[i]\n    return ''.join(state)\n\ndef bfs(start):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        current = queue.popleft()\n        for neighbor in get_neighbors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return visited\n\ndef can_be_same_configuration(bessie, elsie):\n    bessie_start = ''.join(bessie)\n    elsie_start = ''.join(elsie)\n    \n    bessie_reachable = bfs(bessie_start)\n    elsie_reachable = bfs(elsie_start)\n    \n    return not bessie_reachable.isdisjoint(elsie_reachable)\n\n# Input reading\nbessie = [input().strip() for _ in range(2)]\nelsie = [input().strip() for _ in range(2)]\n\nif can_be_same_configuration(bessie, elsie):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_decimal_number(n, k):\n    def convert_to_decimal(num_str, base):\n        return sum(int(digit) * base ** exp for exp, digit in enumerate(reversed(num_str)))\n\n    left, right = 0, 10 ** 18\n    while left < right:\n        mid = (left + right) // 2\n        if convert_to_decimal(k, n) > mid:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\nif __name__ == \"__main__\":\n    n = int(input())\n    k = input().strip()\n    print(min_decimal_number(n, k))"}
{"solution": "def is_unimodal(n, arr):\n    increasing = False\n    constant = False\n    decreasing = True\n    for i in range(1, n):\n        if arr[i] > arr[i - 1]:\n            if decreasing:\n                return \"NO\"\n            if not increasing:\n                increasing = True\n        elif arr[i] < arr[i - 1]:\n            if not increasing and not constant:\n                increasing = True\n                constant = True\n            elif increasing and not decreasing:\n                return \"NO\"\n            decreasing = True\n        else:\n            if not increasing and not constant:\n                increasing = True\n                constant = True\n            elif increasing and not decreasing:\n                return \"NO\"\n            decreasing = False\n    return \"YES\"\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Checking and printing the result\nprint(is_unimodal(n, arr))"}
{"solution": "import math\n\ndef find_max_value(n, k):\n    def f(x):\n        return x // 2 if x % 2 == 0 else x - 1\n    \n    def count_occurrences(y, n):\n        count = 0\n        while y <= n:\n            count += min(n + 1, 2 * y + 1) - y\n            y = 2 * y + 1\n        return count\n    \n    # Binary search for the maximum value\n    low, high = 1, n\n    result = 1\n    while low <= high:\n        mid = (low + high) // 2\n        if count_occurrences(mid, n) >= k:\n            result = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    return result\n\n# Reading input\nn, k = map(int, input().split())\n\n# Solving and printing the output\nprint(find_max_value(n, k))"}
{"solution": "def find_pocket(n, m, x, y, vx, vy):\n    def simulate_movement():\n        nonlocal x, y\n        while True:\n            if x == 0 and y == 0:\n                return (0, 0)\n            elif x == n and y == 0:\n                return (n, 0)\n            elif x == n and y == m:\n                return (n, m)\n            elif x == 0 and y == m:\n                return (0, m)\n\n            if vx > 0:\n                if n - x < abs(vy * (n - x) // vx):\n                    y += (n - x) * vy // vx\n                    x = n\n                    vx = -vx\n                else:\n                    x += (vy * (n - x) // vx)\n                    y = n - (vy * (n - x) // vx)\n            elif vx < 0:\n                if x < abs(vy * x // vx):\n                    y += x * vy // vx\n                    x = 0\n                    vx = -vx\n                else:\n                    x += (vy * x // vx)\n                    y = vy * x // vx\n            if vy > 0:\n                if m - y < abs(vx * (m - y) // vy):\n                    x += (m - y) * vx // vy\n                    y = m\n                    vy = -vy\n                else:\n                    y += (vx * (m - y) // vy)\n                    x = x + (vx * (m - y) // vy)\n            elif vy < 0:\n                if y < abs(vx * y // vy):\n                    x += y * vx // vy\n                    y = 0\n                    vy = -vy\n                else:\n                    y += (vx * y // vy)\n                    x = x + (vx * y // vy)\n\n    if vx == 0 and vy == 0:\n        return -1\n    return simulate_movement()\n\n# Reading input\nn, m, x, y, vx, vy = map(int, input().split())\n\n# Calculating and printing the result\nresult = find_pocket(n, m, x, y, vx, vy)\nif isinstance(result, tuple):\n    print(*result)\nelse:\n    print(result)"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    def fits(w1, h1, w2, h2, W, H):\n        return (w1 + w2 <= W and max(h1, h2) <= H) or (h1 + h2 <= H and max(w1, w2) <= W)\n    \n    if (fits(a2, b2, a3, b3, a1, b1) or fits(b2, a2, a3, b3, a1, b1) or\n        fits(a2, b2, b3, a3, a1, b1) or fits(b2, a2, b3, a3, a1, b1) or\n        fits(a3, b3, a2, b2, a1, b1) or fits(b3, a3, a2, b2, a1, b1) or\n        fits(a3, b3, b2, a2, a1, b1) or fits(b3, a3, b2, a2, a1, b1)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Example usage:\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\nprint(can_place_paintings(a1, b1, a2, b2, a3, b3))"}
{"solution": "from collections import defaultdict\n\ndef solve(b1, q, l, m, bad):\n    if q == 0:\n        if abs(b1) <= l and b1 not in bad:\n            return 1\n        else:\n            return 0\n    \n    bad_set = set(bad)\n    cycle = defaultdict(set)\n    cycle_len = {}\n    \n    for num in bad_set:\n        n = num\n        seq = []\n        while n not in cycle and n != 0:\n            seq.append(n)\n            if n % q == 0:\n                n //= q\n            else:\n                break\n        \n        if n in cycle:\n            for s in seq:\n                cycle[s] = cycle[n]\n        elif n == 0:\n            for s in seq:\n                cycle[s] = {0}\n        else:\n            for s in seq:\n                cycle[s] = set()\n        \n        if len(seq) > 0:\n            cycle_len[num] = len(seq)\n    \n    count = 0\n    n = b1\n    seen = set()\n    while abs(n) <= l:\n        if n in bad_set:\n            if n in seen:\n                break\n            seen.add(n)\n            if cycle[n]:\n                cycle_len[n] -= 1\n                if cycle_len[n] == 0:\n                    break\n        else:\n            count += 1\n        n *= q\n    \n    if count == 0 and seen:\n        return \"inf\"\n    return count\n\nb1, q, l, m = map(int, input().split())\nbad = list(map(int, input().split()))\n\nprint(solve(b1, q, l, m, bad))"}
{"solution": "from collections import defaultdict\n\ndef find_min_square_frame(matrix):\n    rows, cols = len(matrix), len(matrix[0])\n    white_pixels = [(r, c) for r in range(rows) for c in range(cols) if matrix[r][c] == 'w']\n    \n    min_row, max_row = min(white_pixels, key=lambda x: x[0])[0], max(white_pixels, key=lambda x: x[0])[0]\n    min_col, max_col = min(white_pixels, key=lambda x: x[1])[1], max(white_pixels, key=lambda x: x[1])[1]\n    \n    # Find the minimum square size that can fit within the bounds\n    side_length = min(max_row - min_row + 1, max_col - min_col + 1)\n    \n    # Check if a square frame of size `side_length` fits all white pixels\n    def check_square_fit(r, c, size):\n        expected_white = set()\n        for i in range(size):\n            expected_white.add((r + i, c))\n            expected_white.add((r + i, c + size - 1))\n        for j in range(1, size - 1):\n            expected_white.add((r, c + j))\n            expected_white.add((r + size - 1, c + j))\n        \n        return all(matrix[x][y] == 'w' for x, y in expected_white)\n    \n    for size in range(side_length, 0, -1):\n        for r in range(min_row, min_row + (side_length - size) + 1):\n            for c in range(min_col, min_col + (side_length - size) + 1):\n                if check_square_fit(r, c, size):\n                    # Draw the frame\n                    for i in range(size):\n                        matrix[r + i] = matrix[r + i][:c] + '+' * size + matrix[r + i][c + size:]\n                        matrix[r + i] = matrix[r + i][:c] + matrix[r + i][c].replace('w', 'w').replace('.', '+') + matrix[r + i][c + 1:]\n                        matrix[r + i] = matrix[r + i][:-1] + matrix[r + i][-1].replace('w', 'w').replace('.', '+')\n                    matrix[r] = matrix[r][:c + 1] + matrix[r][c + 1:].replace('w', 'w').replace('.', '+')\n                    matrix[r + size - 1] = matrix[r + size - 1][:c + 1] + matrix[r + size - 1][c + 1:].replace('w', 'w').replace('.', '+')\n                    return matrix\n    return -1\n\ndef solve():\n    n, m = map(int, input().split())\n    matrix = [input() for _ in range(n)]\n    \n    result = find_min_square_frame(matrix)\n    if result == -1:\n        print(-1)\n    else:\n        for row in result:\n            print(row)\n\nsolve()"}
{"solution": "def can_spend_exactly(n, a, b):\n    import math\n    \n    # Ensure a is always the smaller one\n    if a > b:\n        a, b = b, a\n    \n    # Calculate the greatest common divisor and the coefficients\n    def gcd_extended(x, y):\n        if x == 0:\n            return y, 0, 1\n        else:\n            g, x1, y1 = gcd_extended(y % x, x)\n            return g, y1 - (y // x) * x1, x1\n    \n    g, x, y = gcd_extended(a, b)\n    \n    # Check if n is divisible by the gcd of a and b\n    if n % g != 0:\n        print(\"NO\")\n        return\n    \n    # Scale the solution to match n\n    x *= n // g\n    y *= n // g\n    \n    # Adjust the solution to ensure both x and y are non-negative\n    t = (x - (n - (x * a))) // (b // g)\n    x -= t * (b // g)\n    y += t * (a // g)\n    \n    if x >= 0 and y >= 0:\n        print(\"YES\")\n        print(x, y)\n    else:\n        print(\"NO\")\n\n# Reading inputs\nn = int(input())\na = int(input())\nb = int(input())\n\n# Solving the problem\ncan_spend_exactly(n, a, b)"}
{"solution": "def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\ns = int(input())\nprint(number_to_words(s))"}
{"solution": "def max_elements_to_erase(n, arr):\n    if n <= 2:\n        return 0\n    \n    max_erase = 0\n    for i in range(2, n):\n        left_gap = arr[i - 2] - 1\n        right_gap = 1000 - arr[i - 1]\n        max_erase = max(max_erase, min(left_gap, right_gap))\n    \n    return max_erase if max_erase > 0 else 0\n\n# Example usage\nn = int(input())\narr = list(map(int, input().split()))\nprint(max_elements_to_erase(n, arr))"}
{"solution": "n = int(input())\nproblems = list(map(int, input().split()))\n\ntotal_problems = sum(problems)\ncumulative_problems = 0\n\nfor day in range(n):\n    cumulative_problems += problems[day]\n    if cumulative_problems * 2 >= total_problems:\n        print(day + 1)\n        break"}
{"solution": "from heapq import heappush, heappop\n\ndef solve_chess_puzzle(N, board):\n    def manhattan(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def knights_moves(pos):\n        x, y = pos\n        moves = [(x + dx, y + dy) for dx, dy in [(-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2)]]\n        return [(nx, ny) for nx, ny in moves if 0 <= nx < N and 0 <= ny < N]\n\n    def bishops_and_rooks_moves(pos):\n        x, y = pos\n        moves = []\n        # Horizontal and Vertical for Rook\n        for dx, dy in [(0, 1), (1, 0)]:\n            for k in range(1, N):\n                nx, ny = x + k * dx, y + k * dy\n                if 0 <= nx < N and 0 <= ny < N:\n                    moves.append((nx, ny))\n                else:\n                    break\n        # Diagonal for Bishop\n        for dx, dy in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:\n            for k in range(1, N):\n                nx, ny = x + k * dx, y + k * dy\n                if 0 <= nx < N and 0 <= ny < N:\n                    moves.append((nx, ny))\n                else:\n                    break\n        return moves\n\n    def find_pos(num):\n        for i in range(N):\n            for j in range(N):\n                if board[i][j] == num:\n                    return (i, j)\n\n    # Initialize distances\n    start_pos = find_pos(1)\n    target_pos = find_pos(N * N)\n    dist = {(start_pos, 'k'): (0, 0), (start_pos, 'b'): (manhattan(start_pos, target_pos), 0), (start_pos, 'r'): (manhattan(start_pos, target_pos), 0)}\n    pq = [(0, start_pos, 'k', 0)]  # (steps, pos, piece, replacements)\n\n    while pq:\n        steps, pos, piece, replacements = heappop(pq)\n\n        if board[pos[0]][pos[1]] == N * N:\n            return steps, replacements\n\n        for next_pos in [find_pos(board[pos[0]][pos[1]] + i) for i in range(1, N * N - board[pos[0]][pos[1]] + 1) if find_pos(board[pos[0]][pos[1]] + i)]:\n            if piece == 'k':\n                if next_pos in knights_moves(pos):\n                    next_steps = steps + 1\n                    next_replacements = replacements\n                elif next_pos in bishops_and_rooks_moves(pos):\n                    next_steps = steps + 1\n                    next_replacements = replacements + 1\n            elif piece == 'b' and next_pos in bishops_and_rooks_moves(pos):\n                next_steps = steps + 1\n                next_replacements = replacements\n            elif piece == 'r' and next_pos in bishops_and_rooks_moves(pos):\n                next_steps = steps + 1\n                next_replacements = replacements\n            else:\n                continue\n\n            if (next_pos, piece) not in dist or (next_steps, next_replacements) < dist[(next_pos, piece)]:\n                dist[(next_pos, piece)] = (next_steps, next_replacements)\n                heappush(pq, (next_steps, next_pos, piece, next_replacements))\n\n# Example usage\nN = int(input())\nboard = [list(map(int, input().split())) for _ in range(N)]\nresult = solve_chess_puzzle(N, board)\nprint(*result)"}
{"solution": "def min_time(n, m, k, a, b):\n    def time_to_first_floor(a):\n        p, fl = divmod(a - 1, k * m)\n        return min(10 + abs(fl) + 5 * (m - 1 - abs(fl)), 10 + 5 * fl)\n\n    def time_between_blocks(p1, p2):\n        return 15 * min(abs(p1 - p2), n - abs(p1 - p2))\n\n    def time_to_floor(p, fl):\n        return 10 + abs(fl) + 5 * (m - 1 - abs(fl)) if fl != 0 else 10\n\n    p1, fl1 = divmod(a - 1, k * m)\n    p2, fl2 = divmod(b - 1, k * m)\n\n    t1 = time_to_first_floor(a)\n    t2 = time_between_blocks(p1, p2)\n\n    if fl2 == 0:\n        return t1 + t2\n    else:\n        return t1 + t2 + time_to_floor(p2, fl2)\n\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\nprint(min_time(n, m, k, a, b))"}
{"solution": "def can_divide_by_64(binary_str):\n    # Check if there's any occurrence of '0' after the first '1'\n    first_one_index = binary_str.find('1')\n    if first_one_index != -1:\n        return '0' in binary_str[first_one_index + 1:]\n    return False\n\n# Read input\nbinary_str = input()\n\n# Determine if it's possible to remove digits to get a number divisible by 64\nresult = \"no\" if can_divide_by_64(binary_str) else \"yes\"\n\n# Print output\nprint(result)"}
{"solution": "from collections import defaultdict\n\ndef transform_string(s):\n    # Track the last occurrence of each character\n    last_occurrence = defaultdict(int)\n    for i, char in enumerate(s):\n        last_occurrence[char] = i\n    \n    # Initialize variables\n    result = []\n    current_char = 'a'\n    position = -1\n    \n    while current_char <= 'z':\n        found = False\n        for char in range(ord(current_char), ord('z') + 1):\n            char = chr(char)\n            if char in last_occurrence and last_occurrence[char] > position:\n                position = last_occurrence[char]\n                result.append(char)\n                found = True\n                break\n        \n        if not found:\n            return \"-1\"\n        \n        current_char = chr(ord(current_char) + 1)\n    \n    return ''.join(result)\n\n# Read input\ns = input().strip()\n\n# Process and print output\nprint(transform_string(s))"}
{"solution": "from heapq import heappush, heappop\n\ndef max_expected_fishes(n, m, r, k):\n    def get_sum(x):\n        return (x * (x + 1) // 2)\n\n    def solve(n, r, k):\n        total = 0\n        max_heap = []\n        for i in range(min(r, n), 0, -1):\n            val = get_sum(i)\n            heappush(max_heap, -val)\n            total += val\n        for _ in range(k - n + r - 1):\n            max_val = -heappop(max_heap)\n            next_val = max_val - (r - 1)\n            heappush(max_heap, -next_val)\n            total += next_val - max_val\n        return total\n\n    ans1 = solve(n, r, k)\n    ans2 = solve(m, r, k)\n    return (ans1 * (m - r + 1) + ans2 * (n - r + 1) - ans1 * ans2) / ((n - r + 1) * (m - r + 1))\n\n# Example usage\nif __name__ == \"__main__\":\n    n, m, r, k = map(int, input().split())\n    print(max_expected_fishes(n, m, r, k))"}
{"solution": "from typing import List\n\ndef maximize_product(arr: List[int]) -> List[int]:\n    \"\"\"\n    Modifies the given array to achieve the maximum possible product of its elements\n    by applying the operation a_i := -a_i - 1 any number of times.\n    \"\"\"\n    negative_count = sum(x < 0 for x in arr)\n    all_non_positive = all(x <= 0 for x in arr)\n    \n    if not arr or (all_non_positive and negative_count % 2 == 0):\n        return [-x - 1 for x in arr]\n    \n    result = []\n    for x in arr:\n        if all_non_positive and negative_count % 2 != 0 and x == max(arr):\n            result.append(-x - 1)\n        else:\n            result.append(-x - 1 if x >= 0 else x)\n    \n    return result\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Processing and printing output\nprint(' '.join(map(str, maximize_product(arr))))"}
{"solution": "import math\n\ndef find_kth_divisor(n, k):\n    def count_divisors(x):\n        count = 0\n        for i in range(1, int(math.sqrt(x)) + 1):\n            if x % i == 0:\n                count += 1\n                if i * i != x:\n                    count += 1\n        return count\n    \n    if n == 1:\n        return 1 if k == 1 else -1\n    \n    low, high = 1, n\n    while low < high:\n        mid = (low + high) // 2\n        if count_divisors(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n            \n    if count_divisors(low) >= k:\n        for i in range(1, int(math.sqrt(low)) + 1):\n            if low % i == 0:\n                k -= 1\n                if k == 0:\n                    return i if low // i == i else low // i\n    return -1\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(find_kth_divisor(n, k))"}
{"solution": "from itertools import product\n\ndef max_number(cubes):\n    digits = [{face for face in cube} for cube in cubes]\n    valid_digits = {str(i) for i in range(1, 10)}\n    valid_digits.remove('9')  # 9 cannot be used as 6\n\n    # Check if '1' is available in any cube\n    if not any('1' in digit_set for digit_set in digits):\n        return 0\n\n    # Generate all possible combinations of digits\n    max_len = sum(len(cube) for cube in cubes)\n    for length in range(1, max_len + 1):\n        for combo in product(*digits, repeat=length):\n            combo_set = set(combo)\n            if len(combo_set) < length:\n                continue  # Skip if there are repeated digits in the combination\n            \n            # Check for invalid combinations\n            if ('6' in combo_set and '9' in combo_set) or ('0' in combo_set and length == 1):\n                continue\n            \n            # Check if all digits from 1 to 9 (excluding 9) are representable\n            if valid_digits.issubset(combo_set):\n                # Construct the maximum number\n                max_num = ''.join(sorted(combo_set, reverse=True))\n                if '0' in max_num:\n                    max_num = max_num.replace('0', '', 1)\n                return int(max_num)\n    \n    return 0\n\n# Reading input\nn = int(input())\ncubes = [list(map(int, input().split())) for _ in range(n)]\n\n# Printing output\nprint(max_number(cubes))"}
{"solution": "import math\n\ndef k_rounding(n, k):\n    if k == 0:\n        return n\n    power_of_10 = 10 ** k\n    quotient, remainder = divmod(n, power_of_10)\n    if remainder == 0:\n        return n\n    else:\n        multiplier = math.ceil((power_of_10 / remainder))\n        return n * multiplier\n\nn, k = map(int, input().split())\nprint(k_rounding(n, k))"}
{"solution": "def transform_matrix(n, m, A):\n    operations = []\n    B = [[0] * m for _ in range(n)]\n    \n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                operations.append((i + 1, j + 1))\n                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1\n    \n    for i in range(n):\n        for j in range(m):\n            if A[i][j] != B[i][j]:\n                return -1\n    \n    return operations\n\n# Input reading\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\n# Process the transformation\nresult = transform_matrix(n, m, A)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for x, y in result:\n        print(x, y)"}
{"solution": "from math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(r, s, p):\n    total = r + s + p\n    if total == 1:\n        return [1 if r else 0, 1 if s else 0, 1 if p else 0]\n\n    L1 = lcm(r + s, s + p)\n    L2 = lcm(L1, r + p)\n\n    a = L2 // (r + s)\n    b = L2 // (s + p)\n    c = L2 // (r + p)\n\n    A = (a * p) // (r + p)\n    B = (b * r) // (r + s)\n    C = (c * s) // (s + p)\n\n    S = a * s + b * r + c * p - A - B - C\n\n    Pr = S * (r * L2) // ((r + s) * (r + p))\n    Ps = S * (s * L2) // ((s + p) * (r + s))\n    Pp = S * (p * L2) // ((r + p) * (s + p))\n\n    Pr += (a * s * r * p) // ((r + s) * (s + p))\n    Ps += (b * r * s * p) // ((r + s) * (s + p))\n    Pp += (c * s * r * p) // ((r + p) * (s + p))\n\n    return [Pr / L2, Ps / L2, Pp / L2]\n\nr, s, p = map(int, input().split())\nprobabilities = solve(r, s, p)\nprint(' '.join(f'{prob:.15f}' for prob in probabilities))"}
{"solution": "def calculate_together_time(l1, r1, l2, r2, k):\n    # Calculate the intersection of the two intervals\n    start = max(l1, l2)\n    end = min(r1, r2)\n\n    # If there's no intersection, they won't meet\n    if start > end:\n        return 0\n\n    # Adjust for the minute Sonya prinks\n    if start <= k <= end:\n        end = k - 1\n\n    # Calculate the total time they can spend together\n    together_time = max(0, end - start + 1)\n\n    return together_time\n\n# Reading input\nl1, r1, l2, r2, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(calculate_together_time(l1, r1, l2, r2, k))"}
{"solution": "from typing import List\nfrom fractions import Fraction\nfrom collections import defaultdict\n\ndef cross(a, b):\n    return a.real * b.imag - a.imag * b.real\n\ndef dot(a, b):\n    return a.real * b.real + a.imag * b.imag\n\ndef subtract(a, b):\n    return complex(a.real - b.real, a.imag - b.imag)\n\ndef convex_hull(points: List[complex]):\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2] - lower[-1], p - lower[-1]) >= 0:\n            lower.pop()\n        lower.append(p)\n\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2] - upper[-1], p - upper[-1]) >= 0:\n            upper.pop()\n        upper.append(p)\n\n    return lower[:-1] + upper[:-1]\n\ndef intersection_line_vertical(line1, line2):\n    A1, B1, C1 = line1\n    D2, E2, F2 = line2\n\n    x = C1\n    if D2 <= x <= E2 or E2 <= x <= D2:\n        y1 = max(A1, B1)\n        y2 = min(A1, B1)\n        return (x, y1, y2)\n    return None\n\ndef intersection_line_horizontal(line1, line2):\n    A1, B1, C1 = line1\n    D2, E2, F2 = line2\n\n    y = C1\n    if A1 <= y <= B1 or B1 <= y <= A1:\n        x1 = max(D2, E2)\n        x2 = min(D2, E2)\n        return (x1, x2, y)\n    return None\n\ndef process_lines(vertical_lines, horizontal_lines):\n    intersections = set()\n\n    for v1 in vertical_lines:\n        for h1 in horizontal_lines:\n            intersection = intersection_line_vertical(v1, h1)\n            if intersection:\n                intersections.add(complex(intersection[0], intersection[2]))\n                intersections.add(complex(intersection[1], intersection[2]))\n\n    for v1 in vertical_lines:\n        for v2 in vertical_lines:\n            if v1 != v2:\n                intersection = intersection_line_vertical(v1, v2)\n                if intersection:\n                    intersections.add(complex(intersection[0], intersection[2]))\n\n    for h1 in horizontal_lines:\n        for h2 in horizontal_lines:\n            if h1 != h2:\n                intersection = intersection_line_horizontal(h1, h2)\n                if intersection:\n                    intersections.add(complex(intersection[2], intersection[0]))\n                    intersections.add(complex(intersection[2], intersection[1]))\n\n    return intersections\n\ndef calculate_area(points: List[complex]):\n    hull = convex_hull(points)\n    origin = complex(0, 0)\n    area = 0\n    for i in range(len(hull)):\n        p1 = hull[i]\n        p2 = hull[(i + 1) % len(hull)]\n        if dot(subtract(p1, origin), subtract(p2, origin)) > 0:\n            continue\n        area += cross(p1, p2).real / 2\n    return int(abs(area))\n\ndef main():\n    N, M = map(int, input().split())\n    vertical_lines = [tuple(map(int, input().split())) for _ in range(N)]\n    horizontal_lines = [tuple(map(int, input().split())) for _ in range(M)]\n\n    intersections = process_lines(vertical_lines, horizontal_lines)\n    if not intersections:\n        print(\"INF\")\n        return\n\n    area = calculate_area(list(intersections))\n    print(area)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "t, s, x = map(int, input().split())\n\nif t == x or (x - t) % (s + 1) == 0 or (x - t - 1) % (s + 1) == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "from typing import List\n\ndef find_nested_segments(segments: List[List[int]]) -> List[int]:\n    n = len(segments)\n    result = [-1, -1]\n    \n    # Sort segments by their start point, and keep track of original indices\n    sorted_segments = sorted((l, r, i) for i, (l, r) in enumerate(segments))\n    \n    # Initialize variables\n    max_end = -1\n    containing_segment = -1\n    \n    for l, r, original_index in sorted_segments:\n        # Check if current segment is contained within another\n        if l >= max_end:\n            max_end = r\n            containing_segment = original_index\n        elif r <= max_end:\n            result = [original_index + 1, containing_segment + 1]\n            break\n    \n    return result\n\n# Read input\nn = int(input())\nsegments = [list(map(int, input().split())) for _ in range(n)]\n\n# Find nested segments\nresult = find_nested_segments(segments)\n\n# Print result\nprint(*result)"}
{"solution": "def decode_genome(n, s):\n    counts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\n    unknown = 0\n    \n    for char in s:\n        if char != '?':\n            counts[char] += 1\n        else:\n            unknown += 1\n    \n    target_count = n // 4\n    nucleotides = ['A', 'C', 'G', 'T']\n    \n    for char in counts:\n        needed = target_count - counts[char]\n        if needed > unknown:\n            return \"===\"  # Impossible to decode\n        unknown -= min(needed, unknown)\n    \n    result = list(s)\n    i = 0\n    for char in nucleotides:\n        needed = target_count - counts[char]\n        while needed > 0 and i < len(result):\n            if result[i] == '?':\n                result[i] = char\n                needed -= 1\n            i += 1\n    \n    return ''.join(result)\n\n# Example usage\nn = int(input())\ns = input()\nprint(decode_genome(n, s))"}
{"solution": "def can_ilya_win(board):\n    for i in range(4):\n        # Check horizontal and vertical\n        for j in range(4):\n            if board[i][j] == '.':\n                # Horizontal check\n                if (j < 3 and board[i][j + 1] == 'x' and board[i][j + 2] == 'x') or \\\n                   (j > 1 and board[i][j - 1] == 'x' and board[i][j - 2] == 'x'):\n                    return \"YES\"\n                # Vertical check\n                if (i < 3 and board[i + 1][j] == 'x' and board[i + 2][j] == 'x') or \\\n                   (i > 1 and board[i - 1][j] == 'x' and board[i - 2][j] == 'x'):\n                    return \"YES\"\n\n    # Check diagonals\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                # Main diagonal check\n                if i < 3 and j < 3 and board[i + 1][j + 1] == 'x' and board[i + 2][j + 2] == 'x':\n                    return \"YES\"\n                if i > 1 and j > 1 and board[i - 1][j - 1] == 'x' and board[i - 2][j - 2] == 'x':\n                    return \"YES\"\n                # Anti-diagonal check\n                if i < 3 and j > 1 and board[i + 1][j - 1] == 'x' and board[i + 2][j - 2] == 'x':\n                    return \"YES\"\n                if i > 1 and j < 3 and board[i - 1][j + 1] == 'x' and board[i - 2][j + 2] == 'x':\n                    return \"YES\"\n\n    return \"NO\"\n\n# Reading the board from standard input\nboard = [input() for _ in range(4)]\n\n# Output\nprint(can_ilya_win(board))"}
{"solution": "def can_balance_array(nums):\n    total_sum = sum(nums)\n    prefix_sum = 0\n    suffix_sum = 0\n    n = len(nums)\n    for i in range(n):\n        suffix_sum = total_sum - prefix_sum - nums[i]\n        if prefix_sum == suffix_sum:\n            return \"YES\"\n        if i > 0 and prefix_sum - nums[i-1] == suffix_sum:\n            return \"YES\"\n        prefix_sum += nums[i]\n    return \"NO\"\n\n# Read input\nn = int(input())\nnums = list(map(int, input().split()))\n\n# Output result\nprint(can_balance_array(nums))"}
{"solution": "from typing import List\n\ndef can_recover_sequence(n: int, k: int, a: List[int], b: List[int]) -> str:\n    # Place all zeros in a list\n    zero_indices = [i for i, value in enumerate(a) if value == 0]\n    \n    # Sort b in descending order to try and make the sequence non-increasing\n    b.sort(reverse=True)\n    \n    # Replace zeros in a with elements from b in descending order\n    for i, index in enumerate(zero_indices):\n        a[index] = b[i]\n    \n    # Check if the sequence is non-increasing\n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            return \"No\"\n    \n    return \"Yes\"\n\n# Reading input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Printing output\nprint(can_recover_sequence(n, k, a, b))"}
{"solution": "def can_make_happy(x, y, z, a, b, c):\n    # Check if it's possible to make everyone happy\n    if a >= x and a + b >= y and a + b + c >= x + y + z:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Example usage\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\nprint(can_make_happy(x, y, z, a, b, c))"}
{"solution": "def is_accident_possible(lights):\n    for l, s, r, p in lights:\n        if p == 1:  # Pedestrian light is green\n            if l == 1 or s == 1 or r == 1:  # Any car light is green\n                return \"YES\"\n    return \"NO\"\n\n# Reading input\nlights = []\nfor _ in range(4):\n    lights.append(list(map(int, input().split())))\n\n# Printing output\nprint(is_accident_possible(lights))"}
{"solution": "def get_coordinates(digit):\n    keypad = {\n        '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2),\n        '0': (3, 1)\n    }\n    return keypad[digit]\n\ndef get_vectors(number):\n    vectors = []\n    for i in range(len(number) - 1):\n        x1, y1 = get_coordinates(number[i])\n        x2, y2 = get_coordinates(number[i + 1])\n        vectors.append((x2 - x1, y2 - y1))\n    return vectors\n\ndef is_unique_finger_movement(n, number):\n    original_vectors = get_vectors(number)\n    for i in range(10**(n-1), 10**n):\n        candidate = str(i).zfill(n)\n        if candidate != number:\n            if get_vectors(candidate) == original_vectors:\n                return \"NO\"\n    return \"YES\"\n\n# Input reading\nn = int(input())\nnumber = input().strip()\n\n# Output the result\nprint(is_unique_finger_movement(n, number))"}
{"solution": "from heapq import heappush, heappop\n\ndef max_products_sold(n, f, items):\n    lost_sales = []\n    extra_stock = 0\n    total_sold = 0\n    sell_out_days = 0\n    \n    for k, l in items:\n        if k > l:\n            heappush(lost_sales, l - k)\n        else:\n            total_sold += min(k * 2 if sell_out_days < f else k, l)\n            if sell_out_days < f and l > k * 2:\n                extra_stock += l - (k * 2)\n        \n        while extra_stock > 0 and lost_sales:\n            wasted = heappop(lost_sales)\n            if wasted <= extra_stock:\n                extra_stock -= wasted\n                total_sold += wasted\n            else:\n                total_sold += extra_stock\n                wasted -= extra_stock\n                extra_stock = 0\n                heappush(lost_sales, wasted)\n                \n        sell_out_days += 1\n        \n    return total_sold\n\n# Reading input\nn, f = map(int, input().split())\nitems = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculating and printing output\nprint(max_products_sold(n, f, items))"}
{"solution": "import sys\n\ndef max_messiness(n, k):\n    # The maximum messiness is achieved by reversing the array,\n    # which can always be done in at most n-1 swaps.\n    # If k is enough to reverse the array, use n * (n - 1) // 2 as messiness.\n    # Otherwise, the messiness is limited by the number of swaps k.\n    return min(n * (n - 1) // 2, k * (n - 1))\n\n# Reading input\ninput_data = sys.stdin.read().split()\nn, k = map(int, input_data)\n\n# Calculating and printing the result\nprint(max_messiness(n, k))"}
{"solution": "import math\n\ndef min_coins_for_friends(N, M, K, L):\n    # Check if it's possible to satisfy the conditions\n    if N - K < L or N < M:\n        return -1\n    # Calculate the minimum number of coins each friend needs to give\n    min_coins = math.ceil((L + (M - 1)) / M)\n    # Ensure the calculated minimum does not exceed the total available unique coins\n    if min_coins > N - K + 1:\n        return -1\n    return min_coins\n\n# Reading input\nN, M, K, L = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_coins_for_friends(N, M, K, L))"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    # Find the bounds of the black cells\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # If no black cells are found\n    if min_row == n:\n        return 1\n    \n    # Calculate the side length of the square\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    \n    # Check if the square can fit within the grid\n    if side_length > n or side_length > m:\n        return -1\n    \n    # Count the number of white cells within the square\n    min_paint = float('inf')\n    for i in range(n - side_length + 1):\n        for j in range(m - side_length + 1):\n            paint_count = 0\n            for x in range(i, i + side_length):\n                for y in range(j, j + side_length):\n                    if grid[x][y] == 'W':\n                        paint_count += 1\n            min_paint = min(min_paint, paint_count)\n    \n    return min_paint\n\n# Example usage:\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\nprint(min_cells_to_paint(n, m, grid))"}
{"solution": "def can_transform(x, y):\n    changes = [j - i for i, j in zip(x, y)]\n    taken = 0\n    for change in changes:\n        if change > 0:\n            taken += change\n        elif change < 0:\n            if taken < -change:\n                return False\n            taken -= -change\n    return True\n\ndef main():\n    n = int(input())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n\n    result = \"Yes\" if can_transform(x, y) else \"No\"\n    print(result)\n\nmain()"}
{"solution": "def min_pizza_diff(n, angles):\n    total_angle = sum(angles)\n    prefix_sum = [0]\n    min_diff = float('inf')\n    \n    for angle in angles:\n        prefix_sum.append(prefix_sum[-1] + angle)\n        \n    for i in range(n):\n        current_sum = prefix_sum[i + 1]\n        other_sum = total_angle - current_sum\n        diff = abs(current_sum - other_sum)\n        min_diff = min(min_diff, diff)\n        \n        # Consider the case where the division happens after the last piece\n        if i < n - 1:\n            next_sum = prefix_sum[i + 2]\n            other_sum = total_angle - next_sum\n            diff = abs(next_sum - other_sum)\n            min_diff = min(min_diff, diff)\n            \n    return min_diff\n\n# Reading input\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(min_pizza_diff(n, angles))"}
{"solution": "MOD = 10**9 + 7\n\ndef power(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef main():\n    n, m = map(int, input().split())\n    \n    # Calculate (m + n - 1) choose (n - 1)\n    numerator = 1\n    for i in range(n):\n        numerator = (numerator * (m + i)) % MOD\n    \n    denominator = 1\n    for i in range(1, n):\n        denominator = (denominator * i) % MOD\n    \n    # Apply modular inverse for the denominator\n    denominator_inv = power(denominator, MOD - 2)\n    \n    # Final result\n    result = (numerator * denominator_inv) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef find_pythagorean_triple(n):\n    if n == 1:\n        return [-1]\n    \n    if n % 2 == 1:\n        # For odd n, use the formula (n, (n**2 - 1)//2, (n**2 + 1)//2)\n        m = (n**2 - 1) // 2\n        k = (n**2 + 1) // 2\n    else:\n        # For even n, find the smallest factor greater than 2\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0 and n // i > i:\n                m = n * (i - 1) // 2\n                k = n * (i + 1) // 2\n                break\n        else:\n            # If no factor found, n cannot form a Pythagorean triple\n            return [-1]\n    \n    return [m, k]\n\nn = int(input())\nresult = find_pythagorean_triple(n)\nprint(*result)"}
{"solution": "def are_remainders_distinct(n, k):\n    seen_remainders = set()\n    for i in range(1, min(k + 1, n + 1)):\n        remainder = n % i\n        if remainder in seen_remainders:\n            return \"No\"\n        seen_remainders.add(remainder)\n        if i > 1 and n // i == n // (i + 1):\n            return \"No\"\n    return \"Yes\"\n\n# Reading input\nn, k = map(int, input().split())\n\n# Processing and printing output\nprint(are_remainders_distinct(n, k))"}
{"solution": "import sys\n\na = sys.stdin.readline().strip()\nb = sys.stdin.readline().strip()\n\n# Remove leading zeros\na = a.lstrip('0')\nb = b.lstrip('0')\n\n# Compare lengths\nif len(a) != len(b):\n    result = '>' if len(a) > len(b) else '<'\nelse:\n    # Lexicographical comparison\n    result = '>' if a > b else ('<' if a < b else '=')\n\nprint(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, p, colors):\n    def dfs(node, parent, adjacency, memo):\n        if memo[node][colors[node] + 2] is not None:\n            return memo[node][colors[node] + 2]\n\n        total = 1 if colors[node] != -1 else 2\n        for child in adjacency[node]:\n            if child == parent:\n                continue\n            total *= dfs(child, node, adjacency, memo)\n            total %= MOD\n\n        memo[node][colors[node] + 2] = total\n        return total\n\n    def calculate_paths(adjacency, colors):\n        even_paths, odd_paths = 1, 1\n        for i in range(n):\n            if colors[i] == -1:\n                colors[i] = 0\n                even_paths *= dfs(i, -1, adjacency, [[None] * 4 for _ in range(n)])\n                even_paths %= MOD\n                colors[i] = 1\n                odd_paths *= dfs(i, -1, adjacency, [[None] * 4 for _ in range(n)])\n                odd_paths %= MOD\n                colors[i] = -1\n            else:\n                even_paths *= dfs(i, -1, adjacency, [[None] * 4 for _ in range(n)])\n                odd_paths *= dfs(i, -1, adjacency, [[None] * 4 for _ in range(n)])\n                even_paths %= MOD\n                odd_paths %= MOD\n\n        return (even_paths, odd_paths)\n\n    adjacency = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if colors[i] != colors[j]:\n                adjacency[i].append(j)\n                adjacency[j].append(i)\n\n    even_paths, odd_paths = calculate_paths(adjacency, colors[:])\n\n    return (even_paths if p == 0 else odd_paths) % MOD\n\n# Reading input\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Calculating and printing the result\nresult = count_ways(n, p, colors)\nprint(result)"}
{"solution": "import sys\n\ndef min_cost(n, a, b, c):\n    target = 4 - (n % 4)\n    if target == 4:\n        return 0\n    \n    options = [a, b // 2, c // 3]\n    \n    # Directly buying the needed copybooks\n    direct_buy = target * a\n    \n    # Buying packs of 2 or 3\n    for i in range(target + 1):\n        current_cost = i * options[1] + (target - i) * options[2]\n        direct_buy = min(direct_buy, current_cost)\n    \n    return direct_buy\n\n# Reading input\ninput_data = sys.stdin.readline().strip().split()\nn, a, b, c = map(int, input_data)\n\n# Calculating and printing the result\nprint(min_cost(n, a, b, c))"}
{"solution": "from collections import deque\n\ndef has_cycle(n, edges):\n    graph = [[] for _ in range(n)]\n    indegrees = [0] * n\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        indegrees[v - 1] += 1\n    \n    queue = deque([i for i, degree in enumerate(indegrees) if degree == 0])\n    visited = 0\n    \n    while queue:\n        node = queue.popleft()\n        visited += 1\n        for neighbor in graph[node]:\n            indegrees[neighbor] -= 1\n            if indegrees[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return visited != n\n\ndef can_make_acyclic(n, m, edges):\n    # Check if the graph is already acyclic\n    if not has_cycle(n, edges):\n        return \"YES\"\n    \n    # Try removing each edge to see if it makes the graph acyclic\n    for u, v in edges:\n        temp_edges = [(x, y) for x, y in edges if (x, y) != (u, v)]\n        if not has_cycle(n, temp_edges):\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output result\nprint(can_make_acyclic(n, m, edges))"}
{"solution": "from typing import List\n\ndef min_coins_for_coverage(n: int, m: int, antennas: List[List[int]]) -> int:\n    \"\"\"\n    Calculates the minimum number of coins needed to ensure all positions from 1 to m are covered by at least one antenna.\n    \n    :param n: Number of antennas.\n    :param m: Last position to be covered.\n    :param antennas: List of [position, initial_scope] for each antenna.\n    :return: Minimum number of coins required.\n    \"\"\"\n    antennas.sort()\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    last_pos = [-1] * (n + 1)\n    for i, (pos, scope) in enumerate(antennas):\n        start, end = pos - scope, pos + scope\n        for j in range(n, -1, -1):\n            if last_pos[j] < start:\n                new_cost = dp[j] + max(0, pos + scope - m)\n                if new_cost < dp[j + 1]:\n                    dp[j + 1] = new_cost\n                    last_pos[j + 1] = end\n                break\n    return dp[n]\n\n# Reading input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculating and printing the output\nprint(min_coins_for_coverage(n, m, antennas))"}
{"solution": "def max_good_subset_weight(W, counts):\n    total_weight = 0\n    for i in range(7, -1, -1):\n        if W >= counts[i] * (i + 1):\n            total_weight += counts[i] * (i + 1)\n            W -= counts[i] * (i + 1)\n        else:\n            total_weight += W\n            break\n    return total_weight\n\n# Reading input\nW = int(input())\ncounts = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(max_good_subset_weight(W, counts))"}
{"solution": "import heapq\n\ndef min_cost_lemonade(n, L, costs):\n    volumes = [2**i - 1 for i in range(1, n + 1)]\n    cost_per_liter = [(cost // volume, volume, cost) for cost, volume in zip(costs, volumes)]\n    heapq.heapify(cost_per_liter)\n    \n    total_cost = 0\n    while L > 0:\n        cost_per_l, volume, _ = heapq.heappop(cost_per_liter)\n        if L >= volume:\n            L -= volume\n            total_cost += volume * cost_per_l\n        else:\n            total_cost += L * cost_per_l\n            L = 0\n    \n    return total_cost\n\n# Reading input\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(min_cost_lemonade(n, L, costs))"}
{"solution": "def max_mex(n, a):\n    a.sort()\n    mex = 1\n    for num in a:\n        if num >= mex:\n            mex += 1\n    return mex\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = max_mex(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(int(digit) for digit in digits)\n\n    # Try every possible segment sum from 1 to total_sum\n    for segment_sum in range(1, total_sum + 1):\n        if total_sum % segment_sum == 0:\n            current_sum = 0\n            valid_partition = True\n            for digit in digits:\n                current_sum += int(digit)\n                if current_sum > segment_sum:\n                    valid_partition = False\n                    break\n                elif current_sum == segment_sum:\n                    current_sum = 0\n            if valid_partition and current_sum == 0:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Example usage:\nn = int(input())\ndigits = input().strip()\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\"\n\nusername = input().strip()\nprint(determine_gender(username))"}
{"solution": "def max_tab_difference(n, k, tabs):\n    def close_tabs(start, k):\n        closed = [False] * n\n        i = start\n        while 1 <= i < n:\n            closed[i] = True\n            i += k\n        return closed\n\n    def remaining_diff(closed):\n        e, s = 0, 0\n        for i in range(n):\n            if not closed[i]:\n                if tabs[i] == 1:\n                    e += 1\n                else:\n                    s += 1\n        return abs(e - s)\n\n    max_diff = 0\n    for start in range(1, n, k):\n        closed = close_tabs(start, k)\n        diff = remaining_diff(closed)\n        max_diff = max(max_diff, diff)\n\n    return max_diff\n\n# Reading input\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(max_tab_difference(n, k, tabs))"}
{"solution": "import math\n\ndef min_cost(n, c0, c1):\n    if c0 > c1:\n        c0, c1 = c1, c0\n\n    if c0 == 0:\n        return (n - 1) * c1\n\n    k = math.sqrt(1 + 8 * c0 * c1 * (n - 1)) - 1\n    k /= 2 * c0\n\n    if k.is_integer():\n        k -= 1\n\n    k = int(k)\n\n    total_cost = (k * (k + 1) * (2 * c0 + k * c1) // 2)\n    letters_covered = (k * (k + 1)) // 2\n\n    remaining_letters = n - letters_covered - 1\n\n    if remaining_letters > 0:\n        next_cost = (total_cost + (k + 1) * (c0 + (k + 1) * c1))\n        total_cost += (next_cost * remaining_letters) // (c0 * (k + 1))\n\n    return total_cost\n\n# Reading input\nn, c0, c1 = map(int, input().split())\n\n# Calculating and printing output\nprint(min_cost(n, c0, c1))"}
{"solution": "def will_meet(n, a, x, b, y):\n    while a != x and b != y:\n        if a == b:\n            return \"YES\"\n        a = a + 1 if a < n else 1\n        b = b - 1 if b > 1 else n\n    return \"YES\" if a == b else \"NO\"\n\n# Example usage:\nn, a, x, b, y = 5, 1, 4, 3, 2\n# print(will_meet(n, a, x, b, y))  # Uncomment to test"}
{"solution": "from math import log\n\ndef max_golden_age(x, y, l, r):\n    def is_unlucky(year):\n        max_power_x = int(log(year, x))\n        max_power_y = int(log(year, y))\n        for i in range(max_power_x + 1):\n            for j in range(max_power_y + 1):\n                if x**i + y**j == year:\n                    return True\n        return False\n\n    unlucky_years = {year for year in range(l, r + 1) if is_unlucky(year)}\n    max_length = 0\n    current_start = l\n    for year in range(l, r + 1):\n        if year in unlucky_years:\n            if year > current_start:\n                max_length = max(max_length, year - current_start)\n            current_start = year + 1\n    if r > current_start:\n        max_length = max(max_length, r - current_start + 1)\n\n    return max_length if max_length > 0 else 0\n\n# Example usage\nx, y, l, r = map(int, input().split())\nprint(max_golden_age(x, y, l, r))"}
{"solution": "import math\n\ndef min_tax(n):\n    # If n is a prime number greater than 2, the minimum tax is n // 2\n    if n > 2 and all(n % i for i in range(2, int(math.sqrt(n)) + 1)):\n        return n // 2\n    # Otherwise, find the largest divisor less than n\n    for i in range(n // 2, 1, -1):\n        if n % i == 0:\n            return i\n\n# Read input\nn = int(input())\n\n# Calculate and print the minimum tax\nprint(min_tax(n))"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    n = len(word)\n    result = []\n    i = 0\n    \n    while i < n:\n        result.append(word[i])\n        if word[i] not in vowels:\n            start = i\n            while i < n and word[i] not in vowels:\n                i += 1\n            if i - start >= 3:\n                block = word[start:i]\n                if len(set(block)) > 1:\n                    result.append(' ')\n        i += 1\n    \n    return ''.join(result)\n\n# Reading input\nword = input().strip()\n\n# Processing and printing output\nprint(fix_typos(word))"}
{"solution": "import bisect\n\ndef prepare_potions(n, m, k, x, s, a, b, c, d):\n    def enough_time(time_limit):\n        # Use a spell of the second type\n        idx = bisect.bisect_right(c, n)\n        if idx > 0:\n            manapoints_used = d[idx - 1]\n            remaining_potions = n - c[idx - 1]\n        else:\n            manapoints_used = 0\n            remaining_potions = n\n\n        remaining_manapoints = s - manapoints_used\n\n        # Use a spell of the first type\n        idx = bisect.bisect_right(b, remaining_manapoints)\n        if idx > 0 and remaining_potions > 0:\n            remaining_manapoints -= b[idx - 1]\n            time_per_potion = a[idx - 1]\n        else:\n            time_per_potion = x\n\n        if remaining_manapoints >= 0:\n            return time_limit >= remaining_potions * time_per_potion\n        return False\n\n    low, high = 0, n * x\n    while low < high:\n        mid = (low + high) // 2\n        if enough_time(mid):\n            high = mid\n        else:\n            low = mid + 1\n\n    return low\n\n# Reading input\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\n# Ensuring non-decreasing order\nb = [0] + sorted(b)\nd = [0] + sorted(d)\nc = [0] + sorted(c)\n\n# Solving the problem\nresult = prepare_potions(n, m, k, x, s, a, b, c, d)\n\n# Printing output\nprint(result)"}
{"solution": "from itertools import accumulate\n\ndef max_points(n, k, M, times):\n    total_time = sum(times)\n    tasks_completed = M // total_time\n    remaining_time = M % total_time\n    \n    points_from_complete_tasks = tasks_completed * (k + 1)\n    \n    prefix_sums = [0] + list(accumulate(times))\n    additional_points = 0\n    \n    for i in range(k):\n        if prefix_sums[i + 1] <= remaining_time:\n            additional_points += 1\n            remaining_time -= prefix_sums[i + 1]\n    \n    return points_from_complete_tasks + additional_points\n\n# Reading input\nn, k, M = map(int, input().split())\ntimes = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(max_points(n, k, M, times))"}
{"solution": "MOD = 998244353\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef preprocess(n):\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    \n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n        invfact[i] = modinv(fact[i])\n    \n    return fact, invfact\n\ndef comb(n, k, fact, invfact):\n    return fact[n] * invfact[k] * invfact[n - k] % MOD\n\ndef solve(n):\n    fact, invfact = preprocess(n)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = 0\n        for j in range((i + 1) // 2):\n            if i - 2 * j - 1 >= 0:\n                dp[i] += comb(i - 1, j, fact, invfact) * comb(i - 1 - j, i - 2 * j - 1, fact, invfact) * dp[j] * dp[i - 2 * j - 1]\n                dp[i] %= MOD\n            if i - 2 * j - 2 >= 0:\n                dp[i] += comb(i - 1, j, fact, invfact) * comb(i - 1 - j, i - 2 * j - 2, fact, invfact) * dp[j] * dp[i - 2 * j - 2]\n                dp[i] %= MOD\n    \n    return dp[n]\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def find_lara_position(n, m, k):\n    total_cells = n * m\n    if k == 0:\n        return (1, 1)\n    \n    segment_length = lambda r: (r - 1) * 2 + m\n    segment = 0\n    while segment_length(segment) <= k:\n        k -= segment_length(segment)\n        segment += 1\n    \n    if k <= m:\n        # Moving down the first column\n        row = n - segment\n        col = 1\n    elif k <= m + (segment - 1):\n        # Moving right on the bottom row\n        row = n - segment + 1\n        col = k - m + 1\n    elif k <= 2 * m + (segment - 1) * 2 - 1:\n        # Moving up on the second last column\n        row = n - segment + 2 - (k - (m + (segment - 1)))\n        col = 2\n    else:\n        # Moving left on the top row\n        row = 1\n        col = 3 - (k - (2 * m + (segment - 1) * 2 - 1) - 1)\n    \n    return (row, col)\n\n# Reading input\nn, m, k = map(int, input().split())\n\n# Calculating and printing the position\nrow, col = find_lara_position(n, m, k)\nprint(row, col)"}
{"solution": "from math import sqrt\n\ndef find_min_max_pair(X):\n    for i in range(int(sqrt(X)), 0, -1):\n        if X % i == 0:\n            return [i, X // i]\n\nX = int(input())\na, b = find_min_max_pair(X)\nprint(a, b)"}
{"solution": "def max_fruits_for_compote(a, b, c):\n    max_sets_lemons = a // 1\n    max_sets_apples = b // 2\n    max_sets_pears = c // 4\n    \n    max_complete_sets = min(max_sets_lemons, max_sets_apples, max_sets_pears)\n    \n    total_fruits = max_complete_sets * (1 + 2 + 4)\n    \n    return total_fruits\n\na = int(input())\nb = int(input())\nc = int(input())\n\nprint(max_fruits_for_compote(a, b, c))"}
{"solution": "def can_divide_teams(n, ratings):\n    ratings.sort()\n    for i in range(n):\n        if ratings[i] >= ratings[i + n]:\n            return \"NO\"\n    return \"YES\"\n\n# Example usage:\nn = 2\nratings = [1, 3, 2, 4]\nprint(can_divide_teams(n, ratings))  # Output: YES\n\nn = 1\nratings = [3, 3]\nprint(can_divide_teams(n, ratings))  # Output: NO"}
{"solution": "from math import gcd\n\ndef find_next_coprime(x, last_coprime):\n    \"\"\"\n    Finds the next coprime number to x that is greater than the last_coprime.\n    \"\"\"\n    num = max(last_coprime + 1, x + 1)\n    while gcd(num, x) != 1:\n        num += 1\n    return num\n\ndef make_coprime_array(arr):\n    \"\"\"\n    Transforms the given array into a co-prime array with minimal insertions.\n    \"\"\"\n    if len(arr) == 1:\n        return 0, arr\n    \n    new_arr = [arr[0]]\n    insertions = 0\n    for i in range(1, len(arr)):\n        if gcd(new_arr[-1], arr[i]) == 1:\n            new_arr.append(arr[i])\n        else:\n            next_coprime = find_next_coprime(new_arr[-1], arr[i])\n            new_arr.extend([next_coprime, arr[i]])\n            insertions += 1\n    return insertions, new_arr\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Solving\ninsertions, new_arr = make_coprime_array(arr)\n\n# Printing output\nprint(insertions)\nprint(*new_arr)"}
{"solution": "import math\nfrom functools import reduce\nfrom math import gcd\n\ndef compute_gcd_of_list(lst):\n    return reduce(gcd, lst)\n\ndef max_divisor_after_operations(N, K, A):\n    if N == 1:\n        return A[0]\n    \n    # Compute the GCD of the differences between all pairs\n    diffs = [abs(A[i] - A[j]) for i in range(N) for j in range(i + 1, N)]\n    initial_gcd = compute_gcd_of_list(diffs)\n    \n    # Check all divisors of the initial GCD\n    max_divisor = 1\n    for d in range(1, initial_gcd + 1):\n        if initial_gcd % d == 0:\n            # Check if we can make all elements divisible by d\n            adjustments = sorted([a % d for a in A])\n            total_adjustment = sum(adjustments)\n            left_adjustment = sum(adjustments[:len(adjustments) - total_adjustment // d])\n            if left_adjustment <= K:\n                max_divisor = max(max_divisor, d)\n    \n    return max_divisor\n\n# Read input\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Compute and print the result\nprint(max_divisor_after_operations(N, K, A))"}
{"solution": "def find_transformation(x):\n    operations = []\n    target_bit_length = x.bit_length()\n    \n    while x != (1 << target_bit_length) - 1 and len(operations) < 40:\n        # Find the highest bit that differs from the target\n        for i in range(target_bit_length):\n            if not x & (1 << i):\n                operations.append(i)\n                x ^= (1 << (i + 1)) - 1\n                break\n        \n        # Increment operation\n        if x != (1 << target_bit_length) - 1:\n            x += 1\n    \n    return len(operations), operations\n\nx = int(input())\nt, operations = find_transformation(x)\n\nprint(t)\nfor op in operations:\n    print(op, end=' ')"}
{"solution": "# Import necessary package\nfrom math import inf\n\n# Function to determine the minimum number of hours to water the garden\ndef min_hours_to_water(n, k, buckets):\n    # Initialize minimum hours to infinity\n    min_hours = inf\n    \n    # Iterate through each bucket\n    for bucket_length in buckets:\n        # Check if the garden length is divisible by the bucket length\n        if k % bucket_length == 0:\n            # Calculate hours required and update minimum hours if less\n            hours_required = k // bucket_length\n            min_hours = min(min_hours, hours_required)\n    \n    # Return the minimum hours required\n    return min_hours\n\n# Read input values\nn, k = map(int, input().split())\nbuckets = list(map(int, input().split()))\n\n# Call the function and print the result\nprint(min_hours_to_water(n, k, buckets))"}
{"solution": "def can_grasshopper_reach_insect(n, k, line):\n    start, target, empty_spots = None, None, []\n    for i in range(n):\n        if line[i] == 'G':\n            start = i\n        elif line[i] == 'T':\n            target = i\n        elif line[i] == '.':\n            empty_spots.append(i)\n\n    def is_reachable(pos, dest):\n        if pos == dest:\n            return True\n        for next_pos in range(pos + k, n, k):\n            if next_pos == dest:\n                return True\n            if next_pos in empty_spots and is_reachable(next_pos, dest):\n                return True\n        for prev_pos in range(pos - k, -1, -k):\n            if prev_pos == dest:\n                return True\n            if prev_pos in empty_spots and is_reachable(prev_pos, dest):\n                return True\n        return False\n\n    return \"YES\" if is_reachable(start, target) else \"NO\"\n\n# Reading input\nn, k = map(int, input().split())\nline = input()\n\n# Solving and printing output\nprint(can_grasshopper_reach_insect(n, k, line))"}
{"solution": "from math import fabs\n\ndef find_target_x(y1, y2, y_wall, x_ball, y_ball, r):\n    def goal_score(xw):\n        xw += r\n        x_intercept = (xw * y_ball) / (y_wall - y_ball)\n        y_goal = y_ball + (y_wall - y_ball) * (y_ball - y2) / (x_ball - xw - r)\n        return x_intercept, y_goal\n\n    def check_goal(x_intercept, y_goal):\n        if y1 - r < y_goal < y2 + r and fabs(x_intercept) < 1e-8:\n            return True\n        return False\n\n    # Binary search for the correct xw\n    left, right = -1, x_ball - r\n    while right - left > 1e-8:\n        mid = (left + right) / 2\n        x_intercept, y_goal = goal_score(mid)\n        if check_goal(x_intercept, y_goal):\n            return mid\n        elif y_goal < y1 - r or y_goal > y2 + r:\n            left = mid\n        else:\n            right = mid\n\n    return -1\n\n# Reading input\ny1, y2, y_wall, x_ball, y_ball, r = map(int, input().split())\n\n# Calculating and printing the output\nresult = find_target_x(y1, y2, y_wall, x_ball, y_ball, r)\nprint(result)"}
{"solution": "def min_missed_meals(breakfasts, dinners, suppers):\n    # Calculate the minimum number of missed meals\n    total_meals = breakfasts + dinners + suppers\n    # The minimum missed meals is when the meals are evenly distributed across days\n    # If one meal is less by 1 than others, that's the only missed meal\n    if breakfasts == dinners == suppers:\n        missed_meals = 0\n    elif breakfasts == dinners or breakfasts == suppers or dinners == suppers:\n        missed_meals = 1\n    else:\n        # If none of the above, calculate the difference\n        missed_meals = 3 - total_meals + min(breakfasts, dinners, suppers)\n    \n    return max(0, missed_meals)\n\n# Read input\nb, d, s = map(int, input().split())\n\n# Calculate and print the result\nprint(min_missed_meals(b, d, s))"}
{"solution": "from math import gcd\n\ndef possible_matrix_dimensions(path):\n    def valid_move(prev, curr, x, y):\n        prev_i, prev_j = divmod(prev - 1, y)\n        curr_i, curr_j = divmod(curr - 1, y)\n        return abs(prev_i - curr_i) + abs(prev_j - curr_j) == 1\n\n    def backtrack(index, x, y):\n        if index == len(path):\n            return True\n        if not valid_move(path[index - 1], path[index], x, y):\n            return False\n        return backtrack(index + 1, x, y)\n\n    n = len(path)\n    for i in range(1, min(21, n)):\n        if path[i] < path[i - 1]:\n            break\n    else:\n        print(\"YES\")\n        print(n, 1)\n        return\n\n    diffs = [path[i] - path[i - 1] for i in range(1, n)]\n    col_diffs = [diff for diff in diffs if diff % n == 0]\n    row_diffs = [diff for diff in diffs if diff % n != 0]\n\n    if not col_diffs or not row_diffs:\n        print(\"NO\")\n        return\n\n    col_gcd = abs(col_diffs[0])\n    row_gcd = abs(row_diffs[0])\n\n    for diff in col_diffs:\n        col_gcd = gcd(col_gcd, abs(diff))\n\n    for diff in row_diffs:\n        row_gcd = gcd(row_gcd, abs(diff))\n\n    if backtrack(1, row_gcd, col_gcd):\n        print(\"YES\")\n        print(row_gcd, col_gcd)\n    else:\n        print(\"NO\")\n\n# Reading input\nn = int(input())\npath = list(map(int, input().split()))\n\n# Processing and printing output\npossible_matrix_dimensions(path)"}
{"solution": "def find_min_subsequence(a, b):\n    n, m = len(a), len(b)\n    next_pos = [-1] * m\n    prev_pos = [n] * m\n    dp = [0] * (m + 1)\n    \n    for i in range(n):\n        if dp[0] == i:\n            dp[0] = i + 1\n        for j in range(m):\n            if a[i] == b[j]:\n                if dp[j] <= i:\n                    dp[j + 1] = i + 1\n                next_pos[j] = i\n    \n    pos = m\n    while pos > 0:\n        if dp[pos] == dp[pos - 1]:\n            pos -= 1\n        else:\n            prev_pos[pos - 1] = min(prev_pos[pos - 1], next_pos[pos - 1])\n            pos -= 1\n    \n    result = []\n    i = 0\n    for j in range(m):\n        if i <= prev_pos[j]:\n            result.append(b[j])\n            i = next_pos[j] + 1\n    \n    return ''.join(result) if result else '-'\n\n# Example usage\na = input().strip()\nb = input().strip()\nprint(find_min_subsequence(a, b))"}
{"solution": "def minimal_stones(n, s):\n    current_stones = 0\n    min_stones = 0\n    \n    for char in s:\n        if char == '+':\n            current_stones += 1\n        elif char == '-':\n            current_stones -= 1\n            current_stones = max(current_stones, 0)\n        min_stones = min(min_stones, current_stones)\n    \n    return max(0, -min_stones)\n\n# Example usage:\nn = int(input())\ns = input().strip()\nprint(minimal_stones(n, s))"}
{"solution": "import sys\n\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nmax_liters = 0\n\n# Buying only plastic bottles\nmax_liters = max(max_liters, n // a)\n\n# Buying glass bottles and returning them\nglass_bottles = n // b\nmoney_left = n % b\nmax_liters = max(max_liters, glass_bottles + (n - (glass_bottles * b)) // (b - c))\n\n# Optimizing the mix of plastic and glass bottles\nwhile n >= b:\n    n -= b\n    max_liters += 1\n    n += c\n    while n >= a:\n        n -= a\n        max_liters += 1\n\nprint(max_liters)"}
{"solution": "def read_cards():\n    n = int(input())\n    k1 = int(input())\n    soldier1 = [int(x) for x in input().split()]\n    k2 = int(input())\n    soldier2 = [int(x) for x in input().split()]\n    return n, soldier1, soldier2\n\ndef simulate_war(s1, s2):\n    fights = 0\n    seen = set()\n    while s1 and s2:\n        state = (tuple(s1), tuple(s2))\n        if state in seen:\n            return -1\n        seen.add(state)\n        \n        c1 = s1.pop(0)\n        c2 = s2.pop(0)\n        fights += 1\n        \n        if c1 > c2:\n            s1.extend([c2, c1])\n        else:\n            s2.extend([c1, c2])\n    \n    return (fights, 1 if s1 else 2)\n\nn, soldier1, soldier2 = read_cards()\nresult = simulate_war(soldier1, soldier2)\nprint(*result)"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    \n    has_upper = False\n    has_lower = False\n    has_digit = False\n    \n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n    \n    if has_upper and has_lower and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\"\n\n# Reading input\npassword = input().strip()\n# Printing the result\nprint(check_password_complexity(password))"}
{"solution": "from collections import Counter\n\ndef min_exchanges_to_balance_groups(n, group_a, group_b):\n    \"\"\"\n    Calculates the minimum number of exchanges needed to make the distribution of academic performances equal in both groups.\n    \n    :param n: Number of students in each group.\n    :param group_a: List of academic performances for students in group A.\n    :param group_b: List of academic performances for students in group B.\n    :return: Minimum number of exchanges or -1 if balancing is impossible.\n    \"\"\"\n    # Count the performances in each group\n    count_a = Counter(group_a)\n    count_b = Counter(group_b)\n    \n    # Check if balancing is possible\n    combined = count_a + count_b\n    for perf in range(1, 6):\n        if combined[perf] % 2 != 0:\n            return -1\n    \n    # Calculate exchanges needed\n    exchanges = 0\n    for perf in range(1, 6):\n        diff = abs(count_a[perf] - count_b[perf])\n        exchanges += diff // 2\n    \n    return exchanges\n\n# Read input\nn = int(input())\ngroup_a = list(map(int, input().split()))\ngroup_b = list(map(int, input().split()))\n\n# Print result\nprint(min_exchanges_to_balance_groups(n, group_a, group_b))"}
{"solution": "def is_reachable(n, m, horizontal_streets, vertical_streets):\n    # Check if there's a way to travel in both directions for both horizontal and vertical streets\n    has_east_west = '>' in horizontal_streets and '<' in horizontal_streets\n    has_north_south = 'v' in vertical_streets and '^' in vertical_streets\n    \n    return \"YES\" if has_east_west and has_north_south else \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nhorizontal_streets = input()\nvertical_streets = input()\n\n# Print result\nprint(is_reachable(n, m, horizontal_streets, vertical_streets))"}
{"solution": "def solve_implication(n, sequence):\n    # Check if it's possible to make the expression false\n    possible = False\n    ones_count = 0\n    \n    for value in sequence:\n        if value == 1:\n            ones_count += 1\n        else:\n            if ones_count > 0:\n                possible = True\n                break\n    \n    # If there are no '1's before the first '0', it's not possible\n    if ones_count == 0 and n == 1:\n        possible = True\n    \n    if possible:\n        expression = \"\"\n        open_brackets = 0\n        \n        for i, value in enumerate(sequence):\n            if value == 1:\n                if i < n - 1 and sequence[i + 1] == 0:\n                    expression += f\"({value}\"\n                    open_brackets += 1\n                else:\n                    expression += str(value)\n            else:\n                if open_brackets > 0:\n                    expression += f\"->{value})\"\n                    open_brackets -= 1\n                else:\n                    expression += f\"({value}\"\n                    open_brackets += 1\n        \n        # Close remaining open brackets\n        while open_brackets > 0:\n            expression += \")\"\n            open_brackets -= 1\n        \n        return \"YES\\n\" + expression\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Solve and print the result\nprint(solve_implication(n, sequence))"}
{"solution": "def process(a, b):\n    while True:\n        if a == 0 or b == 0:\n            break\n        if a >= 2 * b:\n            a %= 2 * b\n        elif b >= 2 * a:\n            b %= 2 * a\n        else:\n            break\n    return a, b\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    result_a, result_b = process(n, m)\n    print(result_a, result_b)"}
{"solution": "import math\n\ndef count_k_divisible(k, a, b):\n    # Calculate the number of k-divisible numbers in the range [a, b]\n    start = math.ceil(a / k) * k if a >= 0 else ((a // k) - 1) * k\n    end = b // k * k\n    \n    # Adjust start if it's less than a\n    if start < a:\n        start += k\n    \n    # Adjust end if it's greater than b\n    if end > b:\n        end -= k\n    \n    # Calculate the count of k-divisible numbers\n    count = (end - start) // k + 1\n    \n    return max(count, 0)\n\n# Read input\nk, a, b = map(int, input().split())\n\n# Output the result\nprint(count_k_divisible(k, a, b))"}
{"solution": "def find_kth_digit(k):\n    if k < 10:\n        return k\n    start, end, width = 1, 9, 1\n    while k > end:\n        k -= end - start + 1\n        start = 10 ** width\n        end = 9 * start + width * (start - 1)\n        width += 1\n    quotient, remainder = divmod(k - 1, width)\n    return int(str(start + quotient)[remainder])\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "def can_vasya_win(n, s):\n    # Calculate the number of moves each player will make\n    moves_each = (n - 11) // 2\n    \n    # Count the number of '8's in the first n - 10 characters\n    count_8s = s[:n - 10].count('8')\n    \n    # Vasya wins if there are more '8's than the number of moves Petya can make\n    if count_8s > moves_each:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Determine if Vasya has a winning strategy\nresult = can_vasya_win(n, s)\nprint(result)"}
{"solution": "from math import factorial\n\nMOD = 10**9 + 7\n\ndef mod_inverse(x):\n    return pow(x, MOD - 2, MOD)\n\ndef calculate_permutations(n, x, pos):\n    if pos == 0:\n        left_side = n - x\n    else:\n        left_side = n - x - 1\n\n    if pos == n - 1:\n        right_side = x - 1\n    else:\n        right_side = x\n\n    left_permutations = factorial(left_side) * mod_inverse(factorial(max(0, left_side - (n - x - 1)))) % MOD\n    right_permutations = factorial(right_side) * mod_inverse(factorial(max(0, right_side - (x - 1)))) % MOD\n\n    total_permutations = (factorial(n - 1) * left_permutations * right_permutations) % MOD\n\n    return total_permutations\n\nn, x, pos = map(int, input().split())\nprint(calculate_permutations(n, x, pos))"}
{"solution": "def decode_message(s, k):\n    i, n, result = 0, len(s), []\n    while i < n and len(result) < k:\n        if s[i].isalpha():\n            result.append(s[i])\n            if i + 1 < n and s[i + 1] == '?':\n                result.pop()\n                i += 1\n            elif i + 1 < n and s[i + 1] == '*':\n                i += 1\n                while i + 1 < n and s[i + 1] == '*':\n                    i += 1\n        i += 1\n    \n    # Adjust for snowflakes by repeating characters\n    repeat_chars = 0\n    for j in range(len(result)):\n        if i < n and s[i] == '*':\n            repeat_chars += 1\n            i += 1\n        else:\n            if repeat_chars > 0:\n                result[j:j] = [result[j]] * repeat_chars\n                repeat_chars = 0\n            if len(result) >= k:\n                break\n\n    # Check if the length matches and trim if necessary\n    if len(result) == k:\n        return ''.join(result)\n    elif len(result) > k:\n        return 'Impossible'\n    else:\n        # Try adding characters removed by candy canes\n        added = 0\n        for j in range(len(s)):\n            if added >= k - len(result):\n                break\n            if s[j].isalpha() and (j + 1 < len(s) and s[j + 1] == '?'):\n                result.insert(j, s[j])\n                added += 1\n        if len(result) == k:\n            return ''.join(result)\n        else:\n            return 'Impossible'\n\n# Read input\ns = input().strip()\nk = int(input().strip())\n\n# Print the decoded message\nprint(decode_message(s, k))"}
{"solution": "x = int(input())\n\n# Normalize the angle to be within [0, 360)\nangle = x % 360\n\n# Determine the minimum number of 90 degree clockwise turns\nif angle == 0:\n    turns = 0\nelif 0 < angle <= 90:\n    turns = 1\nelif 90 < angle <= 180:\n    turns = 2\nelif 180 < angle <= 270:\n    turns = 3\nelse:  # 270 < angle < 360\n    turns = 1\n\nprint(turns)"}
{"solution": "def can_transform(a, b, c, x, y, z):\n    deficit_a = max(0, x - a)\n    deficit_b = max(0, y - b)\n    deficit_c = max(0, z - c)\n    \n    surplus = (a + b + c) - (x + y + z)\n    \n    # Calculate the number of pairs needed to cover the deficit\n    pairs_needed = (deficit_a + 1) // 2 + (deficit_b + 1) // 2 + (deficit_c + 1) // 2\n    \n    return \"Yes\" if surplus >= pairs_needed else \"No\"\n\n# Reading input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Output\nprint(can_transform(a, b, c, x, y, z))"}
{"solution": "def solve(n, k, m):\n    def count_divisible_suffixes(k, m):\n        result = 0\n        suffix = 0\n        for length in range(1, 11):  # Considering up to 10 digits as a practical limit\n            for digit in range(10):\n                suffix = (suffix * 10 + digit) % k\n                if suffix == 0:\n                    result += pow(10, 10 - length, m)\n                    result %= m\n            if suffix == 0:\n                break\n        return result\n\n    total = 0\n    for digits in range(1, n + 1):\n        if digits == 1:\n            total += count_divisible_suffixes(k, m)\n        else:\n            total += (9 * pow(10, digits - 2, m) * count_divisible_suffixes(k, m)) % m\n        total %= m\n    return total\n\n# Reading input\nn, k, m = map(int, input().split())\n\n# Solving and printing the result\nprint(solve(n, k, m))"}
{"solution": "def max_team_size(l, r, a):\n    if l > r:\n        l, r = r, l  # Ensure l is always the smaller or equal group\n    \n    # Use ambidexters to balance the difference\n    d = r - l\n    if a >= d:\n        l += d\n        a -= d\n        # Now l == r, distribute remaining ambidexters equally\n        l += a // 2\n        r += a // 2\n    else:\n        l += a\n        # Not enough ambidexters to balance completely, r remains larger\n    \n    # The maximum team size is twice the smaller group\n    return 2 * min(l, r)\n\n# Reading input\nl, r, a = map(int, input().split())\n\n# Calculating and printing the result\nprint(max_team_size(l, r, a))"}
{"solution": "def min_moves(n, k):\n    k = min(k, n + 1 - k)  # Symmetry\n    result = 2 * (1 + 2 * (k - 1) + (n - k)) + (n - k - 1)\n    return result\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_moves(n, k))"}
{"solution": "import heapq\n\ndef min_tallest_tower(n, m):\n    h = []\n    heapq.heapify(h)\n    for _ in range(n):\n        heapq.heappush(h, 2)\n    for _ in range(m):\n        heapq.heappush(h, 3)\n    \n    while len(h) > 1:\n        tallest = heapq.heappop(h)\n        second_tallest = heapq.heappop(h)\n        new_height = max(tallest, second_tallest + 1)\n        heapq.heappush(h, new_height)\n        heapq.heappush(h, new_height)\n    \n    return h[0]\n\nn, m = map(int, input().split())\nprint(min_tallest_tower(n, m))"}
{"solution": "from collections import Counter\n\ndef can_play_fair(n, cards):\n    card_counts = Counter(cards)\n    unique_counts = list(card_counts.items())\n    \n    for i in range(len(unique_counts)):\n        for j in range(i + 1, len(unique_counts)):\n            if unique_counts[i][1] + unique_counts[j][1] == n:\n                return f\"YES\\n{unique_counts[i][0]} {unique_counts[j][0]}\"\n    return \"NO\"\n\nif __name__ == \"__main__\":\n    n = int(input())\n    cards = [int(input()) for _ in range(n)]\n    print(can_play_fair(n, cards))"}
{"solution": "def can_arrange_soldiers(n, groups):\n    total_seats = 8 * n\n    group_sizes = sorted(groups)\n    while group_sizes:\n        current_group = group_sizes.pop()\n        if current_group > total_seats:\n            return False\n        # Place the largest group first\n        if len(group_sizes) > 0 and current_group + group_sizes[-1] > total_seats // 2:\n            return False\n        total_seats -= current_group\n    return True\n\n# Reading input\nn, k = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(\"YES\" if can_arrange_soldiers(n, groups) else \"NO\")"}
{"solution": "from collections import Counter\n\ndef min_cost_to_adjust_sticks(n, lengths):\n    # Count the frequency of each length\n    length_counts = Counter(lengths)\n    # Sort unique lengths\n    sorted_lengths = sorted(length_counts.keys())\n    \n    # Initialize variables\n    min_cost = float('inf')\n    optimal_t = None\n    \n    # Iterate through possible t values\n    for t in range(1, 101):\n        cost = 0\n        for length in sorted_lengths:\n            # Calculate cost to adjust to t or t+1 or t-1\n            cost += sum([length_counts[length] * min(abs(length - t), abs(length - (t + 1)), abs(length - (t - 1)))])\n        # Update optimal t and cost\n        if cost < min_cost:\n            min_cost = cost\n            optimal_t = t\n            \n    return optimal_t, min_cost\n\n# Read input\nn = int(input())\nlengths = list(map(int, input().split()))\n\n# Calculate and print the result\noptimal_t, min_cost = min_cost_to_adjust_sticks(n, lengths)\nprint(optimal_t, min_cost)"}
{"solution": "def find_min_square_side(n, m, sky_map):\n    min_x, max_x, min_y, max_y = n, -1, m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if sky_map[i][j] == '*':\n                min_x = min(min_x, i)\n                max_x = max(max_x, i)\n                min_y = min(min_y, j)\n                max_y = max(max_y, j)\n                \n    width = max_x - min_x + 1\n    height = max_y - min_y + 1\n    \n    return max(width, height)\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    sky_map = [input() for _ in range(n)]\n    \n    result = find_min_square_side(n, m, sky_map)\n    \n    print(result)"}
{"solution": "from math import factorial\n\nMOD = 10**9 + 7\n\ndef mod_inverse(x):\n    return pow(x, MOD - 2, MOD)\n\ndef solve(n, k, a):\n    ones = sum(a)\n    zeros = n - ones\n    \n    if abs(ones - zeros) > 1:\n        return 0\n    \n    if k % 2 == 0:\n        if abs(ones - zeros) != 1:\n            return 0\n        numerator = 2 * factorial(ones) * factorial(zeros)\n    else:\n        numerator = factorial(ones) * factorial(zeros)\n    \n    denominator = pow(factorial(n), 1, MOD)\n    \n    result = numerator * mod_inverse(denominator) % MOD\n    \n    return result\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nresult = solve(n, k, a)\nprint(result)"}
{"solution": "import sys\n\nx, y = map(int, sys.stdin.readline().split())\n\nresult = 0\nwhile x > y:\n    if x == y + 1:\n        result += 2\n        break\n    elif (x - y) % 2 == 0:\n        result += (x - y)\n        break\n    else:\n        if x % 2 == 0:\n            result += 3\n            x -= 2\n        else:\n            result += 2\n            x -= 1\n\nprint(result)"}
{"solution": "from math import fabs\n\ndef min_norm_degenerate_matrix(a, b, c, d):\n    det = a * d - b * c\n    if det == 0:\n        return 0.0\n    else:\n        return min(fabs(a - b * c / d), fabs(d - b * c / a), fabs(c - a * d / b), fabs(b - a * d / c))\n\nif __name__ == \"__main__\":\n    a, b = map(int, input().split())\n    c, d = map(int, input().split())\n    result = min_norm_degenerate_matrix(a, b, c, d)\n    print(result)"}
{"solution": "n, a, b = map(int, input().split())\nt = list(map(int, input().split()))\n\ndenied = 0\none_seater_empty = a\ntwo_seater_empty = b\ntwo_seater_half_full = 0\n\nfor customer in t:\n    if customer == 1:  # Single customer\n        if one_seater_empty > 0:\n            one_seater_empty -= 1\n        elif two_seater_empty > 0:\n            two_seater_empty -= 1\n        elif two_seater_half_full > 0:\n            two_seater_half_full -= 1\n        else:\n            denied += 1\n    else:  # Two customers\n        if two_seater_empty > 0:\n            two_seater_empty -= 1\n        else:\n            denied += 2\n    # Update half full tables\n    two_seater_half_full = max(0, two_seater_half_full - (customer == 1 and one_seater_empty == 0 and two_seater_empty == 0))\n\nprint(denied)"}
{"solution": "def calculate_unsuccessful_students(A, B, C, N):\n    # Calculate the number of students who visited only one of the restaurants\n    only_bugdonalds = A - C\n    only_beaverking = B - C\n    \n    # Total number of students who passed the exam\n    total_passed = only_bugdonalds + only_beaverking + C\n    \n    # Check for contradictions\n    if total_passed > N or (only_bugdonalds < 0) or (only_beaverking < 0) or (C > A) or (C > B) or (N == 0):\n        return -1\n    else:\n        # Calculate and return the number of students who didn't pass the exam\n        return N - total_passed\n\n# Read input\nA, B, C, N = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_unsuccessful_students(A, B, C, N))"}
{"solution": "MOD = 10**9 + 7\n\ndef power(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef solve(x, k):\n    # Calculate 2^(k+1) % MOD\n    doubled = power(2, k + 1)\n    # Calculate (1/2)^k % MOD\n    half_power = power(2, MOD - 2)  # Fermat's little theorem for inverse\n    half_k = power(half_power, k)\n    \n    # Using the formula derived from the problem statement\n    numerator = (doubled - 1) * half_k + 1\n    denominator = half_k\n    \n    # Calculate the final result\n    result = (x * numerator * power(denominator, MOD - 2)) % MOD\n    return result\n\nx, k = map(int, input().split())\nprint(solve(x, k))"}
{"solution": "from math import gcd\n\nMOD = 998244353\n\ndef mod_inverse(x):\n    return pow(x, MOD - 2, MOD)\n\ndef preprocess(l, r):\n    diff = r - l + 1\n    inv_diff = mod_inverse(diff)\n    return (diff, inv_diff)\n\ndef calc_combinations(l1, r1, l2, r2):\n    d1, inv_d1 = preprocess(l1, r1)\n    d2, inv_d2 = preprocess(l2, r2)\n    \n    total_combinations = (d1 * d2) % MOD\n    \n    # Calculate invalid combinations (inversions)\n    invalid_combinations = 0\n    for i in range(l1, r1 + 1):\n        for j in range(l2, r2 + 1):\n            if i > j:\n                invalid_combinations += 1\n    invalid_combinations = (invalid_combinations * (inv_d1 * inv_d2 % MOD)) % MOD\n    \n    valid_combinations = (total_combinations - invalid_combinations) % MOD\n    return valid_combinations\n\ndef solve(n, problems):\n    result = 1\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            result = (result * calc_combinations(problems[i][0], problems[i][1], problems[j][0], problems[j][1])) % MOD\n    return result\n\nn = int(input())\nproblems = [list(map(int, input().split())) for _ in range(n)]\nprint(solve(n, problems))"}
{"solution": "def count_ways_to_form_rectangle(n):\n    ways = 0\n    # Since the sides of the rectangle cannot be equal (not a square),\n    # we iterate through possible shorter sides (x) and calculate the longer side (y).\n    # The condition n // 2 > x ensures that the longer side can fit twice within the stick.\n    for x in range(1, n // 2):\n        # y represents the longer side of the rectangle.\n        # The condition ensures that the remaining length can be evenly divided into two parts.\n        if (n - 2 * x) % 2 == 0 and (n - 2 * x) // 2 > x:\n            ways += 1\n    return ways\n\n# Read the input\nn = int(input())\n\n# Calculate and print the result\nprint(count_ways_to_form_rectangle(n))"}
{"solution": "def find_min_kvass(n, s, volumes):\n    def is_possible(min_kvass):\n        total_poured = 0\n        for v in volumes:\n            available = max(v - min_kvass, 0)\n            total_poured += available\n        return total_poured >= s\n\n    low, high = 0, max(volumes)\n    while low < high:\n        mid = (low + high + 1) // 2\n        if is_possible(mid):\n            low = mid\n        else:\n            high = mid - 1\n\n    return low if is_possible(low) else -1\n\n\n# Reading input\nn, s = map(int, input().split())\nvolumes = list(map(int, input().split()))\n\n# Solving and printing output\nprint(find_min_kvass(n, s, volumes))"}
{"solution": "import math\n\ndef caterpillar_and_apple(h1, h2, a, b):\n    if a <= b:\n        # The caterpillar slips down more than it climbs up, so it can't reach the apple.\n        return -1\n    \n    # Calculate the net climb per day (daytime climb minus nighttime slip).\n    net_climb_per_day = 8 * a - 12 * b\n    \n    # If the caterpillar reaches or passes the apple during the day, calculate the exact day.\n    if (h2 - h1) <= 8 * a:\n        return math.ceil((h2 - h1) / (8 * a)) - 1 if (h2 - h1) % (8 * a) != 0 else math.ceil((h2 - h1) / (8 * a))\n    \n    # Calculate the full days needed to reach close to the apple.\n    full_days = math.ceil((h2 - h1 - 8 * a) / net_climb_per_day)\n    \n    # Total days including the initial partial day.\n    total_days = full_days + 1\n    \n    return total_days\n\n# Reading input\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculating and printing the result\nprint(caterpillar_and_apple(h1, h2, a, b))"}
{"solution": "def max_joy_units(C, H_r, H_b, W_r, W_b):\n    # Calculate the maximum number of candies Om Nom can eat without getting sick\n    max_red = C // W_r\n    max_blue = C // W_b\n    \n    # Initialize the maximum joy units\n    max_joy = 0\n    \n    # Iterate through possible combinations of red and blue candies\n    for red in range(max_red + 1):\n        remaining_weight = C - red * W_r\n        blue = min(max_blue, remaining_weight // W_b)\n        joy = red * H_r + blue * H_b\n        max_joy = max(max_joy, joy)\n    \n    return max_joy\n\n# Read input\nC, H_r, H_b, W_r, W_b = map(int, input().split())\n\n# Calculate and print the maximum joy units\nprint(max_joy_units(C, H_r, H_b, W_r, W_b))"}
{"solution": "def min_steps(start, end):\n    x1, y1 = start\n    x2, y2 = end\n    dx = abs(x1 - x2)\n    dy = abs(y1 - y2)\n    return max(dx, dy)\n\n# Reading input\nstart = list(map(int, input().split()))\nend = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(min_steps(start, end))"}
{"solution": "n = int(input())\nemployees = input().strip()\n\n# Count initial Ds and Rs\ninitial_ds = 0\ninitial_rs = 0\nfor employee in employees:\n    if employee == 'D':\n        initial_ds += 1\n    else:\n        initial_rs += 1\n\n# Track the number of Ds and Rs that can potentially deny others\nactive_ds = initial_ds\nactive_rs = initial_rs\n\n# Process the sequence\nfor employee in employees:\n    if employee == 'D':\n        # A depublican can deny Rs\n        if active_rs > 0:\n            active_rs -= 1\n    else:\n        # A remocrat can deny Ds\n        if active_ds > 0:\n            active_ds -= 1\n\n# Determine the winner\nif active_ds > active_rs:\n    print('D')\nelse:\n    print('R')"}
{"solution": "from math import gcd\n\ndef count_tv_sets(a, b, x, y):\n    def calculate_pairs(limit, factor):\n        div, mod = divmod(limit, factor)\n        return div + (mod > 0)\n\n    common_divisor = gcd(x, y)\n    x //= common_divisor\n    y //= common_divisor\n\n    # Calculate the number of pairs (w, h) where w <= a and h <= b\n    # and w/h = x/y\n    count_a = calculate_pairs(a, x)\n    count_b = calculate_pairs(b, y)\n\n    # Intersection of two sets\n    intersect_x = calculate_pairs(b // y * x, x)\n    intersect_y = calculate_pairs(a // x * y, y)\n\n    result = count_a * count_b - intersect_x * intersect_y\n\n    return result\n\n# Reading input\na, b, x, y = map(int, input().split())\n\n# Calculating and printing the result\nprint(count_tv_sets(a, b, x, y))"}
{"solution": "from collections import defaultdict\n\ndef max_pow(x, p):\n    res = 0\n    while x >= p:\n        x //= p\n        res += x\n    return res\n\ndef solve(n, b):\n    factors = defaultdict(int)\n    x = b\n    while x % 2 == 0:\n        factors[2] += 1\n        x //= 2\n    f = 3\n    while x > 1:\n        if x % f == 0:\n            factors[f] += 1\n            x //= f\n        else:\n            f += 2\n    ans = float('inf')\n    for f in factors:\n        ans = min(ans, max_pow(n, f) // factors[f])\n    return ans\n\nn, b = map(int, input().split())\nprint(solve(n, b))"}
{"solution": "def calculate_frog_jumps(m, a, b):\n    def gcd(x, y):\n        while y != 0:\n            (x, y) = (y, x % y)\n        return x\n\n    def sum_of_arithmetic_series(n):\n        return n * (n + 1) // 2\n\n    lcm = a * b // gcd(a, b)\n    cycle_length = a + b\n    full_cycles = m // cycle_length\n    partial_cycle_length = min(m % cycle_length + 1, a)\n    \n    # Calculate the sum for full cycles\n    full_cycle_sum = (2 * a + (cycle_length - a - 1) * (a + b)) * full_cycles // 2\n    \n    # Calculate the sum for the partial cycle\n    partial_cycle_sum = sum_of_arithmetic_series(partial_cycle_length)\n    \n    # Total sum\n    total_sum = full_cycle_sum + partial_cycle_sum\n    \n    return total_sum\n\n# Read input\nm, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_frog_jumps(m, a, b))"}
{"solution": "def can_divide_into_odd_subsegments(n, sequence):\n    odd_count = 0\n    in_odd_segment = False\n\n    for num in sequence:\n        if num % 2 != 0:\n            if not in_odd_segment:\n                in_odd_segment = True\n                odd_count += 1\n        else:\n            in_odd_segment = False\n\n    # Check if the last segment is odd and the total count is odd\n    return odd_count % 2 == 1 and (odd_count > 0 or sequence[-1] % 2 != 0)\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Output result\nprint(\"Yes\" if can_divide_into_odd_subsegments(n, sequence) else \"No\")"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    # Check if the points form a vertical side of the square\n    if x1 == x2:\n        x3, y3 = x1, y2 + (y2 - y1)\n        x4, y4 = x1 + (x2 - x1), y2\n    # Check if the points form a horizontal side of the square\n    elif y1 == y2:\n        x3, y3 = x2 + (x2 - x1), y1\n        x4, y4 = x2, y1 + (y2 - y1)\n    else:\n        # Points do not form a side of the square\n        return -1\n\n    # Check if the coordinates are within the valid range\n    if not (-1000 <= x3 <= 1000) or not (-1000 <= y3 <= 1000) or not (-1000 <= x4 <= 1000) or not (-1000 <= y4 <= 1000):\n        return -1\n\n    return f\"{x3} {y3} {x4} {y4}\"\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\n\n# Find and print the coordinates of the remaining trees\nprint(find_remaining_trees(x1, y1, x2, y2))"}
{"solution": "MOD = 1000000007\n\ndef mod_inverse(a):\n    return pow(a, MOD - 2, MOD)\n\ndef matrix_mod_exp(matrix, exp):\n    result = [[1, 0], [0, 1]]  # Identity matrix\n    while exp > 0:\n        if exp % 2 == 1:\n            result = [[(result[i][0] * matrix[0][j] + result[i][1] * matrix[1][j]) % MOD for j in range(2)] for i in range(2)]\n        matrix = [[(matrix[i][0] * matrix[0][j] + matrix[i][1] * matrix[1][j]) % MOD for j in range(2)] for i in range(2)]\n        exp //= 2\n    return result\n\ndef find_fn(x, y, n):\n    if n == 1:\n        return x % MOD\n    if n == 2:\n        return y % MOD\n    \n    # Transformation matrix for the recurrence relation\n    transformation_matrix = [[0, 1], [1, -1]]\n    \n    # Apply matrix exponentiation to find the nth term\n    powered_matrix = matrix_mod_exp(transformation_matrix, n - 2)\n    \n    # Calculate f_n using the powered matrix\n    fn = (powered_matrix[0][0] * y + powered_matrix[0][1] * x) % MOD\n    \n    return fn\n\n# Reading input\nx, y = map(int, input().split())\nn = int(input())\n\n# Calculating and printing the output\nprint(find_fn(x, y, n))"}
{"solution": "def find_non_zero_sums(arr):\n    n = len(arr)\n    start = 0\n    splits = []\n    \n    for end in range(n):\n        if sum(arr[start:end+1]) == 0:\n            if start == end:\n                return \"NO\"\n            splits.append((start+1, end))\n            start = end + 1\n    \n    if start < n and sum(arr[start:n]) == 0:\n        return \"NO\"\n    \n    if start < n:\n        splits.append((start+1, n))\n    \n    if not splits:\n        return \"NO\"\n    \n    return \"YES\", splits\n\ndef main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    result = find_non_zero_sums(arr)\n    \n    if result == \"NO\":\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(len(result[1]))\n        for split in result[1]:\n            print(*split)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_quiz_score(n, m, k):\n    MOD = 1000000009\n    if k > m:\n        return m\n    if k == 0:\n        return 0\n    full_sequences, remaining = divmod(m, k)\n    base_score = full_sequences * k + remaining\n    doubled_score = (full_sequences - 1) * (1 << k) + (1 << remaining)\n    return (base_score + min(doubled_score, 1 << k)) % MOD\n\n# Reading input\nn, m, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_quiz_score(n, m, k))"}
{"solution": "import re\n\ndef find_divisible_by_8(num_str):\n    # Check for single-digit divisibility\n    if num_str == '0':\n        return num_str\n    # Check for two-digit and three-digit divisibility patterns\n    for i in range(len(num_str) - 1, 1, -1):\n        for j in range(i + 1):\n            if int(num_str[j:i+1]) % 8 == 0:\n                return num_str[:j] + num_str[i+1:]\n    # Check for any digits followed by 00\n    match = re.search(r'(\\d*?00)', num_str)\n    if match:\n        return match.group(1)\n    return None\n\ndef main():\n    num_str = input().strip()\n    result = find_divisible_by_8(num_str)\n    if result is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_floor(n, memories):\n    possible_flats_per_floor = set()\n\n    for flats_per_floor in range(1, 101):\n        valid = True\n        for k, f in memories:\n            calculated_floor = (k + flats_per_floor - 1) // flats_per_floor\n            if calculated_floor != f:\n                valid = False\n                break\n        if valid:\n            possible_flats_per_floor.add(flats_per_floor)\n\n    target_floors = set()\n    for flats_per_floor in possible_flats_per_floor:\n        target_floor = (n + flats_per_floor - 1) // flats_per_floor\n        target_floors.add(target_floor)\n\n    if len(target_floors) == 1:\n        return target_floors.pop()\n    else:\n        return -1\n\n# Reading input\nn, m = map(int, input().split())\nmemories = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Calculating and printing output\nresult = find_floor(n, memories)\nprint(result)"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    board = [[board1[i], board2[i]] for i in range(n)]\n    \n    # Define the four possible shapes of the bishwock\n    bishwock_shapes = [\n        [(0, 0), (0, 1), (1, 0)],  # Original L shape\n        [(0, 0), (0, 1), (1, 1)],  # Rotated 90 degrees\n        [(0, 1), (1, 0), (1, 1)],  # Rotated 180 degrees\n        [(0, 0), (1, 0), (1, 1)]   # Rotated 270 degrees\n    ]\n    \n    def can_place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            if nx >= 2 or ny >= n or board[ny][nx] == 'X':\n                return False\n        return True\n    \n    def place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            board[ny][nx] = 'X'\n    \n    count = 0\n    for y in range(n):\n        for x in range(2):\n            for shape in bishwock_shapes:\n                if can_place_bishwock(x, y, shape):\n                    place_bishwock(x, y, shape)\n                    count += 1\n                    break\n    \n    return count\n\n# Example usage\nboard1 = \"00X00X0XXX0\"\nboard2 = \"0XXX0X00X00\"\nprint(max_bishwocks(board1, board2))  # Output: 4"}
{"solution": "def max_pretty_set_length(s):\n    max_length = 0\n    current_set = set()\n    \n    for char in s:\n        if char.islower():\n            if char not in current_set:\n                current_set.add(char)\n        else:\n            max_length = max(max_length, len(current_set))\n            current_set.clear()\n    \n    # Check the last segment\n    max_length = max(max_length, len(current_set))\n    \n    return max_length\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult = max_pretty_set_length(s)\n\n# Print the result\nprint(result)"}
{"solution": "def max_difference(n, arr):\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    \n    # Initialize variables for sums B and C\n    B, C = 0, 0\n    \n    # Iterate through the sorted array and assign elements to maximize B - C\n    for i in range(n):\n        if i % 2 == 0:\n            B += arr[i]\n        else:\n            C += arr[i]\n    \n    # Calculate and return the maximum difference B - C\n    return B - C\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_difference(n, arr))"}
{"solution": "def min_refuels(a, b, f, k):\n    if b >= 2 * a:\n        return 0\n    \n    if 2 * a - f <= b:\n        return -1 if (2 * a - b) * k > f else k - 1\n    \n    refuels = 0\n    dist_to_f = f\n    dist_from_f = a - f\n    max_dist_without_refuel = b - dist_to_f\n    \n    if max_dist_without_refuel < dist_from_f:\n        return -1\n    \n    extra_distance_possible = max_dist_without_refuel - dist_from_f\n    if extra_distance_possible >= dist_to_f:\n        return -1 if (2 * a - b) * k > f else k - 1\n    \n    full_rounds_before_refuel = (max_dist_without_refuel - dist_to_f) // dist_to_f\n    rounds_to_cover_k_journeys = (2 * a - b) * k\n    if rounds_to_cover_k_journeys <= f:\n        return k\n    \n    refuels += rounds_to_cover_k_journeys // f\n    remaining_rounds = rounds_to_cover_k_journeys % f\n    \n    if remaining_rounds > 0:\n        refuels += 1\n    \n    return refuels\n\n# Reading input\na, b, f, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(s, p, q):\n    n = len(s)\n    result = []\n    while s:\n        if n >= p and (n - p) % q == 0:\n            result.append(s[:p])\n            s = s[p:]\n            n -= p\n        elif n >= q and (n - q) % p == 0:\n            result.append(s[:q])\n            s = s[q:]\n            n -= q\n        else:\n            return [-1]\n    return [len(result)] + result\n\nif __name__ == \"__main__\":\n    n, p, q = map(int, input().split())\n    s = input()\n    output = split_string(s, p, q)\n    if output[0] == -1:\n        print(-1)\n    else:\n        print(output[0])\n        for piece in output[1:]:\n            print(piece)"}
{"solution": "from heapq import heappush, heappop\n\ndef possible_path(n, m, s, d, obstacles):\n    obstacles_set = set(obstacles)\n    obstacles.append(m)\n    obstacles.sort()\n    \n    reachable = {0}\n    ways = {0: []}\n    heap = [(0, 0)]\n    \n    while heap:\n        obs, prev = heappop(heap)\n        \n        if obs == m:\n            path = ways[prev] + [f\"RUN {obs - prev}\"]\n            return \"\\n\".join(path)\n        \n        for next_obs in range(obs + 1, min(obs + d + 1, m + 1)):\n            if next_obs in obstacles_set and next_obs not in reachable:\n                run = max(0, next_obs - prev - s)\n                new_path = ways[prev] + [f\"RUN {run}\", f\"JUMP {next_obs - (prev + run)}\"]\n                ways[next_obs] = new_path\n                reachable.add(next_obs)\n                heappush(heap, (next_obs, next_obs))\n                \n        for run in range(1, s + 1):\n            next_pos = obs + run\n            if next_pos not in obstacles_set and next_pos <= m:\n                if next_pos not in reachable:\n                    new_path = ways[prev] + [f\"RUN {run}\"]\n                    ways[next_pos] = new_path\n                    reachable.add(next_pos)\n                    heappush(heap, (next_pos, obs))\n    \n    return \"IMPOSSIBLE\"\n\n# Reading input\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(possible_path(n, m, s, d, obstacles))"}
{"solution": "def count_possible_pairs(s, x):\n    # Check if s - x is even and s > x\n    if (s - x) % 2 == 0 and s > x:\n        # Calculate b\n        b = (s - x) // 2\n        # Check if b is positive\n        if b > 0:\n            return 2  # For each valid pair (a, b) and (b, a)\n    return 0\n\n# Reading input\ns, x = map(int, input().split())\n\n# Printing output\nprint(count_possible_pairs(s, x))"}
{"solution": "def min_actions(n, k):\n    if k == 0:\n        return n, list(range(1, n + 1))\n    else:\n        span = 2 * k + 1\n        actions = []\n        if n % span == 0:\n            return n // span, [i for i in range(k + 1, n, span)]\n        else:\n            full_spans, remainder = divmod(n, span)\n            if remainder > k:\n                full_spans += 1\n            return full_spans, [i for i in range(k + 1, n + 1, span)]\n\nn, k = map(int, input().split())\nactions_count, actions = min_actions(n, k)\nprint(actions_count)\nprint(*actions)"}
{"solution": "import math\n\ndef min_operations_to_square(n):\n    n_str = str(n)\n    n_len = len(n_str)\n    \n    # Generate all possible squares up to the maximum possible value\n    max_square_root = int(math.sqrt(2 * 10**9)) + 1\n    squares = [str(i * i) for i in range(1, max_square_root + 1)]\n    \n    def is_subsequence(small, large):\n        it = iter(large)\n        return all(char in it for char in small)\n    \n    min_deletions = float('inf')\n    \n    for square in squares:\n        if is_subsequence(square, n_str):\n            deletions = n_len - len(square)\n            min_deletions = min(min_deletions, deletions)\n    \n    return min_deletions if min_deletions != float('inf') else -1\n\n# Reading input\nn = int(input())\n\n# Calculating and printing output\nprint(min_operations_to_square(n))"}
{"solution": "from math import gcd\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef fact_mod(n, MOD):\n    facts = [1] * (n + 1)\n    for i in range(2, n + 1):\n        facts[i] = (facts[i - 1] * i) % MOD\n    return facts\n\ndef inverse_mod(x, MOD):\n    return pow(x, MOD - 2, MOD)\n\ndef count_max_gcd_permutations(n):\n    facts = fact_mod(n, MOD)\n    inv_facts = [inverse_mod(fact, MOD) for fact in facts]\n    \n    prime_factors = defaultdict(int)\n    for i in range(2, n + 1):\n        x = i\n        for j in range(2, int(i ** 0.5) + 1):\n            if x % j == 0:\n                prime_factors[j] += 1\n                while x % j == 0:\n                    x //= j\n        if x > 1:\n            prime_factors[x] += 1\n    \n    max_distinct_gcds = len(prime_factors)\n    dp = [0] * (max_distinct_gcds + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        x = i\n        for j in list(prime_factors.keys()):\n            if x % j == 0:\n                prime_factors[j] -= 1\n                if prime_factors[j] == 0:\n                    del prime_factors[j]\n                while x % j == 0:\n                    x //= j\n        new_dp = [dp[k] * facts[i] * inv_facts[i - len(prime_factors)] % MOD * inv_facts[len(prime_factors)] % MOD for k in range(max_distinct_gcds + 1)]\n        if x > 1:\n            new_dp[max_distinct_gcds] += dp[max_distinct_gcds - 1] * facts[i] % MOD\n        else:\n            new_dp[max_distinct_gcds] += dp[max_distinct_gcds]\n        dp = new_dp[:]\n    \n    return dp[max_distinct_gcds]\n\n# Read input\nn = int(input())\n\n# Compute and print the result\nprint(count_max_gcd_permutations(n) % MOD)"}
{"solution": "def minimum_jump_ability(s):\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    positions = [-1]  # Start position before the first character\n    \n    # Collect positions of all vowels\n    for i, char in enumerate(s):\n        if char in vowels:\n            positions.append(i)\n    \n    positions.append(len(s))  # End position after the last character\n    \n    # Calculate maximum distance between consecutive positions\n    max_distance = 0\n    for i in range(1, len(positions)):\n        max_distance = max(max_distance, positions[i] - positions[i - 1])\n    \n    return max_distance\n\n# Example usage:\ns = input()\nprint(minimum_jump_ability(s))"}
{"solution": "def can_distribute_candies(a):\n    total_candies = sum(a)\n    # Check if total candies can be divided equally among two friends\n    if total_candies % 2 != 0:\n        return \"NO\"\n    # Sort the list to try to find a valid distribution\n    a.sort()\n    for i in range(1, 1 << len(a)):\n        sum1 = sum(a[j] for j in range(len(a)) if (i & (1 << j)))\n        sum2 = total_candies - sum1\n        if sum1 == sum2:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\na = list(map(int, input().split()))\n\n# Output result\nprint(can_distribute_candies(a))"}
{"solution": "def optimal_pie_distribution(pie_slices):\n    n = len(pie_slices)\n    dp = [[0] * n for _ in range(n)]\n    \n    for length in range(1, n + 1):\n        for start in range(n - length + 1):\n            end = start + length - 1\n            if length == 1:\n                dp[start][end] = (pie_slices[start], 0)\n            else:\n                take_start = pie_slices[start] + dp[start + 1][end][1]\n                take_end = pie_slices[end] + dp[start][end - 1][1]\n                \n                if take_start > take_end:\n                    dp[start][end] = (take_start, dp[start + 1][end][0])\n                else:\n                    dp[start][end] = (take_end, dp[start][end - 1][0])\n    \n    return dp[0][n - 1]\n\nif __name__ == \"__main__\":\n    n = int(input())\n    pie_slices = list(map(int, input().split()))\n    alice, bob = optimal_pie_distribution(pie_slices)\n    print(alice, bob)"}
{"solution": "from collections import defaultdict\nfrom math import gcd\n\ndef prime_factors(n):\n    i = 2\n    factors = defaultdict(int)\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors[i] += 1\n    if n > 1:\n        factors[n] += 1\n    return factors\n\ndef min_variables(a):\n    factors = [prime_factors(x) for x in a]\n    factor_counts = defaultdict(int)\n    \n    for f in factors:\n        for p, count in f.items():\n            factor_counts[p] = max(factor_counts[p], count)\n    \n    # Check if it's possible to represent the sequence\n    for i, f in enumerate(factors):\n        for p, count in f.items():\n            if factor_counts[p] < count:\n                return -1\n    \n    # Calculate the minimum number of variables\n    m = 1\n    for p, count in factor_counts.items():\n        m = m * ((count + 1) // 2)\n    \n    return m\n\nn = int(input())\na = list(map(int, input().split()))\n\nprint(min_variables(a))"}
{"solution": "def determine_winner(n, piles):\n    odd_count = sum(1 for pile in piles if pile % 2 != 0)\n    if odd_count % 2 == 0:\n        return \"Alice\"\n    else:\n        return \"Bob\"\n\n# Read input\nn = int(input())\npiles = list(map(int, input().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, piles))"}
{"solution": "def can_make_equal(arr):\n    arr.sort()\n    min_diff = float('inf')\n    # Find the minimum difference between any two consecutive elements after sorting\n    for i in range(1, len(arr)):\n        diff = arr[i] - arr[i - 1]\n        min_diff = min(min_diff, diff)\n    \n    # Check if it's possible to make all elements equal by adding/subtracting min_diff\n    target = arr[0]\n    for num in arr:\n        if (num - target) % min_diff != 0:\n            return \"NO\"\n    return \"YES\"\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Processing and printing output\nprint(can_make_equal(arr))"}
{"solution": "def z_algorithm(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            z[i] = min(r - i + 1, z[i - l])\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > r:\n            l, r = i, i + z[i] - 1\n    return z\n\ndef find_longest_repeated_substring(s):\n    n = len(s)\n    max_len = 0\n    for i in range(n):\n        new_s = s[i:] + \"#\" + s\n        z = z_algorithm(new_s)\n        for j in range(i + 1, len(z)):\n            if z[j] > max_len and j - i - 1 >= z[j]:\n                max_len = z[j]\n    return max_len\n\n# Reading input\nn = int(input())\ns = input()\n\n# Finding and printing the result\nprint(find_longest_repeated_substring(s))"}
{"solution": "def minimum_time_to_house(n, a):\n    if a % 2 == 1:\n        # a is odd\n        return (a + 1) // 2\n    else:\n        # a is even\n        return (n - a + 2) // 2\n\n# Read input\nn, a = map(int, input().split())\n\n# Calculate and print the result\nprint(minimum_time_to_house(n, a))"}
{"solution": "def is_mission_possible(n, m, colors, k):\n    from collections import Counter\n    \n    required_counts = Counter({i: ki for i, ki in enumerate(k, start=1) if ki > 0})\n    current_counts = Counter()\n    \n    left = 0\n    for right in range(n):\n        color = colors[right]\n        if color in required_counts:\n            current_counts[color] += 1\n        \n        while all(current_counts[c] == required_counts[c] for c in required_counts):\n            if current_counts == required_counts:\n                return \"YES\"\n            \n            if colors[left] in required_counts:\n                current_counts[colors[left]] -= 1\n                if current_counts[colors[left]] == 0:\n                    del current_counts[colors[left]]\n            left += 1\n    \n    return \"NO\"\n\n# Reading input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\nk = list(map(int, input().split()))\n\n# Printing output\nprint(is_mission_possible(n, m, colors, k))"}
{"solution": "def determine_winner(n, rounds):\n    mishka_wins = 0\n    chris_wins = 0\n    \n    for round in rounds:\n        m, c = round\n        if m > c:\n            mishka_wins += 1\n        elif c > m:\n            chris_wins += 1\n    \n    if mishka_wins > chris_wins:\n        return \"Mishka\"\n    elif chris_wins > mishka_wins:\n        return \"Chris\"\n    else:\n        return \"Friendship is magic!^^\"\n\n# Example usage can be imagined as:\n# n = int(input())\n# rounds = [list(map(int, input().split())) for _ in range(n)]\n# print(determine_winner(n, rounds))"}
{"solution": "def is_valid_minesweeper_field(n, m, field):\n    def count_bombs(i, j):\n        count = 0\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                nx, ny = i + dx, j + dy\n                if 0 <= nx < n and 0 <= ny < m and field[nx][ny] == '*':\n                    count += 1\n        return count\n\n    for i in range(n):\n        for j in range(m):\n            cell = field[i][j]\n            if cell == '.':\n                if any(0 <= i + dx < n and 0 <= j + dy < m and field[i + dx][j + dy] == '*' for dx in [-1, 0, 1] for dy in [-1, 0, 1]):\n                    return \"NO\"\n            elif cell.isdigit():\n                expected_bombs = int(cell)\n                actual_bombs = count_bombs(i, j)\n                if actual_bombs != expected_bombs:\n                    return \"NO\"\n    return \"YES\"\n\n# Reading input\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\n# Output\nprint(is_valid_minesweeper_field(n, m, field))"}
{"solution": "from math import ceil\n\ndef can_vasya_eat_half(n, k):\n    total_candies = n\n    vasya_eaten = 0\n    \n    while total_candies > 0:\n        # Vasya eats k candies\n        vasya_eaten += min(k, total_candies)\n        total_candies -= min(k, total_candies)\n        \n        # Petya eats 10% of the remaining candies\n        petya_eaten = total_candies // 10\n        total_candies -= petya_eaten\n    \n    return vasya_eaten >= (n + 1) // 2\n\ndef find_min_k(n):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Read input\nn = int(input().strip())\n\n# Find and print the minimal k\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace(s):\n    p = s.count('o')\n    l = s.count('-')\n    \n    if p == 0 or p == 1:\n        return \"YES\"\n    if l % p == 0:\n        return \"YES\"\n    return \"NO\"\n\n# Example calls to the function with provided data points\ncan_rearrange_necklace(\"-o-o--\")  # Output: YES\ncan_rearrange_necklace(\"-o---\")   # Output: YES\ncan_rearrange_necklace(\"-o---o-\") # Output: NO\ncan_rearrange_necklace(\"ooo\")     # Output: YES"}
{"solution": "def max_pillows(n, m, k):\n    low, high = 1, m\n    while low < high:\n        mid = (low + high + 1) // 2\n        pillows_needed = mid + 2 * (mid - 1) * (min(k - 1, mid - 1) + min(n - k, mid - 1)) + max(0, (mid - 1) * (k - 1 - (mid - 1))) + max(0, (mid - 1) * (n - k - (mid - 1)))\n        if pillows_needed <= m:\n            low = mid\n        else:\n            high = mid - 1\n    return low\n\n# Example usage\nn, m, k = map(int, input().split())\nprint(max_pillows(n, m, k))"}
{"solution": "from collections import deque\n\ndef max_subarray_cost(n, m, k, arr):\n    prefix_sum = [0]\n    for num in arr:\n        prefix_sum.append(prefix_sum[-1] + num)\n\n    max_cost = 0\n    window_sum = deque()\n    \n    for i in range(len(prefix_sum)):\n        # Calculate the cost for the current window size\n        if window_sum and (i - window_sum[0][1] >= m):\n            window_sum.popleft()\n        \n        current_cost = prefix_sum[i]\n        if window_sum:\n            current_cost -= k * (i - window_sum[0][1]) // m\n        \n        # Update max_cost\n        max_cost = max(max_cost, current_cost)\n        \n        # Maintain a decreasing order queue\n        while window_sum and prefix_sum[i] > window_sum[-1][0]:\n            window_sum.pop()\n        \n        window_sum.append((prefix_sum[i], i))\n    \n    return max_cost\n\n# Read input\nn, m, k = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Print the result\nprint(max_subarray_cost(n, m, k, arr))"}
{"solution": "def main():\n    n, m = map(int, input().split())\n\n    # Ensure n is always the smaller dimension for uniformity in solution\n    if n > m:\n        n, m = m, n\n\n    # Define the points based on dimensions\n    if n == 0:\n        # Special case when there's no vertical dimension\n        print(f\"0 {m-1}\")\n        print(f\"0 {m}\")\n        print(f\"0 0\")\n        print(f\"0 {m-1}\")\n    else:\n        # General case\n        print(f\"{n-1} {m}\")\n        print(f\"0 {m}\")\n        print(f\"{n-1} 0\")\n        print(f\"0 0\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_smallest_number(shuffled_str, remembered_substring):\n    def z_function(s):\n        n = len(s)\n        z = [0] * n\n        l, r = 0, 0\n        for i in range(1, n):\n            if i <= r:\n                z[i] = min(r - i + 1, z[i - l])\n            while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n                z[i] += 1\n            if i + z[i] - 1 > r:\n                l, r = i, i + z[i] - 1\n        return z\n\n    remembered_length = len(remembered_substring)\n    k = len(shuffled_str) - remembered_length\n    z = z_function(remembered_substring + \"#\" + shuffled_str)\n    positions = [i for i, val in enumerate(z) if val == remembered_length]\n    valid_starts = [pos - remembered_length - 1 for pos in positions if pos - remembered_length - 1 >= 0 and pos % (pos - remembered_length) == 0]\n\n    def is_valid(start):\n        period = start - remembered_length\n        return all(shuffled_str[i] == remembered_substring[i % remembered_length] for i in range(start, start + k))\n\n    valid_starts = list(filter(is_valid, valid_starts))\n    smallest_n = float('inf')\n    for start in valid_starts:\n        candidate = int(shuffled_str[:start + k]) * (10 ** remembered_length) + int(remembered_substring)\n        smallest_n = min(smallest_n, candidate)\n\n    return str(smallest_n)\n\n# Reading input\nshuffled_str = input().strip()\nremembered_substring = input().strip()\n\n# Printing output\nprint(find_smallest_number(shuffled_str, remembered_substring))"}
{"solution": "n, m, mn, mx = map(int, input().split())\ntemps = list(map(int, input().split()))\n\nmin_temp_in_set = min(temps)\nmax_temp_in_set = max(temps)\n\nif mn < min_temp_in_set or mx > max_temp_in_set:\n    print(\"Incorrect\")\nelif m == sum([1 for temp in temps if temp == mn]) + sum([1 for temp in temps if temp == mx]):\n    print(\"Correct\")\nelse:\n    print(\"Incorrect\")"}
{"solution": "def count_trailing_zeroes(n):\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count\n\ndef find_numbers(m):\n    low, high = 0, 1000000\n    while low < high:\n        mid = (low + high) // 2\n        if count_trailing_zeroes(mid) < m:\n            low = mid + 1\n        else:\n            high = mid\n    numbers = []\n    n = low\n    while count_trailing_zeroes(n) == m:\n        numbers.append(n)\n        n += 1\n    return numbers\n\nm = int(input())\nnumbers = find_numbers(m)\nprint(len(numbers))\nprint(' '.join(map(str, numbers)))"}
{"solution": "from heapq import heappop, heappush\nfrom collections import defaultdict\n\ndef dijkstra(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [(0, start)]\n    \n    while queue:\n        current_distance, current_node = heappop(queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node].items():\n            distance = max(current_distance, weight)\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heappush(queue, (distance, neighbor))\n                \n    return distances\n\ndef preprocess(graph, special_nodes):\n    processed_distances = {}\n    \n    for node in special_nodes:\n        distances = dijkstra(graph, node)\n        processed_distances[node] = {sn: distances[sn] for sn in special_nodes}\n        \n    return processed_distances\n\ndef find_farthest_special_vertices(processed_distances, special_nodes):\n    results = []\n    \n    for node in special_nodes:\n        max_distance = max((distance for other_node, distance in processed_distances[node].items() if other_node != node), default=0)\n        results.append(max_distance)\n        \n    return results\n\n# Reading input\nn, m, k = map(int, input().split())\nspecial_nodes = list(map(int, input().split()))\n\ngraph = defaultdict(dict)\nfor _ in range(m):\n    u, v, w = map(int, input().split())\n    graph[u][v] = w\n    graph[v][u] = w\n\n# Preprocessing\nprocessed_distances = preprocess(graph, special_nodes)\n\n# Finding farthest special vertices\nresults = find_farthest_special_vertices(processed_distances, special_nodes)\n\n# Output\nprint(*results)"}
{"solution": "n = int(input())\nx = int(input())\n\nif n % 2 == 0:\n    if x == 0:\n        print(0)\n    elif x == 1:\n        print(1)\n    else:\n        print(2)\nelse:\n    if x == 0:\n        print(1)\n    elif x == 1:\n        print(0)\n    else:\n        print(1)"}
{"solution": "def check_square(rectangles):\n    min_x, min_y = float('inf'), float('inf')\n    max_x, max_y = float('-inf'), float('-inf')\n    \n    # Determine bounding box\n    for x1, y1, x2, y2 in rectangles:\n        min_x, min_y = min(min_x, x1), min(min_y, y1)\n        max_x, max_y = max(max_x, x2), max(max_y, y2)\n    \n    # Check if bounding box is a square\n    if max_x - min_x != max_y - min_y:\n        return \"NO\"\n    \n    # Check if rectangles cover the entire square\n    covered = set()\n    for x in range(min_x, max_x + 1):\n        for y in range(min_y, max_y + 1):\n            covered.add((x, y))\n    \n    for x1, y1, x2, y2 in rectangles:\n        for x in range(x1, x2):\n            for y in range(y1, y2):\n                if (x, y) in covered:\n                    covered.remove((x, y))\n    \n    if len(covered) == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Reading input\nn = int(input())\nrectangles = [list(map(int, input().split())) for _ in range(n)]\n\n# Printing output\nprint(check_square(rectangles))"}
{"solution": "def count_really_big_numbers(n, s):\n    def count_digits(num):\n        return len(str(num))\n\n    def max_possible_sum(digits, limit, remaining_s):\n        if remaining_s < 0:\n            return 0\n        if digits == 0:\n            return 1\n        current_digit_limit = min(9, limit // (10 ** (digits - 1)))\n        ways = 0\n        for d in range(current_digit_limit + 1):\n            new_remaining_s = remaining_s - d\n            ways += max_possible_sum(digits - 1, limit, new_remaining_s)\n        return ways\n\n    def calculate(limit, s):\n        digits = count_digits(limit)\n        return max_possible_sum(digits, limit, s)\n\n    original_n = n\n    n += s\n    total_ways = n - original_n\n    digits = count_digits(n)\n    total_ways -= calculate(10 ** digits - 1, s)\n    total_ways += calculate(n, s)\n    return total_ways\n\n# Reading input\nn, s = map(int, input().split())\n\n# Calculating and printing the result\nprint(count_really_big_numbers(n, s))"}
{"solution": "from collections import defaultdict\n\ndef check_two_lines(n, points):\n    slopes = defaultdict(set)\n    \n    for i in range(n):\n        x1, y1 = points[i]\n        for j in range(i + 1, n):\n            x2, y2 = points[j]\n            if x2 - x1 == 0:  # Vertical line\n                slope = float('inf')\n            else:\n                slope = (y2 - y1) / (x2 - x1)\n            \n            intercept = y1 - slope * x1\n            slopes[slope].add(intercept)\n    \n    # Check if there are two slopes with the same intercepts or one slope with all points\n    if len(slopes) == 1 and all(len(intercepts) == n for intercepts in slopes.values()):\n        return \"YES\"\n    elif len(slopes) == 2 and any(len(intercepts) == n for intercepts in slopes.values()):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Reading input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculating and printing the result\nresult = check_two_lines(n, points)\nprint(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(a, b, k, t):\n    dp = [[0] * (2*k+1) for _ in range(t+1)]\n    offset = k\n    dp[0][k] = 1\n    \n    for turn in range(1, t+1):\n        new_dp = [0] * (2*k+1)\n        for diff in range(2*k+1):\n            for move in range(-k, k+1):\n                prev_diff = diff - move\n                if 0 <= prev_diff < 2*k+1:\n                    new_dp[diff] += dp[turn-1][prev_diff]\n                    new_dp[diff] %= MOD\n        dp = new_dp\n    \n    result = 0\n    for diff in range(b-a+offset+1, 2*k+1):\n        result += dp[t][diff]\n        result %= MOD\n    \n    return result\n\na, b, k, t = map(int, input().split())\nprint(solve(a, b, k, t))"}
{"solution": "from itertools import combinations\n\ndef find_min_marks(n, l, x, y, marks):\n    def can_measure(distance):\n        measured_distances = set()\n        for i, j in combinations(range(n), 2):\n            measured_distances.add(abs(marks[j] - marks[i]))\n        return distance in measured_distances\n\n    missing = []\n    if not can_measure(x):\n        missing.append(x)\n    if not can_measure(y):\n        missing.append(y)\n\n    min_marks = float('inf')\n    min_solution = None\n\n    for mark in missing:\n        for pos in range(1, l):\n            if pos not in marks and all(can_measure(dist) for dist in missing):\n                if len(missing) < min_marks:\n                    min_marks = len(missing)\n                    min_solution = missing.copy()\n                missing.remove(pos)\n                break\n            missing.append(pos)\n\n    return min_marks, min_solution\n\n# Reading input\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Solving\nmarks_set = set(marks)\nmin_marks, min_solution = find_min_marks(n, l, x, y, marks)\n\n# Printing output\nprint(min_marks)\nprint(*sorted(min_solution))"}
{"solution": "import math\n\ndef max_cake_volume(n, cakes):\n    # Calculate volumes and sort by volume\n    volumes = [math.pi * r**2 * h for r, h in cakes]\n    cakes_sorted = sorted(enumerate(volumes), key=lambda x: x[1])\n\n    # Dynamic Programming\n    dp = [0] * n\n    parent = [-1] * n\n    max_vol_idx = 0\n\n    for i in range(n):\n        current_vol = volumes[i]\n        dp[i] = current_vol\n        for j in range(i):\n            if cakes_sorted[j][1] < cakes_sorted[i][1] and dp[j] + current_vol > dp[i]:\n                dp[i] = dp[j] + current_vol\n                parent[i] = cakes_sorted[j][0]\n        if dp[i] > dp[max_vol_idx]:\n            max_vol_idx = i\n\n    return dp[max_vol_idx]\n\n# Read input\nn = int(input())\ncakes = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print result\nresult = max_cake_volume(n, cakes)\nprint(result)"}
{"solution": "from typing import List\nfrom bisect import bisect_right\n\ndef min_good_slices(tower_heights: List[int], max_cost: int) -> int:\n    \"\"\"\n    Calculates the minimum number of good slices to make all towers have the same height.\n    \n    Parameters:\n    tower_heights (List[int]): The heights of the towers.\n    max_cost (int): The maximum cost of the slices.\n    \n    Returns:\n    int: The minimum number of good slices.\n    \"\"\"\n    tower_heights.sort()\n    total_towers = len(tower_heights)\n    prefix_sum = [0]\n    for height in tower_heights:\n        prefix_sum.append(prefix_sum[-1] + height)\n    \n    def is_possible(target_height) -> bool:\n        sliced_cost = total_towers * target_height - prefix_sum[bisect_right(tower_heights, target_height)]\n        return sliced_cost <= max_cost\n    \n    left, right = 0, tower_heights[-1]\n    while left < right:\n        mid = (left + right) // 2\n        if is_possible(mid):\n            right = mid\n        else:\n            left = mid + 1\n    \n    result = 0\n    current_height = left\n    while True:\n        new_height = bisect_right(tower_heights, current_height)\n        if new_height == total_towers:\n            break\n        if is_possible(new_height):\n            current_height = new_height\n            result += 1\n        else:\n            break\n    \n    return result\n\n# Example check function (not part of the solution)\ndef check_solution():\n    assert min_good_slices([3, 1, 2, 2, 4], 5) == 2\n    assert min_good_slices([2, 3, 4, 5], 5) == 2\n    print(\"All tests passed!\")\n\ncheck_solution()"}
{"solution": "def max_game_score(n, a):\n    # Calculate prefix sums\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    # Initialize variables to track the maximum score and the minimum value\n    max_score = float('-inf')\n    min_value = float('inf')\n    min_index = -1\n\n    # Iterate through the array to find the minimum value and its index\n    for i in range(n):\n        if a[i] < min_value:\n            min_value = a[i]\n            min_index = i\n\n    # Calculate scores by excluding the minimum value from all possible segments\n    for i in range(min_index):\n        max_score = max(max_score, prefix_sum[min_index] - prefix_sum[i])\n\n    for i in range(min_index + 1, n):\n        max_score = max(max_score, prefix_sum[i + 1] - prefix_sum[min_index + 1])\n\n    # Special case when the minimum value is at the beginning or end\n    max_score = max(max_score, prefix_sum[n] - prefix_sum[1])\n    max_score = max(max_score, prefix_sum[n - 1])\n\n    return max_score\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_game_score(n, a))"}
{"solution": "from math import gcd\n\ndef find_lcm(num1, num2):\n    return num1 * num2 // gcd(num1, num2)\n\ndef check_lighting(k1, k2, k3):\n    lcm12 = find_lcm(k1, k2)\n    lcm13 = find_lcm(k1, k3)\n    lcm23 = find_lcm(k2, k3)\n    lcm_all = find_lcm(lcm12, k3)\n\n    # Check if there's any gap in lighting\n    if (lcm12 // k1 == lcm12 // k2 or\n        lcm13 // k1 == lcm13 // k3 or\n        lcm23 // k2 == lcm23 // k3 or\n        lcm_all // k1 == lcm_all // k2 == lcm_all // k3):\n        return \"NO\"\n    else:\n        return \"YES\"\n\n# Read input\nk1, k2, k3 = map(int, input().split())\n\n# Output result\nprint(check_lighting(k1, k2, k3))"}
{"solution": "def min_operations_to_delete_string(n, s):\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j-1]\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n\n    return dp[0][n-1]\n\nn = int(input())\ns = input().strip()\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "def max_dance_pairs():\n    n = int(input())\n    boys = list(map(int, input().split()))\n    m = int(input())\n    girls = list(map(int, input().split()))\n\n    boys.sort()\n    girls.sort()\n\n    boy_ptr, girl_ptr = 0, 0\n    pairs = 0\n\n    while boy_ptr < n and girl_ptr < m:\n        if abs(boys[boy_ptr] - girls[girl_ptr]) <= 1:\n            pairs += 1\n            boy_ptr += 1\n            girl_ptr += 1\n        elif boys[boy_ptr] < girls[girl_ptr]:\n            boy_ptr += 1\n        else:\n            girl_ptr += 1\n\n    return pairs\n\nprint(max_dance_pairs())"}
{"solution": "def kicker_game(a1, b1, a2, b2, a3, b3, a4, b4):\n    # Team 1 players\n    p1 = (a1, b1)\n    p2 = (a2, b2)\n    \n    # Team 2 players\n    p3 = (a3, b3)\n    p4 = (a4, b4)\n    \n    # Possible arrangements for Team 1\n    team1_wins = [\n        max(p1[0], p2[0]) > min(p3[1], p4[1]) and max(p1[1], p2[1]) > min(p3[0], p4[0]),\n        max(p1[0], p2[1]) > min(p3[1], p4[0]) and max(p1[1], p2[0]) > min(p3[0], p4[1])\n    ]\n    \n    # Possible arrangements for Team 2\n    team2_wins = [\n        max(p3[0], p4[0]) > min(p1[1], p2[1]) and max(p3[1], p4[1]) > min(p1[0], p2[0]),\n        max(p3[0], p4[1]) > min(p1[1], p2[0]) and max(p3[1], p4[0]) > min(p1[0], p2[1])\n    ]\n    \n    # Determine the winner\n    if any(team1_wins):\n        return \"Team 1\"\n    elif any(team2_wins):\n        return \"Team 2\"\n    else:\n        return \"Draw\"\n\n# Reading input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\na4, b4 = map(int, input().split())\n\n# Output\nprint(kicker_game(a1, b1, a2, b2, a3, b3, a4, b4))"}
{"solution": "from scipy.optimize import minimize\nimport numpy as np\n\ndef time_to_grill(XY, meats, K):\n    X, Y = XY\n    times = [c * np.sqrt((X - x) ** 2 + (Y - y) ** 2) for x, y, c in meats]\n    times.sort()\n    return times[K-1]\n\ndef objective(XY, meats, K):\n    return time_to_grill(XY, meats, K)\n\ndef solve(N, K, meats):\n    initial_guess = [0.0, 0.0]\n    bounds = [(-1000, 1000), (-1000, 1000)]\n    result = minimize(objective, initial_guess, args=(meats, K), bounds=bounds)\n    return result.fun\n\n# Reading input\nN, K = map(int, input().split())\nmeats = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Solving and printing output\nprint(solve(N, K, meats))"}
{"solution": "def game_strategy(n, ticket):\n    left_sum = 0\n    right_sum = 0\n    left_erasures = 0\n    right_erasures = 0\n    \n    for i in range(n // 2):\n        if ticket[i] == '?':\n            left_erasures += 1\n        else:\n            left_sum += int(ticket[i])\n    \n    for i in range(n // 2, n):\n        if ticket[i] == '?':\n            right_erasures += 1\n        else:\n            right_sum += int(ticket[i])\n    \n    # Calculate the difference in erasures and sums\n    erasures_diff = abs(left_erasures - right_erasures)\n    sum_diff = abs(left_sum - right_sum)\n    \n    # Determine the winner\n    if erasures_diff % 2 != 0 or sum_diff % 9 != 0:\n        return \"Monocarp\"\n    elif (erasures_diff // 2) * 9 != sum_diff:\n        return \"Monocarp\"\n    else:\n        return \"Bicarp\"\n\n# Read input\nn = int(input())\nticket = input()\n\n# Output the result\nprint(game_strategy(n, ticket))"}
{"solution": "def find_bus_route(n, t, bus_routes):\n    earliest_time = float('inf')\n    chosen_route = -1\n    \n    for i in range(n):\n        s_i, d_i = bus_routes[i]\n        \n        if s_i >= t:\n            next_bus_time = s_i\n        else:\n            # Calculate the next bus time after t\n            if (t - s_i) % d_i == 0:\n                next_bus_time = t\n            else:\n                next_bus_time = s_i + ((t - s_i) // d_i + 1) * d_i\n        \n        if next_bus_time < earliest_time:\n            earliest_time = next_bus_time\n            chosen_route = i + 1\n    \n    return chosen_route\n\n# Reading input\nn, t = map(int, input().split())\nbus_routes = [list(map(int, input().split())) for _ in range(n)]\n\n# Finding and printing the bus route\nprint(find_bus_route(n, t, bus_routes))"}
{"solution": "def count_ones_in_range(start, end, k):\n    count = 0\n    for i in range(start, end + 1):\n        if bin(i).count('1') == k:\n            count += 1\n    return count\n\ndef find_number(m, k):\n    low, high = 1, 10**18\n    while low <= high:\n        mid = (low + high) // 2\n        count = count_ones_in_range(mid + 1, 2 * mid, k)\n        if count == m:\n            return mid\n        elif count < m:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low\n\n# Reading input\nm, k = map(int, input().split())\n\n# Finding and printing the result\nresult = find_number(m, k)\nprint(result)"}
{"solution": "n = int(input())\nlevel = input()\n\ndef is_good_level(level):\n    n = len(level)\n    platforms = [i for i, platform in enumerate(level) if platform == '*']\n    \n    for i in range(len(platforms)):\n        for j in range(i + 1, len(platforms)):\n            d = platforms[j] - platforms[i]\n            if j + 3 < len(platforms) and platforms[j + 1] - platforms[j] == d and platforms[j + 2] - platforms[j + 1] == d and platforms[j + 3] - platforms[j + 2] == d:\n                return True\n    return False\n\nprint('yes' if is_good_level(level) else 'no')"}
{"solution": "from itertools import accumulate\n\ndef solve(n, grid):\n    def is_magic_square(x):\n        target = None\n        # Check rows and calculate target\n        for i in range(n):\n            row_sum = sum(grid[i][j] if j != col else x for j in range(n))\n            if target is None:\n                target = row_sum\n            elif row_sum != target:\n                return False, 0\n        \n        # Check columns\n        for j in range(n):\n            col_sum = sum(grid[i][j] for i in range(n))\n            if col_sum != target:\n                return False, 0\n        \n        # Check diagonals\n        diag1_sum = sum(grid[i][i] for i in range(n))\n        diag2_sum = sum(grid[i][n - 1 - i] for i in range(n))\n        \n        return diag1_sum == target and diag2_sum == target, target\n    \n    for row in range(n):\n        for col in range(n):\n            if grid[row][col] == 0:\n                break\n        else:\n            continue\n        break\n    \n    for x in range(1, 10**18 + 1):\n        valid, _ = is_magic_square(x)\n        if valid:\n            return x\n    return -1\n\n# Read input\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve and print output\nprint(solve(n, grid))"}
{"solution": "def min_max_people_on_benches(n, m, a):\n    # Calculate the maximum possible k\n    max_k = max(a) + m\n    \n    # Calculate the total number of people after adding m people\n    total_people = sum(a) + m\n    \n    # Calculate the minimum possible k\n    min_k = -(-total_people // n)  # Ceiling division\n    \n    return min_k, max_k\n\n# Read input\nn = int(input())\nm = int(input())\na = [int(input()) for _ in range(n)]\n\n# Calculate and print the result\nprint(*min_max_people_on_benches(n, m, a))"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_pow(x, y):\n    \"\"\"Calculate x^y % MOD.\"\"\"\n    result = 1\n    while y > 0:\n        if y & 1:\n            result = result * x % MOD\n        y >>= 1\n        x = x * x % MOD\n    return result\n\ndef calculate_ways(n, m):\n    # Calculate the number of ways to assign tickets to the passengers and board the plane without anyone getting angry.\n    # The formula used here is derived from the problem's constraints and requirements.\n    return mod_pow(2, m) * mod_pow(mod_pow(2, n - m), MOD - 2) % MOD\n\n# Reading input\nn, m = map(int, input().split())\n\n# Calculating and printing the output\nprint(calculate_ways(n, m))"}
{"solution": "from itertools import combinations\n\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef read_list():\n    return list(read_ints()[1:])\n\ndef main():\n    n, m = read_ints()\n    friends = [set(read_list()) for _ in range(n)]\n    pizzas = [([int(i) for i in input().split()][1:], int(input().split()[0])) for _ in range(m)]\n\n    max_happiness = 0\n    best_pair = (0, 0)\n    min_cost = float('inf')\n\n    for pizza1, pizza2 in combinations(pizzas, 2):\n        ingredients = set(pizza1[0]) | set(pizza2[0])\n        happiness = sum(1 for friend in friends if friend.issubset(ingredients))\n        cost = pizza1[1] + pizza2[1]\n\n        if happiness > max_happiness or (happiness == max_happiness and cost < min_cost):\n            max_happiness = happiness\n            min_cost = cost\n            best_pair = (pizza1[1], pizza2[1])\n\n    # Find indices of the best pair\n    indices = [i+1 for i, (ingrs, cost) in enumerate(pizzas) if cost in best_pair]\n    print(*indices[:2])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_min_max_numbers(m, s):\n    def construct_number(m, s, min_or_max):\n        number = []\n        if min_or_max == 'min':\n            # Construct the minimum number\n            for _ in range(m):\n                if s > 9:\n                    number.append('9')\n                    s -= 9\n                else:\n                    number.append(str(s))\n                    s = 0\n                if s == 0:\n                    number.extend(['0'] * (m - len(number)))\n                    number[0] = '0' if number[0] == '0' else number[0]\n                    break\n            if s != 0 or number[0] == '0':\n                return -1\n            return int(''.join(number))\n        else:\n            # Construct the maximum number\n            for _ in range(m):\n                if s < 1:\n                    number.append('0')\n                else:\n                    number.append('1')\n                    s -= 1\n            number[-1] = str(s + int(number[-1]))\n            return int(''.join(number))\n\n    min_num = construct_number(m, s, 'min')\n    max_num = construct_number(m, s, 'max')\n\n    if min_num == -1 or max_num == -1:\n        return \"-1 -1\"\n    else:\n        return f\"{min_num} {max_num}\"\n\n# Reading input\nm, s = map(int, input().split())\n\n# Printing output\nprint(find_min_max_numbers(m, s))"}
{"solution": "MOD = 998244353\n\ndef power(x, y):\n    result = 1\n    while y > 0:\n        if y % 2 == 1:\n            result = (result * x) % MOD\n        y = y // 2\n        x = (x * x) % MOD\n    return result\n\ndef sum_of_numbers_with_k_digits(k):\n    if k == 0:\n        return 0\n    total_sum = 0\n    for i in range(1, 10):\n        total_sum += i * power(10, k - 1)\n    return (total_sum * power(10, k) // 9) % MOD\n\ndef sum_of_numbers_with_at_most_k_digits(k):\n    if k == 0:\n        return 0\n    return (sum_of_numbers_with_k_digits(k) - sum_of_numbers_with_k_digits(k - 1)) % MOD\n\ndef solve(l, r, k):\n    def sum_up_to(n, k):\n        if n == 0:\n            return 0\n        str_n = str(n)\n        len_n = len(str_n)\n        sum_upto_n = sum_of_numbers_with_at_most_k_digits(len_n - 1)\n        for i in range(len(str_n)):\n            sum_upto_n += int(str_n[i]) * sum_of_numbers_with_at_most_k_digits(len_n - i - 1)\n            if i > 0:\n                sum_upto_n += int(str_n[i]) * power(10, len_n - i - 1) * (len_n - i) * (int(str_n[0]) - 1)\n            else:\n                sum_upto_n += int(str_n[i]) * power(10, len_n - i - 1) * (len_n - i) * 9\n            if int(str_n[i]) > 1:\n                break\n        return sum_upto_n % MOD\n\n    return (sum_up_to(r, k) - sum_up_to(l - 1, k)) % MOD\n\n# Reading input\nl, r, k = map(int, input().split())\n\n# Printing output\nprint(solve(l, r, k))"}
{"solution": "def can_distribute_pencils(n, k, d, pencils):\n    pencils.sort()\n    groups = 1\n    last_group_max = pencils[0] + d\n    \n    for i in range(1, n):\n        if pencils[i] > last_group_max:\n            groups += 1\n            last_group_max = pencils[i] + d\n        \n        if groups * k > n:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Reading input\nn, k, d = map(int, input().split())\npencils = list(map(int, input().split()))\n\n# Printing output\nprint(can_distribute_pencils(n, k, d, pencils))"}
{"solution": "from collections import defaultdict\n\ndef count_dead_bulbs(garland):\n    colors = ['R', 'B', 'Y', 'G']\n    dead_count = defaultdict(int)\n    \n    for i in range(len(garland)):\n        if garland[i] == '!':\n            possible_colors = set(colors) - set(garland[max(0, i-3):i+1])\n            for color in possible_colors:\n                dead_count[color] += 1\n                \n    return [dead_count[color] for color in colors]\n\n# Reading input\ngarland = input().strip()\n\n# Calculating the number of dead bulbs for each color\nresult = count_dead_bulbs(garland)\n\n# Printing the result\nprint(*result)"}
{"solution": "from collections import defaultdict, deque\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    N, M = map(int, input().split())\n    graph = defaultdict(list)\n    indeg = [0] * N\n    for _ in range(M):\n        s, t = map(int, input().split())\n        s -= 1\n        t -= 1\n        graph[s].append(t)\n        indeg[t] += 1\n\n    # Topological sort to find layers\n    layers = defaultdict(list)\n    queue = deque([0])\n    visited = [False] * N\n    visited[0] = True\n    while queue:\n        node = queue.popleft()\n        layers[indeg[node]].append(node)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                indeg[neighbor] -= 1\n                if indeg[neighbor] == 0:\n                    queue.append(neighbor)\n                    visited[neighbor] = True\n\n    # Calculate the expected number of passages for each layer\n    dp = [float('inf')] * N\n    dp[N-1] = 0\n    for layer in reversed(range(max(indeg))):\n        for node in layers[layer]:\n            if node == N-1:\n                continue\n            dp[node] = sum(dp[neighbor] + 1 for neighbor in graph[node]) / len(graph[node])\n\n    # Determine the optimal passage to block\n    minE = dp[0]\n    for next_node in graph[0]:\n        altE = dp[next_node] + sum(dp[neighbor] + 1 for neighbor in graph[0] if neighbor != next_node) / (len(graph[0]) - 1)\n        minE = min(minE, altE)\n\n    print(f\"{minE:.10f}\")\n\nsolve()"}
{"solution": "n = int(input())\n\nlast_digit = n % 10\nif last_digit == 0:\n    print(n)\nelse:\n    lower_round = n - last_digit\n    higher_round = lower_round + 10\n    if n - lower_round < higher_round - n:\n        print(lower_round)\n    else:\n        print(higher_round)"}
{"solution": "def find_swaps(s, t):\n    if len(s) != len(t):\n        return -1\n    \n    mismatches = {}\n    \n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if s[i] in mismatches and mismatches[s[i]] != t[i]:\n                return -1\n            if t[i] in mismatches and mismatches[t[i]] != s[i]:\n                return -1\n            mismatches[s[i]] = t[i]\n            mismatches[t[i]] = s[i]\n    \n    visited = set()\n    swaps = []\n    \n    for key in mismatches:\n        if key not in visited:\n            cycle = []\n            current = key\n            while current not in visited:\n                visited.add(current)\n                cycle.append(current)\n                current = mismatches[current]\n            if len(cycle) != 2:\n                return -1\n            swaps.append((cycle[0], cycle[1]))\n    \n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0], swap[1])\n\n# Example usage:\ns = \"helloworld\"\nt = \"ehoolwlroz\"\nfind_swaps(s, t)\n\ns = \"hastalavistababy\"\nt = \"hastalavistababy\"\nfind_swaps(s, t)\n\ns = \"merrychristmas\"\nt = \"christmasmerry\"\nfind_swaps(s, t)"}
{"solution": "def earliest_login(first_name, last_name):\n    earliest = \"\"\n    for i in range(1, len(first_name) + 1):\n        for j in range(1, len(last_name) + 1):\n            login = first_name[:i] + last_name[:j]\n            if earliest == \"\" or login < earliest:\n                earliest = login\n    return earliest\n\nfirst_name, last_name = input().split()\nprint(earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(sequence):\n    def draw(height, width, x):\n        if height == 1:\n            return ['+' + ('-' * width) + '+' if i == x else '|' + (' ' * width) + '|' for i in range(2 * height)]\n        top = ['+' + ('-' * width) + '+' if i == x else '|' + (' ' * width) + '|' for i in range(height)]\n        mid = draw(height - 2, width + 2, x)\n        bottom = ['+' + ('-' * width) + '+' if i == x else '|' + (' ' * width) + '|' for i in range(height)]\n        return [top[i] for i in range(height)] + [mid[i + height] for i in range(len(mid))] + [bottom[i + height * 2] for i in range(height)]\n\n    stack = []\n    max_height = 0\n    for bracket in sequence:\n        if bracket == '[':\n            stack.append(max_height)\n            max_height = 0\n        else:\n            max_height = max(max_height, stack.pop() + 2)\n    current_height = 0\n    result = []\n    for bracket in sequence:\n        if bracket == '[':\n            result.append(draw(current_height, 0, 0))\n            current_height += 2\n        else:\n            current_height -= 2\n            last_draw = result.pop()\n            new_draw = []\n            for i in range(len(last_draw)):\n                new_draw.append(' ' * (len(result[-1][i]) - len(last_draw[i])) + last_draw[i])\n            result[-1] = [result[-1][i] + new_draw[i] for i in range(len(result[-1]))]\n    final_result = [''.join(row) for row in zip(*result)]\n    return '\\n'.join(final_result)\n\nn = int(input())\nsequence = input().strip()\nprint(draw_brackets(sequence))"}
{"solution": "def normalize_golden_number(golden_number):\n    # Convert the golden number string to a list of integers for easier manipulation\n    golden_number = list(map(int, golden_number))\n    n = len(golden_number)\n    \n    # Normalize the number using the property q^2 = q + 1\n    for i in range(n - 1, 0, -1):\n        if golden_number[i] > 1:\n            golden_number[i] -= 2\n            golden_number[i - 1] += 1\n            if i - 2 >= 0:\n                golden_number[i - 2] += 1\n    \n    # Remove leading zeros\n    while len(golden_number) > 1 and golden_number[0] == 0:\n        golden_number.pop(0)\n    \n    return golden_number\n\ndef compare_golden_numbers(num1, num2):\n    # Normalize both numbers\n    norm_num1 = normalize_golden_number(num1)\n    norm_num2 = normalize_golden_number(num2)\n    \n    # Compare lengths first\n    if len(norm_num1) > len(norm_num2):\n        return \">\"\n    elif len(norm_num1) < len(norm_num2):\n        return \"<\"\n    \n    # If lengths are equal, compare digit by digit\n    for digit1, digit2 in zip(norm_num1, norm_num2):\n        if digit1 > digit2:\n            return \">\"\n        elif digit1 < digit2:\n            return \"<\"\n    \n    # If all digits are equal\n    return \"=\"\n\n# Read input\nnum1 = input().strip()\nnum2 = input().strip()\n\n# Compare the numbers and print the result\nresult = compare_golden_numbers(num1, num2)\nprint(result)"}
{"solution": "gem_colors = {'purple': 'Power', 'green': 'Time', 'blue': 'Space', 'orange': 'Soul', 'red': 'Reality', 'yellow': 'Mind'}\nn = int(input())\nseen_colors = set()\nfor _ in range(n):\n    seen_colors.add(input().strip())\n\nabsent_gems = [gem_colors[color] for color in gem_colors if color not in seen_colors]\n\nprint(len(absent_gems))\nfor gem in absent_gems:\n    print(gem)"}
{"solution": "n, a, b = map(int, input().split())\n\nif a > b:\n    a, b = b, a\n\nmeet_round = 1\nwhile True:\n    if a == b:\n        print(\"Final!\")\n        break\n    elif (a + 1) == b:\n        print(meet_round)\n        break\n    else:\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        meet_round += 1"}
{"solution": "from collections import defaultdict\n\ndef dfs(node, parent, graph, b, visited, cycle):\n    visited[node] = True\n    cycle.append((node, b[node]))\n    \n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            dfs(neighbor, node, graph, b, visited, cycle)\n        elif neighbor != parent:\n            cycle.append((neighbor, b[neighbor]))\n\ndef find_cycles(n, p, b):\n    graph = defaultdict(list)\n    for i in range(n):\n        graph[i].append(p[i] - 1)\n    \n    visited = [False] * n\n    cycles = []\n    \n    for i in range(n):\n        if not visited[i]:\n            cycle = []\n            dfs(i, -1, graph, b, visited, cycle)\n            cycles.append(cycle)\n    \n    return cycles\n\ndef min_changes(n, p, b):\n    cycles = find_cycles(n, p, b)\n    changes = 0\n    \n    for cycle in cycles:\n        cycle_len = len(cycle)\n        if cycle_len % 2 == 0:\n            changes += 1\n        else:\n            odd_cycle = False\n            for _, reverse in cycle:\n                if reverse == 1:\n                    odd_cycle = True\n                    break\n            if not odd_cycle:\n                changes += 1\n    \n    return changes\n\n# Reading input\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(min_changes(n, p, b))"}
{"solution": "def max_path_length(v1, v2, t, d):\n    # Calculate the number of seconds needed to reach the maximum speed\n    acc_time = abs(v1 - v2) // d\n    if abs(v1 - v2) % d != 0:\n        acc_time += 1\n    \n    # Adjust for the case where acceleration time exceeds total time\n    if acc_time > t:\n        acc_time = t\n    \n    # Calculate the distance covered during acceleration/deceleration\n    acc_dist = sum(range(v1, v1 - d * acc_time, -d if v1 > v2 else d))\n    \n    # Calculate the distance covered at constant speed\n    const_speed_time = max(0, t - acc_time)\n    const_dist = v2 * const_speed_time if const_speed_time > 0 else 0\n    \n    # Total distance\n    total_dist = acc_dist + const_dist\n    \n    return total_dist\n\n# Read input\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Calculate and print the result\nprint(max_path_length(v1, v2, t, d))"}
{"solution": "from itertools import permutations\nfrom bisect import bisect_left\n\ndef check(feasible, bridge_weights, camel_weights):\n    for perm in permutations(camel_weights):\n        pos = 0\n        for i in range(len(bridge_weights)):\n            limit = bridge_weights[i]\n            total_weight = 0\n            while pos < len(perm) and total_weight + perm[pos] <= limit:\n                total_weight += perm[pos]\n                pos += 1\n            if pos == len(perm):\n                return True\n        feasible[0] = False\n        break\n\ndef main():\n    N, M = map(int, input().split())\n    camel_weights = list(map(int, input().split()))\n    bridge = [list(map(int, input().split())) for _ in range(M)]\n    \n    # Sort the camel weights and calculate the cumulative sums for bridge weights\n    camel_weights.sort()\n    bridge_weights = sorted([v for _, v in bridge])\n    bridge_lengths = [l for l, _ in bridge]\n    \n    # Check feasibility\n    feasible = [True]\n    check(feasible, bridge_weights, camel_weights)\n    if not feasible[0]:\n        print(-1)\n        return\n    \n    # Calculate minimum distance\n    min_distance = float('inf')\n    for perm in permutations(camel_weights):\n        pos, distance = 0, 0\n        for i in range(M):\n            limit = bridge_weights[i]\n            total_weight = 0\n            while pos < len(perm) and total_weight + perm[pos] <= limit:\n                total_weight += perm[pos]\n                pos += 1\n            if pos > 0:\n                distance += bridge_lengths[i]\n            if pos == len(perm):\n                min_distance = min(min_distance, distance)\n                break\n    print(min_distance if min_distance != float('inf') else -1)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def last_digit_of_factorial_division(a, b):\n    \"\"\"\n    Calculate the last digit of the division of two factorials: b! / a!\n    \"\"\"\n    # For b >= 5 and a >= 5, the result will always end in 0 due to the multiplication by 10 (2*5)\n    # Thus, we only need to consider the cases where a or b is less than 5\n    if b < 5:\n        return 0 if b == a else (b * (b - 1) // (a * (a - 1))) % 10\n    elif a < 5:\n        return (b * (b - 1) * (b - 2) // (6 if a == 3 else 2)) % 10\n    else:\n        return 0\n\na, b = map(int, input().split())\nprint(last_digit_of_factorial_division(a, b))"}
{"solution": "from collections import deque\n\ndef min_jumps_to_home(n, d, s):\n    # Initialize variables\n    queue = deque([(1, 0)])  # (position, jumps)\n    visited = [False] * (n + 1)\n    visited[1] = True\n    \n    while queue:\n        position, jumps = queue.popleft()\n        \n        # Check if we've reached the end\n        if position == n:\n            return jumps + 1\n        \n        # Explore all possible jumps from the current position\n        for jump in range(1, d + 1):\n            next_pos = position + jump\n            \n            # Check if the next position is within bounds and has a lily\n            if next_pos <= n and s[next_pos - 1] == '1' and not visited[next_pos]:\n                visited[next_pos] = True\n                queue.append((next_pos, jumps + 1))\n    \n    # If we exit the loop without reaching the end, it's impossible\n    return -1\n\n# Read input\nn, d = map(int, input().split())\ns = input()\n\n# Calculate and print the result\nprint(min_jumps_to_home(n, d, s))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_counterexample(n):\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\n# Read input\nn = int(input().strip())\n\n# Find and print the counterexample\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all_coins(n):\n    cost_house = 1234567\n    cost_car = 123456\n    cost_computer = 1234\n    \n    for a in range(n // cost_house + 1):\n        for b in range((n - a * cost_house) // cost_car + 1):\n            c = (n - a * cost_house - b * cost_car) / cost_computer\n            if c.is_integer() and c >= 0:\n                return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\n\n# Print output\nprint(can_spend_all_coins(n))"}
{"solution": "def find_intersection(k1, b1, k2, b2):\n    if k1 == k2:\n        return None\n    x = (b2 - b1) / (k1 - k2)\n    y = k1 * x + b1\n    return (x, y)\n\ndef check_intersection_inside_strip(n, x1, x2, lines):\n    for i in range(n):\n        for j in range(i + 1, n):\n            ki, bi = lines[i]\n            kj, bj = lines[j]\n            intersection = find_intersection(ki, bi, kj, bj)\n            if intersection and x1 < intersection[0] < x2:\n                return True\n    return False\n\n# Reading input\nn = int(input())\nx1, x2 = map(int, input().split())\nlines = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Solving the problem\nresult = check_intersection_inside_strip(n, x1, x2, lines)\n\n# Printing the result\nprint(\"Yes\" if result else \"No\")"}
{"solution": "def count_weights(n):\n    max_weight = int((1 + (1 + 8 * n) ** 0.5) // 2)\n    unique_weights = set()\n\n    for weight in range(1, max_weight + 1):\n        if n % weight == 0:\n            unique_weights.add(weight)\n        else:\n            k = 1\n            while True:\n                split_sum = weight * (weight + k) // 2\n                if split_sum > n:\n                    break\n                if (n - split_sum) % k == 0:\n                    unique_weights.add(weight)\n                    break\n                k += 1\n\n    return len(unique_weights)\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the output\nprint(count_weights(n))"}
{"solution": "def find_good_apartments(n, k):\n    if k == 0:\n        min_good = 0\n        max_good = 0\n    else:\n        min_good = 1\n        max_good = min(n - k, 2 * k - 1)\n        if n > k * 2:\n            min_good = 1\n        elif k == 1:\n            min_good = 1\n        else:\n            min_good = 2\n    \n    return min_good, max_good\n\n# Reading input\nn, k = map(int, input().split())\n\nmin_good, max_good = find_good_apartments(n, k)\nprint(min_good, max_good)"}
{"solution": "import math\n\ndef max_games_winner_can_play(n):\n    return math.floor(math.log2(n))\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the result\nprint(max_games_winner_can_play(n))"}
{"solution": "def max_vk_occurrences(s):\n    n = len(s)\n    vk_count = 0\n    v_count = 0\n    k_count = 0 if s[0] == 'V' else 1\n\n    for i in range(n - 1):\n        if s[i] == 'V' and s[i + 1] == 'K':\n            vk_count += 1\n        elif s[i] == 'V':\n            v_count += 1\n        elif s[i + 1] == 'V':\n            k_count += 1\n\n    max_vks = vk_count + min(v_count, k_count)\n\n    # Check if we can add one more \"VK\" by changing the last character if it's \"V\"\n    if s[-1] == 'V':\n        max_vks = max(max_vks, vk_count + k_count)\n\n    return max_vks\n\n# Read input\ns = input()\n\n# Output result\nprint(max_vk_occurrences(s))"}
{"solution": "import math\n\ndef min_segments(n):\n    a = int(math.sqrt(n))\n    b = (n + a - 1) // a\n    return a + b + 2\n\n# Reading input\nn = int(input().strip())\nprint(min_segments(n))"}
{"solution": "a, b = map(int, input().split())\n\nyears = 0\nwhile a <= b:\n    a *= 3\n    b *= 2\n    years += 1\n\nprint(years)"}
{"solution": "def calculate_visited_nodes(h, n):\n    visited = 0\n    position = 1\n    level = 0\n    \n    while position != n:\n        if level < h:\n            # Move left\n            if position * 2 <= 2**h - 1 and position * 2 not in visited:\n                position *= 2\n                visited += 1\n                level += 1\n                command_skipped = False\n            else:  # Skip\n                command_skipped = True\n            \n            # Move right\n            if position + 1 <= 2**h - 1 and position + 1 not in visited:\n                position += 1\n                visited += 1\n                level += 1\n                command_skipped = False\n            else:  # Skip\n                if command_skipped:\n                    level -= 1\n                command_skipped = True\n        \n        else:  # At the bottom level, just move left or right\n            if position < n:\n                position += 1\n                visited += 1\n            elif position > n:\n                position -= 1\n                visited += 1\n            else:\n                break\n    \n    return visited\n\nh, n = map(int, input().split())\nprint(calculate_visited_nodes(h, n))"}
{"solution": "from math import sqrt\n\ndef calculate_pairs(x):\n    result = []\n    for n in range(1, int(sqrt(2 * x)) + 1):\n        for m in range(n, int(sqrt(2 * x)) + 1):\n            total_squares = sum(min(n, m - i) for i in range(m))\n            if total_squares == x:\n                result.append((n, m))\n    return result\n\ndef main():\n    x = int(input())\n    pairs = calculate_pairs(x)\n    \n    print(len(pairs))\n    for pair in pairs:\n        print(*pair)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_leap_year(year):\n    return (year % 400 == 0) or (year % 4 == 0 and year % 100 != 0)\n\ndef is_valid_sequence(durations):\n    feb_days = 28\n    for i in range(1, 1000):  # Check up to 1000 years ahead for leap year\n        if is_leap_year(i):\n            feb_days = 29\n        else:\n            feb_days = 28\n        \n        months = [31, feb_days, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        \n        for start in range(12):\n            valid = True\n            for j in range(len(durations)):\n                if j + start >= len(months):\n                    break  # Not enough months left\n                if durations[j] != months[start + j]:\n                    valid = False\n                    break\n            if valid:\n                return True\n    return False\n\nn = int(input())\ndurations = list(map(int, input().split()))\n\nprint(\"Yes\" if is_valid_sequence(durations) else \"No\")"}
{"solution": "from math import gcd\n\ndef find_sequence(n):\n    def find_divisors(x):\n        divisors = []\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                divisors.append(i)\n                if i * i != x:\n                    divisors.append(x // i)\n        return divisors\n\n    def simplify_fraction(a, b):\n        common_divisor = gcd(a, b)\n        return a // common_divisor, b // common_divisor\n\n    def find_combination(divisors, target):\n        if not divisors:\n            return None\n        divisors_set = set(divisors)\n        for i in range(len(divisors)):\n            for j in range(i + 1, len(divisors)):\n                a, b = divisors[i], divisors[j]\n                if a == b:\n                    continue\n                if (a * b) // n == 1:\n                    return [(a, b)]\n                for c in divisors_set - {a, b}:\n                    if (a * b * c) // n == 1:\n                        return [(a, b), (c, n)]\n        return None\n\n    divisors = find_divisors(n)\n    combination = find_combination(divisors, n)\n\n    if combination is None:\n        return \"NO\"\n    else:\n        result = []\n        remaining = n - 1\n        for a, b in combination:\n            x = remaining * b // n\n            simplified_x, simplified_b = simplify_fraction(x, b)\n            result.append((simplified_x, simplified_b))\n            remaining -= x\n        return \"YES\", len(result), result\n\ndef print_result(result):\n    if result[0] == \"NO\":\n        print(result[0])\n    else:\n        print(result[0])\n        print(result[1])\n        for fraction in result[2]:\n            print(fraction[0], fraction[1])\n\n# Read input\nn = int(input())\n\n# Find and print the result\nresult = find_sequence(n)\nprint_result(result)"}
{"solution": "def min_unattractiveness(n, limits, heights):\n    a, b = limits\n    dp = [[float('inf')] * 2 for _ in range(n + 1)]\n    dp[0][0] = dp[0][1] = 0\n    total_red, total_green = [0] * (n + 1), [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        total_red[i] = total_red[i - 1] + heights[i - 1]\n        total_green[i] = total_green[i - 1] + heights[i - 1]\n        \n        for j in range(2):  # 0 for red, 1 for green\n            for k in range(i):\n                prev_color = 1 - j\n                if total_red[k] <= a and total_green[i] - total_green[k] <= b:\n                    dp[i][j] = min(dp[i][j], dp[k][prev_color] + (1 if prev_color != j else 0))\n                    \n    result = min(dp[n][0], dp[n][1])\n    if result == float('inf'):\n        return -1\n    return result\n\n# Example usage\nif __name__ == \"__main__\":\n    n = int(input())\n    a, b = map(int, input().split())\n    heights = list(map(int, input().split()))\n    print(min_unattractiveness(n, (a, b), heights))"}
{"solution": "def find_triangle_points(n, m, k):\n    area = n * m // k\n    if n * m % k != 0 or area < 0.5 or (n == 1 and m == 1):\n        return \"NO\"\n    \n    if area <= m:\n        return [\"YES\", f\"0 0\", f\"0 {area}\", f\"{n} 0\"]\n    elif area <= n * m / 2:\n        h = area * 2 // n\n        if area * 2 % n != 0:\n            h += 1\n        return [\"YES\", f\"0 0\", f\"{n} 0\", f\"0 {min(h, m)}\"]\n    else:\n        return \"NO\"\n\nn, m, k = map(int, input().split())\nresult = find_triangle_points(n, m, k)\nprint('\\n'.join(map(str, result)))"}
{"solution": "def sasha_wins(n, k):\n    \"\"\"\n    Determines if Sasha wins the game based on the rules provided.\n    \n    Parameters:\n    n (int): The initial number of sticks.\n    k (int): The number of sticks to be crossed out on each turn.\n    \n    Returns:\n    str: \"YES\" if Sasha wins, \"NO\" otherwise.\n    \"\"\"\n    # Since Sasha starts, if the total number of moves (n // k) is odd, Sasha wins.\n    return \"YES\" if (n // k) % 2 else \"NO\"\n\n# Reading input\nn, k = map(int, input().split())\n\n# Printing the result\nprint(sasha_wins(n, k))"}
{"solution": "n = int(input())\nrepetitions = list(map(int, input().split()))\n\nchest = 0\nbiceps = 0\nback = 0\n\nfor i, rep in enumerate(repetitions):\n    if i % 3 == 0:\n        chest += rep\n    elif i % 3 == 1:\n        biceps += rep\n    else:\n        back += rep\n\nif chest > biceps and chest > back:\n    print(\"chest\")\nelif biceps > chest and biceps > back:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "def min_redos_to_get_five(n, grades):\n    current_sum = sum(grades)\n    target_sum = n * 4.5\n    \n    if current_sum >= target_sum:\n        return 0\n    \n    grades.sort()\n    redos = 0\n    \n    for grade in grades:\n        if current_sum >= target_sum:\n            break\n        current_sum += (5 - grade)\n        redos += 1\n    \n    return redos\n\n# Example usage:\nn = int(input())\ngrades = list(map(int, input().split()))\nprint(min_redos_to_get_five(n, grades))"}
{"solution": "from math import log2, ceil\n\ndef find_shortest_array(u, v):\n    if u == 0:\n        if v == 0:\n            return [0]\n        else:\n            return [-1]\n    \n    if v < u:\n        return [-1]\n\n    # Special case when v == u\n    if v == u:\n        return [1, [u]]\n\n    # Calculate the minimum length needed\n    min_length = max(2, ceil(log2(u + 1)))\n    \n    if v >= u * min_length:\n        return [min_length, [u] + [1] * (min_length - 1)]\n    \n    # Find the minimum length greater than 2\n    for n in range(min_length, v // u + 2):\n        if (v - n) % (n - 1) == 0:\n            x = (v - n) // (n - 1)\n            if x <= u:\n                continue\n            arr = [x] * (n - 1) + [v - (n - 1) * x]\n            return [n, arr]\n    \n    return [-1]\n\n# Reading input\nu, v = map(int, input().split())\n\n# Calculating and printing output\nresult = find_shortest_array(u, v)\nif result[0] == -1:\n    print(-1)\nelse:\n    print(result[0])\n    print(' '.join(map(str, result[1])))"}
{"solution": "def min_ones(n):\n    ones_count = 0\n    multipliers = [1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111]\n\n    while n > 0:\n        closest = max(m for m in multipliers if m <= n)\n        n -= closest\n        ones_count += len(str(closest))\n\n    return ones_count\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the result\nprint(min_ones(n))"}
{"solution": "def can_reach_treasure(start, end, potion):\n    x1, y1 = start\n    x2, y2 = end\n    x, y = potion\n    \n    # Calculate the differences in x and y coordinates\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    \n    # Check if the differences can be achieved by the moves\n    if dx % x == 0 and dy % y == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\n# Determine if the treasure can be reached\nresult = can_reach_treasure((x1, y1), (x2, y2), (x, y))\nprint(result)"}
{"solution": "from itertools import permutations\n\ndef count_valid_bus_numbers(n):\n    digits = list(str(n))\n    all_permutations = set(permutations(digits))\n    valid_permutations = {int(''.join(perm)) for perm in all_permutations if perm[0] != '0'}\n    return len(valid_permutations)\n\n# Example usage\nn = int(input().strip())\nresult = count_valid_bus_numbers(n)\nprint(result)"}
{"solution": "def max_suit_cost(a, b, c, d, e, f):\n    # Calculate the maximum possible cost of suits that can be composed.\n    # Suits of the first type consist of one tie and one jacket (cost e).\n    # Suits of the second type consist of one scarf, one vest, and one jacket (cost f).\n    \n    # Determine the number of suits of each type that can be made.\n    suits_first_type = min(a, d)\n    suits_second_type = min(b, c, d)\n    \n    # Calculate the remaining jackets after making suits of the first type.\n    remaining_jackets = d - suits_first_type\n    \n    # Adjust the number of suits of the second type if necessary.\n    suits_second_type = min(suits_second_type, remaining_jackets)\n    \n    # Calculate the total cost.\n    total_cost = (suits_first_type * e) + (suits_second_type * f)\n    \n    return total_cost\n\n# Read input values\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\n# Calculate and print the result\nprint(max_suit_cost(a, b, c, d, e, f))"}
{"solution": "from math import gcd\n\ndef mod_inverse(a, m):\n    m0, y = m, 0\n    x = 1\n    if (m == 1): return 0\n    while (a > 1):\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if (x < 0): x += m0\n    return x\n\ndef order(a, p):\n    phi = p - 1\n    factors = []\n    i = 2\n    while i * i <= phi:\n        if phi % i == 0:\n            factors.append(i)\n            while phi % i == 0:\n                phi //= i\n        i += 1\n    if phi > 1:\n        factors.append(phi)\n    \n    for factor in factors:\n        if pow(a, phi // factor, p) == 1:\n            return -1\n    return phi\n\ndef solve(a, b, p, x):\n    ans = 0\n    if a == 1:\n        if b == 0:\n            return x\n        else:\n            return min(x, (p - 1) // b)\n    \n    ord_a = order(a, p)\n    if ord_a == -1:\n        return 0\n    \n    for k in range(1, min(ord_a + 1, x + 1)):\n        if (b * pow(k, ord_a, p - 1)) % p == ((pow(a, k, p) - 1) % p) * mod_inverse(a - 1, p) % p:\n            ans += 1\n            if x >= k * ord_a:\n                ans += x // (k * ord_a) - 1\n                x %= k * ord_a\n    return ans\n\na, b, p, x = map(int, input().split())\nprint(solve(a, b, p, x))"}
{"solution": "def max_sum(k2, k3, k5, k6):\n    # Calculate the maximum number of 256s that can be formed\n    num_256 = min(k5, k6)\n    num_256 = min(num_256, k2 // 2)\n\n    # Calculate remaining digits after forming 256s\n    k2 -= num_256 * 2\n    k5 -= num_256\n    k6 -= num_256\n\n    # Calculate the maximum number of 32s that can be formed with the remaining digits\n    num_32 = min(k2, k3)\n\n    # Calculate the total sum\n    total_sum = num_256 * 256 + num_32 * 32\n\n    return total_sum\n\n# Read input\nk2, k3, k5, k6 = map(int, input().split())\n\n# Calculate and print the result\nprint(max_sum(k2, k3, k5, k6))"}
{"solution": "import math\n\ndef calculate_seconds(n, x, y, c):\n    total_cells_needed = c - 1\n    if total_cells_needed <= 0:\n        return 0\n    \n    max_radius = min(x - 1, y - 1, n - x, n - y)\n    \n    # Calculate the number of cells covered by the initial radius\n    def cells_covered_by_radius(radius):\n        # Cells added by the square corners\n        corner_cells = 4 * ((radius + 1) ** 2 - (radius ** 2))\n        # Subtract the center cell (if it's inside the grid)\n        if radius > 0:\n            corner_cells -= 1\n        # Cells added by the sides\n        side_cells = 4 * (n - (2 * radius) - 1)\n        return corner_cells + side_cells\n\n    # Binary search for the minimum radius that covers enough cells\n    low, high = 0, max_radius\n    while low < high:\n        mid = (low + high) // 2\n        if cells_covered_by_radius(mid) < total_cells_needed:\n            low = mid + 1\n        else:\n            high = mid\n\n    # Calculate the total number of seconds\n    seconds = low\n    remaining_cells = total_cells_needed - cells_covered_by_radius(low - 1)\n    if remaining_cells > 0:\n        seconds += math.ceil(remaining_cells / (4 * (n - (2 * low))))\n\n    return seconds\n\n# Read input\nn, x, y, c = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_seconds(n, x, y, c))"}
{"solution": "import sys\n\ndef find_max_xor(l, r):\n    shift = 60\n    while (1 << shift) > (r - l + 1):\n        shift -= 1\n    return ((1 << (shift + 1)) - 1) ^ l\n\nl, r = map(int, sys.stdin.readline().split())\nprint(find_max_xor(l, r))"}
{"solution": "def minimum_height(n, k):\n    left, right = 1, k  # The height cannot be more than k because the area is k\n    \n    while left < right:\n        mid = (left + right) // 2\n        if n * mid >= k:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Example usage:\nn = 4\nk = 3\nprint(minimum_height(n, k))  # Output: 1\n\nn = 4\nk = 12\nprint(minimum_height(n, k))  # Output: 3\n\nn = 999999999999999999\nk = 999999999999999986\nprint(minimum_height(n, k))  # Output: 1"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    stairs_time = abs(x - y) * t1\n    \n    elevator_to_masha_time = abs(z - x) * t2 + t3\n    elevator_to_egor_time = abs(x - y) * t2 + 2 * t3\n    elevator_time = elevator_to_masha_time + elevator_to_egor_time\n    \n    if stairs_time < elevator_time:\n        return \"NO\"\n    else:\n        return \"YES\"\n\nx, y, z, t1, t2, t3 = map(int, input().split())\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "def find_optimal_a(n, m):\n    # If m is 1, the best option for Andrew is to choose n.\n    if m == 1:\n        return n\n    # If m is n, the best option for Andrew is to choose 1.\n    elif m == n:\n        return 1\n    else:\n        # Otherwise, the best option is m - 1 to maximize the distance from m.\n        return m - 1\n\n# Reading input\nn, m = map(int, input().split())\n\n# Finding and printing the optimal a\nprint(find_optimal_a(n, m))"}
{"solution": "def alena_university_pairs(n, schedule):\n    stay_count = 0\n    consecutive_zeros = 0\n    \n    # Check if the first pair is 0, Alena starts coming from the first non-zero pair\n    if schedule[0] == 0:\n        consecutive_zeros += 1\n    else:\n        stay_count += 1\n    \n    for i in range(1, n):\n        if schedule[i] == 1:\n            stay_count += 1\n            consecutive_zeros = 0\n        elif schedule[i] == 0:\n            consecutive_zeros += 1\n            # If there are more than one consecutive zeros, Alena goes home\n            if consecutive_zeros > 1:\n                consecutive_zeros = 0\n            else:\n                stay_count += 1\n                \n    return stay_count\n\n# Reading input\nn = int(input())\nschedule = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(alena_university_pairs(n, schedule))"}
{"solution": "def min_days_to_give_candies(n, k, candies):\n    total_candies = 0\n    for day in range(n):\n        total_candies += candies[day]\n        if total_candies >= k:\n            return day + 1\n    return -1\n\nn, k = map(int, input().split())\ncandies = list(map(int, input().split()))\n\nresult = min_days_to_give_candies(n, k, candies)\nprint(result)"}
{"solution": "def minimum_additional_walks(n, k, a):\n    b = a[:]\n    additional_walks = 0\n    \n    for i in range(n - 1):\n        if b[i] + b[i + 1] < k:\n            needed_walks = k - (b[i] + b[i + 1])\n            b[i + 1] += needed_walks\n            additional_walks += needed_walks\n    \n    return additional_walks, b\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nadditional_walks, b = minimum_additional_walks(n, k, a)\n\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "n = int(input())\n\nif n == 1:\n    print(1)\nelse:\n    print(2 * n * n - 1)"}
{"solution": "n = int(input())\ns = input()\n\n# Convert the string to uppercase to simplify comparison\ns = s.upper()\n\n# Create a set to track unique letters\nletters_found = set(s)\n\n# Check if the string is a pangram\nis_pangram = len(letters_found) == 26\n\n# Output the result\nprint(\"YES\" if is_pangram else \"NO\")"}
{"solution": "from datetime import datetime, timedelta\n\ndef time_after_minutes(current_time, minutes):\n    # Convert the current time to a datetime object\n    time_obj = datetime.strptime(current_time, \"%H:%M\")\n    \n    # Add the given number of minutes\n    new_time = time_obj + timedelta(minutes=minutes)\n    \n    # Format the new time back to HH:MM format\n    formatted_new_time = new_time.strftime(\"%H:%M\")\n    \n    return formatted_new_time\n\n# Reading input\ncurrent_time = input()\nminutes = int(input())\n\n# Calculating and printing the new time\nprint(time_after_minutes(current_time, minutes))"}
{"solution": "from collections import defaultdict\n\ndef check_lamps(n, m, switches):\n    # Track which lamps are turned on by all switches except one\n    lamp_count = [0] * m\n    switch_coverage = defaultdict(set)\n    \n    for i in range(n):\n        for j in range(m):\n            if switches[i][j] == '1':\n                lamp_count[j] += 1\n                switch_coverage[i].add(j)\n                \n    # Check if ignoring any switch still turns on all lamps\n    for i in range(n):\n        if all(count > 1 or (count == 1 and j in switch_coverage[i]) for j, count in enumerate(lamp_count)):\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nswitches = [input() for _ in range(n)]\n\n# Output result\nprint(check_lamps(n, m, switches))"}
{"solution": "def min_rotation_time(n, dominoes):\n    top_sum, bottom_sum = 0, 0\n    odd_top, odd_bottom = 0, 0\n    \n    for x, y in dominoes:\n        top_sum += x\n        bottom_sum += y\n        \n        if x % 2 != 0:\n            odd_top += 1\n        if y % 2 != 0:\n            odd_bottom += 1\n    \n    total_sum = top_sum + bottom_sum\n    \n    if total_sum % 2 != 0:\n        return -1\n    \n    if top_sum % 2 == 0 and bottom_sum % 2 == 0:\n        return 0\n    \n    if odd_top == 0 or odd_bottom == 0:\n        return -1\n    \n    if odd_top >= 1 and odd_bottom >= 1:\n        return 1\n    \n    if odd_top + odd_bottom >= 2:\n        return 2\n    \n    return -1\n\n# Example usage\nn = int(input())\ndominoes = [list(map(int, input().split())) for _ in range(n)]\nprint(min_rotation_time(n, dominoes))"}
{"solution": "from math import sqrt\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef remaining_area(a, b):\n    return (a**2 - b**2)\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        a, b = map(int, input().split())\n        area = remaining_area(a, b)\n        if is_prime(area):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nsolve()"}
{"solution": "def can_remove_one_point(n, points):\n    positive_count = 0\n    negative_count = 0\n    \n    for x, y in points:\n        if x > 0:\n            positive_count += 1\n        else:\n            negative_count += 1\n    \n    if positive_count <= 1 or negative_count <= 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Reading input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_remove_one_point(n, points))"}
{"solution": "def gcd_factorials(A, B):\n    min_val = min(A, B)\n    result = 1\n    for i in range(2, min_val + 1):\n        result *= i\n    return result\n\n# Reading input\nA, B = map(int, input().split())\n\n# Calculating and printing the output\nprint(gcd_factorials(A, B))"}
{"solution": "def find_composite_pair(n):\n    # Function to check if a number is composite\n    def is_composite(x):\n        if x < 4:  # 1, 2, and 3 are not composite\n            return False\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                return True\n        return False\n\n    # Start with the smallest composite number that is greater than n\n    a = n + 1\n    while not is_composite(a):\n        a += 1\n\n    # Calculate b based on a\n    b = a - n\n\n    # Ensure b is also composite\n    while not is_composite(b):\n        a += 1\n        b = a - n\n\n    return a, b\n\n\n# Read input\nn = int(input())\n\n# Find and print the composite pair\na, b = find_composite_pair(n)\nprint(a, b)"}
{"solution": "from collections import defaultdict, deque\n\ndef max_score(N, M, P, edges):\n    # Build the graph\n    graph = defaultdict(list)\n    for src, dst, coins in edges:\n        graph[src].append((dst, coins))\n\n    # Initialize DP table\n    dp = [-float('inf')] * (N + 1)\n    dp[1] = 0\n    queue = deque([1])\n\n    # Bellman-Ford Algorithm\n    for _ in range(N - 1):\n        for u in list(queue):\n            queue.remove(u)\n            for v, c in graph[u]:\n                new_score = dp[u] + c\n                if new_score > dp[v]:\n                    dp[v] = new_score\n                    if v != N:\n                        queue.append(v)\n\n    # Check for negative cycles\n    has_negative_cycle = False\n    for u in range(1, N + 1):\n        for v, c in graph[u]:\n            if dp[u] + c > dp[v]:\n                has_negative_cycle = True\n                break\n        if has_negative_cycle:\n            break\n\n    if has_negative_cycle:\n        return -1\n\n    # Calculate the maximum score\n    max_score = dp[N]\n    time_to_N = len(dp) - 2  # Time taken to reach N\n    while max_score >= time_to_N * P:\n        time_to_N += 1\n        for v, c in graph[1]:\n            max_score += c\n    return max_score - time_to_N * P\n\n# Reading input\nN, M, P = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(M)]\n\n# Solving and printing output\nprint(max_score(N, M, P, edges))"}
{"solution": "from collections import defaultdict\nfrom heapq import heappush, heappop\n\ndef min_cost_palindrome(n, strings):\n    char_count = defaultdict(int)\n    odd_chars_cost = []\n    total_cost = 0\n    \n    for s, c in strings:\n        char_freq = defaultdict(int)\n        for char in s:\n            char_freq[char] += 1\n        \n        for char, freq in char_freq.items():\n            if freq % 2 == 1:\n                char_count[char] += 1\n        \n        min_cost = min(c, (len(s) - sum(v % 2 for v in char_freq.values())) * c)\n        total_cost += min_cost\n    \n    for count in char_count.values():\n        if count % 2 == 1:\n            if not odd_chars_cost or count < odd_chars_cost[0]:\n                if odd_chars_cost:\n                    heappush(odd_chars_cost, count)\n                    total_cost += heappop(odd_chars_cost)\n                else:\n                    total_cost += count\n            else:\n                heappush(odd_chars_cost, count)\n    \n    if odd_chars_cost:\n        return -1\n    else:\n        return total_cost\n\n# Reading input\nn = int(input())\nstrings = [input().split() for _ in range(n)]\nstrings = [(s, int(c)) for s, c in strings]\n\n# Calculating and printing the result\nprint(min_cost_palindrome(n, strings))"}
{"solution": "def largest_xor_sum(n, k):\n    # Find the number of bits in n\n    num_bits = n.bit_length()\n    # The largest possible xor-sum\n    max_xor_sum = (1 << num_bits) - 1\n    return max_xor_sum\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(largest_xor_sum(n, k))"}
{"solution": "import heapq\n\ndef min_isosceles_side(n, points):\n    # Use a min heap to keep track of the maximum x and y values encountered so far.\n    max_x_heap = []\n    max_y_heap = []\n\n    for x, y in points:\n        # Add the negative value to maintain a min heap, but store the positive value for later use.\n        heapq.heappush(max_x_heap, -x)\n        heapq.heappush(max_y_heap, -y)\n\n        # Ensure the heap size does not exceed 1, keeping only the largest value.\n        if len(max_x_heap) > 1:\n            heapq.heappop(max_x_heap)\n        if len(max_y_heap) > 1:\n            heapq.heappop(max_y_heap)\n\n    # Convert the top elements back to positive to get the maximum x and y values.\n    max_x = -max_x_heap[0]\n    max_y = -max_y_heap[0]\n\n    # The minimum length of the shorter side of the triangle is the maximum of max_x and max_y.\n    return max(max_x, max_y)\n\n# Reading input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculating and printing the output\nprint(min_isosceles_side(n, points))"}
{"solution": "from collections import Counter\n\ndef max_nineteens(s):\n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # Define the required frequency of each character in the word \"nineteen\"\n    required_counts = {'n': 3, 'i': 1, 'e': 3, 't': 1}\n    \n    # Calculate the maximum number of \"nineteen\" words that can be formed\n    max_nineteens = float('inf')\n    for char, required in required_counts.items():\n        if char in char_count:\n            max_nineteens = min(max_nineteens, char_count[char] // required)\n        else:\n            return 0  # If any required character is missing, we can't form \"nineteen\"\n    \n    return max_nineteens\n\n# Reading input\ns = input()\n\n# Calculating and printing the result\nprint(max_nineteens(s))"}
{"solution": "import math\n\ndef find_highest_unreachable_branch(p, y):\n    if p == y:\n        return -1\n    if p == y - 1:\n        return y\n    sqrt_y = int(math.sqrt(y))\n    if p <= sqrt_y:\n        return y\n    else:\n        max_unreachable = y // 2 + 1\n        for i in range(sqrt_y, 1, -1):\n            if p < i * i:\n                break\n            max_unreachable = min(max_unreachable, y // i)\n        return max_unreachable if max_unreachable > p else -1\n\n# Reading input\np, y = map(int, input().split())\n\n# Calculating and printing output\nprint(find_highest_unreachable_branch(p, y))"}
{"solution": "def min_distance_to_affordable_house(n, m, k, prices):\n    # Filter affordable houses and calculate distances\n    affordable_houses = [(i, abs(i - m) * 10) for i, price in enumerate(prices, 1) if price > 0 and price <= k]\n    \n    # Find the closest affordable house\n    closest_distance = min(affordable_houses, key=lambda x: x[1], default=(0, float('inf')))[1]\n    \n    return closest_distance\n\n# Reading input\nn, m, k = map(int, input().split())\nprices = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(min_distance_to_affordable_house(n, m, k, prices))"}
{"solution": "def can_transform(A, B):\n    def sort_rows_and_cols(matrix):\n        rows = sorted([tuple(row) for row in matrix])\n        cols = sorted([tuple(col) for col in zip(*matrix)])\n        return rows, cols\n\n    A_rows, A_cols = sort_rows_and_cols(A)\n    B_rows, B_cols = sort_rows_and_cols(B)\n\n    return A_rows == B_rows and A_cols == B_cols\n\ndef read_matrix(n, m):\n    return [list(map(int, input().split())) for _ in range(n)]\n\nn, m = map(int, input().split())\nA = read_matrix(n, m)\nB = read_matrix(n, m)\n\nprint(\"YES\" if can_transform(A, B) else \"NO\")"}
{"solution": "def longest_uncommon_subsequence_length(a, b):\n    if a == b:\n        return -1\n    else:\n        return max(len(a), len(b))\n\n# Reading input strings\na = input().strip()\nb = input().strip()\n\n# Calculating and printing the result\nprint(longest_uncommon_subsequence_length(a, b))"}
{"solution": "def find_scream_time(a, b, c, d):\n    gcd = lambda x, y: x if not y else gcd(y, x % y)\n    lcm = lambda x, y: x * y // gcd(x, y)\n    \n    if a == c:\n        if (b - d) % a == 0:\n            return min(b, d) + abs(b - d)\n        else:\n            return -1\n    \n    t = lcm(a, c)\n    \n    if (t + b - d) % a == 0 and (t + d - b) % c == 0:\n        return t + max(b, d)\n    else:\n        return -1\n\n# Reading input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculating and printing output\nprint(find_scream_time(a, b, c, d))"}
{"solution": "n = int(input())\n\n# INTJ Approach: Determine the base values for a, b, and c\n# We aim to divide n as evenly as possible among a, b, and c,\n# while ensuring none of them is a multiple of 3.\nbase_value = n // 3\n\n# Adjusting the values to avoid multiples of 3\nif base_value % 3 == 0:\n    # If the base value is a multiple of 3, adjust a and b to be 1 less than the base value\n    # and c to be 2 more than the base value to maintain the sum.\n    a = base_value - 1\n    b = base_value - 1\n    c = base_value + 2\nelif (base_value + 1) % 3 == 0:\n    # If adding 1 to the base value makes it a multiple of 3, adjust a and b to be the base value\n    # and c to be 1 more than the base value.\n    a = base_value\n    b = base_value\n    c = base_value + 1\nelse:\n    # If neither the base value nor adding 1 to it makes it a multiple of 3,\n    # we can simply assign the base value to a and b, and the remainder to c.\n    a = base_value\n    b = base_value\n    c = n - a - b\n\nprint(a, b, c)"}
{"solution": "def count_possible_paintings(n, a, b, c, d):\n    total_count = 0\n    max_sum = 2 * a + b + c\n    \n    for x11 in range(1, n + 1):\n        for x12 in range(1, n + 1):\n            for x21 in range(1, n + 1):\n                for x22 in range(1, n + 1):\n                    # Calculate the sum of the top-left 2x2 square\n                    sum_top_left = x11 + x12 + x21 + x22\n                    \n                    # Check if the sum matches the condition for all 2x2 squares\n                    if sum_top_left == 2 * (a + b) and x12 == a and x21 == b:\n                        # Calculate the remaining values based on the sum\n                        x13 = sum_top_left - x11 - x12\n                        x23 = sum_top_left - x12 - x22\n                        x31 = sum_top_left - x21 - x22\n                        x32 = sum_top_left - x21 - x12\n                        x33 = sum_top_left - x22 - x13\n                        \n                        # Check if all calculated values are within the allowed range\n                        if (0 < x13 <= n and 0 < x23 <= n and 0 < x31 <= n and\n                                0 < x32 <= n and 0 < x33 <= n and x32 == d and x23 == c):\n                            total_count += 1\n                            \n    return total_count\n\n# Read input\nn, a, b, c, d = map(int, input().split())\n\n# Calculate and print the result\nprint(count_possible_paintings(n, a, b, c, d))"}
{"solution": "def final_snowball_weight(w, h, u1, d1, u2, d2):\n    def hit_stone(weight, height, u, d):\n        if height == d:\n            weight = max(0, weight - u)\n        return weight\n\n    # Ensure d1 < d2 for processing\n    if d1 > d2:\n        d1, d2 = d2, d1\n        u1, u2 = u2, u1\n\n    while h > 0:\n        w += h\n        w = hit_stone(w, h, u1, d1)\n        w = hit_stone(w, h, u2, d2)\n        h -= 1\n\n    return w\n\n# Reading input\nw, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\n# Calculating and printing the output\nprint(final_snowball_weight(w, h, u1, d1, u2, d2))"}
{"solution": "def find_passing_rate(m, scores, min_max):\n    def valid_passing_rate(k):\n        beginners = sum(scores[:k])\n        intermediates = sum(scores[k:])\n        return min_max[0] <= beginners <= min_max[1] and min_max[0] <= intermediates <= min_max[1]\n\n    for k in range(m, 0, -1):\n        if valid_passing_rate(k):\n            return k\n    return 0\n\n# Reading input\nm = int(input())\nc = list(map(int, input().split()))\nx, y = map(int, input().split())\n\n# Solving and printing output\nprint(find_passing_rate(m, c, (x, y)))"}
{"solution": "def min_cost(n, k, A, B):\n    costs = [0] * (n + 1)\n    operations = [0] * (n + 1)\n\n    def calculate_cost(x):\n        if x == 1:\n            return 0\n        if operations[x] != 0:\n            return operations[x]\n        cost_subtract = A + calculate_cost(x - 1)\n        cost_divide = float('inf') if x % k else B + calculate_cost(x // k)\n        costs[x] = min(cost_subtract, cost_divide)\n        operations[x] = costs[x]\n        return costs[x]\n\n    return calculate_cost(n)\n\n# Reading inputs\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\n# Calculating and printing the result\nprint(min_cost(n, k, A, B))"}
{"solution": "import math\n\ndef min_value_and_operations(n):\n    operations = 0\n    prime_factors = []\n    \n    # Factorize n into its prime factors\n    while n % 2 == 0:\n        prime_factors.append(2)\n        n //= 2\n    \n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            prime_factors.append(factor)\n            n //= factor\n        factor += 2\n    \n    if n > 1:\n        prime_factors.append(n)\n    \n    # Group the prime factors into square roots\n    square_roots = []\n    current_factor = None\n    count = 0\n    for factor in prime_factors:\n        if factor != current_factor:\n            if count > 0:\n                square_roots.append((current_factor, count))\n            current_factor = factor\n            count = 1\n        else:\n            count += 1\n    if count > 0:\n        square_roots.append((current_factor, count))\n    \n    # Minimize the value by taking square roots\n    minimized_value = 1\n    operations = 0\n    for factor, count in square_roots:\n        sqrt_count = count // 2\n        mul_count = count % 2\n        minimized_value *= factor ** mul_count\n        operations += sqrt_count\n    \n    return minimized_value, operations\n\n# Read input\nn = int(input())\n\n# Calculate and print the result\nresult = min_value_and_operations(n)\nprint(*result)"}
{"solution": "import sys\n\ndef max_score(N, K, RSP, T):\n    dp = [[0, 0, 0] for _ in range(N + 1)]\n    dp[0][0], dp[0][1], dp[0][2] = -RSP[0], -RSP[1], -RSP[2]\n    \n    for i in range(1, N + 1):\n        win_points = [0, 0, 0]\n        win_points[0] = RSP[1] if T[i - 1] == 'p' else RSP[2] if T[i - 1] == 's' else 0\n        win_points[1] = RSP[2] if T[i - 1] == 'r' else RSP[0] if T[i - 1] == 's' else 0\n        win_points[2] = RSP[0] if T[i - 1] == 'p' else RSP[1] if T[i - 1] == 'r' else 0\n        \n        for j in range(3):\n            if i <= K:\n                dp[i][j] = max(dp[i - 1][(j + 1) % 3], dp[i - 1][(j + 2) % 3]) + win_points[j]\n            else:\n                dp[i][j] = max(dp[i - 1][(j + 1) % 3], dp[i - 1][(j + 2) % 3], dp[i - K][j]) + win_points[j]\n    \n    return max(dp[N])\n\n# Reading input\nN, K = map(int, input().split())\nR, S, P = map(int, input().split())\nT = input()\n\n# Calculating and printing the result\nprint(max_score(N, K, [R, S, P], T))"}
{"solution": "def longest_good_string(a, b, c):\n    return min(a, b) * 2 + max(a, b) + c * 2\n\n# Example usage\nif __name__ == \"__main__\":\n    a, b, c = map(int, input().split())\n    print(longest_good_string(a, b, c))"}
{"solution": "def find_marks(n, k, p, x, y, marks):\n    total_marks = sum(marks)\n    remaining_marks = n - k\n    needed_marks = min(p, y) * ((n + 1) // 2 - k)\n    \n    # Check if it's possible to meet the conditions\n    if total_marks + needed_marks > x or (k != 0 and marks[-1] < y):\n        return [-1]\n    \n    # Calculate the marks needed to not exceed x\n    max_possible = x - total_marks\n    marks_needed = [min(max_possible - sum(marks[k:]), p)] * remaining_marks\n    \n    # Adjust marks to ensure the median is at least y\n    for i in range(remaining_marks):\n        if len(marks) % 2 == 1 and (n // 2 - (k + i)) == 0 and marks[n // 2] < y:\n            marks_needed[i] = max(marks_needed[i], y)\n        else:\n            marks_needed[i] = max(1, marks_needed[i])\n    \n    # Final check\n    if sum(marks + marks_needed) > x or (len(marks) % 2 == 1 and (marks + marks_needed)[n // 2] < y):\n        return [-1]\n    \n    return marks_needed\n\n# Reading input\nn, k, p, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Solving and printing output\nresult = find_marks(n, k, p, x, y, marks)\nprint(*result)"}
{"solution": "def is_berlanese(word):\n    vowels = \"aeiou\"\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    \n    prev_char = None\n    for char in word:\n        if char in consonants and prev_char != 'n':\n            if char not in vowels:\n                return \"NO\"\n        prev_char = char\n    return \"YES\"\n\n# Reading input\nword = input()\n\n# Printing output\nprint(is_berlanese(word))"}
{"solution": "from collections import defaultdict\n\ndef max_dominoes_on_graph(n, edges):\n    \"\"\"\n    Calculate the maximum number of dominoes that can be placed on the graph edges\n    following the given rules.\n    \"\"\"\n    # Initialize adjacency list\n    adj_list = defaultdict(set)\n    for u, v in edges:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n\n    # Initialize degrees for each vertex\n    degrees = {vertex: 0 for vertex in range(1, n + 1)}\n    \n    # Calculate degrees\n    for u, v in edges:\n        degrees[u] += 1\n        degrees[v] += 1\n    \n    # Calculate the maximum number of dominoes\n    max_dominoes = 0\n    for vertex, deg in degrees.items():\n        # For each vertex, find the maximum number of dominoes\n        # that can be placed with the current vertex as an endpoint\n        max_dominoes_vertex = 0\n        seen = set()\n        for neighbor in adj_list[vertex]:\n            # Check if the neighbor has not been considered yet\n            if neighbor not in seen:\n                seen.add(neighbor)\n                seen.add(vertex)\n                common_neighbors = adj_list[vertex] & adj_list[neighbor]\n                # Calculate the minimum degree among the common neighbors\n                min_deg = min(degrees[nbr] for nbr in common_neighbors) if common_neighbors else 0\n                # Update the maximum number of dominoes\n                max_dominoes_vertex += min_deg + 1\n        # Add the result for the current vertex to the total\n        max_dominoes += max_dominoes_vertex // 2\n\n    return max_dominoes\n\n# Reading input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output the result\nprint(max_dominoes_on_graph(n, edges))"}
{"solution": "from typing import List\n\ndef max_points(n: int, m: int, prices: List[int], auctions: List[int]) -> int:\n    auctions.sort()\n    non_auctions = sorted((price for idx, price in enumerate(prices) if idx not in auctions), reverse=True)\n    \n    auction_indices = [prices.index(price) for price in auctions]\n    auction_prices = sorted(prices[idx] for idx in auction_indices)\n    \n    def dfs(index, available, current_points):\n        if index == len(auction_prices):\n            return 0\n        \n        max_points = dfs(index + 1, available, current_points)\n        \n        if available > 0 and current_points > auction_prices[index]:\n            updated_points = current_points - auction_prices[index] + max(available, auction_prices[index])\n            max_points = max(max_points, updated_points + dfs(index + 1, available - 1, updated_points))\n        \n        return max_points\n    \n    initial_points = sum(non_auctions[:min(len(non_auctions), m)])\n    return initial_points + dfs(0, m, initial_points)\n\n# Reading input\nn, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauctions = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(max_points(n, m, prices, auctions))"}
{"solution": "def calculate_score(submission_times, wrong_submissions, successful_hacks, unsuccessful_hacks):\n    base_scores = [500, 1000, 1500, 2000, 2500]\n    total_score = 0\n    \n    for i in range(5):\n        score = max(0.3 * base_scores[i], (1 - submission_times[i] / 250) * base_scores[i] - 50 * wrong_submissions[i])\n        total_score += int(score)\n    \n    total_score += successful_hacks * 100 - unsuccessful_hacks * 50\n    \n    return total_score\n\n# Reading input\nsubmission_times = list(map(int, input().split()))\nwrong_submissions = list(map(int, input().split()))\nsuccessful_hacks, unsuccessful_hacks = map(int, input().split())\n\n# Calculating and printing the final score\nprint(calculate_score(submission_times, wrong_submissions, successful_hacks, unsuccessful_hacks))"}
{"solution": "from math import gcd\n\nMOD = 998244353\n\ndef mod_pow(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef solve(n, m, L, R):\n    if n == 1 or m == 1:\n        return ((mod_pow(R - L + 1, n * m) - mod_pow(max(0, R - 2 * L), n * m) * 2 -\n                 mod_pow(max(0, R - 2 * L + 1), n * m) + mod_pow(max(0, R - 2 * L + 2), n * m)) % MOD +\n                MOD) % MOD\n    else:\n        lcm = n * m // gcd(n, m)\n        return ((mod_pow(R - L + 1, n * m) - mod_pow(max(0, R - 2 * L), n * m) * 2 -\n                 mod_pow(max(0, R - 2 * L + 1), n * m) + mod_pow(max(0, R - 2 * L + 2), n * m)) % MOD +\n                MOD) % MOD - (mod_pow(max(0, R - L * lcm), lcm) - mod_pow(max(0, R - (L + 1) * lcm), lcm)) % MOD\n\nn, m, L, R = map(int, input().split())\nprint(solve(n, m, L, R))"}
{"solution": "def is_possible_to_make_increasing(n, m, matrix_a, matrix_b):\n    for i in range(n):\n        for j in range(m):\n            # Ensure that matrix_a[i][j] is the smaller or equal element\n            if matrix_a[i][j] > matrix_b[i][j]:\n                matrix_a[i][j], matrix_b[i][j] = matrix_b[i][j], matrix_a[i][j]\n    \n    # Check rows for strictly increasing property\n    for i in range(n):\n        for j in range(1, m):\n            if matrix_a[i][j] <= matrix_a[i][j-1] or matrix_b[i][j] <= matrix_b[i][j-1]:\n                return \"Impossible\"\n    \n    # Check columns for strictly increasing property\n    for j in range(m):\n        for i in range(1, n):\n            if matrix_a[i][j] <= matrix_a[i-1][j] or matrix_b[i][j] <= matrix_b[i-1][j]:\n                return \"Impossible\"\n    \n    return \"Possible\"\n\n# Example usage:\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\nmatrix_b = [list(map(int, input().split())) for _ in range(n)]\n\nprint(is_possible_to_make_increasing(n, m, matrix_a, matrix_b))"}
{"solution": "from heapq import heappush, heappop\n\ndef max_string_length(n, limits):\n    # Initialize a min heap for the limits and a max heap for the unique counts\n    limits_heap = []\n    unique_counts_heap = []\n    \n    # Add all limits to the min heap\n    for limit in limits:\n        heappush(limits_heap, limit)\n    \n    # Initialize the answer\n    answer = 0\n    \n    while limits_heap:\n        # Pop the smallest limit\n        current_limit = heappop(limits_heap)\n        \n        # If there are no unique counts yet or the smallest unique count is greater than the current limit\n        if not unique_counts_heap or (-unique_counts_heap[0] > current_limit):\n            # Add the current limit as a new unique count\n            heappush(unique_counts_heap, -current_limit)\n            answer += current_limit\n        else:\n            # Find the smallest unique count that can be paired with the current limit\n            unique_count = -heappop(unique_counts_heap)\n            # Calculate the maximum number of characters we can use from the current limit\n            use_count = min(current_limit, unique_count + 1)\n            # Update the unique count heap\n            heappush(unique_counts_heap, -(unique_count + 1))\n            # Add the used count to the answer\n            answer += use_count\n            # Push back the remaining limit if it's greater than 0\n            if current_limit > use_count:\n                heappush(limits_heap, current_limit - use_count)\n    \n    return answer\n\n# Read input\nn = int(input())\nlimits = list(map(int, input().split()))\n\n# Print the result\nprint(max_string_length(n, limits))"}
{"solution": "from collections import Counter\n\ndef min_extra_problems(n, k, difficulties):\n    extra_problems = 0\n    difficulty_counter = Counter(difficulties)\n    \n    # Initialize the current max difficulty that can be solved\n    max_difficulty = k\n    \n    for difficulty in difficulties:\n        required_difficulty = difficulty // 2\n        if difficulty > max_difficulty:\n            found = False\n            for d in range(required_difficulty, max_difficulty + 1):\n                if difficulty_counter[d] > 0:\n                    max_difficulty = difficulty\n                    found = True\n                    break\n            if not found:\n                # Need to solve an extra problem on another judge\n                extra_problems += 1\n                max_difficulty = max(max_difficulty, required_difficulty)\n                \n    return extra_problems\n\n# Read input\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_extra_problems(n, k, difficulties))"}
{"solution": "def distribute_diplomas(n, min_max_1, min_max_2, min_max_3):\n    min_1, max_1 = min_max_1\n    min_2, max_2 = min_max_2\n    min_3, max_3 = min_max_3\n    \n    # Ensure the distribution meets the constraints\n    first = max(min_1, n - max_2 - max_3)\n    first = min(first, max_1)\n    \n    remaining_after_first = n - first\n    second = max(min_2, remaining_after_first - max_3)\n    second = min(second, max_2)\n    \n    third = remaining_after_first - second\n    \n    return first, second, third\n\n# Reading input\nn = int(input())\nmin_max_1 = list(map(int, input().split()))\nmin_max_2 = list(map(int, input().split()))\nmin_max_3 = list(map(int, input().split()))\n\n# Calculating and printing the result\nresult = distribute_diplomas(n, min_max_1, min_max_2, min_max_3)\nprint(*result)"}
{"solution": "n = int(input())\nobservations = list(map(int, input().split()))\n\n# Moon cycle\nmoon_cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n              14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n\n# Find the starting point in the cycle\nstart_index = moon_cycle.index(observations[0])\n\n# Check if the sequence matches the moon cycle\nmatch_start = start_index\nmatch_end = start_index + len(observations)\n\n# Adjust for wrapping\nif match_end > len(moon_cycle):\n    match_end -= len(moon_cycle)\n\n# Verify if the observed sequence matches the moon cycle\nif moon_cycle[match_start:match_end] == observations:\n    # Check the next day\n    next_day_size = moon_cycle[start_index + len(observations)]\n    if next_day_size < observations[-1]:\n        print(\"DOWN\")\n    elif next_day_size > observations[-1]:\n        print(\"UP\")\n    else:\n        print(-1)\nelse:\n    print(-1)"}
{"solution": "def can_transform(s, t):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    if len(s) != len(t):\n        return \"No\"\n    \n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels) != (char_t in vowels):\n            return \"No\"\n    \n    return \"Yes\"\n\n# Reading input\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(can_transform(s, t))"}
{"solution": "import sys\n\ndef find_closest_pawn(pawns, target_row, step):\n    closest = None\n    min_distance = 9  # Since the board size is 8x8, the maximum distance is 7.\n    for pawn in pawns:\n        distance = abs(pawn[0] - target_row)\n        if distance < min_distance:\n            min_distance = distance\n            closest = pawn\n    return closest[0] + step\n\ndef determine_winner(board):\n    white_pawns = []\n    black_pawns = []\n    \n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'W':\n                white_pawns.append((i, j))\n            elif board[i][j] == 'B':\n                black_pawns.append((i, j))\n                \n    closest_white = find_closest_pawn(white_pawns, 0, -1)\n    closest_black = find_closest_pawn(black_pawns, 7, 1)\n    \n    if closest_white <= closest_black:\n        return 'A'\n    else:\n        return 'B'\n\n# Read input\nboard = [list(sys.stdin.readline().strip()) for _ in range(8)]\n\n# Determine and print the winner\nprint(determine_winner(board))"}
{"solution": "def max_equal_length(n, A, m, B):\n    if sum(A) != sum(B):\n        return -1\n    \n    i, j = 0, 0\n    sumA, sumB = 0, 0\n    count = 0\n    \n    while i < n and j < m:\n        sumA += A[i]\n        sumB += B[j]\n        \n        if sumA == sumB:\n            count += 1\n            sumA = 0\n            sumB = 0\n            i += 1\n            j += 1\n        elif sumA < sumB:\n            i += 1\n        else:\n            j += 1\n    \n    return count\n\n# Example usage:\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\nprint(max_equal_length(n, A, m, B))"}
{"solution": "def is_alex_friend_problem(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    count = 0\n    for friend in friends:\n        if friend in problem_name:\n            count += 1\n    return \"YES\" if count == 1 else \"NO\"\n\n# Reading input\nproblem_name = input()\n\n# Processing and printing output\nprint(is_alex_friend_problem(problem_name))"}
{"solution": "def sieve(n):\n    is_prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (is_prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n    is_prime[0], is_prime[1] = False, False  # 0 and 1 are not primes\n    return is_prime\n\ndef count_primes_in_range(is_prime, a, b):\n    prime_count = [0] * (b + 1)\n    for i in range(a, b + 1):\n        prime_count[i] = prime_count[i - 1] + (1 if is_prime[i] else 0)\n    return prime_count\n\ndef min_length_with_k_primes(a, b, k):\n    is_prime = sieve(b)\n    prime_count = count_primes_in_range(is_prime, a, b)\n    \n    def has_k_primes_in_length(l):\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] >= k:\n                return True\n        return False\n    \n    left, right = 1, b - a + 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if has_k_primes_in_length(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\n# Input\na, b, k = map(int, input().split())\n\n# Output\nprint(min_length_with_k_primes(a, b, k))"}
{"solution": "from math import gcd\n\ndef find_min_x(a, h, w):\n    def can_place_photos(rows, cols, x):\n        vertical_fit = (h - (rows - 1) * x) % (a + x) == 0\n        horizontal_fit = (w - (cols - 1) * x) % (a + x) == 0\n        return vertical_fit and horizontal_fit\n\n    def binary_search(min_x, max_x):\n        while max_x - min_x > 1e-6:\n            mid_x = (min_x + max_x) / 2\n            if can_place_photos(*find_possible_grid(mid_x), mid_x):\n                max_x = mid_x\n            else:\n                min_x = mid_x\n        return max_x\n\n    def find_possible_grid(x):\n        for i in range(1, 1000000000 // (a + x) + 1):\n            for j in range(1, 1000000000 // (a + x) + 1):\n                if can_place_photos(i, j, x):\n                    return i, j\n        return None\n\n    common_divisor = gcd(h, w)\n    if a > common_divisor:\n        return -1\n\n    min_x, max_x = 0, min(h, w)\n    possible_grid = find_possible_grid(0)\n    if possible_grid is None:\n        return -1\n\n    return binary_search(min_x, max_x)\n\n# Example usage\na, h, w = map(int, input().split())\nprint(find_min_x(a, h, w))"}
{"solution": "n = int(input())\nchapters = []\nfor _ in range(n):\n    l, r = map(int, input().split())\n    chapters.append((l, r))\nk = int(input())\n\nunread_chapters = 0\nfor l, r in chapters:\n    if k > r:\n        continue\n    else:\n        unread_chapters += 1\n        if k < l:\n            break\n\nprint(unread_chapters)"}
{"solution": "def can_form_codeforces(word):\n    target = \"CODEFORCES\"\n    n = len(word)\n    m = len(target)\n    \n    if n < m:\n        return \"NO\"\n    \n    for i in range(m + 1):\n        if word[:i] == target[:i] and word[n - (m - i):] == target[i:]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Reading input\nword = input().strip()\n\n# Printing output\nprint(can_form_codeforces(word))"}
{"solution": "def min_weight_triangulation(n):\n    dp = [[0] * n for _ in range(n)]\n    \n    def calculate(i, j):\n        if j - i < 2:\n            return 0\n        if dp[i][j] == 0:\n            dp[i][j] = float('inf')\n            for k in range(i + 1, j):\n                weight = k * i * j if j - i == 2 else k * i * j + calculate(i, k) + calculate(k, j)\n                dp[i][j] = min(dp[i][j], weight)\n        return dp[i][j]\n    \n    return calculate(0, n - 1)\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the output\nprint(min_weight_triangulation(n))"}
{"solution": "def count_digits(n):\n    if n < 10:\n        return n\n    digits = 1\n    while 9 * (10 ** (digits - 1)) * digits < n:\n        n -= 9 * (10 ** (digits - 1)) * digits\n        digits += 1\n    start_number = 10 ** (digits - 1)\n    return n + digits * (n // digits + start_number)\n\n# Reading input\nn = int(input())\n\n# Calculating and printing output\nprint(count_digits(n))"}
{"solution": "from collections import defaultdict\n\ndef find_bobs_winning_color():\n    n, alice_color = map(int, input().split())\n    car_colors = list(map(int, input().split()))\n\n    # Initialize variables to track Bob's potential winning color and its score.\n    bobs_color = -1\n    max_score = -1\n\n    # Track the maximum difference in favor of Alice up to the current car.\n    max_diff_alice = 0\n\n    # Dictionary to keep track of the cumulative advantage Bob has over Alice for each color.\n    bobs_advantage = defaultdict(int)\n\n    # Iterate through each car to update the scores and determine Bob's winning strategy.\n    for car in car_colors:\n        if car == alice_color:\n            # If the current car is Alice's color, decrease Bob's advantage for all colors.\n            for color in bobs_advantage:\n                bobs_advantage[color] -= 1\n                max_diff_alice += 1\n                # Update Bob's winning color if he gains a higher advantage.\n                if bobs_advantage[color] > max_score and max_diff_alice <= 0:\n                    max_score = bobs_advantage[color]\n                    bobs_color = color\n        else:\n            # If the current car is not Alice's color, increase Bob's advantage for this color.\n            bobs_advantage[car] += 1\n            if max_diff_alice > 0:\n                max_diff_alice -= 1\n\n    # Check if Bob can win with a color different from Alice's.\n    if bobs_color == alice_color:\n        bobs_color = -1\n\n    print(bobs_color)\n\n# Call the function to solve the problem.\nfind_bobs_winning_color()"}
{"solution": "import sys\n\nn, x = map(int, input().split())\na = list(map(int, sys.stdin.readline().split()))\n\nzeros = x - sum(a)\nif zeros < n - 1:\n    print(\"NO\")\nelif zeros == 0 and len(a) != 1:\n    print(\"NO\")\nelse:\n    print(\"YES\" if zeros >= n - 1 else \"NO\")"}
{"solution": "def min_coins(n, S):\n    dp = [0] + [float('inf')] * S\n    for s in range(1, S + 1):\n        for coin in range(1, min(n + 1, s) + 1):\n            dp[s] = min(dp[s], dp[s - coin] + 1)\n    return dp[S]\n\n# Reading input\nn, S = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_coins(n, S))"}
{"solution": "from collections import Counter\n\ndef smallest_palindrome(s):\n    char_count = Counter(s)\n    left_half = []\n    middle_char = ''\n    \n    # Collect characters for the left half and find the middle character if needed\n    for char, count in sorted(char_count.items()):\n        if count % 2:\n            if middle_char:\n                # If we already have a middle character, use this one instead to minimize lexicographically\n                middle_char = char\n            else:\n                middle_char = char\n            count -= 1\n        left_half.extend([char] * (count // 2))\n    \n    # Construct the left half and the full palindrome\n    left_half = ''.join(left_half)\n    full_palindrome = left_half + middle_char + left_half[::-1]\n    \n    return full_palindrome\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(smallest_palindrome(s))"}
{"solution": "def calculate_weight(board):\n    piece_weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': -9, 'r': -5, 'b': -3, 'n': -3, 'p': -1\n    }\n    \n    total_weight = 0\n    \n    for row in board:\n        for piece in row:\n            total_weight += piece_weights.get(piece, 0)\n    \n    if total_weight > 0:\n        return \"White\"\n    elif total_weight < 0:\n        return \"Black\"\n    else:\n        return \"Draw\"\n\n# Example usage is not needed as per instruction, but the function is ready for use."}
{"solution": "from collections import deque, defaultdict\n\ndef solve_game(N, M, S):\n    # Check if it's possible to win from a position\n    def can_win(pos):\n        if pos == N:\n            return True\n        if S[pos] == '1':\n            return False\n        for move in range(1, M + 1):\n            if pos + move <= N and can_win(pos + move):\n                return True\n        return False\n\n    # Find the shortest path using BFS\n    def shortest_path():\n        queue = deque([(0, [])])\n        visited = [False] * (N + 1)\n        visited[0] = True\n        while queue:\n            pos, path = queue.popleft()\n            if pos == N:\n                return path\n            for move in range(1, M + 1):\n                next_pos = pos + move\n                if next_pos <= N and not visited[next_pos] and S[next_pos] == '0':\n                    visited[next_pos] = True\n                    queue.append((next_pos, path + [move]))\n        return None\n\n    # Check if winning is possible\n    if not can_win(0):\n        return -1\n\n    # Find the shortest path\n    path = shortest_path()\n\n    # Return the result\n    return ' '.join(map(str, path)) if path else -1\n\n# Read input\nN, M = map(int, input().split())\nS = input()\n\n# Solve and print the result\nprint(solve_game(N, M, S))"}
{"solution": "import math\n\ndef solve(K, X, Y):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_closest_multiple(target, value):\n        closest = target % (2 * value)\n        if closest > value:\n            closest -= 2 * value\n        return closest\n\n    def find_path(K, X, Y):\n        if K == 1:\n            return [(X, Y)]\n        \n        L = 2 * K\n        x, y = X, Y\n        path = []\n\n        # Move to a point where both coordinates are multiples of K\n        x -= find_closest_multiple(X, K)\n        y -= find_closest_multiple(Y, K)\n        path.append((x, y))\n\n        # Move along multiples of L to the origin\n        while x != 0 or y != 0:\n            if x > 0:\n                x -= L\n            elif x < 0:\n                x += L\n            if y > 0:\n                y -= L\n            elif y < 0:\n                y += L\n            path.append((x, y))\n\n        # Reverse the path to go from origin to (X, Y)\n        path = [(x, y) for x, y in zip([X - p[0] for p in reversed(path)], [Y - p[1] for p in reversed(path)])]\n\n        return path\n\n    path = find_path(K, X, Y)\n    return len(path), path\n\n# Read input\nK = int(input())\nX, Y = map(int, input().split())\n\n# Solve and print output\nscore, path = solve(K, X, Y)\nprint(score)\nfor x, y in path:\n    print(x, y)"}
{"solution": "from math import sqrt\n\ndef find_smallest_n(m):\n    \"\"\"\n    Finds the smallest possible value of n such that there are exactly m ways\n    the thieves could have taken the chocolates, given the constraints.\n    If no such n exists, returns -1.\n    \"\"\"\n    for n in range(8, 10**15):\n        ways = 0\n        for x in range(1, int(sqrt(n)) + 1):\n            if x * x > n:\n                break\n            if n % x == 0:\n                y = n // x\n                k1 = x - 1\n                k2 = y - 1\n                if k1 >= 0 and k1 ** 3 + k1 ** 2 + k1 + 1 == m:\n                    return n\n                if k2 >= 0 and k2 ** 3 + k2 ** 2 + k2 + 1 == m:\n                    return n\n        if ways == m:\n            return n\n        if n > 10**14:  # Adjust the upper limit based on the problem constraints\n            break\n    return -1\n\n# Reading input\nm = int(input())\n\n# Calculating and printing the result\nprint(find_smallest_n(m))"}
{"solution": "import math\n\ndef intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    \n    if d >= r1 + r2:\n        return 0\n    \n    if d <= abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n    \n    alpha = math.acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n    beta = math.acos((r2 ** 2 + d ** 2 - r1 ** 2) / (2 * r2 * d))\n    \n    A1 = alpha * r1 ** 2 - r1 ** 2 * math.sin(2 * alpha) / 2\n    A2 = beta * r2 ** 2 - r2 ** 2 * math.sin(2 * beta) / 2\n    \n    return A1 + A2\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\nprint(intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "import math\n\ndef minimize_n(v):\n    # Find the smallest prime number greater than sqrt(v)\n    # This is because any composite number c can be broken down into prime factors,\n    # and subtracting a prime factor p from c will result in a smaller number that\n    # is not divisible by p, making it impossible to reach 0 from c by subtracting c itself.\n    upper_limit = int(math.sqrt(v)) + 1\n    for x in range(upper_limit, 1, -1):\n        if all(x % i != 0 for i in range(2, int(math.sqrt(x)) + 1)):\n            return v - x\n    return v\n\n# Read input\nv = int(input())\n\n# Calculate and print the result\nprint(minimize_n(v))"}
{"solution": "import heapq\n\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef solve():\n    n = int(input())\n    parents = read_ints()\n    citizens = read_ints()\n\n    graph = [[] for _ in range(n)]\n    for i, parent in enumerate(parents, start=1):\n        graph[parent - 1].append(i)\n\n    # Calculate the sum of citizens and the last safe node in the subtree\n    heap = [(0, 0, i) for i in range(n) if not graph[i]]\n    total_caught = [0] * n\n    last_safe_node = [0] * n\n\n    while heap:\n        sum_citizens, _, node = heapq.heappop(heap)\n        sum_citizens -= citizens[node]\n        total_caught[node] = sum_citizens\n        last_safe_node[node] = node\n\n        if graph[node]:\n            # Merge subtrees optimally\n            min_heap = []\n            for child in graph[node]:\n                heapq.heappush(min_heap, (total_caught[child], last_safe_node[child]))\n            \n            while len(min_heap) > 1:\n                sum1, last1 = heapq.heappop(min_heap)\n                sum2, last2 = heapq.heappop(min_heap)\n                total_caught[node] += sum1 + max(0, citizens[last1] - citizens[last2])\n                last_safe_node[node] = min(last_safe_node[node], last1, last2, key=lambda x: (citizens[x], x))\n                \n                heapq.heappush(min_heap, (sum2, last2))\n            \n            if min_heap:\n                total_caught[node] += min_heap[0][0]\n                last_safe_node[node] = min(last_safe_node[node], min_heap[0][1], key=lambda x: (citizens[x], x))\n\n        for child in graph[node]:\n            heapq.heappush(heap, (total_caught[node] + citizens[child], citizens[child], child))\n\n    return total_caught[0]\n\nprint(solve())"}
{"solution": "def count_typo_words(n, S, T):\n    count = 0\n    for i in range(n + 1):\n        # Construct W by inserting a character at position i in both S and T\n        if i == 0:\n            W1 = S[0] + S\n            W2 = T[0] + T\n        elif i == n:\n            W1 = S + S[-1]\n            W2 = T + T[-1]\n        else:\n            W1 = S[:i] + S[i] + S[i:]\n            W2 = T[:i] + T[i] + T[i:]\n        \n        # Check if the constructed words are the same\n        if W1 == W2:\n            count += 1\n    \n    return count\n\n# Example usage:\nn = int(input())\nS = input().strip()\nT = input().strip()\nprint(count_typo_words(n, S, T))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.readline\n\ndef dfs(node, parent, graph, strength, updated_strength, hacked):\n    hacked_neighbors = 0\n    max_updated_strength = updated_strength[node]\n\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            if hacked[neighbor]:\n                hacked_neighbors += 1\n            else:\n                new_max, new_hacked_neighbors = dfs(neighbor, node, graph, strength, updated_strength, hacked)\n                hacked_neighbors += new_hacked_neighbors\n                max_updated_strength = max(max_updated_strength, new_max)\n\n    if hacked_neighbors == 0:\n        return max(updated_strength[node], strength[node]), 0\n    else:\n        return max(updated_strength[node], strength[node] + hacked_neighbors), hacked_neighbors + 1\n\ndef main():\n    n = int(input())\n    strength = list(map(int, input().split()))\n    graph = defaultdict(list)\n\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    hacked = [False] * n\n    updated_strength = strength.copy()\n\n    min_strength = float('-inf')\n    for i in range(n):\n        if not hacked[i]:\n            max_strength, _ = dfs(i, -1, graph, strength, updated_strength, hacked)\n            min_strength = max(min_strength, max_strength)\n            hacked[i] = True\n\n    print(min_strength)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_groups(n, m):\n    return min(m, n - m)\n\n# Example usage:\nn, m = map(int, input().split())\nprint(max_groups(n, m))"}
{"solution": "k, r = map(int, input().split())\n\nfor i in range(1, 11):\n    if (i * k) % 10 == 0 or (i * k) % 10 == r:\n        print(i)\n        break"}
{"solution": "def can_form_rectangle(n, m, grid):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    piece = [grid[i][min_col:max_col + 1] for i in range(min_row, max_row + 1)]\n    \n    if width * 2 == m:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j] != piece[i][j + width]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    if height * 2 == n:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j] != piece[i + height][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    return \"NO\"\n\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "def min_segments(x1, y1, x2, y2, x3, y3):\n    # Check if all points are collinear on the same axis\n    if x1 == x2 == x3 or y1 == y2 == y3:\n        return 1\n    # Check if two points are collinear on the same axis\n    elif (x1 == x2 and x1 != x3) or (y1 == y2 and y1 != y3):\n        return 2\n    elif (x2 == x3 and x2 != x1) or (y2 == y3 and y2 != y1):\n        return 2\n    elif (x1 == x3 and x1 != x2) or (y1 == y3 and y1 != y2):\n        return 2\n    else:\n        return 3\n\n# Reading input\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\n# Print the result\nprint(min_segments(x1, y1, x2, y2, x3, y3))"}
{"solution": "def build_k_regular_graph(k):\n    if k == 0:\n        return \"NO\"\n    \n    if k == 1:\n        return \"\\n\".join([\"YES\", \"2 1\", \"1 2\"])\n    \n    n = 2 * k + 2\n    m = k * n // 2\n    \n    if k % 2 == 0:\n        # For even k, create a cycle and connect additional edges\n        edges = [(i, (i + 1) % n) for i in range(n)]\n        for i in range(1, k // 2 + 1):\n            for j in range(n // 2):\n                edges.append((j, (j + n // 2 + i) % n))\n    else:\n        # For odd k, create two cycles and connect them\n        edges = [(i, (i + 1) % (n // 2)) for i in range(n // 2)] + \\\n                [((i + n // 2), (i + 1) % (n // 2) + n // 2) for i in range(n // 2)]\n        for i in range(1, k // 2 + 1):\n            for j in range(n // 4):\n                edges.append((j, (j + n // 4 + i) % (n // 2) + n // 2))\n                edges.append(((j + n // 4), (j + i) % (n // 2) + n // 2))\n    \n    edges_str = [\" \".join(map(str, edge)) for edge in edges]\n    return \"\\n\".join([\"YES\", f\"{n} {m}\"] + edges_str)\n\nk = int(input())\nprint(build_k_regular_graph(k))"}
{"solution": "def build_kmp_table(pattern):\n    table = [0] * len(pattern)\n    length = 0\n    i = 1\n    while i < len(pattern):\n        if pattern[i] == pattern[length]:\n            length += 1\n            table[i] = length\n            i += 1\n        else:\n            if length != 0:\n                length = table[length - 1]\n            else:\n                table[i] = 0\n                i += 1\n    return table\n\ndef kmp_search(text, pattern):\n    text_index, pattern_index = 0, 0\n    occurrences = []\n    kmp_table = build_kmp_table(pattern)\n    while text_index < len(text):\n        if text[text_index] == pattern[pattern_index]:\n            text_index += 1\n            pattern_index += 1\n        if pattern_index == len(pattern):\n            occurrences.append(text_index - pattern_index)\n            pattern_index = kmp_table[pattern_index - 1]\n        elif text_index < len(text) and pattern[pattern_index] != text[text_index]:\n            if pattern_index != 0:\n                pattern_index = kmp_table[pattern_index - 1]\n            else:\n                text_index += 1\n    return occurrences\n\ndef preprocess(s, t):\n    positions = kmp_search(s, t)\n    prefix_sums = [0] * (len(s) + 1)\n    for pos in positions:\n        prefix_sums[pos + 1] = 1\n    for i in range(1, len(prefix_sums)):\n        prefix_sums[i] += prefix_sums[i - 1]\n    return prefix_sums\n\ndef answer_queries(n, m, q, s, t, queries):\n    prefix_sums = preprocess(s, t)\n    answers = []\n    for l, r in queries:\n        l, r = l - 1, r - 1\n        answers.append(prefix_sums[r + 1] - prefix_sums[l])\n    return answers\n\n# Reading input\nn, m, q = map(int, input().split())\ns = input()\nt = input()\nqueries = [list(map(int, input().split())) for _ in range(q)]\n\n# Calculating answers\nanswers = answer_queries(n, m, q, s, t, queries)\n\n# Printing output\nfor ans in answers:\n    print(ans)"}
{"solution": "MOD = 10**9 + 7\n\ndef preprocess(k, d):\n    dp = [[0] * (k + 1) for _ in range(k + 1)]\n    dp[0][0] = 1\n    for i in range(1, k + 1):\n        s = 0\n        for j in range(1, k + 1):\n            dp[i][j] = s + dp[i - 1][j - 1]\n            if j < d:\n                dp[i][j] = 0\n            dp[i][j] %= MOD\n            s += dp[i - 1][j]\n            s %= MOD\n    return dp\n\n\ndef solve(n, k, d):\n    dp = preprocess(k, d)\n    result = 0\n    for i in range(1, k + 1):\n        result += dp[n][i]\n        result %= MOD\n    return result\n\n\nn, k, d = map(int, input().split())\nprint(solve(n, k, d))"}
{"solution": "def encrypt_japanese_crossword(n, row):\n    groups = []\n    count = 0\n    \n    for char in row:\n        if char == 'B':\n            count += 1\n        else:\n            if count > 0:\n                groups.append(count)\n                count = 0\n    \n    if count > 0:\n        groups.append(count)\n    \n    print(len(groups))\n    if groups:\n        print(\" \".join(map(str, groups)))\n\n# Example usage:\nn = int(input())\nrow = input().strip()\nencrypt_japanese_crossword(n, row)"}
{"solution": "def process_operations(s, operations, cursor_pos):\n    pairs = [-1] * len(s)\n    stack = []\n    for i, char in enumerate(s):\n        if char == '(':\n            stack.append(i)\n        else:\n            pairs[stack.pop()] = i\n            pairs[i] = stack[-1] if stack else -1\n\n    def move_cursor_left():\n        nonlocal cursor_pos\n        if s[cursor_pos] == ')':\n            cursor_pos = pairs[cursor_pos]\n        while cursor_pos > 0 and s[cursor_pos - 1] == ')':\n            cursor_pos -= 1\n        cursor_pos -= 1\n\n    def move_cursor_right():\n        nonlocal cursor_pos\n        if s[cursor_pos] == '(':\n            cursor_pos = pairs[cursor_pos]\n        while cursor_pos < len(s) - 1 and s[cursor_pos + 1] == '(':\n            cursor_pos += 1\n        cursor_pos += 1\n\n    def delete():\n        nonlocal cursor_pos\n        start, end = min(cursor_pos, pairs[cursor_pos]), max(cursor_pos, pairs[cursor_pos])\n        s[start:end + 1] = []\n        cursor_pos = min(cursor_pos, len(s) - 1)\n        pairs = [-1] * len(s)\n        stack = []\n        for i, char in enumerate(s):\n            if char == '(':\n                stack.append(i)\n            else:\n                pairs[stack.pop()] = i\n                pairs[i] = stack[-1] if stack else -1\n        return pairs\n\n    for op in operations:\n        if op == 'L':\n            move_cursor_left()\n        elif op == 'R':\n            move_cursor_right()\n        elif op == 'D':\n            pairs = delete()\n\n    return ''.join(s)\n\n# Reading input\nn, m, p = map(int, input().split())\ns = list(input())\noperations = input()\n\n# Processing operations\nresult = process_operations(s, operations, p - 1)\n\n# Printing output\nprint(result)"}
{"solution": "def find_valid_number(queries):\n    min_val = -2 * 10**9\n    max_val = 2 * 10**9\n    \n    for query in queries:\n        sign, x, answer = query\n        x = int(x)\n        \n        if sign == '>':\n            if answer == 'Y': min_val = max(min_val, x + 1)\n            else: max_val = min(max_val, x)\n        elif sign == '<':\n            if answer == 'Y': max_val = min(max_val, x - 1)\n            else: min_val = max(min_val, x)\n        elif sign == '>=':\n            if answer == 'Y': min_val = max(min_val, x)\n            else: max_val = min(max_val, x - 1)\n        elif sign == '<=':\n            if answer == 'Y': max_val = min(max_val, x)\n            else: min_val = max(min_val, x + 1)\n    \n    if min_val > max_val:\n        return \"Impossible\"\n    else:\n        return min_val if min_val == max_val else (min_val + max_val) // 2\n\nif __name__ == \"__main__\":\n    n = int(input())\n    queries = [input().split() for _ in range(n)]\n    result = find_valid_number(queries)\n    print(result)"}
{"solution": "from math import gcd\n\ndef count_possible_periods(a, b):\n    \"\"\"\n    Counts the number of different periods over all possible strings with a letters 'A' and b letters 'B'.\n    \n    :param a: Number of letters 'A'\n    :param b: Number of letters 'B'\n    :return: Number of different periods\n    \"\"\"\n    total_length = a + b\n    max_period = min(a, b) + 1\n    result = 0\n    \n    for k in range(1, max_period):\n        if (a + b) % k == 0:\n            result += 1\n            \n    # Check for the case where the period is greater than min(a, b)\n    if gcd(a, b) == 1 or (gcd(a, b) > 1 and (a + b) % (gcd(a, b) * 2) == 0):\n        result += 1\n        \n    return result\n\n# Reading input\na, b = map(int, input().split())\n\n# Calculating and printing the result\nprint(count_possible_periods(a, b))"}
{"solution": "def generate_names(n, k, conditions):\n    names = [\"A\"] * n\n    unique_names = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\n    \n    current_unique_index = 0\n    for i in range(n - k + 1):\n        if conditions[i] == \"YES\":\n            for j in range(k):\n                if names[i + j] == \"\":\n                    names[i + j] = unique_names[current_unique_index % len(unique_names)]\n                    current_unique_index += 1\n                elif names[i + j] in names[i:i+j]:\n                    names[i + j] = unique_names[current_unique_index % len(unique_names)]\n                    current_unique_index += 1\n        else:\n            for j in range(k):\n                if names[i + j] == \"\":\n                    names[i + j] = unique_names[0]\n                elif names[i + j] == unique_names[0]:\n                    break\n    \n    # Ensure all names are unique where required and follow the pattern where not\n    for i in range(n):\n        if names[i] == \"\":\n            names[i] = unique_names[current_unique_index % len(unique_names)]\n            current_unique_index += 1\n    \n    # Capitalize the first letter and make others lowercase\n    for i in range(n):\n        names[i] = names[i][0].upper() + names[i][1:].lower()\n    \n    return names\n\n# Reading input\nn, k = map(int, input().split())\nconditions = input().split()\n\n# Generate and print the names\nnames = generate_names(n, k, conditions)\nprint(\" \".join(names))"}
{"solution": "def min_operations_to_equal(a, b):\n    def count_factors(n, factor):\n        count = 0\n        while n % factor == 0:\n            n //= factor\n            count += 1\n        return count, n\n\n    # Count the number of times we can divide by 2, 3, and 5\n    a2, a = count_factors(a, 2)\n    a3, a = count_factors(a, 3)\n    a5, a = count_factors(a, 5)\n    \n    b2, b = count_factors(b, 2)\n    b3, b = count_factors(b, 3)\n    b5, b = count_factors(b, 5)\n    \n    # If the remaining parts are not equal, return -1\n    if a != b:\n        return -1\n    \n    # Calculate the total number of operations needed\n    operations = abs(a2 - b2) + abs(a3 - b3) + abs(a5 - b5)\n    \n    return operations\n\n# Example usage (not part of the solution, just for demonstration)\n# print(min_operations_to_equal(15, 20))  # Output: 3\n# print(min_operations_to_equal(14, 8))   # Output: -1\n# print(min_operations_to_equal(6, 6))    # Output: 0"}
{"solution": "def min_cost_palindrome(n, a, b, c):\n    dp = [[float('inf')] * 2 for _ in range(n // 2 + 1)]\n    dp[0][0] = dp[0][1] = 0\n    \n    for i in range(n // 2):\n        cost0 = a if c[i] == 2 else 0 if c[i] == 0 else float('inf')\n        cost1 = b if c[i] == 2 else 0 if c[i] == 1 else float('inf')\n        \n        if c[n - 1 - i] != 0 and c[n - 1 - i] != c[i]:\n            return -1\n        \n        cost0 += 0 if c[n - 1 - i] == 0 or c[n - 1 - i] == 2 else float('inf')\n        cost1 += 0 if c[n - 1 - i] == 1 or c[n - 1 - i] == 2 else float('inf')\n        \n        dp[i + 1][0] = min(dp[i][0] + cost0, dp[i][1] + cost1)\n        dp[i + 1][1] = min(dp[i][0] + cost1, dp[i][1] + cost0)\n    \n    return min(dp[n // 2])\n\n# Example usage\nn, a, b = map(int, input().split())\nc = list(map(int, input().split()))\nprint(min_cost_palindrome(n, a, b, c))"}
{"solution": "def solve_cube(k):\n    if k == 1:\n        return \"-1\"\n    \n    solution = []\n    for _ in range(k):\n        layer = [\"bw\" * (k // 2)] * k\n        if k % 2 == 1 and _ == k // 2:\n            layer = ['b' + 'bw' * (k // 2 - 1) + 'w'] * k\n        solution.extend(layer)\n    \n    # Flip the pattern for every other layer if k is even\n    if k % 2 == 0:\n        for i in range(1, k, 2):\n            solution[i] = ['w' if x == 'b' else 'b' for x in solution[i]]\n    \n    return '\\n'.join([' '.join(row) for row in solution])\n\n# Read input\nk = int(input())\n\n# Solve and print the result\nprint(solve_cube(k))"}
{"solution": "from collections import Counter\nimport math\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        while (n % i) == 0:\n            factors.append(i)\n            n //= i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef largest_lovely_number(n):\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n    \n    lovely_number = 1\n    for prime, count in factor_counts.items():\n        lovely_number *= prime\n    \n    return lovely_number\n\nn = int(input())\nprint(largest_lovely_number(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    # Check for adjacent occupied seats\n    for i in range(n - 1):\n        if seating[i] == '1' and seating[i + 1] == '1':\n            return \"No\"\n    \n    # Check for possible additional seating\n    for i in range(n):\n        if seating[i] == '0':\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                return \"No\"\n    \n    return \"Yes\"\n\n# Example usage:\nn = int(input())\nseating = input().strip()\nprint(is_maximal_seating(n, seating))"}
{"solution": "def find_possible_lengths(n, a):\n    def is_valid(k):\n        diff = [a[i] - a[i-1] for i in range(1, k+1)]\n        for i in range(k, n):\n            expected = diff[i % k]\n            actual = a[i] - a[i-1]\n            if actual != expected:\n                return False\n        return True\n\n    valid_lengths = []\n    for k in range(1, n + 1):\n        if is_valid(k):\n            valid_lengths.append(k)\n\n    print(len(valid_lengths))\n    print(*valid_lengths)\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Solving and printing output\nfind_possible_lengths(n, a)"}
{"solution": "from itertools import combinations\n\ndef can_form_equal_teams(scores):\n    total_score = sum(scores)\n    if total_score % 2 != 0:\n        return \"NO\"\n    \n    target = total_score // 2\n    for combo in combinations(scores, 3):\n        if sum(combo) == target:\n            return \"YES\"\n    return \"NO\"\n\n# Reading input\nscores = list(map(int, input().split()))\n\n# Solving and printing output\nprint(can_form_equal_teams(scores))"}
{"solution": "from math import log2, log\n\ndef max_power(base, limit):\n    return int(log(limit, base))\n\ndef count_23_integers(l, r):\n    max_x = max_power(2, r)\n    max_y = max_power(3, r)\n    \n    def is_23_integer(n):\n        while n % 2 == 0:\n            n //= 2\n        while n % 3 == 0:\n            n //= 3\n        return n == 1\n    \n    # Count 2-3 integers up to r\n    count_up_to_r = sum(is_23_integer(2**x * 3**y) for x in range(max_x + 1) for y in range(max_y + 1))\n    \n    # Count 2-3 integers up to l-1\n    count_up_to_l_minus_1 = sum(is_23_integer(2**x * 3**y) for x in range(max_x + 1) for y in range(max_y + 1) if 2**x * 3**y < l)\n    \n    return count_up_to_r - count_up_to_l_minus_1\n\n# Read input\nl, r = map(int, input().split())\n\n# Output result\nprint(count_23_integers(l, r))"}
{"solution": "import math\n\ndef candies_eaten(n, k):\n    low, high = 0, n\n    while low < high:\n        mid = (low + high) // 2\n        # Calculate the total number of candies added and eaten\n        total_candies = mid * (mid + 1) // 2 - k\n        total_added = (mid + 2) * (mid + 1) // 2\n        if total_added >= n and total_candies <= n:\n            high = mid\n        else:\n            low = mid + 1\n    return n - ((low + 1) * low // 2 - k)\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(candies_eaten(n, k))"}
{"solution": "from typing import List\n\ndef can_form_triangle(segments: List[int]) -> str:\n    \"\"\"\n    Checks if it's possible to form a non-degenerate triangle using exactly 3 line segments from the given list.\n    \n    A non-degenerate triangle can be formed if the sum of the lengths of any two sides is greater than the length of the third side.\n    \n    Parameters:\n    segments (List[int]): The list of segment lengths.\n    \n    Returns:\n    str: \"YES\" if a non-degenerate triangle can be formed, \"NO\" otherwise.\n    \"\"\"\n    segments.sort()\n    for i in range(len(segments) - 2):\n        if segments[i] + segments[i + 1] > segments[i + 2]:\n            return \"YES\"\n    return \"NO\"\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Solving and printing output\nprint(can_form_triangle(a))"}
{"solution": "def is_possible(x, y):\n    while x >= 0 and y > 0:\n        if x < y - 1:\n            return False\n        if x == 0 and y == 1:\n            return True\n        if x == y - 1:\n            return True\n        if x > y - 1:\n            x -= max(2 * (y - 1), 1)\n        y -= 1\n    return False\n\nx, y = map(int, input().split())\nprint(\"Yes\" if is_possible(x, y) else \"No\")"}
{"solution": "def max_rating(n, k, skills):\n    skills = [skill % 10 for skill in skills]\n    skills.sort()\n    \n    base_rating = sum(skill // 10 for skill in range(n))\n    \n    improvements = 0\n    total_improvement = 0\n    \n    for i in range(n):\n        if k >= 10 - skills[i]:\n            k -= 10 - skills[i]\n            skills[i] = 0\n            total_improvement += 1\n        else:\n            break\n    \n    while k > 0 and improvements < n:\n        cost = 10 - skills[improvements]\n        if cost <= k:\n            k -= cost\n            skills[improvements] = 0\n            total_improvement += 1\n        else:\n            break\n        improvements += 1\n    \n    return base_rating + total_improvement\n\n# Example usage\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\nprint(max_rating(n, k, skills))"}
{"solution": "def find_smallest_pretty_integer(n, m, list1, list2):\n    # Convert lists to sets for faster lookup\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check for common digits\n    common_digits = set1.intersection(set2)\n    if common_digits:\n        return min(common_digits)\n    \n    # If no common digits, find the smallest combination\n    min1 = min(list1)\n    min2 = min(list2)\n    \n    # Form the smallest two-digit number\n    smallest_pretty = min(int(str(min1) + str(min2)), int(str(min2) + str(min1)))\n    return smallest_pretty\n\n# Reading input\nn, m = map(int, input().split())\nlist1 = list(map(int, input().split()))\nlist2 = list(map(int, input().split()))\n\n# Output\nprint(find_smallest_pretty_integer(n, m, list1, list2))"}
{"solution": "def max_problems_solved(n, k):\n    # Calculate the total time available for solving problems\n    total_time_available = 240 - k\n    \n    # Initialize variables\n    i = 1  # Problem index\n    total_time_needed = 0\n    \n    # Calculate the total time needed to solve problems\n    while total_time_needed + 5 * i <= total_time_available and i <= n:\n        total_time_needed += 5 * i\n        i += 1\n    \n    # Return the maximum number of problems solved\n    return i - 1\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the result\nprint(max_problems_solved(n, k))"}
{"solution": "def max_teams(n, x, y, a):\n    a.sort()\n    double_sided = x\n    single_sided = y\n    count = 0\n    \n    for pages in a:\n        double_needed = pages // 2\n        single_needed = pages % 2\n        \n        if double_needed <= double_sided:\n            double_sided -= double_needed\n            if single_needed <= single_sided:\n                single_sided -= single_needed\n                count += 1\n            else:\n                double_sided += double_needed\n                break\n        else:\n            remaining_pages = pages - 2 * double_sided\n            if remaining_pages <= single_sided:\n                single_sided -= remaining_pages\n                double_sided = 0\n                count += 1\n            else:\n                break\n    \n    return count\n\n# Reading input\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\n# Printing output\nprint(max_teams(n, x, y, a))"}
{"solution": "import math\n\ndef count_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return len(divisors)\n\n# Read input\nb = int(input().strip())\n\n# Calculate the number of distinct values\nresult = count_divisors(b)\n\n# Print the result\nprint(result)"}
{"solution": "n = int(input())\nbumpers = input()\n\ndef count_falling_positions(bumpers):\n    left_max = [0] * n\n    right_max = [0] * n\n    \n    # Fill left_max\n    left_max[0] = 0\n    for i in range(1, n):\n        if bumpers[i-1] == '<':\n            left_max[i] = left_max[i-1] + 1\n        else:\n            left_max[i] = 0\n    \n    # Fill right_max\n    right_max[n-1] = 0\n    for i in range(n-2, -1, -1):\n        if bumpers[i+1] == '>':\n            right_max[i] = right_max[i+1] + 1\n        else:\n            right_max[i] = 0\n    \n    # Count positions where the ball falls off\n    falling_positions = 0\n    for i in range(n):\n        if left_max[i] >= right_max[i]:\n            falling_positions += 1\n    \n    return falling_positions\n\nprint(count_falling_positions(bumpers))"}
{"solution": "from collections import Counter\n\ndef max_rectangle_area(stick_lengths):\n    count = Counter(stick_lengths)\n    stick_lengths.sort(reverse=True)\n    area = 0\n    i = 0\n    \n    while i < len(stick_lengths):\n        current = stick_lengths[i]\n        if count[current] >= 2:\n            if i + 1 < len(stick_lengths) and count[stick_lengths[i + 1]] >= 2 and stick_lengths[i + 1] == stick_lengths[i] - 1:\n                area += (current - 1) ** 2\n                count[current] -= 2\n                count[current - 1] -= 2\n                while stick_lengths[i] == current and count[current] < 2:\n                    i += 1\n                continue\n            elif count[current] >= 4:\n                area += current ** 2\n                count[current] -= 4\n                while stick_lengths[i] == current and count[current] < 4:\n                    i += 1\n                continue\n        i += 1\n    \n    return area\n\n# Reading input\nn = int(input())\nl = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(max_rectangle_area(l))"}
{"solution": "from collections import defaultdict, Counter\n\ndef min_sum_of_restored_numbers(n, strings):\n    def decode_string(s, mapping):\n        return int(''.join(str(mapping[c]) for c in s))\n    \n    def calculate_min_sum(strings, digit_map):\n        return sum(decode_string(s, digit_map) for s in strings)\n    \n    # Initialize digit mapping\n    digit_map = {chr(97 + i): i for i in range(10)}  # a-j -> 0-9\n    \n    # Process strings\n    strings = [s for s in strings if len(s) > 0]  # Remove empty strings\n    sorted_strings = sorted(strings, key=len, reverse=True)\n    \n    # Count character frequencies\n    char_counts = Counter(char for s in sorted_strings for char in s)\n    \n    # Ensure the most frequent characters map to higher digits\n    for s in sorted_strings:\n        used_digits = set(digit_map[char] for char in s)\n        for char in s:\n            if digit_map[char] in used_digits:\n                # Find the next available higher digit\n                for i in range(digit_map[char] + 1, 10):\n                    if i not in used_digits:\n                        digit_map[char] = i\n                        break\n    \n    # Ensure no leading zeros\n    for s in sorted_strings:\n        if digit_map[s[0]] == 0:\n            for i in range(1, 10):\n                if i not in digit_map.values():\n                    digit_map[s[0]] = i\n                    break\n    \n    return calculate_min_sum(strings, digit_map)\n\n# Read input\nn = int(input())\nstrings = [input() for _ in range(n)]\n\n# Calculate and print the result\nprint(min_sum_of_restored_numbers(n, strings))"}
{"solution": "def max_teams(n, m):\n    # Binary search to find the maximum number of teams\n    low, high = 0, min(n, m, (n + m) // 3)\n    \n    while low < high:\n        mid = (low + high + 1) // 2\n        if mid <= n and mid <= m and 2 * mid <= n + m:\n            low = mid\n        else:\n            high = mid - 1\n    \n    return low\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    n = len(s)\n    \n    # Check for \"AB\" followed by \"BA\"\n    found_AB = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"AB\":\n            found_AB = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"BA\":\n                    print(\"YES\")\n                    return\n            break\n    \n    # Check for \"BA\" followed by \"AB\"\n    found_BA = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"BA\":\n            found_BA = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"AB\":\n                    print(\"YES\")\n                    return\n            break\n    \n    # If neither condition is met\n    print(\"NO\")\n\n# Reading input\ns = input().strip()\ncheck_substrings(s)"}
{"solution": "from typing import List\n\ndef can_transform(initial_weights: List[int], final_weights: List[int]) -> List[str]:\n    def eat_actions():\n        stack = []\n        actions = []\n        j = 0\n        \n        for i in range(len(initial_weights) - 1, -1, -1):\n            while stack and stack[-1] == final_weights[j]:\n                stack.pop()\n                j += 1\n            \n            if stack and stack[-1] > initial_weights[i]:\n                return [\"NO\"]\n            \n            if not stack or stack[-1] < initial_weights[i]:\n                stack.append(initial_weights[i])\n            else:\n                if stack[-1] != initial_weights[i] + final_weights[j]:\n                    return [\"NO\"]\n                \n                actions.append(f\"{len(stack)} L\")\n                stack.pop()\n                j += 1\n        \n        while stack and stack[-1] == final_weights[j]:\n            stack.pop()\n            j += 1\n        \n        if stack or j < len(final_weights):\n            return [\"NO\"]\n        \n        return [\"YES\"] + actions[::-1]\n\n    result = eat_actions()\n    if result[0] == \"NO\":\n        return [\"NO\"]\n    \n    return result\n\n# Reading input\nn = int(input())\ninitial_weights = list(map(int, input().split()))\nk = int(input())\nfinal_weights = list(map(int, input().split()))\n\n# Processing and printing output\noutput = can_transform(initial_weights, final_weights)\nprint('\\n'.join(output))"}
{"solution": "from itertools import combinations\n\ndef cross_product(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef is_possible_to_assign(rebels, bases):\n    n = len(rebels)\n    m = len(bases)\n    \n    if n != m:\n        return \"No\"\n    \n    # Check if all pairs can be connected without intersection\n    for perm in combinations(range(m), n):\n        intersect = False\n        for i in range(n):\n            for j in range(i + 1, n):\n                p1 = rebels[i]\n                p2 = bases[perm[i]]\n                p3 = rebels[j]\n                p4 = bases[perm[j]]\n                \n                # Check if line segments intersect\n                d1 = cross_product(p1, p2, p3)\n                d2 = cross_product(p1, p2, p4)\n                d3 = cross_product(p3, p4, p1)\n                d4 = cross_product(p3, p4, p2)\n                \n                if d1 * d2 < 0 and d3 * d4 < 0:\n                    intersect = True\n                    break\n            if intersect:\n                break\n        if not intersect:\n            return \"Yes\"\n    \n    return \"No\"\n\n# Reading input\nR, B = map(int, input().split())\nrebels = [tuple(map(int, input().split())) for _ in range(R)]\nbases = [tuple(map(int, input().split())) for _ in range(B)]\n\n# Output\nprint(is_possible_to_assign(rebels, bases))"}
{"solution": "def find_max_power_and_count(numbers):\n    max_power = 0\n    for number in numbers:\n        power = 0\n        while number % 2 == 0:\n            number //= 2\n            power += 1\n        if power > max_power:\n            max_power = power\n            count = 1\n        elif power == max_power:\n            count += 1\n    return 2 ** max_power, count\n\nn = int(input())\nnumbers = list(map(int, input().split()))\n\nresult = find_max_power_and_count(numbers)\nprint(*result)"}
{"solution": "def min_clicks(n, m):\n    if n >= m:\n        return n - m\n    clicks = 0\n    while n != m:\n        if m % 2 == 0 and n < m:\n            m //= 2\n        else:\n            m += 1\n        clicks += 1\n    return clicks\n\nn, m = map(int, input().split())\nprint(min_clicks(n, m))"}
{"solution": "from collections import defaultdict\n\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    return find(parent, parent[i])\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef check_tree(n, segments):\n    events = []\n    for i, (l, r) in enumerate(segments):\n        events.append((l, 'start', i))\n        events.append((r, 'end', i))\n    events.sort()\n\n    parent = list(range(n))\n    rank = [0] * n\n    edges = 0\n    last = None\n    intersection = set()\n\n    for pos, typ, seg_id in events:\n        if last is not None and intersection:\n            if len(intersection) > 1:\n                edges += len(intersection) * (len(intersection) - 1) // 2\n                root = find(parent, list(intersection)[0])\n                for x in intersection:\n                    if find(parent, x) != root:\n                        union(parent, rank, x, root)\n            intersection.clear()\n        if typ == 'start':\n            intersection.add(seg_id)\n        else:\n            intersection.discard(seg_id)\n        last = pos\n\n    if len(intersection) > 1:\n        edges += len(intersection) * (len(intersection) - 1) // 2\n        root = find(parent, list(intersection)[0])\n        for x in intersection:\n            if find(parent, x) != root:\n                union(parent, rank, x, root)\n\n    root_count = sum(1 for i in range(n) if parent[i] == i)\n    return \"YES\" if edges == n - 1 and root_count == 1 else \"NO\"\n\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\nprint(check_tree(n, segments))"}
{"solution": "def longest_ddos_attack(n, requests):\n    max_length = 0\n    for start in range(n):\n        total_requests = 0\n        for end in range(start, n):\n            total_requests += requests[end]\n            duration = end - start + 1\n            if total_requests > 100 * duration:\n                max_length = max(max_length, duration)\n            else:\n                break\n    return max_length\n\n# Reading input\nn = int(input())\nrequests = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(longest_ddos_attack(n, requests))"}
{"solution": "def check_dissatisfaction(n, k, episodes):\n    def can_have_dissatisfaction(d):\n        count, max_gap = 0, 0\n        uncertain = 0\n        for e in episodes:\n            if e == 'N':\n                count += 1\n                if count > d:\n                    return False\n            elif e == '?':\n                uncertain += 1\n                count += 1\n            else:\n                max_gap = max(max_gap, count)\n                count = 0\n                uncertain = 0\n        max_gap = max(max_gap, count)\n        return max_gap <= d and (max_gap < d or uncertain >= d - max_gap)\n\n    return \"YES\" if can_have_dissatisfaction(k) else \"NO\"\n\n# Reading input\nn, k = map(int, input().split())\nepisodes = input()\n\n# Calculating and printing the result\nprint(check_dissatisfaction(n, k, episodes))"}
{"solution": "import sys\n\ndef main():\n    N, X, D = map(int, sys.stdin.readline().split())\n    if D == 0:\n        print(3 if N > 2 else 1)\n        return\n    \n    max_val = X + (N - 1) * D\n    min_val = X\n    diff = abs(D)\n\n    possible_values = set()\n\n    # Calculate all possible values of S - T\n    for i in range(N + 1):\n        takahashi_sum = sum(range(X, max_val + 1, diff)) - sum(range(X, min_val + i * diff, diff))\n        aoki_sum = sum(range(X, min_val + i * diff, diff)) - sum(range(X, max_val + 1, diff))\n        possible_values.add(takahashi_sum - aoki_sum)\n\n    print(len(possible_values))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def did_anton_perform_good(n, participants):\n    for participant in participants:\n        handle, before, after = participant\n        if before >= 2400 and after > before:\n            return \"YES\"\n    return \"NO\"\n\n# Example usage:\nn = int(input())\nparticipants = [input().split() for _ in range(n)]\nparticipants = [(handle, int(before), int(after)) for handle, before, after in participants]\n\nprint(did_anton_perform_good(n, participants))"}
{"solution": "def count_missed_trains(binary_time):\n    s = int(binary_time, 2)\n    k = 0\n    missed_trains = 0\n    while 4 ** k < s:\n        missed_trains += 1\n        k += 1\n    return missed_trains\n\n# Example usage\nbinary_time = input()\nprint(count_missed_trains(binary_time))"}
{"solution": "def min_rows_for_matrix_b(n, m, matrix_a):\n    def can_form_mirror(x):\n        for j in range(m):\n            if matrix_a[x - 1][j] != matrix_a[n - x][j]:\n                return False\n        return True\n\n    for i in range(1, n // 2 + 1):\n        if not can_form_mirror(i):\n            return n - 2 * (i - 1)\n    return n % 2 + n // 2\n\n# Reading input\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\n\n# Printing output\nprint(min_rows_for_matrix_b(n, m, matrix_a))"}
{"solution": "import heapq\n\ndef max_accepted_orders(n, intervals):\n    intervals.sort(key=lambda x: x[1])  # Sort by end times\n    heapq.heapify(intervals)  # Convert list to heap based on end times\n    \n    current_end_time = -1\n    accepted_orders = 0\n    \n    while intervals:\n        start, end = heapq.heappop(intervals)\n        if start >= current_end_time:\n            accepted_orders += 1\n            current_end_time = end\n            \n    return accepted_orders\n\n# Read input\nn = int(input())\nintervals = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve and print output\nprint(max_accepted_orders(n, intervals))"}
{"solution": "def can_rearrange(n, k, tables, formulas):\n    prev_table_count = 0\n    prev_formula_count = 0\n    consecutive_tables = 0\n    consecutive_formulas = 0\n    \n    for i in range(n):\n        current_table_count = tables[i]\n        current_formula_count = formulas[i]\n        \n        # Check for tables\n        if prev_table_count + current_table_count > k:\n            return \"NO\"\n        \n        # Update consecutive tables\n        if prev_formula_count == 0:\n            consecutive_tables += current_table_count\n        else:\n            consecutive_tables = current_table_count\n        \n        if consecutive_tables > k:\n            return \"NO\"\n        \n        # Check for formulas\n        if prev_formula_count + current_formula_count > k:\n            return \"NO\"\n        \n        # Update consecutive formulas\n        if prev_table_count == 0:\n            consecutive_formulas += current_formula_count\n        else:\n            consecutive_formulas = current_formula_count\n        \n        if consecutive_formulas > k:\n            return \"NO\"\n        \n        prev_table_count = current_table_count\n        prev_formula_count = current_formula_count\n    \n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ntables = list(map(int, input().split()))\nformulas = list(map(int, input().split()))\n\n# Determine if rearrangement is possible\nresult = can_rearrange(n, k, tables, formulas)\nprint(result)"}
{"solution": "from collections import deque\n\ndef can_human_win(n, k, coefficients):\n    \"\"\"\n    Determines if the human can guarantee a win in the polynomial game.\n    \n    :param n: Integer, the degree of the polynomial.\n    :param k: Integer, the value used in the divisor polynomial x - k.\n    :param coefficients: List of coefficients for the polynomial, where '?' indicates an undefined coefficient.\n    :return: \"Yes\" if the human can guarantee a win, \"No\" otherwise.\n    \"\"\"\n    queue = deque()\n    turn = 1\n    marked = [False] * (n + 1)\n    \n    for i in range(n, -1, -1):\n        if coefficients[i] == '?':\n            if turn == 1:\n                if (n - i) % 2 == 0:\n                    queue.append(i)\n            else:\n                if (n - i) % 2 != 0:\n                    queue.append(i)\n            turn ^= 1\n    \n    while queue:\n        i = queue.popleft()\n        if not marked[i]:\n            marked[i] = True\n            if (n - i) % 2 == 0:\n                if i - k >= 0 and not marked[i - k]:\n                    queue.append(i - k)\n            else:\n                if i - k >= 0 and marked[i - k]:\n                    return \"No\"\n    \n    return \"Yes\"\n\n# Reading input\nn, k = map(int, input().split())\ncoefficients = [input().strip() for _ in range(n + 1)]\n\n# Determining if human can win\nresult = can_human_win(n, k, coefficients)\n\n# Printing output\nprint(result)"}
{"solution": "from sympy import primerange\n\nX_2 = int(input())\n\ndef find_smallest_X0(X2):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    primes = list(primerange(2, X2 - 1))\n    min_X0 = X2\n\n    for i in range(len(primes)):\n        for j in range(i, len(primes)):\n            p1 = primes[i]\n            p2 = primes[j]\n            X1 = ((X2 - 1) // p2) * p2\n            X0 = ((X1 - 1) // p1) * p1\n            if X0 >= 3 and not is_prime(X0):\n                min_X0 = min(min_X0, X0)\n\n    return min_X0\n\nprint(find_smallest_X0(X_2))"}
{"solution": "import math\n\ndef min_summands(n, p):\n    if p >= n:\n        return -1\n    \n    # Function to check if a number can be represented\n    def can_be_represented(x):\n        target = n\n        while x > 0 and target > 0:\n            if target - (x + p) >= 0:\n                target -= x + p\n            x //= 2\n        return target == 0\n    \n    max_power = int(math.log(n - p, 2)) + 1 if n > p else 0\n    min_sum = float('inf')\n    \n    for x in range(max_power + 1):\n        if can_be_represented(1 << x):\n            min_sum = min(min_sum, (n - p + (1 << x) - 1) // (1 << x))\n    \n    return min_sum if min_sum != float('inf') else -1\n\n# Reading input\nn, p = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_summands(n, p))"}
{"solution": "def min_value_s(n, k, s):\n    result = list(s)\n    changes_made = 0\n    for i in range(n):\n        if changes_made < k:\n            if i == 0 and s[i] != '1':\n                result[i] = '1'\n                changes_made += 1\n            elif i != 0:\n                if s[i] != '0':\n                    result[i] = '0'\n                    changes_made += 1\n        else:\n            break\n    # If there are still changes left and the first digit is not 1,\n    # change the first digit to 1 (or 0 if n > 1 and k is enough)\n    if changes_made < k and n > 1 and result[0] != '1':\n        result[0] = '0' if changes_made + 1 <= k else result[0]\n    elif changes_made < k and n == 1:\n        result[0] = '0'\n    return ''.join(result)\n\n# Read input\nn, k = map(int, input().split())\ns = input()\n\n# Compute and print the result\nprint(min_value_s(n, k, s))"}
{"solution": "import math\n\ndef solve(cnt1, cnt2, x, y):\n    def lcm(a, b):\n        return a * b // math.gcd(a, b)\n\n    def count_numbers(n, prime):\n        return n - n // prime\n\n    def check(v):\n        count_x = count_numbers(v, x)\n        count_y = count_numbers(v, y)\n        count_xy = count_numbers(v, lcm(x, y))\n        return count_x >= cnt1 and count_y >= cnt2 and (count_x + count_y - count_xy) >= (cnt1 + cnt2)\n\n    low, high = 0, 2 * 10**9\n    while low < high:\n        mid = (low + high) // 2\n        if check(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\n# Reading input\ncnt1, cnt2, x, y = map(int, input().split())\n\n# Solving and printing the result\nprint(solve(cnt1, cnt2, x, y))"}
{"solution": "def bear_walk(n, sx, sy, dx, dy, t):\n    for _ in range(t):\n        k = sx + sy  # Number of bushes eaten\n        dx += k  # Update speed\n        dy += k  # Update speed\n        \n        # Move the bear\n        sx = ((sx + dx - 1) % n) + 1\n        sy = ((sy + dy - 1) % n) + 1\n        \n        # One additional raspberry bush grows in each cell\n        # No need to handle this as the number of bushes doesn't affect the final position\n    \n    return sx, sy\n\n# Reading input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Calculating final position\nfinal_position = bear_walk(n, sx, sy, dx, dy, t)\n\n# Printing output\nprint(*final_position)"}
{"solution": "from collections import Counter\n\ndef is_nice_word(s):\n    # Check if it's possible to have a nice word\n    if '?' not in s and len(s) < 26:\n        return False, \"-1\"\n    \n    # Count occurrences of each letter and question marks\n    counts = Counter(s)\n    if sum(counts[c] for c in counts if c != '?') > 26:\n        return False, \"-1\"\n    \n    # Generate a nice word\n    nice_word = list(s)\n    used_letters = set()\n    for i, char in enumerate(nice_word):\n        if char == '?':\n            for j in range(65, 91):  # ASCII values for 'A' to 'Z'\n                letter = chr(j)\n                if letter not in used_letters and letter not in nice_word[max(0, i-25):i+1]:\n                    nice_word[i] = letter\n                    used_letters.add(letter)\n                    break\n            else:\n                # If no suitable letter is found, it's not possible to create a nice word\n                return False, \"-1\"\n        else:\n            used_letters.add(char)\n        \n        # Ensure the substring of length 26 is unique\n        if len(used_letters) > 26:\n            return False, \"-1\"\n    \n    # Check if the final word is nice\n    if len(used_letters) == 26:\n        return True, ''.join(nice_word)\n    else:\n        return False, \"-1\"\n\n# Read input\ns = input().strip()\n\n# Solve and print the result\npossible, result = is_nice_word(s)\nprint(result)"}
{"solution": "n = int(input())\nweights = list(map(int, input().split()))\n\ntotal_weight = sum(weights)\ncount_200g = weights.count(200)\n\n# If the total weight is odd or there's an odd number of 200g apples, it's impossible to divide fairly.\nif total_weight % 2 != 0 or count_200g % 2 != 0:\n    print(\"NO\")\nelse:\n    print(\"YES\")"}
{"solution": "from itertools import product\n\ndef min_time_to_turn_off_lights(floors, rooms):\n    dp = [0] * (rooms + 2)\n    for floor in floors:\n        new_dp = [0] * (rooms + 2)\n        for pos, (left, center, right) in enumerate(zip(dp, floor[1:-1], dp[2:])):\n            if center == '0':\n                new_dp[pos + 1] = min(left, right)\n            else:\n                new_dp[pos + 1] = min(left, right) + 1\n        dp = new_dp\n    return dp[1] + sum(1 for f in floors[-1][1:-1] if f == '1') + len(floors) - 1\n\n# Reading input\nn, m = map(int, input().split())\nbuilding = [input() for _ in range(n)]\n\n# Calculating and printing the result\nprint(min_time_to_turn_off_lights(building, m))"}
{"solution": "from collections import defaultdict\n\ndef find_min_trap_cost(n, costs, transitions):\n    visited = [False] * n\n    in_stack = [False] * n\n    min_cost = 0\n\n    def dfs(node, cycle_costs):\n        nonlocal in_stack, visited, transitions\n        if visited[node]:\n            if in_stack[node]:\n                # Found a cycle, calculate the minimum cost in this cycle\n                cycle_min_cost = float('inf')\n                while stack:\n                    cycle_node = stack.pop()\n                    in_stack[cycle_node] = False\n                    cycle_min_cost = min(cycle_min_cost, costs[cycle_node])\n                    if cycle_node == node:\n                        break\n                cycle_costs.append(cycle_min_cost)\n                return\n            return\n        visited[node] = True\n        in_stack[node] = True\n        stack.append(node)\n        dfs(transitions[node], cycle_costs)\n        in_stack[node] = False\n\n    stack = []\n    cycle_costs = []\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, cycle_costs)\n\n    return sum(cycle_costs)\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\n# Adjust transitions to be 0-indexed\ntransitions = [x - 1 for x in transitions]\n\n# Calculate and print the result\nprint(find_min_trap_cost(n, costs, transitions))"}
{"solution": "n, a, b = map(int, input().split())\nresult = (a + b - 1) % n + 1\nprint(result)"}
{"solution": "from typing import List\n\ndef min_arithmetic_progressions(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 1:\n        return 1\n    \n    dp = [1] * n\n    prev = {}\n    \n    def update_dp(i, diff):\n        if (i - 1, diff) in prev:\n            dp[i] = dp[prev[(i - 1, diff)]] + 1\n        else:\n            dp[i] = 1\n        prev[(i, diff)] = i\n    \n    for i in range(1, n):\n        if arr[i] != -1:\n            for j in range(max(0, i - 3000), i):\n                if arr[j] != -1:\n                    diff = arr[i] - arr[j]\n                    if -3000 <= diff <= 3000:\n                        update_dp(i, diff)\n        else:\n            for j in range(max(0, i - 3000), i):\n                if arr[j] != -1:\n                    for d in range(-3000, 3001):\n                        update_dp(i, d)\n    \n    return min(dp)\n\n# Example usage\nif __name__ == \"__main__\":\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(min_arithmetic_progressions(arr))"}
{"solution": "def max_beauty(n, k, s):\n    left, maxBeauty, changes = 0, 0, 0\n    for right in range(n):\n        # Count the changes needed if we include the current character\n        if s[right] != s[left]:\n            changes += 1\n        # If we exceed k changes, move the left pointer\n        while changes > k:\n            if s[left] != s[left + 1]:\n                changes -= 1\n            left += 1\n        # Update the maximum beauty\n        maxBeauty = max(maxBeauty, right - left + 1)\n    return maxBeauty\n\n# Reading input\nn, k = map(int, input().split())\ns = input()\n\n# Printing output\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, seats):\n    total_seats = sum(seats)\n    alice_seats = seats[0]\n    coalition_seats = alice_seats\n    coalition = [1]\n\n    for i in range(1, n):\n        if seats[i] * 2 <= alice_seats:\n            coalition_seats += seats[i]\n            coalition.append(i + 1)\n\n    if coalition_seats * 2 > total_seats:\n        print(len(coalition))\n        print(' '.join(map(str, coalition)))\n    else:\n        print(0)\n\n# Read input\nn = int(input())\nseats = list(map(int, input().split()))\n\n# Solve and print output\nfind_coalition(n, seats)"}
{"solution": "def max_reward(n):\n    harmonic_sum = 0.0\n    for i in range(1, n + 1):\n        harmonic_sum += 1.0 / i\n    return harmonic_sum\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the maximum reward\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "def max_children_candies(n):\n    k = 1\n    while k * (k + 1) // 2 <= n:\n        k += 1\n    k -= 1\n    \n    candies_distribution = list(range(1, k + 1))\n    remaining_candies = n - sum(candies_distribution)\n    \n    if remaining_candies > 0:\n        candies_distribution[-1] += remaining_candies\n    \n    return k, candies_distribution\n\nif __name__ == \"__main__\":\n    n = int(input())\n    k, candies_distribution = max_children_candies(n)\n    print(k)\n    print(\" \".join(map(str, candies_distribution)))"}
{"solution": "n = int(input())\nm = int(input())\n\nresult = m % (2 ** n)\nprint(result)"}
{"solution": "def correct_word(s):\n    vowels = 'aeiouy'\n    i = 0\n    while i < len(s) - 1:\n        if s[i] in vowels and s[i + 1] in vowels:\n            s = s[:i] + s[i+1:]\n        else:\n            i += 1\n    return s\n\nn = int(input())\ns = input()\nresult = correct_word(s)\nprint(result)"}
{"solution": "def max_students(n, a, b, seats):\n    segments = []\n    i = 0\n    \n    # Identify segments of empty seats\n    while i < n:\n        if seats[i] == '.':\n            start = i\n            while i < n and seats[i] == '.':\n                i += 1\n            segments.append(i - start)\n        else:\n            i += 1\n    \n    total_students = 0\n    \n    # Place students in each segment\n    for length in segments:\n        # Calculate the number of students that can be placed in this segment\n        # We will place students in an alternating fashion\n        if a > b:\n            # Start with a student-programmer if more student-programmers are available\n            programmers = (length + 1) // 2\n            athletes = length // 2\n        else:\n            # Start with a student-athlete if more student-athletes are available\n            athletes = (length + 1) // 2\n            programmers = length // 2\n        \n        # Place the students\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n        \n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n    \n    return total_students\n\n# Reading input\nn, a, b = map(int, input().split())\nseats = input()\n\n# Output\nprint(max_students(n, a, b, seats))"}
{"solution": "from math import sqrt\n\ndef solve(r):\n    for x in range(1, int(sqrt(r)) + 1):\n        a = r - x**2 - x - 1\n        if a % (2 * x + 1) == 0:\n            y = a // (2 * x + 1)\n            if y > 0:\n                return x, y\n    return \"NO\"\n\nr = int(input())\nresult = solve(r)\n\nif isinstance(result, tuple):\n    print(*result)\nelse:\n    print(result)"}
{"solution": "from itertools import combinations\n\ndef can_divide_balloons(n, a):\n    total_balloons = sum(a)\n    half = total_balloons // 2\n\n    for k in range(1, n):\n        for comb in combinations(range(n), k):\n            grigory_sum = sum(a[i] for i in comb)\n            andrew_sum = total_balloons - grigory_sum\n            if grigory_sum != andrew_sum and 0 < grigory_sum <= half and 0 < andrew_sum <= half:\n                return k, comb\n    return -1,\n\nn = int(input())\na = list(map(int, input().split()))\n\nresult = can_divide_balloons(n, a)\nprint(*result)"}
{"solution": "def min_unique_digits(n):\n    # Calculate the minimum number of unique digits\n    if n < 10:\n        return [n], [n]\n    unique_digits = 1 if n % 9 == 0 else 2\n    quotient, remainder = divmod(n, 9)\n    \n    # Construct the digits array\n    digits = [9] * quotient\n    if remainder:\n        digits.append(remainder)\n    return digits, [unique_digits]\n\n# Read input\nn = int(input())\n\n# Calculate the result\ndigits, output = min_unique_digits(n)\n\n# Print the result\nprint(len(digits))\nprint(*digits)"}
{"solution": "from math import sqrt\nfrom collections import Counter\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef max_simple_subset(arr):\n    prime_sums = set()\n    for x in arr:\n        new_prime_sums = set()\n        for p in prime_sums:\n            if is_prime(x + p):\n                new_prime_sums.add(x + p)\n        if is_prime(2 * x):\n            new_prime_sums.add(2 * x)\n        prime_sums |= new_prime_sums\n        if is_prime(x):\n            prime_sums.add(x)\n    \n    counts = Counter(arr)\n    result = []\n    for x in sorted(counts.keys(), reverse=True):\n        if counts[x] > 0 and (2 * x not in prime_sums or counts[x] == 1):\n            result.append(x)\n            if 2 * x in prime_sums:\n                prime_sums.remove(2 * x)\n            for p in list(prime_sums):\n                if p - x in prime_sums:\n                    prime_sums.remove(p)\n            counts[x] -= 1\n    \n    return len(result), result\n\nif __name__ == \"__main__\":\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    size, subset = max_simple_subset(arr)\n    \n    print(size)\n    print(*subset)"}
{"solution": "def greatest_beautiful_divisor(n):\n    max_k = 20  # Limiting k to ensure the number remains within the given range\n    for k in range(max_k, 0, -1):\n        beautiful_number = (2**k - 1) * (2**k - 1)\n        if n % beautiful_number == 0:\n            return beautiful_number\n    return 1  # If no beautiful divisor found, return 1 as per definition\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the result\nprint(greatest_beautiful_divisor(n))"}
{"solution": "3\nfrom itertools import product\n\nMOD = 10**9 + 7\n\ndef count_d_magic(m, d, a, b):\n    def count_up_to(n, m, d):\n        if n == 0:\n            return 0\n        n_str = str(n)\n        n_digits = len(n_str)\n        dp = [[[0 for _ in range(2)] for _ in range(11)] for _ in range(n_digits + 1)]\n        dp[0][0][0] = 1\n        \n        for i in range(n_digits):\n            for j in range(10):\n                for has_d in range(2):\n                    next_digit = int(n_str[i]) if i < n_digits - 1 else 9\n                    for k in range(next_digit + 1):\n                        next_has_d = has_d or (k == d and i % 2 == 1)\n                        if (k == d) != (i % 2 == 1):\n                            continue\n                        dp[i + 1][k][next_has_d] += dp[i][j][has_d]\n                        dp[i + 1][k][next_has_d] %= MOD\n        \n        result = sum(dp[n_digits][i][1] for i in range(10)) % MOD\n        return result * pow(10 ** n_digits, m - 1, MOD) % MOD\n    \n    return (count_up_to(b, m, d) - count_up_to(a - 1, m, d) + MOD) % MOD\n\nif __name__ == \"__main__\":\n    m, d = map(int, input().split())\n    a = int(input())\n    b = int(input())\n    print(count_d_magic(m, d, a, b))"}
{"solution": "n, m = map(int, input().split())\ncandies_needed = list(map(int, input().split()))\n\n# Track the effective position of each child\neffective_positions = {i+1: i for i in range(n)}\n\n# The current position in the line\ncurrent_position = 0\n\n# Simulate the process\nwhile True:\n    # Determine the actual index of the child at the current position\n    actual_index = effective_positions[current_position + 1]\n    \n    # Distribute candies\n    candies_needed[actual_index] -= m\n    \n    # Check if the child has enough candies\n    if candies_needed[actual_index] <= 0:\n        # The child goes home\n        del effective_positions[current_position + 1]\n        \n        # If only one child remains, they are the last one\n        if len(effective_positions) == 1:\n            last_child = next(iter(effective_positions.keys()))\n            break\n    else:\n        # Update the effective position of the child\n        effective_positions[current_position + 1] = effective_positions.pop(current_position + 1)\n        current_position = (current_position + 1) % len(effective_positions)\n\nprint(last_child)"}
{"solution": "# Importing necessary library\nfrom math import inf\n\n# Defining the function to calculate the minimum number of bills\ndef min_bills(n):\n    # Denominations of dollar bills\n    denominations = [100, 20, 10, 5, 1]\n    \n    # Initializing the count of bills\n    count = 0\n    \n    # Loop through each denomination\n    for denom in denominations:\n        # Calculate the number of bills for the current denomination\n        count += n // denom\n        # Update the remaining amount\n        n %= denom\n    \n    # Return the total count of bills\n    return count\n\n# Reading the input\nn = int(input())\n\n# Calculating and printing the output\nprint(min_bills(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial(n):\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = i * fact[i - 1] % MOD\n    return fact\n\ndef inverse_factorial(n, fact):\n    inv_fact = [1] * (n + 1)\n    inv_fact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 1, -1):\n        inv_fact[i - 1] = i * inv_fact[i] % MOD\n    return inv_fact\n\ndef binomial_coefficient(n, k, fact, inv_fact):\n    return fact[n] * inv_fact[k] * inv_fact[n - k] % MOD\n\ndef count_good_permutations(n, k):\n    fact = factorial(n)\n    inv_fact = inverse_factorial(n, fact)\n    \n    dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n            if j > 1:\n                dp[i][j] += dp[i - 2][j - 2]\n            dp[i][j] %= MOD\n    \n    result = 0\n    for i in range(max(0, k - n), min(k, n - 1) + 1):\n        result += dp[n][k - i] * binomial_coefficient(n - 1, i, fact, inv_fact)\n        result %= MOD\n    \n    return result\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(count_good_permutations(n, k))"}
{"solution": "from collections import Counter\nfrom heapq import heapify, heappop, heappush\n\ndef max_bouquet_beauty(n, k, beauties, colors):\n    def max_beauty_two_colors(beauties_color, k):\n        total_beauty = 0\n        max_heap = [-beauty for beauty in beauties_color[:k]]\n        heapify(max_heap)\n        for beauty in beauties_color[k:]:\n            if -max_heap[0] < beauty:\n                heappop(max_heap)\n                heappush(max_heap, -beauty)\n        return -sum(max_heap)\n\n    color_counts = Counter(colors)\n    if len(color_counts) == 1:\n        return -1\n\n    if len(color_counts) == 2:\n        if 'W' in color_counts and 'R' in color_counts:\n            return -1\n\n    color_beauties = {'W': [], 'O': [], 'R': []}\n    for beauty, color in zip(beauties, colors):\n        color_beauties[color].append(beauty)\n\n    max_beauty = -1\n    for color, _ in color_counts.items():\n        other_colors = [c for c in 'WOR' if c != color]\n        for other_color in other_colors:\n            if other_color in color_counts:\n                combined_beauties = color_beauties[color] + color_beauties[other_color]\n                combined_beauties.sort(reverse=True)\n                if len(combined_beauties) >= k:\n                    max_beauty = max(max_beauty, sum(combined_beauties[:k]))\n\n        if len(color_counts) > 2:\n            single_color_max = max_beauty_two_colors(color_beauties[color], k)\n            max_beauty = max(max_beauty, single_color_max)\n\n    return max_beauty\n\n# Reading input\nn, k = map(int, input().split())\nbeauties = list(map(int, input().split()))\ncolors = input()\n\n# Computing and printing output\nprint(max_bouquet_beauty(n, k, beauties, colors))"}
{"solution": "from math import gcd\n\ndef read_ints():\n    return map(int, input().split())\n\ndef continued_fraction_to_rational(a):\n    p, q = a[-1], 1\n    for ai in reversed(a[:-1]):\n        p, q = ai * p + q, p\n    return p, q\n\ndef simplify(p, q):\n    g = gcd(p, q)\n    return p // g, q // g\n\np, q = read_ints()\nn = int(input())\na = list(read_ints())\n\np_cf, q_cf = continued_fraction_to_rational(a)\np_cf, q_cf = simplify(p_cf, q_cf)\np, q = simplify(p, q)\n\nprint(\"YES\" if p == p_cf and q == q_cf else \"NO\")"}
{"solution": "def shift_stick(expression):\n    a, b, c = map(lambda x: x.count('|'), expression.split('+')[0], expression.split('=')[0].split('+')[1], expression.split('=')[1])\n    \n    if a + b == c:\n        return expression\n    \n    for i in range(1, 101):\n        if a + 1 + b == c + i or a - 1 + b == c - i or a + b + 1 == c + i or a + b - 1 == c - i:\n            new_a, new_b, new_c = a, b, c\n            \n            if a + 1 + b == c + i:\n                new_a += 1\n                new_c += i\n            elif a - 1 + b == c - i:\n                new_a -= 1\n                new_c -= i\n            elif a + b + 1 == c + i:\n                new_b += 1\n                new_c += i\n            else:\n                new_b -= 1\n                new_c -= i\n                \n            new_expression = '|' * new_a + '+|' + '|' * new_b + '=|' * (new_c // 2)\n            \n            return new_expression.replace('||', '|').replace('+|', '+').replace('=|', '=')\n    \n    return \"Impossible\"\n\nexpression = input().strip()\nprint(shift_stick(expression))"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial_mod(n):\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    return fact\n\ndef inverse_factorial_mod(fact, n):\n    inv_fact = [1] * (n + 1)\n    inv_fact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        inv_fact[i - 1] = inv_fact[i] * i % MOD\n    return inv_fact\n\ndef combination_mod(n, k, fact, inv_fact):\n    return fact[n] * inv_fact[k] * inv_fact[n - k] % MOD\n\ndef number_of_permutations(n, k):\n    fact = factorial_mod(n)\n    inv_fact = inverse_factorial_mod(fact, n)\n    \n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i * i, -1, -1):\n            if j >= i:\n                dp[i][j] = dp[i - 1][j - i] * (i - 1) % MOD\n            if j >= 2 * i:\n                dp[i][j] += dp[i - 1][j - 2 * i]\n            dp[i][j] %= MOD\n            \n            if j >= i:\n                dp[i][j] += dp[i - 1][j]\n            dp[i][j] %= MOD\n                \n    result = 0\n    for j in range(k + 1):\n        if (k - j) % 2 == 0:\n            result += combination_mod(n, j, fact, inv_fact) * dp[n][j] * dp[n][k - j]\n            result %= MOD\n        else:\n            result -= combination_mod(n, j, fact, inv_fact) * dp[n][j] * dp[n][k - j]\n            result %= MOD\n            \n    return result % MOD\n\nn, k = map(int, input().split())\nprint(number_of_permutations(n, k))"}
{"solution": "from itertools import product\n\ndef solve(N, points):\n    # Check if it's possible to reach all points with a single segment\n    for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n        if all(dx * x == dy * y for x, y in points):\n            return 1, [max(abs(dx * x) for x, _ in points)], ['R' * dx + 'U' * dy for _, y in points]\n    \n    # Check combinations of two segments\n    for (dx1, dy1), (dx2, dy2) in product([(1, 0), (-1, 0), (0, 1), (0, -1)], repeat=2):\n        if all(dx1 * x1 + dx2 * x2 == dy1 * y1 + dy2 * y2 for (x1, y1), (x2, y2) in zip(points, points[1:])):\n            lengths = [max(abs(dx1 * x) for x, _ in points), max(abs(dy1 * y) for _, y in points)]\n            directions = ['R' * dx1 + 'U' * dy1 for _, y in points]\n            return 2, lengths, directions\n    \n    # If not possible with 1 or 2 segments, try with 40\n    m = 40\n    d = [1] * m\n    w = []\n    for x, y in points:\n        path = ''\n        for _ in range(m // 2):\n            if x > 0:\n                path += 'R'\n                x -= 1\n            elif x < 0:\n                path += 'L'\n                x += 1\n            else:\n                path += 'D'\n        for _ in range(m // 2):\n            if y > 0:\n                path += 'U'\n                y -= 1\n            elif y < 0:\n                path += 'D'\n                y += 1\n            else:\n                path += 'R'\n        w.append(path)\n    \n    return m, d, w\n\n# Read input\nN = int(input())\npoints = [list(map(int, input().split())) for _ in range(N)]\n\n# Solve and print output\nm, d, w = solve(N, points)\nif isinstance(m, int):\n    print(m)\n    print(' '.join(map(str, d)))\n    for path in w:\n        print(path)\nelse:\n    print(-1)"}
{"solution": "n = int(input())\ns = input()\n\ndef replace_fillers(s):\n    i = 0\n    result = []\n    while i < len(s):\n        if s[i:i+3] == 'ogo':\n            length = 3\n            while i + length <= len(s) and s[i:i+length] == 'ogo' * (length // 3):\n                length += 3\n            result.append('***')\n            i += length - 3\n        else:\n            result.append(s[i])\n        i += 1\n    return ''.join(result)\n\nprint(replace_fillers(s))"}
{"solution": "from math import sqrt\n\nMOD = 10**9 + 7\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return set(factors)\n\ndef max_power(n, p):\n    power = 0\n    while n % p == 0:\n        power += 1\n        n //= p\n    return p ** power\n\ndef compute_product(x, n):\n    total_product = 1\n    primes_x = prime_factors(x)\n    \n    for y in range(1, n + 1):\n        product_y = 1\n        for p in primes_x:\n            product_y = (product_y * max_power(y, p)) % MOD\n        total_product = (total_product * product_y) % MOD\n    \n    return total_product\n\nx, n = map(int, input().split())\nprint(compute_product(x, n))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for s in range(1, 82):  # s(x) can be at most 81\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and sum_of_digits(x) == s:\n            solutions.append(x)\n    solutions.sort()\n    return solutions\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find solutions\nsolutions = find_solutions(a, b, c)\n\n# Print results\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "from collections import Counter\n\ndef is_solvable_with_one_move(colors):\n    face_counts = Counter(colors)\n    if any(count != 4 for count in face_counts.values()):\n        return False\n    \n    faces = {color: [] for color in face_counts}\n    for i, color in enumerate(colors):\n        faces[color].append(i + 1)\n    \n    def check_face(face):\n        rotations = [\n            lambda x: (x - 1) % 4 + 1,\n            lambda x: (x - 1) % 4 + 5,\n            lambda x: (x - 5) % 4 + 5,\n            lambda x: (x - 5) % 4 + 1,\n        ]\n        \n        for rotate in rotations:\n            rotated = [rotate(index) for index in face]\n            if all(len(set(rotated).intersection(faces[color])) == 4 for color, face in faces.items() if color != center_color):\n                return True\n        return False\n    \n    for center_color, face in faces.items():\n        if check_face(face):\n            return True\n    return False\n\n# Reading input\ncolors = list(map(int, input().split()))\n\n# Processing and printing output\nprint(\"YES\" if is_solvable_with_one_move(colors) else \"NO\")"}
{"solution": "def find_hacks(p, x, y):\n    def simulate_score(s):\n        i = (s // 50) % 475\n        for _ in range(25):\n            i = (i * 96 + 42) % 475\n            if 26 + i == p:\n                return True\n        return False\n\n    min_hacks = float('inf')\n    for s in range(y, x + 1):\n        if simulate_score(s):\n            needed_points = max(y, s)\n            hacks = (needed_points - x) // 100\n            if (needed_points - x) % 100 != 0:\n                hacks += 1\n            min_hacks = min(min_hacks, hacks)\n            break\n\n    # Adjust for the case where we need to go above x to win and still get a T-shirt\n    if min_hacks == float('inf'):\n        for s in range(x + 1, x + 20001):  # Upper limit is arbitrary but safe\n            if simulate_score(s):\n                needed_points = max(y, s)\n                hacks = (needed_points - x) // 100\n                if (needed_points - x) % 100 != 0:\n                    hacks += 1\n                min_hacks = min(min_hacks, hacks)\n                break\n\n    return min_hacks\n\n# Read input\np, x, y = map(int, input().split())\n\n# Calculate and print the result\nprint(find_hacks(p, x, y))"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nmin_distance = min(a, b, c)\ntotal_distance = 0\n\nif n > 1:\n    total_distance += min(a, b)  # First move from Rabbit's house\n    if n > 2:\n        total_distance += (n - 2) * min(min_distance, c)\n\nprint(total_distance)"}
{"solution": "x1, x2, x3 = map(int, input().split())\ncoordinates = sorted([x1, x2, x3])\ndistance = coordinates[2] - coordinates[0] + coordinates[1] - coordinates[0]\nprint(distance)"}
{"solution": "from collections import Counter\n\ndef min_operations(n, x, arr):\n    bit_counts = [0] * 20  # Assuming max value is 100,000, which is less than 2^20\n    for num in arr:\n        for bit in range(20):\n            if num & (1 << bit):\n                bit_counts[bit] += 1\n    \n    # Check if x has bits that can never be set in any of the numbers\n    impossible_bits = sum((x >> bit) & 1 and bit_counts[bit] == 0 for bit in range(20))\n    \n    # If there are impossible bits, it's not possible to make two numbers equal\n    if impossible_bits > 0:\n        return -1\n    \n    # Count how many times each number appears\n    num_counts = Counter(arr)\n    # If there's already a duplicate, no operations needed\n    if max(num_counts.values()) > 1:\n        return 0\n    \n    # Calculate the target number after operations\n    target = x\n    for bit in range(20):\n        if bit_counts[bit] == n:\n            target &= ~(1 << bit)\n    \n    # Check if the target can be achieved\n    if target not in num_counts:\n        return -1\n    \n    # Calculate minimum operations needed\n    min_ops = n - num_counts[target]\n    for bit in range(20):\n        if (target & (1 << bit)) == 0 and bit_counts[bit] > 0:\n            min_ops = min(min_ops, n - bit_counts[bit])\n    \n    return min_ops\n\n# Read input\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Print output\nprint(min_operations(n, x, arr))"}
{"solution": "def is_plus_shape(grid):\n    h, w = len(grid), len(grid[0])\n    \n    def is_valid(x, y):\n        return 0 <= x < h and 0 <= y < w and grid[x][y] == '*'\n    \n    def dfs(x, y):\n        if not is_valid(x, y):\n            return False, 0, 0, 0, 0\n        grid[x] = grid[x][:y] + '.' + grid[x][y+1:]  # Mark as visited\n        up, down, left, right = 1, 1, 1, 1\n        \n        if x > 0:\n            _, du, _, dl, dr = dfs(x-1, y)\n            up += du\n            left += dl\n            right += dr\n        if x < h-1:\n            _, dd, _, dl, dr = dfs(x+1, y)\n            down += dd\n            left += dl\n            right += dr\n        if y > 0:\n            _, _, dl, _, _ = dfs(x, y-1)\n            left += dl\n        if y < w-1:\n            _, _, _, dr, _ = dfs(x, y+1)\n            right += dr\n        \n        return True, up, down, left, right\n    \n    center_found = False\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*':\n                if center_found:\n                    return \"NO\"\n                center_found, up, down, left, right = dfs(i, j)\n                if center_found and up > 1 and down > 1 and left > 1 and right > 1:\n                    continue\n                else:\n                    return \"NO\"\n    \n    return \"YES\" if center_found else \"NO\"\n\n# Example usage\nh, w = map(int, input().split())\ngrid = [input() for _ in range(h)]\nprint(is_plus_shape(grid))"}
{"solution": "def solve(n, a, b):\n    if n < a + b - 1:\n        return \"NO\"\n    \n    # Initialize the adjacency matrix\n    matrix = [['0' for _ in range(n)] for _ in range(n)]\n    \n    # Create 'a' connected components\n    start = 0\n    for i in range(a - 1):\n        for j in range(start, start + n // a):\n            for k in range(j + 1, start + n // a):\n                matrix[j][k] = matrix[k][j] = '1'\n        start += n // a\n    \n    # Handle the last component if the division is not exact\n    if start < n:\n        for j in range(start, n):\n            for k in range(j + 1, n):\n                matrix[j][k] = matrix[k][j] = '1'\n    \n    # Create 'b' connected components in the complement\n    if b > 1:\n        start = 0\n        for i in range(b - 1):\n            for j in range(start, start + n // b):\n                for k in range(start + n // b, n):\n                    matrix[j][k] = matrix[k][j] = '1'\n            start += n // b\n        \n        # Handle the last component if the division is not exact\n        if start < n:\n            for j in range(start, n):\n                for k in range(start + n // b, n):\n                    matrix[j][k] = matrix[k][j] = '1'\n    \n    return \"YES\", matrix\n\ndef print_matrix(matrix):\n    for row in matrix:\n        print(''.join(row))\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Solve and print result\nresult = solve(n, a, b)\nif isinstance(result, tuple):\n    print(\"YES\")\n    print_matrix(result[1])\nelse:\n    print(result)"}
{"solution": "def min_problems(c, d, n, m, k):\n    # Calculate the number of main rounds needed\n    main_rounds = -(-n * m // n)  # Ceiling division to ensure enough winners\n    # Adjust for pre-chosen winners\n    main_rounds = max(0, main_rounds - (k + n - 1) // n)\n    # Calculate the number of problems for main rounds\n    main_problems = main_rounds * c\n    # Calculate the number of additional rounds needed\n    additional_rounds = max(0, n * m - k - n * main_rounds)\n    # Calculate the number of problems for additional rounds\n    additional_problems = additional_rounds * d\n    # Return the total number of problems\n    return main_problems + additional_problems\n\n# Read input\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\n# Print the result\nprint(min_problems(c, d, n, m, k))"}
{"solution": "def find_grid_path(s):\n    # Check if 'S' and 'R' are adjacent in the string\n    if ('S' in s[:s.index('R')] and 'R' in s[:s.index('S')]) or abs(s.index('S') - s.index('R')) == 1:\n        return \"Impossible\"\n    \n    # Create the grid\n    grid = [['Y', 'X', 'W', 'V', 'U', 'T', 'G', 'H', 'I', 'J', 'K', 'L', 'M'],\n            ['Z', 'A', 'B', 'C', 'D', 'E', 'F', 'S', 'R', 'Q', 'P', 'O', 'N']]\n    \n    # Adjust positions based on the order of 'S' and 'R'\n    if s.index('S') < s.index('R'):\n        grid[1][6], grid[1][7] = grid[1][7], grid[1][6]\n    \n    # Convert grid to string format\n    grid_str = ''.join(grid[0]) + '\\n' + ''.join(grid[1])\n    \n    return grid_str\n\n# Read input\ns = input()\n\n# Solve and print the result\nprint(find_grid_path(s))"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<' if y > 1 else '='\n    elif y == 1:\n        return '>' if x > 1 else '='\n    else:\n        # Compute y * log(x) and x * log(y)\n        lhs = y * math.log(x)\n        rhs = x * math.log(y)\n        \n        if lhs < rhs:\n            return '<'\n        elif lhs > rhs:\n            return '>'\n        else:\n            return '='\n\n# Read input\nx, y = map(int, input().split())\n\n# Output the result of the comparison\nprint(compare_powers(x, y))"}
{"solution": "def max_balloons(r, h):\n    # Calculate the number of balloons that can fit vertically\n    vertical_balloons = h // r\n    \n    # Calculate the number of balloons that can fit horizontally in one layer\n    horizontal_balloons = 2  # Two balloons can fit side by side in the semicircular top\n    \n    # If there's enough vertical space for at least one layer, add the bottom row\n    if h >= r:\n        horizontal_balloons += 1\n    \n    # Total number of balloons is the product of horizontal and vertical fits\n    total_balloons = vertical_balloons * horizontal_balloons\n    \n    return total_balloons\n\n# Read input\nr, h = map(int, input().split())\n\n# Calculate and print the result\nprint(max_balloons(r, h))"}
{"solution": "from collections import Counter\n\ndef min_remaining_sum(cards):\n    counts = Counter(cards)\n    discarded = 0\n    \n    # Discard up to 3 cards of the most frequent number\n    for number, count in counts.items():\n        if count >= 3:\n            discarded += 3 * number\n            counts[number] = 0\n            break\n        elif count == 2:\n            discarded += 2 * number\n            counts[number] = 0\n            break\n    \n    # Calculate the sum of the remaining numbers\n    remaining_sum = sum(number * count for number, count in counts.items())\n    \n    return remaining_sum\n\n# Read input\ncards = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_remaining_sum(cards))"}
{"solution": "def min_distance(n, a, x):\n    x.sort()\n    if n == 1:\n        return 0\n    elif n == 2:\n        return min(abs(x[0] - a), abs(x[1] - a)) + abs(x[1] - x[0])\n    else:\n        start_idx = 0\n        for i in range(n):\n            if x[i] >= a:\n                start_idx = i\n                break\n        left_distance = abs(x[start_idx - 1] - a) if start_idx > 0 else float('inf')\n        right_distance = abs(x[start_idx] - a) if start_idx < n else float('inf')\n        \n        total_distance = float('inf')\n        if left_distance < right_distance:\n            total_distance = sum(x[n-2:start_idx-1:-1]) - sum(x[start_idx-1])\n        else:\n            total_distance = sum(x[n-2:start_idx:-1]) - sum(x[start_idx])\n            \n        return total_distance\n\n# Reading input\nn, a = map(int, input().split())\nx = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(min_distance(n, a, x))"}
{"solution": "import math\n\ndef s(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_smallest_root(n):\n    max_x = int(math.sqrt(n)) + 10000\n    for x in range(1, max_x + 1):\n        if x**2 + s(x) * x - n == 0:\n            return x\n    return -1\n\nn = int(input())\nprint(find_smallest_root(n))"}
{"solution": "from datetime import datetime, timedelta\n\ndef calculate_bed_time(current_time_str, sleep_duration_str):\n    \"\"\"\n    Calculates the time when George went to bed.\n    \n    :param current_time_str: Current time in \"hh:mm\" format.\n    :param sleep_duration_str: Sleep duration in \"hh:mm\" format.\n    :return: Time when George went to bed in \"hh:mm\" format.\n    \"\"\"\n    current_time = datetime.strptime(current_time_str, \"%H:%M\")\n    sleep_duration = datetime.strptime(sleep_duration_str, \"%H:%M\")\n    \n    # Calculate the bed time by subtracting sleep duration from current time\n    bed_time = current_time - timedelta(hours=sleep_duration.hour, minutes=sleep_duration.minute)\n    \n    # Adjust for the case when bed time is negative (George went to bed yesterday)\n    if bed_time.hour < 0:\n        bed_time = bed_time + timedelta(days=1)\n    \n    return bed_time.strftime(\"%H:%M\")\n\n# Reading input\ncurrent_time_str = input()\nsleep_duration_str = input()\n\n# Calculating and printing the bed time\nprint(calculate_bed_time(current_time_str, sleep_duration_str))"}
{"solution": "from itertools import accumulate\n\ndef max_mean_subsegment_length(n, arr):\n    \"\"\"\n    Finds the length of the longest subsegment with the maximum arithmetic mean.\n    \n    :param n: Length of the array.\n    :param arr: The array of integers.\n    :return: Length of the longest subsegment with the maximum arithmetic mean.\n    \"\"\"\n    prefix_sums = list(accumulate(arr, initial=0))\n    max_mean = -1\n    max_length = 0\n    dp = [float('-inf')] * (n + 1)\n    dp[0] = 0\n\n    for r in range(1, n + 1):\n        for l in reversed(range(r + 1)):\n            current_mean = (prefix_sums[r] - prefix_sums[l]) / (r - l)\n            if current_mean > max_mean:\n                max_mean = current_mean\n                max_length = r - l\n                break\n            elif current_mean == max_mean:\n                if r - l > max_length:\n                    max_length = r - l\n                    break\n            dp[r] = max(dp[r], dp[l] + (prefix_sums[r] - prefix_sums[l]))\n\n    return max_length\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Solving and printing output\nprint(max_mean_subsegment_length(n, arr))"}
{"solution": "MOD = 998244353\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef preprocess(n):\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n        invfact[i] = modinv(fact[i])\n    return fact, invfact\n\ndef comb(n, k, fact, invfact):\n    return fact[n] * invfact[k] * invfact[n - k] % MOD\n\ndef count_ways(n, m, k, fact, invfact):\n    result = 0\n    for j in range(k + 1):\n        c1 = comb(k, j, fact, invfact)\n        c2 = comb(n - 1, k, fact, invfact)\n        c3 = pow(m, j + 1, MOD)\n        c4 = pow(m - 1, k - j, MOD)\n        term = c1 * c2 * c3 * c4 % MOD\n        if (k - j) % 2 == 0:\n            result += term\n        else:\n            result -= term\n        result %= MOD\n    return result\n\ndef main():\n    n, m, k = map(int, input().split())\n    fact, invfact = preprocess(n)\n    print(count_ways(n, m, k, fact, invfact))\n\nmain()"}
{"solution": "import re\n\ndef is_magic_number(n):\n    # Define the regular expression pattern for magic numbers\n    pattern = re.compile(r'^(1|14|144)*$')\n    \n    # Check if the entire number matches the pattern\n    if pattern.match(str(n)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\n\n# Check and print the result\nprint(is_magic_number(n))"}
{"solution": "def min_moves_to_corners(n, m, i, j, a, b):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    \n    def min_steps(target, current, step, limit):\n        target_diff = abs(target - current)\n        full_steps, remainder = divmod(target_diff, step)\n        if remainder == 0:\n            return full_steps\n        else:\n            return full_steps + 1 if (full_steps + 1) * step <= limit else float('inf')\n    \n    # Calculate GCD to find the minimum steps in each direction\n    gcd_a_b = gcd(a, b)\n    \n    # Calculate minimum steps to reach each corner\n    corners = [(1, 1), (1, m), (n, 1), (n, m)]\n    min_steps_to_corner = float('inf')\n    \n    for corner in corners:\n        x_steps = min_steps(corner[0], i, a, n)\n        y_steps = min_steps(corner[1], j, b, m)\n        \n        # Check if both directions can be reached with valid steps\n        if x_steps != float('inf') and y_steps != float('inf'):\n            # Ensure the steps are aligned (both x and y movements are multiples of gcd(a, b))\n            if (x_steps * a) % gcd_a_b == 0 and (y_steps * b) % gcd_a_b == 0:\n                min_steps_to_corner = min(min_steps_to_corner, x_steps + y_steps)\n    \n    if min_steps_to_corner == float('inf'):\n        return \"Poor Inna and pony!\"\n    else:\n        return min_steps_to_corner\n\n# Example usage\nif __name__ == \"__main__\":\n    n, m, i, j, a, b = map(int, input().split())\n    print(min_moves_to_corners(n, m, i, j, a, b))"}
{"solution": "def max_removals(s):\n    removed = 0\n    while True:\n        max_char = ''\n        max_index = -1\n        for i in range(len(s)):\n            current_char = s[i]\n            prev_char = s[i-1] if i > 0 else ''\n            next_char = s[i+1] if i < len(s) - 1 else ''\n            \n            if (prev_char and ord(prev_char) + 1 == ord(current_char)) or \\\n               (next_char and ord(next_char) + 1 == ord(current_char)):\n                if not max_char or current_char > max_char:\n                    max_char = current_char\n                    max_index = i\n        \n        if max_index == -1:\n            break\n        s = s[:max_index] + s[max_index+1:]\n        removed += 1\n    \n    return removed\n\n# Reading input\nlength = int(input())\ns = input()\n\n# Calculating result\nresult = max_removals(s)\n\n# Printing output\nprint(result)"}
{"solution": "from bisect import bisect_left\n\ndef find_min_bills(denominations, k, target):\n    min_bills = float('inf')\n    n = len(denominations)\n    \n    for i in range(n):\n        for j in range(k + 1):\n            remaining = target - denominations[i] * j\n            if remaining == 0:\n                min_bills = min(min_bills, j)\n                continue\n            \n            for l in range(1, k - j + 1):\n                if remaining % l == 0:\n                    value = remaining // l\n                    pos = bisect_left(denominations, value)\n                    if pos < n and denominations[pos] == value:\n                        min_bills = min(min_bills, j + l)\n    \n    return min_bills if min_bills != float('inf') else -1\n\ndef process_queries(denominations, k, queries):\n    results = []\n    for query in queries:\n        results.append(find_min_bills(denominations, k, query))\n    return results\n\n# Read input\nn, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\nqueries = [int(input()) for _ in range(q)]\n\n# Process queries and print results\nresults = process_queries(denominations, k, queries)\nfor result in results:\n    print(result)"}
{"solution": "import math\n\ndef find_min_time(s, x1, x2, t1, t2, p, d):\n    if t2 <= t1:\n        return abs(x2 - x1) * t2\n\n    def meet_time(a, b, va, vb):\n        if a == b:\n            return 0\n        return abs(a - b) / (va + vb)\n\n    def next_meet(a, b, va, vb, dir):\n        if dir == 1:\n            if a < b:\n                return meet_time(a, b, va, vb)\n            else:\n                return (s - a + b) / va + (s - a + b) / vb\n        else:\n            if a > b:\n                return meet_time(a, b, va, vb)\n            else:\n                return (a - b + s) / va + (a - b + s) / vb\n\n    def solve(x1, x2, p, d, time=0):\n        if x1 == x2:\n            return time\n        if (x1 < x2) == (p < x1):\n            return solve(x1, x2, p, -d, time)\n        if d == 1:\n            if p < x1:\n                p = 0\n                d = 1\n            elif p > x2:\n                p = s\n                d = -1\n        else:\n            if p > x1:\n                p = s\n                d = -1\n            elif p < x2:\n                p = 0\n                d = 1\n        if x1 < x2:\n            if p < x1:\n                return min((x2 - x1) * t2, solve(x1, x2, p, d, next_meet(x1, p, t2, t1, d)))\n            elif p > x2:\n                return min((s - x1 + x2) * t2, solve(x1, x2, p, d, next_meet(x1, p, t2, t1, d)))\n            else:\n                return min((x2 - x1) * t2, solve(x1, x2, p, d, next_meet(x1, p, t2, t1, d)))\n        else:\n            if p > x1:\n                return min((x1 - x2) * t2, solve(x1, x2, p, d, next_meet(x1, p, t2, t1, d)))\n            elif p < x2:\n                return min((x1 - x2 + s) * t2, solve(x1, x2, p, d, next_meet(x1, p, t2, t1, d)))\n            else:\n                return min((x1 - x2) * t2, solve(x1, x2, p, d, next_meet(x1, p, t2, t1, d)))\n\n    return solve(x1, x2, p, d)\n\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\nprint(find_min_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "import math\n\nn, x = map(int, input().split())\n\ncount = 0\n\nfor i in range(1, n + 1):\n    if x % i == 0 and x // i <= n:\n        count += 1\n\nprint(count)"}
{"solution": "def generate_password(n, k):\n    password = []\n    alphabet = list(\"abcdefghijklmnopqrstuvwxyz\")[:k]\n    \n    for i in range(n):\n        if i % 2 == 0:\n            password.append(alphabet[i // 2 % len(alphabet)])\n        else:\n            password.append(alphabet[(i // 2) % len(alphabet) + 1 % (len(alphabet) - 1)])\n    \n    return \"\".join(password)\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    print(generate_password(n, k))"}
{"solution": "def first_collision_time(n, directions, positions):\n    min_time = float('inf')\n    collision_found = False\n    \n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            collision_time = (positions[i + 1] - positions[i]) // 2\n            min_time = min(min_time, collision_time)\n            collision_found = True\n    \n    if collision_found:\n        return min_time\n    else:\n        return -1\n\n# Example usage would look like:\n# n = int(input())\n# directions = input()\n# positions = list(map(int, input().split()))\n# print(first_collision_time(n, directions, positions))"}
{"solution": "from itertools import combinations\n\ndef max_seal_area(n, a, b, seals):\n    # Sort seals by their area in descending order, considering both orientations\n    seals.sort(key=lambda xy: max(xy[0] * xy[1], xy[0] * xy[1], xy[1] * xy[0]), reverse=True)\n    \n    max_area = 0\n    \n    # Check each pair of seals\n    for (x1, y1), (x2, y2) in combinations(seals, 2):\n        # Consider both orientations for each seal\n        orientations = [(x1, y1), (y1, x1), (x2, y2), (y2, x2)]\n        \n        for i, j in combinations(orientations, 2):\n            if i[0] <= a and i[1] <= b and j[0] <= a and j[1] <= b:\n                # Calculate area covered by both seals without overlapping\n                area = i[0] * i[1] + j[0] * j[1]\n                if i[0] >= j[0]:\n                    if i[1] >= j[1]:  # j inside i\n                        area -= min(j[0], a - i[0]) * min(j[1], b - i[1])\n                    else:  # j overlaps i vertically\n                        area -= min(j[0], a - i[0]) * j[1]\n                else:\n                    if i[1] >= j[1]:  # i inside j\n                        area -= min(i[0], a - j[0]) * min(i[1], b - j[1])\n                    else:  # i overlaps j vertically\n                        area -= min(i[0], a - j[0]) * i[1]\n                \n                max_area = max(max_area, area)\n                \n    return max_area\n\n# Read input\nn, a, b = map(int, input().split())\nseals = [list(map(int, input().split())) for _ in range(n)]\n\n# Print the result\nprint(max_seal_area(n, a, b, seals))"}
{"solution": "from collections import defaultdict\n\ndef find_outlier_point():\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(4 * n + 1)]\n    \n    x_counts = defaultdict(int)\n    y_counts = defaultdict(int)\n    \n    for x, y in points:\n        x_counts[x] += 1\n        y_counts[y] += 1\n    \n    # Find the outlier based on x-coordinates\n    outlier_x = None\n    for x, count in x_counts.items():\n        if count != 2 * n:\n            outlier_x = x\n            break\n    \n    # Find the outlier based on y-coordinates\n    outlier_y = None\n    for y, count in y_counts.items():\n        if count != 2 * n:\n            outlier_y = y\n            break\n    \n    # Return the outlier point\n    for x, y in points:\n        if x == outlier_x and y == outlier_y:\n            return (x, y)\n\noutlier_point = find_outlier_point()\nprint(*outlier_point)"}
{"solution": "def max_product_of_digits(n):\n    if n < 10:\n        return n\n    nine_count = 0\n    result = 1\n    if n >= 389:\n        while n >= 10:\n            n //= 10\n            nine_count += 1\n            if n <= 6:\n                break\n        result = 9 ** nine_count\n        if n > 6:\n            result *= n\n        else:\n            result *= 6\n            if nine_count == 0:\n                result *= n\n    else:\n        while n > 0:\n            result *= n % 10\n            n //= 10\n    return result\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the result\nprint(max_product_of_digits(n))"}
{"solution": "def find_min_k(n, votes_for_elodreip):\n    max_a = max(votes_for_elodreip)\n    elodreip_votes = sum(votes_for_elodreip)\n    \n    min_k = max_a\n    awruk_votes = 0\n    \n    while True:\n        awruk_votes = n * min_k - elodreip_votes\n        if awruk_votes > elodreip_votes:\n            return min_k\n        min_k += 1\n\n# Reading input\nn = int(input())\nvotes_for_elodreip = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(find_min_k(n, votes_for_elodreip))"}
{"solution": "from collections import deque\n\ndef operations_to_clear_points(colors):\n    \"\"\"\n    Determines the number of operations needed to clear all points with different-colored neighbors.\n    \n    :param colors: A string representing the colors of points in order.\n    :return: The number of operations needed.\n    \"\"\"\n    stack = deque()\n    operations = 0\n    prev_op_count = 0\n    \n    for color in colors:\n        if stack and stack[-1][0] == color:\n            stack[-1][1] += 1\n        else:\n            stack.append([color, 1])\n    \n    while True:\n        new_stack = deque()\n        op_count = 0\n        \n        while stack:\n            current = stack.pop()\n            if not stack or stack[-1][0] != current[0]:\n                new_stack.append(current)\n            else:\n                prev = stack.pop()\n                max_count = max(prev[1], current[1])\n                op_count += min(prev[1], current[1])\n                \n                if prev[1] > current[1]:\n                    new_stack.append(prev)\n                elif prev[1] < current[1]:\n                    stack.append(current)\n                else:\n                    stack.append(prev)\n        \n        if op_count == prev_op_count:\n            break\n        \n        prev_op_count = op_count\n        operations += 1\n        stack = new_stack\n    \n    return operations\n\n# Reading input\ncolors = input().strip()\n\n# Calculating and printing the result\nprint(operations_to_clear_points(colors))"}
{"solution": "import heapq\n\ndef find_min_triples(n, arr):\n    min_heap = []\n    for i, val in enumerate(arr):\n        heapq.heappush(min_heap, (val, i))\n\n    # Get the smallest value and its indices\n    smallest_val, indices = heapq.nsmallest(3, min_heap)[-1]\n    indices_of_smallest = [index for _, index in min_heap if _ == smallest_val]\n\n    # Count combinations\n    count = 0\n    left_count = 0\n    for idx in indices_of_smallest:\n        right_count = len(indices_of_smallest) - (left_count + 1)\n        if right_count > 0:\n            count += left_count * right_count\n        left_count += 1\n\n    return count\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Solving and printing output\nprint(find_min_triples(n, arr))"}
{"solution": "def min_cuts_for_pizza_friends(n):\n    \"\"\"\n    Calculates the minimum number of straight cuts needed to divide a pizza into n + 1 equal slices.\n    \n    Parameters:\n    n (int): The number of Shiro's friends.\n    \n    Returns:\n    int: The minimum number of straight cuts needed.\n    \"\"\"\n    return n if n <= 1 else (1 + (2 * (n - 1)) // 3)\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the output\nprint(min_cuts_for_pizza_friends(n))"}
{"solution": "def max_bank_account(state):\n    if state >= 0:\n        return state  # If the state is positive or zero, no need to change it.\n    str_state = str(state)\n    # Remove the last digit and convert back to int\n    option1 = int(str_state[:-1])\n    # Remove the second last digit and convert back to int\n    option2 = int(str_state[:-2] + str_state[-1])\n    # Return the maximum of the two options or the original state if removing digits makes it larger\n    return max(option1, option2, state)\n\n# Reading the state of the bank account\nstate = int(input())\n# Printing the maximum state of the bank account\nprint(max_bank_account(state))"}
{"solution": "def spinner_direction(start, end, n):\n    positions = {'v': 0, '<': 1, '^': 2, '>': 3}\n    start_pos = positions[start]\n    end_pos = positions[end]\n    \n    # Calculate the difference in positions\n    diff = (end_pos - start_pos) % 4\n    \n    # Determine the direction based on the difference and duration\n    if n % 4 == 0:\n        return 'undefined' if diff != 0 else 'cw'\n    elif diff == 1 or diff == -3:\n        return 'cw'\n    elif diff == -1 or diff == 3:\n        return 'ccw'\n    else:\n        return 'undefined'\n\n# Read input\nstart, end = input().split()\nn = int(input())\n\n# Output the direction\nprint(spinner_direction(start, end, n))"}
{"solution": "def count_standing_dominos(n, pushes):\n    stack = []\n    for i, push in enumerate(pushes):\n        if push != '.':\n            while stack and stack[-1] != push:\n                stack.pop()\n            if not stack or (stack[-1] == '.' and push == 'R'):\n                stack.append(push)\n        else:\n            if not stack or stack[-1] == 'L':\n                continue\n            else:\n                stack.append(push)\n    return len(stack)\n\n# Reading input\nn = int(input())\npushes = input().strip()\n\n# Calculating and printing the result\nprint(count_standing_dominos(n, pushes))"}
{"solution": "def find_permutation(n, m, leaders):\n    permutation = [-1] * n\n    current_position = 0\n    \n    for step in range(m):\n        target_leader = leaders[step] - 1\n        \n        # Calculate the distance from the current position to the target leader\n        distance = (target_leader - current_position) % n\n        \n        # Check if the distance is already determined and matches\n        if permutation[current_position] != -1 and permutation[current_position] != distance + 1:\n            return -1\n        \n        # Assign the distance to the current position\n        permutation[current_position] = distance + 1\n        \n        # Update the current position\n        current_position = target_leader\n    \n    # Fill the remaining positions with unused numbers\n    available_numbers = set(range(1, n + 1))\n    for i in range(n):\n        if permutation[i] == -1:\n            for num in sorted(available_numbers):\n                if (i + num) % n not in [x[0] for x in enumerate(permutation) if x[1] != -1]:\n                    permutation[i] = num\n                    available_numbers.remove(num)\n                    break\n    \n    # Verify the solution\n    current_position = 0\n    for step in range(m):\n        target_leader = leaders[step] - 1\n        if (current_position + permutation[current_position]) % n != target_leader:\n            return -1\n        current_position = target_leader\n    \n    return ' '.join(map(str, permutation))\n\n# Reading input\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(find_permutation(n, m, leaders))"}
{"solution": "from collections import deque\n\ndef max_number_after_swaps(num_str, k):\n    stack = []\n    for i, digit in enumerate(num_str):\n        while k > 0 and stack and stack[-1] < digit:\n            stack.pop()\n            k -= 1\n        if len(stack) < len(num_str):\n            stack.append(digit)\n    \n    # If there are still swaps left, use them to optimize from the end\n    n = len(num_str)\n    while k > 0:\n        i = n - 1\n        while i > 0 and k > 0:\n            if num_str[i] != stack[-1]:\n                break\n            i -= 1\n        if i == 0:\n            break\n        num_str = num_str[:i-1] + num_str[i] + num_str[i-1] + num_str[i+1:]\n        stack.pop()\n        k -= 1\n    \n    return ''.join(stack)\n\nif __name__ == \"__main__\":\n    num_str, k = input().split()\n    k = int(k)\n    result = max_number_after_swaps(list(num_str), k)\n    print(result)"}
{"solution": "def find_next_in_sequence(a, b, c):\n    # Check for arithmetic progression\n    if (b - a) == (c - b):\n        return str(c + (b - a))\n    \n    # Check for geometric progression\n    if b != 0 and c != 0 and (a != 0 and (b / a) == (c / b)):\n        next_geometric = c * (b // a)\n        if next_geometric // 1 == next_geometric:\n            return str(int(next_geometric))\n    \n    return \"42\"\n\n# Read input\nnumbers = list(map(int, input().split()))\n\n# Determine and print the next number\nprint(find_next_in_sequence(*numbers))"}
{"solution": "def max_distance(n, colors):\n    # Find the first and last occurrence of each color\n    first_occurrence = {}\n    last_occurrence = {}\n    \n    for i in range(n):\n        color = colors[i]\n        if color not in first_occurrence:\n            first_occurrence[color] = i\n        last_occurrence[color] = i\n    \n    # Get the list of unique colors\n    unique_colors = list(first_occurrence.keys())\n    \n    # Calculate the maximum distance\n    max_dist = 0\n    \n    # Compare distances from the first house to the last house of a different color\n    for color in unique_colors:\n        if colors[0] != color:\n            max_dist = max(max_dist, last_occurrence[color])\n        if colors[-1] != color:\n            max_dist = max(max_dist, n - 1 - first_occurrence[color])\n    \n    return max_dist\n\n# Reading input\nn = int(input())\ncolors = list(map(int, input().split()))\n\n# Printing output\nprint(max_distance(n, colors))"}
{"solution": "n, m, k = map(int, input().split())\n\nlane = (k - 1) // (2 * m) + 1\ndesk = ((k - 1) % (2 * m)) // 2 + 1\nside = \"L\" if ((k - 1) % 2 == 0) else \"R\"\n\nprint(lane, desk, side)"}
{"solution": "from collections import Counter\n\ndef final_card_color(cards):\n    color_counts = Counter(cards)\n    # Convert color names to numbers for easier manipulation\n    color_map = {'B': 0, 'G': 1, 'R': 2}\n    inverse_color_map = {0: 'B', 1: 'G', 2: 'R'}\n    \n    # Map colors to their counts\n    counts = [color_counts[color] for color in 'BGR']\n    \n    # Determine the possible final colors based on parity\n    possible_colors = []\n    for i in range(3):\n        if counts[i] % 2 == 1:\n            possible_colors.append(inverse_color_map[i])\n    \n    # If there's no odd count, or if there are odd counts for all colors,\n    # all colors are possible final colors.\n    if len(possible_colors) == 0 or len(possible_colors) == 3:\n        possible_colors = ['B', 'G', 'R']\n    \n    return ''.join(sorted(possible_colors))\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Print the result\nprint(final_card_color(s))"}
