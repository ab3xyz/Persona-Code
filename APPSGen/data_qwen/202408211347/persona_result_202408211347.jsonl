{"solution": "from collections import deque\n\ndef find_longest_accordion(s):\n    open_bracket = ord('[')\n    close_bracket = ord(']')\n    colon = ord(':')\n    vertical_bar = ord('|')\n\n    stack = deque()\n    max_length = -1\n    current_length = 0\n    has_open = False\n    has_colon_after_open = False\n\n    for char in s:\n        ascii_val = ord(char)\n        if ascii_val == open_bracket:\n            if has_open:\n                stack.append(current_length)\n                current_length = 0\n            has_open = True\n            has_colon_after_open = False\n        elif ascii_val == colon and has_open:\n            has_colon_after_open = True\n        elif ascii_val == vertical_bar and has_colon_after_open:\n            current_length += 1\n        elif ascii_val == close_bracket and has_colon_after_open:\n            if stack:\n                prev_length = stack.pop()\n                max_length = max(max_length, prev_length + 4 + current_length * 2)\n                current_length = 0\n                has_open = False\n            else:\n                break\n\n    return max_length\n\n# Read input\ns = input()\n\n# Calculate and print the result\nprint(find_longest_accordion(s))"}
{"solution": "def max_digit_sum(x):\n    x_str = str(x)\n    length = len(x_str)\n    \n    # Check if the number is all 9s, return x if true\n    if x_str == '9' * length:\n        return x\n    \n    # Find the position where we can increase the digit to 9\n    for i in range(length):\n        if x_str[i] != '9':\n            # Calculate the new number\n            new_num = int(x_str[:i] + str(int(x_str[i]) - 1) + '9' * (length - i - 1))\n            return new_num if new_num <= x else int(x_str[:i] + '9' * (length - i))\n    \n    return x\n\n# Reading input\nx = int(input())\n\n# Calculating and printing the result\nprint(max_digit_sum(x))"}
{"solution": "def next_lucky_year(n):\n    def is_lucky(year):\n        digits = [int(d) for d in str(year)]\n        non_zero_count = sum(1 for d in digits if d != 0)\n        return non_zero_count <= 1\n\n    while True:\n        n += 1\n        if is_lucky(n):\n            return n - int(n)\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the result\nprint(next_lucky_year(n))"}
{"solution": "from itertools import accumulate\n\ndef max_painted_sections(n, q, painters):\n    prefix_sum = [0] * (n + 1)\n    for l, r in painters:\n        prefix_sum[l - 1] += 1\n        prefix_sum[r] -= 1\n    coverage = list(accumulate(accumulate(prefix_sum), initial=0))\n    coverage.pop(0)  # Remove the initial zero added for accumulation\n    \n    max_covered = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            covered = coverage[j + 1] - coverage[i] - (coverage[i + 1] - coverage[0]) - (coverage[-1] - coverage[j + 1])\n            max_covered = max(max_covered, covered)\n    \n    return max_covered\n\n# Reading input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Solving and printing output\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def find_lucky_time(snooze_interval, wake_hour, wake_minute):\n    def has_seven(time):\n        return '7' in str(time)\n    \n    current_time = wake_hour * 60 + wake_minute\n    press_count = 0\n    \n    while not has_seven(current_time // 60) or not has_seven(current_time % 60):\n        current_time -= snooze_interval\n        press_count += 1\n        if current_time < 0:\n            current_time += 24 * 60\n            \n    return press_count\n\n# Input\nsnooze_interval = int(input())\nwake_hour, wake_minute = map(int, input().split())\n\n# Output\nprint(find_lucky_time(snooze_interval, wake_hour, wake_minute))"}
{"solution": "def min_seconds(n, pos, l, r):\n    if l <= pos <= r:\n        # If pos is within the range [l, r], calculate the minimum seconds needed\n        left_close = pos - l\n        right_close = r - pos\n        # Option 1: Close all to the left and then move to the right edge and close all to the right\n        option1 = left_close + 1 + right_close\n        # Option 2: Move to the right edge, close all to the right, then move to the left edge and close all to the left\n        option2 = (r - pos) + 1 + (pos - l)\n        return min(option1, option2)\n    else:\n        # If pos is outside the range [l, r], calculate the minimum move to get into the range\n        move_to_range = min(abs(pos - l), abs(pos - r))\n        # Closing all to one side\n        close_all = max(pos - l, r - pos)\n        return move_to_range + close_all\n\n# Reading input\nn, pos, l, r = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_seconds(n, pos, l, r))"}
{"solution": "from heapq import heappush, heappop\nfrom collections import defaultdict\n\ndef defeat_zmei(n, x, blows):\n    # Filter out blows that do not reduce the number of heads\n    useful_blows = [(h, d) for d, h in blows if d > h]\n    useless_blows = [d for d, h in blows if d <= h]\n\n    # If all blows are useless, check if we can win with the initial number of heads\n    if not useful_blows:\n        return 0 if x == 0 else -1\n\n    # Calculate the maximum damage per blow from useful blows\n    max_damage = max(d for _, d in useful_blows)\n\n    # Sum of damages for useless blows\n    total_useless_damage = sum(useless_blows)\n\n    # Total damage needed to defeat Zmei Gorynich\n    total_damage_needed = x - total_useless_damage\n\n    # Priority queue to store the blows by their healing value\n    priority_queue = []\n    for h, d in useful_blows:\n        heappush(priority_queue, (h, d))\n\n    # Dictionary to keep track of the number of times a blow has been used\n    blow_count = defaultdict(int)\n\n    # Counter for the number of blows dealt\n    blow_counter = 0\n\n    while total_damage_needed > 0:\n        if not priority_queue:\n            return -1\n\n        # Pop the blow with the lowest healing value\n        h, d = heappop(priority_queue)\n\n        # Update the total damage needed\n        total_damage_needed -= d\n\n        # Increment the counter for the number of blows\n        blow_counter += 1\n\n        # If the blow can still be used, push it back into the priority queue\n        if total_damage_needed < 0:\n            total_damage_needed += d\n            blow_counter -= 1\n\n        # Push the blow back if it's still useful\n        if blow_count[(h, d)] < (max_damage // d):\n            heappush(priority_queue, (h, d))\n            blow_count[(h, d)] += 1\n\n    return blow_counter + len(useless_blows)\n\n# Reading input\nt = int(input())\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    print(defeat_zmei(n, x, blows))"}
{"solution": "import math\n\ndef day_barn_becomes_empty(n, m):\n    if m == 0:\n        return n\n    # Calculate the day when the barn becomes empty\n    if n > m:\n        total_days = math.ceil((n + m) / (2 * m) - 0.5)\n    else:\n        total_days = math.ceil(math.sqrt(2 * n + 0.25) - 0.5)\n    return total_days\n\n# Read input\nn, m = map(int, input().split())\n\n# Output the result\nprint(day_barn_becomes_empty(n, m))"}
{"solution": "def min_tiles_to_draw(hand):\n    # Split the hand into individual tiles\n    tiles = hand.split()\n    \n    # Count the occurrences of each tile\n    counts = {}\n    for tile in tiles:\n        if tile in counts:\n            counts[tile] += 1\n        else:\n            counts[tile] = 1\n    \n    # Check for existing koutsu (triplet)\n    has_koutsu = any(count >= 3 for count in counts.values())\n    \n    # Check for existing shuntsu (sequence)\n    has_shuntsu = False\n    suits = {'m', 'p', 's'}\n    for suit in suits:\n        numbers = sorted(int(tile[:-1]) for tile in tiles if tile.endswith(suit))\n        for i in range(len(numbers) - 2):\n            if numbers[i] + 1 == numbers[i + 1] and numbers[i + 1] + 1 == numbers[i + 2]:\n                has_shuntsu = True\n                break\n    \n    # Determine the minimum number of tiles to draw\n    if has_koutsu or has_shuntsu:\n        return 0\n    elif len(tiles) == 3:\n        # If there are exactly three unique tiles, check if they can form a sequence with one more tile\n        unique_tiles = list(set(tiles))\n        if len(unique_tiles) == 3:\n            nums = sorted(int(tile[:-1]) for tile in unique_tiles)\n            if nums[0] + 1 == nums[1] and nums[1] + 1 == nums[2]:\n                return 1\n        return 2\n    else:\n        return 1\n\n# Read input\nhand = input()\n\n# Print the result\nprint(min_tiles_to_draw(hand))"}
{"solution": "import sys\n\ndef find_grandpas_sofa(d, n, m, sofas, cnt):\n    def count_relations(sofa, relation):\n        x1, y1, x2, y2 = sofa\n        return sum(1 for other in sofas if other != sofa and relation(x1, y1, x2, y2, *other))\n\n    def left_of(x1, y1, x2, y2, xo1, yo1, xo2, yo2):\n        return (y1 > yo2 and y2 > yo2 and (x1 == xo2 or x2 == xo2)) or (y1 > yo1 and y2 > yo1 and (x1 == xo1 or x2 == xo1))\n\n    def right_of(x1, y1, x2, y2, xo1, yo1, xo2, yo2):\n        return (y1 < yo1 and y2 < yo1 and (x1 == xo1 or x2 == xo1)) or (y1 < yo2 and y2 < yo2 and (x1 == xo2 or x2 == xo2))\n\n    def top_of(x1, y1, x2, y2, xo1, yo1, xo2, yo2):\n        return (x1 > xo2 and x2 > xo2 and (y1 == yo2 or y2 == yo2)) or (x1 > xo1 and x2 > xo1 and (y1 == yo1 or y2 == yo1))\n\n    def bottom_of(x1, y1, x2, y2, xo1, yo1, xo2, yo2):\n        return (x1 < xo1 and x2 < xo1 and (y1 == yo1 or y2 == yo1)) or (x1 < xo2 and x2 < xo2 and (y1 == yo2 or y2 == yo2))\n\n    for i, sofa in enumerate(sofas):\n        counts = [\n            count_relations(sofa, left_of),\n            count_relations(sofa, right_of),\n            count_relations(sofa, top_of),\n            count_relations(sofa, bottom_of)\n        ]\n        if counts == cnt:\n            return i + 1\n    return -1\n\nd = int(sys.stdin.readline())\nn, m = map(int, sys.stdin.readline().split())\nsofas = [tuple(map(int, sys.stdin.readline().split())) for _ in range(d)]\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, sys.stdin.readline().split())\n\nresult = find_grandpas_sofa(d, n, m, sofas, [cnt_l, cnt_r, cnt_t, cnt_b])\nprint(result)"}
{"solution": "n = int(input())\n\nmin_rest = (n // 7) * 2\nmax_rest = min_rest\n\nif n % 7 >= 2:\n    max_rest += 1\nif n % 7 >= 5:\n    min_rest += 1\n\nprint(min_rest, max_rest)"}
{"solution": "def max_chocolates(n, a, b, p, q):\n    lcm = (a * b) // math.gcd(a, b)\n    full_cycles = n // lcm\n    red_only = a - lcm\n    blue_only = b - lcm\n    \n    red_full = full_cycles * (lcm // a) * p + min(red_only, n % lcm) * p\n    blue_full = full_cycles * (lcm // b) * q + min(blue_only, n % lcm) * q\n    \n    extra_red = (n // a - full_cycles * (lcm // a)) * p\n    extra_blue = (n // b - full_cycles * (lcm // b)) * q\n    \n    return max(red_full + extra_blue, blue_full + extra_red)\n\nimport math\n\n# Reading input\nn, a, b, p, q = map(int, input().split())\n\n# Calculating and printing the result\nprint(max_chocolates(n, a, b, p, q))"}
{"solution": "def max_golden_segment(trophies):\n    n = len(trophies)\n    prefix_sums = [0]\n    suffix_sums = [0]\n    \n    # Calculate prefix sums of non-golden trophies\n    for i in range(n):\n        prefix_sums.append(prefix_sums[-1] + (1 if trophies[i] == 'S' else 0))\n    \n    # Calculate suffix sums of non-golden trophies\n    for i in range(n - 1, -1, -1):\n        suffix_sums.insert(0, suffix_sums[0] + (1 if trophies[i] == 'S' else 0))\n    \n    max_beauty = 0\n    left_golden = 0\n    right_golden = 0\n    \n    for i in range(n):\n        if trophies[i] == 'G':\n            left_golden += 1\n        else:\n            # Potential swap here\n            left_non_golden = prefix_sums[i] - prefix_sums[left_golden]\n            right_non_golden = suffix_sums[right_golden] - suffix_sums[i + 1]\n            max_beauty = max(max_beauty, i - left_golden + 1 - left_non_golden + (right_golden - i - 1 - right_non_golden))\n        \n        while right_golden < n and trophies[right_golden] == 'G':\n            right_golden += 1\n    \n    return max_beauty\n\n# Reading input\nn = int(input())\ntrophies = input().strip()\n\n# Calculating and printing output\nprint(max_golden_segment(trophies))"}
{"solution": "from collections import defaultdict, deque\n\ndef topological_sort(n, k, prerequisites, main_courses):\n    graph = defaultdict(list)\n    indegree = [0] * (n + 1)\n    for course, deps in enumerate(prerequisites):\n        for dep in deps:\n            graph[dep].append(course + 1)\n            indegree[course + 1] += 1\n\n    queue = deque([course for course in main_courses if indegree[course] == 0])\n    visited = set()\n    sorted_courses = []\n\n    while queue:\n        course = queue.popleft()\n        sorted_courses.append(course)\n        visited.add(course)\n\n        for next_course in graph[course]:\n            indegree[next_course] -= 1\n            if indegree[next_course] == 0 and next_course not in visited:\n                queue.append(next_course)\n\n    if len(visited.intersection(set(main_courses))) != len(main_courses):\n        return -1\n\n    return len(sorted_courses), sorted_courses\n\ndef parse_input():\n    n, k = map(int, input().split())\n    main_courses = set(map(int, input().split()))\n    prerequisites = []\n    for _ in range(n):\n        num_deps, *deps = map(int, input().split())\n        prerequisites.append(deps)\n    return n, k, prerequisites, main_courses\n\ndef main():\n    n, k, prerequisites, main_courses = parse_input()\n    result = topological_sort(n, k, prerequisites, main_courses)\n    if result == -1:\n        print(-1)\n    else:\n        count, courses = result\n        print(count)\n        print(' '.join(map(str, courses)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_stack_sortable(arr):\n    stack = []\n    sorted_arr = []\n    for item in arr:\n        stack.append(item)\n        while stack and max(stack) <= min(arr[len(sorted_arr):]):\n            sorted_arr.append(stack.pop())\n    return len(stack) == 0\n\ndef restore_permutation(n, k, given):\n    remaining = list(range(1, n + 1))\n    for num in given:\n        remaining.remove(num)\n\n    def backtrack(index):\n        if index == k:\n            return is_stack_sortable(given + remaining)\n        if given[index] in remaining:\n            remaining.remove(given[index])\n            if backtrack(index + 1):\n                return True\n            remaining.append(given[index])\n        return False\n\n    if not backtrack(0):\n        return [-1]\n\n    result = given + sorted(remaining, reverse=True)\n    if is_stack_sortable(result):\n        return result\n    else:\n        return [-1]\n\n# Reading input\nn, k = map(int, input().split())\ngiven = list(map(int, input().split()))\n\n# Solving and printing output\noutput = restore_permutation(n, k, given)\nprint(*output)"}
{"solution": "a, b, c = map(int, input().split())\n\nif c == 0:\n    print(\"YES\" if a == b else \"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "def can_form_regular_sequence(cnt1, cnt2, cnt3, cnt4):\n    if cnt1 > cnt3 or cnt4 > cnt2:\n        return 0\n    if cnt1 + cnt2 != cnt3 + cnt4:\n        return 0\n    return 1\n\n# Reading input\ncnt1 = int(input())\ncnt2 = int(input())\ncnt3 = int(input())\ncnt4 = int(input())\n\n# Computing and printing the result\nprint(can_form_regular_sequence(cnt1, cnt2, cnt3, cnt4))"}
{"solution": "def standing_spectators(n, k, t):\n    \"\"\"\n    Calculates the number of spectators standing at time t.\n    \n    Parameters:\n    n (int): Total number of spectators.\n    k (int): The pattern repeats every k spectators.\n    t (int): The time at which to calculate the number of standing spectators.\n    \n    Returns:\n    int: Number of spectators standing at time t.\n    \"\"\"\n    full_cycles = t // k\n    partial_cycle_time = t % k\n    \n    if t <= n:\n        standing = min(t, n)\n    else:\n        standing = n - (full_cycles * (n - k))\n        \n        if partial_cycle_time > 0:\n            standing += partial_cycle_time\n        \n    return min(standing, n)\n\n# Reading input\nn, k, t = map(int, input().split())\n\n# Calculating and printing the result\nprint(standing_spectators(n, k, t))"}
{"solution": "def min_lexico_string(s):\n    # Initialize variables\n    t = []\n    u = []\n    sorted_s = sorted(s)\n    \n    # Process each character in sorted order\n    for char in sorted_s:\n        t.append(char)\n        \n    # Move characters from t to u\n    while t:\n        u.append(t.pop())\n    \n    return ''.join(u)\n\n# Read input\ninput_str = input()\n\n# Compute and print the result\nresult = min_lexico_string(input_str)\nprint(result)"}
{"solution": "def validate_records(plays_clears):\n    previous_play, previous_clear = 0, 0\n    for play, clear in plays_clears:\n        if play < previous_play or clear < previous_clear:\n            return \"NO\"\n        elif clear > previous_clear and play == previous_play:\n            return \"NO\"\n        previous_play, previous_clear = play, clear\n    return \"YES\"\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        records = [tuple(map(int, input().split())) for _ in range(n)]\n        print(validate_records(records))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_palindrome(time_str):\n    return time_str == time_str[::-1]\n\ndef next_palindrome_time(current_time):\n    hours, minutes = map(int, current_time.split(':'))\n    current_minutes = hours * 60 + minutes\n    next_time = current_minutes\n\n    while True:\n        next_time += 1\n        if next_time % 60 < 10:\n            time_str = f\"{next_time // 60:02d}:0{next_time % 60}\"\n        else:\n            time_str = f\"{next_time // 60:02d}:{next_time % 60:02d}\"\n        if is_palindrome(time_str.replace(\":\", \"\")):\n            return time_str\n        if next_time == 24 * 60:\n            next_time = 0\n\ndef min_sleep_for_palindrome_wake_up(current_time):\n    next_palindrome = next_palindrome_time(current_time)\n    current_minutes = int(current_time[:2]) * 60 + int(current_time[3:])\n    next_palindrome_minutes = int(next_palindrome[:2]) * 60 + int(next_palindrome[3:])\n    return (next_palindrome_minutes - current_minutes) % (24 * 60)\n\n# Example usage\ncurrent_time = input().strip()\nprint(min_sleep_for_palindrome_wake_up(current_time))"}
{"solution": "def max_distance_after_swap(n, arr):\n    min_pos, max_pos = None, None\n    for i, value in enumerate(arr):\n        if value == 1 and min_pos is None:\n            min_pos = i\n        elif value == n and max_pos is None:\n            max_pos = i\n    \n    # If min and max are already at the ends, no swap needed for max distance\n    if min_pos == 0 and max_pos == n - 1:\n        return max_pos - min_pos\n    elif max_pos == 0 and min_pos == n - 1:\n        return max_pos - min_pos\n    \n    # Calculate max distance after swap\n    max_dist = max(max_pos, n - 1 - min_pos)\n    \n    return max_dist\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Printing output\nprint(max_distance_after_swap(n, arr))"}
{"solution": "def is_s_palindrome(s):\n    length = len(s)\n    mid = length // 2\n    \n    # If the length is odd, ignore the middle character\n    if length % 2 != 0:\n        mid_part = s[:mid]\n        mirrored_mid_part = s[mid+1:][::-1]\n    else:\n        mid_part = s[:mid]\n        mirrored_mid_part = s[mid:][::-1]\n    \n    return mid_part == mirrored_mid_part\n\ns = input().strip()\nprint(\"TAK\" if is_s_palindrome(s) else \"NIE\")"}
{"solution": "def max_permutation(a, b):\n    a_str, b_str = str(a), str(b)\n    a_len, b_len = len(a_str), len(b_str)\n    \n    if a_len > b_len:\n        return -1\n    \n    result = [-1] * a_len\n    a_list = list(a_str)\n    a_list.sort(reverse=True)\n    \n    for i in range(a_len):\n        for j in range(len(a_list)):\n            if int(a_list[j]) <= int(b_str[i]):\n                result[i] = a_list[j]\n                a_list[j] = -1\n                break\n        \n        # Reassign unused digits\n        for j in range(len(a_list)):\n            if a_list[j] == -1:\n                for k in range(j + 1, len(a_list)):\n                    if a_list[k] != -1:\n                        a_list[j], a_list[k] = a_list[k], -1\n                        break\n    \n    return ''.join(result)\n\n# Reading input\na = int(input().strip())\nb = int(input().strip())\n\n# Calculating and printing output\nprint(max_permutation(a, b))"}
{"solution": "def check_win(board):\n    def check_line(line):\n        count = 0\n        for char in line:\n            if char == 'X':\n                count += 1\n            else:\n                count = 0\n            if count >= 5:\n                return True\n        return False\n\n    # Check rows\n    for row in board:\n        if check_line(row):\n            return True\n\n    # Check columns\n    for col in zip(*board):\n        if check_line(col):\n            return True\n\n    # Check diagonals\n    for i in range(6, 11):\n        # Top left to bottom right\n        if check_line([board[x][x] for x in range(i)]):\n            return True\n        if check_line([board[x][i - x] for x in range(i)]):\n            return True\n        # Bottom left to top right\n        if check_line([board[10 - x - 1][x] for x in range(i)]):\n            return True\n        if check_line([board[10 - x - 1][i - x - 1] for x in range(i)]):\n            return True\n\n    return False\n\ndef can_win(board):\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i] = board[i][:j] + 'X' + board[i][j+1:]\n                if not check_win(board):\n                    board[i] = board[i][:j] + 'O' + board[i][j+1:]\n                    if not check_win(board):\n                        board[i] = board[i][:j] + '.' + board[i][j+1:]\n                        return \"YES\"\n                board[i] = board[i][:j] + '.' + board[i][j+1:]\n    return \"NO\"\n\n# Read input\nboard = [input() for _ in range(10)]\n\n# Solve and print output\nprint(can_win(board))"}
{"solution": "def create_symmetric_matrix(n, k):\n    matrix = [[0] * n for _ in range(n)]\n    placed_ones = 0\n    \n    # Fill the upper triangle and the diagonal\n    for i in range(n):\n        for j in range(i, n):\n            if placed_ones < k and (i == j or placed_ones + (n - i) + (n - i - 1) >= k):\n                matrix[i][j] = 1\n                placed_ones += 1\n                if i != j:\n                    matrix[j][i] = 1  # Symmetry\n\n    # Check if we placed all ones\n    if placed_ones != k:\n        return -1\n\n    return matrix\n\ndef print_matrix(matrix):\n    if matrix == -1:\n        print(-1)\n    else:\n        for row in matrix:\n            print(' '.join(map(str, row)))\n\n# Reading input\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\nprint_matrix(result)"}
{"solution": "def calculate_max_expression(x, y, z):\n    # Define the expressions\n    expressions = [\n        (x, y, z, \"x^y^z\"), \n        (x, z, y, \"x^z^y\"), \n        ((x**y), z, \"(x^y)^z\"), \n        ((x**z), y, \"(x^z)^y\"), \n        (y, x, z, \"y^x^z\"), \n        (y, z, x, \"y^z^x\"), \n        ((y**x), z, \"(y^x)^z\"), \n        ((y**z), x, \"(y^z)^x\"), \n        (z, x, y, \"z^x^y\"), \n        (z, y, x, \"z^y^x\"), \n        ((z**x), y, \"(z^x)^y\"), \n        ((z**y), x, \"(z^y)^x\")\n    ]\n    \n    max_value = -float('inf')\n    max_expression = \"\"\n    \n    for base, exp1, exp2, expr in expressions:\n        # Calculate the value of the expression using logarithms for comparison\n        if exp1 == 1:\n            value = exp2 * base\n        else:\n            value = exp2 * exp1 * base\n        \n        if value > max_value:\n            max_value = value\n            max_expression = expr\n    \n    return max_expression\n\n# Read input\nx, y, z = map(float, input().split())\n\n# Find and print the maximum expression\nprint(calculate_max_expression(x, y, z))"}
{"solution": "n = int(input())\ns = input()\n\ndef min_operations(s):\n    # Base case: If the string is empty or has a single character\n    if len(s) <= 1:\n        return len(s)\n    \n    # Initialize the minimum operations to the length of the string\n    min_ops = len(s)\n    \n    # Iterate through possible substrings to find the optimal repeat\n    for i in range(1, len(s)//2 + 1):\n        # Check if the current substring can form the whole string\n        if len(s) % i == 0:\n            substring = s[:i]\n            constructed = substring * (len(s) // i)\n            if constructed == s:\n                min_ops = i\n                break\n            else:\n                # Check if appending the substring can form the rest of the string\n                extra_needed = 1\n                while len(substring) * (len(s) // i + extra_needed) < len(s):\n                    extra_needed += 1\n                constructed_with_extra = substring * (len(s) // i + extra_needed)\n                if constructed_with_extra.endswith(s):\n                    min_ops = min(min_ops, i + extra_needed - 1)\n    \n    # Return the minimum operations needed\n    return min_ops\n\nprint(min_operations(s))"}
{"solution": "from collections import defaultdict\n\ndef rename_files(n, files):\n    # Sort files by type (example first)\n    files.sort(key=lambda x: x[1], reverse=True)\n    \n    # Track renamed files and current index\n    renamed = set()\n    index = 1\n    script = []\n    \n    # Function to rename a file\n    def rename(file_name, new_name):\n        if file_name not in renamed:\n            script.append(f\"move {file_name} {new_name}\")\n            renamed.add(file_name)\n    \n    # Rename example files\n    for name, is_example in files:\n        if is_example:\n            rename(name, str(index))\n            index += 1\n    \n    # Rename regular files\n    for name, _ in files:\n        if name not in renamed:\n            rename(name, str(index))\n            index += 1\n    \n    return len(script), script\n\n# Reading input\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\n# Solving and printing output\nscript_length, script = rename_files(n, files)\nprint(script_length)\nfor line in script:\n    print(line)"}
{"solution": "def min_changes_to_lucky_ticket(ticket):\n    left_sum = sum(int(digit) for digit in ticket[:3])\n    right_sum = sum(int(digit) for digit in ticket[3:])\n    diff = abs(left_sum - right_sum)\n    \n    # Calculate the minimum changes needed\n    return diff // 9 + (diff % 9 > 0)\n\n# Read input\nticket = input()\n\n# Print output\nprint(min_changes_to_lucky_ticket(ticket))"}
{"solution": "from math import gcd\n\ndef min_traps(m, x):\n    \"\"\"\n    Calculate the minimum number of traps needed to catch the x-mouse.\n    \n    :param m: Number of rooms in the campus.\n    :param x: The parameter of the x-mouse movement.\n    :return: Minimum number of traps required.\n    \"\"\"\n    if gcd(x, m) != 1:\n        raise ValueError(\"GCD(x, m) must be 1.\")\n    \n    # Calculate the minimum number of traps using the formula m/gcd(m, x)\n    return m // gcd(m, x)\n\n# Reading input\nm, x = map(int, input().split())\n\n# Calculating and printing the answer\nprint(min_traps(m, x))"}
{"solution": "from math import gcd\n\nMOD = 10**6 + 3\n\ndef mod_inverse(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    return x1 + m0 if x1 < 0 else x1\n\ndef mod_pow(base, exponent, modulus):\n    result = 1\n    base = base % modulus\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % modulus\n        exponent = exponent >> 1\n        base = (base * base) % modulus\n    return result\n\ndef calculate_probability(n, k):\n    n = pow(2, n, MOD - 1)\n    total_days = mod_pow(n, k, MOD)\n    distinct_birthdays = 1\n    for i in range(k):\n        distinct_birthdays = (distinct_birthdays * (n - i)) % MOD\n    distinct_birthdays = mod_pow(distinct_birthdays, MOD - 2, MOD)  # Inverse for distinct birthdays\n    total_days = mod_pow(total_days, MOD - 2, MOD)  # Inverse for total days\n    probability = (total_days - distinct_birthdays) % MOD\n    denominator = (total_days * mod_inverse(probability, MOD)) % MOD\n    return probability, denominator\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating and printing the result\nA, B = calculate_probability(n, k)\nprint(A, B)"}
{"solution": "def validate_journey(n, moves):\n    latitude = 0\n    longitude = 0\n    on_north_pole = True\n    on_south_pole = False\n    \n    for distance, direction in moves:\n        if on_north_pole and direction != \"South\":\n            return \"NO\"\n        if on_south_pole and direction != \"North\":\n            return \"NO\"\n        \n        if direction == \"North\":\n            latitude += distance\n        elif direction == \"South\":\n            latitude -= distance\n        elif direction == \"East\":\n            longitude += distance\n        elif direction == \"West\":\n            longitude -= distance\n        \n        on_north_pole = latitude == 20000\n        on_south_pole = latitude == -20000\n        \n        if on_south_pole and direction != \"North\":\n            return \"NO\"\n    \n    if not on_north_pole or longitude != 0:\n        return \"NO\"\n    \n    return \"YES\"\n\nif __name__ == \"__main__\":\n    n = int(input())\n    moves = []\n    for _ in range(n):\n        t_i, dir_i = input().split()\n        moves.append((int(t_i), dir_i))\n    print(validate_journey(n, moves))"}
{"solution": "from math import gcd\n\ndef find_common_values(a1, b1, a2, b2, L, R):\n    # Calculate the common difference that will be used to find the intersection points\n    common_diff = a1 * a2 // gcd(a1, a2)\n    \n    # Find the first and last possible k' and l' that satisfy the conditions within the range [L, R]\n    first_k = max(0, (L - b1 + a1 - 1) // a1)\n    last_k = min((R - b1) // a1, (R - b2) // a2) if (b1 - b2) % common_diff == 0 else -1\n    \n    first_l = max(0, (L - b2 + a2 - 1) // a2)\n    last_l = min((R - b2) // a2, (R - b1) // a1) if (b2 - b1) % common_diff == 0 else -1\n    \n    # If no valid k' or l' found, return 0\n    if last_k == -1 or last_l == -1:\n        return 0\n    \n    # Calculate the number of valid k' and l'\n    count_k = max(0, last_k - first_k + 1)\n    count_l = max(0, last_l - first_l + 1)\n    \n    # The final count is the minimum of the two, as we're looking for values that satisfy both equations\n    return min(count_k, count_l)\n\n# Reading input\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Calculating and printing the result\nprint(find_common_values(a1, b1, a2, b2, L, R))"}
{"solution": "def max_pieces_per_plate(n, a, b):\n    # Find the maximum number of pieces per plate\n    for x in range(min(a, b), 0, -1):\n        # Check if the distribution is possible\n        if (a // x + (a % x > 0)) + (b // x + (b % x > 0)) >= n:\n            return x\n    return 1\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(max_pieces_per_plate(n, a, b))"}
{"solution": "def is_berland_flag(n, m, flag):\n    def check_stripe(stripe, color):\n        return all(cell == color for cell in stripe)\n\n    if n % 3 != 0:\n        return \"NO\"\n\n    stripe_height = n // 3\n    colors = ['R', 'G', 'B']\n\n    for i in range(3):\n        for j in range(i + 1, 3):\n            top_stripe = flag[:stripe_height]\n            middle_stripe = flag[stripe_height:2 * stripe_height]\n            bottom_stripe = flag[2 * stripe_height:]\n\n            if (check_stripe(top_stripe, colors[i]) and\n                    check_stripe(middle_stripe, colors[j]) and\n                    check_stripe(bottom_stripe, colors[(i + j) % 3])):\n                return \"YES\"\n\n    return \"NO\"\n\n# Reading input\nn, m = map(int, input().split())\nflag = [input() for _ in range(n)]\n\n# Checking and printing the result\nprint(is_berland_flag(n, m, flag))"}
{"solution": "def find_coordinates(n):\n    layer = 0\n    x, y = 0, 0\n    while True:\n        # Top horizontal\n        for _ in range(6 * layer + 1):\n            if n == 0:\n                break\n            n -= 1\n            x -= 1\n        if n == 0:\n            break\n        # Left diagonal\n        for _ in range(6 * layer + 1):\n            if n == 0:\n                break\n            n -= 1\n            x += 1\n            y += 1\n        if n == 0:\n            break\n        # Up vertical\n        for _ in range(6 * layer + 1):\n            if n == 0:\n                break\n            n -= 1\n            y += 1\n        if n == 0:\n            break\n        # Right diagonal\n        for _ in range(6 * layer + 1):\n            if n == 0:\n                break\n            n -= 1\n            x += 1\n            y -= 1\n        if n == 0:\n            break\n        # Bottom horizontal\n        for _ in range(6 * layer + 1):\n            if n == 0:\n                break\n            n -= 1\n            x -= 1\n        if n == 0:\n            break\n        # Left diagonal\n        for _ in range(6 * layer + 1):\n            if n == 0:\n                break\n            n -= 1\n            x += 1\n            y -= 1\n        if n == 0:\n            break\n        layer += 1\n    return x, y\n\nn = int(input())\nx, y = find_coordinates(n)\nprint(x, y)"}
{"solution": "def can_break_shield(a, b, c):\n    for x in range(c // a + 1):\n        for y in range(c // b + 1):\n            if a * x + b * y == c:\n                return \"Yes\"\n    return \"No\"\n\n# Reading input\na, b, c = map(int, input().split())\n\n# Processing and printing output\nprint(can_break_shield(a, b, c))"}
{"solution": "def can_be_same_track(n, L, kefa_barriers, sasha_barriers):\n    for i in range(n):\n        if all((kefa_barriers[j] - sasha_barriers[i]) % L == sasha_barriers[j] for j in range(n)):\n            return \"YES\"\n    return \"NO\"\n\nif __name__ == \"__main__\":\n    n, L = map(int, input().split())\n    kefa_barriers = list(map(int, input().split()))\n    sasha_barriers = list(map(int, input().split()))\n    \n    print(can_be_same_track(n, L, kefa_barriers, sasha_barriers))"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    max_len = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if not is_palindrome(s[i:j]):\n                max_len = max(max_len, j-i)\n    return max_len\n\n# Reading input\ns = input().strip()\n\n# Computing and printing the result\nprint(longest_non_palindrome_substring(s))"}
{"solution": "n = int(input())\nrated = False\nunrated = True\nprev_rating = 4127\n\nfor _ in range(n):\n    a, b = map(int, input().split())\n    if a != b:\n        rated = True\n    if a < prev_rating:\n        unrated = False\n    prev_rating = a\n\nif rated:\n    print(\"rated\")\nelif unrated:\n    print(\"unrated\")\nelse:\n    print(\"maybe\")"}
{"solution": "def find_nearest_zero_distances(n, arr):\n    last_zero_pos = -1\n    distances = [0] * n\n    \n    # Forward pass to fill in distances up to the current position\n    for i in range(n):\n        if arr[i] == 0:\n            last_zero_pos = i\n        distances[i] = i - last_zero_pos\n    \n    last_zero_pos = n\n    # Backward pass to find the minimum distance from both sides\n    for i in reversed(range(n)):\n        if arr[i] == 0:\n            last_zero_pos = i\n        distances[i] = min(distances[i], last_zero_pos - i)\n    \n    return distances\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculating and printing output\nresult = find_nearest_zero_distances(n, arr)\nprint(' '.join(map(str, result)))"}
{"solution": "from math import gcd\n\ndef z_function(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            z[i] = min(r - i + 1, z[i - l])\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > r:\n            l, r = i, i + z[i] - 1\n    return z\n\ndef count_cyclical_strings(n, s):\n    m = len(s)\n    z = z_function(s + '#' + s)\n    periods = [i for i in range(1, m) if z[i + m + 1] == m - i]\n    \n    result = 0\n    for period in periods:\n        result += n // period\n    \n    result -= len(periods)\n    result += n\n    \n    return result\n\n# Reading input\nn = int(input())\ns = input()\n\n# Calculating and printing the result\nprint(count_cyclical_strings(n, s))"}
{"solution": "import math\n\ndef main():\n    def angle(x, y):\n        return math.atan2(y, x)\n\n    def non_oriented_angle(a1, a2):\n        diff = abs(a1 - a2)\n        return min(diff, math.pi - diff)\n\n    n = int(input())\n    vectors = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        vectors.append((x, y))\n\n    # Calculate angles for all vectors\n    angles = [angle(x, y) for x, y in vectors]\n\n    # Sort angles while keeping track of original indices\n    sorted_angles = sorted((ang, i) for i, ang in enumerate(angles))\n\n    # Initialize variables\n    min_angle = math.pi\n    min_pair = None\n\n    # Check adjacent angles\n    for i in range(n - 1):\n        current_angle = non_oriented_angle(sorted_angles[i][0], sorted_angles[i + 1][0])\n        if current_angle < min_angle:\n            min_angle = current_angle\n            min_pair = sorted_angles[i][1], sorted_angles[i + 1][1]\n\n    # Check wrap-around (first and last)\n    wrap_around_angle = non_oriented_angle(sorted_angles[-1][0], sorted_angles[0][0])\n    if wrap_around_angle < min_angle:\n        min_angle = wrap_around_angle\n        min_pair = sorted_angles[-1][1], sorted_angles[0][1]\n\n    print(*sorted(min_pair) + 1)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from math import ceil\n\ndef min_time_to_post_office(d, k, a, b, t):\n    full_segments = d // k\n    last_segment = d % k\n    time_full_segments_car = full_segments * (k * a + t)\n    time_last_segment_car = last_segment * a\n    time_last_segment_foot = last_segment * b\n\n    # Check if it's better to walk the last segment or drive it\n    if time_last_segment_car > time_last_segment_foot:\n        return time_full_segments_car + time_last_segment_foot\n    else:\n        return time_full_segments_car + time_last_segment_car - t if full_segments > 0 else time_last_segment_car\n\n# Reading input\nd, k, a, b, t = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_time_to_post_office(d, k, a, b, t))"}
{"solution": "import math\n\ndef find_max_gcd_sequence(n, k):\n    if n < k:\n        return [-1]\n    \n    result = []\n    gcd = 1\n    remaining = n\n    \n    for i in range(k - 1):\n        if remaining <= gcd * k:\n            break\n        new_gcd = min(remaining // k, gcd + 1)\n        while remaining % new_gcd != 0:\n            new_gcd -= 1\n        gcd = new_gcd\n        result.append(gcd)\n        remaining -= gcd\n    \n    result.append(remaining)\n    \n    if sum(result) != n:\n        return [-1]\n    \n    return result\n\nn, k = map(int, input().split())\nsequence = find_max_gcd_sequence(n, k)\nprint(' '.join(map(str, sequence)))"}
{"solution": "n, m = map(int, input().split())\n\ndef count_divisible_by_5(n, m):\n    # Calculate full cycles of 5 and remainder for both n and m\n    full_cycles_n = n // 5\n    remainder_n = n % 5\n    full_cycles_m = m // 5\n    remainder_m = m % 5\n    \n    # Counts for each remainder value\n    counts_n = [full_cycles_n for _ in range(5)]\n    counts_m = [full_cycles_m for _ in range(5)]\n    \n    # Update counts based on remainders\n    counts_n[remainder_n] += 1\n    counts_m[remainder_m] += 1\n    \n    # Pairs that sum up to a multiple of 5\n    pairs = [\n        (0, 0), (0, 1), (0, 2), (0, 3), (0, 4),\n        (1, 4), (1, 0), (1, 2), (1, 3),\n        (2, 3), (2, 0), (2, 1), (2, 4),\n        (3, 2), (3, 1), (3, 0), (3, 4),\n        (4, 1), (4, 2), (4, 3), (4, 0)\n    ]\n    \n    result = 0\n    for x, y in pairs:\n        result += counts_n[x] * counts_m[y]\n    \n    return result\n\nprint(count_divisible_by_5(n, m))"}
{"solution": "import sys\n\ndef max_beauty(a, x):\n    max_ending_here = max_so_far = max_with_x = 0\n    for value in a:\n        max_ending_here = max(0, value, max_ending_here + value)\n        max_with_x = max(max_with_x, max_ending_here + value * (x - 1), value * x, 0)\n        max_so_far = max(max_so_far, max_with_x, max_ending_here)\n    return max_so_far\n\n# Reading input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(max_beauty(a, x))"}
{"solution": "import bisect\n\ndef kth_largest_in_multiplication_table(n, m, k):\n    def enough(x):\n        # Counts how many numbers are less than or equal to x in the table\n        count = sum(min(x // i, m) for i in range(1, n + 1))\n        return count >= k\n    \n    # Binary search between 1 and n*m\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if enough(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\n# Reading input\nn, m, k = map(int, input().split())\n\n# Solving and printing the result\nprint(kth_largest_in_multiplication_table(n, m, k))"}
{"solution": "import math\n\ndef find_kth_digit(k):\n    length = 1\n    count = 9\n\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n\n    start = 10 ** (length - 1)\n    number = start + (k - 1) // length\n    digit_index = (k - 1) % length\n    return int(str(number)[digit_index])\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "def max_profit(n, m, r, buy_prices, sell_prices):\n    buy_prices = sorted(buy_prices)\n    sell_prices = sorted(sell_prices, reverse=True)\n    \n    buy_ptr, sell_ptr = 0, 0\n    shares_bought = 0\n    money_spent = 0\n    \n    while buy_ptr < n and sell_ptr < m:\n        if buy_prices[buy_ptr] < sell_prices[sell_ptr]:\n            # Buy as much as possible with remaining money\n            shares_to_buy = (r - money_spent) // buy_prices[buy_ptr]\n            money_spent += shares_to_buy * buy_prices[buy_ptr]\n            shares_bought += shares_to_buy\n            buy_ptr += 1\n        else:\n            # Sell all bought shares\n            money_spent = 0\n            r = money_spent + shares_bought * sell_prices[sell_ptr]\n            shares_bought = 0\n            sell_ptr += 1\n    \n    # Sell remaining shares if any\n    if shares_bought > 0 and sell_ptr < m:\n        r = money_spent + shares_bought * sell_prices[sell_ptr]\n    \n    return r\n\n# Reading input\nn, m, r = map(int, input().split())\nbuy_prices = list(map(int, input().split()))\nsell_prices = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(max_profit(n, m, r, buy_prices, sell_prices))"}
{"solution": "def find_possible_overlap(t):\n    n = len(t)\n    for i in range(1, n // 2 + 1):\n        if n % i != 0:\n            continue\n        pattern = t[:i]\n        double_pattern = pattern * 2\n        if pattern * (n // i) == t:\n            return 'NO'\n        for j in range(1, i):\n            if t.startswith(double_pattern[j:i+j]):\n                return f'YES\\n{pattern}'\n    return 'NO'\n\n# Reading input\nt = input()\n\n# Processing and printing output\nprint(find_possible_overlap(t))"}
{"solution": "def find_teams(n):\n    def find_x(k):\n        x = int((k * (k - 1) / 2) ** 0.5)\n        return x * (x + 1) == k * (k - 1) // 2, x\n\n    possible_teams = []\n    while n > 0:\n        is_round_robin, x = find_x(n)\n        if is_round_robin:\n            possible_teams.append(n)\n            break\n        elif n % 2 == 1:\n            possible_teams.append(n)\n            break\n        else:\n            n = (n + 1) // 2\n\n    if not possible_teams:\n        possible_teams.append(-1)\n    else:\n        possible_teams.sort()\n\n    return possible_teams\n\ndef main():\n    n = int(input())\n    results = find_teams(n)\n    for team_count in results:\n        print(team_count)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import Counter\n\ndef max_beauty(n, s, b):\n    letter_counts = Counter(s)\n    # Ensure we can form an antipalindromic string\n    for count in letter_counts.values():\n        if count % 2 == 1:\n            return \"Impossible\"\n    \n    sorted_letters = sorted(letter_counts.items(), key=lambda x: -x[1])\n    sorted_indices = sorted(range(n), key=lambda i: -b[i])\n    \n    beauty = 0\n    used_letters = {}\n    \n    for i in sorted_indices:\n        found = False\n        for letter, _ in sorted_letters:\n            if letter not in used_letters and letter != s[i]:\n                s[i] = letter\n                used_letters[letter] = True\n                beauty += b[i]\n                found = True\n                break\n        if not found:\n            for letter, _ in sorted_letters:\n                if letter not in used_letters:\n                    s[i] = letter\n                    used_letters[letter] = True\n                    break\n    \n    return beauty\n\n# Reading input\nn = int(input())\ns = list(input())\nb = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(max_beauty(n, s, b))"}
{"solution": "def can_weight(w, m):\n    weights = [w**i for i in range(101)]\n    dp = [False] * (m + 1)\n    dp[0] = True\n    \n    for weight in weights:\n        for j in range(m, weight - 1, -1):\n            dp[j] = dp[j] or dp[j - weight]\n            if j >= weight and dp[j]:\n                dp[j] = True\n                \n    return \"YES\" if any(dp[m - weight] for weight in weights if m >= weight) else \"NO\"\n\n# Read input\nw, m = map(int, input().split())\n\n# Solve and print the result\nprint(can_weight(w, m))"}
{"solution": "import heapq\n\ndef find_sequence(n, k):\n    if n.bit_length() - 1 > k:\n        return \"No\"\n    \n    powers = []\n    remaining = n\n    current_power = n.bit_length() - 1\n    \n    while remaining > 0 and len(powers) < k:\n        if remaining & 1:\n            powers.append(current_power)\n        remaining >>= 1\n        current_power -= 1\n    \n    for _ in range(k - len(powers)):\n        powers.append(-10**18)\n    \n    max_power = max(powers)\n    if max_power < 0:\n        diff = k - sum(2**p == 1 for p in powers)\n        for i in range(len(powers)):\n            if powers[i] == -10**18 and diff > 0:\n                powers[i] = -1\n                diff -= 1\n    \n    if min(powers) > -10**18:\n        heapq._heapify_max(powers)\n        while powers[0] > -10**18:\n            max_val = heapq._heappop_max(powers)\n            new_val = max_val - 1\n            while new_val >= -10**18 and sum(2**p for p in powers) + 2**new_val > n:\n                new_val -= 1\n            heapq._heappush_max(powers, new_val)\n    \n    if sum(2**p for p in powers) != n:\n        return \"No\"\n    \n    return [\"Yes\", *map(str, sorted(powers, reverse=True))]\n\nn, k = map(int, input().split())\nprint(' '.join(find_sequence(n, k)))"}
{"solution": "def pour_champagne(n, t):\n    pyramid = [[0] * i for i in range(1, n + 1)]\n    pyramid[0][0] = t\n\n    for level in range(n):\n        for glass in range(level + 1):\n            overflow = (pyramid[level][glass] - 1) / 2.0\n            if overflow > 0:\n                pyramid[level + 1][glass] += overflow\n                if glass + 1 < level + 1:\n                    pyramid[level + 1][glass + 1] += overflow\n\n    full_glasses = sum(1 for level in pyramid for glass in level if glass >= 1)\n    return full_glasses\n\n# Reading input\nn, t = map(int, input().split())\n\n# Calculating and printing the result\nprint(pour_champagne(n, t))"}
{"solution": "def calculate_area(n, points):\n    x_coords = set()\n    y_coords = set()\n    \n    for _ in range(n):\n        x, y = map(int, input().split())\n        x_coords.add(x)\n        y_coords.add(y)\n    \n    if len(x_coords) == 1 or len(y_coords) == 1:\n        return -1\n    elif len(x_coords) == 2 and len(y_coords) == 2:\n        width = abs(max(x_coords) - min(x_coords))\n        height = abs(max(y_coords) - min(y_coords))\n        return width * height\n    else:\n        return -1\n\nn = int(input())\nprint(calculate_area(n, []))"}
{"solution": "def min_wooden_bars(n, a, b):\n    # Calculate the total length needed for the vertical sides of two doors\n    total_vertical_length = 2 * a * 2  # Two doors, each with two vertical sides\n    # Calculate the total length needed for the top sides of two doors\n    total_top_length = b * 2  # Two doors, each with one top side\n    \n    # Calculate the total length needed\n    total_length_needed = total_vertical_length + total_top_length\n    \n    # Calculate the minimum number of wooden bars needed\n    min_bars_needed = -(-total_length_needed // n)  # Ceiling division\n    \n    return min_bars_needed\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\n\n# Output the result\nprint(min_wooden_bars(n, a, b))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\ns = input()\n\n# Track the last position of each number\nlast_pos = {val: idx for idx, val in enumerate(a)}\n\n# Initialize the last forbidden index\nlast_forbidden = -1\nfor i in range(n - 1):\n    if s[i] == '0':  # If swapping is forbidden\n        last_forbidden = max(last_forbidden, i)\n    # Check if the current number is greater than the next number\n    # and the next number's last position is before the last forbidden index\n    if a[i] > a[i + 1] and last_pos[a[i + 1]] <= last_forbidden:\n        print(\"NO\")\n        exit()\n\nprint(\"YES\")"}
{"solution": "def time_to_serve(row_number, seat):\n    # Convert seat to numerical value for ordering (f=0, e=1, d=2, c=3, b=4, a=5)\n    seat_order = {'f': 0, 'e': 1, 'd': 2, 'c': 3, 'b': 4, 'a': 5}\n    seat_index = seat_order[seat]\n\n    # Calculate the number of complete cycles before reaching the current row\n    cycle = 1\n    while True:\n        if row_number <= cycle:\n            break\n        row_number -= cycle\n        cycle += 2\n\n    # Calculate the total time spent on full cycles\n    time_spent = sum(range(1, cycle, 2))\n\n    # Add time to serve all rows before the current row\n    time_spent += sum(range(1, 2 * (row_number - 1) + 1, 2))\n\n    # Add time to move to the current row\n    time_spent += row_number\n\n    # Add time to serve seats before the current seat\n    time_spent += 6 - seat_index\n\n    return time_spent\n\n# Read input\ninput_str = input().strip()\nrow_number = int(input_str[:-1])\nseat = input_str[-1]\n\n# Calculate and print the result\nprint(time_to_serve(row_number, seat))"}
{"solution": "def convert_to_decimal(digits, base):\n    # Convert a number from a given base to decimal\n    return sum(int(digit) * (base ** i) for i, digit in enumerate(reversed(digits)))\n\ndef compare_numbers(n, bx, x_digits, m, by, y_digits):\n    # Convert both numbers to decimal\n    x_decimal = convert_to_decimal(x_digits, bx)\n    y_decimal = convert_to_decimal(y_digits, by)\n\n    # Compare the decimal values\n    if x_decimal == y_decimal:\n        return \"=\"\n    elif x_decimal < y_decimal:\n        return \"<\"\n    else:\n        return \">\"\n\n# Read input\nn, bx = map(int, input().split())\nx_digits = input().split()\n\nm, by = map(int, input().split())\ny_digits = input().split()\n\n# Output the comparison result\nprint(compare_numbers(n, bx, x_digits, m, by, y_digits))"}
{"solution": "def calculate_nim_sum(sequence):\n    nim_sum = 0\n    for number in sequence:\n        nim_sum ^= number\n    return nim_sum\n\ndef determine_winner(n, sequence):\n    min_value = min(sequence)\n    nim_sum = calculate_nim_sum(sequence)\n    adjusted_sequence = [x - min_value for x in sequence]\n    adjusted_nim_sum = calculate_nim_sum(adjusted_sequence)\n    \n    # If the nim sum of the original sequence is 0 or the adjusted nim sum is 0,\n    # the first player (BitLGM) will lose because no winning move can be made.\n    if nim_sum == 0 or adjusted_nim_sum == 0:\n        return \"BitAryo\"\n    else:\n        return \"BitLGM\"\n\n# Reading input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Determining the winner\nwinner = determine_winner(n, sequence)\nprint(winner)"}
{"solution": "from math import gcd\nfrom collections import defaultdict\n\ndef count_valid_decks(n, k, cards):\n    \"\"\"\n    Counts the number of ways to remove cards from the top and bottom of the deck\n    such that the product of the remaining cards is divisible by k.\n    \"\"\"\n    prefix_gcds = [0] * (n + 1)\n    suffix_gcds = [0] * (n + 1)\n    \n    # Calculate prefix GCDs\n    for i in range(n):\n        if i == 0:\n            prefix_gcds[i + 1] = cards[i]\n        else:\n            prefix_gcds[i + 1] = gcd(prefix_gcds[i], cards[i])\n    \n    # Calculate suffix GCDs\n    for i in range(n - 1, -1, -1):\n        if i == n - 1:\n            suffix_gcds[i] = cards[i]\n        else:\n            suffix_gcds[i] = gcd(suffix_gcds[i + 1], cards[i])\n    \n    # Count valid decks\n    valid_decks = 0\n    last_prefix_divisible = -1\n    prefix_counts = defaultdict(int)\n    \n    for i in range(n + 1):\n        if i > 0 and gcd(prefix_gcds[i], k) == k:\n            last_prefix_divisible = i\n        if last_prefix_divisible >= 0:\n            if gcd(suffix_gcds[last_prefix_divisible], k) == k:\n                valid_decks += (n - i + 1)\n            else:\n                valid_decks += (n - last_prefix_divisible)\n                \n        prefix_counts[prefix_gcds[i]] += 1\n    \n    return valid_decks\n\n# Read input\nn, k = map(int, input().split())\ncards = list(map(int, input().split()))\n\n# Solve and print the result\nprint(count_valid_decks(n, k, cards))"}
{"solution": "from collections import Counter\n\ndef can_distribute_balloons(n, k, s):\n    # Count the frequency of each balloon color\n    color_count = Counter(s)\n    \n    # Find the maximum frequency of any color\n    max_color_count = max(color_count.values())\n    \n    # Check if it's possible to distribute the balloons\n    if max_color_count > k:\n        return \"NO\"\n    else:\n        return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ns = input()\n\n# Solve and print the result\nprint(can_distribute_balloons(n, k, s))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\nmin_value = min(a)\nfirst_occurrence = a.index(min_value)\na[first_occurrence] = float('inf')  # Mark the first occurrence so it's not considered again\nnext_occurrence = a.index(min_value)\n\ndistance = next_occurrence - first_occurrence\n\nprint(distance)"}
{"solution": "from math import gcd\n\ndef find_tie_probability(t, w, b):\n    numerator = 0\n    lcm = (w * b) // gcd(w, b)\n    \n    # Calculate the number of ties within one cycle of the LCM\n    cycle_ties = (lcm // w + lcm // b - 2) % lcm\n    \n    # Full cycles\n    full_cycles = t // lcm\n    numerator += full_cycles * cycle_ties\n    \n    # Remaining part\n    remainder = t % lcm\n    for i in range(1, remainder + 1):\n        if i % w == 0 and i % b == 0:\n            numerator += 1\n    \n    # Simplify the fraction\n    common_divisor = gcd(numerator, t)\n    simplified_numerator = numerator // common_divisor\n    simplified_denominator = t // common_divisor\n    \n    return f\"{simplified_numerator}/{simplified_denominator}\"\n\n# Read input\nt, w, b = map(int, input().split())\n\n# Output the result\nprint(find_tie_probability(t, w, b))"}
{"solution": "def determine_outcome(x, y, z):\n    # If z is 0, the outcome is certain based on x and y\n    if z == 0:\n        if x > y:\n            return \"+\"\n        elif y > x:\n            return \"-\"\n        else:\n            return \"0\"\n    \n    # If z is not 0, check if the outcome can be uncertain\n    if x + z > y or x < y:\n        if x > y + z or x + z < y:\n            return \"?\"\n        else:\n            if x + z == y or x == y + z:\n                return \"?\"\n            else:\n                if x > y:\n                    return \"+\"\n                else:\n                    return \"-\"\n    else:\n        return \"?\"\n\n# Reading input\nx, y, z = map(int, input().split())\n\n# Printing the output\nprint(determine_outcome(x, y, z))"}
{"solution": "def min_changes_to_reach_target(n, ops, target):\n    x, y = 0, 0\n    min_x, max_x = 0, 0\n    min_y, max_y = 0, 0\n    changes = 0\n    max_change = 0\n    required_x, required_y = target\n\n    for i, op in enumerate(ops):\n        if op == 'R':\n            x += 1\n            max_x = max(max_x, x)\n        elif op == 'L':\n            x -= 1\n            min_x = min(min_x, x)\n        elif op == 'U':\n            y += 1\n            max_y = max(max_y, y)\n        elif op == 'D':\n            y -= 1\n            min_y = min(min_y, y)\n\n        # Check if we can reach the target from the current position\n        if (max_x - min_x >= required_x and max_y - min_y >= required_y) or \\\n           (max_x - min_x >= required_x and y <= required_y <= max_y) or \\\n           (max_y - min_y >= required_y and x <= required_x <= max_x):\n            max_change = max(max_change, i + 1 - changes)\n\n        # Update changes needed to reach the target from the current position\n        if x > required_x or y > required_y:\n            changes = max(changes, x - required_x, y - required_y)\n    \n    # Calculate the minimum changes needed\n    min_changes = max(0, required_x - (max_x - min_x), required_y - (max_y - min_y))\n    if min_changes > n or max_change == 0:\n        return -1\n    else:\n        return max(max_change - min_changes, 0) + min_changes\n\n# Read input\nn = int(input())\nops = input().strip()\ntarget = list(map(int, input().split()))\n\n# Print output\nprint(min_changes_to_reach_target(n, ops, tuple(target)))"}
{"solution": "from collections import defaultdict\n\ndef count_good_prefixes(n, x, s):\n    prefix_counts = [0]\n    balance = 0\n    seen_balances = defaultdict(int)\n    seen_balances[0] = 1\n    \n    for char in s:\n        balance += 1 if char == '0' else -1\n        prefix_counts.append(balance)\n        seen_balances[balance] += 1\n    \n    result = 0\n    balance = 0\n    for char in s:\n        balance += 1 if char == '0' else -1\n        target_balance = balance + x\n        if target_balance in seen_balances:\n            result += seen_balances[target_balance]\n    \n    if x % (balance if balance != 0 else 1) == 0:\n        return -1\n    else:\n        return result\n\n# Reading input\nT = int(input())\n\nfor _ in range(T):\n    n, x = map(int, input().split())\n    s = input()\n    \n    # Calculating and printing output\n    print(count_good_prefixes(n, x, s))"}
{"solution": "n, k = map(int, input().split())\n\nstr_n = str(n)\nzero_count = str_n.count('0')\ntrailing_zeros = len(str_n) - len(str_n.rstrip('0'))\n\n# We need to remove digits until we have k trailing zeros or the entire number is removed\n# If the number already has k or more trailing zeros, no need to remove anything\ndigits_to_remove = 0\nif trailing_zeros < k:\n    # Count how many non-zero digits we need to remove\n    # We need to remove all digits except for the last k digits that could be zeros\n    digits_to_remove = len(str_n) - trailing_zeros - k\n\nprint(digits_to_remove)"}
{"solution": "def calculate_questions(n, m, k, x, y):\n    max_questions = k // (n * m) + min(k % (n * m), m)\n    min_questions = k // (n * m)\n    cycle_length = 2 * n - 2\n    cycle_count = k // (m * cycle_length)\n    remaining = k % (m * cycle_length)\n    sergi_questions = cycle_count * (n - abs(x - n) + 1)\n\n    if remaining > 0:\n        half_cycle = (remaining - 1) // m\n        if x <= n - half_cycle:\n            sergi_questions += max(0, min(m, remaining - half_cycle * m) >= y)\n        else:\n            sergi_questions += max(0, min(m, remaining - half_cycle * m) >= y)\n\n    return max_questions, min_questions, sergi_questions\n\n# Reading input\nn, m, k, x, y = map(int, input().split())\n\n# Calculating and printing output\nmax_q, min_q, sergi_q = calculate_questions(n, m, k, x, y)\nprint(max_q, min_q, sergi_q)"}
{"solution": "def max_beauty(s):\n    from collections import Counter\n    counts = Counter(s)\n    max_count = max(counts.values())\n    return max_count * len(s)\n\ndef optimal_beauty(n, s):\n    from collections import Counter\n    counts = Counter(s)\n    max_count = max(counts.values())\n    other_counts = [c for c in counts.values() if c != max_count]\n    \n    if n >= len(s) - max_count:\n        return len(s)\n    elif other_counts and n >= (len(s) - max_count) // 2:\n        second_max = max(other_counts)\n        return max_count + min(n - (len(s) - max_count), second_max)\n    else:\n        return max_count\n\ndef solve(n, ribbons):\n    kuro, shiro, katie = ribbons\n    kuro_beauty = optimal_beauty(n, kuro)\n    shiro_beauty = optimal_beauty(n, shiro)\n    katie_beauty = optimal_beauty(n, katie)\n    \n    if kuro_beauty > shiro_beauty and kuro_beauty > katie_beauty:\n        return \"Kuro\"\n    elif shiro_beauty > kuro_beauty and shiro_beauty > katie_beauty:\n        return \"Shiro\"\n    elif katie_beauty > kuro_beauty and katie_beauty > shiro_beauty:\n        return \"Katie\"\n    else:\n        return \"Draw\"\n\nn = int(input())\nribbons = [input() for _ in range(3)]\nprint(solve(n, ribbons))"}
{"solution": "def calculate_reading_days(c, v0, v1, a, l):\n    total_pages_read = 0\n    current_speed = v0\n    days = 0\n    while True:\n        days += 1\n        # Adjust speed based on max limit\n        if current_speed + a <= v1:\n            current_speed += a\n        else:\n            current_speed = v1\n        # Calculate pages to read today\n        pages_to_read_today = current_speed - l if days > 1 else current_speed\n        if total_pages_read + pages_to_read_today >= c:\n            break\n        total_pages_read += pages_to_read_today\n    return days\n\n# Reading input\nc, v0, v1, a, l = map(int, input().split())\n\n# Calculating and printing the result\nprint(calculate_reading_days(c, v0, v1, a, l))"}
{"solution": "from math import sqrt\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_primes_sum(n):\n    if n == 3:\n        return [3]\n    if is_prime(n - 2):\n        return [2, n - 2]\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        if is_prime(i) and is_prime(n - i - 2):\n            return [2, i, n - i - 2]\n\nn = int(input())\nprimes = find_primes_sum(n)\nprint(len(primes))\nprint(' '.join(map(str, primes)))"}
{"solution": "def can_destroy_all_walls(n, m, grid):\n    row_counts = [0] * n\n    col_counts = [0] * m\n    has_wall_in_row = set()\n    has_wall_in_col = set()\n\n    # Count walls in each row and column\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*':\n                row_counts[i] += 1\n                col_counts[j] += 1\n                has_wall_in_row.add(i)\n                has_wall_in_col.add(j)\n\n    # Check if there's a row or column with the same number of walls as the total\n    for i in range(n):\n        if row_counts[i] == len(has_wall_in_col):\n            return [\"YES\", [i + 1, list(has_wall_in_col)[0] + 1]]\n\n    for j in range(m):\n        if col_counts[j] == len(has_wall_in_row):\n            return [\"YES\", [list(has_wall_in_row)[0] + 1, j + 1]]\n\n    # Check if there's a cell where row and column walls match the total\n    for i in range(n):\n        for j in range(m):\n            if (grid[i][j] == '*' and\n                    (len(has_wall_in_row) - row_counts[i] == len(has_wall_in_col) - col_counts[j])):\n                return [\"YES\", [i + 1, j + 1]]\n\n    return [\"NO\"]\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Solve and print output\nresult = can_destroy_all_walls(n, m, grid)\nprint(result[0])\nif result[0] == \"YES\":\n    print(*result[1])"}
{"solution": "from math import gcd\n\ndef min_cost(n, m, a, b):\n    lcm = (m * n) // gcd(m, n)\n    remainder = n % m\n    cost_build = (m - remainder) % m * a if a < b else 0\n    cost_demolish = remainder * b if a >= b else 0\n    return min(cost_build, cost_demolish)\n\n# Reading input\nn, m, a, b = map(int, input().split())\n\n# Calculating and printing the output\nprint(min_cost(n, m, a, b))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\nmax_even_sum = 0\nmax_odd_sum = float('-inf')\ncurrent_even_sum = 0\ncurrent_odd_sum = float('-inf')\n\nfor num in a:\n    if num % 2 == 0:\n        current_even_sum += num\n        max_even_sum = max(max_even_sum, current_even_sum)\n        current_even_sum = max(0, current_even_sum)\n    else:\n        current_odd_sum = max(current_odd_sum + num, num)\n        max_odd_sum = max(max_odd_sum, current_odd_sum + max_even_sum)\n        current_even_sum = 0\n\nprint(max_odd_sum)"}
{"solution": "from collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef solve(n, T, songs):\n    dp = [[[0 for _ in range(4)] for _ in range(T + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 1\n    \n    song_durations = [0] * (n + 1)\n    song_genres = [0] * (n + 1)\n    \n    for i, (duration, genre) in enumerate(songs, start=1):\n        song_durations[i] = duration\n        song_genres[i] = genre\n    \n    for i in range(1, n + 1):\n        for j in range(T + 1):\n            for k in range(4):\n                dp[i][j][k] = dp[i - 1][j][0]\n                \n                if j >= song_durations[i] and k != song_genres[i]:\n                    dp[i][j][k] += dp[i - 1][j - song_durations[i]][song_genres[i]]\n                    dp[i][j][k] %= MOD\n    \n    return sum(dp[n][T]) % MOD\n\n# Reading input\nn, T = map(int, input().split())\nsongs = [list(map(int, input().split())) for _ in range(n)]\n\n# Solving and printing output\nprint(solve(n, T, songs))"}
{"solution": "from math import gcd\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef mod_inverse(x):\n    return pow(x, MOD - 2, MOD)\n\ndef expected_length(m):\n    dp = [0] * (m + 1)\n    dp[1] = 1\n    total_gcd = defaultdict(int)\n    total_gcd[1] = 1\n    for i in range(2, m + 1):\n        prev_total = total_gcd.copy()\n        for j in range(1, m + 1):\n            g = gcd(i, j)\n            dp[i] += dp[j]\n            total_gcd[g] += dp[j]\n        dp[i] = (dp[i] * 2) % MOD\n        total_gcd[1] += dp[i]\n        for k, v in prev_total.items():\n            dp[i] -= v\n            total_gcd[k] -= v\n        dp[i] = (dp[i] + MOD) % MOD\n    ans = dp[m]\n    inv_m = mod_inverse(m)\n    return (ans * inv_m) % MOD\n\nm = int(input())\nprint(expected_length(m))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(l, r, x, y):\n    def is_valid_pair(a, x, y):\n        b = y * x // a\n        return l <= a <= r and l <= b <= r and a * b == y and gcd(a, b) == x\n\n    count = 0\n    lcm_div_gcd = y // x\n    max_a = min(r, lcm_div_gcd * x)\n    \n    for a in range(max(1, l // (lcm_div_gcd * x)) * (lcm_div_gcd * x), max_a + 1, lcm_div_gcd * x):\n        if is_valid_pair(a, x, y):\n            count += 2  # Counting both (a, b) and (b, a)\n        if a == x:  # If a equals x, we've counted it twice, so subtract one\n            count -= 1\n    \n    return count\n\n# Reading input\nl, r, x, y = map(int, input().split())\n\n# Solving and printing the result\nprint(solve(l, r, x, y))"}
{"solution": "from math import gcd\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef find_smallest_k(a, b):\n    if a > b:\n        a, b = b, a\n    shift = 0\n    min_lcm = float('inf')\n    best_k = 0\n    \n    for k in range(min(a, 1000)):  # Considering the first 1000 shifts\n        current_lcm = lcm(a + k, b + k)\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = k\n        elif current_lcm == min_lcm:\n            break  # Found the pattern, no need to continue\n    \n    # Check if shifting both numbers by their GCD helps\n    gcd_ab = gcd(a, b)\n    for k in [gcd_ab - a % gcd_ab, gcd_ab - b % gcd_ab]:\n        if k >= 0:\n            current_lcm = lcm(a + k, b + k)\n            if current_lcm < min_lcm:\n                best_k = k\n    \n    return best_k\n\n# Reading input\na, b = map(int, input().split())\n\n# Calculating and printing the result\nprint(find_smallest_k(a, b))"}
{"solution": "from math import ceil\n\ndef min_hack_marks(n, k, marks):\n    current_sum = sum(marks)\n    target_final_mark = k\n    # Calculate the minimum sum required to achieve the target final mark\n    required_sum = ceil((n + target_final_mark - 1) * target_final_mark / n)\n    \n    # Calculate the difference between required sum and current sum\n    diff = required_sum - current_sum\n    \n    # Return the minimum number of hacks required\n    return max(0, ceil(diff / k))\n\n# Reading input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(min_hack_marks(n, k, marks))"}
{"solution": "from math import ceil\n\ndef find_divisor(arr):\n    n = len(arr)\n    required_positives = ceil(n / 2)\n    pos_count = sum(1 for num in arr if num > 0)\n    \n    # If there are already enough positives, return 1\n    if pos_count >= required_positives:\n        return 1\n    \n    # Check for possible divisors\n    for d in range(-1000, 1001):\n        if d == 0:\n            continue\n        new_pos_count = sum(1 for num in arr if num / d > 0)\n        if new_pos_count >= required_positives:\n            return d\n    \n    # No valid divisor found\n    return 0\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Solve and print output\nprint(find_divisor(arr))"}
{"solution": "def max_nines_pairs(n):\n    def max_trailing_nines(x):\n        str_x = str(x)\n        nines = 0\n        for char in reversed(str_x):\n            if char == '9':\n                nines += 1\n            else:\n                break\n        return nines\n\n    max_nines = 0\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            current_nines = max_trailing_nines(i + j)\n            if current_nines > max_nines:\n                max_nines = current_nines\n\n    pairs_count = 0\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            if max_trailing_nines(i + j) == max_nines:\n                pairs_count += 1\n\n    return pairs_count\n\n# Read input\nn = int(input())\n\n# Calculate and print the result\nprint(max_nines_pairs(n))"}
{"solution": "from math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef find_min_time_and_sizes(a1, b1, a2, b2):\n    area1 = a1 * b1\n    area2 = a2 * b2\n    \n    # Calculate the least common multiple of the two areas\n    common_area = lcm(area1, area2)\n    \n    # Check if it's possible to make the areas equal\n    if common_area > 10**18:\n        return [-1]\n    \n    # Calculate the number of minutes needed\n    minutes = 0\n    while area1 != common_area:\n        if area1 > area2:\n            if area1 % 2 == 0:\n                area1 //= 2\n                minutes += 1\n            elif area1 % 3 == 0:\n                area1 *= 2 // 3\n                minutes += 1\n            else:\n                return [-1]\n        else:\n            if area2 % 2 == 0:\n                area2 //= 2\n                minutes += 1\n            elif area2 % 3 == 0:\n                area2 *= 2 // 3\n                minutes += 1\n            else:\n                return [-1]\n    \n    # Calculate the new sizes of the bars\n    factor1 = common_area // (a1 * b1)\n    factor2 = common_area // (a2 * b2)\n    \n    new_a1, new_b1 = a1 * factor1, b1 * factor1\n    new_a2, new_b2 = a2 * factor2, b2 * factor2\n    \n    return [minutes, [new_a1, new_b1], [new_a2, new_b2]]\n\n# Reading input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\nresult = find_min_time_and_sizes(a1, b1, a2, b2)\n\nif len(result) == 1:\n    print(result[0])\nelse:\n    print(result[0])\n    print(*result[1])\n    print(*result[2])"}
{"solution": "def who_wins(xp, yp, xv, yv):\n    # Calculate the minimum moves for Polycarp and Vasiliy to reach (0, 0)\n    polycarp_moves = max(xp, yp)\n    vasiliy_moves = max(xv, yv)\n\n    # Check if Vasiliy can stop Polycarp\n    if xp == xv + 1 and yp == yv:\n        polycarp_moves += 1\n    elif xp == xv and yp == yv + 1:\n        polycarp_moves += 1\n\n    # Determine the winner\n    if polycarp_moves < vasiliy_moves:\n        return \"Polycarp\"\n    else:\n        return \"Vasiliy\"\n\n# Read input\nxp, yp, xv, yv = map(int, input().split())\n\n# Output the winner\nprint(who_wins(xp, yp, xv, yv))"}
{"solution": "def calculate_columns(month, start_day):\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    # Adjust for non-leap years\n    days = days_in_month[month - 1]\n    # Calculate the number of complete weeks and extra days\n    complete_weeks, extra_days = divmod(days + start_day - 1, 7)\n    # The number of columns is the number of complete weeks plus any extra days\n    # If extra_days is 0, it means the last week is complete, so we subtract 1\n    columns = complete_weeks + (extra_days > 0)\n    return columns\n\n# Read input\nm, d = map(int, input().split())\n\n# Calculate and print the number of columns\nprint(calculate_columns(m, d))"}
{"solution": "def count_years_with_single_zero(start, end):\n    def count_trailing_ones(n):\n        trailing_zeros_count = 0\n        while n & 1 == 0:\n            n >>= 1\n            trailing_zeros_count += 1\n        return trailing_zeros_count\n\n    def next_year_with_single_zero(year):\n        trailing_zeros = count_trailing_ones(year)\n        if trailing_zeros == 0:\n            return year + (1 << (count_trailing_ones(year + 1) + 1)) + 1\n        else:\n            return year + (1 << trailing_zeros) + 1\n\n    count = 0\n    current_year = max(1, start - 1)\n    while current_year < end:\n        current_year = next_year_with_single_zero(current_year)\n        if current_year <= end:\n            count += 1\n    return count\n\n# Reading input\na, b = map(int, input().split())\n\n# Calculating and printing the result\nprint(count_years_with_single_zero(a, b))"}
{"solution": "def min_layers(n):\n    \"\"\"\n    Calculate the minimum number of layers required to draw segments on a coordinate axis\n    without overlaps for a given N.\n\n    :param n: Integer representing the range of coordinates from 0 to N.\n    :return: Minimum number of layers required.\n    \"\"\"\n    # The formula derived from the pattern observed in the problem statement\n    return n * (n + 1) // 2\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the output\nprint(min_layers(n))"}
{"solution": "from math import factorial\nfrom itertools import combinations\n\ndef calculate_ways(n, k, S, cubes):\n    max_fact = max(cubes)\n    if max_fact > 12:  # Precompute factorials up to a reasonable limit\n        max_fact = 12\n    fact_table = [factorial(i) for i in range(max_fact + 1)]\n    \n    def dfs(index, remaining_k, current_sum):\n        if current_sum == S:\n            return 1\n        if index >= n or current_sum > S:\n            return 0\n        \n        ways = 0\n        for use_fact in [False, True] if remaining_k > 0 else [False]:\n            value = fact_table[cubes[index]] if use_fact else cubes[index]\n            ways += dfs(index + 1, remaining_k - int(use_fact), current_sum + value)\n        \n        ways += dfs(index + 1, remaining_k, current_sum)\n        \n        return ways\n    \n    return dfs(0, k, 0)\n\n# Reading input\nn, k, S = map(int, input().split())\ncubes = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(calculate_ways(n, k, S, cubes))"}
{"solution": "from math import log\n\ndef can_achieve_array(n, k, a):\n    steps = [0] * 31\n    for value in a:\n        step = int(log(value, k)) if value > 0 else -1\n        if step != -1:\n            if steps[step] == 0:\n                steps[step] = value\n            else:\n                if steps[step] != value:\n                    return \"NO\"\n    return \"YES\"\n\n# Reading input\nT = int(input())\nfor _ in range(T):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(can_achieve_array(n, k, a))"}
{"solution": "MOD = 1073741824\n\ndef d(n):\n    divisors = 1\n    i = 2\n    while i * i <= n:\n        power = 1\n        while n % i == 0:\n            n //= i\n            power += 1\n        divisors *= power\n        i += 1\n        if i == 2:\n            i += 1\n    if n > 1:\n        divisors *= 2\n    return divisors\n\ndef precompute_divisors(n):\n    divisors = [0] * (n + 1)\n    for i in range(1, n + 1):\n        divisors[i] = d(i)\n    return divisors\n\ndef compute_sum(a, b, c):\n    divisors = precompute_divisors(a * b * c)\n    total_sum = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                total_sum += divisors[i * j * k]\n                total_sum %= MOD\n    return total_sum\n\na, b, c = map(int, input().split())\nresult = compute_sum(a, b, c)\nprint(result)"}
{"solution": "import itertools\n\ndef can_become_friends(bessie, elsie):\n    def parse_puzzle(puzzle):\n        return [(row.index('A'), col) for col, row in enumerate(puzzle)], \\\n               [(row.index('B'), col) for col, row in enumerate(puzzle)], \\\n               [(row.index('C'), col) for col, row in enumerate(puzzle)]\n\n    def is_same_configuration(a1, a2, b1, b2, c1, c2):\n        return sorted([a1, b1, c1]) == sorted([a2, b2, c2])\n\n    b_a, b_b, b_c = parse_puzzle(bessie)\n    e_a, e_b, e_c = parse_puzzle(elsie)\n\n    # Generate all permutations of Elsie's puzzle configurations\n    for perm in itertools.permutations([e_a, e_b, e_c]):\n        if is_same_configuration(b_a, perm[0], b_b, perm[1], b_c, perm[2]):\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nbessie = [input().strip() for _ in range(2)]\nelsie = [input().strip() for _ in range(2)]\n\n# Output result\nprint(can_become_friends(bessie, elsie))"}
{"solution": "def min_decimal(n, k):\n    def check(x):\n        power = 0\n        while x > 0:\n            if x % n >= len(str(k)): return False\n            if str(x % n) != k[-1 - power]: return False\n            power += 1\n            x //= n\n        return True\n\n    left, right = 0, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\nn = int(input())\nk = input().strip()\nprint(min_decimal(n, k))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nincreasing = False\nconstant = False\ndecreasing = False\nflag = True\n\nfor i in range(1, n):\n    if not increasing:\n        if a[i] > a[i - 1]:\n            increasing = True\n        elif a[i] < a[i - 1]:\n            flag = False\n            break\n    elif not constant:\n        if a[i] == a[i - 1]:\n            constant = True\n        elif a[i] < a[i - 1]:\n            constant = True\n            decreasing = True\n        else:\n            flag = False\n            break\n    elif not decreasing:\n        if a[i] >= a[i - 1]:\n            flag = False\n            break\n        else:\n            decreasing = True\n\nif flag and (increasing or constant or decreasing):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\ndef find_max_value(n, k):\n    def f(x):\n        return x // 2 if x % 2 == 0 else x - 1\n    \n    def count_occurrences(y, n):\n        count = 0\n        while y <= n:\n            count += min(k, 1 + (n - y) // (y - f(y)))\n            y = y * 2\n        return count\n    \n    # Binary search for the maximum y\n    low, high = 1, n\n    result = 1\n    while low <= high:\n        mid = (low + high) // 2\n        if count_occurrences(mid, n) >= k:\n            result = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    return result\n\n# Read input\nn, k = map(int, input().split())\n\n# Solve and print the result\nprint(find_max_value(n, k))"}
{"solution": "def find_pocket(n, m, x, y, vx, vy):\n    if vx == 0 and vy == 0:\n        return -1\n    \n    if vx == 0:\n        if vy > 0 and y + vy * m >= m:\n            return 0, m\n        elif vy < 0 and y + vy * m <= 0:\n            return 0, 0\n        else:\n            return -1\n    elif vy == 0:\n        if vx > 0 and x + vx * n >= n:\n            return n, 0\n        elif vx < 0 and x + vx * n <= 0:\n            return 0, 0\n        else:\n            return -1\n    else:\n        gcd = abs(vx * m // vy) if vx * vy > 0 else abs(vx * m // vy) + 1\n        steps = gcd\n        final_x = x + vx * steps\n        final_y = y + vy * steps\n        \n        if final_x % n == 0:\n            if final_y % m == 0:\n                return -1\n            elif final_y > m:\n                return final_x % n, m\n            else:\n                return final_x % n, 0\n        else:\n            if final_y > m:\n                return n, final_y % m\n            else:\n                return 0, final_y % m\n\n# Reading input\nn, m, x, y, vx, vy = map(int, input().split())\n\n# Finding the pocket\npocket = find_pocket(n, m, x, y, vx, vy)\n\n# Printing the output\nif isinstance(pocket, int):\n    print(pocket)\nelse:\n    print(*pocket)"}
{"solution": "def can_place_paintings(board_a, board_b, painting1_a, painting1_b, painting2_a, painting2_b):\n    # Check all orientations for the paintings to fit on the board\n    fits = (\n        max(painting1_a, painting2_a) <= board_a and painting1_b + painting2_b <= board_b or\n        max(painting1_b, painting2_b) <= board_b and painting1_a + painting2_a <= board_a or\n        max(painting1_a, painting2_b) <= board_a and painting1_b + painting2_a <= board_b or\n        max(painting1_b, painting2_a) <= board_b and painting1_a + painting2_b <= board_a\n    )\n    return \"YES\" if fits else \"NO\"\n\n# Reading input\nboard_a, board_b = map(int, input().split())\npainting1_a, painting1_b = map(int, input().split())\npainting2_a, painting2_b = map(int, input().split())\n\n# Output result\nprint(can_place_paintings(board_a, board_b, painting1_a, painting1_b, painting2_a, painting2_b))"}
{"solution": "import bisect\n\ndef count_numbers(b1, q, l, m, bad):\n    if q == 0:\n        if abs(b1) <= l and b1 not in bad:\n            return 1\n        else:\n            return 0\n\n    def count_in_range(n):\n        if n == 0:\n            return 0\n        sign = 1 if n > 0 else -1\n        n = abs(n)\n        return (n - abs(b1)) // abs(q) + 1 if (n - abs(b1)) >= 0 else 0\n\n    positive_count = count_in_range(l)\n    negative_count = count_in_range(-l)\n\n    total_count = positive_count + negative_count - (b1 == 0)\n\n    bad_terms_positive = len([x for x in bad if x > 0 and x % q == b1 % q and x <= l])\n    bad_terms_negative = len([x for x in bad if x < 0 and x % q == b1 % q and x >= -l])\n\n    bad_terms = bad_terms_positive + bad_terms_negative\n\n    if b1 % q in [x % q for x in bad]:\n        return 'inf'\n    else:\n        return total_count - bad_terms\n\nb1, q, l, m = map(int, input().split())\nbad = set(map(int, input().split()))\n\nprint(count_numbers(b1, q, l, m, bad))"}
{"solution": "def find_frame(screen):\n    n, m = len(screen), len(screen[0])\n    white_pixels = [(i, j) for i in range(n) for j in range(m) if screen[i][j] == 'w']\n\n    min_row, max_row = min(white_pixels, key=lambda x: x[0])[0], max(white_pixels, key=lambda x: x[0])[0]\n    min_col, max_col = min(white_pixels, key=lambda x: x[1])[1], max(white_pixels, key=lambda x: x[1])[1]\n\n    if max_row - min_row != max_col - min_col:\n        return -1\n\n    def draw_frame(min_row, max_row, min_col, max_col):\n        for i in range(n):\n            for j in range(m):\n                if min_row <= i <= max_row and min_col <= j <= max_col:\n                    if (i == min_row or i == max_row) or (j == min_col or j == max_col):\n                        screen[i] = screen[i][:j] + '+' + screen[i][j+1:]\n                    else:\n                        screen[i] = screen[i][:j] + '.' + screen[i][j+1:]\n        return '\\n'.join(screen)\n\n    if max_row - min_row == max_col - min_col:\n        return draw_frame(min_row, max_row, min_col, max_col)\n    else:\n        return -1\n\n# Example usage\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    screen = [input() for _ in range(n)]\n    result = find_frame(screen)\n    print(result)"}
{"solution": "def solve(n, a, b):\n    if a == 0 and b == 0:\n        return \"YES\", [0, 0]\n    if a == 0:\n        return \"YES\" if n % b == 0 else \"NO\", [0, n // b] if n % b == 0 else [0, 0]\n    if b == 0:\n        return \"YES\" if n % a == 0 else \"NO\", [n // a, 0] if n % a == 0 else [0, 0]\n\n    def extended_gcd(aa, bb):\n        last_remainder, remainder = abs(aa), abs(bb)\n        x, last_x, y, last_y = 0, 1, 1, 0\n        while remainder:\n            last_remainder, (quotient, remainder) = remainder, divmod(last_remainder, remainder)\n            x, last_x = last_x - quotient * x, x\n            y, last_y = last_y - quotient * y, y\n        return last_remainder, last_x * (-1 if aa < 0 else 1), last_y * (-1 if bb < 0 else 1)\n\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd != 0:\n        return \"NO\", [0, 0]\n\n    x *= n // gcd\n    y *= n // gcd\n\n    if x < 0:\n        k = -x // b\n        x += k * b\n        y -= k * a\n    if y < 0:\n        k = -y // a\n        x -= k * b\n        y += k * a\n\n    return \"YES\", [x, y]\n\nn = int(input())\na = int(input())\nb = int(input())\n\nresult, solution = solve(n, a, b)\nprint(result)\nif result == \"YES\":\n    print(*solution)"}
{"solution": "def number_to_words(score):\n    if score == 0:\n        return \"zero\"\n    \n    ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if score < 10:\n        return ones[score]\n    elif score < 20:\n        return teens[score - 10]\n    elif score < 100:\n        if score % 10 == 0:\n            return tens[score // 10]\n        else:\n            return f\"{tens[score // 10]}-{ones[score % 10]}\"\n    else:\n        return \"out-of-range\"\n\n# Reading input\nscore = int(input())\n\n# Converting number to words\nresult = number_to_words(score)\n\n# Printing output\nprint(result)"}
{"solution": "def max_elements_to_erase(n, arr):\n    max_erase = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            gap = arr[j] - arr[i]\n            if gap <= 1000 and gap >= 1:\n                max_erase = max(max_erase, j-i)\n    return max_erase if max_erase == 0 else max_erase - 1\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(max_elements_to_erase(n, arr))"}
{"solution": "n = int(input())\nproblems = list(map(int, input().split()))\n\ntotal_problems = sum(problems)\ncumulative_sum = 0\n\nfor i, num_problems in enumerate(problems, start=1):\n    cumulative_sum += num_problems\n    if cumulative_sum * 2 >= total_problems:\n        print(i)\n        break"}
{"solution": "from heapq import heappush, heappop\n\ndef solve_chess_puzzle(N, board):\n    def moves_knight(x, y):\n        for dx, dy in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                yield nx, ny\n\n    def moves_bishop(x, y):\n        for dx, dy in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:\n            for i in range(1, N):\n                nx, ny = x + dx * i, y + dy * i\n                if 0 <= nx < N and 0 <= ny < N:\n                    yield nx, ny\n                else:\n                    break\n\n    def moves_rook(x, y):\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            for i in range(1, N):\n                nx, ny = x + dx * i, y + dy * i\n                if 0 <= nx < N and 0 <= ny < N:\n                    yield nx, ny\n                else:\n                    break\n\n    def heuristic(x, y, target):\n        return abs(x - target[0]) + abs(y - target[1])\n\n    start = (0, 0)\n    target_positions = {val: (i, j) for i, row in enumerate(board) for j, val in enumerate(row)}\n    targets = list(range(1, N*N + 1))\n    path_cost = {pos: float('inf') for pos in targets}\n    path_cost[1] = 0\n    piece_changes = {pos: float('inf') for pos in targets}\n    piece_changes[1] = 0\n    priority_queue = [(0, 0, start, 'knight')]\n    \n    while priority_queue:\n        cost, changes, pos, piece = heappop(priority_queue)\n        if pos == targets[-1]:\n            return cost, changes\n        \n        next_target = targets[targets.index(board[pos[0]][pos[1]]) + 1]\n        \n        for next_pos in [target_positions[next_target]]:\n            if piece == 'knight':\n                possible_moves = list(moves_knight(*pos))\n            elif piece == 'bishop':\n                possible_moves = list(moves_bishop(*pos))\n            else:  # rook\n                possible_moves = list(moves_rook(*pos))\n            \n            for move in possible_moves:\n                if move == next_pos:\n                    new_cost = cost + 1\n                    new_changes = changes\n                    if new_cost < path_cost[next_target]:\n                        path_cost[next_target] = new_cost\n                        piece_changes[next_target] = new_changes\n                        heappush(priority_queue, (new_cost + heuristic(*next_pos, target_positions[next_target]), new_changes, next_pos, piece))\n            \n            for new_piece in ['knight', 'bishop', 'rook']:\n                if new_piece != piece:\n                    new_changes = changes + 1\n                    if new_changes < piece_changes[next_target]:\n                        piece_changes[next_target] = new_changes\n                        heappush(priority_queue, (cost + 1 + heuristic(*pos, target_positions[next_target]), new_changes, pos, new_piece))\n    \n    return path_cost[targets[-1]], piece_changes[targets[-1]]\n\n# Reading input\nN = int(input())\nboard = [list(map(int, input().split())) for _ in range(N)]\n\n# Solving and printing output\nsteps, changes = solve_chess_puzzle(N, board)\nprint(steps, changes)"}
{"solution": "def min_time_to_reach(n, m, k, a, b):\n    def apartment_to_coords(apartment):\n        floor = (apartment - 1) % (m * k)\n        return ((apartment - 1) // (m * k) + 1, (floor // k) + 1, floor % k + 1)\n\n    def coords_to_apartment(entrance, floor, apartment_on_floor):\n        return ((entrance - 1) * m * k + (floor - 1) * k + apartment_on_floor)\n\n    def time_to_reach_by_stairs(from_entrance, from_floor, to_entrance, to_floor):\n        # Time to go down to first floor if needed\n        if from_floor > 1:\n            time_down = (from_floor - 1) * 5\n        else:\n            time_down = 0\n        \n        # Time to walk between entrances\n        time_between_entrances = min(abs(to_entrance - from_entrance) * 15, (n - abs(to_entrance - from_entrance)) * 15)\n        \n        # Time to go up to target floor\n        time_up = (to_floor - 1) * 5\n        \n        return time_down + time_between_entrances + time_up\n\n    def time_to_reach_by_elevator(from_entrance, from_floor, to_entrance, to_floor):\n        # Time to go down to first floor if needed\n        if from_floor > 1:\n            time_down = (from_floor - 1) * 5\n        else:\n            time_down = 0\n\n        # Time to wait for elevator\n        time_wait_for_elevator = 10\n        \n        # Time to go to target entrance\n        time_to_target_entrance = min(abs(to_entrance - from_entrance) * 15, (n - abs(to_entrance - from_entrance)) * 15)\n        \n        # Time to go up to target floor\n        time_up = abs(to_floor - 1)\n        \n        return time_down + time_wait_for_elevator + time_to_target_entrance + time_up\n\n    a_entrance, a_floor, a_apartment = apartment_to_coords(a)\n    b_entrance, b_floor, b_apartment = apartment_to_coords(b)\n\n    # Time using stairs\n    time_stairs = time_to_reach_by_stairs(a_entrance, a_floor, b_entrance, b_floor)\n    \n    # Time using elevator\n    time_elevator = time_to_reach_by_elevator(a_entrance, a_floor, b_entrance, b_floor)\n    \n    return min(time_stairs, time_elevator)\n\n# Reading input\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\nprint(min_time_to_reach(n, m, k, a, b))"}
{"solution": "def can_be_divisible_by_64(binary_str):\n    # Check if the string can be transformed into a binary number divisible by 64\n    # A binary number is divisible by 64 if its last 6 bits are 0\n    # We can achieve this by checking if there's a '1' followed by at least six '0's in the string\n    \n    # Find the index of the first '1'\n    first_one_index = binary_str.find('1')\n    \n    # If there's no '1' in the string, it's not a valid binary number\n    if first_one_index == -1:\n        return False\n    \n    # Check if after the first '1', there are at least six '0's\n    remaining_str = binary_str[first_one_index+1:]\n    if len(remaining_str) >= 6 and '1' not in remaining_str:\n        return True\n    else:\n        return False\n\n# Read input\nbinary_str = input().strip()\n\n# Check if the string can be transformed into a binary number divisible by 64\nif can_be_divisible_by_64(binary_str):\n    print(\"yes\")\nelse:\n    print(\"no\")"}
{"solution": "from collections import Counter\n\ndef find_next_char(char, count_map):\n    while char <= 'z':\n        if count_map[char] > 0:\n            return char\n        char = chr(ord(char) + 1)\n    return None\n\ndef solve(s):\n    count_map = Counter(s)\n    result = []\n    last_char = 'a'\n    \n    while last_char <= 'z':\n        next_char = find_next_char(last_char, count_map)\n        if next_char is None:\n            return \"-1\"\n        result.append(next_char)\n        count_map[next_char] -= 1\n        last_char = next_char\n    \n    return ''.join(result)\n\ns = input().strip()\nprint(solve(s))"}
{"solution": "from math import inf\n\ndef max_expected_fishes(n, m, r, k):\n    def prefix_sum(arr):\n        for i in range(1, len(arr)):\n            arr[i] += arr[i - 1]\n        return arr\n\n    def get_sum(arr, idx):\n        return arr[min(idx, len(arr) - 1)]\n\n    def calculate_expectation():\n        result = 0.0\n        total_positions = (n - r + 1) * (m - r + 1)\n        for i in range(k + 1):\n            result += (i * positions[i])\n        return result / total_positions\n\n    positions = [0] * (r * r + 1)\n    for i in range(n - r + 1):\n        for j in range(m - r + 1):\n            covered_cells = (min(r, i + 1) * r +\n                             (r * (r - 1)) // 2 +\n                             (min(r, j + 1) * r -\n                              min(r, i + 1) * min(r, j + 1)) +\n                              (r * (r - 1)) // 2)\n            positions[covered_cells] += 1\n\n    for i in range(len(positions)):\n        positions[i] = (prefix_sum(positions[:i + 1]))\n\n    low, high = 0, k\n    while high - low > 1e-9:\n        mid = (low + high) / 2\n        if calculate_expectation() < mid:\n            high = mid\n        else:\n            low = mid\n\n    return low\n\n# Example usage\nn, m, r, k = map(int, input().split())\nprint(max_expected_fishes(n, m, r, k))"}
{"solution": "def max_product_array(n, a):\n    # Count negatives, positives, and zeros\n    negatives = positives = zeros = 0\n    for num in a:\n        if num < 0:\n            negatives += 1\n        elif num > 0:\n            positives += 1\n        else:\n            zeros += 1\n    \n    # If all numbers are non-positive, keep the largest negative and convert others\n    if positives == 0:\n        a.sort()\n        for i in range(n):\n            if i < n - 1 or negatives != 1:\n                a[i] = -a[i] - 1\n        return a\n    \n    # Convert all negative numbers and keep positives\n    for i in range(n):\n        if a[i] < 0:\n            a[i] = -a[i] - 1\n    return a\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Solving and printing output\nresult = max_product_array(n, a)\nprint(' '.join(map(str, result)))"}
{"solution": "import math\n\ndef find_kth_divisor(n, k):\n    def count_divisors(x):\n        count = 0\n        for i in range(1, int(math.sqrt(x)) + 1):\n            if x % i == 0:\n                count += 1\n                if i * i != x:\n                    count += 1\n        return count\n    \n    low, high = 1, n\n    while low < high:\n        mid = (low + high) // 2\n        if count_divisors(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n            \n    if count_divisors(low) >= k:\n        for i in range(1, int(math.sqrt(low)) + 1):\n            if low % i == 0:\n                k -= 1\n                if k == 0:\n                    return i if i * i == low else low // i\n    return -1\n\n# Example usage\nn, k = map(int, input().split())\nprint(find_kth_divisor(n, k))"}
{"solution": "from itertools import product\n\ndef max_number(cubes):\n    digits = [{face for face in cube if face in [1, 2, 3, 4, 5, 7]} for cube in cubes]\n    has_zero = any(0 in cube for cube in cubes)\n    has_one = any(1 in cube for cube in cubes)\n\n    if not has_one:\n        return 0\n\n    if has_zero:\n        valid_combinations = {int(''.join(map(str, combo))) for combo in product(*digits) if '0' not in combo}\n        max_valid = max(valid_combinations) if valid_combinations else 0\n        return min(max_valid, 9 * len(cubes))\n    else:\n        valid_combinations = {int(''.join(map(str, combo))) for combo in product(*digits)}\n        return max(valid_combinations)\n\nn = int(input())\ncubes = [list(map(int, input().split())) for _ in range(n)]\n\nprint(max_number(cubes))"}
{"solution": "def k_rounding(n, k):\n    if k == 0:\n        return n\n    power_of_ten = 10 ** k\n    if n % power_of_ten == 0:\n        return n\n    quotient, remainder = divmod(n, power_of_ten)\n    return ((quotient + 1) * power_of_ten)\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating k-rounding\nresult = k_rounding(n, k)\n\n# Printing output\nprint(result)"}
{"solution": "def can_transform(A):\n    n, m = len(A), len(A[0])\n    operations = []\n    \n    def apply_operation(x, y):\n        A[x][y] = A[x][y + 1] = A[x + 1][y] = A[x + 1][y + 1] = 1\n        operations.append((x + 1, y + 1))\n    \n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1:\n                apply_operation(i, j)\n    \n    # Check if the transformation is possible\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] != 0:\n                return -1\n    \n    return len(operations), operations\n\n# Read input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve and print output\nresult, ops = can_transform(A)\nif result == -1:\n    print(-1)\nelse:\n    print(result)\n    for op in ops:\n        print(*op)"}
{"solution": "from math import factorial as fact\n\ndef solve(r, s, p):\n    total = r + s + p\n    def prob(x, y, z):\n        if x == 0:\n            return 0\n        return (fact(y+z) / (fact(y) * fact(z))) * (1.0 / (y + z))\n    pr = prob(r, s, p) * ((1 - prob(s, r-1, p)) ** s) * ((1 - prob(p, r-1, s)) ** p)\n    ps = prob(s, r, p) * ((1 - prob(r, s-1, p)) ** r) * ((1 - prob(p, s-1, r)) ** p)\n    pp = prob(p, r, s) * ((1 - prob(r, p-1, s)) ** r) * ((1 - prob(s, p-1, r)) ** s)\n    return pr, ps, pp\n\nr, s, p = map(int, input().split())\npr, ps, pp = solve(r, s, p)\nprint(f\"{pr:.15f} {ps:.15f} {pp:.15f}\")"}
{"solution": "def calculate_together_time(l1, r1, l2, r2, k):\n    # Calculate the max start time and min end time for both intervals\n    together_start = max(l1, l2)\n    together_end = min(r1, r2)\n\n    # If there is no overlap, return 0\n    if together_start > together_end:\n        return 0\n\n    # Adjust for the minute when Sonya is prinking\n    if together_start <= k <= together_end:\n        together_end -= 1\n\n    # If after adjusting, the end time becomes less than the start time, return 0\n    if together_end < together_start:\n        return 0\n\n    # Calculate and return the total time they can spend together\n    return together_end - together_start + 1\n\n# Example check function (not part of the solution)\ndef check_solution():\n    assert calculate_together_time(1, 10, 9, 20, 1) == 2\n    assert calculate_together_time(1, 100, 50, 200, 75) == 50\n    print(\"All tests passed!\")\n\n# Uncomment the following line to run the check function\n# check_solution()"}
{"solution": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\ndef ccw(p1, p2, p3):\n    a, b = p1\n    c, d = p2\n    e, f = p3\n    return (c-a)*(f-b) - (e-a)*(d-b)\n\ndef intersect(a1, a2, b1, b2):\n    return ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 and ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0\n\ndef convex_hull(points):\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and ccw(lower[-2], lower[-1], p) < 0:\n            lower.pop()\n        lower.append(p)\n    \n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and ccw(upper[-2], upper[-1], p) < 0:\n            upper.pop()\n        upper.append(p)\n    \n    return lower[:-1] + upper[:-1]\n\ndef area_of_polygon(points):\n    area = 0\n    n = len(points)\n    for i in range(n):\n        j = (i + 1) % n\n        area += points[i][0] * points[j][1]\n        area -= points[j][0] * points[i][1]\n    return abs(area) // 2\n\nN, M = map(int, input().split())\nlines_ns = [tuple(map(int, input().split())) for _ in range(N)]\nlines_ew = [tuple(map(int, input().split())) for _ in range(M)]\n\nintersections = set([(0, 0)])\nfor i in range(N):\n    for j in range(M):\n        A, B, C = lines_ns[i]\n        D, E, F = lines_ew[j]\n        if intersect((A, C), (B, C), (D, E), (D, F)):\n            intersections.add((C, E))\n            intersections.add((C, F))\n            intersections.add((A, C))\n            intersections.add((B, C))\n\nif len(intersections) == 1:\n    print('INF')\nelse:\n    hull_points = convex_hull(list(intersections))\n    print(area_of_polygon(hull_points))"}
{"solution": "def will_pineapple_bark(t, s, x):\n    # Check if x is equal to the start time or can be expressed as t + ks or t + ks + 1\n    k = (x - t) // s\n    if x == t or x == t + k * s or x == t + k * s + 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Reading input\nt, s, x = map(int, input().split())\n\n# Processing and printing output\nprint(will_pineapple_bark(t, s, x))"}
{"solution": "from typing import List\n\ndef find_nested_segments(segments: List[List[int]]) -> List[int]:\n    n = len(segments)\n    result = [-1, -1]\n    \n    # Sort segments by their start point, and keep track of original indices\n    sorted_segments = sorted((l, r, i) for i, (l, r) in enumerate(segments))\n    \n    # Initialize variables\n    max_end = -1\n    containing_segment = -1\n    \n    for l, r, original_index in sorted_segments:\n        # Check if current segment is contained within another\n        if r <= max_end:\n            result = [original_index + 1, containing_segment + 1]\n            break\n        else:\n            max_end = r\n            containing_segment = original_index\n    \n    return result\n\n# Read input\nn = int(input())\nsegments = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve and print output\nprint(*find_nested_segments(segments))"}
{"solution": "def decode_genome(n, s):\n    counts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\n    unknown = 0\n    \n    for char in s:\n        if char != '?':\n            counts[char] += 1\n        else:\n            unknown += 1\n    \n    target_count = n // 4\n    nucleotides = ['A', 'C', 'G', 'T']\n    \n    for char in counts:\n        needed = target_count - counts[char]\n        if needed > unknown:\n            return \"===\"  # Impossible to decode\n        unknown -= min(needed, unknown)\n    \n    result = list(s)\n    for i, char in enumerate(s):\n        if char == '?':\n            for nt in nucleotides:\n                if counts[nt] < target_count:\n                    result[i] = nt\n                    counts[nt] += 1\n                    break\n    \n    return ''.join(result)\n\n# Reading input\nn = int(input())\ns = input()\n\n# Processing and printing output\nprint(decode_genome(n, s))"}
{"solution": "def can_ilya_win(board):\n    for i in range(4):\n        # Check rows and columns\n        for j in range(4):\n            if board[i][j] == '.':\n                # Check row\n                if all(board[i][k] == 'x' for k in range(4) if k != j):\n                    return \"YES\"\n                # Check column\n                if all(board[k][j] == 'x' for k in range(4) if k != i):\n                    return \"YES\"\n        # Check diagonals\n        if board[i][i] == '.' and all(board[k][k] == 'x' for k in range(4) if k != i):\n            return \"YES\"\n        if board[3 - i][i] == '.' and all(board[3 - k][k] == 'x' for k in range(4) if k != i):\n            return \"YES\"\n\n    return \"NO\"\n\n# Read the board from input\nboard = [input() for _ in range(4)]\n\n# Print the result\nprint(can_ilya_win(board))"}
{"solution": "def can_divide_after_moving(n, arr):\n    total_sum = sum(arr)\n    prefix_sum = 0\n    suffix_sum = 0\n    possible_positions = set()\n\n    # Calculate possible positions where we can insert an element to make the division possible.\n    for i in range(n):\n        suffix_sum += arr[i]\n        if prefix_sum + arr[i] == total_sum - suffix_sum:\n            possible_positions.add(i)\n\n        prefix_sum += arr[i]\n\n    # Check if there's an element that can be moved to make the division possible.\n    for i in range(n):\n        new_prefix_sum = prefix_sum - arr[i]\n        new_suffix_sum = suffix_sum + arr[i]\n\n        if new_prefix_sum == total_sum - new_suffix_sum:\n            return \"YES\"\n\n        if i in possible_positions:\n            return \"YES\"\n\n        prefix_sum += arr[i]\n        suffix_sum -= arr[i]\n\n    return \"NO\"\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Printing output\nprint(can_divide_after_moving(n, arr))"}
{"solution": "def can_recover_sequence(n, k, a, b):\n    a_with_zeros = [i for i, x in enumerate(a) if x == 0]\n    b_sorted = sorted(b, reverse=True)\n    \n    for i, pos in enumerate(a_with_zeros):\n        a[pos] = b_sorted[i]\n    \n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            return \"No\"\n    return \"Yes\"\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    print(can_recover_sequence(n, k, a, b))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_make_happy(x, y, z, a, b, c):\n    # Check if it's possible to make everyone happy\n    if a >= x and a + b >= y and a + b + c >= x + y + z:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Output result\nprint(can_make_happy(x, y, z, a, b, c))"}
{"solution": "def is_accident_possible(lights):\n    for l, s, r, p in lights:\n        if p == 1:  # Pedestrian light is green\n            if l == 1 or s == 1 or r == 1:  # Any car light is green\n                return \"YES\"\n    return \"NO\"\n\n# Reading input\nlights = []\nfor _ in range(4):\n    lights.append(list(map(int, input().split())))\n\n# Printing output\nprint(is_accident_possible(lights))"}
{"solution": "def is_unique_sequence(n, number):\n    # Define the mapping of keys that have the same finger movement\n    key_mapping = {\n        '1': ['1', '2', '4'],\n        '2': ['1', '2', '3', '5'],\n        '3': ['2', '3', '6'],\n        '4': ['1', '4', '5', '7'],\n        '5': ['2', '4', '5', '6', '8'],\n        '6': ['3', '5', '6', '9'],\n        '7': ['4', '7', '8', '*'],\n        '8': ['5', '7', '8', '9', '0'],\n        '9': ['6', '8', '9', '#'],\n        '*': ['*', '7', '0'],\n        '0': ['8', '*', '0', '#'],\n        '#': ['#', '9', '0']\n    }\n\n    # Check if the number has a unique sequence of finger movements\n    for i in range(n - 1):\n        current_key = number[i]\n        next_key = number[i + 1]\n        if next_key in key_mapping[current_key]:\n            # Check if there's another possible digit for the next movement\n            for alternative_key in key_mapping[current_key]:\n                if alternative_key != current_key and alternative_key != next_key:\n                    if all(next_digit in key_mapping[alternative_key] for next_digit in number[i + 1:]):\n                        return \"NO\"\n                    break\n    return \"YES\"\n\n# Read input\nn = int(input())\nnumber = input()\n\n# Determine if the sequence is unique\nprint(is_unique_sequence(n, number))"}
{"solution": "from heapq import heappush, heappop\n\ndef max_sold_products(n, f, items):\n    total_sold = 0\n    potential_gains = []\n    potential_losses = []\n\n    for k, l in items:\n        if k < l:\n            heappush(potential_gains, -(l - k))\n        elif k > l:\n            heappush(potential_losses, -(k - l))\n\n    for _ in range(f):\n        if potential_gains:\n            total_sold -= heappop(potential_gains)\n        elif potential_losses:\n            # If there are no gains, try to minimize losses by converting a loss into a gain.\n            heappush(potential_gains, heappop(potential_losses))\n            total_sold -= heappop(potential_gains)\n\n    # Calculate the total sold including non-doubled days\n    total_sold += sum(min(k, l) for k, l in items)\n\n    return total_sold\n\n# Reading input\nn, f = map(int, input().split())\nitems = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculating and printing the result\nprint(max_sold_products(n, f, items))"}
{"solution": "from heapq import heappush, heappop\n\ndef max_messiness(n, k):\n    # Initialize a min heap with the first k+1 elements (reversed for max heap behavior)\n    heap = list(range(n - k, n))\n    total_messiness = 0\n    \n    # Calculate initial messiness for the remaining elements\n    for i in range(n - k - 1, -1, -1):\n        heappush(heap, i)\n        total_messiness += n - 1 - heap[0]\n    \n    # Perform swaps\n    for _ in range(k):\n        heappop(heap)  # Remove the smallest element (to be swapped with the largest)\n        total_messiness += n - 1 - heap[0]  # Update messiness\n        \n    return total_messiness\n\n# Read input\nn, k = map(int, input().split())\n\n# Output the result\nprint(max_messiness(n, k))"}
{"solution": "import math\n\ndef min_coins_for_friends(N, M, K, L):\n    # Check if it's impossible to meet the conditions\n    if N - K < L or M < L:\n        return -1\n    # Calculate the minimum number of coins each friend needs to give\n    min_coins = math.ceil((L + (M - 1)) / M)\n    # Ensure that the total number of coins does not exceed the available unique coins\n    if min_coins * M > N - K + L:\n        return -1\n    return min_coins\n\n# Reading input\nN, M, K, L = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_coins_for_friends(N, M, K, L))"}
{"solution": "def min_paintings(n, m, grid):\n    def find_square():\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'B':\n                    for side in range(min(n - i, m - j), 0, -1):\n                        if (i + side <= n and j + side <= m and\n                                all(grid[i + k][j:j+side] == 'B' * side for k in range(side)) and\n                                all(grid[k][j:j+side].count('B') == side for k in range(i, i + side))):\n                            return side\n        return -1\n\n    def count_additional_paintings(side, start_i, start_j):\n        total_paintings = 0\n        for i in range(n):\n            for j in range(m):\n                if i < start_i or i >= start_i + side or j < start_j or j >= start_j + side:\n                    if grid[i][j] == 'B':\n                        total_paintings += 1\n        return total_paintings\n\n    side = find_square()\n    if side == -1:\n        return -1\n    start_i, start_j = 0, 0\n    for i in range(n - side + 1):\n        for j in range(m - side + 1):\n            if all(grid[i + k][j:j+side] == 'B' * side for k in range(side)):\n                start_i, start_j = i, j\n                break\n        else:\n            continue\n        break\n    return count_additional_paintings(side, start_i, start_j)\n\n# Reading input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Printing output\nprint(min_paintings(n, m, grid))"}
{"solution": "def check_stone_piles(x, y):\n    changes = []\n    for i in range(len(x)):\n        if x[i] != y[i]:\n            change = y[i] - x[i]\n            changes.append(change)\n    \n    positive_changes = sum(c > 0 for c in changes)\n    negative_changes = sum(c < 0 for c in changes)\n    \n    if positive_changes > 0 and negative_changes > 0:\n        return \"No\"\n    \n    return \"Yes\"\n\n# Reading input\nn = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Solving and printing output\nprint(check_stone_piles(x, y))"}
{"solution": "def min_pizza_diff(n, angles):\n    total_angle = sum(angles)\n    half_angle = total_angle / 2\n    dp = [0] + [-float('inf')] * half_angle\n    current_sum = 0\n    \n    for angle in angles:\n        for j in range(half_angle, angle - 1, -1):\n            dp[j] = max(dp[j], dp[j - angle] + angle)\n        current_sum += angle\n    \n    return abs(2 * dp[half_angle] - total_angle)\n\n# Reading input\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(int(min_pizza_diff(n, angles)))"}
{"solution": "MOD = 10**9 + 7\n\ndef power(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef main():\n    n, m = map(int, input().split())\n    \n    # Calculate (m + n - 1) choose (n - 1)\n    numerator = 1\n    for i in range(n):\n        numerator = (numerator * (m + i)) % MOD\n    \n    denominator = 1\n    for i in range(1, n):\n        denominator = (denominator * i) % MOD\n    \n    # Fermat's little theorem for modular inverse\n    denominator_inv = power(denominator, MOD - 2)\n    \n    result = (numerator * denominator_inv) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef find_pythagorean_triple(n):\n    if n == 1:\n        return [-1]\n    for m in range(1, int(math.sqrt(n)) + 1):\n        if (n * n - m * m) % (2 * m) == 0:\n            k = (n * n - m * m) // (2 * m)\n            if k > 0:\n                return [k, n * n + m * m]\n    return [-1]\n\nn = int(input())\nresult = find_pythagorean_triple(n)\nprint(' '.join(map(str, result)))"}
{"solution": "def check_distinct_remainders(n, k):\n    seen = set()\n    for i in range(1, min(n + 1, k + 1)):\n        remainder = n % i\n        if remainder in seen:\n            print(\"No\")\n            return\n        seen.add(remainder)\n        if i > n // 2:\n            break\n    print(\"Yes\")\n\n# Reading input\nn, k = map(int, input().split())\n\n# Solving the problem\ncheck_distinct_remainders(n, k)"}
{"solution": "import sys\n\ndef compare_large_numbers(a, b):\n    len_a, len_b = len(a), len(b)\n    \n    # Compare lengths\n    if len_a != len_b:\n        return '<' if len_a < len_b else '>'\n    \n    # If lengths are equal, compare lexicographically\n    for i in range(len_a):\n        if a[i] != b[i]:\n            return '<' if a[i] < b[i] else '>'\n    \n    # If all characters are equal\n    return '='\n\n# Reading the input\na = sys.stdin.readline().strip()\nb = sys.stdin.readline().strip()\n\n# Comparing and printing the result\nprint(compare_large_numbers(a, b))"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_pow(x, y):\n    \"\"\"Compute x^y % MOD.\"\"\"\n    result = 1\n    while y > 0:\n        if y & 1:\n            result = result * x % MOD\n        y >>= 1\n        x = x * x % MOD\n    return result\n\ndef calculate_ways(n, p, colors):\n    \"\"\"Calculate the number of ways to put arrows and choose colors.\"\"\"\n    dp = [[[[0 for _ in range(2)] for _ in range(2)] for _ in range(n + 1)] for _ in range(n + 1)]\n    dp[0][0][0][0] = 1\n    for i in range(n):\n        for j in range(n):\n            for k in range(2):\n                for l in range(2):\n                    next_i = i + 1\n                    next_j = j\n                    if colors[i] == -1:\n                        next_j += 1\n                    if next_i <= n:\n                        for m in range(2):\n                            if colors[i] == -1 or colors[i] == m:\n                                dp[next_i][next_j][k | (colors[i] == 0)][l | (colors[i] == 1)] += dp[i][j][k][l]\n                                dp[next_i][next_j][k | (colors[i] == 0)][l | (colors[i] == 1)] %= MOD\n    ans = 0\n    for i in range(n + 1):\n        for j in range(i + 1):\n            for k in range(2):\n                for l in range(2):\n                    parity = (i - j + k + l) & 1\n                    if parity == p:\n                        ans += dp[n][i][k][l]\n                        ans %= MOD\n    return ans\n\n# Reading input\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(calculate_ways(n, p, colors))"}
{"solution": "def min_cost(n, a, b, c):\n    def cost_to_next_multiple_of_four(x):\n        return 4 - x % 4 if x % 4 != 0 else 0\n\n    def min_cost_to_buy(k):\n        # Cost of buying k copybooks\n        one_cost = a * k\n        two_cost = float('inf')\n        three_cost = float('inf')\n\n        # Try every combination of packs of 2\n        for i in range(k // 2 + 1):\n            remaining = k - 2 * i\n            two_cost = min(two_cost, b * i + a * remaining)\n\n        # Try every combination of packs of 3\n        for i in range(k // 3 + 1):\n            remaining = k - 3 * i\n            three_cost = min(three_cost, c * i + a * remaining)\n\n        return min(one_cost, two_cost, three_cost)\n\n    additional_needed = cost_to_next_multiple_of_four(n)\n    return min_cost_to_buy(additional_needed)\n\n# Read input\nn, a, b, c = map(int, input().split())\n\n# Output\nprint(min_cost(n, a, b, c))"}
{"solution": "from collections import defaultdict, deque\n\ndef topological_sort(n, adj_list):\n    indegree = [0] * (n + 1)\n    for neighbors in adj_list.values():\n        for neighbor in neighbors:\n            indegree[neighbor] += 1\n    \n    queue = deque([i for i in range(1, n + 1) if indegree[i] == 0])\n    sorted_order = []\n    \n    while queue:\n        node = queue.popleft()\n        sorted_order.append(node)\n        for neighbor in adj_list.get(node, []):\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n                \n    return sorted_order if len(sorted_order) == n else []\n\ndef can_be_acyclic(n, m, edges):\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n    \n    # Attempt to perform topological sort\n    sorted_order = topological_sort(n, adj_list)\n    if len(sorted_order) == n:\n        return \"YES\"\n    \n    # Check for cycles and potential removal\n    for u, v in edges:\n        adj_list[u].remove(v)\n        sorted_order = topological_sort(n, adj_list)\n        if len(sorted_order) == n:\n            return \"YES\"\n        adj_list[u].append(v)  # Revert change\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Solve and print output\nprint(can_be_acyclic(n, m, edges))"}
{"solution": "from typing import List\n\ndef min_coins_for_modernization(n: int, m: int, antennas: List[List[int]]) -> int:\n    \"\"\"\n    Calculates the minimum number of coins needed to ensure all positions from 1 to m are covered by at least one antenna.\n    \"\"\"\n    antennas.sort(key=lambda x: x[0] - x[1], reverse=True)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    max_reach = [0] * (n + 1)\n    \n    for i in range(n):\n        x, s = antennas[i]\n        left, right = max(1, x - s), min(m, x + s)\n        for j in range(i, -1, -1):\n            new_left, new_right = max(left, max_reach[j]), right + (x - left)\n            if new_left <= new_right:\n                cost = max(0, new_left - max_reach[j]) + (new_right - new_left + 1) - (right - left + 1)\n                dp[i + 1] = min(dp[i + 1], dp[j] + cost)\n                max_reach[i + 1] = max(max_reach[i + 1], new_right)\n                \n    return dp[n]\n\n# Example check function (not part of the solution)\ndef check_solution():\n    assert min_coins_for_modernization(3, 595, [[43, 2], [300, 4], [554, 10]]) == 281\n    assert min_coins_for_modernization(1, 1, [[1, 1]]) == 0\n    assert min_coins_for_modernization(2, 50, [[20, 0], [3, 1]]) == 30\n    assert min_coins_for_modernization(5, 240, [[13, 0], [50, 25], [60, 5], [155, 70], [165, 70]]) == 26\n\ncheck_solution()"}
{"solution": "def max_good_subset_weight(W, counts):\n    total_weight = 0\n    for i in range(8, 0, -1):\n        if W >= i:\n            take = min(W // i, counts[i-1])\n            total_weight += take * i\n            W -= take * i\n    return total_weight\n\n# Reading input\nW = int(input())\ncounts = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(max_good_subset_weight(W, counts))"}
{"solution": "import heapq\n\ndef min_cost_lemonade(n, L, costs):\n    volumes = [2**i - 1 for i in range(1, n + 1)]\n    cost_per_liter = [(costs[i] / volumes[i], costs[i], volumes[i]) for i in range(n)]\n    \n    heapq.heapify(cost_per_liter)\n    \n    total_cost = 0\n    while L > 0:\n        cpw, cost, volume = heapq.heappop(cost_per_liter)\n        if L >= volume:\n            L -= volume\n            total_cost += cost\n        else:\n            total_cost += L * cpw\n            break\n    \n    return int(total_cost)\n\n# Reading input\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(min_cost_lemonade(n, L, costs))"}
{"solution": "from collections import Counter\n\ndef max_mex_after_operations(n, arr):\n    counter = Counter(arr)\n    sorted_unique_elements = sorted(set(arr))\n    \n    # Track the maximum possible mex\n    max_mex = 1\n    \n    for num in sorted_unique_elements:\n        # If the current number is greater than the max_mex, we found our answer\n        if num >= max_mex:\n            break\n        \n        # Decrease the max_mex by the count of the current number\n        max_mex += counter[num]\n    \n    return max_mex\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(max_mex_after_operations(n, arr))"}
{"solution": "def is_lucky_ticket(n, ticket_str):\n    total_sum = sum(int(digit) for digit in ticket_str)\n    segment_sum = 0\n    \n    for i, digit in enumerate(ticket_str):\n        segment_sum += int(digit)\n        # Check if the current segment sum divides the total sum evenly\n        if segment_sum * (n - i) == total_sum and i < n - 1:\n            remaining_sum = total_sum - segment_sum\n            # If the remaining part can be evenly divided by its length, it's lucky\n            if remaining_sum % (n - i - 1) == 0 and remaining_sum // (n - i - 1) * (n - i - 1) == remaining_sum:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Reading input\nn = int(input())\nticket_str = input()\n\n# Printing output\nprint(is_lucky_ticket(n, ticket_str))"}
{"solution": "username = input().strip()\ndistinct_chars = len(set(username))\nif distinct_chars % 2 == 0:\n    print(\"IGNORE HIM!\")\nelse:\n    print(\"CHAT WITH HER!\")"}
{"solution": "def max_tab_difference(n, k, tabs):\n    def close_tabs(start, k):\n        return [tabs[i] for i in range(n) if (i - start) % k != 0]\n\n    max_diff = 0\n    for start in range(k):\n        remaining_tabs = close_tabs(start, k)\n        e = remaining_tabs.count(1)\n        s = remaining_tabs.count(-1)\n        max_diff = max(max_diff, abs(e - s))\n    \n    return max_diff\n\n# Reading input\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(max_tab_difference(n, k, tabs))"}
{"solution": "3\nimport math\n\ndef min_cost_alphabet(n, c0, c1):\n    if c0 > c1:\n        c0, c1 = c1, c0\n    \n    if c0 == 0:\n        return (n - 1) * c1\n    \n    def calculate_total_cost(k):\n        total_cost = k * (k * c1 + (k + 1) * c0) // 2\n        count_codes = (k + 1) * (k * c1 + (k + 1) * c0) // (2 * (c1 - c0))\n        return total_cost, count_codes\n\n    left, right = 0, int(1e9)\n    while left < right:\n        mid = (left + right + 1) // 2\n        total_cost, count_codes = calculate_total_cost(mid)\n        if count_codes >= n:\n            right = mid - 1\n        else:\n            left = mid\n\n    total_cost, count_codes = calculate_total_cost(left)\n    remaining = n - count_codes\n    additional_cost = remaining * (left * c1 + left * c0 + c0)\n\n    return total_cost + additional_cost\n\n# Reading input\nn, c0, c1 = map(int, input().split())\n\n# Calculating and printing the output\nprint(min_cost_alphabet(n, c0, c1))"}
{"solution": "def toads_meet(n, a, x, b, y):\n    def next_station(station, direction, n):\n        return (station + direction) % n or n\n\n    daniel_stations = set()\n    current_station_daniel = a\n    while current_station_daniel != x:\n        daniel_stations.add(current_station_daniel)\n        current_station_daniel = next_station(current_station_daniel, 1, n)\n\n    current_station_vlad = b\n    while current_station_vlad != y:\n        if current_station_vlad in daniel_stations:\n            return \"YES\"\n        current_station_vlad = next_station(current_station_vlad, -1, n)\n\n    return \"NO\"\n\n# Example usage based on provided input format\nn, a, x, b, y = map(int, input().split())\nprint(toads_meet(n, a, x, b, y))"}
{"solution": "import math\n\ndef max_golden_age(x, y, l, r):\n    def is_unlucky(year):\n        max_pow_x = int(math.log(year, x))\n        max_pow_y = int(math.log(year, y))\n        \n        for a in range(max_pow_x + 1):\n            for b in range(max_pow_y + 1):\n                if x ** a + y ** b == year:\n                    return True\n        return False\n\n    max_gap = 0\n    current_gap = 0\n    current_start = max(l, 1)\n\n    for year in range(l, r + 1):\n        if not is_unlucky(year):\n            if current_gap == 0:\n                current_start = year\n            current_gap += 1\n        else:\n            max_gap = max(max_gap, current_gap)\n            current_gap = 0\n\n    max_gap = max(max_gap, current_gap)\n    return max_gap\n\n# Reading input\nx, y, l, r = map(int, input().split())\n\n# Calculating and printing the result\nprint(max_golden_age(x, y, l, r))"}
{"solution": "def min_tax(n):\n    if n == 2:\n        return 1\n    # Check if n is a power of a prime\n    for base in range(2, int(n**0.5) + 1):\n        exp = 1\n        while base ** exp <= n:\n            if base ** (exp + 1) > n:\n                return base\n            exp += 1\n    return 1\n\n# Read input\nn = int(input())\n\n# Calculate and print the minimum tax\nprint(min_tax(n))"}
{"solution": "def find_typo(word):\n    vowels = set('aeiou')\n    i = 0\n    result = []\n    while i < len(word):\n        if word[i] not in vowels:\n            start = i\n            count = 0\n            distinct_consonants = set()\n            while i < len(word) and word[i] not in vowels:\n                distinct_consonants.add(word[i])\n                count += 1\n                i += 1\n            if count >= 3 and len(distinct_consonants) > 1:\n                result.append(word[start:i])\n                result.append(\" \")\n                i -= 1  # To ensure the next character is processed\n            else:\n                i += 1\n        else:\n            i += 1\n    return \"\".join(result) + word[i:] if result else word\n\n# Read input\nword = input().strip()\n\n# Process and print output\nprint(find_typo(word))"}
{"solution": "import bisect\n\ndef min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d):\n    # Initialize variables\n    min_time = x * n\n    instant_max_cost = 0\n    \n    # Find the best instant potion creation\n    for i in range(k):\n        if d[i] <= s:\n            instant_max_cost = max(instant_max_cost, c[i])\n    \n    # If we can instantly create enough potions, return 0 time\n    if instant_max_cost >= n:\n        return 0\n    \n    # Calculate the remaining potions needed after using the best instant potion\n    remaining_potions = max(0, n - instant_max_cost)\n    \n    # Find the best potion time reduction\n    for i in range(m):\n        cost = b[i]\n        if cost <= s:\n            new_time = a[i] * remaining_potions\n            if new_time < min_time:\n                min_time = new_time\n                \n    # Check if we can afford to use any of the time reduction spells\n    if min_time == x * n:\n        min_time = remaining_potions * x\n    \n    return min_time\n\n# Read input\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\n# Solve and print the result\nprint(min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d))"}
{"solution": "from itertools import accumulate\nimport bisect\n\ndef max_points(n, k, M, times):\n    total_time = list(accumulate(times))\n    total_time.append(total_time[-1] + M)  # For full tasks\n    \n    def possible(full_tasks):\n        remaining_time = M - (full_tasks * total_time[-1])\n        remaining_points = (n - full_tasks) * k + full_tasks * (k + 1)\n        subtask_points = remaining_time // times[0]\n        return remaining_points + subtask_points\n    \n    low, high = 0, n\n    while high - low > 1:\n        mid = (low + high) // 2\n        if possible(mid) <= n * k:\n            low = mid\n        else:\n            high = mid\n            \n    return possible(low)\n\n# Reading input\nn, k, M = map(int, input().split())\ntimes = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(max_points(n, k, M, times))"}
{"solution": "}\nMOD = 998244353\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef preprocess(n):\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    \n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n        invfact[i] = modinv(fact[i])\n    \n    return fact, invfact\n\ndef comb(n, k, fact, invfact):\n    return fact[n] * invfact[k] * invfact[n - k] % MOD\n\ndef solve(n):\n    fact, invfact = preprocess(n)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = (dp[(i + 1) // 2] * dp[i // 2] * comb(i, i // 2, fact, invfact)) % MOD\n        \n        if i % 2 == 0:\n            dp[i] *= 2\n            dp[i] %= MOD\n    \n    return dp[n]\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def find_lara_position(n, m, k):\n    cycle_length = 2 * (n - 1) + 2 * (m - 2)\n    # Adjust k to the actual movement count considering the starting point\n    k += 1\n    \n    while k > 0:\n        if k >= cycle_length:\n            k %= cycle_length\n        if k == 0:\n            return (1, 2)\n        \n        # Determine the phase of the movement\n        if k <= n - 1:  # Going down\n            row, col = n - k, 1\n        elif k <= 2 * (n - 1):  # Going right\n            row, col = 1, (k - (n - 1)) // (n - 1) + 2\n        elif k <= 2 * (n - 1) + (m - 2):  # Going up\n            row, col = 2 - (k - (2 * (n - 1))), m\n        else:  # Going left\n            row, col = 1, (m - 1) - (k - (2 * (n - 1) + (m - 2)))\n        \n        return (row, col)\n\n# Reading input\nn, m, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(*find_lara_position(n, m, k))"}
{"solution": "from math import sqrt\n\ndef find_min_max_values(x):\n    \"\"\"\n    Finds two positive integers a and b such that LCM(a, b) = x and max(a, b) is minimized.\n    \"\"\"\n    for i in range(int(sqrt(x)), 0, -1):\n        if x % i == 0:\n            # The pair (i, x // i) satisfies the condition\n            return i, x // i\n\n# Reading input\nx = int(input())\n\n# Calculating and printing the result\na, b = find_min_max_values(x)\nprint(a, b)"}
{"solution": "a = int(input())\nb = int(input())\nc = int(input())\n\nmin_lemons = b // 2\nmin_pears = c // 4\n\nmax_lemons = min(a, min_lemons, min_pears)\n\nif max_lemons == 0:\n    print(0)\nelse:\n    print(max_lemons * 7)"}
{"solution": "n = int(input())\nratings = list(map(int, input().split()))\n\n# Sort the ratings in descending order\nratings.sort(reverse=True)\n\n# Check if it's possible to form two teams with the given condition\npossible = len(ratings) // 2 == len(set(ratings[:len(ratings)//2]))\n\nprint(\"YES\" if possible else \"NO\")"}
{"solution": "from math import gcd\nfrom itertools import accumulate\n\ndef extend_array_to_coprime(arr):\n    \"\"\"\n    Extends the given array to a co-prime array with the minimum number of insertions.\n    \n    Parameters:\n    arr (list): The input array of integers.\n    \n    Returns:\n    tuple: A tuple containing the number of insertions and the extended co-prime array.\n    \"\"\"\n    # Append 1 to handle the last element\n    arr.append(1)\n    prefix_gcd = list(accumulate(arr, gcd))\n    suffix_gcd = list(accumulate(arr[::-1], gcd))[::-1]\n    \n    extended_arr = []\n    insertions = 0\n    \n    for i in range(len(arr) - 1):\n        if gcd(prefix_gcd[i], suffix_gcd[i + 1]) > 1:\n            # Find a suitable coprime number\n            for x in range(2, 10**9 + 1):\n                if gcd(x, prefix_gcd[i]) == 1 and gcd(x, suffix_gcd[i + 1]) == 1:\n                    extended_arr.append(arr[i])\n                    extended_arr.append(x)\n                    insertions += 1\n                    break\n        else:\n            extended_arr.append(arr[i])\n    \n    # Remove the appended 1\n    extended_arr.pop()\n    \n    return (insertions, extended_arr)\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Solving and printing output\ninsertions, extended_arr = extend_array_to_coprime(arr)\nprint(insertions)\nprint(*extended_arr)"}
{"solution": "from typing import List\n\ndef max_divisor_after_operations(N: int, K: int, A: List[int]) -> int:\n    total_sum = sum(A)\n    \n    # Find divisors of the total sum\n    divisors = [i for i in range(1, int(total_sum**0.5) + 1) if total_sum % i == 0]\n    divisors.extend([total_sum // i for i in divisors if i != total_sum // i])\n    divisors.sort(reverse=True)\n    \n    for divisor in divisors:\n        mods = [a % divisor for a in A]\n        mods.sort()\n        prefix_sum = list(mods)\n        for i in range(1, len(prefix_sum)):\n            prefix_sum[i] += prefix_sum[i - 1]\n        \n        for i in range(N):\n            if prefix_sum[i] == divisor * (N - i - 1) - (prefix_sum[-1] - prefix_sum[i]) and prefix_sum[i] <= K:\n                return divisor\n\n# Reading input\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(max_divisor_after_operations(N, K, A))"}
{"solution": "def find_transformation(x):\n    operations = []\n    target_bit_length = x.bit_length()\n    \n    # Find the target bit length for the perfect longcat\n    while (1 << target_bit_length) - 1 != x:\n        target_bit_length += 1\n    \n    # Apply Operation A to flip bits except the highest set bit\n    for bit in range(target_bit_length - 1, -1, -1):\n        if not (x >> bit) & 1:\n            operations.append(bit)\n            x ^= (1 << bit) - 1\n    \n    return len(operations), operations\n\nx = int(input())\nt, operations = find_transformation(x)\n\nprint(t)\nfor op in operations:\n    print(op, end=' ')"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Find the maximum segment length that divides the garden length evenly\nmax_segment = max(x for x in a if k % x == 0)\n\n# Calculate and print the minimum number of hours required\nprint(k // max_segment)"}
{"solution": "def can_grasshopper_reach(insects_line, jump_distance):\n    n = len(insects_line)\n    g_pos = insects_line.find('G')\n    t_pos = insects_line.find('T')\n\n    # Convert the line into a boolean array where True means the cell is empty\n    line_status = [cell == '.' or cell == 'G' or cell == 'T' for cell in insects_line]\n\n    # Function to check if the grasshopper can reach from one position to another\n    def can_reach(start, end):\n        # Calculate the difference in positions\n        diff = abs(end - start)\n        # Check if the difference is a multiple of the jump distance\n        return diff % jump_distance == 0\n\n    # Breadth-first search to find a path\n    visited = set()\n    queue = [g_pos]\n    while queue:\n        current_pos = queue.pop(0)\n        if current_pos == t_pos:\n            return \"YES\"\n        visited.add(current_pos)\n\n        # Check next possible positions\n        for next_pos in [current_pos + jump_distance, current_pos - jump_distance]:\n            if 0 <= next_pos < n and line_status[next_pos] and next_pos not in visited:\n                queue.append(next_pos)\n\n    return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\ninsects_line = input()\n\n# Solve and print the result\nprint(can_grasshopper_reach(insects_line, k))"}
{"solution": "from math import fabs\n\ndef solve(y1, y2, yw, xb, yb, r):\n    # Calculate the effective height range for the goal\n    ye1 = y1 + r\n    ye2 = y2 - r\n    \n    # Calculate the intersection point on the y-axis\n    xw = (yw - yb) * (xb / (yb - ye1)) + xb\n    xw2 = (yw - yb) * (xb / (yb - ye2)) + xb\n    \n    # Check if the intersection point is valid\n    if yb < ye1 and yb > ye2:\n        return -1\n    elif yb <= ye2:\n        return xw2 if xw2 >= 0 else -1\n    else:\n        return xw if xw >= 0 else -1\n\nif __name__ == \"__main__\":\n    y1, y2, yw, xb, yb, r = map(int, input().split())\n    result = solve(y1, y2, yw, xb, yb, r)\n    print(result)"}
{"solution": "b, d, s = map(int, input().split())\n\n# Calculate the minimum possible missed meals\nmissed_meals = max((max(b, d, s) - min(b, d, s)) - 1, 0)\n\nprint(missed_meals)"}
{"solution": "from math import gcd\n\ndef possible_dimensions(path):\n    def calculate_dimensions(a, b):\n        row_diff = (b - a) // y\n        col_diff = (b - a) % y\n        return (row_diff, col_diff)\n\n    n = len(path)\n    if n == 1:\n        return \"YES\\n1000000000 1\"\n\n    changes = []\n    for i in range(1, n):\n        a, b = path[i - 1], path[i]\n        diff = b - a\n        if diff % y == 0:\n            changes.append((diff // y, 0))\n        else:\n            changes.append((diff // y + 1, diff % y))\n\n    for y in range(1, min(changes[0][1] + 1, 10**9) + 1):\n        valid = True\n        for change in changes:\n            row_diff, col_diff = calculate_dimensions(*change)\n            if abs(row_diff) + abs(col_diff) != 1:\n                valid = False\n                break\n        if valid:\n            return \"YES\\n\" + str(max(1, max(change[0] for change in changes))) + \" \" + str(y)\n\n    return \"NO\"\n\n# Reading input\nn = int(input())\npath = list(map(int, input().split()))\n\n# Calculating possible dimensions\nprint(possible_dimensions(path))"}
{"solution": "def find_min_subsequence(a, b):\n    n, m = len(a), len(b)\n    next_pos = [-1] * m\n    j = m - 1\n    matches = [-1] * n\n    match_count = 0\n    \n    # Find the last occurrence of each character in 'b' within 'a'\n    for i in range(n - 1, -1, -1):\n        if a[i] == b[j]:\n            matches[i] = j\n            j -= 1\n            if j < 0:\n                break\n    \n    j = 0\n    # Find the longest subsequence\n    for i in range(n):\n        while j > 0 and a[i] != b[j]:\n            j = next_pos[j - 1] + 1\n        if a[i] == b[j]:\n            matches[i] = j\n            j += 1\n            if j == m:\n                match_count = m\n                break\n        if j > 0 and matches[i] is None:\n            matches[i] = j - 1\n    \n    # Construct the result\n    result = []\n    prev_match = -1\n    for i in range(n):\n        if matches[i] is not None and matches[i] > prev_match:\n            result.append(a[i])\n            prev_match = matches[i]\n    \n    if not result:\n        return \"-\"\n    else:\n        return \"\".join(result)\n\n# Reading input\na = input().strip()\nb = input().strip()\n\n# Printing output\nprint(find_min_subsequence(a, b))"}
{"solution": "def min_stones_after_operations(n, s):\n    balance = 0\n    min_stones = 0\n    \n    for op in s:\n        if op == '+':\n            balance += 1\n        else:\n            balance -= 1\n            # Ensure the pile is never empty\n            if balance < 0:\n                min_stones += 1\n                balance = 0\n    \n    return min_stones + max(0, balance)\n\n# Reading input\nn = int(input())\ns = input()\n\n# Calculating and printing the result\nprint(min_stones_after_operations(n, s))"}
{"solution": "def max_kefir_liters(n, a, b, c):\n    def max_liters_with_glass_bottles(money, b, c):\n        # Calculate the maximum liters of kefir from glass bottles\n        bottles = money // b\n        remaining_money = money % b\n        total_liters = bottles\n        while bottles * c >= b:\n            new_bottles = bottles // (b // c)\n            total_liters += new_bottles\n            bottles = (bottles % (b // c)) + new_bottles\n            if bottles * c < b:\n                break\n        if bottles * c <= remaining_money:\n            total_liters += 1\n        return total_liters\n\n    # Calculate the maximum liters of kefir from plastic bottles\n    max_plastic_liters = n // a\n\n    # Calculate the maximum liters of kefir from glass bottles\n    max_glass_liters = max_liters_with_glass_bottles(n, b, c)\n\n    # Return the maximum of the two\n    return max(max_plastic_liters, max_glass_liters)\n\n# Reading input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Output the result\nprint(max_kefir_liters(n, a, b, c))"}
{"solution": "def read_cards():\n    n = int(input())\n    k1 = int(input())\n    soldier1 = [int(x) for x in input().split()]\n    k2 = int(input())\n    soldier2 = [int(x) for x in input().split()]\n    return n, soldier1, soldier2\n\ndef play_war(s1, s2):\n    fights = 0\n    while True:\n        if not s1 or not s2:\n            return fights, 1 if s2 else 2\n        c1, c2 = s1.pop(0), s2.pop(0)\n        if c1 > c2:\n            s1.extend([c2, c1])\n        else:\n            s2.extend([c1, c2])\n        fights += 1\n        if fights > 10000:\n            return -1,\n\nn, soldier1, soldier2 = read_cards()\nresult = play_war(soldier1, soldier2)\nprint(*result)"}
{"solution": "import re\n\ndef check_password_strength(password):\n    # Check for at least 5 characters\n    if len(password) < 5:\n        return \"Too weak\"\n    \n    # Check for at least one uppercase letter, one lowercase letter, and one digit\n    if not re.search(\"[A-Z]\", password) or not re.search(\"[a-z]\", password) or not re.search(\"[0-9]\", password):\n        return \"Too weak\"\n    \n    return \"Correct\"\n\n# Read the password from input\npassword = input().strip()\n\n# Check the password strength and print the result\nprint(check_password_strength(password))"}
{"solution": "from collections import Counter\n\ndef min_exchanges_to_equalize_performance(n, group_a, group_b):\n    \"\"\"\n    Calculate the minimum number of exchanges needed to equalize the number of students\n    with the same academic performance in two groups.\n\n    :param n: Number of students in each group.\n    :param group_a: List of academic performances for students in group A.\n    :param group_b: List of academic performances for students in group B.\n    :return: Minimum number of exchanges or -1 if it's impossible to equalize.\n    \"\"\"\n    # Count academic performances in both groups\n    count_a = Counter(group_a)\n    count_b = Counter(group_b)\n\n    # Check if equalization is possible\n    for perf in range(1, 6):\n        if count_a[perf] + count_b[perf] != n * 2:\n            return -1\n\n    exchanges = 0\n    for perf in range(1, 6):\n        diff = abs(count_a[perf] - count_b[perf])\n        exchanges += diff // 2\n\n    return exchanges\n\n# Read input\nn = int(input())\ngroup_a = list(map(int, input().split()))\ngroup_b = list(map(int, input().split()))\n\n# Print result\nprint(min_exchanges_to_equalize_performance(n, group_a, group_b))"}
{"solution": "def can_reach_any_junction(n, m, horizontal_streets, vertical_streets):\n    # Check if the first and last horizontal streets are bidirectional\n    if horizontal_streets[0] == '>' and horizontal_streets[-1] == '<':\n        return \"NO\"\n    \n    # Check if the first and last vertical streets are bidirectional\n    if vertical_streets[0] == 'v' and vertical_streets[-1] == '^':\n        return \"NO\"\n    \n    return \"YES\"\n\n# Reading input\nn, m = map(int, input().split())\nhorizontal_streets = input()\nvertical_streets = input()\n\n# Printing output\nprint(can_reach_any_junction(n, m, horizontal_streets, vertical_streets))"}
{"solution": "def find_bracket_placement(values):\n    n = len(values)\n    falses_needed = 0\n    \n    for i in range(n):\n        if values[i] == 1:\n            falses_needed += 1\n        else:\n            if falses_needed > 0:\n                falses_needed -= 1\n            else:\n                break\n    \n    if falses_needed == 0:\n        return \"YES\", build_expression_with_brackets(values)\n    else:\n        return \"NO\", \"\"\n\ndef build_expression_with_brackets(values):\n    stack = []\n    expression_parts = []\n    \n    for value in values:\n        if value == 1:\n            if stack:\n                expression_parts.append('1' if stack.pop() else '0')\n            else:\n                stack.append(True)\n        else:\n            if stack:\n                expression_parts.append('0' if stack.pop() else '1')\n            else:\n                stack.append(False)\n    \n    while stack:\n        expression_parts.append('1' if stack.pop() else '0')\n    \n    def wrap_with_brackets(part):\n        if part in ('0', '1'):\n            return part\n        return f\"({part})\"\n    \n    def build_expression(parts):\n        expr = ''\n        for part in reversed(parts):\n            if expr:\n                expr = f\"{wrap_with_brackets(part)}->{expr}\"\n            else:\n                expr = part\n        return expr\n    \n    return build_expression(expression_parts)\n\n# Reading input\nn = int(input())\nvalues = list(map(int, input().split()))\n\n# Solving and printing output\nresult, expression = find_bracket_placement(values)\nprint(result)\nif result == \"YES\":\n    print(expression)"}
{"solution": "def process_variables(a, b):\n    while a > 0 and b > 0:\n        if a >= 2 * b:\n            a %= 2 * b\n        elif b >= 2 * a:\n            b %= 2 * a\n        else:\n            break\n    return a, b\n\nif __name__ == \"__main__\":\n    a, b = map(int, input().split())\n    result_a, result_b = process_variables(a, b)\n    print(result_a, result_b)"}
{"solution": "def count_k_divisible(k, a, b):\n    \"\"\"\n    Counts the number of k-divisible numbers in the range [a, b].\n    \n    :param k: The divisor.\n    :param a: The start of the range.\n    :param b: The end of the range.\n    :return: The count of numbers divisible by k in the range [a, b].\n    \"\"\"\n    if a < 0 and b > 0:\n        return (b // k) - ((a - 1) // k) + 1 if a % k == 0 else (b // k) - (a // k)\n    elif a <= 0 <= b:\n        return b // k + 1 if a % k == 0 else b // k\n    else:\n        return (b // k) - (a // k) + 1 if a % k == 0 else (b // k) - (a // k)\n\n# Reading input\nk, a, b = map(int, input().strip().split())\n\n# Calculating and printing the result\nprint(count_k_divisible(k, a, b))"}
{"solution": "def find_kth_digit(k):\n    \"\"\"\n    Finds the k-th digit in the concatenated sequence of all positive integers.\n    \n    Args:\n    k (int): The 1-based index of the digit in the sequence to find.\n    \n    Returns:\n    int: The k-th digit in the sequence.\n    \"\"\"\n    base = 1\n    while k > base * 9 * len(str(base)):\n        k -= base * 9 * len(str(base))\n        base *= 10\n    \n    number = base + (k - 1) // len(str(base))\n    return int(str(number)[(k - 1) % len(str(base))])\n\n# Read input\nk = int(input())\n\n# Find and print the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "def can_vasya_win(n, s):\n    # Check if the first digit is 8 and the length is correct after removals\n    def is_telephone_number(s):\n        return len(s) == 11 and s[0] == '8'\n\n    # Dynamic programming approach to determine if Vasya can win\n    dp = [False] * (n + 1)\n    dp[11] = True  # Base case: a string of length 11 is always a win for Vasya if it starts with 8\n\n    for length in range(n - 1, 0, -1):\n        for i in range(length):\n            # Simulate removing a character and check if the resulting string is not a win for Petya\n            new_s = s[:i] + s[i+1:]\n            if not dp[length + 1]:\n                dp[length] = is_telephone_number(new_s)\n                if dp[length]:\n                    break\n\n    return dp[1]\n\n# Read input\nn = int(input())\ns = input()\n\n# Determine if Vasya can win\nif can_vasya_win(n, s):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "from math import factorial\n\nMOD = 10**9 + 7\n\ndef mod_inverse(x):\n    return pow(x, MOD - 2, MOD)\n\ndef calculate_permutations(n, x, pos):\n    if pos == 0:\n        left_side = n - x\n    else:\n        left_side = n - x - 1\n\n    if pos == n - 1:\n        right_side = x - 1\n    else:\n        right_side = x\n\n    left_permutations = factorial(left_side) * mod_inverse(factorial(max(0, left_side - (n - x - 1)))) % MOD\n    right_permutations = factorial(right_side) * mod_inverse(factorial(max(0, right_side - (x - 1)))) % MOD\n\n    total_permutations = (factorial(n - 1) * left_permutations * right_permutations) % MOD\n    return total_permutations\n\nn, x, pos = map(int, input().split())\nprint(calculate_permutations(n, x, pos))"}
{"solution": "def decode_message(s, k):\n    i, n, res = 0, len(s), []\n    while i < n and len(res) < k:\n        start_i = i\n        word_part = []\n        while i < n and s[i] in \"abcdefghijklmnopqrstuvwxyz\":\n            word_part.append(s[i])\n            i += 1\n            if i < n and s[i] == '?':\n                i += 1\n            elif i < n and s[i] == '*':\n                i += 1\n                if i < n and s[i] == s[i-2]:\n                    repeats = 1\n                    while i < n and s[i] == s[i-2]:\n                        repeats += 1\n                        i += 1\n                    word_part.extend([s[i-2]] * repeats)\n        if len(res) + len(word_part) > k:\n            return \"Impossible\"\n        res.extend(word_part)\n        i += 1\n    if len(res) < k:\n        return \"Impossible\"\n    return \"\".join(res[:k])\n\n# Reading input\ns = input().strip()\nk = int(input().strip())\n\n# Solving and printing output\nprint(decode_message(s, k))"}
{"solution": "x = int(input())\n\n# Normalize the angle to be within [0, 360)\nangle = x % 360\n\n# Determine the minimum number of 90 degree rotations needed\nif angle == 0:\n    rotations = 0\nelif 0 < angle <= 90:\n    rotations = 1\nelif 90 < angle <= 180:\n    rotations = 2\nelif 180 < angle <= 270:\n    rotations = 3\nelse:  # 270 < angle < 360\n    rotations = 1\n\nprint(rotations)"}
{"solution": "def can_cast_spell(a, b, c, x, y, z):\n    a_deficit = max(0, x - a)\n    b_deficit = max(0, y - b)\n    c_deficit = max(0, z - c)\n    \n    # Calculate the maximum possible deficit reduction\n    max_reduction = (a + b + c - x - y - z) // 2\n    \n    # Check if the deficits can be covered\n    return \"Yes\" if a_deficit + b_deficit + c_deficit <= max_reduction else \"No\"\n\n# Read input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Output result\nprint(can_cast_spell(a, b, c, x, y, z))"}
{"solution": "def solve(n, k, m):\n    def compute_powers_modulo(k, m, max_pow):\n        powers = [1]\n        for _ in range(max_pow - 1):\n            powers.append((powers[-1] * k) % m)\n        return powers\n\n    def compute_suffix_counts(k, m, max_len):\n        counts = [0] * max_len\n        powers = compute_powers_modulo(k, m, max_len)\n        current_sum = 0\n        for i in range(max_len):\n            if powers[i] % k == 0:\n                current_sum += 1\n            counts[i] = current_sum % m\n        return counts\n\n    def compute_total_count(n, k, m):\n        if k == 1:\n            return (10 ** n - 1) % m\n        total_count = 0\n        suffix_counts = compute_suffix_counts(k, m, n + 1)\n        for i in range(1, n + 1):\n            suffix_count = suffix_counts[i - 1]\n            prefix_possibilities = (10 ** (n - i)) % m\n            total_count += (prefix_possibilities * suffix_count) % m\n            total_count %= m\n        return total_count\n\n    return compute_total_count(n, k, m)\n\n# Example usage\nif __name__ == \"__main__\":\n    n, k, m = map(int, input().split())\n    print(solve(n, k, m))"}
{"solution": "l, r, a = map(int, input().split())\n\nmax_team_size = 0\n\n# Case when we use all left-handed and right-handed if possible\nteam_size = min(l + a, r + a) * 2\nif team_size % 2 == 1:\n    team_size -= 1\nmax_team_size = max(max_team_size, team_size)\n\n# Case when we use all ambidextrous and either left or right-handed\nteam_size = (min(l, r) + a) * 2\nif team_size % 2 == 1:\n    team_size -= 1\nmax_team_size = max(max_team_size, team_size)\n\nprint(max_team_size)"}
{"solution": "def min_moves(n, k):\n    k = min(k, n + 1 - k)  # Symmetry\n    result = 2 * (1 + 2 * (k - 1) + (n - k)) + (n - k - 1)\n    return result\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_moves(n, k))"}
{"solution": "def min_tallest_tower(n, m):\n    total_students = n + m\n    two_block_students = n\n    three_block_students = m\n    height = 0\n    i = 1\n    while True:\n        if two_block_students > 0:\n            if height + 2 > 0:\n                height += 2\n                two_block_students -= 1\n        if three_block_students > 0:\n            if height + 3 > 0:\n                height += 3\n                three_block_students -= 1\n        if two_block_students == 0 and three_block_students == 0:\n            break\n        i += 1\n        if i % 2 == 0 and two_block_students > 0:\n            two_block_students += 1\n        if i % 3 == 0 and three_block_students > 0:\n            three_block_students += 1\n    return height\n\n# Example usage\nn, m = map(int, input().split())\nprint(min_tallest_tower(n, m))"}
{"solution": "from collections import Counter\n\ndef can_play_fair(n, cards):\n    card_counts = Counter(cards)\n    unique_counts = list(card_counts.items())\n    \n    # Sort by count descending, then by value ascending\n    unique_counts.sort(key=lambda x: (-x[1], x[0]))\n    \n    # Check if the first two unique cards can form a fair game\n    if len(unique_counts) > 1 and unique_counts[0][1] == unique_counts[1][1] and unique_counts[0][1] * 2 == n:\n        return \"YES\", [unique_counts[0][0], unique_counts[1][0]]\n    \n    return \"NO\", []\n\n# Read input\nn = int(input())\ncards = [int(input()) for _ in range(n)]\n\n# Process and print output\nresult, numbers = can_play_fair(n, cards)\nprint(result)\nif result == \"YES\":\n    print(*numbers)"}
{"solution": "def can_arrange_soldiers(n, k, soldiers):\n    total_seats = n * 8\n    max_group_size = max(soldiers)\n    total_soldiers = sum(soldiers)\n\n    # Check if the total number of soldiers can fit in the plane\n    if total_soldiers > total_seats:\n        return \"NO\"\n\n    # Check if the largest group can be placed without neighbors\n    if max_group_size > 4 or (max_group_size > total_seats // 2 and max_group_size > 4 * (total_seats % 8 // 2)):\n        return \"NO\"\n\n    # Check if all groups can be placed without neighbors\n    if total_seats // 2 < total_soldiers and 4 * (total_seats % 8 // 2) < max_group_size:\n        return \"NO\"\n\n    return \"YES\"\n\n# Reading input\nn, k = map(int, input().split())\nsoldiers = list(map(int, input().split()))\n\n# Printing output\nprint(can_arrange_soldiers(n, k, soldiers))"}
{"solution": "from collections import Counter\n\ndef min_cost_to_almost_good(n, sticks):\n    counter = Counter(sticks)\n    sorted_lengths = sorted(counter.keys())\n    \n    def calculate_cost(target):\n        cost = 0\n        for length in sorted_lengths:\n            diff = abs(length - target)\n            count = counter[length]\n            cost += min(diff, diff + 2) * count\n        return cost\n    \n    min_cost = float('inf')\n    best_t = None\n    \n    for t in range(min(sorted_lengths) - 1, max(sorted_lengths) + 2):\n        cost = calculate_cost(t)\n        if cost < min_cost:\n            min_cost = cost\n            best_t = t\n    \n    print(best_t, min_cost)\n\n# Reading input\nn = int(input())\nsticks = list(map(int, input().split()))\n\n# Solving and printing output\nmin_cost_to_almost_good(n, sticks)"}
{"solution": "def min_square_side(n, m, sky):\n    stars_x = []\n    stars_y = []\n    for i in range(n):\n        for j in range(m):\n            if sky[i][j] == '*':\n                stars_x.append(i)\n                stars_y.append(j)\n    \n    width = max(stars_x) - min(stars_x) + 1\n    height = max(stars_y) - min(stars_y) + 1\n    \n    return max(width, height)\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    sky = [input() for _ in range(n)]\n    print(min_square_side(n, m, sky))"}
{"solution": "MOD = 10**9 + 7\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef solve(n, k, a):\n    ones = sum(a)\n    zeros = n - ones\n    \n    if abs(ones - zeros) > 1:\n        return 0\n    \n    if k % 2 == 0:\n        if abs(ones - zeros) != 1:\n            return 0\n        else:\n            return 1\n    \n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    \n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n        inv_fact[i] = modinv(fact[i])\n    \n    def comb(n, k):\n        return (fact[n] * inv_fact[k] * inv_fact[n - k]) % MOD\n    \n    total_ways = comb(n, ones)\n    \n    if ones > zeros:\n        good_ways = comb(ones - 1, n // 2 - 1)\n    else:\n        good_ways = comb(zeros - 1, n // 2 - 1)\n    \n    return (good_ways * modinv(total_ways)) % MOD\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nresult = solve(n, k, a)\nprint(result)"}
{"solution": "x, y = map(int, input().split())\n\nresult = 0\nwhile x > y:\n    if x % 2 == 0 and y * 2 <= x:\n        x //= 2\n        result += 1\n    else:\n        x -= 1\n        result += 1\n\nprint(result)"}
{"solution": "from math import sqrt\n\ndef min_norm_degenerate_matrix(a, b, c, d):\n    det = a * d - b * c\n    if det == 0:\n        return 0.0\n    else:\n        return sqrt(min(abs(a * d), abs(b * c)) / abs(det))\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\nprint(min_norm_degenerate_matrix(a, b, c, d))"}
{"solution": "n, a, b = map(int, input().split())\nt = list(map(int, input().split()))\n\ndenied = 0\none_seater_empty = a\ntwo_seater_empty = b\ntwo_seater_half = 0\n\nfor customer in t:\n    if customer == 1:  # Single person\n        if one_seater_empty > 0:\n            one_seater_empty -= 1\n        elif two_seater_empty > 0:\n            two_seater_empty -= 1\n        elif two_seater_half > 0:\n            two_seater_half -= 1\n        else:\n            denied += 1\n    else:  # Two people\n        if two_seater_empty > 0:\n            two_seater_empty -= 1\n        else:\n            denied += 2\n\nprint(denied)"}
{"solution": "def calculate_unsuccessful_students(A, B, C, N):\n    # Calculate the number of students who visited only one of the restaurants\n    only_bugdonalds = A - C\n    only_beaverking = B - C\n    \n    # Total number of students who passed the exam\n    total_passed = only_bugdonalds + only_beaverking + C\n    \n    # Check if the total number of students who passed is valid\n    if total_passed > N or total_passed == N:\n        return -1\n    else:\n        # Calculate and return the number of students who did not pass the exam\n        return N - total_passed\n\n# Read input\nA, B, C, N = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_unsuccessful_students(A, B, C, N))"}
{"solution": "MOD = 10**9 + 7\n\ndef power(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef calculate_dresses(x, k):\n    # Calculate 2^(k+1) % MOD\n    final_multiplier = power(2, k + 1)\n    # Calculate (1 - 0.5^(k)) % MOD\n    survival_rate = (power(2, k, MOD - 1) - 1) % MOD\n    # Calculate the expected number of dresses\n    expected_dresses = ((final_multiplier * x) % MOD + survival_rate) % MOD\n    return expected_dresses\n\nx, k = map(int, input().split())\nprint(calculate_dresses(x, k))"}
{"solution": "from math import gcd\n\ndef modinv(x, MOD=998244353):\n    return pow(x, MOD-2, MOD)\n\ndef solve(n, lr):\n    MOD = 998244353\n    dp = [1] + [0] * (n-1)\n    denom = 1\n    for i in range(n-1):\n        l, r = lr[i]\n        total = r - l + 1\n        next_dp = [0] * n\n        for j in range(n):\n            next_dp[j] = sum(dp[max(0, j-i-1):min(n, j+1)]) * (r - l + 1) % MOD\n            if j > 0:\n                next_dp[j] -= dp[j-1] * (l - (lr[i+1][0] if i+1 < n else 0)) % MOD\n            next_dp[j] %= MOD\n        dp = next_dp\n        denom = (denom * total) % MOD\n    \n    numerator = sum(dp) % MOD\n    inv_denom = modinv(denom, MOD)\n    result = (numerator * inv_denom) % MOD\n    return result\n\nn = int(input())\nlr = [list(map(int, input().split())) for _ in range(n)]\nprint(solve(n, lr))"}
{"solution": "def count_ways_to_form_rectangle(n):\n    # Initialize the result variable\n    result = 0\n    \n    # Iterate through possible values of a and b\n    for a in range(1, n // 2):\n        for b in range(a + 1, n // 2):\n            # Calculate c and d based on a and b\n            c = a\n            d = n - a - b - c\n            # Check if d is valid and not equal to b\n            if d > 0 and d != b:\n                result += 1\n                \n    # Since each pair (a, b) is counted twice (once as (a, b) and once as (b, a))\n    # we need to divide the result by 2\n    return result\n\n# Read the input\nn = int(input())\n\n# Print the output\nprint(count_ways_to_form_rectangle(n))"}
{"solution": "from typing import List\n\ndef min_kvass_volume(kegs: List[int], s: int) -> int:\n    def is_possible(min_volume):\n        total_liters = 0\n        for v in kegs:\n            total_liters += max(v - min_volume, 0)\n        return total_liters >= s\n\n    if sum(kegs) < s:\n        return -1\n\n    low, high = 0, max(kegs)\n\n    while low < high:\n        mid = (low + high + 1) // 2\n        if is_possible(mid):\n            low = mid\n        else:\n            high = mid - 1\n\n    return low\n\n# Reading input\nn, s = map(int, input().split())\nv = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(min_kvass_volume(v, s))"}
{"solution": "def caterpillar_and_apple(h1, h2, a, b):\n    if a <= b:\n        return -1 if h2 > h1 else 0\n\n    distance_to_apple = h2 - h1\n    net_progress_per_day = a - b\n\n    # Calculate full days needed\n    full_days = (distance_to_apple + net_progress_per_day - 1) // net_progress_per_day\n\n    # Check if the caterpillar reaches the apple exactly on the next day without slipping back\n    if (distance_to_apple - (full_days * net_progress_per_day)) <= a:\n        return full_days\n\n    return full_days + 1\n\n# Reading input\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Printing output\nprint(caterpillar_and_apple(h1, h2, a, b))"}
{"solution": "def max_joy_units(C, H_r, H_b, W_r, W_b):\n    # Calculate joy per gram for red and blue candies\n    joy_per_gram_r = H_r / W_r\n    joy_per_gram_b = H_b / W_b\n    \n    # Calculate the maximum number of candies of each type that can be consumed\n    max_candies_r = C // W_r\n    max_candies_b = C // W_b\n    \n    # Initialize variables to store the maximum joy units\n    max_joy = 0\n    \n    # Iterate through possible combinations of red and blue candies\n    for candies_r in range(max_candies_r + 1):\n        remaining_weight = C - candies_r * W_r\n        candies_b = min(remaining_weight // W_b, max_candies_b)\n        \n        # Calculate joy units for the current combination\n        joy_units = candies_r * H_r + candies_b * H_b\n        \n        # Update the maximum joy units if the current combination provides more joy\n        max_joy = max(max_joy, joy_units)\n    \n    return max_joy\n\n# Read input\nC, H_r, H_b, W_r, W_b = map(int, input().split())\n\n# Calculate and print the maximum joy units\nprint(max_joy_units(C, H_r, H_b, W_r, W_b))"}
{"solution": "def min_steps_to_target(x1, y1, x2, y2):\n    # Calculate the differences in x and y coordinates\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    \n    # The minimum number of steps required is the maximum of the two differences,\n    # since the robot can move diagonally as well as horizontally/vertically.\n    return max(dx, dy)\n\n# Read input from stdin\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\n# Calculate and print the result\nprint(min_steps_to_target(x1, y1, x2, y2))"}
{"solution": "def determine_winner(employees):\n    depublicans, remocrats = 0, 0\n    for emp in employees:\n        if emp == 'D':\n            depublicans += 1\n        else:\n            remocrats += 1\n    \n    current_turn = 0\n    while depublicans > 0 and remocrats > 0:\n        if current_turn % 2 == 0:  # Depublicans' turn\n            remocrats -= 1\n        else:  # Remocrats' turn\n            depublicans -= 1\n        current_turn += 1\n    \n    return 'D' if depublicans > 0 else 'R'\n\n# Reading input\nn = int(input())\nemployees = input().strip()\n\n# Determining the winner\nwinner = determine_winner(employees)\n\n# Printing the output\nprint(winner)"}
{"solution": "from math import gcd\n\ndef count_tv_sets(a, b, x, y):\n    # Calculate the greatest common divisor of x and y\n    d = gcd(x, y)\n    \n    # Adjust x and y by dividing them by their gcd\n    x //= d\n    y //= d\n    \n    # Calculate the upper bounds for w and h\n    w_max = a // x\n    h_max = b // y\n    \n    # Find the minimum of the two to get the maximum number of full sets that fit\n    max_sets = min(w_max, h_max)\n    \n    # Calculate the final result using the adjusted values\n    result = (max_sets * (max_sets + 1) * x * y) // (2 * d)\n    \n    # Adjust for the case where w_max and h_max are not equal\n    if w_max != h_max:\n        if w_max > h_max:\n            result -= ((w_max - h_max) * x * (w_max - h_max + 1) * y) // (2 * d)\n        else:\n            result -= ((h_max - w_max) * y * (h_max - w_max + 1) * x) // (2 * d)\n    \n    return result\n\n# Read input\na, b, x, y = map(int, input().split())\n\n# Print the result\nprint(count_tv_sets(a, b, x, y))"}
{"solution": "from collections import defaultdict\n\ndef max_pow(x, p):\n    res = 0\n    while x >= p:\n        res += x // p\n        x //= p\n    return res\n\ndef find_trailing_zeros(n, b):\n    factors = defaultdict(int)\n    x = b\n    while x % 2 == 0:\n        factors[2] += 1\n        x //= 2\n    div = 3\n    while x > 1 and div * div <= x:\n        while x % div == 0:\n            factors[div] += 1\n            x //= div\n        div += 2\n    if x > 1:\n        factors[x] += 1\n    \n    ans = float('inf')\n    for f in factors:\n        ans = min(ans, max_pow(n, f) // factors[f])\n    return ans\n\nn, b = map(int, input().split())\nprint(find_trailing_zeros(n, b))"}
{"solution": "def calculate_sum(m, a, b):\n    gcd = lambda x, y: x if not y else gcd(y, x % y)\n    g = gcd(a, b)\n    a //= g\n    b //= g\n\n    def count_reachable(x):\n        if x == 0:\n            return 1\n        k = (x + a - 1) // a\n        l = (x + b - 1) // b\n        mn = min(k, l)\n        mx = max(k, l)\n        cnt = (mn + 1) * (mx + 1)\n        if (a + b) <= x:\n            cnt -= 1\n        return cnt\n\n    total = m + 1\n    cycle_length = a * b\n    full_cycles = m // cycle_length\n    partial_cycle = m % cycle_length\n\n    full_cycle_sum = full_cycles * (full_cycles + 1) // 2 * cycle_length\n    partial_cycle_sum = count_reachable(partial_cycle) * (partial_cycle + 1)\n\n    return total + full_cycle_sum + partial_cycle_sum - 1\n\n# Reading input\nm, a, b = map(int, input().split())\n\n# Calculating and printing the output\nprint(calculate_sum(m, a, b))"}
{"solution": "def can_divide_into_odd_subsegments(n, sequence):\n    odd_count = 0\n    can_divide = False\n\n    for num in sequence:\n        if num % 2 != 0:\n            if odd_count == 0:\n                odd_count += 1\n            else:\n                odd_count += 1\n                if odd_count % 2 != 0:\n                    can_divide = True\n        else:\n            odd_count = 0\n\n    # Check if the last segment is odd and starts and ends with an odd number\n    if odd_count % 2 != 0 and odd_count > 0:\n        can_divide = True\n\n    return \"Yes\" if can_divide else \"No\"\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Output result\nprint(can_divide_into_odd_subsegments(n, sequence))"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    if x1 == x2:  # Trees are on the same vertical line\n        x3, x4 = x1, x1\n        y3, y4 = y2, y2 + (y2 - y1)\n    elif y1 == y2:  # Trees are on the same horizontal line\n        y3, y4 = y1, y1\n        x3, x4 = x2, x2 + (x2 - x1)\n    else:  # Trees are diagonally opposite\n        if abs(x1 - x2) != abs(y1 - y2):  # Not forming a square\n            return -1\n        x3, y3 = x2, y1\n        x4, y4 = x1, y2\n    \n    return x3, y3, x4, y4\n\n# Reading input\nx1, y1, x2, y2 = map(int, input().split())\n\n# Finding the remaining trees\nresult = find_remaining_trees(x1, y1, x2, y2)\n\n# Printing the result\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "MOD = 1000000007\n\ndef mod_inverse(a):\n    return pow(a, MOD - 2, MOD)\n\ndef calculate_fn(x, y, n):\n    if n == 1:\n        return x % MOD\n    elif n == 2:\n        return y % MOD\n    \n    # Calculate f3 using the given formula\n    f3 = (y - x) % MOD\n    \n    # Special case for n = 3\n    if n == 3:\n        return f3\n    \n    # Calculate the ratio\n    ratio = (x - y) % MOD\n    \n    # Calculate the denominator which is the same as calculating f2 for n-2\n    denom = pow(2, n - 2, MOD)\n    denom_inv = mod_inverse(denom)\n    \n    # Calculate fn using the derived formula\n    result = ((ratio * denom_inv) % MOD + y) % MOD\n    return result\n\n# Read input\nx, y = map(int, input().split())\nn = int(input())\n\n# Output result\nprint(calculate_fn(x, y, n))"}
{"solution": "def can_split_array(nums):\n    if len(nums) == 0:\n        return False, []\n    \n    splits = []\n    start = 0\n    \n    for i in range(len(nums)):\n        current_sum = sum(nums[start:i+1])\n        \n        if current_sum != 0:\n            if start != i:\n                splits.append((start + 1, i + 1))\n            start = i + 1\n            \n    if start < len(nums) and sum(nums[start:]) != 0:\n        splits.append((start + 1, len(nums)))\n    \n    return len(splits) > 0, splits\n\ndef print_solution(can_split, splits):\n    if not can_split:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(len(splits))\n        for split in splits:\n            print(f\"{split[0]} {split[1]}\")\n\nn = int(input())\nnums = list(map(int, input().split()))\n\ncan_split, splits = can_split_array(nums)\nprint_solution(can_split, splits)"}
{"solution": "def min_quiz_score(n, m, k):\n    mod = 1000000009\n    if m >= k:\n        full_sequences = m // k\n        remaining_correct = m % k\n        score = ((full_sequences * (full_sequences - 1) // 2) * (1 << k) + (full_sequences + 1) * (1 << (k - 1)) + remaining_correct) % mod\n    else:\n        score = m\n    return score\n\n# Reading input\nn, m, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_quiz_score(n, m, k))"}
{"solution": "def is_divisible_by_8(number_str):\n    if int(number_str) % 8 == 0:\n        return True\n    return False\n\ndef find_subsequence_divisible_by_8(n):\n    # Check if the number itself is divisible by 8\n    if is_divisible_by_8(n):\n        return \"YES\\n\" + n\n    \n    # Check subsequences of length 1 to 3\n    for i in range(len(n)):\n        for j in range(i+1, len(n)+1):\n            subseq = n[i:j]\n            if len(subseq) > 0 and subseq[0] != '0' and is_divisible_by_8(subseq):\n                return \"YES\\n\" + subseq\n    \n    return \"NO\"\n\n# Read input\nn = input().strip()\n\n# Solve and print the result\nresult = find_subsequence_divisible_by_8(n)\nprint(result)"}
{"solution": "def find_floor(n, memories):\n    possible_flats_per_floor = set()\n\n    for flats_per_floor in range(1, 101):\n        valid = True\n        for k, f in memories:\n            calculated_floor = (k - 1) // flats_per_floor + 1\n            if calculated_floor != f:\n                valid = False\n                break\n        if valid:\n            possible_flats_per_floor.add(flats_per_floor)\n\n    target_floor = None\n    for flats_per_floor in possible_flats_per_floor:\n        calculated_floor = (n - 1) // flats_per_floor + 1\n        if target_floor is None:\n            target_floor = calculated_floor\n        elif target_floor != calculated_floor:\n            return -1\n    return target_floor\n\n# Reading input\nn, m = map(int, input().split())\nmemories = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Calculating and printing output\nprint(find_floor(n, memories))"}
{"solution": "def max_bishwocks(board_top, board_bottom):\n    def count_bishwocks(row):\n        count = 0\n        i = 0\n        while i < len(row):\n            if row[i] == '0':\n                if i + 1 < len(row) and row[i + 1] == '0':\n                    count += 1\n                    i += 2\n                else:\n                    i += 1\n            else:\n                i += 1\n        return count\n\n    # Combine rows to check for vertical conflicts\n    combined = ''.join(f'{board_top[i]}{board_bottom[i]}' for i in range(len(board_top)))\n\n    # Count bishwocks for each row, adjusting for conflicts\n    top_count = count_bishwocks(board_top)\n    bottom_count = count_bishwocks(board_bottom)\n\n    conflict_count = combined.count('XX')\n    return (top_count + bottom_count - conflict_count) // 2\n\n# Read input\nboard_top = input().strip()\nboard_bottom = input().strip()\n\n# Calculate and print the result\nprint(max_bishwocks(board_top, board_bottom))"}
{"solution": "def max_pretty_positions(n, s):\n    last_lowercase = -1\n    distinct_count = 0\n    for i in range(n):\n        if s[i].islower():\n            if last_lowercase == -1:\n                last_lowercase = i\n            elif s[i] not in s[last_lowercase:i]:\n                distinct_count += 1\n                last_lowercase = i\n        elif s[i].isupper() and last_lowercase != -1:\n            last_lowercase = -1\n    if last_lowercase != -1:\n        distinct_count += 1\n    return distinct_count\n\n# Reading input\nn = int(input())\ns = input()\n\n# Printing output\nprint(max_pretty_positions(n, s))"}
{"solution": "# Given the problem statement, the optimal strategy is to put all positive numbers into sequence b\n# and all negative numbers into sequence c. If there are zeros, they can go into either sequence,\n# but the optimal choice is to place them in sequence c to maximize B - C.\n\ndef max_diff(n, arr):\n    # Initialize variables to store sums of positive and negative numbers\n    pos_sum = 0\n    neg_sum = 0\n    \n    # Iterate through the array to calculate sums\n    for num in arr:\n        if num >= 0:\n            pos_sum += num\n        else:\n            neg_sum += num\n            \n    # Calculate and return the maximum difference\n    return pos_sum - neg_sum\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output the result\nprint(max_diff(n, arr))"}
{"solution": "def min_refuels(a, b, f, k):\n    if b >= 2 * a:\n        return 0\n    \n    if f <= b - a:\n        return -1\n    \n    refuels = 0\n    distance_covered = 0\n    remaining_distance = 2 * a * k\n    \n    while remaining_distance > 0:\n        if distance_covered + b >= f:\n            distance_covered += b\n            remaining_distance -= b\n            if f + b >= 2 * a:\n                remaining_distance -= max(0, 2 * a - f)\n                distance_covered = 0\n                refuels += 1\n            else:\n                distance_covered -= f\n                remaining_distance += f\n        elif distance_covered + b < f:\n            if b < a:\n                return -1\n            distance_covered += b\n            remaining_distance -= b\n            if distance_covered >= 2 * a:\n                distance_covered -= 2 * a\n                remaining_distance += 2 * a\n            else:\n                distance_covered = 0\n                refuels += 1\n                \n        if distance_covered == 0 and remaining_distance < 2 * a:\n            break\n            \n    return refuels\n\n# Example usage\na, b, f, k = map(int, input().split())\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    def can_split(length):\n        count, remainder = divmod(n, length)\n        return remainder == 0, count\n\n    can_p, count_p = can_split(p)\n    can_q, count_q = can_split(q)\n\n    if not can_p and not can_q:\n        return [-1]\n\n    result = []\n    while n > 0:\n        if can_p and (can_q and (n - p >= q or n < q)):\n            result.append(s[:p])\n            s = s[p:]\n            n -= p\n        else:\n            result.append(s[:q])\n            s = s[q:]\n            n -= q\n\n    return [len(result)] + result\n\nif __name__ == \"__main__\":\n    n, p, q = map(int, input().split())\n    s = input()\n    result = split_string(n, p, q, s)\n    if result[0] == -1:\n        print(-1)\n    else:\n        print(result[0])\n        for i in range(1, len(result)):\n            print(result[i])"}
{"solution": "from bisect import bisect_left\n\ndef can_reach(n, m, s, d, obstacles):\n    obstacles.sort()\n    last_jump = 0\n    position = 0\n    jumps = []\n    \n    while position < m:\n        # Find the next obstacle or the end\n        next_obstacle = bisect_left(obstacles, position + 1)\n        if next_obstacle == len(obstacles) or obstacles[next_obstacle] > position + d:\n            next_obstacle = min(m, position + d + 1)\n        \n        # Calculate the run-up needed\n        run_up = max(0, position - last_jump - s)\n        \n        # Check if we can reach the next obstacle or end\n        if position + run_up + d < next_obstacle:\n            return [\"IMPOSSIBLE\"]\n        \n        # Perform the run\n        print(f\"RUN {run_up}\")\n        \n        # Update the position\n        position += run_up\n        \n        # If we've reached the end, break\n        if position >= m:\n            break\n        \n        # Perform the jump\n        jump_distance = min(d, next_obstacle - position - 1)\n        print(f\"JUMP {jump_distance}\")\n        \n        # Update the position and last_jump\n        position += jump_distance\n        last_jump = position\n        \n    return []\n\n# Read input\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\n# Solve and print the result\nresult = can_reach(n, m, s, d, obstacles)"}
{"solution": "def count_solutions(s, x):\n    if s < x or (s - x) % 2 != 0:\n        return 0\n    else:\n        # Calculate the number of solutions based on the difference between s and x\n        diff = (s - x) // 2\n        # The number of solutions is determined by the difference and the range of possible values\n        # For each valid a, there's exactly one valid b, except when a == b and x > 0, which is not possible.\n        return max(0, diff)\n\n# Reading input\ns, x = map(int, input().split())\n\n# Printing output\nprint(count_solutions(s, x))"}
{"solution": "def min_turns(n, k):\n    if k == 0:\n        return [str(i) for i in range(1, n + 1)]\n    else:\n        span = 2 * k + 1\n        turns = []\n        for i in range(1, n + 1, span):\n            turns.append(str(i))\n        if len(turns) * span < n:\n            last_turn = turns[-1]\n            last_index = int(last_turn)\n            next_index = last_index + span\n            if next_index <= n:\n                turns.append(str(next_index))\n        return turns\n\ndef print_solution(n, k):\n    turns = min_turns(n, k)\n    print(len(turns))\n    print(' '.join(turns))\n\n# Reading input\nn, k = map(int, input().split())\n\n# Printing the solution\nprint_solution(n, k)"}
{"solution": "from math import sqrt\n\ndef is_square(n):\n    return int(sqrt(n)) ** 2 == n\n\ndef min_operations_to_square(n):\n    str_n = str(n)\n    length = len(str_n)\n    \n    # Early exit if n is already a square\n    if is_square(n):\n        return 0\n    \n    # Precompute squares close to n\n    limit = int(sqrt(n)) + 2\n    squares = [i * i for i in range(1, limit)]\n    \n    dp = [float('inf')] * (length + 1)\n    dp[0] = 0\n    \n    for i in range(1, length + 1):\n        for j in range(i):\n            current = int(str_n[j:i])\n            if current in squares:\n                dp[i] = min(dp[i], dp[j])\n            else:\n                dp[i] = min(dp[i], dp[j] + 1)\n                \n    return dp[length] if dp[length] != float('inf') else -1\n\n# Read input\nn = int(input())\n\n# Calculate and print the result\nprint(min_operations_to_square(n))"}
{"solution": "from math import gcd\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef fact(n):\n    f = [1] * (n + 1)\n    for i in range(2, n + 1):\n        f[i] = (f[i-1] * i) % MOD\n    return f\n\ndef inv_fact(n, f):\n    if n == 0:\n        return [1]\n    inv = [1] * (n + 1)\n    inv[n] = pow(f[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        inv[i-1] = (inv[i] * i) % MOD\n    return inv\n\ndef count_max_gcd_perms(n):\n    f = fact(n)\n    inv = inv_fact(n, f)\n    \n    primes = []\n    is_prime = [True] * (n + 1)\n    for p in range(2, n + 1):\n        if is_prime[p]:\n            primes.append(p)\n            for multiple in range(p * p, n + 1, p):\n                is_prime[multiple] = False\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for prime in primes:\n        next_dp = [0] * (n + 1)\n        for j in range(prime, n + 1):\n            next_dp[j] = (dp[j] + dp[j - prime]) % MOD\n            if j >= 2 * prime:\n                next_dp[j] = (next_dp[j] - dp[j - 2 * prime]) % MOD\n        dp = next_dp\n    \n    result = 0\n    for k in range(1, n + 1):\n        count = dp[k]\n        if k < n:\n            count = (count * 2) % MOD\n        count = (count * f[n]) % MOD\n        count = (count * inv[k]) % MOD\n        count = (count * inv[n - k]) % MOD\n        result = (result + count) % MOD\n    \n    return result\n\nn = int(input())\nprint(count_max_gcd_perms(n))"}
{"solution": "def min_jump_ability(s):\n    n = len(s)\n    vowels = set('AEIOUY')\n    dp = [n] * n\n    dp[n-1] = 1 if s[n-1] in vowels else n\n\n    for i in range(n-2, -1, -1):\n        if s[i] in vowels:\n            j = max(i + 1, min(n - 1, i + 4))  # Start from i+1 and limit the max jump to i+4 initially\n            while j < n and dp[j] != n:\n                dp[i] = min(dp[i], dp[j] + 1)\n                j += 1\n            if dp[i] == n:  # If no valid jump found, set to n\n                dp[i] = n\n            else:\n                dp[i] -= 1  # Adjust for the extra increment done in the loop\n        else:\n            dp[i] = n\n\n    return dp[0] if dp[0] != n else n\n\n# Read input\ns = input().strip()\n\n# Calculate and print the result\nprint(min_jump_ability(s))"}
{"solution": "def can_distribute_equally(bags):\n    total_candies = sum(bags)\n    # Check if total candies are even and can be divided into two equal parts\n    if total_candies % 2 == 0:\n        # Sort the bags to simplify finding combinations\n        sorted_bags = sorted(bags)\n        # Check if any combination of two bags equals the other two\n        if sorted_bags[0] + sorted_bags[1] == sorted_bags[2] + sorted_bags[3]:\n            return \"YES\"\n        elif sorted_bags[0] + sorted_bags[3] == sorted_bags[1] + sorted_bags[2]:\n            return \"YES\"\n        elif sorted_bags[0] + sorted_bags[2] == sorted_bags[1] + sorted_bags[3]:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nbags = list(map(int, input().split()))\n\n# Output result\nprint(can_distribute_equally(bags))"}
{"solution": "def optimal_pie_distribution(slices):\n    n = len(slices)\n    dp = [[0] * n for _ in range(n)]\n    \n    for length in range(1, n + 1):\n        for start in range(n - length + 1):\n            end = start + length - 1\n            if length == 1:\n                dp[start][end] = (slices[start], 0)\n            else:\n                take_start = (slices[start] + dp[start + 1][end][1], dp[start + 1][end][0])\n                take_end = (slices[end] + dp[start][end - 1][1], dp[start][end - 1][0])\n                if take_start[0] > take_end[0]:\n                    dp[start][end] = take_start\n                else:\n                    dp[start][end] = take_end\n    \n    return dp[0][n - 1]\n\nif __name__ == \"__main__\":\n    n = int(input())\n    slices = list(map(int, input().split()))\n    alice, bob = optimal_pie_distribution(slices)\n    print(alice, bob)"}
{"solution": "from math import gcd\nfrom functools import reduce\n\ndef find_min_variables(nums):\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_lcm(nums):\n        return reduce(lcm, nums)\n\n    if any(nums[i] % nums[i-1] != 0 for i in range(1, len(nums))):\n        return -1\n\n    lcm_value = find_lcm(nums)\n    max_val = max(nums)\n    \n    if lcm_value > max_val:\n        return -1\n    \n    count = 0\n    current_gcd = max_val\n    for num in reversed(nums[:-1]):\n        current_gcd = gcd(current_gcd, num)\n        if current_gcd == num:\n            count += 1\n    return count + 1\n\n# Reading input\nn = int(input())\nnums = list(map(int, input().split()))\n\n# Printing output\nprint(find_min_variables(nums))"}
{"solution": "def game_winner(n, piles):\n    unique_piles = set(piles)\n    if len(unique_piles) == 1:\n        return \"Bob\"\n    else:\n        return \"Alice\"\n\n# Reading input\nn = int(input())\npiles = list(map(int, input().split()))\n\n# Determining the winner\nwinner = game_winner(n, piles)\n\n# Printing the output\nprint(winner)"}
{"solution": "def can_equalize_elements(arr):\n    min_val = min(arr)\n    max_val = max(arr)\n    if max_val - min_val == 0:\n        return \"YES\"\n    \n    def check(x):\n        additions, subtractions = [], []\n        avg_with_additions = min_val + x\n        avg_with_subtractions = max_val - x\n        \n        for elem in arr:\n            if elem < avg_with_additions:\n                additions.append(avg_with_additions - elem)\n            elif elem > avg_with_subtractions:\n                subtractions.append(elem - avg_with_subtractions)\n        \n        additions.sort()\n        subtractions.sort(reverse=True)\n        \n        i, j = 0, 0\n        while i < len(additions) and j < len(subtractions):\n            if additions[i] != subtractions[j]:\n                return \"NO\"\n            i += 1\n            j += 1\n        \n        return i == len(additions) and j == len(subtractions)\n    \n    for x in range(1, (max_val - min_val) + 1):\n        if check(x):\n            return \"YES\"\n    \n    return \"NO\"\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Printing output\nprint(can_equalize_elements(arr))"}
{"solution": "def find_max_repeated_substring_length(s):\n    n = len(s)\n    max_len = 0\n\n    # Function to check if a substring of length `len` repeats\n    def repeats(sub_len):\n        seen = set()\n        for i in range(n - sub_len + 1):\n            substr = s[i:i+sub_len]\n            if substr in seen:\n                return True\n            seen.add(substr)\n        return False\n\n    # Binary search for the maximum length\n    low, high = 1, n // 2\n    while low <= high:\n        mid = (low + high) // 2\n        if repeats(mid):\n            max_len = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return max_len\n\n# Read input\nn = int(input())\ns = input()\n\n# Print the result\nprint(find_max_repeated_substring_length(s))"}
{"solution": "n, a = map(int, input().split())\n\nif a > n // 2:\n    print(n - a)\nelse:\n    print(a)"}
{"solution": "def is_possible(n, m, colors, k):\n    from collections import Counter\n    \n    target_counts = Counter(k)\n    current_counts = Counter()\n    \n    for i in range(n):\n        current_counts[colors[i]] += 1\n        \n        if i >= sum(target_counts.values()) - 1:\n            if current_counts == target_counts:\n                return \"YES\"\n            current_counts[colors[i - (sum(target_counts.values()) - 1)]] -= 1\n            if current_counts[colors[i - (sum(target_counts.values()) - 1)]] == 0:\n                del current_counts[colors[i - (sum(target_counts.values()) - 1)]]\n                \n    return \"NO\"\n\n# Reading input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\nk = list(map(int, input().split()))\n\n# Solving and printing output\nprint(is_possible(n, m, colors, k))"}
{"solution": "# Import necessary package\nn = int(input())\n\nmishka_wins = 0\nchris_wins = 0\n\nfor _ in range(n):\n    m, c = map(int, input().split())\n    if m > c:\n        mishka_wins += 1\n    elif c > m:\n        chris_wins += 1\n\nif mishka_wins > chris_wins:\n    print(\"Mishka\")\nelif chris_wins > mishka_wins:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")"}
{"solution": "def is_valid_minesweeper_field(n, m, field):\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n\n    def count_bombs(x, y):\n        count = 0\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and field[nx][ny] == '*':\n                count += 1\n        return count\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '.':\n                if any(0 <= i + dx < n and 0 <= j + dy < m and field[i + dx][j + dy] == '*' for dx, dy in directions):\n                    return \"NO\"\n            elif field[i][j] != '*':\n                expected_bombs = int(field[i][j])\n                actual_bombs = count_bombs(i, j)\n                if expected_bombs != actual_bombs:\n                    return \"NO\"\n    return \"YES\"\n\n# Reading input\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\n# Printing output\nprint(is_valid_minesweeper_field(n, m, field))"}
{"solution": "from math import ceil\n\ndef petya_eats(candies):\n    return candies - (candies // 10)\n\ndef find_min_k(n):\n    k = 1\n    while True:\n        remaining_candies = n\n        vasya_eats = 0\n        while remaining_candies > 0:\n            remaining_candies -= k\n            vasya_eats += k\n            if remaining_candies <= 0:\n                break\n            remaining_candies = petya_eats(remaining_candies)\n            if remaining_candies <= 0:\n                break\n        if vasya_eats >= n / 2:\n            return k\n        k += 1\n\nn = int(input())\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace(necklace: str) -> str:\n    n = len(necklace)\n    pearl_positions = [i for i, char in enumerate(necklace) if char == 'o']\n    num_pearls = len(pearl_positions)\n    \n    if num_pearls <= 1:\n        return \"YES\"\n    \n    # Check if links between pearls can be evenly distributed\n    for links_between in range(n):\n        if (n - num_pearls + links_between * (num_pearls - 1)) % num_pearls == 0:\n            return \"YES\"\n    return \"NO\"\n\n# Reading input\nnecklace = input().strip()\n\n# Computing and printing the result\nprint(can_rearrange_necklace(necklace))"}
{"solution": "def max_pillows(n, m, k):\n    low, high = 0, m\n    while low < high:\n        mid = (low + high + 1) // 2\n        pillows_needed = mid + 2 * (mid - 1) * (k - 1 > 0) + 2 * (mid - 1) * (n - k > 0)\n        if pillows_needed <= m:\n            low = mid\n        else:\n            high = mid - 1\n    return low\n\n# Example usage\nn, m, k = map(int, input().split())\nprint(max_pillows(n, m, k))"}
{"solution": "from collections import deque\n\ndef max_subarray_cost(n, m, k, a):\n    prefix_sum = [0]\n    for val in a:\n        prefix_sum.append(prefix_sum[-1] + val)\n\n    max_cost = 0\n    window_sum = deque()\n    \n    for i in range(n + 1):\n        while window_sum and i - window_sum[0][1] >= m:\n            window_sum.popleft()\n        \n        current_cost = prefix_sum[i] - k * (i // m)\n        max_cost = max(max_cost, current_cost - (window_sum[0][0] if window_sum else 0))\n        \n        while window_sum and prefix_sum[i] > window_sum[-1][0]:\n            window_sum.pop()\n        \n        window_sum.append((prefix_sum[i], i))\n\n    return max_cost\n\n# Reading input\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Printing output\nprint(max_subarray_cost(n, m, k, a))"}
{"solution": "def main():\n    n, m = map(int, input().split())\n\n    # Ensure n is always the larger dimension for uniformity in solution\n    if m > n:\n        n, m = m, n\n\n    # Define the four points to maximize the polyline length\n    p1 = (n, m)\n    p2 = (0, 0)\n    p3 = (n, 0)\n    p4 = (0, m)\n\n    # Print the coordinates of the points\n    print(f\"{p1[0]} {p1[1]}\")\n    print(f\"{p2[0]} {p2[1]}\")\n    print(f\"{p3[0]} {p3[1]}\")\n    print(f\"{p4[0]} {p4[1]}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import Counter\n\ndef reconstruct_number(shuffled_str, substring):\n    # Count occurrences of each digit in the shuffled string\n    shuffled_count = Counter(shuffled_str)\n    \n    # Count occurrences of each digit in the substring\n    sub_count = Counter(substring)\n    \n    # Initialize variables\n    result = []\n    remaining_length = len(shuffled_str) - len(substring)\n    \n    # Process digits in ascending order, excluding those in the substring\n    for digit in range(10):\n        current_digit = str(digit)\n        if current_digit not in sub_count:\n            for _ in range(shuffled_count[current_digit]):\n                result.append(current_digit)\n                remaining_length -= 1\n                if remaining_length == len(substring):\n                    break\n    \n    # Append the substring\n    result.append(substring)\n    \n    # Reconstruct the final number\n    final_number = ''.join(result).lstrip('0')\n    if not final_number:\n        final_number = '0'\n    \n    return final_number\n\n# Read input\nshuffled_str = input().strip()\nsubstring = input().strip()\n\n# Print the reconstructed number\nprint(reconstruct_number(shuffled_str, substring))"}
{"solution": "n, m, min_temp, max_temp = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\nmin_possible = max(min_temp, min(temperatures))\nmax_possible = min(max_temp, max(temperatures))\n\nif max_possible - min_possible + m <= n and min_possible <= max_temp and max_possible >= min_temp:\n    print('Correct')\nelse:\n    print('Incorrect')"}
{"solution": "def find_trailing_zeros(m):\n    n = 5 * m\n    count = 0\n    result = []\n    while n <= 5 * m + 4:\n        temp_n = n\n        zeros = 0\n        while temp_n % 5 == 0:\n            temp_n //= 5\n            zeros += 1\n        if zeros == m:\n            result.append(n)\n            count += 1\n        n += 1\n    return count, result\n\nm = int(input())\ncount, result = find_trailing_zeros(m)\nprint(count)\nif count > 0:\n    print(' '.join(map(str, result)))"}
{"solution": "import heapq\n\ndef dfs(node, visited, graph, start, dist):\n    stack = [(node, float('inf'))]\n    max_dist = 0\n    while stack:\n        current_node, current_max = stack.pop()\n        if visited[current_node] >= current_max:\n            continue\n        visited[current_node] = current_max\n        for neighbor, weight in graph[current_node]:\n            next_max = max(current_max, weight)\n            max_dist = max(max_dist, next_max)\n            if neighbor == start:\n                continue\n            if visited[neighbor] < next_max:\n                stack.append((neighbor, next_max))\n    return max_dist, visited\n\ndef find_farthest_special_vertices(n, m, k, special_vertices, edges):\n    # Build graph\n    graph = [[] for _ in range(n + 1)]\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    # Initialize visited array\n    visited = [0] * (n + 1)\n\n    # Perform DFS from each special vertex\n    results = []\n    for sv in special_vertices:\n        _, updated_visited = dfs(sv, visited.copy(), graph, sv, 0)\n        results.append(updated_visited)\n\n    # Find farthest special vertex for each special vertex\n    final_results = []\n    for i, sv in enumerate(special_vertices):\n        max_distance = 0\n        for j, other_sv in enumerate(special_vertices):\n            if i != j:\n                max_distance = max(max_distance, results[j][other_sv])\n        final_results.append(max_distance)\n\n    return final_results\n\n# Read input\nn, m, k = map(int, input().split())\nspecial_vertices = list(map(int, input().split()))\nedges = [list(map(int, input().split())) for _ in range(m)]\n\n# Solve and print output\noutput = find_farthest_special_vertices(n, m, k, special_vertices, edges)\nprint(*output)"}
{"solution": "n = int(input())\nx = int(input())\n\nif n % 2 == 0:\n    if x == 0:\n        print(0)\n    elif x == 1:\n        print(2)\n    else:\n        print(1)\nelse:\n    if x == 0:\n        print(1)\n    elif x == 1:\n        print(0)\n    else:\n        print(2)"}
{"solution": "def check_square(rectangles):\n    x_coords = set()\n    y_coords = set()\n    for rect in rectangles:\n        x1, y1, x2, y2 = rect\n        x_coords.add(x1)\n        x_coords.add(x2)\n        y_coords.add(y1)\n        y_coords.add(y2)\n\n    x_diff = max(x_coords) - min(x_coords)\n    y_diff = max(y_coords) - min(y_coords)\n\n    return \"YES\" if len(x_coords) == 2 and len(y_coords) == 2 and x_diff == y_diff else \"NO\"\n\ndef main():\n    n = int(input())\n    rectangles = [list(map(int, input().split())) for _ in range(n)]\n    print(check_square(rectangles))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_really_big_numbers(n, s):\n    def count_digits(num):\n        return len(str(num))\n\n    def helper(target, remaining_sum, index, tight, sum_so_far, dp):\n        if index == -1:\n            return 1 if remaining_sum <= sum_so_far else 0\n        if remaining_sum < 0:\n            return 0\n        if dp[index][tight][sum_so_far] != -1:\n            return dp[index][tight][sum_so_far]\n        \n        ways = 0\n        limit = int(str(target)[index]) if tight else 9\n        for digit in range(limit + 1):\n            new_tight = tight and digit == int(str(target)[index])\n            ways += helper(target, remaining_sum, index - 1, new_tight, sum_so_far + digit, dp)\n        \n        dp[index][tight][sum_so_far] = ways\n        return ways\n\n    max_possible_sum = 9 * count_digits(n)\n    dp = [[[-1 for _ in range(max_possible_sum + 1)] for _ in range(2)] for _ in range(count_digits(n))]\n    total_ways = helper(n, s, count_digits(n) - 1, 1, 0, dp)\n\n    # Subtract the count for numbers less than 1 (if applicable)\n    if s > n:\n        total_ways -= 1\n\n    return total_ways\n\n# Reading input\nn, s = map(int, input().split())\n\n# Calculating and printing the result\nprint(count_really_big_numbers(n, s))"}
{"solution": "from collections import defaultdict\n\ndef check_lines(n, points):\n    slopes = defaultdict(int)\n    \n    # If there's only one point, it's trivially possible.\n    if n == 1:\n        return \"YES\"\n    \n    # Attempt to find two lines that cover all points.\n    for i in range(n):\n        if points[i][0] == 0 and points[i][1] == 0:\n            continue  # Skip origin point\n        \n        for j in range(i + 1, n):\n            dx = points[j][0] - points[i][0]\n            dy = points[j][1] - points[i][1]\n            \n            if dx == 0 and dy == 0:  # Duplicate points, skip\n                continue\n            \n            gcd = abs(__gcd(dx, dy))\n            dx //= gcd\n            dy //= gcd\n            \n            if (dx, dy) != (0, 0):\n                slopes[(dx, dy)] += 1\n    \n    # Check if any slope covers more than half of the points or if there's a vertical line.\n    max_covered = max(slopes.values(), default=0)\n    has_vertical_or_horizontal = (0, 1) in slopes or (0, -1) in slopes or (1, 0) in slopes or (-1, 0) in slopes\n    \n    if max_covered >= n // 2 + (n % 2 > 0) or has_vertical_or_horizontal:\n        return \"YES\"\n    else:\n        return \"NO\"\n\ndef __gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Read input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(check_lines(n, points))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(a, b, k, t):\n    dp = [[0] * (2*k+1) for _ in range(t+1)]\n    offset = k\n    dp[0][k] = 1\n    \n    for turn in range(1, t+1):\n        new_dp = [0] * (2*k+1)\n        for diff in range(-k, k+1):\n            for prev_diff in range(-k, k+1):\n                new_diff = prev_diff + diff - offset\n                if 0 <= new_diff + offset < 2*k+1:\n                    new_dp[new_diff + offset] += dp[turn-1][prev_diff + offset]\n                    new_dp[new_diff + offset] %= MOD\n        dp[turn] = new_dp\n    \n    result = 0\n    for diff in range(b-a+1, 2*k+1):\n        result += dp[t][diff]\n        result %= MOD\n    \n    return result\n\na, b, k, t = map(int, input().split())\nprint(solve(a, b, k, t))"}
{"solution": "from itertools import combinations\n\ndef find_min_marks(n, l, x, y, marks):\n    def can_measure(distance):\n        diff_set = set()\n        for i, j in combinations(marks, 2):\n            if i - j == distance or j - i == distance:\n                return True\n            diff_set.update([j - i])\n        return False\n\n    if can_measure(x) and can_measure(y):\n        return 0, []\n\n    # Add missing distances\n    needed_distances = [x, y]\n    new_marks = set(marks)\n    for dist in needed_distances:\n        if not can_measure(dist):\n            # Find a position for the new mark\n            for pos in range(l + 1):\n                if pos not in new_marks and (pos + dist in new_marks or pos - dist in new_marks):\n                    new_marks.add(pos)\n                    break\n\n    # Filter out existing marks\n    added_marks = sorted(list(new_marks - set(marks)))\n\n    return len(added_marks), added_marks\n\n# Read input\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Solve\ncount, marks_to_add = find_min_marks(n, l, x, y, marks)\n\n# Output\nprint(count)\nprint(' '.join(map(str, marks_to_add)))"}
{"solution": "from math import pi\n\ndef max_cake_volume(n, cakes):\n    volumes = [pi * r**2 * h for r, h in cakes]\n    dp = [0] * n\n    max_vol = 0\n\n    def binary_search(subseq, vol):\n        left, right = 0, len(subseq) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if subseq[mid] < vol:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    for i in range(n):\n        dp[i] = volumes[i]\n        for j in range(i):\n            if volumes[j] < volumes[i]:\n                pos = binary_search(dp[:j+1], volumes[i])\n                if dp[j] > dp[pos]:\n                    dp[pos] = dp[j]\n        max_vol = max(max_vol, volumes[i])\n\n    for length in range(n, 0, -1):\n        if dp[length-1] > 0:\n            subseq_vol = sum(x for x in dp[:length] if x > 0)\n            max_vol = max(max_vol, subseq_vol)\n            break\n\n    return max_vol\n\n# Reading input\nn = int(input())\ncakes = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculating and printing the output\nprint(max_cake_volume(n, cakes))"}
{"solution": "from typing import List\nfrom bisect import bisect_right\n\ndef min_good_slices(tower_heights: List[int], k: int) -> int:\n    tower_heights.sort()\n    max_possible_heights = [0] * (len(tower_heights) + 1)\n    max_possible_heights[0] = tower_heights[0]\n    for i in range(1, len(tower_heights)):\n        max_possible_heights[i] = max(max_possible_heights[i-1], tower_heights[i])\n    \n    max_possible_heights[-1] = max_possible_heights[-2]\n    \n    total_towers = 0\n    for height in tower_heights:\n        index = bisect_right(max_possible_heights, height)\n        if total_towers + len(tower_heights) - index > k:\n            return len(tower_heights) - index\n        total_towers += len(tower_heights) - index\n    \n    return 0\n\n# Example check function (not part of the solution)\ndef check_solution():\n    assert min_good_slices([3, 1, 2, 2, 4], 5) == 2\n    assert min_good_slices([2, 3, 4, 5], 5) == 2\n    assert min_good_slices([1, 2, 3, 4, 5], 10) == 1\n    print(\"All tests passed!\")\n\ncheck_solution()"}
{"solution": "def max_game_score(n, a):\n    prefix_sum = [0]\n    for value in a:\n        prefix_sum.append(prefix_sum[-1] + value)\n    \n    left_max = [0] * (n + 2)\n    right_max = [0] * (n + 2)\n    \n    stack = []\n    for i in range(n):\n        while stack and a[stack[-1]] <= a[i]:\n            stack.pop()\n        if not stack:\n            left_max[i + 1] = 0\n        else:\n            left_max[i + 1] = stack[-1] + 1\n        stack.append(i)\n    \n    stack = []\n    for i in range(n - 1, -1, -1):\n        while stack and a[stack[-1]] <= a[i]:\n            stack.pop()\n        if not stack:\n            right_max[i] = n + 1\n        else:\n            right_max[i] = stack[-1]\n        stack.append(i)\n    \n    max_score = 0\n    for i in range(1, n + 1):\n        score = prefix_sum[right_max[i] - 1] - prefix_sum[left_max[i]]\n        max_score = max(max_score, score)\n    \n    return max_score\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(max_game_score(n, a))"}
{"solution": "from math import gcd\n\ndef can_light_garlands(k1, k2, k3):\n    # Calculate gcd for all pairs\n    gcd_k1_k2 = gcd(k1, k2)\n    gcd_k2_k3 = gcd(k2, k3)\n    gcd_k1_k3 = gcd(k1, k3)\n\n    # Calculate gcd of all three\n    gcd_all = gcd(gcd_k1_k2, gcd_k2_k3, gcd_k1_k3)\n\n    # If the gcd of all three periods is 1, we can light at least one garland every second\n    return \"YES\" if gcd_all == 1 else \"NO\"\n\n# Reading input\nk1, k2, k3 = map(int, input().split())\n\n# Printing output\nprint(can_light_garlands(k1, k2, k3))"}
{"solution": "def min_deletions_to_empty_string(n, s):\n    \"\"\"\n    Calculate the minimum number of operations to delete the whole string s,\n    where in one operation you can delete some contiguous substring of equal characters.\n    \"\"\"\n    dp = [0] * (n + 1)\n    max_length = 0\n    last_positions = {}\n    \n    for i in range(1, n + 1):\n        dp[i] = i\n        max_length = 0\n        while s[i - 1 - max_length] == s[i - 1]:\n            max_length += 1\n            if i - max_length in last_positions:\n                dp[i] = min(dp[i], dp[i - max_length] + 1)\n        last_positions[i - 1] = i\n    \n    return dp[n]\n\n# Reading input\nn = int(input())\ns = input()\n\n# Calculating and printing the result\nprint(min_deletions_to_empty_string(n, s))"}
{"solution": "def max_dance_pairs():\n    n = int(input())\n    boys = sorted(list(map(int, input().split())))\n    m = int(input())\n    girls = sorted(list(map(int, input().split())))\n\n    boy, girl = 0, 0\n    pairs = 0\n\n    while boy < n and girl < m:\n        if abs(boys[boy] - girls[girl]) <= 1:\n            pairs += 1\n            boy += 1\n            girl += 1\n        elif boys[boy] < girls[girl]:\n            boy += 1\n        else:\n            girl += 1\n\n    return pairs\n\nprint(max_dance_pairs())"}
{"solution": "def kicker_winner(a1, b1, a2, b2, a3, b3, a4, b4):\n    # Team 1 strategies\n    team1_win_strategies = []\n    # Strategy 1: Player 1 defends, Player 2 attacks\n    if max(a1, a2) == a1 and max(b1, b2) == b2:\n        team1_win_strategies.append((min(b3, b4), max(a3, a4), min(a3, a4), max(b3, b4)))\n    # Strategy 2: Player 1 attacks, Player 2 defends\n    if max(a1, a2) == a2 and max(b1, b2) == b1:\n        team1_win_strategies.append((min(b3, b4), max(a3, a4), min(a3, a4), max(b3, b4)))\n\n    # Team 2 strategies\n    team2_win_strategies = []\n    # Strategy 1: Player 3 defends, Player 4 attacks\n    if max(a3, a4) == a3 and max(b3, b4) == b4:\n        team2_win_strategies.append((min(b1, b2), max(a1, a2), min(a1, a2), max(b1, b2)))\n    # Strategy 2: Player 3 attacks, Player 4 defends\n    if max(a3, a4) == a4 and max(b3, b4) == b3:\n        team2_win_strategies.append((min(b1, b2), max(a1, a2), min(a1, a2), max(b1, b2)))\n\n    # Check if Team 1 can guarantee a win\n    can_team1_win = any(d1 > a2 and a1 > d2 for d1, a1, d2, a2 in team1_win_strategies)\n    # Check if Team 2 can guarantee a win\n    can_team2_win = any(d1 > a2 and a1 > d2 for d1, a1, d2, a2 in team2_win_strategies)\n\n    if can_team1_win and not can_team2_win:\n        return \"Team 1\"\n    elif can_team2_win and not can_team1_win:\n        return \"Team 2\"\n    else:\n        return \"Draw\"\n\n# Read input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\na4, b4 = map(int, input().split())\n\n# Output\nprint(kicker_winner(a1, b1, a2, b2, a3, b3, a4, b4))"}
{"solution": "import heapq\nimport math\n\ndef solve(N, K, meats):\n    def feasible(time):\n        pq = []\n        for x, y, c in meats:\n            t = time / c\n            dist = math.sqrt(t * t)  # sqrt(t^2)\n            score = -(math.sqrt((x * x) + (y * y)) - dist)\n            if len(pq) == K:\n                if score > pq[0]:\n                    return True\n                heapq.heappushpop(pq, score)\n            else:\n                heapq.heappush(pq, score)\n        return False\n\n    left, right = 0, 1e9\n    while right - left > 1e-6:\n        mid = (left + right) / 2\n        if feasible(mid):\n            right = mid\n        else:\n            left = mid\n    return right\n\n# Reading input\nN, K = map(int, input().split())\nmeats = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Solving\nresult = solve(N, K, meats)\n\n# Printing output\nprint(f\"{result:.6f}\")"}
{"solution": "def game_winner(n, ticket):\n    left_sum = 0\n    right_sum = 0\n    left_erasures = 0\n    right_erasures = 0\n    \n    for i in range(n // 2):\n        if ticket[i] == '?':\n            left_erasures += 1\n        else:\n            left_sum += int(ticket[i])\n    \n    for i in range(n // 2, n):\n        if ticket[i] == '?':\n            right_erasures += 1\n        else:\n            right_sum += int(ticket[i])\n    \n    # Calculate the difference in erasures and sums\n    erasures_diff = abs(left_erasures - right_erasures)\n    sum_diff = abs(left_sum - right_sum)\n    \n    # Determine the winner\n    if erasures_diff % 2 != 0 or sum_diff > 9 * (erasures_diff // 2):\n        return \"Monocarp\"\n    else:\n        return \"Bicarp\"\n\n# Read input\nn = int(input())\nticket = input()\n\n# Print the winner\nprint(game_winner(n, ticket))"}
{"solution": "def find_bus_route(n, t, routes):\n    earliest_bus = (float('inf'), None)\n    for i in range(n):\n        s_i, d_i = routes[i]\n        if s_i < t:\n            # Calculate the next bus arrival time after t\n            next_bus_time = s_i + ((t - s_i + d_i - 1) // d_i) * d_i\n        else:\n            next_bus_time = s_i\n        if next_bus_time < earliest_bus[0]:\n            earliest_bus = (next_bus_time, i + 1)\n    return earliest_bus[1]\n\n# Reading input\nn, t = map(int, input().split())\nroutes = [list(map(int, input().split())) for _ in range(n)]\n\n# Solving and printing output\nprint(find_bus_route(n, t, routes))"}
{"solution": "def count_ones_in_range(start, end):\n    count = 0\n    for num in range(start, end + 1):\n        binary_representation = bin(num)[2:]  # Convert to binary and remove the '0b' prefix.\n        count += binary_representation.count('1')\n    return count\n\ndef find_number(m, k):\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        end = 2 * mid\n        ones_count = count_ones_in_range(mid + 1, end)\n        if ones_count == m * k:\n            return mid\n        elif ones_count < m * k:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Reading input\nm, k = map(int, input().split())\n\n# Solving the problem\nresult = find_number(m, k)\n\n# Printing the result\nprint(result)"}
{"solution": "n = int(input())\nlevel = input()\n\ndef is_good_level(level_str):\n    for i in range(n):\n        if level_str[i] == '*':\n            for d in range(1, n):\n                if i + 4 * d >= n:\n                    break\n                if level_str[i + d] == '*' and level_str[i + 2 * d] == '*' and level_str[i + 3 * d] == '*' and level_str[i + 4 * d] == '*':\n                    return True\n    return False\n\nprint('yes' if is_good_level(level) else 'no')"}
{"solution": "from itertools import accumulate\nimport sys\n\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    A = [list(map(int, input().split())) for _ in range(n)]\n\n    # Find the zero\n    for r in range(n):\n        for c in range(n):\n            if A[r][c] == 0:\n                zero_r, zero_c = r, c\n                break\n\n    # Calculate sums\n    row_sums = [sum(row) for row in A]\n    col_sums = [sum(A[r][c] for r in range(n)) for c in range(n)]\n    diag_sum1 = sum(A[i][i] for i in range(n))\n    diag_sum2 = sum(A[i][n - 1 - i] for i in range(n))\n\n    # Check consistency of sums\n    target_sum = row_sums[zero_r]\n    if not all(s == target_sum for s in row_sums + col_sums + [diag_sum1, diag_sum2]):\n        return -1\n\n    # Calculate missing value\n    missing_value_row = target_sum - sum(A[zero_r][:zero_c] + A[zero_r][zero_c + 1:])\n    missing_value_col = target_sum - sum(A[r][zero_c] for r in range(n) if r != zero_r)\n    missing_value_diag1 = (target_sum - sum(A[i][i] for i in range(n) if i != zero_r)\n                           if zero_r == zero_c else None)\n    missing_value_diag2 = (target_sum - sum(A[i][n - 1 - i] for i in range(n) if i != zero_r)\n                           if zero_r == n - 1 - zero_c else None)\n\n    # Check consistency of missing values\n    if (missing_value_row != missing_value_col or\n        (missing_value_diag1 is not None and missing_value_row != missing_value_diag1) or\n        (missing_value_diag2 is not None and missing_value_row != missing_value_diag2)):\n        return -1\n\n    return missing_value_row\n\nprint(solve())"}
{"solution": "def calculate_min_max_k(n, m, benches):\n    # Calculate minimum k\n    total_people = sum(benches)\n    min_k = (total_people + m - 1) // n\n    \n    # Calculate maximum k\n    max_k = max(benches) + m\n    \n    # Ensure max_k is feasible\n    if max_k > (total_people + m):\n        max_k = (total_people + m)\n    \n    return min_k, max_k\n\n# Reading input\nn = int(input())\nm = int(input())\nbenches = [int(input()) for _ in range(n)]\n\n# Calculating and printing output\nmin_k, max_k = calculate_min_max_k(n, m, benches)\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_pow(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef solve(n, m):\n    # The formula derived from the problem statement and analysis\n    return (mod_pow(2, m) * mod_pow(2, n - m)) % MOD\n\n# Reading input\nn, m = map(int, input().split())\n\n# Solving and printing the result\nprint(solve(n, m))"}
{"solution": "from itertools import combinations\n\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef read_list():\n    return list(read_ints())\n\ndef main():\n    n, m = read_ints()\n    friends = [set(read_list()[1:]) for _ in range(n)]\n    pizzas = [[read_list()[0], set(read_list()[1:])] for _ in range(m)]\n\n    min_cost = float('inf')\n    best_pizzas = (0, 0)\n    max_happiness = 0\n\n    for i, j in combinations(range(m), 2):\n        pizza1, pizza2 = pizzas[i][1], pizzas[j][1]\n        cost = pizzas[i][0] + pizzas[j][0]\n        happiness = sum(1 for friend in friends if friend.issubset(pizza1.union(pizza2)))\n\n        if happiness > max_happiness or (happiness == max_happiness and cost < min_cost):\n            max_happiness = happiness\n            min_cost = cost\n            best_pizzas = (i + 1, j + 1)\n\n    print(*best_pizzas)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_min_max_numbers(m, s):\n    def generate_number(m, s, ascending=True):\n        if s == 0:\n            return '0' * m if m > 1 else '0'\n        if s > 9 * m:\n            return '-1'\n\n        number = []\n        if ascending:\n            while m > 1:\n                digit = min(s, 9)\n                number.append(str(digit))\n                s -= digit\n                m -= 1\n            number.append(str(s))\n        else:\n            while m > 1:\n                digit = max(0, s - 9 * (m - 1))\n                number.append(str(digit))\n                s -= digit\n                m -= 1\n            number.append(str(s))\n\n        return int(''.join(number[::-1] if ascending else number)) if number[0] != '0' else '-1'\n\n    min_num = generate_number(m, s, ascending=True)\n    max_num = generate_number(m, s, ascending=False)\n\n    return f\"{min_num} {max_num}\"\n\n# Reading input\nm, s = map(int, input().split())\n\n# Printing output\nprint(find_min_max_numbers(m, s))"}
{"solution": "MOD = 998244353\n\ndef power(base, exp):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exp //= 2\n    return result\n\ndef inv(x):\n    return power(x, MOD - 2)\n\ndef C(n, k):\n    if k == 0 or k == n:\n        return 1\n    return ((fact[n] * inv(fact[k])) % MOD * inv(fact[n-k])) % MOD\n\ndef S(n, k):\n    if k == 0:\n        return 1\n    return ((C(9, k) - C(9, k-1)) * power(10, n-1)) % MOD\n\ndef fact_init(N):\n    fact = [1] * (N+1)\n    for i in range(2, N+1):\n        fact[i] = (fact[i-1] * i) % MOD\n    return fact\n\ndef sum_of_numbers(l, r, k):\n    fact = fact_init(10)\n    total_sum = 0\n    for d in range(1, 10):\n        x = 0\n        for nd in range(1, k+1):\n            if nd == 1:\n                x = d * power(10, (len(str(r)) - 1))\n            else:\n                x += d * S(len(str(r)), nd)\n            x %= MOD\n        x += r\n        x -= d * power(10, (len(str(l-1)) - 1))\n        if len(str(l-1)) > 0:\n            x -= d * S(len(str(l-1)), k)\n        x %= MOD\n        total_sum += x\n        total_sum %= MOD\n    return total_sum\n\n# Reading input\nl, r, k = map(int, input().split())\n\n# Calculating and printing the output\nprint(sum_of_numbers(l, r, k))"}
{"solution": "def can_distribute_pencils(n, k, d, pencils):\n    pencils.sort()\n    groups = 1\n    last_group_max = pencils[0] + d\n    for i in range(1, n):\n        if pencils[i] > last_group_max:\n            groups += 1\n            last_group_max = pencils[i] + d\n        if groups * k > n:\n            return \"NO\"\n    return \"YES\"\n\n# Reading input\nn, k, d = map(int, input().split())\npencils = list(map(int, input().split()))\n\n# Printing output\nprint(can_distribute_pencils(n, k, d, pencils))"}
{"solution": "def count_dead_bulbs(garland):\n    colors = ['R', 'B', 'Y', 'G']\n    dead_counts = {'R': 0, 'B': 0, 'Y': 0, 'G': 0}\n\n    for i in range(len(garland)):\n        if garland[i] == '!':\n            possible_colors = set(colors)\n            for j in range(max(0, i-3), min(len(garland), i+4)):\n                if garland[j] != '!':\n                    possible_colors.discard(garland[j])\n            \n            for color in possible_colors:\n                dead_counts[color] += 1\n\n    return dead_counts['R'], dead_counts['B'], dead_counts['Y'], dead_counts['G']\n\n# Reading input\ngarland = input().strip()\n\n# Calculating and printing the result\nresult = count_dead_bulbs(garland)\nprint(*result)"}
{"solution": "from collections import defaultdict, deque\n\ndef solve(n, m, st_pairs):\n    graph = defaultdict(list)\n    indeg = [0] * n\n    for s, t in st_pairs:\n        graph[s - 1].append(t - 1)\n        indeg[t - 1] += 1\n    \n    # Topological sort to find layers\n    layers = [[] for _ in range(n)]\n    queue = deque([i for i in range(n) if indeg[i] == 1])\n    while queue:\n        node = queue.popleft()\n        layers[len(queue)].append(node)\n        for neighbor in graph[node]:\n            indeg[neighbor] -= 1\n            if indeg[neighbor] == 1:\n                queue.append(neighbor)\n    \n    # Calculate initial expected values\n    exp_vals = [0] * n\n    for layer in reversed(range(n - 1)):\n        for node in layers[layer]:\n            next_layers_sum = sum(len(graph[n]) for n in layers[layer + 1])\n            for next_node in graph[node]:\n                exp_vals[node] += exp_vals[next_node] + len(graph[next_node]) / next_layers_sum\n    \n    # Determine the best passage to block\n    min_exp_val = exp_vals[0]\n    for next_node in graph[0]:\n        temp_val = exp_vals[0] - (exp_vals[next_node] + 1) * len(graph[next_node]) / len(graph[0])\n        min_exp_val = min(min_exp_val, temp_val)\n    \n    return min_exp_val + 1\n\n# Read input\nn, m = map(int, input().split())\nst_pairs = [list(map(int, input().split())) for _ in range(m)]\n\n# Solve and print the result\nprint(solve(n, m, st_pairs))"}
{"solution": "n = int(input())\nif n % 10 == 0:\n    print(n)\nelse:\n    last_non_zero_digit_position = 1\n    while n // (10 ** last_non_zero_digit_position) % 10 == 0:\n        last_non_zero_digit_position += 1\n    lower_bound = n - n % (10 ** last_non_zero_digit_position)\n    upper_bound = lower_bound + 10 ** last_non_zero_digit_position\n    if n - lower_bound < upper_bound - n:\n        print(lower_bound)\n    else:\n        print(upper_bound)"}
{"solution": "def find_swaps(s, t):\n    if s == t:\n        return 0, []\n    \n    swaps = {}\n    unmatched_s = set()\n    unmatched_t = set()\n    \n    for char_s, char_t in zip(s, t):\n        if char_s != char_t:\n            if char_t in swaps and swaps[char_t] != char_s:\n                return -1\n            elif char_s in swaps and swaps[char_s] != char_t:\n                return -1\n            else:\n                swaps[char_s] = char_t\n                unmatched_s.add(char_s)\n                unmatched_t.add(char_t)\n    \n    if len(unmatched_s) % 2 != 0 or len(unmatched_t) % 2 != 0:\n        return -1\n    \n    result_swaps = []\n    seen = set()\n    \n    for char_s, char_t in swaps.items():\n        if char_s not in seen and char_t not in seen:\n            result_swaps.append((char_s, char_t))\n            seen.add(char_s)\n            seen.add(char_t)\n    \n    return len(result_swaps), result_swaps\n\n# Reading input\ns = input().strip()\nt = input().strip()\n\n# Calculating and printing output\nnum_swaps, swaps = find_swaps(s, t)\n\nif num_swaps == -1:\n    print(-1)\nelse:\n    print(num_swaps)\n    for swap in swaps:\n        print(' '.join(swap))"}
{"solution": "def earliest_login(first_name, last_name):\n    min_login = first_name[0] + last_name[0]\n    for i in range(1, min(len(first_name), 11)):\n        for j in range(1, min(len(last_name), 11)):\n            login = first_name[:i] + last_name[:j]\n            if login < min_login:\n                min_login = login\n    return min_login\n\n# Reading input\nfirst_name, last_name = input().split()\n\n# Calculating and printing the output\nprint(earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(sequence):\n    def draw(stack, level):\n        if not stack:\n            return [' ' * level]\n        h1, d1 = draw(stack[0][1], level + stack[0][0])\n        h2, d2 = draw(stack[1:], level)\n        h = max(len(h1), len(h2))\n        h1 += [' ' * len(h1[0])] * (h - len(h1))\n        h2 += [' ' * len(h2[0])] * (h - len(h2))\n        drawing = []\n        for i in range(h):\n            drawing.append(' ' * level + h1[i] + d1[i] + h2[i] + d2[i])\n        return h, '\\n'.join(drawing)\n\n    stack = []\n    for b in sequence:\n        if b == '[':\n            stack.append((1, []))\n        else:\n            height, drawing = draw(stack.pop()[1], 0)\n            stack[-1][1].append((height, drawing))\n\n    _, result = draw(stack[0][1], 0)\n    top = '+' + ('-+' * (len(stack[0][1]) + 1)).replace('+', '-+').replace('-', '+')\n    return '\\n'.join([top] + result.split('\\n') + [top])\n\nif __name__ == \"__main__\":\n    n = int(input())\n    sequence = input().strip()\n    print(draw_brackets(sequence))"}
{"solution": "from math import sqrt\n\ndef golden_compare(x, y):\n    phi = (1 + sqrt(5)) / 2\n    n = min(len(x), len(y))\n    for i in range(n):\n        if x[i] != y[i]:\n            return '>' if x[i] > y[i] else '<'\n    if len(x) == len(y):\n        return '='\n    return '<' if len(x) < len(y) else '>'\n\ndef main():\n    x = input().strip()\n    y = input().strip()\n\n    # Reverse the strings since the least significant digit is at the end\n    x = x[::-1]\n    y = y[::-1]\n\n    result = golden_compare(x, y)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "gem_colors = {'purple': 'Power', 'green': 'Time', 'blue': 'Space', 'orange': 'Soul', 'red': 'Reality', 'yellow': 'Mind'}\nn = int(input())\nseen_colors = set()\nfor _ in range(n):\n    seen_colors.add(input().strip())\n\nabsent_gems = [gem_colors[color] for color in gem_colors if color not in seen_colors]\n\nprint(len(absent_gems))\nfor gem in absent_gems:\n    print(gem)"}
{"solution": "n, a, b = map(int, input().split())\n\nif a > b:\n    a, b = b, a\n\nmeet_round = 1\nwhile True:\n    if a == b:\n        print(\"Final!\")\n        break\n    elif (b - a) == 1:\n        print(meet_round)\n        break\n    else:\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        meet_round += 1"}
{"solution": "from collections import defaultdict\n\ndef find_cycle_length(n, visited, p, b):\n    cycle_length = 0\n    start = n\n    while not visited[n]:\n        visited[n] = True\n        cycle_length += 1\n        if b[n - 1] == 1:\n            # If the skewer is flipped, we consider it as moving to a virtual position\n            n = p[n - 1]\n        else:\n            n = p[n - 1]\n    # Check if we've completed a cycle by returning to the start\n    if n != start:\n        cycle_length = 0\n    return cycle_length\n\ndef min_changes(n, p, b):\n    visited = [False] * (n + 1)\n    changes = 0\n    cycles = defaultdict(int)\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            length = find_cycle_length(i, visited, p, b)\n            if length > 0:\n                cycles[length] += 1\n    \n    for length, count in cycles.items():\n        if length < 4:\n            changes += count\n        elif length % 2 == 0:\n            changes += count * (length // 2 - 2)\n        else:\n            changes += count * (length // 2 - 1)\n    \n    return changes\n\n# Reading input\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(min_changes(n, p, b))"}
{"solution": "def max_distance(v1, v2, t, d):\n    def acceleration_time(v, d):\n        return max(0, v // d + (1 if v % d else 0))\n\n    time_to_v1 = acceleration_time(v1, d)\n    time_to_v2 = acceleration_time(v2, d)\n\n    if time_to_v1 + time_to_v2 - 1 <= t:\n        dist = min(v1, v2) * (t - abs(time_to_v1 - time_to_v2) + 1) + (v1 + v2) * (abs(time_to_v1 - time_to_v2) - 1) / 2\n        dist += sum(range(d + 1, max(v1, v2) + 1))\n    else:\n        total_speed_changes = d * (t - 1)\n        final_speed = min(v1, v2) + total_speed_changes\n        dist = min(v1, v2) * (t - 1) + final_speed\n\n    return int(dist)\n\n# Reading input\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Calculating and printing the output\nprint(max_distance(v1, v2, t, d))"}
{"solution": "from itertools import permutations\nfrom bisect import bisect_left\n\ndef check(mid, weights, bridge_lengths, bridge_capacities):\n    current_weight = [0] * (M + 1)\n    pos = [0] * (N + 1)\n    pos[0] = 0\n    pos[N] = mid\n    \n    for i in range(1, N):\n        p = bisect_left(pos, pos[i - 1] + mid)\n        if p == 0:\n            current_weight[0] += weights[i - 1]\n        else:\n            current_weight[p - 1] -= weights[i - 1]\n            current_weight[p] += weights[i - 1]\n    \n    for i in range(1, M + 1):\n        current_weight[i] += current_weight[i - 1]\n        if current_weight[i] > bridge_capacities[i - 1]:\n            return False\n        current_weight[i] -= bridge_lengths[i - 1]\n    \n    return True\n\nN, M = map(int, input().split())\nweights = list(map(int, input().split()))\nbridge_lengths, bridge_capacities = zip(*[map(int, input().split()) for _ in range(M)])\n\nmin_distance = float('inf')\nfor order in permutations(range(N)):\n    low, high = 0, 10**18\n    while high - low > 1:\n        mid = (low + high) // 2\n        if check(mid, [weights[i] for i in order], bridge_lengths, bridge_capacities):\n            high = mid\n        else:\n            low = mid\n    if check(low, [weights[i] for i in order], bridge_lengths, bridge_capacities):\n        min_distance = min(min_distance, low)\n    elif check(high, [weights[i] for i in order], bridge_lengths, bridge_capacities):\n        min_distance = min(min_distance, high)\n\nprint(-1 if min_distance == float('inf') else int(min_distance))"}
{"solution": "def last_digit_of_factorial_division(a, b):\n    \"\"\"\n    Calculate the last digit of the division of two factorials: b! / a!.\n    \"\"\"\n    if b < 10:\n        # Direct calculation for small numbers\n        result = 1\n        for i in range(a + 1, b + 1):\n            result *= i\n            result %= 10\n        return result\n    else:\n        # For b >= 10, the last digit is always 0 because of the factors 2 and 5\n        return 0\n\n# Reading input\na, b = map(int, input().split())\n\n# Calculating and printing the last digit\nprint(last_digit_of_factorial_division(a, b))"}
{"solution": "def min_jumps(n, d, s):\n    dp = [float('inf')] * n\n    dp[0] = 0\n    \n    for i in range(1, n):\n        if s[i] == '0':\n            continue\n        for j in range(max(0, i-d), i):\n            if s[j] == '1':\n                dp[i] = min(dp[i], dp[j] + 1)\n    \n    return dp[-1] if dp[-1] != float('inf') else -1\n\nif __name__ == \"__main__\":\n    n, d = map(int, input().split())\n    s = input()\n    print(min_jumps(n, d, s))"}
{"solution": "def is_prime(num):\n    \"\"\"Check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_counterexample(n):\n    \"\"\"Find a counterexample to PolandBall's hypothesis.\"\"\"\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\n# Read input\nn = int(input())\n\n# Find and print counterexample\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all_coins(n):\n    house_cost = 1234567\n    car_cost = 123456\n    computer_cost = 1234\n\n    for a in range(n // house_cost + 1):\n        for b in range((n - a * house_cost) // car_cost + 1):\n            c = (n - a * house_cost - b * car_cost) / computer_cost\n            if c.is_integer() and c >= 0:\n                return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\n\n# Output result\nprint(can_spend_all_coins(n))"}
{"solution": "from heapq import heappush, heappop\n\ndef solve(lines, x1, x2):\n    events = []\n    for i in range(len(lines)):\n        for j in range(i + 1, len(lines)):\n            ki, bi = lines[i]\n            kj, bj = lines[j]\n            if ki == kj:\n                continue\n            x = (bj - bi) / (ki - kj)\n            if x1 < x < x2:\n                y = ki * x + bi\n                heappush(events, (x, y, ki, kj))\n\n    while len(events) >= 2:\n        x1, y1, ki1, ki2 = heappop(events)\n        x2, y2, _, _ = events[0]\n        if x1 == x2:\n            return \"YES\"\n        ki1, ki2 = sorted([ki1, ki2])\n        if ki1 < 0 < ki2:\n            return \"YES\"\n    return \"NO\"\n\nn = int(input())\nx1, x2 = map(int, input().split())\nlines = [tuple(map(int, input().split())) for _ in range(n)]\n\nprint(solve(lines, x1, x2))"}
{"solution": "def count_weights(n):\n    # The maximum possible weight is when all numbers are 1, so we start from n and decrease.\n    # The minimum possible weight is 1, when the first number is n itself.\n    # We iterate from 1 to n to find all possible weights.\n    possible_weights = set()\n    \n    for weight in range(1, n + 1):\n        # The largest possible number that can be the first element given the weight\n        first_num_max = n // weight\n        # The smallest possible number that can be the first element given the weight\n        first_num_min = 1\n        \n        # Check if there exists a valid first number for the current weight\n        while first_num_max >= first_num_min:\n            first_num = (first_num_max + first_num_min) // 2\n            remaining_sum = n - first_num * weight\n            \n            # If the remaining sum can be made with numbers less than or equal to first_num,\n            # then this weight is possible.\n            if remaining_sum >= 0 and remaining_sum <= (weight - 1) * (first_num - 1):\n                possible_weights.add(weight)\n                break\n            elif remaining_sum < 0 or remaining_sum > (weight - 1) * (first_num - 1):\n                first_num_max = first_num - 1\n            else:\n                first_num_min = first_num + 1\n                \n    return len(possible_weights)\n\n# Read input\nn = int(input())\n\n# Calculate and print the result\nprint(count_weights(n))"}
{"solution": "def calculate_good_apartments(n, k):\n    # Minimum good apartments\n    min_good = max(0, k - 1)\n    \n    # Maximum good apartments\n    if k == 0:\n        max_good = 0\n    elif k >= 2:\n        max_good = 2 * k - 2\n        # Adjust for edge cases\n        if n <= max_good:\n            max_good = n - k\n    else:\n        max_good = 0 if n > 1 else 1\n    \n    return min_good, max_good\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating and printing output\nmin_good, max_good = calculate_good_apartments(n, k)\nprint(min_good, max_good)"}
{"solution": "def max_games_winner_can_play(n):\n    games = 0\n    while n > 1:\n        n = (n + 1) // 2\n        games += 1\n    return games\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the result\nprint(max_games_winner_can_play(n))"}
{"solution": "s = input()\nn = len(s)\nvk_count = 0\nv_count = 0\nk_count = 0\n\nfor i in range(n):\n    if s[i] == 'V':\n        v_count += 1\n        if i > 0 and s[i-1] == 'K':\n            vk_count += 1\n    elif s[i] == 'K':\n        k_count += 1\n        if i > 0 and s[i-1] == 'V':\n            vk_count += 1\n\nmax_vks = min(v_count, k_count)\n\nif max_vks == 0:\n    print(0)\nelse:\n    if vk_count == max_vks:\n        print(max_vks)\n    else:\n        print(min(max_vks + 1, vk_count + 1))"}
{"solution": "n = int(input())\nprint(2 * ((n // 2) + (n % 2)))"}
{"solution": "a, b = map(int, input().split())\n\nyears = 0\nwhile a <= b:\n    a *= 3\n    b *= 2\n    years += 1\n\nprint(years)"}
{"solution": "def count_visited_nodes(h, n):\n    def path_to_leaf(n, h):\n        path = []\n        while h > 0:\n            half = 1 << (h - 1)\n            if n > half:\n                path.append('R')\n                n -= half\n            else:\n                path.append('L')\n            h -= 1\n        return ''.join(path[::-1])\n\n    def simulate_path(path):\n        visited = set()\n        pos = 0\n        depth = 0\n        skipped = 0\n        command_index = 0\n        infinite_command = 'LRLR' * (h + 1)\n\n        while True:\n            if command_index in visited:\n                break\n            visited.add(command_index)\n            cmd = infinite_command[command_index % len(infinite_command)]\n            if skipped == 2:\n                depth -= 1\n                skipped = 0\n                pos = (pos - (1 << depth)) // 2\n                command_index += 1\n                continue\n            if cmd == 'L':\n                if pos * 2 + 1 not in visited:\n                    pos = pos * 2 + 1\n                    depth += 1\n                else:\n                    skipped += 1\n            elif cmd == 'R':\n                if pos * 2 + 2 not in visited:\n                    pos = pos * 2 + 2\n                    depth += 1\n                else:\n                    skipped += 1\n            command_index += 1\n            if pos == n - 1:\n                break\n        return len(visited)\n\n    leaf_path = path_to_leaf(n, h)\n    return simulate_path(leaf_path)\n\n# Example usage\nif __name__ == \"__main__\":\n    h, n = map(int, input().split())\n    print(count_visited_nodes(h, n))"}
{"solution": "from math import sqrt\n\ndef find_tables(x):\n    result = []\n    for n in range(1, int(sqrt(2 * x)) + 1):\n        m = n\n        while n * (n + 1) // 2 * m * (m + 1) // 2 <= x:\n            if n * (n + 1) // 2 * m * (m + 1) // 2 == x:\n                result.append((n, m))\n            m += 1\n    return result\n\ndef main():\n    x = int(input())\n    tables = find_tables(x)\n    print(len(tables))\n    for table in tables:\n        print(*table)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_leap_year(year):\n    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\ndef is_valid_sequence(durations):\n    feb_29 = False\n    for i in range(len(durations)):\n        if durations[i] == 29:\n            if feb_29 or i > 0 and durations[i-1] == 31:\n                return False\n            feb_29 = True\n        elif durations[i] == 31:\n            if i > 0 and durations[i-1] == 31 and (i < len(durations) - 1 and durations[i+1] == 30):\n                return False\n        elif durations[i] == 30:\n            if i > 0 and durations[i-1] == 31 and (i < len(durations) - 1 and durations[i+1] == 31):\n                return False\n    return feb_29 or not any(d == 29 for d in durations)\n\ndef main():\n    n = int(input())\n    durations = list(map(int, input().split()))\n    \n    if n < 2:\n        return \"NO\"\n    \n    if 29 in durations and not is_leap_year(2000):  # Using 2000 as a reference year\n        return \"NO\"\n    \n    if is_valid_sequence(durations):\n        return \"YES\"\n    else:\n        return \"NO\"\n\nprint(main())"}
{"solution": "def find_sequence(n):\n    if n == 2:\n        return [\"NO\"]\n    \n    factors = []\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            factors.append(i)\n            if i * i != n:\n                factors.append(n // i)\n    factors.sort()\n    \n    if not factors:\n        return [\"NO\"]\n    \n    sequence = []\n    remaining = n - 1\n    for factor in factors:\n        a = remaining // factor\n        if a > 0:\n            sequence.append((a, factor))\n            remaining -= a * (n // factor)\n        if remaining == 0:\n            break\n    \n    if remaining != 0:\n        return [\"NO\"]\n    \n    return [\"YES\", str(len(sequence))] + [f\"{a} {b}\" for a, b in sequence]\n\n# Since the problem statement does not provide a specific input method,\n# we assume the input is provided as a function argument.\nn = 6  # Example input\nresult = find_sequence(n)\nprint('\\n'.join(result))"}
{"solution": "def min_unattractiveness(n, limits, heights):\n    from functools import lru_cache\n    \n    a, b = limits\n    total_area = sum(heights)\n    \n    if total_area > a + b:\n        return -1\n    \n    @lru_cache(maxsize=None)\n    def dp(index, prev_color, red_area, green_area):\n        if index == n:\n            return 0\n        \n        red_possible = red_area + heights[index] <= a\n        green_possible = green_area + heights[index] <= b\n        \n        result = float('inf')\n        \n        if red_possible:\n            result = dp(index + 1, 0, red_area + heights[index], green_area) + (prev_color == 1)\n        \n        if green_possible:\n            result = min(result, dp(index + 1, 1, red_area, green_area + heights[index]) + (prev_color == 0))\n        \n        return result\n    \n    return dp(0, -1, 0, 0)\n\n# Reading input\nn = int(input())\nlimits = list(map(int, input().split()))\nheights = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(min_unattractiveness(n, limits, heights))"}
{"solution": "def find_triangle_points(n, m, k):\n    area = n * m // k\n    if area == 0 or n * m % k != 0:\n        return \"NO\"\n    \n    # Base case for simple validation\n    if area <= m:\n        return [\"YES\", f\"0 0\", f\"{area} 0\", f\"0 {m}\"]\n    \n    # General case\n    height = m\n    base = 2 * area // height\n    \n    # Check if base is valid\n    if 2 * area % height != 0 or base > n:\n        return \"NO\"\n    \n    # Points for general case\n    x1, y1 = 0, 0\n    x2, y2 = base, 0\n    x3, y3 = 0, height\n    \n    return [\"YES\", f\"{x1} {y1}\", f\"{x2} {y2}\", f\"{x3} {y3}\"]\n\n# Reading input\nn, m, k = map(int, input().split())\n\n# Calculating and printing the result\nresult = find_triangle_points(n, m, k)\nfor line in result:\n    print(line)"}
{"solution": "def game_winner(n, k):\n    \"\"\"\n    Determines the winner of the game based on the initial number of sticks and the number of sticks crossed out each turn.\n    \n    Parameters:\n    n (int): The initial number of sticks.\n    k (int): The number of sticks crossed out each turn.\n    \n    Returns:\n    str: \"YES\" if Sasha wins, \"NO\" otherwise.\n    \"\"\"\n    # Calculate the number of moves Sasha can make\n    sasha_moves = n // (2 * k)\n    # Calculate the remaining sticks after Sasha's moves\n    remaining_sticks = n - (sasha_moves * k)\n    # Determine if Sasha can make an additional move\n    sasha_additional_move = remaining_sticks > k\n    \n    # Sasha wins if he can make at least one more move than Lena\n    return \"YES\" if sasha_additional_move else \"NO\"\n\n# Read input\nn, k = map(int, input().split())\n\n# Output the result\nprint(game_winner(n, k))"}
{"solution": "# Reading the input\nn = int(input())\nexercises = list(map(int, input().split()))\n\n# Calculating the total repetitions for each muscle group\nchest_reps = sum(exercises[i] for i in range(0, n, 3))\nbiceps_reps = sum(exercises[i] for i in range(1, n, 3))\nback_reps = sum(exercises[i] for i in range(2, n, 3))\n\n# Determining which muscle gets the most exercise\nif chest_reps > biceps_reps and chest_reps > back_reps:\n    print(\"chest\")\nelif biceps_reps > chest_reps and biceps_reps > back_reps:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "from typing import List\n\ndef min_redo_for_grade_five(grades: List[int]) -> int:\n    \"\"\"\n    Calculates the minimum number of lab works Vasya needs to redo to ensure he gets a grade of 5.\n    \n    :param grades: List of integers representing Vasya's grades for his lab works.\n    :return: Minimum number of lab works Vasya has to redo.\n    \"\"\"\n    total_grades = len(grades)\n    current_sum = sum(grades)\n    \n    # Calculate the target sum needed for an average of 4.5 or more\n    target_sum = (total_grades * 4 + 1) // 2\n    \n    # If the current sum is already enough, no need to redo any work\n    if current_sum >= target_sum:\n        return 0\n    \n    # Calculate the minimum number of redos needed\n    redos_needed = 0\n    for grade in sorted(grades):\n        if current_sum < target_sum:\n            current_sum += 5 - grade\n            redos_needed += 1\n        else:\n            break\n    \n    return redos_needed\n\n# Reading input\nn = int(input())\ngrades = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(min_redo_for_grade_five(grades))"}
{"solution": "def find_shortest_array(u, v):\n    if v < u:\n        return -1\n    \n    if u == 0:\n        if v == 0:\n            return 0, []\n        else:\n            return 1, [v]\n    \n    n = 1\n    arr = [u]\n    remaining_sum = v - u\n    \n    while remaining_sum > 0:\n        n += 1\n        value = min(remaining_sum, 1 << (len(bin(u)) - 3))\n        arr.append(value)\n        remaining_sum -= value\n    \n    return n, arr\n\ndef main():\n    u, v = map(int, input().split())\n    result = find_shortest_array(u, v)\n    \n    if result == -1:\n        print(-1)\n    else:\n        n, arr = result\n        print(n)\n        print(\" \".join(map(str, arr)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_ones(n):\n    if n == 1:\n        return 1\n    ones = 0\n    current = 1\n    while n > 0:\n        remainder = n % (current * 10)\n        n -= max(remainder - current, 0)\n        ones += (n // current) + (remainder >= current)\n        current *= 10\n    return ones\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the result\nprint(min_ones(n))"}
{"solution": "def can_reach_treasure(start, target, potion):\n    x1, y1 = start\n    x2, y2 = target\n    x, y = potion\n    \n    # Calculate differences in x and y coordinates\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    \n    # Check if the differences are divisible by the potion's values\n    return dx % x == 0 and dy % y == 0\n\n# Read input\nstart = list(map(int, input().split()))\ntarget = list(map(int, input().split()))\n\n# Determine if the treasure can be reached\nif can_reach_treasure(start, target, target):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "from collections import Counter\n\ndef calculate_variants(n):\n    digit_count = Counter(str(n))\n    total_variants = 1\n    for count in digit_count.values():\n        total_variants *= (count + 1)\n    # Adjust for leading zero cases\n    if '0' in digit_count:\n        total_variants -= digit_count['0']\n    return total_variants\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the result\nprint(calculate_variants(n))"}
{"solution": "def max_suit_cost(a, b, c, d, e, f):\n    # Calculate the maximum number of suits of the first type (tie and jacket)\n    max_first_type = min(a, d) * e\n    \n    # Calculate the maximum number of suits of the second type (scarf, vest, jacket)\n    max_second_type = min(b, c, d) * f\n    \n    # Return the sum of the maximum costs of both types of suits\n    return max_first_type + max_second_type\n\n# Reading input\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\n# Calculating and printing the output\nprint(max_suit_cost(a, b, c, d, e, f))"}
{"solution": "from math import gcd\nfrom itertools import accumulate\n\ndef mod_inverse(a, m):\n    m0, y = m, 0\n    x = 1\n    if (m == 1): return 0\n    while (a > 1):\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if (x < 0): x += m0\n    return x\n\ndef discrete_logarithm(a, b, m, n):\n    if a == 1:\n        return 0 if b == 1 else -1\n    if b == 1:\n        return 0\n    if gcd(a, m) != 1:\n        return -1\n    a = a % m\n    b = b % m\n    order = []\n    current = 1\n    for i in range(m):\n        if current == b:\n            order.append(i)\n        current = (current * a) % m\n    if len(order) == 0:\n        return 0\n    max_val = min(n, (order[-1] + m - 1) // m * m)\n    count = [0] * (max_val + 1)\n    for i in order:\n        count[i] += 1\n    for i in range(1, len(count)):\n        count[i] += count[i - 1]\n    return count[n]\n\ndef solve(a, b, p, x):\n    result = discrete_logarithm(a, b, p, x)\n    return result\n\n# Reading input\na, b, p, x = map(int, input().split())\n\n# Solving and printing output\nprint(solve(a, b, p, x))"}
{"solution": "def max_sum(k2, k3, k5, k6):\n    # The goal is to maximize the sum of numbers 256 and 32\n    # First, calculate how many 256 can be formed\n    num_256 = min(k5, k6, k2 // 2)\n    \n    # Calculate remaining digits after forming 256s\n    k2 -= num_256 * 2\n    k5 -= num_256\n    k6 -= num_256\n    \n    # Then, calculate how many 32 can be formed with the remaining digits\n    num_32 = min(k2, k3)\n    \n    # Calculate the total sum\n    total_sum = num_256 * 256 + num_32 * 32\n    return total_sum\n\n# Reading input\nk2, k3, k5, k6 = map(int, input().split())\n\n# Calculating and printing the result\nprint(max_sum(k2, k3, k5, k6))"}
{"solution": "import math\n\ndef time_to_happiness(n, x, y, c):\n    total_on = 1\n    seconds = 0\n    max_on = n * n\n    \n    if c == max_on or c == 1:\n        return seconds\n    \n    # Calculate the maximum possible increase per second\n    max_increase_per_second = 4 * (min(n, max(x, y)) - 1) + 4 * (min(n, n - max(x, y) + 1) - 1)\n    \n    while total_on < c:\n        seconds += 1\n        # The increase in on cells after the current second\n        increase = 4 - (x == 1) - (y == 1) - (x == n) - (y == n)\n        total_on += increase\n        \n        if total_on >= c:\n            break\n        \n        # After the first second, the increase will be at most 4\n        if seconds > 1:\n            increase = 4\n        \n        # If the increase is not enough, fast forward\n        if increase < max_increase_per_second and (c - total_on) % increase == 0:\n            seconds += (c - total_on) // increase - 1\n            break\n    \n    return seconds\n\n# Reading input\nn, x, y, c = map(int, input().split())\n\n# Calculating and printing the result\nprint(time_to_happiness(n, x, y, c))"}
{"solution": "import sys\n\ndef solve(l, r):\n    if l == r:\n        return 0\n    shift = 0\n    while l < r:\n        l >>= 1\n        r >>= 1\n        shift += 1\n    return (1 << shift) - 1 + (r - (1 << shift)) * 2\n\nl, r = map(int, sys.stdin.readline().split())\nprint(solve(l, r))"}
{"solution": "import math\n\ndef find_min_height(n, k):\n    left, right = 0, int(1e18)\n    \n    while left < right:\n        mid = (left + right) // 2\n        # Calculate the area if the height is mid\n        area = (mid * (2*n + 1) - (mid * (mid + 1)) // 2)\n        if area >= k:\n            right = mid\n        else:\n            left = mid + 1\n            \n    return left\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(find_min_height(n, k))"}
{"solution": "def choose_transport(x, y, z, t1, t2, t3):\n    # Calculate time using stairs\n    stairs_time = abs(y - x) * t1\n    \n    # Calculate time using elevator\n    to_elevator = abs(z - x) * t2 + 2 * t3\n    to_destination = abs(y - z) * t2 + 2 * t3\n    elevator_time = to_elevator + to_destination if x != z else to_destination\n    \n    # Determine the best choice\n    return \"YES\" if elevator_time <= stairs_time else \"NO\"\n\n# Read input\nx, y, z, t1, t2, t3 = map(int, input().split())\n\n# Output result\nprint(choose_transport(x, y, z, t1, t2, t3))"}
{"solution": "def optimal_strategy(n, m):\n    # Calculate the optimal value of a for Andrew to choose\n    if m == 1:\n        return 2\n    elif m == n:\n        return n - 1\n    else:\n        return m - 1\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the optimal value of a\nprint(optimal_strategy(n, m))"}
{"solution": "def university_schedule(n, schedule):\n    stay_count = 0\n    consecutive_zeros = 0\n    \n    for i in range(n):\n        if schedule[i] == 1:\n            if consecutive_zeros >= 2:\n                consecutive_zeros = 0\n            stay_count += 1\n        else:\n            consecutive_zeros += 1\n    \n    # Check if the last two or more were zeros, subtract from stay_count\n    if consecutive_zeros >= 2 and schedule[n - 2] == 0:\n        stay_count -= 1\n    \n    return stay_count\n\n# Reading input\nn = int(input())\nschedule = list(map(int, input().split()))\n\n# Calculating result\nresult = university_schedule(n, schedule)\n\n# Printing output\nprint(result)"}
{"solution": "def min_days_to_give_candies(n, k, candies_per_day):\n    total_candies = 0\n    for day in range(n):\n        total_candies += candies_per_day[day]\n        if total_candies >= k:\n            return day + 1\n    return -1\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    candies_per_day = list(map(int, input().split()))\n    result = min_days_to_give_candies(n, k, candies_per_day)\n    print(result)"}
{"solution": "def min_additional_walks(n, k, walks):\n    additional_walks = 0\n    schedule = [0] * n\n    prev_walks = k\n    \n    for i in range(n):\n        needed = max(prev_walks - walks[i], 0)\n        schedule[i] = walks[i] + needed\n        additional_walks += needed\n        prev_walks = schedule[i]\n    \n    # Ensuring the last day meets the requirement for the next day (which is assumed to have k walks)\n    if schedule[-1] < k:\n        additional_walks += k - schedule[-1]\n        schedule[-1] = k\n    \n    return additional_walks, schedule\n\n# Reading input\nn, k = map(int, input().split())\nwalks = list(map(int, input().split()))\n\n# Calculating the result\nadditional_walks, schedule = min_additional_walks(n, k, walks)\n\n# Printing the output\nprint(additional_walks)\nprint(' '.join(map(str, schedule)))"}
{"solution": "def calculate_rhombus_cells(n):\n    if n == 1:\n        return 1\n    else:\n        return 4 * n - 3 + calculate_rhombus_cells(n - 1)\n\n# Reading input\nn = int(input())\n\n# Calculating and printing output\nprint(calculate_rhombus_cells(n))"}
{"solution": "n = int(input())\ns = input()\n\n# Convert the string to lowercase to handle both upper and lower case letters\ns = s.lower()\n\n# Create a set of unique characters in the string\nunique_chars = set(s)\n\n# Define the set of all lowercase English letters\nalphabet = set(\"abcdefghijklmnopqrstuvwxyz\")\n\n# Check if all English letters are present in the string\nis_pangram = alphabet.issubset(unique_chars)\n\n# Output \"YES\" if it's a pangram, \"NO\" otherwise\nprint(\"YES\" if is_pangram else \"NO\")"}
{"solution": "from datetime import datetime, timedelta\n\ndef time_after_minutes(current_time, minutes):\n    # Convert the current time to a datetime object\n    time_obj = datetime.strptime(current_time, \"%H:%M\")\n    # Add the specified number of minutes\n    new_time = time_obj + timedelta(minutes=minutes)\n    # Format the new time back to HH:MM with leading zeros\n    return new_time.strftime(\"%H:%M\")\n\n# Read input\ncurrent_time = input()\nminutes = int(input())\n\n# Calculate and print the new time\nprint(time_after_minutes(current_time, minutes))"}
{"solution": "from collections import defaultdict\n\ndef check_lamps(n, m, switches):\n    # Track which lamps are turned on by all switches except one\n    lamp_count = [0] * m\n    switch_lamps = defaultdict(set)\n    \n    for i in range(n):\n        for j in range(m):\n            if switches[i][j] == '1':\n                lamp_count[j] += 1\n                switch_lamps[i].add(j)\n                \n    # Check if ignoring any switch still turns on all lamps\n    for i in range(n):\n        if all(lamp_count[j] > (1 if j in switch_lamps[i] else 0) for j in range(m)):\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nswitches = [input() for _ in range(n)]\n\n# Output result\nprint(check_lamps(n, m, switches))"}
{"solution": "def min_rotation_time(n, dominoes):\n    top_sum_odd, bottom_sum_odd, both_even = 0, 0, 0\n    \n    for x, y in dominoes:\n        if (x + y) % 2 == 0:\n            both_even += 1\n        else:\n            if x % 2 == 1 and y % 2 == 0:\n                top_sum_odd += 1\n            elif x % 2 == 0 and y % 2 == 1:\n                bottom_sum_odd += 1\n            else:\n                top_sum_odd += 1\n                bottom_sum_odd += 1\n\n    if (top_sum_odd + bottom_sum_odd) % 2 != 0:\n        return -1\n    else:\n        total_odd = top_sum_odd + bottom_sum_odd\n        half_odd = total_odd // 2\n        if top_sum_odd < half_odd:\n            return -1\n        return max(0, half_odd - both_even)\n\nn = int(input())\ndominoes = [list(map(int, input().split())) for _ in range(n)]\nprint(min_rotation_time(n, dominoes))"}
{"solution": "from math import sqrt\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef remaining_area(a, b):\n    return a**2 - b**2\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        a, b = map(int, input().split())\n        area = remaining_area(a, b)\n        if is_prime(area):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nsolve()"}
{"solution": "from typing import List, Tuple\n\ndef check_points(points: List[Tuple[int, int]]) -> bool:\n    points.sort(key=lambda p: (p[1], p[0]))\n    above = below = 0\n    for x, y in points:\n        if x > 0:\n            above += 1\n        else:\n            below += 1\n        if above and below:\n            return False\n    return True\n\ndef main():\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Check removing each point\n    for i in range(n):\n        other_points = points[:i] + points[i+1:]\n        if check_points(other_points):\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef gcd_factorial(a, b):\n    min_val = min(a, b)\n    result = 1\n    for i in range(2, min_val + 1):\n        result *= i\n    return result\n\n# Reading input\na, b = map(int, input().split())\n\n# Calculating and printing output\nprint(gcd_factorial(a, b))"}
{"solution": "def find_composite_pair(n):\n    # Define a function to check if a number is composite\n    def is_composite(x):\n        if x < 4:\n            return False\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                return True\n        return False\n    \n    # Start with the simplest composite number and the target difference\n    a = 4\n    b = a - n\n    \n    # Ensure both a and b are composite\n    while not (is_composite(a) and is_composite(b)):\n        a += 1\n        b = a - n\n    \n    return a, b\n\n# Read input\nn = int(input())\n\n# Find and print the solution\na, b = find_composite_pair(n)\nprint(a, b)"}
{"solution": "from collections import defaultdict, deque\n\ndef bellman_ford(n, edges, start):\n    dist = [float('inf')] * n\n    dist[start] = 0\n    for _ in range(n):\n        for u, v, w in edges:\n            if dist[u] != float('inf') and dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                if _ == n - 1 and v == n - 1:\n                    return \"cycle\"\n    return dist\n\ndef solve(n, m, p, edges):\n    adj_list = defaultdict(list)\n    for a, b, c in edges:\n        adj_list[a-1].append((b-1, c))\n\n    # Bellman-Ford to detect negative cycles\n    result = bellman_ford(n, edges, 0)\n    if result == \"cycle\":\n        return -1\n\n    # Shortest path to N\n    shortest_path = result[n-1]\n\n    # Max coins on each path to N\n    max_coins = [0] * n\n    queue = deque([(0, 0)])\n    while queue:\n        current_time, current_vertex = queue.popleft()\n        if current_vertex == n - 1:\n            max_coins[current_vertex] = max(max_coins[current_vertex], current_time)\n            continue\n        for next_vertex, coin in adj_list[current_vertex]:\n            new_time = current_time + 1\n            max_coins[next_vertex] = max(max_coins[next_vertex], current_time + coin)\n            queue.append((new_time, next_vertex))\n\n    # Calculate score\n    max_score = -1\n    for time, coins in enumerate(max_coins):\n        if time > shortest_path:\n            fee = time * p\n            score = coins - fee\n            max_score = max(max_score, score)\n\n    return max_score\n\n# Reading input\nn, m, p = map(int, input().split())\nedges = []\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    edges.append((a-1, b-1, c))\n\n# Solving and printing output\nprint(solve(n, m, p, edges))"}
{"solution": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    N = int(input())\n    strings = []\n    costs = defaultdict(int)\n    for _ in range(N):\n        S, C = input().split()\n        C = int(C)\n        S = S[::-1]  # Normalize strings to avoid duplicates\n        strings.append((S, C))\n        costs[S] += C\n\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    # Preprocess strings for palindrome check\n    palindrome_costs = defaultdict(int)\n    for S, C in strings:\n        half_cost = 0\n        for i in range(len(S) // 2):\n            if S[i] != S[-(i + 1)]:\n                half_cost = C\n                break\n        if is_palindrome(S):\n            palindrome_costs[S] += C\n        else:\n            palindrome_costs[S[:len(S) // 2]] += half_cost\n\n    # Find the minimum cost to form a palindrome\n    min_cost = float('inf')\n    for S, C in strings:\n        if len(S) % 2 == 1:\n            center_cost = costs[S[len(S) // 2]]\n            for prefix, prefix_cost in palindrome_costs.items():\n                if S.startswith(prefix):\n                    min_cost = min(min_cost, prefix_cost + center_cost + costs[S[len(prefix):]])\n        else:\n            for prefix, prefix_cost in palindrome_costs.items():\n                if S.startswith(prefix):\n                    min_cost = min(min_cost, prefix_cost + costs[S[len(prefix):]])\n\n    if min_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_cost)\n\nsolve()"}
{"solution": "def max_xor_sum(n, k):\n    # Base case: if k is 1, the maximum XOR sum is simply n itself if n <= 2, otherwise it's 3.\n    if k == 1:\n        return min(n, 3)\n    \n    # If n is less than 4, the result is n itself since the maximum XOR can be achieved by taking all.\n    if n < 4:\n        return n\n    \n    # For larger values of n and k, the pattern repeats every 4 numbers.\n    # The maximum XOR sum is 3 for any k >= 2 and n >= 4.\n    return 3\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(max_xor_sum(n, k))"}
{"solution": "import heapq\n\ndef min_triangle_side(n, points):\n    max_x = 0\n    max_y = 0\n    \n    for x, y in points:\n        max_x = max(max_x, x)\n        max_y = max(max_y, y)\n    \n    # Calculate the hypotenuse for the case where the short side is vertical/horizontal\n    hypotenuse_x = max_x + max_y\n    hypotenuse_y = max_x + max_y\n    \n    # Calculate the short side based on the hypotenuse and the other side (max_x or max_y)\n    short_side_x = (hypotenuse_x * max_x) // (max_x + max_y)\n    short_side_y = (hypotenuse_y * max_y) // (max_x + max_y)\n    \n    return min(max_x, max_y, short_side_x, short_side_y)\n\n# Reading input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculating and printing the result\nprint(min_triangle_side(n, points))"}
{"solution": "from collections import Counter\n\ndef max_nineteens(s):\n    \"\"\"\n    Calculates the maximum number of \"nineteen\" occurrences that can be formed by rearranging the letters of the given string.\n    \"\"\"\n    char_count = Counter(s)\n    \n    # Counting the minimum occurrences of each character in \"nineteen\"\n    n_count = char_count['n'] // 4\n    i_count = char_count['i'] // 2\n    e_count = char_count['e'] // 4\n    t_count = char_count['t'] // 1\n    other_count = min(char_count[c] for c in \"nein\") // 1  # Considering 'n', 'e', 'i', 'n' as they are common\n    \n    # The limiting factor is the minimum of all these counts\n    return min(n_count, i_count, e_count, t_count, other_count)\n\n# Reading input\ns = input().strip()\n\n# Printing output\nprint(max_nineteens(s))"}
{"solution": "import math\n\ndef find_highest_safe_branch(p, y):\n    max_possible = y // 2\n    if p > max_possible:\n        return -1\n\n    # Find the highest branch not reachable by any grasshopper\n    for i in range(max_possible, 1, -1):\n        # Check if any grasshopper can reach this branch\n        if any(i % j == 0 for j in range(2, min(y // i + 1, p + 1))):\n            continue\n        return i\n    return -1\n\n# Reading input\np, y = map(int, input().split())\n\n# Calculating and printing output\nprint(find_highest_safe_branch(p, y))"}
{"solution": "def find_closest_house(n, m, k, prices):\n    # Filter out the houses that Zane can afford and their distances from the girl's house\n    affordable_houses = [(i, price) for i, price in enumerate(prices) if price > 0 and price <= k]\n\n    # Calculate distances to the closest affordable houses on both sides\n    min_distance = float('inf')\n    for i, price in affordable_houses:\n        distance_left = abs(i - m) * 10\n        distance_right = abs((i + 1) - m) * 10 if i + 1 < n else float('inf')\n        min_distance = min(min_distance, distance_left, distance_right)\n\n    return min_distance\n\n# Reading input\nn, m, k = map(int, input().split())\nprices = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(find_closest_house(n, m, k, prices))"}
{"solution": "def can_transform(A, B):\n    def sort_rows_and_columns(matrix):\n        rows = sorted([tuple(row) for row in matrix])\n        cols = sorted([tuple(column) for column in zip(*matrix)])\n        return rows, cols\n\n    A_rows, A_cols = sort_rows_and_columns(A)\n    B_rows, B_cols = sort_rows_and_columns(B)\n\n    return A_rows == B_rows and A_cols == B_cols\n\ndef read_matrix():\n    n, m = map(int, input().split())\n    matrix = [list(map(int, input().split())) for _ in range(n)]\n    return matrix\n\n# Reading matrices A and B\nA = read_matrix()\nB = read_matrix()\n\n# Checking if transformation is possible\nif can_transform(A, B):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "s1 = input()\ns2 = input()\n\nif s1 == s2:\n    print(-1)\nelse:\n    print(max(len(s1), len(s2)))"}
{"solution": "from math import gcd\n\ndef find_common_scream_time(a, b, c, d):\n    \"\"\"\n    Finds the first time Rick and Morty scream at the same time.\n    \n    Parameters:\n    a (int): The interval at which Rick screams.\n    b (int): The starting time of Rick's screams.\n    c (int): The interval at which Morty screams.\n    d (int): The starting time of Morty's screams.\n    \n    Returns:\n    int: The first common scream time, or -1 if they never scream at the same time.\n    \"\"\"\n    # Calculate the difference in starting times\n    diff = abs(b - d)\n    \n    # Calculate the least common multiple of the intervals\n    lcm = a * c // gcd(a, c)\n    \n    # Check if there's a common scream time\n    if diff % lcm == 0:\n        return diff\n    else:\n        # Find the next common time\n        for i in range(0, lcm, a):\n            if (d + i - b) % c == 0:\n                return b + i\n        for i in range(0, lcm, c):\n            if (b + i - d) % a == 0:\n                return d + i\n        return -1\n\n# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate and print the result\nprint(find_common_scream_time(a, b, c, d))"}
{"solution": "n = int(input())\nif n % 3 == 0:\n    a = n // 3 - 1\n    b = n // 3 + 1\n    c = n // 3\nelif n % 3 == 1:\n    a = n // 3 + 1\n    b = n // 3 - 1\n    c = n // 3 + 1\nelse:\n    a = n // 3\n    b = n // 3\n    c = n // 3 + 2\nprint(a, b, c)"}
{"solution": "def count_possible_paintings(n, a, b, c, d):\n    total_count = 0\n    for x11 in range(1, n + 1):\n        for x12 in range(1, n + 1):\n            for x21 in range(1, n + 1):\n                x22 = a + b - x11 + c - x12\n                if x22 <= 0 or x22 > n:\n                    continue\n                x31 = a + b - x12 + d - x21\n                if x31 <= 0 or x31 > n:\n                    continue\n                x32 = a + c - x12 - x22\n                if x32 <= 0 or x32 > n:\n                    continue\n                x33 = a + b + c + d - x11 - x12 - x21 - x22\n                if x33 <= 0 or x33 > n:\n                    continue\n                x23 = a + x33 - x12 - x32\n                x13 = a + x33 - x22 - x32\n                x13_check = b + x33 - x21 - x31\n                if x13 != x13_check or x23 < 1 or x23 > n or x13 < 1 or x13 > n:\n                    continue\n                total_count += 1\n    return total_count\n\n# Reading input\nn, a, b, c, d = map(int, input().split())\n\n# Calculating and printing the result\nprint(count_possible_paintings(n, a, b, c, d))"}
{"solution": "3\nimport sys\n\nclass SnowballAdventure:\n    def calculateFinalWeight(self, w, h, u1, d1, u2, d2):\n        stones = [(u1, d1), (u2, d2)]\n        stones.sort(key=lambda x: x[1], reverse=True)\n\n        current_weight = w\n        for height in range(h, 0, -1):\n            current_weight += height\n            for u, d in stones:\n                if d == height:\n                    current_weight = max(0, current_weight - u)\n                    break\n\n        return current_weight\n\ndef main():\n    input_data = iter(sys.stdin.read().split())\n    w, h = map(int, next(input_data).split())\n    u1, d1 = map(int, next(input_data).split())\n    u2, d2 = map(int, next(input_data).split())\n\n    solver = SnowballAdventure()\n    result = solver.calculateFinalWeight(w, h, u1, d1, u2, d2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_passing_rate(m, scores, min_max):\n    x, y = min_max\n    prefix_sum = [0]\n    for score in scores:\n        prefix_sum.append(prefix_sum[-1] + score)\n\n    for k in range(1, m + 1):\n        beginners = prefix_sum[k]\n        intermediates = prefix_sum[m] - beginners\n        if x <= beginners <= y and x <= intermediates <= y:\n            return k\n    return 0\n\n# Reading input\nm = int(input())\nscores = list(map(int, input().split()))\nmin_max = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(find_passing_rate(m, scores, min_max))"}
{"solution": "def min_cost(n, k, A, B):\n    costs = [0] * (n + 1)\n    \n    def calculate_cost(x):\n        if x == 1:\n            return 0\n        if costs[x] != 0:\n            return costs[x]\n        \n        cost = float('inf')\n        if x % k == 0:\n            cost = calculate_cost(x // k) + B\n        else:\n            cost = calculate_cost(x - 1) + A\n        \n        costs[x] = cost\n        return cost\n    \n    return calculate_cost(n)\n\n# Reading inputs\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\n# Calculating and printing the result\nprint(min_cost(n, k, A, B))"}
{"solution": "import math\n\ndef min_value_operations(n):\n    steps = 0\n    while n % (int(math.sqrt(n))) != 0 and n != 1:\n        n = n // (n % (int(math.sqrt(n))) + 1)\n        steps += 1\n    if n != 1:\n        steps += 2\n        n = int(math.sqrt(n))\n    return n, steps\n\nn = int(input())\nmin_n, min_steps = min_value_operations(n)\nprint(min_n, min_steps)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.readline\n\ndef solve():\n    N, K = map(int, input().split())\n    R, S, P = map(int, input().split())\n    T = input().strip()\n\n    # Dynamic Programming\n    dp = [[0] * 3 for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        dp[i][0] = max(dp[i-1])  # Skip current move\n        if i > K:\n            dp[i][1] = max(dp[i][1], dp[i-K][2] + R) if T[i-1] != 'p' else dp[i][1]\n            dp[i][2] = max(dp[i][2], dp[i-K][0] + S) if T[i-1] != 's' else dp[i][2]\n            dp[i][0] = max(dp[i][0], dp[i-K][1] + P) if T[i-1] != 'r' else dp[i][0]\n        else:\n            dp[i][1] = dp[i][1] + R if T[i-1] != 'p' else dp[i][1]\n            dp[i][2] = dp[i][2] + S if T[i-1] != 's' else dp[i][2]\n            dp[i][0] = dp[i][0] + P if T[i-1] != 'r' else dp[i][0]\n\n    print(max(dp[N]))\n\nsolve()"}
{"solution": "def max_good_string_length(a, b, c):\n    # Calculate the maximum length of a good string\n    # Using the formula derived from the problem statement\n    return 2 * c + 2 * min(a, b) + abs(a - b)\n\n# Reading input\na, b, c = map(int, input().split())\n\n# Calculating and printing the output\nprint(max_good_string_length(a, b, c))"}
{"solution": "def find_marks(n, k, p, x, y, marks):\n    total_marks_so_far = sum(marks)\n    marks.sort()\n\n    # Calculate the remaining marks needed to keep the sum below x\n    max_possible_marks = x - total_marks_so_far\n    remaining_marks = []\n\n    # Calculate the median requirement\n    median_index = (n + 1) // 2\n    current_median = marks[median_index - 1] if k >= median_index else 0\n\n    # Adjust marks to meet the requirements\n    for i in range(n - k):\n        if median_index - k - 1 >= 0 and median_index - k - 1 + len(remaining_marks) == median_index - 1:\n            # Ensure the median is at least y\n            needed_mark = max(y - marks[median_index - k - 1 + len(remaining_marks) - 1], 1)\n            remaining_marks.append(needed_mark)\n        else:\n            # Fill with the maximum possible mark without exceeding x\n            needed_mark = min(max_possible_marks, p)\n            max_possible_marks -= needed_mark\n            remaining_marks.append(needed_mark)\n\n        if max_possible_marks <= 0:\n            break\n\n    # Check if the requirements are met\n    if sum(marks + remaining_marks) > x or (len(marks + remaining_marks) >= median_index and marks[median_index - 1] < y):\n        return [-1]\n\n    return remaining_marks\n\n# Read input\nn, k, p, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Solve and print the result\nresult = find_marks(n, k, p, x, y, marks)\nprint(' '.join(map(str, result)))"}
{"solution": "def is_berlanese(word):\n    vowels = \"aouie\"\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    \n    prev_char = None\n    for char in word:\n        if char in consonants and prev_char != \"n\":\n            if prev_char not in vowels:\n                return \"NO\"\n        prev_char = char\n    \n    if prev_char == \"n\":\n        return \"YES\"\n    elif prev_char in vowels or prev_char is None:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nword = input()\n\n# Print output\nprint(is_berlanese(word))"}
{"solution": "from collections import defaultdict\n\ndef max_dominoes_on_graph(n, edges):\n    \"\"\"\n    Calculate the maximum number of dominoes that can be placed on the graph edges\n    following the specified rules.\n    \"\"\"\n    # Initialize adjacency list\n    adj_list = defaultdict(set)\n    for u, v in edges:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n\n    # Initialize degree list\n    degree = [0] * (n + 1)\n    for u in adj_list:\n        degree[u] = len(adj_list[u])\n\n    # Function to calculate the maximum number of dominoes\n    def dfs(node, visited):\n        visited.add(node)\n        degrees = [degree[node]]\n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                sub_degrees, _ = dfs(neighbor, visited)\n                degrees.extend(sub_degrees)\n        degrees.sort()\n        total = len(degrees)\n        min_dominoes = total - max(degrees[0], degrees[-1])\n        visited.remove(node)\n        return degrees, min_dominoes\n\n    # Find the minimum number of dominoes needed\n    visited = set()\n    min_needed = float('inf')\n    for node in range(1, n + 1):\n        if node not in visited:\n            _, min_needed_for_component = dfs(node, visited)\n            min_needed = min(min_needed, min_needed_for_component)\n\n    # Calculate the maximum number of dominoes\n    max_dominoes = len(edges) - min_needed // 2\n    return max_dominoes\n\n# Example check function (not part of the solution)\ndef check_solution():\n    assert max_dominoes_on_graph(4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == 4\n    assert max_dominoes_on_graph(7, []) == 0\n    assert max_dominoes_on_graph(3, [(1, 3)]) == 1\n    assert max_dominoes_on_graph(7, [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (3, 4), (3, 5), (3, 6), (3, 7), (4, 5), (4, 6), (4, 7), (5, 6), (5, 7), (6, 7)]) == 16\n\ncheck_solution()"}
{"solution": "from typing import List\n\ndef max_points(n: int, m: int, prices: List[int], auctions: List[int]) -> int:\n    from itertools import combinations\n    from functools import lru_cache\n    \n    auctions_set = set(auctions)\n    \n    @lru_cache(maxsize=None)\n    def dp(index, taken, budget):\n        if index == n or taken == m:\n            return 0\n        \n        # Skip current question\n        skip = dp(index + 1, taken, budget)\n        \n        # Take current question\n        take = 0\n        if index in auctions_set:\n            if budget > prices[index]:\n                # Change price\n                new_price = prices[index]\n                for p in range(prices[index], budget + 1):\n                    new_price = p\n                    temp_budget = budget - p\n                    temp_taken = taken + 1\n                    temp_ans = dp(index + 1, temp_taken, temp_budget) + p\n                    take = max(take, temp_ans)\n            else:\n                # Cannot change price, take as is\n                take = dp(index + 1, taken + 1, budget - prices[index]) + prices[index]\n        else:\n            # Regular question\n            take = dp(index + 1, taken, budget - prices[index]) + prices[index]\n        \n        return max(skip, take)\n    \n    # Start with the highest possible budget (sum of all prices)\n    return dp(0, 0, sum(prices))\n\n# Reading input\nn, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauctions = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(max_points(n, m, prices, auctions))"}
{"solution": "# Import necessary package for reading input\nfrom sys import stdin\n\n# Read the input\nm = list(map(int, stdin.readline().split()))\nw = list(map(int, stdin.readline().split()))\nh = list(map(int, stdin.readline().split()))\n\n# Define the maximum point values for each problem\npoints = [500, 1000, 1500, 2000, 2500]\n\n# Calculate the score for each problem\nscores = []\nfor i in range(5):\n    score = max(0.3 * points[i], (1 - m[i] / 250) * points[i] - 50 * w[i])\n    scores.append(score)\n\n# Calculate the total score including hacks\ntotal_score = sum(scores) + 100 * h[0] - 50 * h[1]\n\n# Print the total score\nprint(int(total_score))"}
{"solution": "from math import gcd\n\nMOD = 998244353\n\ndef mod_pow(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef solve(n, m, L, R):\n    if (n*m) % 2 == 1:\n        return 0\n    common_divisor = gcd(n, m)\n    total_cells = n * m\n    half_cells = total_cells // 2\n    valid_grids = mod_pow(R - L + 1, half_cells)\n    if common_divisor > 1:\n        invalid_grids = mod_pow(R - L + 1, half_cells // common_divisor)\n        valid_grids = (valid_grids - invalid_grids) % MOD\n    return valid_grids\n\nif __name__ == \"__main__\":\n    n, m, L, R = map(int, input().split())\n    print(solve(n, m, L, R))"}
{"solution": "def is_increasing(matrix):\n    n, m = len(matrix), len(matrix[0])\n    for i in range(n):\n        for j in range(m - 1):\n            if matrix[i][j] >= matrix[i][j + 1]:\n                return False\n    for j in range(m):\n        for i in range(n - 1):\n            if matrix[i][j] >= matrix[i + 1][j]:\n                return False\n    return True\n\ndef can_make_increasing(a, b):\n    n, m = len(a), len(a[0])\n    # Check if already increasing\n    if is_increasing(a) and is_increasing(b):\n        return True\n    \n    # Store the min and max elements for each column and row\n    min_a_row, max_b_col = [float('inf')] * n, [float('-inf')] * m\n    max_a_row, min_b_col = [-float('inf')] * n, [float('inf')] * m\n    \n    for i in range(n):\n        for j in range(m):\n            min_a_row[i] = min(min_a_row[i], a[i][j])\n            max_a_row[i] = max(max_a_row[i], a[i][j])\n            max_b_col[j] = max(max_b_col[j], b[i][j])\n            min_b_col[j] = min(min_b_col[j], b[i][j])\n    \n    # Check if there's a conflict between min and max values\n    for i in range(n):\n        for j in range(m):\n            if not (min_b_col[j] <= max_a_row[i] and min_a_row[i] <= max_b_col[j]):\n                return False\n    return True\n\n# Reading input\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nb = [list(map(int, input().split())) for _ in range(n)]\n\n# Checking if it's possible to make both matrices increasing\nif can_make_increasing(a, b):\n    print(\"Possible\")\nelse:\n    print(\"Impossible\")"}
{"solution": "from heapq import heappush, heappop\n\ndef max_string_length(n, limits):\n    \"\"\"\n    Calculate the maximum length of a string that can be formed with the given constraints.\n    \n    :param n: Number of letters in the alphabet\n    :param limits: List of integers representing the maximum occurrences of each letter\n    :return: Maximum possible length of the string\n    \"\"\"\n    # Initialize a min heap for the limits\n    limit_heap = []\n    for i, limit in enumerate(limits):\n        heappush(limit_heap, (limit, i))\n    \n    used_numbers = set()\n    total_length = 0\n    \n    while limit_heap:\n        limit, letter_index = heappop(limit_heap)\n        \n        # Find the next available unique number of occurrences\n        occurrences = limit\n        while occurrences in used_numbers:\n            occurrences -= 1\n        \n        if occurrences > 0:\n            total_length += occurrences\n            used_numbers.add(occurrences)\n            heappush(limit_heap, (occurrences - 1, letter_index))\n    \n    return total_length\n\n# Reading input\nn = int(input())\nlimits = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(max_string_length(n, limits))"}
{"solution": "from collections import Counter\n\ndef min_extra_problems(n, k, difficulties):\n    # Count the frequency of each difficulty\n    difficulty_count = Counter(difficulties)\n    \n    # Initialize the count of extra problems needed\n    extra_problems = 0\n    \n    # Track the maximum difficulty solved so far\n    max_difficulty_solved = k\n    \n    for difficulty in sorted(difficulty_count.keys()):\n        if difficulty > 2 * max_difficulty_solved:\n            # Calculate the minimum difficulty needed to solve the current problem\n            min_needed_difficulty = difficulty // 2\n            if difficulty % 2 == 1:\n                min_needed_difficulty += 1\n            \n            # Update the maximum difficulty solved\n            max_difficulty_solved = max(max_difficulty_solved, min_needed_difficulty)\n            \n            # Increment the count of extra problems needed\n            extra_problems += 1\n        else:\n            max_difficulty_solved = max(max_difficulty_solved, difficulty)\n    \n    return extra_problems\n\n# Read input\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_extra_problems(n, k, difficulties))"}
{"solution": "def distribute_diplomas(n, min_max_1, min_max_2, min_max_3):\n    min_1, max_1 = min_max_1\n    min_2, max_2 = min_max_2\n    min_3, max_3 = min_max_3\n    \n    # Ensure the total number of diplomas does not exceed n\n    first_degree = max(min(max_1, n - min_2 - min_3), min_1)\n    remaining = n - first_degree\n    \n    second_degree = max(min(max_2, remaining - min_3), min_2)\n    remaining -= second_degree\n    \n    third_degree = remaining\n    \n    return first_degree, second_degree, third_degree\n\n# Reading input\nn = int(input())\nmin_max_1 = list(map(int, input().split()))\nmin_max_2 = list(map(int, input().split()))\nmin_max_3 = list(map(int, input().split()))\n\n# Calculating and printing output\nresult = distribute_diplomas(n, min_max_1, min_max_2, min_max_3)\nprint(*result)"}
{"solution": "def moon_cycle(n, observations):\n    # Define the moon cycle\n    moon_sizes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                  14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n\n    # Find the current position in the cycle\n    current_position = moon_sizes.index(observations[0])\n    \n    # Check if we can determine the direction\n    if current_position + n <= 30:\n        if moon_sizes[current_position + n - 1] < moon_sizes[current_position + n]:\n            return \"UP\"\n        elif moon_sizes[current_position + n - 1] > moon_sizes[current_position + n]:\n            return \"DOWN\"\n    else:\n        # Calculate the offset for the cycle\n        offset = (current_position + n) % 30\n        if moon_sizes[offset - 1] < moon_sizes[offset]:\n            return \"UP\"\n        elif moon_sizes[offset - 1] > moon_sizes[offset]:\n            return \"DOWN\"\n\n    return -1\n\n# Read input\nn = int(input())\nobservations = list(map(int, input().split()))\n\n# Print output\nprint(moon_cycle(n, observations))"}
{"solution": "def can_transform(s, t):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s_vowels = {c for c in s if c in vowels}\n    s_consonants = {c for c in s if c not in vowels}\n    t_vowels = {c for c in t if c in vowels}\n    t_consonants = {c for c in t if c not in vowels}\n\n    # Check if the number of unique vowels and consonants match\n    if len(s_vowels.symmetric_difference(t_vowels)) == 0 and len(s_consonants.symmetric_difference(t_consonants)) == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Process and print the result\nprint(can_transform(s, t))"}
{"solution": "import sys\n\ndef read_board():\n    board = [list(input().strip()) for _ in range(8)]\n    return board\n\ndef find_pawns(board):\n    white_pawns = []\n    black_pawns = []\n    for r in range(8):\n        for c in range(8):\n            if board[r][c] == 'W':\n                white_pawns.append(r)\n            elif board[r][c] == 'B':\n                black_pawns.append(7 - r)\n    return white_pawns, black_pawns\n\ndef determine_winner(white_pawns, black_pawns):\n    min_white_distance = min(white_pawns, default=float('inf'))\n    max_black_distance = max(black_pawns, default=0)\n    return 'A' if min_white_distance < max_black_distance else 'B'\n\nboard = read_board()\nwhite_pawns, black_pawns = find_pawns(board)\nwinner = determine_winner(white_pawns, black_pawns)\nprint(winner)"}
{"solution": "def find_max_length(n, A, m, B):\n    S_A = sum(A)\n    S_B = sum(B)\n    \n    if S_A != S_B:\n        return -1\n    \n    def check(k):\n        P, Q = [0] * (k + 1), [0] * (k + 1)\n        \n        i, j = k - 1, k - 1\n        sA, sB = 0, 0\n        \n        while i >= 0 or j >= 0:\n            if i >= 0:\n                sA += A[i]\n            if j >= 0:\n                sB += B[j]\n            \n            while i >= 0 and sA > S_A // k:\n                sA -= A[i]\n                i -= 1\n            \n            while j >= 0 and sB > S_B // k:\n                sB -= B[j]\n                j -= 1\n            \n            if i >= 0 and j >= 0 and sA == sB:\n                P[min(i, j)] = max(P[min(i, j)], sA)\n            \n            if i >= 0:\n                i -= 1\n            if j >= 0:\n                j -= 1\n        \n        i, j = 0, 0\n        result = 0\n        \n        while i < k or j < k:\n            if i < k and (j == k or P[i] >= Q[j]):\n                result += 1\n                i += 1\n            else:\n                j += 1\n        \n        return result == k\n    \n    l, r = 1, min(n, m) + 1\n    \n    while l + 1 < r:\n        mid = (l + r) // 2\n        if check(mid):\n            l = mid\n        else:\n            r = mid\n    \n    return l if check(l) else l - 1\n\n# Example usage\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\nprint(find_max_length(n, A, m, B))"}
{"solution": "def is_from_contest(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    for friend in friends:\n        count = problem_name.count(friend)\n        if count == 1:\n            return \"YES\"\n    return \"NO\"\n\n# Reading input\nproblem_name = input()\n\n# Processing and printing output\nprint(is_from_contest(problem_name))"}
{"solution": "from sympy import primerange\n\ndef min_l_for_primes(a, b, k):\n    primes = list(primerange(1, b + 1))\n    prime_count = [0] * (b + 1)\n    for p in primes:\n        prime_count[p] = 1\n    for i in range(2, b + 1):\n        prime_count[i] += prime_count[i - 1]\n\n    def is_valid(l):\n        for i in range(a, b - l + 2):\n            if prime_count[i + l - 1] - prime_count[i - 1] >= k:\n                return True\n        return False\n\n    left, right = 1, b - a + 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if is_valid(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return result\n\n# Reading input\na, b, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_l_for_primes(a, b, k))"}
{"solution": "from math import gcd\n\ndef find_min_x(a, h, w):\n    def check(y, n):\n        return (n * a + y * (n - 1)) <= h and (h // (a + y) - 1) >= n - 1\n    \n    def binary_search(low, high, n):\n        while low < high:\n            mid = (low + high) / 2\n            if check(mid, n):\n                high = mid\n            else:\n                low = mid + 1e-9\n        return low\n\n    g = gcd(h, w)\n    \n    if a > h or a > w:\n        return -1\n    \n    min_x = float('inf')\n    for n in range(1, (h // a) + 1):\n        x = binary_search(0, a, n)\n        m = (w - n * a - x * (n - 1)) / (x + a)\n        if m.is_integer() and m >= 0:\n            min_x = min(min_x, x)\n    \n    for m in range(1, (w // a) + 1):\n        x = binary_search(0, a, m)\n        n = (h - m * a - x * (m - 1)) / (x + a)\n        if n.is_integer() and n >= 0:\n            min_x = min(min_x, x)\n    \n    return min_x if min_x != float('inf') else -1\n\nif __name__ == \"__main__\":\n    a, h, w = map(int, input().split())\n    result = find_min_x(a, h, w)\n    print(f\"{result:.6f}\" if result != -1 else \"-1\")"}
{"solution": "def chapters_left(n, chapters, k):\n    unread_chapters = 0\n    for i in range(n):\n        if chapters[i][1] < k:\n            continue\n        elif chapters[i][0] > k:\n            unread_chapters += 1\n        else:\n            unread_chapters += n - i\n            break\n    return unread_chapters\n\nif __name__ == \"__main__\":\n    n = int(input())\n    chapters = []\n    for _ in range(n):\n        l, r = map(int, input().split())\n        chapters.append((l, r))\n    k = int(input())\n    print(chapters_left(n, chapters, k))"}
{"solution": "def can_form_codeforces(s):\n    targets = [\"C\", \"CO\", \"COD\", \"CODE\", \"CODEF\", \"CODEFO\", \"CODEFOR\", \"CODEFORC\", \"CODEFORCE\", \"CODEFORCES\"]\n    \n    for target in targets:\n        i = 0\n        j = 0\n        while i < len(s) and j < len(target):\n            if s[i] == target[j]:\n                j += 1\n            i += 1\n        if j == len(target):\n            return True\n    return False\n\ns = input().strip()\nprint('YES' if can_form_codeforces(s) else 'NO')"}
{"solution": "def min_weight_triangulation(n):\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    def calculate(i, j):\n        if j - i < 2:\n            return 0\n        if dp[i][j] == 0:\n            dp[i][j] = float('inf')\n            for k in range(i+1, j, 2):\n                weight = (i+1) * (k+1) * (j+1) + calculate(i, k) + calculate(k, j)\n                dp[i][j] = min(dp[i][j], weight)\n        return dp[i][j]\n    \n    return calculate(0, n-1)\n\n# Reading input\nn = int(input())\n\n# Calculating and printing output\nprint(min_weight_triangulation(n))"}
{"solution": "def count_digits(n):\n    if n < 10:\n        return n\n    digits = 1\n    while True:\n        if n >= 10**digits:\n            n -= 10**digits\n            digits += 1\n        else:\n            break\n    return digits * (n - 10**(digits - 1) + 1) + count_digits(10**(digits - 1) - 1)\n\nn = int(input())\nprint(count_digits(n))"}
{"solution": "from collections import defaultdict\n\ndef find_bobs_winning_color():\n    n, alice_color = map(int, input().split())\n    colors = list(map(int, input().split()))\n    \n    # Initialize counters and variables\n    bob_advantage = defaultdict(int)\n    max_advantage = 0\n    winning_color = -1\n    alice_count = 0\n    bob_count = defaultdict(int)\n    \n    for color in colors:\n        if color == alice_color:\n            alice_count += 1\n        else:\n            bob_count[color] += 1\n        \n        # Update the maximum advantage and winning color\n        if bob_count[color] - alice_count > max_advantage:\n            max_advantage = bob_count[color] - alice_count\n            winning_color = color\n    \n    # Check if there's a winning color for Bob\n    if winning_color != alice_color:\n        print(winning_color)\n    else:\n        print(-1)\n\n# Call the function to solve the problem\nfind_bobs_winning_color()"}
{"solution": "import sys\n\nn, x = map(int, input().split())\na = list(map(int, sys.stdin.readline().strip().split()))\n\ntotal_ones = sum(a)\nspaces_needed = n - 1\n\nif total_ones + spaces_needed > x:\n    print(\"NO\")\nelif total_ones + spaces_needed == x:\n    print(\"YES\")\nelse:\n    remaining_spaces = x - (total_ones + spaces_needed)\n    if remaining_spaces >= 0:\n        print(\"YES\" if remaining_spaces == 0 else \"NO\")\n    else:\n        print(\"NO\")"}
{"solution": "def min_coins(n, S):\n    dp = [0] + [float('inf')] * S\n    for s in range(1, S + 1):\n        for coin in range(1, min(n, s) + 1):\n            dp[s] = min(dp[s], dp[s - coin] + 1)\n    return dp[S]\n\nn, S = map(int, input().split())\nprint(min_coins(n, S))"}
{"solution": "from collections import Counter\n\ndef smallest_palindrome(s):\n    char_count = Counter(s)\n    left_side = []\n    middle_char = None\n    \n    for char, count in sorted(char_count.items()):\n        if count % 2 == 1:\n            if middle_char is not None:\n                middle_char = char\n            else:\n                middle_char = char\n        left_side.extend([char] * (count // 2))\n    \n    right_side = left_side[::-1]\n    \n    result = ''.join(left_side)\n    if middle_char is not None:\n        result += middle_char\n    result += ''.join(right_side)\n    \n    return result\n\n# Read input\ns = input().strip()\n\n# Calculate and print the result\nprint(smallest_palindrome(s))"}
{"solution": "def calculate_position_weight(board):\n    piece_weights = {'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n                     'q': -9, 'r': -5, 'b': -3, 'n': -3, 'p': -1}\n    total_weight = 0\n    \n    for row in board:\n        for piece in row:\n            total_weight += piece_weights.get(piece, 0)\n    \n    return total_weight\n\ndef determine_stronger_position(board):\n    total_weight = calculate_position_weight(board)\n    \n    if total_weight > 0:\n        return \"White\"\n    elif total_weight < 0:\n        return \"Black\"\n    else:\n        return \"Draw\"\n\n# Reading input from stdin\nboard = [input() for _ in range(8)]\n\n# Printing output to stdout\nprint(determine_stronger_position(board))"}
{"solution": "import sys\nfrom collections import deque\n\ninput = sys.stdin.readline\n\ndef main():\n    N, M = map(int, input().split())\n    S = list(map(int, input().strip()))\n\n    # Initialize DP array\n    dp = [-1] * (N + 1)\n    dp[N] = 0\n\n    # Queue for BFS-like traversal\n    q = deque([N])\n\n    while q:\n        pos = q.popleft()\n\n        # Check backwards from the current position\n        for step in range(1, M + 1):\n            next_pos = pos - step\n\n            # Check if it's a valid move and not a game over square\n            if next_pos >= 0 and S[next_pos] == 0 and dp[next_pos] == -1:\n                dp[next_pos] = step\n                q.append(next_pos)\n\n    # Reconstruct the path\n    path = []\n    pos = 0\n    while pos < N:\n        if dp[pos] == -1:\n            print(-1)\n            return\n        path.append(dp[pos])\n        pos += dp[pos]\n\n    print(*path[::-1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef solve(K, X, Y):\n    def gcd_extended(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            g, x, y = gcd_extended(b % a, a)\n            return g, y - (b // a) * x, x\n\n    def find_solution(a, b, c):\n        _, x, y = gcd_extended(a, b)\n        x = x * c % (b // math.gcd(a, c))\n        y = (c - a * x) // b\n        return x, y\n\n    def find_path(K, X, Y, steps=0, x=0, y=0, path=[]):\n        if X == x and Y == y:\n            return steps, path\n        d = abs(X - x) + abs(Y - y)\n        if d < K or (d % K != 0 and d % (2 * K) != 0):\n            return None\n        if d % K == 0:\n            dx, dy = find_solution(K, K, d)\n        else:\n            dx, dy = find_solution(K, 2 * K, d)\n        next_x, next_y = x + dx * K, y + dy * K\n        result = find_path(K, X, Y, steps + 1, next_x, next_y, path + [(next_x, next_y)])\n        return result\n\n    result = find_path(K, X, Y)\n    if result is None:\n        return -1\n    else:\n        steps, path = result\n        return f\"{steps}\\n\" + \"\\n\".join(f\"{x} {y}\" for x, y in path)\n\nK = int(input())\nX, Y = map(int, input().split())\n\nprint(solve(K, X, Y))"}
{"solution": "from math import sqrt\n\ndef find_smallest_n(m):\n    \"\"\"\n    Finds the smallest possible value of n such that there are exactly m ways\n    the thieves could have taken the chocolates, given the constraints.\n    \"\"\"\n    def count_ways(n):\n        ways = 0\n        max_k = int(sqrt(3 * n + 1)) // 2\n        for x1 in range(1, n + 1):\n            a = 3 * x1 * x1 + 3 * x1 + 1\n            b = 2 * x1 * n + 2 * x1\n            for k in range(2, max_k + 1):\n                if (a * k * k - b) % (3 * k * k - 3 * k) == 0 and (a * k * k - b) // (3 * k * k - 3 * k) >= 0:\n                    ways += 1\n        return ways\n\n    left, right = 1, int(1e15)\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        current_ways = count_ways(mid)\n        if current_ways == m:\n            result = mid\n            break\n        elif current_ways < m:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result\n\n# Reading input\nm = int(input())\n\n# Calculating and printing the output\nprint(find_smallest_n(m))"}
{"solution": "import math\n\ndef intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    \n    if d >= r1 + r2:\n        return 0.0\n    elif d <= abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n    else:\n        phi1 = math.acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        phi2 = math.acos((r2 ** 2 + d ** 2 - r1 ** 2) / (2 * r2 * d))\n        \n        area1 = r1 ** 2 * phi1 - r1 ** 2 * math.sin(2 * phi1) / 2\n        area2 = r2 ** 2 * phi2 - r2 ** 2 * math.sin(2 * phi2) / 2\n        \n        return area1 + area2\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\nprint(intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "import math\n\ndef minimize_n(v):\n    # Base case: if v is 1, it's already minimized\n    if v == 1:\n        return 1\n    \n    # Find the largest perfect square less than or equal to v\n    max_sqrt = int(math.sqrt(v))\n    \n    # Initialize the result with v\n    result = v\n    \n    for i in range(max_sqrt, 0, -1):\n        # Calculate the square of the current number\n        square = i * i\n        \n        # If the square divides v, skip it\n        if v % square == 0:\n            continue\n        \n        # Update the result if a smaller value is found\n        result = min(result, v - square)\n    \n    return result\n\n# Read input\nv = int(input())\n\n# Print the minimum value of n\nprint(minimize_n(v))"}
{"solution": "3\nimport sys\nfrom heapq import heappush, heappop\n\ninput = sys.stdin.readline\n\ndef build_tree(n, edges):\n    tree = [[] for _ in range(n+1)]\n    for i in range(2, n+1):\n        tree[i].append(edges[i-1])\n        tree[edges[i-1]].append(i)\n    return tree\n\ndef dfs(node, parent, citizens, tree, scores):\n    score = citizens[node]\n    max_score = 0\n    for child in tree[node]:\n        if child == parent:\n            continue\n        child_score = dfs(child, node, citizens, tree, scores)\n        score += child_score\n        max_score = max(max_score, child_score)\n    scores[node] = max(0, score - max_score)\n    return scores[node]\n\ndef main():\n    n = int(input())\n    parents = list(map(int, input().split()))\n    citizens = list(map(int, input().split()))\n\n    # Build the tree\n    tree = build_tree(n, parents)\n\n    # Calculate scores\n    scores = [0] * (n+1)\n    dfs(1, -1, citizens, tree, scores)\n\n    # Find the maximum score from the root to each leaf\n    max_scores = [0] * (n+1)\n    queue = [(0, 1)]  # (score, node)\n    visited = set()\n    while queue:\n        score, node = heappop(queue)\n        if node in visited:\n            continue\n        visited.add(node)\n        max_scores[node] = -score\n        for child in tree[node]:\n            if child not in visited:\n                new_score = max(-score, scores[child])\n                heappush(queue, (-new_score, child))\n\n    # The answer is the sum of the maximum scores from the root to each leaf\n    print(sum(max_scores[1:]))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_possible_words(n, s, t):\n    \"\"\"\n    Counts the number of possible words of length n + 1 that can be transformed into both s and t\n    by deleting exactly one character.\n    \n    :param n: Length of words s and t.\n    :param s: First word of length n.\n    :param t: Second word of length n.\n    :return: Number of possible words W.\n    \"\"\"\n    start, end = 0, n - 1\n    while start < n and s[start] == t[start]:\n        start += 1\n    while end >= 0 and s[end] == t[end]:\n        end -= 1\n    \n    match_s = s[start:end] == t[start+1:end+1]\n    match_t = s[start+1:end+1] == t[start:end]\n    \n    return int(match_s) + int(match_t)\n\n# Reading input\nn = int(input())\ns = input()\nt = input()\n\n# Computing and printing the result\nprint(count_possible_words(n, s, t))"}
{"solution": "from collections import defaultdict, deque\n\ndef build_graph(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    return graph\n\ndef bfs(graph, root, strengths):\n    queue = deque([root])\n    visited = set([root])\n    max_strength = strengths[root]\n    \n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                max_strength = max(max_strength, strengths[neighbor])\n                \n                # Increase strength of semi-neighbors\n                for semi_neighbor in graph[neighbor]:\n                    if semi_neighbor != current and semi_neighbor in visited:\n                        strengths[semi_neighbor] += 1\n                        \n    return max_strength\n\ndef min_computer_strength(n, strengths, edges):\n    graph = build_graph(n, edges)\n    \n    # Find leaf nodes\n    leaves = [node for node, neighbors in graph.items() if len(neighbors) == 1]\n    \n    # Process leaf nodes until only one node remains\n    while len(leaves) > 1:\n        new_leaves = []\n        for leaf in leaves:\n            parent = graph[leaf][0]\n            strengths[parent] += strengths[leaf]\n            \n            if strengths[parent] > max_strength:\n                max_strength = strengths[parent]\n                \n            del graph[parent][graph[parent].index(leaf)]\n            \n            if len(graph[parent]) == 1:\n                new_leaves.append(parent)\n                \n        leaves = new_leaves\n    \n    return max_strength\n\n# Reading input\nn = int(input())\nstrengths = list(map(int, input().split()))\nedges = [list(map(int, input().split())) for _ in range(n - 1)]\n\n# Calculating and printing output\nprint(min_computer_strength(n, dict(enumerate(strengths, 1)), edges))"}
{"solution": "def max_groups(n, m):\n    if m == 0:\n        return 1\n    if m >= n - 1:\n        return n - m\n    return min(m + 1, n - m)\n\nn, m = map(int, input().split())\nprint(max_groups(n, m))"}
{"solution": "k, r = map(int, input().split())\n\n# Find the minimum number of shovels that can be bought without change\nfor i in range(1, 11):\n    if (i * k) % 10 == 0 or (i * k) % 10 == r:\n        print(i)\n        break"}
{"solution": "from collections import defaultdict\n\ndef is_rectangle_possible(n, m, grid):\n    X_positions = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                X_positions.append((i, j))\n\n    # Find the bounding box\n    min_row, max_row = min(pos[0] for pos in X_positions), max(pos[0] for pos in X_positions)\n    min_col, max_col = min(pos[1] for pos in X_positions), max(pos[1] for pos in X_positions)\n\n    # Check if the bounding box forms a rectangle\n    if max_row - min_row == max_col - min_col:\n        return \"NO\"\n\n    # Check if the positions outside the bounding box are all empty\n    for row, col in X_positions:\n        if (row < min_row or row > max_row) and (col < min_col or col > max_col):\n            return \"NO\"\n\n    # Check if the positions inside the bounding box are all filled\n    for i in range(min_row, max_row + 1):\n        for j in range(min_col, max_col + 1):\n            if grid[i][j] != 'X':\n                return \"NO\"\n\n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Solve\nprint(is_rectangle_possible(n, m, grid))"}
{"solution": "def min_segments(x1, y1, x2, y2, x3, y3):\n    def same_axis(val1, val2, val3):\n        return val1 == val2 == val3\n\n    def can_connect(val1, val2, val3):\n        return val1 == val2 or val2 == val3 or val1 == val3\n\n    # Check if all points are aligned horizontally or vertically\n    if same_axis(x1, x2, x3) or same_axis(y1, y2, y3):\n        return 1\n\n    # Check if any two points are aligned horizontally or vertically\n    if can_connect(x1, x2, x3) or can_connect(y1, y2, y3):\n        return 2\n\n    return 3\n\n# Reading input\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_segments(x1, y1, x2, y2, x3, y3))"}
{"solution": "def build_k_regular_graph(k):\n    if k == 0:\n        print(\"NO\")\n        return\n    \n    if k == 1:\n        print(\"YES\")\n        print(2, 1)\n        print(1, 2)\n        return\n    \n    # For even k, we cannot create a k-regular graph with at least one bridge\n    if k % 2 == 0:\n        print(\"NO\")\n        return\n    \n    # For odd k > 1, we can construct a suitable graph\n    print(\"YES\")\n    n = k + 1\n    m = n * k // 2\n    print(n, m)\n    \n    # Connect each node to k other nodes to form a k-regular graph\n    for i in range(1, n):\n        for j in range(i + 1, min(i + k + 1, n + 1)):\n            print(i, j)\n\n# Read input\nk = int(input())\n\n# Build the graph\nbuild_k_regular_graph(k)"}
{"solution": "def build_kmp_table(pattern):\n    table = [0] * len(pattern)\n    length = 0\n    i = 1\n    while i < len(pattern):\n        if pattern[i] == pattern[length]:\n            length += 1\n            table[i] = length\n            i += 1\n        else:\n            if length != 0:\n                length = table[length - 1]\n            else:\n                table[i] = 0\n                i += 1\n    return table\n\ndef kmp_search(text, pattern):\n    text_len = len(text)\n    pattern_len = len(pattern)\n    table = build_kmp_table(pattern)\n    i = 0\n    j = 0\n    while i < text_len:\n        if text[i] == pattern[j]:\n            i += 1\n            j += 1\n        if j == pattern_len:\n            return True, i - j\n        elif i < text_len and text[i] != pattern[j]:\n            if j != 0:\n                j = table[j - 1]\n            else:\n                i += 1\n    return False, -1\n\ndef process_queries(s, t, queries):\n    n = len(s)\n    m = len(t)\n    kmp_table = build_kmp_table(t)\n    prefix_sums = [0] * (n + 1)\n    \n    j = 0\n    for i in range(n):\n        while j > 0 and s[i] != t[j]:\n            j = kmp_table[j - 1]\n        if s[i] == t[j]:\n            j += 1\n        if j == m:\n            prefix_sums[i + 1] = prefix_sums[i] + 1\n            j = kmp_table[j - 1]\n        else:\n            prefix_sums[i + 1] = prefix_sums[i]\n\n    for l, r in queries:\n        print(prefix_sums[r] - prefix_sums[l - 1])\n\nif __name__ == \"__main__\":\n    n, m, q = map(int, input().split())\n    s = input()\n    t = input()\n    queries = [tuple(map(int, input().split())) for _ in range(q)]\n    process_queries(s, t, queries)"}
{"solution": "MOD = 10**9 + 7\n\ndef calculate_paths(n, k, d):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(1, min(k + 1, i + 1)):\n            dp[i][j] = dp[i - j][j - 1]\n            for l in range(j):\n                dp[i][j] += dp[i - j][l]\n                dp[i][j] %= MOD\n    \n    result = 0\n    for i in range(d, k + 1):\n        result += dp[n][i]\n        result %= MOD\n    \n    return result\n\nn, k, d = map(int, input().split())\nprint(calculate_paths(n, k, d))"}
{"solution": "def encode_row(row):\n    n = len(row)\n    groups = []\n    count = 0\n    for i in range(n):\n        if row[i] == 'B':\n            count += 1\n        elif count > 0:\n            groups.append(count)\n            count = 0\n    if count > 0:\n        groups.append(count)\n\n    return len(groups), groups\n\n# Reading input\nn = int(input())\nrow = input().strip()\n\n# Encoding the row\nk, groups = encode_row(row)\n\n# Printing output\nprint(k)\nif k > 0:\n    print(' '.join(map(str, groups)))\nelse:\n    print()"}
{"solution": "def process_operations(cbs, operations, cursor_pos):\n    pairs = [-1] * len(cbs)\n    stack = []\n    \n    # Build the pairs array\n    for i, char in enumerate(cbs):\n        if char == '(':\n            stack.append(i)\n        else:\n            pairs[stack.pop()] = i\n            pairs[i] = stack[-1] if stack else -1\n    \n    def move_left():\n        nonlocal cursor_pos\n        cursor_pos -= 1\n        while cbs[cursor_pos] == -1:\n            cursor_pos -= 1\n    \n    def move_right():\n        nonlocal cursor_pos\n        cursor_pos += 1\n        while cbs[cursor_pos] == -1:\n            cursor_pos += 1\n    \n    def delete():\n        nonlocal cursor_pos\n        start, end = cursor_pos, pairs[cursor_pos]\n        for i in range(start, end + 1):\n            cbs[i] = -1\n        \n        # Move cursor to the nearest non-deleted bracket\n        if end < len(cbs) - 1 and cbs[end + 1] != -1:\n            cursor_pos = end + 1\n        else:\n            cursor_pos = start - 1\n            while cbs[cursor_pos] == -1:\n                cursor_pos -= 1\n    \n    for op in operations:\n        if op == 'L':\n            move_left()\n        elif op == 'R':\n            move_right()\n        elif op == 'D':\n            delete()\n    \n    return ''.join(')' if x == -1 else '(' for x in cbs).replace('-1', '')\n\n# Read input\nn, m, p = map(int, input().split())\ncbs = list(input())\noperations = input()\n\n# Process operations\nresult_cbs = process_operations(cbs, operations, p - 1)\n\n# Print the result\nprint(result_cbs)"}
{"solution": "def find_possible_y(queries):\n    min_y, max_y = -2000000000, 2000000000\n    \n    for query in queries:\n        condition, x, answer = query.split()\n        x = int(x)\n        \n        if answer == 'Y':\n            if condition == '>':\n                min_y = max(min_y, x + 1)\n            elif condition == '<':\n                max_y = min(max_y, x - 1)\n            elif condition == '>=':\n                min_y = max(min_y, x)\n            elif condition == '<=':\n                max_y = min(max_y, x)\n        else: \n            if condition == '>':\n                max_y = min(max_y, x)\n            elif condition == '<':\n                min_y = max(min_y, x)\n            elif condition == '>=':\n                max_y = min(max_y, x - 1)\n            elif condition == '<=':\n                min_y = max(min_y, x + 1)\n    \n    if min_y <= max_y:\n        return min_y\n    else:\n        return \"Impossible\"\n\nif __name__ == \"__main__\":\n    n = int(input())\n    queries = [input() for _ in range(n)]\n    result = find_possible_y(queries)\n    print(result)"}
{"solution": "from math import gcd\n\ndef count_possible_periods(a, b):\n    \"\"\"\n    Calculates the number of different periods for all possible strings\n    composed of a 'A's and b 'B's.\n    \"\"\"\n    total = a + b\n    result = total - 1\n    common_divisors = gcd(a, b)\n    \n    if common_divisors > 1:\n        result -= (total // common_divisors - 1)\n    \n    return result\n\n# Reading input\na, b = map(int, input().split())\n\n# Calculating and printing the result\nprint(count_possible_periods(a, b))"}
{"solution": "def find_soldier_names(n, k, effectiveness):\n    names = [\"A\"] * n\n    unique_name_counter = 1\n    for i in range(n - k + 1):\n        if effectiveness[i] == \"NO\":\n            continue\n        for j in range(i, i + k):\n            if names[j] == \"A\":\n                new_name = chr(65 + unique_name_counter % 26)\n                names[j] = new_name + \"a\" * (min(10, unique_name_counter))\n                unique_name_counter += 1\n            else:\n                break\n    return names\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    effectiveness = input().split()\n    soldier_names = find_soldier_names(n, k, effectiveness)\n    print(\" \".join(soldier_names))"}
{"solution": "def min_operations_to_equal(a, b):\n    if a == b:\n        return 0\n    operations = 0\n    while True:\n        if a > b:\n            a, b = b, a\n        if a % 5 == 0 and b % 5 == 0:\n            diff = b - a\n            if diff % 5 == 0:\n                operations += diff // 5 * 4\n                break\n        if a % 3 == 0 and b % 3 == 0:\n            diff = b - a\n            if diff % 3 == 0:\n                operations += diff // 3 * 2\n                break\n        if a % 2 == 0 and b % 2 == 0:\n            diff = b - a\n            if diff % 2 == 0:\n                operations += diff // 2\n                break\n        if a % 5 == 0:\n            operations += 4\n            a *= 4 // 5\n        elif a % 3 == 0:\n            operations += 2\n            a *= 1 // 3 * 2\n        elif a % 2 == 0:\n            operations += 1\n            a //= 2\n        else:\n            break\n    if a != b:\n        operations = -1\n    return operations\n\na, b = map(int, input().split())\nprint(min_operations_to_equal(a, b))"}
{"solution": "def min_cost_palindrome(n, a, b, c):\n    dp = [[float('inf')] * 2 for _ in range((n + 1) // 2)]\n    dp[0][0] = 0\n    dp[0][1] = 0\n    \n    for i in range(1, (n + 1) // 2):\n        for prev in range(2):\n            for curr in range(2):\n                cost = 0\n                if c[i - 1] == 2:\n                    cost += a if curr == 0 else b\n                elif c[i - 1] != curr:\n                    cost = float('inf')\n                \n                if c[n - i] == 2:\n                    cost += a if curr == 0 else b\n                elif c[n - i] != curr:\n                    cost = float('inf')\n                \n                dp[i][curr] = min(dp[i][curr], dp[i - 1][prev] + cost)\n    \n    if dp[(n + 1) // 2 - 1][0] == float('inf') and dp[(n + 1) // 2 - 1][1] == float('inf'):\n        return -1\n    else:\n        return min(dp[(n + 1) // 2 - 1])\n\n# Reading input\nn, a, b = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(min_cost_palindrome(n, a, b, c))"}
{"solution": "def solve_cube(k):\n    if k == 1:\n        return \"-1\"\n    \n    solution = []\n    for layer in range(k):\n        layer_pattern = []\n        for row in range(k):\n            row_pattern = []\n            for col in range(k):\n                # Determine the color based on the position and layer\n                color = 'w' if (row + col + layer) % 3 == 0 else 'b'\n                row_pattern.append(color)\n            layer_pattern.append(row_pattern)\n        solution.append(layer_pattern)\n    \n    # Format and print the solution\n    formatted_solution = \"\"\n    for layer in solution:\n        for row in layer:\n            formatted_solution += \"\".join(row) + \"\\n\"\n        if layer != solution[-1]:\n            formatted_solution += \"\\n\"\n    \n    return formatted_solution.strip()\n\n# Read input\nk = int(input())\n\n# Solve and print the result\nprint(solve_cube(k))"}
{"solution": "import math\n\ndef is_lovely(x):\n    if x < 2:\n        return True\n    for i in range(2, int(math.sqrt(x)) + 1):\n        if x % (i * i) == 0:\n            return False\n    return True\n\ndef max_lovely_divisor(n):\n    for x in range(n, 0, -1):\n        if n % x == 0 and is_lovely(x):\n            return x\n\nn = int(input())\nprint(max_lovely_divisor(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    if n == 1:\n        return True\n    if seating[0] == '1' and seating[1] == '1':\n        return False\n    if seating[-1] == '1' and seating[-2] == '1':\n        return False\n    \n    last_seen = seating[0]\n    for i in range(1, n):\n        if seating[i] == '1':\n            if last_seen == '1' or (i < n - 1 and seating[i + 1] == '1'):\n                return False\n            last_seen = '1'\n        else:\n            last_seen = '0'\n    \n    # Check if we can insert an additional person\n    for i in range(1, n - 1):\n        if seating[i] == '0' and seating[i - 1] == '0' and seating[i + 1] == '0':\n            return False\n    return True\n\ndef main():\n    n = int(input())\n    seating = input().strip()\n    if is_maximal_seating(n, seating):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from typing import List\n\ndef find_possible_lengths(a: List[int]) -> List[int]:\n    n = len(a)\n    valid_lengths = []\n\n    for k in range(1, n + 1):\n        valid = True\n        prefix_sum = 0\n        for i in range(1, n + 1):\n            current_value = a[(i - 1) % n]\n            expected_value = prefix_sum + a[i % n]\n            if current_value != expected_value:\n                valid = False\n                break\n            prefix_sum = current_value\n            if i % k == 0:\n                prefix_sum = 0\n\n        if valid:\n            valid_lengths.append(k)\n\n    return valid_lengths\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Finding possible lengths\npossible_lengths = find_possible_lengths(a)\n\n# Preparing output\noutput = [str(length) for length in possible_lengths]\nprint(len(possible_lengths))\nprint(' '.join(output))"}
{"solution": "from itertools import combinations\n\ndef can_form_equal_teams(scores):\n    total_score = sum(scores)\n    if total_score % 2 != 0:\n        return \"NO\"\n    \n    target = total_score // 2\n    for combo in combinations(scores, 3):\n        if sum(combo) == target:\n            return \"YES\"\n    return \"NO\"\n\n# Reading input\nscores = list(map(int, input().split()))\n\n# Processing and printing output\nprint(can_form_equal_teams(scores))"}
{"solution": "from math import log2, log3\n\ndef count_2_3_integers(l, r):\n    def max_power(base, limit):\n        return int(log2(limit)) if base == 2 else int(log3(limit))\n    \n    def count(limit):\n        count = 0\n        for x in range(max_power(2, limit) + 1):\n            max_y = max_power(3, limit // (2 ** x))\n            count += max_y + 1\n        return count\n    \n    return count(r) - count(l - 1)\n\n# Reading input\nl, r = map(int, input().split())\n\n# Calculating and printing the result\nprint(count_2_3_integers(l, r))"}
{"solution": "import math\n\ndef candies_eaten(n, k):\n    low, high = 0, n\n    while low < high:\n        mid = (low + high) // 2\n        eaten = n - mid\n        total_candies = mid * (mid + 1) // 2 - eaten\n        if total_candies > k:\n            high = mid\n        else:\n            low = mid + 1\n        if total_candies == k:\n            return eaten\n    return n - low + (k - (low * (low + 1) // 2 - n + low))\n\nn, k = map(int, input().split())\nprint(candies_eaten(n, k))"}
{"solution": "def can_form_triangle(n, segments):\n    segments.sort()\n    for i in range(n - 2):\n        if segments[i] + segments[i + 1] > segments[i + 2]:\n            return \"YES\"\n    return \"NO\"\n\n# Reading input\nn = int(input())\nsegments = list(map(int, input().split()))\n\n# Processing and printing output\nprint(can_form_triangle(n, segments))"}
{"solution": "def is_possible(x, y):\n    if y > x or (x == 0 and y != 1):\n        return \"No\"\n    while x > 0 and y > 0:\n        if x >= y:\n            x -= y\n        else:\n            y -= 1\n        if x == 0 and y == 1:\n            return \"Yes\"\n    return \"No\"\n\nx, y = map(int, input().split())\nprint(is_possible(x, y))"}
{"solution": "def max_rating(n, k, skills):\n    skills = [skill // 10 * 10 + 10 if skill % 10 > 0 else skill for skill in skills]\n    skills.sort()\n    \n    while k > 0 and len(skills) > 0:\n        last = skills[-1]\n        cost = min(k, 110 - last)\n        skills[-1] += cost\n        k -= cost\n        if skills[-1] == 110:\n            skills.pop()\n    \n    return sum(skill // 10 for skill in skills)\n\n# Reading input\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Computing and printing output\nprint(max_rating(n, k, skills))"}
{"solution": "def smallest_pretty_integer(n, m, a, b):\n    # Combine both lists and sort them\n    digits = sorted(set(a + b))\n    \n    # Start checking from the smallest digit\n    for d in digits:\n        # Check if the digit exists in both lists\n        if d in a and d in b:\n            return d\n        \n    # If no common digit, form the smallest number by concatenating the smallest digits from each list\n    min_a = min(a)\n    min_b = min(b)\n    return int(f\"{min(min_a, min_b)}{max(min_a, min_b)}\")\n\n# Read input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Print the result\nprint(smallest_pretty_integer(n, m, a, b))"}
{"solution": "n, k = map(int, input().split())\nmax_time = 240 - k\ntotal_time = 0\nproblems_solved = 0\n\nfor i in range(1, n + 1):\n    total_time += 5 * i\n    if total_time > max_time:\n        break\n    problems_solved += 1\n\nprint(problems_solved)"}
{"solution": "def max_teams(n, x, y, pages):\n    pages.sort()\n    \n    def can_print(k):\n        double_sided_needed = sum(pages[:k]) // 2\n        single_sided_needed = sum(pages[:k]) % 2\n        \n        # If we have enough double-sided paper\n        if double_sided_needed <= x:\n            return double_sided_needed * 2 + min(y, single_sided_needed) >= sum(pages[:k])\n        else:\n            remaining_double_sided = double_sided_needed - x\n            required_single_sided = remaining_double_sided + single_sided_needed\n            return required_single_sided <= y\n    \n    low, high = 0, n\n    while low < high:\n        mid = (low + high + 1) // 2\n        if can_print(mid):\n            low = mid\n        else:\n            high = mid - 1\n            \n    return low\n\n# Reading input\nn, x, y = map(int, input().split())\npages = list(map(int, input().split()))\n\n# Printing output\nprint(max_teams(n, x, y, pages))"}
{"solution": "from math import gcd\n\ndef solve(b):\n    count = 1  # Starting from 1 because [a, b]/a is always 1 when a is 1\n    factor = 2\n    while b >= factor:\n        prev_b = b\n        b //= factor\n        while b % factor == 0:\n            b //= factor\n        count *= (factor + 1)\n        factor += 1\n        if prev_b == b * factor:\n            factor = prev_b\n    return count\n\n# Reading input\nb = int(input())\n\n# Solving and printing output\nprint(solve(b))"}
{"solution": "n = int(input())\nbumper_sequence = input()\n\ndef count_falling_positions(bumper_sequence):\n    left_max = [0] * n\n    right_max = [0] * n\n    \n    # Calculate max consecutive '<' to the left\n    left_count = 0\n    for i in range(n):\n        if bumper_sequence[i] == '<':\n            left_count += 1\n        else:\n            left_count = 0\n        left_max[i] = left_count\n    \n    # Calculate max consecutive '>' to the right\n    right_count = 0\n    for i in range(n - 1, -1, -1):\n        if bumper_sequence[i] == '>':\n            right_count += 1\n        else:\n            right_count = 0\n        right_max[i] = right_count\n    \n    # Count positions where the ball falls off\n    count = 0\n    for i in range(n):\n        if left_max[i] >= i or right_max[i] >= n - i - 1:\n            count += 1\n    \n    return count\n\nprint(count_falling_positions(bumper_sequence))"}
{"solution": "from collections import Counter\n\ndef max_rectangle_area(stick_lengths):\n    count = Counter(stick_lengths)\n    stick_lengths.sort(reverse=True)\n    area = 0\n    i = 0\n    \n    while i < len(stick_lengths):\n        current = stick_lengths[i]\n        if count[current] >= 4:\n            area += current * current\n            count[current] -= 4\n        elif count[current] >= 2 and count[current-1] >= 2:\n            area += (current-1) * (current-1)\n            count[current] -= 2\n            count[current-1] -= 2\n        else:\n            i += 1\n            continue\n        i += 1  # Skip the next one since we've paired the current\n        \n    return area\n\n# Reading input\nn = int(input())\nl = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(max_rectangle_area(l))"}
{"solution": "from collections import defaultdict, Counter\n\ndef min_sum_of_numbers(n, numbers):\n    def value_of_number(s, mapping):\n        return int(\"\".join(str(mapping[c]) for c in s))\n    \n    # Count occurrences of each character in the first position and overall\n    first_chars = Counter()\n    all_chars = Counter()\n    max_len = 0\n    for s in numbers:\n        if len(s) > 1:\n            first_chars[s[0]] += 1\n        all_chars.update(s)\n        max_len = max(max_len, len(s))\n\n    # Characters that appear only in the first position can be mapped directly\n    direct_map = {c: str(9 - i) for i, (c, count) in enumerate(first_chars.items()) if count == len(numbers)}\n\n    # Remaining characters need to be assigned values from 0 to 9, avoiding conflicts\n    remaining_chars = sorted(set(all_chars) - set(direct_map), key=lambda x: -all_chars[x])\n    remaining_values = ['0', '1', '2', '3', '4', '5', '6', '7', '8']\n    char_to_digit = {c: v for c, v in zip(remaining_chars, remaining_values)}\n    char_to_digit.update(direct_map)\n\n    # Calculate the total sum\n    total_sum = sum(value_of_number(s, char_to_digit) for s in numbers)\n    return total_sum\n\n# Reading input\nn = int(input())\nnumbers = [input().strip() for _ in range(n)]\n\n# Printing output\nprint(min_sum_of_numbers(n, numbers))"}
{"solution": "def max_teams(n, m):\n    # Calculate the maximum number of teams under A's condition\n    teams_A = min(n, m // 2)\n    # Calculate the maximum number of teams under B's condition\n    teams_B = min(m, n // 2)\n    # Return the total number of teams\n    return teams_A + teams_B\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    ab_found = False\n    ba_found = False\n    last_ab_pos = -1\n    last_ba_pos = -1\n    \n    for i in range(len(s) - 1):\n        if s[i:i+2] == \"AB\":\n            if last_ba_pos < i:\n                ab_found = True\n                last_ab_pos = i\n        elif s[i:i+2] == \"BA\":\n            if last_ab_pos < i:\n                ba_found = True\n                last_ba_pos = i\n                \n    if ab_found and ba_found:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n# Read input\ns = input().strip()\n\n# Process and print output\ncheck_substrings(s)"}
{"solution": "from collections import deque\n\ndef can_eat(a, b):\n    stack = []\n    eaten = []\n\n    for weight in reversed(a):\n        if len(stack) > 0 and weight < stack[-1]:\n            eaten.append(len(stack))\n            stack[-1] += weight\n        else:\n            stack.append(weight)\n    stack.reverse()\n\n    for i in range(len(b)):\n        if stack and b[i] == stack[0]:\n            stack.pop(0)\n        else:\n            return \"NO\"\n\n    if not stack:\n        actions = []\n        for i, eat in enumerate(reversed(eaten)):\n            direction = 'L' if (len(a) - i - 1) > eat else 'R'\n            actions.append(f\"{eat + 1} {direction}\")\n\n        return f\"YES\\n{''.join(actions[::-1])}\"\n    else:\n        return \"NO\"\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\nk = int(input())\nb = list(map(int, input().split()))\n\n# Printing the result\nprint(can_eat(a, b))"}
{"solution": "from itertools import combinations\n\ndef can_connect(rebels, bases):\n    n = len(rebels)\n    m = len(bases)\n\n    if n != m:\n        return \"No\"\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def is_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n\n        if o1 != o2 and o3 != o4:\n            return True\n\n        return False\n\n    for perm in combinations(range(m), n):\n        if all(not is_intersect(rebels[i], bases[perm[i]], rebels[j], bases[perm[j]]) for i, j in combinations(range(n), 2)):\n            return \"Yes\"\n    return \"No\"\n\n# Reading input\nR, B = map(int, input().split())\nrebels = [list(map(int, input().split())) for _ in range(R)]\nbases = [list(map(int, input().split())) for _ in range(B)]\n\n# Printing output\nprint(can_connect(rebels, bases))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmax_power = 0\ncount = 0\n\nfor num in a:\n    power = 0\n    while num % 2 == 0:\n        num //= 2\n        power += 1\n    if power > max_power:\n        max_power = power\n        count = 1\n    elif power == max_power:\n        count += 1\n\nprint(2 ** max_power, count)"}
{"solution": "import heapq\n\ndef min_clicks(n, m):\n    if n == m:\n        return 0\n    if n > m:\n        return n - m\n    \n    clicks = 0\n    while n != m:\n        if m % 2 == 0 and n < m:\n            m //= 2\n        else:\n            m += 1\n        clicks += 1\n    return clicks\n\n# Reading input\nn, m = map(int, input().split())\n\n# Calculating and printing the answer\nprint(min_clicks(n, m))"}
{"solution": "3\nfrom collections import defaultdict\n\ndef build_graph(n, segments):\n    events = []\n    for i, (l, r) in enumerate(segments):\n        events.append((l, 'start', i))\n        events.append((r, 'end', i))\n    events.sort()\n\n    graph = defaultdict(set)\n    active_segments = set()\n    last_pos = None\n\n    for pos, event_type, seg_index in events:\n        if last_pos is not None and last_pos != pos:\n            for seg in active_segments:\n                graph[seg].add(seg_index)\n                graph[seg_index].add(seg)\n        if event_type == 'start':\n            active_segments.add(seg_index)\n        else:\n            active_segments.remove(seg_index)\n        last_pos = pos\n\n    return graph, len(events) // 2\n\ndef is_tree(graph, n):\n    if n == 1:\n        return True\n\n    visited = set()\n    stack = [next(iter(graph))]\n\n    while stack:\n        node = stack.pop()\n        if node in visited:\n            return False  # Cycle detected\n        visited.add(node)\n\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                stack.append(neighbor)\n\n    return len(visited) == n\n\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\ngraph, actual_vertices = build_graph(n, segments)\n\nprint(\"YES\" if is_tree(graph, actual_vertices) else \"NO\")"}
{"solution": "def longest_ddos_attack(n, requests):\n    max_length = 0\n    for start in range(n):\n        total_requests = 0\n        for end in range(start, n):\n            total_requests += requests[end]\n            attack_threshold = 100 * (end - start + 1)\n            if total_requests > attack_threshold:\n                current_length = end - start + 1\n                max_length = max(max_length, current_length)\n            else:\n                break\n    return max_length\n\n# Reading input\nn = int(input())\nrequests = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(longest_ddos_attack(n, requests))"}
{"solution": "def check_dissatisfaction(n, k, episodes):\n    def check(max_consecutive, k):\n        consecutive = 0\n        unsure_start = -1\n        unsure_count = 0\n        \n        for i in range(n):\n            if episodes[i] == 'N':\n                if unsure_count > 0:\n                    if unsure_start + unsure_count + consecutive >= k:\n                        return True\n                    consecutive = max(0, k - unsure_count)\n                    unsure_count = 0\n                consecutive += 1\n            elif episodes[i] == '?':\n                if consecutive + unsure_count == k:\n                    return True\n                if unsure_start == -1:\n                    unsure_start = i\n                unsure_count += 1\n                consecutive += 1\n            else:\n                consecutive = 0\n                unsure_start = -1\n                unsure_count = 0\n        \n        return max_consecutive >= k and (max_consecutive - unsure_count < k or unsure_count == 0)\n\n    max_consecutive = 0\n    consecutive = 0\n    for i in range(n):\n        if episodes[i] == 'N':\n            consecutive += 1\n            max_consecutive = max(max_consecutive, consecutive)\n        else:\n            consecutive = 0\n    \n    return \"YES\" if check(max_consecutive, k) else \"NO\"\n\n# Example usage\nn, k = map(int, input().split())\nepisodes = input()\nprint(check_dissatisfaction(n, k, episodes))"}
{"solution": "import sys\n\ninput = sys.stdin.readline\n\ndef main():\n    N, X, D = map(int, input().split())\n    \n    if D == 0:\n        print(2 * (N % 2) - 1)\n        return\n    \n    diff_set = set()\n    max_diff = (N - 1) * D\n    \n    for i in range(N):\n        for j in range(i, N):\n            diff = (X + i * D) - (X + j * D) if i != j else 0\n            if diff > 0:\n                diff_set.add(diff)\n                diff_set.add(-diff)\n                \n    print(len(diff_set) + 2 * (max_diff not in diff_set))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Import necessary package\nn = int(input())\n\n# Initialize a flag to track if Anton performed good\nperformed_good = False\n\n# Process each participant\nfor _ in range(n):\n    name, before, after = input().split()\n    before = int(before)\n    after = int(after)\n    \n    # Check if the participant was red before the contest and improved\n    if before >= 2400 and after > before:\n        performed_good = True\n        break\n\n# Determine the output based on the flag\nif performed_good:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_missed_trains(binary_time):\n    missed_trains = 0\n    time = int(binary_time, 2)\n    k = 0\n    \n    while 4**k < time:\n        missed_trains += 1\n        k += 1\n    \n    return missed_trains\n\n# Example usage based on the problem statement\nbinary_time = input().strip()\nprint(count_missed_trains(binary_time))"}
{"solution": "def min_rows_for_mirrored_matrix(n, m, matrix):\n    # Initialize the result to n, as the maximum possible rows needed is n\n    result = n\n    \n    # Iterate through the matrix from the second row to the middle\n    for i in range(1, (n // 2) + 1):\n        # If the current row is not equal to its mirrored counterpart,\n        # the minimum number of rows cannot be less than the current row index\n        if matrix[i-1] != matrix[n-i]:\n            result = n - i + 1\n            break\n    \n    return result\n\n# Read input\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(min_rows_for_mirrored_matrix(n, m, matrix))"}
{"solution": "def max_acceptable_orders(n, intervals):\n    intervals.sort(key=lambda x: x[1])  # Sort by end times\n    count = 0\n    end_time = 0\n    \n    for interval in intervals:\n        if interval[0] >= end_time:\n            count += 1\n            end_time = interval[1]\n    \n    return count\n\n# Reading input\nn = int(input())\nintervals = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculating and printing the result\nprint(max_acceptable_orders(n, intervals))"}
{"solution": "def can_rearrange(n, k, tables, formulas):\n    prev_table_count = 0\n    prev_formula_count = 0\n    table_streak = 0\n    formula_streak = 0\n    for i in range(n):\n        curr_table_count = tables[i]\n        curr_formula_count = formulas[i]\n        \n        # Calculate new streaks\n        table_streak = prev_formula_count + curr_table_count\n        formula_streak = prev_table_count + curr_formula_count\n        \n        # Check if any streak exceeds k\n        if table_streak > k or formula_streak > k:\n            return \"NO\"\n        \n        # Update previous counts for next iteration\n        prev_table_count = curr_table_count\n        prev_formula_count = curr_formula_count\n    \n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ntables = list(map(int, input().split()))\nformulas = list(map(int, input().split()))\n\n# Solve and print result\nprint(can_rearrange(n, k, tables, formulas))"}
{"solution": "def can_human_win(n, k, coefficients):\n    # Track the positions that are still unknown\n    unknown_positions = [i for i, coeff in enumerate(coefficients) if coeff == '?']\n    \n    # Determine whose turn it is\n    is_computer_turn = len(unknown_positions) % 2 == 0\n    \n    # If it's human's turn and there are no unknowns left, check divisibility\n    if not is_computer_turn and not unknown_positions:\n        P = sum(coefficients[i] * pow(k, i) for i in range(n + 1))\n        return P % k == 0\n    \n    # If it's computer's turn, it can always prevent a loss by setting a coefficient\n    if is_computer_turn:\n        return False\n    \n    # For human's turn, find a move that guarantees victory\n    for pos in unknown_positions:\n        # Calculate what value should be set to ensure divisibility\n        required_value = -sum(coefficients[i] * pow(k, i) for i in range(n + 1) if i != pos) % k\n        if required_value == 0 and pos == 0:\n            continue\n        \n        # If such a move exists, human can win\n        return True\n    \n    # If no such move exists, human cannot guarantee a win\n    return False\n\n# Read input\nn, k = map(int, input().split())\ncoefficients = [input() if line.strip() == '?' else int(input()) for _ in range(n + 1)]\n\n# Determine and print the result\nprint(\"Yes\" if can_human_win(n, k, coefficients) else \"No\")"}
{"solution": "from sympy import primerange\n\nX_2 = int(input())\n\ndef smallest_X0(X_2):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def get_primes_below(n):\n        return list(primerange(2, n))\n\n    primes = get_primes_below(X_2)\n    min_X0 = X_2\n\n    for i in range(len(primes)):\n        for j in range(i + 1, len(primes)):\n            p1 = primes[i]\n            p2 = primes[j]\n\n            # Alice's move\n            X1 = X_2\n            while X1 % p2 == 0 and X1 > p2:\n                X1 //= p2\n\n            if X1 == p2:\n                continue\n\n            # Bob's move\n            X0 = X1\n            while X0 % p1 == 0 and X0 > p1:\n                X0 //= p1\n\n            if X0 == p1:\n                continue\n\n            min_X0 = min(min_X0, X0)\n\n    # Check if X_2 itself is a prime, in which case X_0 = X_2\n    if is_prime(X_2):\n        min_X0 = X_2\n\n    return min_X0\n\nprint(smallest_X0(X_2))"}
{"solution": "import math\n\ndef min_summands(n, p):\n    if p >= n:\n        return -1\n    \n    # Adjust n by p if possible to simplify the problem\n    adjusted_n = n - p\n    if adjusted_n < 0:\n        return -1\n    \n    # Calculate the minimum number of summands\n    max_power = int(math.log(adjusted_n, 2))\n    summands = 0\n    for x in range(max_power, -1, -1):\n        current_value = 2**x + p\n        while adjusted_n >= current_value:\n            adjusted_n -= current_value\n            summands += 1\n            \n    # Check if the final adjusted_n can be represented\n    if adjusted_n > 0:\n        return -1 if adjusted_n + p <= 0 else summands + 1\n    else:\n        return summands\n\n# Read input\nn, p = map(int, input().split())\n\n# Solve and print the result\nprint(min_summands(n, p))"}
{"solution": "def min_possible_number(n, k, s):\n    result = list(s)\n    changed = 0\n    for i in range(n):\n        if changed + (n - i) <= k:\n            break\n        if result[i] != '0' and changed < k:\n            if i == 0:\n                result[i] = '1'\n            else:\n                result[i] = '0'\n            changed += 1\n        elif result[i] != '0':\n            break\n    for i in range(changed < k, n):\n        if k - changed > 0 and result[i] != '0':\n            result[i] = '0'\n            changed += 1\n    return ''.join(result)\n\n# Reading input\nn, k = map(int, input().split())\ns = input()\n\n# Calculating and printing output\nprint(min_possible_number(n, k, s))"}
{"solution": "import math\n\ndef find_min_v(cnt1, cnt2, x, y):\n    lcm = x * y // math.gcd(x, y)\n    cycle = [i for i in range(1, lcm + 1) if i % x != 0 and i % y != 0]\n    cycle_len = len(cycle)\n\n    full_cycles, remainder = divmod(cnt1 + cnt2, cycle_len)\n\n    if remainder == 0:\n        return full_cycles * lcm - 1\n    else:\n        return (full_cycles * lcm + cycle[remainder - 1])\n\ndef main():\n    cnt1, cnt2, x, y = map(int, input().split())\n    print(find_min_v(cnt1, cnt2, x, y))\n\nmain()"}
{"solution": "def final_position(n, sx, sy, dx, dy, t):\n    if t == 0:\n        return sx, sy\n    \n    # Calculate the total change in dx and dy over t seconds\n    total_dx_change = (dx + t) * t // 2\n    total_dy_change = (dy + t) * t // 2\n    \n    # Adjust for the increase in raspberry bushes\n    total_dx_change += t\n    total_dy_change += t\n    \n    # Calculate the final dx and dy\n    final_dx = (dx + total_dx_change) % n\n    final_dy = (dy + total_dy_change) % n\n    \n    # Calculate the final position\n    final_sx = ((sx + final_dx * t) - 1) % n + 1\n    final_sy = ((sy + final_dy * t) - 1) % n + 1\n    \n    return final_sx, final_sy\n\n# Reading input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Calculating and printing the final position\nfinal_sx, final_sy = final_position(n, sx, sy, dx, dy, t)\nprint(final_sx, final_sy)"}
{"solution": "from collections import Counter\n\ndef is_nice_word(s):\n    # Check if it's possible to have a nice word\n    if '?' not in s and len(s) < 26:\n        return False\n    \n    # Count occurrences of each letter and '?'\n    count = Counter(s)\n    \n    # Check if there are too many of any letter other than '?'\n    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n        if count[letter] > 1:\n            return False\n    \n    return True\n\ndef fill_question_marks(s):\n    alphabet = list('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    result = list(s)\n    used_letters = set()\n    \n    i = 0\n    while '?' in result:\n        if result[i] == '?':\n            # Find a letter that hasn't been used yet\n            for letter in alphabet:\n                if letter not in used_letters:\n                    result[i] = letter\n                    used_letters.add(letter)\n                    break\n        i += 1\n    \n    return ''.join(result)\n\ndef solve(s):\n    if is_nice_word(s):\n        filled_s = fill_question_marks(s)\n        # Ensure the filled word has a substring of length 26 with all unique letters\n        for i in range(len(filled_s) - 25):\n            if len(set(filled_s[i:i+26])) == 26:\n                return filled_s\n    return -1\n\n# Reading input\ns = input().strip()\n\n# Solving and printing output\nprint(solve(s))"}
{"solution": "n = int(input())\nweights = list(map(int, input().split()))\n\ntotal_weight = sum(weights)\ncount_200g = weights.count(200)\n\n# If the total weight is odd, it's impossible to divide equally\nif total_weight % 2 != 0:\n    print(\"NO\")\nelse:\n    # If there are an odd number of 200g apples, it's impossible to divide equally\n    if count_200g % 2 != 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")"}
{"solution": "def min_time_to_turn_off_lights(n, m, building):\n    # Initialize DP table\n    dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    for floor in range(1, n + 1):\n        prev_floor_state = building[n - floor]\n        # Calculate the state of rooms on the current floor\n        rooms_state = [int(x) for x in prev_floor_state[1:-1]]\n        \n        for last_room in range(m + 1):\n            # Time taken if starting from the left\n            time_from_left = dp[floor - 1][0]\n            # Time taken if starting from a specific room\n            time_from_room = dp[floor - 1][last_room] if last_room < m else float('inf')\n            \n            # Update DP table based on the state of the rooms\n            for room in range(m):\n                if rooms_state[room]:\n                    # If the light is on, update the DP values\n                    time_from_left += 2 * room + 1\n                    time_from_room += abs(room - last_room) + 1\n                    dp[floor][room] = min(dp[floor][room], time_from_left, time_from_room)\n            # Add the case where the last room visited was the right stairs\n            dp[floor][m] = min(dp[floor][m], time_from_left + 2 * m, time_from_room + m - last_room)\n    \n    return min(dp[n])\n\n# Read input\nn, m = map(int, input().split())\nbuilding = [input() for _ in range(n)]\n\n# Calculate and print the result\nprint(min_time_to_turn_off_lights(n, m, building))"}
{"solution": "from collections import defaultdict, deque\n\ndef min_cost_traps(n, costs, moves):\n    def dfs(node, visited):\n        stack = [node]\n        cycle = []\n        while stack:\n            current = stack[-1]\n            if visited[current] == -1:\n                visited[current] = len(cycle)\n                cycle.append(current)\n                stack.pop()\n                if current in moves:\n                    next_node = moves[current]\n                    if visited[next_node] == -1:\n                        stack.append(next_node)\n                    else:\n                        cycle = cycle[:visited[next_node]] + cycle[visited[next_node]:]\n                        del moves[current]\n                        return cycle\n            else:\n                del stack[-1]\n        return []\n\n    # Find cycles and their costs\n    cycle_costs = []\n    visited = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if visited[i] == -1:\n            cycle = dfs(i, visited)\n            if cycle:\n                cycle_costs.append((sum(costs[node - 1] for node in cycle), len(cycle)))\n\n    # Calculate minimum cost for cycles\n    cycle_costs.sort()\n    min_cost = 0\n    for cost, length in cycle_costs:\n        min_cost += min(cost, sum(sorted(costs[node - 1] for node in cycle)[1:]))\n        break  # Only need to consider one cycle\n\n    # Find connected components outside cycles\n    components = defaultdict(list)\n    for i in range(1, n + 1):\n        if visited[i] == -1:\n            queue = deque([i])\n            while queue:\n                current = queue.popleft()\n                if visited[current] == -1:\n                    visited[current] = 0\n                    components[0].append(current)\n                    if current in moves:\n                        next_node = moves[current]\n                        queue.append(next_node)\n\n    # Calculate minimum cost for connected components\n    component_costs = [min(costs[node - 1] for node in nodes) for nodes in components.values()]\n    min_cost += sum(component_costs)\n\n    return min_cost\n\n# Read input\nn = int(input())\ncosts = list(map(int, input().split()))\nmoves = {i + 1: a for i, a in enumerate(map(int, input().split()))}\n\n# Solve and print output\nprint(min_cost_traps(n, costs, moves))"}
{"solution": "n, a, b = map(int, input().split())\nresult = (a + b - 1) % n + 1\nprint(result)"}
{"solution": "from typing import List\n\ndef min_arithmetic_sequences(arr: List[int]) -> int:\n    n = len(arr)\n    last_known_values = []\n    sequence_count = 0\n    d = [0] * (n + 1)\n    \n    def find_last_known_value(index):\n        for i in range(len(last_known_values) - 1, -1, -1):\n            if last_known_values[i][0] <= index:\n                return i\n        return -1\n    \n    for i in range(n):\n        if arr[i] == -1:\n            continue\n        \n        j = find_last_known_value(i - 1)\n        if j != -1:\n            diff = arr[i] - last_known_values[j][1]\n            d[i] = d[last_known_values[j][0]] + (1 if diff != d[last_known_values[j][0]] else 0)\n        else:\n            d[i] = 1\n        \n        last_known_values.append((i, arr[i]))\n        sequence_count = max(sequence_count, d[i])\n    \n    return sequence_count\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(min_arithmetic_sequences(arr))"}
{"solution": "def max_beauty(n, k, s):\n    left, maxBeauty, changes = 0, 0, 0\n    for right in range(n):\n        # Count the changes needed if we include the current character\n        if s[right] != s[left]:\n            changes += 1\n        # If we exceed k changes, move the left pointer\n        while changes > k:\n            if s[left] != s[left + 1]:\n                changes -= 1\n            left += 1\n        # Update the maximum beauty\n        maxBeauty = max(maxBeauty, right - left + 1)\n    return maxBeauty\n\n# Read input\nn, k = map(int, input().split())\ns = input()\n\n# Compute and print the result\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, seats):\n    total_seats = sum(seats)\n    alice_seats = seats[0]\n    coalition_seats = alice_seats\n    coalition = [1]\n\n    # Check if Alice's party already has a majority\n    if coalition_seats > total_seats // 2:\n        return coalition\n\n    for i in range(1, n):\n        if seats[i] * 2 <= alice_seats:\n            coalition_seats += seats[i]\n            coalition.append(i + 1)\n            if coalition_seats > total_seats // 2:\n                return coalition\n\n    return []\n\n# Read input\nn = int(input())\nseats = list(map(int, input().split()))\n\n# Find and print the coalition\ncoalition = find_coalition(n, seats)\nif not coalition:\n    print(0)\nelse:\n    print(len(coalition))\n    print(' '.join(map(str, coalition)))"}
{"solution": "from math import log2, floor\n\ndef max_reward(n):\n    total_reward = 0.0\n    remaining_opponents = n\n    while remaining_opponents > 0:\n        # Optimal strategy is to eliminate one opponent per question\n        reward_this_round = 1.0 / remaining_opponents\n        total_reward += reward_this_round\n        remaining_opponents -= 1\n    return total_reward\n\n# Reading input\nn = int(input())\n\n# Calculating and printing output\nprint(max_reward(n))"}
{"solution": "def max_children_with_candies(n):\n    kids = []\n    total_candies = n\n    num_kids = 0\n    current_candy = 1\n    \n    while total_candies >= current_candy:\n        kids.append(current_candy)\n        total_candies -= current_candy\n        current_candy += 1\n        num_kids += 1\n    \n    if total_candies > 0:\n        kids[-1] += total_candies\n    \n    return num_kids, kids\n\nn = int(input())\nnum_kids, candies_distribution = max_children_with_candies(n)\n\nprint(num_kids)\nprint(' '.join(map(str, candies_distribution)))"}
{"solution": "n = int(input())\nm = int(input())\n\nresult = m % (2 ** n)\nprint(result)"}
{"solution": "def correct_word(s):\n    vowels = 'aeiouy'\n    i = 0\n    while i < len(s) - 1:\n        if s[i] in vowels and s[i + 1] in vowels:\n            s = s[:i] + s[i+1:]\n        else:\n            i += 1\n    return s\n\nn = int(input())\ns = input()\nresult = correct_word(s)\nprint(result)"}
{"solution": "def max_students(n, a, b, seats):\n    dp = [[0] * 4 for _ in range(n + 1)]\n    dp[0][3] = 0\n    for i in range(1, n + 1):\n        if seats[i - 1] == '*':\n            dp[i][0] = dp[i - 1][0]\n            dp[i][1] = dp[i - 1][1]\n            dp[i][2] = dp[i - 1][2]\n            dp[i][3] = max(dp[i - 1])\n        else:\n            dp[i][0] = dp[i - 1][1]\n            dp[i][1] = dp[i - 1][2] + 1\n            dp[i][2] = dp[i - 1][0] + 1\n            dp[i][3] = max(dp[i - 1])\n    \n    res = max(dp[n])\n    res = min(res, a + b)\n    res = min(res, a * 2 + b)\n    res = min(res, a + b * 2)\n    return res\n\n# Reading input\nn, a, b = map(int, input().split())\nseats = input()\n\n# Calculating and printing output\nprint(max_students(n, a, b, seats))"}
{"solution": "from sympy import symbols, solve, Eq\n\ndef find_x_y(r):\n    x, y = symbols('x y', integer=True)\n    # Define the equation H(x, y) = r\n    equation = Eq(x**2 + 2*x*y + x + 1, r)\n\n    # Solve the equation for y in terms of x\n    y_expr = solve(equation, y)\n\n    # Check for the smallest x that gives a positive integer y\n    for x_val in range(1, int(r**0.5) + 1):\n        y_val = y_expr[0].subs(x, x_val)\n        if y_val.is_integer and y_val > 0:\n            return x_val, int(y_val)\n    return \"NO\"\n\n# Read input\nr = int(input())\n\n# Find x and y or determine NO\nresult = find_x_y(r)\n\n# Print the result\nprint(result[0], result[1]) if isinstance(result, tuple) else print(result)"}
{"solution": "from itertools import combinations\n\ndef distribute_balloons(packets):\n    n = len(packets)\n    for k in range(1, n):\n        for combo in combinations(range(n), k):\n            grigory_sum = sum(packets[i] for i in combo)\n            andrew_sum = sum(packets) - grigory_sum\n            if grigory_sum != andrew_sum:\n                return k, combo\n    return -1\n\ndef main():\n    n = int(input())\n    packets = list(map(int, input().split()))\n\n    result = distribute_balloons(packets)\n\n    if result == -1:\n        print(-1)\n    else:\n        k, combo = result\n        print(k)\n        print(' '.join(map(str, combo + 1)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_unique_digits(n):\n    # Calculate the minimum number of unique digits\n    if n < 10:\n        return [n], [str(n)]\n    unique_count = 1 if n % 9 == 0 else 2\n    digits = [9] * (n // 9)\n    if n % 9 != 0:\n        digits.append(n % 9)\n    return digits, list(map(str, digits))\n\n# Reading input\nn = int(input())\n\n# Calculating the result\ndigits, output_digits = min_unique_digits(n)\n\n# Printing the result\nprint(len(digits))\nprint(' '.join(output_digits))"}
{"solution": "from math import sqrt\nfrom collections import Counter\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef max_simple_subset(arr):\n    prime_sums = set()\n    element_counts = Counter(arr)\n    \n    # Identify all unique elements\n    unique_elements = list(element_counts.keys())\n    unique_elements.sort(reverse=True)\n    \n    result = []\n    \n    for elem in unique_elements:\n        # Check if adding this element would violate the prime sum condition\n        valid = True\n        for r_elem in result:\n            if not is_prime(elem + r_elem):\n                valid = False\n                break\n        \n        # If valid, add the element and update prime sums\n        if valid:\n            result.extend([elem] * min(2, element_counts[elem]))\n    \n    # Prepare the output\n    print(len(result))\n    print(' '.join(map(str, result)))\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Solving and printing output\nmax_simple_subset(arr)"}
{"solution": "def greatest_beautiful_divisor(n):\n    max_divisor = 1\n    k = 1\n    while True:\n        beautiful_number = (2**k - 1) * (2**k)\n        if beautiful_number > n:\n            break\n        if n % beautiful_number == 0:\n            max_divisor = beautiful_number\n        k += 1\n    return max_divisor\n\nn = int(input())\nprint(greatest_beautiful_divisor(n))"}
{"solution": "3\nMOD = 10**9 + 7\n\ndef compute_dp():\n    dp = [[0 for _ in range(10)] for _ in range(2001)]\n    dp[0][0] = 1  # Base case: one way to form a 0-digit number (empty string)\n    \n    for length in range(1, len(s) + 1):\n        for last_digit in range(10):\n            for new_digit in range(10):\n                if (new_digit == d and length % 2 == 0) or new_digit != d:\n                    dp[length][last_digit] += dp[length - 1][new_digit]\n            dp[length][last_digit] %= MOD\n    \n    return dp\n\ndef count_numbers(num_str, m, d):\n    dp = compute_dp()\n    total_count = 0\n    num_length = len(num_str)\n    for i, digit in enumerate(num_str):\n        digit = int(digit)\n        for prev_digit in range(10):\n            if i % 2 == 0 and prev_digit == d:\n                continue  # Skip if trying to extend with d on an odd position\n        \n            valid_digits = range(int(digit) + 1) if i < num_length else range(int(digit) + 1)\n            for next_digit in valid_digits:\n                if (next_digit == d and i % 2 == 0) or next_digit != d:\n                    if i == num_length:\n                        # For the exact length, we need to ensure divisibility by m\n                        if (prev_digit * (10 ** (num_length - i - 1)) + next_digit) % m == 0:\n                            total_count += dp[num_length - i - 1][prev_digit]\n                            total_count %= MOD\n                    else:\n                        # For shorter lengths, just add the counts\n                        total_count += dp[num_length - i - 1][prev_digit]\n                        total_count %= MOD\n    \n    return total_count\n\nm, d = map(int, input().split())\ns = input().strip()\nt = input().strip()\n\nresult = count_numbers(t, m, d) - count_numbers(s, m, d) + (1 if count_numbers(s, m, d) > 0 else 0)\nprint(result % MOD)"}
{"solution": "def last_child_home(n, m, desires):\n    queue = list(range(1, n + 1))\n    while queue:\n        child = queue.pop(0)\n        desires[child - 1] -= m\n        if desires[child - 1] > 0:\n            queue.append(child)\n        else:\n            last = child\n    return last\n\n# Reading input\nn, m = map(int, input().split())\ndesires = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(last_child_home(n, m, desires))"}
{"solution": "def min_bills(n):\n    denominations = [100, 20, 10, 5, 1]\n    count = 0\n    for denom in denominations:\n        count += n // denom\n        n %= denom\n    return count\n\n# Reading input\nn = int(input())\n\n# Calculating and printing output\nprint(min_bills(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial(n):\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = i * fact[i - 1] % MOD\n    return fact\n\ndef inverse_factorial(n, fact):\n    inv_fact = [1] * (n + 1)\n    inv_fact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 1, -1):\n        inv_fact[i - 1] = i * inv_fact[i] % MOD\n    return inv_fact\n\ndef binomial_coefficient(n, k, fact, inv_fact):\n    return fact[n] * inv_fact[k] * inv_fact[n - k] % MOD\n\ndef count_good_permutations(n, k):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    fact = factorial(n)\n    inv_fact = inverse_factorial(n, fact)\n\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            dp[i][j] = (dp[i - 1][j] + (dp[i - 1][j - 1] if j > 0 else 0)) % MOD\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n                dp[i][j] %= MOD\n            if j < i:\n                dp[i][j] += dp[i - 1][j]\n                dp[i][j] %= MOD\n\n    result = 0\n    for bad in range(k + 1):\n        good = i - bad\n        if good % 2 == 0:\n            result += dp[bad][good // 2] * binomial_coefficient(n - bad, good // 2, fact, inv_fact)\n            result %= MOD\n    return result\n\n# Reading input here\nn, k = map(int, input().split())\nprint(count_good_permutations(n, k))"}
{"solution": "from collections import Counter\nfrom heapq import heapify, heappop, heappush\n\ndef max_beauty(n, k, beauties, colors):\n    color_counts = Counter(colors)\n    color_beauties = {color: [] for color in set(colors)}\n    \n    # Populate color_beauties with negative beauty values for min heap\n    for beauty, color in zip(beauties, colors):\n        heappush(color_beauties[color], -beauty)\n    \n    # Case 1: Two different colors\n    max_beauty_two_colors = -float('inf')\n    for color1 in color_beauties:\n        for color2 in color_beauties:\n            if color1 != color2:\n                beauty_sum = sum(-heappop(color_beauties[color1]) for _ in range(min(k, len(color_beauties[color1]))))\n                beauty_sum += sum(-heappop(color_beauties[color2]) for _ in range(k - min(k, len(color_beauties[color1]))))\n                max_beauty_two_colors = max(max_beauty_two_colors, beauty_sum)\n                # Push back the popped elements\n                for _ in range(min(k, len(color_beauties[color1]))):\n                    heappush(color_beauties[color1], -(-beauty_sum % k))\n                for _ in range(k - min(k, len(color_beauties[color1]))):\n                    heappush(color_beauties[color2], -(-beauty_sum % k))\n    \n    # Case 2: Three different colors\n    max_beauty_three_colors = -float('inf')\n    if len(color_beauties) == 3:\n        beauty_sum = 0\n        for color in color_beauties:\n            beauty_sum += sum(-heappop(color_beauties[color]) for _ in range(k // 3))\n        max_beauty_three_colors = beauty_sum + sum(-heappop(color_beauties[color]) for color in color_beauties for _ in range(k % 3))\n    \n    # Case 3: One color (not possible due to constraints)\n    max_beauty_one_color = -1\n    \n    result = max(max_beauty_two_colors, max_beauty_three_colors, max_beauty_one_color)\n    return result if result != -float('inf') else -1\n\n# Reading input\nn, k = map(int, input().split())\nbeauties = list(map(int, input().split()))\ncolors = input()\n\n# Calculating and printing the output\nprint(max_beauty(n, k, beauties, colors))"}
{"solution": "from math import gcd\n\ndef continued_to_fraction(a):\n    p, q = a[-1], 1\n    for ai in reversed(a[:-1]):\n        p, q = ai * p + q, p\n    return p, q\n\ndef simplify_fraction(p, q):\n    g = gcd(p, q)\n    return p // g, q // g\n\ndef check_equality(p1, q1, p2, q2):\n    p1, q1 = simplify_fraction(p1, q1)\n    p2, q2 = simplify_fraction(p2, q2)\n    return \"YES\" if p1 == p2 and q1 == q2 else \"NO\"\n\ndef solve():\n    p, q = map(int, input().split())\n    n = int(input())\n    a = list(map(int, input().split()))\n    p2, q2 = continued_to_fraction(a)\n    result = check_equality(p, q, p2, q2)\n    print(result)\n\nsolve()"}
{"solution": "def shift_stick(expression):\n    parts = expression.split('+=')\n    a_sticks = len(parts[0])\n    b_sticks = len(parts[1].split('=')[0])\n    c_sticks = len(parts[1].split('=')[1])\n\n    correct_sum = a_sticks + b_sticks\n\n    # Case 1: No shift needed\n    if correct_sum == c_sticks:\n        return expression\n\n    # Case 2: Shift from C to A or B\n    if correct_sum + 1 == c_sticks:\n        return f\"{a_sticks + 1}+={c_sticks - 1}\"\n    if correct_sum - 1 == c_sticks:\n        return f\"{a_sticks}+={c_sticks - 1}\"\n\n    # Case 3: Shift from A or B to C\n    if correct_sum + 1 == c_sticks + 1:\n        return f\"{a_sticks - 1}+={c_sticks + 1}\"\n    if correct_sum - 1 == c_sticks + 1:\n        return f\"{a_sticks}+={c_sticks + 1}\"\n\n    # Impossible case\n    return \"Impossible\"\n\n# Reading input\nexpression = input().replace('|', '')\n\n# Processing and printing output\nresult = shift_stick(expression)\nprint(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial_mod(n):\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    return fact\n\ndef inverse_factorial_mod(fact, n):\n    inv_fact = [1] * (n + 1)\n    inv_fact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        inv_fact[i - 1] = inv_fact[i] * i % MOD\n    return inv_fact\n\ndef combination_mod(n, k, fact, inv_fact):\n    return fact[n] * inv_fact[k] * inv_fact[n - k] % MOD\n\ndef count_permutations(n, k):\n    fact = factorial_mod(n)\n    inv_fact = inverse_factorial_mod(fact, n)\n    \n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i * i, -1, -1):\n            for d in range(max(0, j - 2 * i), min(j, i - 1) + 1, 2):\n                dp[i][j] += dp[i - 1][j - d] * combination_mod(i - 1, (d + i - 1 - d) // 2, fact, inv_fact)\n                dp[i][j] %= MOD\n    \n    return dp[n][k]\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(count_permutations(n, k))"}
{"solution": "from collections import defaultdict\nimport math\n\ndef find_gcd(x, y):\n    while(y):\n        x, y = y, x % y\n    return x\n\ndef find_lcm(x, y):\n    return (x*y)//find_gcd(x,y)\n\ndef lcm_list(numbers):\n    lcm = numbers[0]\n    for i in numbers[1:]:\n        lcm = find_lcm(lcm, i)\n    return lcm\n\ndef solve(N, points):\n    # Calculate differences\n    diffs_x = [abs(points[i][0] - points[(i+1)%N][0]) for i in range(N)]\n    diffs_y = [abs(points[i][1] - points[(i+1)%N][1]) for i in range(N)]\n    \n    # Find LCM of differences\n    lcm_x = lcm_list(diffs_x)\n    lcm_y = lcm_list(diffs_y)\n    \n    # Determine if a solution exists\n    if any(x % lcm_x != 0 for x in diffs_x) or any(y % lcm_y != 0 for y in diffs_y):\n        return [-1]\n    \n    m = 2 * int(math.log(max(lcm_x, lcm_y), 2)) + 2\n    d = [lcm_x] + [lcm_y] + [1] * (m - 2)\n    \n    # Generate configurations\n    configs = []\n    for x, y in points:\n        config = ''\n        if x < 0:\n            config += 'L' * int(abs(x) // lcm_x)\n        else:\n            config += 'R' * int(abs(x) // lcm_x)\n        if y < 0:\n            config += 'D' * int(abs(y) // lcm_y)\n        else:\n            config += 'U' * int(abs(y) // lcm_y)\n        config += 'R' * (m - len(config))\n        configs.append(config)\n    \n    return [m, *d, *configs]\n\n# Reading input\nN = int(input())\npoints = [list(map(int, input().split())) for _ in range(N)]\n\n# Solving and printing output\nresult = solve(N, points)\nfor line in result:\n    if isinstance(line, list):\n        print(' '.join(map(str, line)))\n    else:\n        print(line)"}
{"solution": "n = int(input())\ns = input()\npattern = 'ogo'\nresult = []\n\ndef find_pattern(s, pattern):\n    while len(pattern) <= len(s) and s.endswith(pattern):\n        s = s[:-len(pattern)]\n        pattern += 'go'\n    return s\n\ni = 0\nwhile i < len(s):\n    if s[i:i+len(pattern)] == pattern:\n        s = s[:i] + s[i+len(pattern):]\n        s = find_pattern(s, pattern)\n        result.append('***')\n    else:\n        result.append(s[i])\n        i += 1\n\nprint(''.join(result))"}
{"solution": "from math import sqrt\n\nMOD = 10**9 + 7\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return set(factors)\n\ndef max_power(n, p):\n    power = 0\n    while n % p == 0:\n        power += 1\n        n //= p\n    return p ** power\n\ndef compute_product(x, n):\n    result = 1\n    primes_x = prime_factors(x)\n    for y in range(1, n + 1):\n        for p in primes_x:\n            result *= max_power(y, p)\n            result %= MOD\n    return result\n\nx, n = map(int, input().split())\nprint(compute_product(x, n))"}
{"solution": "def s(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    # Upper limit for search, considering the maximum possible value for s(x)\n    upper_limit = 10**9\n    for x in range(1, upper_limit):\n        if x == b * s(x)**a + c:\n            solutions.append(x)\n    solutions.sort()\n    return solutions\n\ndef main():\n    a, b, c = map(int, input().split())\n    solutions = find_solutions(a, b, c)\n    print(len(solutions))\n    if solutions:\n        print(\" \".join(map(str, solutions)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import Counter\n\ndef can_solve_with_one_rotation(colors):\n    color_counts = Counter(colors)\n    \n    # Check if all colors appear exactly 4 times\n    if any(count != 4 for count in color_counts.values()):\n        return False\n    \n    faces = [\n        colors[0:4], colors[4:8], colors[8:12], colors[12:16],\n        colors[16:20], colors[20:24]\n    ]\n    \n    def is_solved(face):\n        return len(set(face)) == 1\n    \n    # Check if cube is already solved\n    if all(is_solved(face) for face in faces):\n        return False\n    \n    # Rotate each face and check if it solves the cube\n    for face in faces:\n        rotated_face = face[1:] + face[:1]\n        if is_solved(rotated_face):\n            return True\n        rotated_face = face[2:] + face[:2]\n        if is_solved(rotated_face):\n            return True\n        rotated_face = face[3:] + face[:3]\n        if is_solved(rotated_face):\n            return True\n    \n    return False\n\n# Read input\ncolors = list(map(int, input().split()))\n\n# Solve and print result\nprint(\"YES\" if can_solve_with_one_rotation(colors) else \"NO\")"}
{"solution": "def find_hacks(p, x, y):\n    def get_position(score):\n        i = (score // 50) % 475\n        for _ in range(25):\n            i = (i * 96 + 42) % 475\n            pos = 26 + i\n            if pos == p:\n                return score\n        return -1\n\n    if x >= y:\n        # Check if the current score wins a T-shirt\n        if get_position(x) != -1:\n            return 0\n\n    # Calculate the minimum number of successful hacks\n    min_hacks = float('inf')\n    for successful_hacks in range(26):  # Max 25 successful hacks needed to win a T-shirt\n        for unsuccessful_hacks in range(21):  # Max 20000 points, losing 50 per unsuccessful hack\n            new_score = x + successful_hacks * 100 - unsuccessful_hacks * 50\n            if new_score >= y and get_position(new_score) != -1:\n                min_hacks = min(min_hacks, successful_hacks)\n\n    return min_hacks\n\n# Read input\np, x, y = map(int, input().split())\n\n# Output the result\nprint(find_hacks(p, x, y))"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate the minimum distance between the three houses\nmin_distance = min(a, b, c)\n\n# If n is 1, Winnie doesn't need to move\nif n == 1:\n    print(0)\nelse:\n    # Calculate the initial move from Rabbit's house to either Owl's or Eeyore's\n    initial_move = min(a, b)\n    \n    # If the minimum distance is between Owl and Eeyore, calculate the total distance\n    if min_distance == c:\n        total_distance = initial_move + (n - 2) * c\n    else:\n        # If the minimum distance is between Rabbit and one of the others, calculate the total distance\n        total_distance = (n - 1) * min_distance\n    \n    print(total_distance)"}
{"solution": "x1, x2, x3 = map(int, input().split())\n\n# Sort the coordinates to find the median\ncoordinates = sorted([x1, x2, x3])\n\n# The optimal meeting point is the middle coordinate\nmeeting_point = coordinates[1]\n\n# Calculate the total distance\ntotal_distance = abs(meeting_point - x1) + abs(meeting_point - x2) + abs(meeting_point - x3)\n\nprint(total_distance)"}
{"solution": "from collections import Counter\nimport sys\n\ninput = sys.stdin.readline\n\ndef min_operations(n, x, arr):\n    bit_counts = [0] * 20  # Assuming max value is 100,000, which fits in 17 bits but using 20 for safety\n    x_bits = bin(x)[2:]\n    \n    for num in arr:\n        num_bits = bin(num)[2:]\n        for i in range(len(x_bits)):\n            if len(num_bits) > i and x_bits[-(i + 1)] == '1' and num_bits[-(i + 1)] == '0':\n                bit_counts[i] += 1\n    \n    # Count the frequency of each bit position in x that could potentially change\n    bit_freq = Counter(bit_counts)\n    \n    min_ops = float('inf')\n    for i in range(len(x_bits)):\n        if x_bits[-(i + 1)] == '1' and bit_freq[i] >= 2:\n            min_ops = min(min_ops, n - bit_freq[i])\n    \n    if min_ops == float('inf'):\n        return -1\n    else:\n        return min_ops\n\n# Reading input\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Solving and printing output\nprint(min_operations(n, x, arr))"}
{"solution": "def find_plus_shape(h, w, picture):\n    def valid(x, y):\n        return 0 <= x < h and 0 <= y < w\n    \n    def dfs(x, y):\n        if not valid(x, y) or picture[x][y] == '.':\n            return False\n        picture[x][y] = '.'\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if not valid(nx, ny) or picture[nx][ny] == '.':\n                continue\n            if not dfs(nx, ny):\n                return False\n        return True\n    \n    center = None\n    for i in range(h):\n        for j in range(w):\n            if picture[i][j] == '*':\n                if center is None:\n                    center = (i, j)\n                else:\n                    # Found another center, multiple shapes or invalid \"+\"\n                    return \"NO\"\n    \n    if center is None:\n        return \"NO\"  # No '*' found, invalid \"+\"\n    \n    # Check for the presence of '*' in all four directions from the center\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = center[0] + dx, center[1] + dy\n        if not valid(nx, ny) or picture[nx][ny] == '.':\n            return \"NO\"  # No extension in one of the directions\n    \n    # Verify that all '*' are part of the \"+\"\n    for i in range(h):\n        for j in range(w):\n            if picture[i][j] == '*':\n                if not dfs(i, j):\n                    return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nh, w = map(int, input().split())\npicture = [input() for _ in range(h)]\n\n# Solve and print output\nprint(find_plus_shape(h, w, picture))"}
{"solution": "def solve(n, a, b):\n    if n < a + b - 1:\n        return \"NO\"\n    \n    result = [[\"0\" for _ in range(n)] for _ in range(n)]\n    \n    # Create 'a' connected components in the graph\n    start = 0\n    for i in range(a - 1):\n        for j in range(start, min(start + b, n)):\n            for k in range(j + 1, n):\n                result[j][k] = \"1\"\n                result[k][j] = \"1\"\n        start += b\n    \n    # Connect the last component\n    for i in range(start, n):\n        for j in range(i + 1, n):\n            result[i][j] = \"1\"\n            result[j][i] = \"1\"\n    \n    return \"YES\", result\n\ndef print_matrix(matrix):\n    for row in matrix:\n        print(\"\".join(row))\n\ndef main():\n    n, a, b = map(int, input().split())\n    answer, matrix = solve(n, a, b)\n    print(answer)\n    if answer == \"YES\":\n        print_matrix(matrix)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_problems_needed(c, d, n, m, k):\n    # Calculate the number of people already selected (k)\n    # and the target number of people to select (n * m - k).\n    target = n * m - k\n    \n    # Calculate the minimum number of main rounds needed.\n    main_rounds = -(-target // n)  # Ceiling division to get at least target people.\n    \n    # Calculate the minimum number of problems used in main rounds.\n    main_problems = main_rounds * c\n    \n    # Calculate the remaining spots after main rounds.\n    remaining_spots = max(0, target - main_rounds * n)\n    \n    # Calculate the minimum number of additional rounds needed.\n    additional_rounds = -(-remaining_spots // 1)  # Ceiling division.\n    \n    # Calculate the minimum number of problems used in additional rounds.\n    additional_problems = additional_rounds * d\n    \n    # Return the total minimum number of problems needed.\n    return main_problems + additional_problems\n\n# Read input\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\n# Print output\nprint(min_problems_needed(c, d, n, m, k))"}
{"solution": "from collections import Counter\n\ndef find_grid_path(s):\n    # Count occurrences of each character\n    char_count = Counter(s)\n    \n    # Check if 'S' is present since it's a special case\n    if 'S' not in char_count:\n        return \"Impossible\"\n    \n    # Initialize the grid\n    grid = [['' for _ in range(13)] for _ in range(2)]\n    \n    # Mapping of characters to their positions\n    pos_map = {}\n    row, col = 0, 0\n    \n    # Place characters in the grid\n    for char in sorted(char_count.keys()):\n        if char == 'S':\n            # Special case for 'S'\n            grid[row][col] = 'S'\n            pos_map['S'] = (row, col)\n            col += 1\n        else:\n            # Place other characters\n            for _ in range(char_count[char]):\n                if col == 13:\n                    row += 1\n                    col = 0\n                grid[row][col] = char\n                pos_map[char] = (row, col)\n                col += 1\n    \n    # Check if the path is possible\n    prev_char = s[0]\n    for char in s[1:]:\n        if not (is_adjacent(pos_map[prev_char], pos_map[char]) or\n                (prev_char == 'S' and char_count[char] > 1)):\n            return \"Impossible\"\n        prev_char = char\n    \n    # Convert grid to strings\n    return '\\n'.join(''.join(row) for row in grid)\n\ndef is_adjacent(pos1, pos2):\n    r1, c1 = pos1\n    r2, c2 = pos2\n    return abs(r1 - r2) <= 1 and abs(c1 - c2) <= 1 and not (r1 == r2 and c1 == c2)\n\n# Read input\ns = input().strip()\n\n# Solve and print the result\nprint(find_grid_path(s))"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return \"=\"\n    elif x > y:\n        x, y = y, x\n    # Using logarithms to avoid large number arithmetic\n    # Compare y * log(x) with x * log(y)\n    if y * math.log(x) > x * math.log(y):\n        return \">\"\n    else:\n        return \"<\"\n\n# Reading input\nx, y = map(int, input().split())\n\n# Printing the result\nprint(compare_powers(x, y))"}
{"solution": "import math\n\ndef max_balloons(r, h):\n    # Calculate the volume of the cupboard\n    cupboard_volume = 2 * r * h + (math.pi * r**2) / 2\n    \n    # Calculate the volume of a single balloon\n    balloon_volume = (4/3) * math.pi * (r/2)**3\n    \n    # Calculate the maximum number of balloons that can fit\n    max_balloons = int(cupboard_volume // balloon_volume)\n    \n    return max_balloons\n\n# Read input\nr, h = map(int, input().split())\n\n# Calculate and print the result\nprint(max_balloons(r, h))"}
{"solution": "from collections import Counter\n\n# Reading input\nnumbers = list(map(int, input().split()))\n\n# Counting occurrences of each number\ncounts = Counter(numbers)\n\n# Tracking if we can remove 2 or 3 cards\nremoved_two_or_three = False\n\n# Calculating the sum of numbers to keep\ntotal_sum = sum(numbers)\nfor number, count in counts.items():\n    if count >= 3:\n        total_sum -= 3 * number\n        removed_two_or_three = True\n        break\n    elif count == 2 and not removed_two_or_three:\n        total_sum -= 2 * number\n        removed_two_or_three = True\n\n# Printing the result\nprint(total_sum)"}
{"solution": "def min_distance(n, a, x):\n    x.sort()\n    if n == 1:\n        return 0\n    if n == 2:\n        return min(abs(x[0] - a), abs(x[1] - a)) + abs(x[1] - x[0])\n    \n    start_idx = find_closest(x, a)\n    \n    # If starting point is closest to the leftmost checkpoint\n    left_distance = abs(x[0] - a) + sum(abs(x[i+1] - x[i]) for i in range(n-1))\n    \n    # If starting point is closest to the rightmost checkpoint\n    right_distance = abs(x[-1] - a) + sum(abs(x[i] - x[i-1]) for i in range(1, n))\n    \n    # If starting point is between two checkpoints\n    mid_distance = abs(x[start_idx] - a) + sum(abs(x[i] - x[i-1]) for i in range(1, n) if i != start_idx)\n    \n    return min(left_distance, right_distance, mid_distance)\n\ndef find_closest(x, a):\n    idx = 0\n    for i, val in enumerate(x):\n        if val >= a:\n            idx = i\n            break\n    return idx\n\n# Reading input\nn, a = map(int, input().split())\nx = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(min_distance(n, a, x))"}
{"solution": "import math\n\ndef s(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_smallest_root(n):\n    max_x = int(math.sqrt(n)) + 1000\n    for x in range(1, max_x + 1):\n        if x**2 + s(x) * x - n == 0:\n            return x\n    return -1\n\nn = int(input())\nprint(find_smallest_root(n))"}
{"solution": "from datetime import datetime, timedelta\n\ndef calculate_bedtime(current_time: str, sleep_duration: str) -> str:\n    \"\"\"\n    Calculates the bedtime based on the current time and the duration of sleep.\n    \n    Parameters:\n    current_time (str): The current time in \"hh:mm\" format.\n    sleep_duration (str): The duration of sleep in \"hh:mm\" format.\n    \n    Returns:\n    str: The bedtime in \"hh:mm\" format.\n    \"\"\"\n    # Convert strings to datetime objects\n    current_time_obj = datetime.strptime(current_time, \"%H:%M\")\n    sleep_duration_obj = datetime.strptime(sleep_duration, \"%H:%M\")\n    \n    # Calculate bedtime\n    bedtime = current_time_obj - timedelta(hours=sleep_duration_obj.hour, minutes=sleep_duration_obj.minute)\n    \n    # Adjust for crossing midnight\n    if bedtime.hour < 0:\n        bedtime = bedtime + timedelta(hours=24)\n    \n    # Format and return the result\n    return bedtime.strftime(\"%H:%M\")\n\n# Read input\ncurrent_time = input()\nsleep_duration = input()\n\n# Calculate and print the bedtime\nprint(calculate_bedtime(current_time, sleep_duration))"}
{"solution": "from itertools import accumulate\n\ndef max_mean_subsegment_length(n, arr):\n    \"\"\"\n    Finds the length of the longest subsegment with the maximum arithmetic mean.\n    \n    :param n: Length of the array.\n    :param arr: The array of integers.\n    :return: Length of the longest subsegment with maximum arithmetic mean.\n    \"\"\"\n    prefix_sums = list(accumulate(arr, initial=0))\n    best_avg, best_len = 0.0, 0\n    dp = [float('-inf')] * (n + 1)\n    dp[0] = 0\n\n    for r in range(1, n + 1):\n        for l in reversed(range(r + 1)):\n            current_avg = (prefix_sums[r] - prefix_sums[l]) / (r - l)\n            if current_avg > best_avg:\n                best_avg = current_avg\n                best_len = r - l\n                break\n            dp[r] = max(dp[r], dp[l] + current_avg)\n\n    return best_len\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Printing output\nprint(max_mean_subsegment_length(n, arr))"}
{"solution": "MOD = 998244353\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef comb(n, k):\n    if k > n:\n        return 0\n    res = 1\n    for i in range(k):\n        res = res * (n - i) % MOD * modinv(i + 1) % MOD\n    return res\n\ndef count_ways(n, m, k):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            dp[i][j] = (dp[i - 1][j] * (m - j) + dp[i - 1][j - 1] * j) % MOD\n    return dp[n][k] * m % MOD\n\n# Reading input\nn, m, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(count_ways(n, m, k))"}
{"solution": "def is_magic_number(n):\n    magic_numbers = [1, 14, 144]\n    def check(magic, remaining):\n        if remaining == 0:\n            return True\n        for num in magic_numbers:\n            if remaining >= num and check(magic + [num], remaining - num):\n                return True\n        return False\n\n    return \"YES\" if check([], n) else \"NO\"\n\n# Read input\nn = int(input())\n\n# Output result\nprint(is_magic_number(n))"}
{"solution": "def min_moves_to_corner(n, m, i, j, a, b):\n    # Calculate the distance to each corner\n    corners = [(1, m), (n, 1), (n, m), (1, 1)]\n    moves = []\n\n    for corner in corners:\n        x_diff = abs(corner[0] - i)\n        y_diff = abs(corner[1] - j)\n\n        # Adjust distances to be divisible by a and b\n        x_moves = ((x_diff + a - 1) // a) * a\n        y_moves = ((y_diff + b - 1) // b) * b\n\n        # Check if the moves can be made within the constraints\n        if (x_moves % a == 0 and y_moves % b == 0 and\n                (x_moves + y_moves) % (a + b) == 0 and\n                (x_moves - x_diff) % (2 * a) == 0 and\n                (y_moves - y_diff) % (2 * b) == 0):\n            moves.append((x_moves + y_moves) // (a + b))\n\n    if not moves:\n        return \"Poor Inna and pony!\"\n    else:\n        return min(moves)\n\n# Read input\nn, m, i, j, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(min_moves_to_corner(n, m, i, j, a, b))"}
{"solution": "def max_removals(s):\n    changes = True\n    alpha_order = 'abcdefghijklmnopqrstuvwxyz'\n    removed = 0\n\n    while changes and len(s) > 1:\n        changes = False\n        max_char = 'a'\n        max_index = -1\n\n        for i in range(len(s)):\n            if i == 0 and s[i] == alpha_order[alpha_order.index(s[i + 1]) + 1]:\n                if s[i] >= max_char:\n                    max_char = s[i]\n                    max_index = i\n            elif i == len(s) - 1 and s[i] == alpha_order[alpha_order.index(s[i - 1]) + 1]:\n                if s[i] >= max_char:\n                    max_char = s[i]\n                    max_index = i\n            elif 0 < i < len(s) - 1 and (s[i] == alpha_order[alpha_order.index(s[i + 1]) + 1] or s[i] == alpha_order[alpha_order.index(s[i - 1]) + 1]):\n                if s[i] >= max_char:\n                    max_char = s[i]\n                    max_index = i\n\n        if max_index != -1:\n            s = s[:max_index] + s[max_index + 1:]\n            removed += 1\n            changes = True\n\n    return removed\n\n# Reading input\nlength = int(input())\ns = input()\n\n# Calculating and printing output\nprint(max_removals(s))"}
{"solution": "from bisect import bisect_left\n\ndef possible_combinations(bills, target, max_bills):\n    min_bills = float('inf')\n    for i, bill in enumerate(bills):\n        for count in range(1, max_bills + 1):\n            remaining = target - bill * count\n            if remaining == 0:\n                min_bills = min(min_bills, count)\n                break\n            if remaining > 0:\n                position = bisect_left(bills, remaining)\n                if position < len(bills) and bills[position] == remaining:\n                    min_bills = min(min_bills, count + 1)\n    return min_bills if min_bills != float('inf') else -1\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    bills = list(map(int, input().split()))\n    q = int(input())\n\n    for _ in range(q):\n        target = int(input())\n        print(possible_combinations(bills, target, k))"}
{"solution": "import math\n\ndef find_min_time(s, x1, x2, t1, t2, p, d):\n    if t2 <= t1:\n        return abs(x2 - x1) * t2\n\n    def meet_time(a, b, va, vb):\n        if a == b:\n            return 0\n        return abs(a - b) / (va + vb)\n\n    def next_meet(a, b, va, vb, dir):\n        if dir == 1:\n            if a < b:\n                return meet_time(a, b, va, vb)\n            else:\n                return (s - a + b) / (vb - va)\n        else:\n            if a > b:\n                return meet_time(a, b, va, vb)\n            else:\n                return (a - b + s) / (vb - va)\n\n    def time_to_catch_up(x, p, dir):\n        if (x1 < x2) == (dir == 1):\n            if (x < x1) == (dir == -1):\n                return next_meet(x, p, t2, t1, dir)\n            else:\n                return 0\n        else:\n            if (x > x1) == (dir == 1):\n                return next_meet(x, p, t2, t1, dir)\n            else:\n                return 0\n\n    def time_to_reach(x):\n        if x1 < x2:\n            if x > x2:\n                return (s + x1 - x2) * t2\n            return abs(x - x2) * t2\n        else:\n            if x < x2:\n                return (s + x2 - x1) * t2\n            return abs(x - x2) * t2\n\n    min_time = float('inf')\n    curr_time = 0\n    while True:\n        catch_up_time = time_to_catch_up(x1, p, d)\n        if catch_up_time == 0:\n            break\n        curr_time += catch_up_time\n        if x1 < x2:\n            if d == 1:\n                p += catch_up_time * t1\n                if p >= x2:\n                    min_time = min(min_time, curr_time + (p - x2) * t1)\n                else:\n                    min_time = min(min_time, curr_time + time_to_reach(p))\n            else:\n                p -= catch_up_time * t1\n                if p <= x2:\n                    min_time = min(min_time, curr_time + (x2 - p) * t1)\n                else:\n                    min_time = min(min_time, curr_time + time_to_reach(p))\n        else:\n            if d == -1:\n                p -= catch_up_time * t1\n                if p <= x2:\n                    min_time = min(min_time, curr_time + (x2 - p) * t1)\n                else:\n                    min_time = min(min_time, curr_time + time_to_reach(p))\n            else:\n                p += catch_up_time * t1\n                if p >= x2:\n                    min_time = min(min_time, curr_time + (p - x2) * t1)\n                else:\n                    min_time = min(min_time, curr_time + time_to_reach(p))\n\n        if p >= s:\n            p = s - (p - s)\n            d = -1\n        elif p <= 0:\n            p = -(p)\n            d = 1\n\n    return min(curr_time + abs(x1 - x2) * t2, min_time)\n\n# Reading input\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Calculating and printing the result\nprint(find_min_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "import math\n\nn, x = map(int, input().split())\n\ncount = 0\nmax_i = min(n, x)\nfor i in range(1, max_i + 1):\n    if x % i == 0 and x // i <= n:\n        count += 1\n\nprint(count)"}
{"solution": "def generate_password(n, k):\n    password = []\n    for i in range((n+1)//2):\n        password.append(chr(97 + i % k))\n    if n % 2 != 0:\n        password.append(chr(97 + (n//2) % k))\n    for i in range(n//2 - 1, -1, -1):\n        password.append(chr(97 + (i + 1) % k))\n    return ''.join(password)\n\nn, k = map(int, input().split())\nprint(generate_password(n, k))"}
{"solution": "def find_first_collision(n, directions, coordinates):\n    closest_collision = float('inf')\n    \n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            diff = coordinates[i + 1] - coordinates[i]\n            closest_collision = min(closest_collision, diff // 2)\n    \n    if closest_collision == float('inf'):\n        return -1\n    else:\n        return closest_collision\n\n# Reading input\nn = int(input())\ndirections = input().strip()\ncoordinates = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(find_first_collision(n, directions, coordinates))"}
{"solution": "from itertools import combinations\n\ndef max_seal_area(n, a, b, seals):\n    # Sort seals by their area in descending order, considering both orientations\n    seals.sort(key=lambda x: max(x[0] * x[1], x[0] * x[1], x[1] * x[0]), reverse=True)\n    \n    max_area = 0\n    for seal1, seal2 in combinations(seals, 2):\n        # Check all orientations for both seals\n        orientations = [(seal1[0], seal1[1]), (seal1[1], seal1[0]), (seal2[0], seal2[1]), (seal2[1], seal2[0])]\n        \n        for i in range(3):\n            for j in range(i + 1, 4):\n                s1, s2 = orientations[i], orientations[j]\n                # Check if both seals fit in either orientation\n                if (s1[0] <= a and s1[1] <= b) and (s2[0] <= a and s2[1] <= b):\n                    area = s1[0] * s1[1] + s2[0] * s2[1]\n                    max_area = max(max_area, area)\n    \n    return max_area\n\n# Reading input\nn, a, b = map(int, input().split())\nseals = [list(map(int, input().split())) for _ in range(n)]\n\n# Printing output\nprint(max_seal_area(n, a, b, seals))"}
{"solution": "from collections import defaultdict\n\ndef find_odd_one_out():\n    n = int(input())\n    points = []\n    for _ in range(4 * n + 1):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    x_count = defaultdict(int)\n    y_count = defaultdict(int)\n\n    for x, y in points:\n        x_count[x] += 1\n        y_count[y] += 1\n\n    odd_x = None\n    odd_y = None\n\n    for x in x_count:\n        if x_count[x] == n:\n            continue\n        if odd_x is None:\n            odd_x = x\n        else:\n            odd_x = None  # Found more than one non-matching x-coordinate\n\n    for y in y_count:\n        if y_count[y] == n:\n            continue\n        if odd_y is None:\n            odd_y = y\n        else:\n            odd_y = None  # Found more than one non-matching y-coordinate\n\n    if odd_x is not None and odd_y is not None:\n        print(odd_x, odd_y)\n\nfind_odd_one_out()"}
{"solution": "def max_digit_product(n):\n    if n < 10:\n        return n\n    digs = []\n    while n > 0:\n        digs.append(n % 10)\n        n //= 10\n    digs.sort(reverse=True)\n    \n    max_prod = 1\n    zeros_counted = False\n    for d in digs:\n        if d == 0 and not zeros_counted:\n            continue\n        elif d == 0:\n            zeros_counted = True\n        max_prod *= d\n    \n    if max_prod <= 1:\n        return max(digs)\n    \n    # Adjusting for optimal configuration\n    if len(digs) >= 5 and digs[-1] == 1 and digs[-2] in [1, 2]:\n        max_prod //= digs[-1]\n        max_prod //= digs[-2]\n        max_prod *= 2\n    \n    return max_prod\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the result\nprint(max_digit_product(n))"}
{"solution": "def find_winning_k(n, votes_for_opponent):\n    max_a = max(votes_for_opponent)\n    low, high = max_a, sum(votes_for_opponent)\n    \n    while low < high:\n        mid = (low + high) // 2\n        awruk_votes = sum(mid - a for a in votes_for_opponent)\n        opponent_votes = sum(votes_for_opponent)\n        \n        if awruk_votes > opponent_votes:\n            high = mid\n        else:\n            low = mid + 1\n            \n    return low\n\n# Reading input\nn = int(input())\nvotes_for_opponent = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(find_winning_k(n, votes_for_opponent))"}
{"solution": "s = input()\noperations = 0\n\n# Convert the string to a list of characters for easier manipulation\npoints = list(s)\n\nwhile True:\n    to_delete = [points[i] for i in range(1, len(points) - 1) if points[i-1] != points[i] or points[i+1] != points[i]]\n    \n    # Check if there are points to delete\n    if not to_delete:\n        break\n    \n    # Delete the points\n    for color in to_delete:\n        points = [point for point in points if point != color]\n    \n    operations += 1\n\nprint(operations)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\na_sorted = sorted((val, i) for i, val in enumerate(a))\nmin_val, min_idx = a_sorted[0]\ncount_min = 1\ncount_before_min = 0\n\nfor _, idx in a_sorted[1:]:\n    if a[idx] == min_val:\n        count_min += 1\n    else:\n        break\n\nfor i in range(count_min, len(a_sorted)):\n    if a_sorted[i][0] != min_val:\n        break\n    count_before_min += 1\n\nresult = count_min * (count_min - 1) * (count_before_min) // 2 + count_min * (count_before_min) * (count_before_min - 1) // 2\nprint(result)"}
{"solution": "def min_cuts(n):\n    if n == 0:\n        return 0\n    else:\n        return n * 2 - 1\n\nn = int(input())\nprint(min_cuts(n))"}
{"solution": "def max_bank_state(n):\n    # Convert the number to a string to easily manipulate digits\n    n_str = str(n)\n    \n    # Check if the last two digits are negative and if removing one would increase the value\n    if n < 0:\n        # Option 1: Remove the last digit\n        option1 = int(n_str[:-1])\n        \n        # Option 2: Remove the second last digit\n        option2 = int(n_str[:-2] + n_str[-1])\n        \n        # Return the maximum of the original number and the two options\n        return max(n, option1, option2)\n    else:\n        # If the number is positive, removing a digit can't increase its value\n        return n\n\n# Read the input\nn = int(input())\n\n# Compute and print the result\nprint(max_bank_state(n))"}
{"solution": "def spinner_direction(start, end, n):\n    positions = {'v': 0, '<': 1, '^': 2, '>': 3}\n    start_pos = positions[start]\n    end_pos = positions[end]\n    \n    # Calculate the difference in positions\n    diff = (end_pos - start_pos) % 4\n    \n    # Determine the direction based on the difference and the number of seconds\n    if diff == 1 or diff == 3 and n % 2 == 1:\n        return \"cw\"\n    elif diff == 3 or diff == 1 and n % 2 == 1:\n        return \"ccw\"\n    else:\n        return \"undefined\"\n\n# Read input\nstart, end = input().split()\nn = int(input())\n\n# Output the direction\nprint(spinner_direction(start, end, n))"}
{"solution": "def count_standing_dominoes(n, arrangement):\n    stack = []\n    standing = 0\n    \n    for i in range(n):\n        if arrangement[i] != '.':\n            while len(stack) > 0:\n                last = stack[-1]\n                if arrangement[i] == 'R' and last == 'L':\n                    stack.pop()\n                    standing += 1\n                    break\n                else:\n                    stack.pop()\n            if arrangement[i] == 'L' or (arrangement[i] == 'R' and not stack):\n                stack.append(arrangement[i])\n    \n    standing += len(stack)\n    standing += arrangement.count('.')\n    \n    return standing - len(stack)\n\n# Reading input\nn = int(input())\narrangement = input()\n\n# Calculating result\nresult = count_standing_dominoes(n, arrangement)\n\n# Printing output\nprint(result)"}
{"solution": "def find_permutation(n, m, leaders):\n    permutation = [-1] * n\n    current_position = 0\n    \n    for i in range(m):\n        target_position = leaders[i] - 1\n        \n        if current_position != target_position:\n            if permutation[target_position] != -1:\n                return -1\n            \n            distance = target_position - current_position\n            if distance < 0:\n                distance += n\n            \n            if permutation[current_position] == -1:\n                permutation[current_position] = distance\n            \n            permutation[target_position] = n - distance\n            \n            current_position = target_position\n        else:\n            if permutation[current_position] != -1:\n                return -1\n    \n    for i in range(n):\n        if permutation[i] == -1:\n            available = set(range(1, n + 1)) - set(permutation)\n            if len(available) == 0:\n                return -1\n            permutation[i] = min(available)\n    \n    for i in range(n - 1):\n        if permutation[i] >= n - i:\n            return -1\n    \n    return permutation\n\n# Reading input\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\n# Finding permutation\nresult = find_permutation(n, m, leaders)\n\n# Printing output\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "from collections import deque\n\ndef max_number_after_swaps(a, k):\n    str_a = str(a)\n    n = len(str_a)\n    \n    # Sliding window approach\n    stack = deque()\n    first_digit_index = 0\n    \n    for i, digit in enumerate(str_a + '#'):\n        while stack and str_a[stack[-1]] < digit:\n            if k > 0:\n                k -= 1\n                stack.pop()\n            else:\n                break\n        \n        if i < n:\n            if not stack or str_a[stack[-1]] >= digit:\n                stack.append(i)\n            elif str_a[stack[0]] < digit:\n                first_digit_index = i\n                while stack and str_a[stack[-1]] > digit and k > 0:\n                    k -= 1\n                    stack.pop()\n                stack.append(i)\n    \n    sorted_part = sorted(str_a[first_digit_index:stack[-1]+1], reverse=True)\n    result = str_a[:first_digit_index] + ''.join(sorted_part) + str_a[stack[-1]+1:]\n    \n    return result\n\n# Reading input\na, k = input().split()\nk = int(k)\n\n# Solving and printing output\nprint(max_number_after_swaps(a, k))"}
{"solution": "def find_next_in_sequence(a, b, c):\n    d1 = b - a\n    d2 = c - b\n    q1 = b // a\n    q2 = c // b\n    \n    # Check for arithmetic progression\n    if d1 == d2:\n        return c + d1\n    # Check for geometric progression\n    elif q1 == q2 and b % a == 0 and c % b == 0:\n        return c * q1\n    else:\n        return 42\n\n# Reading input\na, b, c, _ = map(int, input().split())\n\n# Calculating and printing the result\nresult = find_next_in_sequence(a, b, c)\nprint(result)"}
{"solution": "def max_distance(n, colors):\n    max_dist = 0\n    color_positions = {}\n\n    for i in range(n):\n        if colors[i] in color_positions:\n            max_dist = max(max_dist, i - color_positions[colors[i]])\n        else:\n            color_positions[colors[i]] = i\n\n    # Reset positions for new pass\n    color_positions.clear()\n    for i in reversed(range(n)):\n        if colors[i] in color_positions:\n            max_dist = max(max_dist, color_positions[colors[i]] - i)\n        else:\n            color_positions[colors[i]] = i\n\n    return max_dist\n\n# Reading input\nn = int(input())\ncolors = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(max_distance(n, colors))"}
{"solution": "def find_santa_place(n, m, k):\n    desks_per_lane = 2 * m\n    lane = (k - 1) // desks_per_lane + 1\n    position_in_lane = (k - 1) % desks_per_lane + 1\n    desk = position_in_lane // 2 if position_in_lane % 2 == 0 else (position_in_lane + 1) // 2\n    side = \"L\" if position_in_lane % 2 == 0 else \"R\"\n    return lane, desk, side\n\n# Reading input\nn, m, k = map(int, input().split())\n\n# Finding Santa's place\nlane, desk, side = find_santa_place(n, m, k)\n\n# Printing output\nprint(lane, desk, side)"}
{"solution": "n = int(input())\ns = input()\n\n# Count the occurrences of each color\ncounts = {'B': 0, 'G': 0, 'R': 0}\nfor c in s:\n    counts[c] += 1\n\n# Determine the possible final colors\npossible_colors = []\nif counts['B'] % 2 == 1:\n    possible_colors.append('B')\nif counts['G'] % 2 == 1:\n    possible_colors.append('G')\nif counts['R'] % 2 == 1:\n    possible_colors.append('R')\n\n# Sort and print the possible colors\npossible_colors.sort()\nprint(''.join(possible_colors))"}
