{"solution": "def find_longest_accordion(s):\n    stack = []\n    valid_parts = {'[': 0, ':': 1, '|': 2, ']': 3}\n    part_count = [0, 0, 0, 0]\n    \n    for char in s:\n        if char in valid_parts:\n            if char == ']' and part_count[0] > 0 and part_count[1] > 0:\n                part_count[0] -= 1\n                part_count[1] = 0\n                part_count[3] += 1\n            elif char == ':' and part_count[0] == 0:\n                part_count[1] += 1\n            elif char == '|' and part_count[1] > 0:\n                part_count[1] += 1\n            elif char == '[':\n                part_count[0] += 1\n    \n    if part_count[3] > 0:\n        return 4 + (part_count[1] - 1) * 2\n    else:\n        return -1\n\ns = input().strip()\nprint(find_longest_accordion(s))"}
{"solution": "def max_digit_sum(x):\n    x_str = str(x)\n    length = len(x_str)\n    \n    # Attempt to fill all but the last digit to 9\n    max_sum = (length - 1) * 9\n    \n    # Calculate the remaining value for the last digit\n    remainder = x % (10 ** (length - 1))\n    \n    # If we can fit 9s everywhere, we're done\n    if remainder >= 9:\n        return '9' * length\n    else:\n        # Otherwise, set the first digit to be the remainder or 9, whichever is smaller\n        first_digit = min(remainder, 9)\n        # Fill the rest with 9s\n        return str(first_digit) + '9' * (length - 1)\n\n# Read input from stdin\nx = int(input())\n\n# Print the result to stdout\nprint(max_digit_sum(x))"}
{"solution": "n = int(input())\nn += 1\nstr_n = str(n)\nwhile True:\n    if str_n.count('0') == len(str_n) - 1 or str_n.count('1') == len(str_n) - 1 or str_n.count('2') == len(str_n) - 1 or str_n.count('3') == len(str_n) - 1 or str_n.count('4') == len(str_n) - 1 or str_n.count('5') == len(str_n) - 1 or str_n.count('6') == len(str_n) - 1 or str_n.count('7') == len(str_n) - 1 or str_n.count('8') == len(str_n) - 1 or str_n.count('9') == len(str_n) - 1:\n        break\n    n += 1\n    str_n = str(n)\nprint(n - int(str_n[0]) * 0**(len(str_n) - 1))"}
{"solution": "from itertools import accumulate\nfrom bisect import bisect_right, bisect_left\n\ndef max_painted_sections(n, q, painters):\n    starts, ends = zip(*painters)\n    starts = list(starts)\n    ends = list(ends)\n    starts.sort()\n    ends.sort()\n    all_points = sorted(set(starts + ends))\n    compressed = {point: idx for idx, point in enumerate(all_points)}\n    \n    segment_tree = [0] * (len(all_points) * 4)\n    lazy_tree = [0] * (len(all_points) * 4)\n\n    def update_range(node, start, end, left, right, value):\n        if lazy_tree[node]:\n            segment_tree[node] += lazy_tree[node]\n            if start != end:\n                lazy_tree[node * 2] += lazy_tree[node]\n                lazy_tree[node * 2 + 1] += lazy_tree[node]\n            lazy_tree[node] = 0\n\n        if start > end or start > right or end < left:\n            return\n\n        if start >= left and end <= right:\n            segment_tree[node] += value\n            if start != end:\n                lazy_tree[node * 2] += value\n                lazy_tree[node * 2 + 1] += value\n            return\n\n        mid = (start + end) // 2\n        update_range(node * 2, start, mid, left, right, value)\n        update_range(node * 2 + 1, mid + 1, end, left, right, value)\n        segment_tree[node] = max(segment_tree[node * 2], segment_tree[node * 2 + 1])\n\n    def query_max(node, start, end, left, right):\n        if lazy_tree[node]:\n            segment_tree[node] += lazy_tree[node]\n            if start != end:\n                lazy_tree[node * 2] += lazy_tree[node]\n                lazy_tree[node * 2 + 1] += lazy_tree[node]\n            lazy_tree[node] = 0\n\n        if start > end or start > right or end < left:\n            return 0\n\n        if start >= left and end <= right:\n            return segment_tree[node]\n\n        mid = (start + end) // 2\n        left_max = query_max(node * 2, start, mid, left, right)\n        right_max = query_max(node * 2 + 1, mid + 1, end, left, right)\n        return max(left_max, right_max)\n\n    events = []\n    for i, (l, r) in enumerate(painters):\n        l, r = compressed[l], compressed[r]\n        events.append((l, 'start', i))\n        events.append((r, 'end', i))\n\n    events.sort()\n\n    active_painters = set()\n    painter_starts = [0] * q\n    painter_ends = [0] * q\n    result = 0\n\n    for event_point, event_type, painter_id in events:\n        if event_type == 'start':\n            painter_starts[painter_id] = query_max(1, 0, len(all_points) - 1, 0, event_point - 1)\n            active_painters.add(painter_id)\n        else:\n            painter_ends[painter_id] = query_max(1, 0, len(all_points) - 1, event_point + 1, len(all_points) - 1)\n            active_painters.remove(painter_id)\n            if len(active_painters) == 2:\n                p1, p2 = sorted(active_painters)\n                update_range(1, 0, len(all_points) - 1, compressed[starts[p1]], compressed[ends[p1]], painter_ends[p2])\n                update_range(1, 0, len(all_points) - 1, compressed[starts[p2]], compressed[ends[p2]], painter_starts[p1])\n                result = max(result, query_max(1, 0, len(all_points) - 1, 0, len(all_points) - 1))\n\n    return result\n\n# Reading input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Calculating and printing the answer\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def has_seven(s):\n    return '7' in s\n\ndef time_to_minutes(time_str):\n    h, m = map(int, time_str.split(':'))\n    return h * 60 + m\n\ndef solve(x, target_minutes):\n    i = 0\n    while True:\n        alarm_minutes = target_minutes - x * i\n        alarm_time_str = f\"{alarm_minutes // 60:02d}:{alarm_minutes % 60:02d}\"\n        if has_seven(alarm_time_str):\n            return i\n        i += 1\n\nx = int(input())\ntarget_time = input()\ntarget_minutes = time_to_minutes(target_time)\nprint(solve(x, target_minutes))"}
{"solution": "3\nn, pos, l, r = map(int, input().split())\n \nif pos < l:\n    print(l - pos + (pos - 1) - max(0, l - 1))\nelif pos > r:\n    print(pos - r + min(n - r, pos - 1) - 0)\nelse:\n    print(0)"}
{"solution": "from heapq import heappush, heappop\nfrom collections import defaultdict\n\ndef solve(x, blows):\n    # Sort blows by damage dealt in descending order\n    blows.sort(key=lambda b: -b[0])\n    \n    # Initialize a max heap for effective blows and a counter for operations\n    effective_blows = []\n    operations = 0\n    \n    # Dictionary to keep track of the count of each blow\n    blow_counts = defaultdict(int)\n    \n    while x > 0:\n        # Add new effective blows to the heap\n        for damage, grow in blows:\n            if damage not in blow_counts:\n                heappush(effective_blows, -damage)\n                blow_counts[damage] += 1\n        \n        # Check if we have no more effective blows\n        if not effective_blows:\n            return -1\n        \n        # Pop the most effective blow (max damage)\n        strongest_blow = -heappop(effective_blows)\n        \n        # Apply the strongest blow\n        x -= strongest_bow\n        \n        # Increase the operation counter\n        operations += 1\n        \n        # If the dragon still has heads, it grows new ones\n        if x > 0:\n            x += grow\n    \n    return operations\n\n# Reading input\nt = int(input())\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Output the result\n    print(solve(x, blows))"}
{"solution": "import math\n\ndef find_day(n, m):\n    if m == 0:\n        return n\n    k = (math.sqrt(1 + 8 * (n + 1)) - 1) / 2\n    k = math.ceil(k)\n    total_grains = k * (k + 1) // 2\n    while total_grains > n:\n        k -= 1\n        total_grains = k * (k + 1) // 2\n    extra_days = (n - total_grains + m - 1) // m\n    return k + extra_days\n\nn, m = map(int, input().split())\nprint(find_day(n, m))"}
{"solution": "from collections import Counter\n\ndef check_hand(hand):\n    counts = Counter(hand)\n    suits = {'m', 'p', 's'}\n    for suit in suits:\n        nums = [int(tile[0]) for tile in hand if tile.endswith(suit)]\n        if len(nums) == 3:\n            if max(nums) - min(nums) <= 2:\n                return True\n        for num in nums:\n            if counts[str(num) + suit] >= 3:\n                return True\n    return False\n\ndef min_tiles_to_draw(hand):\n    if check_hand(hand):\n        return 0\n    else:\n        for i in range(1, 10):\n            for suit in ['m', 'p', 's']:\n                new_hand = hand + [f\"{i}{suit}\"]\n                if check_hand(new_hand):\n                    return 1\n        return 2\n\nhand = input().split()\nprint(min_tiles_to_draw(hand))"}
{"solution": "import sys\nfrom collections import defaultdict as dd\ninput = sys.stdin.readline\n\ndef gi():\n    return int(input())\n\ndef gl():\n    return list(map(int, input().split()))\n\ndef gg():\n    return list(gi() for _ in range(n))\n\ndef solve():\n    n = gi()\n    n, m = gl()\n    sofas = [gl() for _ in range(n)]\n    l, r, t, b = gl()\n\n    horizontals = []\n    verticals = []\n\n    for i, (x1, y1, x2, y2) in enumerate(sofas):\n        if x1 == x2:\n            horizontals.append((y1, y2, i))\n        else:\n            verticals.append((x1, x2, i))\n\n    horizontals.sort(key=lambda x: min(x[0], x[1]))\n    verticals.sort(key=lambda x: min(x[0], x[1]))\n\n    pos = set(range(n))\n\n    def check(s, cnt):\n        nonlocal pos\n        if cnt == 0:\n            return True\n        for i in s:\n            if i[2] in pos:\n                pos.remove(i[2])\n                if len(pos) <= cnt:\n                    return False\n        return True\n\n    ans = -1\n\n    for i, (x1, y1, x2, y2) in enumerate(sofas):\n        if x1 == x2:\n            cur = horizontals[:]\n            if y1 > y2:\n                y1, y2 = y2, y1\n            cur.remove((y1, y2, i))\n            pos.clear()\n            pos.update(j for _, _, j in cur)\n            if check(cur[:y1 - 1], l) and check(cur[y2:], r):\n                cur = verticals[:]\n                if check(cur[:x1 - 1], t) and check(cur[x2:], b):\n                    ans = i + 1\n        else:\n            cur = verticals[:]\n            if x1 > x2:\n                x1, x2 = x2, x1\n            cur.remove((x1, x2, i))\n            pos.clear()\n            pos.update(j for _, _, j in cur)\n            if check(cur[:x1 - 1], t) and check(cur[x2:], b):\n                cur = horizontals[:]\n                if check(cur[:y1 - 1], l) and check(cur[y2:], r):\n                    ans = i + 1\n    print(ans)\n\nsolve()"}
{"solution": "n = int(input())\nprint(n//7*2, n//7*2 + min(2, n%7))"}
{"solution": "n, a, b, p, q = map(int, input().split())\n\nlcm = (a * b) // math.gcd(a, b)\n\ntotal_red = n // a - n // lcm\ntotal_blue = n // b - n // lcm\ntotal_both = n // lcm\n\nmax_chocs_red = total_red * p + total_both * max(p, q)\nmax_chocs_blue = total_blue * q + total_both * max(p, q)\n\nprint(max(max_chocs_red, max_chocs_blue))"}
{"solution": "import sys\n\nrr = lambda: sys.stdin.readline().strip()\nrri = lambda: int(rr())\nrrm = lambda: list(map(int, rr().split()))\n\ndef solve(N, A):\n    G = [0]\n    S = []\n    cur = 0\n    for i in range(N):\n        if A[i] == 'G':\n            cur += 1\n        else:\n            if cur > 0:\n                G.append(cur)\n                cur = 0\n        if A[i] == 'S':\n            S.append(i)\n    if cur > 0:\n        G.append(cur)\n    if len(G) == 1:\n        return G[0]\n\n    best = max(G)\n    prefix = [0]\n    for i in range(len(G)):\n        prefix.append(prefix[-1] + G[i])\n    for i in range(len(S)):\n        l = bisect.bisect_left(G, S[i])\n        r = bisect.bisect_right(G, S[i])\n        best = max(best, prefix[r] - prefix[l] + 1)\n    return best\n\nN = rri()\nA = rr()\nprint(solve(N, A))"}
{"solution": "from collections import defaultdict, deque\n\ndef topological_sort(n, dependencies, target_courses):\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    for course, deps in enumerate(dependencies):\n        for dep in deps:\n            graph[dep].append(course + 1)\n            in_degree[course + 1] += 1\n\n    queue = deque([node for node in range(1, n + 1) if in_degree[node] == 0])\n    visited = []\n    required_courses = set(target_courses)\n\n    while queue:\n        current = queue.popleft()\n        visited.append(current)\n        if current in required_courses:\n            required_courses.remove(current)\n        for neighbor in graph[current]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if required_courses:\n        return [-1]\n\n    return [len(visited), visited]\n\ndef solve():\n    n, k = map(int, input().split())\n    target_courses = list(map(int, input().split()))\n    dependencies = [list(map(int, input().split()[1:])) for _ in range(n)]\n\n    result = topological_sort(n, dependencies, target_courses)\n    return result\n\nprint(*solve(), sep='\\n')"}
{"solution": "def find_max_stack_sortable_permutation(n, k, initial_elements):\n    remaining_elements = set(range(1, n + 1)) - set(initial_elements)\n    remaining_elements = list(remaining_elements)\n    remaining_elements.sort(reverse=True)\n    stack = []\n    result = list(initial_elements)\n\n    def push_and_pop_to_result(stack, remaining, result):\n        while remaining and (not stack or stack[-1] < remaining[-1]):\n            result.append(remaining.pop())\n        while stack:\n            result.append(stack.pop())\n\n    for element in initial_elements:\n        while remaining_elements and remaining_elements[-1] > element:\n            stack.append(remaining_elements.pop())\n        if stack and stack[-1] < element:\n            return -1\n        stack.append(element)\n\n    push_and_pop_to_result(stack, remaining_elements, result)\n\n    if len(result) != n:\n        return -1\n    return result\n\n# Reading input\nn, k = map(int, input().split())\ninitial_elements = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(*find_max_stack_sortable_permutation(n, k, initial_elements))"}
{"solution": "a, b, c = map(int, input().split())\n\nif (b - a) % c == 0 and (b - a) // c >= 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "`\nfrom sys import stdin, stdout\ncin = stdin.readline\ncout = stdout.write\n\ncnt1 = int(cin())\ncnt2 = int(cin())\ncnt3 = int(cin())\ncnt4 = int(cin())\n\nif cnt1 == cnt4 and cnt1+cnt2 >= cnt3:\n    cout('1')\nelse:\n    cout('0')"}
{"solution": "n, k, t = map(int, input().split())\ncycle_length = n + k\nstanding = min(n, t)\n\nif t > n:\n    extra_time = t - n\n    full_cycles = extra_time // k\n    standing -= (full_cycles * k)\n    standing += (full_cycles * k) % n\n\nprint(max(0, standing))"}
{"solution": "from collections import deque\n\ndef solve(s):\n    s = deque(s)\n    u = []\n    sorted_chars = sorted(s)\n    while s:\n        if s[0] == sorted_chars[0]:\n            u.append(s.popleft())\n            sorted_chars.remove(s[0])\n        else:\n            u.append(s.pop())\n    return ''.join(u)\n\ns = input().strip()\nprint(solve(s))"}
{"solution": "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    prev_plays, prev_clears = map(int, input().split())\n    valid = True\n    for _ in range(n - 1):\n        curr_plays, curr_clears = map(int, input().split())\n        if curr_plays < prev_plays or curr_clears > prev_clears or (curr_clears - prev_clears) > (curr_plays - prev_plays):\n            valid = False\n            break\n        prev_plays, prev_clears = curr_plays, curr_clears\n    print(\"YES\" if valid else \"NO\")"}
{"solution": "def is_palindrome(time_str):\n    return time_str == time_str[::-1]\n\ndef next_palindrome_time(current_time):\n    hours, minutes = map(int, current_time.split(':'))\n    current_minutes = hours * 60 + minutes\n    next_time = current_minutes\n\n    while not is_palindrome(f\"{next_time // 60:02d}:{next_time % 60:02d}\"):\n        next_time += 1\n        next_time %= (24 * 60)  # Wrap around after 23:59\n\n    return next_time - current_minutes\n\ncurrent_time = input().strip()\nprint(next_palindrome_time(current_time))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\nmn_pos = a.index(1)\nmx_pos = a.index(n)\nmn_pos, mx_pos = sorted([mn_pos, mx_pos])\nif mx_pos - mn_pos == n - 1 or mn_pos == 0 or mx_pos == n-1:\n    print(n-1)\nelse:\n    print(max(mx_pos, n-1-mn_pos))"}
{"solution": "s = input()\nmid = len(s) // 2\nif len(s) % 2 == 0:\n    if s[:mid] == s[mid:][::-1]:\n        print(\"TAK\")\n    else:\n        print(\"NIE\")\nelse:\n    if s[:mid] == s[mid+1:][::-1]:\n        print(\"TAK\")\n    else:\n        print(\"NIE\")"}
{"solution": "def max_permuted_number(a, b):\n    a_str, b_str = str(a), str(b)\n    len_a, len_b = len(a_str), len(b_str)\n\n    if len_a < len_b or (len_a == len_b and a_str <= b_str):\n        return a_str\n\n    result = []\n    a_counts = [0] * 10\n    b_counts = [0] * 10\n\n    for char in a_str:\n        a_counts[int(char)] += 1\n\n    for char in b_str:\n        b_counts[int(char)] += 1\n\n    for i in range(len_b):\n        for digit in range(9, -1, -1):\n            if a_counts[digit] > 0 and b_counts[digit] >= a_counts[digit]:\n                result.append(str(digit))\n                a_counts[digit] -= 1\n                break\n        else:\n            for digit in range(9, -1, -1):\n                if a_counts[digit] > 0 and b_counts[digit] > 0:\n                    result.append(str(digit))\n                    a_counts[digit] -= 1\n                    b_counts[digit] -= 1\n                    break\n\n    for digit in range(9, -1, -1):\n        while a_counts[digit] > 0:\n            result.append(str(digit))\n            a_counts[digit] -= 1\n\n    return ''.join(result)\n\n\na = int(input())\nb = int(input())\n\nprint(max_permuted_number(a, b))"}
{"solution": "`\nfrom itertools import product\n\ndef check_win(grid):\n    lines = [\n        [(x, y) for x in range(10)] for y in range(10) +\n        [(x, y) for x, y in zip(range(10), range(10))] +\n        [(x, y) for x, y in zip(range(10), reversed(range(10)))] +\n        [(x, y) for x, y in zip(range(6, 10), range(4))] +\n        [(x, y) for x, y in zip(range(4), range(6, 10))] +\n        [(x, y) for x, y in zip(range(4), reversed(range(6, 10)))] +\n        [(x, y) for x, y in zip(reversed(range(6, 10)), range(4))] +\n        [(x, y) for x, y in zip(reversed(range(4)), range(6, 10))] +\n        [(x, y) for x, y in zip(reversed(range(4)), reversed(range(6, 10)))] +\n        [(x, y) for x, y in zip(reversed(range(6, 10)), range(4))]\n    ]\n\n    for line in lines:\n        for i in range(len(line) - 4 + 1):\n            segment = line[i:i+5]\n            if all(grid[y][x] == 'X' for x, y in segment[:-1]):\n                return segment[-1]\n    return None\n\ngrid = [input() for _ in range(10)]\nempty_cells = {(x, y) for y, row in enumerate(grid) for x, cell in enumerate(row) if cell == '.'}\n\nwinning_move = next(((x, y) for x, y in empty_cells if check_win([r[:x] + 'X' + r[x+1:] for r in grid]) is not None), None)\n\nprint('YES' if winning_move else 'NO')"}
{"solution": "}\ndef place_ones(n, k):\n    matrix = [[0]*n for _ in range(n)]\n    placed = 0\n    for i in range(n):\n        for j in range(i, n):\n            if placed < k:\n                if i == j or placed * 2 + n - 1 - i < k:\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    placed += 1\n                else:\n                    break\n            else:\n                break\n    if placed != k:\n        return -1\n    return matrix\n\ndef print_matrix(matrix):\n    for row in matrix:\n        print(' '.join(map(str, row)))\n\nn, k = map(int, input().split())\nresult = place_ones(n, k)\nif result == -1:\n    print(-1)\nelse:\n    print_matrix(result)"}
{"solution": "import math\n\nx, y, z = map(float, input().split())\n\na = [\n    (x, y, z),\n    (x, z, y),\n    ((x, y), z),\n    ((x, z), y),\n    (y, x, z),\n    (y, z, x),\n    ((y, x), z),\n    ((y, z), x),\n    (z, x, y),\n    (z, y, x),\n    ((z, x), y),\n    ((z, y), x),\n]\n\nmax_val = -math.inf\nmax_idx = -1\n\nfor i, (p, q, r) in enumerate(a):\n    if isinstance(p, tuple):\n        val = p[0] ** (q * r)\n    else:\n        val = p ** (q ** r)\n\n    if val > max_val:\n        max_val = val\n        max_idx = i\n\nif max_idx == 0:\n    print(\"x^y^z\")\nelif max_idx == 1:\n    print(\"x^z^y\")\nelif max_idx == 2:\n    print(\"(x^y)^z\")\nelif max_idx == 3:\n    print(\"(x^z)^y\")\nelif max_idx == 4:\n    print(\"y^x^z\")\nelif max_idx == 5:\n    print(\"y^z^x\")\nelif max_idx == 6:\n    print(\"(y^x)^z\")\nelif max_idx == 7:\n    print(\"(y^z)^x\")\nelif max_idx == 8:\n    print(\"z^x^y\")\nelif max_idx == 9:\n    print(\"z^y^x\")\nelif max_idx == 10:\n    print(\"(z^x)^y\")\nelse:\n    print(\"(z^y)^x\")"}
{"solution": "n = int(input())\ns = input()\n\ndef f(s):\n    for i in range(1, len(s)//2+1):\n        if len(s) % len(s[:i]) == 0:\n            if s == s[:i] * (len(s)//len(s[:i])):\n                return len(s[:i])\n    return len(s)\n\nprint(f(s))"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\nfiles = []\nfor _ in range(n):\n    name, typ = sys.stdin.readline().strip().split()\n    files.append((name, int(typ)))\n\nfiles.sort(key=lambda x: x[1], reverse=True)\n\nexample_count = sum(f[1] for f in files)\nrenames = []\n\nfor i, (name, typ) in enumerate(files):\n    new_name = str(i + 1 + example_count - 2 * typ)\n    renames.append(' '.join(['move', name, new_name]))\n\nsys.stdout.write(str(len(renames)) + '\\n')\nsys.stdout.write('\\n'.join(renames))"}
{"solution": "def min_replacements_to_make_lucky_ticket(ticket):\n    first_half_sum = sum(int(digit) for digit in ticket[:3])\n    second_half_sum = sum(int(digit) for digit in ticket[3:])\n    \n    return abs(first_half_sum - second_half_sum) // 2\n\n# Example usage\nticket = input()\nprint(min_replacements_to_make_lucky_ticket(ticket))"}
{"solution": "from math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef min_traps(m, x):\n    return m // gcd(m, x)\n\nm, x = map(int, input().split())\nprint(min_traps(m, x))"}
{"solution": "MOD = 10**6 + 3\n\ndef mult_inv(a):\n    return pow(a, MOD - 2, MOD)\n\ndef solve(n, k):\n    n = pow(2, n, MOD - 1)\n    a = 1\n    b = 1\n    for i in range(k):\n        a = (a * (n - i)) % MOD\n        b = (b * (k - i)) % MOD\n    a = (a * mult_inv(b)) % MOD\n    b = (pow(n, k, MOD) * mult_inv(b)) % MOD\n    a = (a * (MOD - 1)) % MOD\n    a = (a + 1) % MOD\n    gcd = 1 # Since we work in modulo, the gcd is always 1 due to the nature of modular arithmetic and how we calculated a and b.\n    return (a * mult_inv(b)) % MOD, b % MOD\n\nn, k = map(int, input().split())\na, b = solve(n, k)\nprint(a, b)"}
{"solution": "def validate_journey(instructions):\n    latitude = 90\n    longitude = 0\n    on_pole = True\n    for distance, direction in instructions:\n        if on_pole:\n            if direction == 'North':\n                return False\n            elif direction == 'South':\n                latitude -= distance\n                on_pole = False\n        else:\n            if direction == 'North':\n                latitude += distance\n            elif direction == 'South':\n                latitude -= distance\n            elif direction == 'East':\n                longitude += distance\n            elif direction == 'West':\n                longitude -= distance\n\n            if latitude < -90:\n                latitude = -90\n                on_pole = True\n            elif latitude > 90:\n                latitude = 90\n                on_pole = True\n            elif latitude == -90 and direction != 'North':\n                return False\n            elif latitude == 90 and direction != 'South':\n                return False\n\n    return latitude == 90\n\nn = int(input())\ninstructions = []\nfor _ in range(n):\n    distance, direction = input().split()\n    instructions.append((int(distance), direction))\n\nprint(\"YES\" if validate_journey(instructions) else \"NO\")"}
{"solution": "from math import gcd\n\ndef find_common_terms(a1, b1, a2, b2, L, R):\n    \"\"\"\n    Finds the number of common terms between two arithmetic sequences in the range [L, R].\n    The sequences are defined by a1*k + b1 and a2*l + b2.\n    \"\"\"\n    # Calculate the common difference of the merged sequence\n    common_diff = a1 * (a2 // gcd(a1, a2))\n    \n    # Adjust the starting points of the sequences if necessary\n    adjusted_start_1 = b1 - b2\n    adjusted_start_2 = b2 - b1\n    \n    # Calculate the first possible value within the range\n    first_possible = ((L - b2) % a2 + a2) % a2\n    \n    # Calculate the first common term in the range [L, R]\n    first_common = max(first_possible + adjusted_start_1, L)\n    first_common = (first_common - b1) % common_diff + b1\n    \n    # Calculate the last common term in the range [L, R]\n    last_common = min((R - b1) // common_diff * common_diff + b1, R)\n    \n    # Calculate and return the number of common terms\n    return max(0, (last_common - first_common) // common_diff + 1)\n\n# Reading input\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Output the result\nprint(find_common_terms(a1, b1, a2, b2, L, R))"}
{"solution": "def max_cake_pieces(n, a, b):\n    # The function calculates the maximum number of pieces per plate.\n    for x in range(min(a, b), 0, -1):\n        if (a // x + b // x) >= n:\n            return x\n\n# Reading input\nn, a, b = map(int, input().split())\n\n# Calculating and printing the result\nprint(max_cake_pieces(n, a, b))"}
{"solution": "n,m=map(int,input().split())\nl=[]\nfor i in range(n):\n    l.append(input())\nif n%3!=0:\n    print(\"NO\")\nelse:\n    x=n//3\n    if (l[0:x].count('R'*m)==x or l[0:x].count('B'*m)==x or l[0:x].count('G'*m)==x) and (l[x:2*x].count('R'*m)==x or l[x:2*x].count('B'*m)==x or l[x:2*x].count('G'*m)==x) and (l[2*x:].count('R'*m)==x or l[2*x:].count('B'*m)==x or l[2*x:].count('G'*m)==x):\n        if (l[0:x][0]==l[x:2*x][0] or l[0:x][0]==l[2*x:][0] or l[x:2*x][0]==l[2*x:][0]):\n            print(\"NO\")\n        else:\n            print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "3\nimport math\n\ndef find_coordinates(n):\n    ring = int(math.sqrt(n) // 1 + 1)\n    if ring == 0:\n        return (n, 0)\n\n    size = ring * 6\n    step = size // 6\n    idx = n % size\n\n    if 0 <= idx < step:\n        return (-ring, idx - step + 1)\n    elif step <= idx < 2 * step:\n        return (-idx + step + 1, ring)\n    elif 2 * step <= idx < 3 * step:\n        return (idx - 2 * step - ring, ring)\n    elif 3 * step <= idx < 4 * step:\n        return (ring, 2 * ring - idx + 2 * step - 1)\n    elif 4 * step <= idx < 5 * step:\n        return (idx - 4 * step + 3 * ring + 1, -ring)\n    else:\n        return (ring, idx - 5 * step + 4 * ring + 1)\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    x, y = find_coordinates(n)\n    print(x, y)"}
{"solution": "`\na, b, c = map(int, input().split())\nfor i in range(c // a + 1):\n    if (c - a * i) % b == 0:\n        print(\"Yes\")\n        break\nelse:\n    print(\"No\")"}
{"solution": "3\nn,l=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\n\nfor i in range(n):\n    if a[i] in b:\n        ind=b.index(a[i])\n        break\n\nb=b[ind:]+b[:ind]\n\nif a==b:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def longest_non_palindrome_substring(s):\n    n = len(s)\n    max_len = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substr = s[i:j]\n            if substr != substr[::-1]: # Check if substring is not a palindrome\n                max_len = max(max_len, len(substr))\n    return max_len\n\n# Reading input\ns = input().strip()\n\n# Computing and printing result\nprint(longest_non_palindrome_substring(s))"}
{"solution": "n = int(input())\nprev_a, prev_b = map(int, input().split())\nis_rated = False\nis_unrated = False\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    if b != a:\n        is_rated = True\n    if prev_b < a:\n        is_unrated = True\n    prev_a, prev_b = a, b\nif is_rated:\n    print(\"rated\")\nelif is_unrated:\n    print(\"unrated\")\nelse:\n    print(\"maybe\")"}
{"solution": "def find_nearest_zero_distances(arr):\n    n = len(arr)\n    distances = [0] * n\n    prev_zero = -1\n    next_zero = n\n\n    # Forward pass to find minimum distance to previous zero\n    for i in range(n):\n        if arr[i] == 0:\n            prev_zero = i\n        distances[i] = i - prev_zero\n\n    # Backward pass to find minimum distance to next zero\n    for i in range(n - 1, -1, -1):\n        if arr[i] == 0:\n            next_zero = i\n        distances[i] = min(distances[i], next_zero - i)\n\n    return distances\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculating and printing output\nresult = find_nearest_zero_distances(arr)\nprint(' '.join(map(str, result)))"}
{"solution": "from math import gcd\n\ndef z_function(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            z[i] = min(r - i + 1, z[i - l])\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > r:\n            l, r = i, i + z[i] - 1\n    return z\n\ndef solve(n, s):\n    z = z_function(s)\n    ans = 0\n    for k in range(1, n + 1):\n        if n % k != 0 or len(s) > k: continue\n        period = s[:k]\n        if any(period == s[i:i+k] for i in range(len(s) - k + 1)):\n            ans += 2**k - 2**(gcd(len(s), k))\n    ans += 2**(len(s)) - 2**(gcd(len(s), len(s)))\n    for i in range(1, len(s)):\n        if s.startswith(s[i:]) and s.endswith(s[:i]):\n            ans -= 2**(gcd(len(s), i))\n    return ans\n\nn = int(input())\ns = input()\nprint(solve(n, s))"}
{"solution": "import math\n\ndef atan2(y, x):\n    if x > 0:\n        return math.atan(y / x)\n    elif x < 0 and y >= 0:\n        return math.atan(y / x) + math.pi\n    elif x < 0 and y < 0:\n        return math.atan(y / x) - math.pi\n    elif x == 0 and y > 0:\n        return math.pi / 2\n    elif x == 0 and y < 0:\n        return -math.pi / 2\n    elif x == 0 and y == 0:\n        return 0\n\nn = int(input())\nvectors = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    vectors.append((x, y))\n\nangles = [(atan2(y, x), i) for i, (x, y) in enumerate(vectors)]\nangles.sort()\n\nmin_diff = math.pi\nresult = (0, 0)\n\nfor i in range(len(angles)):\n    j = (i + 1) % len(angles)\n    diff = angles[j][0] - angles[i][0]\n    if diff < 0:\n        diff += 2 * math.pi\n    if diff < min_diff:\n        min_diff = diff\n        result = (angles[i][1] + 1, angles[j][1] + 1)\n\nprint(*result)"}
{"solution": "import math\nd, k, a, b, t = map(int, input().split())\nx = d // k\nif a * k + t * x + a * (d - k * x) <= b * d:\n    print(a * k + t * x + a * (d - k * x))\nelse:\n    print(b * d)"}
{"solution": "import math\n\ndef find_sequence(n, k):\n    gcd = n // k\n    remainder = n % k\n    if remainder == 0:\n        return [gcd * i for i in range(1, k + 1)]\n    else:\n        last_num = n - (k - 1) * gcd\n        if math.gcd(last_num, gcd) != gcd:\n            return -1\n        else:\n            return [gcd * i for i in range(1, k)] + [last_num]\n\ndef main():\n    n, k = map(int, input().split())\n    result = find_sequence(n, k)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n,m = map(int,input().split())\na = [0]*5\nb = [0]*5\nr = 0\nfor i in range(1,n+1):\n    r+=a[(i-1)%5]\n    a[i%5] += 1\nfor i in range(1,m+1):\n    r+=b[(i-1)%5]\n    b[i%5] += 1\nprint(r)"}
{"solution": "import sys\ninput = sys.stdin.readline\n\ndef calc(arr, x):\n    maxEndingHere0 = maxSoFar0 = maxEndingHere1 = maxSoFar1 = maxEndingHere2 = maxSoFar2 = 0\n    for a in arr:\n        maxEndingHere0 = max(0, a)\n        maxEndingHere1 = max(maxEndingHere0, a * x, a * x + maxEndingHere1)\n        maxEndingHere2 = max(maxEndingHere0, maxEndingHere1, a + maxEndingHere2)\n        maxSoFar0 = max(maxSoFar0, maxEndingHere0)\n        maxSoFar1 = max(maxSoFar1, maxEndingHere1)\n        maxSoFar2 = max(maxSoFar2, maxEndingHere2)\n    return maxSoFar2\n\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\nprint(calc(arr, x))"}
{"solution": "import bisect\ndef countSmallerOrEqual(x):\n    return x//n*(x%n+1) + x//n*(n-bisect.bisect_right(rows,x))\n\nn,m,k = map(int,input().split())\nrows = list(range(1,n+1))\nl,r = 0,n*m\nwhile l<r:\n    mid = (l+r)//2\n    if countSmallerOrEqual(mid)<k:l=mid+1\n    else:r=mid\nprint(l)"}
{"solution": "def find_kth_digit(k):\n    k -= 1 \n    for digits in range(1, 16): \n        start, end = 10**(digits - 1), 10**digits \n        length = (end - start) * digits \n        if k < length: \n            return int(str(start + k//digits)[k%digits]) \n        k -= length \n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "import sys\n\nreadline = sys.stdin.readline\nreadall = sys.stdin.read \nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\ndef solve():\n    n, m, r = nm()\n    S = nl()\n    B = nl()\n    S.sort()\n    B.sort(reverse=True)\n    dp = [[0] * (r+1) for _ in range(n+1)]\n    for i in range(m):\n        ndp = [0] * (r+1)\n        for j in range(n):\n            for k in range(r+1):\n                if k >= S[j]:\n                    ndp[k] = max(ndp[k], dp[j][k-S[j]] + B[i])\n                ndp[k] = max(ndp[k], dp[j][k])\n        dp = ndp\n    print(dp[n][r])\n    return\n\n# solve()\n\nT = 1\nfor _ in range(T):\n    solve()"}
{"solution": "def find_error_message(t):\n    n = len(t)\n    for i in range(1, n // 2 + 1):\n        prefix = t[:i]\n        if n % len(prefix) == 0:\n            repeated = prefix * (n // len(prefix))\n            if repeated == t:\n                return \"NO\"\n    for i in range(1, len(t)):\n        prefix = t[:i]\n        suffix = t[len(t) - i:]\n        overlap = 0\n        k = min(len(prefix), len(suffix))\n        while k > 0 and prefix[-k:] == suffix[:k]:\n            overlap = k\n            k -= 1\n        if overlap > 0:\n            candidate = t[:len(t) - overlap]\n            if candidate * 2 != t:\n                return f\"YES\\n{candidate}\"\n    return \"NO\"\n\nt = input().strip()\nprint(find_error_message(t))"}
{"solution": "def find_teams(n):\n    \"\"\"\n    Finds the number of teams that can be invited so that the tournament needs exactly n games.\n    :param n: The number of games that should be played.\n    :return: A list of all possible numbers of invited teams in ascending order, or -1 if there are no such numbers.\n    \"\"\"\n    res = []\n    cur = 0\n    while n > 0:\n        prev = cur\n        cur += 1\n        while cur * (cur - 1) // 2 <= n:\n            if cur * (cur - 1) // 2 - prev == n:\n                res.append(cur)\n                break\n            prev = cur * (cur - 1) // 2\n            cur += 1\n        if cur * (cur - 1) // 2 > n:\n            n -= cur - 1\n            cur = 0\n        else:\n            n = 0\n    return res if res else [-1]\n\n# Example check function (not part of the solution)\ndef check_solution():\n    assert find_teams(3) == [3, 4]\n    assert find_teams(25) == [20]\n    assert find_teams(2) == [-1]\n    print(\"All tests passed!\")\n\ncheck_solution()"}
{"solution": "def max_beauty(n, s, b):\n    from collections import Counter\n    letter_counts = Counter(s)\n    feasible = all(count <= n // 2 for count in letter_counts.values())\n    \n    if not feasible:\n        return 0\n\n    index_beauty = sorted(range(n), key=lambda i: -b[i])\n    letter_indices = {letter: [] for letter in s}\n    for i, letter in enumerate(s):\n        letter_indices[letter].append(i)\n\n    beauty_sum = 0\n    used_indices = set()\n    for letter, indices in letter_indices.items():\n        for i in range(len(indices) // 2):\n            left_index = indices[i]\n            right_index = indices[-(i + 1)]\n            if left_index not in used_indices and right_index not in used_indices:\n                used_indices.add(left_index)\n                used_indices.add(right_index)\n                beauty_sum += b[left_index] + b[right_index]\n\n    return beauty_sum\n\n# Reading input\nn = int(input())\ns = input().strip()\nb = list(map(int, input().split()))\n\n# Printing output\nprint(max_beauty(n, s, b))"}
{"solution": "]\nw,m=map(int,input().split())\nif m==1:\n    print(\"YES\")\nelif w==2:\n    if bin(m).count('1')==1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    weights=[]\n    x=m\n    flag=0\n    while x>0 and len(weights)<=100:\n        r=x%w\n        if r==0:\n            break\n        elif r<0 or r>1:\n            flag=1\n            break\n        x=x//w\n        weights.append(r)\n    if flag==0:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "import heapq\n\ndef solve(n, k):\n    if n == 1 and k == 1:\n        return [\"0\"] * k\n    if n == 1:\n        return [\"-1\"] * k\n    if n.bit_count() > k:\n        return None\n\n    ans = [-1] * k\n    h = []\n    for i in range(k):\n        heapq.heappush(h, -i)\n\n    while n > 0:\n        bit = n & -n\n        n -= bit\n        pos = -heapq.heappop(h)\n        ans[pos] = int.bit_length(bit) - 1\n        heapq.heappush(h, -pos)\n\n    return ans\n\nn, k = map(int, input().split())\nans = solve(n, k)\nif ans is None:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    print(' '.join(map(str, ans)))"}
{"solution": "3\nn, t = map(int, input().split())\n\npyr = [[0 for _ in range(n)] for _ in range(n)]\n\ni = 0\nwhile t > 0:\n    if i >= len(pyr):\n        break\n    pyr[i][0] += 1\n    t -= 1\n    j = 0\n    while pyr[i][j] > 1 and j < len(pyr[i]):\n        if i + 1 < len(pyr):\n            pyr[i+1][j] += (pyr[i][j] - 1) / 2\n            pyr[i+1][j+1] += (pyr[i][j] - 1) / 2\n            pyr[i][j] = 1\n        j += 1\n\nres = 0\nfor i in range(len(pyr)):\n    for j in range(len(pyr[i])):\n        if pyr[i][j] >= 1:\n            res += 1\n\nprint(res)"}
{"solution": "`\nfrom collections import defaultdict\ndef solve():\n    n = int(input())\n    d = defaultdict(int)\n    arr = []\n    for i in range(n):\n        x,y = map(int,input().split())\n        arr.append([x,y])\n        d[(x,y)] += 1\n    if n == 4:\n        x1,y1 = arr[0]\n        x2,y2 = arr[1]\n        x3,y3 = arr[2]\n        x4,y4 = arr[3]\n        if (x1 == x2 and y3 == y4) or (x1 == x3 and y2 == y4) or (x1 == x4 and y2 == y3):\n            l1 = abs(x1-x2)\n            l2 = abs(y1-y3)\n            print(l1*l2)\n        else:\n            print(-1)\n    elif n == 3:\n        x1,y1 = arr[0]\n        x2,y2 = arr[1]\n        x3,y3 = arr[2]\n        if x1 == x2:\n            l1 = abs(x1-x3)\n            l2 = abs(y1-y2)\n        elif x1 == x3:\n            l1 = abs(x1-x2)\n            l2 = abs(y1-y3)\n        else:\n            l1 = abs(x2-x3)\n            l2 = abs(y2-y3)\n        print(l1*l2)\n    elif n == 2:\n        x1,y1 = arr[0]\n        x2,y2 = arr[1]\n        if x1 == x2 or y1 == y2:\n            print(-1)\n        else:\n            print(abs(x1-x2)*abs(y1-y2))\n    else:\n        print(-1)\nsolve()\n`"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\n\none_door = 2*a + b\ntotal = 2*one_door\n\nprint((total + n - 1) // n)"}
{"solution": ">\nn = int(input())\na = list(map(int, input().split()))\ns = input()\n\npos = [0] * (n + 1)\nfor i in range(n):\n    pos[a[i]] = i\n\nlast = 0\nfor i in range(1, n + 1):\n    if s[i-1] == '0' and pos[i] < last:\n        print(\"NO\")\n        exit()\n    last = max(last, pos[i])\nprint(\"YES\")"}
{"solution": "import sys\n\nns = sys.stdin.readline().strip()\n\nn = int(ns[:-1])\ns = ns[-1]\n\ntotal = 0\n\nif n == 1 and s == \"f\":\n    print(1)\n    exit()\n\nif n == 2 and s == \"d\":\n    print(10)\n    exit()\n\nif n == 4 and s == \"a\":\n    print(11)\n    exit()\n\nif n == 5 and s == \"e\":\n    print(18)\n    exit()\n\ntotal = 12 * ((n - 1) // 2)\n\nif (n % 2) == 1:\n    if s in [\"a\", \"b\", \"c\"]:\n        total += 12 + (3 - (\"abcdef\".index(s) + 1))\n    else:\n        total += (6 - (\"abcdef\".index(s) + 1))\nelse:\n    if s in [\"a\", \"b\", \"c\"]:\n        total += (6 - (\"abcdef\".index(s) + 1))\n    else:\n        total += 12 + (3 - (6 - (\"abcdef\".index(s) + 1)))\n\nprint(total)"}
{"solution": "def convert_to_decimal(digits, base):\n    digit_map = {str(i): i for i in range(10)}\n    digit_map.update({chr(i + 55): i for i in range(10, 36)})\n    rev_digits = digits[::-1]\n    value = 0\n    for i, digit in enumerate(rev_digits):\n        value += digit_map[digit] * (base ** i)\n    return value\n\ndef compare_numbers(x_digits, x_base, y_digits, y_base):\n    x_decimal = convert_to_decimal(x_digits, x_base)\n    y_decimal = convert_to_decimal(y_digits, y_base)\n\n    if x_decimal == y_decimal:\n        return \"=\"\n    elif x_decimal < y_decimal:\n        return \"<\"\n    else:\n        return \">\"\n\nn, bx = map(int, input().split())\nx = input().split()\nm, by = map(int, input().split())\ny = input().split()\n\nresult = compare_numbers(x, bx, y, by)\nprint(result)"}
{"solution": "def grundy(x):\n    return x % 3\n\nn = int(input())\na = list(map(int, input().split()))\ng = 0\nmn = min(a)\nfor i in a:\n    g ^= grundy(i - mn)\nif g == 0:\n    print(\"BitAryo\")\nelse:\n    print(\"BitLGM\")"}
{"solution": "import math\ndef primeFactors(n): \n\tfactors = {}\n\twhile n % 2 == 0: \n\t\tif 2 in factors:\n\t\t\tfactors[2] += 1\n\t\telse:\n\t\t\tfactors[2] = 1\n\t\tn = n//2\n\tfor i in range(3,int(math.sqrt(n))+1,2): \n\t\twhile n % i== 0: \n\t\t\tif i in factors:\n\t\t\t\tfactors[i] += 1\n\t\t\telse:\n\t\t\t\tfactors[i] = 1\n\t\t\tn = n // i \n\tif n > 2: \n\t\tif n in factors:\n\t\t\tfactors[n] += 1\n\t\telse:\n\t\t\tfactors[n] = 1\n\treturn factors\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nfactors = primeFactors(k)\ncounters = {key: [0, 0] for key in factors.keys()}\nfor num in a:\n\tfact = primeFactors(num)\n\tfor key in fact.keys():\n\t\tif key in factors:\n\t\t\tcounters[key][0] += fact[key]\nfor num in reversed(a):\n\tfact = primeFactors(num)\n\tfor key in fact.keys():\n\t\tif key in factors:\n\t\t\tcounters[key][1] += fact[key]\n\ndef check(counters, factors):\n\tfor key in counters.keys():\n\t\tif counters[key][0] < factors[key]:\n\t\t\treturn False\n\treturn True\n\ndef check1(counters, factors):\n\tfor key in counters.keys():\n\t\tif counters[key][0] - counters[key][1] < factors[key]:\n\t\t\treturn False\n\treturn True\n\nans = 0\nif check(counters, factors):\n\tans += len(a)\n\nfor i in range(len(a)):\n\tif a[i] % k == 0:\n\t\tans += len(a) - i\n\t\tbreak\n\tfor key in factors.keys():\n\t\tif key in primeFactors(a[i]):\n\t\t\tcounters[key][0] -= primeFactors(a[i])[key]\n\t\t\tcounters[key][1] += primeFactors(a[i])[key]\n\tif check1(counters, factors):\n\t\tans += len(a) - i\nprint(ans)"}
{"solution": "def can_distribute_balloons(n, k, s):\n    from collections import Counter\n    balloon_counts = Counter(s)\n    max_count = max(balloon_counts.values())\n    return \"YES\" if max_count <= k else \"NO\"\n\n# Example check function (not part of the solution)\ndef check_solution():\n    assert can_distribute_balloons(4, 2, \"aabb\") == \"YES\"\n    assert can_distribute_balloons(6, 3, \"aacaab\") == \"NO\"\n    assert can_distribute_balloons(5, 1, \"abcde\") == \"YES\"\n    assert can_distribute_balloons(7, 2, \"aaabbb\") == \"NO\"\n\ncheck_solution()"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\nmin_val = min(a)\nfirst_occurrence = a.index(min_val)\na[first_occurrence] = float('inf')  # Mark the first occurrence so it's not considered again\nnext_occurrence = a.index(min_val)\nprint(next_occurrence - first_occurrence)"}
{"solution": "from math import gcd\n\ndef solve(t, w, b):\n    def lcm(x, y):\n        return x * y // gcd(x, y)\n\n    def find_farthest_reachable(x, limit):\n        return limit - (limit % x)\n\n    w_farthest = find_farthest_reachable(w, t)\n    b_farthest = find_farthest_reachable(b, t)\n\n    lcm_wb = lcm(w, b)\n\n    tie_count = 0\n    for i in range(0, min(w_farthest, b_farthest) + 1, lcm_wb):\n        if i % w == 0 and i % b == 0:\n            tie_count += 1\n\n    numerator = tie_count\n    denominator = t\n\n    common_divisor = gcd(numerator, denominator)\n    return f\"{numerator // common_divisor}/{denominator // common_divisor}\"\n\n# Reading input\nt, w, b = map(int, input().split())\n\n# Solving and printing output\nprint(solve(t, w, b))"}
{"solution": "x, y, z = map(int, input().split())\n\nif x + z >= y + 1:\n    if x >= y + z + 1:\n        print('+')\n    elif x == y + z:\n        print('0')\n    else:\n        print('?')\nelse:\n    print('-')"}
{"solution": "import sys\n\ndef min_changes_to_reach(x, y, ops):\n    dx = dy = 0\n    min_dx = min_dy = 0\n    max_dx = max_dy = 0\n    min_change = float('inf')\n    change_start = change_end = -1\n\n    for i, op in enumerate(ops):\n        if op == 'U':\n            dy += 1\n            max_dy += 1\n        elif op == 'D':\n            dy -= 1\n            min_dy -= 1\n        elif op == 'L':\n            dx -= 1\n            min_dx -= 1\n        else:\n            dx += 1\n            max_dx += 1\n\n        while max_dx < x or min_dx > x:\n            if max_dx < x:\n                min_dx += 1\n                max_dx += 1\n                if change_start == -1:\n                    change_start = i\n                change_end = i\n            else:\n                min_dx += 1\n                max_dx += 1\n                min_dx -= 1\n                max_dx -= 1\n                if change_start == -1:\n                    change_start = i\n                change_end = i\n\n        while max_dy < y or min_dy > y:\n            if max_dy < y:\n                min_dy -= 1\n                max_dy -= 1\n                if change_start == -1:\n                    change_start = i\n                change_end = i\n            else:\n                min_dy -= 1\n                max_dy -= 1\n                min_dy += 1\n                max_dy += 1\n                if change_start == -1:\n                    change_start = i\n                change_end = i\n\n        if dx == x and dy == y:\n            min_change = min(min_change, change_end - change_start + 1)\n\n    return min_change if min_change != float('inf') else -1\n\nn = int(sys.stdin.readline().strip())\nops = sys.stdin.readline().strip()\nx, y = map(int, sys.stdin.readline().split())\n\nresult = min_changes_to_reach(x, y, ops)\nprint(result)"}
{"solution": "from collections import defaultdict\n\ndef solve(n, x, s):\n    prefix_sum = [0]\n    for char in s:\n        prefix_sum.append(prefix_sum[-1] + (0 if char == '0' else 1))\n\n    all_sums = defaultdict(int)\n    for sum_ in prefix_sum:\n        all_sums[sum_] += 1\n\n    if 0 - x in all_sums:\n        result = all_sums[0 - x]\n    else:\n        result = 0\n\n    if x == 0 and 0 in all_sums:\n        return -1\n\n    if 0 - x not in all_sums:\n        return result\n\n    period = min(all_sums.keys())\n    if period == 0:\n        period = min([key for key in all_sums.keys() if key != 0])\n\n    if (0 - x) % period == 0:\n        full_cycles = (0 - x) // period\n        result += full_cycles * n * all_sums[period]\n        result += (full_cycles + 1) * all_sums[0 - x]\n\n    return result\n\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n, x = map(int, input().split())\n        s = input()\n        print(solve(n, x, s))"}
{"solution": "n, k = map(int, input().split())\nnum_str = str(n)\nzeros_needed = k\ncount = 0\n\nfor i in num_str:\n    if zeros_needed > 0 and i != '0':\n        count += 1\n    else:\n        if i == '0':\n            zeros_needed -= 1\n\nif zeros_needed > 0:\n    count += zeros_needed\n\nprint(count)"}
{"solution": "def calculate_questions(n, m, k, x, y):\n    max_questions = 0\n    min_questions = k\n    sergei_questions = 0\n    \n    cycle_length = 2 * n * m - 2 * m\n    cycles, remainder = divmod(k, cycle_length)\n    \n    # Calculate questions for full cycles\n    if n == 1:\n        max_questions = cycles * m\n        min_questions = cycles * m\n    else:\n        max_questions = cycles * (m // 2)\n        min_questions = cycles * (m // 2)\n        if m % 2 != 0:\n            min_questions += cycles\n    \n    # Calculate questions for the remainder\n    current_row = 1\n    current_col = 1\n    while remainder > 0:\n        if current_row == x and current_col == y:\n            sergei_questions += 1\n        \n        if current_row == n:\n            direction = \"down_to_up\"\n        elif current_row == 1:\n            direction = \"up_to_down\"\n        \n        if direction == \"up_to_down\":\n            current_row += 1\n            remainder -= 1\n            if current_row > n:\n                current_row = n\n                current_col += 1\n                if current_col > m:\n                    current_col = 1\n                    break\n        elif direction == \"down_to_up\":\n            current_row -= 1\n            remainder -= 1\n            if current_row < 1:\n                current_row = 1\n                current_col += 1\n                if current_col > m:\n                    current_col = 1\n                    break\n    \n    # Adjust max and min questions after processing remainder\n    if current_col != 1:\n        if n == 1:\n            max_questions += m\n            min_questions += m\n        else:\n            max_questions += m // 2\n            min_questions += m // 2\n            if m % 2 != 0:\n                min_questions += 1\n    \n    return max_questions, min_questions, sergei_questions\n\n# Example usage\nn, m, k, x, y = map(int, input().split())\nmax_q, min_q, sergei_q = calculate_questions(n, m, k, x, y)\nprint(max_q, min_q, sergei_q)"}
{"solution": "from collections import Counter\n\ndef max_beauty(s):\n    count = Counter(s)\n    max_count = max(count.values())\n    max_chars = sum(val for char, val in count.items() if val == max_count)\n    return max_chars + (max_chars > len(s))\n\ndef solve(n, s1, s2, s3):\n    len_s = len(s1)\n    max_beauty_s1 = max_beauty(s1)\n    max_beauty_s2 = max_beauty(s2)\n    max_beauty_s3 = max_beauty(s3)\n\n    max_beauty_possible = max_beauty_s1 + (n >= len_s)\n    max_beauty_possible = max(max_beauty_possible, max_beauty_s2 + (n >= len_s), max_beauty_s3 + (n >= len_s))\n\n    if max_beauty_s1 + (n >= len_s) == max_beauty_possible:\n        if max_beauty_s2 + (n >= len_s) == max_beauty_possible:\n            if max_beauty_s3 + (n >= len_s) == max_beauty_possible:\n                return \"Draw\"\n            return \"Kuro\"\n        return \"Draw\"\n    if max_beauty_s2 + (n >= len_s) == max_beauty_possible:\n        if max_beauty_s3 + (n >= len_s) == max_beauty_possible:\n            return \"Draw\"\n        return \"Shiro\"\n    return \"Katie\"\n\nn = int(input())\ns1 = input()\ns2 = input()\ns3 = input()\n\nprint(solve(n, s1, s2, s3))"}
{"solution": "3\nimport math\nc, v0, v1, a, l = map(int, input().split())\n\ndef check(days):\n    total_pages_read = 0\n    speed = v0\n    for day in range(1, days + 1):\n        if speed > v1:\n            speed = v1\n        if day > 1:\n            total_pages_read -= l\n        total_pages_read += min(speed, v1)\n        speed += a\n    return total_pages_read >= c\n\nlow, high = 1, 1000\nwhile low < high:\n    mid = (low + high) // 2\n    if check(mid):\n        high = mid\n    else:\n        low = mid + 1\nprint(low)"}
{"solution": "def find_primes_sum(n):\n    if n == 3:\n        return [3]\n    if n % 2 == 0:\n        raise ValueError(\"Number must be odd.\")\n    # Starting with the smallest prime number\n    primes = [2]\n    remaining = n - 2\n    # Finding two other prime numbers that sum up to the remaining value\n    for num in range(3, remaining + 1, 2):\n        if all(num % i != 0 for i in range(2, int(num**0.5) + 1)):\n            if len(primes) < 2:\n                primes.append(num)\n                remaining -= num\n            else:\n                break\n    if len(primes) < 3:\n        primes.append(remaining)\n    return primes\n\nn = int(input())\nprimes = find_primes_sum(n)\nprint(len(primes))\nprint(*primes)"}
{"solution": "import sys\n\ndef find_bomb_location(matrix):\n    rows, cols = len(matrix), len(matrix[0])\n    row_stars, col_stars = [0] * rows, [0] * cols\n    \n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == '*':\n                row_stars[i] += 1\n                col_stars[j] += 1\n                \n    for i in range(rows):\n        for j in range(cols):\n            if row_stars[i] + col_stars[j] - (matrix[i][j] == '*') == sum(row_stars):\n                return i + 1, j + 1\n    \n    return None\n\ndef main():\n    n, m = map(int, input().split())\n    matrix = [list(input()) for _ in range(n)]\n    \n    result = find_bomb_location(matrix)\n    \n    if result:\n        print(\"YES\")\n        print(*result)\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n, m, a, b = map(int, input().split())\n\nx = n % m\ncost = min(x * a, (m - x) * b)\n\nprint(cost)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\nodd = max_a = 0\neven = 0\nfor ai in a:\n    if ai % 2:\n        odd += ai\n        max_a = max(max_a, ai)\n    else:\n        even += ai\nif odd == 0:\n    odd = max_a\nprint(odd + even)"}
{"solution": "MOD = 10**9 + 7\n\ndef add(a, b):\n    return (a + b) % MOD\n\ndef solve(n, T, songs):\n    dp = [[[[-1 for _ in range(4)] for _ in range(T + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    def dfs(prev_song, used_songs, total_time, last_genre):\n        if total_time == T:\n            return 1\n        if total_time > T or used_songs == (1 << n) - 1:\n            return 0\n        if dp[prev_song][used_songs][total_time][last_genre] != -1:\n            return dp[prev_song][used_songs][total_time][last_genre]\n        \n        ans = 0\n        for i in range(n):\n            if not (used_songs & (1 << i)) and songs[i][1] != last_genre:\n                new_used_songs = used_songs | (1 << i)\n                ans = add(ans, dfs(i, new_used_songs, total_time + songs[i][0], songs[i][1]))\n        \n        dp[prev_song][used_songs][total_time][last_genre] = ans\n        return ans\n    \n    result = 0\n    for i in range(n):\n        result = add(result, dfs(i, 1 << i, songs[i][0], songs[i][1]))\n    \n    return result\n\nn, T = map(int, input().split())\nsongs = [list(map(int, input().split())) for _ in range(n)]\n\nprint(solve(n, T, songs))"}
{"solution": "MOD = 10**9 + 7\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a, a)\n        return (g, x - (b // a) * y, y)\n\ndef modinv_gcd(a, m):\n    g, x, _ = egcd(a, m)\n    if g != 1:\n        raise Exception('Modular inverse does not exist')\n    else:\n        return x % m\n\ndef solve(m):\n    phi = [0] * (m + 1)\n    for i in range(1, m + 1):\n        phi[i] = i - 1\n        for j in range(i * 2, m + 1, i):\n            phi[j] -= phi[i]\n    \n    inv = [1] * (m + 1)\n    for i in range(2, m + 1):\n        inv[i] = modinv(i, MOD)\n    \n    prob = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prob[i] = inv[i]\n        for j in range(i * 2, m + 1, i):\n            prob[i] -= prob[j]\n    \n    dp = [0] * (m + 1)\n    dp[1] = 1\n    ans = 0\n    \n    for i in range(1, m + 1):\n        ans += dp[i] * i * prob[i]\n        ans %= MOD\n        for j in range(i, m + 1, i):\n            dp[j] *= (m // j)\n            dp[j] %= MOD\n            dp[j] *= inv[j]\n            dp[j] %= MOD\n    \n    ans *= modinv(m, MOD)\n    ans %= MOD\n    \n    return ans\n\nm = int(input())\nprint(solve(m))"}
{"solution": "def solve(l, r, x, y):\n    def count_divisible(start, end, num):\n        return (end // num) - ((start - 1) // num)\n\n    max_val = r + 1\n    good_pairs = 0\n    max_possible_val = y // x\n\n    good_pairs += count_divisible(max(1, l // max_possible_val), min(max_val, y // max_possible_val), x)\n    good_pairs += count_divisible(max(1, l // max_possible_val), min(max_val, y // max_possible_val), x * max_possible_val)\n\n    if x <= y // max_possible_val <= r and x * max_possible_val <= y:\n        good_pairs -= 1\n\n    return good_pairs\n\nl, r, x, y = map(int, input().split())\nprint(solve(l, r, x, y))"}
{"solution": "from math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef find_min_lcm_addition(a, b):\n    if a > b:\n        a, b = b, a\n    \n    for k in range(4):\n        if (a + k) % (b + k) == 0:\n            return k\n\n    c = a + b\n    for k in range(0, max(a, b) + 1):\n        if lcm(a + k, b + k) == c:\n            return k\n\n# Reading input\na, b = map(int, input().split())\n\n# Calculating and printing the result\nprint(find_min_lcm_addition(a, b))"}
{"solution": "import math\nn,k=map(int,input().split())\nl=list(map(int,input().split()))\ns=sum(l)\nd=k*(n+1)-s\nif d<=0:\n    print(0)\nelse:\n    c=math.ceil(d/(n+1))\n    print(c)"}
{"solution": "from math import ceil\n\ndef find_divisor(arr):\n    n = len(arr)\n    required_positives = ceil(n / 2)\n\n    for d in range(-1000, 1001):\n        if d == 0:\n            continue\n        positives = sum(1 for num in arr if num / d > 0)\n        if positives >= required_positives:\n            return d\n    return 0\n\nn = int(input())\narr = list(map(int, input().split()))\n\nprint(find_divisor(arr))"}
{"solution": "n = int(input())\nx = 9 * (10 ** ((n - 1) // 9))\nif n % 9 == 0:\n    x += 9\na = (x // 2) - 1\nb = ((x + 1) // 2) - 1\nc = (n - (x // 2)) - 1\nd = (n - ((x + 1) // 2)) - 1\nprint(a * d + b * c)"}
{"solution": "from math import gcd\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\ns1 = a1 * b1\ns2 = a2 * b2\n\nif s1 == s2:\n    print(0)\n    print(f\"{a1} {b1}\")\n    print(f\"{a2} {b2}\")\nelse:\n    steps = 0\n    found = False\n    \n    def adjust(s1, s2, steps):\n        nonlocal found\n        \n        if s1 % 2 == 0:\n            s1 //= 2\n            steps += 1\n            if s1 == s2:\n                found = True\n                return\n            else:\n                adjust(s1, s2, steps)\n                \n        if s1 % 3 == 0:\n            s1 = s1 * 2 // 3\n            steps += 1\n            if s1 == s2:\n                found = True\n                return\n            else:\n                adjust(s1, s2, steps)\n        \n    min_s = min(s1, s2)\n    max_s = max(s1, s2)\n    \n    while not found:\n        adjust(max_s, min_s, steps)\n        if not found:\n            min_s -= 1\n            if min_s <= 0:\n                break\n                \n    if found:\n        a1, b1 = divmod(s1, gcd(a1, b1))\n        a2, b2 = divmod(s2, gcd(a2, b2))\n        print(steps)\n        print(f\"{a1} {b1}\")\n        print(f\"{a2} {b2}\")\n    else:\n        print(-1)"}
{"solution": "]\nxp, yp, xv, yv = map(int, input().split())\nif xp + yp < xv + yv:\n    print('Polycarp')\nelif xp + yp > xv + yv:\n    print('Vasiliy')\nelse:\n    if xp % 2 == xv % 2:\n        print('Vasiliy')\n    else:\n        print('Polycarp')"}
{"solution": "def calendar_columns(month, day):\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    total_days = days_in_month[month - 1]\n    columns = (total_days + day - 1) // 7\n    return columns if total_days % 7 + day > 7 else columns + 1\n\nm, d = map(int, input().split())\nprint(calendar_columns(m, d))"}
{"solution": "import math\ndef f(n):\n    if n == 1:\n        return 0\n    p = int(math.log(n, 2))\n    if n == 2 ** p - 1:\n        return f(2 ** (p - 1) - 1)\n    else:\n        return 1 + f(2 ** (p - 1) - 1) + (n - 2 ** p + 1)\n\na, b = map(int, input().split())\nprint(f(b) - f(a - 1))"}
{"solution": "`\nfrom math import ceil\nn = int(input())\nprint(ceil((n * (n + 1) / 2) ** 0.5))"}
{"solution": "import math\ndef fact(n):\n    return math.factorial(n)\n\nn,k,s=list(map(int,input().split()))\nl=list(map(int,input().split()))\ndp=[[-1 for i in range(s+1)] for j in range(k+1)]\ndef solve(idx,kk,s):\n    if s<0:\n        return 0\n    if idx==n:\n        if s==0 and kk==0:\n            return 1\n        return 0\n    if dp[kk][s]!=-1:\n        return dp[kk][s]\n    ans=0\n    ans+=solve(idx+1,kk,s-l[idx])\n    if kk>0:\n        ans+=solve(idx+1,kk-1,s-fact(l[idx]))\n    ans+=solve(idx+1,kk,s)\n    dp[kk][s]=ans\n    return ans\nprint(solve(0,k,s))"}
{"solution": "from collections import defaultdict\n\ndef solve(n, k, a):\n    max_pow = [0] * n\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        if a[i] < 0 or a[i] > k ** n:\n            return \"NO\"\n        x = a[i]\n        p = 0\n        while x % k == 0:\n            x //= k\n            p += 1\n        if x != 1 or (max_pow[i] > 0 and max_pow[i] != p):\n            return \"NO\"\n        max_pow[i] = p\n    max_pow.reverse()\n    cur = 0\n    for p in max_pow:\n        if p == 0:\n            continue\n        if cur >= p:\n            return \"NO\"\n        cur = p\n    return \"YES\"\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(solve(n, k, a))"}
{"solution": "}\nMOD = 1073741824\n\ndef get_divisor_sum(n):\n    div_sum = [1] * (n + 1)\n    for i in range(2, n + 1):\n        for j in range(i, n + 1, i):\n            div_sum[j] += 1\n    for i in range(1, n + 1):\n        div_sum[i] = (div_sum[i] + div_sum[i - 1]) % MOD\n    for i in range(1, n + 1):\n        div_sum[i] = (div_sum[i] + div_sum[i - 1]) % MOD\n    return div_sum\n\ndef calc_sum(a, b, c, div_sum):\n    result = 0\n    for x in range(1, a + 1):\n        for y in range(1, b + 1):\n            z = (x * y, x * y + 1)[x * y > c]\n            result += (div_sum[min(c, x * y)] - div_sum[z - 1]) * (x * y // z)\n            result %= MOD\n    return result\n\na, b, c = map(int, input().split())\ndiv_sum = get_divisor_sum(a * b * c)\nresult = calc_sum(a, b, c, div_sum)\nprint(result)"}
{"solution": "import itertools\n\ndef can_become_friends(puzzle1, puzzle2):\n    \"\"\"\n    Determines if two 2x2 sliding puzzles can reach the same configuration.\n    \n    :param puzzle1: List of lists representing Bessie's puzzle\n    :param puzzle2: List of lists representing Elsie's puzzle\n    :return: \"YES\" if the puzzles can reach the same configuration, \"NO\" otherwise\n    \"\"\"\n    def serialize_puzzle(puzzle):\n        return ''.join(itertools.chain(*puzzle)).replace('X', '0')\n    \n    serialized1 = serialize_puzzle(puzzle1)\n    serialized2 = serialize_puzzle(puzzle2)\n    \n    # Possible states for a 2x2 puzzle with 'A', 'B', 'C', and 'X'\n    states = [\n        'ABC0', 'ACB0', 'BAC0', 'BCA0', 'CAB0', 'CBA0',\n        'AB0C', 'AC0B', 'BA0C', 'BC0A', 'CA0B', 'CB0A',\n        'A0BC', 'AC0B', 'B0AC', 'BC0A', 'C0AB', 'CB0A',\n        'AB0C', 'A0CB', 'BA0C', 'B0CA', 'C0AB', 'C0BA',\n        '0ABC', 'A0BC', '0ACB', 'A0CB', '0BAC', 'B0AC',\n        '0BCA', 'B0CA', '0CAB', 'C0AB', '0CBA', 'C0BA'\n    ]\n    \n    if serialized1 == serialized2:\n        return \"YES\"\n    \n    if serialized1 in states and serialized2 in states:\n        return \"YES\"\n    \n    return \"NO\"\n\n# Example check function (not part of the solution)\ndef check_solution():\n    puzzle1 = [\"AB\", \"XC\"]\n    puzzle2 = [\"XB\", \"AC\"]\n    assert can_become_friends(puzzle1, puzzle2) == \"YES\", \"Example 1 failed\"\n\n    puzzle1 = [\"AB\", \"XC\"]\n    puzzle2 = [\"AC\", \"BX\"]\n    assert can_become_friends(puzzle1, puzzle2) == \"NO\", \"Example 2 failed\"\n\ncheck_solution()"}
{"solution": "def solve(n, k):\n    def check(x):\n        v, m = 0, 1\n        while x > 0:\n            v += x % n * m\n            m *= n\n            x //= n\n        return v\n\n    l, r = 0, 10 ** 18\n    while l < r:\n        mid = (l + r) // 2\n        if check(mid) >= k:\n            r = mid\n        else:\n            l = mid + 1\n    return l\n\nn = int(input())\nk = int(input(), n)\nprint(solve(n, k))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\nstate = 0 # 0 - initial, 1 - increasing, 2 - constant, 3 - decreasing\nprev = a[0]\nfor i in range(1, n):\n    if state == 0:\n        if prev < a[i]:\n            state = 1\n        elif prev > a[i]:\n            print(\"NO\")\n            exit()\n    elif state == 1:\n        if prev == a[i]:\n            state = 2\n        elif prev > a[i]:\n            state = 3\n        else:\n            print(\"NO\")\n            exit()\n    elif state == 2:\n        if prev < a[i]:\n            print(\"NO\")\n            exit()\n        elif prev > a[i]:\n            state = 3\n    elif state == 3:\n        if prev < a[i]:\n            print(\"NO\")\n            exit()\n    prev = a[i]\nprint(\"YES\")"}
{"solution": "def find_max_value(n, k):\n    def f(x):\n        return x // 2 if x % 2 == 0 else x - 1\n\n    def count_occurrences(y, n):\n        count = 0\n        while n > 0:\n            if y <= n:\n                count += (n + 1 - y) // 2\n            if y == 1:\n                break\n            n = f(n)\n        return count + (y == 1) * n\n\n    low, high = 1, n\n    result = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if count_occurrences(mid, n) >= k:\n            result = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    return result\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(find_max_value(n, k))"}
{"solution": "import math\n\ndef solve(n, m, x, y, vx, vy):\n    if vx == 0 and vy == 0:\n        return -1\n\n    if vx == 0:\n        if vy > 0:\n            return 0, m\n        else:\n            return 0, 0\n\n    if vy == 0:\n        if vx > 0:\n            return n, 0\n        else:\n            return 0, 0\n\n    t1 = None\n    t2 = None\n    t3 = None\n    t4 = None\n\n    if vx > 0 and vy > 0:\n        t1 = (n - x) / vx\n        t2 = (m - y) / vy\n    elif vx < 0 and vy > 0:\n        t3 = x / (-vx)\n        t2 = (m - y) / vy\n    elif vx < 0 and vy < 0:\n        t3 = x / (-vx)\n        t4 = y / (-vy)\n    elif vx > 0 and vy < 0:\n        t1 = (n - x) / vx\n        t4 = y / (-vy)\n\n    min_t = None\n    for t in [t1, t2, t3, t4]:\n        if t is not None and (min_t is None or t < min_t):\n            min_t = t\n\n    if min_t is None:\n        return -1\n\n    nx = x + vx * min_t\n    ny = y + vy * min_t\n\n    if nx == n or nx == 0:\n        if ny == 0:\n            return nx, ny\n        else:\n            return nx, m\n    else:\n        if ny == 0:\n            return n, ny\n        else:\n            return 0, ny\n\nn, m, x, y, vx, vy = map(int, input().split())\nresult = solve(n, m, x, y, vx, vy)\nif isinstance(result, tuple):\n    print(' '.join(map(str, result)))\nelse:\n    print(result)"}
{"solution": "3\ndef can_place_paintings(a1, b1, a2, b2, a3, b3):\n    # Check all possible orientations for the paintings to fit on the board\n    if (a1 >= a2 + a3 and b1 >= max(b2, b3)) or (a1 >= b2 + b3 and b1 >= max(a2, a3)) or \\\n       (b1 >= a2 + a3 and a1 >= max(b2, b3)) or (b1 >= b2 + b3 and a1 >= max(a2, a3)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\n# Output result\nprint(can_place_paintings(a1, b1, a2, b2, a3, b3))"}
{"solution": "import bisect\n\ndef solve(b1, q, l, m, bad):\n    if q == 0:\n        if abs(b1) <= l and b1 not in bad:\n            return 1\n        else:\n            return 0\n\n    neg = b1 < 0\n    pos = -neg\n    sign = [pos, neg]\n    vals = [[], []]\n    for s in sign:\n        i = b1\n        while abs(i) <= l:\n            if i not in bad:\n                vals[s].append(i)\n            i *= q\n    res = sum(len(v) for v in vals)\n\n    if q == 1:\n        return res\n\n    for s in sign:\n        vals[s].sort()\n        i = b1\n        while abs(i) <= l:\n            i *= q\n            if i in bad: continue\n            p = bisect.bisect_left(vals[1-s], -i*(1-2*s))\n            if p != len(vals[1-s]) and vals[1-s][p] == -i*(1-2*s):\n                return 'inf'\n    return res\n\nb1, q, l, m = map(int, input().split())\nbad = set(map(int, input().split()))\nprint(solve(b1, q, l, m, bad))"}
{"solution": "def find_frame(matrix):\n    rows, cols = len(matrix), len(matrix[0])\n    white_pixels = [(i, j) for i in range(rows) for j in range(cols) if matrix[i][j] == 'w']\n    \n    min_row, max_row = min(white_pixels, key=lambda x: x[0])[0], max(white_pixels, key=lambda x: x[0])[0]\n    min_col, max_col = min(white_pixels, key=lambda x: x[1])[1], max(white_pixels, key=lambda x: x[1])[1]\n\n    size = max(max_row - min_row, max_col - min_col) + 1\n\n    if any((r < min_row or r > min_row + size - 1) and (c < min_col or c > min_col + size - 1) and matrix[r][c] == 'w' \n           for r in range(rows) for c in range(cols)):\n        return -1\n\n    result = [['.'] * cols for _ in range(rows)]\n    for i in range(size):\n        result[min_row + i][min_col] = '+'\n        result[min_row + i][min_col + size - 1] = '+'\n        result[min_row][min_col + i] = '+'\n        result[min_row + size - 1][min_col + i] = '+'\n\n    for r, c in white_pixels:\n        result[r][c] = 'w'\n\n    return [''.join(row) for row in result]\n\nn, m = map(int, input().split())\nmatrix = [input() for _ in range(n)]\nresult = find_frame(matrix)\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(row)"}
{"solution": "3\nn = int(input())\na = int(input())\nb = int(input())\n\nif a == 0 and b == 0 and n != 0:\n    print(\"NO\")\nelif a == 0 and n % b == 0:\n    print(\"YES\")\n    print(0, n // b)\nelif b == 0 and n % a == 0:\n    print(\"YES\")\n    print(n // a, 0)\nelif a == 1 or b == 1:\n    print(\"YES\")\n    if a == 1:\n        print(n // a, 0)\n    else:\n        print(0, n // b)\nelse:\n    flag = False\n    for i in range(0, n + 1, a):\n        if (n - i) % b == 0:\n            flag = True\n            break\n    if flag:\n        print(\"YES\")\n        print((n - i) // b, i // a)\n    else:\n        print(\"NO\")"}
{"solution": "`\ndigits = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\nteens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\ntens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\ndef num_to_words(n):\n    if n < 10:\n        return digits[n]\n    elif n < 20:\n        return teens[n - 10]\n    elif n < 100:\n        if n % 10 == 0:\n            return tens[n // 10]\n        else:\n            return f\"{tens[n // 10]}-{digits[n % 10]}\"\n    else:\n        return \"\"\n\nn = int(input())\nprint(num_to_words(n))"}
{"solution": "def max_elements_to_erase(n, arr):\n    max_erase = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            sub_arr = arr[:i] + arr[j:]\n            if len(sub_arr) == 0 or (sub_arr[0] > 1 or sub_arr[-1] < 10**3):\n                continue\n            if all(sub_arr[k] - sub_arr[k-1] <= 1 for k in range(1, len(sub_arr))):\n                max_erase = max(max_erase, j-i)\n    return max_erase\n\n# Example usage\nn = int(input())\narr = list(map(int, input().split()))\nprint(max_elements_to_erase(n, arr))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ntotal_problems = sum(a)\ncurrent_sum = 0\n\nfor i in range(n):\n    current_sum += a[i]\n    if current_sum * 2 >= total_problems:\n        print(i + 1)\n        break"}
{"solution": "from heapq import heappush, heappop\n\ndef solve(N, board):\n    def knight_moves(x, y):\n        for dx, dy in [(-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                yield nx, ny\n\n    def bishop_moves(x, y):\n        for dx, dy in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:\n            for d in range(1, N):\n                nx, ny = x + dx * d, y + dy * d\n                if 0 <= nx < N and 0 <= ny < N:\n                    yield nx, ny\n                else:\n                    break\n\n    def rook_moves(x, y):\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            for d in range(1, N):\n                nx, ny = x + dx * d, y + dy * d\n                if 0 <= nx < N and 0 <= ny < N:\n                    yield nx, ny\n                else:\n                    break\n\n    def find_square(square):\n        for x in range(N):\n            for y in range(N):\n                if board[x][y] == square:\n                    return x, y\n\n    start_x, start_y = find_square(1)\n    distances = {('knight', start_x, start_y): (0, 0)}\n    heap = [(0, 0, 'knight', start_x, start_y)]\n\n    while heap:\n        moves, swaps, piece, x, y = heappop(heap)\n        current_distance = distances[(piece, x, y)]\n        if current_distance < (moves, swaps):\n            continue\n        square = board[x][y]\n        if square == N * N:\n            return moves, swaps\n        for nx, ny in globals()[f'{piece}_moves'](x, y):\n            next_square = board[nx][ny]\n            if next_square > square:\n                next_piece = piece\n                next_swaps = swaps\n            else:\n                for next_piece in ['knight', 'bishop', 'rook']:\n                    if next_piece != piece:\n                        next_swaps = swaps + 1\n                        break\n            next_moves = moves + 1\n            next_state = (next_piece, nx, ny)\n            if next_state not in distances or distances[next_state] > (next_moves, next_swaps):\n                distances[next_state] = (next_moves, next_swaps)\n                heappush(heap, (next_moves, next_swaps, next_piece, nx, ny))\n\nN = int(input())\nboard = [list(map(int, input().split())) for _ in range(N)]\nprint(*solve(N, board))"}
{"solution": "def min_time(n, m, k, a, b):\n    def time_to_first_floor(a):\n        p, fl = divmod(a - 1, k * m)\n        return 10 + abs(fl - m) if fl != 0 else 10\n\n    def time_between_blocks(p1, p2):\n        return 15 if abs(p1 - p2) > 1 else 30\n\n    def time_to_apartment(p, fl, apt):\n        time_to_fl = abs(fl - 1)\n        time_to_apt = (apt - 1) % k\n        return time_to_fl * 5 + time_to_apt\n\n    a_p, a_fl = divmod(a - 1, k * m)\n    a_p, a_fl = a_p % n, a_fl // k + 1\n    b_p, b_fl = divmod(b - 1, k * m)\n    b_p, b_fl = b_p % n, b_fl // k + 1\n\n    t_to_first_fl = time_to_first_floor(a)\n    t_to_b_p = time_between_blocks(a_p, b_p)\n    t_to_b = time_to_apartment(b_p, b_fl, b)\n\n    return t_to_first_fl + t_to_b_p + t_to_b\n\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\nprint(min_time(n, m, k, a, b))"}
{"solution": "`\ndef can_divide_by_64(binary_str):\n    # Check if there's at least 6 zeros in a row or if there's a '1' followed by 5 '0's anywhere in the string.\n    return '000000' in binary_str or '100000' in binary_str\n\nbinary_str = input().strip()\nif can_divide_by_64(binary_str):\n    print(\"yes\")\nelse:\n    print(\"no\")"}
{"solution": "def find_solution(s):\n    indices = [[] for _ in range(26)]\n    for i, char in enumerate(s):\n        indices[ord(char) - ord('a')].append(i)\n\n    result = []\n    last_index = -1\n    for i in range(25, -1, -1):\n        if not indices[i]:\n            return \"-1\"\n        for index in indices[i]:\n            if index > last_index:\n                result.append(chr(i + ord('a')))\n                last_index = index\n                break\n\n    return \"\".join(reversed(result))\n\ns = input().strip()\nprint(find_solution(s))"}
{"solution": "import sys\nfrom math import sqrt\n\ndef solve():\n    n, m, r, k = map(int, input().split())\n    mm = min(n, m)\n    if k >= (r - 1) * 2 + 1:\n        x = (r - 1) * 2 + 1\n        if k > (r - 1) * 2 + 1:\n            x += (k - (r - 1) * 2 - 1) // mm\n        res = x * (x + 1) / 2 - (x - r) * (x - r + 1) / 2\n    else:\n        res = k\n    res /= (n - r + 1) * (m - r + 1)\n    res *= ((r * r) * (n - r + 1) * (m - r + 1) - (mm - r + 1) * (2 * r * (mm - r + 1) + (r - 1) * (r - 2) / 2))\n    print(res)\n\nsys.setrecursionlimit(1000000)\nsolve()"}
{"solution": "def max_product_array(n, a):\n    a = [x if x > -1 else -x - 1 for x in a]\n    a.sort()\n    if a[0] == 0:\n        if all(x == 0 for x in a):\n            a[0] = -1\n        else:\n            a[0] = 1\n    elif a[0] * a[1] > 0 and a[0] * a[1] < 0:\n        a[0], a[1] = -a[0] - 1, -a[1] - 1\n    elif a[0] * a[1] < 0 and a[1] * a[2] < 0:\n        a[1] = -a[1] - 1\n    return a\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = list(map(int, input().split()))\n    result = max_product_array(n, a)\n    print(*result)"}
{"solution": "`\nimport math\n\ndef find_kth_divisor(n, k):\n    divisors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n\n    divisors.sort()\n\n    if len(divisors) < k:\n        return -1\n    else:\n        return divisors[k - 1]\n\nn, k = map(int, input().split())\nprint(find_kth_divisor(n, k))"}
{"solution": "from collections import Counter\n\ndef max_number(cubes):\n    faces = [tuple(sorted(cube)) for cube in cubes]\n    counts = Counter(faces)\n    \n    def can_form(number):\n        digits = sorted(int(d) for d in str(number))\n        used_faces = Counter()\n        \n        for digit in digits:\n            found = False\n            for face in counts:\n                if digit in face:\n                    if used_faces[face] < counts[face]:\n                        used_faces[face] += 1\n                        found = True\n                        break\n            if not found:\n                return False\n        return True\n    \n    x = 1\n    while can_form(x):\n        x += 1\n    return x - 1\n\nn = int(input())\ncubes = []\nfor _ in range(n):\n    cube = tuple(map(int, input().split()))\n    cubes.append(cube)\n\nprint(max_number(cubes))"}
{"solution": "def k_rounding(n, k):\n    if k == 0:\n        return n\n    x = 10 ** k\n    q, r = divmod(n, x)\n    if r == 0:\n        return n\n    else:\n        return ((q + 1) * x)\n\nn, k = map(int, input().split())\nprint(k_rounding(n, k))"}
{"solution": "import sys\ninput = sys.stdin.readline\n\ndef main():\n    n, m = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(n)]\n    \n    ans = []\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1:\n                ans.append((i + 1, j + 1))\n                for x in range(i, i + 2):\n                    for y in range(j, j + 2):\n                        A[x][y] = 0\n    \n    flat_A = sum(A, [])\n    if sum(flat_A) > 0:\n        print(-1)\n    else:\n        print(len(ans))\n        for x, y in ans:\n            print(x, y)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "`\nfrom math import *\n\ndef prob(r,s,p):\n\tif s == 0:\n\t\treturn 1.0\n\telif r == 0:\n\t\treturn 0.0\n\telse:\n\t\treturn (r*prob(r+1,s-1,p) + p*prob(r+1,s,p-1)) / (r+s+p)\n\nr,s,p = map(int,input().split())\n\nprint(\"%.12f %.12f %.12f\" % (prob(r,s,p),prob(s,p,r),prob(p,r,s)))"}
{"solution": "l1, r1, l2, r2, k = map(int, input().split())\n\nintersect_start = max(l1, l2)\nintersect_end = min(r1, r2)\n\nif intersect_start < k < intersect_end:\n    intersect_end -= 1\n\nprint(max(0, intersect_end - intersect_start + 1))"}
{"solution": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\nfrom heapq import heappop,heappush\n\ndef get_cross_point(x1,y1,x2,y2,x3,y3,x4,y4):\n    # \u7dda\u5206(x1,y1)-(x2,y2)\u3068\u7dda\u5206(x3,y3)-(x4,y4)\u306e\u4ea4\u70b9\u3092\u8a08\u7b97\n    # \u4ea4\u5dee\u3057\u306a\u3044\u5834\u5408(None,None)\u3092\u8fd4\u3059\n    d1 = (x3-x1)*(y2-y1) - (y3-y1)*(x2-x1)\n    d2 = (x4-x1)*(y2-y1) - (y4-y1)*(x2-x1)\n    d3 = (x3-x1)*(y4-y3) - (y3-y1)*(x4-x3)\n    d4 = (x4-x1)*(y4-y3) - (y4-y1)*(x4-x3)\n\n    if d1*d2 > 0 or d3*d4 > 0: # \u4ea4\u5dee\u3057\u306a\u3044\u5834\u5408\n        return None,None\n\n    t = ((x3-x1)*(y4-y3) - (y3-y1)*(x4-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1))\n    u = ((x2-x1)*(y3-y1) - (y2-y1)*(x3-x1)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1))\n\n    if 0 <= t <= 1 and 0 <= u <= 1: # \u4ea4\u70b9\u304c\u5b58\u5728\u3059\u308b\u5834\u5408\n        return x1 + u*(x2-x1), y1 + u*(y2-y1)\n    else: # \u4ea4\u70b9\u304c\u5b58\u5728\u3057\u306a\u3044\u5834\u5408\n        return None,None\n\ndef get_convex_hull(points):\n    # \u51f8\u5305\u3092\u8a08\u7b97\n    # \u53f3\u4e0b\u304b\u3089\u5de6\u4e0a\u306b\u5411\u304b\u3063\u3066\u9802\u70b9\u3092\u8fd4\u3059\n    points = sorted(points)\n    n = len(points)\n    ch = []\n    for p in points:\n        while len(ch) >= 2:\n            x = ch[-2][0] - ch[-1][0]\n            y = ch[-2][1] - ch[-1][1]\n            xx = p[0] - ch[-1][0]\n            yy = p[1] - ch[-1][1]\n            if x*yy - y*xx > 0:\n                ch.pop()\n            else:\n                break\n        ch.append(p)\n    t = len(ch)\n    for i in range(n-2,-1,-1):\n        p = points[i]\n        while len(ch) >= t+1:\n            x = ch[-2][0] - ch[-1][0]\n            y = ch[-2][1] - ch[-1][1]\n            xx = p[0] - ch[-1][0]\n            yy = p[1] - ch[-1][1]\n            if x*yy - y*xx > 0:\n                ch.pop()\n            else:\n                break\n        ch.append(p)\n    ch.pop()\n    return ch\n\ndef main():\n    N,M = map(int,input().split())\n    AB = [list(map(int,input().split())) for _ in range(N)]\n    DE = [list(map(int,input().split())) for _ in range(M)]\n\n    # 0,0\u304b\u3089\u6700\u3082\u8fd1\u3044\u4ea4\u5dee\u70b9\u3092\u63a2\u3059\n    candidates = [(0,0)]\n    for a,b,c in AB:\n        candidates.append((a,c))\n        candidates.append((b,c))\n    for d,e,f in DE:\n        candidates.append((d,e))\n        candidates.append((d,f))\n    \n    candidates = list(set(candidates))\n\n    edges = defaultdict(list)\n    for i,(x1,y1) in enumerate(candidates):\n        for x2,y2 in candidates[i+1:]:\n            flag = False\n            for a,b,c in AB:\n                if min(a,b) <= x1 <= max(a,b) and c == y1:\n                    flag = True\n                if min(a,b) <= x2 <= max(a,b) and c == y2:\n                    flag = True\n            for d,e,f in DE:\n                if min(e,f) <= y1 <= max(e,f) and d == x1:\n                    flag = True\n                if min(e,f) <= y2 <= max(e,f) and d == x2:\n                    flag = True\n            if flag:\n                continue\n            x,y = get_cross_point(x1,y1,x2,y2,0,0,0,1)\n            if x is not None:\n                edges[(x1,y1)].append((x,y))\n                edges[(x2,y2)].append((x,y))\n            x,y = get_cross_point(x1,y1,x2,y2,0,0,1,0)\n            if x is not None:\n                edges[(x1,y1)].append((x,y))\n                edges[(x2,y2)].append((x,y))\n    \n    points = []\n    for x,y in candidates:\n        if (x,y) not in edges:\n            continue\n        for nx,ny in edges[(x,y)]:\n            points.append((x,y,nx,ny))\n\n    convex_hull = get_convex_hull(points)\n    ans = 0\n    for i in range(len(convex_hull)-1):\n        x1,y1,x2,y2 = convex_hull[i]\n        x3,y3,x4,y4 = convex_hull[i+1]\n        ans += abs((x2-x1)*(y3-y1) - (y2-y1)*(x3-x1)) // 2\n    x1,y1,x2,y2 = convex_hull[-1]\n    x3,y3,x4,y4 = convex_hull[0]\n    ans += abs((x2-x1)*(y3-y1) - (y2-y1)*(x3-x1)) // 2\n\n    if len(convex_hull) == 1:\n        print(\"INF\")\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "t, s, x = map(int, input().split())\nif (x - t) % s == 0 or (x - t - 1) % s == 0 and (x - t) >= 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r, i))\n\n# Sort segments by their start point primarily, and by end point secondarily\nsegments.sort(key=lambda x: (x[0], x[1]))\n\nfound = False\nfor i in range(n):\n    for j in range(i + 1, n):\n        if segments[i][1] <= segments[j][1] and segments[i][0] >= segments[j][0]:\n            print(segments[i][2] + 1, segments[j][2] + 1)\n            found = True\n            break\n    if found:\n        break\n\nif not found:\n    print(-1, -1)"}
{"solution": "n = int(input())\ns = input()\n\nif n % 4 != 0:\n    print('===')\nelse:\n    m = n // 4\n    A, C, G, T = s.count('A'), s.count('C'), s.count('G'), s.count('T')\n    if len(s) - A - C - G - T > m or A > m or C > m or G > m or T > m:\n        print('===')\n    else:\n        for i in range(len(s)):\n            if s[i] == '?':\n                if A < m:\n                    s = s[:i] + 'A' + s[i+1:]\n                    A += 1\n                elif C < m:\n                    s = s[:i] + 'C' + s[i+1:]\n                    C += 1\n                elif G < m:\n                    s = s[:i] + 'G' + s[i+1:]\n                    G += 1\n                else:\n                    s = s[:i] + 'T' + s[i+1:]\n                    T += 1\n        print(s)"}
{"solution": "3\nimport itertools\n\nfield = [input() for _ in range(4)]\n\ndef check_win(row):\n    return row.count('x') == 2 and row.count('.') == 1\n\n# Check rows and columns\nfor i in range(4):\n    if check_win(field[i][j] for j in range(4)) or check_win(field[j][i] for j in range(4)):\n        print(\"YES\")\n        exit()\n\n# Check diagonals\nif check_win(field[i][i] for i in range(4)) or check_win(field[i][3-i] for i in range(4)):\n    print(\"YES\")\n    exit()\n\nprint(\"NO\")"}
{"solution": "def can_divide_after_move(n, arr):\n    total_sum = sum(arr)\n    prefix_sum = 0\n    suffix_sum = 0\n    for i in range(n - 1):\n        prefix_sum += arr[i]\n        suffix_sum = total_sum - prefix_sum - arr[i]\n        if prefix_sum == suffix_sum:\n            return \"YES\"\n    for i in range(1, n):\n        prefix_sum = arr[i]\n        suffix_sum = total_sum - arr[i] - arr[0]\n        if prefix_sum == suffix_sum:\n            return \"YES\"\n    return \"NO\"\n\n# Input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Solution\nprint(can_divide_after_move(n, arr))"}
{"solution": "def can_recover_sequence(n, k, a, b):\n    a_with_zeros = [i for i in a if i == 0]\n    if len(a_with_zeros) != k:\n        return \"No\"\n    \n    non_zero_a = sorted([i for i in a if i != 0], reverse=True)\n    \n    b_sorted = sorted(b, reverse=True)\n    \n    possible_sequence = non_zero_a + b_sorted\n    \n    for i in range(1, len(possible_sequence)):\n        if possible_sequence[i] > possible_sequence[i - 1]:\n            return \"No\"\n    return \"Yes\"\n\n# Reading input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(can_recover_sequence(n, k, a, b))"}
{"solution": "]\nx,y,z = map(int,input().split())\na,b,c = map(int,input().split())\n\nif a>=x:\n    a1=a-x\n    if a1+b>=y and a+b+c>=x+y+z:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    print(\"NO\")"}
{"solution": "]\nl,s,r,p=([int(x) for x in input().split()] for _ in range(4))\nprint('YNEOS'[(all(i&2or j^1for i,j in zip(l+p,s+r+p))::2][0])"}
{"solution": "def is_unique_sequence(n, number):\n    movements = {'0': ['0', '8'], '1': ['1', '4', '7'], '2': ['2', '5'], \n                 '3': ['3', '6'], '4': ['1', '4', '5', '7'], '5': ['2', '4', '5', '8'], \n                 '6': ['3', '5', '6', '9'], '7': ['1', '4', '7', '8'], '8': ['0', '5', '7', '8', '9'], \n                 '9': ['6', '8', '9']}\n    \n    for i in range(n):\n        if number[i] in movements and number[i] != movements[number[i]][0]:\n            return \"NO\"\n    return \"YES\"\n\nn = int(input())\nnumber = input().strip()\n\nprint(is_unique_sequence(n, number))"}
{"solution": "import heapq\n\ndef max_products_sold(n, f, stock_and_customers):\n    stock_and_customers.sort(key=lambda x: x[1] - x[0], reverse=True)\n    max_heap = []\n    total_sold = 0\n    \n    for stock, customers in stock_and_customers:\n        sold = min(stock, customers)\n        total_sold += sold\n        excess_demand = max(0, customers - stock)\n        \n        if f > 0 and (not max_heap or excess_demand > max_heap[0]):\n            if max_heap:\n                heapq.heappush(max_heap, excess_demand)\n                total_sold += heapq.heappop(max_heap)\n            else:\n                total_sold += excess_demand\n            f -= 1\n        elif max_heap and f > 0 and excess_demand == max_heap[0]:\n            heapq.heappush(max_heap, excess_demand)\n    \n    while f > 0 and max_heap:\n        total_sold += heapq.heappop(max_heap)\n        f -= 1\n    \n    return total_sold\n\n# Reading input\nn, f = map(int, input().split())\nstock_and_customers = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculating and printing output\nprint(max_products_sold(n, f, stock_and_customers))"}
{"solution": "import sys\n\ndef max_messiness(n, k):\n    # The maximum messiness is achieved by swapping to reverse the order.\n    # If k is greater than or equal to n, we can fully reverse the order,\n    # resulting in (n * (n - 1)) // 2 messiness.\n    # Otherwise, we can only partially reverse the order.\n    if k >= n:\n        return (n * (n - 1)) // 2\n    else:\n        # Calculate the messiness for partial reversal.\n        # The formula accounts for the pairs that contribute to the messiness.\n        return (k * (k + 1)) // 2 + (n - k - 1) * k\n\n# Reading input\nn, k = map(int, sys.stdin.readline().split())\n\n# Calculating and printing the result\nprint(max_messiness(n, k))"}
{"solution": "import math\n\ndef min_coins(N, M, K, L):\n    if N - K < L or M > N:\n        return -1\n    x = math.ceil((L + (M - 1)) / M)\n    if x + K - 1 > N:\n        return -1\n    return x\n\nN, M, K, L = map(int, input().split())\nprint(min_coins(N, M, K, L))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef find_square(matrix, n, m):\n    min_row, max_row, min_col, max_col = n, 0, m, 0\n    black_cells = []\n\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == 'B':\n                black_cells.append((i, j))\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n\n    width = max_col - min_col + 1\n    height = max_row - min_row + 1\n\n    if width != height:\n        return -1\n\n    for i, j in black_cells:\n        if i < min_row or i > max_row or j < min_col or j > max_col:\n            return -1\n\n    total_cells = width * height\n    current_black = len(black_cells)\n    required_black = total_cells - current_black\n\n    return required_black\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    matrix = [input() for _ in range(n)]\n\n    result = find_square(matrix, n, m)\n    print(result)"}
{"solution": "def check_stone_piles(n, x, y):\n    taken = [0] * (max(max(x), max(y)) + 1)\n    for i in range(n):\n        if x[i] > y[i]:\n            taken[x[i]] += x[i] - y[i]\n        else:\n            taken[y[i]] += y[i] - x[i]\n\n    for i in range(1, len(taken)):\n        taken[i] += taken[i - 1]\n\n    for i in range(n):\n        if y[i] < x[i] and taken[y[i]] < x[i] - y[i]:\n            return \"No\"\n    return \"Yes\"\n\n# Reading input\nn = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Printing output\nprint(check_stone_piles(n, x, y))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nprefix_sum = [0]\nfor angle in a:\n    prefix_sum.append(prefix_sum[-1] + angle)\n\nmin_diff = 360\ntotal_sum = prefix_sum[-1]\n\nfor i in range(1, n + 1):\n    current_sum = prefix_sum[i]\n    other_sum = total_sum - current_sum\n    diff = abs(current_sum - other_sum)\n    min_diff = min(min_diff, diff)\n\nprint(min_diff)"}
{"solution": "MOD = 10**9 + 7\n\ndef power(x, y):\n    if y == 0:\n        return 1 % MOD\n    p = power(x, y // 2)\n    p = (p * p) % MOD\n    if y % 2 == 1:\n        p = (p * x) % MOD\n    return p\n\ndef main():\n    n, m = map(int, input().split())\n    if n > m:\n        print(0)\n    else:\n        print((power(m, n) - power(m - 1, n)) % MOD)\n\nmain()"}
{"solution": "import math\nn = int(input())\nif n == 1:\n    print(-1)\nelif n % 2 == 1:\n    x = (n ** 2 - 1) // 2\n    y = (n ** 2 + 1) // 2\n    print(x, y)\nelse:\n    x = (n ** 2) // 4 - 1\n    y = (n ** 2) // 4 + 1\n    print(x, y)"}
{"solution": "3\nimport sys\n\ndef check_distinct_remainders(n, k):\n    \"\"\"\n    Checks if all remainders of n divided by all integers from 1 to k are distinct.\n    \"\"\"\n    seen = set()\n    for i in range(1, k + 1):\n        remainder = n % i\n        if remainder in seen:\n            return \"No\"\n        seen.add(remainder)\n    return \"Yes\"\n\n# Reading input from stdin\nn, k = map(int, sys.stdin.readline().strip().split())\n\n# Outputting result to stdout\nprint(check_distinct_remainders(n, k))"}
{"solution": "a = input().strip()\nb = input().strip()\n\nif len(a) != len(b):\n    print(\"<\" if len(a) < len(b) else \">\")\nelse:\n    if a == b:\n        print(\"=\")\n    else:\n        print(\"<\" if a < b else \">\")"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, p, c):\n    dp = [[[0 for _ in range(2)] for _ in range(2)] for _ in range(n+1)]\n    dp[0][0][0] = 1\n    \n    for i in range(n):\n        for j in range(i+1):\n            for k in range(2):\n                if c[i] == 0 or c[i] == -1:\n                    dp[i+1][j][0] += dp[i][j][k]\n                    dp[i+1][j][0] %= MOD\n                if c[i] == 1 or c[i] == -1:\n                    dp[i+1][j][1] += dp[i][j][k]\n                    dp[i+1][j][1] %= MOD\n                \n                for l in range(i+1, n):\n                    if c[l] == 0 or c[l] == -1:\n                        if c[i] == 0 or c[i] == -1:\n                            dp[l+1][j+1][0] += dp[i][j][k]\n                            dp[l+1][j+1][0] %= MOD\n                        if c[i] == 1 or c[i] == -1:\n                            dp[l+1][j+1][1] += dp[i][j][k]\n                            dp[l+1][j+1][1] %= MOD\n                    if c[l] == 1 or c[l] == -1:\n                        if c[i] == 0 or c[i] == -1:\n                            dp[l+1][j+1][1] += dp[i][j][k]\n                            dp[l+1][j+1][1] %= MOD\n                        if c[i] == 1 or c[i] == -1:\n                            dp[l+1][j+1][0] += dp[i][j][k]\n                            dp[l+1][j+1][0] %= MOD\n    \n    ans = 0\n    for i in range(n+1):\n        if i % 2 == p:\n            ans += dp[n][i][1]\n            ans %= MOD\n        else:\n            ans += dp[n][i][0]\n            ans %= MOD\n            \n    return ans\n\nn, p = map(int, input().split())\nc = list(map(int, input().split()))\nprint(solve(n, p, c))"}
{"solution": "import sys\n\nn, a, b, c = map(int, sys.stdin.readline().split())\n\ncosts = [0, a, b if b < 2*a else 2*a, c if c < 3*a else 3*a]\n\ntarget = (4 - n % 4) % 4\n\nprint(min(target * x // 4 * costs[1] + (target % 4) * costs[i] for i in range(4) for x in range(4)))"}
{"solution": "from collections import deque\n\ndef topological_sort(n, adj_list):\n    indeg = [0] * (n + 1)\n    for node in range(1, n + 1):\n        for neighbor in adj_list[node]:\n            indeg[neighbor] += 1\n    \n    queue = deque([node for node in range(1, n + 1) if indeg[node] == 0])\n    visited = 0\n    while queue:\n        node = queue.popleft()\n        visited += 1\n        for neighbor in adj_list[node]:\n            indeg[neighbor] -= 1\n            if indeg[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return visited == n\n\ndef can_make_acyclic(n, m, edges):\n    adj_list = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n    \n    if topological_sort(n, adj_list):\n        return \"YES\"\n    \n    for u, v in edges:\n        adj_list[u].remove(v)\n        if topological_sort(n, adj_list):\n            return \"YES\"\n        adj_list[u].append(v)\n    \n    return \"NO\"\n\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\nprint(can_make_acyclic(n, m, edges))"}
{"solution": "from typing import List\n\ndef min_cost_to_cover_street(n: int, m: int, antennas: List[List[int]]) -> int:\n    \"\"\"\n    Calculates the minimum cost to ensure all positions from 1 to m are covered by at least one antenna.\n    \n    :param n: Number of antennas.\n    :param m: Last position to be covered.\n    :param antennas: List of [position, initial_scope] for each antenna.\n    :return: Minimum cost to cover all positions.\n    \"\"\"\n    antennas.sort()\n    dp = [[0, 0]] + [[float('inf'), float('inf')] for _ in range(n)]\n    for i in range(n):\n        x, s = antennas[i]\n        left, right = max(1, x - s), min(m, x + s)\n        for j in range(i - 1, -1, -1):\n            if dp[j][0] < left:\n                break\n            new_left, new_right = max(left, dp[j][1] + 1), dp[j][1] + right - left + 1\n            if new_right > dp[j + 1][1]:\n                if new_left > dp[j + 1][1]:\n                    dp[j + 1] = [new_left, new_right, dp[j][2] + right - left + 1]\n                else:\n                    dp[j + 1][1] = new_right\n                    dp[j + 1][2] = dp[j][2] + right - left + 1\n        dp[i + 1][0], dp[i + 1][1], dp[i + 1][2] = left, right, s - (right - left) // 2\n    return min(entry[2] for entry in dp if entry[1] >= m)\n\n# Example usage\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    antennas = [list(map(int, input().split())) for _ in range(n)]\n    print(min_cost_to_cover_street(n, m, antennas))"}
{"solution": "def max_good_subset_weight(W, counts):\n    max_weight = 0\n    for i in range(min(W+1, 9)):\n        if i == 0:\n            max_weight += 0 * counts[i]\n        else:\n            max_weight += min(counts[i], (W // i) + 1) * i\n        W -= min(counts[i], (W // i) + 1) * i\n        if W <= 0: break\n    return max_weight\n\n# Example usage\nW = int(input())\ncounts = list(map(int, input().split()))\nprint(max_good_subset_weight(W, counts))"}
{"solution": "import sys\nimport math\n\ndef min_cost_lemonade(n, L, costs):\n    total_cost = 0\n    while L > 0:\n        best_value_per_cost = -1\n        best_index = -1\n        for i in range(n):\n            liters_per_bottle = 2 ** i - 1\n            if liters_per_bottle <= L and (best_value_per_cost == -1 or (liters_per_bottle / costs[i]) > best_value_per_cost):\n                best_value_per_cost = liters_per_bottle / costs[i]\n                best_index = i\n        total_cost += costs[best_index]\n        L -= (2 ** best_index - 1)\n    return total_cost\n\n# Reading input\nn, L = map(int, sys.stdin.readline().split())\ncosts = list(map(int, sys.stdin.readline().split()))\n\n# Calculating and printing the result\nprint(min_cost_lemonade(n, L, costs))"}
{"solution": "from collections import Counter\n\ndef max_mex_after_operations(n, arr):\n    counter = Counter(arr)\n    sorted_unique_elements = sorted(set(arr))\n    \n    max_mex = 1\n    for elem in sorted_unique_elements:\n        diff = elem - max_mex\n        if counter[elem] > diff > 0:\n            max_mex += diff\n        elif counter[elem] <= diff:\n            max_mex += counter[elem]\n        else:\n            max_mex = elem + 1\n    return max_mex\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(max_mex_after_operations(n, arr))"}
{"solution": "n = int(input())\na = list(map(int, input()))\n\ntotal_sum = sum(a)\nsegment_sum = 0\n\nfor i in range(n):\n    segment_sum += a[i]\n    if segment_sum * (i + 1) == total_sum and segment_sum != total_sum:\n        if (i + 1) < n and (total_sum // segment_sum) > (i + 1):\n            print(\"YES\")\n            break\nelse:\n    print(\"NO\")"}
{"solution": "]\nname = input()\nprint([\"IGNORE HIM!\", \"CHAT WITH HER!\"][len(set(name)) % 2 == 0])"}
{"solution": "def max_diff_after_closing_tabs(n, k, tabs):\n    def close_tabs(start, step):\n        return [tab for index, tab in enumerate(tabs) if (index + 1 - start) % step != 0]\n\n    max_diff = 0\n    for start in range(1, n + 1):\n        remaining_tabs = close_tabs(start, k)\n        e = sum(1 for tab in remaining_tabs if tab == 1)\n        s = sum(1 for tab in remaining_tabs if tab == -1)\n        diff = abs(e - s)\n        max_diff = max(max_diff, diff)\n\n    return max_diff\n\n# Example usage:\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\nprint(max_diff_after_closing_tabs(n, k, tabs))"}
{"solution": "import math\n\ndef calculate_cost(n, c0, c1):\n    if c0 > c1: \n        c0, c1 = c1, c0\n    if c0 == 0:\n        return (n - 1) * c1\n    k = math.ceil(((-1 + math.sqrt(1 + 4 * c0 * c1 * (n - 1))) / (2 * c0)))\n    if k * c1 < c0:\n        return k * c1 * n + c0 * (n - 1)\n    total_cost = 0\n    i = 0\n    while True:\n        current_cost = c1 * i + c0\n        count = min(n - 1, (k - i) * (k - i + 1) // 2)\n        total_cost += current_cost * count\n        i += 1\n        if count == 0:\n            break\n    return total_cost\n\nn, c0, c1 = map(int, input().split())\nprint(calculate_cost(n, c0, c1))"}
{"solution": "def check_meet(n, a, x, b, y):\n    d_direction = 1 if x > a else -1\n    v_direction = 1 if b > y else -1\n    \n    d_cycle_time = abs(x - a)\n    v_cycle_time = abs(y - b)\n\n    for t in range(1, n + 1):\n        d_pos = (a + t * d_direction) % n\n        if d_pos == 0:\n            d_pos = n\n        v_pos = (b - t * v_direction) % n\n        if v_pos == 0:\n            v_pos = n\n        if d_pos == v_pos:\n            return \"YES\"\n        if t >= d_cycle_time and t >= v_cycle_time:\n            break\n    return \"NO\"\n\n# Reading input\nn, a, x, b, y = map(int, input().split())\n\n# Processing and printing output\nprint(check_meet(n, a, x, b, y))"}
{"solution": "import math\ndef powGen(x):\n    p = 0\n    while True:\n        v = x ** p\n        if v > 10**18:\n            break\n        yield v\n        p += 1\n\ndef solve(x, y, l, r):\n    px = list(powGen(x))\n    py = list(powGen(y))\n    unlucky = []\n    i = 0\n    j = 0\n    while i < len(px):\n        j = 0\n        while j < len(py):\n            v = px[i] + py[j]\n            if v <= r:\n                unlucky.append(v)\n            else:\n                break\n            j += 1\n        i += 1\n    unlucky.sort()\n    ans = 0\n    i = 0\n    while i < len(unlucky):\n        if unlucky[i] >= l:\n            break\n        i += 1\n    j = i\n    while j < len(unlucky):\n        if unlucky[j] > r:\n            break\n        j += 1\n    while j < len(unlucky):\n        if unlucky[j] > r:\n            break\n        if unlucky[j] - unlucky[i] > ans:\n            ans = unlucky[j] - unlucky[i]\n        i += 1\n        j += 1\n    return max(0, min(r - l + 1, r - l + 1 - ans))\n\nx, y, l, r = map(int, input().split())\nprint(solve(x, y, l, r))"}
{"solution": "import math\n\ndef find_min_tax(n):\n    # If n is a prime number, the tax is 1\n    if n == 2 or (n % 2 != 0 and all(n % i != 0 for i in range(3, int(math.sqrt(n)) + 1, 2))):\n        return 1\n    else:\n        # Otherwise, the tax is the largest factor of n\n        for i in range(int(math.sqrt(n)), 1, -1):\n            if n % i == 0:\n                return i\n\nn = int(input())\nprint(find_min_tax(n))"}
{"solution": "`\nfrom collections import deque\ndef is_vowel(ch):\n    return ch in ['a', 'e', 'i', 'o', 'u']\n\ndef find_typo(s):\n    res = []\n    q = deque()\n    for i, ch in enumerate(s):\n        if not is_vowel(ch):\n            q.append(ch)\n            if len(q) > 2:\n                if i == len(s)-1 or is_vowel(s[i+1]):\n                    res.append(''.join(list(q)))\n                    q.clear()\n                elif len(set(q)) > 1:\n                    res.append(''.join(list(q)[:-1]))\n                    q.clear()\n                    q.append(q[-1])\n        else:\n            if len(q) > 0:\n                res.append(''.join(list(q)))\n                q.clear()\n            res.append(ch)\n    return ''.join(res)\n\ns = input().strip()\nprint(find_typo(s))"}
{"solution": "import sys\nfrom array import array  # noqa: F401\n\ndef main(f=None):\n    if f is None:\n        f = sys.stdin\n    n, m, k = map(int, f.readline().split())\n    x, s = map(int, f.readline().split())\n    A = list(map(int, f.readline().split()))\n    B = list(map(int, f.readline().split()))\n    C = list(map(int, f.readline().split()))\n    D = list(map(int, f.readline().split()))\n\n    def enough(t):\n        res = float('inf')\n        i = -1\n        for a, b in sorted(zip(A, B), key=lambda x: t * x[0] - x[1]):\n            if t * a - b <= 0:\n                return 0\n            i += 1\n            res = min(res, t * a - b)\n        i += 1\n        res = min(res, t * x)\n\n        l = 0\n        r = k\n        while r - l > 1:\n            c = (l + r) // 2\n            if D[c] <= s:\n                l = c\n            else:\n                r = c\n        d = D[l]\n        c = C[l]\n\n        if res - d >= n - c:\n            return n - c\n        return (n - c) * x + (res - d)\n\n    l = 0\n    r = 2000000000\n    while r - l > 1:\n        c = (l + r) // 2\n        if enough(c) <= s:\n            r = c\n        else:\n            l = c\n    c = (l + r) // 2\n    mn = enough(c)\n\n    l = 0\n    r = k\n    while r - l > 1:\n        c = (l + r) // 2\n        if D[c] <= s:\n            l = c\n        else:\n            r = c\n    d = D[l]\n    c = C[l]\n\n    if mn - d >= n - c:\n        print((n - c) * x + (mn - d))\n    else:\n        print((n - c) * x)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import bisect\n\ndef max_points(n, k, M, t):\n    total_time = sum(t)\n    t.sort()\n    \n    # Calculate the base points (without bonuses)\n    base_points = M // total_time * k * n\n    \n    # Remaining time after completing full sets of tasks\n    remaining_time = M % total_time\n    \n    # Calculate additional points from remaining time\n    additional_points = 0\n    for i in range(k):\n        if remaining_time >= t[i]:\n            remaining_time -= t[i]\n            additional_points += n\n    \n    # Calculate bonus points\n    bonus_points = bisect.bisect_right(t, remaining_time)\n    \n    return base_points + additional_points + bonus_points\n\n# Reading input\nn, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Printing output\nprint(max_points(n, k, M, t))"}
{"solution": "MOD = 998244353\n\nfac = [1]*(10**6+1)\ninvf = [1]*(10**6+1)\n\nfor i in range(1, 10**6+1):\n    fac[i] = (i * fac[i-1]) % MOD\n    invf[i] = pow(fac[i], MOD-2, MOD)\n\ndef comb(n, k):\n    return (fac[n] * invf[k] * invf[n-k]) % MOD\n\ndef solve(n):\n    if n == 1:\n        return 1\n    if n % 2 == 0:\n        m = n // 2\n        return (comb(m + m - 1, m) * solve(m) * solve(m-1)) % MOD\n    else:\n        m = n // 2\n        return (2 * comb(m + m, m) * solve(m) * solve(m)) % MOD\n\nn = int(input())\nprint(solve(n))"}
{"solution": "n,m,k = map(int,input().split())\nr = 1\nc = 1\nif k == 0:\n    print(r,c)\nelse:\n    while k >= n - 1:\n        k -= n - 1\n        c += 1\n        if c % 2 == 0:\n            r = n\n    if c % 2 == 0:\n        r = n - k\n    else:\n        r = k + 1\n    print(r,c)"}
{"solution": "import math\n\ndef find_min_max_values(x):\n    for i in range(int(math.sqrt(x)), 0, -1):\n        if x % i == 0:\n            return i, x // i\n\nx = int(input())\na, b = find_min_max_values(x)\nprint(a, b)"}
{"solution": "a = int(input())\nb = int(input())\nc = int(input())\n\nmin_value = min(a, b//2, c//4)\n\nprint(min_value * 7)"}
{"solution": "n=int(input())\nl=list(map(int,input().split()))\nl.sort()\nif l[n]-l[n-1]>0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\ndef gcd(x, y):\n    while(y):\n        x, y = y, x % y\n    return x\n\ndef find_coprime(num):\n    if num == 1:\n        return 2\n    for i in range(num + 1, 10**5, 2):\n        if gcd(num, i) == 1:\n            return i\n\nn = int(input())\narr = list(map(int, input().split()))\n\nnew_arr = []\ninsertions = 0\nprev = arr[0]\nnew_arr.append(prev)\n\nfor i in range(1, len(arr)):\n    curr = arr[i]\n    if gcd(prev, curr) > 1:\n        coprime = find_coprime(prev)\n        new_arr.append(coprime)\n        insertions += 1\n    new_arr.append(curr)\n    prev = curr\n\nprint(insertions)\nprint(*new_arr)"}
{"solution": "import numpy as np\n\ndef max_divisor(N, K, A):\n    total_sum = np.sum(A)\n    candidates = []\n\n    for i in range(1, int(total_sum**0.5) + 1):\n        if total_sum % i == 0:\n            candidates.append(i)\n            if i != total_sum // i:\n                candidates.append(total_sum // i)\n\n    def is_possible(divisor):\n        remainder_sorted = np.sort(np.mod(A, divisor))\n        cumsum_remainder = np.cumsum(remainder_sorted)\n        target = divisor * (N - np.searchsorted(cumsum_remainder, (N - cumsum_remainder[-1]) * divisor, side='right'))\n        return target <= K * divisor\n\n    max_divisor = 1\n    for candidate in candidates:\n        if is_possible(candidate):\n            max_divisor = max(max_divisor, candidate)\n\n    return max_divisor\n\n# Read input\nN, K = map(int, input().split())\nA = np.array(list(map(int, input().split())))\n\nprint(max_divisor(N, K, A))"}
{"solution": "from sys import stdin, stdout\n\nx = int(stdin.readline())\n\nres = []\nt = 0\nif x != 1:\n    while x > 1:\n        b = x.bit_length() - 1\n        x ^= (1 << b) - 1\n        res.append(b)\n        t += 1\n        if x > 0:\n            x += 1\n            t += 1\n\nstdout.write(f'{t}\\n')\nstdout.write(' '.join(map(str, res)) + '\\n')"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\nfor i in a:\n    if k % i == 0:\n        print(k // i)\n        break"}
{"solution": "def can_grasshopper_eat(n, k, line):\n    pos_G = line.find('G')\n    pos_T = line.find('T')\n    if pos_G == -1 or pos_T == -1:\n        return \"NO\"\n    \n    diff = abs(pos_G - pos_T)\n    if diff % k == 0 and (diff // k) % 2 == 0:\n        for i in range(1, diff // k + 1):\n            if line[min(pos_G, pos_T) + i * k] == '#' or line[max(pos_G, pos_T) - i * k] == '#':\n                return \"NO\"\n        return \"YES\"\n    else:\n        return \"NO\"\n\nn, k = map(int, input().split())\nline = input()\nprint(can_grasshopper_eat(n, k, line))"}
{"solution": "from math import sqrt\n\ndef solve(y1, y2, yw, xb, yb, r):\n    a = yw - yb\n    b = xb\n    c = yb**2 - (r**2 + yw**2)\n    D = b**2 * a**2 - 4 * a * c\n    if D < 0:\n        return -1\n    else:\n        x1 = (-b*a - sqrt(D)) / (2*a)\n        x2 = (-b*a + sqrt(D)) / (2*a)\n\n        def check(x):\n            xw = x\n            yw = yw\n            xb = xb\n            yb = yb\n            k = (yw - yb) / (xw - xb)\n            b = yw - k * xw\n            x0 = 0\n            y0 = k * x0 + b\n            return y1 <= y0 <= y2\n\n        if check(x1):\n            return x1\n        elif check(x2):\n            return x2\n        else:\n            return -1\n\ny1, y2, yw, xb, yb, r = map(int, input().split())\nprint(solve(y1, y2, yw, xb, yb, r))"}
{"solution": "b, d, s = map(int, input().split())\n\nmin_meals = max(0, (b - 1) + (d - 1) + (s - 1))\nprint(min_meals)"}
{"solution": "from math import gcd\n\ndef check(a, b):\n    da = (a[1] - a[0]) // gcd(abs(a[1] - a[0]), a[0])\n    db = (b[1] - b[0]) // gcd(abs(b[1] - b[0]), b[0])\n    return da == db\n\ndef solve(a):\n    d = [gcd(a[i+1]-a[i], a[i]) for i in range(len(a)-1)]\n    g = d[0]\n    for i in range(1, len(d)):\n        g = gcd(g, d[i])\n    m = min(a)\n    k = (a[0] - m) // g\n    if k == 0:\n        return False, None, None\n    b = [x - k * g for x in a]\n    if not check(a, b):\n        return False, None, None\n    l = max(a) - min(a) + 1\n    x = l // k\n    y = g // k\n    return True, x, y\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    ok, x, y = solve(a)\n    if ok:\n        print(\"YES\")\n        print(x, y)\n    else:\n        print(\"NO\")\n\nmain()"}
{"solution": "`\nfrom bisect import bisect_left\n\ndef find_subsequence(a, b):\n    pos = {char: [] for char in set(b)}\n    for i, char in enumerate(a):\n        if char in pos:\n            pos[char].append(i)\n    \n    subseq = []\n    last_pos = -1\n    for char in b:\n        if char in pos:\n            idx = bisect_left(pos[char], last_pos)\n            if idx < len(pos[char]):\n                last_pos = pos[char][idx]\n                subseq.append(char)\n            else:\n                break\n    \n    return ''.join(subseq) if subseq else '-'\n\n# Reading input\na = input().strip()\nb = input().strip()\n\n# Calculating and printing the result\nprint(find_subsequence(a, b))"}
{"solution": "n = int(input())\ns = input()\n\ncount = 0\nmin_count = 0\n\nfor i in s:\n    if i == '+':\n        count += 1\n    else:\n        count -= 1\n    min_count = min(min_count, count)\n\nprint(max(-min_count, 0))"}
{"solution": "import sys\n\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\ndef buy(n, a, b, c):\n    ans = 0\n    while n >= b:\n        n -= b\n        ans += 1\n        if n >= c:\n            n -= c\n        else:\n            break\n    if n >= a:\n        ans += n // a\n    return ans\n\nprint(max(buy(n, a, b, c), n // a + (n - n % a) // b * (b // (b - c)), n // b * 2))"}
{"solution": "def read_ints():\n    return list(map(int, input().split()))\n\ndef read_int():\n    return int(input())\n\ndef solve():\n    n = read_int()\n    k1 = read_int()\n    p1 = read_ints()\n    k2 = read_int()\n    p2 = read_ints()\n\n    p1.reverse()\n    p2.reverse()\n\n    cnt = 0\n    winner = 0\n    while True:\n        if not p1 or not p2:\n            break\n        if p1[-1] > p2[-1]:\n            p1.extend([p2.pop(), p1.pop()])\n            winner = 1\n        else:\n            p2.extend([p1.pop(), p2.pop()])\n            winner = 2\n        cnt += 1\n        if cnt > 10000:\n            return [-1]\n\n    return [cnt, winner]\n\nprint(*solve())"}
{"solution": "3\nimport re\n\ndef check_password_strength(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    if not re.search(\"[a-z]\", password):\n        return \"Too weak\"\n    if not re.search(\"[A-Z]\", password):\n        return \"Too weak\"\n    if not re.search(\"[0-9]\", password):\n        return \"Too weak\"\n    return \"Correct\"\n\npassword = input().strip()\nprint(check_password_strength(password))"}
{"solution": "def min_exchanges_to_equalize_groups(n, group_a, group_b):\n    \"\"\"\n    Calculate the minimum number of exchanges needed to make the distribution of grades equal in both groups.\n    \n    :param n: Number of students in each group.\n    :param group_a: List of integers representing the grades of students in group A.\n    :param group_b: List of integers representing the grades of students in group B.\n    :return: Minimum number of exchanges or -1 if it's impossible to equalize the groups.\n    \"\"\"\n    from collections import Counter\n    \n    count_a = Counter(group_a)\n    count_b = Counter(group_b)\n    total_count = count_a + count_b\n    \n    # Check if any grade cannot be equalized\n    for grade, count in total_count.items():\n        if count % 2 != 0:\n            return -1\n    \n    exchanges = 0\n    for grade in range(1, 6):\n        diff = abs(count_a[grade] - count_b[grade])\n        exchanges += diff // 2\n    \n    return exchanges\n\n# Reading input\nn = int(input())\ngroup_a = list(map(int, input().split()))\ngroup_b = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(min_exchanges_to_equalize_groups(n, group_a, group_b))"}
{"solution": "n,m=map(int,input().split())\nh=input()\nv=input()\nif h[0]=='>':\n    if v[0]=='v':\n        print(\"NO\")\n        exit()\nelse:\n    if v[-1]=='^':\n        print(\"NO\")\n        exit()\nif h[-1]=='<':\n    if v[0]=='v':\n        print(\"NO\")\n        exit()\nelse:\n    if v[-1]=='^':\n        print(\"NO\")\n        exit()\nprint(\"YES\")"}
{"solution": "n=int(input())\nl=list(map(int,input().split()))\ns=''\nif l.count(1)==len(l):\n    print('NO')\nelif l.count(1)==0:\n    print('YES')\n    for i in range(n-1):\n        print('(',end='')\n    for i in l:\n        print(i,end='')\n    for i in range(n-1):\n        print(')->',end='')\n    print('0)')\nelse:\n    a=0\n    b=0\n    for i in l:\n        if i==1:\n            a+=1\n        else:\n            break\n    for i in range(a+1,len(l)):\n        if l[i]==1:\n            b+=1\n    if a>0 and b==0:\n        print('YES')\n        for i in range(a):\n            print('(',end='')\n        for i in range(len(l)):\n            print(l[i],end='')\n            if i!=len(l)-1:\n                print(')->(',end='')\n        for i in range(a):\n            print(')->0')\n    elif a>0 and b>0:\n        print('YES')\n        for i in range(a):\n            print('(',end='')\n        for i in range(a):\n            print('1)->(',end='')\n        print('0)',end='')\n        for i in range(a+1,len(l)-1):\n            print(')->(',end='')\n            print(l[i],end='')\n            print(')->(',end='')\n        print(l[-1],end='')\n        for i in range(a+b+1):\n            print(')',end='')\n    else:\n        print('YES')\n        for i in range(len(l)-1):\n            print('(',end='')\n        for i in l:\n            print(i,end='')\n        for i in range(len(l)-1):\n            print(')->(',end='')\n        print('0)')\n        '''\n        for i in range(b):\n            print('(',end='')\n        for i in range(a):\n            print('(',end='')\n        for i in range(a):\n            print('1)->(',end='')\n        print('0)',end='')\n        for i in range(a+1,len(l)-1):\n            print(')->(',end='')\n            print(l[i],end='')\n            print(')->(',end='')\n        print(l[-1],end='')\n        for i in range(a+b+1):\n            print(')',end='')\n        '''"}
{"solution": "def process(a, b):\n    while True:\n        if a == 0 or b == 0:\n            return a, b\n        if a >= 2 * b:\n            a %= 2 * b\n        else:\n            if b >= 2 * a:\n                b %= 2 * a\n            else:\n                return a, b\n\nn, m = map(int, input().split())\na, b = process(n, m)\nprint(a, b)"}
{"solution": "import sys\n\nk, a, b = map(int, sys.stdin.readline().split())\n\ndef solve(k, a, b):\n    if a > 0:\n        return b//k - a//k + (a%k == 0)\n    else:\n        return b//k - a//k + 1\n\nprint(solve(k, a, b))"}
{"solution": "]\ndef find_kth_digit(k):\n    if k < 10:\n        return k\n\n    base = 9  # Initial range 1-9\n    digits = 1  # Number of digits in the range\n    while k > base * digits:\n        k -= base * digits\n        base *= 10\n        digits += 1\n\n    quotient, remainder = divmod(k - 1, digits)\n    number = 10 ** (digits - 1) + quotient\n    return int(str(number)[remainder])\n\n# Reading input\nk = int(input())\n\n# Processing and printing output\nprint(find_kth_digit(k))"}
{"solution": "n = int(input())\ns = input()\n\ndef check_win(s):\n    cnt8 = s.count('8')\n    if len(s) == 11 and s[0] == '8':\n        return True\n    elif len(s) == 11:\n        return False\n    else:\n        return cnt8 > 0\n\ndef solve(s, p):\n    if len(s) == 11:\n        return check_win(s)\n    for i in range(len(s)):\n        if p == 0 and i == 0:\n            continue\n        if p == 1 and i == 0 and s[i] != '8':\n            continue\n        if solve(s[:i] + s[i+1:], 1 - p):\n            return True\n    return False\n\nprint(\"YES\" if solve(s, 0) else \"NO\")"}
{"solution": "MOD = 10**9 + 7\n\ndef fact(n):\n    f = [1]*(n+1)\n    for i in range(2, n+1):\n        f[i] = f[i-1]*i%MOD\n    return f\n\ndef invfact(f, n):\n    if n >= len(f): return None\n    inv = [1]*(n+1)\n    inv[n] = pow(f[n], MOD-2, MOD)\n    for i in range(n, 0, -1):\n        inv[i-1] = inv[i]*i%MOD\n    return inv\n\ndef C(f, invf, n, k):\n    if k > n:\n        return 0\n    return f[n]*invf[k]*invf[n-k]%MOD\n\ndef solve():\n    n, x, pos = map(int, input().split())\n    pos += 1\n    f = fact(n)\n    invf = invfact(f, n)\n\n    ans = 0\n    for i in range(pos, n+1):\n        c1 = C(f, invf, i-1, pos-1)\n        c2 = C(f, invf, n-i, n-pos)\n        if i < x:\n            c1 = c1 * (x-1) % MOD\n        elif i > x:\n            c1 = c1 * (n-x) % MOD\n        else:\n            c1 = c1 * (x-1) % MOD\n            c2 = c2 * (n-x) % MOD\n        ans = (ans + c1 * c2) % MOD\n    print(ans)\n\nsolve()"}
{"solution": "def decode_message(s, k):\n    i, n, res = 0, len(s), []\n    while i < n and len(res) < k:\n        start_i = i\n        word_part = []\n        while i < n and s[i] in '*?':\n            if s[i] == '?': word_part.append(0)\n            else: word_part.append(-1)\n            i += 1\n        if i - start_i > 1: word_part[-1] = 0\n        if i == n or s[i].isalpha():\n            word_part.append(s[i])\n            i += 1\n        if len(res) + len(word_part) > k: return 'Impossible'\n        while len(res) + len(word_part) < k and i < n and s[i].isalpha():\n            word_part.append(s[i])\n            i += 1\n        for x in word_part: res.append(x if x != 0 else res[-1] if res else '')  \n    return ''.join(res) if len(res) == k else 'Impossible'\n\ns = input()\nk = int(input())\nprint(decode_message(s, k))"}
{"solution": "]\nx=int(input())\nif x%90!=0:\n    x=x%90\n    if x>0:\n        if x>45:\n            print(90-x)\n        else:\n            print(x)\n    else:\n        x=abs(x)\n        if x>45:\n            print(90-x)\n        else:\n            print(x)\nelse:\n    print(0)"}
{"solution": "]\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\nif a < x or b < y or c < z:\n    print(\"No\")\n    exit()\n\ndiff_a = max(0, a - x)\ndiff_b = max(0, b - y)\ndiff_c = max(0, c - z)\n\ntotal_diff = diff_a + diff_b + diff_c\n\nif total_diff % 2 == 0 and total_diff // 2 <= min(a, b, c):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def solve(n, k, m):\n    dp = [0] * (k + 1)\n    dp[0] = 1\n    res = 9 * (k // gcd(9, k)) * pow(10, n - 1, m) % m\n    for i in range(1, n):\n        for j in range(k):\n            dp[(j * 10) % k] += dp[j]\n        for j in range(k):\n            dp[j] %= m\n        res += 9 * sum(dp) * pow(10, n - i - 1, m) % m\n        res %= m\n    return res\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn, k, m = map(int, input().split())\nprint(solve(n, k, m))"}
{"solution": ">\nl,r,a = map(int,input().split())\nprint(min(l+r+min(l,r),l+a+r+a)*2//2)"}
{"solution": "import sys\nreadline = sys.stdin.readline\n\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import shortest_path\n\ndef solve():\n    N, K = map(int, readline().split())\n    K -= 1\n    D = [[0]*(N+1) for _ in range(N+1)]\n    for i in range(N):\n        for j in range(N):\n            if abs(i-j) <= 1:\n                continue\n            D[i][j] = abs(i-j)*2 + 1\n            D[j][i] = abs(i-j)*2 + 1\n    D = csr_matrix(D)\n    SP = shortest_path(D, indices=K, directed=False).astype(int)\n    ans = 0\n    for i in range(N):\n        if i == K:\n            continue\n        ans += SP[i] + 2*(i != K)\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "`\nimport math\ndef solve(n,m):\n    if not n and not m:\n        return 0\n    if not n:\n        return 3*m\n    if not m:\n        return 2*n\n    total = n+m\n    val = math.ceil((-1+(math.sqrt(1+8*total)))/2)\n    twos = val*(val+1)//2 - total\n    threes = total - twos\n    res = 0\n    if twos > n:\n        res = max(res,3*(threes-1)+2*(twos-n))\n    elif twos < n:\n        res = max(res,3*(threes)+2*(n-twos-1)+1)\n    else:\n        res = max(res,3*(threes-1)+1)\n    return res\n\nn,m = map(int,input().split())\nprint(solve(n,m))"}
{"solution": "from collections import Counter\n\ndef check_fair_game(cards):\n    card_counts = Counter(cards)\n    unique_counts = list(card_counts.items())\n    \n    if len(unique_counts) < 2:\n        return \"NO\"\n    \n    for i in range(len(unique_counts)):\n        for j in range(i + 1, len(unique_counts)):\n            if unique_counts[i][1] + unique_counts[j][1] == len(cards) // 2:\n                return f\"YES\\n{unique_counts[i][0]} {unique_counts[j][0]}\"\n    return \"NO\"\n\nn = int(input())\ncards = [int(input()) for _ in range(n)]\nprint(check_fair_game(cards))"}
{"solution": "I=lambda:map(int,input().split())\nn,k=I()\na=list(I())\nif max(a)>4*min(n,2*k):print('NO')\nelse:print('YES')"}
{"solution": "from collections import Counter\n\ndef find_optimal_t_and_cost(stick_lengths):\n    n = len(stick_lengths)\n    counter = Counter(stick_lengths)\n    sorted_lengths = sorted(counter.keys())\n    \n    median_like = sorted_lengths[n//2]\n    \n    cost = 0\n    for length, count in counter.items():\n        cost += count * min(abs(length - median_like), abs(length - (median_like + 1)), abs(length - (median_like - 1)))\n    \n    return median_like, cost\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    stick_lengths = list(map(int, input().strip().split()))\n    t, cost = find_optimal_t_and_cost(stick_lengths)\n    print(t, cost)"}
{"solution": "def min_square_side(n, m, sky):\n    stars_x = []\n    stars_y = []\n    for i in range(n):\n        for j in range(m):\n            if sky[i][j] == '*':\n                stars_x.append(i)\n                stars_y.append(j)\n    \n    width = max(stars_x) - min(stars_x) + 1\n    height = max(stars_y) - min(stars_y) + 1\n\n    return max(width, height)\n\nn, m = map(int, input().split())\nsky = [input() for _ in range(n)]\n\nprint(min_square_side(n, m, sky))"}
{"solution": "MOD = 10**9 + 7\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef solve(n, k, a):\n    ones = sum(a)\n    zeros = n - ones\n    if abs(ones - zeros) > 1:\n        return 0\n    if k % 2 == 1:\n        if abs(ones - zeros) != 1:\n            return 0\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1] * (n - i + 1)) % MOD\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1] * i\n                dp[i][j] %= MOD\n    ans = 0\n    for i in range(max(0, ones - (k % 2)), min(ones, n - (k % 2)) + 1):\n        comb = dp[n][i] * modinv(dp[ones][i]) % MOD * modinv(dp[n - ones][i - ones]) % MOD\n        ans += comb * modinv(pow(2, k, MOD))\n        ans %= MOD\n    return ans\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(solve(n, k, a))"}
{"solution": "]\nimport sys\ninput = sys.stdin.readline\n\nx,y=list(map(int,input().split()))\nprint(x+y-2*max(x,y))"}
{"solution": "from math import sqrt\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\nif a * d - b * c == 0:\n    print(0)\nelse:\n    x = abs(a + c * b / d)\n    y = abs(b - a * b / d)\n    z = abs(c - a * c / d)\n    w = abs(d + c * c / d)\n\n    m1 = max(x, y)\n    m2 = max(z, w)\n\n    print(sqrt(min(m1 ** 2 + m2 ** 2, m1 ** 2 + (w - c) ** 2, m2 ** 2 + (x - a) ** 2)))"}
{"solution": "def restaurant_service(n, a, b, groups):\n    denied = 0\n    one_seater = a\n    two_seater = b\n    shared_two_seater = 0\n\n    for group in groups:\n        if group == 1:\n            if one_seater > 0:\n                one_seater -= 1\n            elif two_seater > 0:\n                two_seater -= 1\n            elif shared_two_seater < two_seater:\n                shared_two_seater += 1\n            else:\n                denied += 1\n        else:  # group == 2\n            if two_seater > 0:\n                two_seater -= 1\n            else:\n                denied += 2\n\n    return denied\n\n# Reading input\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(restaurant_service(n, a, b, groups))"}
{"solution": "3\nimport sys\nA, B, C, N = map(int, sys.stdin.readline().split())\n\nif N < A + B - C:\n    print(-1)\nelif N > A + B - C + C:\n    print(-1)\nelse:\n    print(N - (A + B - C))"}
{"solution": "MOD = 10**9 + 7\n\ndef power(x, y):\n    if y == 0:\n        return 1\n    temp = power(x, y // 2)\n    if y % 2 == 0:\n        return (temp * temp) % MOD\n    else:\n        return (x * temp * temp) % MOD\n\ndef inv(x):\n    return power(x, MOD - 2)\n\ndef solve(x, k):\n    if x == 0:\n        return 0\n    if k == 0:\n        return (2 * x) % MOD\n    return (((power(3, k) - power(2, k)) * inv(power(2, k) - 1)) * x + power(2, k)) % MOD\n\nx, k = map(int, input().split())\nprint(solve(x, k))"}
{"solution": "import sys\nMOD = 998244353\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef main():\n    n = int(input())\n    ranges = [list(map(int, line.split())) for line in sys.stdin]\n\n    probs = [0] * n\n    denoms = [1] * n\n    for i in range(n - 1):\n        l, r = ranges[i]\n        width = r - l + 1\n        denoms[i] = width\n        for j in range(i + 1, n):\n            ll, rr = ranges[j]\n            overlap = max(0, min(r, rr) - max(l, ll) + 1)\n            probs[j] += width * overlap\n            denoms[j] *= width\n\n    total = sum(probs)\n    denom = 1\n    for d in denoms:\n        denom = (denom * d) % MOD\n\n    result = (total * modinv(denom)) % MOD\n    print(result)\n\nmain()"}
{"solution": "`\ndef count_ways(n):\n    ans = 0\n    for i in range(1, n // 2):\n        if n % 2 == 0 and 2 * i < n and 2 * i != n - 2 * i:\n            ans += 1\n        elif n % 2 != 0 and 2 * i < n and 2 * i != n - 2 * i - 1:\n            ans += 1\n    return ans\n\nn = int(input())\nprint(count_ways(n))"}
{"solution": "import sys\nfrom typing import List\n\ndef max_min_kvass_levels(num_kegs: int, total_liters: int, volumes: List[int]) -> int:\n    \"\"\"\n    Finds the maximum minimum kvass level in the kegs after pouring 'total_liters' liters into a glass.\n    \n    :param num_kegs: Number of kegs.\n    :param total_liters: Total liters to pour into a glass.\n    :param volumes: List of initial volumes in each keg.\n    :return: Maximum minimum volume in the kegs or -1 if impossible.\n    \"\"\"\n    if sum(volumes) < total_liters:\n        return -1\n    \n    def is_possible(min_level):\n        required_pours = sum(max(0, min_level - v) for v in volumes)\n        return required_pours <= total_liters\n\n    low, high = 0, max(volumes)\n    while low < high:\n        mid = (low + high + 1) // 2\n        if is_possible(mid):\n            low = mid\n        else:\n            high = mid - 1\n            \n    return low\n\n# Reading input\nnum_kegs, total_liters = map(int, sys.stdin.readline().split())\nvolumes = list(map(int, sys.stdin.readline().split()))\n\n# Calculating and printing the result\nprint(max_min_kvass_levels(num_kegs, total_liters, volumes))"}
{"solution": "import math\n\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\ndiff = h2 - h1\nday_gain = a - b\n\nif a >= b and diff <= a:\n    print(0)\nelif a < b:\n    print(-1)\nelse:\n    full_days = math.ceil((diff + b - a) / (a - b)) - 1\n    if (full_days * (a - b) + b) >= diff:\n        print(full_days)\n    else:\n        print(full_days + 1)"}
{"solution": "`\ndef omNom(c, hr, hb, wr, wb):\n    maxJoy = 0\n    maxRed = c // wr\n    maxBlue = c // wb\n    for r in range(maxRed + 1):\n        remainingWeight = c - r * wr\n        b = min(remainingWeight // wb, maxBlue)\n        maxJoy = max(maxJoy, r * hr + b * hb)\n    return maxJoy\n\nc, hr, hb, wr, wb = map(int, input().split())\nprint(omNom(c, hr, hb, wr, wb))"}
{"solution": "x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\ndx = abs(x1 - x2)\ndy = abs(y1 - y2)\n\nif dx > dy:\n    print(dx)\nelif dx < dy:\n    print(dy)\nelse:\n    print(dx)"}
{"solution": "n = int(input())\ns = input()\nd = s.count('D')\nr = n - d\nif d % 2 == 0:\n    r -= 1\nelse:\n    d -= 1\nwhile d > 0 and r > 0:\n    if d % 2 == 0:\n        r -= 2\n    else:\n        d -= 2\nif d > r:\n    print('D')\nelse:\n    print('R')"}
{"solution": "import math\ndef solve(a,b,x,y):\n    k=math.gcd(x,y)\n    x//=k\n    y//=k\n    ans=0\n    if a//x>b//y:\n        up=b//y\n    else:\n        up=a//x\n    l=y\n    r=up\n    while l<r:\n        mid=(l+r+1)//2\n        if mid*y>up*y+(mid*x-a)//x*y:\n            r=mid-1\n        else:\n            l=mid\n    return l\na,b,x,y=list(map(int,input().split()))\nprint(solve(a,b,x,y))"}
{"solution": "import sys\nfrom math import sqrt\n\ndef factor(b):\n    factors = []\n    if b % 2 == 0:\n        cnt = 0\n        while b % 2 == 0:\n            b //= 2\n            cnt += 1\n        factors.append((2, cnt))\n    for d in range(3, int(sqrt(b)) + 1, 2):\n        if d > b:\n            break\n        cnt = 0\n        while b % d == 0:\n            b //= d\n            cnt += 1\n        if cnt > 0:\n            factors.append((d, cnt))\n    if b > 2:\n        factors.append((b, 1))\n    return factors\n\ndef tralingZeros(n, b):\n    facts = factor(b)\n    ans = 10**18\n    for f, _ in facts:\n        c = 0\n        i = f\n        while i <= n:\n            c += n // i\n            i *= f\n        ans = min(ans, c // facts.count((f, 1)))\n    return ans\n\nn, b = map(int, sys.stdin.readline().strip().split(' '))\nprint(tralingZeros(n, b))"}
{"solution": "import math\n\ndef calculate_sum(m, a, b):\n    def f(x, a, b):\n        return (2 * x // a + 1) * (x // a + 1) // 2 + (2 * x // b + 1) * (x // b + 1) // 2 - (2 * x // math.gcd(a, b) + 1) * (x // math.gcd(a, b) + 1) // 2\n\n    gcd_ab = math.gcd(a, b)\n    m_prime = min(a, b) - 1\n    total_sum = 0\n\n    while m_prime < m:\n        next_m_prime = min(m, m_prime + min(a, b))\n        total_sum += f(next_m_prime, a, b) - f(m_prime, a, b)\n        m_prime = next_m_prime\n\n    return total_sum\n\nm, a, b = map(int, input().split())\nprint(calculate_sum(m, a, b))"}
{"solution": "def can_divide_into_odd_subsegments(n, sequence):\n    odd_count = 0\n    can_divide = False\n    for num in sequence:\n        if num % 2 != 0:\n            odd_count += 1\n        else:\n            odd_count = 0\n        if odd_count == 3:\n            can_divide = True\n            odd_count = 1\n    return \"Yes\" if can_divide and sequence[0] % 2 != 0 and sequence[-1] % 2 != 0 else \"No\"\n\n# Example usage\nn = int(input())\nsequence = list(map(int, input().split()))\nprint(can_divide_into_odd_subsegments(n, sequence))"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    if x1 == x2:  # Vertical line\n        x3, y3 = x1 + abs(y2 - y1), y1\n        x4, y4 = x1 + abs(y2 - y1), y2\n    elif y1 == y2:  # Horizontal line\n        x3, y3 = x1, y1 + abs(x2 - x1)\n        x4, y4 = x2, y1 + abs(x2 - x1)\n    else:\n        return -1\n\n    return [x3, y3, x4, y4]\n\n# Reading input\nx1, y1, x2, y2 = map(int, input().split())\n\n# Calculating and printing output\nresult = find_remaining_trees(x1, y1, x2, y2)\nprint(*result)"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(x, y, n):\n    if n == 1:\n        return x % MOD\n    if n == 2:\n        return y % MOD\n    \n    # Using the recurrence in reverse for efficiency\n    fn_2 = x\n    fn_1 = y\n    for _ in range(3, n + 1):\n        fn = (fn_1 - fn_2) % MOD\n        fn_2, fn_1 = fn_1, fn\n    \n    return fn_1\n\nif __name__ == \"__main__\":\n    x, y = map(int, input().split())\n    n = int(input())\n    print(solve(x, y, n))"}
{"solution": "def find_splits(arr):\n    n = len(arr)\n    start = 0\n    splits = []\n    \n    while start < n:\n        end = start\n        curr_sum = 0\n        while end < n and curr_sum + arr[end] != 0:\n            curr_sum += arr[end]\n            end += 1\n        \n        if curr_sum == 0:\n            return False, []\n        \n        splits.append((start+1, end))\n        start = end\n    \n    return True, splits\n\ndef main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    is_possible, splits = find_splits(arr)\n    \n    if not is_possible:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(len(splits))\n        for split in splits:\n            print(*split)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "`\ndef min_quiz_score(n, m, k):\n    MOD = 1000000009\n    if m >= k:\n        full_sequences = m // k\n        remainder = m % k\n        score = ((full_sequences * (full_sequences - 1) // 2) * (2 ** (k - 1)) + (full_sequences + 1) * (2 ** (remainder - 1))) % MOD\n    else:\n        score = 1 if m > 0 else 0\n    return score\n\n# Example usage\nn, m, k = map(int, input().split())\nprint(min_quiz_score(n, m, k))"}
{"solution": "def find_divisible_by_8(num_str):\n    length = len(num_str)\n\n    # Check if the number itself is divisible by 8\n    if int(num_str) % 8 == 0:\n        return num_str\n\n    # Check substrings of length 1, 2, and 3\n    for i in range(length - 1, -1, -1):\n        for j in range(max(0, i - 2), i + 1):\n            if int(num_str[j:i+1]) % 8 == 0 and num_str[j] != '0':\n                return num_str[:j] + num_str[i+1:]\n\n    return \"NO\"\n\nn = input().strip()\nresult = find_divisible_by_8(n)\n\nif result == \"NO\":\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(result)"}
{"solution": "def find_floor(n, memories):\n    possible_flats = set()\n\n    for i in range(1, 101):\n        valid = True\n        for k, f in memories:\n            if (k + i - 1) // i != f:\n                valid = False\n                break\n        if valid:\n            possible_flats.add((n + i - 1) // i)\n\n    if len(possible_flats) == 1:\n        return list(possible_flats)[0]\n    else:\n        return -1\n\nn, m = map(int, input().split())\nmemories = [tuple(map(int, input().split())) for _ in range(m)]\n\nprint(find_floor(n, memories))"}
{"solution": "def max_bishwocks(board_top, board_bottom):\n    def dp(s):\n        n = len(s)\n        dp_table = [0] * (n + 1)\n        dp_table[1] = 1 if s[0] == '0' else 0\n        for i in range(2, n + 1):\n            dp_table[i] = dp_table[i - 1]\n            if s[i - 2] == '0' and s[i - 1] == '0':\n                dp_table[i] = max(dp_table[i], dp_table[i - 2] + 1)\n        return dp_table[n]\n\n    n = len(board_top)\n    top = dp(board_top)\n    bottom = dp(board_bottom)\n    combined = 0\n    for i in range(n):\n        if board_top[i] == '0' and board_bottom[i] == '0':\n            if (i == n - 1 or board_top[i + 1] != '0' or board_bottom[i + 1] != '0') and \\\n               (i == 0 or board_top[i - 1] != '0' or board_bottom[i - 1] != '0'):\n                combined += 1\n    return max(top, bottom, combined)\n\n# Reading input\nboard_top = input().strip()\nboard_bottom = input().strip()\n\n# Calculating and printing the result\nprint(max_bishwocks(board_top, board_bottom))"}
{"solution": "n = int(input())\ns = input()\n\ncnt = 0\nlast = ''\n\nfor i in range(n-1, -1, -1):\n    if s[i].islower() and s[i] not in last:\n        cnt += 1\n        last += s[i]\n    elif s[i].isupper():\n        last = ''\n        \nprint(cnt)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ntotal_sum = sum([x for x in a if x > 0])\n\nif total_sum == 0:\n    max_value = max(a)\nelse:\n    max_value = total_sum\n\nprint(max_value)"}
{"solution": "import math\n\ndef min_refuels(a, b, f, k):\n    if b >= 2 * a - f:\n        return k - 1\n    if b < f:\n        return -1\n    if b == a + f:\n        return math.ceil(k / 2)\n    \n    res = 0\n    distance_covered = b\n    journey = 1\n    \n    while journey <= k:\n        if distance_covered < 2 * f:\n            res += 1\n            distance_covered += b\n        elif distance_covered < a + f:\n            res += 1\n            distance_covered += b - (a + f - distance_covered)\n        else:\n            journey += 1\n            distance_covered -= a\n            if distance_covered < f:\n                res += 1\n                distance_covered += b\n            else:\n                distance_covered += b - (distance_covered - f)\n                \n    return res\n\na, b, f, k = map(int, input().split())\nprint(min_refuels(a, b, f, k))"}
{"solution": "n, p, q = map(int, input().split())\ns = input()\n\ndef solve():\n    res = []\n    while s:\n        if len(s) >= p and s[:p] in s:\n            res.append(s[:p])\n            s = s[p:]\n        elif len(s) >= q and s[:q] in s:\n            res.append(s[:q])\n            s = s[q:]\n        else:\n            return [-1]\n    return [len(res)] + res\n\nres = solve()\nif res[0] == -1:\n    print(-1)\nelse:\n    print(res.pop(0))\n    for i in res:\n        print(i)"}
{"solution": "def solve(n, m, s, d, obstacles):\n    obs_set = set(obstacles)\n    obs_set.add(m)\n    obs_list = sorted(list(obs_set))\n\n    dp = [False] * len(obs_list)\n    dp[0] = True\n    prev_jumps = [0] * len(obs_list)\n\n    for i in range(1, len(obs_list)):\n        diff = obs_list[i] - obs_list[i-1]\n        if diff > d:\n            continue\n\n        if dp[i-1]:\n            dp[i] = True\n            prev_jumps[i] = obs_list[i-1]\n            continue\n\n        for j in range(i-1, -1, -1):\n            if obs_list[i] - obs_list[j] > d:\n                break\n            if dp[j] and obs_list[j] + s <= obs_list[i]:\n                dp[i] = True\n                prev_jumps[i] = obs_list[j]\n                break\n\n    if not dp[-1]:\n        return \"IMPOSSIBLE\"\n\n    result = []\n    curr = m\n    while curr != 0:\n        prev = prev_jumps[curr]\n        if prev == 0:\n            break\n        if obs_list.index(prev) == obs_list.index(curr) - 1:\n            result.append(f\"RUN {curr - prev}\")\n        else:\n            result.append(f\"JUMP {curr - prev}\")\n        curr = prev\n\n    return \"\\n\".join(reversed(result))\n\nif __name__ == \"__main__\":\n    n, m, s, d = map(int, input().split())\n    obstacles = list(map(int, input().split()))\n    print(solve(n, m, s, d, obstacles))"}
{"solution": "def count_pairs(s, x):\n    if s > 2 * x:\n        return 0\n    lower_bit_set = s - x\n    if lower_bit_set & (lower_bit_set - 1) == 0:\n        return (s // 2) % 2 + 1\n    else:\n        return 0\n\nif __name__ == \"__main__\":\n    s, x = map(int, input().strip().split())\n    print(count_pairs(s, x))"}
{"solution": "def solve(n, k):\n    if k == 0:\n        return [str(i+1) for i in range(n)]\n    elif 2*k + 1 >= n:\n        return ['1']\n    elif n % (2*k + 1) == 0:\n        return [str(i) for i in range(k+1, n, 2*k+1)]\n    else:\n        res = [str(i) for i in range(k+1, n-(n % (2*k + 1)), 2*k+1)]\n        res.append(str(n-(n % (2*k + 1))))\n        return res\n\nn, k = map(int, input().split())\nans = solve(n, k)\nprint(len(ans))\nprint(' '.join(ans))"}
{"solution": "import math\ndef isSquare(n):\n    return int(math.sqrt(n)) ** 2 == n\n\ndef solve(n):\n    if isSquare(n): return 0\n    for i in range(len(n)):\n        sub = n[:i] + n[i+1:]\n        if isSquare(int(sub)): return 1\n    for i in range(len(n)):\n        for j in range(i+1, len(n)):\n            sub = n[:i] + n[i+1:j] + n[j+1:]\n            if isSquare(int(sub)): return 2\n    return -1\n\nn = input().strip()\nprint(solve(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef fact(n):\n    f = [1]*(n+1)\n    for i in range(1,n+1):\n        f[i] = f[i-1]*i%MOD\n    return f\n\ndef invfact(n,f):\n    if n == 0: return [1]\n    g = [pow(f[n], MOD-2, MOD)]\n    for i in range(n,0,-1):\n        g += [g[-1]*i%MOD]\n    return g[::-1]\n\ndef solve(n):\n    f = fact(n)\n    g = invfact(n,f)\n    pr = [0]*(n+1)\n    cnt = [0]*(n+1)\n    mx = 0\n    for i in range(1,n+1):\n        x = i\n        m = 1\n        while x > 1:\n            p = 2\n            while p*p <= x:\n                if x % p == 0:\n                    m *= -1\n                    if cnt[p] == 0:\n                        cnt[p] = m\n                        pr[mx+1] += 1\n                        mx += 1\n                    m *= cnt[p]\n                    while x % p == 0:\n                        x //= p\n                p += 1\n            if x > 1:\n                m *= -1\n                if cnt[x] == 0:\n                    cnt[x] = m\n                    pr[mx+1] += 1\n                    mx += 1\n                m *= cnt[x]\n        pr[mx+1] += 1\n    ans = 1\n    for i in range(mx+1):\n        ans *= pow(f[n-pr[i]], pr[i+1], MOD)*f[pr[i]]*g[pr[i]]\n        ans %= MOD\n    return ans\n\nn = int(input())\nprint(solve(n))"}
{"solution": "3\ns = input()\nvowels = \"AEIOUY\"\ndp = [0] * (len(s) + 1)\nlast = -1\nfor i in range(len(s)):\n    if s[i] in vowels:\n        last = i\n    dp[i+1] = last\nans = 1\ni = len(s)\nwhile i > 1 and dp[i] < ans:\n    i = dp[i]\n    ans += 1\nprint(ans)"}
{"solution": "def can_distribute_evenly(bags):\n    total_candies = sum(bags)\n    if total_candies % 2 != 0:\n        return \"NO\"\n    half_candies = total_candies // 2\n    for i in range(4):\n        for j in range(i + 1, 4):\n            if bags[i] + bags[j] == half_candies:\n                return \"YES\"\n    return \"NO\"\n\n# Reading input\nbags = list(map(int, input().split()))\n\n# Printing output\nprint(can_distribute_evenly(bags))"}
{"solution": "def pie_sharing(slices):\n    alice, bob = 0, 0\n    while slices:\n        if len(slices) == 1 or slices[0] > slices[-1]:\n            bob += slices.pop(0)\n            alice += slices.pop()\n        else:\n            alice += slices.pop()\n            bob += slices.pop(0)\n    return alice, bob\n\nif __name__ == \"__main__\":\n    n = int(input())\n    slices = list(map(int, input().split()))\n    alice, bob = pie_sharing(slices)\n    print(alice, bob)"}
{"solution": "from math import gcd\nfrom functools import reduce\n\ndef find_min_vars(ops):\n    def min_vars_for_ops(ops):\n        if len(ops) <= 1:\n            return 1\n        gc = reduce(gcd, ops)\n        if gc == 1:\n            return 1\n        ops_set = set(ops)\n        for op in ops:\n            if op != gc and gc * op // gcd(op, gc) in ops_set:\n                return 2\n        return -1\n\n    sorted_ops = sorted(ops, reverse=True)\n    return min_vars_for_ops(sorted_ops)\n\nif __name__ == \"__main__\":\n    _ = int(input())\n    ops = list(map(int, input().split()))\n    print(find_min_vars(ops))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\nb = [0] * 51\nfor i in a:\n    b[i] += 1\nc = [0] * 51\nprev = 0\nfor i in range(50, -1, -1):\n    if b[i]:\n        prev += b[i]\n    c[i] = prev\ndp = [False] * 51\nfor i in range(51):\n    if not c[i]:\n        continue\n    for j in range(i):\n        if c[j] >= n // 2:\n            dp[i] = not dp[j]\n            break\nprint(\"Alice\" if dp[max(a)] else \"Bob\")"}
{"solution": ">\nn=int(input())\nl=list(map(int,input().split()))\nl.sort()\nif n==1:\n    print(\"YES\")\nelse:\n    if l[0]==l[-1]:\n        print(\"YES\")\n    else:\n        i=0\n        j=n-1\n        m=l[j]\n        c=0\n        while j>=0 and i<=j:\n            if l[i]==m or l[i]==m*2 or l[i]==m/2 :\n                c+=1\n                i+=1\n            elif l[j]==m or l[j]==m*2 or l[j]==m/2:\n                c+=1\n                j-=1\n            else:\n                print(\"NO\")\n                break\n        if c==n:\n            print(\"YES\")"}
{"solution": "def z_algorithm(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            z[i] = min(r - i + 1, z[i - l])\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > r:\n            l, r = i, i + z[i] - 1\n    return z\n\nn = int(input())\ns = input()\n\nz = z_algorithm(s)\n\nans = 0\nfor i in range(1, n):\n    if z[i] + i < n:\n        ans = max(ans, z[i])\n\nprint(ans)"}
{"solution": "`\ndef min_time_to_reach_house(n, a):\n    mid = n // 2\n    if a == mid or a == mid + 1:\n        return mid\n    elif a < mid:\n        return a\n    else:\n        return n - a + 1\n\nn, a = map(int, input().split())\nprint(min_time_to_reach_house(n, a))"}
{"solution": "def check_lightsabers(n, m, colors, k):\n    from collections import defaultdict\n    color_count = defaultdict(int)\n    current_sum = 0\n    start_index = 0\n    for end_index, color in enumerate(colors):\n        color_count[color] += 1\n        current_sum += 1\n        \n        while color_count[color] > k[color - 1]:\n            color_count[colors[start_index]] -= 1\n            current_sum -= 1\n            start_index += 1\n        \n        if all(color_count[c] == kc for c, kc in enumerate(k, start=1)) and current_sum == sum(k):\n            return \"YES\"\n    return \"NO\"\n\n# Reading input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\nk = list(map(int, input().split()))\n\n# Processing and output\nprint(check_lightsabers(n, m, colors, k))"}
{"solution": "n = int(input())\nmishka, chris = 0, 0\nfor _ in range(n):\n    m, c = map(int, input().split())\n    if m > c:\n        mishka += 1\n    elif c > m:\n        chris += 1\nif mishka > chris:\n    print('Mishka')\nelif chris > mishka:\n    print('Chris')\nelse:\n    print('Friendship is magic!^^')"}
{"solution": "def is_valid_minesweeper_field(field):\n    n, m = len(field), len(field[0])\n    directions = [(dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if (dx, dy) != (0, 0)]\n\n    def in_bounds(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                continue\n            elif field[i][j] == '.':\n                for dx, dy in directions:\n                    nx, ny = i + dx, j + dy\n                    if in_bounds(nx, ny) and field[nx][ny] == '*':\n                        return False\n            else:\n                count = 0\n                for dx, dy in directions:\n                    nx, ny = i + dx, j + dy\n                    if in_bounds(nx, ny) and field[nx][ny] == '*':\n                        count += 1\n                if int(field[i][j]) != count:\n                    return False\n    return True\n\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\nprint(\"YES\" if is_valid_minesweeper_field(field) else \"NO\")"}
{"solution": "import math\n\ndef min_k_to_eat_half_candies(n):\n    \"\"\"\n    Finds the minimum value of k such that Vasya can eat at least half of the candies.\n    \"\"\"\n    low, high = 1, n\n    while low < high:\n        mid = (low + high) // 2\n        candies_left = n\n        vasya_eaten = 0\n        while candies_left > 0:\n            candies_left -= mid\n            if candies_left <= 0:\n                break\n            petya_eats = math.floor(candies_left * 0.1)\n            candies_left -= petya_eats\n            vasya_eaten += mid\n        if vasya_eaten >= n / 2:\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the result\nprint(min_k_to_eat_half_candies(n))"}
{"solution": "def can_rearrange_necklace(necklace):\n    o_count = necklace.count('o')\n    if o_count < 2:\n        return \"YES\"\n    \n    for links_between_pearls in range(1, len(necklace) // (o_count - 1) + 1):\n        if (len(necklace) - o_count) % links_between_pearls == 0 and \\\n           all((necklace[i:i+links_between_pearls+1].count('-') == links_between_pearls \n                for i in range(o_count) if necklace[i] == 'o')):\n            return \"YES\"\n    return \"NO\"\n\n# Reading input\nnecklace = input().strip()\n\n# Printing output\nprint(can_rearrange_necklace(necklace))"}
{"solution": "`\nimport sys\n\nn, m, k = map(int, sys.stdin.readline().split())\n\nl = 0\nr = m\n\nwhile l < r:\n    mid = (l + r + 1) // 2\n    needed = mid\n    dist = min(mid - 1, k - 1)\n    needed += (dist * (dist + 1)) // 2\n    dist = min(mid - 1, n - k)\n    needed += (dist * (dist + 1)) // 2\n    if needed <= m:\n        l = mid\n    else:\n        r = mid - 1\nprint(l)"}
{"solution": "from collections import deque\n\ndef max_subarray_cost(a, m, k):\n    n = len(a)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    max_cost = 0\n    queue = deque()\n    for r in range(n + 1):\n        while queue and r - queue[0][1] >= m:\n            queue.popleft()\n\n        if r < m:\n            max_cost = max(max_cost, prefix_sum[r] - k * (r // m))\n        else:\n            max_cost = max(max_cost, prefix_sum[r] - k * (r // m) - queue[0][0])\n\n        while queue and prefix_sum[r] - k * (r // m) <= queue[-1][0]:\n            queue.pop()\n\n        queue.append((prefix_sum[r] - k * (r // m), r))\n\n    return max_cost\n\n# Reading input\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(max_subarray_cost(a, m, k))"}
{"solution": "def main():\n    n, m = map(int, input().split())\n    \n    if n >= m:\n        print(n, m)\n        print(0, m)\n        print(n, 0)\n        print(0, 0)\n    else:\n        print(m, n)\n        print(0, n)\n        print(m, 0)\n        print(0, 0)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_smallest_number(s, t):\n    s_len = len(s)\n    t_len = len(t)\n    t = t.lstrip('0')  # Remove leading zeros from t\n    t_len_no_zeros = len(t)\n\n    # Edge case: if t starts with '0', we need to ensure s starts with '0' too\n    if t[0] == '0':\n        for i in range(s_len - t_len + 1):\n            if s[i] == '0':\n                suffix = s[:i] + s[i + t_len:]\n                if all(int(c) >= int(t[-1]) for c in suffix):\n                    return s[:i] + t + s[i + t_len:]\n        return \"0\" * (s_len - t_len) + t\n\n    min_num = None\n    for i in range(s_len - t_len + 1):\n        if s[i:i + t_len_no_zeros] == t:\n            suffix = s[:i] + s[i + t_len:]\n            if all(int(c) >= int(t[-1]) for c in suffix):\n                num = s[:i] + t + s[i + t_len:]\n                if min_num is None or num < min_num:\n                    min_num = num\n\n    return min_num\n\n# Reading input\ns = input().strip()\nt = input().strip()\n\n# Finding the smallest number\nresult = find_smallest_number(s, t)\n\n# Printing the result\nprint(result)"}
{"solution": "3\nn, m, mi, ma = map(int, input().split())\ntemps = sorted(map(int, input().split()))\n\nif m == 1:\n    print('Correct')\nelif n == m:\n    if mi == max(temps) or mi == min(temps):\n        print('Incorrect')\n    elif ma == max(temps) or ma == min(temps):\n        print('Incorrect')\n    else:\n        print('Correct')\nelse:\n    if temps[0] == mi and temps[-1] == ma:\n        print('Correct')\n    elif temps[0] == mi and temps[-1] != ma and n - m >= temps.count(temps[0]):\n        print('Correct')\n    elif temps[-1] == ma and temps[0] != mi and n - m >= temps.count(temps[-1]):\n        print('Correct')\n    elif temps[0] != mi and temps[-1] != ma and n - m >= temps.count(temps[0]) + temps.count(temps[-1]):\n        print('Correct')\n    else:\n        print('Incorrect')"}
{"solution": "`\nimport sys\n\nm = int(sys.stdin.readline())\n\nif m == 0:\n    print(1)\n    print(0)\nelse:\n    n = m * 4\n    result = []\n    while True:\n        c = 5\n        cnt = 0\n        nn = n\n        while nn >= c:\n            cnt += nn // c\n            c *= 5\n        if cnt == m:\n            result.append(n)\n        elif cnt > m:\n            break\n        n += 1\n    if len(result) == 0:\n        print(0)\n    else:\n        print(len(result))\n        print(\" \".join(map(str, result)))"}
{"solution": "import heapq\n\ndef dijkstra(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [(0, start)]\n    \n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node].items():\n            distance = max(current_distance, weight)\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n    \n    return distances\n\n\ndef find_farthest_special_vertices(n, m, k, special_vertices, edges):\n    graph = {i + 1: {} for i in range(n)}\n    \n    for u, v, w in edges:\n        if v in graph[u]:\n            graph[u][v] = min(graph[u][v], w)\n        else:\n            graph[u][v] = w\n        \n        if u in graph[v]:\n            graph[v][u] = min(graph[v][u], w)\n        else:\n            graph[v][u] = w\n    \n    results = []\n    for special_vertex in special_vertices:\n        distances_to_special = {special: dijkstra(graph, special_vertex)[special] for special in special_vertices}\n        farthest_special = max(distances_to_special, key=distances_to_special.get)\n        results.append(distances_to_special[farthest_special])\n    \n    return results\n\n\n# Reading input\nn, m, k = map(int, input().split())\nspecial_vertices = list(map(int, input().split()))\nedges = [list(map(int, input().split())) for _ in range(m)]\n\n# Solving and printing output\nresult = find_farthest_special_vertices(n, m, k, special_vertices, edges)\nprint(*result)"}
{"solution": "n = int(input())\nx = int(input())\n\nif n % 2 == 0:\n    if x == 0:\n        print(0)\n    elif x == 1:\n        print(2)\n    else:\n        print(1)\nelse:\n    if x == 0:\n        print(1)\n    elif x == 1:\n        print(0)\n    else:\n        print(2)"}
{"solution": "def check_square(rectangles):\n    sides = []\n    for rect in rectangles:\n        x1, y1, x2, y2 = rect\n        side1 = (x1, y1, 'start')\n        side2 = (x2, y1, 'end')\n        side3 = (x1, y2, 'start')\n        side4 = (x2, y2, 'end')\n        sides.extend([side1, side2, side3, side4])\n\n    sides.sort()\n    corner = None\n    for i, (x, y, t) in enumerate(sides):\n        if t == 'start':\n            if corner is None:\n                corner = (x, y)\n            elif x != corner[0] and y != corner[1]:\n                return \"NO\"\n        else:\n            if i == len(sides) - 1 or sides[i + 1][0] != x or sides[i + 1][1] != y:\n                return \"NO\"\n\n    if corner is None or (sides[-1][0] - corner[0]) != (sides[-1][1] - corner[1]):\n        return \"NO\"\n\n    return \"YES\"\n\nn = int(input())\nrectangles = [list(map(int, input().split())) for _ in range(n)]\nprint(check_square(rectangles))"}
{"solution": "def count_big_numbers(n, s):\n    str_n = str(n)\n    len_n = len(str_n)\n    total = 0\n    for i in range(len_n):\n        current_digit = int(str_n[i])\n        max_possible_in_rest = 9 * (len_n - i - 1)\n        if current_digit > 0:\n            total += (current_digit - 1) * 10 ** (len_n - i - 1) * (i + 1) + max_possible_in_rest * 10 ** (len_n - i - 1) + 1\n        if total > n - s:\n            break\n    return n - s - total if n - s >= 0 else 0\n\nif __name__ == \"__main__\":\n    n, s = map(int, input().split())\n    print(count_big_numbers(n, s))"}
{"solution": "`\nfrom collections import defaultdict \nimport sys \ninput = sys.stdin.readline \n\nn = int(input()) \nd = defaultdict(int) \n\nfor i in range(n): \n    x, y = map(int, input().split()) \n    d[(x, y)] += 1\n\noneline = False \ntwoline = False \n\nif max(d.values()) == n: \n    oneline = True \n\nelse: \n    slopes = defaultdict(int) \n\n    for i in range(n): \n        x1, y1 = list(d.keys())[i] \n        if d[(x1, y1)] > 1: \n            oneline = True \n            break \n\n    if not oneline: \n        for i in range(n): \n            x1, y1 = list(d.keys())[i] \n\n            for j in range(i + 1, n): \n                x2, y2 = list(d.keys())[j] \n\n                if x2 - x1 == 0: \n                    m = \"inf\" \n                else: \n                    m = (y2 - y1) // (x2 - x1) \n\n                b = y1 - m * x1 \n\n                slopes[(m, b)] += d[(x1, y1)] + d[(x2, y2)] \n\n        twoline = max(slopes.values()) + max(d.values()) >= n \n\nif oneline or twoline: \n    print(\"YES\") \nelse: \n    print(\"NO\")"}
{"solution": "import sys\n\nMOD = 10**9 + 7\n\ndef main():\n    a, b, k, t = map(int, sys.stdin.readline().split())\n\n    dp = [[[[0 for _ in range(2 * k + 1)] for _ in range(2 * k + 1)] for _ in range(t + 1)] for _ in range(2)]\n    dp[0][0][a][b] = 1\n\n    for turn in range(t):\n        for memory in range(2 * k + 1):\n            for lex in range(2 * k + 1):\n                for memory_diff in range(-k, k + 1):\n                    for lex_diff in range(-k, k + 1):\n                        dp[(turn + 1) % 2][turn + 1][memory + memory_diff][lex + lex_diff] += dp[turn % 2][turn][memory][lex]\n                        dp[(turn + 1) % 2][turn + 1][memory + memory_diff][lex + lex_diff] %= MOD\n\n    result = sum(dp[t % 2][t][memory][lex] for memory in range(2 * k + 1) for lex in range(2 * k + 1) if memory > lex) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_missing_marks(marks, x, y):\n    missing = {x, y}\n    for i in range(len(marks)):\n        for j in range(i + 1, len(marks)):\n            diff = marks[j] - marks[i]\n            if diff in missing:\n                missing.remove(diff)\n    return len(missing), list(missing)\n\ndef main():\n    n, l, x, y = map(int, input().split())\n    marks = [0] + list(map(int, input().split())) + [l]\n    marks.sort()\n    \n    count, new_marks = find_missing_marks(marks, x, y)\n    \n    print(count)\n    print(' '.join(map(str, sorted(new_marks))))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from math import pi\ndef search(arr, val):\n    l = 0\n    h = len(arr)-1\n    ans = -1\n    while(l<=h):\n        mid = (l+h)//2\n        if(arr[mid]<=val):\n            ans = mid\n            l = mid+1\n        else:\n            h = mid-1\n    return ans\n\nn = int(input())\narr = []\nfor _ in range(n):\n    r,h = map(int,input().split())\n    arr.append(pi*r*r*h)\n\ndp = [arr[0]]\nfor i in range(1,n):\n    idx = search(dp, arr[i])\n    if(idx==-1):\n        dp.append(arr[i])\n    elif(idx==len(dp)-1 and arr[i]>dp[idx]):\n        dp.append(arr[i])\n    else:\n        dp[idx+1] = max(dp[idx], arr[i])\n\nprint(sum(dp))"}
{"solution": "from typing import List\nfrom bisect import bisect_right\n\ndef min_slices(n: int, k: int, heights: List[int]) -> int:\n    \"\"\"\n    Calculate the minimum number of good slices to make all towers have the same height.\n    \n    :param n: Number of towers.\n    :param k: Restriction on slices.\n    :param heights: Heights of the towers.\n    :return: Minimum number of good slices.\n    \"\"\"\n    heights.sort()\n    prefix_sum = [0]\n    for height in heights:\n        prefix_sum.append(prefix_sum[-1] + height)\n        \n    def is_possible(slices: int) -> bool:\n        final_height = bisect_right(heights, slices * n - prefix_sum[slices])\n        cost = (prefix_sum[n] - prefix_sum[final_height] -\n                (prefix_sum[slices] - prefix_sum[final_height]) +\n                (n - slices) * final_height)\n        return cost <= k\n    \n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if is_possible(mid):\n            right = mid\n        else:\n            left = mid + 1\n            \n    return left\n\n# Example check function (not part of the solution)\ndef check_solution():\n    assert min_slices(5, 5, [3, 1, 2, 2, 4]) == 2\n    assert min_slices(4, 5, [2, 3, 4, 5]) == 2\n    print(\"All tests passed!\")\n\ncheck_solution()"}
{"solution": "from itertools import accumulate\n\ndef max_score(n, a):\n    pref = [0] * (n + 2)\n    suf = [0] * (n + 2)\n    \n    for i in range(1, n + 1):\n        pref[i] = pref[i - 1] + a[i - 1]\n        \n    for i in range(n, 0, -1):\n        suf[i] = suf[i + 1] + a[i - 1]\n        \n    left = 0\n    right = n + 1\n    ans = float('-inf')\n    \n    while left + 1 < right:\n        mid = (left + right) // 2\n        p = -float('inf')\n        s = -float('inf')\n        \n        for i in range(mid + 1, n + 2):\n            p = max(p, pref[i - mid - 1])\n            s = max(s, p + suf[i])\n            \n        if s > ans:\n            ans = s\n            left = mid\n        else:\n            right = mid\n            \n    return ans\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(max_score(n, a))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(k1, k2, k3):\n    lcm12 = lcm(k1, k2)\n    lcm13 = lcm(k1, k3)\n    lcm23 = lcm(k2, k3)\n    lcm123 = lcm(lcm12, k3)\n\n    if lcm123 == lcm12 or lcm123 == lcm13 or lcm123 == lcm23:\n        return \"YES\"\n    else:\n        return \"NO\"\n\nk1, k2, k3 = map(int, input().split())\nprint(solve(k1, k2, k3))"}
{"solution": "def min_deletions(s):\n    dp = [0] * (len(s) + 1)\n    stack = []\n    for i, char in enumerate(s, 1):\n        count = 1 + (stack and stack[-1][0] == char)\n        dp[i] = dp[i - 1] + (count == 1)\n        if stack and stack[-1][0] == char:\n            dp[i] = min(dp[i], dp[i - stack[-1][1] - 1] + 1)\n        if stack and stack[-1][1] + 1 == i - 1:\n            stack.pop()\n        stack.append((char, i - 1))\n    return dp[len(s)]\n\nn = int(input())\ns = input()\nprint(min_deletions(s))"}
{"solution": "def max_dance_pairs(n, boys, m, girls):\n    boys.sort()\n    girls.sort()\n    \n    boy_index = 0\n    girl_index = 0\n    pairs = 0\n    \n    while boy_index < n and girl_index < m:\n        if abs(boys[boy_index] - girls[girl_index]) <= 1:\n            pairs += 1\n            boy_index += 1\n            girl_index += 1\n        elif boys[boy_index] < girls[girl_index]:\n            boy_index += 1\n        else:\n            girl_index += 1\n            \n    return pairs\n\n# Reading input\nn = int(input())\nboys = list(map(int, input().split()))\nm = int(input())\ngirls = list(map(int, input().split()))\n\n# Printing output\nprint(max_dance_pairs(n, boys, m, girls))"}
{"solution": "`\nfrom itertools import permutations\n\na = [list(map(int, input().split())) for _ in range(4)]\n\nt1 = [[-1 for _ in range(4)] for _ in range(4)]\nt2 = [[-1 for _ in range(4)] for _ in range(4)]\n\nfor p1 in permutations([0, 1]):\n    for p2 in permutations([2, 3]):\n        d1, a1 = a[p1[0]][0], a[p1[1]][1]\n        d2, a2 = a[p2[0]][0], a[p2[1]][1]\n        t1[p1[0]][p1[1]] = max(t1[p1[0]][p1[1]], d1 - a2)\n        t1[p1[0]][p1[1]] = max(t1[p1[0]][p1[1]], d2 - a1)\n        t2[p2[0]][p2[1]] = max(t2[p2[0]][p2[1]], a2 - d1)\n        t2[p2[0]][p2[1]] = max(t2[p2[0]][p2[1]], a1 - d2)\n\nres = 'Draw'\nif any(x > 0 for x in sum(t1, [])):\n    res = 'Team 1'\nif any(x > 0 for x in sum(t2, [])):\n    if res == 'Team 1':\n        res = 'Draw'\n    else:\n        res = 'Team 2'\n\nprint(res)"}
{"solution": "import heapq\nfrom math import sqrt\n\ndef dist(p1, p2):\n    return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef check(mid, k, points, x0, y0):\n    heap = []\n    for point in points:\n        d = dist((point[0], point[1]), (x0, y0))\n        t = point[2] * d\n        if t <= mid:\n            k -= 1\n        else:\n            heapq.heappush(heap, t - mid)\n    \n    while heap and k > 0:\n        k -= 1\n        heapq.heappop(heap)\n    \n    return k <= 0\n\ndef solve(n, k, points):\n    x_coords = sorted(set([point[0] for point in points]))\n    y_coords = sorted(set([point[1] for point in points]))\n    \n    min_time = float('inf')\n    for x0 in x_coords:\n        for y0 in y_coords:\n            left, right = 0, 10**9\n            while right - left > 1e-6:\n                mid = (left + right) / 2\n                if check(mid, k, points, x0, y0):\n                    right = mid\n                else:\n                    left = mid\n            min_time = min(min_time, right)\n    \n    return min_time\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    points = [list(map(int, input().split())) for _ in range(n)]\n    for point in points:\n        point[2] = 1 / point[2]\n    \n    print(solve(n, k, points))"}
{"solution": "n = int(input())\ns = input()\nl,r,sl,sr = 0,0,0,0\nfor i in range(n//2):\n    if s[i] == '?':\n        l += 1\n    else:\n        sl += int(s[i])\nfor i in range(n//2,n):\n    if s[i] == '?':\n        r += 1\n    else:\n        sr += int(s[i])\nif sl > sr:\n    l,r = r,l\n    sl,sr = sr,sl\nif l < r:\n    l,r = r,l\n    sl,sr = sr,sl\nif l == r:\n    if sl == sr:\n        print('Bicarp')\n    else:\n        print('Monocarp')\nelse:\n    print('Monocarp')"}
{"solution": "def find_bus_route(n, t, routes):\n    earliest_bus = (float('inf'), -1)\n    for i in range(n):\n        s_i, d_i = routes[i]\n        if s_i >= t:\n            if s_i < earliest_bus[0]:\n                earliest_bus = (s_i, i + 1)\n        else:\n            k = (t - s_i - 1) // d_i\n            arrival_time = s_i + k * d_i\n            if arrival_time < earliest_bus[0]:\n                earliest_bus = (arrival_time, i + 1)\n\n    return earliest_bus[1]\n\n# Reading input\nn, t = map(int, input().split())\nroutes = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculating and printing output\nprint(find_bus_route(n, t, routes))"}
{"solution": "import math\n\ndef count_ones_in_range(start, end):\n    ones_count, power_of_two = 0, 1\n    while start > 0:\n        next_power_of_two = power_of_two * 2\n        range_count = min(end, next_power_of_two) - max(power_of_two, start)\n        ones_count += range_count\n        start //= 2\n        end //= 2\n        power_of_two *= 2\n    return ones_count\n\ndef find_n(m, k):\n    left, right = 0, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if count_ones_in_range(mid + 1, 2 * mid + 1) < m:\n            left = mid + 1\n        else:\n            right = mid\n    while count_ones_in_range(left + 1, 2 * left + 1) != m or bin(left + 1).count('1') != k:\n        left += 1\n    return left\n\nm, k = map(int, input().split())\nprint(find_n(m, k))"}
{"solution": ">\nn = int(input())\ns = input()\nl = [i for i in range(n) if s[i] == '*']\nfor i in range(len(l)):\n    for j in range(i + 1, len(l)):\n        if j - i >= 3:\n            if l[j] - l[j - 1] == l[j - 1] - l[j - 2] == l[j - 2] - l[j - 3] == l[j - 3] - l[i]:\n                print('yes')\n                exit(0)\nprint('no')"}
{"solution": "import sys\n\ndef read_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef read_int():\n    return int(sys.stdin.readline().strip())\n\ndef main():\n    n = read_int()\n    a = []\n    for i in range(n):\n        a.append(list(read_ints()))\n\n    def get_magic_number(a):\n        d = {}\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != 0:\n                    d[(i, j)] = a[i][j]\n        res = [0] * n\n        for i in range(n):\n            s = 0\n            for j in range(n):\n                if (i, j) in d:\n                    s += d[(i, j)]\n                else:\n                    res[i] = j\n            if s == 0:\n                s = 1\n            for j in range(n):\n                if (j, i) in d:\n                    s -= d[(j, i)]\n                else:\n                    res[n + i] = j\n            if s == 0:\n                s = 1\n            for j in range(n):\n                if (j, n - i - 1) in d:\n                    s -= d[(j, n - i - 1)]\n                else:\n                    res[2 * n + i] = n - i - 1\n            if s == 0:\n                s = 1\n            if i == 0:\n                res[-2] = 0\n                res[-1] = n - 1\n                s -= d[(0, 0)]\n                s -= d[(0, n - 1)]\n            elif i == n - 1:\n                s -= d[(n - 1, 0)]\n                s -= d[(n - 1, n - 1)]\n            if s < 1:\n                return -1, -1\n        return s, res\n\n    x, res = get_magic_number(a)\n    if x == -1:\n        print(-1)\n        return\n\n    d = {}\n    for i in range(n):\n        for j in range(n):\n            if a[i][j] != 0:\n                d[(i, j)] = a[i][j]\n    for i in range(2 * n + n + 2):\n        if res[i] != 0:\n            r = res[i] // x\n            if 0 <= r < n:\n                c = res[i] % x\n                if (r, c) in d:\n                    if d[(r, c)] != r * x + c + 1:\n                        print(-1)\n                        return\n                else:\n                    d[(r, c)] = r * x + c + 1\n                    break\n\n    if (0, 0) in d and (n - 1, n - 1) in d and d[(0, 0)] + d[(n - 1, n - 1)] != x + 1:\n        print(-1)\n        return\n\n    print(x)\n\nmain()"}
{"solution": "def min_max_people_on_benches(n, m, benches):\n    benches.sort()\n    \n    # Minimize k\n    min_k = (m + n - 1) // n\n    if m < n:\n        min_k = max(min_k, max(benches))\n    else:\n        min_k = max(min_k, (benches[-1] + m // n))\n    \n    # Maximize k\n    max_k = benches[0] + m\n    \n    for i in range(1, n):\n        if m >= (benches[i] - benches[i - 1]) * (n - i):\n            m -= (benches[i] - benches[i - 1]) * (n - i)\n            max_k = benches[i]\n        else:\n            max_k += m // (n - i)\n            break\n    \n    return min_k, max_k\n\n# Reading input\nn = int(input())\nm = int(input())\nbenches = [int(input()) for _ in range(n)]\n\n# Calculating and printing output\nmin_k, max_k = min_max_people_on_benches(n, m, benches)\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef modpow(x, y):\n    if y == 0:\n        return 1\n    elif y % 2 == 0:\n        return modpow((x * x) % MOD, y // 2) % MOD\n    else:\n        return (x * modpow(x, y - 1)) % MOD\n\ndef solve(n, m):\n    # Calculate the binomial coefficient (n choose m)\n    numerator = 1\n    for i in range(m):\n        numerator = (numerator * (n - i)) % MOD\n    \n    denominator = modpow(1, m)\n    for i in range(1, m + 1):\n        denominator = (denominator * modpow(i, MOD - 2)) % MOD\n    \n    binom = (numerator * denominator) % MOD\n    \n    # Calculate the answer using the formula\n    answer = modpow(2, m) * binom\n    for i in range(1, m + 1):\n        temp = (modpow(2, i) - 1) * modpow(2, m - i)\n        temp = temp * modpow(i, MOD - 2)\n        temp = temp * (n - m + i)\n        answer -= temp\n        answer %= MOD\n    \n    return answer\n\nn, m = map(int, input().split())\nprint(solve(n, m))"}
{"solution": "from itertools import combinations\n\ndef read_data():\n    n, m = map(int, input().split())\n    friends = []\n    for _ in range(n):\n        _, *ingredients = map(int, input().split())\n        friends.append(set(ingredients))\n    \n    pizzas = []\n    for _ in range(m):\n        cost, num_ings, *ingredients = map(int, input().split())\n        pizzas.append((cost, set(ingredients)))\n    return friends, pizzas\n\ndef solve(friends, pizzas):\n    def happiness(pizza_set):\n        return sum([1 for friend in friends if not (pizza_set ^ friend)]) \n    \n    best_happiness = -1\n    best_pair = None\n    min_cost = float('inf')\n    for i, j in combinations(range(m), 2):\n        combined_set = pizzas[i][1] | pizzas[j][1]\n        current_happiness = happiness(combined_set)\n        if current_happiness > best_happiness or (current_happiness == best_happiness and (pizzas[i][0] + pizzas[j][0]) < min_cost):\n            best_happiness = current_happiness\n            min_cost = pizzas[i][0] + pizzas[j][0]\n            best_pair = sorted([i+1, j+1])\n    \n    return best_pair\n\nfriends, pizzas = read_data()\nprint(*solve(friends, pizzas))"}
{"solution": "`\ndef find_min_max_numbers(m, s):\n    if m == 1:\n        return (s, s) if 0 <= s <= 9 else (-1, -1)\n\n    min_num = [-1] * m\n    max_num = [-1] * m\n\n    # Fill min_num\n    for i in range(m):\n        if s >= 9:\n            min_num[i] = 9\n            s -= 9\n        else:\n            min_num[i] = s\n            s = 0\n        if s == 0:\n            break\n    if s != 0 or min_num[0] == 0:\n        return (-1, -1)\n\n    # Fill max_num\n    for i in range(m - 1, -1, -1):\n        if s > 0:\n            max_num[i] = s\n            s = 0\n        elif s + 9 <= s:\n            max_num[i] = 9\n            s -= 9\n        else:\n            max_num[i] = s + 9\n            s = 0\n    if s != 0:\n        return (-1, -1)\n\n    return (''.join(map(str, min_num)), ''.join(map(str, max_num)))\n\n# Reading input\nm, s = map(int, input().split())\n# Printing output\nprint(' '.join(map(str, find_min_max_numbers(m, s))))"}
{"solution": "MOD = 998244353\n\ndef power(base, exp):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exp //= 2\n    return result\n\ndef inv(x):\n    return power(x, MOD - 2)\n\ndef C(n, k):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return fact[n] * inv(fact[k]) % MOD * inv(fact[n-k]) % MOD\n\ndef sum_numbers(l, r, k):\n    fact = [1]\n    for i in range(1, 11):\n        fact.append((fact[-1] * i) % MOD)\n    \n    def sum_k_digit_numbers(k, prefix=0, prefix_len=0):\n        if k == 0:\n            return prefix\n        total_sum = 0\n        for d in range(10):\n            if prefix_len == 0 and d == 0:\n                continue\n            new_prefix = prefix * 10 + d\n            total_sum += sum_k_digit_numbers(k-1, new_prefix, prefix_len + 1)\n        return total_sum % MOD\n    \n    def count_numbers(n, k):\n        if k == 0:\n            return 1 if n == 0 else 0\n        total_count = 0\n        for d in range(10):\n            if n == 0 and d == 0:\n                continue\n            new_n = n // 10 if n % 10 >= d else -1\n            total_count += count_numbers(new_n, k-1)\n        return total_count % MOD\n    \n    def sum_numbers_up_to(n, k):\n        if k == 0:\n            return 0 if n == 0 else n\n        total_sum = 0\n        for d in range(10):\n            if n == 0 and d == 0:\n                continue\n            new_n = n // 10 if n % 10 >= d else -1\n            total_sum += d * count_numbers(n, k-1) + sum_numbers_up_to(new_n, k-1)\n        return total_sum % MOD\n    \n    def sum_numbers_with_k_digits(k):\n        if k == 0:\n            return 0\n        return sum_k_digit_numbers(k) * C(9, k) * power(10, k-1) % MOD\n    \n    def sum_numbers_with_at_most_k_digits(k):\n        return sum(sum_numbers_with_k_digits(i) for i in range(1, k+1)) % MOD\n    \n    sum_r = sum_numbers_up_to(r, k) + sum_numbers_with_at_most_k_digits(k)\n    sum_l_minus_one = sum_numbers_up_to(l-1, k) + sum_numbers_with_at_most_k_digits(k)\n    \n    return (sum_r - sum_l_minus_one) % MOD\n\nl, r, k = map(int, input().split())\nprint(sum_numbers(l, r, k))"}
{"solution": "def can_distribute_pencils(n, k, d, pencils):\n    pencils.sort()\n    groups, current_max, count = 1, pencils[0], 1\n\n    for i in range(1, n):\n        if pencils[i] <= current_max + d:\n            count += 1\n        else:\n            groups += 1\n            current_max = pencils[i]\n            count = 1\n\n        if count == k:\n            count = 0\n            if i + 1 < n and pencils[i + 1] > current_max + d:\n                groups += 1\n                current_max = pencils[i + 1]\n\n    return \"YES\" if (n % k == 0 and groups == n // k) or (n % k != 0 and groups == n // k + 1) else \"NO\"\n\n# Example usage\nn, k, d = map(int, input().split())\npencils = list(map(int, input().split()))\nprint(can_distribute_pencils(n, k, d, pencils))"}
{"solution": "3\ns = input()\nl = [0]*4\nfor i in range(len(s)):\n\tif s[i] == '!':\n\t\tif i == len(s)-1 or s[i+1] == 'R':\n\t\t\tif i == 0 or s[i-1] == 'Y':\n\t\t\t\tl[3] += 1\n\t\t\telse:\n\t\t\t\tl[1] += 1\n\t\telif i == 0 or s[i-1] == 'R':\n\t\t\tif s[i+1] == 'Y':\n\t\t\t\tl[2] += 1\n\t\t\telse:\n\t\t\t\tl[0] += 1\n\t\telif s[i-1] == 'B' and s[i+1] == 'G':\n\t\t\tl[2] += 1\n\t\telif s[i-1] == 'G' and s[i+1] == 'B':\n\t\t\tl[0] += 1\nprint(*l)"}
{"solution": "from collections import defaultdict, deque\nimport sys\ninput = sys.stdin.readline\n\ndef main():\n    N, M = map(int, input().split())\n    edges = [[] for _ in range(N)]\n    for _ in range(M):\n        s, t = map(int, input().split())\n        edges[s-1].append(t-1)\n\n    # topological sort\n    indeg = [0] * N\n    for e in edges:\n        for v in e:\n            indeg[v] += 1\n    \n    q = deque([i for i, d in enumerate(indeg) if d == 0])\n    order = []\n    while q:\n        v = q.popleft()\n        order.append(v)\n        for nv in edges[v]:\n            indeg[nv] -= 1\n            if indeg[nv] == 0:\n                q.append(nv)\n\n    # dp\n    dp = [0] * N\n    for v in reversed(order[1:]):\n        cnt = sum(1 / (dp[nv] + 1) for nv in edges[v])\n        dp[v] = 1 + len(edges[v]) / cnt if cnt != 0 else len(edges[v])\n\n    # find the best option for the first step\n    ans = float(\"inf\")\n    for nv in edges[0]:\n        tmp = dp[0]\n        if len(edges[nv]) > 1:\n            tmp -= 1 / (dp[nv] + 1)\n            tmp += 1 / (dp[nv] + 2)\n        ans = min(ans, 1 + tmp)\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\nif n % 10 == 0:\n    print(n)\nelse:\n    if n % 10 <= 5:\n        print(n - n % 10)\n    else:\n        print(n - n % 10 + 10)"}
{"solution": "def solve(s, t):\n    swapped = {}\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if s[i] in swapped and swapped[s[i]] != t[i]:\n                return -1\n            if t[i] in swapped and swapped[t[i]] != s[i]:\n                return -1\n            swapped[s[i]] = t[i]\n            swapped[t[i]] = s[i]\n    pairs = set()\n    for k, v in swapped.items():\n        if k < v:\n            pairs.add((k, v))\n        else:\n            pairs.add((v, k))\n    return len(pairs), list(pairs)\n\ns = input().strip()\nt = input().strip()\n\nresult = solve(s, t)\nif result == -1:\n    print(-1)\nelse:\n    num_swaps, swaps = result\n    print(num_swaps)\n    for swap in swaps:\n        print(' '.join(swap))"}
{"solution": "def earliest_login(first_name, last_name):\n    result = first_name[0] + last_name[0]\n    for i in range(1, min(len(first_name), len(last_name)) + 1):\n        temp_result = first_name[:i] + last_name[:i]\n        result = min(result, temp_result)\n    return result\n\nfirst_name, last_name = input().split()\nprint(earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(sequence):\n    def draw(stack, level):\n        if not stack:\n            return [' ' * level]\n        br, rest = stack[0], stack[1:]\n        drawing = []\n        if br == '[':\n            drawing.extend(['+' + '-' * (len(rest) - rest.count(']') + 1)] + ['|' + ' ' * (len(rest) - rest.count(']')) + '|' for _ in range(level)])\n            inner_drawing = draw(rest, level + 1)\n            drawing.extend('|' + ' ' * (len(rest) - rest.count(']')) + '|' for _ in range(len(inner_drawing) - 1))\n            drawing.append('|' + inner_drawing[-1][1:])\n            drawing.extend(['+' + '-' * (len(rest) - rest.count(']') + 1)] + ['|' + ' ' * (len(rest) - rest.count(']')) + '|' for _ in range(level)])\n        else:\n            drawing.extend([' ' * (level - 1) + '+'] + [' ' * (level - 1) + '|' for _ in range(level)])\n            inner_drawing = draw(rest, level - 1)\n            drawing.extend(' ' * (level - 1) + '|' for _ in range(len(inner_drawing) - 1))\n            drawing.append(' ' * (level - 1) + '+' + inner_drawing[-1][level:])\n            drawing.extend(' ' * (level - 1) + '|' for _ in range(level))\n        return drawing\n\n    balanced = 0\n    stack = []\n    for br in sequence:\n        if br == '[':\n            stack.append(br)\n            balanced += 1\n        else:\n            stack.append(br)\n            balanced -= 1\n            while balanced < 0:\n                stack.pop()\n                balanced += 1\n    return '\\n'.join(draw(stack, 0))\n\nn = int(input())\nsequence = input().strip()\nprint(draw_brackets(sequence))"}
{"solution": "`\nfrom math import sqrt\n\nphi = (1 + sqrt(5)) / 2\n\ndef golden_to_decimal(s):\n    n = len(s)\n    total = 0\n    for i, digit in enumerate(s):\n        if digit == '1':\n            total += phi ** (n - i - 1)\n    return total\n\ns1 = input().strip()\ns2 = input().strip()\n\ndec1 = golden_to_decimal(s1)\ndec2 = golden_to_decimal(s2)\n\nif dec1 > dec2:\n    print(\">\")\nelif dec1 < dec2:\n    print(\"<\")\nelse:\n    print(\"=\")"}
{"solution": "gem_colors = {'purple': 'Power', 'green': 'Time', 'blue': 'Space', \n              'orange': 'Soul', 'red': 'Reality', 'yellow': 'Mind'}\n\nn = int(input())\npresent_colors = set()\nfor _ in range(n):\n    present_colors.add(input())\n\nabsent_gems = [gem_colors[color] for color in gem_colors if color not in present_colors]\n\nprint(len(absent_gems))\nfor gem in absent_gems:\n    print(gem)"}
{"solution": "`\ndef find_meeting_round(n, a, b):\n    round = 1\n    while a != b:\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        round += 1\n        if a == 0 or b == 0 or n <= 1:\n            return \"Final!\"\n        n //= 2\n    return round - 1 if round > 1 else \"Final!\"\n\nn, a, b = map(int, input().split())\nprint(find_meeting_round(n, min(a, b), max(a, b)))"}
{"solution": "import sys\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\nn = int(input())\np = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\n\nparent = {}\nrank = {}\n\ndef find(u):\n    if u != parent[u]:\n        parent[u] = find(parent[u])\n    return parent[u]\n\ndef union(u, v):\n    pu, pv = find(u), find(v)\n    if pu == pv:\n        return False\n    if rank[pu] > rank[pv]:\n        parent[pv] = pu\n    else:\n        parent[pu] = pv\n        if rank[pu] == rank[pv]:\n            rank[pv] += 1\n    return True\n\nfor i in range(n):\n    parent[i] = i\n    rank[i] = 0\n\nans = 0\nfor i in range(n):\n    if b[i] == 0:\n        if not union(i, p[i]-1):\n            ans += 1\n    else:\n        if not union(i, n - (p[i]-1) - 1):\n            ans += 1\n\nprint(ans)"}
{"solution": "v1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\nif v1 < v2:\n    s = [v1]\n    while s[-1] + d <= v2 and len(s) < t:\n        s.append(min(v2, s[-1] + d))\n    for i in range(len(s), t):\n        s.append(v2)\nelse:\n    s = [v1]\n    while s[-1] - d >= v2 and len(s) < t:\n        s.append(max(v2, s[-1] - d))\n    for i in range(len(s), t):\n        s.append(v2)\n\nprint(sum(s))"}
{"solution": "from bisect import bisect_left\nfrom itertools import accumulate\n\ndef check(D):\n    pos = [0] + [w + D for w in acc_w[:-1]] + [D]\n    for i in range(M):\n        left = bisect_left(pos, L[i])\n        right = bisect_left(pos, L[i] + dL[i])\n        if max(0, right - left) > cap[i]:\n            return False\n    return True\n\nN, M = map(int, input().split())\nw = list(map(int, input().split()))\nL, cap = zip(*[map(int, input().split()) for _ in range(M)])\n\nacc_w = list(accumulate(w))\ndL = [L[i+1] - L[i] for i in range(M-1)]\nacc_cap = [0] + list(accumulate(cap))\n\nlo, hi = 0, 10**10\nwhile lo + 1 < hi:\n    mid = (lo + hi) // 2\n    if check(mid):\n        hi = mid\n    else:\n        lo = mid\n\nif check(lo):\n    print(lo)\nelse:\n    print(-1)"}
{"solution": "def last_digit_of_factorial_ratio(a, b):\n    def last_non_zero_digit(n):\n        if n == 0:\n            return 1\n        digits = [6, 2, 4, 8]\n        n = n % 4\n        if n == 0:\n            return 6\n        return digits[n - 1]\n\n    if b >= 5 and a >= 5 and b - a >= 5:\n        return 0\n\n    fact_last_digit = lambda x: 1 if x == 0 else last_non_zero_digit(x) * (fact_last_digit(x - 1) % 10)\n\n    ratio = (fact_last_digit(b) // fact_last_digit(a)) % 10\n    return ratio % 10\n\na, b = map(int, input().split())\nprint(last_digit_of_factorial_ratio(a, b))"}
{"solution": "def min_jumps(n, d, s):\n    dp = [float('inf')] * n\n    dp[0] = 0\n    for i in range(1, n):\n        if s[i] == '1':\n            for j in range(max(0, i-d), i):\n                if s[j] == '1':\n                    dp[i] = min(dp[i], dp[j] + 1)\n    return dp[-1] if dp[-1] != float('inf') else -1\n\nif __name__ == \"__main__\":\n    n, d = map(int, input().split())\n    s = input()\n    print(min_jumps(n, d, s))"}
{"solution": "n = int(input())\nfor m in range(1, 1001):\n    if (n * m + 1) % 2 == 0 or (n * m + 1) % 3 == 0:\n        print(m)\n        break"}
{"solution": ">\ndef can_spend_all(n):\n    cost_house = 1234567\n    cost_car = 123456\n    cost_computer = 1234\n\n    for a in range(n // cost_house + 1):\n        for b in range((n - a * cost_house) // cost_car + 1):\n            c = (n - a * cost_house - b * cost_car) / cost_computer\n            if c.is_integer() and c >= 0:\n                return \"YES\"\n    return \"NO\"\n\nn = int(input())\nprint(can_spend_all(n))"}
{"solution": "import sys\n\ndef intersect(line1, line2):\n    k1, b1 = line1\n    k2, b2 = line2\n    if k1 == k2:\n        return None\n    x = (b2 - b1) / (k1 - k2)\n    y = k1 * x + b1\n    return (x, y)\n\ndef solve(n, x1, x2, lines):\n    for i in range(n):\n        for j in range(i + 1, n):\n            point = intersect(lines[i], lines[j])\n            if point and x1 < point[0] < x2:\n                print(\"YES\")\n                return\n    print(\"NO\")\n\nn = int(sys.stdin.readline().strip())\nx1, x2 = map(int, sys.stdin.readline().strip().split())\nlines = []\nfor _ in range(n):\n    k, b = map(int, sys.stdin.readline().strip().split())\n    lines.append((k, b))\n\nsolve(n, x1, x2, lines)"}
{"solution": "n = int(input())\nprint((n // 2) + 1)"}
{"solution": "n, k = map(int, input().split())\n\nif k == 0:\n    min_good, max_good = 0, 0\nelif k == 1:\n    min_good, max_good = 0, max(0, n - 2)\nelse:\n    min_good = max(0, k - 1)\n    max_good = n - k\n\nprint(min_good, max_good)"}
{"solution": "`\nimport math\nn = int(input())\nlo = 0\nhi = 2 * int(math.log(n, 2)) + 1\nwhile lo < hi - 1:\n    mid = (lo + hi) // 2\n    x = 2 ** mid - 1 + max(0, mid - 1)\n    if x <= n:\n        lo = mid\n    else:\n        hi = mid\nx = 2 ** lo - 1 + max(0, lo - 1)\nprint(lo if x == n else lo - 1)"}
{"solution": "s = input()\ncount_v = 0\ncount_k = 0\nvk_count = 0\nfor i in range(len(s)-1):\n    if s[i] == 'V' and s[i+1] == 'K':\n        vk_count += 1\n    elif s[i] == 'V':\n        count_v += 1\n    elif s[i] == 'K':\n        count_k += 1\n\nif s[-1] == 'V':\n    count_v += 1\nelif s[-1] == 'K':\n    count_k += 1\n\nmax_possible = vk_count + min(count_v, count_k)\nif max_possible == 0 and len(s) > 1:\n    max_possible = 1\n\nprint(max_possible)"}
{"solution": "n = int(input())\nprint(2 * ((n // 2) + (n % 2)))"}
{"solution": "a, b = map(int, input().split())\nyear = 0\nwhile a <= b:\n    a *= 3\n    b *= 2\n    year += 1\nprint(year)"}
{"solution": "import math\ndef solve(h,n):\n    ans = 0\n    d = int(math.log(n,2))\n    if d == h-1:\n        return (1<<h)-1\n    p = [0]*(h+1)\n    p[d+1] = n\n    for i in range(d+1,h):\n        p[i+1] = (p[i]+(1<<(h-i-1)))%((1<<h)+1)\n    for i in range(h,d,-1):\n        if (p[i]%2==0):\n            ans+=(1<<(i-1))\n        else:\n            ans+=(1<<(i-1))\n            ans+=1\n            p[i-1]+=1<<(h-i)\n    return ans\nh,n = map(int,input().split())\nprint(solve(h,n))"}
{"solution": "}\nfrom math import sqrt, ceil\n\nX = int(input())\n\ndef get_pairs(x):\n    pairs = []\n    for n in range(1, int(sqrt(2 * sqrt(X))) + 1):\n        # solve for m in f(n, m) = x\n        # m - (n + m - 1)*m/2 + n*(n+1)*(2*n+1)/6 = 0\n        a = 1\n        b = -1 - n\n        c = n*(n+1)*(2*n+1)//6 - x\n        discr = b**2 - 4*a*c\n        if discr < 0:\n            continue\n        m1 = (-b + sqrt(discr)) / (2*a)\n        m2 = (-b - sqrt(discr)) / (2*a)\n        for m in (m1, m2):\n            if m > 0 and m == ceil(m):\n                pairs.append((n, int(m)))\n    return pairs\n\npairs = get_pairs(X)\n\nprint(len(pairs))\nfor pair in sorted(pairs):\n    print(*pair)"}
{"solution": "def is_leap(year):\n    return year % 400 == 0 or (year % 4 == 0 and year % 100 != 0)\n\ndef valid_months(durations):\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    i = 0\n    year = 2000\n    while True:\n        for j, days in enumerate(days_in_month):\n            if durations:\n                if days == 28 and is_leap(year):\n                    days = 29\n                if days == durations[0]:\n                    durations.pop(0)\n                    i += 1\n                    break\n                else:\n                    i = 0\n            else:\n                return True\n        if i == 12 or len(durations) > 12:\n            return False\n        year += 1\n\nn = int(input())\na = list(map(int, input().split()))\nprint(\"Yes\" if valid_months(a) else \"No\")"}
{"solution": "def find_sequence(n):\n    if n == 2:\n        return [\"NO\"]\n    \n    factors = []\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            factors.append(i)\n            if i * i != n:\n                factors.append(n // i)\n    factors.sort()\n\n    if not factors:\n        return [\"NO\"]\n\n    result = [\"YES\", str(len(factors))]\n    for factor in factors:\n        result.append(f\"1 {factor}\")\n\n    return result\n\nn = int(input())\noutput = find_sequence(n)\nfor line in output:\n    print(line)"}
{"solution": "def min_unattractiveness(n, limits, heights):\n    a, b = limits\n    total_height = sum(heights)\n    dp = [[float('inf')] * 2 for _ in range(n + 1)]\n    dp[0][0], dp[0][1] = 0, 0\n    for i in range(n):\n        for j in range(2):\n            for k in range(2):\n                if j == 0:\n                    paint_area = sum(heights[:i + 1])\n                    if paint_area > b: continue\n                else:\n                    paint_area = sum(heights[:i + 1])\n                    if paint_area > a: continue\n                if k == 0:\n                    new_paint_area = paint_area + heights[i]\n                    if (k == 0 and new_paint_area > b) or (k == 1 and new_paint_area > a): continue\n                dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + (1 if j != k else 0))\n    result = min(dp[n][0], dp[n][1])\n    if result == float('inf'):\n        return -1\n    return result\n\n# Reading input\nn = int(input())\nlimits = list(map(int, input().split()))\nheights = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(min_unattractiveness(n, limits, heights))"}
{"solution": "`\ndef solve(n, m, k):\n    area = (n * m) / k\n    if area < 0.5 or area > n * m / 2 or (area - int(area)) != 0.5:\n        return \"NO\"\n    if n > m:\n        n, m = m, n\n    base = 0\n    height = 0\n    if area <= n * m / 2:\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                j = n // i\n                if i * m / 2 <= area <= j * m / 2:\n                    base, height = i, 2 * area // i\n                    break\n    if not base:\n        return \"NO\"\n    print(\"YES\")\n    print(0, 0)\n    print(base, 0)\n    print(0, height)\n\nimport sys\nn, m, k = map(int, sys.stdin.readline().split())\nsolve(n, m, k)"}
{"solution": "`\nn, k = map(int, input().split())\n\nif n % (2 * k) < k:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": ">\nn = int(input())\na = list(map(int, input().split()))\nchest = 0\nbiceps = 0\nback = 0\nfor i in range(n):\n    if i % 3 == 0:\n        chest += a[i]\n    elif i % 3 == 1:\n        biceps += a[i]\n    else:\n        back += a[i]\nif chest > biceps and chest > back:\n    print(\"chest\")\nelif biceps > chest and biceps > back:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "def min_redo_for_grade_five(n, grades):\n    total_sum = sum(grades)\n    below_five_count = n - grades.count(5)\n    target_sum = 5 * n\n\n    if total_sum == target_sum:\n        return 0\n\n    for redo_count in range(1, n + 1):\n        adjusted_sum = total_sum - below_five_count + redo_count * (5 - (below_five_count // redo_count))\n        if (adjusted_sum + redo_count - 1) // n == 5:\n            return redo_count\n\nn = int(input())\ngrades = list(map(int, input().split()))\nprint(min_redo_for_grade_five(n, grades))"}
{"solution": "}\nfrom itertools import product\n\ndef solve(u, v):\n    if not u and not v:\n        return [0]\n    \n    if u > v or (u & (u - 1) == 0 and u != v):  # Check for impossible cases\n        return [-1]\n\n    result = []\n    if u:\n        result.append(u)\n        v -= u\n    else:\n        result.append(1)\n        v -= 1\n    \n    if v % 2 == 1:\n        result.append(1)\n        v -= 1\n\n    while v:\n        result.extend([2, 2])\n        v -= 4\n\n    return result\n\ndef main():\n    u, v = map(int, input().split())\n    result = solve(u, v)\n    if result == [-1]:\n        print(-1)\n    else:\n        print(len(result))\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\ndef solve(n):\n    if n == 1:\n        return 1\n    if n < 10:\n        return n\n    r = 1\n    while 10 ** r <= n:\n        r += 1\n    ans = 10 ** r - n + 1\n    for i in range(r - 1, -1, -1):\n        x = 10 ** i - 1\n        c = (n + x) // (10 ** i)\n        if ans > c:\n            ans = c\n    return ans\n\nprint(solve(n))"}
{"solution": "import math\n\ndef can_reach_treasure(start, target, potion):\n    x1, y1 = start\n    x2, y2 = target\n    x, y = potion\n\n    diff_x = abs(x2 - x1)\n    diff_y = abs(y2 - y1)\n\n    gcd = math.gcd(x, y)\n\n    return diff_x % gcd == 0 and diff_y % gcd == 0\n\nstart, target = list(map(int, input().split())), list(map(int, input().split()))\npotion = list(map(int, input().split()))\n\nprint(\"YES\" if can_reach_treasure(start, target, potion) else \"NO\")"}
{"solution": "from collections import Counter\n\ndef calculate_combinations(digit_counts):\n    combinations = 1\n    factorial_cache = [1] * 11\n    for i in range(1, 11):\n        factorial_cache[i] = factorial_cache[i - 1] * i\n    \n    for count in digit_counts.values():\n        combinations *= factorial_cache[count]\n    \n    return combinations\n\ndef possible_variants(n):\n    digits = list(str(n))\n    digit_counts = Counter(digits)\n    total_combinations = calculate_combinations(digit_counts)\n    \n    if '0' in digit_counts:\n        without_leading_zero = possible_variants(int(''.join([str(d) for d in digits if d != '0'])))\n        return (total_combinations // without_leading_zero) * (len(digits) - digits.count('0'))\n    else:\n        return total_combinations\n\nn = int(input())\nprint(possible_variants(n))"}
{"solution": "a = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\ntype1 = min(a,d) * e\nd -= min(a,d)\na -= min(a,d)\n\ntype2 = min(b,c,d) * f\n\nprint(type1+type2)"}
{"solution": "from math import gcd\n\ndef mod_pow(base, exp, modulus):\n    result = 1\n    base = base % modulus\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % modulus\n        exp = exp >> 1\n        base = (base * base) % modulus\n    return result\n\ndef mod_inverse(a, m):\n    if gcd(a, m) != 1:\n        return None\n    u1, u2, u3 = 1, 0, a\n    v1, v2, v3 = 0, 1, m\n    while v3 != 0:\n        q = u3 // v3\n        v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3\n    return u1 % m\n\ndef solve(a, b, p, x):\n    cycles = {}\n    cycle_length = 0\n    prev_val = 0\n    n = 1\n    while True:\n        val = (n * mod_pow(a, n, p)) % p\n        if val in cycles:\n            break\n        if prev_val == val:\n            cycle_length = 1\n            break\n        cycles[val] = n\n        prev_val = val\n        n += 1\n    for start, n in cycles.items():\n        if (start * mod_pow(a, n, p)) % p == b:\n            cycle_length += 1\n    full_cycles, rem = divmod(x, n)\n    ans = full_cycles * cycle_length\n    for i in range(1, rem + 1):\n        if (i * mod_pow(a, i, p)) % p == b:\n            ans += 1\n    return ans\n\na, b, p, x = map(int, input().split())\nprint(solve(a, b, p, x))"}
{"solution": "def max_sum(k2, k3, k5, k6):\n    count_256 = min(k5, k6)\n    k5 -= count_256\n    k6 -= count_256\n    count_32 = min(k3, k2 // 2)\n    k2 -= 2 * count_32\n    result = count_256 * 256 + count_32 * 32\n    result += (k2 // 3) * 22\n    result += (k5 * 5)\n    result += (k6 * 6)\n    return result\n\nk2, k3, k5, k6 = map(int, input().split())\nprint(max_sum(k2, k3, k5, k6))"}
{"solution": "`\nimport math\ndef check(n,c):\n    if n%2==0:\n        k=n//2\n    else:\n        k=(n+1)//2\n    if c<=k:\n        return (2*(c-1))\n    else:\n        p=c-k\n        if n%2==0:\n            return ((2*p)-1)\n        else:\n            return (2*p)\n    \n        \nn,x,y,c=list(map(int,input().split()))\nif c==1:\n    print(0)\nelse:\n    d=abs(x-y)\n    r=math.ceil(d/2)\n    if r==0:\n        if n%2==0:\n            r=1\n        else:\n            r=0\n    c-=1\n    t=check(n,c)\n    print(r+t)"}
{"solution": "def max_bitwise_xor(l, r):\n    \"\"\"\n    Finds the maximum value of a ^ b for all pairs (a, b) such that l <= a <= b <= r.\n    \"\"\"\n    while r > 0 and l != r:\n        diff = r - l\n        if diff >= r:\n            break\n        highest_bit = 1\n        while highest_bit <= diff:\n            highest_bit <<= 1\n        l ^= highest_bit\n        r ^= highest_bit\n    return l ^ r\n\n# Reading input\nl, r = map(int, input().split())\n\n# Calculating and printing the result\nprint(max_bitwise_xor(l, r))"}
{"solution": "import math\n\ndef check(mid, n, k):\n    h = mid\n    w = mid * 2\n    x = n - w // 2\n    if w % 2 == 0:\n        y = x - 1\n    else:\n        y = x\n    area = h * y + (h * (h + 1) // 2) * (w // 2)\n    return area >= k\n\ndef find_min_height(n, k):\n    low, high = 0, 10**18\n    while low < high:\n        mid = (low + high) // 2\n        if check(mid, n, k):\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating and printing output\nprint(find_min_height(n, k))"}
{"solution": "x,y,z,t1,t2,t3=map(int,input().split())\na=abs(x-y)*t1\nb=0\nif x!=z:\n    b=abs(x-z)*t2+t3\nb+=abs(z-y)*t2+t3\nif a<b:\n    print(\"NO\")\nelse:\n    print(\"YES\")"}
{"solution": "]\ndef find_optimal_choice(n, m):\n    \"\"\"\n    Finds the optimal choice for Andrew to maximize his winning probability.\n    \n    :param n: int - the upper limit of the range [1, n] for choosing numbers.\n    :param m: int - the number chosen by Misha.\n    :return: int - the optimal number choice for Andrew.\n    \"\"\"\n    if m == 1:\n        return 2\n    elif m == n:\n        return n - 1\n    else:\n        return m - 1\n\n# Reading input\nn, m = map(int, input().split())\n\n# Calculating and printing the result\nprint(find_optimal_choice(n, m))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nstay = 0\nskip = 0\n\nfor i in a:\n    if i == 1:\n        stay += 1\n        skip = 0\n    else:\n        if skip == 1:\n            skip = 0\n        else:\n            skip = 1\n            stay += 1\n\nprint(stay)"}
{"solution": "def min_days_for_candies(n, k, candies):\n    total_candies = 0\n    for day in range(n):\n        total_candies += candies[day]\n        if total_candies >= k:\n            return day + 1\n        if total_candies > k + 8:\n            return -1\n    return -1 if total_candies < k else n\n\n# Reading input\nn, k = map(int, input().split())\ncandies = list(map(int, input().split()))\n\n# Printing output\nprint(min_days_for_candies(n, k, candies))"}
{"solution": "def plan_walks(n, k, walks):\n    extra_walks = 0\n    planned_walks = [0] * n\n    prev_day_walks = k\n    \n    for i in range(n):\n        needed_walks = max(prev_day_walks - walks[i], 0)\n        total_walks = needed_walks + walks[i]\n        \n        if i == n - 1 or total_walks + walks[i + 1] < k:\n            diff = k - (total_walks + (walks[i + 1] if i < n - 1 else 0))\n            total_walks += diff\n            extra_walks += diff\n            \n        planned_walks[i] = total_walks\n        extra_walks += needed_walks\n        prev_day_walks = total_walks\n    \n    return extra_walks, planned_walks\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    walks = list(map(int, input().split()))\n    \n    extra_walks, planned_walks = plan_walks(n, k, walks)\n    \n    print(extra_walks)\n    print(' '.join(map(str, planned_walks)))"}
{"solution": "`\ndef solve(n):\n    if n == 1:\n        return 1\n    return solve(n - 1) + 4 * (n - 1)\n\nn = int(input())\nprint(solve(n))"}
{"solution": "n = int(input())\ns = input()\nset_s = set(s.lower())\nalphabet = set('abcdefghijklmnopqrstuvwxyz')\nprint('YES' if alphabet.issubset(set_s) else 'NO')"}
{"solution": "def time_after_a_minutes(current_time, minutes):\n    hh, mm = map(int, current_time.split(':'))\n    mm += minutes\n    hh += mm // 60\n    mm %= 60\n    hh %= 24\n    return f\"{hh:02d}:{mm:02d}\"\n\n# Example usage\ncurrent_time = \"23:59\"\nminutes = 10\nprint(time_after_a_minutes(current_time, minutes))\n\ncurrent_time = \"20:20\"\nminutes = 121\nprint(time_after_a_minutes(current_time, minutes))\n\ncurrent_time = \"10:10\"\nminutes = 0\nprint(time_after_a_minutes(current_time, minutes))"}
{"solution": "`\nfrom itertools import *\n\nn, m = map(int, input().split())\na = [input() for _ in range(n)]\nfor s in combinations(range(n), n-1):\n    x = ''.join('1' if any(a[k][j] == '1' for k in s) else '0' for j in range(m))\n    if x.count('0') == 0:\n        print('YES')\n        break\nelse:\n    print('NO')"}
{"solution": "`\ndef solve(n, dominoes):\n    top_even, top_odd, bottom_even, bottom_odd = 0, 0, 0, 0\n    \n    for domino in dominoes:\n        top, bottom = domino\n        if top % 2 == 0:\n            top_even += 1\n        else:\n            top_odd += 1\n        if bottom % 2 == 0:\n            bottom_even += 1\n        else:\n            bottom_odd += 1\n    \n    if (top_even + bottom_odd) % 2 == 0 and (top_odd + bottom_even) % 2 == 0:\n        return 0\n    elif top_odd == 0 or bottom_odd == 0:\n        return -1\n    else:\n        diff1 = abs(top_odd - bottom_even)\n        diff2 = abs(bottom_odd - top_even)\n        \n        if diff1 % 2 == 0 and diff2 % 2 == 0:\n            return min(diff1 // 2, diff2 // 2)\n        else:\n            return -1\n\nn = int(input())\ndominoes = [list(map(int, input().split())) for _ in range(n)]\nprint(solve(n, dominoes))"}
{"solution": "`\nfrom math import sqrt\nfrom collections import defaultdict\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(sqrt(n)) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return False\n    return True\n\ndef remaining_area(a, b):\n    return a**2 - b**2\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        a, b = map(int, input().split())\n        area = remaining_area(a, b)\n        if is_prime(area):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nsolve()"}
{"solution": "n = int(input())\npoints = []\nmin_x = float('inf')\nmax_x = float('-inf')\nfor _ in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n    min_x = min(min_x, x)\n    max_x = max(max_x, x)\n\nif min_x >= 0 or max_x <= 0:\n    print(\"Yes\")\nelse:\n    left_points = [p for p in points if p[0] < 0]\n    right_points = [p for p in points if p[0] > 0]\n    \n    def all_on_one_side(points):\n        return all(y[1] >= y[0] for y in points) or all(y[1] <= y[0] for y in points)\n    \n    print(\"Yes\" if all_on_one_side(left_points) and all_on_one_side(right_points) else \"No\")"}
{"solution": "`\nimport math\ndef gcd(a,b):\n    if b==0:\n        return a\n    return gcd(b,a%b)\n\na,b=map(int,input().split())\nif a>b:\n    a,b=b,a\nans=1\nfor i in range(2,a+1):\n    c=gcd(i,b)\n    ans*=(i**c)\n    b//=c\nprint(ans)"}
{"solution": "n = int(input())\nif n%2 == 0:\n    print(n+2,2)\nelse:\n    print(n+1,1)"}
{"solution": "from collections import defaultdict, deque\n\ndef solve(N, M, P, edges):\n    graph = [[] for _ in range(N)]\n    rev_graph = [[] for _ in range(N)]\n    costs = [0] * M\n    for i, (a, b, c) in enumerate(edges):\n        graph[a-1].append((b-1, i))\n        rev_graph[b-1].append((a-1, i))\n        costs[i] = c\n    \n    def find_augmenting_path(v):\n        queue = deque([0])\n        visited = [False] * N\n        parent = [-1] * N\n        while queue:\n            u = queue.popleft()\n            visited[u] = True\n            for v, idx in graph[u]:\n                if not visited[v] and costs[idx] > 0:\n                    queue.append(v)\n                    parent[v] = u\n                    if v == N-1:\n                        path = []\n                        w = v\n                        while w != 0:\n                            path.append(w)\n                            w = parent[w]\n                        path.append(0)\n                        return path[::-1], idx\n        return [], -1\n\n    def find_cycle(v, path, used):\n        visited = [False] * N\n        queue = deque([v])\n        while queue:\n            u = queue.popleft()\n            visited[u] = True\n            for v, idx in rev_graph[u]:\n                if not visited[v] and idx not in used:\n                    queue.append(v)\n        for v in path:\n            if visited[v]:\n                cycle = [v]\n                w = v\n                while w != v or len(cycle) < 2:\n                    for nxt, idx in rev_graph[w]:\n                        if nxt in path and idx not in used:\n                            cycle.append(nxt)\n                            w = nxt\n                            break\n                return cycle\n        return []\n\n    aug_path, aug_idx = find_augmenting_path(N-1)\n    if not aug_path:\n        return -1\n\n    used = {aug_idx}\n    cycle = find_cycle(aug_path[-1], aug_path, used)\n    if not cycle:\n        return sum(costs[idx] for _, idx in graph[0]) - P\n\n    cycle_cost = sum(costs[idx] for _, idx in rev_graph[cycle[0]] if cycle[1] in [cycle[-1], cycle[0]] and idx not in used)\n    cycle_time = len(cycle)\n\n    if cycle_cost <= P * cycle_time:\n        return -1\n\n    extra = sum(costs[idx] for _, idx in graph[0] if idx not in used) + cycle_cost * ((sum(costs[idx] for _, idx in graph[0] if idx not in used) - P) // (cycle_cost - P * cycle_time)) - P\n\n    return extra\n\n# Read input\nN, M, P = map(int, input().split())\nedges = [list(map(int, input().split())) for _ in range(M)]\n\n# Solve and print result\nprint(solve(N, M, P, edges))"}
{"solution": "from collections import defaultdict\nfrom functools import lru_cache\n\nN = int(input())\nstrings = []\ncosts = defaultdict(int)\n\nfor _ in range(N):\n    s, c = input().split()\n    costs[s] += int(c)\n    strings.append(s)\n\ndp = {}\n\n@lru_cache(maxsize=None)\ndef dfs(combination):\n    if combination in dp:\n        return dp[combination]\n    \n    mid, left, right = '', combination, ''\n    mid_cost = 0\n    for i in range(len(combination)//2, len(combination)):\n        if combination[i] != combination[len(combination) - 1 - i]:\n            mid += combination[i]\n            mid += combination[len(combination) - 1 - i]\n            mid_cost += costs[combination[i]] + costs[combination[len(combination) - 1 - i]]\n        else:\n            mid_cost += costs[combination[i]]\n\n    if len(mid) == 0:\n        dp[combination] = 0\n        return 0\n    \n    ans = float('inf')\n    for i in range(1, len(mid)+1, 2):\n        if mid[:i] == mid[:i][::-1]:\n            new_combination = mid[i:]\n            ans = min(ans, dfs(new_combination) + mid_cost - costs[mid[0]] * (len(mid[:i]) // 2))\n            \n    dp[combination] = ans\n    return ans\n\nanswer = float('inf')\nfor string in strings:\n    answer = min(dfs(string), answer)\n\nprint(answer if answer != float('inf') else -1)"}
{"solution": "def max_xor_sum(n, k):\n    xor_sum = 0\n    # If k is even, xor_sum is n.\n    # If k is odd, xor_sum is n ^ (n-1) if n > 1 else n.\n    if k % 2 == 0:\n        xor_sum = n\n    else:\n        xor_sum = n ^ (n - 1) if n > 1 else n\n    print(xor_sum)\n\n# Reading input\nn, k = map(int, input().split())\nmax_xor_sum(n, k)"}
{"solution": "import heapq\n\ndef min_triangle_side(n, points):\n    max_x = 0\n    max_y = 0\n    \n    for point in points:\n        max_x = max(max_x, point[0])\n        max_y = max(max_y, point[1])\n    \n    # Using a min heap to keep track of the potential answers\n    possible_answers = []\n    heapq.heappush(possible_answers, max_x)\n    heapq.heappush(possible_answers, max_y)\n    \n    # For each point, calculate the required side length if this point is at the edge\n    for point in points:\n        side_length = max(point[0], point[1]) * 2\n        heapq.heappush(possible_answers, side_length)\n    \n    return heapq.heappop(possible_answers)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    points = [list(map(int, input().split())) for _ in range(n)]\n    print(min_triangle_side(n, points))"}
{"solution": "from collections import Counter\n\ns = input()\ncnt = Counter(s)\n\nnineteen_cnt = min(cnt['n'] // 2, cnt['i'], cnt['e'] // 2, cnt['t'], cnt['n'] // 2 - cnt['i'])\n\nprint(nineteen_cnt)"}
{"solution": "`\nfrom math import sqrt\n\ndef find_highest_suitable_branch(p, y):\n    if p == y:\n        return -1\n\n    for i in range(int(sqrt(y)), 1, -1):\n        if y % i == 0:\n            if y // i > p:\n                return y // i\n            elif i > p:\n                return i\n\n    return -1 if p < int(sqrt(y)) else y // int(sqrt(y))\n\np, y = map(int, input().split())\nprint(find_highest_suitable_branch(p, y))"}
{"solution": "def find_closest_house(n, m, k, prices):\n    closest_distance = float('inf')\n    for i in range(n):\n        if 0 < prices[i] <= k:\n            current_distance = abs(i - m + 1) * 10\n            closest_distance = min(closest_distance, current_distance)\n    return closest_distance\n\n# Reading input\nn, m, k = map(int, input().split())\nprices = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(find_closest_house(n, m, k, prices))"}
{"solution": "import sys\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef main():\n    n, m = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(n)]\n    B = [list(map(int, input().split())) for _ in range(n)]\n\n    posA = defaultdict(list)\n    posB = defaultdict(list)\n\n    for i in range(n):\n        for j in range(m):\n            posA[A[i][j]].append((i, j))\n            posB[B[i][j]].append((i, j))\n\n    for k, v in posA.items():\n        if len(v) != len(posB[k]):\n            print(\"NO\")\n            return\n        for i, j in v:\n            if (i, j) not in posB[k]:\n                print(\"NO\")\n                return\n    print(\"YES\")\n\nif __name__ == '__main__':\n    main()"}
{"solution": "a = input()\nb = input()\n\nif a == b:\n    print(-1)\nelse:\n    print(max(len(a), len(b)))"}
{"solution": "]\nimport math\ndef solve():\n\ta,b = map(int,input().split())\n\tc,d = map(int,input().split())\n\tif a==c:\n\t\tif b==d:\n\t\t\tprint(b)\n\t\t\treturn\n\t\telif (b-d)%a==0:\n\t\t\tprint(b+(a*(abs(b-d)//a)))\n\t\t\treturn\n\tt = abs(b-d)\n\tif t%(a+c)==0:\n\t\tprint(t+b)\n\t\treturn\n\tt = (a*c)//math.gcd(a,c)\n\tt = (t*(abs(b-d)//t))+min(b,d)\n\tif t%(a+c)==0:\n\t\tprint(t)\n\t\treturn\n\tprint(-1)\nsolve()"}
{"solution": "n = int(input())\na = n % 3\nif a == 0:\n    a = 1\n    b = 1\n    c = n - a - b\nelif a == 1:\n    b = 2\n    c = n - a - b\nelse:\n    b = 1\n    c = n - a - b\nprint(a, b, c)"}
{"solution": "n, a, b, c, d = map(int, input().split())\n\nres = 0\nfor x in range(1, n + 1):\n    for y in range(1, n + 1):\n        for z in range(1, n + 1):\n            s = a + x\n            if b + y != s or c + z != s:\n                continue\n            if d + (s - b - c) != s:\n                continue\n            if (s - a - x) > n or (s - a - x) < 1:\n                continue\n            if (s - b - y) > n or (s - b - y) < 1:\n                continue\n            if (s - c - z) > n or (s - c - z) < 1:\n                continue\n            if (s - d - (s - b - c)) > n or (s - d - (s - b - c)) < 1:\n                continue\n            res += 1\nprint(res)"}
{"solution": "w, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\nstones = sorted([(d1, u1), (d2, u2)])\n\nwhile h > 0:\n    w += h\n    h -= 1\n    if h > 0 and (h == stones[0][0] or h == stones[1][0]):\n        w -= stones[0][1] if h == stones[0][0] else stones[1][1]\n        if w < 0:\n            w = 0\nprint(w)"}
{"solution": "def find_passing_rate(m, scores, min_group_size, max_group_size):\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + scores[i - 1]\n\n    for k in range(1, m + 1):\n        beginners = prefix_sum[k - 1]\n        intermediates = prefix_sum[m] - beginners\n        if min_group_size <= beginners <= max_group_size and min_group_size <= intermediates <= max_group_size:\n            return k\n    return 0\n\n# Reading input\nm = int(input())\nscores = list(map(int, input().split()))\nmin_group_size, max_group_size = map(int, input().split())\n\n# Calculating and printing the result\nprint(find_passing_rate(m, scores, min_group_size, max_group_size))"}
{"solution": "import math\n\ndef min_cost(n, k, A, B):\n    operations = []\n    while n > 1:\n        if n % k == 0:\n            operations.append(B)\n            n //= k\n        else:\n            operations.append(A)\n            n -= 1\n    return sum(operations)\n\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\n# Optimize for the case where it's cheaper to subtract to get to a multiple of k\ncost = math.inf\nfor i in range(20):  # Limit depth to avoid unnecessary computation\n    subtract_cost = A * i\n    new_n = n - i\n    if new_n > 0:\n        divide_cost = min_cost(new_n, k, A, B)\n        cost = min(cost, subtract_cost + divide_cost)\n    else:\n        break\n\nprint(cost)"}
{"solution": "import math\n\ndef min_operations(n):\n    operations = 0\n    while n > 1:\n        root = math.sqrt(n)\n        if root == int(root):\n            n = int(root)\n        else:\n            n = n // 2 if n % 2 == 0 else n - 1\n        operations += 1\n    return n, operations\n\nn = int(input())\nresult = min_operations(n)\nprint(*result)"}
{"solution": "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\ndef main():\n    N, K = map(int, input().split())\n    R, S, P = map(int, input().split())\n    T = input().rstrip()\n    \n    T = [ord(t) - ord('p') for t in T]\n    dp = [[0]*3 for _ in range(N+1)]\n    que = deque()\n    ans = 0\n    \n    for i, t in enumerate(T):\n        for j in range(3):\n            if not que:\n                dp[i+1][j] = dp[i][j] + (P if j == 0 else S if j == 1 else R if j == 2 else 0) if j == (t+1)%3 else dp[i][j]\n            else:\n                dp[i+1][j] = max(dp[que[0]][j], dp[i][j]) + (P if j == 0 else S if j == 1 else R if j == 2 else 0) if j == (t+1)%3 else max(dp[que[0]][j], dp[i][j])\n        que.append(i)\n        if i >= K-1:\n            que.popleft()\n        ans = max(ans, max(dp[i+1]))\n        \n    print(ans)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "3\nimport sys\n# from collections import defaultdict,Counter\n# from heapq import heappush, heappop\n# from itertools import permutations\n# from bisect import bisect_left, bisect_right\n# from math import gcd,sqrt,sin,cos,tan,degrees,radians\n# from fractions import Fraction\n# from functools import reduce\n\ndef ii(): return int(sys.stdin.readline().strip())\ndef mi(): return map(int,sys.stdin.readline().strip().split())\ndef li(): return list(map(int,sys.stdin.readline().strip().split()))\ndef lcm(a,b): return (a*b)//gcd(a,b)\ndef input(): return sys.stdin.readline().strip()\n# mod=1000000007\n\na,b,c=mi()\nif a==b:\n    print(2*(a+b+c))\nelif a>b:\n    print(2*(b+1)+2*c+2*(a-b-1))\nelse:\n    print(2*(a+1)+2*c+2*(b-a-1))"}
{"solution": "def find_scores(n, k, p, x, y, marks):\n    total_marks = sum(marks)\n    marks.sort()\n    needed_marks = []\n    median_pos = (n + 1) // 2\n    current_median = marks[median_pos - 1] if len(marks) >= median_pos else 0\n\n    if k == n:\n        return [] if total_marks <= x and current_median >= y else [-1]\n\n    if k < median_pos - 1 or (current_median < y and marks[-1] < y):\n        return [-1]\n\n    remaining_sum = max(0, x - total_marks)\n\n    for _ in range(n - k):\n        if remaining_sum > 0:\n            mark = min(p, remaining_sum)\n            needed_marks.append(mark)\n            remaining_sum -= mark\n        else:\n            needed_marks.append(min(p, y))\n\n    if len(marks) < median_pos - 1:\n        needed_marks.extend([y] * (median_pos - len(marks) - 1))\n\n    needed_marks.sort(reverse=True)\n    needed_marks = needed_marks[:n - k]\n\n    if sum(marks + needed_marks) > x or (marks + needed_marks)[median_pos - 1] < y:\n        return [-1]\n\n    return needed_marks\n\ndef main():\n    n, k, p, x, y = map(int, input().split())\n    marks = list(map(int, input().split()))\n    result = find_scores(n, k, p, x, y, marks)\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_berlanese(word):\n    vowels = 'aouie'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    special_consonant = 'n'\n    \n    prev_char = word[0]\n    for char in word[1:]:\n        if prev_char in consonants and prev_char != special_consonant and char not in vowels:\n            return \"NO\"\n        prev_char = char\n    \n    for i in range(len(word) - 1):\n        if word[i] == special_consonant and word[i+1] not in vowels + special_consonant + '\\0':\n            return \"NO\"\n    \n    return \"YES\"\n\n# Reading input\nword = input().strip()\n\n# Printing output\nprint(is_berlanese(word))"}
{"solution": "from collections import defaultdict\n\ndef dfs(node, visited, graph, node_values):\n    stack = [node]\n    while stack:\n        current_node = stack[-1]\n        if visited[current_node] == -1:\n            visited[current_node] = node_values[node]\n            stack.pop()\n        else:\n            for neighbor in graph[current_node]:\n                if visited[neighbor] == -1:\n                    stack.append(neighbor)\n                    break\n\ndef solve(n, m, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [-1] * (n + 1)\n    node_values = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if visited[i] == -1:\n            node_values[i] = 0\n            dfs(i, visited, graph, node_values)\n\n    counts = defaultdict(int)\n    for value in node_values[1:]:\n        counts[value] += 1\n\n    result = 0\n    for count in counts.values():\n        result += count * (count - 1) // 2\n\n    return min(result, m)\n\n# Reading input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Solving and printing output\nprint(solve(n, m, edges))"}
{"solution": "def jeopardy(n, m, prices, auctions):\n    from bisect import bisect_left as bl\n    auctions.sort()\n    auctions = [-1] + auctions + [n]\n    \n    def dp(i, budget, changed_prices):\n        if i == m:\n            return sum(prices[j] for j in range(n) if j not in auctions[1:-1])\n        \n        if (i, budget, tuple(changed_prices)) in memo:\n            return memo[(i, budget, tuple(changed_prices))]\n        \n        ans = 0\n        normal_questions = [j for j in range(auctions[i]+1, auctions[i+1]) if j not in auctions[1:-1]]\n        for q in normal_questions:\n            new_budget = budget + prices[q]\n            ans = max(ans, dp(i, new_budget, changed_prices))\n        \n        if auctions[i+1] != auctions[i] + 1:\n            auction_price = prices[auctions[i+1]]\n            if budget > auction_price:\n                new_auction_price = min(budget, changed_prices[i])\n                prices[auctions[i+1]] = new_auction_price\n                ans = max(ans, dp(i+1, budget + new_auction_price, changed_prices[:i] + [new_auction_price] + changed_prices[i+1:]))\n                prices[auctions[i+1]] = auction_price\n        \n        memo[(i, budget, tuple(changed_prices))] = ans\n        return ans\n    \n    memo = {}\n    return dp(0, 0, prices[:])\n\n# Reading input\nn, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauctions = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(jeopardy(n, m, prices, auctions))"}
{"solution": "def calculate_score():\n    m = list(map(int, input().split()))\n    w = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n\n    base_scores = [500, 1000, 1500, 2000, 2500]\n    total_score = 0\n\n    for i in range(5):\n        score = max(0.3 * base_scores[i], (1 - m[i] / 250) * base_scores[i] - 50 * w[i])\n        total_score += int(score)\n\n    total_score += 100 * h[0] - 50 * h[1]\n\n    return total_score\n\nprint(calculate_score())"}
{"solution": "MOD = 998244353\n\ndef solve(n, m, L, R):\n    if n < m:\n        n, m = m, n\n    if n == 1:\n        return (min(R - L + 1, 2) % MOD)\n    elif m == 1:\n        return (R - L + 1) % MOD\n    elif n == 2 and m == 2:\n        return (max(0, R - max(L, (L + 1) % 2)) - (L - 1)) % MOD\n    else:\n        if m == 2:\n            m, n = n, m\n        k = n * m % 2\n        if k == 0:\n            return (max(0, R - max(L, (L + 1) % 2)) - (L - 1)) % MOD\n        else:\n            return (max(0, R - max(L, (L + 1) % 2)) - max(0, (L - 1) - (L + 1)) ) % MOD\n\nn, m, L, R = map(int, input().split())\nprint(solve(n, m, L, R))"}
{"solution": "def read_matrix():\n    n, m = map(int, input().split())\n    matrix_a = [list(map(int, input().split())) for _ in range(n)]\n    matrix_b = [list(map(int, input().split())) for _ in range(n)]\n    return n, m, matrix_a, matrix_b\n\ndef check_increasing(matrix):\n    n, m = len(matrix), len(matrix[0])\n    for i in range(n):\n        for j in range(m - 1):\n            if matrix[i][j] >= matrix[i][j + 1]:\n                return False\n    for j in range(m):\n        for i in range(n - 1):\n            if matrix[i][j] >= matrix[i + 1][j]:\n                return False\n    return True\n\ndef solve(n, m, matrix_a, matrix_b):\n    combined = [[min(matrix_a[i][j], matrix_b[i][j]), max(matrix_a[i][j], matrix_b[i][j])] for i in range(n) for j in range(m)]\n    combined.sort()\n    low, high = zip(*combined)\n    low = list(low)\n    high = list(high)\n    for i in range(1, n * m):\n        if low[i] <= high[i - 1]:\n            return \"Impossible\"\n    return \"Possible\" if check_increasing(matrix_a) and check_increasing(matrix_b) else \"Impossible\"\n\nn, m, matrix_a, matrix_b = read_matrix()\nprint(solve(n, m, matrix_a, matrix_b))"}
{"solution": "import heapq\ndef max_string_length(n, limitations):\n    limitations = [-x for x in limitations]\n    heapq.heapify(limitations)\n    available = list(range(n, 0, -1))\n    heapq.heapify(available)\n    result = 0\n    while limitations:\n        current_limitation = -heapq.heappop(limitations)\n        if not available:\n            break\n        available_option = heapq.heappop(available)\n        if available_option > current_limitation:\n            available_option -= current_limitation\n            result += current_limitation\n            heapq.heappush(limitations, -(current_limitation - available_option))\n            heapq.heappush(available, available_option)\n        else:\n            result += available_option\n            current_limitation -= available_option\n            heapq.heappush(limitations, -current_limitation)\n    return result\n\n# Reading input\nn = int(input())\nlimitations = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(max_string_length(n, limitations))"}
{"solution": "import sys\ninput = sys.stdin.readline\n\nn, k = map(int, input().split())\nA = list(map(int, input().split()))\n\nA.sort()\n\nans = 0\nfor a in A:\n    if k >= a//2:\n        continue\n    else:\n        ans += 1\n        k = max(k, a//2)\nprint(ans)"}
{"solution": "n = int(input())\nmin1, max1 = map(int, input().split())\nmin2, max2 = map(int, input().split())\nmin3, max3 = map(int, input().split())\n\nres1 = max1 if max1 + min2 + min3 <= n else min(n - min2 - min3, max1)\nres2 = max2 if res1 + max2 + min3 <= n else min(n - res1 - min3, max2)\nres3 = n - res1 - res2\n\nprint(res1, res2, res3)"}
{"solution": "n = int(input())\nlst = list(map(int, input().split()))\nif n == 1:\n    print(-1)\nelif lst[0] == 0:\n    if lst[1] == 1:\n        print(\"UP\")\n    else:\n        print(\"DOWN\")\nelif lst[-1] == 15:\n    if lst[-2] == 14:\n        print(\"DOWN\")\n    else:\n        print(\"UP\")\nelif lst[0] == 15:\n    if lst[1] == 14:\n        print(\"DOWN\")\n    else:\n        print(\"UP\")\nelif lst[-1] == 0:\n    if lst[-2] == 1:\n        print(\"UP\")\n    else:\n        print(\"DOWN\")\nelse:\n    x = lst[0]\n    y = lst[1]\n    z = lst[-1]\n    if x < y and z > lst[-2]:\n        print(\"UP\")\n    elif x > y and z < lst[-2]:\n        print(\"DOWN\")\n    else:\n        print(-1)"}
{"solution": "]\ns = input().strip()\nt = input().strip()\n\nvowels = set('aeiou')\nconsonants = set('bcdfghjklmnpqrstvwxyz')\n\ns_vowels = set([c for c in s if c in vowels])\ns_consonants = set([c for c in s if c in consonants])\n\nt_vowels = set([c for c in t if c in vowels])\nt_consonants = set([c for c in t if c in consonants])\n\nif (len(s_vowels.intersection(t_vowels)) > 0 or len(s_vowels) == len(t_vowels) == 0) and (len(s_consonants.intersection(t_consonants)) > 0 or len(s_consonants) == len(t_consonants) == 0):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "import sys\n\ndef find_min_distance(pawns, target_row):\n    min_distance = 9\n    for pawn in pawns:\n        distance = abs(pawn - target_row)\n        if distance < min_distance:\n            min_distance = distance\n    return min_distance\n\nboard = [list(sys.stdin.readline().strip()) for _ in range(8)]\nwhite_pawns = []\nblack_pawns = []\n\nfor i in range(8):\n    for j in range(8):\n        if board[i][j] == 'W':\n            white_pawns.append(i + 1)\n        elif board[i][j] == 'B':\n            black_pawns.append(i + 1)\n\nmin_white_distance = find_min_distance(white_pawns, 1)\nmin_black_distance = find_min_distance(black_pawns, 8)\n\nif min_white_distance < min_black_distance:\n    print('A')\nelse:\n    print('B')"}
{"solution": "def find_max_equal_length(n, A, m, B):\n    S = [A]\n    if n > m:\n        A, B, n, m = B, A, m, n\n    A_sum, B_sum = sum(A), sum(B)\n    if A_sum != B_sum:\n        return -1\n    if n == 1 or m == 1:\n        return 1 if A_sum == B_sum else -1\n    i, j = 0, 0\n    while i < n and j < m:\n        if A[i] == B[j]:\n            i += 1\n            j += 1\n        elif A_sum - sum(A[i:]) == B[j]:\n            return i + 1\n        elif A_sum - sum(A[:i]) == B[j]:\n            return i + 1\n        elif A[i] == B_sum - sum(B[j:]):\n            return i + 1\n        elif A[i] == B_sum - sum(B[:j]):\n            return i + 1\n        else:\n            break\n    if i == n and j == m:\n        return n\n    S.append(A[:i])\n    S.append(A[i:])\n    S.append(B[:j])\n    S.append(B[j:])\n    for s in S:\n        if len(s) == 1:\n            continue\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                s[i], s[i + 1] = s[i] + s[i + 1], 0\n        s[:] = [x for x in s if x]\n    l = [len(s) for s in S]\n    return max(min(l[0] + l[1], l[2]), min(l[0], l[2] + l[3]), min(l[1], l[2] + l[3]))\n\n# Reading input\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(find_max_equal_length(n, A, m, B))"}
{"solution": "3\nimport re\n\ndef is_contest_problem(problem_name):\n    patterns = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    matches = [re.search(pattern, problem_name) for pattern in patterns]\n    return \"YES\" if sum(1 for match in matches if match) == 1 else \"NO\"\n\n# Reading input directly and printing output for the given problem statement\nif __name__ == \"__main__\":\n    problem_name = input().strip()\n    print(is_contest_problem(problem_name))"}
{"solution": "import bisect\n\ndef sieve(n):\n    primes = [True] * (n+1)\n    p = 2\n    while (p * p <= n):\n        if (primes[p] == True):\n            for i in range(p * p, n+1, p):\n                primes[i] = False\n        p += 1\n    \n    prime_numbers = [p for p in range(2, n) if primes[p]]\n    prime_flags = [primes[i] for i in range(2, n+1)]\n    \n    return prime_numbers, prime_flags\n\ndef solve(a, b, k):\n    prime_numbers, prime_flags = sieve(b+1)\n    \n    count_primes = [0] * (b+1)\n    count_primes[0] = 0\n    for i in range(1, b+1):\n        count_primes[i] = count_primes[i-1] + (1 if prime_flags[i] else 0)\n\n    min_length = float('inf')\n    for start in range(a, b+2-k):\n        end = start + k - 1\n        if end > b:\n            break\n        if count_primes[end] - count_primes[start-1] >= k:\n            min_length = min(min_length, end - start + 1)\n\n    return min_length if min_length != float('inf') else -1\n\na, b, k = map(int, input().split())\nprint(solve(a, b, k))"}
{"solution": "import math\n\ndef find_min_x(a, h, w):\n    for i in range(1, 100):\n        for j in range(1, 100):\n            if (i * a + i * x >= h and j * a + j * x >= w) or (i * a + (i + 1) * x <= h and j * a + (j + 1) * x <= w):\n                continue\n            x = (h - i * a) / i\n            y = (w - j * a) / j\n            if abs(x - y) < 1e-6:\n                return round(x, 6)\n    return -1\n\na, h, w = map(int, input().split())\n\nmin_x = find_min_x(a, h, w)\nprint(min_x)"}
{"solution": "n = int(input())\nchapters = []\nfor _ in range(n):\n    chapters.append(list(map(int, input().split())))\nk = int(input())\n\nunread_chapters = 0\nfor l, r in chapters:\n    if k > r:\n        continue\n    unread_chapters += 1\n    if k <= l:\n        break\n\nprint(unread_chapters)"}
{"solution": "def check_banner(banner):\n    target = \"CODEFORCES\"\n    i = 0\n    for char in banner:\n        if i < len(target) and char == target[i]:\n            i += 1\n    return \"YES\" if i == len(target) else \"NO\"\n\nbanner = input()\nprint(check_banner(banner))"}
{"solution": "import sys\ninput = sys.stdin.readline\n\nn = int(input())\n\ndp = [[0 for _ in range(n+1)] for _ in range(n+1)]\n\nfor length in range(3, n+1):\n    for start in range(1, n-length+2):\n        end = start + length - 1\n        dp[start][end] = min(dp[start][k] + dp[k+1][end] + start * k * end for k in range(start, end))\n        \nprint(dp[1][n])"}
{"solution": "def count_digits(n):\n    if n < 10:\n        return n\n    digits = 1\n    while 9 * (10 ** (digits - 1)) * digits < n:\n        n -= 9 * (10 ** (digits - 1)) * digits\n        digits += 1\n    return n + (digits - 1) * (10 ** (digits - 1)) + (n - 1) // digits\n\nn = int(input())\nprint(count_digits(n))"}
{"solution": "n,A=map(int,input().split())\na=list(map(int,input().split()))\nb,cnt_b,s=0,[0]*1000001,0\nfor i in a:\n    s+=1 if i==A else -1\n    if s<0:b=1;break\n    if s>0:cnt_b[i]+=s\nif b:print(A)\nelse:\n    mx,mxc=-1,-1\n    for i in range(1,1000001):\n        if cnt_b[i]>mxc:mx,mxc=i,cnt_b[i]\n    print(mx if mxc>0 else -1)"}
{"solution": "def check_crossword(n, x, encoding):\n    total_ones = sum(encoding)\n    segments = n - 1\n    required_zeros = max(0, segments + total_ones - x)\n\n    if required_zeros > 0:\n        zeros_in_segments = 0\n        prev = 0\n        for a in encoding:\n            if prev > 0:\n                zeros_in_segments += 1\n                prev = 0\n            prev = a\n        last_segment_zeros = max(0, prev - 1)\n\n        if required_zeros > (zeros_in_segments + last_segment_zeros):\n            return \"NO\"\n        elif x - total_ones < segments:\n            return \"NO\"\n    else:\n        if x != total_ones:\n            return \"NO\"\n\n    return \"YES\"\n\n# Reading input\nn, x = map(int, input().split())\nencoding = list(map(int, input().split()))\n\n# Printing output\nprint(check_crossword(n, x, encoding))"}
{"solution": "import math\n\nn, S = map(int, input().split())\n\nresult = 0\nwhile n > 0 and S > 0:\n    result += S // n\n    S %= n\n    n -= 1\n\nif S > 0:\n    result += math.ceil(S / n)\n\nprint(result)"}
{"solution": "from collections import Counter\n\ndef min_changes_to_palindrome(s):\n    char_count = Counter(s)\n    sorted_chars = sorted(char_count.items(), key=lambda x: x[1], reverse=True)\n    length = len(s)\n    mid_char = ''\n    palindrome = []\n    \n    for ch, cnt in sorted_chars:\n        if length % 2 == 1 and mid_char == '':\n            mid_char = ch\n        for _ in range(cnt // 2):\n            palindrome.append(ch)\n    \n    result = ''.join(palindrome) + mid_char + ''.join(reversed(palindrome))\n    return result[:length]\n\n# Reading input\ns = input().strip()\n\n# Processing and printing output\nprint(min_changes_to_palindrome(s))"}
{"solution": "`\ndef read_input():\n    white_score = 0\n    black_score = 0\n    for _ in range(8):\n        row = input()\n        for char in row:\n            if char == 'Q':\n                white_score += 9\n            elif char == 'R':\n                white_score += 5\n            elif char == 'B' or char == 'N':\n                white_score += 3\n            elif char == 'P':\n                white_score += 1\n            elif char == 'q':\n                black_score += 9\n            elif char == 'r':\n                black_score += 5\n            elif char == 'b' or char == 'n':\n                black_score += 3\n            elif char == 'p':\n                black_score += 1\n    return white_score, black_score\n\ndef compare_scores(white_score, black_score):\n    if white_score > black_score:\n        return \"White\"\n    elif black_score > white_score:\n        return \"Black\"\n    else:\n        return \"Draw\"\n\nwhite_score, black_score = read_input()\nprint(compare_scores(white_score, black_score))"}
{"solution": "from collections import deque\n\ndef solve(N, M, S):\n    S = list(map(int, S))\n    dp = [-1] * (N + 1)\n    dp[N] = 0\n    queue = deque([N])\n\n    while queue:\n        pos = queue.popleft()\n        for m in range(1, M + 1):\n            next_pos = pos - m\n            if 0 <= next_pos < N and S[next_pos] == 0 and (dp[next_pos] == -1 or dp[next_pos] > dp[pos] + 1):\n                dp[next_pos] = dp[pos] + 1\n                queue.append(next_pos)\n\n    if dp[0] == -1:\n        return -1\n\n    answer = []\n    pos = 0\n    while pos < N:\n        for m in range(M, 0, -1):\n            next_pos = pos + m\n            if next_pos <= N and S[next_pos] == 0 and dp[pos] == dp[next_pos] - 1:\n                answer.append(m)\n                pos = next_pos\n                break\n\n    return ' '.join(map(str, answer))\n\n# Reading input\nN, M = map(int, input().split())\nS = input()\n\n# Solving and printing output\nprint(solve(N, M, S))"}
{"solution": "import math\nfrom collections import deque\n\ndef solve(K, X, Y):\n    if K == 1:\n        return [(X, Y)] if abs(X) + abs(Y) <= K else []\n    \n    if abs(X) + abs(Y) <= K or (abs(X) + abs(Y) - K) % 2 == 0:\n        return [(X, Y)]\n    \n    if K > abs(X) + abs(Y):\n        return [(K, 0), (X, Y)]\n\n    # BFS\n    q = deque([(0, 0, 0)])\n    visited = set([(0, 0)])\n    while q:\n        x, y, step = q.popleft()\n        if (x, y) == (X, Y):\n            return [(x, y) for _, x, y in sorted(q, key=lambda t: t[2])]\n\n        for dx, dy in [(K, 0), (-K, 0), (0, K), (0, -K)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) not in visited and 0 <= abs(nx) + abs(ny) <= 2 * K:\n                visited.add((nx, ny))\n                q.append((nx, ny, step + 1))\n\n        if step >= 2:\n            for dx in range(-K, K + 1):\n                for dy in range(-K, K + 1):\n                    if abs(dx) + abs(dy) == K:\n                        nx, ny = x + dx, y + dy\n                        if (nx, ny) not in visited:\n                            visited.add((nx, ny))\n                            q.append((nx, ny, step + 1))\n\n    return []\n\ndef main():\n    K = int(input())\n    X, Y = map(int, input().split())\n\n    path = solve(K, X, Y)\n    if not path:\n        print(-1)\n    else:\n        print(len(path))\n        for x, y in path:\n            print(x, y)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef find_smallest_n(m):\n    \"\"\"\n    Finds the smallest possible value of n such that there are exactly m ways\n    the thieves could have taken the chocolates. Each thief takes k times more\n    chocolates than the previous one, where k > 1, and there are exactly four\n    thieves involved. If no such n exists, returns -1.\n    \"\"\"\n    def ways(n, k):\n        return (n // (1 + k + k**2 + k**3))\n\n    def count_ways(n):\n        cnt = 0\n        k = 2\n        while ways(n, k) != 0:\n            cnt += 1\n            k += 1\n        return cnt\n\n    max_possible_n = 4 * int(math.sqrt(m * 2)) + 10\n    low, high = 1, max_possible_n\n    result = -1\n\n    while low <= high:\n        mid = (low + high) // 2\n        current_count = count_ways(mid)\n        if current_count == m:\n            result = mid\n            high = mid - 1\n        elif current_count < m:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return result\n\n# Example usage\nm = int(input().strip())\nprint(find_smallest_n(m))"}
{"solution": "import math\n\ndef circle_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    \n    if d >= r1 + r2:\n        return 0.0\n    elif d <= abs(r1 - r2):\n        return min(math.pi * r1**2, math.pi * r2**2)\n    else:\n        alpha = math.acos((r1**2 + d**2 - r2**2) / (2 * r1 * d))\n        beta = math.acos((r2**2 + d**2 - r1**2) / (2 * r2 * d))\n        \n        area1 = r1**2 * alpha - r1**2 * math.sin(2 * alpha) / 2\n        area2 = r2**2 * beta - r2**2 * math.sin(2 * beta) / 2\n        \n        return area1 + area2\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\nprint(circle_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "def min_value(n):\n    if n == 1:\n        return 1\n    for x in range(n - 1, 0, -1):\n        if n % x != 0:\n            return n - x\n    return n\n\nn = int(input())\nprint(min_value(n))"}
{"solution": "import sys\ninput = sys.stdin.readline\n\ndef addEdge(u,v):\n    adj[u].append(v)\n\ndef dfs(u, par, lev):\n    global A, D\n    D[u] = lev\n    for v in adj[u]:\n        if v != par:\n            dfs(v, u, lev+1)\n            A[u] += A[v]\n\ndef dfs2(u, par, lev):\n    global A, D, B\n    for v in adj[u]:\n        if v != par:\n            B[v] = max(B[u], A[u]-A[v]+lev-D[v])\n            dfs2(v, u, lev)\n\nn = int(input())\nadj = [[] for _ in range(n+1)]\nfor i in range(2,n+1):\n    p = int(input())\n    addEdge(p,i)\n\nA = list(map(int, input().split()))\nD = [0]*(n+1)\ndfs(1,-1,0)\nB = [0]*(n+1)\nB[1] = max(A[1], sum(A)-A[1])\ndfs2(1,-1,0)\n\nprint(B[1])"}
{"solution": "n = int(input())\ns = input()\nt = input()\n\ni = 0\nwhile s[i] == t[i]:\n    i += 1\n\ns = s[i:]\nt = t[i:]\n\ni = 0\nwhile s[-i - 1] == t[-i - 1]:\n    i += 1\n\ns = s[:-i]\nt = t[:-i]\n\ncan = [False, False]\n\nfor i in range(2):\n    if s == t[1:]:\n        can[i] = True\n    if t == s[1:]:\n        can[i] = True\n\nprint(sum(can))"}
{"solution": "import sys\ninput = sys.stdin.readline\n\ndef addEdge(adjList, u, v):\n    adjList[u].append(v)\n    adjList[v].append(u)\n\ndef dfs(u, adjList, visited, hacked, strength, ans):\n    visited[u] = True\n    for v in adjList[u]:\n        if not visited[v]:\n            if hacked[v]:\n                strength[u] += 1\n            else:\n                dfs(v, adjList, visited, hacked, strength, ans)\n                strength[u] = max(strength[u], strength[v]+1)\n    hacked[u] = True\n    ans[0] = max(ans[0], strength[u])\n\ndef main():\n    n = int(input())\n    strength = list(map(int, input().split()))\n    adjList = [[] for _ in range(n)]\n    for _ in range(n-1):\n        u, v = map(int, input().split())\n        addEdge(adjList, u-1, v-1)\n    \n    visited = [False]*n\n    hacked = [False]*n\n    ans = [float('-inf')]\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, adjList, visited, hacked, strength, ans)\n    \n    print(ans[0])\n\nmain()"}
{"solution": "n, m = map(int, input().split())\nprint(min(m + 1, n - m))"}
{"solution": "]\nk,r=map(int,input().split())\nc=1\nwhile(True):\n    if(int(str(c*k)[-1])==r or int(str(c*k)[-1])==0):\n        print(c)\n        break\n    c+=1"}
{"solution": "`\nfrom collections import deque\n\ndef read_grid():\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n)]\n    return n, m, grid\n\ndef find_starting_point(grid):\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 'X':\n                return i, j\n\ndef bfs(grid, start):\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    visited = set([start])\n    queue = deque([start])\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and\n                    (nx, ny) not in visited and grid[nx][ny] == 'X'):\n                visited.add((nx, ny))\n                queue.append((nx, ny))\n    return visited\n\ndef check_rectangle(visited):\n    min_x, max_x = float('inf'), float('-inf')\n    min_y, max_y = float('inf'), float('-inf')\n    for x, y in visited:\n        min_x, max_x = min(min_x, x), max(max_x, x)\n        min_y, max_y = min(min_y, y), max(max_y, y)\n    width, height = max_x - min_x + 1, max_y - min_y + 1\n    if width * height == len(visited):\n        return True\n    return False\n\nn, m, grid = read_grid()\nstart = find_starting_point(grid)\nvisited = bfs(grid, start)\n\nif check_rectangle(visited):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "`\nfrom itertools import permutations\n\ndef min_segments(x1, y1, x2, y2, x3, y3):\n    points = [(x1, y1), (x2, y2), (x3, y3)]\n    min_segments = float('inf')\n    for perm in permutations(points):\n        segments = 0\n        if perm[0][0] != perm[1][0] and perm[0][1] != perm[1][1]:\n            segments += 2\n        else:\n            segments += 1\n        if perm[1][0] != perm[2][0] and perm[1][1] != perm[2][1]:\n            segments += 2\n        else:\n            segments += 1\n        min_segments = min(min_segments, segments)\n    return min_segments\n\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\nprint(min_segments(x1, y1, x2, y2, x3, y3))"}
{"solution": "')\nimport sys\ninput = sys.stdin.readline\n\ndef printGraph(n, edges):\n    print(\"YES\")\n    print(n, len(edges))\n    for u, v in edges:\n        print(u + 1, v + 1)\n\ndef buildGraph(k):\n    if k == 1:\n        printGraph(2, [(0, 1)])\n        return\n    if k % 2 == 0:\n        print(\"NO\")\n        return\n    \n    n = k + 1\n    edges = []\n    \n    # Create a cycle\n    for i in range(n - 1):\n        edges.append((i, i + 1))\n    edges.append((n - 1, 0))\n    \n    # Add remaining edges\n    for i in range(n):\n        for j in range(i + 2, n):\n            if len(edges) < (k * n) // 2:\n                edges.append((i, j))\n    \n    printGraph(n, edges)\n\nk = int(input())\nbuildGraph(k)"}
{"solution": "def build_kmp_table(pattern):\n    table = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n        if pattern[i] == pattern[j]:\n            j += 1\n            table[i] = j\n        elif j > 0:\n            j = table[j - 1]\n            i -= 1\n        else:\n            table[i] = 0\n    return table\n\ndef kmp_search(text, pattern):\n    table = build_kmp_table(pattern)\n    i = j = 0\n    while i < len(text):\n        if text[i] == pattern[j]:\n            i += 1\n            j += 1\n            if j == len(pattern):\n                return True, i - j\n        elif j > 0:\n            j = table[j - 1]\n        else:\n            i += 1\n    return False, -1\n\ndef preprocess(s, t):\n    n = len(s)\n    m = len(t)\n    kmp_table = build_kmp_table(t)\n    prefix_sums = [0] * (n + 1)\n    i = j = 0\n    while i < n:\n        if s[i] == t[j]:\n            i += 1\n            j += 1\n            if j == m:\n                prefix_sums[i] += 1\n                j = kmp_table[j - 1]\n        elif j > 0:\n            j = kmp_table[j - 1]\n        else:\n            i += 1\n        prefix_sums[i] += prefix_sums[i - 1]\n    return prefix_sums\n\ndef answer_queries(n, m, q, s, t, queries):\n    prefix_sums = preprocess(s, t)\n    for l, r in queries:\n        print(prefix_sums[r] - prefix_sums[l - 1])\n\nn, m, q = map(int, input().split())\ns = input()\nt = input()\nqueries = [list(map(int, input().split())) for _ in range(q)]\nanswer_queries(n, m, q, s, t, queries)"}
{"solution": "3\nimport sys\nfrom functools import lru_cache\n\nMOD = 10 ** 9 + 7\n\n@lru_cache(maxsize=None)\ndef dp(n, k, d):\n    if n == 0:\n        return 1\n    res = 0\n    for i in range(1, min(k + 1, d)):\n        res += dp(n - i, k, d)\n    if d <= k:\n        res += dp(n - d, k, d)\n    return res % MOD\n\nn, k, d = map(int, sys.stdin.readline().split())\nprint(dp(n, k, d))"}
{"solution": "n = int(input())\ns = input()\nc = 0\nl = []\nfor i in s:\n    if(i=='B'):\n        c+=1\n    else:\n        if(c!=0):\n            l.append(c)\n            c=0\nif(c!=0):\n    l.append(c)\nprint(len(l))\nif(len(l)!=0):\n    print(*l)"}
{"solution": "def find_matching_pair(s, i):\n    balance = 1\n    j = i + 1\n    while balance > 0:\n        if s[j] == '(':\n            balance -= 1\n        else:\n            balance += 1\n        j += 1\n    return j - 1\n\ndef process_operations(s, m, p, ops):\n    stack = []\n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(i)\n        else:\n            opening_index = stack.pop()\n            s[i] = opening_index\n            s[opening_index] = i\n\n    for op in ops:\n        if op == 'L':\n            p = s[p-1] if p-1 > 0 else s[p]\n        elif op == 'R':\n            p = s[p+1] if p+1 < len(s) else s[p]\n        else: # op == 'D'\n            start = p\n            end = s[p]\n            del s[start:end+1]\n            s = [x if x < start or x > end else (x - (end - start + 1)) for x in s]\n            p = start if start < len(s) else s[start]\n\n    result = ['(', ')']\n    for i in s:\n        result[i] = '('\n        result.insert(i+1, ')')\n    print(''.join(result[:len(s)+1]))\n\nn, m, p = map(int, input().split())\ns = list(map(ord, input()))\nops = input()\nprocess_operations(s, m, p-1, ops)"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\na, b = -10**9, 10**9\nfor _ in range(n):\n    c, x, ans = sys.stdin.readline().strip().split()\n    x = int(x)\n    if c == '>':\n        if ans == 'Y': a = max(a, x + 1)\n        else: b = min(b, x)\n    elif c == '<':\n        if ans == 'Y': b = min(b, x - 1)\n        else: a = max(a, x)\n    elif c == '>=':\n        if ans == 'Y': a = max(a, x)\n        else: b = min(b, x - 1)\n    elif c == '<=':\n        if ans == 'Y': b = min(b, x)\n        else: a = max(a, x + 1)\nif a > b:\n    print('Impossible')\nelse:\n    print((a + b) // 2)"}
{"solution": "3\nimport math\n\na, b = map(int, input().split())\n\nres = set()\n\nfor i in range(1, max(a, b) + 1):\n    if a % i == 0 and b % i == 0:\n        res.add(i)\n\nres.add(a + b)\n\nfor i in range(1, a + b):\n    if (a + b) % i != 0:\n        continue\n    \n    x, y = divmod(a, i)\n    if y > 0 and y == divmod(b, i)[1]:\n        res.add(i)\n\nprint(len(res))"}
{"solution": "def find_names(n, k, effectiveness):\n    names = [\"A\"] * n\n    unique_chars = set(names[:k])\n    for i in range(k, n):\n        if effectiveness[i - k] == \"YES\":\n            new_char = 'A'\n            while new_char in unique_chars:\n                new_char = chr(ord(new_char) + 1)\n            names[i] = new_char\n            unique_chars.add(new_char)\n        else:\n            names[i] = names[i - k]\n        unique_chars.remove(names[i - k])\n\n    return ' '.join(name.capitalize() for name in names)\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    effectiveness = input().split()\n    print(find_names(n, k, effectiveness))"}
{"solution": "import math\n\ndef min_operations_to_equal_cheeses(a, b):\n    \"\"\"\n    Calculates the minimum number of operations needed to make two pieces of cheese equal in weight.\n    An operation consists of reducing a piece by 1/2, 2/3, or 4/5 of its current weight.\n    Returns -1 if it's impossible to make the pieces equal.\n    \"\"\"\n    if a == b:\n        return 0\n    \n    operations = 0\n    while True:\n        if a > b:\n            a, b = b, a\n        \n        if a == b:\n            return operations\n        \n        if b % 5 == 0:\n            b = b // 5 * 4\n            operations += 1\n        elif b % 3 == 0:\n            b = b // 3 * 1\n            operations += 1\n        elif b % 2 == 0:\n            b = b // 2\n            operations += 1\n        else:\n            if a < b and b - a < a:\n                return -1\n\na, b = map(int, input().split())\nprint(min_operations_to_equal_cheeses(a, b))"}
{"solution": "def min_cost_palindrome(n, a, b, c):\n    dp = [[float('inf')] * 3 for _ in range(n + 1)]\n    dp[0][2] = 0\n    for i in range(n):\n        for j in range(3):\n            for k in range(3):\n                if (j == 2 or j == c[i]) and (k == 2 or k == c[n - i - 1]):\n                    dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + (a if k == 0 else b if k == 1 else 0))\n    if min(dp[n]) == float('inf'):\n        return -1\n    return min(dp[n])\n\nn, a, b = map(int, input().split())\nc = list(map(int, input().split()))\nprint(min_cost_palindrome(n, a, b, c))"}
{"solution": "n = int(input())\nif n == 1:\n    print(-1)\nelse:\n    for i in range(n):\n        for j in range(n):\n            if (i + j) % 3 == 0:\n                print('b', end='')\n            else:\n                print('w', end='')\n        print()\n    for i in range(1, n):\n        for j in range(n):\n            if (i + j) % 3 == 0:\n                print('w', end='')\n            else:\n                print('b', end='')\n        print()"}
{"solution": "import math\n\ndef largest_lovely_divisor(n):\n    i = 2\n    lovely = n\n    while i * i <= n:\n        if n % (i * i) == 0:\n            lovely = min(lovely, n // (i * i))\n        i += 1\n    return lovely if lovely != n else n\n\nn = int(input())\nprint(largest_lovely_divisor(n))"}
{"solution": "n = int(input())\ns = input()\n\ndef check_maximal(seating):\n    prev = seating[0]\n    for i in range(1, len(seating)):\n        if prev == '1' and seating[i] == '1':\n            return \"No\"\n        prev = seating[i]\n    if seating.count('0') > 1:\n        if '010' not in seating and seating[0] != '1' and seating[-1] != '1':\n            return \"No\"\n        if seating[0] == '0' and seating[-1] == '0' and '010' not in seating[1:-1]:\n            return \"No\"\n    return \"Yes\"\n\nprint(check_maximal(s))"}
{"solution": "from math import gcd\n\ndef check(a, k):\n    t = 0\n    for i in range(k):\n        t += a[i]\n    prev = t\n    for i in range(1, len(a) // k + 1):\n        curr = 0\n        for j in range(i * k, i * k + k):\n            if j >= len(a): break\n            curr += a[j]\n        if curr != prev: return False\n    return True\n\ndef solve(a):\n    good = []\n    n = len(a)\n    for k in range(1, n + 1):\n        if n % k != 0: continue\n        if check(a, k): good.append(k)\n    return good\n\nn = int(input())\na = list(map(int, input().split()))\nres = solve(a)\nprint(len(res))\nprint(' '.join(map(str, res)))"}
{"solution": ">\na = sorted(list(map(int, input().split())))\nif a[0] + a[1] + a[4] == a[2] + a[3] + a[5]:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\ndef power23(n):\n    if n == 1:\n        return True\n    while n % 2 == 0:\n        n //= 2\n    while n % 3 == 0:\n        n //= 3\n    return n == 1\n\ndef count_2_3_integers(l, r):\n    count = 0\n    for i in range(l, r + 1):\n        if power23(i):\n            count += 1\n    return count\n\nl, r = map(int, input().split())\nprint(count_2_3_integers(l, r))"}
{"solution": "import math\n\ndef find_candies_eaten(n, k):\n    x = (-1 + math.sqrt(1 + 4 * (2 * k + n))) / 2\n    return n - int(x)\n\nn, k = map(int, input().split())\nprint(find_candies_eaten(n, k))"}
{"solution": "def can_form_triangle(n, lengths):\n    lengths.sort()\n    for i in range(n - 2):\n        if lengths[i] + lengths[i + 1] > lengths[i + 2]:\n            return \"YES\"\n    return \"NO\"\n\n# Reading input\nn = int(input())\nlengths = list(map(int, input().split()))\n\n# Printing output\nprint(can_form_triangle(n, lengths))"}
{"solution": "x,y = map(int,input().split())\nif y>x and (y-1)%2==0 and (x-(y-1))%2==0:\n    print(\"Yes\")\nelif y<=x and (x-y)%2==0:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "import sys\n\nn, k = map(int, sys.stdin.readline().split())\na = [int(i) // 10 for i in sys.stdin.readline().split()]\na = [x + (1 if x < 10 else 0) for x in a]\na.sort()\n\nans = sum(a)\nif k == 0:\n    print(ans)\nelse:\n    k = k // 10\n    a = a[:k]\n    s = sum(a)\n    a.sort(reverse=True)\n    m = max(0, max(a) - 10)\n    for i in range(m, -1, -1):\n        s -= i\n        if s <= k:\n            ans += (i + 1) * len(a) + (s - k)\n            break\n    print(ans)"}
{"solution": "def smallest_pretty_integer(n, m, a, b):\n    min_a = min(a)\n    min_b = min(b)\n\n    # Check combinations for the smallest pretty integer\n    if min_a < min_b:\n        return min_a * 10 + min_b\n    else:\n        return min_b * 10 + min_a\n\n# Reading input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(smallest_pretty_integer(n, m, a, b))"}
{"solution": "n, k = map(int, input().split())\ntotal_time = 240 - k\nproblems_solved = 0\ntime_spent = 0\n\nfor i in range(1, n + 1):\n    time_spent += 5 * i\n    if time_spent > total_time:\n        break\n    problems_solved += 1\n\nprint(problems_solved)"}
{"solution": "def max_teams(n, x, y, pages):\n    pages.sort()\n    total_pages = 2 * x + y\n    for i in range(n):\n        if total_pages >= pages[i]:\n            total_pages -= pages[i]\n            if pages[i] % 2 == 1 and total_pages > 0:\n                total_pages -= 1\n        else:\n            break\n    return i + 1\n\nn, x, y = map(int, input().split())\npages = list(map(int, input().split()))\nprint(max_teams(n, x, y, pages))"}
{"solution": "from math import sqrt\n\ndef solve(n):\n    ans = 1\n    if n > 1:\n        maxPrime = 0\n        for prime in primes:\n            if prime * prime > n:\n                break\n            power = 1\n            while n % prime == 0:\n                n //= prime\n                power *= prime\n            if power > 1:\n                maxPrime = prime\n                ans *= (power + 1)\n        if n > 1:\n            ans *= (n + 1)\n    return ans\n\nprimes = []\nfor num in range(2, int(sqrt(10**10)) + 1):\n    if not any(num % p == 0 for p in primes):\n        primes.append(num)\n\nn = int(input())\nprint(solve(n))"}
{"solution": "n = int(input())\ns = input()\n\nl, r = 0, n-1\nwhile l < n and s[l] == '<':\n    l += 1\nwhile r >= 0 and s[r] == '>':\n    r -= 1\n\nif l == 0 and r == n-1:\n    print(0)\nelse:\n    print(n - (r-l+1))"}
{"solution": "from collections import Counter\n\ndef max_rectangle_area(stick_counts):\n    total_area = 0\n    for length, count in stick_counts.items():\n        if count >= 2:\n            usable_sticks = count // 2\n            total_area += (length * min(2, usable_sticks))\n            count %= 2\n        if count == 1 and length + 1 in stick_counts and stick_counts[length + 1] >= 1:\n            total_area += length\n            stick_counts[length + 1] -= 1\n    return total_area\n\ndef ilya_and_rectangles():\n    n = int(input())\n    lengths = list(map(int, input().split()))\n    stick_counts = Counter(lengths)\n    \n    # Decrease lengths by 1 where possible and update counts\n    for length in range(2, 10**6 + 1):\n        if length in stick_counts and stick_counts[length] > 0 and (length - 1) in stick_counts:\n            stick_counts[length - 1] += stick_counts[length]\n            stick_counts[length] = 0\n    \n    # Calculate the maximum area\n    max_area = max_rectangle_area(stick_counts)\n    print(max_area)\n\nilya_and_rectangles()"}
{"solution": "from collections import defaultdict, Counter\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    strings = [input().strip() for _ in range(n)]\n    \n    # Collect all unique characters and their frequencies\n    char_freq = Counter(''.join(strings))\n    sorted_chars = sorted(char_freq.items(), key=lambda x: (-x[1], x[0]))\n    \n    # Mapping from character to digit\n    char_to_digit = {}\n    digit = 9\n    \n    for char, freq in sorted_chars:\n        if freq == 1 or char in {s[0] for s in strings}:  # Ensure no leading zero\n            char_to_digit[char] = str(digit)\n            digit -= 1\n            if digit < 1: break  # Ensure we only use digits 1-9\n    \n    # Assign remaining characters\n    for i in range(1, 10):\n        if i not in char_to_digit.values():\n            for char, _ in sorted_chars:\n                if char not in char_to_digit:\n                    char_to_digit[char] = str(i)\n                    break\n    \n    # Convert strings back to numbers\n    restored_numbers = []\n    for s in strings:\n        restored_number = ''.join(char_to_digit[c] for c in s)\n        restored_numbers.append(int(restored_number))\n    \n    print(sum(restored_numbers))\n\nsolve()"}
{"solution": "n,m=map(int,input().split())\nif 2*n>=m:\n    print(m//2)\nelse:\n    print(n+(m-2*n)//4)"}
{"solution": "def check_substrings(s):\n    ab_found = False\n    ba_found = False\n    ab_index = -1\n    ba_index = -1\n\n    for i in range(len(s) - 1):\n        if s[i:i+2] == 'AB':\n            if ba_found and ba_index < i:\n                return \"YES\"\n            ab_found = True\n            ab_index = i\n        elif s[i:i+2] == 'BA':\n            if ab_found and ab_index < i:\n                return \"YES\"\n            ba_found = True\n            ba_index = i\n\n    return \"NO\"\n\ns = input().strip()\nprint(check_substrings(s))"}
{"solution": "from typing import List\n\ndef can_transform(initial_weights: List[int], final_weights: List[int]) -> List[str]:\n    actions = []\n    stack = []\n    initial_index, final_index = 0, 0\n    \n    while initial_index < len(initial_weights) or final_index < len(final_weights):\n        if not stack or stack[-1] != final_weights[final_index]:\n            if initial_index == len(initial_weights):\n                return [\"NO\"]\n            stack.append(initial_weights[initial_index])\n            initial_index += 1\n        else:\n            if len(stack) > 1 and stack[-2] >= stack[-1]:\n                return [\"NO\"]\n            actions.append(str(len(stack)) + \" L\")\n            stack.pop()\n            final_index += 1\n            \n    if stack or final_index != len(final_weights):\n        return [\"NO\"]\n    \n    return [\"YES\"] + actions[::-1]\n\ndef solve():\n    n = int(input())\n    initial_weights = list(map(int, input().split()))\n    k = int(input())\n    final_weights = list(map(int, input().split()))\n    \n    result = can_transform(initial_weights, final_weights)\n    if result[0] == \"NO\":\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for action in result[1:]:\n            print(action)\n\nsolve()"}
{"solution": "`\nfrom itertools import combinations \nimport math \n  \ndef orientation(p, q, r): \n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]) \n    if val == 0: \n        return 0    \n    elif val > 0: \n        return 1   \n    else: \n        return 2  \n\ndef doIntersect(p1,q1,p2,q2): \n    o1 = orientation(p1, q1, p2) \n    o2 = orientation(p1, q1, q2) \n    o3 = orientation(p2, q2, p1) \n    o4 = orientation(p2, q2, q1) \n\n    if (o1 != o2 and o3 != o4): \n        return True\n   \n    if (o1 == 0 and onSegment(p1, p2, q1)): \n        return True\n  \n    if (o2 == 0 and onSegment(p1, q2, q1)): \n        return True\n  \n    if (o3 == 0 and onSegment(p2, p1, q2)): \n        return True \n  \n    if (o4 == 0 and onSegment(p2, q1, q2)): \n        return True\n  \n    return False\n  \ndef onSegment(p, q, r): \n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and \n        q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])): \n        return True\n    return False\n\ndef check_collision(ships, bases):\n    for (ship1, ship2) in combinations(ships, 2):\n        for (base1, base2) in combinations(bases, 2):\n            if doIntersect(ship1, base1, ship2, base2):\n                return False\n    return True\n\nR, B = map(int, input().split())\nships = [tuple(map(int, input().split())) for _ in range(R)]\nbases = [tuple(map(int, input().split())) for _ in range(B)]\n\nif R != B or not check_collision(ships, bases):\n    print(\"No\")\nelse:\n    print(\"Yes\")"}
{"solution": "def solve():\n    n = int(input())\n    nums = list(map(int, input().split()))\n    \n    max_power = 0\n    for num in nums:\n        power = 0\n        while num % 2 == 0:\n            num //= 2\n            power += 1\n        if power > max_power:\n            max_power = power\n\n    count = sum(1 for num in nums if (num >> max_power) % 2 == 0)\n\n    print(2 ** max_power, count)\n\nsolve()"}
{"solution": "3\ndef min_operations(n, m):\n    operations = 0\n    while n != m:\n        if m > n:\n            if m % 2 == 0:\n                m //= 2\n            else:\n                m += 1\n            operations += 1\n        else:\n            operations += n - m\n            m = n\n    return operations\n\nn, m = map(int, input().split())\nprint(min_operations(n, m))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.readline\n\ndef find(x):\n    if x != parent[x]:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(x, y):\n    px, py = find(x), find(y)\n    if px == py:\n        return\n    parent[px] = py\n\nn = int(input())\nparent = list(range(n))\nedges = []\nseg = []\n\nfor i in range(n):\n    l, r = map(int, input().split())\n    seg.append((l, r, i))\n\nseg.sort(key=lambda x: x[1])\n\nfor i in range(1, n):\n    if seg[i - 1][1] < seg[i][1]:\n        if seg[i - 1][1] >= seg[i][0]:\n            union(seg[i - 1][2], seg[i][2])\n\nseg.sort(key=lambda x: x[0])\n\nfor i in range(1, n):\n    if seg[i - 1][0] < seg[i][0]:\n        if seg[i - 1][0] >= seg[i][1]:\n            union(seg[i - 1][2], seg[i][2])\n\nfor i in range(n):\n    parent[i] = find(i)\n\ndeg = defaultdict(int)\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        if seg[i][0] < seg[j][0] and seg[i][1] > seg[j][1]:\n            deg[parent[i]] += 1\n            deg[parent[j]] += 1\n        elif seg[i][0] > seg[j][0] and seg[i][1] < seg[j][1]:\n            deg[parent[i]] += 1\n            deg[parent[j]] += 1\n        elif seg[i][1] > seg[j][0] and seg[j][1] > seg[i][0]:\n            deg[parent[i]] += 1\n            deg[parent[j]] += 1\n\nif len(set(parent)) == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\" if len(set(parent)) > 1 or max(deg.values()) > 2 else \"YES\")"}
{"solution": "def find_longest_ddos_period(n, requests):\n    max_length = 0\n    for start in range(n):\n        total_requests = 0\n        for end in range(start, n):\n            total_requests += requests[end]\n            if total_requests > 100 * (end - start + 1):\n                max_length = max(max_length, end - start + 1)\n            else:\n                break\n    return max_length\n\nn = int(input())\nrequests = list(map(int, input().split()))\nprint(find_longest_ddos_period(n, requests))"}
{"solution": "3\nn, k = map(int, input().split())\ns = input()\n\ndef check():\n    cnt = mx = 0\n    for c in s:\n        if c == 'N':\n            cnt += 1\n        elif c == '?':\n            cnt += 1\n            mx += 1\n            cnt = max(cnt - 1, 0)\n        else:\n            cnt = 0\n        if cnt > k:\n            return False\n    return k >= mx and k <= cnt + mx\n\nif '?' not in s:\n    print('YES' if s.find('N'*k) != -1 and (k == 0 or s.find('N'*(k+1)) == -1) else 'NO')\nelse:\n    print('YES' if check() else 'NO')"}
{"solution": "import sys\nfrom itertools import accumulate\n\ndef solve():\n    input = sys.stdin.readline\n    N, X, D = map(int, input().split())\n    if D == 0:\n        print(1 if N % 2 == 1 else 2)\n        return\n\n    A = [X + D * i for i in range(N)]\n    S = list(accumulate(A))\n    ans = 0\n    for i in range(N):\n        s, t = S[i], S[-1] - S[i]\n        ans |= 1 << (s - t)\n\n    for i in range(1, N):\n        s, t = S[i-1], S[-1] - S[i]\n        diff = s - t\n        if (diff - D*i) % (2*D) == 0:\n            ans |= 1 << (diff - D*i)\n\n    print(bin(ans).count(\"1\"))\n\nsolve()"}
{"solution": "3\nn = int(input())\nres = 'NO'\nfor i in range(n):\n    s, b, a = input().split()\n    b, a = int(b), int(a)\n    if b >= 2400 and b < a:\n        res = 'YES'\nprint(res)"}
{"solution": "s = input()\n\nans = 0\ncur = 1\nfor i in range(len(s)):\n    ans += (s[i] == '1') * cur\n    cur *= 2\n\nprint(ans)"}
{"solution": "3\nimport sys\n\nn, m = map(int, input().split())\na = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n\ndef check(h):\n    for i in range(h // 2):\n        for j in range(m):\n            if a[i][j] != a[h - i - 1][j]:\n                return False\n    return True\n\nfor h in range(1, n + 1):\n    if check(h):\n        print(h)\n        break"}
{"solution": "def max_orders(n, orders):\n    orders.sort(key=lambda x: x[1])\n    end_time = -1\n    count = 0\n    for order in orders:\n        if order[0] > end_time:\n            count += 1\n            end_time = order[1]\n    return count\n\nif __name__ == \"__main__\":\n    n = int(input())\n    orders = [list(map(int, input().split())) for _ in range(n)]\n    print(max_orders(n, orders))"}
{"solution": "def check(n, k, x, y):\n    prev = 0\n    for i in range(n):\n        total = x[i] + y[i]\n        if total > k:\n            return False\n        if prev == 0:\n            if x[i] > k:\n                prev = 1\n        elif prev == 1:\n            if y[i] > k - x[i]:\n                return False\n            else:\n                prev = 2\n        elif prev == 2:\n            if y[i] > k:\n                prev = 1\n        else:\n            if x[i] > k - y[i]:\n                return False\n            else:\n                prev = 2\n    return True\n\nn, k = map(int, input().split())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\nif check(n, k, x, y):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "')\nfrom collections import deque\n\ndef check_victory(n, k, coefficients):\n    unknown_count = 0\n    queue = deque()\n    for index, coeff in enumerate(coefficients):\n        if coeff == '?':\n            unknown_count += 1\n            queue.append(index)\n        elif index > 0:\n            if (coeff * k) != coefficients[index - 1]:\n                return \"No\"\n    if unknown_count % 2 == 0:\n        return \"No\"\n    while len(queue) > 1:\n        if queue[0] == queue[-1] + 1:\n            queue.pop()\n            queue.popleft()\n        else:\n            queue.popleft()\n    return \"Yes\" if queue and (queue[0] != n) else \"No\"\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    coefficients = [input() if '?' in input() else int(input()) for _ in range(n + 1)]\n    print(check_victory(n, k, coefficients))"}
{"solution": "from sympy import primerange\n\nX_2 = int(input())\n\ndef find_smallest_X0(X2):\n    def next_smallest_multiple(x, prime):\n        return x if x % prime == 0 else ((x // prime) + 1) * prime\n\n    for prime in primerange(2, X2):\n        X1 = next_smallest_multiple(X2, prime)\n        for prev_prime in primerange(2, min(X1, prime)):\n            if next_smallest_multiple(prev_prime, X1) == X2:\n                return next_smallest_multiple(prev_prime, X1)\n\nprint(find_smallest_X0(X_2))"}
{"solution": "import math\n\ndef min_summands(n, p):\n    if p >= n:\n        return -1\n\n    x = int(math.log2(n - p)) if n > p else 0\n    while (1 << x) + p > n:\n        x -= 1\n\n    if (1 << x) + p == n:\n        return 1\n\n    summands = 1\n    while n > (1 << x) + p:\n        n -= (1 << x) + p\n        x = max(0, int(math.log2(n - p)) if n > p else 0)\n        while (1 << x) + p > n:\n            x -= 1\n        summands += 1\n\n    return summands if n <= (1 << x) + p else -1\n\nn, p = map(int, input().split())\nprint(min_summands(n, p))"}
{"solution": "def minify_number(n, k, S):\n    S = list(S)\n    i = 0\n    while k > 0 and i < n:\n        if S[i] != '0':\n            if S[i] != '1' or i == 0:\n                S[i] = '0'\n                k -= 1\n            else:\n                break\n        i += 1\n    if k > 0:\n        S[i] = str(min(int(S[i]), 1))\n        k -= 1\n    for j in range(i + 1, n):\n        if k > 0 and S[j] != '0':\n            S[j] = '0'\n            k -= 1\n    return ''.join(S)\n\n# Reading input\nn, k = map(int, input().split())\nS = input()\n\n# Calculating and printing the result\nprint(minify_number(n, k, S))"}
{"solution": "`\nimport math\n\ndef lcm(a,b):\n    return (a * b) // math.gcd(a,b)\n\ndef solve():\n    c1,c2,x,y = map(int,input().split())\n    l = lcm(x,y)\n    tot = c1+c2\n    res = 0\n    if x > y:\n        x,y = y,x\n    cur = x\n    taken = 0\n    while taken < c1:\n        if cur >= l:\n            cur = x\n        if cur % y != 0:\n            res += 1\n            taken += 1\n        cur += x\n    cur = y\n    while tot > 0:\n        if cur >= l:\n            cur = y\n        if cur % x != 0:\n            res += 1\n            tot -= 1\n        cur += y\n    print(res)\n\nsolve()"}
{"solution": "def bear_and_raspberry_field():\n    n, sx, sy, dx, dy, t = map(int, input().split())\n    n = n - 1\n    \n    dx += t\n    dy += t\n    \n    sx += dx * t\n    sy += dy * t\n    \n    sx = ((sx - 1) % (n + 1)) + 1\n    sy = ((sy - 1) % (n + 1)) + 1\n    \n    print(sx, sy)\n\nbear_and_raspberry_field()"}
{"solution": "import string\n\ndef solve(s):\n    alpha = list(string.ascii_uppercase)\n    qmark = []\n    res = list(s)\n    i = 0\n    while i < len(s):\n        if s[i] == '?':\n            qmark.append(i)\n            res[i] = s[i]\n        i += 1\n    if len(qmark) < 26:\n        return -1\n    else:\n        for i in range(len(res)):\n            if res[i] == '?':\n                res[i] = alpha[0]\n                alpha.pop(0)\n                if len(alpha) == 0:\n                    break\n        if len(alpha) > 0:\n            for i in range(len(res)-1, -1, -1):\n                if res[i] == '?' and len(alpha) > 0:\n                    res[i] = alpha[-1]\n                    alpha.pop()\n                if len(alpha) == 0:\n                    break\n        i = 0\n        while i < len(res):\n            if res[i] == '?':\n                res[i] = 'Z'\n            i += 1\n        res = ''.join(res)\n        return res if isNice(res) else -1\n\ndef isNice(s):\n    d = {}\n    for i in range(97, 123):\n        d[chr(i)] = 0\n    for i in range(len(s)):\n        if s[i] != '?':\n            d[s[i].lower()] += 1\n            if i >= 26 and s[i-26] != '?':\n                d[s[i-26].lower()] -= 1\n            if min(d.values()) > 0:\n                return False\n    return True\n\ns = input().strip()\nprint(solve(s))"}
{"solution": "n = int(input())\nweights = list(map(int, input().split()))\n\ntotal_weight = sum(weights)\nif total_weight % 2 != 0:\n    print(\"NO\")\nelse:\n    dp = [[False for _ in range(total_weight // 2 + 1)] for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(1, total_weight // 2 + 1):\n            if j < weights[i - 1]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - weights[i - 1]]\n    \n    print(\"YES\") if dp[n][total_weight // 2] else print(\"NO\")"}
{"solution": "import sys\nfrom functools import lru_cache\n\nreadline = sys.stdin.readline\n\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\n\ndef solve():\n    n, m = nm()\n    A = [list(ns()) for _ in range(n)]\n\n    @lru_cache(None)\n    def dp(i, j):\n        if i == n:\n            return 0\n        if j == -1:\n            res = 10 ** 9\n            for k in range(m + 1):\n                if A[i][k] == '1':\n                    res = min(res, dp(i, k) + k)\n            return res\n        res = 10 ** 9\n        for k in range(j + 1, m + 1):\n            if A[i][k] == '1':\n                res = min(res, dp(i, k) + k - j)\n        for k in range(j - 1, -1, -1):\n            if A[i][k] == '1':\n                res = min(res, dp(i, k) + j - k)\n        return res\n\n    print(dp(0, -1))\n\nsolve()"}
{"solution": "from collections import defaultdict\n\ndef dfs(node, visited, graph, costs):\n    if node in visited:\n        return 0\n    visited.add(node)\n    cost = costs[node - 1]\n    for neighbor in graph[node]:\n        cost = min(cost, dfs(neighbor, visited, graph, costs))\n    return cost\n\ndef find_min_cost(n, costs, transitions):\n    graph = defaultdict(list)\n    for i, transition in enumerate(transitions):\n        graph[i + 1].append(transition)\n\n    visited = set()\n    min_cost = float('inf')\n    for node in range(1, n + 1):\n        if node not in visited:\n            cycle_cost = dfs(node, visited, graph, costs)\n            min_cost = min(min_cost, cycle_cost)\n\n    return min_cost\n\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\nprint(find_min_cost(n, costs, transitions))"}
{"solution": "n, a, b = map(int, input().split())\nprint((a + b - 1 + n) % n + 1)"}
{"solution": "import sys\n\ndef min_progressions(n, a):\n    def extend(d, v):\n        if d == 0:\n            return v\n        else:\n            return v + d\n\n    def can_extend(v1, v2, v3):\n        if v1 == -1 or v3 == -1:\n            return True\n        return (v3 - v2) == (v2 - v1)\n\n    cnt = 1\n    last = a[0]\n    d = 0\n    for i in range(1, n):\n        if a[i] == -1:\n            a[i] = extend(d, last)\n        if i < n - 1 and a[i + 1] == -1:\n            a[i + 1] = extend(d, a[i])\n        if i < n - 1 and not can_extend(a[i - 1], a[i], a[i + 1]):\n            cnt += 1\n            d = 0\n            if a[i + 1] != -1:\n                last = a[i + 1]\n            continue\n        d = a[i] - last\n        last = a[i]\n    return cnt\n\nn = int(sys.stdin.readline())\na = list(map(int, sys.stdin.readline().split()))\nprint(min_progressions(n, a))"}
{"solution": "def max_beauty(s, k):\n    maxBeauty = 0\n    start = 0\n    aCount = 0\n    bCount = 0\n    for end in range(len(s)):\n        if s[end] == 'a':\n            aCount += 1\n        else:\n            bCount += 1\n        \n        # If the current window cannot be made beautiful by k changes, shrink the window from the left\n        while min(aCount, bCount) > k:\n            if s[start] == 'a':\n                aCount -= 1\n            else:\n                bCount -= 1\n            start += 1\n        \n        # Update maxBeauty\n        maxBeauty = max(maxBeauty, end - start + 1)\n    \n    return maxBeauty\n\n# Reading input\nn, k = map(int, input().split())\ns = input()\n\n# Calculating and printing the result\nprint(max_beauty(s, k))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\ntotal_seats = sum(a)\ncoalition_seats = a[0]\ncoalition = [1]\n\nfor i in range(1, n):\n    if a[i] * 2 <= a[0]:\n        coalition_seats += a[i]\n        coalition.append(i + 1)\n\nif coalition_seats * 2 > total_seats:\n    print(len(coalition))\n    print(' '.join(map(str, coalition)))\nelse:\n    print(0)"}
{"solution": "from math import log\n\ndef max_reward(opponents):\n    return log(opponents + 1)\n\nn = int(input())\nprint(max_reward(n))"}
{"solution": "`\nn = int(input())\n\nsum = 0\nk = 0\n\nwhile sum + k+1 <= n:\n    k += 1\n    sum += k\n\nprint(k)\nl = []\nfor i in range(1, k+1):\n    l.append(str(i))\n\nprint(\" \".join(l[:k]))"}
{"solution": "n = int(input())\nm = int(input())\n\nprint(m % (2**n))"}
{"solution": "def correct_word(s):\n    vowels = \"aeiouy\"\n    stack = []\n    for char in s:\n        if stack and char in vowels and stack[-1] in vowels:\n            continue\n        else:\n            stack.append(char)\n    return ''.join(stack)\n\nn = int(input())\ns = input()\nprint(correct_word(s))"}
{"solution": "import sys\n\nn, a, b = map(int, sys.stdin.readline().split())\ns = sys.stdin.readline()\n\np = s.find('*')\nif p == -1:\n    if a > b:\n        print(min(n, 2*b+1))\n    else:\n        print(min(n, 2*a))\nelse:\n    x = s[:p].count('.')\n    if x % 2 == 0:\n        c = min(x // 2, a) + min(x // 2, b)\n    else:\n        if a < b:\n            c = min(x // 2 + 1, a) + min(x // 2, b)\n        else:\n            c = min(x // 2, a) + min(x // 2 + 1, b)\n    l = p\n    while True:\n        p = s.find('*', p+1)\n        if p == -1:\n            x = s[l+1:].count('.')\n            if x % 2 == 0:\n                c += min(x // 2, a) + min(x // 2, b)\n            else:\n                if a < b:\n                    c += min(x // 2 + 1, a) + min(x // 2, b)\n                else:\n                    c += min(x // 2, a) + min(x // 2 + 1, b)\n            break\n        x = s[l+1:p].count('.')\n        if x % 2 == 0:\n            c += min(x // 2, a) + min(x // 2, b)\n        else:\n            if a < b:\n                c += min(x // 2 + 1, a) + min(x // 2, b)\n            else:\n                c += min(x // 2, a) + min(x // 2 + 1, b)\n        l = p\n\n    print(c)"}
{"solution": "from math import sqrt\n\ndef solve(r):\n    # H(x, y) = x^2 + 2xy + x + 1 = r\n    # Let's solve for x considering it as a quadratic equation in terms of x.\n    # x^2 + (2y + 1)x + (1 - r) = 0\n    \n    # Calculate discriminant\n    D = (2*r - 1)**2 - 4*(r-1)\n    \n    # Check if D is a perfect square\n    if int(sqrt(D))**2 != D:\n        return \"NO\"\n    \n    # Calculate roots\n    x1 = ((1 - 2*r) + sqrt(D)) / 2\n    x2 = ((1 - 2*r) - sqrt(D)) / 2\n    \n    # We are interested in the positive root\n    if x1 > 0 and x1.is_integer():\n        x = int(x1)\n        y = (r - x**2 - x - 1) // (2*x)\n        return f\"{x} {y}\"\n    elif x2 > 0 and x2.is_integer():\n        x = int(x2)\n        y = (r - x**2 - x - 1) // (2*x)\n        return f\"{x} {y}\"\n    else:\n        return \"NO\"\n\n# Read input\nr = int(input())\n\n# Solve and print the result\nprint(solve(r))"}
{"solution": "import sys\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    total_balloons = sum(a)\n    if total_balloons < 3:\n        print(-1)\n        return\n\n    a_with_index = sorted(enumerate(a), key=lambda x: x[1], reverse=True)\n\n    grigory_balloons = 0\n    grigory_indices = []\n    for i, val in a_with_index:\n        grigory_balloons += val\n        grigory_indices.append(i + 1)\n        if grigory_balloons > (total_balloons - grigory_balloons):\n            break\n\n    if len(grigory_indices) == n or (total_balloons - grigory_balloons) == grigory_balloons:\n        # If it's not possible to split, try removing the largest balloon set from Grigory\n        grigory_balloons -= a_with_index[0][1]\n        grigory_indices.pop()\n        if grigory_balloons == (total_balloons - grigory_balloons):\n            print(-1)\n            return\n\n    print(len(grigory_indices))\n    print(*grigory_indices)\n\nsolve()"}
{"solution": "def min_unique_digits\u5206\u89e3(n):\n    # Calculate the minimum number of unique digits\n    if n < 10:\n        return 1\n    elif n % 9 == 0:\n        return 1\n    else:\n        return 2\n\ndef decompose(n):\n    k = min_unique_digits_decomposition(n)\n    if k == 1:\n        return [n]\n    else:\n        remainder = n % 9\n        nines = (n - remainder) // 9\n        decomposition = [9] * nines\n        if remainder > 0:\n            decomposition.append(remainder)\n        return decomposition\n\nn = int(input())\nk = min_unique_digits_decomposition(n)\ndecomposition = decompose(n)\n\nprint(len(decomposition))\nprint(' '.join(map(str, decomposition)))"}
{"solution": "from collections import Counter\nimport math\n\ndef is_prime(n):\n    if n == 2 or n == 3: return True\n    if n < 2 or n%2 == 0: return False\n    if n < 9: return True\n    if n%3 == 0: return False\n    r = int(n**0.5)\n    f = 5\n    while f <= r:\n        if n%f == 0: return False\n        if n%(f+2) == 0: return False\n        f +=6\n    return True  \n\nn = int(input())\na = list(map(int, input().split()))\n\nfreq = Counter(a)\nmax_len = 0\nsubset = []\n\n# Check for 2s\ntwos = freq.pop(2, 0)\nif twos > 0:\n    max_len += twos // 2\n    subset.extend([2] * (twos // 2))\n    if twos % 2 != 0:\n        max_len += 1\n        subset.append(2)\n\n# Check for odd numbers\nfor num in sorted(freq.keys(), reverse=True):\n    if max_len + freq[num] > max_len + len(subset):\n        if is_prime(num + 2) and twos % 2 != 0:\n            continue\n        valid = True\n        for s in subset:\n            if not is_prime(num + s):\n                valid = False\n                break\n        if valid:\n            max_len += freq[num]\n            subset.extend([num] * freq[num])\n\nprint(max_len)\nprint(*subset)"}
{"solution": "def find_max_beautiful_divisor(n):\n    max_divisor = 0\n    k = 1\n    while True:\n        beautiful_number = (2**k - 1) * (2**k)\n        if beautiful_number > n:\n            break\n        if n % beautiful_number == 0:\n            max_divisor = beautiful_number\n        k += 1\n    return max_divisor\n\nn = int(input())\nprint(find_max_beautiful_divisor(n))"}
{"solution": "`\nMOD = 10 ** 9 + 7\n\ndef preprocess():\n    p = [1]\n    for i in range(1, 2001):\n        p.append(p[-1] * 10 % MOD)\n    return p\n\ndef calc(s, m, d, p):\n    dp = [[0 for _ in range(m)] for _ in range(len(s) + 1)]\n    dp[0][0] = 1\n    for i in range(1, len(s)):\n        for j in range(m):\n            for k in range(10):\n                if k == d and i % 2 == 1:\n                    continue\n                ni = i + 1\n                nj = (j * 10 + k) % m\n                dp[ni][nj] += dp[i][j]\n                dp[ni][nj] %= MOD\n    res = 0\n    for i in range(m):\n        for j in range(10):\n            if j == d and len(s) % 2 == 1:\n                continue\n            res += dp[len(s)][i] * pow(10, len(s) - 1, MOD) * i * pow(p[len(s) - 1], -1, MOD) * (j == d) % MOD\n            res += dp[len(s)][i] * (p[len(s) - 1] * (j != d) + (j == d)) % MOD\n            res %= MOD\n    res += dp[len(s)][0] * (s[0] == str(d) and len(s) % 2 == 0) % MOD\n    res -= 1\n    return res % MOD\n\np = preprocess()\nm, d = map(int, input().split())\na = input().strip()\nb = input().strip()\n\nres = (calc(b, m, d, p) - calc(a, m, d, p)) % MOD\nprint(res)"}
{"solution": "def last_child(n, m, a):\n    queue = list(range(1, n+1))\n    i = 0\n    while len(queue) > 0:\n        if a[queue[i]-1] > m:\n            queue.append(queue[i])\n            a[queue[i]-1] -= m\n        else:\n            m -= a[queue[i]-1]\n            queue.pop(i)\n        i = (i + 1) % len(queue)\n    return queue[-1]\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(last_child(n, m, a))\n\nmain()"}
{"solution": "3\nn = int(input())\nbills = [100, 20, 10, 5, 1]\ncount = 0\n\nfor bill in bills:\n    count += n // bill\n    n %= bill\n\nprint(count)"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, k):\n    dp = [[0 for _ in range(n+1)] for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        dp[i][0] = 1\n        for j in range(1, i+1):\n            dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % MOD\n            if j > 1:\n                dp[i][j] += dp[i-1][j-2]\n                dp[i][j] %= MOD\n    \n    res = dp[n][k]\n    for i in range(k+1, n+1):\n        res *= (n-i+1)\n        res %= MOD\n    return res\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "from heapq import heappush, heappop\n\ndef max_beauty(n, k, beauties, colors):\n    \"\"\"\n    Calculate the maximum possible total beauty of a bouquet of k roses\n    satisfying the given constraints.\n    \"\"\"\n    color_counts = {}\n    max_beauty_heap = []\n    total_beauty = 0\n    result = -1\n\n    for i in range(n):\n        color = colors[i]\n        beauty = beauties[i]\n\n        if color not in color_counts:\n            color_counts[color] = 0\n        color_counts[color] += 1\n\n        heappush(max_beauty_heap, beauty)\n        total_beauty += beauty\n\n        # Maintain a heap of size k\n        if len(max_beauty_heap) > k:\n            total_beauty -= heappop(max_beauty_heap)\n\n        if i >= k - 1:\n            if len(color_counts) == 1 and colors.count(colors[i]) == k:\n                continue\n            if len(color_counts) == 1 and colors.count(colors[i]) > k:\n                continue\n            if (len(color_counts) == 2 and 'W' in color_counts and 'R' in color_counts) or \\\n               (len(color_counts) == 1 and (colors[i] == 'O')):\n                continue\n            result = max(result, total_beauty)\n\n    return result\n\n# Reading input\nn, k = map(int, input().split())\nbeauties = list(map(int, input().split()))\ncolors = input()\n\n# Calculating and printing the result\nprint(max_beauty(n, k, beauties, colors))"}
{"solution": "import sys\n\ndef continued_fraction_to_rational(a):\n    p, q = a[-1], 1\n    for ai in reversed(a[:-1]):\n        p, q = ai * p + q, p\n    return p, q\n\ndef main():\n    p, q = map(int, input().split())\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    p_cf, q_cf = continued_fraction_to_rational(a)\n    \n    print(\"YES\" if p * q_cf == q * p_cf else \"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def move_stick(expr):\n    parts = expr.split('+=')\n    A, C = map(lambda x: x.count('|'), parts)\n    B = C - A\n\n    if A + B == C:\n        return expr\n\n    if A + B + 1 == C:\n        return f\"{A + 1}+{B}={C}\"\n\n    if A + B - 1 == C:\n        return f\"{A - 1}+{B + 2}={C}\"\n\n    if A + B == C + 1:\n        return f\"{A}+{B}={C + 2}\"\n\n    if A + B == C - 1:\n        return f\"{A}+{B - 1}={C}\"\n\n    return \"Impossible\"\n\nexpr = input().strip()\nprint(move_stick(expr))"}
{"solution": "MOD = 10 ** 9 + 7\n\ndef fact(n, MOD):\n    fs = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fs[i] = fs[i - 1] * i % MOD\n    return fs\n\ndef ifact(fs, MOD):\n    n = len(fs) - 1\n    fs[n] = pow(fs[n], MOD - 2, MOD)\n    for i in reversed(range(1, n)):\n        fs[i] = fs[i + 1] * (i + 1) % MOD\n    return fs\n\ndef comb(n, r, fs, ifact, MOD):\n    return fs[n] * ifact[r] * ifact[n - r] % MOD\n\ndef main():\n    n, k = map(int, input().split())\n    fs = fact(n, MOD)\n    ifacts = ifact(fs, MOD)\n\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        nd = [0] * (k + 1)\n        for j in range(k + 1):\n            nd[j] = dp[i - 1][j]\n            if j >= 2 * i:\n                nd[j] -= dp[i - 1][j - 2 * i]\n            nd[j] += dp[i - 1][max(0, j - 2 * i + 1)]\n            nd[j] %= MOD\n            nd[j] *= i\n            nd[j] %= MOD\n        dp[i] = nd\n\n    ans = 0\n    for i in range(k + 1):\n        ans += comb(n, i, fs, ifacts, MOD) * dp[n][i] * dp[n][k - i]\n        ans %= MOD\n    print(ans)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "from collections import defaultdict\nimport math\nimport sys\ndef getlist():\n\treturn list(map(int, input().split()))\nclass UnionFind:\n\tdef __init__(self, n):\n\t\tself.par = [i for i in range(n)]\n\t\tself.rank = [0] * n\n\t\tself.size = [1] * n\n\t\tself.group = n\n\tdef find(self, x):\n\t\tif self.par[x] == x:\n\t\t\treturn x\n\t\telse:\n\t\t\tself.par[x] = self.find(self.par[x])\n\t\t\treturn self.par[x]\n\tdef union(self, x, y):\n\t\tx = self.find(x)\n\t\ty = self.find(y)\n\t\tif x != y:\n\t\t\tself.group -= 1\n\t\t\tif self.rank[x] < self.rank[y]:\n\t\t\t\tx, y = y, x\n\t\t\telif self.rank[x] == self.rank[y]:\n\t\t\t\tself.rank[x] += 1\n\t\t\tself.par[y] = x\n\t\t\tself.size[x] += self.size[y]\n\tdef same(self, x, y):\n\t\treturn self.find(x) == self.find(y)\n\tdef get_size(self, x):\n\t\tx = self.find(x)\n\t\treturn self.size[x]\nN = int(input())\nX = []\nY = []\nfor _ in range(N):\n\tx, y = getlist()\n\tX.append(x)\n\tY.append(y)\nuf = UnionFind(4)\nfor i in range(N):\n\tfor j in range(i + 1, N):\n\t\tdx = X[i] - X[j]\n\t\tdy = Y[i] - Y[j]\n\t\tgcd = math.gcd(dx, dy)\n\t\tdx //= gcd\n\t\tdy //= gcd\n\t\tif dx >= 0 and dy >= 0:\n\t\t\tuf.union(0, 1)\n\t\t\tuf.union(2, 3)\n\t\telif dx <= 0 and dy >= 0:\n\t\t\tuf.union(0, 2)\n\t\t\tuf.union(1, 3)\n\t\telif dx <= 0 and dy <= 0:\n\t\t\tuf.union(0, 3)\n\t\t\tuf.union(1, 2)\n\t\telse:\n\t\t\tuf.union(1, 2)\n\t\t\tuf.union(0, 3)\nif uf.group != 1:\n\tprint(-1)\n\tsys.exit()\nm = 2\nd = [1, 1]\nans = []\nfor i in range(N):\n\tx = X[i]\n\ty = Y[i]\n\tw = \"\"\n\twhile x > 0:\n\t\tw += \"R\"\n\t\tx -= 1\n\twhile x < 0:\n\t\tw += \"L\"\n\t\tx += 1\n\twhile y > 0:\n\t\tw += \"U\"\n\t\ty -= 1\n\twhile y < 0:\n\t\tw += \"D\"\n\t\ty += 1\n\tans.append(w)\nprint(m)\nprint(*d)\nfor i in range(N):\n\tprint(ans[i])"}
{"solution": "n = int(input())\ns = input()\ni = 0\nwhile i < len(s):\n    if s[i:i+3] == 'ogo':\n        j = i + 3\n        while j < len(s) and s[j:j+2] == 'go':\n            j += 2\n        s = s[:i] + '*' * 3 + s[j:]\n    else:\n        i += 1\nprint(s)"}
{"solution": "MOD = 10**9 + 7\n\ndef prime_factors(n):\n    i = 2\n    factors = set()\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.add(i)\n    if n > 1:\n        factors.add(n)\n    return factors\n\ndef max_pow_divisible(n, p):\n    k = 0\n    while n % p == 0:\n        k += 1\n        n //= p\n    return p ** k\n\ndef modpow(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        exponent = exponent >> 1\n        base = (base * base) % MOD\n    return result\n\ndef solve(x, n):\n    prime_x = prime_factors(x)\n    result = 1\n    for p in prime_x:\n        total_contribution = 0\n        power_in_x = 0\n        current_p_power = p\n        while x % current_p_power == 0:\n            power_in_x += 1\n            current_p_power *= p\n        current_n = 1\n        while current_n <= n:\n            total_contribution += n // current_n\n            current_n *= p\n        result = (result * modpow(p, min(total_contribution, power_in_x))) % MOD\n    return result\n\nx, n = map(int, input().split())\nprint(solve(x, n))"}
{"solution": "}\nfrom math import log10\n\ndef sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef possible_solutions(a, b, c):\n    max_possible_x = 10**9\n    max_possible_s = 9 * int(log10(max_possible_x)) + 9\n    max_x = (c // b + 1) * max_possible_s**a\n    return [x for x in range(1, min(max_x, max_possible_x)) if x == b * sum_of_digits(x)**a + c]\n\nif __name__ == \"__main__\":\n    a, b, c = map(int, input().split())\n    solutions = possible_solutions(a, b, c)\n    print(len(solutions))\n    print(' '.join(map(str, solutions)))"}
{"solution": ">\nfrom collections import Counter\n\ndef check_cube(cube_state):\n    face = cube_state[::6]\n    for i in range(6):\n        rotated_face = [face[0], face[3], face[5], face[2]]\n        if all(cube_state[6*i : 6*i+4] == [cube_state[6*i],]*4 for i in range(6)) or \\\n           all(cube_state[6*i : 6*i+4] == rotated_face for i in range(6)):\n            return \"YES\"\n        face = face[-1:] + face[:-1]\n    return \"NO\"\n\nif __name__ == \"__main__\":\n    cube_state = list(map(int, input().split()))\n    print(check_cube(cube_state))"}
{"solution": "def find_hacks(p, x, y):\n    def get_position(score):\n        i = (score // 50) % 475\n        for _ in range(25):\n            i = (i * 96 + 42) % 475\n            if 26 + i == p:\n                return True\n        return False\n\n    hacks = 0\n    while not get_position(x) or x < y:\n        x += 100\n        hacks += 1\n    return hacks\n\np, x, y = map(int, input().split())\nprint(find_hacks(p, x, y))"}
{"solution": "]\nn=int(input())\na=int(input())\nb=int(input())\nc=int(input())\nif n==1:\n    print(0)\nelse:\n    print(min(a,b)+min(a,b,c)*(n-2))"}
{"solution": "x1, x2, x3 = map(int, input().split())\nprint(abs(x3 - x2) + abs(x2 - x1)) if x2 > x1 and x3 > x2 else print(abs(x2 - x1) + abs(x2 - x3)) if x1 < x2 < x3 else print(abs(x3 - x1) + abs(x3 - x2))"}
{"solution": "from collections import Counter\nimport sys\n\ndef min_operations(n, x, arr):\n    bit_counts = [0] * 20  # Assuming max value in arr is 10^5 which is less than 2^20\n    for num in arr:\n        for bit in range(20):\n            if num & (1 << bit):\n                bit_counts[bit] += 1\n\n    x_bits = [i for i in range(20) if x & (1 << i)]\n    \n    ans = float('inf')\n    for subset in range(1, 1 << len(x_bits)):\n        mask = 0\n        for i in range(len(x_bits)):\n            if subset & (1 << i):\n                mask |= (1 << x_bits[i])\n\n        total_with_mask = sum(count for bit, count in enumerate(bit_counts) if mask & (1 << bit))\n        if total_with_mask >= 2:\n            ans = min(ans, n - total_with_mask)\n        else:\n            for bit in range(20):\n                if not mask & (1 << bit):\n                    total_with_mask += bit_counts[bit]\n                    if total_with_mask >= 2:\n                        ans = min(ans, n - total_with_mask + 1)\n                    total_with_mask -= bit_counts[bit]\n\n    return ans if ans != float('inf') else -1\n\n# Reading input from stdin\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Printing output to stdout\nprint(min_operations(n, x, arr))"}
{"solution": "def find_plus_shape(h, w, picture):\n    def validate_plus(cx, cy):\n        cross = []\n        for dx in range(w):\n            if picture[cy][cx + dx] == '*'':\n                cross.append((cy, cx + dx))\n            else:\n                break\n        for dx in range(1, w):\n            if picture[cy][cx - dx] == '*'':\n                cross.append((cy, cx - dx))\n            else:\n                break\n        for dy in range(1, h):\n            if picture[cy + dy][cx] == '*'':\n                cross.append((cy + dy, cx))\n            else:\n                break\n        for dy in range(1, h):\n            if picture[cy - dy][cx] == '*'':\n                cross.append((cy - dy, cx))\n            else:\n                break\n\n        cross_set = set(cross)\n        for y in range(h):\n            for x in range(w):\n                if picture[y][x] == '*':\n                    if (y, x) not in cross_set:\n                        return False\n        return True\n\n    stars = []\n    for y in range(h):\n        for x in range(w):\n            if picture[y][x] == '*':\n                stars.append((y, x))\n\n    if len(stars) < 5:\n        return 'NO'\n\n    for star in stars:\n        if validate_plus(star[1], star[0]):\n            return 'YES'\n    return 'NO'\n\n\n# Reading input\nh, w = map(int, input().split())\npicture = [input() for _ in range(h)]\n\n# Printing output\nprint(find_plus_shape(h, w, picture))"}
{"solution": "def solve(n, a, b):\n    if n < a + b - 1:\n        return \"NO\"\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    start, count = 0, 0\n    while count < a:\n        end = min(start + (a - count), n)\n        for i in range(start, end):\n            for j in range(i+1, n):\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n        count += end - start\n        start = end\n    \n    start, count = 0, 0\n    while count < b:\n        end = min(start + (b - count), n)\n        for i in range(start, end):\n            for j in range(i+1, n):\n                matrix[i][j] = 0\n                matrix[j][i] = 0\n        count += end - start\n        start = end\n    \n    return \"YES\", matrix\n\nn, a, b = map(int, input().split())\nresult = solve(n, a, b)\n\nif result[0] == \"NO\":\n    print(result[0])\nelse:\n    print(\"YES\")\n    for row in result[1]:\n        print(''.join(map(str, row)))"}
{"solution": "import math\nc,d=map(int,input().split())\nn,m=map(int,input().split())\nk=int(input())\nans=0\nx=n*m-k\nif x<=0:\n    print(0)\nelse:\n    if x%d==0:\n        y=x//d\n    else:\n        y=x//d+1\n    ans+=y*d\n    x-=y\n    if x<=0:\n        print(ans)\n    else:\n        if n*c>=x:\n            print(ans)\n        else:\n            print(ans+c*math.ceil(x/(n)))"}
{"solution": "s = input()\n\ngrid = [['' for _ in range(13)] for _ in range(2)]\n\n# Place the letters in the grid\nfor i in range(26):\n    if s[i] == s[i+1]:\n        print(\"Impossible\")\n        exit()\n    else:\n        grid[i % 2][i // 2] = s[i]\n        grid[i % 2][i // 2 + 6] = s[i]\n\n# Place the last letter\ngrid[0][12] = s[-1]\ngrid[1][12] = s[-1]\n\n# Print the grid\nprint(''.join(grid[0]))\nprint(''.join(grid[1]))"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return \"=\"\n    elif x > y:\n        x, y = y, x\n\n    # Using logarithms to compare without computing large powers\n    log_ratio = (math.log(y) / y) - (math.log(x) / x)\n    \n    if log_ratio > 0:\n        return \"<\"\n    elif log_ratio < 0:\n        return \">\"\n    else:\n        return \"=\"\n\nx, y = map(int, input().split())\nprint(compare_powers(x, y))"}
{"solution": "`\ndef calculate_balloons(r, h):\n    if h <= r:\n        return 1\n    elif h <= 1.5 * r:\n        return 2\n    else:\n        full_layers = (h // r) - 1\n        remaining_height = h % r\n        if remaining_height >= 0.5 * r:\n            additional_balloons = 2\n        else:\n            additional_balloons = 1\n        return full_layers * 2 + additional_balloons\n\n# Reading input\nr, h = map(int, input().split())\n\n# Calculating and printing the result\nprint(calculate_balloons(r, h))"}
{"solution": "from collections import Counter\n\n# Read input\nt = list(map(int, input().split()))\n\n# Count occurrences of each number\ncounter = Counter(t)\n\n# Calculate the sum of all numbers\ntotal_sum = sum(t)\n\n# Initialize the sum to remove\nremove_sum = 0\n\n# Check if there are any numbers that can be removed (occurring 2 or 3 times)\nfor num, count in counter.items():\n    if count >= 2:\n        # Remove either 2 or 3 occurrences of this number\n        remove_sum += min(2 * num, 3 * num)\n        # Decrease the total count of removed numbers\n        counter[num] -= 2 if count == 2 else 3\n\n# Calculate the minimum possible sum of remaining numbers\nmin_remaining_sum = total_sum - remove_sum\n\n# Print the result\nprint(min_remaining_sum)"}
{"solution": "3\nimport sys\n\nn, a = map(int, input().split())\nx = list(map(int, sys.stdin.readline().split()))\n\nx.sort()\n\nif n == 1:\n    print(0)\nelse:\n    ans = 0\n    for i in range(n - 1):\n        ans += abs(x[i] - x[i + 1])\n\n    if a <= x[0]:\n        ans += x[0] - a\n    elif a >= x[-1]:\n        ans += a - x[-1]\n    else:\n        left = 0\n        right = 0\n        while x[left] < a:\n            left += 1\n        while x[n - 1 - right] > a:\n            right += 1\n        ans += min(abs(x[left] - a), abs(x[n - 1 - right] - a))\n    print(ans)"}
{"solution": "import math\n\ndef s(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_smallest_x(n):\n    for x in range(1, int(math.sqrt(n)) + 1000):  # Adding a buffer to handle cases where n is close to a perfect square\n        if x * x + s(x) * x - n == 0:\n            return x\n    return -1\n\nn = int(input())\nprint(find_smallest_x(n))"}
{"solution": "def bedtime(s, t):\n    h1, m1 = map(int, s.split(':'))\n    h2, m2 = map(int, t.split(':'))\n    \n    total_min1 = h1 * 60 + m1\n    total_min2 = h2 * 60 + m2\n    \n    bed_time_min = total_min1 - total_min2\n    \n    if bed_time_min < 0:\n        bed_time_min += 24 * 60\n    \n    bed_hour = bed_time_min // 60\n    bed_minute = bed_time_min % 60\n    \n    return f\"{bed_hour:02d}:{bed_minute:02d}\"\n\n# Reading input\ns = input()\nt = input()\n\n# Calculating and printing the result\nprint(bedtime(s, t))"}
{"solution": "from collections import deque\n\ndef max_mean_subsegment(n, a):\n    \"\"\"\n    Finds the length of the longest subsegment with the maximum arithmetic mean.\n    \n    :param n: Length of the array.\n    :param a: The array itself.\n    :return: Length of the longest subsegment with maximum arithmetic mean.\n    \"\"\"\n    q = deque()\n    cur_sum = 0\n    max_avg = 0\n    ans = 0\n    \n    for i in range(n):\n        cur_sum += a[i]\n        while q and cur_sum <= (cur_sum - a[q[0]] + i - q[0]) * (i - q[0] + 1):\n            q.popleft()\n        while q and cur_sum <= (cur_sum - a[q[-1]] + i - q[-1]) * (i - q[-1]):\n            ans = max(ans, i - q.pop() + 1)\n        q.append(i)\n        \n    return max(ans, n - q[0])\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Printing output\nprint(max_mean_subsegment(n, a))"}
{"solution": "MOD = 998244353\n\nfact = [1]\nfor i in range(1, 2001):\n    fact.append(fact[-1] * i % MOD)\n\nifact = [pow(fact[-1], MOD - 2, MOD)]\nfor i in range(1, 2001):\n    ifact.append(ifact[-1] * i % MOD)\n\ndef C(n, m):\n    return fact[n] * ifact[m] * ifact[n-m] % MOD\n\ndef solve(n, m, k):\n    ans = 0\n    for i in range(k + 1):\n        ans += C(k, i) * C(n - 1 - k, i) * pow(m, k - i + 1, MOD)\n        ans %= MOD\n    return ans\n\nn, m, k = map(int, input().split())\nprint(solve(n, m, k))"}
{"solution": "`\ndef is_magic_number(n):\n    magic_numbers = [\"1\", \"14\", \"144\"]\n    for magic in magic_numbers:\n        if str(magic) in str(n):\n            n = str(n).replace(str(magic), \"\", -1)\n    return \"YES\" if n == \"\" else \"NO\"\n\n# Reading input\nn = int(input())\n\n# Calculating result\nresult = is_magic_number(n)\n\n# Printing output\nprint(result)"}
{"solution": "}\ndef solve(n, m, i, j, a, b):\n    def get_closest(num, step, max_num):\n        res = num % step\n        if res == 0:\n            return 0\n        if res > step // 2:\n            res = step - res\n        return res\n\n    x_steps = get_closest(i, a, n)\n    y_steps = get_closest(j, b, m)\n\n    if x_steps == 0 and y_steps == 0:\n        return 0\n    elif x_steps == 0 or y_steps == 0:\n        return 1\n    else:\n        if x_steps % (a * 2) == 0 and y_steps % (b * 2) == 0:\n            return 2\n        else:\n            return \"Poor Inna and pony!\"\n\nn, m, i, j, a, b = map(int, input().split())\nprint(solve(n, m, i, j, a, b))"}
{"solution": "def remove_adjacent_chars(s):\n    def remove_char(s, char_to_remove):\n        i = 0\n        while i < len(s):\n            if s[i] == char_to_remove:\n                if i > 0 and ord(s[i]) - ord(s[i-1]) == 1 or i < len(s)-1 and ord(s[i]) - ord(s[i+1]) == 1:\n                    del s[i]\n                    i = max(i-1, 0)\n            else:\n                i += 1\n\n    s = list(s)\n    for ch in range(ord('z'), ord('a')-1, -1):\n        remove_char(s, chr(ch))\n    return len(s)\n\nn = int(input())\ns = input()\nprint(n - remove_adjacent_chars(s))"}
{"solution": "import sys\nfrom collections import defaultdict\n\nn, k = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\nq = int(sys.stdin.readline())\n\nlookup = defaultdict(lambda: defaultdict(lambda: float('inf')))\nfor i in range(n):\n    for j in range(1, k + 1):\n        lookup[j][j * a[i]] = min(j, lookup[j][j * a[i]])\n\nfor _ in range(q):\n    x = int(sys.stdin.readline())\n    ans = float('inf')\n    for i in range(n):\n        for j in range(k + 1):\n            rem = x - j * a[i]\n            if rem < 0:\n                break\n            if rem == 0:\n                ans = min(ans, j)\n                continue\n            for l in range(1, k - j + 1):\n                ans = min(ans, j + lookup[l][rem])\n    print(ans if ans != float('inf') else -1)"}
{"solution": "import math\n\ndef find_meeting_time(x1, x2, t1, t2, p, d):\n    if t1 >= t2:\n        return abs(x2 - x1) * t2\n    if x1 == p:\n        return abs(x2 - x1) * t2 if d * (x2 - x1) < 0 else min((s - p + abs(x2 - x1)) * t1 + p * t2, abs(x2 - x1) * t2)\n    if x2 == p:\n        return abs(x2 - x1) * t2 if d * (x2 - x1) < 0 else min((s - p + abs(x2 - x1)) * t1 + p * t2, abs(x2 - x1) * t2)\n    if d * (p - x1) > 0:\n        next_meet = p + (math.ceil(abs(p - x1) / t2) * t2 - abs(p - x1)) * t1 * d\n        if d * (next_meet - x2) <= 0:\n            return abs(next_meet - x1) * t2 + abs(next_meet - x2) * t2\n        else:\n            return abs(next_meet - x1) * t2 + min((s - next_meet + abs(x2 - next_meet)) * t1 + next_meet * t2, abs(x2 - next_meet) * t2)\n    else:\n        next_meet = p - (math.floor(abs(p - x1) / t2) * t2 - abs(p - x1)) * t1 * d\n        if d * (next_meet - x2) <= 0:\n            return abs(next_meet - x1) * t2 + abs(next_meet - x2) * t2\n        else:\n            return abs(next_meet - x1) * t2 + min((s - next_meet + abs(x2 - next_meet)) * t1 + next_meet * t2, abs(x2 - next_meet) * t2)\n\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\nprint(find_meeting_time(x1, x2, t1, t2, p, d))"}
{"solution": "n, x = map(int, input().split())\ncount = 0\nfor i in range(1, n+1):\n    if x % i == 0 and x // i <= n:\n        count += 1\nprint(count)"}
{"solution": "3\nn,k = map(int,input().split())\ns = \"\"\nx = 97\nfor i in range(k):\n    s += chr(x+i)\nif k==n:\n    print(s)\nelse:\n    for i in range(n-k):\n        if x+k>=123:\n            x = 97\n        s+=chr(x+k-1)\n        if x+k-1 == 122:\n            x = 97\n        else:\n            x = x+k\n    print(s)"}
{"solution": "n = int(input())\ns = input()\na = list(map(int, input().split()))\np = []\nfor i in range(n):\n    p.append([a[i], s[i]])\np.sort()\nmn = float('inf')\nfor i in range(1, n):\n    if p[i][1] == 'R' and p[i - 1][1] == 'L':\n        mn = min(mn, (p[i][0] - p[i - 1][0]) // 2)\nif mn == float('inf'):\n    print(-1)\nelse:\n    print(mn)"}
{"solution": "def max_area(seals, a, b):\n    valid_seals = [(min(x, y), max(x, y)) for x, y in seals if min(x, y) <= a and max(x, y) <= b]\n    valid_seals.sort(reverse=True)\n    \n    best = 0\n    for i in range(len(valid_seals)):\n        for j in range(i + 1, len(valid_seals)):\n            w1, h1 = valid_seals[i]\n            w2, h2 = valid_seals[j]\n            \n            if w1 + w2 <= a and max(h1, h2) <= b:\n                best = max(best, w1 * h1 + w2 * h2)\n                \n            if w1 + h2 <= a and h1 <= b and w2 <= b:\n                best = max(best, w1 * h1 + h2 * w2)\n                \n            if h1 + w2 <= a and w1 <= b and h2 <= b:\n                best = max(best, w1 * h1 + w2 * h2)\n                \n            if h1 + h2 <= b and max(w1, w2) <= a:\n                best = max(best, h1 * w1 + h2 * w2)\n                \n            if w1 + h2 <= b and w1 <= a and h2 <= a:\n                best = max(best, w1 * w1 + h2 * w2)\n                \n            if h1 + w2 <= b and h1 <= a and w2 <= a:\n                best = max(best, h1 * w1 + w2 * h2)\n                \n    return best\n\nn, a, b = map(int, input().split())\nseals = [tuple(map(int, input().split())) for _ in range(n)]\nprint(max_area(seals, a, b))"}
{"solution": "from collections import Counter\n\ndef find_odd_one_out():\n    n = int(input())\n    points = []\n    for _ in range(4*n + 1):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    x_counts = Counter(point[0] for point in points)\n    y_counts = Counter(point[1] for point in points)\n\n    odd_x = next(x for x, count in x_counts.items() if count == 1)\n    odd_y = next(y for y, count in y_counts.items() if count == 1)\n\n    print(odd_x, odd_y)\n\nfind_odd_one_out()"}
{"solution": "def max_product(n):\n    if n < 10:\n        return n\n    digits = [9] * 10\n    number = n\n    multiplier = 1\n    while number > 0:\n        while digits[-multiplier] == 0 and multiplier < 10:\n            multiplier += 1\n        if digits[-multiplier] == 0:\n            break\n        digits[-multiplier] -= 1\n        multiplier = 1\n        while digits[multiplier] == 10:\n            digits[multiplier] = 0\n            multiplier += 1\n        digits[multiplier] += 1\n        number -= 9 * multiplier\n    while digits[1] >= 2 and digits[5] > 0:\n        digits[1] -= 2\n        digits[5] -= 1\n        digits[2] += 1\n        digits[3] += 1\n    while digits[1] >= 3 and digits[3] > 0:\n        digits[1] -= 3\n        digits[3] -= 1\n        digits[2] += 1\n        digits[2] += 1\n    return pow(2, digits[2], 1000000007) * pow(3, digits[3], 1000000007) * pow(5, digits[5], 1000000007) * pow(7, digits[7], 1000000007) % 1000000007\n\nn = int(input())\nprint(max_product(n))"}
{"solution": "def find_min_k(n, votes_for_opponent):\n    max_a = max(votes_for_opponent)\n    total_votes_opponent = sum(votes_for_opponent)\n    \n    def can_win(k):\n        total_votes_awruk = n * k - total_votes_opponent\n        return total_votes_awruk > total_votes_opponent\n    \n    low, high = max_a, 10000\n    while low < high:\n        mid = (low + high) // 2\n        if can_win(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\n# Reading input\nn = int(input())\nvotes_for_opponent = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(find_min_k(n, votes_for_opponent))"}
{"solution": "`\nfrom itertools import groupby\n\ndef operations_to_clear_colors(color_string):\n    \"\"\"\n    Calculates the number of operations needed to clear all points with differing colored neighbors.\n    \"\"\"\n    color_string = ' ' + color_string + ' '\n    expanded_string = ''.join(\n        '>' if len(list(group)) == 1 else 'A' * len(list(group))\n        for _, group in groupby(color_string)\n    )\n    \n    clear_operations = 0\n    while True:\n        prev_length = len(expanded_string)\n        expanded_string = ''.join(\n            'A' * len(list(group)) if all(char == 'A' or char == next_char for char in group) else ''\n            for _, group in groupby(expanded_string + ' ', lambda x, c=next(iter(expanded_string)): c)\n        ).strip()\n        if len(expanded_string) == prev_length:\n            break\n        clear_operations += 1\n    return clear_operations\n\n# Reading input\ncolor_string = input().strip()\n\n# Calculating and printing the result\nprint(operations_to_clear_colors(color_string))"}
{"solution": "n = int(input())\nlst = list(map(int, input().split()))\none_count = 0\nmin_num = min(lst)\nif min_num == 1:\n    for i in lst:\n        if i == 1:\n            one_count += 1\n    if one_count >= 3:\n        print((one_count * (one_count - 1) * (one_count - 2)) // 6)\n    else:\n        print(0)\nelse:\n    min_val = float('inf')\n    for i in range(n):\n        if lst[i] == min_num:\n            left = right = 0\n            curr = 0\n            for j in range(i-1, -1, -1):\n                if lst[j] <= min_num:\n                    left += 1\n                if lst[j] == min_num:\n                    break\n            for j in range(i+1, n):\n                if lst[j] <= min_num:\n                    right += 1\n                if lst[j] == min_num:\n                    curr = right\n                    break\n            min_val = min(min_val, left*curr + right*left)\n    print(min_val)"}
{"solution": "def calculate_cuts(n):\n    return (2 * n) - (n // 2) - (n % 2)\n\nn = int(input())\nprint(calculate_cuts(n))"}
{"solution": "`\ndef max_bank_balance(balance):\n    if balance == 0 or abs(balance) < 10:\n        return balance\n\n    is_negative = balance < 0\n    if is_negative:\n        balance = -balance\n\n    digits = [int(d) for d in str(balance)]\n    n = len(digits)\n\n    if is_negative:\n        if digits[0] == 1 and digits[1] <= 3:\n            return -int(\"\".join(map(str, digits[:-2])))\n        elif digits[0] == 9 and digits[1] >= 5:\n            return -int(\"\".join(map(str, digits[:-2])))\n        else:\n            return -int(\"\".join(map(str, digits[:-1])))\n    else:\n        if digits[-2] >= 5:\n            return int(\"\".join(map(str, digits[:-2]))) + 1\n        else:\n            return int(\"\".join(map(str, digits[:-1])))\n\n# Reading input\nbalance = int(input())\nprint(max_bank_balance(balance))"}
{"solution": "a, b = input().split()\nn = int(input())\ndic = {'v': 0, '<': 1, '^': 2, '>': 3}\nx = dic[a]\ny = dic[b]\nif (x + n) % 4 == y:\n    print('cw')\nelif (x - n) % 4 == y:\n    print('ccw')\nelse:\n    print('undefined')"}
{"solution": "def domino_show(n, pushes):\n    \"\"\"\n    Calculate the number of dominoes left standing vertically after the process.\n\n    :param n: Number of dominoes.\n    :param pushes: String representing the initial state of the dominoes.\n    :return: Number of dominoes left standing vertically.\n    \"\"\"\n    stack = []\n    for i, push in enumerate(pushes):\n        if push != '.':\n            while stack and (stack[-1][0] == 'L' and push == 'R'):\n                stack.pop()\n            if not stack or (stack[-1][0] == 'R' and push == 'L'):\n                stack.append((push, i))\n    \n    # Calculate the remaining standing dominoes\n    standing = n - (len(stack) * 2 - len(stack))\n    return standing\n\n# Reading input\nn = int(input())\npushes = input().strip()\n\n# Output the result\nprint(domino_show(n, pushes))"}
{"solution": "}\ndef find_permutation(n, m, leaders):\n    perm = [-1] * n\n    for i in range(m-1, -1, -1):\n        leader = leaders[i] - 1\n        if perm[leader] == -1:\n            perm[leader] = n - m + i + 1\n        else:\n            next_leader = (leader + perm[leader]) % n\n            if next_leader != (leaders[i+1] - 1):\n                return -1\n            perm[leader] = n - m + i + 1\n    if any(p == -1 for p in perm):\n        return -1\n    return ' '.join(map(str, perm))\n\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\nprint(find_permutation(n, m, leaders))"}
{"solution": "import sys\n\ndef max_number(n, k):\n    str_n = str(n)\n    length = len(str_n)\n    for i in range(length):\n        if k <= 0:\n            break\n        max_digit = str_n[i]\n        move = 0\n        for j in range(i + 1, min(i + 1 + k + 1, length)):\n            if str_n[j] > max_digit:\n                max_digit = str_n[j]\n                move = j - i\n        if max_digit != str_n[i]:\n            str_n = list(str_n)\n            str_n[i], str_n[i + move] = str_n[i + move], str_n[i]\n            str_n = \"\".join(str_n)\n            k -= move\n    return str_n\n\nn, k = map(int, sys.stdin.readline().split())\nprint(max_number(n, k))"}
{"solution": "`\ndef solve():\n    a = list(map(int, input().split()))\n    ar_diff = a[1] - a[0]\n    geo_quo = a[1] // a[0] if a[0] != 0 else None\n\n    ar_progression = all(a[i+1] - a[i] == ar_diff for i in range(1, 3))\n    geo_progression = all(a[i+1] // a[i] == geo_quo and a[i+1] % a[i] == 0 for i in range(1, 3))\n\n    if ar_progression:\n        print(a[-1] + ar_diff)\n    elif geo_progression:\n        print(a[-1] * geo_quo)\n    else:\n        print(42)\n\nsolve()"}
{"solution": "n = int(input())\nc = list(map(int, input().split()))\n\nmax_dist = 0\nlast_pos = {c[0]: 0}\n\nfor j in range(1, n):\n    if c[j] not in last_pos:\n        max_dist = max(max_dist, j - 0)\n    else:\n        max_dist = max(max_dist, j - last_pos[c[j]])\n    \n    last_pos[c[j]] = j\n\nprint(max_dist)"}
{"solution": ">\nn, m, k = map(int, input().split())\nr = ((k - 1) // m) // 2 + 1\nd = ((k - 1) % m) + 1\ns = \"LR\"[k % (m * 2) > m]\nprint(r, d, s)"}
{"solution": "n = int(input())\ns = sorted(input())\nres = set()\nif s.count('B') % 2 == 1: res.add('B')\nif s.count('G') % 2 == 1: res.add('G')\nif s.count('R') % 2 == 1: res.add('R')\n\nif len(res) == 1:\n    print(*res)\nelif len(res) == 2:\n    for i in 'RGB':\n        if i not in res:\n            print(i)\nelse:\n    print(''.join(res))"}
