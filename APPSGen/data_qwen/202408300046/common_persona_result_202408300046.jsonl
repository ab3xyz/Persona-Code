{"solution": "def max_accordion_length(s):\n    stack = []\n    open_brackets = 0\n    colons = 0\n    lines = 0\n    \n    for char in s:\n        if char == '[':\n            open_brackets += 1\n            stack.append(char)\n        elif char == ':':\n            if stack and stack[-1] == '[':\n                colons += 1\n                stack.pop()\n            else:\n                colons = 0\n                stack.clear()\n        elif char == '|':\n            lines += 1\n        elif char == ']':\n            if colons >= 2 and lines > 0:\n                return 4 + 2 * (lines - 1)\n            else:\n                colons = 0\n                lines = 0\n                stack.clear()\n    \n    return -1\n\n# Reading input\ns = input()\n\n# Calculating and printing the output\nprint(max_accordion_length(s))"}
{"solution": "def max_sum_of_digits(x):\n    x_str = str(x)\n    length = len(x_str)\n    \n    # Case 1: All digits before the last can be 9\n    if int(x_str[0]) > 4:\n        max_val = '9' * (length - 1) + x_str[-1]\n    else:\n        # Case 2: Reduce the first digit and fill the rest with 9s\n        first_digit = int(x_str[0]) - 1\n        max_val = str(first_digit) + '9' * (length - 1)\n    \n    return min(int(max_val), x)\n\n# Read input\nx = int(input())\n\n# Compute and print the result\nprint(max_sum_of_digits(x))"}
{"solution": "def is_lucky_year(year):\n    digits = [int(d) for d in str(year)]\n    non_zero_count = sum(1 for d in digits if d != 0)\n    return non_zero_count <= 1\n\ndef find_next_lucky_year(current_year):\n    next_year = current_year + 1\n    while not is_lucky_year(next_year):\n        next_year += 1\n    return next_year - current_year\n\ncurrent_year = int(input())\nprint(find_next_lucky_year(current_year))"}
{"solution": "from itertools import accumulate\nfrom bisect import bisect_left, bisect_right\n\ndef max_painted_sections(n, q, painters):\n    painters.sort()\n    starts = [l for l, _ in painters]\n    ends = [r + 1 for _, r in painters]\n\n    coverage = [0] * (n + 1)\n    for start, end in zip(starts, ends):\n        coverage[start - 1] += 1\n        coverage[end] -= 1\n\n    prefix_sum = list(accumulate(coverage))\n    prefix_sum.pop()  # Remove the last element since it's out of bounds\n\n    max_covered = 0\n    for i in range(len(painters)):\n        for j in range(i + 1, len(painters)):\n            left_coverage = bisect_right(starts, painters[i][1]) - 1\n            right_coverage = bisect_left(starts, painters[j][0])\n            if right_coverage < len(painters):\n                max_covered = max(max_covered, prefix_sum[painters[i][1]] - prefix_sum[painters[i][0] - 1] + \n                                  prefix_sum[painters[j][1]] - prefix_sum[painters[j][0] - 1] - \n                                  (prefix_sum[right_coverage - 1] - prefix_sum[left_coverage]))\n    \n    return max_covered\n\n# Reading input\nn, q = map(int, input().split())\npainters = [list(map(int, input().split())) for _ in range(q)]\n\n# Calculating and printing the output\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def is_lucky(time_str):\n    return '7' in time_str\n\ndef prev_lucky_time(hh, mm, x):\n    # Convert hh:mm to total minutes\n    total_minutes = hh * 60 + mm\n    \n    # Check times going backwards in steps of x minutes\n    for i in range(total_minutes // x + 1000):\n        minutes_ago = total_minutes - i * x\n        hours, minutes = divmod(minutes_ago % (24 * 60), 60)\n        time_str = f\"{hours:02d}:{minutes:02d}\"\n        if is_lucky(time_str):\n            return i\n    return -1  # Fallback, should not happen given problem constraints\n\n# Read inputs\nx = int(input())\nhh, mm = map(int, input().split())\n\n# Calculate and print the result\nprint(prev_lucky_time(hh, mm, x))"}
{"solution": "def min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0\n    elif l == 1:\n        return abs(pos - r) + 1\n    elif r == n:\n        return abs(pos - l) + 1\n    else:\n        # Calculate the cost for moving to each boundary and closing tabs\n        cost_left = abs(pos - l) + (r - l + 1) + 1\n        cost_right = abs(pos - r) + (r - l + 1) + 1\n        # Return the minimum of the two costs\n        return min(cost_left, cost_right)\n\n# Read input\nn, pos, l, r = map(int, input().split())\n# Print the result\nprint(min_seconds_to_close_tabs(n, pos, l, r))"}
{"solution": "from typing import List\n\ndef min_blows_to_defeat(zmei_heads: int, blows: List[List[int]]) -> int:\n    # Sort blows by damage dealt in descending order\n    blows.sort(key=lambda x: x[0], reverse=True)\n    \n    def can_defeat_with_k_blows(k):\n        heads = zmei_heads\n        for d, h in blows:\n            # Calculate the maximum possible reduction in heads with k blows\n            max_reduction = min(d * k, heads)\n            heads -= max_reduction\n            heads += min(h * k, heads)\n            if heads <= 0:\n                return True\n        return False\n    \n    lo, hi = 0, 10**10\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if can_defeat_with_k_blows(mid):\n            hi = mid\n        else:\n            lo = mid + 1\n            \n    # Check if it's impossible to defeat Zmei Gorynich\n    if lo == 10**10:\n        return -1\n    return lo\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [list(map(int, input().split())) for _ in range(n)]\n    print(min_blows_to_defeat(x, blows))"}
{"solution": "def day_barn_empty(n, m):\n    day = 1\n    grains = n\n    while True:\n        # Grains added at the beginning of the day\n        grains += m\n        # Ensure grains do not exceed the barn's capacity\n        grains = min(grains, n)\n        # Sparrows eat grains at the end of the day\n        grains -= day\n        if grains <= 0:\n            return day\n        day += 1\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(day_barn_empty(n, m))"}
{"solution": "def min_draws_to_win(tiles):\n    # Parse the input tiles\n    tile1, tile2, tile3 = tiles.split()\n    \n    # Extract numbers and suits\n    num1, suit1 = int(tile1[0]), tile1[1]\n    num2, suit2 = int(tile2[0]), tile2[1]\n    num3, suit3 = int(tile3[0]), tile3[1]\n    \n    # Check for koutsu (triplet)\n    if tile1 == tile2 == tile3:\n        return 0\n    \n    # Check for shuntsu (sequence)\n    def is_shuntsu(n1, n2, n3):\n        return sorted([n1, n2, n3]) in [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9]]\n    \n    if suit1 == suit2 == suit3 and is_shuntsu(num1, num2, num3):\n        return 0\n    \n    # Check for possible koutsu with one more draw\n    if tile1 == tile2 or tile1 == tile3 or tile2 == tile3:\n        return 1\n    \n    # Check for possible shuntsu with one more draw\n    def needs_one_for_shuntsu(n1, n2):\n        return abs(n1 - n2) == 1 or abs(n1 - n2) == 2\n    \n    if suit1 == suit2 and needs_one_for_shuntsu(num1, num2):\n        return 1\n    if suit1 == suit3 and needs_one_for_shuntsu(num1, num3):\n        return 1\n    if suit2 == suit3 and needs_one_for_shuntsu(num2, num3):\n        return 1\n    \n    # If no koutsu or shuntsu can be formed with one more draw, return 2\n    return 2\n\n# Example usage\nprint(min_draws_to_win(\"1s 2s 3s\"))\nprint(min_draws_to_win(\"9m 9m 9m\"))\nprint(min_draws_to_win(\"3p 9m 2p\"))"}
{"solution": "def find_grandpas_sofa(d, n, m, sofas, cnt):\n    def count_sofas_relative_to(s, sofas, condition):\n        count = 0\n        for other in sofas:\n            if condition(s, other):\n                count += 1\n        return count\n\n    def is_left_of(s, other):\n        return min(s[0][1], s[1][1]) < min(other[0][1], other[1][1])\n\n    def is_right_of(s, other):\n        return max(s[0][1], s[1][1]) > max(other[0][1], other[1][1])\n\n    def is_above(s, other):\n        return min(s[0][0], s[1][0]) < min(other[0][0], other[1][0])\n\n    def is_below(s, other):\n        return max(s[0][0], s[1][0]) > max(other[0][0], other[1][0])\n\n    # Convert input coordinates to a simpler form\n    sofas_coords = []\n    for i, (x1, y1, x2, y2) in enumerate(sofas):\n        sofas_coords.append(((x1, y1), (x2, y2)))\n\n    # Check each sofa against the given conditions\n    for i, sofa in enumerate(sofas_coords):\n        if (\n            count_sofas_relative_to(sofa, sofas_coords, is_left_of) == cnt[0] and\n            count_sofas_relative_to(sofa, sofas_coords, is_right_of) == cnt[1] and\n            count_sofas_relative_to(sofa, sofas_coords, is_above) == cnt[2] and\n            count_sofas_relative_to(sofa, sofas_coords, is_below) == cnt[3]\n        ):\n            return i + 1  # Sofa numbers start from 1\n    return -1\n\n# Read input\nd = int(input())\nn, m = map(int, input().split())\nsofas = [list(map(int, input().split())) for _ in range(d)]\ncnt = list(map(int, input().split()))\n\n# Find and print the result\nprint(find_grandpas_sofa(d, n, m, sofas, cnt))"}
{"solution": "def mars_days_off(n):\n    full_weeks = n // 7\n    remaining_days = n % 7\n    \n    min_days_off = full_weeks * 2\n    max_days_off = full_weeks * 2 + min(remaining_days, 2)\n    \n    return min_days_off, max_days_off\n\nn = int(input())\nmin_days_off, max_days_off = mars_days_off(n)\nprint(min_days_off, max_days_off)"}
{"solution": "def max_chocolates(n, a, b, p, q):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    lcm = a * b // gcd(a, b)\n\n    # Count multiples of a, b, and lcm within n\n    red_tiles = n // a\n    blue_tiles = n // b\n    both_tiles = n // lcm\n\n    # Total chocolates for red and blue tiles\n    total_red = red_tiles * p\n    total_blue = blue_tiles * q\n\n    # Adjust for tiles that can be both red and blue\n    # Choose the maximum between p and q for these tiles\n    both_max = both_tiles * max(p, q)\n\n    # Final calculation\n    total_chocolates = (total_red + total_blue - both_max)\n\n    return total_chocolates\n\n# Read input\nn, a, b, p, q = map(int, input().split())\n\n# Calculate and print the result\nprint(max_chocolates(n, a, b, p, q))"}
{"solution": "def max_golden_segment(n, trophies):\n    # Convert the string to a list of integers for easier manipulation (0 for S, 1 for G)\n    trophies = [1 if trophy == 'G' else 0 for trophy in trophies]\n    \n    max_length = 0\n    prefix_sum = [0]\n    for i in range(n):\n        prefix_sum.append(prefix_sum[-1] + trophies[i])\n    \n    # Find the longest segment of Gs without swapping\n    max_length = max(max_length, max(prefix_sum))\n    \n    # Check all possible swaps\n    for i in range(n):\n        if trophies[i] == 0:  # Only try to swap if the trophy is S\n            left_gold = prefix_sum[i]\n            right_gold = prefix_sum[n] - prefix_sum[i + 1]\n            \n            # Try to swap with a G from the left side\n            if i > 0 and trophies[i - 1] == 1:\n                left_gold -= 1\n            # Try to swap with a G from the right side\n            if i < n - 1 and trophies[i + 1] == 1:\n                right_gold -= 1\n            \n            max_length = max(max_length, left_gold + right_gold + 1)\n    \n    return max_length\n\n# Read input\nn = int(input())\ntrophies = input().strip()\n\n# Compute and print the result\nprint(max_golden_segment(n, trophies))"}
{"solution": "from collections import defaultdict, deque\n\ndef topological_sort(n, k, prerequisites):\n    # Build graph and indegree map\n    graph = defaultdict(list)\n    indegree = {i: 0 for i in range(1, n + 1)}\n    \n    for i in range(n):\n        num_prereqs = prerequisites[i][0]\n        for prereq in prerequisites[i][1:]:\n            graph[prereq].append(i + 1)\n            indegree[i + 1] += 1\n    \n    # Queue for courses with no prerequisites\n    queue = deque([course for course in range(1, n + 1) if indegree[course] == 0])\n    visited = []\n    \n    while queue:\n        course = queue.popleft()\n        visited.append(course)\n        \n        for neighbor in graph[course]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    if len(visited) != n:\n        return [-1]\n    \n    # Filter and sort required courses\n    required_courses = set(k_courses)\n    result = [course for course in visited if course in required_courses]\n    additional_courses = [course for course in visited if course not in required_courses]\n    \n    for course in additional_courses:\n        if any(indegree[result[i]] > 0 for i in range(len(result))):\n            break\n        result.append(course)\n    \n    return [len(result)] + result\n\n# Read input\nn, k = map(int, input().split())\nk_courses = list(map(int, input().split()))\nprerequisites = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve and print output\nresult = topological_sort(n, k, prerequisites)\nprint(*result)"}
{"solution": "def is_stack_sortable(arr):\n    stack = []\n    sorted_arr = []\n    max_val = 0\n    for val in arr:\n        if val < max_val:\n            return False\n        max_val = max(max_val, val)\n        stack.append(val)\n        while stack and (not sorted_arr or stack[-1] >= sorted_arr[-1]):\n            sorted_arr.append(stack.pop())\n    return True\n\ndef restore_permutation(n, k, initial_elements):\n    remaining_elements = set(range(1, n + 1)) - set(initial_elements)\n    remaining_list = list(remaining_elements)\n    remaining_list.sort(reverse=True)\n    \n    result = list(initial_elements)\n    stack = []\n    max_seen = 0\n    \n    for i in range(k):\n        if initial_elements[i] < max_seen:\n            return [-1]\n        max_seen = max(max_seen, initial_elements[i])\n        stack.append(initial_elements[i])\n        while stack and (not result or stack[-1] >= result[-1]):\n            result.append(stack.pop())\n    \n    for val in remaining_list:\n        stack.append(val)\n        while stack and (not result or stack[-1] >= result[-1]):\n            result.append(stack.pop())\n    \n    if len(result) != n or not is_stack_sortable(result):\n        return [-1]\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\ninitial_elements = list(map(int, input().split()))\n\n# Solve and print output\noutput = restore_permutation(n, k, initial_elements)\nprint(*output)"}
{"solution": "def does_b_appear_in_sequence(a, b, c):\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\na, b, c = map(int, input().split())\nprint(does_b_appear_in_sequence(a, b, c))"}
{"solution": "def can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    return 1 if cnt_1 == cnt_4 else 0\n\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\nprint(can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4))"}
{"solution": "def standing_spectators(n, k, t):\n    # Calculate the number of complete cycles of k stand-ups and k sit-downs before time t\n    full_cycles = t // k\n    # Calculate the number of spectators currently standing after full cycles\n    standing = min(n, full_cycles * k)\n    # Calculate the remaining time after full cycles\n    remaining_time = t % k\n    # Add the number of spectators standing up in the remaining time\n    standing += remaining_time\n    # If there have been more than n stand-ups, subtract the number of spectators who have sat down\n    if t >= n:\n        standing -= (t - n)\n    return standing\n\n# Read input\nn, k, t = map(int, input().split())\n\n# Calculate and print the number of standing spectators at time t\nprint(standing_spectators(n, k, t))"}
{"solution": "def lexicographically_minimal_string(s):\n    t = []\n    u = []\n    s = list(s)\n    min_char_index = 0\n    \n    while s or t:\n        if t and (not s or s[min_char_index] > t[-1]):\n            u.append(t.pop())\n        else:\n            t.append(s.pop(min_char_index))\n            min_char_index = min(range(len(s)), key=lambda i: s[i] if i < len(s) else 'z')\n    \n    return ''.join(u)\n\n# Reading input\ns = input().strip()\nprint(lexicographically_minimal_string(s))"}
{"solution": "def check_stats(test_cases):\n    for _ in range(test_cases):\n        moments = int(input())\n        previous_plays, previous_clears = 0, 0\n        valid = True\n        \n        for _ in range(moments):\n            current_plays, current_clears = map(int, input().split())\n            \n            if current_plays < previous_plays or current_clears < previous_clears:\n                valid = False\n                break\n            \n            plays_diff = current_plays - previous_plays\n            clears_diff = current_clears - previous_clears\n            \n            if clears_diff > plays_diff:\n                valid = False\n                break\n            \n            previous_plays, previous_clears = current_plays, current_clears\n        \n        print(\"YES\" if valid else \"NO\")\n\n# Read the number of test cases\ntest_cases = int(input())\n\n# Process each test case\ncheck_stats(test_cases)"}
{"solution": "from datetime import datetime, timedelta\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef next_palindromic_time(current_time):\n    current = datetime.strptime(current_time, '%H:%M')\n    next_time = current\n    \n    while True:\n        next_time += timedelta(minutes=1)\n        time_str = next_time.strftime('%H:%M')\n        if is_palindrome(time_str.replace(\":\", \"\")):\n            break\n    \n    minutes_to_sleep = (next_time - current).seconds // 60\n    return minutes_to_sleep\n\n# Read input\ncurrent_time = input().strip()\n\n# Calculate and print the result\nprint(next_palindromic_time(current_time))"}
{"solution": "def max_distance_after_swap(n, arr):\n    # Find positions of 1 and n\n    pos_1 = arr.index(1)\n    pos_n = arr.index(n)\n    \n    # Calculate current distance\n    current_distance = abs(pos_n - pos_1)\n    \n    # Calculate potential maximum distance\n    max_distance = max(pos_1, pos_n) + (n - 1 - min(pos_1, pos_n))\n    \n    # Check if swap is needed\n    if current_distance == max_distance:\n        # If already maximum, return current distance\n        return current_distance\n    else:\n        # Otherwise, return the maximum distance achievable\n        return max_distance\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Compute and print the result\nprint(max_distance_after_swap(n, arr))"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    mid = n // 2\n    first_half = s[:mid]\n    second_half = s[mid + 1:] if n % 2 else s[mid:]\n    \n    if first_half == second_half[::-1]:\n        return \"TAK\"\n    else:\n        return \"NIE\"\n\ns = input().strip()\nprint(is_s_palindrome(s))"}
{"solution": "def max_permutation(a, b):\n    a_str = list(str(a))\n    b_str = list(str(b))\n    \n    if len(a_str) < len(b_str) or a < b:\n        return a\n    \n    result = []\n    i = 0\n    while a_str and i < len(b_str):\n        placed = False\n        for j in range(len(a_str) - 1, -1, -1):\n            if a_str[j] <= b_str[i]:\n                result.append(a_str.pop(j))\n                placed = True\n                break\n        if not placed:\n            # If no digit can be placed, return the original number\n            return a\n        i += 1\n    \n    # Adjusting remaining digits\n    for j in range(i, len(b_str)):\n        if a_str[-1] > b_str[j]:\n            return int(''.join(result + a_str))\n        result.append(a_str.pop())\n    \n    return int(''.join(result))\n\n# Reading input\na = int(input().strip())\nb = int(input().strip())\n\n# Printing output\nprint(max_permutation(a, b))"}
{"solution": "def check_win(matrix, row, col):\n    def check_line(dx, dy):\n        count = 1\n        for i in range(1, 5):\n            nx, ny = row + dx * i, col + dy * i\n            if 0 <= nx < 10 and 0 <= ny < 10 and matrix[nx][ny] == 'X':\n                count += 1\n            else:\n                break\n        for i in range(1, 5):\n            nx, ny = row - dx * i, col - dy * i\n            if 0 <= nx < 10 and 0 <= ny < 10 and matrix[nx][ny] == 'X':\n                count += 1\n            else:\n                break\n        return count >= 5\n\n    # Check horizontal, vertical, and diagonals\n    return any(check_line(d1, d2) for d1 in (0, 1) for d2 in (0, 1))\n\ndef can_alice_win(matrix):\n    for row in range(10):\n        for col in range(10):\n            if matrix[row][col] == '.':\n                matrix[row] = matrix[row][:col] + 'X' + matrix[row][col+1:]\n                if check_win(matrix, row, col):\n                    return 'YES'\n                matrix[row] = matrix[row][:col] + '.' + matrix[row][col+1:]\n    return 'NO'\n\n# Read input\nmatrix = [input() for _ in range(10)]\n\n# Output result\nprint(can_alice_win(matrix))"}
{"solution": "def print_matrix(matrix):\n    for row in matrix:\n        print(' '.join(map(str, row)))\n\ndef fill_symmetric_matrix(n, k):\n    matrix = [[0] * n for _ in range(n)]\n    placed_ones = 0\n    \n    # Fill the upper triangle and main diagonal\n    for i in range(n):\n        for j in range(i, n):\n            if placed_ones < k:\n                matrix[i][j] = 1\n                placed_ones += 1\n                if placed_ones == k:\n                    break\n    \n    # Check if k ones can be placed\n    if placed_ones < k:\n        return -1\n    \n    # Ensure symmetry\n    for i in range(n):\n        for j in range(i + 1, n):\n            matrix[j][i] = matrix[i][j]\n    \n    return matrix\n\n# Read input\nn, k = map(int, input().split())\n\n# Solve and print result\nresult = fill_symmetric_matrix(n, k)\nif result == -1:\n    print(-1)\nelse:\n    print_matrix(result)"}
{"solution": "from math import pow\n\ndef calculate_expression(x, y, z):\n    # Define the 12 possible expressions\n    expressions = [\n        (pow(x, pow(y, z)), \"x^y^z\"),\n        (pow(x, pow(z, y)), \"x^z^y\"),\n        (pow(pow(x, y), z), \"(x^y)^z\"),\n        (pow(pow(x, z), y), \"(x^z)^y\"),\n        (pow(y, pow(x, z)), \"y^x^z\"),\n        (pow(y, pow(z, x)), \"y^z^x\"),\n        (pow(pow(y, x), z), \"(y^x)^z\"),\n        (pow(pow(y, z), x), \"(y^z)^x\"),\n        (pow(z, pow(x, y)), \"z^x^y\"),\n        (pow(z, pow(y, x)), \"z^y^x\"),\n        (pow(pow(z, x), y), \"(z^x)^y\"),\n        (pow(pow(z, y), x), \"(z^y)^x\")\n    ]\n    \n    # Find the maximum value and its corresponding expression\n    max_value, max_expression = max(expressions)\n    \n    return max_expression\n\n# Read input\nx, y, z = map(float, input().split())\n\n# Calculate and print the result\nprint(calculate_expression(x, y, z))"}
{"solution": "def min_operations_to_type_string(n, s):\n    # Base case: if the string is of length 1 or doesn't repeat, return its length\n    if n == 1 or s == \"\".join(set(s)):\n        return n\n    \n    # Initialize the result with the length of the string\n    result = n\n    \n    # Iterate over possible substrings to find the minimum operations\n    for i in range(1, n // 2 + 1):\n        # Check if the current substring can be repeated to form the entire string\n        if n % i == 0 and s[:i] * (n // i) == s:\n            # Calculate operations: length of substring + 1 for copy + (n // i - 1) for pastes\n            result = min(result, i + n // i - 1)\n            break  # Found the optimal solution\n    \n    return result\n\n# Read input\nn = int(input())\ns = input()\n\n# Print the result\nprint(min_operations_to_type_string(n, s))"}
{"solution": "from collections import defaultdict\n\ndef min_script_moves(n, files):\n    # Separate files by type and sort them\n    examples = sorted([name for name, type_ in files if type_ == '1'])\n    regulars = sorted([name for name, type_ in files if type_ == '0'])\n\n    # Initialize variables\n    total_moves = 0\n    script = []\n\n    # Number of examples\n    num_examples = len(examples)\n\n    # Rename examples\n    for i, example in enumerate(examples):\n        if example != str(i + 1):\n            script.append(f\"move {example} {i + 1}\")\n            total_moves += 1\n\n    # Rename regulars\n    for i, regular in enumerate(regulars):\n        new_index = num_examples + i + 1\n        if regular != str(new_index):\n            script.append(f\"move {regular} {new_index}\")\n            total_moves += 1\n\n    return total_moves, script\n\n# Read input\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\n# Generate script\ntotal_moves, script = min_script_moves(n, files)\n\n# Print output\nprint(total_moves)\nfor line in script:\n    print(line)"}
{"solution": "def min_replacements_to_make_lucky_ticket(ticket):\n    # Calculate the sum of the first and last three digits\n    first_half_sum = sum(int(digit) for digit in ticket[:3])\n    second_half_sum = sum(int(digit) for digit in ticket[3:])\n    \n    # Calculate the difference between the sums\n    diff = abs(first_half_sum - second_half_sum)\n    \n    # Initialize the result variable\n    result = 0\n    \n    # Iterate over each digit in the ticket\n    for i in range(6):\n        # Calculate the maximum possible reduction in the difference\n        # by replacing the current digit with another digit\n        max_reduction = min(diff, 9 - int(ticket[i]))\n        \n        # Update the difference and result accordingly\n        diff -= max_reduction\n        result += 1\n        \n        # If the difference reaches 0, break the loop\n        if diff == 0:\n            break\n    \n    return result\n\n# Read input\nticket = input()\n\n# Print the minimum number of replacements\nprint(min_replacements_to_make_lucky_ticket(ticket))"}
{"solution": "from math import gcd\n\ndef minimum_traps(m, x):\n    # Since GCD(x, m) = 1, x and m are coprime.\n    # The mouse will visit all rooms in a cycle, thus the minimum number of traps is m - 1.\n    return m - 1\n\n# Reading input\nm, x = map(int, input().split())\n# Ensuring GCD(x, m) = 1 as per the problem statement\nassert gcd(x, m) == 1\n# Printing the output\nprint(minimum_traps(m, x))"}
{"solution": "from math import gcd\n\nMOD = 10**6 + 3\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef solve(n, k):\n    n = pow(2, n, MOD - 1)\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator = (numerator * (n - i)) % MOD\n        denominator = (denominator * (i + 1)) % MOD\n    numerator = (numerator * modinv(denominator)) % MOD\n    denominator = pow(n, k, MOD)\n    # Simplify fraction\n    common_divisor = gcd(numerator, denominator)\n    numerator //= common_divisor\n    denominator //= common_divisor\n    return numerator % MOD, denominator % MOD\n\ndef main():\n    n, k = map(int, input().split())\n    a, b = solve(n, k)\n    print(a, b)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def check_journey(n, journey):\n    latitude = 90.0  # Start at the North Pole\n    longitude = 0.0  # Longitude does not matter for poles but kept for completeness\n    \n    for t, direction in journey:\n        if direction == \"North\":\n            if latitude == 90.0:\n                return \"NO\"\n            latitude = min(90.0, latitude + t)\n        elif direction == \"South\":\n            if latitude == -90.0:\n                return \"NO\"\n            latitude = max(-90.0, latitude - t)\n        elif direction == \"East\":\n            longitude = (longitude + t) % 40000\n        elif direction == \"West\":\n            longitude = (longitude - t) % 40000\n    \n    if latitude != 90.0:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Reading input\nn = int(input())\njourney = []\nfor _ in range(n):\n    t, direction = input().split()\n    journey.append((int(t), direction))\n\n# Checking the journey and printing the result\nprint(check_journey(n, journey))"}
{"solution": "from math import gcd\n\ndef find_common_elements(a1, b1, a2, b2, L, R):\n    # Calculate the greatest common divisor (gcd)\n    common_diff = a1 * a2 // gcd(a1, a2)\n    \n    # Initialize counters for the number of valid k' and l'\n    count = 0\n    \n    # Check if L is a valid starting point\n    if (L - b1) % a1 == 0 and (L - b2) % a2 == 0 and (L - b1) % common_diff == 0:\n        current = L\n    else:\n        # Find the next possible value after L\n        current = L + (common_diff - (L - b1) % common_diff) % common_diff\n    \n    # Loop through all possible values up to R\n    while current <= R:\n        count += 1\n        current += common_diff\n    \n    return count\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Calculate and print the result\nprint(find_common_elements(a1, b1, a2, b2, L, R))"}
{"solution": "def max_pieces_per_plate(n, a, b):\n    # Initialize the minimum number of pieces per plate\n    min_pieces = 0\n    # Initialize the maximum number of pieces per plate\n    max_pieces = max(a, b) + 1\n\n    while min_pieces + 1 < max_pieces:\n        mid = (min_pieces + max_pieces) // 2\n        # Calculate the total number of plates needed if each plate has mid pieces\n        total_plates_needed = (a + mid - 1) // mid + (b + mid - 1) // mid\n\n        if total_plates_needed <= n:\n            min_pieces = mid\n        else:\n            max_pieces = mid\n\n    return min_pieces\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(max_pieces_per_plate(n, a, b))"}
{"solution": "def is_valid_flag(n, m, flag):\n    # Check if dimensions are divisible by 3\n    if n % 3 != 0 or m % 3 != 0:\n        return \"NO\"\n    \n    stripe_height = n // 3\n    stripe_width = m // 3\n    \n    # Define the expected pattern\n    expected_pattern = ['RRR', 'GGG', 'BBB']\n    \n    # Check each stripe\n    for i in range(3):\n        start_row = i * stripe_height\n        end_row = (i + 1) * stripe_height\n        for row in range(start_row, end_row):\n            for col in range(stripe_width):\n                if flag[row][col] != expected_pattern[i][col // (m // 3)]:\n                    return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nflag = [input() for _ in range(n)]\n\n# Print the result\nprint(is_valid_flag(n, m, flag))"}
{"solution": "def calculate_hexagon_coordinates(n):\n    if n == 0:\n        return (0, 0)\n    \n    # Determine the ring and starting position\n    ring = 1\n    while True:\n        if n <= 6 * ring:\n            break\n        n -= 6 * ring\n        ring += 1\n    \n    # Determine the side of the hexagon\n    side_length = ring\n    side = n // side_length\n    offset = n % side_length\n    \n    # Calculate coordinates based on the side\n    if side == 0:\n        x, y = -ring + offset, ring - 1\n    elif side == 1:\n        x, y = -ring + 1, ring - 2 - offset\n    elif side == 2:\n        x, y = offset - ring + 1, -ring + 1\n    elif side == 3:\n        x, y = ring - 1 - offset, -ring + 1\n    elif side == 4:\n        x, y = -ring + 1, offset - ring\n    else:  # side == 5\n        x, y = ring - 1, ring - 1 - offset\n    \n    return (x, y)\n\n# Read input\nn = int(input())\n\n# Calculate and print the coordinates\nx, y = calculate_hexagon_coordinates(n)\nprint(x, y)"}
{"solution": "import math\n\ndef can_break_shield(a, b, c):\n    # Calculate the greatest common divisor of a and b\n    gcd_ab = math.gcd(a, b)\n    \n    # Check if c is divisible by the gcd of a and b\n    if c % gcd_ab == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input values\na, b, c = map(int, input().split())\n\n# Output the result\nprint(can_break_shield(a, b, c))"}
{"solution": "def can_tracks_coincide(n, L, kefa_barriers, sasha_barriers):\n    # Calculate distances between consecutive barriers for Kefa\n    kefa_distances = [(kefa_barriers[(i + 1) % n] - kefa_barriers[i]) % L for i in range(n)]\n    # Calculate distances between consecutive barriers for Sasha\n    sasha_distances = [(sasha_barriers[(i + 1) % n] - sasha_barriers[i]) % L for i in range(n)]\n    \n    # Double the kefa_distances to handle circular rotation\n    doubled_kefa_distances = kefa_distances + kefa_distances\n    \n    # Check if sasha_distances is a sublist of doubled_kefa_distances\n    for i in range(n):\n        if doubled_kefa_distances[i:i + n] == sasha_distances:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_barriers, sasha_barriers))"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindromic_substring(s):\n    n = len(s)\n    max_len = 0\n    \n    for i in range(n):\n        for j in range(i+1, n+1):\n            if not is_palindrome(s[i:j]):\n                max_len = max(max_len, j-i)\n    \n    return max_len\n\n# Reading input\ns = input().strip()\n\n# Calculating the result\nresult = longest_non_palindromic_substring(s)\n\n# Printing the output\nprint(result)"}
{"solution": "def determine_round_status(n, participants):\n    # Check if any rating has changed\n    any_change = False\n    # Check if the standings are in non-increasing order of initial ratings\n    non_increasing_order = all(participants[i][0] >= participants[i+1][0] for i in range(n-1))\n    \n    for i in range(n):\n        if participants[i][0] != participants[i][1]:\n            any_change = True\n            break\n    \n    # If any rating has changed, the round is rated\n    if any_change:\n        return \"rated\"\n    # If standings are not in non-increasing order, the round is unrated\n    elif not non_increasing_order:\n        return \"unrated\"\n    # Otherwise, it's impossible to determine\n    else:\n        return \"maybe\"\n\n# Reading input\nn = int(input())\nparticipants = [list(map(int, input().split())) for _ in range(n)]\n\n# Determine and print the result\nprint(determine_round_status(n, participants))"}
{"solution": "def find_nearest_zero_distances(n, arr):\n    # Initialize distances list with maximum possible distance\n    distances = [n] * n\n    \n    # Forward pass to update distances towards the left\n    for i in range(n):\n        if arr[i] == 0:\n            distances[i] = 0\n        else:\n            if i > 0:\n                distances[i] = min(distances[i], distances[i - 1] + 1)\n    \n    # Backward pass to update distances towards the right\n    for i in range(n - 2, -1, -1):\n        distances[i] = min(distances[i], distances[i + 1] + 1)\n    \n    return distances\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate and print the distances\nresult = find_nearest_zero_distances(n, arr)\nprint(' '.join(map(str, result)))"}
{"solution": "from itertools import product\n\ndef is_substring_in_cyclical_shifts(t, s):\n    t_extended = t + t\n    return any(s in t_extended[i:i+len(t)] for i in range(len(t)))\n\ndef count_distinct_cyclical_strings(n, s):\n    distinct_cyclical_strings = set()\n    \n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if is_substring_in_cyclical_shifts(t, s):\n            distinct_cyclical_strings.add(t)\n    \n    return len(distinct_cyclical_strings)\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import math\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    angles = []\n    \n    # Calculate angles and store them with vector index\n    for i, (x, y) in enumerate(vectors):\n        angle = math.atan2(y, x)\n        if angle < 0:\n            angle += 2 * math.pi\n        angles.append((angle, i + 1))\n    \n    # Sort the angles\n    angles.sort()\n    \n    min_diff = math.pi\n    result = (0, 0)\n    \n    # Check the difference between consecutive angles and wrap around\n    for i in range(n):\n        diff = abs(angles[i][0] - angles[(i + 1) % n][0])\n        if diff > math.pi:\n            diff = 2 * math.pi - diff\n        if diff < min_diff:\n            min_diff = diff\n            result = (angles[i][1], angles[(i + 1) % n][1])\n    \n    return result\n\n# Read input\nn = int(input())\nvectors = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Find and print the pair of vectors with the minimal non-oriented angle\na, b = find_min_angle_pair(vectors)\nprint(a, b)"}
{"solution": "def minimal_time(d, k, a, b, t):\n    if d <= k:\n        return d * a\n    \n    # Full segments\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Time for full segments\n    time_for_full_segments = full_segments * k * a + (full_segments - 1) * t\n    \n    # Time for remaining distance\n    if remaining_distance == 0:\n        return time_for_full_segments\n    else:\n        # Option 1: Drive the remaining distance\n        time_drive_remaining = remaining_distance * a + t\n        # Option 2: Walk the remaining distance\n        time_walk_remaining = remaining_distance * b\n        \n        return time_for_full_segments + min(time_drive_remaining, time_walk_remaining)\n\n# Read input\nd, k, a, b, t = map(int, input().split())\n\n# Calculate and print the minimal time\nprint(minimal_time(d, k, a, b, t))"}
{"solution": "import math\n\ndef find_max_gcd_sequence(n, k):\n    if n < k:\n        return [-1]\n    \n    gcd = n // k\n    remainder = n % k\n    \n    # Check if the GCD can be increased\n    while gcd > 1:\n        valid = True\n        for i in range(2, int(math.sqrt(gcd)) + 1):\n            if gcd % i == 0:\n                if remainder % i != 0:\n                    valid = False\n                    break\n                else:\n                    remainder //= i\n                    gcd //= i\n                    gcd *= i\n        if valid:\n            break\n        gcd -= 1\n    \n    if gcd < 1:\n        return [-1]\n    \n    sequence = [gcd] * k\n    for i in range(remainder):\n        sequence[i] += gcd\n    \n    return sequence\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating and printing the result\nresult = find_max_gcd_sequence(n, k)\nprint(' '.join(map(str, result)))"}
{"solution": "def count_pairs(n, m):\n    # Initialize counts for each remainder\n    counts = [0] * 5\n    result = 0\n    \n    # Count remainders for n\n    for i in range(1, n + 1):\n        counts[i % 5] += 1\n    \n    # Calculate pairs for m\n    for j in range(1, m + 1):\n        needed_remainder = (5 - j % 5) % 5\n        result += counts[needed_remainder]\n    \n    return result\n\n# Read input\nn, m = map(int, input().split())\n\n# Compute and print the result\nprint(count_pairs(n, m))"}
{"solution": "def max_beauty(n, x, a):\n    dp = [[0] * 3 for _ in range(n + 1)]\n    max_beauty = 0\n    \n    for i in range(1, n + 1):\n        dp[i][0] = max(dp[i - 1][0] + a[i - 1], 0)\n        dp[i][1] = max(dp[i - 1][0] + a[i - 1] * x, a[i - 1] * x, dp[i - 1][1] + a[i - 1] * x)\n        dp[i][2] = max(dp[i - 1][1] + a[i - 1], dp[i - 1][2] + a[i - 1], a[i - 1])\n        \n        max_beauty = max(max_beauty, dp[i][0], dp[i][1], dp[i][2])\n    \n    print(max_beauty)\n\n# Reading input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Solving and printing the output\nmax_beauty(n, x, a)"}
{"solution": "def find_kth_largest(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(m, x // i)\n        return count\n\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_less_equal(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\nn, m, k = map(int, input().split())\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    \"\"\"\n    Finds the k-th digit in the concatenated sequence of all positive integers.\n    \n    :param k: The 1-based index of the digit in the sequence.\n    :return: The k-th digit in the sequence.\n    \"\"\"\n    # Base case for k less than 10\n    if k < 10:\n        return k\n    \n    # Initialize variables to keep track of the current range and count of digits seen so far\n    base = 9  # The base count of numbers for the current range\n    digits = 1  # The number of digits in the numbers of the current range\n    while k > base * digits:\n        k -= base * digits\n        base *= 10\n        digits += 1\n    \n    # Find the actual number that contains the k-th digit\n    num = (k - 1) // digits + base // 9\n    # Find the position of the digit within the number\n    digit_pos = (k - 1) % digits\n    \n    # Return the k-th digit\n    return int(str(num)[digit_pos])\n\n# Read input\nk = int(input())\n\n# Compute and print the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "def max_bourles(n, m, r, buy_prices, sell_prices):\n    # Sort the buy and sell prices\n    buy_prices.sort()\n    sell_prices.sort(reverse=True)\n    \n    max_profit = r\n    for buy_price in buy_prices:\n        if buy_price == 0:\n            continue  # Avoid division by zero\n        shares = r // buy_price\n        for sell_price in sell_prices:\n            if sell_price <= buy_price:\n                break  # No profit can be made\n            current_profit = (shares * sell_price) + (r % buy_price)\n            max_profit = max(max_profit, current_profit)\n    \n    return max_profit\n\n# Read input\nn, m, r = map(int, input().split())\nbuy_prices = list(map(int, input().split()))\nsell_prices = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_bourles(n, m, r, buy_prices, sell_prices))"}
{"solution": "def find_original_message(t):\n    n = len(t)\n    for overlap in range(1, n // 2 + 1):\n        if t[:n - overlap] == t[overlap:]:\n            return \"YES\", t[:n - overlap]\n    return \"NO\", None\n\nt = input().strip()\nresult, s = find_original_message(t)\nprint(result)\nif result == \"YES\":\n    print(s)"}
{"solution": "def find_teams(n):\n    def solve(k):\n        total_games = 0\n        while k > 1:\n            if k % 2 == 0:\n                total_games += k // 2\n                k //= 2\n            else:\n                total_games += k * (k - 1) // 2\n                break\n        return total_games\n\n    results = []\n    current = 1\n    while True:\n        if solve(current) == n:\n            results.append(current)\n        if solve(current + 1) < n and solve(current + 2) >= n:\n            break\n        current += 1\n\n    if not results:\n        return [-1]\n    return results\n\nn = int(input())\nresults = find_teams(n)\nfor result in results:\n    print(result)"}
{"solution": "def max_antipalindromic_beauty(n, s, b):\n    from collections import Counter\n    \n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # Check if the string can be rearranged to form an antipalindromic string\n    if any(freq % 2 != 0 for freq in char_count.values()):\n        return 0  # Not possible to form an antipalindromic string\n    \n    # Sort the beauty values\n    sorted_b = sorted(b, reverse=True)\n    \n    # Initialize the beauty sum\n    beauty_sum = 0\n    \n    # Assign the characters to maximize the beauty\n    for i in range(n):\n        if s[i] != s[n - i - 1]:  # Ensure the string remains antipalindromic\n            beauty_sum += sorted_b.pop(0)\n    \n    return beauty_sum\n\n# Read input\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_antipalindromic_beauty(n, s, b))"}
{"solution": "def can_weigh(w, m):\n    # Initialize a set to store the achievable weights\n    achievable_weights = {0}\n    \n    # Iterate through the possible weights from w^0 to w^100\n    for i in range(101):\n        current_weight = w ** i\n        # Update the set with new achievable weights by adding and subtracting the current weight\n        new_weights = set()\n        for existing_weight in achievable_weights:\n            new_weights.add(existing_weight + current_weight)\n            new_weights.add(existing_weight - current_weight)\n        # Update the set of achievable weights\n        achievable_weights |= new_weights\n        \n        # Check if m is in the set of achievable weights\n        if m in achievable_weights:\n            return 'YES'\n    \n    return 'NO'\n\n# Read input\nw, m = map(int, input().split())\n\n# Output the result\nprint(can_weigh(w, m))"}
{"solution": "def find_sequence(n, k):\n    # Function to convert n to binary and find the highest bit set\n    def highest_bit_set(x):\n        bit = -1\n        while x > 0:\n            bit += 1\n            x >>= 1\n        return bit\n    \n    # Check if it's possible to represent n with k powers of 2\n    if n.bit_length() - 1 >= k:\n        return \"No\"\n    \n    sequence = [-1] * k\n    bits = []\n    temp_n = n\n    while temp_n > 0:\n        bit = highest_bit_set(temp_n)\n        bits.append(bit)\n        temp_n -= (1 << bit)\n    \n    bits.reverse()\n    remaining_k = k - len(bits)\n    \n    # Fill the sequence with the bits and remaining -1's\n    for i in range(len(bits)):\n        sequence[i] = bits[i]\n    \n    # Fill the rest with -1's to make the sequence lexicographically largest\n    for i in range(len(bits), k):\n        sequence[i] = -1\n    \n    return [\"Yes\", ' '.join(map(str, sequence))]\n\n# Read input\nn, k = map(int, input().split())\n\n# Solve and print the result\nresult = find_sequence(n, k)\nprint(result[0])\nif result[0] == \"Yes\":\n    print(result[1])"}
{"solution": "def pour_champagne(n, t):\n    # Initialize the pyramid with zeros\n    pyramid = [[0] * (i + 1) for i in range(n)]\n    \n    # Start pouring champagne from the top\n    current_level = 0\n    while t > 0:\n        # Pour champagne into the current level's glasses\n        for glass in range(len(pyramid[current_level])):\n            if t == 0:\n                break\n            pyramid[current_level][glass] += 1\n            t -= 1\n            if pyramid[current_level][glass] == 2:\n                # Overflow occurs, distribute champagne to the next level\n                if current_level + 1 < n:\n                    pyramid[current_level + 1][glass] += 1\n                    pyramid[current_level + 1][glass + 1] += 1\n                pyramid[current_level][glass] = 0\n        \n        current_level += 1\n    \n    # Count the number of completely full glasses\n    full_glasses = sum(1 for row in pyramid for glass in row if glass >= 1)\n    \n    return full_glasses\n\n# Read input\nn, t = map(int, input().split())\n\n# Calculate and print the result\nprint(pour_champagne(n, t))"}
{"solution": "def calculate_area(n, vertices):\n    if n == 1:\n        return -1\n    elif n == 2:\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        if x1 != x2 and y1 != y2:\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 3:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 4:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n\n# Read input\nn = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the area\nprint(calculate_area(n, vertices))"}
{"solution": "def min_wooden_bars(n, a, b):\n    total_sides = 2 * a + b  # Calculate the total length needed for one door frame\n    total_length_needed = 2 * total_sides  # Total length needed for two door frames\n    return -(-total_length_needed // n)  # Ceiling division to get the minimal number of bars\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\n\n# Calculate and print the result\nprint(min_wooden_bars(n, a, b))"}
{"solution": "def can_sort_array(n, a, swaps):\n    # Convert the swaps string into a list of integers for easier manipulation\n    swaps = [int(s) for s in swaps]\n    \n    # Find the starting points of segments where swaps are allowed\n    segments = []\n    start = 0\n    for i in range(n - 1):\n        if swaps[i] == 0:\n            if start < i:\n                segments.append((start, i))\n            start = i + 1\n    if start < n - 1:\n        segments.append((start, n - 1))\n    \n    # Check if each segment can be sorted independently\n    for start, end in segments:\n        # Extract the subarray\n        subarray = a[start:end+1]\n        # Check if the subarray is already sorted\n        if subarray != sorted(subarray):\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nswaps = input()\n\n# Output the result\nprint(can_sort_array(n, a, swaps))"}
{"solution": "def calculate_waiting_time(seat_info):\n    row, seat = seat_info[:-1], seat_info[-1]\n    row = int(row)\n    sequence_position = (row - 1) // 2\n    total_seconds = 0\n    \n    # Calculate time to reach the current row\n    if row % 2 == 1:\n        total_seconds += sequence_position * 6 + 3 * (sequence_position * (sequence_position + 1))\n    else:\n        total_seconds += (sequence_position + 1) * 6 + 3 * (sequence_position * (sequence_position + 1))\n    \n    # Calculate movement time to the current row\n    total_seconds += (row - 1) * 2\n    \n    # Calculate time to serve previous passengers in the current row\n    if seat in 'def':\n        total_seconds += ord(seat) - ord('d') + 3\n    else:\n        total_seconds += ord('d') - ord('a') + ord(seat) - ord('a') + 1\n    \n    return total_seconds\n\n# Read input\nseat_info = input().strip()\n\n# Calculate and print the waiting time\nprint(calculate_waiting_time(seat_info))"}
{"solution": "from itertools import accumulate\nfrom operator import mul\n\ndef convert_to_decimal(digits, base):\n    # Convert a number from a given base to decimal\n    return sum(val * (base ** idx) for idx, val in enumerate(reversed(digits)))\n\ndef compare_numbers():\n    # Read input for X\n    n, bx = map(int, input().split())\n    x_digits = list(map(int, input().split()))\n    \n    # Read input for Y\n    m, by = map(int, input().split())\n    y_digits = list(map(int, input().split()))\n    \n    # Convert X and Y to decimal\n    x_decimal = convert_to_decimal(x_digits, bx)\n    y_decimal = convert_to_decimal(y_digits, by)\n    \n    # Compare X and Y\n    if x_decimal == y_decimal:\n        print('=')\n    elif x_decimal < y_decimal:\n        print('<')\n    else:\n        print('>')\n\ncompare_numbers()"}
{"solution": "def calculate_grundy_number(nums):\n    max_val = max(nums)\n    grundy_numbers = [0] * (max_val + 1)\n    \n    # Calculate Grundy numbers for all possible values\n    for i in range(1, max_val + 1):\n        mex = set()\n        # Option 1: Decrease by x (1 \u2264 x \u2264 i)\n        for x in range(1, i + 1):\n            mex.add(grundy_numbers[i - x])\n        # Option 2: Decrease all by x (1 \u2264 x \u2264 min(nums))\n        for x in range(1, min(nums) + 1):\n            mex.add(grundy_numbers[i - x] ^ grundy_numbers[x])\n        \n        # Find the minimum excluded value (mex)\n        grundy_numbers[i] = 0\n        while grundy_numbers[i] in mex:\n            grundy_numbers[i] += 1\n    \n    # XOR all Grundy numbers to get the overall game state\n    xor_result = 0\n    for num in nums:\n        xor_result ^= grundy_numbers[num]\n    \n    return xor_result\n\ndef determine_winner(n, nums):\n    grundy_number = calculate_grundy_number(nums)\n    if grundy_number == 0:\n        return \"BitAryo\"\n    else:\n        return \"BitLGM\"\n\n# Read input\nn = int(input())\nnums = list(map(int, input().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, nums))"}
{"solution": "from math import gcd\n\ndef count_valid_decks(n, k, cards):\n    prefix_gcd = [0] * (n + 1)\n    suffix_gcd = [0] * (n + 1)\n    \n    # Calculate prefix gcds\n    for i in range(1, n + 1):\n        prefix_gcd[i] = gcd(prefix_gcd[i - 1], cards[i - 1])\n    \n    # Calculate suffix gcds\n    for i in range(n - 1, -1, -1):\n        suffix_gcd[i] = gcd(suffix_gcd[i + 1], cards[i])\n    \n    # Count valid decks\n    valid_decks = 0\n    for i in range(n):\n        if gcd(prefix_gcd[i], suffix_gcd[i + 1]) % k == 0:\n            valid_decks += 1\n    \n    return valid_decks\n\n# Read input\nn, k = map(int, input().split())\ncards = list(map(int, input().split()))\n\n# Output result\nprint(count_valid_decks(n, k, cards))"}
{"solution": "from collections import Counter\n\ndef can_distribute_balloons(n, k, s):\n    # Count the frequency of each balloon color\n    color_counts = Counter(s)\n    \n    # Check if it's possible to distribute the balloons without upsetting any friend\n    max_color_count = max(color_counts.values())\n    return \"YES\" if max_color_count <= k else \"NO\"\n\n# Read input\nn, k = map(int, input().split())\ns = input()\n\n# Solve and print the result\nprint(can_distribute_balloons(n, k, s))"}
{"solution": "# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize variables\nmin_value = min(a)\nfirst_pos = -1\nsecond_pos = -1\nmin_distance = n  # Initialize with maximum possible distance\n\n# Iterate through the array to find the closest minimums\nfor i in range(n):\n    if a[i] == min_value:\n        if first_pos != -1:\n            second_pos = i\n            min_distance = min(min_distance, second_pos - first_pos)\n        else:\n            first_pos = i\n\n# Print the distance between the two closest minimums\nprint(min_distance)"}
{"solution": "from math import gcd\n\ndef find_tie_probability(t, w, b):\n    def count_multiples(n, step):\n        return n // step + (n % step == 0)\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    # Count multiples of w and b up to t\n    multiples_w = count_multiples(t, w)\n    multiples_b = count_multiples(t, b)\n\n    # Count common multiples of w and b up to t\n    common_multiples = count_multiples(t, lcm(w, b))\n\n    # Calculate the number of tie positions\n    ties = (t + 1) - (multiples_w + multiples_b - common_multiples)\n\n    # Simplify the fraction\n    common_divisor = gcd(ties, t + 1)\n    numerator = ties // common_divisor\n    denominator = (t + 1) // common_divisor\n\n    return f\"{numerator}/{denominator}\"\n\n# Read input\nt, w, b = map(int, input().split())\n\n# Print the result\nprint(find_tie_probability(t, w, b))"}
{"solution": "def determine_vote_result(x, y, z):\n    # Check if the result is certain or uncertain based on the values of x, y, and z\n    if z == 0:\n        # If z is 0, the result is directly determined by x and y\n        if x > y:\n            return \"+\"\n        elif x < y:\n            return \"-\"\n        else:\n            return \"0\"\n    else:\n        # If z is not 0, check for uncertainty\n        max_upvotes = x + z\n        max_downvotes = y + z\n        if max_upvotes < y or max_downvotes < x:\n            # If one side can never catch up, the result is certain\n            return \"-\" if max_upvotes < y else \"+\"\n        elif x == y and z > 0:\n            # If equal votes and there are unknowns, it's uncertain\n            return \"?\"\n        else:\n            # If there are scenarios where the result can change, it's uncertain\n            return \"?\"\n\n# Read input\nx, y, z = map(int, input().split())\n\n# Output the result\nprint(determine_vote_result(x, y, z))"}
{"solution": "def min_subsegment_length(n, ops, target):\n    x, y = 0, 0\n    x_diff = 0\n    y_diff = 0\n    x_moves = [0] * (n + 1)\n    y_moves = [0] * (n + 1)\n    \n    for i, op in enumerate(ops):\n        if op == 'R': x += 1\n        elif op == 'L': x -= 1\n        elif op == 'U': y += 1\n        elif op == 'D': y -= 1\n        \n        x_diff = max(x_diff, abs(x - target[0]))\n        y_diff = max(y_diff, abs(y - target[1]))\n        \n        x_moves[i + 1] = x\n        y_moves[i + 1] = y\n    \n    if x_diff >= abs(target[0]) and y_diff >= abs(target[1]):\n        min_x = min(x_moves)\n        max_x = max(x_moves)\n        min_y = min(y_moves)\n        max_y = max(y_moves)\n        \n        if min_x <= target[0] <= max_x and min_y <= target[1] <= max_y:\n            left, right = 0, n\n            while left < right:\n                mid = (left + right) // 2\n                if x_moves[mid] >= target[0] and y_moves[mid] >= target[1]:\n                    right = mid\n                else:\n                    left = mid + 1\n            \n            while right < n and (x_moves[right] > target[0] or y_moves[right] > target[1]):\n                right += 1\n            \n            min_len = min(right - left + 1, n - left + right)\n            \n            return min_len\n        else:\n            return -1\n    else:\n        return -1\n\n# Read input\nn = int(input())\nops = input()\ntarget = list(map(int, input().split()))\n\n# Calculate and print output\nprint(min_subsegment_length(n, ops, target))"}
{"solution": "from collections import defaultdict\n\ndef solve():\n    import sys\n    input = sys.stdin.readline\n    \n    T = int(input())\n    for _ in range(T):\n        n, x = map(int, input().split())\n        s = input().strip()\n        \n        balance_s = s.count('0') - s.count('1')\n        prefix_balances = [0]\n        \n        current_balance = 0\n        for char in s:\n            current_balance += 1 if char == '0' else -1\n            prefix_balances.append(current_balance)\n        \n        balance_count = defaultdict(int)\n        for balance in prefix_balances:\n            balance_count[balance] += 1\n        \n        if balance_s == 0:\n            if x == 0:\n                print(-1)\n            else:\n                print(0)\n        else:\n            count = 0\n            target_balance = x % balance_s\n            if target_balance < 0:\n                target_balance += balance_s\n            \n            if (x - target_balance) % balance_s == 0:\n                count = balance_count[target_balance]\n            print(count)\n\nsolve()"}
{"solution": "def min_digits_to_delete(n, k):\n    # Convert the number to a string to easily manipulate individual digits\n    str_n = str(n)\n    # Calculate the divisor\n    divisor = 10 ** k\n    \n    # If n is already divisible by divisor, no digits need to be removed\n    if n % divisor == 0:\n        return 0\n    \n    # Initialize variables to track the minimum deletions and current suffix\n    min_deletions = float('inf')\n    current_suffix = ''\n    \n    # Iterate over each digit in the number\n    for i in range(len(str_n)):\n        # Build the current suffix\n        current_suffix = str_n[i] + current_suffix\n        \n        # Check if the current suffix is divisible by 10^k\n        if int(current_suffix) % divisor == 0:\n            # Update the minimum deletions if fewer deletions are needed\n            min_deletions = min(min_deletions, len(str_n) - len(current_suffix))\n    \n    # Special case: if the entire number needs to be deleted\n    if min_deletions == float('inf'):\n        return len(str_n)\n    \n    return min_deletions\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the result\nprint(min_digits_to_delete(n, k))"}
{"solution": "def calculate_questions(n, m, k, x, y):\n    # Calculate the number of students\n    num_students = n * m\n    \n    # Calculate the number of questions per full cycle\n    full_cycle_questions = 2 * (n - 1) if n > 1 else 1\n    \n    # Calculate the number of full cycles and remaining questions\n    full_cycles, remaining_questions = divmod(k, full_cycle_questions * m)\n    \n    # Calculate the maximum and minimum number of questions per student\n    max_questions = full_cycles * m\n    min_questions = max_questions\n    \n    # Adjust maximum if there are extra questions\n    if remaining_questions > 0:\n        max_questions += remaining_questions // m + 1\n    elif full_cycles % 2 == 1:\n        max_questions += 1\n    \n    # Adjust minimum if there are extra questions\n    if remaining_questions < m:\n        min_questions += remaining_questions // m\n    elif full_cycles % 2 == 0:\n        min_questions += 1\n    \n    # Calculate the number of times Sergei is asked\n    sergei_questions = full_cycles * (m if n > 1 else 1)\n    \n    # Determine the position of Sergei in the cycle\n    if n > 1:\n        if full_cycles % 2 == 0:\n            if remaining_questions >= (x - 1) * m + y:\n                sergei_questions += 1\n        else:\n            if remaining_questions >= (2 * n - x - 1) * m + y:\n                sergei_questions += 1\n    \n    return max_questions, min_questions, sergei_questions\n\n# Read input\nn, m, k, x, y = map(int, input().split())\n\n# Calculate and print the results\nmax_questions, min_questions, sergei_questions = calculate_questions(n, m, k, x, y)\nprint(max_questions, min_questions, sergei_questions)"}
{"solution": "from collections import Counter\n\ndef calculate_max_beauty(ribbon, turns):\n    ribbon_length = len(ribbon)\n    most_common_char, _ = Counter(ribbon).most_common(1)[0]\n    current_beauty = ribbon.count(most_common_char)\n    max_possible_beauty = ribbon_length\n    return max_possible_beauty if current_beauty + turns >= max_possible_beauty else current_beauty + turns\n\ndef determine_winner(turns, ribbons):\n    beauties = [calculate_max_beauty(ribbon, turns) for ribbon in ribbons]\n    max_beauty = max(beauties)\n    winners = [names[i] for i, beauty in enumerate(beauties) if beauty == max_beauty]\n    \n    if len(winners) > 1:\n        return \"Draw\"\n    else:\n        return winners[0]\n\n# Reading input\nn = int(input())\nribbons = [input() for _ in range(3)]\nnames = [\"Kuro\", \"Shiro\", \"Katie\"]\n\n# Determine and print the winner\nprint(determine_winner(n, ribbons))"}
{"solution": "def calculate_reading_days(c, v_0, v_1, a, l):\n    total_pages_read = 0\n    current_speed = v_0\n    days = 0\n    \n    while total_pages_read < c:\n        days += 1\n        if current_speed > v_1:\n            current_speed = v_1\n        else:\n            current_speed = min(v_0 + (days - 1) * a, v_1)\n        \n        if days == 1:\n            pages_read_today = current_speed\n        else:\n            pages_read_today = current_speed - l\n        \n        if total_pages_read + pages_read_today >= c:\n            pages_read_today = c - total_pages_read\n        \n        total_pages_read += pages_read_today\n    \n    return days\n\n# Reading input\nc, v_0, v_1, a, l = map(int, input().split())\n\n# Calculating and printing the result\nprint(calculate_reading_days(c, v_0, v_1, a, l))"}
{"solution": "from math import sqrt\n\ndef is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_prime_sum(n):\n    if is_prime(n):\n        print(1)\n        print(n)\n    elif is_prime(n - 2):\n        print(2)\n        print(2, n - 2)\n    else:\n        for i in range(2, n // 2 + 1):\n            if is_prime(i) and is_prime(n - i - 2) and is_prime(2):\n                print(3)\n                print(2, i, n - i - 2)\n                break\n\nn = int(input())\nfind_prime_sum(n)"}
{"solution": "def can_wipe_out_walls(rows, cols, grid):\n    wall_counts = [0] * (rows + cols)\n    wall_indices = set()\n    \n    # Count walls in each row and column\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '*':\n                wall_counts[i] += 1\n                wall_counts[rows + j] += 1\n                wall_indices.add((i, j))\n                \n    total_walls = sum(wall_counts) // 2\n    \n    # Check each cell\n    for i in range(rows):\n        for j in range(cols):\n            if (wall_counts[i] + wall_counts[rows + j] - (1 if (i, j) in wall_indices else 0)) == total_walls:\n                return \"YES\", i + 1, j + 1\n    \n    return \"NO\", None, None\n\n# Read input\nn, m = map(int, input().split())\ndepot = [input() for _ in range(n)]\n\n# Solve and print output\nresult, x, y = can_wipe_out_walls(n, m, depot)\nprint(result)\nif result == \"YES\":\n    print(x, y)"}
{"solution": "def min_burles(n, m, a, b):\n    remainder = n % m\n    build_cost = (m - remainder) * a if remainder > 0 else 0\n    demolish_cost = remainder * b if remainder < m else 0\n    if b <= a:\n        return demolish_cost\n    else:\n        return min(build_cost, demolish_cost)\n\n# Example usage\nn, m, a, b = map(int, input().split())\nprint(min_burles(n, m, a, b))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize variables\nmax_odd_sum = float('-inf')\nmax_even_sum = 0\nhas_odd = False\n\nfor num in a:\n    if num % 2 == 1:\n        has_odd = True\n        max_odd_sum = max(max_odd_sum, max_even_sum + num)\n    max_even_sum = max(max_even_sum + num, 0)\n\n# Ensure there is at least one odd number\nif not has_odd:\n    max_odd_sum = max(a)\n\nprint(max_odd_sum)"}
{"solution": "from collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_playlists(n, T, songs):\n    dp = [[[0 for _ in range(4)] for _ in range(T + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 1\n    \n    for i in range(1, n + 1):\n        ti, gi = songs[i - 1]\n        for j in range(T + 1):\n            for k in range(4):\n                dp[i][j][k] = dp[i - 1][j][k]\n                if j >= ti:\n                    dp[i][j][gi] += dp[i - 1][j - ti][k] * (1 if k != 0 else 3 - (3 if gi == 1 else 2))\n                    dp[i][j][gi] %= MOD\n    \n    result = sum(dp[n][T]) % MOD\n    return result\n\n# Reading input\nn, T = map(int, input().split())\nsongs = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculating and printing the result\nprint(count_playlists(n, T, songs))"}
{"solution": "from math import gcd\nMOD = 10**9 + 7\n\ndef mod_inverse(x):\n    return pow(x, MOD - 2, MOD)\n\ndef expected_length(m):\n    dp = [0] * (m + 1)\n    dp[1] = 1\n    total_gcd = [0] * (m + 1)\n    total_gcd[1] = 1\n    for i in range(2, m + 1):\n        dp[i] = (2 * total_gcd[i - 1] + i) % MOD\n        total_gcd[i] = (total_gcd[i - 1] * 2 * i + i * (i + 1) // 2) % MOD\n        for j in range(1, i):\n            if gcd(i, j) == 1:\n                dp[i] -= dp[j]\n                dp[i] %= MOD\n        dp[i] = (dp[i] + MOD) % MOD\n        dp[i] = (dp[i] * mod_inverse(i)) % MOD\n    result = sum(dp) % MOD\n    return (result * mod_inverse(m)) % MOD\n\nm = int(input())\nprint(expected_length(m))"}
{"solution": "from math import gcd\n\ndef count_good_pairs(l, r, x, y):\n    count = 0\n    # Check if the conditions for GCD and LCM are valid\n    if y % x != 0:\n        return 0\n    \n    k = y // x\n    for a in range(max(l, x), min(r + 1, x * k) + 1, x):\n        b_start = max(l, a * k // gcd(a, k))\n        b_end = min(r, a * k // gcd(a, k)) + 1\n        if b_start < b_end:\n            count += (b_end - b_start)\n    \n    return count\n\n# Read input\nl, r, x, y = map(int, input().split())\n\n# Calculate and print the result\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "from math import gcd\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef find_smallest_k(a, b):\n    # Calculate the difference\n    diff = abs(a - b)\n    \n    # Calculate the initial gcd\n    initial_gcd = gcd(a, b)\n    \n    # Find the smallest k such that gcd(a+k, b+k) is maximized\n    for k in range(min(a, b) + 1):\n        if gcd(a + k, b + k) > initial_gcd:\n            return k\n    \n    # If no k found, return 0\n    return 0\n\n# Read input\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(find_smallest_k(a, b))"}
{"solution": "def min_additional_marks(n, k, marks):\n    current_sum = sum(marks)\n    target_avg = k - 1 + 0.5  # Target average to round up to k\n    \n    # Calculate the minimum number of marks needed to reach the target average\n    min_marks_needed = max(0, int((target_avg * (n + 1) - current_sum + 0.5) / k))\n    \n    return min_marks_needed\n\n# Read input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_additional_marks(n, k, marks))"}
{"solution": "from math import ceil\n\ndef find_divisor(arr):\n    n = len(arr)\n    required_positives = ceil(n / 2)\n    pos_count = sum(1 for num in arr if num > 0)\n    \n    if pos_count >= required_positives:\n        return 1\n    \n    for d in range(-1000, 1001):\n        if d == 0:\n            continue\n        new_pos_count = sum(1 for num in arr if num / d > 0)\n        if new_pos_count >= required_positives:\n            return d\n    \n    return 0\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Solve and print the result\nprint(find_divisor(arr))"}
{"solution": "def max_nines_pairs(n):\n    # Calculate the maximum number of nines at the end of the sum\n    def max_nines(x):\n        count = 0\n        while x % 10 == 9:\n            count += 1\n            x //= 10\n        return count\n    \n    # Initialize variables\n    max_count = 0\n    pairs_count = 0\n    \n    # Iterate through possible pairs\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            current_sum = i + j\n            current_nines = max_nines(current_sum)\n            \n            # Update max_count if a new maximum is found\n            if current_nines > max_count:\n                max_count = current_nines\n                pairs_count = 1\n            elif current_nines == max_count:\n                pairs_count += 1\n    \n    return pairs_count\n\n# Read input\nn = int(input())\n\n# Compute and print the result\nprint(max_nines_pairs(n))"}
{"solution": "from math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef find_min_minutes(a1, b1, a2, b2):\n    area1 = a1 * b1\n    area2 = a2 * b2\n    \n    # Check if it's impossible to equalize the areas\n    if area1 % 3 != area2 % 3:\n        return -1, None, None\n    \n    # Calculate the least common multiple of the two areas\n    target_area = lcm(area1, area2)\n    \n    minutes1 = 0\n    minutes2 = 0\n    \n    # Calculate minutes needed for the first bar\n    while area1 != target_area:\n        if area1 % 2 == 0:\n            area1 //= 2\n            minutes1 += 1\n        elif area1 % 3 == 0:\n            area1 //= 3\n            minutes1 += 1\n        else:\n            break\n    \n    # Calculate minutes needed for the second bar\n    while area2 != target_area:\n        if area2 % 2 == 0:\n            area2 //= 2\n            minutes2 += 1\n        elif area2 % 3 == 0:\n            area2 //= 3\n            minutes2 += 1\n        else:\n            break\n    \n    # Check if it was possible to reach the target area for both bars\n    if area1 != target_area or area2 != target_area:\n        return -1, None, None\n    \n    total_minutes = max(minutes1, minutes2)\n    \n    # Determine the final sizes of the bars\n    final_a1, final_b1 = a1, b1\n    final_a2, final_b2 = a2, b2\n    \n    # Adjust sizes based on the target area\n    if minutes1 > minutes2:\n        factor1 = target_area // (final_a1 * final_b1)\n        final_a1 *= factor1\n        final_b1 *= factor1\n    else:\n        factor2 = target_area // (final_a2 * final_b2)\n        final_a2 *= factor2\n        final_b2 *= factor2\n    \n    return total_minutes, (final_a1, final_b1), (final_a2, final_b2)\n\n# Read input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\n# Solve and print output\nresult = find_min_minutes(a1, b1, a2, b2)\nif result == -1:\n    print(-1)\nelse:\n    minutes, size1, size2 = result\n    print(minutes)\n    print(*size1)\n    print(*size2)"}
{"solution": "def determine_winner(x_p, y_p, x_v, y_v):\n    # Polycarp's moves\n    polycarp_moves = x_p + y_p\n    # Vasiliy's moves\n    vasiliy_moves = max(x_v, y_v)\n    \n    # Determine the winner based on the minimum number of moves required to reach (0, 0)\n    if polycarp_moves < vasiliy_moves:\n        return \"Polycarp\"\n    else:\n        return \"Vasiliy\"\n\n# Read input\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Output the winner\nprint(determine_winner(x_p, y_p, x_v, y_v))"}
{"solution": "# Import necessary library\nfrom calendar import monthrange\n\ndef calculate_calendar_columns(month, start_weekday):\n    \"\"\"\n    Calculate the number of columns needed for a monthly calendar.\n    \n    :param month: Integer representing the month (1-12)\n    :param start_weekday: Integer representing the weekday of the first day of the month (1-Monday, 7-Sunday)\n    :return: Number of columns needed for the calendar\n    \"\"\"\n    # Adjust start_weekday to match Python's 0-based indexing (0-Monday, 6-Sunday)\n    start_weekday = (start_weekday - 1) % 7\n    \n    # Get the number of days in the given month\n    num_days = monthrange(2023, month)[1]\n    \n    # Calculate the total number of days until the first day of the month\n    days_until_first = start_weekday\n    \n    # Calculate the total number of days including the partial week\n    total_days = days_until_first + num_days\n    \n    # Calculate the number of full weeks and the remaining days\n    full_weeks = total_days // 7\n    remaining_days = total_days % 7\n    \n    # Determine the number of columns needed\n    if remaining_days > 0:\n        columns_needed = full_weeks + 1\n    else:\n        columns_needed = full_weeks\n    \n    return columns_needed\n\n# Read input\nm, d = map(int, input().split())\n\n# Calculate and print the number of columns needed\nprint(calculate_calendar_columns(m, d))"}
{"solution": "def count_years_with_one_zero(a, b):\n    def count_up_to(n):\n        if n == 0:\n            return 0\n        \n        length = len(bin(n)) - 2\n        if length <= 1:\n            return 1 if n == 1 else 0\n        \n        result = 0\n        for i in range(length - 1):\n            result += 2 ** i\n        result += (n + 1 - 2 ** (length - 1)) // (2 ** (length - 1))\n        \n        return result\n    \n    return count_up_to(b) - count_up_to(a - 1)\n\na, b = map(int, input().split())\nprint(count_years_with_one_zero(a, b))"}
{"solution": "def minimal_layers(N):\n    return (N * (N + 1)) // 2\n\nN = int(input())\nprint(minimal_layers(N))"}
{"solution": "from itertools import combinations\nfrom math import factorial\n\ndef count_ways(n, k, S, cubes):\n    # Precompute factorials for efficiency\n    precomputed_factorials = {cube: factorial(cube) for cube in cubes}\n    \n    def dfs(index, remaining_k, current_sum, target):\n        if current_sum == target:\n            return 1\n        if index >= n or current_sum > target:\n            return 0\n        \n        # Skip current cube\n        ways = dfs(index + 1, remaining_k, current_sum, target)\n        \n        # Include current cube without sticker\n        ways += dfs(index + 1, remaining_k, current_sum + cubes[index], target)\n        \n        # Include current cube with sticker if possible\n        if remaining_k > 0:\n            ways += dfs(index + 1, remaining_k - 1, current_sum + precomputed_factorials[cubes[index]], target)\n        \n        return ways\n    \n    return dfs(0, k, 0, S)\n\n# Read input\nn, k, S = map(int, input().split())\ncubes = list(map(int, input().split()))\n\n# Compute and print the result\nprint(count_ways(n, k, S, cubes))"}
{"solution": "from collections import defaultdict\n\ndef can_transform(n, k, a):\n    powers = defaultdict(int)\n    for value in a:\n        if value == 0:\n            continue\n        current = value\n        power_sum = 0\n        while current > 0:\n            if current % k != 0 and current != 1:\n                return \"NO\"\n            power_sum += 1\n            current //= k\n        powers[power_sum] += 1\n    \n    for count in powers.values():\n        if count > 1:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Reading input\nT = int(input())\nfor _ in range(T):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    # Printing output\n    print(can_transform(n, k, a))"}
{"solution": "def d(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count\n\ndef calculate_divisor_sum(a, b, c):\n    MOD = 1073741824\n    total_sum = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                total_sum += d(i * j * k)\n                total_sum %= MOD\n    return total_sum\n\n# Read input\na, b, c = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_divisor_sum(a, b, c))"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    neighbors = []\n    idx = state.index('X')\n    moves = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    for dx, dy in moves:\n        new_idx = idx + dx + dy * 2\n        if 0 <= new_idx < 4:\n            new_state = list(state)\n            new_state[idx], new_state[new_idx] = new_state[new_idx], new_state[idx]\n            neighbors.append(''.join(new_state))\n    return neighbors\n\ndef bfs(start):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        current = queue.popleft()\n        for neighbor in get_neighbors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return visited\n\ndef can_be_same_configuration(bessie, elsie):\n    bessie_start = ''.join(bessie)\n    elsie_start = ''.join(elsie)\n    \n    bessie_reachable = bfs(bessie_start)\n    elsie_reachable = bfs(elsie_start)\n    \n    return not bessie_reachable.isdisjoint(elsie_reachable)\n\n# Input reading\nbessie = [input().strip() for _ in range(2)]\nelsie = [input().strip() for _ in range(2)]\n\nif can_be_same_configuration(bessie, elsie):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_decimal_number(n, k):\n    def convert_to_decimal(num_str, base):\n        num_str = str(num_str)\n        length = len(num_str)\n        decimal_num = 0\n        for i in range(length):\n            decimal_num += int(num_str[i]) * (base ** (length - i - 1))\n        return decimal_num\n    \n    left, right = 0, 10**18\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if convert_to_decimal(k, n) > mid:\n            right = mid\n        else:\n            left = mid\n    \n    return left if convert_to_decimal(k, n) == left else right\n\n# Reading input\nn = int(input())\nk = input()\n\n# Calculating and printing the result\nprint(min_decimal_number(n, k))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ndef is_unimodal(arr):\n    increasing = False\n    constant = True\n    decreasing = False\n    \n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            if decreasing:\n                return False\n            increasing = True\n            constant = False\n        elif arr[i] < arr[i - 1]:\n            if not increasing:\n                return False\n            decreasing = True\n        else:  # Constant\n            if decreasing:\n                return False\n            if increasing:\n                constant = False\n                \n    return True\n\nif is_unimodal(a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def max_value_in_paths(n, k):\n    def count_occurrences(y):\n        count, x = 0, 1\n        while x <= n:\n            if y >= x:\n                count += min(y + 1, (n + 1) // 2) - x\n                x *= 2\n            else:\n                break\n        return count\n\n    low, high = 1, n\n    result = 0\n\n    while low <= high:\n        mid = (low + high) // 2\n        if count_occurrences(mid) >= k:\n            result = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return result\n\n# Reading input\nn, k = map(int, input().split())\n\n# Computing and printing the result\nprint(max_value_in_paths(n, k))"}
{"solution": "def determine_pocket(n, m, x, y, vx, vy):\n    if vx == 0 and vy == 0:\n        return -1  # Ball does not move\n    \n    # Check if the ball is initially in a pocket\n    if x in [0, n] or y in [0, m]:\n        return -1\n    \n    # Calculate the next intersection points\n    if vx != 0:\n        t = (n - x) // abs(vx) if vx > 0 else -x // abs(vx)\n        y_next = y + vy * t\n        if 0 <= y_next < m:\n            x += vx * t\n        else:\n            t = (m - y) // abs(vy) if vy > 0 else -y // abs(vy)\n            x_next = x + vx * t\n            if 0 <= x_next < n:\n                y += vy * t\n            else:\n                return -1\n    else:\n        t = (m - y) // abs(vy) if vy > 0 else -y // abs(vy)\n        y += vy * t\n    \n    # Determine the pocket based on the final coordinates\n    if x == n and 0 <= y < m:\n        return n, m\n    elif x == 0 and 0 <= y < m:\n        return 0, y\n    elif 0 <= x < n and y == m:\n        return x, m\n    elif 0 <= x < n and y == 0:\n        return x, 0\n    else:\n        return -1\n\n# Read input\nn, m, x, y, vx, vy = map(int, input().split())\n\n# Determine and print the pocket\nresult = determine_pocket(n, m, x, y, vx, vy)\nprint(*result)"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    # Check if two rectangles (a2, b2) and (a3, b3) can fit in (a1, b1)\n    def fits(w1, h1, w2, h2, W, H):\n        return (w1 + w2 <= W and max(h1, h2) <= H) or (h1 + h2 <= H and max(w1, w2) <= W)\n    \n    # Check all combinations of orientations\n    if (fits(a2, b2, a3, b3, a1, b1) or fits(b2, a2, a3, b3, a1, b1) or\n        fits(a2, b2, b3, a3, a1, b1) or fits(b2, a2, b3, a3, a1, b1) or\n        fits(a3, b3, a2, b2, a1, b1) or fits(b3, a3, a2, b2, a1, b1) or\n        fits(a3, b3, b2, a2, a1, b1) or fits(b3, a3, b2, a2, a1, b1)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\n# Output result\nprint(can_place_paintings(a1, b1, a2, b2, a3, b3))"}
{"solution": "def count_good_terms(b1, q, l, bad_integers):\n    if q == 0:\n        if abs(b1) <= l and b1 not in bad_integers:\n            return \"inf\"\n        else:\n            return 0\n    \n    count = 0\n    current_term = b1\n    seen = set()\n    \n    while abs(current_term) <= l and current_term not in bad_integers and current_term not in seen:\n        seen.add(current_term)\n        count += 1\n        current_term *= q\n    \n    if current_term in seen:\n        return \"inf\"\n    \n    return count\n\n# Reading input\nb1, q, l, m = map(int, input().split())\nbad_integers = set(map(int, input().split()))\n\n# Calculating and printing the result\nresult = count_good_terms(b1, q, l, bad_integers)\nprint(result)"}
{"solution": "def find_smallest_frame(matrix):\n    n, m = len(matrix), len(matrix[0])\n    \n    # Find top-left and bottom-right corners of the white pixels\n    top, left, bottom, right = n, m, 0, 0\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == 'w':\n                top = min(top, i)\n                left = min(left, j)\n                bottom = max(bottom, i)\n                right = max(right, j)\n    \n    # Check if the white pixels form a valid frame\n    valid_frame = True\n    for i in range(top, bottom + 1):\n        if matrix[i][left] != 'w' or matrix[i][right] != 'w':\n            valid_frame = False\n            break\n    for j in range(left, right + 1):\n        if matrix[top][j] != 'w' or matrix[bottom][j] != 'w':\n            valid_frame = False\n            break\n    \n    if not valid_frame:\n        return -1\n    \n    # Draw the frame\n    for i in range(top, bottom + 1):\n        for j in range(left, right + 1):\n            if (i == top or i == bottom) or (j == left or j == right):\n                if matrix[i][j] != 'w':\n                    matrix[i] = matrix[i][:j] + '+' + matrix[i][j+1:]\n    \n    # Convert matrix back to string\n    result = '\\n'.join(matrix)\n    return result\n\n# Read input\nn, m = map(int, input().split())\nmatrix = [input() for _ in range(n)]\n\n# Solve and print output\nresult = find_smallest_frame(matrix)\nprint(result)"}
{"solution": "def can_spend_exactly(n, a, b):\n    for x in range(n // a + 1):\n        y = (n - a * x) / b\n        if y.is_integer() and y >= 0:\n            return \"YES\\n{} {}\".format(x, int(y))\n    return \"NO\"\n\n# Reading input\nn = int(input())\na = int(input())\nb = int(input())\n\n# Processing and printing output\nprint(can_spend_exactly(n, a, b))"}
{"solution": "def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\ns = int(input())\nprint(number_to_words(s))"}
{"solution": "def max_elements_to_erase(n, arr):\n    # Edge case: if the array has only one element, no elements can be erased\n    if n == 1:\n        return 0\n    \n    # Find the minimum number of elements needed to reconstruct the array\n    min_needed = 2  # At least two elements are needed to determine the sequence\n    if arr[0] != 1 or arr[-1] != 1000:\n        min_needed = 1  # If the array does not start from 1 or end at 1000, one element is enough\n    \n    # Calculate the maximum number of consecutive elements that can be erased\n    max_erase = n - min_needed\n    \n    # Check if erasing the first or last elements violates the conditions\n    if arr[0] != 1:\n        max_erase = max(max_erase, n - 2)\n    if arr[-1] != 1000:\n        max_erase = max(max_erase, n - 2)\n    \n    return min(max_erase, n - 1)  # Ensure the maximum number of elements to erase is valid\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output the result\nprint(max_elements_to_erase(n, arr))"}
{"solution": "# Import necessary packages\nfrom itertools import accumulate\n\ndef find_equator_day(n, problems):\n    # Calculate the cumulative sum of problems solved each day\n    cumulative_problems = list(accumulate(problems))\n    \n    # Total number of problems to be solved\n    total_problems = cumulative_problems[-1]\n    \n    # Find the day when Polycarp solves half or more of all the problems\n    for day in range(n):\n        if cumulative_problems[day] >= total_problems / 2:\n            return day + 1  # Days are 1-indexed\n\n# Read input\nn = int(input())\nproblems = list(map(int, input().split()))\n\n# Output the result\nprint(find_equator_day(n, problems))"}
{"solution": "from collections import defaultdict, deque\n\ndef bfs(graph, start, target, piece):\n    queue = deque([(start, 0, 0)])  # (position, steps, replacements)\n    visited = {start}\n    \n    while queue:\n        pos, steps, replacements = queue.popleft()\n        if pos == target:\n            return steps, replacements\n        \n        for next_pos in graph[piece][pos]:\n            if next_pos not in visited:\n                visited.add(next_pos)\n                queue.append((next_pos, steps + 1, replacements))\n                \n        # Try replacing the piece\n        for alt_piece in ('knight', 'bishop', 'rook'):\n            if alt_piece != piece:\n                queue.append((pos, steps + 1, replacements + 1))\n\ndef build_graph(N, board):\n    graph = {'knight': defaultdict(list), 'bishop': defaultdict(list), 'rook': defaultdict(list)}\n    \n    def add_edges(piece, pos, deltas):\n        for dx, dy in deltas:\n            x, y = pos\n            while 0 <= x + dx < N and 0 <= y + dy < N:\n                x, y = x + dx, y + dy\n                graph[piece][board[x][y]].append(board[x][y])\n                if piece == 'bishop' or piece == 'rook':\n                    break\n    \n    knight_deltas = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n    bishop_deltas = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\n    rook_deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    for i in range(N):\n        for j in range(N):\n            add_edges('knight', (i, j), knight_deltas)\n            add_edges('bishop', (i, j), bishop_deltas)\n            add_edges('rook', (i, j), rook_deltas)\n    \n    return graph\n\ndef solve_chess_puzzle(N, board):\n    graph = build_graph(N, board)\n    start = board[0][0]\n    target = board[N-1][N-1]\n    \n    min_steps = float('inf')\n    min_replacements = float('inf')\n    \n    for piece in ('knight', 'bishop', 'rook'):\n        steps, replacements = bfs(graph, start, target, piece)\n        if steps < min_steps or (steps == min_steps and replacements < min_replacements):\n            min_steps, min_replacements = steps, replacements\n    \n    return min_steps, min_replacements\n\n# Reading input\nN = int(input())\nboard = [list(map(int, input().split())) for _ in range(N)]\n\n# Solving the puzzle\nmin_steps, min_replacements = solve_chess_puzzle(N, board)\n\n# Printing the output\nprint(min_steps, min_replacements)"}
{"solution": "from collections import deque\n\ndef min_time_to_reach(n, m, k, a, b):\n    def apartment_to_coords(apartment):\n        return (apartment - 1) // (m * k), ((apartment - 1) % (m * k)) // k, (apartment - 1) % k\n\n    edward_building, edward_floor, _ = apartment_to_coords(a)\n    natasha_building, natasha_floor, _ = apartment_to_coords(b)\n\n    # Calculate building transition time\n    clockwise_building_distance = abs(edward_building - natasha_building)\n    counterclockwise_building_distance = n - clockwise_building_distance\n    building_transition_time = min(clockwise_building_distance, counterclockwise_building_distance) * 15\n\n    # Elevator and stairs time calculation\n    def calculate_time(curr_building, curr_floor, target_building, target_floor):\n        # Time to go to ground floor\n        time_to_ground = 10 + curr_floor\n        # Time to reach target building\n        total_time = time_to_ground + building_transition_time\n        # Time to reach target floor using elevator\n        total_time += 10 + abs(target_floor)\n        # Time to reach target floor using stairs\n        stairs_time = abs(curr_floor - target_floor) * 5\n        # Choose minimum time\n        return min(total_time, stairs_time)\n\n    return calculate_time(edward_building, edward_floor, natasha_building, natasha_floor)\n\n# Reading input\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculating and printing output\nprint(min_time_to_reach(n, m, k, a, b))"}
{"solution": "def is_divisible_by_64(binary_str):\n    # Check if the string can be transformed to be divisible by 64\n    # A binary number is divisible by 64 if its last 6 bits are zeros\n    # Remove all '1's except the leading one (if any)\n    cleaned_str = binary_str.lstrip('1')\n    \n    # Check if the remaining string is all zeros and at least 6 zeros long\n    return len(cleaned_str) >= 6 and '1' not in cleaned_str\n\n# Read input\nbinary_str = input()\n\n# Output result\nprint('yes' if is_divisible_by_64(binary_str) else 'no')"}
{"solution": "from collections import defaultdict\n\ndef next_char(c):\n    return 'a' if c == 'z' else chr(ord(c) + 1)\n\ndef find_solution(s):\n    alphabet_count = defaultdict(int)\n    for char in s:\n        alphabet_count[char] += 1\n    \n    result = []\n    current_char = 'a'\n    \n    while len(result) < 26:\n        found = False\n        for char in sorted(alphabet_count.keys()):\n            if char >= current_char:\n                result.append(char)\n                alphabet_count[char] -= 1\n                if alphabet_count[char] == 0:\n                    del alphabet_count[char]\n                found = True\n                break\n        if not found:\n            return -1\n        current_char = next_char(current_char)\n    \n    return ''.join(result)\n\ns = input()\nprint(find_solution(s))"}
{"solution": "from math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef max_expected_fish(n, m, r, k):\n    total_positions = (n - r + 1) * (m - r + 1)\n    \n    def compute_expected_value(row_overlap, col_overlap):\n        valid_positions = (n - r + 1 - row_overlap) * (m - r + 1 - col_overlap)\n        area = (r - row_overlap) * (r - col_overlap)\n        return (area * valid_positions) / total_positions\n    \n    max_expected = 0\n    for row_overlap in range(r + 1):\n        for col_overlap in range(r + 1):\n            area = (r - row_overlap) * (r - col_overlap)\n            if k < area:\n                break\n            max_expected = max(max_expected, compute_expected_value(row_overlap, col_overlap))\n    \n    # Binary search to find the optimal overlap\n    low, high = 0, min(n, m)\n    while low <= high:\n        mid = (low + high) // 2\n        common_area = (r - mid) ** 2\n        if k < common_area:\n            high = mid - 1\n        else:\n            max_expected = max(max_expected, compute_expected_value(mid, mid))\n            low = mid + 1\n    \n    return max_expected\n\n# Reading input\nn, m, r, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(max_expected_fish(n, m, r, k))"}
{"solution": "def max_product_array(n, a):\n    # Count negative and non-positive numbers\n    count_negative = sum(1 for x in a if x < 0)\n    count_non_positive = sum(1 for x in a if x <= 0)\n    \n    # If there are no negative numbers or exactly one negative number and no zeros, invert all\n    if count_negative == 0 or (count_negative == 1 and count_non_positive == 1):\n        a = [-x - 1 for x in a]\n    else:\n        # Otherwise, only invert non-positive numbers\n        a = [-x - 1 if x <= 0 else x for x in a]\n    \n    return a\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Compute and print the result\nresult = max_product_array(n, a)\nprint(*result)"}
{"solution": "import math\n\ndef find_kth_divisor(n, k):\n    def enough_divisors(x):\n        count, max_divisor = 0, min(int(math.sqrt(n)), n // x)\n        for i in range(1, max_divisor + 1):\n            if n % i == 0:\n                count += 1\n                if i >= x:\n                    break\n                if n // i != i and n // i < x:\n                    count += 1\n        return count >= k\n\n    low, high = 1, n + 1\n    while low < high:\n        mid = (low + high) // 2\n        if enough_divisors(mid):\n            high = mid\n        else:\n            low = mid + 1\n    \n    if low == n + 1 or not enough_divisors(low):\n        return -1\n    else:\n        return low\n\n# Read input\nn, k = map(int, input().split())\n\n# Compute and print the result\nprint(find_kth_divisor(n, k))"}
{"solution": "def max_number(n, cubes):\n    # Initialize counts for digits 1, 2, 3, 4, 5, 7, and 8\n    count_1 = count_2 = count_3 = count_4 = count_5 = count_7 = count_8 = 0\n    \n    # Count occurrences of each digit\n    for cube in cubes:\n        for digit in cube:\n            if digit == 1:\n                count_1 += 1\n            elif digit == 2:\n                count_2 += 1\n            elif digit == 3:\n                count_3 += 1\n            elif digit == 4:\n                count_4 += 1\n            elif digit == 5:\n                count_5 += 1\n            elif digit == 7:\n                count_7 += 1\n            elif digit == 8:\n                count_8 += 1\n    \n    # Check if 0 can be used as 1 (if needed)\n    count_0_as_1 = sum(1 for cube in cubes for digit in cube if digit == 0)\n    \n    # Determine the maximum number that can be formed\n    min_count = min(count_1 + count_0_as_1, count_2, count_3, count_4, count_5, count_7, count_8)\n    \n    # Calculate the maximum number\n    max_num = 0\n    while True:\n        max_num += 1\n        str_num = str(max_num)\n        \n        # Check if the current number can be formed\n        valid = True\n        for digit in str_num:\n            if digit == '6' or digit == '9':\n                continue\n            if int(digit) == 1 and count_1 < str_num.count('1') - count_0_as_1:\n                valid = False\n                break\n            if int(digit) != 1 and str_num.count(digit) > eval(f\"count_{digit}\"):\n                valid = False\n                break\n        \n        if not valid:\n            break\n    \n    return max_num - 1\n\n# Read input\nn = int(input())\ncubes = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_number(n, cubes))"}
{"solution": "def k_rounding(n, k):\n    if k == 0:\n        return n\n    power_of_5 = 0\n    power_of_2 = 0\n    \n    # Calculate the number of 5s in the factorization of n\n    while n % 5 == 0:\n        n //= 5\n        power_of_5 += 1\n    \n    # Calculate the number of 2s in the factorization of n\n    while n % 2 == 0:\n        n //= 2\n        power_of_2 += 1\n    \n    # Determine the minimum power needed to achieve k zeros\n    min_power = max(k - power_of_5, k - power_of_2)\n    \n    # Calculate the result\n    result = n * (2 ** max(0, min_power - power_of_2)) * (5 ** max(0, min_power - power_of_5))\n    return result * (10 ** max(0, k - min_power))\n\n# Read input\nn, k = map(int, input().split())\n\n# Compute and print the k-rounding of n\nprint(k_rounding(n, k))"}
{"solution": "def transform_matrix(n, m, A):\n    operations = []\n    B = [[0] * m for _ in range(n)]\n    \n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                operations.append((i + 1, j + 1))\n                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1\n    \n    for i in range(n):\n        for j in range(m):\n            if A[i][j] != B[i][j]:\n                return -1\n    \n    return operations\n\n# Input reading\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\n# Process the transformation\nresult = transform_matrix(n, m, A)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for x, y in result:\n        print(x, y)"}
{"solution": "from itertools import accumulate\n\ndef solve(r, s, p):\n    def compute_prob(x, y):\n        if x == 0:\n            return 0\n        if y == 0:\n            return 1\n        return (x / (x + y)) * compute_prob(x, y - 1) + (y / (x + y)) * compute_prob(x - 1, y)\n\n    total = r + s + p\n    prob_r = compute_prob(r, s + p)\n    prob_s = compute_prob(s, r + p)\n    prob_p = compute_prob(p, r + s)\n\n    # Normalize the probabilities\n    normalization_factor = prob_r + prob_s + prob_p\n    prob_r /= normalization_factor\n    prob_s /= normalization_factor\n    prob_p /= normalization_factor\n\n    return prob_r, prob_s, prob_p\n\n# Read input\nr, s, p = map(int, input().split())\n\n# Calculate and print the probabilities\nprob_r, prob_s, prob_p = solve(r, s, p)\nprint(f\"{prob_r:.15f} {prob_s:.15f} {prob_p:.15f}\")"}
{"solution": "def calculate_together_time(l1, r1, l2, r2, k):\n    # Find the intersection of the two intervals\n    start = max(l1, l2)\n    end = min(r1, r2)\n    \n    # If there is no intersection, return 0\n    if start > end:\n        return 0\n    \n    # Adjust for the minute when Sonya prinks\n    if start <= k <= end:\n        start = k + 1\n    \n    # Calculate the effective time they can spend together\n    effective_start = max(start, k + 1)\n    \n    # Return the duration of the intersection\n    return max(0, end - effective_start + 1)\n\n# Read input\nl1, r1, l2, r2, k = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_together_time(l1, r1, l2, r2, k))"}
{"solution": "from typing import List, Tuple\nimport sys\n\ndef cross(a: Tuple[int, int], b: Tuple[int, int]) -> int:\n    return a[0] * b[1] - a[1] * b[0]\n\ndef ccw(p: Tuple[int, int], q: Tuple[int, int], r: Tuple[int, int]) -> int:\n    a = (q[0] - p[0], q[1] - p[1])\n    b = (r[0] - p[0], r[1] - p[1])\n    return cross(a, b)\n\ndef intersect(p1: Tuple[int, int], p2: Tuple[int, int], q1: Tuple[int, int], q2: Tuple[int, int]) -> bool:\n    return ccw(p1, p2, q1) * ccw(p1, p2, q2) <= 0 and ccw(q1, q2, p1) * ccw(q1, q2, p2) <= 0\n\ndef find_intersection(p1: Tuple[int, int], p2: Tuple[int, int], q1: Tuple[int, int], q2: Tuple[int, int]) -> Tuple[int, int]:\n    det = (p2[0] - p1[0]) * (q2[1] - q1[1]) - (p2[1] - p1[1]) * (q2[0] - q1[0])\n    if det == 0:\n        return (0, 0)\n    det_inv = pow(det, -1, 1_000_000_007)\n    x = ((p2[0] - p1[0]) * (q2[0] * q1[1] - q2[1] * q1[0])) % 1_000_000_007 * det_inv % 1_000_000_007\n    y = ((q2[0] - q1[0]) * (p2[0] * p1[1] - p2[1] * p1[0])) % 1_000_000_007 * det_inv % 1_000_000_007\n    return (x, y)\n\ndef convex_hull(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    points = sorted(set(points))\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and ccw(lower[-2], lower[-1], p) < 0:\n            lower.pop()\n        lower.append(p)\n    \n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and ccw(upper[-2], upper[-1], p) < 0:\n            upper.pop()\n        upper.append(p)\n    \n    return lower[:-1] + upper[:-1]\n\ndef compute_area(polygon: List[Tuple[int, int]]) -> int:\n    n = len(polygon)\n    area = 0\n    for i in range(n):\n        j = (i + 1) % n\n        area += polygon[i][0] * polygon[j][1]\n        area -= polygon[j][0] * polygon[i][1]\n    return abs(area) // 2\n\ndef main():\n    N, M = map(int, input().split())\n    vertical_lines = [tuple(map(int, input().split())) for _ in range(N)]\n    horizontal_lines = [tuple(map(int, input().split())) for _ in range(M)]\n\n    intersections = [(0, 0)]\n    for i in range(N):\n        for j in range(M):\n            v_start, v_end, v_x = vertical_lines[i]\n            h_y1, h_x1, h_x2 = horizontal_lines[j]\n            if h_x1 <= v_x <= h_x2 and intersect((v_start, v_x), (v_end, v_x), (h_y1, h_x1), (h_y1, h_x2)):\n                intersections.append(find_intersection((v_start, v_x), (v_end, v_x), (h_y1, h_x1), (h_y1, h_x2)))\n\n    polygon = convex_hull(intersections)\n    if len(polygon) < 3:\n        print(\"INF\")\n    else:\n        area = compute_area(polygon)\n        print(area)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "t, s, x = map(int, input().split())\n\nif t == x or (x - t) % (s + 1) < 2 and (x - t) % (s + 1) >= 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "from typing import List\n\ndef find_nested_segments(segments: List[List[int]]) -> List[int]:\n    n = len(segments)\n    result = [-1, -1]\n    \n    # Sort segments by left endpoint, and then by right endpoint in descending order\n    sorted_segments = sorted((l, r, i) for i, (l, r) in enumerate(segments))\n    \n    max_right = -1\n    for i, (l, r, original_index) in enumerate(sorted_segments):\n        if r < max_right:\n            result = [original_index + 1, sorted_segments[max_right[2]][2] + 1]\n            break\n        else:\n            max_right = (l, r, i)\n    \n    return result\n\n# Reading input\nn = int(input())\nsegments = [list(map(int, input().split())) for _ in range(n)]\n\n# Finding nested segments\nresult = find_nested_segments(segments)\n\n# Printing output\nprint(*result)"}
{"solution": "def decode_genome(n, s):\n    counts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\n    question_marks = 0\n    \n    # Count existing nucleotides and question marks\n    for char in s:\n        if char != '?':\n            counts[char] += 1\n        else:\n            question_marks += 1\n    \n    # Calculate the target count for each nucleotide\n    target_count = n // 4\n    \n    # Check if it's possible to decode\n    if n % 4 != 0 or sum(count > target_count for count in counts.values()) > question_marks:\n        return \"===\"\n\n    # Decode the genome\n    result = list(s)\n    for char in 'ACGT':\n        needed = target_count - counts[char]\n        index = 0\n        while needed > 0:\n            if result[index] == '?':\n                result[index] = char\n                needed -= 1\n            index += 1\n    \n    return ''.join(result)\n\n# Read input\nn = int(input())\ns = input()\n\n# Print output\nprint(decode_genome(n, s))"}
{"solution": "def can_ilya_win(board):\n    # Check rows and columns for potential winning moves\n    for i in range(4):\n        # Check rows\n        if board[i].count('x') == 2 and board[i].count('.') == 1:\n            return \"YES\"\n        # Check columns\n        col = [board[j][i] for j in range(4)]\n        if col.count('x') == 2 and col.count('.') == 1:\n            return \"YES\"\n\n    # Check diagonals for potential winning moves\n    # Main diagonal\n    main_diagonal = [board[i][i] for i in range(4)]\n    if main_diagonal.count('x') == 2 and main_diagonal.count('.') == 1:\n        return \"YES\"\n\n    # Anti-diagonal\n    anti_diagonal = [board[i][3-i] for i in range(4)]\n    if anti_diagonal.count('x') == 2 and anti_diagonal.count('.') == 1:\n        return \"YES\"\n\n    return \"NO\"\n\n# Read the board from input\nboard = [input() for _ in range(4)]\n\n# Output the result\nprint(can_ilya_win(board))"}
{"solution": "def can_balance_array(n, arr):\n    total_sum = sum(arr)\n    prefix_sum = 0\n    \n    # Count occurrences of each number\n    count_map = {}\n    for num in arr:\n        if num in count_map:\n            count_map[num] += 1\n        else:\n            count_map[num] = 1\n    \n    # Check if balancing is possible by moving one element\n    for i in range(n):\n        prefix_sum += arr[i]\n        suffix_sum = total_sum - prefix_sum + arr[i]\n        \n        if prefix_sum == suffix_sum:\n            # Check if removing the current element leaves enough occurrences to still form the required sum\n            if count_map[arr[i]] > 1 or (count_map[arr[i]] == 1 and i != 0 and i != n - 1):\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output result\nprint(can_balance_array(n, arr))"}
{"solution": "def can_make_non_increasing(n, k, a, b):\n    # Identify the positions of zeros in sequence a\n    zero_positions = [i for i, x in enumerate(a) if x == 0]\n    \n    # Sort sequence b in non-decreasing order\n    b.sort()\n    \n    # Try to place elements from b into the positions of zeros in a\n    for i in range(k - 1, -1, -1):\n        pos = zero_positions[i]\n        val = b[i]\n        a[pos] = val\n        \n        # Check if placing the current value breaks the non-increasing condition\n        if pos > 0 and a[pos] > a[pos - 1]:\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Output result\nprint(can_make_non_increasing(n, k, a, b))"}
{"solution": "def can_make_everyone_happy(x, y, z, a, b, c):\n    # Check if Andrew's requirement can be met\n    if a < x:\n        return \"NO\"\n    \n    # Check if Dmitry's requirement can be met after Andrew's share\n    remaining_green = a - x\n    total_non_black = remaining_green + b\n    if total_non_black < y:\n        return \"NO\"\n    \n    # Check if Michal's requirement can be met after Andrew and Dmitry's shares\n    remaining_grapes = c + (total_non_black - y)\n    if remaining_grapes < z:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Output result\nprint(can_make_everyone_happy(x, y, z, a, b, c))"}
{"solution": "def is_accident_possible(lights):\n    # Iterate over each part of the intersection\n    for i in range(4):\n        # Check if the pedestrian light is green\n        if lights[i][3] == 1:\n            # Check if any car light (left, straight, right) is also green\n            if any(lights[i][:3]):\n                return \"YES\"\n            # Check if any other part's pedestrian light is green and its corresponding car light is green\n            for j in range(4):\n                if i != j and lights[j][3] == 1 and any(lights[j][:3]):\n                    return \"YES\"\n    return \"NO\"\n\n# Read input\nlights = []\nfor _ in range(4):\n    lights.append(list(map(int, input().split())))\n\n# Print the result\nprint(is_accident_possible(lights))"}
{"solution": "def get_coordinates(digit):\n    keypad = {\n        '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2),\n        '0': (3, 1)\n    }\n    return keypad[digit]\n\ndef get_vectors(number):\n    vectors = []\n    for i in range(len(number) - 1):\n        x1, y1 = get_coordinates(number[i])\n        x2, y2 = get_coordinates(number[i + 1])\n        vectors.append((x2 - x1, y2 - y1))\n    return vectors\n\ndef is_unique_finger_movement(n, number):\n    original_vectors = get_vectors(number)\n    for i in range(10**(n-1), 10**n):\n        candidate = str(i).zfill(n)\n        if candidate != number:\n            if get_vectors(candidate) == original_vectors:\n                return \"NO\"\n    return \"YES\"\n\n# Input reading\nn = int(input())\nnumber = input().strip()\n\n# Output the result\nprint(is_unique_finger_movement(n, number))"}
{"solution": "import heapq\n\ndef max_products_sold(n, f, days):\n    # Calculate the initial sold products and potential gain from doubling\n    sold = 0\n    gains = []\n    for k, l in days:\n        sold += min(k, l)\n        if k < l:\n            gains.append(l - k)\n    \n    # Convert list to a max heap\n    gains = [-gain for gain in gains]\n    heapq.heapify(gains)\n    \n    # Apply the sell-out days to maximize the number of sold products\n    for _ in range(f):\n        if gains and -gains[0] > 0:\n            sold += -heapq.heappop(gains)\n    \n    return sold\n\n# Read input\nn, f = map(int, input().split())\ndays = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(max_products_sold(n, f, days))"}
{"solution": "import heapq\n\ndef max_messiness(n, k):\n    # Initialize a min heap with the first half of the indices\n    min_heap = list(range(n // 2))\n    heapq.heapify(min_heap)\n    \n    # Initialize a max heap with the second half of the indices, negated to use as a max heap\n    max_heap = [-x for x in range(n // 2, n)]\n    heapq.heapify(max_heap)\n    \n    messiness = 0\n    for _ in range(k):\n        # Pop the smallest element from the min heap and the largest from the max heap\n        min_val = heapq.heappop(min_heap)\n        max_val = -heapq.heappop(max_heap)\n        \n        # Update the messiness based on the current indices\n        messiness += (max_val - min_val) * (n - max_val + min_val - 1)\n        \n        # Push the next elements into the heaps if available\n        if min_val + 1 <= max_val - 1:\n            heapq.heappush(min_heap, min_val + 1)\n            heapq.heappush(max_heap, -(max_val - 1))\n    \n    return messiness\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the maximum messiness\nprint(max_messiness(n, k))"}
{"solution": "def min_coins_needed(N, M, K, L):\n    # Check if it's impossible to meet all conditions\n    if N - K < L:\n        return -1\n    if N < M:\n        return -1\n    \n    # Calculate minimum number of coins each friend needs to give\n    min_coins_per_friend = max((L + M - 1) // M, (N + M - 1) // M)\n    \n    return min_coins_per_friend\n\n# Read input\nN, M, K, L = map(int, input().split())\n\n# Calculate and print the result\nprint(min_coins_needed(N, M, K, L))"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    # Find the bounds of the black cells\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # If no black cells are found\n    if min_row == n:\n        return 1\n    \n    # Calculate the side length of the square\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    \n    # Check if the square can fit within the grid\n    if side_length > n or side_length > m:\n        return -1\n    \n    # Count the number of white cells within the square\n    min_paint = float('inf')\n    for i in range(n - side_length + 1):\n        for j in range(m - side_length + 1):\n            paint_count = 0\n            for x in range(i, i + side_length):\n                for y in range(j, j + side_length):\n                    if grid[x][y] == 'W':\n                        paint_count += 1\n            min_paint = min(min_paint, paint_count)\n    \n    return min_paint\n\n# Input handling\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Output the result\nprint(min_cells_to_paint(n, m, grid))"}
{"solution": "def can_transform(x, y):\n    diff = [a - b for a, b in zip(x, y)]\n    positive_diff = sum(d for d in diff if d > 0)\n    negative_diff = sum(d for d in diff if d < 0)\n    \n    # Check if the total positive difference can be balanced by the negative difference\n    if positive_diff == -negative_diff:\n        # Check if each pile's reduction can be covered by the increase in other piles\n        taken = 0\n        for d in sorted(diff):\n            if d > 0:\n                if taken < d:\n                    return \"No\"\n                taken -= d\n            else:\n                taken += d\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input\nn = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Output result\nprint(can_transform(x, y))"}
{"solution": "def min_angle_difference(n, angles):\n    total_angle = sum(angles)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    current_sum = 0\n    \n    for i in range(n):\n        current_sum += angles[i]\n        dp[i + 1] = current_sum\n        for j in range(i + 1):\n            diff = abs(current_sum - (total_angle - current_sum + angles[j]))\n            dp[i + 1] = min(dp[i + 1], diff)\n    \n    return min(dp)\n\n# Reading input\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(min_angle_difference(n, angles))"}
{"solution": "MOD = 10**9 + 7\n\ndef power(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef solve(n, m):\n    # Calculate (m + n - 1) choose (n - 1)\n    numerator = power(m, n)\n    denominator = power((power(m, MOD - 2)), (MOD - 2))\n    return (numerator * denominator) % MOD\n\ndef main():\n    n, m = map(int, input().split())\n    print(solve(n, m))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef find_pythagorean_triple(n):\n    # Check if n is a cathetus\n    for m in range(1, int(math.sqrt(n)) + 1):\n        if n % m == 0:\n            k = n // m\n            if k > m and math.isqrt(k * k - m * m) * math.isqrt(k * k - m * m) == k * k - m * m:\n                return m, k\n    \n    # Check if n is a hypotenuse\n    for m in range(1, n):\n        k = math.isqrt(n * n - m * m)\n        if k * k == n * n - m * m:\n            return m, k\n    \n    return -1\n\n# Read input\nn = int(input())\n\n# Find and print the Pythagorean triple\nresult = find_pythagorean_triple(n)\nprint(*result)"}
{"solution": "def are_remainders_distinct(n, k):\n    seen = set()\n    for i in range(1, min(k + 1, n + 1)):\n        remainder = n % i\n        if remainder in seen:\n            return \"No\"\n        seen.add(remainder)\n    return \"Yes\"\n\n# Read input\nn, k = map(int, input().split())\n\n# Check and print the result\nprint(are_remainders_distinct(n, k))"}
{"solution": "import sys\n\n# Fast input method\ndef read_int():\n    return int(sys.stdin.readline().strip())\n\ndef compare_large_numbers(a, b):\n    # Remove leading zeros for accurate comparison\n    a = a.lstrip('0')\n    b = b.lstrip('0')\n    \n    # Compare lengths of the numbers\n    if len(a) != len(b):\n        return '<' if len(a) < len(b) else '>'\n    \n    # Lexicographical comparison if lengths are equal\n    for i in range(len(a)):\n        if a[i] != b[i]:\n            return '<' if a[i] < b[i] else '>'\n    \n    # Numbers are equal\n    return '='\n\n# Read input\na = sys.stdin.readline().strip()\nb = sys.stdin.readline().strip()\n\n# Compare and print result\nprint(compare_large_numbers(a, b))"}
{"solution": "from itertools import chain\nfrom functools import reduce\nfrom operator import mul\n\nMOD = 10**9 + 7\n\ndef power(x, y):\n    result = 1\n    while y > 0:\n        if y % 2 == 1:\n            result = (result * x) % MOD\n        y = y // 2\n        x = (x * x) % MOD\n    return result\n\ndef solve(n, p, colors):\n    black_count = sum(1 for c in colors if c == 0)\n    white_count = sum(1 for c in colors if c == 1)\n    uncolored_count = sum(1 for c in colors if c == -1)\n    \n    # Calculate the total number of ways to color uncolored pieces\n    total_colorings = power(2, uncolored_count)\n    \n    # Calculate the number of ways to form paths with alternating colors\n    # Paths can start with either black or white\n    black_ways = power(2, black_count + uncolored_count) - 1\n    white_ways = power(2, white_count + uncolored_count) - 1\n    \n    # Total number of alternating paths\n    total_paths = (black_ways * white_ways) % MOD\n    \n    # Adjust for the desired parity\n    if p == 0:  # Even parity\n        even_paths = (total_paths + 1) // 2\n        return (total_colorings * even_paths) % MOD\n    else:  # Odd parity\n        odd_paths = (total_paths - 1) // 2\n        return (total_colorings * odd_paths) % MOD\n\n# Read input\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Solve and print the result\nprint(solve(n, p, colors))"}
{"solution": "def min_cost(n, a, b, c):\n    # Calculate the remainder when n is divided by 4\n    remainder = n % 4\n    # Initialize the minimum cost to a very large number\n    min_cost = float('inf')\n    \n    # Check all possible values of k (0 to 3) to make n + k divisible by 4\n    for k in range(4):\n        if remainder == (4 - k) % 4:\n            continue\n        diff = (4 - (remainder + k)) % 4\n        \n        # Try to buy 1 copybook at a time\n        cost = diff * a\n        \n        # Try to buy 2 copybooks at once if it's cheaper\n        if diff >= 2:\n            cost = min(cost, (diff // 2) * b + (diff % 2) * a)\n        \n        # Try to buy 3 copybooks at once if it's cheaper\n        if diff >= 3:\n            cost = min(cost, c + (diff - 3) * a)\n        \n        min_cost = min(min_cost, cost)\n    \n    return min_cost\n\n# Read input\nn, a, b, c = map(int, input().split())\n\n# Print the minimum cost\nprint(min_cost(n, a, b, c))"}
{"solution": "from collections import defaultdict, deque\n\ndef find_cycle(n, graph):\n    indegree = [0] * (n + 1)\n    topo_order = []\n    for node in graph:\n        for neighbor in graph[node]:\n            indegree[neighbor] += 1\n\n    queue = deque()\n    for i in range(1, n + 1):\n        if indegree[i] == 0:\n            queue.append(i)\n\n    while queue:\n        node = queue.popleft()\n        topo_order.append(node)\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(topo_order) == n:\n        return []\n    else:\n        remaining_nodes = set(range(1, n + 1)) - set(topo_order)\n        visited = set()\n        for node in remaining_nodes:\n            if node not in visited:\n                cycle = []\n                if dfs(node, graph, visited, cycle):\n                    return cycle\n        return []\n\ndef dfs(node, graph, visited, cycle):\n    if node in visited:\n        return True\n    visited.add(node)\n    for neighbor in graph[node]:\n        if dfs(neighbor, graph, visited, cycle):\n            cycle.append(neighbor)\n            return True\n    visited.remove(node)\n    return False\n\ndef can_make_acyclic(n, m, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n\n    cycle = find_cycle(n, graph)\n    if not cycle:\n        return \"YES\"\n\n    for i in range(len(cycle)):\n        next_node = cycle[(i + 1) % len(cycle)]\n        graph[cycle[i]].remove(next_node)\n        if not find_cycle(n, graph):\n            return \"YES\"\n        graph[cycle[i]].append(next_node)\n\n    return \"NO\"\n\n# Reading input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Solving and printing output\nprint(can_make_acyclic(n, m, edges))"}
{"solution": "def min_coins_for_coverage(n, m, antennas):\n    # Sort antennas based on their positions\n    antennas.sort(key=lambda x: x[0])\n    \n    result = 0\n    current_max = 0\n    \n    for x, s in antennas:\n        # If the current max coverage is less than m, check the current antenna\n        if current_max < m:\n            # If the current position is beyond the current max coverage, extend it\n            if x > current_max:\n                result += x - current_max\n                current_max = x\n            # Extend the current antenna to cover the gap up to m\n            if x + s < m:\n                extend_by = min(s + 1, m - x)\n                result += m - (x + s)\n                current_max = m\n            else:\n                current_max = x + s\n        else:\n            break\n    \n    return result\n\n# Reading input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculating and printing the output\nprint(min_coins_for_coverage(n, m, antennas))"}
{"solution": "def max_good_subset_weight(W, weights):\n    # Initialize the result\n    result = 0\n    \n    # Iterate through each weight from 8 to 1\n    for i in range(8, 0, -1):\n        # Calculate the maximum number of items of weight i that can be added\n        max_items = min(weights[i-1], W // i)\n        # Update the result\n        result += max_items * i\n        # Update W to keep track of remaining capacity\n        W -= max_items * i\n    \n    # Return the result\n    return result\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Call the function and print the result\nprint(max_good_subset_weight(W, cnt))"}
{"solution": "def min_cost_lemonade(n, L, costs):\n    # Initialize the total cost\n    total_cost = 0\n    \n    # Create a list of tuples containing volume and cost\n    bottles = [(2**i - 1, costs[i]) for i in range(n)]\n    \n    # Sort the bottles by cost per liter\n    bottles.sort(key=lambda x: x[1] / x[0])\n    \n    # Iterate through sorted bottles\n    for volume, cost in bottles:\n        if L > 0:\n            # Calculate how many liters we can buy from the current bottle\n            buy = min(volume, L)\n            # Update the total cost\n            total_cost += (buy / volume) * cost\n            # Decrease the required liters\n            L -= buy\n    \n    return int(total_cost)\n\n# Read input\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Calculate and print the minimum cost\nprint(min_cost_lemonade(n, L, costs))"}
{"solution": "def max_mex(n, a):\n    a.sort()\n    mex = 1\n    for num in a:\n        if num >= mex:\n            mex += 1\n    return mex\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = max_mex(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(int(digit) for digit in digits)\n    \n    for segment_sum in range(1, total_sum + 1):\n        if total_sum % segment_sum == 0:\n            num_segments = total_sum // segment_sum\n            current_sum = 0\n            segments_count = 0\n            for digit in digits:\n                current_sum += int(digit)\n                if current_sum == segment_sum:\n                    current_sum = 0\n                    segments_count += 1\n            if segments_count >= 2 and current_sum == 0:\n                return \"YES\"\n    \n    return \"NO\"\n\nn = int(input())\ndigits = input().strip()\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\"\n\nusername = input().strip()\nprint(determine_gender(username))"}
{"solution": "def max_tab_difference(n, k, tabs):\n    def calculate_difference(start_index):\n        closed_tabs = set()\n        current_index = start_index\n        while 1 <= current_index <= n:\n            closed_tabs.add(current_index)\n            current_index += k\n        \n        e_count = s_count = 0\n        for i in range(1, n + 1):\n            if i not in closed_tabs:\n                if tabs[i - 1] == 1:\n                    e_count += 1\n                else:\n                    s_count += 1\n        \n        return abs(e_count - s_count)\n    \n    max_diff = 0\n    for start_index in range(1, n + 1):\n        diff = calculate_difference(start_index)\n        max_diff = max(max_diff, diff)\n    \n    return max_diff\n\n# Reading input\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(max_tab_difference(n, k, tabs))"}
{"solution": "def min_cost_encoding(n, c0, c1):\n    if c0 == c1:\n        return (n - 1) * (c0 + c1)\n    \n    if c0 > c1:\n        c0, c1 = c1, c0\n    \n    total_cost = 0\n    current_cost = c0 + c1\n    codes_needed = n - 1\n    while codes_needed > 0:\n        if codes_needed <= current_cost // c1 + 1:\n            total_cost += codes_needed * current_cost\n            break\n        else:\n            total_cost += (current_cost // c1 + 1) * current_cost\n            codes_needed -= current_cost // c1 + 1\n            current_cost += c0\n    \n    return total_cost\n\n# Reading input\nn, c0, c1 = map(int, input().split())\n\n# Calculating and printing the output\nprint(min_cost_encoding(n, c0, c1))"}
{"solution": "def will_meet(n, a, x, b, y):\n    while a != x and b != y:\n        if a == b:\n            return \"YES\"\n        a = a + 1 if a < n else 1\n        b = b - 1 if b > 1 else n\n    return \"YES\" if a == b else \"NO\"\n\n# Example usage:\n# n, a, x, b, y = 5, 1, 4, 3, 2\n# print(will_meet(n, a, x, b, y))"}
{"solution": "import math\n\ndef generate_unlucky_years(x, y, max_year):\n    unlucky_years = set()\n    max_power = int(math.log(max_year, min(x, y))) + 1\n    \n    for a in range(max_power):\n        for b in range(max_power):\n            year = x**a + y**b\n            if year <= max_year:\n                unlucky_years.add(year)\n    \n    return unlucky_years\n\ndef find_max_golden_age(x, y, l, r):\n    unlucky_years = generate_unlucky_years(x, y, r)\n    max_length = 0\n    current_start = l\n    last_unlucky = l - 1\n    \n    for year in range(l, r + 1):\n        if year in unlucky_years:\n            if last_unlucky + 1 < year:\n                max_length = max(max_length, year - (last_unlucky + 1))\n            last_unlucky = year\n            current_start = year + 1\n    \n    if last_unlucky + 1 < r + 1:\n        max_length = max(max_length, r + 1 - (last_unlucky + 1))\n    \n    return max_length\n\n# Read input\nx, y, l, r = map(int, input().split())\n\n# Calculate and print the result\nprint(find_max_golden_age(x, y, l, r))"}
{"solution": "def min_tax(n):\n    if n % 2 == 0:\n        return n // 2\n    else:\n        # Find the largest even divisor less than n\n        for i in range(n - 1, 1, -1):\n            if n % i == 0 and i % 2 == 0:\n                return i // 2\n        return 1  # Fallback, should not happen for n >= 2\n\n# Read input\nn = int(input())\n\n# Calculate and print the minimum tax\nprint(min_tax(n))"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    n = len(word)\n    result = []\n    i = 0\n    \n    while i < n:\n        result.append(word[i])\n        if word[i] not in vowels:\n            start = i\n            while i < n and word[i] not in vowels:\n                i += 1\n            if i - start >= 3:\n                block = word[start:i]\n                if len(set(block)) > 1:\n                    result.append(' ')\n        i += 1\n    \n    return ''.join(result)\n\nword = input().strip()\nprint(fix_typos(word))"}
{"solution": "import bisect\n\ndef min_potion_prep_time(n, m, k, x, s, a, b, c, d):\n    # Sort spells by cost-effectiveness\n    a_b = sorted(zip(a, b), key=lambda x: (x[0], -x[1]))\n    c_d = sorted(zip(c, d), key=lambda x: (x[1], x[0]))\n\n    a, b = zip(*a_b) if a_b else ([], [])\n    c, d = zip(*c_d) if c_d else ([], [])\n\n    def enough_time(t):\n        # Find the best first-type spell that fits within the time limit\n        i = bisect.bisect_left(a, t)\n        if i < m:\n            t, mb = a[i], b[i]\n        else:\n            mb = 0\n\n        # Calculate remaining potions needed after using the first-type spell\n        remaining_potions = n - max(0, c[bisect.bisect_right(d, s - mb)] if k > 0 else 0)\n\n        # Calculate time needed to prepare the remaining potions\n        return remaining_potions * t <= t\n\n    # Binary search for the minimum time\n    low, high = 1, n * x\n    while low < high:\n        mid = (low + high) // 2\n        if enough_time(mid):\n            high = mid\n        else:\n            low = mid + 1\n\n    return low\n\n# Read input\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\n# Output result\nprint(min_potion_prep_time(n, m, k, x, s, a, b, c, d))"}
{"solution": "def max_points(n, k, M, times):\n    from itertools import accumulate\n    \n    # Calculate cumulative time to solve subtasks\n    cum_times = list(accumulate(times))\n    \n    # Binary search to find the optimal number of complete tasks\n    low, high = 0, n\n    while low < high:\n        mid = (low + high + 1) // 2\n        if cum_times[-1] * mid <= M:\n            low = mid\n        else:\n            high = mid - 1\n    \n    # Time left after completing 'low' tasks fully\n    remaining_time = M - low * cum_times[-1]\n    \n    # Points from fully completed tasks\n    points = low * (k + 1)\n    \n    # Add points from incomplete tasks\n    for time in times:\n        if remaining_time >= time:\n            remaining_time -= time\n            points += 1\n    \n    return points\n\n# Read input\nn, k, M = map(int, input().split())\ntimes = list(map(int, input().split()))\n\n# Calculate and print the maximum points\nprint(max_points(n, k, M, times))"}
{"solution": "MOD = 998244353\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef C(n, k):\n    if k > n:\n        return 0\n    res = 1\n    for i in range(k):\n        res = res * (n - i) % MOD\n        res = res * modinv(i + 1) % MOD\n    return res\n\ndef solve(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = 0\n        for j in range((i + 1) // 2):\n            left = C(i - 1, j)\n            right = C(i - 1 - j, i - 1 - 2 * j)\n            dp[i] += dp[j] * dp[i - 1 - j] * left * right % MOD\n            dp[i] %= MOD\n    \n    result = dp[n]\n    # Adjust for parity conditions\n    if n % 2 == 0:\n        result = result * 2 % MOD\n    \n    return result\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def find_laras_position(n, m, k):\n    # Determine the direction of movement and the current position\n    def move(row, col, direction):\n        if direction == 'down':\n            return row + 1, col, 'right'\n        elif direction == 'right':\n            return row, col + 1, 'up'\n        elif direction == 'up':\n            return row - 1, col, 'left'\n        elif direction == 'left':\n            return row, col - 1, 'down'\n\n    row, col = 1, 1\n    direction = 'down'\n    steps_down = 0\n\n    while k > 0:\n        # Calculate the maximum possible steps in the current direction\n        if direction == 'down':\n            max_steps = n - row\n        elif direction == 'right':\n            max_steps = m - col\n        elif direction == 'up':\n            max_steps = row - 1\n        else:  # direction == 'left'\n            max_steps = col - 1\n\n        # Move the minimum of remaining steps and max steps\n        steps = min(k, max_steps)\n        row, col, direction = move(row, col, direction)\n        k -= steps\n        steps_down += 1 if direction == 'down' else 0\n\n        # Adjust for the special case when moving back up\n        if direction == 'up' and steps_down % 2 == 0:\n            row += 1\n\n    return row, col\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Find and print Lara's position\nposition = find_laras_position(n, m, k)\nprint(*position)"}
{"solution": "from math import gcd\n\ndef find_min_max_pair(X):\n    # Find the largest divisor of X that when squared does not exceed X\n    for a in range(int(X**0.5), 0, -1):\n        if X % a == 0:\n            b = X // a\n            return [a, b]\n\n# Read input\nX = int(input())\n\n# Find and print the pair (a, b)\na, b = find_min_max_pair(X)\nprint(a, b)"}
{"solution": "def max_fruits_for_compote(a, b, c):\n    # Calculate the maximum number of complete sets for each fruit type\n    max_sets_lemons = a // 1\n    max_sets_apples = b // 2\n    max_sets_pears = c // 4\n    \n    # Find the limiting factor (minimum number of complete sets)\n    max_complete_sets = min(max_sets_lemons, max_sets_apples, max_sets_pears)\n    \n    # Calculate the total number of fruits used in the compote\n    total_fruits = max_complete_sets * (1 + 2 + 4)\n    \n    return total_fruits\n\n# Read input\na = int(input())\nb = int(input())\nc = int(input())\n\n# Print the result\nprint(max_fruits_for_compote(a, b, c))"}
{"solution": "def can_divide_teams(n, ratings):\n    ratings.sort()\n    for i in range(n):\n        if ratings[i] >= ratings[i + n]:\n            return \"NO\"\n    return \"YES\"\n\n# Reading input\nn = int(input())\nratings = list(map(int, input().split()))\n\n# Printing output\nprint(can_divide_teams(n, ratings))"}
{"solution": "from math import gcd\n\ndef find_next_coprime(arr):\n    n = len(arr)\n    result = []\n    insertions = 0\n    \n    for i in range(n - 1):\n        if gcd(arr[i], arr[i + 1]) > 1:\n            # Find the smallest coprime number\n            x = 1\n            while gcd(x, arr[i]) != 1 or gcd(x, arr[i + 1]) != 1:\n                x += 1\n            result.append(arr[i])\n            result.append(x)\n            insertions += 1\n        else:\n            result.append(arr[i])\n    result.append(arr[-1])\n    \n    return insertions, result\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Solving the problem\ninsertions, modified_array = find_next_coprime(a)\n\n# Printing the output\nprint(insertions)\nprint(' '.join(map(str, modified_array)))"}
{"solution": "from math import gcd\nfrom functools import reduce\n\ndef compute_gcd_of_list(lst):\n    return reduce(gcd, lst)\n\ndef max_divisor_after_operations(N, K, A):\n    total_sum = sum(A)\n    possible_divisors = set()\n\n    # Find all possible divisors of the total sum\n    for i in range(1, int(total_sum**0.5) + 1):\n        if total_sum % i == 0:\n            possible_divisors.add(i)\n            possible_divisors.add(total_sum // i)\n\n    max_divisor = 1\n    for d in sorted(possible_divisors, reverse=True):\n        mods = sorted([a % d for a in A])\n        prefix_sum = list(mods)\n        for i in range(1, N):\n            prefix_sum[i] += prefix_sum[i - 1]\n        \n        for i in range(N):\n            add_cost = prefix_sum[i]\n            sub_cost = (N - i - 1) * d - (prefix_sum[-1] - prefix_sum[i])\n            if add_cost == sub_cost and add_cost <= K:\n                return d\n\n    return max_divisor\n\n# Read input\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Compute and print the result\nprint(max_divisor_after_operations(N, K, A))"}
{"solution": "def find_transformation(x):\n    # Function to count the number of set bits (1s) in the binary representation of x\n    def count_set_bits(n):\n        count = 0\n        while n:\n            n &= (n - 1)\n            count += 1\n        return count\n\n    # Determine the number of operations needed\n    operations = []\n    m = count_set_bits(x)\n    if m == 1:  # If x is already a power of 2 minus 1, no operations needed\n        return [0]\n\n    # Perform operations to transform x into a perfect longcat\n    while True:\n        # Find the largest bit position where x has a 0\n        highest_zero_bit = max(i for i in range(31) if not (x & (1 << i)))\n        if highest_zero_bit == -1:\n            break\n        # Apply Operation A\n        operations.append(highest_zero_bit)\n        x ^= ((1 << (highest_zero_bit + 1)) - 1)\n        # Apply Operation B\n        x += 1\n        operations.append(None)  # Placeholder for Operation B\n\n        # Check if x is now a perfect longcat\n        if count_set_bits(x) == 1:\n            break\n\n    # Remove placeholders and ensure the number of operations is correct\n    operations = [op for op in operations if op is not None]\n    t = len(operations)\n\n    return [t] + operations[:t//2]\n\n# Read input\nx = int(input())\n\n# Generate transformation plan\ntransformation_plan = find_transformation(x)\n\n# Print the transformation plan\nprint(' '.join(map(str, transformation_plan)))"}
{"solution": "# Import necessary packages\nfrom math import inf\n\ndef min_hours_to_water_garden(n, k, bucket_lengths):\n    \"\"\"\n    Determine the minimum number of hours required to water the garden.\n    \n    :param n: Number of buckets\n    :param k: Length of the garden\n    :param bucket_lengths: List of bucket lengths\n    :return: Minimum number of hours required to water the garden\n    \"\"\"\n    # Initialize minimum hours to infinity\n    min_hours = inf\n    \n    # Iterate through each bucket length\n    for length in bucket_lengths:\n        # Check if the garden can be watered completely using this bucket\n        if k % length == 0:\n            # Calculate the number of hours required and update minimum hours\n            hours_required = k // length\n            min_hours = min(min_hours, hours_required)\n    \n    # Return the minimum hours required\n    return min_hours\n\n# Read input\nn, k = map(int, input().split())\nbucket_lengths = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_hours_to_water_garden(n, k, bucket_lengths))"}
{"solution": "def can_grasshopper_reach_insect(n, k, line):\n    from collections import deque\n    \n    # Find the positions of the grasshopper (G) and the insect (T)\n    grasshopper_pos = line.find('G')\n    insect_pos = line.find('T')\n    \n    # Check if the grasshopper and the insect are already in the same position\n    if grasshopper_pos == insect_pos:\n        return \"YES\"\n    \n    visited = set()\n    queue = deque([grasshopper_pos])\n    \n    while queue:\n        current_pos = queue.popleft()\n        \n        # Check if the grasshopper has reached the insect\n        if current_pos == insect_pos:\n            return \"YES\"\n        \n        # Mark the current position as visited\n        visited.add(current_pos)\n        \n        # Calculate the next possible positions\n        next_left = current_pos - k\n        next_right = current_pos + k\n        \n        # Check if the next positions are valid and not visited\n        if next_left >= 0 and line[next_left] != '#' and next_left not in visited:\n            queue.append(next_left)\n        if next_right < n and line[next_right] != '#' and next_right not in visited:\n            queue.append(next_right)\n    \n    return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\nline = input()\n\n# Print the result\nprint(can_grasshopper_reach_insect(n, k, line))"}
{"solution": "from math import fabs\n\ndef check_collision(x_b, y_b, x_w, y_w, y1, y2, r):\n    dx = x_w - x_b\n    dy = y_w - y_b\n    slope = dy / dx\n    x_intercept = -y_b / slope\n    y_intercept = y_b - x_b * slope\n\n    if y_intercept <= y1 + r and y_intercept >= y1 - r:\n        return True\n    if y_intercept <= y2 + r and y_intercept >= y2 - r:\n        return True\n    if x_intercept <= x_b + r and x_intercept >= x_b - r:\n        return True\n    return False\n\ndef find_target_point(y1, y2, y_w, x_b, y_b, r):\n    # Calculate the intersection point with the wall\n    x_w = (y_w - y_b) * x_b / (2 * (y_w - y_b - r)) + x_b\n    if x_w <= x_b:\n        return -1\n    \n    # Check if the ball hits the goal posts\n    if check_collision(x_b, y_b, x_w, y_w, y1, y2, r):\n        return -1\n    \n    return x_w\n\ndef main():\n    y1, y2, y_w, x_b, y_b, r = map(int, input().split())\n    result = find_target_point(y1, y2, y_w, x_b, y_b, r)\n    print(f\"{result:.10f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_missed_meals(breakfasts, dinners, suppers):\n    # Calculate the minimum number of missed meals\n    total_meals = breakfasts + dinners + suppers\n    # If Vasiliy had at least one meal of each type, he didn't miss any meals\n    if breakfasts > 0 and dinners > 0 and suppers > 0:\n        return 0\n    # Calculate the minimum possible missed meals\n    missed = 3 * min(breakfasts, dinners, suppers)  # Minimum full days of meals accounted for\n    missed += max(0, (breakfasts + dinners + suppers) - 3 * min(breakfasts, dinners, suppers))\n    return total_meals - missed\n\n# Read input\nb, d, s = map(int, input().split())\n\n# Print the result\nprint(min_missed_meals(b, d, s))"}
{"solution": "def find_possible_dimensions(path):\n    def get_position(value, x, y):\n        row = (value - 1) // y\n        col = (value - 1) % y\n        return row, col\n\n    def is_valid_move(pos1, pos2):\n        row1, col1 = pos1\n        row2, col2 = pos2\n        return abs(row1 - row2) + abs(col1 - col2) == 1\n\n    n = len(path)\n    for y in range(1, 1000001):  # Limiting y to a reasonable range for practical computation\n        for x in range(1, 1000001):\n            valid_path = True\n            for i in range(n - 1):\n                pos1 = get_position(path[i], x, y)\n                pos2 = get_position(path[i + 1], x, y)\n                if not is_valid_move(pos1, pos2):\n                    valid_path = False\n                    break\n            if valid_path:\n                return \"YES\\n\" + str(x) + \" \" + str(y)\n    return \"NO\"\n\n# Reading input\nn = int(input())\npath = list(map(int, input().split()))\n\n# Printing output\nprint(find_possible_dimensions(path))"}
{"solution": "def find_min_consecutive_removals(a, b):\n    m, n = len(a), len(b)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Fill dp table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    # Reconstruct the subsequence\n    i, j = m, n\n    subsequence = []\n    while i > 0 and j > 0:\n        if a[i - 1] == b[j - 1]:\n            subsequence.append(a[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    # Reverse to get correct order\n    subsequence = ''.join(reversed(subsequence))\n\n    # Handle empty subsequence case\n    if not subsequence:\n        return '-'\n    return subsequence\n\n# Read input\na = input().strip()\nb = input().strip()\n\n# Output result\nprint(find_min_consecutive_removals(a, b))"}
{"solution": "def minimal_stones(n, s):\n    current_stones = 0\n    min_stones = 0\n    \n    for char in s:\n        if char == '+':\n            current_stones += 1\n        elif char == '-':\n            current_stones -= 1\n        min_stones = min(min_stones, current_stones)\n    \n    return max(0, -min_stones)\n\n# Reading input\nn = int(input())\ns = input().strip()\n\n# Printing output\nprint(minimal_stones(n, s))"}
{"solution": "def max_kefir_liters(n, a, b, c):\n    def calculate_liters(money, bottle_cost, refund):\n        total_liters = 0\n        while money >= bottle_cost:\n            bottles_bought = money // bottle_cost\n            money -= bottles_bought * bottle_cost\n            total_liters += bottles_bought\n            refund_money = bottles_bought * refund\n            money += refund_money\n        return total_liters\n\n    # Calculate the maximum liters of kefir if only plastic bottles are bought\n    plastic_liters = n // a\n\n    # Calculate the maximum liters of kefir if glass bottles are bought and returned\n    glass_liters = calculate_liters(n, b, c)\n\n    # Return the maximum of the two options\n    return max(plastic_liters, glass_liters)\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Output the result\nprint(max_kefir_liters(n, a, b, c))"}
{"solution": "from collections import deque\n\ndef read_cards():\n    n = int(input())\n    k1 = int(input())\n    soldier1 = deque(map(int, input().split()))\n    k2 = int(input())\n    soldier2 = deque(map(int, input().split()))\n    return n, soldier1, soldier2\n\ndef simulate_game(soldier1, soldier2):\n    fights = 0\n    winner = 0\n    while True:\n        if fights > 10**6:  # Check for infinite loop\n            return -1\n        if not soldier1 or not soldier2:\n            break\n        card1 = soldier1.popleft()\n        card2 = soldier2.popleft()\n        if card1 > card2:\n            soldier1.append(card2)\n            soldier1.append(card1)\n        else:\n            soldier2.append(card1)\n            soldier2.append(card2)\n        fights += 1\n    \n    if soldier1:\n        winner = 1\n    else:\n        winner = 2\n    \n    return fights, winner\n\nn, soldier1, soldier2 = read_cards()\nresult = simulate_game(soldier1, soldier2)\nif result == -1:\n    print(-1)\nelse:\n    fights, winner = result\n    print(fights, winner)"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    \n    has_upper = any(char.isupper() for char in password)\n    has_lower = any(char.islower() for char in password)\n    has_digit = any(char.isdigit() for char in password)\n    \n    if has_upper and has_lower and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\"\n\n# Read input\npassword = input().strip()\nprint(check_password_complexity(password))"}
{"solution": "def min_exchanges_to_balance_groups(n, group_a, group_b):\n    from collections import Counter\n    \n    # Count academic performances in each group\n    counter_a = Counter(group_a)\n    counter_b = Counter(group_b)\n    \n    # Calculate differences for each performance level\n    differences = [abs(counter_a[i] - counter_b[i]) for i in range(1, 6)]\n    \n    # Sum of all differences should be even to achieve the goal\n    total_diff = sum(differences)\n    if total_diff % 2 != 0:\n        return -1\n    \n    exchanges = 0\n    for diff in differences:\n        # Each difference needs to be paired up (even number of exchanges)\n        exchanges += diff // 2\n    \n    return exchanges\n\n# Reading input\nn = int(input())\ngroup_a = list(map(int, input().split()))\ngroup_b = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(min_exchanges_to_balance_groups(n, group_a, group_b))"}
{"solution": "def is_reachable(n, m, horizontal_streets, vertical_streets):\n    # Check if there is at least one east-west and one west-east horizontal street\n    has_east = '>' in horizontal_streets\n    has_west = '<' in horizontal_streets\n    \n    # Check if there is at least one north-south and one south-north vertical street\n    has_north = '^' in vertical_streets\n    has_south = 'v' in vertical_streets\n    \n    # If all conditions are met, return \"YES\", otherwise return \"NO\"\n    if has_east and has_west and has_north and has_south:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nhorizontal_streets = input()\nvertical_streets = input()\n\n# Print the result\nprint(is_reachable(n, m, horizontal_streets, vertical_streets))"}
{"solution": "def can_make_false(n, a):\n    zeros = 0\n    for value in a:\n        if value == 0:\n            if zeros == 0:\n                zeros += 1\n            else:\n                zeros -= 1\n        else:\n            zeros += 1\n    return zeros == 0\n\ndef generate_expression(n, a):\n    if not can_make_false(n, a):\n        return \"NO\"\n    \n    expr = []\n    zero_stack = []\n    for i, value in enumerate(a):\n        if value == 0:\n            if zero_stack:\n                expr.append('(')\n                expr.append(str(zero_stack.pop()))\n                expr.append(')')\n            expr.append('0')\n        else:\n            zero_stack.append(i)\n            expr.append('1')\n        \n        if len(expr) > 1:\n            start_index = max(0, len(expr) - 2 - len(zero_stack))\n            expr.insert(start_index, '(')\n            expr.insert(start_index + 2 * len(zero_stack) + 2, ')')\n            expr.insert(start_index + 2 * len(zero_stack) + 1, '->')\n    \n    while zero_stack:\n        expr.append('->')\n        expr.append('(')\n        expr.append(str(zero_stack.pop()))\n        expr.append(')')\n    \n    return \"\".join(map(str, expr))\n\nn = int(input())\na = list(map(int, input().split()))\n\nresult = generate_expression(n, a)\nprint(\"YES\")\nprint(result)"}
{"solution": "def process_variables(a, b):\n    while a > 0 and b > 0:\n        if a >= 2 * b:\n            a -= 2 * b\n        elif b >= 2 * a:\n            b -= 2 * a\n        else:\n            break\n    return a, b\n\nn, m = map(int, input().split())\nresult_a, result_b = process_variables(n, m)\nprint(result_a, result_b)"}
{"solution": "def count_k_divisible(k, a, b):\n    # Calculate the number of k-divisible numbers in the range [a, b]\n    start = (a + k - 1) // k * k if a % k != 0 else a\n    end = b - b % k if b % k == 0 else b - b % k + k\n    return max(0, (end - start) // k + 1)\n\n# Read input\nk, a, b = map(int, input().split())\n\n# Print the result\nprint(count_k_divisible(k, a, b))"}
{"solution": "def find_kth_digit(k):\n    # Initialize variables\n    total_digits = 0\n    current_range_start = 1\n    digits_in_range = 1\n    \n    # Find the range where the k-th digit is located\n    while total_digits + digits_in_range * 9 * (10 ** (digits_in_range - 1)) < k:\n        total_digits += digits_in_range * 9 * (10 ** (digits_in_range - 1))\n        digits_in_range += 1\n        current_range_start *= 10\n    \n    # Calculate the exact number where the k-th digit is located\n    remaining_digits = k - total_digits\n    target_number = current_range_start + (remaining_digits - 1) // digits_in_range\n    \n    # Find the exact digit within the target number\n    digit_index = (remaining_digits - 1) % digits_in_range\n    return int(str(target_number)[digit_index])\n\n# Read input\nk = int(input())\n\n# Find and print the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "def can_vasya_win(n, s):\n    # Calculate the number of moves each player will make\n    moves_each = (n - 11) // 2\n    \n    # Count the number of '8's in the first n - 10 characters\n    count_8s = s[:n - 10].count('8')\n    \n    # Vasya wins if there are more '8's than the number of moves Petya can make\n    if count_8s > moves_each:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Determine if Vasya has a winning strategy\nresult = can_vasya_win(n, s)\nprint(result)"}
{"solution": "from math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_permutations(n, x, pos):\n    if pos == 0:\n        # If pos is 0, the number x is at the beginning, so we only need to ensure\n        # that the numbers greater than x are placed in the correct order.\n        return (factorial(n - 1) * pow(2, n - x - 1, MOD)) % MOD\n    elif pos == n - 1:\n        # If pos is n-1, the number x is at the end, so we only need to ensure\n        # that the numbers less than x are placed in the correct order.\n        return (factorial(n - 1) * pow(2, x - 1, MOD)) % MOD\n    else:\n        # For other positions, we need to consider both sides of x.\n        left_permutations = pow(2, x - 1 - (pos == 0), MOD)\n        right_permutations = pow(2, n - x - 1 - (pos == n - 1), MOD)\n        return (factorial(pos) * factorial(n - pos - 1) * left_permutations * right_permutations) % MOD\n\n# Reading input\nn, x, pos = map(int, input().split())\n\n# Calculating and printing the result\nprint(calculate_permutations(n, x, pos))"}
{"solution": "def decode_message(s, k):\n    i, n = 0, len(s)\n    message = []\n    \n    while i < n and len(message) < k:\n        start_i = i\n        while i < n and s[i].isalpha():\n            i += 1\n        if i == start_i:  # No alphabetic character found\n            break\n        remaining_k = k - len(message)\n        char = s[start_i]\n        \n        while i < n and (s[i] == '?' or s[i] == '*'):\n            if s[i] == '?':\n                if remaining_k > 0:\n                    message.append(char)\n                    remaining_k -= 1\n                else:\n                    break\n            else:  # s[i] == '*'\n                if remaining_k > 0:\n                    repeats = min(remaining_k, n - i)\n                    message.extend([char] * repeats)\n                    remaining_k -= repeats\n                    i += repeats\n            i += 1\n        \n        if remaining_k > 0:\n            message.extend([char] * remaining_k)\n            remaining_k = 0\n    \n    if len(message) == k:\n        return ''.join(message)\n    else:\n        return 'Impossible'\n\n# Reading input\ns = input().strip()\nk = int(input().strip())\n\n# Processing and printing output\nprint(decode_message(s, k))"}
{"solution": "def min_clockwise_turns(x):\n    # Normalize the angle to be within 0 to 360 degrees\n    normalized_angle = x % 360\n    # Determine the minimum number of 90-degree clockwise turns\n    if normalized_angle <= 90:\n        return 0 if normalized_angle == 0 else 1\n    elif normalized_angle <= 180:\n        return 2 if normalized_angle == 180 else 1\n    elif normalized_angle <= 270:\n        return 2\n    else:\n        return 3\n\n# Read input\nx = int(input())\n\n# Output the result\nprint(min_clockwise_turns(x))"}
{"solution": "def can_transform_spheres(a, b, c, x, y, z):\n    # Calculate the difference needed for each color\n    diff_b = max(0, x - a)\n    diff_v = max(0, y - b)\n    diff_o = max(0, z - c)\n    \n    # Total extra spheres available for transformation\n    total_extra = (a + b + c) - (x + y + z)\n    \n    # Total needed to transform into other colors\n    total_needed = diff_b + diff_v + diff_o\n    \n    # Check if it's possible to transform\n    return \"Yes\" if total_extra >= total_needed else \"No\"\n\n# Read input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Output result\nprint(can_transform_spheres(a, b, c, x, y, z))"}
{"solution": "def calculate_suffix_numbers(n, k, m):\n    power_10_mod_m = pow(10, n, m * k)\n    cycle_length = 1\n    for i in range(1, k + 1):\n        if pow(10, i, m * k) == 1:\n            cycle_length = i\n            break\n    \n    total_sum = 0\n    current_power = 1\n    for i in range(n):\n        current_sum = ((power_10_mod_m - 1) // 9) % m\n        total_sum += current_sum * (k - (current_power - 1) % k) % m\n        total_sum %= m\n        power_10_mod_m = (power_10_mod_m * 10) % (m * k)\n        current_power = (current_power * 10) % k\n    \n    return total_sum\n\n# Reading input\nn, k, m = map(int, input().split())\n\n# Calculating and printing the result\nprint(calculate_suffix_numbers(n, k, m))"}
{"solution": "def max_team_size(l, r, a):\n    if l > r:\n        l, r = r, l  # Ensure l is always the smaller or equal group\n    \n    # Use ambidexters to balance the difference\n    d = r - l\n    if a >= d:\n        l += d\n        a -= d\n        # Now l == r, distribute remaining ambidexters equally\n        l += a // 2\n        r += a // 2\n    else:\n        l += a\n        # Not enough ambidexters to balance completely, r remains larger\n    \n    # The maximum team size is twice the smaller group\n    return 2 * l\n\n# Read input\nl, r, a = map(int, input().split())\n\n# Calculate and print the result\nprint(max_team_size(l, r, a))"}
{"solution": "def min_moves(n, k):\n    # Initialize the result variable\n    result = 0\n    \n    # Calculate the total moves required\n    for i in range(1, n + 1):\n        # Distance to the current manhole from Nastya's initial position\n        dist = abs(i - k) + 1\n        \n        # Total moves for this manhole\n        moves = (n - i) * 2 + dist\n        \n        # Update the result\n        result += moves\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the minimum number of moves\nprint(min_moves(n, k))"}
{"solution": "import heapq\n\ndef min_tallest_tower_height(n, m):\n    used_heights = set()\n    heap = [2, 3]\n    heapq.heapify(heap)\n    for _ in range(n + m):\n        smallest = heapq.heappop(heap)\n        while smallest in used_heights:\n            smallest += 1\n        used_heights.add(smallest)\n        heapq.heappush(heap, smallest * 2)\n        heapq.heappush(heap, smallest * 3)\n    return max(used_heights)\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(min_tallest_tower_height(n, m))"}
{"solution": "from collections import Counter\n\ndef is_fair_game(cards):\n    n = len(cards)\n    card_counts = Counter(cards)\n    for petya_choice in card_counts:\n        vasya_choices = [card for card in card_counts if card != petya_choice]\n        for vasya_choice in vasya_choices:\n            petya_count = card_counts[petya_choice]\n            vasya_count = card_counts[vasya_choice]\n            remaining_cards = n - petya_count - vasya_count\n            if petya_count == vasya_count and remaining_cards == 0:\n                return True, (petya_choice, vasya_choice)\n    return False, None\n\n# Read input\nn = int(input())\ncards = [int(input()) for _ in range(n)]\n\n# Check if the game can be fair\nis_fair, choices = is_fair_game(cards)\n\nif is_fair:\n    print(\"YES\")\n    print(*choices)\nelse:\n    print(\"NO\")"}
{"solution": "def can_arrange_soldiers(n, k, groups):\n    total_seats = 8 * n\n    total_soldiers = sum(groups)\n    \n    # Check if the total number of soldiers can fit in the airplane\n    if total_soldiers > total_seats:\n        return \"NO\"\n    \n    # Calculate the maximum number of soldiers that can be placed without neighbors\n    max_non_neighbor_seats = 4 * n\n    \n    # Check if the largest group can fit without having neighbors\n    if max(groups) > max_non_neighbor_seats:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Output result\nprint(can_arrange_soldiers(n, k, groups))"}
{"solution": "def min_cost_to_almost_good(n, sticks):\n    \"\"\"\n    Finds the minimum cost to adjust the lengths of the sticks so that all lengths are almost good for some t.\n    \n    Parameters:\n    n (int): Number of sticks.\n    sticks (list of int): Lengths of the sticks.\n    \n    Returns:\n    tuple: (t, min_cost) where t is the optimal value making all stick lengths almost good and min_cost is the minimum cost to achieve this.\n    \"\"\"\n    # Count occurrences of each length\n    counts = [0] * 101\n    for stick in sticks:\n        counts[stick] += 1\n    \n    min_cost = float('inf')\n    t_optimal = None\n    \n    # Calculate cost for each possible t\n    for t in range(1, 101):\n        cost = sum(count * min(abs(stick - t), abs(stick - t - 1), abs(stick - t + 1)) for stick, count in enumerate(counts))\n        if cost < min_cost:\n            min_cost = cost\n            t_optimal = t\n            \n    return (t_optimal, min_cost)\n\n# Read input\nn = int(input())\nsticks = list(map(int, input().split()))\n\n# Calculate and print the result\nt, cost = min_cost_to_almost_good(n, sticks)\nprint(t, cost)"}
{"solution": "def find_min_square_side(n, m, sky_map):\n    # Initialize minimum and maximum coordinates\n    min_row, max_row, min_col, max_col = None, None, None, None\n    \n    # Find the bounding box of stars\n    for i in range(n):\n        for j in range(m):\n            if sky_map[i][j] == '*':\n                if min_row is None or i < min_row:\n                    min_row = i\n                if max_row is None or i > max_row:\n                    max_row = i\n                if min_col is None or j < min_col:\n                    min_col = j\n                if max_col is None or j > max_col:\n                    max_col = j\n    \n    # Calculate width and height of the bounding box\n    width = max_col - min_col + 1\n    height = max_row - min_row + 1\n    \n    # The side of the square is the maximum of width and height\n    return max(width, height)\n\n# Read input\nn, m = map(int, input().split())\nsky_map = [input() for _ in range(n)]\n\n# Convert strings to lists for easier manipulation\nsky_map = [list(row) for row in sky_map]\n\n# Calculate and print the result\nprint(find_min_square_side(n, m, sky_map))"}
{"solution": "from math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef mod_inverse(x):\n    return pow(x, MOD - 2, MOD)\n\ndef count_zeros_ones(arr):\n    zeros = ones = 0\n    for num in arr:\n        if num == 0:\n            zeros += 1\n        else:\n            ones += 1\n    return zeros, ones\n\ndef is_sorted(arr):\n    return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\n\ndef calculate_probability(n, k, arr):\n    zeros, ones = count_zeros_ones(arr)\n    \n    # If the array is already sorted and k is odd, it cannot remain sorted.\n    if is_sorted(arr) and k % 2 != 0:\n        return 0\n    \n    # If the array is not sorted and k is even, it cannot become sorted.\n    if not is_sorted(arr) and k % 2 == 0:\n        return 0\n    \n    # Calculate the number of ways to choose pairs (i, j) for swaps.\n    total_pairs = n * (n - 1) // 2\n    swap_pairs = total_pairs * k % MOD\n    \n    # Calculate the number of valid permutations.\n    valid_permutations = 1\n    for i in range(1, zeros + 1):\n        valid_permutations *= i\n        valid_permutations %= MOD\n    for i in range(1, ones + 1):\n        valid_permutations *= i\n        valid_permutations %= MOD\n    \n    # Calculate the total number of permutations.\n    total_permutations = 1\n    for i in range(1, n + 1):\n        total_permutations *= i\n        total_permutations %= MOD\n    \n    # Calculate the probability.\n    probability = valid_permutations * mod_inverse(total_permutations) % MOD\n    \n    return probability\n\n# Read input\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(calculate_probability(n, k, arr))"}
{"solution": "def min_seconds(x, y):\n    seconds = 0\n    while x > y:\n        if x > y * 2:\n            x //= 2\n            seconds += 1\n        else:\n            diff = x - y\n            x -= diff\n            seconds += diff\n    return seconds\n\nx, y = map(int, input().split())\nprint(min_seconds(x, y))"}
{"solution": "from math import sqrt\n\ndef min_norm_degenerate_matrix(a, b, c, d):\n    det = a * d - b * c\n    if det == 0:\n        return 0.0\n    else:\n        options = [\n            abs(a - b * (d / det)),\n            abs(d - a * (b / det)),\n            abs(c - d * (a / det)),\n            abs(b - c * (d / det))\n        ]\n        return min(options) / sqrt(2)\n\n# Reading input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculating and printing the output\nprint(min_norm_degenerate_matrix(a, b, c, d))"}
{"solution": "n, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\ndenied = 0\none_seater_used = 0\ntwo_seater_used = 0\none_person_at_two_seater = 0\n\nfor group in groups:\n    if group == 1:\n        if a - one_seater_used > 0:\n            one_seater_used += 1\n        elif b - two_seater_used > 0:\n            two_seater_used += 1\n        elif one_person_at_two_seater < two_seater_used:\n            one_person_at_two_seater += 1\n        else:\n            denied += 1\n    else:\n        if b - two_seater_used > 0:\n            two_seater_used += 1\n        else:\n            denied += 2\n\nprint(denied)"}
{"solution": "def calculate_failed_students(A, B, C, N):\n    # Calculate the number of students who visited only one restaurant\n    only_BugDonalds = A - C\n    only_BeverKing = B - C\n    \n    # Total number of students who visited at least one restaurant\n    total_visited = only_BugDonalds + only_BeverKing + C\n    \n    # Check if the data is consistent\n    if total_visited > N or (N - total_visited) < 1:\n        return -1\n    else:\n        # Number of students who did not pass the exam\n        failed_students = N - total_visited\n        return failed_students\n\n# Read input\nA, B, C, N = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_failed_students(A, B, C, N))"}
{"solution": "def expected_dresses(x, k):\n    MOD = 10**9 + 7\n    \n    def power_two_mod(n, k, mod):\n        result = 1\n        while k > 0:\n            if k % 2 == 1:\n                result = (result * n) % mod\n            n = (n * n) % mod\n            k //= 2\n        return result\n    \n    # Calculate the effect of the wardrobe eating a dress\n    eat_effect = (power_two_mod(2, k, MOD) - power_two_mod(2, k, MOD - 1)) % MOD\n    \n    # Calculate the final expected number of dresses\n    final_dresses = (power_two_mod(2, k + 1, MOD) * x - eat_effect) % MOD\n    \n    return final_dresses\n\n# Read input\nx, k = map(int, input().split())\n\n# Compute and print the result\nprint(expected_dresses(x, k))"}
{"solution": "from math import gcd\nfrom functools import reduce\n\nMOD = 998244353\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef process_problem(l, r, prev_l, prev_r):\n    total_prev = prev_r - prev_l + 1\n    total_curr = r - l + 1\n    overlap = max(0, min(r, prev_r) - max(l, prev_l) + 1)\n    return (total_prev * total_curr - overlap * overlap) % MOD\n\ndef solve(n, problems):\n    # Sort problems by lower bound to simplify calculation\n    problems.sort(key=lambda x: x[0])\n    \n    numerator = 1\n    denominator = 1\n    \n    for i in range(1, n):\n        numerator = (numerator * process_problem(problems[i][0], problems[i][1], problems[i-1][0], problems[i-1][1])) % MOD\n        denominator = (denominator * (problems[i][1] - problems[i][0] + 1)) % MOD\n    \n    # Ensure the denominator is coprime with MOD\n    assert gcd(denominator, MOD) == 1\n    \n    # Calculate the modular inverse of the denominator\n    denominator_inv = modinv(denominator)\n    \n    # Calculate the final result\n    result = (numerator * denominator_inv) % MOD\n    return result\n\n# Read input\nn = int(input())\nproblems = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve and print the result\nprint(solve(n, problems))"}
{"solution": "def count_ways_to_form_rectangle(n):\n    # Initialize the count of ways to form a rectangle but not a square\n    count = 0\n    \n    # Iterate over possible lengths for the sides of the rectangle\n    for a in range(1, n // 4 + 1):\n        for b in range(a, (n - 2 * a) // 2 + 1):\n            c = n - 2 * a - 2 * b\n            # Check if the sides form a rectangle but not a square\n            if c >= b and a != b:\n                count += 1\n                \n    return count\n\n# Read input\nn = int(input())\n\n# Calculate and print the result\nprint(count_ways_to_form_rectangle(n))"}
{"solution": "def find_min_kvass(n, s, volumes):\n    def is_possible(min_volume):\n        total_liters = 0\n        for v in volumes:\n            total_liters += max(v - min_volume, 0)\n        return total_liters >= s\n\n    if sum(volumes) < s:\n        return -1\n\n    left, right = 0, max(volumes)\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if is_possible(mid):\n            left = mid\n        else:\n            right = mid\n\n    return left\n\n# Reading input\nn, s = map(int, input().split())\nvolumes = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(find_min_kvass(n, s, volumes))"}
{"solution": "def caterpillar_and_apple(h1, h2, a, b):\n    if a <= b:\n        return -1  # Caterpillar cannot reach the apple\n    \n    net_gain_per_day = (8 * a) - (12 * b)\n    remaining_distance = h2 - h1\n    \n    # Calculate full days required\n    full_days = 0\n    while remaining_distance > net_gain_per_day:\n        remaining_distance -= net_gain_per_day\n        full_days += 1\n    \n    # Check if the caterpillar can reach the apple on the next day\n    if remaining_distance <= 8 * a:\n        return full_days\n    else:\n        return -1\n\n# Read input\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(caterpillar_and_apple(h1, h2, a, b))"}
{"solution": "def max_joy_units(C, H_r, H_b, W_r, W_b):\n    # Calculate the maximum number of candies Om Nom can eat without getting sick\n    max_red = C // W_r\n    max_blue = C // W_b\n    \n    # Initialize the maximum joy units\n    max_joy = 0\n    \n    # Iterate through all possible combinations of red and blue candies\n    for red in range(max_red + 1):\n        remaining_weight = C - (red * W_r)\n        if remaining_weight >= 0:\n            blue = remaining_weight // W_b\n            joy_units = (red * H_r) + (blue * H_b)\n            max_joy = max(max_joy, joy_units)\n    \n    return max_joy\n\n# Read input\nC, H_r, H_b, W_r, W_b = map(int, input().split())\n\n# Calculate and print the maximum number of joy units\nprint(max_joy_units(C, H_r, H_b, W_r, W_b))"}
{"solution": "def minimal_steps(start_x, start_y, end_x, end_y):\n    # Calculate the differences in x and y coordinates\n    delta_x = abs(start_x - end_x)\n    delta_y = abs(start_y - end_y)\n    \n    # The minimal number of steps is the maximum of the two deltas\n    # because the robot can move diagonally\n    steps = max(delta_x, delta_y)\n    return steps\n\n# Read input\nstart_x, start_y = map(int, input().split())\nend_x, end_y = map(int, input().split())\n\n# Calculate and print the minimal number of steps\nprint(minimal_steps(start_x, start_y, end_x, end_y))"}
{"solution": "from collections import deque\n\ndef predict_vote_outcome(n, employees):\n    depublicans = deque()\n    remocrats = deque()\n    for i, emp in enumerate(employees):\n        if emp == 'D':\n            depublicans.append(i)\n        else:\n            remocrats.append(i)\n\n    while len(depublicans) > 0 and len(remocrats) > 0:\n        for _ in range(len(depublicans)):\n            if not remocrats:\n                break\n            remocrats.popleft()  # Depublican removes the first Remocrat\n        for _ in range(len(remocrats)):\n            if not depublicans:\n                break\n            depublicans.popleft()  # Remocrat removes the first Depublican\n\n    return 'D' if depublicans else 'R'\n\n# Read input\nn = int(input())\nemployees = input().strip()\n\n# Predict and print the outcome\nprint(predict_vote_outcome(n, employees))"}
{"solution": "def count_tv_sets(a, b, x, y):\n    # Calculate the maximum possible value for w and h\n    max_w = a // (x // gcd(x, y))\n    max_h = b // (y // gcd(x, y))\n    \n    # Return the minimum of the two to get the number of valid TV sets\n    return min(max_w, max_h)\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Read input\na, b, x, y = map(int, input().split())\n\n# Calculate and print the result\nprint(count_tv_sets(a, b, x, y))"}
{"solution": "import math\n\ndef find_trailing_zeros(n, b):\n    \"\"\"\n    Calculate the number of trailing zero digits in the b-ary representation of n!\n    \"\"\"\n    def count_factors(n, p):\n        count = 0\n        while n > 0:\n            n //= p\n            count += n\n        return count\n    \n    prime_factors = []\n    i = 2\n    while i * i <= b:\n        if b % i == 0:\n            prime_factors.append(i)\n            while b % i == 0:\n                b //= i\n        i += 1\n    if b > 1:\n        prime_factors.append(b)\n    \n    min_count = float('inf')\n    for p in prime_factors:\n        count = count_factors(n, p)\n        min_count = min(min_count, count)\n    \n    return min_count\n\n# Reading input\nn, b = map(int, input().split())\n\n# Calculating and printing the result\nprint(find_trailing_zeros(n, b))"}
{"solution": "def calculate_sum(m, a, b):\n    gcd = math.gcd(a, b)\n    a //= gcd\n    b //= gcd\n    \n    if a == 1 or b == 1:\n        return (m + 1) * (m + 2) // 2\n    \n    period = a * b - a - b + 1\n    full_periods = m // period\n    remainder = m % period\n    \n    total_sum = full_periods * (a + b + (period - a - b) * (a + b) // 2)\n    current_pos = full_periods * period\n    while current_pos <= m:\n        total_sum += current_pos + 1\n        current_pos += a\n    current_pos = full_periods * period\n    while current_pos <= m:\n        total_sum += current_pos + 1\n        current_pos += b\n    \n    return total_sum\n\nimport math\n\nm, a, b = map(int, input().split())\nprint(calculate_sum(m, a, b))"}
{"solution": "def can_divide_into_odd_subsegments(n, sequence):\n    odd_count = 0\n    start = -1\n    \n    for i in range(n):\n        if sequence[i] % 2 != 0:\n            if start == -1:\n                start = i\n        else:\n            if start != -1:\n                if (i - start) % 2 == 1:\n                    odd_count += 1\n                    start = -1\n    \n    # Check the last segment if it ends with an odd number\n    if start != -1 and (n - start) % 2 == 1:\n        odd_count += 1\n    \n    return \"Yes\" if odd_count % 2 == 1 and odd_count > 0 else \"No\"\n\n# Reading input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Processing and printing output\nprint(can_divide_into_odd_subsegments(n, sequence))"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    # Check if the points form a vertical or horizontal line\n    if x1 == x2:\n        x3, x4 = x1, x2\n        y3, y4 = y2, y1\n    elif y1 == y2:\n        x3, x4 = x2, x1\n        y3, y4 = y1, y2\n    else:\n        # Check if the points can form a square\n        if abs(x1 - x2) == abs(y1 - y2):\n            x3, y3 = x1, y2\n            x4, y4 = x2, y1\n        else:\n            return [-1]\n    \n    return [x3, y3, x4, y4]\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\n\n# Find and print the coordinates of the remaining trees\nresult = find_remaining_trees(x1, y1, x2, y2)\nprint(*result)"}
{"solution": "MOD = 1000000007\n\ndef solve(x, y, n):\n    if n == 1:\n        return x % MOD\n    if n == 2:\n        return y % MOD\n    \n    # From the recurrence relation, we derive that f3 = y - x and fn = (-1)^(n+1) * (x - y)\n    if n >= 3:\n        if n % 2 == 0:\n            return ((y - x) % MOD + MOD) % MOD\n        else:\n            return ((x - y) % MOD + MOD) % MOD\n\n# Read input\nx, y = map(int, input().split())\nn = int(input())\n\n# Calculate and print the result\nprint(solve(x, y, n))"}
{"solution": "def can_split_array(n, arr):\n    # Initialize variables\n    start = 0\n    splits = []\n    \n    # Iterate through the array to find valid splits\n    for end in range(n):\n        # Check if the current subarray sum is non-zero\n        if sum(arr[start:end+1]) != 0:\n            splits.append((start + 1, end + 1))\n            start = end + 1\n    \n    # Check if the entire array was processed\n    if start == n:\n        if len(splits) > 0:\n            return \"YES\", splits\n        else:\n            return \"NO\", []\n    else:\n        return \"NO\", []\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Solve the problem\nresult, splits = can_split_array(n, arr)\n\n# Print the result\nprint(result)\nif result == \"YES\":\n    print(len(splits))\n    for split in splits:\n        print(split[0], split[1])"}
{"solution": "def min_quiz_score(n, m, k):\n    MOD = 1000000009\n    if k > m:\n        return m\n    dp = [0] * (m + 1)\n    dp[0] = 0\n    current_max = 0\n    for i in range(1, m + 1):\n        current_max = (current_max + 1) % MOD\n        if i >= k:\n            current_max = (current_max + (dp[i - k] * 2 - dp[i - k] - 1)) % MOD\n        dp[i] = current_max\n    return dp[m]\n\n# Reading input\nn, m, k = map(int, input().split())\n\n# Calculating and printing the result\nresult = min_quiz_score(n, m, k)\nprint(result)"}
{"solution": "def is_divisible_by_8(s):\n    # Check all substrings of length 1, 2, and 3\n    for i in range(len(s)):\n        # Check single digit\n        if int(s[i]) % 8 == 0:\n            return s[i]\n        # Check two digits\n        if i < len(s) - 1 and int(s[i:i+2]) % 8 == 0:\n            return s[i:i+2]\n        # Check three digits\n        if i < len(s) - 2 and int(s[i:i+3]) % 8 == 0:\n            return s[i:i+3]\n    \n    return \"\"\n\ndef solve(n):\n    # Remove leading zeros and check if the entire number is 0\n    n_str = str(n).lstrip('0')\n    if n_str == \"\" or n_str == \"0\":\n        return \"YES\\n0\"\n    \n    # Check for divisibility by 8\n    result = is_divisible_by_8(n_str)\n    if result:\n        return f\"YES\\n{result}\"\n    else:\n        return \"NO\"\n\n# Read input\nn = input().strip()\n\n# Solve and print the result\nprint(solve(n))"}
{"solution": "def find_floor(n, m, memory):\n    possible_flats_per_floor = set(range(1, 101))\n    \n    for k, f in memory:\n        if k % f == 0:\n            possible_flats_per_floor &= set(range(k // f, 101))\n        else:\n            possible_flats_per_floor &= set(range((k // f) + 1, 101))\n        \n        if f > 1:\n            if k % (f - 1) == 0:\n                possible_flats_per_floor -= set(range(1, k // (f - 1) + 1))\n            else:\n                possible_flats_per_floor -= set(range(1, (k // (f - 1)) + 1))\n    \n    if len(possible_flats_per_floor) == 1:\n        x = next(iter(possible_flats_per_floor))\n        return (n + x - 1) // x\n    else:\n        floors = {(n + x - 1) // x for x in possible_flats_per_floor}\n        if len(floors) == 1:\n            return next(iter(floors))\n        else:\n            return -1\n\n# Reading input\nn, m = map(int, input().split())\nmemory = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Calculating and printing the output\nprint(find_floor(n, m, memory))"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    board = [list(board1), list(board2)]\n    \n    # Define the four possible shapes of the bishwock\n    bishwock_shapes = [\n        [(0, 0), (0, 1), (1, 0)],  # Original L shape\n        [(0, 0), (0, 1), (1, 1)],  # Rotated 90 degrees\n        [(0, 1), (1, 0), (1, 1)],  # Rotated 180 degrees\n        [(0, 0), (1, 0), (1, 1)]   # Rotated 270 degrees\n    ]\n    \n    def can_place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            if nx < 0 or nx >= 2 or ny < 0 or ny >= n or board[nx][ny] == 'X':\n                return False\n        return True\n    \n    def place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            board[nx][ny] = 'X'\n    \n    count = 0\n    for y in range(n):\n        for x in range(2):\n            for shape in bishwock_shapes:\n                if can_place_bishwock(x, y, shape):\n                    place_bishwock(x, y, shape)\n                    count += 1\n                    break\n    \n    return count\n\n# Example usage\nboard1 = \"00X00X0XXX0\"\nboard2 = \"0XXX0X00X00\"\nprint(max_bishwocks(board1, board2))  # Output: 4"}
{"solution": "def max_pretty_set_length(s):\n    max_length = 0\n    current_set = set()\n    \n    for char in s:\n        if char.islower():\n            current_set.add(char)\n        else:\n            max_length = max(max_length, len(current_set))\n            current_set.clear()\n    \n    # Check the last segment\n    max_length = max(max_length, len(current_set))\n    \n    return max_length\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult = max_pretty_set_length(s)\n\n# Print the result\nprint(result)"}
{"solution": "def max_difference_partition(n, sequence):\n    # Calculate the total sum of the sequence\n    total_sum = sum(sequence)\n    # Initialize the minimum sum to be the total sum if all elements are negative\n    min_sum = min(0, total_sum)\n    \n    # Iterate through the sequence to find the maximum difference\n    current_sum = 0\n    for num in sequence:\n        current_sum += num\n        # Update the minimum sum with the current sum if it's more negative\n        min_sum = min(min_sum, current_sum)\n    \n    # The maximum possible value of B - C is the total sum minus the minimum sum\n    max_diff = total_sum - min_sum\n    print(max_diff)\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Solving the problem\nmax_difference_partition(n, a)"}
{"solution": "def min_refuels(a, b, f, k):\n    # Calculate the maximum distance the bus can travel without refueling\n    max_distance_without_refuel = 2 * f if 2 * f <= b else b + (b - 2 * f)\n    \n    # Check if the bus can complete a single journey without refueling\n    if 2 * a <= b:\n        return 0\n    \n    # Check if the bus can reach the gas station at least once\n    if f > b:\n        return -1\n    \n    # Calculate the minimum number of refuels needed per round trip\n    refuels_per_round_trip = 0\n    if 2 * f > b:\n        refuels_per_round_trip = 1\n    elif f + a > b:\n        refuels_per_round_trip = 1\n    \n    # Calculate the total number of refuels needed\n    total_refuels = 0\n    remaining_journeys = k\n    while remaining_journeys > 0:\n        # Calculate how many round trips can be made without refueling\n        trips_without_refuel = (b - f) // (a - f)\n        if trips_without_refuel >= remaining_journeys:\n            return total_refuels + (remaining_journeys - 1) * refuels_per_round_trip\n        else:\n            total_refuels += trips_without_refuel * refuels_per_round_trip\n            remaining_journeys -= trips_without_refuel\n        \n        # Refuel after completing the trips without refueling\n        if remaining_journeys > 0:\n            total_refuels += 1\n    \n    return total_refuels\n\n# Read input\na, b, f, k = map(int, input().split())\n\n# Output the result\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(s, p, q):\n    n = len(s)\n    result = []\n    \n    def can_split(length_p, length_q):\n        remaining = n\n        while remaining > 0:\n            if length_p <= remaining:\n                result.append(s[:length_p])\n                s = s[length_p:]\n                remaining -= length_p\n            elif length_q <= remaining:\n                result.append(s[:length_q])\n                s = s[length_q:]\n                remaining -= length_q\n            else:\n                return False\n        return True\n    \n    if can_split(p, q) or can_split(q, p):\n        print(len(result))\n        for piece in result:\n            print(piece)\n    else:\n        print(\"-1\")\n\n# Reading input\nn, p, q = map(int, input().split())\ns = input()\n\n# Solving the problem\nsplit_string(s, p, q)"}
{"solution": "from bisect import bisect_left\n\ndef can_reach_finish(n, m, s, d, obstacles):\n    obstacles.sort()\n    obstacles.append(m)\n    \n    def can_reach(start, end):\n        if start >= end:\n            return True\n        index = bisect_left(obstacles, start + s, hi=len(obstacles) - 1)\n        if index == len(obstacles) - 1:\n            return False\n        max_jump_end = min(end, obstacles[index + 1] - 1)\n        if start + s <= max_jump_end and max_jump_end - (start + s) <= d:\n            return True\n        return any(can_reach(max(0, obs - d), obs) for obs in obstacles[index:] if start + s <= obs <= max_jump_end)\n\n    if not can_reach(0, m):\n        print(\"IMPOSSIBLE\")\n        return\n\n    path = []\n    current_pos = 0\n    while current_pos < m:\n        index = bisect_left(obstacles, current_pos + s, hi=len(obstacles) - 1)\n        max_jump_end = min(m, obstacles[index + 1] - 1)\n        if current_pos + s <= max_jump_end and max_jump_end - (current_pos + s) <= d:\n            path.append((\"RUN\", s))\n            path.append((\"JUMP\", max_jump_end - (current_pos + s)))\n            current_pos = max_jump_end\n        else:\n            for obs in obstacles[index:]:\n                if current_pos + s <= obs <= max_jump_end:\n                    if can_reach(max(0, obs - d), obs):\n                        path.append((\"RUN\", obs - current_pos))\n                        path.append((\"JUMP\", obs - (obs - d)))\n                        current_pos = obs\n                        break\n\n    for action, value in path:\n        if action == \"RUN\":\n            print(f\"RUN {value}\")\n        elif action == \"JUMP\":\n            print(f\"JUMP {value}\")\n\n# Read input\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\n# Solve and print output\ncan_reach_finish(n, m, s, d, obstacles)"}
{"solution": "def count_pairs(s, x):\n    # Check if s - x is even, which is a necessary condition for a and b to be integers\n    if (s - x) % 2 == 0:\n        # Calculate b\n        b = (s - x) // 2\n        # Check if b is non-negative\n        if b >= 0:\n            # Since a = s - b, we need to ensure a is also positive\n            a = s - b\n            if a > 0 and b > 0:\n                # There are 2 valid pairs: (a, b) and (b, a)\n                return 2\n    # If the conditions are not met, return 0\n    return 0\n\n# Read input\ns, x = map(int, input().split())\n\n# Print the result\nprint(count_pairs(s, x))"}
{"solution": "def min_actions(n, k):\n    # Calculate the minimum number of actions needed to turn over all skewers\n    actions = []\n    step = 2 * k + 1\n    if k == 0:\n        actions.append(1)\n    else:\n        for i in range(1, n + 1, step):\n            actions.append(i)\n            if i + k > n:\n                break\n    return len(actions), actions\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nl, actions = min_actions(n, k)\nprint(l)\nprint(' '.join(map(str, actions)))"}
{"solution": "import math\n\ndef min_operations_to_square(n):\n    n_str = str(n)\n    n_len = len(n_str)\n    \n    # Generate all possible squares up to the maximum possible value\n    max_square_root = int(math.sqrt(2 * 10**9)) + 1\n    squares = [str(i * i) for i in range(1, max_square_root + 1)]\n    \n    def is_subsequence(small, large):\n        it = iter(large)\n        return all(char in it for char in small)\n    \n    min_deletions = float('inf')\n    \n    for square in squares:\n        if is_subsequence(square, n_str):\n            deletions = n_len - len(square)\n            min_deletions = min(min_deletions, deletions)\n    \n    return min_deletions if min_deletions != float('inf') else -1\n\n# Read input\nn = int(input())\n\n# Calculate and print the result\nprint(min_operations_to_square(n))"}
{"solution": "from math import gcd\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef mod_inverse(x):\n    return pow(x, MOD - 2, MOD)\n\ndef mod_factorial(n):\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n        inv_fact[i] = mod_inverse(fact[i])\n    return fact, inv_fact\n\ndef mod_combinations(n, k, fact, inv_fact):\n    return fact[n] * inv_fact[k] * inv_fact[n - k] % MOD\n\ndef count_good_permutations(n):\n    fact, inv_fact = mod_factorial(n)\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    result = 0\n    \n    for i in range(2, n + 1):\n        dp[i] = mod_combinations(i - 1, 1, fact, inv_fact) * dp[i - 1] % MOD\n        for j in range(i // 2, 1, -1):\n            dp[i] += mod_combinations(i - 1, j - 1, fact, inv_fact) * dp[j] % MOD\n            dp[i] %= MOD\n        \n        if i % 2 == 0:\n            dp[i] += mod_combinations(i - 1, i // 2 - 1, fact, inv_fact)\n            dp[i] %= MOD\n        \n        result += dp[i]\n        result %= MOD\n    \n    return result\n\nn = int(input())\nprint(count_good_permutations(n))"}
{"solution": "def minimum_jump_ability(s):\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    positions = [-1]  # Start position before the first character\n    \n    # Collect positions of all vowels\n    for i, char in enumerate(s):\n        if char in vowels:\n            positions.append(i)\n    \n    positions.append(len(s))  # End position after the last character\n    \n    # Calculate maximum distance between consecutive positions\n    max_distance = 0\n    for i in range(1, len(positions)):\n        max_distance = max(max_distance, positions[i] - positions[i - 1])\n    \n    return max_distance\n\n# Read input\ns = input().strip()\n\n# Calculate and print the minimum jump ability\nprint(minimum_jump_ability(s))"}
{"solution": "def can_distribute_equally(a1, a2, a3, a4):\n    total_candies = a1 + a2 + a3 + a4\n    # If the total number of candies is odd, it's impossible to distribute equally\n    if total_candies % 2 != 0:\n        return \"NO\"\n    \n    # Check if there's any combination of two bags that equals half of the total candies\n    if (a1 + a2 == total_candies // 2) or \\\n       (a1 + a3 == total_candies // 2) or \\\n       (a1 + a4 == total_candies // 2) or \\\n       (a2 + a3 == total_candies // 2) or \\\n       (a2 + a4 == total_candies // 2) or \\\n       (a3 + a4 == total_candies // 2):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\na1, a2, a3, a4 = map(int, input().split())\n\n# Output result\nprint(can_distribute_equally(a1, a2, a3, a4))"}
{"solution": "def optimal_pie_distribution(pie_slices):\n    n = len(pie_slices)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for length in range(1, n + 1):\n        for start in range(n - length + 1):\n            end = start + length\n            if length == 1:\n                dp[start][end] = pie_slices[start]\n            else:\n                take_start = pie_slices[start] + dp[start + 1][end] - dp[start + 1][start + length - 1]\n                take_end = pie_slices[start + length - 1] + dp[start][end - 1] - dp[start + length - 1][end - 1]\n                dp[start][end] = max(take_start, take_end)\n    \n    alice_score = dp[0][n]\n    bob_score = sum(pie_slices) - alice_score\n    return alice_score, bob_score\n\n# Reading input\nn = int(input())\npie_slices = list(map(int, input().split()))\n\n# Calculating and printing output\nalice_score, bob_score = optimal_pie_distribution(pie_slices)\nprint(alice_score, bob_score)"}
{"solution": "from collections import defaultdict\n\ndef min_variables(n, seq):\n    factors = defaultdict(int)\n    \n    def factorize(x):\n        if x == 1:\n            return\n        for i in range(2, int(x**0.5) + 1):\n            while x % i == 0:\n                factors[i] += 1\n                x //= i\n        if x > 1:\n            factors[x] += 1\n    \n    for num in seq:\n        factorize(num)\n    \n    prime_factors = list(factors.keys())\n    \n    # Check if there is any prime factor with frequency more than 1\n    for factor in prime_factors:\n        if factors[factor] > 1:\n            return -1\n    \n    # Count the number of unique prime factors\n    return len(prime_factors)\n\n# Reading input\nn = int(input())\nseq = list(map(int, input().split()))\n\n# Output\nprint(min_variables(n, seq))"}
{"solution": "def determine_winner(n, piles):\n    odd_count = sum(1 for pile in piles if pile % 2 != 0)\n    if odd_count % 2 == 0:\n        return \"Alice\"\n    else:\n        return \"Bob\"\n\n# Read input\nn = int(input())\npiles = list(map(int, input().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, piles))"}
{"solution": "def can_make_equal(arr):\n    arr.sort()\n    n = len(arr)\n    \n    # Check if it's possible to make all elements equal\n    if (arr[-1] - arr[0]) % 2 == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output result\nprint(can_make_equal(arr))"}
{"solution": "def find_longest_repeated_substring(s):\n    n = len(s)\n    max_len = 0\n    # Create a set to store seen substrings\n    seen = set()\n    \n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            # Extract substring\n            substring = s[i:j]\n            if substring in seen and i + len(substring) <= j:\n                max_len = max(max_len, len(substring))\n            else:\n                seen.add(substring)\n                \n    return max_len\n\n# Read input\nn = int(input())\ns = input()\n\n# Find and print the maximum length\nprint(find_longest_repeated_substring(s))"}
{"solution": "def minimum_time_to_house(n, a):\n    if a % 2 == 1:\n        # a is odd\n        return (a + 1) // 2\n    else:\n        # a is even\n        return (n - a + 2) // 2\n\n# Read input\nn, a = map(int, input().split())\n\n# Calculate and print the result\nprint(minimum_time_to_house(n, a))"}
{"solution": "def is_mission_possible(n, m, lightsabers, color_counts):\n    from collections import defaultdict\n\n    # Initialize variables\n    required_sum = sum(color_counts)\n    current_counts = defaultdict(int)\n    current_sum = 0\n    left = 0\n\n    # Function to update counts when adding or removing elements\n    def update_counts(action, color):\n        nonlocal current_sum\n        current_counts[color] += action\n        if current_counts[color] > 0:\n            current_sum += 1\n        elif current_counts[color] == 0:\n            current_sum -= 1\n\n    # Check each possible subarray\n    for right in range(n):\n        update_counts(1, lightsabers[right])\n\n        # Shrink the window from the left if it's too large\n        while current_sum > required_sum or (current_counts[lightsabers[right]] > color_counts[lightsabers[right] - 1]):\n            update_counts(-1, lightsabers[left])\n            left += 1\n\n        # Check if the current window matches the required counts\n        if all(current_counts[i + 1] == count for i, count in enumerate(color_counts)):\n            return \"YES\"\n\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nlightsabers = list(map(int, input().split()))\ncolor_counts = list(map(int, input().split()))\n\n# Output result\nprint(is_mission_possible(n, m, lightsabers, color_counts))"}
{"solution": "def determine_winner(n, rounds):\n    mishka_wins = 0\n    chris_wins = 0\n    \n    for m, c in rounds:\n        if m > c:\n            mishka_wins += 1\n        elif c > m:\n            chris_wins += 1\n    \n    if mishka_wins > chris_wins:\n        return \"Mishka\"\n    elif chris_wins > mishka_wins:\n        return \"Chris\"\n    else:\n        return \"Friendship is magic!^^\"\n\n# Reading input\nn = int(input())\nrounds = [list(map(int, input().split())) for _ in range(n)]\n\n# Determining and printing the winner\nprint(determine_winner(n, rounds))"}
{"solution": "def is_valid_minesweeper_field(n, m, field):\n    def count_bombs(i, j):\n        count = 0\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                nx, ny = i + dx, j + dy\n                if 0 <= nx < n and 0 <= ny < m and field[nx][ny] == '*':\n                    count += 1\n        return count\n\n    for i in range(n):\n        for j in range(m):\n            cell = field[i][j]\n            if cell == '.':\n                if any(0 <= i + dx < n and 0 <= j + dy < m and field[i + dx][j + dy] == '*' for dx in [-1, 0, 1] for dy in [-1, 0, 1]):\n                    return \"NO\"\n            elif cell.isdigit():\n                expected_bombs = int(cell)\n                actual_bombs = count_bombs(i, j)\n                if expected_bombs != actual_bombs:\n                    return \"NO\"\n    return \"YES\"\n\n# Reading input\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\n# Printing output\nprint(is_valid_minesweeper_field(n, m, field))"}
{"solution": "def can_vasya_eat_half(n, k):\n    total_candies = n\n    vasya_eaten = 0\n    \n    while total_cries > 0:\n        # Vasya eats k candies\n        vasya_eaten += min(k, total_candies)\n        total_candies -= min(k, total_candies)\n        \n        # Petya eats 10% of the remaining candies\n        petya_eaten = total_candies // 10\n        total_candies -= petya_eaten\n    \n    return vasya_eaten >= (n + 1) // 2\n\ndef find_min_k(n):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Read input\nn = int(input().strip())\n\n# Find and print the minimal k\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace(s):\n    p = s.count('o')\n    l = s.count('-')\n    \n    if p == 0 or p == 1:\n        return \"YES\"\n    if l % p == 0:\n        return \"YES\"\n    return \"NO\"\n\n# Function to read input and call the can_rearrange_necklace function\ndef solve():\n    s = input().strip()\n    print(can_rearrange_necklace(s))\n\n# Call the solve function\nsolve()"}
{"solution": "def max_pillows_for_frodo(n, m, k):\n    low, high = 1, m\n    while low <= high:\n        mid = (low + high) // 2\n        required_pillows = mid * (mid + 1) // 2\n        left_diff = max(0, mid - 1)\n        right_diff = max(0, mid - 1)\n        if k > 1:\n            required_pillows += (mid - 1) * (mid) // 2 + (k - 1) * left_diff\n        if n - k > 0:\n            required_pillows += (mid - 1) * (mid) // 2 + (n - k) * right_diff\n        if required_pillows <= m:\n            feasible = True\n            low = mid + 1\n        else:\n            feasible = False\n            high = mid - 1\n    if feasible:\n        return low - 1\n    else:\n        return high\n\n# Reading input\nn, m, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(max_pillows_for_frodo(n, m, k))"}
{"solution": "from math import ceil\n\ndef max_subarray_cost(n, m, k, a):\n    dp = [0] * (n + 1)\n    max_cost = 0\n    queue = []\n    \n    for i in range(1, n + 1):\n        dp[i] = a[i - 1] + dp[i - 1]\n        while queue and dp[queue[-1]] < dp[i]:\n            queue.pop()\n        while queue and i - queue[0] >= m:\n            queue.pop(0)\n        current_cost = dp[i] - k * ceil(i / m)\n        max_cost = max(max_cost, current_cost - (dp[queue[0]] - k * ceil(queue[0] / m)) if queue else 0)\n        queue.append(i)\n    \n    return max_cost\n\n# Reading input\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(max_subarray_cost(n, m, k, a))"}
{"solution": "def find_longest_polyline(n, m):\n    # Define the four points to maximize the polyline length\n    p1 = (0, 0)\n    p2 = (n, 0)\n    p3 = (n, m)\n    p4 = (0, m)\n    \n    # Print the coordinates of the four points\n    print(p1[0], p1[1])\n    print(p2[0], p2[1])\n    print(p3[0], p3[1])\n    print(p4[0], p4[1])\n\n# Read input\nn, m = map(int, input().split())\n\n# Solve and print the result\nfind_longest_polyline(n, m)"}
{"solution": "def find_smallest_number(shuffled_str, remembered_substring):\n    def is_subsequence(s, sub):\n        it = iter(s)\n        return all(c in it for c in sub)\n\n    n = len(shuffled_str)\n    m = len(remembered_substring)\n    dp = [0] * (n + 1)\n    for i in range(n):\n        dp[i + 1] = min(dp[i] * 10 + int(shuffled_str[i]), 10**9)\n\n    for length in range(1, n + 1):\n        if n - length == len(remembered_substring) and is_subsequence(shuffled_str[:length], remembered_substring):\n            num = dp[length]\n            remaining = shuffled_str[:length].replace(remembered_substring, '')\n            num_str = str(num) + remaining\n            num_str = num_str.lstrip('0')\n            if not num_str:\n                num_str = '0'\n            return num_str\n\n# Reading input\nshuffled_str = input().strip()\nremembered_substring = input().strip()\n\n# Calculating and printing the output\nprint(find_smallest_number(shuffled_str, remembered_substring))"}
{"solution": "def check_temperatures(n, m, min_temp, max_temp, temperatures):\n    # Initialize counters for temperatures below and above the given temperatures\n    below_min = above_max = 0\n    \n    # Count how many temperatures are below the minimum and above the maximum\n    for temp in temperatures:\n        if temp < min_temp:\n            below_min += 1\n        if temp > max_temp:\n            above_max += 1\n    \n    # Check if it's possible to add temperatures to meet the requirements\n    if below_min == 0 and above_max == 0 and min_temp <= max(temperatures) and max_temp >= min(temperatures):\n        remaining_slots = n - m\n        lowest_temp_needed = min_temp - max(temperatures)\n        highest_temp_needed = max_temp - min(temperatures)\n        if lowest_temp_needed <= remaining_slots and highest_temp_needed <= remaining_slots:\n            return \"Correct\"\n    \n    return \"Incorrect\"\n\n# Read input\nn, m, min_temp, max_temp = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\n# Print the result\nprint(check_temperatures(n, m, min_temp, max_temp, temperatures))"}
{"solution": "def count_trailing_zeroes(n):\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count\n\ndef find_numbers_with_m_zeroes(m):\n    start, end = 0, 1000000  # Adjust the range based on the problem constraints\n    \n    # Binary search to find the range of numbers\n    while start <= end:\n        mid = (start + end) // 2\n        if count_trailing_zeroes(mid) < m:\n            start = mid + 1\n        else:\n            end = mid - 1\n            \n    lower_bound = start\n    \n    start, end = lower_bound, 1000000  # Reset the search for the upper bound\n    \n    while start <= end:\n        mid = (start + end) // 2\n        if count_trailing_zeroes(mid) <= m:\n            start = mid + 1\n        else:\n            end = mid - 1\n            \n    upper_bound = end\n    \n    # Collect all numbers within the range that have exactly m trailing zeroes\n    results = []\n    for n in range(lower_bound, upper_bound + 1):\n        if count_trailing_zeroes(n) == m:\n            results.append(n)\n    \n    return results\n\n# Read input\nm = int(input())\n\n# Find numbers with exactly m trailing zeroes\nresults = find_numbers_with_m_zeroes(m)\n\n# Output the result\nprint(len(results))\nprint(' '.join(map(str, results)))"}
{"solution": "from heapq import heappush, heappop\nfrom collections import defaultdict\n\ndef dijkstra(graph, start):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[v] > w:\n                dist[v] = w\n                heappush(pq, (w, v))\n    return dist\n\ndef find_farthest_special_vertices(n, m, k, special_vertices, edges):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u-1].append((v-1, w))\n        graph[v-1].append((u-1, w))\n    \n    # Compute distances from each special vertex to all other vertices\n    distances_from_special = [dijkstra(graph, sv-1) for sv in special_vertices]\n    \n    # Find the farthest special vertex for each special vertex\n    result = []\n    for i, sv in enumerate(special_vertices):\n        max_dist = max(distances_from_special[i][sv-1] for sv in special_vertices if sv != special_vertices[i])\n        result.append(max_dist)\n    \n    return result\n\n# Read input\nn, m, k = map(int, input().split())\nspecial_vertices = list(map(int, input().split()))\nedges = [list(map(int, input().split())) for _ in range(m)]\n\n# Solve and print output\nprint(*find_farthest_special_vertices(n, m, k, special_vertices, edges))"}
{"solution": "def initial_position(n, x):\n    # Determine the initial position of the ball\n    if n % 2 == 0:\n        # Even number of moves\n        if x == 0: return 0\n        elif x == 1: return 1\n        else: return 2\n    else:\n        # Odd number of moves\n        if x == 0: return 1\n        elif x == 1: return 0\n        else: return 1\n\n# Read input\nn = int(input())\nx = int(input())\n\n# Print the initial position\nprint(initial_position(n, x))"}
{"solution": "def check_square(rectangles):\n    min_x, min_y = float('inf'), float('inf')\n    max_x, max_y = float('-inf'), float('-inf')\n    \n    # Determine bounding box\n    for x1, y1, x2, y2 in rectangles:\n        min_x, min_y = min(min_x, x1), min(min_y, y1)\n        max_x, max_y = max(max_x, x2), max(max_y, y2)\n    \n    # Check if bounding box forms a square\n    if max_x - min_x != max_y - min_y:\n        return \"NO\"\n    \n    # Initialize grid\n    width = max_x - min_x + 1\n    height = max_y - min_y + 1\n    grid = [[False] * width for _ in range(height)]\n    \n    # Fill grid based on rectangles\n    for x1, y1, x2, y2 in rectangles:\n        for x in range(x1, x2):\n            for y in range(y1, y2):\n                if grid[y - min_y][x - min_x]:\n                    return \"NO\"  # Overlap detected\n                grid[y - min_y][x - min_x] = True\n    \n    # Check if all cells in the bounding box are covered\n    for y in range(height):\n        for x in range(width):\n            if not grid[y][x]:\n                return \"NO\"  # Gap detected\n    \n    return \"YES\"\n\n# Read input\nn = int(input())\nrectangles = [list(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(check_square(rectangles))"}
{"solution": "def count_digits(n):\n    return len(str(n))\n\ndef sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef count_really_big_numbers(n, s):\n    count = 0\n    max_possible_digits = count_digits(n)\n    \n    # Precompute the maximum possible sum of digits for a given number of digits\n    max_sum_of_digits = [9 * i for i in range(max_possible_digits + 1)]\n    \n    # Calculate the minimum value for each number of digits\n    min_values = [max(0, s - max_sum_of_digits[i]) for i in range(max_possible_digits + 1)]\n    \n    def helper(current, remaining_digits, min_value):\n        nonlocal count\n        if remaining_digits == 0:\n            if current >= min_value:\n                count += 1\n            return\n        \n        for digit in range(10):\n            if current * 10 + digit < min_value:\n                continue\n            helper(current * 10 + digit, remaining_digits - 1, min_value - digit)\n    \n    for digits in range(1, max_possible_digits + 1):\n        min_value = min_values[digits]\n        helper(0, digits, min_value)\n    \n    # Adjust for numbers up to n\n    diff = n - sum_of_digits(n)\n    if diff >= s:\n        count += 1\n    \n    # Subtract counts for numbers with more digits than n\n    num_digits = count_digits(n)\n    for digits in range(num_digits + 1, max_possible_digits + 1):\n        count -= min_values[digits]\n    \n    return count\n\n# Read input\nn, s = map(int, input().split())\n\n# Calculate and print the result\nprint(count_really_big_numbers(n, s))"}
{"solution": "from collections import defaultdict\n\ndef can_cover_with_two_lines(n, points):\n    # Create dictionaries to count occurrences of x and y coordinates\n    x_count = defaultdict(int)\n    y_count = defaultdict(int)\n    \n    # Count occurrences of each x and y coordinate\n    for x, y in points:\n        x_count[x] += 1\n        y_count[y] += 1\n    \n    # Check if any x or y coordinate appears in at least n-1 points\n    if any(count >= n - 1 for count in x_count.values()):\n        return \"YES\"\n    if any(count >= n - 1 for count in y_count.values()):\n        return \"YES\"\n    \n    # Calculate slopes for each pair of points\n    slopes = defaultdict(int)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dx = points[j][0] - points[i][0]\n            dy = points[j][1] - points[i][1]\n            \n            # Avoid division by zero\n            if dx == 0:\n                slope = (float('inf'), dy)\n            elif dy == 0:\n                slope = (dx, float('inf'))\n            else:\n                gcd = math.gcd(dx, dy)\n                slope = (dx // gcd, dy // gcd)\n            \n            slopes[slope] += 1\n    \n    # Check if there are two lines covering all points\n    if max(slopes.values()) >= n - 1:\n        return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Determine if two lines can cover all points\nprint(can_cover_with_two_lines(n, points))"}
{"solution": "from collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef solve(a, b, k, t):\n    diff = a - b\n    dp = defaultdict(int)\n    dp[diff] = 1\n    \n    for _ in range(t):\n        new_dp = defaultdict(int)\n        for d, count in dp.items():\n            for x in range(-k, k + 1):\n                new_diff = d + x\n                new_dp[new_diff] = (new_dp[new_diff] + count) % MOD\n        dp = new_dp\n    \n    result = sum(dp[d] for d in dp if d > 0) % MOD\n    return result\n\na, b, k, t = map(int, input().split())\nprint(solve(a, b, k, t))"}
{"solution": "from typing import List\n\ndef min_marks(n: int, l: int, x: int, y: int, marks: List[int]) -> List[int]:\n    def can_measure(distance: int, marks: List[int]) -> bool:\n        seen = set(marks)\n        for mark in marks:\n            if distance + mark in seen or abs(mark - distance) in seen:\n                return True\n        return False\n\n    needed_marks = set()\n    if not can_measure(x, marks):\n        needed_marks.add(x)\n    if not can_measure(y, marks):\n        needed_marks.add(y)\n\n    return sorted(list(needed_marks))\n\ndef main():\n    n, l, x, y = map(int, input().split())\n    marks = list(map(int, input().split()))\n    result_marks = min_marks(n, l, x, y, marks)\n    \n    print(len(result_marks))\n    print(\" \".join(map(str, result_marks)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef max_cake_volume(n, cakes):\n    # Calculate volumes and store them in a list\n    volumes = [math.pi * r**2 * h for r, h in cakes]\n    \n    # Initialize DP array to store the maximum volume up to each index\n    dp = [0] * n\n    \n    # Function to perform binary search\n    def binary_search(volumes, current_index, start, end):\n        while start < end:\n            mid = (start + end) // 2\n            if volumes[mid] < volumes[current_index]:\n                start = mid + 1\n            else:\n                end = mid\n        return start\n    \n    # Initialize a list to keep track of the indices of the smallest tail of all increasing subsequences\n    tails_indices = []\n    \n    for i in range(n):\n        pos = binary_search(volumes, i, 0, len(tails_indices))\n        dp[i] = volumes[i] + (dp[tails_indices[pos-1]] if pos > 0 else 0)\n        \n        # Update tails_indices\n        if pos == len(tails_indices):\n            tails_indices.append(i)\n        elif volumes[i] < volumes[tails_indices[pos]]:\n            tails_indices[pos] = i\n    \n    # Find the maximum volume\n    max_volume = max(dp)\n    return max_volume\n\n# Read input\nn = int(input())\ncakes = [list(map(int, input().split())) for _ in range(n)]\n\n# Compute and print the result\nprint(max_cake_volume(n, cakes))"}
{"solution": "def min_good_slices(n, k, heights):\n    def is_possible(cuts):\n        target_height = heights[n - cuts]\n        total_cost = 0\n        for height in heights[:n - cuts]:\n            if height > target_height:\n                total_cost += height - target_height\n                if total_cost > k:\n                    return False\n        return True\n\n    heights.sort()\n    low, high = 0, n\n    while low < high:\n        mid = (low + high) // 2\n        if is_possible(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\n# Reading input\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(min_good_slices(n, k, heights))"}
{"solution": "def max_game_score(n, a):\n    # Calculate prefix sums\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n    \n    # Initialize variables to track the maximum score and the maximum value in the array\n    max_score = float('-inf')\n    max_value = max(a)\n    \n    # Precompute the sum of the whole array minus each element\n    total_sum = prefix_sum[n]\n    for i in range(n):\n        score = total_sum - a[i]\n        max_score = max(max_score, score)\n    \n    # Handle the case where the maximum value is negative or zero\n    if max_value <= 0:\n        return 0\n    \n    return max_score\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the maximum score\nprint(max_game_score(n, a))"}
{"solution": "from math import gcd\n\ndef find_lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef can_light_continuously(k1, k2, k3):\n    lcm12 = find_lcm(k1, k2)\n    lcm123 = find_lcm(lcm12, k3)\n    return lcm123 == 1 or (lcm123 // k1 != k2 and lcm123 // k2 != k1 and lcm123 // k3 != k1 and lcm123 // k3 != k2)\n\ndef main():\n    k1, k2, k3 = map(int, input().split())\n    print(\"YES\" if can_light_continuously(k1, k2, k3) else \"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_operations_to_delete_string(n, s):\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(n)]\n    \n    # Base case: single character substrings\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the DP table for substrings of length greater than 1\n    for length in range(2, n + 1):  # length of the substring\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j-1]\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n    \n    # The result for the entire string\n    return dp[0][n-1]\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "# Read the number of boys and their dancing skills\nn = int(input())\nboys = list(map(int, input().split()))\n\n# Read the number of girls and their dancing skills\nm = int(input())\ngirls = list(map(int, input().split()))\n\n# Sort both lists to make it easier to find matching pairs\nboys.sort()\ngirls.sort()\n\n# Initialize pointers for boys and girls lists\nboy_idx, girl_idx = 0, 0\npairs = 0\n\n# Iterate through both lists to find matching pairs\nwhile boy_idx < n and girl_idx < m:\n    # Check if the difference in skills is within the allowed limit\n    if abs(boys[boy_idx] - girls[girl_idx]) <= 1:\n        pairs += 1\n        boy_idx += 1\n        girl_idx += 1\n    elif boys[boy_idx] < girls[girl_idx]:\n        boy_idx += 1\n    else:\n        girl_idx += 1\n\n# Print the maximum number of pairs\nprint(pairs)"}
{"solution": "def determine_winner(a, b):\n    # Calculate all possible configurations for Team 1\n    team1_configs = [(a[0], b[0], a[1], b[1]), (a[1], b[1], a[0], b[0])]\n    team2_configs = [(a[2], b[2], a[3], b[3]), (a[3], b[3], a[2], b[2])]\n\n    # Check if Team 1 can guarantee a win\n    team1_can_win = any(\n        all(\n            (team1_def >= team2_att and team1_att >= team2_def)\n            for team2_def, team2_att, _, _ in team2_configs\n        )\n        for team1_def, team1_att, _, _ in team1_configs\n    )\n\n    # Check if Team 2 can guarantee a win\n    team2_can_win = any(\n        all(\n            (team2_def >= team1_att and team2_att >= team1_def)\n            for team1_def, team1_att, _, _ in team1_configs\n        )\n        for team2_def, team2_att, _, _ in team2_configs\n    )\n\n    # Determine the winner or if it's a draw\n    if team1_can_win and not team2_can_win:\n        return \"Team 1\"\n    elif team2_can_win and not team1_can_win:\n        return \"Team 2\"\n    else:\n        return \"Draw\"\n\n# Read input\na = []\nb = []\nfor _ in range(4):\n    ai, bi = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\n\n# Output the result\nprint(determine_winner(a, b))"}
{"solution": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef calculate_time(X, Y, meats, K):\n    distances = [(c * np.sqrt((X - x) ** 2 + (Y - y) ** 2)) for x, y, c in meats]\n    return np.partition(distances, K - 1)[K - 1]\n\ndef objective_func(position, meats, K):\n    X, Y = position\n    return calculate_time(X, Y, meats, K)\n\ndef find_optimal_position(meats, K):\n    initial_guess = (0.0, 0.0)\n    result = minimize(lambda pos: objective_func(pos, meats, K), initial_guess, method='Powell')\n    return result.fun\n\n# Reading input\nN, K = map(int, input().split())\nmeats = [tuple(map(int, input().split())) + (i,) for i in range(N)]\n\n# Solving for the optimal position\noptimal_time = find_optimal_position(meats, K)\nprint(f\"{optimal_time:.6f}\")"}
{"solution": "def determine_winner(n, ticket):\n    left_sum = 0\n    right_sum = 0\n    left_erasures = 0\n    right_erasures = 0\n    \n    half = n // 2\n    \n    for i, char in enumerate(ticket):\n        if char == '?':\n            if i < half:\n                left_erasures += 1\n            else:\n                right_erasures += 1\n        else:\n            if i < half:\n                left_sum += int(char)\n            else:\n                right_sum += int(char)\n    \n    # Calculate the maximum possible sum that can be achieved by replacing erasures\n    max_left_sum = left_sum + min(9 * (left_erasures // 2), 9 * (right_erasures // 2))\n    max_right_sum = right_sum + min(9 * (right_erasures // 2), 9 * (left_erasures // 2))\n    \n    # Check if the sums can be made equal\n    if max_left_sum == max_right_sum:\n        return \"Bicarp\"\n    else:\n        return \"Monocarp\"\n\n# Read input\nn = int(input())\nticket = input()\n\n# Output result\nprint(determine_winner(n, ticket))"}
{"solution": "def find_bus_route(n, t, bus_routes):\n    earliest_time = float('inf')\n    chosen_route = -1\n    \n    for i in range(n):\n        s_i, d_i = bus_routes[i]\n        \n        if s_i >= t:\n            next_bus_time = s_i\n        else:\n            # Calculate the next bus time after t\n            if (t - s_i) % d_i == 0:\n                next_bus_time = t\n            else:\n                next_bus_time = s_i + ((t - s_i) // d_i + 1) * d_i\n        \n        if next_bus_time <= t and next_bus_time < earliest_time:\n            earliest_time = next_bus_time\n            chosen_route = i + 1\n    \n    return chosen_route\n\n# Reading input\nn, t = map(int, input().split())\nbus_routes = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Printing output\nprint(find_bus_route(n, t, bus_routes))"}
{"solution": "def count_ones_in_range(start, end, k):\n    count = 0\n    for i in range(start, end + 1):\n        if bin(i).count('1') == k:\n            count += 1\n    return count\n\ndef find_n(m, k):\n    low, high = 1, 10**18\n    while low <= high:\n        mid = (low + high) // 2\n        count = count_ones_in_range(mid + 1, 2 * mid, k)\n        if count == m:\n            return mid\n        elif count < m:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low\n\n# Reading input\nm, k = map(int, input().split())\n\n# Finding and printing the result\nprint(find_n(m, k))"}
{"solution": "def is_good_level(n, level_scheme):\n    # Convert the level scheme into a list of indices where platforms are located\n    platforms = [i for i, char in enumerate(level_scheme) if char == '*']\n    \n    # Check for a sequence of four jumps of the same length\n    for i in range(len(platforms)):\n        for j in range(i + 1, len(platforms)):\n            if platforms[j] - platforms[i] > 2:  # Ensure the gap is more than 2 to avoid trivial cases\n                k = platforms[j] + (platforms[j] - platforms[i])\n                l = k + (platforms[j] - platforms[i])\n                m = l + (platforms[j] - platforms[i])\n                if k in platforms and l in platforms and m in platforms:\n                    return \"yes\"\n    return \"no\"\n\n# Read input\nn = int(input())\nlevel_scheme = input()\n\n# Output result\nprint(is_good_level(n, level_scheme))"}
{"solution": "def read_matrix(n):\n    matrix = []\n    for _ in range(n):\n        row = list(map(int, input().split()))\n        matrix.append(row)\n    return matrix\n\ndef find_empty_cell(matrix):\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            if matrix[i][j] == 0:\n                return i, j\n    return None\n\ndef calculate_magic_constant(matrix, n, row_sum):\n    # Check columns\n    for j in range(n):\n        col_sum = sum(matrix[i][j] for i in range(n))\n        if col_sum != row_sum:\n            return -1\n\n    # Check main diagonal\n    main_diag_sum = sum(matrix[i][i] for i in range(n))\n    if main_diag_sum != row_sum:\n        return -1\n\n    # Check secondary diagonal\n    sec_diag_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if sec_diag_sum != row_sum:\n        return -1\n\n    return row_sum\n\ndef solve_magic_square(matrix, n):\n    row_sums = [sum(row) for row in matrix]\n    col_sums = [sum(matrix[i][j] for i in range(n)) for j in range(n)]\n    \n    # Find the empty cell\n    empty_i, empty_j = find_empty_cell(matrix)\n    \n    # Calculate the required value for the empty cell\n    required_value = calculate_magic_constant(matrix, n, row_sums[empty_i])\n    if required_value == -1:\n        return -1\n    \n    # Check if the required value conflicts with the column sum\n    if matrix[empty_i][empty_j] != 0 and col_sums[empty_j] + matrix[empty_i][empty_j] != required_value:\n        return -1\n    \n    # Check diagonals if necessary\n    if empty_i == empty_j:  # Main diagonal\n        main_diag_sum = sum(matrix[i][i] for i in range(n))\n        if main_diag_sum + required_value != required_value:\n            return -1\n    if empty_i == n - 1 - empty_j:  # Secondary diagonal\n        sec_diag_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n        if sec_diag_sum + required_value != required_value:\n            return -1\n    \n    return required_value\n\n# Read input\nn = int(input())\nmatrix = read_matrix(n)\n\n# Solve and print the result\nprint(solve_magic_square(matrix, n))"}
{"solution": "def calculate_min_max_k(n, m, a):\n    # Calculate the maximum possible k\n    max_k = max(a) + m\n    \n    # Calculate the total number of people after adding m people\n    total_people = sum(a) + m\n    \n    # Calculate the minimum possible k\n    min_k = (total_people + n - 1) // n\n    \n    return min_k, max_k\n\n# Read input\nn = int(input())\nm = int(input())\na = [int(input()) for _ in range(n)]\n\n# Calculate and print the result\nmin_k, max_k = calculate_min_max_k(n, m, a)\nprint(min_k, max_k)"}
{"solution": "def calculate_ways(n, m):\n    MOD = 10**9 + 7\n    \n    # Precompute factorials and their modular inverses\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    \n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n        inv_fact[i] = pow(fact[i], MOD - 2, MOD)\n    \n    def nCr(n, r):\n        return fact[n] * inv_fact[r] * inv_fact[n - r] % MOD\n    \n    # Calculate the number of ways\n    ways = 1\n    for i in range(1, m + 1):\n        ways = ways * nCr(n, i) * pow(2, i, MOD) % MOD\n    \n    return ways\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_ways(n, m))"}
{"solution": "from collections import defaultdict\n\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef read_pizzas(m):\n    pizzas = []\n    for _ in range(m):\n        c, r, *a = read_ints()\n        pizzas.append((c, set(a)))\n    return pizzas\n\ndef read_friends(n):\n    friends = []\n    for _ in range(n):\n        f, *b = read_ints()\n        friends.append(set(b))\n    return friends\n\ndef max_satisfaction(pizzas, friends):\n    n, m = len(friends), len(pizzas)\n    satisfied_counts = [[0] * m for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            combined_ingredients = pizzas[i][1] | pizzas[j][1]\n            for friend in friends:\n                if friend.issubset(combined_ingredients):\n                    satisfied_counts[i][j] += 1\n                    satisfied_counts[j][i] += 1\n    \n    max_satisfied = 0\n    best_pair = (0, 1)\n    for i in range(m):\n        for j in range(i + 1, m):\n            if satisfied_counts[i][j] > max_satisfied or (satisfied_counts[i][j] == max_satisfied and pizzas[i][0] + pizzas[j][0] < sum(pizzas[k][0] for k in best_pair)):\n                max_satisfied = satisfied_counts[i][j]\n                best_pair = (i, j)\n    \n    return best_pair\n\ndef main():\n    n, m = read_ints()\n    friends = read_friends(n)\n    pizzas = read_pizzas(m)\n    best_pair = max_satisfaction(pizzas, friends)\n    print(*[index + 1 for index in best_pair])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_min_max_numbers(m, s):\n    def build_number(is_min):\n        result = []\n        if is_min:\n            # Build the minimum number\n            i = 1\n            while s > 0 and m > 0:\n                if s >= 9:\n                    result.append(9)\n                    s -= 9\n                else:\n                    result.append(s)\n                    s = 0\n                m -= 1\n            if s > 0:  # Sum cannot be distributed\n                return -1\n            result.extend([0] * m)\n        else:\n            # Build the maximum number\n            while m > 0:\n                if s >= 9:\n                    result.append(9)\n                    s -= 9\n                else:\n                    result.append(s)\n                    s = 0\n                m -= 1\n            if s > 0:  # Sum cannot be distributed\n                return -1\n        if is_min and result[0] == 0:  # Handle leading zero for min\n            return -1\n        return int(''.join(map(str, result[::-1] if is_min else result)))\n\n    min_num = build_number(True)\n    max_num = build_number(False)\n\n    if min_num == -1 or max_num == -1:\n        return [-1, -1]\n    return [min_num, max_num]\n\n# Read input\nm, s = map(int, input().split())\n\n# Compute and print the result\nresult = find_min_max_numbers(m, s)\nprint(f\"{result[0]} {result[1]}\")"}
{"solution": "MOD = 998244353\n\ndef sum_of_numbers_with_k_digits(l, r, k):\n    def sum_range(start, end):\n        return ((end * (end + 1)) // 2 - (start * (start - 1)) // 2) % MOD\n    \n    def is_valid_number(n, k):\n        digits = set()\n        while n > 0:\n            digits.add(n % 10)\n            n //= 10\n        return len(digits) <= k\n    \n    total_sum = 0\n    current_sum = 0\n    for num in range(l, r + 1):\n        if is_valid_number(num, k):\n            current_sum += num\n            current_sum %= MOD\n        total_sum += current_sum\n        total_sum %= MOD\n    \n    return total_sum\n\n# Reading input\nl, r, k = map(int, input().split())\n\n# Calculating the result\nresult = sum_of_numbers_with_k_digits(l, r, k)\n\n# Printing the output\nprint(result)"}
{"solution": "def can_distribute_pencils(n, k, d, pencils):\n    pencils.sort()\n    groups = 0\n    last_group_max = -1\n    \n    for i in range(n):\n        if i == 0 or (pencils[i] - last_group_max <= d and (i - groups) < k - 1):\n            continue\n        else:\n            groups += 1\n            last_group_max = pencils[i]\n        \n        if (n - i) / (k - (i - groups)) > 1:\n            return \"NO\"\n    \n    return \"YES\" if (n - groups) % (k - 1) == 0 else \"NO\"\n\n# Reading input\nn, k, d = map(int, input().split())\npencils = list(map(int, input().split()))\n\n# Printing output\nprint(can_distribute_pencils(n, k, d, pencils))"}
{"solution": "from collections import Counter\n\ndef count_dead_bulbs(garland):\n    # Count occurrences of each color\n    color_count = Counter(garland)\n    \n    # Calculate the total length of the garland\n    total_length = len(garland)\n    \n    # Calculate the expected occurrences of each color\n    expected_count = total_length // 4\n    \n    # Initialize the result list with zeros\n    dead_counts = [0] * 4\n    \n    # Calculate the number of dead bulbs for each color\n    for color in ['R', 'B', 'Y', 'G']:\n        index = 'RGBY'.index(color)  # Map each color to its index\n        dead_counts[index] = expected_count - color_count[color]\n    \n    return dead_counts\n\n# Read input\ngarland = input().strip()\n\n# Calculate and print the result\nprint(*count_dead_bulbs(garland))"}
{"solution": "from collections import defaultdict, deque\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    N, M = map(int, input().split())\n    graph = defaultdict(list)\n    outdeg = [0] * (N + 1)\n    for _ in range(M):\n        s, t = map(int, input().split())\n        graph[s].append(t)\n        outdeg[s] += 1\n\n    # Topological Sort\n    queue = deque([node for node in range(1, N + 1) if outdeg[node] == 0])\n    order = []\n    while queue:\n        node = queue.popleft()\n        order.append(node)\n        for neighbor in graph[node]:\n            outdeg[neighbor] -= 1\n            if outdeg[neighbor] == 0:\n                queue.append(neighbor)\n\n    # Calculate expected values\n    exp_val = [0] * (N + 1)\n    for node in reversed(order):\n        if node == N:\n            exp_val[node] = 0\n        else:\n            exp_val[node] = 1 + sum(exp_val[neighbor] for neighbor in graph[node]) / len(graph[node])\n\n    # Find minimum expected value after blocking an edge\n    min_exp = exp_val[1]\n    for node in graph[1]:\n        if exp_val[node] < min_exp:\n            min_exp = exp_val[node]\n\n    # Adjust for the new expected value\n    min_exp = 1 + (exp_val[1] - exp_val[1] / len(graph[1]) * (len(graph[1]) - 1)) + min_exp * (len(graph[1]) - 1) / len(graph[1])\n\n    print(f\"{min_exp:.10f}\")\n\nsolve()"}
{"solution": "n = int(input())\nlast_digit = n % 10\nif last_digit < 5:\n    n -= last_digit\nelse:\n    n += (10 - last_digit)\nprint(n)"}
{"solution": "def find_swaps(s, t):\n    if len(s) != len(t):\n        return -1\n    \n    mismatches = {}\n    swaps = []\n    \n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if s[i] in mismatches and mismatches[s[i]] != t[i]:\n                return -1\n            if t[i] in mismatches and mismatches[t[i]] != s[i]:\n                return -1\n            mismatches[s[i]] = t[i]\n            mismatches[t[i]] = s[i]\n    \n    visited = set()\n    \n    for key in mismatches:\n        if key not in visited:\n            cycle = []\n            current = key\n            while current not in visited:\n                visited.add(current)\n                cycle.append(current)\n                current = mismatches[current]\n            if len(cycle) != 2:\n                return -1\n            swaps.append((cycle[0], cycle[1]))\n    \n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0], swap[1])\n\n# Example usage:\ns = \"helloworld\"\nt = \"ehoolwlroz\"\nfind_swaps(s, t)\n\ns = \"hastalavistababy\"\nt = \"hastalavistababy\"\nfind_swaps(s, t)\n\ns = \"merrychristmas\"\nt = \"christmasmerry\"\nfind_swaps(s, t)"}
{"solution": "def earliest_login(first_name, last_name):\n    # Initialize the earliest login with the concatenation of both full names\n    earliest = first_name + last_name\n    \n    # Iterate through all possible prefixes of the first name\n    for i in range(1, len(first_name) + 1):\n        # Iterate through all possible prefixes of the last name\n        for j in range(1, len(last_name) + 1):\n            # Generate the current combination of prefixes\n            current = first_name[:i] + last_name[:j]\n            # Update the earliest login if the current combination is alphabetically earlier\n            if current < earliest:\n                earliest = current\n                \n    return earliest\n\n# Read input\nfirst_name, last_name = input().split()\n\n# Calculate and print the alphabetically earliest login\nprint(earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(n, sequence):\n    def draw(bracket_stack, height):\n        if not bracket_stack:\n            return [\"+\" * width]\n        \n        result = []\n        current_row = [\"+\"] * width\n        \n        for i in range(height - 1, -1, -1):\n            for b in range(len(bracket_stack)):\n                if bracket_stack[b] > i:\n                    current_row[2 * b] = \"|\"\n                    current_row[2 * b + 1] = \"-\"\n                else:\n                    current_row[2 * b] = \" \"\n                    current_row[2 * b + 1] = \" \"\n            \n            result.append(\"\".join(current_row))\n        \n        return result[::-1]\n    \n    stack = []\n    max_height = 0\n    width = 0\n    \n    for char in sequence:\n        if char == \"[\":\n            stack.append(max_height)\n            width += 1\n            max_height = 0\n        else:\n            max_height = max(max_height, stack.pop())\n            width += 1\n    \n    height = max(max_height, len(stack))\n    \n    bracket_stack = [max_height] * len(stack)\n    \n    result = draw(bracket_stack, height)\n    \n    # Add spaces between consecutive brackets\n    for i in range(1, len(result)):\n        result[i] = result[i][:2] + \" \" + result[i][3:]\n    \n    return \"\\n\".join(result)\n\n# Read input\nn = int(input())\nsequence = input()\n\n# Print output\nprint(draw_brackets(n, sequence))"}
{"solution": "def normalize_golden_number(golden_number):\n    # Convert the golden number string to a list of integers for easier manipulation\n    golden_number = list(map(int, golden_number))\n    n = len(golden_number)\n    \n    # Normalize the number using the property q^2 = q + 1\n    for i in range(n - 1, 0, -1):\n        if golden_number[i] > 1:\n            golden_number[i] -= 2\n            golden_number[i - 1] += 1\n            if i - 2 >= 0:\n                golden_number[i - 2] += 1\n    \n    # Remove leading zeros\n    while len(golden_number) > 1 and golden_number[0] == 0:\n        golden_number.pop(0)\n    \n    return golden_number\n\ndef compare_golden_numbers(num1, num2):\n    # Normalize both numbers\n    norm_num1 = normalize_golden_number(num1)\n    norm_num2 = normalize_golden_number(num2)\n    \n    # Compare lengths first\n    if len(norm_num1) > len(norm_num2):\n        return \">\"\n    elif len(norm_num1) < len(norm_num2):\n        return \"<\"\n    \n    # If lengths are equal, compare digit by digit\n    for digit1, digit2 in zip(norm_num1, norm_num2):\n        if digit1 > digit2:\n            return \">\"\n        elif digit1 < digit2:\n            return \"<\"\n    \n    # If all digits are equal\n    return \"=\"\n\n# Read input\nnum1 = input().strip()\nnum2 = input().strip()\n\n# Compare the numbers and print the result\nresult = compare_golden_numbers(num1, num2)\nprint(result)"}
{"solution": "# Define the mapping of gem colors to their names\ngem_colors_to_names = {\n    'purple': 'Power',\n    'green': 'Time',\n    'blue': 'Space',\n    'orange': 'Soul',\n    'red': 'Reality',\n    'yellow': 'Mind'\n}\n\n# Read the number of gems in the gauntlet\nn = int(input())\n\n# Initialize a set to store the colors of the gems seen\nseen_gems = set()\n\n# Read the colors of the gems seen\nfor _ in range(n):\n    color = input().strip()\n    seen_gems.add(color)\n\n# Determine the absent gems\nabsent_gems = [gem_colors_to_names[color] for color in gem_colors_to_names if color not in seen_gems]\n\n# Output the number of absent gems\nprint(len(absent_gems))\n\n# Output the names of the absent gems\nfor gem_name in absent_gems:\n    print(gem_name)"}
{"solution": "def find_meeting_round(n, a, b):\n    while n > 1:\n        if abs(a - b) == 1:\n            return n // 2\n        elif a > b:\n            a, b = b, a\n        if b - a > n // 2:\n            return \"Final!\"\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n //= 2\n    return \"Final!\"\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Print output\nprint(find_meeting_round(n, a, b))"}
{"solution": "def min_changes(n, p, b):\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n            size[rootY] += size[rootX]\n\n    parent = list(range(2 * n))\n    size = [1] * (2 * n)\n\n    for i in range(n):\n        pi = p[i] - 1\n        bi = b[i]\n        union(i, pi + n * bi)\n\n    components = sum(1 for i in range(n) if find(i) == i)\n    return 2 * n - components\n\n# Reading input\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(min_changes(n, p, b))"}
{"solution": "def max_path_length(v1, v2, t, d):\n    # Initialize variables\n    path_length = 0\n    current_speed = v1\n    \n    # Calculate the maximum path length for the first t-1 seconds\n    for i in range(t - 1):\n        path_length += current_speed\n        # Adjust speed towards v2 with maximum change d per second\n        if current_speed < v2:\n            current_speed = min(current_speed + d, v2)\n        else:\n            current_speed = max(current_speed - d, v2)\n    \n    # Add the speed of the last second\n    path_length += current_speed\n    \n    return path_length\n\n# Read input\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Calculate and print the maximum possible length of the path section\nprint(max_path_length(v1, v2, t, d))"}
{"solution": "from itertools import permutations\nfrom bisect import bisect_left\n\ndef check_order(perm, L, V, W):\n    max_dist = 0\n    for i in range(len(L)):\n        start, end = max_dist, max_dist + L[i]\n        camels_in_part = [W[j] for j in range(len(W)) if perm[j] >= start and perm[j] < end]\n        if sum(camels_in_part) > V[i]:\n            return False\n        max_dist = end\n    return True\n\ndef min_distance(N, M, W, L, V):\n    min_dist = float('inf')\n    for perm in permutations(range(N)):\n        W_sorted = sorted(W)\n        total_weight = sum(W_sorted[:2])\n        if any(total_weight > v for v in V):\n            return -1\n        \n        low, high = 0, 10**9\n        while low + 1 < high:\n            mid = (low + high) // 2\n            positions = [mid * (i / (N - 1)) for i in range(N)]\n            pos_perm = [positions[p] for p in perm]\n            if check_order(pos_perm, L, V, W_sorted):\n                high = mid\n            else:\n                low = mid\n        \n        if check_order([high * (i / (N - 1)) for i in range(N)], L, V, W_sorted):\n            min_dist = min(min_dist, high)\n    \n    return int(min_dist)\n\n# Reading input\nN, M = map(int, input().split())\nW = list(map(int, input().split()))\nL, V = [], []\nfor _ in range(M):\n    l, v = map(int, input().split())\n    L.append(l)\n    V.append(v)\n\n# Calculating and printing the output\nprint(min_distance(N, M, W, L, V))"}
{"solution": "def last_digit_of_factorial_ratio(a, b):\n    \"\"\"\n    Calculate the last digit of the ratio of b! to a!.\n    \"\"\"\n    # For b >= 5 and a >= 5, the last digit is 0 because the factorial will have at least one 2 and one 5,\n    # making the product end in 0.\n    if b >= 5 and a >= 5:\n        return 0\n    \n    # If a is 0, return the last digit of b!\n    if a == 0:\n        return last_digit_of_factorial(b)\n    \n    # Calculate the last digit of the ratio by dividing the last digit of b! by the last digit of a!\n    last_digit_b = last_digit_of_factorial(b)\n    last_digit_a = last_digit_of_factorial(a)\n    \n    # Special case when the last digit of a! is 0, the result is the last digit of b!\n    if last_digit_a == 0:\n        return last_digit_b\n    \n    # Calculate the last digit of the division\n    return (last_digit_b * pow(last_digit_a, -1, 10)) % 10\n\ndef last_digit_of_factorial(n):\n    \"\"\"\n    Calculate the last digit of n!.\n    \"\"\"\n    if n == 0:\n        return 1\n    last_digits = [1, 1, 2, 6, 4]\n    if n < 5:\n        return last_digits[n]\n    # For n >= 5, the last digit is 0\n    return 0\n\n# Read input\na, b = map(int, input().split())\n\n# Calculate and print the last digit of the ratio\nprint(last_digit_of_factorial_ratio(a, b))"}
{"solution": "from collections import deque\n\ndef min_jumps(n, d, s):\n    # Initialize the queue and visited array\n    queue = deque([(1, 0)])  # (position, jumps)\n    visited = [False] * (n + 1)\n    visited[1] = True\n    \n    while queue:\n        position, jumps = queue.popleft()\n        \n        # Check if we have reached the target\n        if position == n:\n            return jumps + 1\n        \n        # Explore all possible jumps from the current position\n        for jump in range(1, d + 1):\n            next_position = position + jump\n            \n            # Check if the next position is within bounds and has a lily\n            if 1 <= next_position <= n and s[next_position - 1] == '1' and not visited[next_position]:\n                visited[next_position] = True\n                queue.append((next_position, jumps + 1))\n    \n    # If we cannot reach the target\n    return -1\n\n# Read input\nn, d = map(int, input().split())\ns = input()\n\n# Compute and print the result\nprint(min_jumps(n, d, s))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_counterexample(n):\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\nn = int(input().strip())\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all(n):\n    # Constants representing the costs of houses, cars, and computers\n    cost_house = 1234567\n    cost_car = 123456\n    cost_computer = 1234\n    \n    # Loop through possible number of houses\n    for a in range(n // cost_house + 1):\n        # Remaining amount after buying 'a' houses\n        remaining_after_houses = n - a * cost_house\n        \n        # Loop through possible number of cars\n        for b in range(remaining_after_houses // cost_car + 1):\n            # Remaining amount after buying 'b' cars\n            remaining_after_cars = remaining_after_houses - b * cost_car\n            \n            # Check if the remaining amount can be spent on computers\n            if remaining_after_cars % cost_computer == 0:\n                return \"YES\"\n    \n    # If no combination of houses, cars, and computers can be bought\n    return \"NO\"\n\n# Read input\nn = int(input())\n\n# Print output\nprint(can_spend_all(n))"}
{"solution": "def find_intersection(k1, b1, k2, b2):\n    if k1 == k2:\n        return None\n    x = (b2 - b1) / (k1 - k2)\n    return x\n\ndef check_intersection_inside_strip(n, x1, x2, lines):\n    for i in range(n):\n        for j in range(i + 1, n):\n            k1, b1 = lines[i]\n            k2, b2 = lines[j]\n            x = find_intersection(k1, b1, k2, b2)\n            if x is not None and x1 < x < x2:\n                return \"YES\"\n    return \"NO\"\n\n# Reading input\nn = int(input())\nx1, x2 = map(int, input().split())\nlines = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Solving and printing output\nprint(check_intersection_inside_strip(n, x1, x2, lines))"}
{"solution": "def count_different_weights(n):\n    # The maximum possible weight is n (all elements being 1)\n    # The minimum possible weight is 1 (the sequence being [n])\n    # We need to count the number of divisors of n, which will give us the number of different weights\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, then n // i is also a divisor\n            # Increment count by 2 for each pair of divisors\n            count += 2\n    # If n is a perfect square, we've counted the middle divisor twice, so subtract one\n    if int(n**0.5) ** 2 == n:\n        count -= 1\n    return count\n\n# Read input\nn = int(input())\n\n# Output the result\nprint(count_different_weights(n))"}
{"solution": "def find_good_apartments(n, k):\n    if k == 0:\n        min_good = 0\n        max_good = 0\n    else:\n        min_good = 1\n        max_good = min(n - k, 2 * k)\n    \n    return min_good, max_good\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating and printing the result\nmin_good, max_good = find_good_apartments(n, k)\nprint(min_good, max_good)"}
{"solution": "import math\n\ndef max_games_winner_can_play(n):\n    \"\"\"\n    Determine the maximum number of games the winner of the tournament can take part in.\n    \n    Args:\n    n (int): The number of players participating in the tournament.\n    \n    Returns:\n    int: The maximum number of games the winner can play.\n    \"\"\"\n    return int(math.floor(math.log2(n)))\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the result\nprint(max_games_winner_can_play(n))"}
{"solution": "def max_vk_occurrences(s):\n    n = len(s)\n    vk_count = 0\n    v_count = 0\n    k_after_v = 0\n    \n    for i in range(n):\n        if s[i] == 'V':\n            v_count += 1\n            if i < n - 1 and s[i + 1] == 'K':\n                vk_count += 1\n            else:\n                k_after_v += 1\n        elif s[i] == 'K' and v_count > 0:\n            k_after_v += 1\n    \n    max_vk = vk_count + min(v_count, k_after_v)\n    return max_vk\n\n# Read input\ns = input().strip()\n\n# Compute and print the output\nprint(max_vk_occurrences(s))"}
{"solution": "import math\n\ndef min_segments(n):\n    a = int(math.sqrt(n))\n    b = (n + a - 1) // a  # Equivalent to math.ceil(n / a)\n    return a + b + 2\n\n# Read input\nn = int(input().strip())\nprint(min_segments(n))"}
{"solution": "a, b = map(int, input().split())\nyears = 0\n\nwhile a <= b:\n    a *= 3\n    b *= 2\n    years += 1\n\nprint(years)"}
{"solution": "def calculate_visited_nodes(h, n):\n    visited = 0\n    position = 0\n    level = 0\n    command_index = 0\n    skipped = 0\n    \n    while True:\n        if level == h:\n            break\n        \n        # Determine the direction based on the command string\n        direction = 'L' if command_index % 2 == 0 else 'R'\n        \n        # Calculate the new position\n        new_position = (position << 1) + (1 if direction == 'R' else 0)\n        \n        # Check if the new position has been visited\n        if new_position & (n - 1):\n            skipped += 1\n            if skipped == 2:\n                level -= 1\n                position >>= 1\n                skipped = 0\n        else:\n            visited += 1\n            position = new_position\n            level += 1\n            skipped = 0\n        \n        command_index += 1\n    \n    return visited\n\n# Read input\nh, n = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_visited_nodes(h, n))"}
{"solution": "def find_tables(x):\n    def num_squares(n, m):\n        return sum(min(n, i) * min(m, i) for i in range(1, min(n, m) + 1))\n\n    def find_pairs(x):\n        pairs = []\n        max_dim = int(x**0.5) + 1\n        for n in range(1, max_dim):\n            low, high = 1, max_dim\n            while low <= high:\n                m = (low + high) // 2\n                total_squares = num_squares(n, m)\n                if total_squares == x:\n                    pairs.append((n, m))\n                    break\n                elif total_squares < x:\n                    low = m + 1\n                else:\n                    high = m - 1\n            # Check for the exact match in reverse order\n            if n != m and num_squares(m, n) == x:\n                pairs.append((m, n))\n        return pairs\n\n    pairs = find_pairs(x)\n    print(len(pairs))\n    for pair in sorted(pairs):\n        print(*pair)\n\n# Read input\nx = int(input())\n\n# Solve and print output\nfind_tables(x)"}
{"solution": "def is_leap_year(year):\n    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\ndef days_in_month(month, year):\n    if month == 2:\n        return 29 if is_leap_year(year) else 28\n    return 31 if month in [1, 3, 5, 7, 8, 10, 12] else 30\n\ndef check_consecutive_months(n, days_list):\n    current_year = 0\n    current_month = 0\n    while current_year < 10000:  # Assuming a reasonable upper limit for years\n        for month in range(1, 13):\n            if current_month >= n:\n                return \"Yes\"\n            if days_in_month(month, current_year) == days_list[current_month]:\n                current_month += 1\n        current_year += 1\n    return \"No\"\n\n# Reading input\nn = int(input())\ndays_list = list(map(int, input().split()))\n\n# Printing output\nprint(check_consecutive_months(n, days_list))"}
{"solution": "from math import gcd\n\ndef find_sequence(n):\n    if n == 2:\n        return \"NO\"\n    \n    # Function to check if a number is a divisor of n\n    def is_divisor(x, n):\n        return n % x == 0\n    \n    # Function to simplify a fraction\n    def simplify(a, b):\n        common_divisor = gcd(a, b)\n        return a // common_divisor, b // common_divisor\n    \n    # Initialize variables\n    sequence = []\n    used_divisors = set()\n    \n    # Find divisors of n\n    for b in range(2, n):\n        if is_divisor(b, n) and b not in used_divisors:\n            a = b - 1\n            while a > 1 and a % b != 0:\n                if is_divisor(a, n) and a not in used_divisors:\n                    sequence.append((a, b))\n                    used_divisors.add(a)\n                    used_divisors.add(b)\n                    break\n                a -= 1\n    \n    # Sum of the sequence\n    total_sum = 0\n    for a, b in sequence:\n        total_sum += a / b\n    \n    # Check if the sum equals 1 - 1/n\n    if abs(total_sum - (1 - 1/n)) < 1e-9:\n        return \"YES\", len(sequence), sequence\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\n\n# Solve the problem\nresult = find_sequence(n)\n\n# Print the output\nif result == \"NO\":\n    print(result)\nelse:\n    print(\"YES\")\n    print(result[1])\n    for a, b in result[2]:\n        print(a, b)"}
{"solution": "def min_unattractiveness(n, limits, heights):\n    a, b = limits\n    total_area = sum(heights)\n    \n    if a + b < total_area:\n        return -1\n    \n    dp = [[float('inf')] * (n + 1) for _ in range(2)]\n    dp[0][0] = 0\n    dp[1][0] = 0\n    \n    for i in range(n):\n        for j in range(i + 1):\n            dp[0][i + 1] = min(dp[0][i + 1], dp[0][j] + (heights[i] if j > 0 else 0))\n            dp[1][i + 1] = min(dp[1][i + 1], dp[1][j] + (heights[i] if j > 0 else 0))\n            \n            if j == 0:\n                continue\n            \n            if a >= sum(heights[:i + 1 - j]) + heights[i]:\n                dp[1][i + 1] = min(dp[1][i + 1], dp[0][j] + heights[i])\n                \n            if b >= sum(heights[j:i + 1]):\n                dp[0][i + 1] = min(dp[0][i + 1], dp[1][j] + heights[i])\n                \n    result = float('inf')\n    for i in range(n + 1):\n        if a >= sum(heights[:i]) and b >= sum(heights[i:]):\n            result = min(result, dp[0][i])\n    \n    return result if result != float('inf') else -1\n\n# Reading input\nn = int(input())\nlimits = list(map(int, input().split()))\nheights = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(min_unattractiveness(n, limits, heights))"}
{"solution": "from math import gcd\n\ndef find_triangle_points(n, m, k):\n    area = (n * m) // k\n    if area == 0 or (n * m) % (2 * k) != 0:\n        print(\"NO\")\n        return\n    \n    # Check if it's possible to form a triangle with the given area\n    if area <= n * m // 2:\n        print(\"YES\")\n        # Example points that satisfy the condition\n        print(0, 0)\n        print(n, 0)\n        height = min(m, 2 * area // n)\n        print(0, height)\n    else:\n        print(\"NO\")\n\n# Reading input\nn, m, k = map(int, input().split())\nfind_triangle_points(n, m, k)"}
{"solution": "def sasha_wins(n, k):\n    # Calculate the total number of moves possible in the game\n    total_moves = n // k\n    # Sasha wins if he can make more moves than Lena. Since they alternate,\n    # Sasha wins if the total number of moves is odd (he goes first).\n    return \"YES\" if total_moves % 2 == 1 else \"NO\"\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the result\nprint(sasha_wins(n, k))"}
{"solution": "# Reading input\nn = int(input())\nrepetitions = list(map(int, input().split()))\n\n# Initializing counters for each muscle group\nchest_count = 0\nbiceps_count = 0\nback_count = 0\n\n# Iterating through the list of repetitions\nfor i, rep in enumerate(repetitions):\n    # Determining the muscle group based on the index\n    if i % 3 == 0:\n        chest_count += rep\n    elif i % 3 == 1:\n        biceps_count += rep\n    else:\n        back_count += rep\n\n# Determining which muscle group gets the most exercise\nif chest_count > biceps_count and chest_count > back_count:\n    print(\"chest\")\nelif biceps_count > chest_count and biceps_count > back_count:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "def min_redos_to_get_five(n, grades):\n    current_sum = sum(grades)\n    target_sum = n * 4.5\n    \n    if current_sum >= target_sum:\n        return 0\n    \n    grades.sort()\n    redos = 0\n    \n    for i in range(n):\n        if current_sum >= target_sum:\n            break\n        # Replace the lowest grade with 5\n        current_sum += (5 - grades[i])\n        redos += 1\n    \n    return redos\n\n# Read input\nn = int(input())\ngrades = list(map(int, input().split()))\n\n# Output the result\nprint(min_redos_to_get_five(n, grades))"}
{"solution": "def find_shortest_array(u, v):\n    if u == 0:\n        if v == 0:\n            print(0)\n        else:\n            print(-1)\n        return\n    \n    # Check if v is less than u, which is impossible\n    if v < u:\n        print(-1)\n        return\n    \n    n = 1\n    arr = [u]\n    remaining_sum = v - u\n    \n    # Add zeros (as 0s do not affect xor) until the sum matches\n    while remaining_sum > 0:\n        if remaining_sum >= u:\n            arr.append(u)\n            remaining_sum -= u\n        else:\n            arr.append(remaining_sum)\n            remaining_sum = 0\n        n += 1\n    \n    # If the sum does not match, check for the smallest k where k % u == remaining_sum\n    if remaining_sum != 0:\n        k = 1\n        while (k % u) != remaining_sum:\n            k += 1\n        arr.append(k)\n        n += 1\n    \n    print(n)\n    print(\" \".join(map(str, arr)))\n\n# Reading input\nu, v = map(int, input().split())\n\n# Solving the problem\nfind_shortest_array(u, v)"}
{"solution": "def min_ones(n):\n    ones = [1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 1111111111, 11111111111, 111111111111, 1111111111111, 11111111111111, 111111111111111]\n    dp = [0] + [float('inf')] * n\n    \n    for i in range(1, len(ones)):\n        for j in range(ones[i-1], n+1):\n            if j >= ones[i]:\n                dp[j] = min(dp[j], dp[j - ones[i]] + 1)\n            else:\n                dp[j] = min(dp[j], dp[j - ones[i-1]] + 1)\n    \n    return dp[n]\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the result\nprint(min_ones(n))"}
{"solution": "def can_reach_treasure(start_x, start_y, treasure_x, treasure_y, potion_x, potion_y):\n    # Calculate the differences in x and y coordinates\n    diff_x = abs(treasure_x - start_x)\n    diff_y = abs(treasure_y - start_y)\n    \n    # Check if the differences are multiples of the potion's x and y values\n    if (diff_x % (2 * potion_x) == 0) and (diff_y % (2 * potion_y) == 0):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nstart_x, start_y, treasure_x, treasure_y = map(int, input().split())\npotion_x, potion_y = map(int, input().split())\n\n# Determine if Captain Bill the Hummingbird can reach the treasure\nprint(can_reach_treasure(start_x, start_y, treasure_x, treasure_y, potion_x, potion_y))"}
{"solution": "from itertools import permutations\n\ndef count_valid_bus_numbers(n):\n    digits = list(str(n))\n    all_permutations = set(permutations(digits))\n    valid_permutations = {int(''.join(perm)) for perm in all_permutations if perm[0] != '0'}\n    return len(valid_permutations)\n\nn = int(input().strip())\nresult = count_valid_bus_numbers(n)\nprint(result)"}
{"solution": "# Import necessary packages if any required here\n# In this case, no additional packages are needed.\n\ndef max_suit_cost(a, b, c, d, e, f):\n    # Calculate the maximum number of suits of the first type (tie and jacket)\n    max_type_1 = min(a, d) * e\n    \n    # Calculate the maximum number of suits of the second type (scarf, vest, and jacket)\n    max_type_2 = min(b, c, d) * f\n    \n    # Calculate the remaining jackets after making suits of the first type\n    remaining_jackets = d - min(a, d)\n    \n    # If there are remaining jackets, check if making more suits of the second type is beneficial\n    if remaining_jackets > 0:\n        # Calculate the additional suits of the second type that can be made with remaining jackets\n        additional_type_2 = min(b - min(b, c, d), c - min(b, c, d), remaining_jackets) * f\n        max_type_2 += additional_type_2\n    \n    # Return the maximum total cost\n    return max(max_type_1, max_type_2)\n\n# Read input values\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\n# Calculate and print the maximum total cost\nprint(max_suit_cost(a, b, c, d, e, f))"}
{"solution": "from math import gcd\n\ndef mod_pow(base, exponent, modulus):\n    result = 1\n    base = base % modulus\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % modulus\n        exponent = exponent >> 1\n        base = (base * base) % modulus\n    return result\n\ndef find_possible_ns(a, b, p, x):\n    count = 0\n    # Calculate the multiplicative inverse of a modulo p\n    inv_a = pow(a, p - 2, p)\n    \n    # Check each possible value of n from 1 to x\n    for n in range(1, min(x + 1, p)):\n        target = (b * mod_pow(inv_a, n, p)) % p\n        if target == 0:\n            continue\n        \n        # Check if there exists an integer k such that a^k \u2261 target (mod p)\n        if gcd(target, p) == 1:\n            order = p - 1\n            if pow(a, order // gcd(order, n), p) == target:\n                # Calculate the number of valid n within the range\n                full_cycles = x // p\n                partial_cycle_count = min(p, x % p + 1) - n\n                count += full_cycles * (p - n) + partial_cycle_count\n    \n    return count\n\n# Read input\na, b, p, x = map(int, input().split())\n\n# Solve and print the result\nprint(find_possible_ns(a, b, p, x))"}
{"solution": "def max_sum(k2, k3, k5, k6):\n    # Calculate the minimum number of 256s that can be formed\n    num_256 = min(k2, k5, k6)\n    \n    # Update counts after forming 256s\n    k2 -= num_256\n    k5 -= num_256\n    k6 -= num_256\n    \n    # Calculate the number of 32s that can be formed with remaining digits\n    num_32 = min(k2, k3)\n    \n    # Calculate the total sum\n    total_sum = num_256 * 256 + num_32 * 32\n    \n    return total_sum\n\n# Read input\nk2, k3, k5, k6 = map(int, input().split())\n\n# Output the result\nprint(max_sum(k2, k3, k5, k6))"}
{"solution": "import math\n\ndef time_to_happiness(n, x, y, c):\n    # Calculate the maximum distance a cell can be from the center\n    max_distance = max(abs(x - (n + 1) // 2), abs(y - (n + 1) // 2))\n    \n    # Calculate the minimum number of cells that can be turned on if the initial cell is at the center\n    min_cells_center = (max(0, n - 2 * max_distance)) ** 2\n    \n    # If the initial cell is at the center and enough cells are already on, no time is needed\n    if min_cells_center >= c:\n        return 0\n    \n    # Calculate the number of additional cells needed\n    additional_cells_needed = max(0, c - (n - 2 * max_distance) ** 2)\n    \n    # Calculate the minimum time required to turn on the additional cells\n    time_for_additional_cells = math.ceil(math.sqrt(additional_cells_needed)) - 1\n    \n    # Total time is the maximum of the time to reach the center and the time to turn on additional cells\n    total_time = max(max_distance, time_for_additional_cells)\n    \n    return total_time\n\n# Read input\nn, x, y, c = map(int, input().split())\n\n# Calculate and print the answer\nprint(time_to_happiness(n, x, y, c))"}
{"solution": "import sys\n\ndef max_bitwise_xor(l, r):\n    if l == r:\n        return 0\n    bin_l = bin(l)[2:]  # Convert l to binary and remove the '0b' prefix\n    bin_r = bin(r)[2:]  # Convert r to binary and remove the '0b' prefix\n    \n    # Find the position of the first differing bit\n    i = 0\n    while i < len(bin_l) and i < len(bin_r) and bin_l[-(i + 1)] == bin_r[-(i + 1)]:\n        i += 1\n    \n    # Calculate the maximum XOR value\n    max_xor = ((1 << (len(bin_l) - i)) - 1) ^ l\n    \n    return max_xor\n\n# Read input from stdin\nl, r = map(int, sys.stdin.readline().strip().split())\n\n# Compute and print the result\nprint(max_bitwise_xor(l, r))"}
{"solution": "def minimum_height(n, k):\n    left, right = 1, k  # The height cannot be more than k because the area is k\n    \n    while left < right:\n        mid = (left + right) // 2\n        if n * mid >= k:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Example usage:\nn, k = map(int, input().split())\nprint(minimum_height(n, k))"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    # Calculate time using stairs\n    stairs_time = abs(x - y) * t1\n    \n    # Calculate time using elevator\n    # Time to reach Masha\n    elevator_to_masha_time = abs(z - x) * t2 + t3\n    # Time to reach Egor's floor\n    elevator_to_egor_time = abs(x - y) * t2 + 2 * t3\n    elevator_time = elevator_to_masha_time + elevator_to_egor_time\n    \n    # Compare times and return result\n    if stairs_time < elevator_time:\n        return \"NO\"\n    else:\n        return \"YES\"\n\n# Read input\nx, y, z, t1, t2, t3 = map(int, input().split())\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "def find_optimal_a(n, m):\n    # If m is exactly in the middle or the middle is a half integer, choose the next integer\n    if m > (n + 1) // 2:\n        return (n + 1) // 2\n    else:\n        return (n + 1) // 2 + 1\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the optimal value of a\nprint(find_optimal_a(n, m))"}
{"solution": "n = int(input())\nschedule = list(map(int, input().split()))\n\npairs_at_university = 0\nin_university = False\n\nfor i in range(n):\n    if schedule[i] == 1:\n        if not in_university:\n            pairs_at_university += 1\n            in_university = True\n        pairs_at_university += 1\n    else:\n        if in_university and (i + 1 < n and schedule[i + 1] == 0):\n            in_university = False\n\nprint(pairs_at_university)"}
{"solution": "def min_days_to_give_candies(n, k, candies_per_day):\n    total_candies = 0\n    for day in range(n):\n        total_candies += candies_per_day[day]\n        if total_candies >= k:\n            return day + 1\n    return -1\n\n# Reading input\nn, k = map(int, input().split())\ncandies_per_day = list(map(int, input().split()))\n\n# Calculating and printing the result\nresult = min_days_to_give_candies(n, k, candies_per_day)\nprint(result)"}
{"solution": "def minimum_additional_walks(n, k, a):\n    b = a[:]\n    additional_walks = 0\n    \n    for i in range(n - 1):\n        if b[i] + b[i + 1] < k:\n            needed_walks = k - (b[i] + b[i + 1])\n            b[i + 1] += needed_walks\n            additional_walks += needed_walks\n    \n    return additional_walks, b\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nadditional_walks, b = minimum_additional_walks(n, k, a)\n\n# Print the result\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "def compute_rhombus_cells(n):\n    # Base case for 1st order rhombus\n    if n == 1:\n        return 1\n    \n    # Calculate the number of cells for n-th order rhombus\n    return 4 * n * (n - 1) + 1\n\n# Read input\nn = int(input())\n\n# Compute and print the number of cells\nprint(compute_rhombus_cells(n))"}
{"solution": "# Import necessary package\nfrom string import ascii_uppercase\n\n# Read the number of characters in the string\nn = int(input())\n\n# Read the string\ns = input()\n\n# Convert the string to uppercase to simplify comparison\ns_upper = s.upper()\n\n# Initialize a set to track the unique letters found in the string\nunique_letters = set()\n\n# Iterate through the string and add each letter to the set\nfor letter in s_upper:\n    if letter in ascii_uppercase:\n        unique_letters.add(letter)\n\n# Check if the set contains all 26 letters of the alphabet\nis_pangram = len(unique_letters) == 26\n\n# Output the result\nprint(\"YES\" if is_pangram else \"NO\")"}
{"solution": "from datetime import datetime, timedelta\n\n# Read the current time in 24-hour format\ncurrent_time_str = input()\n# Read the number of minutes to add\nminutes_to_add = int(input())\n\n# Convert the current time string to a datetime object\ncurrent_time = datetime.strptime(current_time_str, \"%H:%M\")\n\n# Add the specified number of minutes\nnew_time = current_time + timedelta(minutes=minutes_to_add)\n\n# Format the new time back to a string in 24-hour format with leading zeros\nformatted_time = new_time.strftime(\"%H:%M\")\n\n# Print the formatted time\nprint(formatted_time)"}
{"solution": "def can_ignore_switch(n, m, switches):\n    # Convert the input strings to a list of integers for easier manipulation\n    switch_matrix = [[int(s) for s in switch] for switch in switches]\n    \n    # Check if there exists a switch that can be ignored\n    for i in range(n):\n        # Create a set of lamps that are turned on by all other switches\n        all_lamps_on = set()\n        for j in range(n):\n            if j != i:\n                for k in range(m):\n                    if switch_matrix[j][k] == 1:\n                        all_lamps_on.add(k)\n        \n        # If all lamps are turned on by the remaining switches, return \"YES\"\n        if len(all_lamps_on) == m:\n            return \"YES\"\n    \n    # If no such switch exists, return \"NO\"\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nswitches = [input() for _ in range(n)]\n\n# Output result\nprint(can_ignore_switch(n, m, switches))"}
{"solution": "def min_rotation_time(n, dominoes):\n    upper_sum = 0\n    lower_sum = 0\n    can_rotate_upper = 0\n    can_rotate_lower = 0\n    \n    for x, y in dominoes:\n        upper_sum += x\n        lower_sum += y\n        if x % 2 != 0 and y % 2 == 0:\n            can_rotate_upper += 1\n        if x % 2 == 0 and y % 2 != 0:\n            can_rotate_lower += 1\n    \n    if (upper_sum % 2 == 0 and lower_sum % 2 == 0):\n        return 0\n    elif (upper_sum % 2 != 0 and lower_sum % 2 != 0) and (can_rotate_upper + can_rotate_lower > 0):\n        return 1\n    elif abs(can_rotate_upper - can_rotate_lower) <= (min(can_rotate_upper, can_rotate_lower) + 1):\n        return min(can_rotate_upper, can_rotate_lower) + 1\n    else:\n        return -1\n\n# Reading input\nn = int(input())\ndominoes = [list(map(int, input().split())) for _ in range(n)]\n\n# Printing output\nprint(min_rotation_time(n, dominoes))"}
{"solution": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef remaining_area(a, b):\n    return (a * a) - (b * b)\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        a, b = map(int, input().split())\n        area = remaining_area(a, b)\n        if is_prime(area):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nsolve()"}
{"solution": "def can_remove_one_point(n, points):\n    positive_count = 0\n    negative_count = 0\n    \n    for x, y in points:\n        if x > 0:\n            positive_count += 1\n        else:\n            negative_count += 1\n    \n    if positive_count <= 1 or negative_count <= 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Reading input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_remove_one_point(n, points))"}
{"solution": "def gcd_factorials(A, B):\n    min_val = min(A, B)\n    gcd = 1\n    for i in range(1, min_val + 1):\n        gcd *= i\n    return gcd\n\n# Reading input\nA, B = map(int, input().split())\n\n# Calculating and printing the output\nprint(gcd_factorials(A, B))"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_composite_pair(n):\n    a = n + 4  # Start with a number greater than n and ensure it's composite\n    while is_prime(a):\n        a += 1\n    b = a - n\n    while is_prime(b):\n        a += 1\n        b = a - n\n    return a, b\n\nn = int(input())\na, b = find_composite_pair(n)\nprint(a, b)"}
{"solution": "from collections import defaultdict, deque\n\ndef max_score(N, M, P, edges):\n    # Build the graph\n    graph = defaultdict(list)\n    for A, B, C in edges:\n        graph[A].append((B, C))\n\n    # Initialize DP table\n    dp = [-float('inf')] * (N + 1)\n    dp[1] = 0\n    queue = deque([1])\n\n    # BFS to compute the maximum coins reachable at each node\n    while queue:\n        current = queue.popleft()\n        for next_node, coins in graph[current]:\n            new_score = dp[current] + coins\n            if dp[next_node] < new_score:\n                dp[next_node] = new_score\n                queue.append(next_node)\n\n    # Check if it's possible to reach Node N\n    if dp[N] == -float('inf'):\n        return -1\n\n    # Initialize variables for the main loop\n    max_coins = dp[N]\n    time_penalty = 0\n    current_node = 1\n    visited = [False] * (N + 1)\n    visited[1] = True\n    queue = deque([(current_node, 0)])\n\n    # BFS to explore all possible paths and compute the final score\n    while queue:\n        current_node, time = queue.popleft()\n        for next_node, coins in graph[current_node]:\n            if not visited[next_node]:\n                visited[next_node] = True\n                new_time = time + 1\n                new_coins = dp[next_node] + (new_time * coins)\n                if next_node == N:\n                    score = new_coins - (new_time * P)\n                    max_coins = max(max_coins, score)\n                else:\n                    queue.append((next_node, new_time))\n\n    return max_coins\n\n# Read input\nN, M, P = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(M)]\n\n# Compute and print the result\nprint(max_score(N, M, P, edges))"}
{"solution": "from collections import defaultdict\nfrom itertools import product\n\ndef min_cost_palindrome(n, strings):\n    # Initialize costs and character frequency dictionary\n    costs = []\n    char_freq = defaultdict(int)\n    \n    for _ in range(n):\n        s, c = input().split()\n        c = int(c)\n        costs.append((s, c))\n        \n        # Count characters for each string\n        for char in s:\n            char_freq[char] += 1\n    \n    # Check if it's impossible to form a palindrome\n    odd_chars = sum(v % 2 for v in char_freq.values())\n    if odd_chars > 1:\n        return -1\n    \n    # Generate all possible pairs of strings and calculate costs\n    dp = defaultdict(lambda: float('inf'))\n    dp[()] = 0\n    \n    for i, j in product(range(n), repeat=2):\n        s1, c1 = costs[i]\n        s2, c2 = costs[j]\n        \n        # Check if concatenation forms a palindrome\n        concat = s1 + s2\n        if concat == concat[::-1]:\n            dp[s1, s2] = min(dp[s1, s2], c1 + c2)\n    \n    # Find the minimum cost for any palindrome\n    min_cost = float('inf')\n    for combo in dp.values():\n        min_cost = min(min_cost, combo)\n    \n    return min_cost\n\n# Read input\nn = int(input())\nprint(min_cost_palindrome(n, []))"}
{"solution": "def largest_xor_sum(n, k):\n    # Find the number of bits in n\n    num_bits = n.bit_length()\n    # The largest possible xor-sum\n    max_xor_sum = (1 << num_bits) - 1\n    return max_xor_sum\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the largest possible xor-sum\nprint(largest_xor_sum(n, k))"}
{"solution": "from typing import List, Tuple\n\ndef min_shorter_side_triangle(points: List[Tuple[int, int]]) -> int:\n    max_x = max_y = 0\n    for x, y in points:\n        max_x = max(max_x, x)\n        max_y = max(max_y, y)\n    return min(max_x, max_y) * 2\n\n# Read input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(min_shorter_side_triangle(points))"}
{"solution": "from collections import Counter\n\ndef max_nineteens(s):\n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # Define the required frequency of each character in the word \"nineteen\"\n    required_counts = {'n': 3, 'i': 1, 'e': 3, 't': 1}\n    \n    # Calculate the maximum number of \"nineteen\" words that can be formed\n    max_nineteens = float('inf')\n    for char, required in required_counts.items():\n        if char in char_count:\n            max_nineteens = min(max_nineteens, char_count[char] // required)\n        else:\n            return 0  # If any required character is missing, we can't form \"nineteen\"\n    \n    return max_nineteens\n\n# Read input\ns = input()\n\n# Print the result\nprint(max_nineteens(s))"}
{"solution": "def find_highest_unreachable_branch(p, y):\n    if y == 1:\n        return -1\n\n    # Check if the highest branch (y) is unreachable\n    for i in range(2, int(y ** 0.5) + 1):\n        if p >= i and y % i == 0:\n            return y - 1\n\n    # If y is a prime number greater than p, it is unreachable\n    if y > p:\n        return y\n\n    return -1\n\n# Read input\np, y = map(int, input().split())\n\n# Output the result\nprint(find_highest_unreachable_branch(p, y))"}
{"solution": "def min_distance_to_affordable_house(n, m, k, prices):\n    # Filter out the houses that Zane can afford\n    affordable_houses = [i for i, price in enumerate(prices) if price > 0 and price <= k]\n    \n    # Calculate the minimum distance\n    min_dist = float('inf')\n    for house in affordable_houses:\n        dist = abs(house - (m - 1)) * 10  # Convert house index difference to meters\n        min_dist = min(min_dist, dist)\n    \n    return min_dist\n\n# Read input\nn, m, k = map(int, input().split())\nprices = list(map(int, input().split()))\n\n# Solve the problem\nresult = min_distance_to_affordable_house(n, m, k, prices)\n\n# Print the result\nprint(result)"}
{"solution": "def can_transform(A, B):\n    def transpose_submatrix(matrix, x, y, k):\n        temp = [matrix[i][y:y+k] for i in range(x, x+k)]\n        for i in range(x, x+k):\n            for j in range(y, y+k):\n                matrix[i][j] = temp[j-y][i-x]\n\n    n, m = len(A), len(A[0])\n    if sorted([item for sublist in A for item in sublist]) != sorted([item for sublist in B for item in sublist]):\n        return \"NO\"\n\n    while True:\n        changed = False\n        for i in range(n):\n            for j in range(m):\n                if A[i][j] != B[i][j]:\n                    for k in range(1, min(n - i, m - j) + 1):\n                        submatrix_before = [row[j:j+k] for row in A[i:i+k]]\n                        transpose_submatrix(A, i, j, k)\n                        if A == B:\n                            return \"YES\"\n                        else:\n                            # Revert the change if not matched\n                            transpose_submatrix(A, i, j, k)\n                            A[i:i+k] = [row[j:j+k] for row in submatrix_before]\n                    changed = True\n                    break\n            if changed:\n                break\n        if not changed:\n            break\n\n    return \"YES\" if A == B else \"NO\"\n\n# Reading input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nB = [list(map(int, input().split())) for _ in range(n)]\n\n# Printing output\nprint(can_transform(A, B))"}
{"solution": "def longest_uncommon_subsequence(a, b):\n    if a == b:\n        print(-1)\n    else:\n        print(max(len(a), len(b)))\n\n# Read input strings\na = input().strip()\nb = input().strip()\n\n# Calculate and print the result\nlongest_uncommon_subsequence(a, b)"}
{"solution": "def find_intersection(a, b, c, d):\n    # Calculate the least common multiple (LCM) of a and c\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    lcm = a * c // gcd(a, c)\n\n    # Check if there is an intersection\n    if (d - b) % lcm == 0:\n        time = b + ((d - b) // lcm) * lcm\n        return time\n    else:\n        return -1\n\n# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Output the result\nprint(find_intersection(a, b, c, d))"}
{"solution": "def find_solution(n):\n    if n % 3 == 0:\n        # If n is a multiple of 3, adjust a, b, and c accordingly\n        a = n // 3 - 1\n        b = n // 3 - 1\n        c = n // 3 + 2\n    elif n % 3 == 1:\n        # If n gives a remainder of 1 when divided by 3\n        a = n // 3\n        b = n // 3\n        c = n // 3 + 1\n    else:\n        # If n gives a remainder of 2 when divided by 3\n        a = n // 3\n        b = n // 3 + 1\n        c = n // 3 + 1\n    \n    return a, b, c\n\n# Read input\nn = int(input())\n\n# Find and print the solution\na, b, c = find_solution(n)\nprint(a, b, c)"}
{"solution": "def count_valid_paintings(n, a, b, c, d):\n    valid_paintings = 0\n    target_sum = a + b + c + d\n    \n    for x1 in range(1, n + 1):\n        for x2 in range(1, n + 1):\n            for x3 in range(1, n + 1):\n                for x4 in range(1, n + 1):\n                    # Top-left 2x2 sum\n                    tl_sum = a + b + x1 + x2\n                    if tl_sum != target_sum:\n                        continue\n                    \n                    # Middle row\n                    m1 = x3\n                    m2 = x4\n                    m3 = c\n                    m4 = d\n                    mid_sum = m1 + m2 + m3 + m4\n                    if mid_sum != target_sum:\n                        continue\n                    \n                    # Bottom row\n                    br1 = target_sum - x2 - m2 - d\n                    br2 = target_sum - x1 - m1 - br1\n                    br3 = target_sum - m3 - m4 - d\n                    br4 = target_sum - m1 - m2 - br2\n                    \n                    if (1 <= br1 <= n and 1 <= br2 <= n and 1 <= br3 <= n and 1 <= br4 <= n and\n                        br1 + br2 + br3 + br4 == target_sum):\n                        valid_paintings += 1\n                        \n    return valid_paintings\n\n# Read input\nn, a, b, c, d = map(int, input().split())\n\n# Calculate and print the result\nprint(count_valid_paintings(n, a, b, c, d))"}
{"solution": "def final_snowball_weight(w, h, u1, d1, u2, d2):\n    # Ensure the stones are processed in order of their heights\n    if d1 > d2:\n        d1, d2 = d2, d1\n        u1, u2 = u2, u1\n\n    while h > 0:\n        w += h  # Increase weight by current height\n        if h == d1:\n            w -= u1  # Lose weight hitting the first stone\n            w = max(0, w)  # Ensure weight does not go below zero\n        elif h == d2:\n            w -= u2  # Lose weight hitting the second stone\n            w = max(0, w)  # Ensure weight does not go below zero\n        h -= 1  # Move down one meter\n\n    return w\n\n# Read input\nw, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\n# Compute and print the final weight\nprint(final_snowball_weight(w, h, u1, d1, u2, d2))"}
{"solution": "def find_passing_rate(m, scores, min_max):\n    # Calculate cumulative scores\n    cumulative_scores = [0]\n    for score in scores:\n        cumulative_scores.append(cumulative_scores[-1] + score)\n    \n    x, y = min_max\n    \n    # Check for valid passing rate\n    for k in range(1, m + 1):\n        beginners = cumulative_scores[k]\n        intermediates = cumulative_scores[m] - beginners\n        \n        if x <= beginners <= y and x <= intermediates <= y:\n            return k\n    \n    return 0\n\n# Read input\nm = int(input())\nscores = list(map(int, input().split()))\nx, y = map(int, input().split())\n\n# Output result\nprint(find_passing_rate(m, scores, (x, y)))"}
{"solution": "def min_coins_to_one(n, k, A, B):\n    operations = []\n    while n > 1:\n        if n % k == 0 and (len(operations) == 0 or operations[-1] != B):\n            operations.append(B)\n            n //= k\n        else:\n            operations.append(A)\n            n -= 1\n    return sum(operations)\n\n# Reading input\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\n# Calculating and printing the output\nprint(min_coins_to_one(n, k, A, B))"}
{"solution": "from math import sqrt\n\ndef min_value_and_operations(n):\n    # Initialize the minimum value and the number of operations\n    min_value = n\n    operations = 0\n    \n    # Factorize n and count square factors\n    i = 2\n    while i * i <= n:\n        exp = 0\n        while n % i == 0:\n            n //= i\n            exp += 1\n        operations += exp // 2\n        min_value = min(min_value, i ** (exp // 2))\n        i += 1\n    if n > 1:\n        operations += 1\n        min_value = min(min_value, int(sqrt(n)))\n    \n    return min_value, operations\n\n# Read input\nn = int(input())\n\n# Calculate and print the result\nresult = min_value_and_operations(n)\nprint(*result)"}
{"solution": "import sys\n\ndef max_score(N, K, R, S, P, T):\n    dp = [[0, 0, 0] for _ in range(N + 1)]\n    \n    for i in range(K, N):\n        dp[i + 1][0] = max(dp[i - K + 1][1], dp[i - K + 1][2]) + (P if T[i] == 'r' else 0)\n        dp[i + 1][1] = max(dp[i - K + 1][0], dp[i - K + 1][2]) + (R if T[i] == 's' else 0)\n        dp[i + 1][2] = max(dp[i - K + 1][0], dp[i - K + 1][1]) + (S if T[i] == 'p' else 0)\n    \n    # Handle the initial K rounds separately\n    for i in range(min(K, N)):\n        dp[i + 1][0] = (P if T[i] == 'r' else 0)\n        dp[i + 1][1] = (R if T[i] == 's' else 0)\n        dp[i + 1][2] = (S if T[i] == 'p' else 0)\n    \n    return max(dp[N])\n\n# Read input\nN, K = map(int, input().split())\nR, S, P = map(int, input().split())\nT = input()\n\nprint(max_score(N, K, R, S, P, T))"}
{"solution": "def longest_good_string(a, b, c):\n    # Calculate the maximum length of the good string\n    if a > b:\n        a, b = b, a  # Ensure a <= b for simplification\n    max_length = 2 * (a + b) + 2 * c\n    if a == 0:  # Handle special case where one of the counts is zero\n        max_length = max(max_length, 2 * c + 1)\n    return max_length\n\n# Read input\na, b, c = map(int, input().split())\n\n# Output the result\nprint(longest_good_string(a, b, c))"}
{"solution": "def find_marks(n, k, p, x, y, marks):\n    total_marks_so_far = sum(marks)\n    remaining_marks_needed = x - total_marks_so_far\n    if remaining_marks_needed < 0:\n        return -1\n\n    # Calculate the median position\n    median_pos = (n + 1) // 2\n\n    # Sort the existing marks to find the current median\n    marks.sort()\n\n    # Determine the required marks for the remaining tests\n    required_marks = []\n    for i in range(n - k):\n        if len(required_marks) < median_pos - k:\n            # Ensure the median is at least y\n            required_marks.append(max(y, 1))\n        else:\n            # Ensure the total does not exceed x\n            required_marks.append(min(p, remaining_marks_needed))\n            remaining_marks_needed -= min(p, remaining_marks_needed)\n            if remaining_marks_needed <= 0:\n                break\n\n    # Check if the requirements can be met\n    if remaining_marks_needed > 0:\n        return -1\n\n    # Update the marks list and sort it to check the median\n    updated_marks = marks + required_marks\n    updated_marks.sort()\n    if updated_marks[median_pos - 1] < y or sum(updated_marks) > x:\n        return -1\n\n    return required_marks\n\n# Read input\nn, k, p, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Solve the problem\nresult = find_marks(n, k, p, x, y, marks)\n\n# Print the output\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "def is_berlanese(word):\n    vowels = \"aeiou\"\n    prev_char = ''\n    \n    for char in word:\n        if char not in vowels:\n            if prev_char != 'n':\n                return \"NO\"\n        prev_char = char\n    \n    return \"YES\"\n\n# Read input\ns = input()\n\n# Print output\nprint(is_berlanese(s))"}
{"solution": "from collections import defaultdict\n\ndef max_dominoes_on_graph(n, edges):\n    # Create an adjacency list to represent the graph\n    graph = defaultdict(set)\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    # Initialize the degree count for each vertex\n    degrees = {vertex: len(neighbors) for vertex, neighbors in graph.items()}\n\n    # Count the total number of edges\n    total_edges = len(edges)\n\n    # Initialize the result variable\n    result = 0\n\n    # Track the vertices that have been matched\n    matched_vertices = set()\n\n    # Iterate over each vertex\n    for vertex in range(1, n + 1):\n        if vertex in matched_vertices:\n            continue\n\n        # Find the neighbor with the minimum degree\n        min_degree_neighbor = None\n        min_degree = float('inf')\n        for neighbor in graph[vertex]:\n            if neighbor not in matched_vertices and degrees[neighbor] < min_degree:\n                min_degree = degrees[neighbor]\n                min_degree_neighbor = neighbor\n\n        # If a valid neighbor is found, match them and update degrees\n        if min_degree_neighbor is not None:\n            result += 1\n            matched_vertices.add(vertex)\n            matched_vertices.add(min_degree_neighbor)\n            degrees[vertex] -= 1\n            degrees[min_degree_neighbor] -= 1\n\n            # Update the degrees of common neighbors\n            for common_neighbor in graph[vertex] & graph[min_degree_neighbor]:\n                degrees[common_neighbor] -= 1\n\n    # Calculate the remaining unmatched edges\n    remaining_edges = total_edges - (result * 2)\n\n    # Add half of the remaining edges to the result\n    result += remaining_edges // 2\n\n    return result\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Compute and print the result\nprint(max_dominoes_on_graph(n, edges))"}
{"solution": "from typing import List\n\ndef max_points(n: int, m: int, prices: List[int], auctions: List[int]) -> int:\n    from sortedcontainers import SortedList\n    \n    # Convert auction indices to 0-based indexing and sort\n    auctions = sorted(a - 1 for a in auctions)\n    \n    # Initialize variables\n    points = 0\n    current_score = 0\n    next_non_auction = 0\n    auction_indices = SortedList()\n    \n    # Populate the list of auction indices\n    for i in range(m):\n        auction_indices.add(auctions[i])\n    \n    for i in range(n):\n        # If the current question is an auction question\n        if i in auction_indices:\n            # Find the position of the current auction question\n            pos = auction_indices.index(i)\n            \n            # Calculate the new price based on the current score\n            new_price = min(current_score, prices[i])\n            current_score += new_price\n            \n            # Remove the current auction question index\n            auction_indices.pop(pos)\n            \n            # Update the next non-auction question index if needed\n            if next_non_auction < i:\n                next_non_auction = i + 1\n        else:\n            # Handle the case when the next non-auction question is beyond the current index\n            if next_non_auction >= n:\n                break\n            \n            # If the next non-auction question is before the current index, move to the next one\n            while next_non_auction < i:\n                next_non_auction += 1\n            \n            # Add the points for the non-auction question\n            current_score += prices[next_non_auction]\n            next_non_auction += 1\n        \n        # Update the total points\n        points = max(points, current_score)\n    \n    return points\n\n# Read input\nn, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauctions = list(map(int, input().split()))\n\n# Compute and print the result\nprint(max_points(n, m, prices, auctions))"}
{"solution": "# Import necessary package for reading input\nfrom sys import stdin\n\n# Read input\nm = list(map(int, stdin.readline().strip().split()))\nw = list(map(int, stdin.readline().strip().split()))\nh_s, h_u = map(int, stdin.readline().strip().split())\n\n# Define the maximum point values for each problem\npoints = [500, 1000, 1500, 2000, 2500]\n\n# Initialize total score\ntotal_score = 0\n\n# Calculate score for each problem\nfor i in range(5):\n    score = max(0.3 * points[i], (1 - m[i] / 250) * points[i] - 50 * w[i])\n    total_score += int(score)\n\n# Add points for successful and unsuccessful hacks\ntotal_score += 100 * h_s - 50 * h_u\n\n# Print the final score\nprint(total_score)"}
{"solution": "MOD = 998244353\n\ndef mod_pow(base, exponent, modulus):\n    result = 1\n    base %= modulus\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % modulus\n        exponent = exponent >> 1\n        base = (base * base) % modulus\n    return result\n\ndef solve(n, m, L, R):\n    if (n * m) % 2 == 1:\n        return 0\n    total_cells = n * m\n    even_cells = total_cells // 2\n    odd_cells = total_cells - even_cells\n    if L % 2 == 0:\n        valid_range = min(R, L + 1)\n    else:\n        valid_range = min(R, L)\n    even_count = (valid_range - L) // 2 + 1\n    odd_count = (valid_range - L) // 2 + 1\n    total_even = mod_pow(even_count, even_cells, MOD)\n    total_odd = mod_pow(odd_count, odd_cells, MOD)\n    return (total_even * total_odd) % MOD\n\n# Reading input\nn, m, L, R = map(int, input().split())\n\n# Solving the problem\nresult = solve(n, m, L, R)\n\n# Printing the output\nprint(result)"}
{"solution": "def is_possible_to_make_increasing(n, m, matrix_a, matrix_b):\n    # Ensure that matrix_a[i][j] is the smaller or equal element\n    for i in range(n):\n        for j in range(m):\n            if matrix_a[i][j] > matrix_b[i][j]:\n                matrix_a[i][j], matrix_b[i][j] = matrix_b[i][j], matrix_a[i][j]\n    \n    # Check rows for strictly increasing property\n    for i in range(n):\n        for j in range(1, m):\n            if matrix_a[i][j] <= matrix_a[i][j-1] or matrix_b[i][j] <= matrix_b[i][j-1]:\n                return \"Impossible\"\n    \n    # Check columns for strictly increasing property\n    for j in range(m):\n        for i in range(1, n):\n            if matrix_a[i][j] <= matrix_a[i-1][j] or matrix_b[i][j] <= matrix_b[i-1][j]:\n                return \"Impossible\"\n    \n    return \"Possible\"\n\n# Input handling\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\nmatrix_b = [list(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(is_possible_to_make_increasing(n, m, matrix_a, matrix_b))"}
{"solution": "import heapq\n\ndef max_string_length(n, limits):\n    # Initialize a min heap for the limits\n    min_heap = []\n    for i in range(1, n + 1):\n        heapq.heappush(min_heap, (limits[i - 1], i))\n    \n    # Initialize a dictionary to keep track of used occurrence values\n    used = [False] * (10**9 + 1)\n    ans = 0\n    \n    while min_heap:\n        limit, char = heapq.heappop(min_heap)\n        found = False\n        \n        # Find the smallest valid occurrence value\n        for val in range(ans % (n + 1) + 1, limit + 1):\n            if not used[val]:\n                used[val] = True\n                ans += val\n                found = True\n                break\n        \n        # If no valid occurrence value is found, break the loop\n        if not found:\n            break\n        \n        # Push back the updated limit if it's greater than the chosen value\n        if limit > val:\n            heapq.heappush(min_heap, (limit - val, char))\n    \n    return ans\n\n# Read input\nn = int(input())\nlimits = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_string_length(n, limits))"}
{"solution": "def min_problems_to_solve(n, k, difficulties):\n    # Initialize the count of additional problems needed\n    additional_problems = 0\n    # Create a set to keep track of difficulties that have been solved\n    solved_difficulties = set()\n    \n    # Add initial difficulty k to the set\n    solved_difficulties.add(k)\n    \n    # Function to ensure the difficulty or half of it is in the set\n    def ensure_difficulty(difficulty):\n        while difficulty > 0 and difficulty not in solved_difficulties:\n            difficulty //= 2\n        return difficulty\n    \n    # Iterate through each problem's difficulty\n    for difficulty in difficulties:\n        # Ensure the problem or a sufficiently difficult problem is solved\n        min_difficulty = ensure_difficulty(difficulty)\n        if min_difficulty == 0:\n            # If no sufficient difficulty is found, add one and mark it as solved\n            additional_problems += 1\n            solved_difficulties.add(difficulty // 2)\n    \n    return additional_problems\n\n# Read input\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_problems_to_solve(n, k, difficulties))"}
{"solution": "def distribute_diplomas(n, min_max_1, min_max_2, min_max_3):\n    min_1, max_1 = min_max_1\n    min_2, max_2 = min_max_2\n    min_3, max_3 = min_max_3\n    \n    # Initialize diplomas\n    diplomas_1 = max(min_1, n - max_2 - max_3)\n    diplomas_2 = max(min_2, n - diplomas_1 - max_3)\n    diplomas_3 = n - diplomas_1 - diplomas_2\n    \n    # Ensure diplomas fit within their constraints\n    if diplomas_1 > max_1:\n        diff = diplomas_1 - max_1\n        diplomas_1 = max_1\n        diplomas_2 += min(diff, max_2 - diplomas_2)\n        diplomas_3 += max(diff - (max_2 - diplomas_2), 0)\n    \n    if diplomas_2 > max_2:\n        diff = diplomas_2 - max_2\n        diplomas_2 = max_2\n        diplomas_3 += diff\n    \n    if diplomas_3 > max_3:\n        diff = diplomas_3 - max_3\n        diplomas_3 = max_3\n    \n    return diplomas_1, diplomas_2, diplomas_3\n\n# Read input\nn = int(input())\nmin_max_1 = list(map(int, input().split()))\nmin_max_2 = list(map(int, input().split()))\nmin_max_3 = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = distribute_diplomas(n, min_max_1, min_max_2, min_max_3)\nprint(*result)"}
{"solution": "def moon_cycle_prediction(n, observations):\n    # Moon cycle data\n    moon_cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                  14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    \n    # Find the starting index in the cycle\n    start_index = moon_cycle.index(observations[0])\n    \n    # Check if the sequence matches the moon cycle\n    for i in range(n):\n        if moon_cycle[start_index + i] != observations[i]:\n            return -1\n    \n    # Predict the next day\n    if start_index + n < len(moon_cycle) - 1:\n        if moon_cycle[start_index + n] < moon_cycle[start_index + n - 1]:\n            return \"DOWN\"\n        elif moon_cycle[start_index + n] > moon_cycle[start_index + n - 1]:\n            return \"UP\"\n    else:\n        # Handle wrapping around the cycle\n        if moon_cycle[(start_index + n) % len(moon_cycle)] < moon_cycle[(start_index + n - 1) % len(moon_cycle)]:\n            return \"DOWN\"\n        elif moon_cycle[(start_index + n) % len(moon_cycle)] > moon_cycle[(start_index + n - 1) % len(moon_cycle)]:\n            return \"UP\"\n    \n    return -1\n\n# Read input\nn = int(input())\nobservations = list(map(int, input().split()))\n\n# Print output\nprint(moon_cycle_prediction(n, observations))"}
{"solution": "def can_transform(s, t):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    # Check if lengths are the same\n    if len(s) != len(t):\n        return \"No\"\n    \n    # Check each character\n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels) != (char_t in vowels):\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(can_transform(s, t))"}
{"solution": "def determine_winner(board):\n    min_white_distance = 8\n    max_black_distance = 0\n    \n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'W':\n                distance_to_top = i\n                min_white_distance = min(min_white_distance, distance_to_top)\n            elif board[i][j] == 'B':\n                distance_to_bottom = 7 - i\n                max_black_distance = max(max_black_distance, distance_to_bottom)\n    \n    if min_white_distance < max_black_distance:\n        return 'A'\n    else:\n        return 'B'\n\n# Read the board from input\nboard = [input() for _ in range(8)]\n\n# Determine and print the winner\nprint(determine_winner(board))"}
{"solution": "def max_equal_length(n, A, m, B):\n    if sum(A) != sum(B):\n        return -1\n    \n    i, j = 0, 0\n    sumA, sumB = 0, 0\n    count = 0\n    \n    while i < n and j < m:\n        sumA += A[i]\n        sumB += B[j]\n        \n        if sumA == sumB:\n            count += 1\n            sumA = 0\n            sumB = 0\n            i += 1\n            j += 1\n        elif sumA < sumB:\n            i += 1\n            sumA -= A[i-1]\n        else:\n            j += 1\n            sumB -= B[j-1]\n    \n    if i < n or j < m:\n        return -1\n    \n    return count\n\n# Example usage:\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\nprint(max_equal_length(n, A, m, B))"}
{"solution": "def is_alex_friend_name_included(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    friend_count = sum(problem_name.count(friend) for friend in friends)\n    \n    if friend_count == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Reading input\nproblem_name = input()\n\n# Processing and printing output\nprint(is_alex_friend_name_included(problem_name))"}
{"solution": "def sieve(n):\n    is_prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (is_prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n    is_prime[0], is_prime[1] = False, False  # 0 and 1 are not primes\n    return is_prime\n\ndef count_primes_in_range(is_prime, a, b):\n    prime_count = [0] * (b + 1)\n    for i in range(a, b + 1):\n        prime_count[i] = prime_count[i - 1] + (1 if is_prime[i] else 0)\n    return prime_count\n\ndef min_length_with_k_primes(a, b, k):\n    is_prime = sieve(b)\n    prime_count = count_primes_in_range(is_prime, a, b)\n    \n    def has_k_primes_in_length(l):\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] >= k:\n                return True\n        return False\n    \n    left, right = 1, b - a + 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if has_k_primes_in_length(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\n# Input\na, b, k = map(int, input().split())\n\n# Output\nprint(min_length_with_k_primes(a, b, k))"}
{"solution": "from math import gcd\n\ndef min_distance(a, h, w):\n    def feasible(r, c):\n        if r * a + r * x > h or c * a + c * x > w:\n            return False\n        if (h - r * a) % r != 0 or (w - c * a) % c != 0:\n            return False\n        return True\n\n    min_x = float('inf')\n    for r in range(1, h // a + 1):\n        for c in range(1, w // a + 1):\n            g = gcd(r, c)\n            r, c = r // g, c // g\n            low, high = 0, 10 ** 9\n            while high - low > 1e-6:\n                x = (low + high) / 2\n                if feasible(r, c):\n                    high = x\n                else:\n                    low = x\n            if feasible(r, c):\n                min_x = min(min_x, high)\n    \n    return min_x if min_x < float('inf') else -1\n\n# Reading input\na, h, w = map(int, input().split())\n\n# Calculating and printing the output\nprint(min_distance(a, h, w))"}
{"solution": "n = int(input())\nchapters = []\nfor _ in range(n):\n    li, ri = map(int, input().split())\n    chapters.append((li, ri))\nk = int(input())\n\nunread_chapters = 0\nfor li, ri in chapters:\n    if k <= li:\n        unread_chapters += 1\n\n# Check if the marked page is within a chapter that hasn't been fully read\nfor li, ri in chapters:\n    if li < k <= ri:\n        break\n    else:\n        unread_chapters += 1\n\nprint(unread_chapters)"}
{"solution": "def can_form_codeforces(word):\n    target = \"CODEFORCES\"\n    n = len(word)\n    m = len(target)\n    \n    if n < m:\n        return \"NO\"\n    \n    for i in range(m + 1):\n        if word[:i] == target[:i] and word[n - (m - i):] == target[i:]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Reading input\nword = input()\nprint(can_form_codeforces(word))"}
{"solution": "def min_weight_triangulation(n):\n    # Initialize a DP table\n    dp = [[0] * n for _ in range(n)]\n    \n    # Fill the DP table\n    for gap in range(2, n):\n        for i in range(n - gap):\n            j = i + gap\n            dp[i][j] = float('inf')\n            for k in range(i + 1, j):\n                # Weight of current triangulation\n                weight = dp[i][k] + dp[k][j] + (i + 1) * (k + 1) * (j + 1)\n                dp[i][j] = min(dp[i][j], weight)\n    \n    # Return the minimum weight\n    return dp[0][n - 1]\n\n# Read input\nn = int(input())\n\n# Calculate and print the minimum weight\nprint(min_weight_triangulation(n))"}
{"solution": "def count_digits(n):\n    if n < 10:\n        return n\n    digits = 0\n    current_length = 1\n    while n >= 10 ** current_length:\n        digits += current_length * (10 ** (current_length - 1))\n        n -= 10 ** current_length\n        current_length += 1\n    digits += current_length * n\n    return digits\n\nn = int(input())\nprint(count_digits(n))"}
{"solution": "from collections import defaultdict\n\ndef find_bobs_winning_color():\n    n, A = map(int, input().split())\n    colors = list(map(int, input().split()))\n    \n    # Track the count of Alice's color and all other colors\n    alice_count = 0\n    other_counts = defaultdict(int)\n    max_other_count = 0\n    \n    # Track the maximum count of any other color seen so far\n    for color in colors:\n        if color == A:\n            alice_count += 1\n        else:\n            other_counts[color] += 1\n            max_other_count = max(max_other_count, other_counts[color])\n        \n        # If Alice's count is ever greater than or equal to the max other count, reset max_other_count\n        if alice_count >= max_other_count:\n            max_other_count = 0\n    \n    # Find a color that always has a count greater than or equal to Alice's color\n    for color, count in other_counts.items():\n        if count > alice_count:\n            print(color)\n            return\n    \n    print(-1)\n\nfind_bobs_winning_color()"}
{"solution": "def check_crossword(n, x, encoding):\n    # Initial gap before the first segment\n    initial_gap = 1\n    total_length = initial_gap\n    \n    for length in encoding:\n        total_length += length + 1  # Add segment length and gap\n    \n    # Remove the last added gap\n    total_length -= 1\n    \n    # Check if the total length matches the required length\n    if total_length == x:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, x = map(int, input().split())\nencoding = list(map(int, input().split()))\n\n# Print the result\nprint(check_crossword(n, x, encoding))"}
{"solution": "def min_coins(n, S):\n    dp = [0] + [float('inf')] * S\n    for s in range(1, S + 1):\n        for coin in range(1, min(n + 1, s) + 1):\n            dp[s] = min(dp[s], dp[s - coin] + 1)\n    return dp[S]\n\n# Reading input\nn, S = map(int, input().split())\n\n# Calculating and printing the output\nprint(min_coins(n, S))"}
{"solution": "from collections import Counter\n\ndef smallest_palindrome(s):\n    char_count = Counter(s)\n    left_part = []\n    middle_char = ''\n    \n    # Count characters and prepare the left part\n    for char in sorted(char_count.keys()):\n        count = char_count[char]\n        half_count = count // 2\n        for _ in range(half_count):\n            left_part.append(char)\n        if count % 2 != 0 and middle_char == '':\n            middle_char = char\n    \n    # Construct the left part of the palindrome\n    left_part = ''.join(left_part)\n    # If no odd-count character, use 'a' as the middle character\n    if not middle_char:\n        middle_char = 'a'\n    # Construct the right part of the palindrome\n    right_part = left_part[::-1]\n    \n    # Combine the parts to form the palindrome\n    if len(s) % 2 == 0:\n        return left_part + right_part\n    else:\n        return left_part + middle_char + right_part\n\n# Read input\ns = input()\n# Print output\nprint(smallest_palindrome(s))"}
{"solution": "def calculate_weight(board):\n    piece_weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n    }\n    \n    white_weight = 0\n    black_weight = 0\n    \n    for row in board:\n        for piece in row:\n            if piece in piece_weights:\n                if piece.isupper():\n                    white_weight += piece_weights[piece]\n                else:\n                    black_weight += piece_weights[piece]\n    \n    if white_weight > black_weight:\n        return \"White\"\n    elif black_weight > white_weight:\n        return \"Black\"\n    else:\n        return \"Draw\"\n\n# Read input from stdin\nboard = [input() for _ in range(8)]\n\n# Calculate and print the result\nprint(calculate_weight(board))"}
{"solution": "from collections import deque\n\ndef solve(N, M, S):\n    # Initialize dynamic programming arrays\n    dp = [-1] * (N + 1)\n    dp[N] = 0\n    path = [None] * (N + 1)\n    \n    # Queue for BFS\n    queue = deque([N])\n    \n    # BFS to find the shortest path and lexicographically smallest sequence\n    while queue:\n        current = queue.popleft()\n        \n        for step in range(1, min(M, current) + 1):\n            next_pos = current - step\n            \n            if S[next_pos] == '1' or dp[next_pos] != -1:\n                continue\n            \n            # Update the path and DP array\n            if dp[next_pos] == -1 or (dp[next_pos] == dp[current] + 1 and path[current] < step):\n                dp[next_pos] = dp[current] + 1\n                path[next_pos] = step\n                queue.append(next_pos)\n    \n    # Check if 0 is reachable\n    if dp[0] == -1:\n        return -1\n    \n    # Reconstruct the path\n    result = []\n    pos = 0\n    while pos < N:\n        result.append(path[pos])\n        pos += path[pos]\n    \n    return ' '.join(map(str, reversed(result)))\n\n# Read input\nN, M = map(int, input().split())\nS = input()\n\n# Solve and print the result\nprint(solve(N, M, S))"}
{"solution": "from math import gcd\n\ndef solve(K, X, Y):\n    def reachable(K, x, y):\n        g = gcd(abs(x), abs(y))\n        return g % K == 0\n    \n    def move(K, x, y):\n        g = gcd(abs(x), abs(y))\n        return (x // g * K, y // g * K)\n    \n    if not reachable(K, X, Y):\n        print(-1)\n        return\n    \n    path = [(0, 0)]\n    target = (X, Y)\n    while target != (0, 0):\n        if abs(target[0]) >= K and abs(target[1]) >= K:\n            next_move = move(K, target[0], target[1])\n            path.append(next_move)\n            target = (target[0] - next_move[0], target[1] - next_move[1])\n        else:\n            break\n    \n    if target != (X, Y):\n        if abs(target[0]) < K:\n            target = (0, target[1])\n        if abs(target[1]) < K:\n            target = (target[0], 0)\n        path.extend([target, (X, Y)])\n    \n    print(len(path) - 1)\n    for p in path[1:]:\n        print(p[0], p[1])\n\n# Read input\nK = int(input())\nX, Y = map(int, input().split())\n\nsolve(K, X, Y)"}
{"solution": "from math import gcd\n\ndef find_smallest_n(m):\n    def count_ways(n):\n        total = 0\n        for a in range(1, n + 1):\n            limit = n // a\n            for k in range(2, limit + 1):\n                b = a * k\n                if b > n:\n                    break\n                c = b * k\n                if c > n:\n                    break\n                d = c * k\n                if d > n:\n                    break\n                total += 1\n        return total\n    \n    if m == 1:\n        return 8  # Special case as per the problem statement\n    \n    # Binary search for the smallest n\n    low, high = 1, int(1e15)\n    while low < high:\n        mid = (low + high) // 2\n        if count_ways(mid) < m:\n            low = mid + 1\n        else:\n            high = mid\n            \n    if count_ways(low) == m:\n        return low\n    else:\n        return -1\n\n# Read input\nm = int(input())\n\n# Calculate and print the result\nprint(find_smallest_n(m))"}
{"solution": "import math\n\ndef intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    \n    if d >= r1 + r2:\n        return 0.0  # No intersection\n    elif d <= abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2  # One circle is completely inside the other\n    else:\n        phi = math.acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        theta = math.acos((r2 ** 2 + d ** 2 - r1 ** 2) / (2 * r2 * d))\n        \n        area1 = r1 ** 2 * phi - r1 ** 2 * math.sin(2 * phi) / 2\n        area2 = r2 ** 2 * theta - r2 ** 2 * math.sin(2 * theta) / 2\n        \n        return area1 + area2\n\n# Read input\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\n# Calculate and print the area of intersection\nprint(intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "def minimize_n(v):\n    if v == 1:\n        return 1\n    # Find the smallest prime number greater than or equal to v\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    # Start checking from v and go down to find the smallest non-prime number\n    while not is_prime(v):\n        v -= 1\n    return v - 1\n\n# Read input\nv = int(input())\n\n# Calculate and print the output\nprint(minimize_n(v))"}
{"solution": "from collections import defaultdict\n\ndef dfs(node, parent, depth, citizens, graph, dp):\n    dp[node] = citizens[node]\n    for child in graph[node]:\n        if child != parent:\n            dfs(child, node, depth + 1, citizens, graph, dp)\n            dp[node] = min(dp[node], citizens[node] + (dp[child] if depth > 0 else float('inf')))\n\ndef min_citizens_caught(n, parents, citizens):\n    # Build the graph\n    graph = defaultdict(list)\n    for i, parent in enumerate(parents, start=2):\n        graph[parent].append(i)\n    \n    # Dynamic Programming table\n    dp = [0] * (n + 1)\n    \n    # Start DFS from the main square (node 1)\n    dfs(1, -1, 0, citizens, graph, dp)\n    \n    return dp[1]\n\n# Read input\nn = int(input())\nparents = list(map(int, input().split()))\ncitizens = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_citizens_caught(n, parents, citizens))"}
{"solution": "def count_typo_words(n, S, T):\n    count = 0\n    i = 0\n    j = n - 1\n    \n    # Find the first differing character from the start\n    while i < n and S[i] == T[i]:\n        i += 1\n    \n    # Find the first differing character from the end\n    while j >= 0 and S[j] == T[j]:\n        j -= 1\n    \n    # Check if S[i:j+1] matches T[i+1:j+2] or T[i:j+1] matches S[i+1:j+2]\n    if S[i:j+1] == T[i+1:j+2] or T[i:j+1] == S[i+1:j+2]:\n        count += 1\n    \n    if S[i+1:j+2] == T[i:j+1]:\n        count += 1\n    \n    return count\n\n# Example usage:\nn = int(input())\nS = input().strip()\nT = input().strip()\nprint(count_typo_words(n, S, T))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef dfs(node, parent, strengths, graph, visited, subtree_max):\n    visited[node] = True\n    max_strength = strengths[node]\n\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            child_max = dfs(neighbor, node, strengths, graph, visited, subtree_max)\n            max_strength = max(max_strength, child_max + 1)\n\n    if parent == -1:\n        return float('inf')\n    else:\n        subtree_max[node] = max_strength\n        return max_strength\n\ndef compute_min_strength(n, strengths, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * (n + 1)\n    subtree_max = [0] * (n + 1)\n\n    # Compute maximum strength in each subtree\n    dfs(1, -1, strengths, graph, visited, subtree_max)\n\n    # Compute the maximum strength needed\n    max_strength_needed = 0\n    for node in range(1, n + 1):\n        for neighbor in graph[node]:\n            max_strength_needed = max(max_strength_needed, min(subtree_max[node], subtree_max[neighbor]) - 1)\n\n    return max_strength_needed\n\n# Reading input\nn = int(input())\nstrengths = list(map(int, input().split()))\nedges = [list(map(int, input().split())) for _ in range(n - 1)]\n\n# Computing and printing the output\nprint(compute_min_strength(n, strengths, edges))"}
{"solution": "def max_groups(n, m):\n    return min(m, n - m)\n\n# Reading input\nn, m = map(int, input().split())\n\n# Calculating and printing the maximum number of groups\nprint(max_groups(n, m))"}
{"solution": "def min_shovels(k, r):\n    for n in range(1, 11):\n        if (n * k) % 10 == r:\n            return n\n    return 10\n\nk, r = map(int, input().split())\nprint(min_shovels(k, r))"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # Dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Extract the bounding box\n    piece = []\n    for i in range(min_row, max_row + 1):\n        piece.append(grid[i][min_col:max_col + 1])\n    \n    # Check horizontal placement\n    if width * 2 == m:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j] != piece[i][j + width]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    # Check vertical placement\n    if height * 2 == n:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j] != piece[i + height][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "def min_segments(x1, y1, x2, y2, x3, y3):\n    # Check if all points are collinear on the same axis\n    if x1 == x2 == x3:\n        return 1\n    if y1 == y2 == y3:\n        return 1\n    \n    # Check if two points share the same x-coordinate or y-coordinate\n    if (x1 == x2 or x1 == x3 or x2 == x3) or (y1 == y2 or y1 == y3 or y2 == y3):\n        return 2\n    \n    # General case where no two points share the same coordinate\n    return 3\n\n# Read input\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\n# Calculate and print the minimum number of segments\nprint(min_segments(x1, y1, x2, y2, x3, y3))"}
{"solution": "def build_k_regular_graph(k):\n    if k == 1:\n        return \"YES\\n2 1\\n1 2\"\n    elif k % 2 == 0:\n        return \"NO\"\n    else:\n        n = 2 * k + 1\n        m = n * k // 2\n        edges = []\n        \n        # Create a cycle to ensure connectivity\n        for i in range(n - 1):\n            edges.append((i + 1, i + 2))\n        edges.append((n, 1))\n        \n        # Add remaining edges to make it k-regular\n        for i in range(1, n // 2 + 1):\n            for j in range(1, k):\n                edges.append((i, (i + j) % (n // 2) + 1))\n            edges.append((i, (i + k // 2) % (n // 2) + 1 + n // 2))\n        \n        # Ensure the graph has at least one bridge\n        if n > 3:\n            edges.remove((2, 3))\n            edges.append((1, 3))\n        \n        result = [\"YES\", f\"{n} {m}\"]\n        for u, v in edges:\n            result.append(f\"{u} {v}\")\n        \n        return \"\\n\".join(result)\n\n# Read input\nk = int(input())\n\n# Generate and print the output\nprint(build_k_regular_graph(k))"}
{"solution": "def build_z_function(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            z[i] = min(r - i + 1, z[i - l])\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > r:\n            l, r = i, i + z[i] - 1\n    return z\n\ndef preprocess(s, t):\n    concatenated = t + '$' + s\n    z_values = build_z_function(concatenated)\n    m = len(t)\n    occurrences = [0] * (len(s) + 1)\n    for i in range(m + 1, len(z_values)):\n        if z_values[i] == m:\n            occurrences[i - m - 1] += 1\n    for i in range(len(s)):\n        occurrences[i + 1] += occurrences[i]\n    return occurrences\n\ndef count_occurrences(s, t, queries):\n    n, m, q = len(s), len(t), len(queries)\n    occurrences = preprocess(s, t)\n    answers = []\n    for l, r in queries:\n        l, r = l - 1, r - 1\n        count = occurrences[r] - occurrences[l]\n        answers.append(count)\n    return answers\n\n# Reading input\nn, m, q = map(int, input().split())\ns = input()\nt = input()\nqueries = [list(map(int, input().split())) for _ in range(q)]\n\n# Solving the problem\nanswers = count_occurrences(s, t, queries)\n\n# Printing output\nfor answer in answers:\n    print(answer)"}
{"solution": "def count_paths(n, k, d):\n    MOD = 1000000007\n\n    # Initialize DP tables\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill DP table\n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            for w in range(1, k + 1):\n                if i >= w:\n                    dp[i][j] += dp[i - w][max(j - 1, 0)] if w >= d else dp[i - w][j]\n                    dp[i][j] %= MOD\n\n    # Sum all valid paths\n    result = sum(dp[n]) % MOD\n    return result\n\n# Read input\nn, k, d = map(int, input().split())\n\n# Compute and print the result\nprint(count_paths(n, k, d))"}
{"solution": "def encrypt_japanese_crossword(n, row):\n    groups = []\n    count = 0\n    \n    for char in row:\n        if char == 'B':\n            count += 1\n        else:\n            if count > 0:\n                groups.append(count)\n                count = 0\n    \n    if count > 0:\n        groups.append(count)\n    \n    print(len(groups))\n    if groups:\n        print(\" \".join(map(str, groups)))\n\n# Reading input\nn = int(input())\nrow = input().strip()\nencrypt_japanese_crossword(n, row)"}
{"solution": "def process_operations(n, m, p, sequence, operations):\n    pairs = [-1] * n\n    stack = []\n    \n    # Pairing brackets\n    for i, char in enumerate(sequence):\n        if char == '(':\n            stack.append(i)\n        else:\n            pairs[stack.pop()] = i\n            pairs[i] = stack[-1] if stack else -1\n    \n    cursor = p - 1\n    remaining = list(range(n))\n    \n    for op in operations:\n        if op == 'L':\n            if cursor > 0:\n                cursor -= 1\n                while pairs[remaining[cursor]] != -1 and remaining[cursor] != -1:\n                    cursor -= 1\n        elif op == 'R':\n            if cursor < n - 1:\n                cursor += 1\n                while pairs[remaining[cursor]] != -1 and remaining[cursor] != -1:\n                    cursor += 1\n        elif op == 'D':\n            start = remaining[cursor]\n            end = pairs[start]\n            \n            # Remove the range\n            remaining[start:end+1] = []\n            pairs[start:end+1] = [-1] * (end - start + 1)\n            \n            # Update cursor position\n            if cursor >= len(remaining) or cursor == -1:\n                cursor = max(0, cursor - 1)\n    \n    # Reconstruct the sequence\n    result = ''.join(sequence[i] for i in remaining if pairs[i] == -1)\n    \n    return result\n\n# Reading input\nn, m, p = map(int, input().split())\nsequence = input()\noperations = input()\n\n# Processing and printing output\nprint(process_operations(n, m, p, sequence, operations))"}
{"solution": "def find_valid_integer():\n    n = int(input())\n    lower_bound = -2 * (10 ** 9)\n    upper_bound = 2 * (10 ** 9)\n    \n    for _ in range(n):\n        sign, x, answer = input().split()\n        x = int(x)\n        \n        if sign == \">\" and answer == \"Y\":\n            lower_bound = max(lower_bound, x + 1)\n        elif sign == \"<\" and answer == \"Y\":\n            upper_bound = min(upper_bound, x - 1)\n        elif sign == \">=\" and answer == \"Y\":\n            lower_bound = max(lower_bound, x)\n        elif sign == \"<=\" and answer == \"Y\":\n            upper_bound = min(upper_bound, x)\n        else:\n            if sign == \">\" and answer == \"N\":\n                upper_bound = min(upper_bound, x)\n            elif sign == \"<\" and answer == \"N\":\n                lower_bound = max(lower_bound, x)\n            elif sign == \">=\" and answer == \"N\":\n                upper_bound = min(upper_bound, x - 1)\n            elif sign == \"<=\" and answer == \"N\":\n                lower_bound = max(lower_bound, x + 1)\n    \n    if lower_bound <= upper_bound:\n        print(upper_bound)\n    else:\n        print(\"Impossible\")\n\nfind_valid_integer()"}
{"solution": "from math import gcd\n\ndef count_possible_periods(a, b):\n    \"\"\"\n    Calculate the number of different periods over all possible strings with a letters 'A' and b letters 'B'.\n    \"\"\"\n    # The total length of the string\n    n = a + b\n    \n    # Initialize the set to store unique periods\n    periods = set()\n    \n    # Loop through all possible divisors of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, check both i and n//i\n            periods.add(i)\n            periods.add(n // i)\n    \n    # For each potential period k, check if it can form a valid period with a and b\n    for k in list(periods):\n        g = gcd(a, k)\n        if k * g > a or k - g > b:\n            periods.remove(k)\n    \n    return len(periods)\n\n# Read input\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(count_possible_periods(a, b))"}
{"solution": "def generate_names(n, k, conditions):\n    names = [\"Aa\"] * n\n    unique_names = [\"Aa\"]\n    next_name_index = 1\n    \n    for i in range(1, 26):\n        unique_names.append(chr(ord('A') + i) + \"a\")\n    \n    for i in range(n - k + 1):\n        if conditions[i] == \"YES\":\n            # Check if the current group needs unique names\n            for j in range(k):\n                if names[i + j] == \"\":\n                    if next_name_index < len(unique_names):\n                        names[i + j] = unique_names[next_name_index]\n                        next_name_index += 1\n                    else:\n                        names[i + j] = unique_names[j]\n        else:\n            # If the group is not effective, make sure some names are repeated\n            used_names = set()\n            for j in range(i, i + k):\n                if names[j] != \"\":\n                    used_names.add(names[j])\n            if len(used_names) > 1:\n                # Find a name to duplicate\n                for j in range(i, i + k):\n                    if names[j] != \"\":\n                        for m in range(j + 1, i + k):\n                            if names[m] == \"\":\n                                names[m] = names[j]\n                                break\n                        break\n    \n    return names\n\n# Reading input\nn, k = map(int, input().split())\nconditions = input().split()\n\n# Generate and print the names\nnames = generate_names(n, k, conditions)\nprint(\" \".join(names))"}
{"solution": "def min_operations_to_equal(a, b):\n    def count_factors(n, factor):\n        count = 0\n        while n % factor == 0:\n            n //= factor\n            count += 1\n        return count, n\n\n    # Count the number of times we can divide by 2, 3, and 5\n    a2, a = count_factors(a, 2)\n    a3, a = count_factors(a, 3)\n    a5, a = count_factors(a, 5)\n    \n    b2, b = count_factors(b, 2)\n    b3, b = count_factors(b, 3)\n    b5, b = count_factors(b, 5)\n    \n    # If the remaining parts are not equal, return -1\n    if a != b:\n        return -1\n    \n    # Calculate the total number of operations needed\n    operations = abs(a2 - b2) + abs(a3 - b3) + abs(a5 - b5)\n    \n    return operations\n\n# Read input\na, b = map(int, input().split())\n\n# Print the result\nprint(min_operations_to_equal(a, b))"}
{"solution": "def min_cost_palindrome(n, a, b, c):\n    dp = [[float('inf')] * (1 << n) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(n):\n        for mask in range(1 << n):\n            if dp[i][mask] == float('inf'):\n                continue\n            for j in range(n):\n                if not (mask & (1 << j)):\n                    if c[j] == 2 or (c[i - (i > j)] == c[j]):\n                        dp[i + 1][mask | (1 << j)] = min(dp[i + 1][mask | (1 << j)], dp[i][mask] + (a if c[j] == 0 else b if c[j] == 1 else 0))\n\n    result = min(dp[n][mask] for mask in range(1 << n) if mask.count_bit() == n // 2)\n    return result if result != float('inf') else -1\n\n# Helper function to count set bits in a binary number\ndef count_bit(x):\n    return bin(x).count('1')\n\n# Overwrite the count_bit method in the dp array\nfor i in range(len(dp)):\n    dp[i].__count_bit__ = count_bit\n\n# Read input\nn, a, b = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Compute and print the result\nprint(min_cost_palindrome(n, a, b, c))"}
{"solution": "def paint_cube(k):\n    if k == 1:\n        print(-1)\n        return\n    \n    # Initialize the cube as a 3D list filled with 'w'\n    cube = [[[None for _ in range(k)] for _ in range(k)] for _ in range(k)]\n    \n    # Fill the cube with alternating 'b' and 'w' in a checkerboard pattern\n    for z in range(k):\n        for x in range(k):\n            for y in range(k):\n                # Checkerboard pattern\n                if (x + y + z) % 2 == 0:\n                    cube[z][x][y] = 'b'\n                else:\n                    cube[z][x][y] = 'w'\n    \n    # Check if the solution is valid\n    def is_valid(cube):\n        for z in range(k):\n            for x in range(k):\n                for y in range(k):\n                    count = 0\n                    # Check neighbors\n                    for dz, dx, dy in [(-1, 0, 0), (1, 0, 0), (0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1)]:\n                        nz, nx, ny = z + dz, x + dx, y + dy\n                        if 0 <= nz < k and 0 <= nx < k and 0 <= ny < k:\n                            if cube[nz][nx][ny] == cube[z][x][y]:\n                                count += 1\n                    if cube[z][x][y] == 'w' and count != 2:\n                        return False\n                    if cube[z][x][y] == 'b' and count != 2:\n                        return False\n        return True\n    \n    if not is_valid(cube):\n        print(-1)\n        return\n    \n    # Print the cube\n    for z in range(k):\n        for x in range(k):\n            for y in range(k):\n                print(cube[z][x][y], end='')\n            print()\n        if z < k - 1:\n            print()"}
{"solution": "from math import sqrt\nfrom collections import Counter\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n        i += 1\n        if i == 2:  # Skip even numbers after 2\n            i += 1\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef largest_lovely_number(n):\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n    \n    lovely_number = 1\n    for prime, count in factor_counts.items():\n        lovely_number *= prime if count % 2 == 1 else 1\n    \n    return lovely_number\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the result\nprint(largest_lovely_number(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    # Check for adjacent occupied seats\n    for i in range(n - 1):\n        if seating[i] == '1' and seating[i + 1] == '1':\n            return \"No\"\n    \n    # Check for possible additional seating\n    for i in range(n):\n        if seating[i] == '0':\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nn = int(input())\nseating = input().strip()\nprint(is_maximal_seating(n, seating))"}
{"solution": "def find_possible_k_values(n, a):\n    def is_valid_period(k):\n        prefix_sums = [0]\n        for i in range(1, k + 1):\n            prefix_sums.append(a[i] - a[i - 1])\n        \n        for i in range(k + 1, n + 1):\n            current_diff = a[i] - a[i - 1]\n            expected_diff = prefix_sums[i % k] - prefix_sums[(i % k) - 1]\n            if current_diff != expected_diff:\n                return False\n        return True\n    \n    valid_ks = []\n    for k in range(1, n + 1):\n        if is_valid_period(k):\n            valid_ks.append(k)\n    \n    print(len(valid_ks))\n    print(\" \".join(map(str, valid_ks)))\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Solving and printing output\nfind_possible_k_values(n, a)"}
{"solution": "from itertools import combinations\n\ndef can_form_equal_teams(scores):\n    total_score = sum(scores)\n    if total_score % 2 != 0:\n        return \"NO\"\n    \n    target_score = total_score // 2\n    for team in combinations(scores, 3):\n        if sum(team) == target_score:\n            remaining_scores = [s for s in scores if s not in team]\n            if sum(remaining_scores) == target_score:\n                return \"YES\"\n    return \"NO\"\n\n# Read input\nscores = list(map(int, input().split()))\n\n# Output result\nprint(can_form_equal_teams(scores))"}
{"solution": "import math\n\ndef generate_2_3_integers(limit):\n    max_exp = int(math.log(limit, 2)) + 1\n    nums = set()\n    \n    for x in range(max_exp):\n        for y in range(int(math.log(limit // (2 ** x), 3)) + 1):\n            num = 2 ** x * 3 ** y\n            if num <= limit:\n                nums.add(num)\n                \n    return sorted(nums)\n\ndef count_2_3_integers_in_range(l, r):\n    # Generate all 2-3 integers up to the maximum limit\n    all_2_3_integers = generate_2_3_integers(r)\n    \n    # Count the 2-3 integers within the range [l, r]\n    count = sum(1 for num in all_2_3_integers if l <= num <= r)\n    \n    return count\n\n# Read input\nl, r = map(int, input().split())\n\n# Output the result\nprint(count_2_3_integers_in_range(l, r))"}
{"solution": "def candies_eaten(n, k):\n    eaten = 0\n    candies = 0\n    add = 1\n    \n    while True:\n        # Add candies\n        candies += add\n        n -= 1\n        if candies > k:\n            candies -= add\n            n += 1\n            break\n        if n == 0 and candies == k:\n            break\n        add += 1\n        \n        # Eat candies if possible\n        if n > 0 and candies > 0:\n            candies -= 1\n            eaten += 1\n            n -= 1\n            if n == 0 and candies == k:\n                break\n    \n    return eaten\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(candies_eaten(n, k))"}
{"solution": "def can_form_triangle(n, segments):\n    # Sort the segments to simplify comparison\n    segments.sort()\n    \n    # Iterate through the sorted segments to find a valid triangle\n    for i in range(n - 2):\n        # Check if the current set of three segments can form a non-degenerate triangle\n        if segments[i] + segments[i + 1] > segments[i + 2]:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\nsegments = list(map(int, input().split()))\n\n# Output result\nprint(can_form_triangle(n, segments))"}
{"solution": "def is_possible(x, y):\n    if y < 1:\n        return \"No\"\n    y -= 1  # Adjusting for the initial original toy\n    while y < x or y % 2:\n        if x < y or x % 2:\n            return \"No\"\n        x //= 2\n        y *= 2\n    return \"Yes\" if y == x == 0 else \"No\"\n\n# Read input\nx, y = map(int, input().split())\n\n# Output result\nprint(is_possible(x, y))"}
{"solution": "def max_character_rating(n, k, skills):\n    # Calculate initial total rating\n    initial_rating = sum(a // 10 for a in skills)\n    \n    # Calculate the number of units needed to reach the next multiple of 10 for each skill\n    improvements = [(10 * ((a + 9) // 10) - a, i) for i, a in enumerate(skills)]\n    improvements.sort()  # Sort by the number of units needed\n    \n    # Allocate improvement units\n    for units_needed, index in improvements:\n        if k >= units_needed:\n            k -= units_needed\n            skills[index] += units_needed\n        else:\n            break\n    \n    # Recalculate the total rating\n    final_rating = sum(a // 10 for a in skills)\n    \n    return final_rating\n\n# Read input\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Compute and print the maximum total rating\nprint(max_character_rating(n, k, skills))"}
{"solution": "def find_smallest_pretty_integer(n, m, list1, list2):\n    # Convert lists to sets for faster lookup\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check for common digits\n    common_digits = set1.intersection(set2)\n    if common_digits:\n        return min(common_digits)\n    \n    # If no common digits, find the smallest combination\n    min1 = min(list1)\n    min2 = min(list2)\n    \n    # Form the smallest two-digit number\n    smallest_pretty = min(int(f\"{min1}{min2}\"), int(f\"{min2}{min1}\"))\n    return smallest_pretty\n\n# Read input\nn, m = map(int, input().split())\nlist1 = list(map(int, input().split()))\nlist2 = list(map(int, input().split()))\n\n# Print the result\nprint(find_smallest_pretty_integer(n, m, list1, list2))"}
{"solution": "# Import necessary package\nfrom typing import Tuple\n\ndef max_problems_solved(n: int, k: int) -> int:\n    \"\"\"\n    Determines the maximum number of problems Limak can solve before leaving for the party.\n    \n    Args:\n    n (int): The number of problems in the contest.\n    k (int): The number of minutes Limak needs to get to the party.\n    \n    Returns:\n    int: The maximum number of problems Limak can solve.\n    \"\"\"\n    # Total time available for the contest in minutes (from 20:00 to 24:00)\n    total_time = 240  # 4 hours * 60 minutes/hour\n    \n    # Time left for solving problems after accounting for travel time\n    time_left = total_time - k\n    \n    # Calculate the cumulative time needed to solve problems\n    for i in range(1, n + 1):\n        time_needed = 5 * i * (i + 1) // 2  # Sum of the first i terms of the sequence 5, 10, 15, ...\n        if time_needed > time_left:\n            return i - 1  # Return the number of problems solved before exceeding time\n    return n  # If Limak can solve all problems within the time limit\n\n# Example check function (not part of the solution)\ndef check_solution() -> None:\n    assert max_problems_solved(3, 222) == 2\n    assert max_problems_solved(4, 190) == 4\n    assert max_problems_solved(7, 1) == 7\n\n# Uncomment the following line to run the example check function\n# check_solution()"}
{"solution": "def max_teams(n, x, y, a):\n    a.sort()\n    double_sided = x\n    single_sided = y\n    count = 0\n    \n    for pages in a:\n        double_needed = pages // 2\n        single_needed = pages % 2\n        \n        if double_needed <= double_sided:\n            double_sided -= double_needed\n            if single_needed <= single_sided:\n                single_sided -= single_needed\n                count += 1\n            else:\n                double_sided += double_needed\n                break\n        else:\n            remaining_pages = pages - 2 * double_sided\n            if remaining_pages <= single_sided:\n                single_sided -= remaining_pages\n                double_sided = 0\n                count += 1\n            else:\n                break\n    \n    return count\n\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\nprint(max_teams(n, x, y, a))"}
{"solution": "from math import gcd\n\ndef count_divisors(n):\n    divisors = set()\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return len(divisors)\n\n# Read input\nb = int(input().strip())\n\n# Calculate the number of distinct values\nresult = count_divisors(b)\n\n# Print the result\nprint(result)"}
{"solution": "n = int(input())\nbumper_sequence = input()\n\n# Initialize counters\nleft_fall_count = 0\nright_fall_count = 0\nmax_left_fall = 0\nmax_right_fall = 0\n\n# Count consecutive '<' from the left\nfor i in range(n):\n    if bumper_sequence[i] == '<':\n        left_fall_count += 1\n    else:\n        max_left_fall = max(max_left_fall, left_fall_count)\n        left_fall_count = 0\n\n# Count consecutive '>' from the right\nfor i in range(n - 1, -1, -1):\n    if bumper_sequence[i] == '>':\n        right_fall_count += 1\n    else:\n        max_right_fall = max(max_right_fall, right_fall_count)\n        right_fall_count = 0\n\n# Final check for the last sequence of '<'\nmax_left_fall = max(max_left_fall, left_fall_count)\n# Final check for the last sequence of '>'\nmax_right_fall = max(max_right_fall, right_fall_count)\n\n# Calculate the number of positions from which the ball will fall\nresult = max_left_fall + max_right_fall + 1\n\nprint(result)"}
{"solution": "from collections import Counter\n\ndef max_rectangle_area(stick_lengths):\n    count = Counter(stick_lengths)\n    stick_lengths = sorted(set(stick_lengths))\n    total_area = 0\n    \n    for i, length in enumerate(stick_lengths):\n        if count[length] >= 4:\n            total_area += (length ** 2) * (count[length] // 4)\n            count[length] %= 4\n        elif count[length] >= 2 and i > 0 and count[stick_lengths[i-1]] >= 2:\n            total_area += (length - 1) * (length - 1)\n            count[length] -= 2\n            count[stick_lengths[i-1]] -= 2\n        # Check if we can reduce length by 1 and still form a rectangle\n        if count[length] >= 2 and i > 0 and count[stick_lengths[i-1]] >= 2:\n            total_area += (length - 1) * (length - 1)\n            count[length] -= 2\n            count[stick_lengths[i-1]] -= 2\n    \n    return total_area\n\n# Reading input\nn = int(input())\nl = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(max_rectangle_area(l))"}
{"solution": "from collections import defaultdict, Counter\nfrom itertools import permutations\n\ndef min_sum_of_restored_numbers(n, strings):\n    # Mapping letters to digits\n    letter_to_digit = {chr(97 + i): -1 for i in range(10)}  # 'a' to 'j'\n    \n    # Collect all unique characters\n    all_chars = set(''.join(strings))\n    \n    # Initialize the mapping and the result\n    min_sum = float('inf')\n    \n    # Generate all permutations of digits for mapping\n    for perm in permutations(range(10), len(all_chars)):\n        # Assign digits to letters\n        for char, digit in zip(sorted(all_chars), perm):\n            letter_to_digit[char] = digit\n        \n        # Check if the current mapping leads to a valid number without leading zeros\n        current_sum = 0\n        for s in strings:\n            num = int(s.translate(str.maketrans(letter_to_digit)))\n            if str(num).startswith('0'):\n                break\n            current_sum += num\n        else:\n            # Update the minimum sum if the current one is smaller\n            min_sum = min(min_sum, current_sum)\n        \n        # Reset the mapping for the next permutation\n        for char in all_chars:\n            letter_to_digit[char] = -1\n    \n    return min_sum\n\n# Reading input\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Calculating and printing the minimum sum\nprint(min_sum_of_restored_numbers(n, strings))"}
{"solution": "def max_teams(n, m):\n    # Binary search to find the maximum number of teams\n    low, high = 0, min(n, m, (n + m) // 3)\n    \n    while low < high:\n        mid = (low + high + 1) // 2\n        if mid <= n and mid <= m and 2 * mid <= n + m:\n            low = mid\n        else:\n            high = mid - 1\n    \n    return low\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    n = len(s)\n    \n    # Check for \"AB\" followed by \"BA\"\n    index_ab = -1\n    for i in range(n - 1):\n        if s[i:i+2] == \"AB\":\n            index_ab = i\n            break\n    \n    if index_ab != -1:\n        for j in range(index_ab + 2, n - 1):\n            if s[j:j+2] == \"BA\":\n                print(\"YES\")\n                return\n    \n    # Check for \"BA\" followed by \"AB\"\n    index_ba = -1\n    for i in range(n - 1):\n        if s[i:i+2] == \"BA\":\n            index_ba = i\n            break\n    \n    if index_ba != -1:\n        for j in range(index_ba + 2, n - 1):\n            if s[j:j+2] == \"AB\":\n                print(\"YES\")\n                return\n    \n    # If neither condition is met\n    print(\"NO\")\n\n# Read input\ns = input().strip()\ncheck_substrings(s)"}
{"solution": "def can_transform(a, b):\n    n = len(a)\n    k = len(b)\n    \n    stack = []\n    j = 0\n    \n    for i in range(n):\n        stack.append(a[i])\n        \n        while j < k and stack and (stack[-1] == b[j] or stack[-1] > b[j]):\n            if stack[-1] < b[j]:\n                return False\n            stack.pop()\n            j += 1\n    \n    return j == k and not stack\n\ndef simulate_eating(a, b):\n    n = len(a)\n    k = len(b)\n    \n    if not can_transform(a, b):\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    \n    j = 0\n    for i in range(n):\n        if j < k and a[i] == b[j]:\n            j += 1\n        else:\n            print(i + 1, 'L' if i > 0 and a[i] > a[i - 1] else 'R')\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    k = int(input())\n    b = list(map(int, input().split()))\n    \n    simulate_eating(a, b)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_possible_to_assign(rebels, bases):\n    def ccw(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    def segment_intersection(seg1, seg2):\n        p1, p2 = seg1\n        q1, q2 = seg2\n        return (ccw(p1, p2, q1) * ccw(p1, p2, q2) <= 0) and (ccw(q1, q2, p1) * ccw(q1, q2, p2) <= 0)\n\n    n = len(rebels)\n    m = len(bases)\n\n    if n != m:\n        return \"No\"\n\n    def check_assignment(assignment):\n        for i in range(n):\n            for j in range(i + 1, n):\n                if segment_intersection((rebels[i], bases[assignment[i]]), (rebels[j], bases[assignment[j]])):\n                    return False\n        return True\n\n    from itertools import permutations\n    for perm in permutations(range(n)):\n        if check_assignment(perm):\n            return \"Yes\"\n    return \"No\"\n\n# Reading input\nR, B = map(int, input().split())\nrebels = [tuple(map(int, input().split())) for _ in range(R)]\nbases = [tuple(map(int, input().split())) for _ in range(B)]\n\n# Printing output\nprint(is_possible_to_assign(rebels, bases))"}
{"solution": "def max_power_of_two(n, arr):\n    def highest_power_of_two(num):\n        power = 0\n        while num % 2 == 0:\n            num //= 2\n            power += 1\n        return power\n\n    max_power = 0\n    count = 0\n\n    for num in arr:\n        current_power = highest_power_of_two(num)\n        if current_power > max_power:\n            max_power = current_power\n            count = 1\n        elif current_power == max_power:\n            count += 1\n\n    # Calculate the actual value of r\n    r = 2 ** max_power\n    print(r, count)\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Solving and printing output\nmax_power_of_two(n, arr)"}
{"solution": "def min_clicks(n, m):\n    clicks = 0\n    while n != m:\n        if m < n or (m % 2 == 0 and n <= m):\n            m //= 2\n        else:\n            m += 1\n        clicks += 1\n    return clicks\n\nn, m = map(int, input().split())\nprint(min_clicks(n, m))"}
{"solution": "from collections import defaultdict\n\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    return find(parent, parent[i])\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef check_tree(n, segments):\n    edges = []\n    graph = defaultdict(list)\n    \n    # Build edges based on segment intersection rules\n    for i in range(n):\n        for j in range(i + 1, n):\n            li, ri = segments[i]\n            lj, rj = segments[j]\n            if lj < ri < rj or li < rj < ri:\n                if not (li <= lj and ri >= rj) and not (lj <= li and rj >= ri):\n                    edges.append((i, j))\n                    graph[i].append(j)\n                    graph[j].append(i)\n    \n    # Check connectivity and cycle using Union-Find\n    parent = list(range(n))\n    rank = [0] * n\n    expected_edges = n - 1\n    actual_edges = len(edges)\n    \n    for u, v in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x != y:\n            union(parent, rank, u, v)\n        else:\n            expected_edges -= 1\n    \n    # Check if the graph is a tree\n    if expected_edges == actual_edges and len(set(find(parent, i) for i in range(n))) == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(check_tree(n, segments))"}
{"solution": "def longest_ddos_attack(n, requests):\n    max_length = 0\n    for start in range(n):\n        total_requests = 0\n        for end in range(start, n):\n            total_requests += requests[end]\n            duration = end - start + 1\n            if total_requests > 100 * duration:\n                max_length = max(max_length, duration)\n            else:\n                break\n    return max_length\n\n# Read input\nn = int(input())\nrequests = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(longest_ddos_attack(n, requests))"}
{"solution": "def check_dissatisfaction(n, k, episodes):\n    def check_possible(max_consecutive, episodes):\n        current_consecutive = 0\n        for episode in episodes:\n            if episode == 'N':\n                current_consecutive += 1\n                if current_consecutive > max_consecutive:\n                    return False\n            elif episode == 'Y':\n                current_consecutive = 0\n            else:  # episode == '?'\n                if current_consecutive == max_consecutive:\n                    current_consecutive = 0\n        return True\n\n    episodes = episodes.replace('?', 'N')\n    if max(map(len, episodes.split('Y'))) == k:\n        return \"YES\"\n    \n    episodes = episodes.replace('?', 'Y')\n    if max(map(len, episodes.split('Y'))) < k:\n        return \"NO\"\n\n    return \"YES\" if check_possible(k, episodes) else \"NO\"\n\n# Reading input\nn, k = map(int, input().split())\nepisodes = input()\n\n# Printing output\nprint(check_dissatisfaction(n, k, episodes))"}
{"solution": "def count_possible_values(N, X, D):\n    # Calculate the total sum of the sequence\n    total_sum = X * N + D * (N * (N - 1) // 2)\n    \n    # Calculate the maximum possible difference\n    max_diff = total_sum\n    \n    # The minimum possible difference is always -max_diff\n    min_diff = -max_diff\n    \n    # The number of possible values of S - T is the range of possible differences plus 1\n    num_possible_values = max_diff - min_diff + 1\n    \n    return num_possible_values\n\n# Read input\nN, X, D = map(int, input().split())\n\n# Calculate and print the number of possible values of S - T\nprint(count_possible_values(N, X, D))"}
{"solution": "def did_anton_perform_good(n, participants):\n    for handle, before, after in participants:\n        if before >= 2400 and after > before:\n            return \"YES\"\n    return \"NO\"\n\n# Reading input\nn = int(input())\nparticipants = [input().split() for _ in range(n)]\nparticipants = [(handle, int(before), int(after)) for handle, before, after in participants]\n\n# Printing the result\nprint(did_anton_perform_good(n, participants))"}
{"solution": "def count_missed_trains(binary_time):\n    # Convert binary time to decimal\n    decimal_time = int(binary_time, 2)\n    missed_trains = 0\n    \n    # Iterate through powers of 4 until reaching the time\n    k = 0\n    while 4 ** k < decimal_time:\n        missed_trains += 1\n        k += 1\n    \n    return missed_trains\n\n# Read input\nbinary_time = input()\n\n# Calculate and print the number of missed trains\nprint(count_missed_trains(binary_time))"}
{"solution": "def min_rows_for_matrix_b(n, m, matrix_a):\n    # Initialize the result variable\n    result = 0\n    \n    # Iterate through each column to find the minimum number of unique rows needed\n    for j in range(m):\n        current_column = [matrix_a[i][j] for i in range(n)]\n        unique_patterns = set()\n        \n        # Add each half of the column to the set of unique patterns\n        for i in range((n + 1) // 2):\n            unique_patterns.add((current_column[i], current_column[n - 1 - i]))\n        \n        # If the number of unique patterns is more than 1, we need 2 rows for this column\n        # Otherwise, we only need 1 row\n        result = max(result, min(2, len(unique_patterns)))\n    \n    return result\n\n# Read input\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the minimum number of rows for matrix b\nprint(min_rows_for_matrix_b(n, m, matrix_a))"}
{"solution": "import sys\n\n# Reading input\ninput = sys.stdin.read\ndata = list(map(int, input().split()))\n\nn = data[0]\norders = [(data[i], data[i + 1]) for i in range(1, 2 * n, 2)]\n\n# Sorting orders by their end times\norders.sort(key=lambda x: x[1])\n\n# Initializing variables\ncount = 0\nlast_end_time = -1\n\n# Iterating through sorted orders\nfor start, end in orders:\n    if start >= last_end_time:\n        count += 1\n        last_end_time = end\n\nprint(count)"}
{"solution": "def can_rearrange(n, k, tables, formulas):\n    prev_table_count = 0\n    prev_formula_count = 0\n    \n    for i in range(n):\n        table_count = 0\n        formula_count = 0\n        \n        # Count consecutive tables and formulas\n        if prev_formula_count > 0:\n            table_count += prev_formula_count\n            prev_formula_count = 0\n        table_count += tables[i]\n        \n        if prev_table_count > 0:\n            formula_count += prev_table_count\n            prev_table_count = 0\n        formula_count += formulas[i]\n        \n        # Check if current page violates the constraint\n        if table_count > k or formula_count > k:\n            return \"NO\"\n        \n        # Update previous counts\n        if table_count % 2 == 1:\n            prev_table_count = (table_count + 1) // 2\n            prev_formula_count = (formula_count + 1) // 2\n        else:\n            prev_table_count = table_count // 2\n            prev_formula_count = formula_count // 2\n    \n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ntables = list(map(int, input().split()))\nformulas = list(map(int, input().split()))\n\n# Output result\nprint(can_rearrange(n, k, tables, formulas))"}
{"solution": "from collections import deque\n\ndef can_human_win(n, k, coefficients):\n    # Initialize a queue to keep track of unset coefficients\n    unset_indices = deque()\n    \n    # Populate the queue with indices of unset coefficients\n    for i in range(n + 1):\n        if coefficients[i] == '?':\n            unset_indices.append(i)\n    \n    # Check if the first coefficient is set correctly\n    if len(unset_indices) == 0:\n        return \"Yes\" if coefficients[0] == 0 else \"No\"\n    \n    # If the first move is not made by the computer, simulate its move\n    if unset_indices[0] == 0:\n        unset_indices.popleft()\n        coefficients[0] = 0\n    \n    # Iterate through the remaining unset coefficients\n    while unset_indices:\n        current_index = unset_indices.popleft()\n        \n        # Calculate the required coefficient to ensure divisibility by (x - k)\n        required_coefficient = -sum(coefficients[i] * k ** (current_index - i) for i in range(current_index))\n        \n        # If the required coefficient is already set and doesn't match, human cannot win\n        if current_index < len(coefficients) and coefficients[current_index] != '?' and coefficients[current_index] != required_coefficient:\n            return \"No\"\n        \n        # Set the coefficient to the required value\n        coefficients[current_index] = required_coefficient\n    \n    return \"Yes\"\n\n# Read input\nn, k = map(int, input().split())\ncoefficients = [input() if input().strip() != '?' else '?' for _ in range(n + 1)]\n\n# Determine if the human can guarantee a win\nprint(can_human_win(n, k, coefficients))"}
{"solution": "from sympy import primerange\n\ndef smallest_starting_number(X2):\n    def next_move(X, primes):\n        for p in primes:\n            if p < X - 1:\n                next_X = ((X - 1) // p + 1) * p\n                if next_X >= X:\n                    return next_X\n        return X\n\n    primes = list(primerange(2, X2))\n    possible_X0 = set()\n\n    for X1 in range(4, X2 + 1):\n        X0 = X1\n        while True:\n            X1 = next_move(X1, primes)\n            if X1 == X2:\n                possible_X0.add(X0)\n                break\n            elif X1 > X2:\n                break\n            X0 -= 1\n\n    return min(possible_X0)\n\n# Read input\nX2 = int(input())\n\n# Calculate and print the smallest possible starting number\nprint(smallest_starting_number(X2))"}
{"solution": "def min_p_binary_summands(n, p):\n    if p >= n:\n        return -1\n    if p == 0:\n        return bin(n).count('1')\n    \n    count = 0\n    while n > 0:\n        x = 1\n        while (1 << x) - p <= n:\n            x += 1\n        if x > 0:\n            n -= (1 << (x - 1)) - p\n            count += 1\n        else:\n            return -1\n    \n    return count\n\n# Reading input\nn, p = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_p_binary_summands(n, p))"}
{"solution": "def minimize_number(n, k, S):\n    # Convert S to a list of characters for easy manipulation\n    S_list = list(S)\n    \n    # Initialize a pointer for iteration\n    pointer = 0\n    \n    # Process the first digit separately\n    if k > 0 and S_list[pointer] != '1':\n        S_list[pointer] = '1'\n        k -= 1\n    elif k > 0 and S_list[pointer] == '1':\n        pointer += 1\n    \n    # Iterate through the rest of the digits\n    while pointer < n and k > 0:\n        if S_list[pointer] != '0':\n            S_list[pointer] = '0'\n            k -= 1\n        pointer += 1\n    \n    # If there's only one digit and k > 0, change it to 0\n    if n == 1 and k > 0:\n        S_list[0] = '0'\n    \n    # Join the list back into a string\n    result = ''.join(S_list)\n    \n    # Print the result\n    print(result)\n\n# Read input\nn, k = map(int, input().split())\nS = input()\n\n# Call the function\nminimize_number(n, k, S)"}
{"solution": "import math\n\ndef lcm(a, b):\n    return abs(a * b) // math.gcd(a, b)\n\ndef find_minimum_v(cnt_1, cnt_2, x, y):\n    lcm_xy = lcm(x, y)\n    step_x = x * (lcm_xy // x)\n    step_y = y * (lcm_xy // y)\n    \n    cnt_1_max = (cnt_1 - 1) // (lcm_xy // x) * step_x + x\n    cnt_2_max = (cnt_2 - 1) // (lcm_xy // y) * step_y + y\n    \n    v = max(cnt_1_max, cnt_2_max)\n    total_cnt = (v // x - v // lcm_xy) + (v // y - v // lcm_xy)\n    \n    while total_cnt < cnt_1 + cnt_2:\n        v += 1\n        total_cnt = (v // x - v // lcm_xy) + (v // y - v // lcm_xy)\n    \n    return v\n\n# Reading input\ncnt_1, cnt_2, x, y = map(int, input().split())\n\n# Calculating and printing the answer\nprint(find_minimum_v(cnt_1, cnt_2, x, y))"}
{"solution": "def final_position(n, sx, sy, dx, dy, t):\n    def update_speed(dx, dy, k):\n        return dx + k, dy + k\n    \n    def next_cell(x, y, dx, dy, n):\n        return ((x + dx - 1) % n) + 1, ((y + dy - 1) % n) + 1\n    \n    current_x, current_y = sx, sy\n    current_dx, current_dy = dx, dy\n    \n    for _ in range(t):\n        k = current_x + current_y  # Number of bushes eaten\n        current_dx, current_dy = update_speed(current_dx, current_dy, k)\n        current_x, current_y = next_cell(current_x, current_y, current_dx, current_dy, n)\n        \n        # Additional raspberry bush grows in each cell (but does not affect the outcome)\n    \n    return current_x, current_y\n\n# Reading input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Calculating and printing the output\nresult_x, result_y = final_position(n, sx, sy, dx, dy, t)\nprint(result_x, result_y)"}
{"solution": "from collections import Counter\n\ndef is_nice_word(s):\n    # Count occurrences of each character\n    char_count = Counter(s)\n    # Check if '?' appears at least 26 times or any letter appears more than twice\n    if char_count['?'] < 26 and any(char_count[c] > 2 for c in char_count if c != '?'):\n        return -1\n    \n    # Generate a nice word if possible\n    nice_word = list(s)\n    used_letters = set()\n    question_marks = []\n    \n    for i, char in enumerate(nice_word):\n        if char == '?':\n            question_marks.append(i)\n        else:\n            used_letters.add(char)\n    \n    # Ensure all letters A-Z are present\n    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n        if letter not in used_letters:\n            for idx in question_marks:\n                if nice_word[idx] == '?':\n                    nice_word[idx] = letter\n                    used_letters.add(letter)\n                    question_marks.remove(idx)\n                    break\n    \n    # Fill remaining '?' with any letter that doesn't exceed 2 occurrences\n    for idx in question_marks:\n        for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n            if nice_word.count(letter) < 2:\n                nice_word[idx] = letter\n                break\n    \n    return ''.join(nice_word)\n\n# Read input\ns = input().strip()\n\n# Solve and print the result\nresult = is_nice_word(s)\nprint(result)"}
{"solution": "def can_divide_apples(n, weights):\n    total_weight = sum(weights)\n    # If the total weight is odd, it's impossible to divide equally\n    if total_weight % 2 != 0:\n        return \"NO\"\n    \n    # Count the number of 100g and 200g apples\n    count_100 = weights.count(100)\n    count_200 = weights.count(200)\n    \n    # If the total weight is even, check if it's possible to divide\n    if total_weight % 100 == 0:\n        # If all apples are 100g, it's always possible\n        if count_200 == 0:\n            return \"YES\"\n        # If there are more than 2 200g apples, it's possible\n        if count_200 > 2:\n            return \"YES\"\n        # If there are exactly 2 200g apples, check if there are at least 2 100g apples\n        if count_200 == 2 and count_100 >= 2:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\nweights = list(map(int, input().split()))\n\n# Output result\nprint(can_divide_apples(n, weights))"}
{"solution": "def min_time_to_turn_off_lights(n, m, building):\n    # Initialize DP table\n    dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for floor in range(1, n + 1):\n        floor_plan = [0] + list(map(int, building[n - floor])) + [0]\n        for left in range(m + 1):\n            min_steps = float('inf')\n            steps_from_left = 0\n            steps_from_right = 0\n\n            # Calculate steps from left side\n            for room in range(left, m + 1):\n                if floor_plan[room]:\n                    steps_from_left += 1\n                else:\n                    steps_from_left = 0\n                min_steps = min(min_steps, steps_from_left)\n\n            # Calculate steps from right side\n            for room in range(left, -1, -1):\n                if floor_plan[room]:\n                    steps_from_right += 1\n                else:\n                    steps_from_right = 0\n                min_steps = min(min_steps, steps_from_right)\n\n            # Update DP table\n            dp[floor][left] = dp[floor - 1][left] + min_steps\n\n    return min(dp[n])\n\n# Read input\nn, m = map(int, input().split())\nbuilding = []\nfor _ in range(n):\n    building.append(input())\n\n# Calculate and print the result\nprint(min_time_to_turn_off_lights(n, m, building))"}
{"solution": "from collections import defaultdict\n\ndef find_min_trap_cost(n, costs, transitions):\n    visited = [False] * n\n    in_stack = [False] * n\n    min_cost = 0\n    cycle_costs = []\n\n    def dfs(node, cycle_costs):\n        nonlocal in_stack, visited, min_cost\n        stack = []\n        while True:\n            if visited[node]:\n                if in_stack[node]:\n                    # Found a cycle, calculate the minimum cost in this cycle\n                    cycle_min_cost = float('inf')\n                    while stack:\n                        cycle_node = stack.pop()\n                        in_stack[cycle_node] = False\n                        cycle_min_cost = min(cycle_min_cost, costs[cycle_node])\n                        if cycle_node == node:\n                            break\n                    cycle_costs.append(cycle_min_cost)\n                    return\n                else:\n                    return\n            visited[node] = True\n            in_stack[node] = True\n            stack.append(node)\n            node = transitions[node] - 1\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, cycle_costs)\n\n    # Sum of minimum costs of all cycles\n    return sum(cycle_costs)\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(find_min_trap_cost(n, costs, transitions))"}
{"solution": "n, a, b = map(int, input().split())\nresult = (a + b - 1) % n + 1\nprint(result)"}
{"solution": "from typing import List, Tuple\n\ndef min_arithmetic_progressions(n: int, sequence: List[int]) -> int:\n    def is_arithmetic(start: int, end: int, step: int) -> bool:\n        return (end - start) % step == 0\n\n    def extend_progression(start: int, end: int, step: int, index: int) -> Tuple[bool, int]:\n        if end != -1:\n            if is_arithmetic(start, end, step):\n                return True, step\n            else:\n                return False, 0\n        else:\n            # Calculate the possible value for the missing element\n            possible_value = start + step\n            sequence[index] = possible_value\n            return True, step\n\n    count = 0\n    i = 0\n    while i < n:\n        if sequence[i] == -1:\n            count += 1\n            i += 1\n            continue\n\n        if i + 1 < n and sequence[i + 1] != -1:\n            diff = sequence[i + 1] - sequence[i]\n            valid, _ = extend_progression(sequence[i], sequence[i + 1], diff, i + 1)\n            j = i + 2\n            while j < n:\n                if sequence[j] != -1:\n                    valid, diff = extend_progression(sequence[i], sequence[j], diff, j)\n                    if not valid:\n                        break\n                j += 1\n            if valid:\n                count += 1\n                i = j\n            else:\n                count += 1\n                i += 1\n        else:\n            count += 1\n            i += 1\n\n    return count\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Print the result\nprint(min_arithmetic_progressions(n, sequence))"}
{"solution": "def max_beauty(n, k, s):\n    left, max_length = 0, 0\n    changes = 0\n    \n    for right in range(n):\n        if s[right] != s[left]:\n            changes += 1\n        \n        while changes > k:\n            if s[left] != s[left + 1]:\n                changes -= 1\n            left += 1\n        \n        max_length = max(max_length, right - left + 1)\n    \n    print(max_length)\n\n# Reading input\nn, k = map(int, input().split())\ns = input()\n\n# Solving the problem\nmax_beauty(n, k, s)"}
{"solution": "def find_coalition(n, seats):\n    alice_seats = seats[0]\n    total_seats = sum(seats)\n    majority = total_seats // 2 + 1\n    coalition_seats = alice_seats\n    coalition = [1]\n\n    for i in range(1, n):\n        if alice_seats >= 2 * seats[i]:\n            coalition_seats += seats[i]\n            coalition.append(i + 1)\n\n        if coalition_seats >= majority:\n            break\n\n    if coalition_seats < majority:\n        print(0)\n    else:\n        print(len(coalition))\n        print(' '.join(map(str, coalition)))\n\n# Read input\nn = int(input())\nseats = list(map(int, input().split()))\n\n# Solve and print output\nfind_coalition(n, seats)"}
{"solution": "def max_reward(n):\n    harmonic_sum = 0.0\n    for i in range(1, n + 1):\n        harmonic_sum += 1.0 / i\n    return harmonic_sum\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the maximum reward\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "def max_children_candies(n):\n    k = 1\n    while k * (k + 1) // 2 <= n:\n        k += 1\n    k -= 1\n    \n    candies_distribution = [i for i in range(1, k + 1)]\n    remaining_candies = n - sum(candies_distribution)\n    \n    if remaining_candies > 0:\n        candies_distribution[-1] += remaining_candies\n    \n    return k, candies_distribution\n\nn = int(input())\nk, candies_distribution = max_children_candies(n)\nprint(k)\nprint(' '.join(map(str, candies_distribution)))"}
{"solution": "# Reading input\nn = int(input())\nm = int(input())\n\n# Calculating m mod 2^n\nresult = m % (2 ** n)\n\n# Printing the output\nprint(result)"}
{"solution": "def correct_word(s):\n    vowels = 'aeiouy'\n    i = 0\n    while i < len(s) - 1:\n        if s[i] in vowels and s[i + 1] in vowels:\n            s = s[:i] + s[i + 1:]\n        else:\n            i += 1\n    return s\n\nn = int(input())\ns = input()\nprint(correct_word(s))"}
{"solution": "def max_students(n, a, b, seats):\n    segments = []\n    i = 0\n    \n    # Identify segments of empty seats\n    while i < n:\n        if seats[i] == '.':\n            start = i\n            while i < n and seats[i] == '.':\n                i += 1\n            segments.append(i - start)\n        else:\n            i += 1\n    \n    total_students = 0\n    \n    # Place students in each segment\n    for length in segments:\n        # Calculate the number of students that can be placed in this segment\n        # We will place students in an alternating fashion\n        if a > b:\n            # Start with a student-programmer if more student-programmers are available\n            programmers = (length + 1) // 2\n            athletes = length // 2\n        else:\n            # Start with a student-athlete if more student-athletes are available\n            athletes = (length + 1) // 2\n            programmers = length // 2\n        \n        # Place the students\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n        \n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n    \n    return total_students\n\n# Read input\nn, a, b = map(int, input().split())\nseats = input()\n\n# Output the result\nprint(max_students(n, a, b, seats))"}
{"solution": "from math import sqrt\n\ndef find_pair(r):\n    for x in range(1, int(sqrt(r)) + 1):\n        h_x = x**2 + x + 1\n        if r >= h_x:\n            delta = 1 + 4 * (r - h_x)\n            if delta >= 0:\n                y = (-1 + sqrt(delta)) / 2\n                if y.is_integer():\n                    return x, int(y)\n    return \"NO\"\n\n# Read input\nr = int(input())\n\n# Calculate and print the result\nresult = find_pair(r)\nprint(*result)"}
{"solution": "from itertools import combinations\n\ndef can_divide_balloons(n, packets):\n    total_balloons = sum(packets)\n    for k in range(1, n):\n        for combo in combinations(range(n), k):\n            grigory_balloons = sum(packets[i] for i in combo)\n            andrew_balloons = total_balloons - grigory_balloons\n            if grigory_balloons != andrew_balloons:\n                return k, [i + 1 for i in combo]\n    return -1\n\ndef main():\n    n = int(input())\n    packets = list(map(int, input().split()))\n    \n    result = can_divide_balloons(n, packets)\n    \n    if result == -1:\n        print(-1)\n    else:\n        k, indices = result\n        print(k)\n        print(*indices)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_different_digits(n):\n    # Calculate the minimal number of different digits\n    if n % 9 == 0:\n        k = 1\n    else:\n        k = n % 9\n    \n    # Determine the number of digits needed\n    num_digits = n // 9 + (1 if k > 0 else 0)\n    \n    # Generate the output\n    output = [9] * (num_digits - (1 if k > 0 else 0))\n    if k > 0:\n        output.append(k)\n    \n    return num_digits, output\n\n# Read input\nn = int(input())\n\n# Solve and print the result\nk, digits = min_different_digits(n)\nprint(k)\nprint(' '.join(map(str, digits)))"}
{"solution": "from itertools import combinations\nfrom math import sqrt\n\ndef is_prime(num):\n    if num <= 1:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(sqrt(num)) + 1, 2):\n        if num % i == 0:\n            return False\n    return True\n\ndef find_max_simple_subset(arr):\n    max_size = 0\n    max_subset = []\n    \n    for r in range(1, len(arr) + 1):\n        for subset in combinations(arr, r):\n            if all(is_prime(x + y) for x, y in combinations(subset, 2)):\n                if len(subset) > max_size:\n                    max_size = len(subset)\n                    max_subset = list(subset)\n    \n    return max_size, max_subset\n\nn = int(input())\na = list(map(int, input().split()))\n\nmax_size, max_subset = find_max_simple_subset(a)\n\nprint(max_size)\nprint(' '.join(map(str, max_subset)))"}
{"solution": "def greatest_beautiful_divisor(n):\n    max_divisor = 0\n    k = 1\n    while True:\n        beautiful_number = (2**k - 1) * (2**k)\n        if beautiful_number > n:\n            break\n        if n % beautiful_number == 0:\n            max_divisor = beautiful_number\n        k += 1\n    return max_divisor\n\nn = int(input())\nprint(greatest_beautiful_divisor(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef multiply_mod(a, b):\n    return (a * b) % MOD\n\ndef power_mod(a, b):\n    result = 1\n    while b > 0:\n        if b & 1:\n            result = multiply_mod(result, a)\n        a = multiply_mod(a, a)\n        b >>= 1\n    return result\n\ndef count_d_magic(m, d, a, b):\n    a_len = len(str(a))\n    b_len = len(str(b))\n    \n    if a_len != b_len:\n        return 0\n    \n    dp = [[0] * 2 for _ in range(a_len + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, a_len + 1):\n        for j in range(2):\n            for k in range(10):\n                ni = i + 1\n                nj = j or k > 0\n                if (i % 2 == 1 and k == d) or (i % 2 == 0 and k != d):\n                    continue\n                dp[ni][nj] = (dp[ni][nj] + dp[i][j]) % MOD\n    \n    result = 0\n    for i in range(a_len):\n        for j in range(2):\n            if (i % 2 == 1 and d == 0) or (i % 2 == 0 and d != 0):\n                continue\n            if int(str(b)[i]) >= d:\n                result = (result + dp[i + 1][j]) % MOD\n            if int(str(a)[i]) > d:\n                result = (result + dp[i + 1][j]) % MOD\n            elif int(str(a)[i]) == d:\n                result = (result + dp[i + 1][j and 1]) % MOD\n    \n    return (result * power_mod(power_mod(5, m), MOD - 2)) % MOD\n\n# Reading input\nm, d = map(int, input().split())\na = int(input())\nb = int(input())\n\n# Calculating and printing the result\nprint(count_d_magic(m, d, a, b))"}
{"solution": "def last_child_home(n, m, candies_needed):\n    queue = list(range(1, n + 1))\n    while queue:\n        child = queue.pop(0)\n        candies_needed[child - 1] -= m\n        if candies_needed[child - 1] > 0:\n            queue.append(child)\n        else:\n            last_child = child\n    return last_child\n\n# Reading input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(last_child_home(n, m, a))"}
{"solution": "def min_bills(n):\n    denominations = [100, 20, 10, 5, 1]\n    count = 0\n    for denom in denominations:\n        count += n // denom\n        n %= denom\n    return count\n\n# Read input\nn = int(input())\n\n# Calculate and print the output\nprint(min_bills(n))"}
{"solution": "MOD = 1000000007\n\ndef factorial(n):\n    \"\"\"Compute factorial of n modulo MOD.\"\"\"\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n    return fact\n\ndef inverse_factorial(n, fact):\n    \"\"\"Compute modular inverse of factorial of n.\"\"\"\n    inv_fact = [1] * (n + 1)\n    inv_fact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 1, -1):\n        inv_fact[i - 1] = (inv_fact[i] * i) % MOD\n    return inv_fact\n\ndef comb(n, k, fact, inv_fact):\n    \"\"\"Compute binomial coefficient C(n, k) modulo MOD.\"\"\"\n    return (fact[n] * inv_fact[k] * inv_fact[n - k]) % MOD\n\ndef count_permutations(n, k):\n    \"\"\"Count the number of permutations of size n with exactly k good positions.\"\"\"\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    fact = factorial(n)\n    inv_fact = inverse_factorial(n, fact)\n    \n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(min(i, k) + 1):\n            dp[i][j] = dp[i - 1][j] * (i - 1) % MOD\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1] * (i - 1) % MOD\n            dp[i][j] %= MOD\n    \n    result = 0\n    for bad in range(k + 1):\n        good = k - bad\n        if (n - k) % 2 == bad % 2:\n            result += comb(n - k, bad, fact, inv_fact) * dp[n - bad][good] % MOD\n        else:\n            result -= comb(n - k, bad, fact, inv_fact) * dp[n - bad][good] % MOD\n        result %= MOD\n    \n    return (result + MOD) % MOD\n\n# Read input\nn, k = map(int, input().split())\n\n# Compute and print the result\nprint(count_permutations(n, k))"}
{"solution": "from collections import Counter\nfrom heapq import nlargest\n\ndef max_beauty_bouquet(n, k, beauties, colors):\n    color_count = Counter(colors)\n    color_beauty = {color: [] for color in set(colors)}\n    \n    # Populate the beauty lists for each color\n    for beauty, color in zip(beauties, colors):\n        color_beauty[color].append(beauty)\n    \n    # Sort the beauty lists for each color\n    for color in color_beauty:\n        color_beauty[color].sort(reverse=True)\n    \n    # Check if it's impossible to form a bouquet\n    if len(color_beauty) < 2 or (len(color_beauty) == 2 and 'R' in color_beauty and 'W' in color_beauty and color_count['R'] + color_count['W'] == n):\n        return -1\n    \n    # Case: Use two different colors\n    if len(color_beauty) >= 2:\n        # Find the two colors with the highest total beauty\n        colors_sorted_by_beauty = sorted(color_beauty.items(), key=lambda x: sum(x[1]), reverse=True)\n        first_color, second_color = colors_sorted_by_beauty[:2]\n        \n        # Check combinations of the top two colors\n        first_sum = sum(first_color[1][:k])\n        second_sum = sum(second_color[1][:k])\n        max_sum = max(first_sum, second_sum)\n        \n        # Try mixing the two colors\n        for i in range(max(0, k - len(second_color[1])), min(k, len(first_color[1])) + 1):\n            mixed_sum = sum(first_color[1][:i]) + sum(second_color[1][:k-i])\n            max_sum = max(max_sum, mixed_sum)\n    \n    # Case: Use three different colors\n    if len(color_beauty) == 3:\n        # Calculate the beauty of the third color\n        third_color = list(color_beauty.items())[2][1]\n        third_sum = sum(third_color[:k])\n        max_sum = max(max_sum, third_sum)\n    \n    return max_sum\n\n# Read input\nn, k = map(int, input().split())\nbeauties = list(map(int, input().split()))\ncolors = input()\n\n# Compute and print the result\nprint(max_beauty_bouquet(n, k, beauties, colors))"}
{"solution": "import sys\n\ndef continued_fraction_to_rational(a):\n    n = len(a)\n    if n == 1:\n        return (a[0], 1)\n    p1, q1 = a[n - 1], 1\n    p2, q2 = 1, 0\n    for i in range(n - 2, -1, -1):\n        temp = p1\n        p1 = a[i] * p1 + p2\n        p2 = temp\n        q2, q1 = q1, a[i] * q1 + q2\n    return (p1, q1)\n\ndef main():\n    p, q = map(int, input().split())\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    cf_p, cf_q = continued_fraction_to_rational(a)\n    \n    if p * cf_q == q * cf_p:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def shift_stick(expression):\n    parts = expression.split('+=')\n    a_sticks = parts[0]\n    b_sticks = parts[1].split('=')[0]\n    c_sticks = parts[1].split('=')[1]\n\n    a = len(a_sticks)\n    b = len(b_sticks)\n    c = len(c_sticks)\n\n    # Check if the expression is already correct\n    if a + b == c:\n        return f\"{a_sticks}+{b_sticks}={c_sticks}\"\n\n    # Try shifting one stick from C to A\n    if a + 1 + b == c - 1:\n        return f\"{a_sticks + '|'}+{b_sticks}={c_sticks[:-1]}\"\n\n    # Try shifting one stick from A to C\n    if a - 1 + b == c + 1:\n        return f\"{a_sticks[:-1]}+{b_sticks}={c_sticks + '|'}\"\n\n    # Try shifting one stick from B to C\n    if a + b - 1 == c + 1:\n        return f\"{a_sticks}+{b_sticks[:-1]}={c_sticks + '|'}\"\n\n    # Try shifting one stick from C to B\n    if a + b + 1 == c - 1:\n        return f\"{a_sticks}+{b_sticks + '|'}={c_sticks[:-1]}\"\n\n    return \"Impossible\"\n\n# Read input\nexpression = input().strip()\n\n# Solve and print the result\nprint(shift_stick(expression))"}
{"solution": "from itertools import permutations\n\nMOD = 10**9 + 7\n\ndef calculate_oddness(p):\n    return sum(abs(i - p[i]) for i in range(len(p)))\n\ndef count_permutations_with_oddness(n, k):\n    count = 0\n    for perm in permutations(range(1, n + 1)):\n        if calculate_oddness(perm) == k:\n            count += 1\n    return count % MOD\n\nn, k = map(int, input().split())\nprint(count_permutations_with_oddness(n, k))"}
{"solution": "from itertools import product\n\ndef solve(N, points):\n    # Check if it's possible to reach all points with a single section\n    if any(x == 0 and y != 0 or y == 0 and x != 0 for x, y in points):\n        return -1\n\n    # Generate all possible combinations of modes for up to 40 sections\n    for m in range(1, 41):\n        for ds in product([1, -1], repeat=m):\n            for us in product([1, -1], repeat=m):\n                # Generate all possible positions for each combination\n                positions = set()\n                x, y = 0, 0\n                for d, u in zip(ds, us):\n                    x += d\n                    y += u\n                    positions.add((x, y))\n\n                # Check if all target points can be reached\n                if all(point in positions for point in points):\n                    # Generate the configuration and paths\n                    config = [abs(d) + abs(u) for d, u in zip(ds, us)]\n                    paths = []\n                    for X, Y in points:\n                        path = ''\n                        for d, u in zip(ds, us):\n                            if d > 0 and X > 0:\n                                path += 'R'\n                                X -= 1\n                            elif d < 0 and X < 0:\n                                path += 'L'\n                                X += 1\n                            if u > 0 and Y > 0:\n                                path += 'U'\n                                Y -= 1\n                            elif u < 0 and Y < 0:\n                                path += 'D'\n                                Y += 1\n                        paths.append(path)\n\n                    return [m] + config + paths\n\n    return -1\n\n# Read input\nN = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Solve and print output\nresult = solve(N, points)\nif result == -1:\n    print(-1)\nelse:\n    print(result[0])\n    print(' '.join(map(str, result[1:result[0]+1])))\n    for path in result[result[0]+1:]:\n        print(path)"}
{"solution": "n = int(input())\ns = input()\n\ndef replace_fillers(s):\n    i = 0\n    while i < len(s):\n        if s[i:i+3] == 'ogo':\n            k = 0\n            while s[i:i+3*(k+1)] == 'ogo' * (k+1):\n                k += 1\n            s = s[:i] + '*'*3 + s[i+3*k:]\n            i += 3\n        else:\n            i += 1\n    return s\n\nresult = replace_fillers(s)\nprint(result)"}
{"solution": "from math import sqrt\n\nMOD = 10**9 + 7\n\n# Sieve of Eratosthenes to find primes up to sqrt(x)\ndef sieve(limit):\n    limitn = limit+1\n    primes = dict()\n    for ind, val in enumerate([True] * limitn): primes[ind] = val\n\n    primes[0] = primes[1] = False\n\n    for ind, val in enumerate(primes):\n        if val is True:\n            primes[ind*2::ind] = [False] * (((limit - ind)//ind) + 1)\n    return primes\n\ndef prime_factors(n):\n    factors = set()\n    for i in range(2, int(sqrt(n)) + 1):\n        while n % i == 0:\n            factors.add(i)\n            n //= i\n    if n > 1:\n        factors.add(n)\n    return factors\n\ndef g(y, p):\n    k = 0\n    while y % p == 0:\n        y //= p\n        k += 1\n    return p ** k\n\ndef f(x, y):\n    product = 1\n    for p in prime_factors(x):\n        product *= g(y, p)\n        product %= MOD\n    return product\n\ndef solve(x, n):\n    result = 1\n    factors = prime_factors(x)\n    \n    # Precompute powers of each factor\n    precomp = {p: [0] * (n + 1) for p in factors}\n    for p in factors:\n        for i in range(1, n + 1):\n            precomp[p][i] = g(i, p)\n    \n    # Calculate the product using precomputed powers\n    for p in factors:\n        partial_product = 1\n        current_power = 1\n        for i in range(1, n + 1):\n            if precomp[p][i] > 1:\n                partial_product *= precomp[p][i] ** current_power\n                partial_product %= MOD\n                current_power += 1\n        result *= partial_product\n        result %= MOD\n    \n    return result\n\n# Reading input\nx, n = map(int, input().split())\n\n# Solving and printing the output\nprint(solve(x, n))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for s in range(1, 82):  # s(x) can be at most 81\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and sum_of_digits(x) == s:\n            solutions.append(x)\n    solutions.sort()\n    return solutions\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find solutions\nsolutions = find_solutions(a, b, c)\n\n# Print results\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "from collections import defaultdict\n\ndef is_solvable_with_one_rotation(colors):\n    # Group colors by their positions\n    faces = defaultdict(list)\n    for pos, color in enumerate(colors, start=1):\n        faces[color].append(pos)\n\n    # Define the positions of each face\n    face_positions = {\n        'front': {1, 2, 6, 10},\n        'back': {3, 4, 8, 12},\n        'left': {1, 5, 7, 11},\n        'right': {2, 4, 9, 11},\n        'top': {1, 2, 3, 4},\n        'bottom': {7, 8, 9, 10}\n    }\n\n    # Check if any face can be made uniform with one rotation\n    for color, positions in faces.items():\n        for face, face_pos in face_positions.items():\n            # Check if the face can be made uniform\n            if len(set(positions) & face_pos) == 3:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\ncolors = list(map(int, input().split()))\n\n# Output result\nprint(is_solvable_with_one_rotation(colors))"}
{"solution": "def find_min_hacks(p, x, y):\n    def simulate(s):\n        i = (s // 50) % 475\n        for _ in range(25):\n            if 26 + i == p:\n                return True\n            i = (i * 96 + 42) % 475\n        return False\n\n    min_hacks = float('inf')\n    for s in range(y, 20001):\n        if simulate(s):\n            diff = s - x\n            successful_hacks = (diff + 50 - 1) // 150  # (100h - 50u) = diff -> h = (diff + 50u)/150, u = 0\n            min_hacks = min(min_hacks, successful_hacks)\n            break\n\n    return min_hacks\n\n# Read input\np, x, y = map(int, input().split())\n\n# Calculate and print the result\nprint(find_min_hacks(p, x, y))"}
{"solution": "def min_distance(n, a, b, c):\n    if n == 1:\n        return 0\n    \n    # Initialize the current position and total distance\n    current_position = 'Rabbit'\n    total_distance = 0\n    \n    # Dictionary to represent the distances between houses\n    distances = {\n        ('Rabbit', 'Owl'): a,\n        ('Rabbit', 'Eeyore'): b,\n        ('Owl', 'Eeyore'): c,\n        ('Owl', 'Rabbit'): a,\n        ('Eeyore', 'Rabbit'): b,\n        ('Eeyore', 'Owl'): c\n    }\n    \n    # Determine the minimum distance for the first move\n    min_first_move = min(a, b)\n    total_distance += min_first_move\n    \n    # If the minimum first move is to Rabbit or Owl, update the current position accordingly\n    if min_first_move == a:\n        current_position = 'Owl'\n    else:\n        current_position = 'Eeyore'\n    \n    # Calculate the remaining moves\n    for _ in range(2, n):\n        # Find the minimum distance for the next move based on the current position\n        if current_position == 'Rabbit':\n            min_next_move = min(a, b)\n        elif current_position == 'Owl':\n            min_next_move = min(a, c)\n        else:  # current_position == 'Eeyore'\n            min_next_move = min(b, c)\n        \n        total_distance += min_next_move\n        \n        # Update the current position based on the minimum next move\n        if current_position == 'Rabbit' and min_next_move == a:\n            current_position = 'Owl'\n        elif current_position == 'Rabbit' and min_next_move == b:\n            current_position = 'Eeyore'\n        elif current_position == 'Owl' and min_next_move == a:\n            current_position = 'Rabbit'\n        elif current_position == 'Owl' and min_next_move == c:\n            current_position = 'Eeyore'\n        elif current_position == 'Eeyore' and min_next_move == b:\n            current_position = 'Rabbit'\n        else:  # current_position == 'Eeyore' and min_next_move == c\n            current_position = 'Owl'\n    \n    return total_distance\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Output the result\nprint(min_distance(n, a, b, c))"}
{"solution": "# Importing necessary functionality\nfrom typing import List\n\ndef min_total_distance(x: List[int]) -> int:\n    \"\"\"\n    Calculates the minimum total distance the friends need to travel to meet at one point.\n    \n    Parameters:\n    x (List[int]): A list containing the coordinates of the houses of the three friends.\n    \n    Returns:\n    int: The minimum total distance the friends need to travel.\n    \"\"\"\n    # Sort the coordinates to find the median\n    x.sort()\n    # The optimal meeting point is at the median coordinate\n    meeting_point = x[1]\n    # Calculate the total distance by summing the absolute differences\n    total_distance = sum(abs(meeting_point - xi) for xi in x)\n    return total_distance\n\n# Reading input\nx = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(min_total_distance(x))"}
{"solution": "def min_operations(n, x, arr):\n    # Track occurrences of each element\n    count = {}\n    for num in arr:\n        count[num] = count.get(num, 0) + 1\n    \n    # Check if there are already at least two equal elements\n    for val in count.values():\n        if val >= 2:\n            return 0\n    \n    # Check if it's possible to make two elements equal using the bitwise AND operation\n    for num in arr:\n        new_num = num & x\n        if new_num in count:\n            return 1\n    \n    # If not possible, return -1\n    return -1\n\n# Read input\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_operations(n, x, arr))"}
{"solution": "def is_plus_shape(h, w, grid):\n    # Find the center of the plus sign\n    centers = []\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*':\n                centers.append((i, j))\n    \n    if len(centers) < 5:\n        return \"NO\"\n    \n    center_x, center_y = centers[0]\n    for x, y in centers[1:]:\n        if abs(x - center_x) + abs(y - center_y) > 1:\n            return \"NO\"\n    \n    # Check horizontal and vertical arms\n    left, right, top, bottom = center_y, center_y, center_x, center_x\n    while left > 0 and grid[center_x][left - 1] == '*':\n        left -= 1\n    while right < w - 1 and grid[center_x][right + 1] == '*':\n        right += 1\n    while top > 0 and grid[top - 1][center_y] == '*':\n        top -= 1\n    while bottom < h - 1 and grid[bottom + 1][center_y] == '*':\n        bottom += 1\n    \n    # Verify the shape\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*' and not ((i == center_x and left <= j <= right) or (j == center_y and top <= i <= bottom)):\n                return \"NO\"\n    \n    return \"YES\" if (right - left) * (bottom - top) >= 16 else \"NO\"\n\n# Read input\nh, w = map(int, input().split())\ngrid = [input() for _ in range(h)]\n\n# Check and print the result\nprint(is_plus_shape(h, w, grid))"}
{"solution": "def find_adjacency_matrix(n, a, b):\n    # Check if the problem has a valid solution\n    if a + b - 1 != n:\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    \n    # Initialize the adjacency matrix\n    adj_matrix = [[0] * n for _ in range(n)]\n    \n    # Create 'a' connected components in the graph\n    start = 0\n    while a > 1:\n        for i in range(start, start + 1):\n            for j in range(i + 1, start + 1):\n                adj_matrix[i][j] = 1\n                adj_matrix[j][i] = 1\n        start += 1\n        a -= 1\n    \n    # Create 'b' connected components in the complement graph\n    while b > 1:\n        for i in range(start, start + 1):\n            for j in range(i + 1, start + 1):\n                adj_matrix[i][j] = 0\n                adj_matrix[j][i] = 0\n        start += 1\n        b -= 1\n    \n    # Print the adjacency matrix\n    for row in adj_matrix:\n        print(''.join(map(str, row)))\n\n# Example usage\nn, a, b = map(int, input().split())\nfind_adjacency_matrix(n, a, b)"}
{"solution": "def min_problems_needed(c, d, n, m, k):\n    # Calculate the number of people needed to go to the finals\n    people_needed = n * m - k\n    \n    # If no more people are needed, return 0\n    if people_needed <= 0:\n        return 0\n    \n    # Calculate the minimum number of problems using main rounds\n    main_rounds = -(-people_needed // n)  # Ceiling division\n    problems_with_main_rounds = main_rounds * c\n    \n    # Calculate the minimum number of problems using additional rounds\n    additional_rounds = people_needed\n    problems_with_additional_rounds = additional_rounds * d\n    \n    # Return the minimum of the two options\n    return min(problems_with_main_rounds, problems_with_additional_rounds)\n\n# Read input\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\n# Calculate and print the result\nprint(min_problems_needed(c, d, n, m, k))"}
{"solution": "from collections import Counter\n\ndef find_grid_path(s):\n    # Count occurrences of each character\n    char_count = Counter(s)\n    \n    # Check if each letter occurs at least once\n    if len(char_count) != 26:\n        return \"Impossible\"\n    \n    # Initialize the grid\n    grid = [['' for _ in range(13)] for _ in range(2)]\n    \n    # Mapping of letters to positions\n    position_map = {}\n    index = 0\n    \n    # Fill the grid\n    for i in range(2):\n        for j in range(13):\n            while char_count[s[index]] == 1 and (index in position_map or index + 13 in position_map):\n                index += 1\n            position_map[index] = (i, j)\n            grid[i][j] = s[index]\n            char_count[s[index]] -= 1\n            index += 1\n            \n    # Verify the path\n    for i in range(26):\n        current_pos = position_map[i]\n        next_pos = position_map[i + 1]\n        \n        if abs(current_pos[0] - next_pos[0]) + abs(current_pos[1] - next_pos[1]) > 1:\n            return \"Impossible\"\n    \n    # Construct and return the grid\n    return '\\n'.join([''.join(row) for row in grid])\n\n# Read input\ns = input()\n\n# Generate and print the output\nprint(find_grid_path(s))"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<' if y > 1 else '='\n    elif y == 1:\n        return '>' if x > 1 else '='\n    else:\n        # Compute y * log(x) and x * log(y)\n        lhs = y * math.log(x)\n        rhs = x * math.log(y)\n        \n        if lhs < rhs:\n            return '<'\n        elif lhs > rhs:\n            return '>'\n        else:\n            return '='\n\n# Read input\nx, y = map(int, input().split())\n\n# Output the result of the comparison\nprint(compare_powers(x, y))"}
{"solution": "import math\n\ndef max_balloons(r, h):\n    # Calculate the number of balloons that can fit vertically\n    vertical_balloons = h // (r / 2)\n    \n    # Calculate the total number of balloons by adding the ones that can fit horizontally\n    # One full row of balloons and possibly one extra row if height allows\n    total_balloons = 2 * (vertical_balloons + 1) if (h % (r / 2)) >= (r / 2) else 2 * vertical_balloons\n    \n    return total_balloons\n\n# Read input\nr, h = map(int, input().split())\n\n# Calculate and print the maximum number of balloons\nprint(max_balloons(r, h))"}
{"solution": "from collections import Counter\n\ndef min_remaining_sum(cards):\n    card_counts = Counter(cards)\n    possible_to_discard = [num for num, count in card_counts.items() if count >= 2]\n    \n    min_sum = sum(cards)\n    for num in possible_to_discard:\n        # Discard two cards\n        new_sum = min_sum - 2 * num\n        min_sum = min(min_sum, new_sum)\n        \n        if card_counts[num] >= 3:\n            # Discard three cards if possible\n            new_sum = min_sum - num\n            min_sum = min(min_sum, new_sum)\n    \n    return min_sum\n\n# Read input\ncards = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_remaining_sum(cards))"}
{"solution": "def min_distance(n, a, checkpoints):\n    checkpoints.sort()\n    start_index = 0\n    for i, checkpoint in enumerate(checkpoints):\n        if checkpoint < a:\n            start_index = i + 1\n        else:\n            break\n    \n    left_distance = abs(a - checkpoints[start_index - 1]) if start_index > 0 else float('inf')\n    right_distance = abs(a - checkpoints[start_index]) if start_index < n else float('inf')\n    \n    if start_index == 0:\n        return sum(abs(checkpoints[i] - checkpoints[i + 1]) for i in range(n - 1))\n    elif start_index == n:\n        return sum(abs(checkpoints[i] - checkpoints[i + 1]) for i in range(n - 1))\n    else:\n        total_distance = float('inf')\n        # Visit left first\n        distance_left_first = left_distance\n        for i in range(start_index - 1, 0, -1):\n            distance_left_first += abs(checkpoints[i] - checkpoints[i - 1])\n        distance_left_first += abs(checkpoints[0] - checkpoints[-1])\n        for i in range(start_index, n - 1):\n            distance_left_first += abs(checkpoints[i] - checkpoints[i + 1])\n        \n        # Visit right first\n        distance_right_first = right_distance\n        for i in range(start_index, n - 1):\n            distance_right_first += abs(checkpoints[i] - checkpoints[i + 1])\n        distance_right_first += abs(checkpoints[-1] - checkpoints[0])\n        for i in range(start_index - 1, 0, -1):\n            distance_right_first += abs(checkpoints[i] - checkpoints[i - 1])\n        \n        total_distance = min(distance_left_first, distance_right_first)\n        \n        return total_distance\n\n# Read input\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_distance(n, a, checkpoints))"}
{"solution": "import sys\n\ndef s(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_smallest_root(n):\n    for x in range(1, min(int(n**0.5) + 1000000, 10**10)):\n        if x**2 + s(x) * x - n == 0:\n            return x\n    return -1\n\n# Read input\nn = int(input())\n\n# Solve and print output\nprint(find_smallest_root(n))"}
{"solution": "from datetime import datetime, timedelta\n\ndef calculate_bed_time(current_time_str, sleep_duration_str):\n    # Convert strings to datetime objects\n    current_time = datetime.strptime(current_time_str, \"%H:%M\")\n    sleep_duration = datetime.strptime(sleep_duration_str, \"%H:%M\")\n    \n    # Calculate the bedtime by subtracting sleep duration from current time\n    bedtime = current_time - sleep_duration\n    \n    # Adjust for crossing midnight\n    if bedtime.hour < 0:\n        bedtime = datetime.strptime(\"24:00\", \"%H:%M\") + bedtime\n    \n    # Format and return the bedtime as a string\n    return bedtime.strftime(\"%H:%M\")\n\n# Read input\ncurrent_time_str = input()\nsleep_duration_str = input()\n\n# Calculate and print the bedtime\nprint(calculate_bed_time(current_time_str, sleep_duration_str))"}
{"solution": "from itertools import accumulate\n\ndef find_longest_subsegment_with_max_mean(n, a):\n    # Calculate prefix sums\n    prefix_sums = [0] + list(accumulate(a))\n    \n    # Initialize variables to track the maximum mean and the corresponding segment length\n    max_mean = float('-inf')\n    max_length = 0\n    \n    # Use a dictionary to keep track of the minimum prefix sum index for each current mean\n    mean_index_map = {}\n    \n    for end in range(1, n + 1):\n        for start in range(end):\n            current_mean = (prefix_sums[end] - prefix_sums[start]) / (end - start)\n            \n            # Update the maximum mean and length if the current mean is greater\n            if current_mean > max_mean:\n                max_mean = current_mean\n                max_length = end - start\n                mean_index_map[current_mean] = (start, end)\n            elif current_mean == max_mean:\n                if end - start > max_length:\n                    max_length = end - start\n                    mean_index_map[current_mean] = (start, end)\n    \n    return max_length\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find and print the length of the longest subsegment with maximum arithmetic mean\nprint(find_longest_subsegment_with_max_mean(n, a))"}
{"solution": "MOD = 998244353\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef preprocess(n):\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n        invfact[i] = modinv(fact[i])\n    return fact, invfact\n\ndef comb(n, k, fact, invfact):\n    return fact[n] * invfact[k] * invfact[n - k] % MOD\n\ndef count_ways(n, m, k):\n    fact, invfact = preprocess(n)\n    result = 0\n    for i in range(k + 1):\n        ways = comb(k, i, fact, invfact) * comb(n - 1, k - i, fact, invfact) % MOD\n        ways = ways * pow(m - 1, k - i, MOD) % MOD\n        ways = ways * m % MOD\n        result = (result + ways) % MOD\n    return result\n\n# Reading input\nn, m, k = map(int, input().split())\n\n# Calculating and printing the output\nprint(count_ways(n, m, k))"}
{"solution": "import re\n\ndef is_magic_number(n):\n    # Define the regular expression pattern for magic numbers\n    pattern = re.compile(r'^(1|14|144)*$')\n    \n    # Check if the entire number matches the pattern\n    if pattern.match(str(n)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\n\n# Print the result\nprint(is_magic_number(n))"}
{"solution": "def min_moves_to_corner(n, m, i, j, a, b):\n    # Function to calculate the minimum number of moves required to reach a corner\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    \n    # Check if it's possible to reach any corner\n    if (i == 1 and j == 1) or (i == 1 and j == m) or (i == n and j == 1) or (i == n and j == m):\n        return 0\n    \n    # Calculate the greatest common divisor of a and b\n    gcd_ab = gcd(a, b)\n    \n    # Check if it's possible to reach any of the corners\n    if (i - 1) % a != 0 or (j - m) % b != 0:\n        return \"Poor Inna and pony!\"\n    if (n - i) % a != 0 or (j - 1) % b != 0:\n        return \"Poor Inna and pony!\"\n    if (i - 1) % a != 0 or (j - 1) % b != 0:\n        return \"Poor Inna and pony!\"\n    if (n - i) % a != 0 or (m - j) % b != 0:\n        return \"Poor Inna and pony!\"\n    \n    # Calculate the minimum number of moves to reach each corner\n    moves_1_m = ((i - 1) // a + (m - j) // b) * 2\n    moves_n_1 = ((n - i) // a + (j - 1) // b) * 2\n    moves_n_m = ((n - i) // a + (m - j) // b) * 2\n    moves_1_1 = ((i - 1) // a + (j - 1) // b) * 2\n    \n    # Return the minimum number of moves\n    return min(moves_1_m, moves_n_1, moves_n_m, moves_1_1)\n\n# Read input\nn, m, i, j, a, b = map(int, input().split())\n\n# Output the result\nprint(min_moves_to_corner(n, m, i, j, a, b))"}
{"solution": "def max_removals(s):\n    # Function to check if a character can be removed\n    def can_remove(s, i):\n        if i == 0:\n            return ord(s[i]) - ord(s[i + 1]) == 1\n        elif i == len(s) - 1:\n            return ord(s[i]) - ord(s[i - 1]) == 1\n        else:\n            return ord(s[i]) - ord(s[i - 1]) == 1 or ord(s[i]) - ord(s[i + 1]) == 1\n\n    # Main loop to perform removals\n    while True:\n        max_index = -1\n        for i in range(len(s)):\n            if can_remove(s, i):\n                if max_index == -1 or ord(s[i]) > ord(s[max_index]):\n                    max_index = i\n        \n        if max_index == -1:\n            break\n        s = s[:max_index] + s[max_index + 1:]\n\n    return len(s)\n\n# Read input\nn = int(input())\ns = input()\n\n# Calculate and print the maximum number of characters that can be removed\nprint(n - max_removals(s))"}
{"solution": "from bisect import bisect_left\n\ndef can_withdraw(amount, k, denominations):\n    n = len(denominations)\n    min_bills = float('inf')\n    \n    for i in range(n):\n        for j in range(k + 1):\n            for l in range(k + 1 - j):\n                if j * denominations[i] + (amount - j * denominations[i]) / (l if l else 1) == amount:\n                    if l > 0 and (amount - j * denominations[i]) % l == 0 and (amount - j * denominations[i]) // l in denominations:\n                        min_bills = min(min_bills, j + l)\n    \n    return min_bills if min_bills != float('inf') else -1\n\ndef main():\n    n, k = map(int, input().split())\n    denominations = list(map(int, input().split()))\n    q = int(input())\n    \n    for _ in range(q):\n        amount = int(input())\n        print(can_withdraw(amount, k, denominations))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_time_to_reach(s, x1, x2, t1, t2, p, d):\n    def distance_to_meet(x1, x2, t1, t2, p, d):\n        v_tram = 1 / t1\n        v_igor = 1 / t2\n        relative_v = abs(v_tram - v_igor)\n        \n        if d == 1:\n            if p < x1:\n                meet_point = (x1 - p) / (v_tram + v_igor) + p\n            else:\n                meet_point = (p - x1) / (v_tram - v_igor) + x1\n        else:\n            if p > x1:\n                meet_point = (p - x1) / (v_tram + v_igor) + x1\n            else:\n                meet_point = (x1 - p) / (v_tram - v_igor) + p\n        \n        return meet_point\n    \n    def time_to_walk(x1, x2, t2):\n        return abs(x2 - x1) * t2\n    \n    def time_to_ride(x1, x2, t1, t2, p, d):\n        meet_point = distance_to_meet(x1, x2, t1, t2, p, d)\n        time_to_meet = abs(meet_point - x1) * t2\n        time_on_tram = abs(meet_point - x2) * t1\n        return time_to_meet + time_on_tram\n    \n    if x1 == x2:\n        return 0\n    \n    # Walking directly to the destination\n    walk_time = time_to_walk(x1, x2, t2)\n    \n    # Considering the tram's direction and position\n    if d == 1:\n        if p <= x1 and p >= 0:\n            tram_to_end = (s - p) * t1\n            tram_to_start = p * t1\n            if x2 <= p:\n                ride_time = time_to_ride(x1, x2, t1, t2, p, d)\n            else:\n                ride_time = time_to_ride(x1, s, t1, t2, s, -1) + time_to_walk(s, x2, t2)\n        else:\n            ride_time = time_to_ride(x1, x2, t1, t2, p, d)\n    else:\n        if p >= x1 and p <= s:\n            tram_to_end = (s - p) * t1\n            tram_to_start = p * t1\n            if x2 >= p:\n                ride_time = time_to_ride(x1, x2, t1, t2, p, d)\n            else:\n                ride_time = time_to_ride(x1, 0, t1, t2, 0, 1) + time_to_walk(0, x2, t2)\n        else:\n            ride_time = time_to_ride(x1, x2, t1, t2, p, d)\n    \n    return min(walk_time, ride_time)\n\n# Reading input\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_time_to_reach(s, x1, x2, t1, t2, p, d))"}
{"solution": "def count_occurrences(n, x):\n    count = 0\n    for i in range(1, n + 1):\n        if x % i == 0 and x // i <= n:\n            count += 1\n    return count\n\nn, x = map(int, input().split())\nprint(count_occurrences(n, x))"}
{"solution": "def generate_password(n, k):\n    # Initialize variables\n    password = []\n    alphabet = [chr(97 + i) for i in range(k)]  # Generate the first k lowercase letters\n    i = 0\n    \n    # Generate the password\n    for pos in range(n):\n        password.append(alphabet[i % k])\n        i += 1 if pos == 0 or password[pos - 1] != alphabet[(i + 1) % k] else 2\n    \n    # Print the generated password\n    print(''.join(password))\n\n# Read input\nn, k = map(int, input().split())\n\n# Generate and print the password\ngenerate_password(n, k)"}
{"solution": "def first_collision_time(n, directions, positions):\n    min_time = float('inf')\n    collision_found = False\n    \n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            collision_time = (positions[i + 1] - positions[i]) // 2\n            min_time = min(min_time, collision_time)\n            collision_found = True\n    \n    if collision_found:\n        return min_time\n    else:\n        return -1\n\n# Input handling\nn = int(input())\ndirections = input()\npositions = list(map(int, input().split()))\n\n# Function call and output\nresult = first_collision_time(n, directions, positions)\nprint(result)"}
{"solution": "def max_seal_area(n, a, b, seals):\n    # Sort each seal by its area in descending order, considering both orientations\n    seals = sorted([(max(x, y), min(x, y)) for x, y in seals], key=lambda s: s[0] * s[1], reverse=True)\n    \n    # Initialize the maximum area to 0\n    max_area = 0\n    \n    # Iterate through each pair of seals\n    for i in range(min(n, 2)):  # Only need to check the top 2 seals by area\n        for j in range(i + 1, n):\n            seal1_large, seal1_small = seals[i]\n            seal2_large, seal2_small = seals[j]\n            \n            # Check all possible orientations\n            if (seal1_large + seal2_large <= a and max(seal1_small, seal2_small) <= b) or \\\n               (seal1_large + seal2_large <= b and max(seal1_small, seal2_small) <= a) or \\\n               (seal1_large + seal2_small <= a and max(seal1_small, seal2_large) <= b) or \\\n               (seal1_large + seal2_small <= b and max(seal1_small, seal2_large) <= a) or \\\n               (seal1_small + seal2_large <= a and max(seal1_large, seal2_small) <= b) or \\\n               (seal1_small + seal2_large <= b and max(seal1_large, seal2_small) <= a) or \\\n               (seal1_small + seal2_small <= a and max(seal1_large, seal2_large) <= b) or \\\n               (seal1_small + seal2_small <= b and max(seal1_large, seal2_large) <= a):\n                # Calculate the total area occupied by the two seals\n                area = (seal1_large * seal1_small) + (seal2_large * seal2_small)\n                max_area = max(max_area, area)\n                \n    return max_area\n\n# Read input\nn, a, b = map(int, input().split())\nseals = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_seal_area(n, a, b, seals))"}
{"solution": "def find_outlier_point():\n    n = int(input())\n    points = []\n    for _ in range(4 * n + 1):\n        x, y = map(int, input().split())\n        points.append((x, y))\n    \n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n    \n    x_counts = {x: x_coords.count(x) for x in set(x_coords)}\n    y_counts = {y: y_coords.count(y) for y in set(y_coords)}\n    \n    outlier_x = min(x_counts, key=x_counts.get)\n    outlier_y = min(y_counts, key=y_counts.get)\n    \n    for x, y in points:\n        if x_counts[x] == 1 and y_counts[y] == 1:\n            print(x, y)\n            return\n\nfind_outlier_point()"}
{"solution": "def max_product_of_digits(n):\n    if n < 10:\n        return n\n    length = len(str(n))\n    if length <= 2 or n < 25:\n        return int(max(str(n)))\n    if length <= 3 or n < 1000:\n        return 9 * max_product_of_digits((n - 1) // 9)\n    if length <= 4 or n < 10000:\n        return 9 * max_product_of_digits((n - 1) // 9)\n    if n >= 1099999999:\n        return 387420489\n    nine_count = n // (10 ** (length - 1))\n    remaining = n % (10 ** (length - 1))\n    product = 9 ** nine_count * max_product_of_digits(remaining)\n    return max(product, max_product_of_digits(10 ** (length - 1) + remaining - 1))\n\n# Read input\nn = int(input())\n\n# Compute and print the result\nprint(max_product_of_digits(n))"}
{"solution": "def find_smallest_k(n, votes_for_elodreip):\n    max_a = max(votes_for_elodreip)\n    awruk_votes = 0\n    elodreip_votes = sum(votes_for_elodreip)\n    \n    k = max_a\n    \n    while True:\n        awruk_votes = sum(k - a for a in votes_for_elodreip)\n        if awruk_votes > elodreip_votes:\n            return k\n        k += 1\n\n# Read input\nn = int(input())\nvotes_for_elodreip = list(map(int, input().split()))\n\n# Calculate and print the smallest k\nprint(find_smallest_k(n, votes_for_elodreip))"}
{"solution": "def count_operations(points):\n    operations = 0\n    while True:\n        to_delete = set()\n        prev_color = None\n        prev_index = -1\n        \n        # Identify points to delete\n        for index, color in enumerate(points):\n            if prev_color is not None and prev_color != color:\n                # Both neighbors are different\n                to_delete.update(range(prev_index, index + 1))\n            prev_color = color\n            prev_index = index\n        \n        # Check if any points were marked for deletion\n        if not to_delete:\n            break\n        \n        # Perform the deletion\n        new_points = [point for index, point in enumerate(points) if index not in to_delete]\n        points = ''.join(new_points)\n        \n        operations += 1\n    \n    return operations\n\n# Read input\npoints = input()\n\n# Calculate and print the number of operations\nprint(count_operations(points))"}
{"solution": "def count_min_triples(n, arr):\n    min_val = min(arr)\n    indices = [i for i, x in enumerate(arr) if x == min_val]\n    \n    count = 0\n    for i in range(len(indices)):\n        for j in range(i + 1, len(indices)):\n            for k in range(j + 1, len(indices)):\n                count += 1\n                \n    return count\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(count_min_triples(n, arr))"}
{"solution": "def min_cuts_for_pizza(n):\n    if n == 0:\n        return 0\n    elif n <= 3:\n        return n\n    else:\n        return n - 1\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the output\nprint(min_cuts_for_pizza(n))"}
{"solution": "def maximize_bank_account(n):\n    # Convert the number to a string to easily manipulate digits\n    str_n = str(n)\n    \n    # Check if the number is negative\n    is_negative = n < 0\n    \n    # If the number is negative, start by removing '-' sign for simplicity\n    if is_negative:\n        str_n = str_n[1:]\n    \n    # Initialize variables to store the results of removing the last and the second last digit\n    remove_last = int(str_n[:-1])\n    remove_second_last = int(str_n[:-2] + str_n[-1])\n    \n    # Adjust results if the original number was negative\n    if is_negative:\n        remove_last = -remove_last\n        remove_second_last = -remove_second_last\n    \n    # Determine the maximum result\n    max_result = max(remove_last, remove_second_last)\n    \n    # Return the maximum result\n    return max_result\n\n# Read the input\nn = int(input())\n\n# Calculate and print the output\nprint(maximize_bank_account(n))"}
{"solution": "def spinner_direction(start, end, n):\n    positions = {'v': 0, '<': 1, '^': 2, '>': 3}\n    start_pos = positions[start]\n    end_pos = positions[end]\n    \n    # Calculate the difference in positions\n    diff = (end_pos - start_pos) % 4\n    \n    # Determine the direction based on the difference and duration\n    if diff == 1 or diff == 3:\n        if n % 4 == diff:\n            return 'cw' if diff == 1 else 'ccw'\n        else:\n            return 'undefined'\n    elif diff == 3 or diff == 1:\n        if n % 4 == 4 - diff:\n            return 'ccw' if diff == 3 else 'cw'\n        else:\n            return 'undefined'\n    else:\n        if n % 4 == 0:\n            return 'undefined'\n        else:\n            return 'cw' if diff == 0 else 'ccw'\n\n# Read input\nstart, end = input().split()\nn = int(input())\n\n# Output the direction\nprint(spinner_direction(start, end, n))"}
{"solution": "def count_standing_dominos(n, s):\n    standing_count = 0\n    left_push = False\n    right_push = False\n    \n    for char in s:\n        if char == 'L':\n            if right_push:\n                standing_count += 1\n            right_push = False\n            left_push = True\n        elif char == 'R':\n            if not left_push:\n                right_push = True\n            else:\n                standing_count += 1\n                left_push = False\n        else:\n            if not left_push and not right_push:\n                standing_count += 1\n    \n    return standing_count\n\n# Read input\nn = int(input())\ns = input()\n\n# Calculate and print the result\nprint(count_standing_dominos(n, s))"}
{"solution": "def find_permutation(n, m, leaders):\n    permutation = [-1] * n\n    used = [False] * n\n    \n    for i in range(m):\n        if permutation[leaders[i] - 1] == -1:\n            permutation[leaders[i] - 1] = i + 1\n            used[i] = True\n    \n    for i in range(n):\n        if permutation[i] == -1:\n            for j in range(m):\n                if not used[j]:\n                    permutation[i] = j + 1\n                    used[j] = True\n                    break\n    \n    # Verify the solution\n    current_leader = leaders[0]\n    for i in range(m):\n        next_leader = (current_leader + permutation[current_leader - 1] - 1) % n + 1\n        if next_leader != leaders[i + 1]:\n            return -1\n        current_leader = next_leader\n    \n    return permutation\n\n# Reading input\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\n# Finding and printing the permutation\nresult = find_permutation(n, m, leaders)\nprint(*result)"}
{"solution": "def max_number_after_swaps(a, k):\n    s = list(str(a))\n    n = len(s)\n    \n    def find_max_index(start, remaining_swaps):\n        max_index = start\n        search_end = min(n, start + remaining_swaps + 1)\n        for i in range(start + 1, search_end):\n            if s[i] > s[max_index]:\n                max_index = i\n        return max_index\n\n    def swap(i, j):\n        s[i], s[j] = s[j], s[i]\n\n    for i in range(n):\n        if k <= 0:\n            break\n        max_idx = find_max_index(i, k)\n        while max_idx > i:\n            swap(max_idx, max_idx - 1)\n            max_idx -= 1\n            k -= 1\n            if k <= 0:\n                break\n\n    return int(\"\".join(s))\n\n# Read input\na, k = map(int, input().split())\n\n# Solve and print the result\nprint(max_number_after_swaps(a, k))"}
{"solution": "def find_next_in_sequence(a, b, c, d):\n    # Check for arithmetic progression\n    if (b - a) == (c - b) == (d - c):\n        return d + (b - a)\n    \n    # Check for geometric progression\n    if a != 0 and b != 0 and c != 0 and d != 0:\n        if (b / a) == (c / b) == (d / c):\n            next_element = d * (b / a)\n            if next_element.is_integer():\n                return int(next_element)\n    \n    # Default case\n    return 42\n\n# Read input\na, b, c, d = map(int, input().split())\n\n# Print output\nprint(find_next_in_sequence(a, b, c, d))"}
{"solution": "def max_distance(n, colors):\n    # Find the first and last occurrence of each color\n    first_occurrence = [float('inf')] * (n + 1)\n    last_occurrence = [float('-inf')] * (n + 1)\n    \n    for i in range(n):\n        color = colors[i]\n        first_occurrence[color] = min(first_occurrence[color], i)\n        last_occurrence[color] = max(last_occurrence[color], i)\n    \n    # Calculate the maximum distance\n    max_dist = 0\n    \n    # Compare distances from the first house to the last house of a different color\n    for color in range(1, n + 1):\n        if colors[0] != color:\n            max_dist = max(max_dist, last_occurrence[color])\n        if colors[-1] != color:\n            max_dist = max(max_dist, n - 1 - first_occurrence[color])\n    \n    return max_dist\n\n# Read input\nn = int(input())\ncolors = list(map(int, input().split()))\n\n# Print the result\nprint(max_distance(n, colors))"}
{"solution": "def find_santa_place(n, m, k):\n    # Determine the lane, desk, and side for Santa Claus' place\n    places_per_lane = m * 2\n    lane = (k - 1) // places_per_lane + 1\n    remaining_places = (k - 1) % places_per_lane + 1\n    desk = remaining_places // 2 if remaining_places % 2 == 0 else remaining_places // 2 + 1\n    side = \"L\" if remaining_places % 2 == 0 else \"R\"\n    \n    return f\"{lane} {desk} {side}\"\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Print the result\nprint(find_santa_place(n, m, k))"}
{"solution": "def possible_final_card_colors(n, s):\n    # Count the occurrences of each color\n    counts = {'B': 0, 'G': 0, 'R': 0}\n    for card in s:\n        counts[card] += 1\n    \n    # Determine the parities of the counts\n    parity = [counts['B'] % 2, counts['G'] % 2, counts['R'] % 2]\n    \n    # Determine the possible final colors based on parities\n    possible_colors = []\n    if parity.count(1) == 0 or parity.count(1) == 3:\n        possible_colors = ['B', 'G', 'R']\n    elif parity.count(1) == 1:\n        index = parity.index(1)\n        possible_colors = ['B', 'G', 'R'][index:index+1]\n    else:  # parity.count(1) == 2\n        index = parity.index(0)\n        possible_colors = ['B', 'G', 'R'][:index] + ['B', 'G', 'R'][index+1:]\n    \n    # Sort and return the possible colors\n    return ''.join(sorted(possible_colors))\n\n# Read input\nn = int(input())\ns = input()\n\n# Print the result\nprint(possible_final_card_colors(n, s))"}
