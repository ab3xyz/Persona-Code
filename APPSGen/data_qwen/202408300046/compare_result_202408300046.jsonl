{"solution": "def max_accordion_length(s):\n    open_brackets = []\n    colon_positions = []\n\n    for i, c in enumerate(s):\n        if c == '[':\n            open_brackets.append(i)\n        elif c == ':':\n            colon_positions.append(i)\n\n    max_length = -1\n    for i in range(len(colon_positions)):\n        for j in range(i + 1, len(colon_positions)):\n            if colon_positions[i] < colon_positions[j]:\n                open_bracket = next((x for x in open_brackets if x > colon_positions[i]), None)\n                close_bracket = next((x for x in reversed(open_brackets) if x < colon_positions[j]), None)\n                if open_bracket is not None and close_bracket is not None and open_bracket < close_bracket:\n                    vertical_lines = sum(1 for k in range(colon_positions[i] + 1, colon_positions[j]) if s[k] == '|')\n                    current_length = 2 + 2 + vertical_lines\n                    max_length = max(max_length, current_length)\n\n    return max_length\n\n# Input\ns = input().strip()\n# Output\nprint(max_accordion_length(s))"}
{"solution": "def max_digit_sum_number(x):\n    x_str = str(x)\n    length = len(x_str)\n    \n    # Try to maximize the sum by making all digits 9\n    max_sum = 9 * (length - 1)\n    \n    # Calculate the remaining value to distribute\n    remaining = int(x_str[0]) - 1\n    \n    # Check if we can increase the sum with the remaining value\n    if remaining > 0:\n        max_sum += remaining\n    \n    # Special case handling for numbers like 19, 29, etc.\n    if int(x_str) < 10 * (length - 1) + 10 - 1:\n        max_sum += 9\n    \n    # Construct the number with the maximum digit sum\n    result = ''\n    if int(x_str[0]) - 1 > 0:\n        result += str(int(x_str[0]) - 1)\n        result += '9' * (length - 1)\n    else:\n        result = str(int(x_str[0]))\n        result += '9' * (length - 1)\n    \n    # Ensure the constructed number does not exceed x\n    if int(result) > x:\n        result = x_str[:-1] + str(9)\n    \n    return int(result)\n\n# Read input\nx = int(input())\n\n# Print the result\nprint(max_digit_sum_number(x))"}
{"solution": "def next_lucky_year(year):\n    \"\"\"\n    Finds the next lucky year after the given year.\n    \n    A lucky year has no more than one non-zero digit in its number.\n    \"\"\"\n    year_str = str(year)\n    next_year_str = '1' + '0' * (len(year_str) - 1)\n    if len(year_str) == 1 or year_str[0] != '1':\n        # If it's a single digit or the first digit is not 1, just bump up to the next power of 10 minus 1\n        next_year_str = '1' + '0' * len(year_str)\n    next_year = int(next_year_str)\n    return next_year - year\n\n# Reading input\nn = int(input().strip())\n\n# Calculating and printing the result\nprint(next_lucky_year(n))"}
{"solution": "from itertools import accumulate\n\ndef max_painted_sections(n, q, painters):\n    events = []\n    for l, r in painters:\n        events.append((l, 1))\n        events.append((r + 1, -1))\n    events.sort()\n\n    coverage = [0] * (n + 1)\n    active_painters = 0\n    for i, (position, delta) in enumerate(events):\n        if i > 0:\n            for _ in range(events[i - 1][0], position):\n                coverage[_] = active_painters\n        active_painters += delta\n\n    prefix_sum = list(accumulate(coverage))\n    suffix_sum = list(accumulate(reversed(coverage)))[::-1]\n\n    max_painted = 0\n    for i in range(1, n - 1):\n        max_left = prefix_sum[i - 1]\n        max_right = suffix_sum[i + 1]\n        max_painted = max(max_painted, max_left + max_right)\n\n    return max_painted\n\n# Reading input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Solving and printing output\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def has_seven(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef solve(x, hh, mm):\n    for i in range(1440):\n        y = i * x\n        new_hh = (hh - y // 60) % 24\n        new_mm = (mm - y % 60) % 60\n        if has_seven(new_hh, new_mm):\n            return i\n\nx = int(input())\nhh, mm = map(int, input().split())\nprint(solve(x, hh, mm))"}
{"solution": "def min_seconds(n, pos, l, r):\n    \"\"\"\n    Calculate the minimum number of seconds to close all tabs except those from l to r.\n    \"\"\"\n    # If pos is within the range [l, r], no need to move within the range\n    if l <= pos <= r:\n        # Calculate the minimum moves to close tabs on both sides\n        left_closing = pos - l\n        right_closing = r - pos\n        return min(pos - l, r - pos) + (n - r) + (l - 1)\n    \n    # If pos is outside the range [l, r]\n    # Calculate the optimal move\n    optimal_move = min(abs(pos - l), abs(pos - r))\n    # Calculate the closing operations\n    closing_operations = (n - r) + (l - 1)\n    return optimal_move + closing_operations\n\n# Reading input\nn, pos, l, r = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_seconds(n, pos, l, r))"}
{"solution": "import heapq\nfrom collections import defaultdict\n\ndef min_blows_to_defeat(zmei_heads, blows):\n    # Sort blows by net reduction in heads (d-h)\n    blows.sort(key=lambda x: x[0] - x[1], reverse=True)\n\n    net_reductions = [(x[0] - x[1], x[0], x[1]) for x in blows]\n    max_net_reduction = max(0, net_reductions[0][0])\n\n    if max_net_reduction <= 0:\n        return -1\n\n    # Use a priority queue to efficiently find the best blow\n    pq = [(net[0], net[1], net[2]) for net in net_reductions]\n    heapq.heapify(pq)\n\n    steps = 0\n    while zmei_heads > 0:\n        _, damage, regrowth = heapq.heappop(pq)\n        if damage >= zmei_heads:\n            steps += 1\n            break\n        else:\n            zmei_heads -= damage\n            zmei_heads += regrowth\n            steps += 1\n\n    return steps\n\ndef process_queries():\n    t = int(input())\n    for _ in range(t):\n        n, x = map(int, input().split())\n        blows = [list(map(int, input().split())) for _ in range(n)]\n        print(min_blows_to_defeat(x, blows))\n\nprocess_queries()"}
{"solution": "import math\ndef empty_barn(n, m):\n    if m >= n:\n        return 1\n    else:\n        k = (n - m) // (m + 1)\n        day = math.ceil((-1 + math.sqrt(1 + 4 * (k + 1) * (2 * n - m))) / 2)\n        return day\n\nn, m = map(int, input().split())\nprint(empty_barn(n, m))"}
{"solution": "from collections import Counter\n\ndef can_form_sequence(counter):\n    for num in range(1, 8):\n        if counter[str(num) + 'm'] and counter[str(num + 1) + 'm'] and counter[str(num + 2) + 'm']:\n            return True\n        if counter[str(num) + 'p'] and counter[str(num + 1) + 'p'] and counter[str(num + 2) + 'p']:\n            return True\n        if counter[str(num) + 's'] and counter[str(num + 1) + 's'] and counter[str(num + 2) + 's']:\n            return True\n    return False\n\ntiles = input().split()\ncounter = Counter(tiles)\n\n# Check for existing triplet\nif any([counter[tile] >= 3 for tile in counter]):\n    print(0)\n    exit()\n\n# Check for existing sequence\nif can_form_sequence(counter):\n    print(0)\n    exit()\n\n# Check if adding one tile can form a triplet\nif any([counter[tile] == 2 for tile in counter]):\n    print(1)\n    exit()\n\n# Check if adding one tile can form a sequence\nfor tile in counter:\n    num, suit = int(tile[0]), tile[1]\n    if num <= 7 and counter[str(num + 1) + suit] and counter[str(num + 2) + suit]:\n        print(1)\n        exit()\n    if num >= 2 and num <= 8 and counter[str(num - 1) + suit] and counter[str(num + 1) + suit]:\n        print(1)\n        exit()\n    if num >= 2 and counter[str(num - 1) + suit] and counter[str(num - 2) + suit]:\n        print(1)\n        exit()\n\nprint(2)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.readline\n\ndef get_sofa_position(sofa):\n    x1, y1, x2, y2 = sofa\n    if x1 == x2:\n        return (x1, min(y1, y2))\n    else:\n        return (min(x1, x2), y1)\n\ndef main():\n    d = int(input())\n    n, m = map(int, input().split())\n    sofas = [tuple(map(int, input().split())) for _ in range(d)]\n    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\n    sofa_positions = [get_sofa_position(sofa) for sofa in sofas]\n    sofa_dict = {pos: idx + 1 for idx, pos in enumerate(sofa_positions)}\n\n    def count_left(idx):\n        x, y = sofa_positions[idx]\n        return sum(1 for other in sofa_positions if other[0] == x and other[1] < y)\n\n    def count_top(idx):\n        x, y = sofa_positions[idx]\n        return sum(1 for other in sofa_positions if other[1] == y and other[0] < x)\n\n    for i in range(d):\n        left = count_left(i)\n        top = count_top(i)\n        right = d - 1 - left - (cnt_l + cnt_r) + cnt_l\n        bottom = d - 1 - top - (cnt_t + cnt_b) + cnt_t\n        if left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b:\n            print(sofa_dict[sofa_positions[i]])\n            return\n\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def mars_days_off(n):\n    min_days_off = (n // 7) * 2\n    max_days_off = ((n + 6) // 7) * 2\n    print(min_days_off, max_days_off)\n\n# Example usage:\n# mars_days_off(14)\n# mars_days_off(2)"}
{"solution": "def max_chocolates(n, a, b, p, q):\n    lcm = (a * b) // gcd(a, b)\n    full_cycles = n // lcm\n    red_in_cycle = min(a, lcm) * p\n    blue_in_cycle = min(b, lcm) * q\n    cycle_diff = blue_in_cycle - red_in_cycle\n\n    extra_a = max(0, n % lcm - a) * p\n    extra_b = n % lcm * q\n\n    max_extra = max(extra_a, extra_b)\n\n    return (full_cycles * (red_in_cycle if red_in_cycle > blue_in_cycle else blue_in_cycle) + max_extra)\n\nfrom math import gcd\n\n# Reading inputs\nn, a, b, p, q = map(int, input().split())\n\nprint(max_chocolates(n, a, b, p, q))"}
{"solution": "def max_golden_segment(trophies):\n    n = len(trophies)\n    prefix_sum = [0] * (n + 2)\n    max_len = 0\n    g_count = 0\n    s_positions = []\n\n    for i, t in enumerate(trophies):\n        if t == 'G':\n            g_count += 1\n        else:\n            s_positions.append(i)\n        prefix_sum[i + 1] = g_count\n\n    for s_pos in s_positions:\n        left_g = prefix_sum[s_pos]\n        right_g = prefix_sum[-1] - prefix_sum[s_pos + 1]\n        current_len = left_g + right_g\n        max_len = max(max_len, current_len)\n\n    if not s_positions:  # All trophies are golden\n        return n\n    if len(s_positions) == 1 and g_count == n - 1:\n        return n - 1\n\n    return max(max_len, g_count)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    trophies = input().strip()\n    print(max_golden_segment(trophies))"}
{"solution": "from collections import defaultdict, deque\n\ndef topological_sort(n, dependencies, main_courses):\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    for course, deps in enumerate(dependencies):\n        for dep in deps:\n            graph[dep].append(course + 1)\n            in_degree[course + 1] += 1\n\n    queue = deque([i for i in range(1, n + 1) if in_degree[i] == 0])\n    visited = []\n    while queue:\n        course = queue.popleft()\n        visited.append(course)\n        for next_course in graph[course]:\n            in_degree[next_course] -= 1\n            if in_degree[next_course] == 0:\n                queue.append(next_course)\n\n    required_courses = set(main_courses)\n    for course in visited[:]:\n        if course in required_courses:\n            required_courses.remove(course)\n            for next_course in graph[course]:\n                if next_course in required_courses:\n                    required_courses.remove(next_course)\n                    visited.remove(course)\n                    break\n\n    if required_courses:\n        return [-1]\n\n    return [len(visited), ' '.join(map(str, visited))]\n\n# Reading input\nn, k = map(int, input().split())\nmain_courses = list(map(int, input().split()))\ndependencies = []\nfor _ in range(n):\n    t, *deps = map(int, input().split())\n    dependencies.append(deps)\n\n# Computing and printing the result\nresult = topological_sort(n, dependencies, main_courses)\nprint('\\n'.join(map(str, result)))"}
{"solution": "def solve(n, k, p):\n    s = []\n    used = set(p)\n    max_used = max(p)\n    next_available = max_used + 1\n    for i in range(k - 1, -1, -1):\n        while s and s[-1] < p[i]:\n            if s.pop() < next_available:\n                return -1\n        if p[i] < next_available:\n            s.append(p[i])\n    s.reverse()\n    result = list(p)\n    for i in range(k, n):\n        while s and s[0] < next_available:\n            result[i] = s.pop(0)\n            i += 1\n        if i < n:\n            result[i] = next_available\n            next_available += 1\n            while next_available <= n and next_available in used:\n                next_available += 1\n    return result\n\nn, k = map(int, input().split())\np = list(map(int, input().split()))\nprint(*solve(n, k, p))"}
{"solution": "a, b, c = map(int, input().split())\n\nif c == 0:\n    print(\"YES\") if a == b else print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "from sys import stdin\n\n# Reading the counts from stdin\ncnt_1 = int(stdin.readline())\ncnt_2 = int(stdin.readline())\ncnt_3 = int(stdin.readline())\ncnt_4 = int(stdin.readline())\n\n# Checking the conditions for forming a regular bracket sequence\nif cnt_1 == cnt_3 and cnt_2 >= abs(cnt_4 - cnt_1) and cnt_2 + min(cnt_4, cnt_1) >= abs(cnt_4 - cnt_1):\n    print(1)\nelse:\n    print(0)"}
{"solution": "def standing_spectators(n, k, t):\n    if t <= k:\n        return t\n    else:\n        cycle_length = n + k\n        full_cycles = t // cycle_length\n        remainder = t % cycle_length\n        if remainder <= k:\n            return remainder\n        else:\n            return k - (remainder - k)\n\n# Reading input\nn, k, t = map(int, input().split())\n\n# Calculating and printing the result\nprint(standing_spectators(n, k, t))"}
{"solution": "def min_lexico_string(s):\n    \"\"\"\n    Given a string s, perform operations to achieve an empty string s and derive a lexicographically minimal string u.\n    \"\"\"\n    stack = []\n    for char in s:\n        while stack and stack[-1] > char:\n            stack.pop()\n        stack.append(char)\n    u = ''.join(stack)\n    return u\n\n# Reading input string from stdin\ns = input().strip()\n\n# Function call and printing output string u\nprint(min_lexico_string(s))"}
{"solution": "def check_level_stats(test_cases):\n    for _ in range(test_cases):\n        moments = int(input())\n        previous_plays, previous_clears = 0, 0\n        valid = True\n        for _ in range(moments):\n            current_plays, current_clears = map(int, input().split())\n            if current_plays < previous_plays or current_clears < previous_clears:\n                valid = False\n                break\n            if current_clears > current_plays or (current_plays - previous_plays) < (current_clears - previous_clears):\n                valid = False\n                break\n            previous_plays, previous_clears = current_plays, current_clears\n        print(\"YES\" if valid else \"NO\")\n\n# The following line is necessary to call the function with the number of test cases.\n# Replace `number_of_test_cases` with the actual input.\nnumber_of_test_cases = int(input())\ncheck_level_stats(number_of_test_cases)"}
{"solution": "from datetime import datetime, timedelta\n\ndef is_palindrome_time(time_str):\n    return time_str == time_str[::-1]\n\ndef minutes_until_palindrome(current_time_str):\n    current_time = datetime.strptime(current_time_str, \"%H:%M\")\n    next_palindrome_time = current_time\n    increment = timedelta(minutes=1)\n\n    while not is_palindrome_time(next_palindrome_time.strftime(\"%H%M\")):\n        next_palindrome_time += increment\n\n    return (next_palindrome_time - current_time).seconds // 60\n\n# Example usage (assuming this part is not required as per instruction)\n# current_time = \"05:39\"\n# print(minutes_until_palindrome(current_time))"}
{"solution": "def max_distance_after_swap(n, arr):\n    min_pos = arr.index(1)\n    max_pos = arr.index(n)\n    \n    # Calculate current distance\n    current_dist = abs(max_pos - min_pos)\n    \n    # Calculate potential distances after swap\n    dist_with_min_at_start = max_pos + (n - 1 - min_pos)\n    dist_with_max_at_end = max(min_pos, n - 1 - max_pos)\n    \n    # Return the maximum distance achievable with one swap\n    return max(current_dist, dist_with_min_at_start, dist_with_max_at_end)\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Printing output\nprint(max_distance_after_swap(n, arr))"}
{"solution": "def check_s_palindrome(s):\n    pairs = {\n        'a': 'a', 'b': 'd', 'd': 'b', 'e': 'm', 'm': 'e',\n        'h': 'h', 'i': 'i', 'n': 'u', 'o': 'o', 'u': 'n',\n        'v': 'v', 'w': 'w', 'x': 'x', 'y': 'y'\n    }\n    \n    length = len(s)\n    mid = length // 2\n    \n    for i in range(mid):\n        if s[i] != s[length - 1 - i]:\n            if (s[i] not in pairs) or (s[length - 1 - i] != pairs[s[i]]):\n                return \"NIE\"\n    \n    return \"TAK\"\n\n# Read input from stdin\ns = input().strip()\n\n# Print output to stdout\nprint(check_s_palindrome(s))"}
{"solution": "def max_permutation(a, b):\n    a_str, b_str = str(a), str(b)\n    a_len, b_len = len(a_str), len(b_str)\n\n    if a_len < b_len or (a_len == b_len and a_str <= b_str):\n        return a_str\n    else:\n        result = []\n        a_counts = [0] * 10\n        for digit in a_str:\n            a_counts[int(digit)] += 1\n\n        for i in range(b_len):\n            found = False\n            for d in range(9, -1, -1):\n                if b_str[i] >= str(d) and a_counts[d] > 0:\n                    result.append(str(d))\n                    a_counts[d] -= 1\n                    found = True\n                    break\n            if not found:\n                for d in range(9, -1, -1):\n                    if a_counts[d] > 0:\n                        result.append(str(d))\n                        a_counts[d] -= 1\n                        break\n\n        return ''.join(result).ljust(a_len, '0').lstrip('0') or '0'\n\n# Input\na = int(input())\nb = int(input())\n\n# Solution\nprint(max_permutation(a, b))"}
{"solution": "def check_win(matrix):\n    size = 10\n    directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n\n    for i in range(size):\n        for j in range(size):\n            if matrix[i][j] == '.':\n                matrix[i][j] = 'X'\n                for dx, dy in directions:\n                    x, y = i, j\n                    count = 0\n                    while 0 <= x < size and 0 <= y < size and matrix[x][y] == 'X':\n                        count += 1\n                        x += dx\n                        y += dy\n                    if count >= 5:\n                        return \"YES\"\n                matrix[i][j] = '.'\n    return \"NO\"\n\nmatrix = [input() for _ in range(10)]\nprint(check_win(matrix))"}
{"solution": "def print_matrix(matrix):\n    for row in matrix:\n        print(' '.join(map(str, row)))\n\ndef generate_symmetric_matrix(n, k):\n    matrix = [[0] * n for _ in range(n)]\n    ones_placed = 0\n    \n    # Fill the upper triangle and diagonal\n    for i in range(n):\n        for j in range(i, n):\n            if ones_placed < k:\n                matrix[i][j] = 1\n                ones_placed += 1\n                if ones_placed == k:\n                    break\n    \n    # Check if we've placed too many ones\n    if ones_placed != k:\n        return -1\n    \n    # Reflect the upper triangle below the diagonal\n    for i in range(n):\n        for j in range(i + 1, n):\n            matrix[j][i] = matrix[i][j]\n    \n    return matrix\n\n# Reading input\nn, k = map(int, input().split())\n\n# Generating and printing the result\nresult = generate_symmetric_matrix(n, k)\nif result == -1:\n    print(-1)\nelse:\n    print_matrix(result)"}
{"solution": "def calculate(x, y, z):\n    return [\n        (x ** (y ** z), 'x^y^z'),\n        (x ** (z ** y), 'x^z^y'),\n        ((x ** y) ** z, '(x^y)^z'),\n        ((x ** z) ** y, '(x^z)^y'),\n        (y ** (x ** z), 'y^x^z'),\n        (y ** (z ** x), 'y^z^x'),\n        ((y ** x) ** z, '(y^x)^z'),\n        ((y ** z) ** x, '(y^z)^x'),\n        (z ** (x ** y), 'z^x^y'),\n        (z ** (y ** x), 'z^y^x'),\n        ((z ** x) ** y, '(z^x)^y'),\n        ((z ** y) ** x, '(z^y)^x')\n    ]\n\nx, y, z = map(float, input().split())\nresults = calculate(x, y, z)\nmax_result, expression = max(results, key=lambda item: item[0])\nprint(expression)"}
{"solution": "def min_operations(n, s):\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = i\n        for j in range(1, i // 2 + 1):\n            if s[:j] * (i // j) == s[:i] or s[:j] * (i // j + 1) == s[:i]:\n                dp[i] = min(dp[i], dp[j] + i % j)\n    return dp[n]\n\nn = int(input())\ns = input()\nprint(min_operations(n, s))"}
{"solution": "def sort_tests():\n    from collections import defaultdict\n\n    n = int(input())\n    files = [input().split() for _ in range(n)]\n    example_count = sum(1 for _, t in files if t == '1')\n\n    name_to_index = {name: i for i, (name, _) in enumerate(files)}\n    files.sort(key=lambda x: (x[1], x[0]))\n\n    moves = []\n    current_names = [''] * n\n    for i, (name, test_type) in enumerate(files):\n        target_index = i - example_count if test_type == '0' else i\n        if name != str(target_index + 1):\n            moves.append(f\"move {name} {target_index + 1}\")\n            current_names[target_index] = str(target_index + 1)\n\n    # Resolve conflicts\n    new_names = [''] * n\n    for i, name in enumerate(current_names):\n        if not name.isdigit():\n            new_name = str(i + 1)\n            while new_name in current_names:\n                new_name = chr(ord('a') + len(new_name)) + new_name\n            moves.append(f\"move {name} {new_name}\")\n            new_names[i] = new_name\n        else:\n            new_names[i] = name\n\n    print(len(moves))\n    for move in moves:\n        print(move)\n\nsort_tests()"}
{"solution": "def min_replacements(ticket):\n    left_sum = sum(int(digit) for digit in ticket[:3])\n    right_sum = sum(int(digit) for digit in ticket[3:])\n    diff = abs(left_sum - right_sum)\n\n    # Calculate the minimum replacements needed\n    min_replacements = diff // 9 + (diff % 9 > 0)\n    return min_replacements\n\n# Read input\nticket = input()\n\n# Output the result\nprint(min_replacements(ticket))"}
{"solution": "from math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef min_traps(m, x):\n    return m // gcd(m, x)\n\nm, x = map(int, input().split())\nprint(min_traps(m, x))"}
{"solution": "MOD = 1000003\n\ndef mod_pow(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        exponent = exponent >> 1\n        base = (base * base) % MOD\n    return result\n\ndef mod_inv(a):\n    return mod_pow(a, MOD - 2)\n\ndef solve(n, k):\n    total_days = mod_pow(2, n)\n    numerator = total_days\n    denominator = 1\n    for i in range(1, k):\n        numerator = (numerator * (total_days - i)) % MOD\n        denominator = (denominator * (i + 1)) % MOD\n    prob_no_same_birthday = (numerator * mod_inv(denominator)) % MOD\n    prob_at_least_one_match = ((MOD - 1) - prob_no_same_birthday) % MOD\n    return (prob_at_least_one_match, mod_inv(denominator))\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    a, b = solve(n, k)\n    print(a, b)"}
{"solution": "def validate_journey(n, moves):\n    latitude = 0  # Start from North Pole\n    on_north_pole = True\n    on_south_pole = False\n\n    for t, direction in moves:\n        if on_north_pole and direction != 'South':\n            return \"NO\"\n        if on_south_pole and direction != 'North':\n            return \"NO\"\n\n        if direction == 'South':\n            latitude -= t\n            if latitude < -20000:\n                return \"NO\"\n            on_north_pole = False\n        elif direction == 'North':\n            latitude += t\n            if latitude > 20000:\n                return \"NO\"\n            if latitude == 0:\n                on_north_pole = True\n            if latitude == -20000:\n                on_south_pole = True\n        else:  # East or West\n            if on_north_pole:\n                on_north_pole = False\n            elif latitude < 0:\n                latitude = -20000 - (latitude % 40000)\n\n    if not on_north_pole or latitude != 0:\n        return \"NO\"\n\n    return \"YES\"\n\n# Reading input\nn = int(input())\nmoves = []\nfor _ in range(n):\n    t, direction = input().split()\n    moves.append((int(t), direction))\n\n# Printing output\nprint(validate_journey(n, moves))"}
{"solution": "from math import gcd\n\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Calculate the common difference for the intersection sequence\ncommon_diff = a1 * a2 // gcd(a1, a2)\n\n# Adjust L to the first valid value in range [L, R] if possible\nif (L - b1) % a1:\n    L += (a2 - (L - b1) % a2) % a2\nelse:\n    L += (a1 - (L - b1) % a1) % a1\n\n# If after adjustment L is more than R, there's no intersection in the range\nif L > R:\n    print(0)\nelse:\n    # Adjust R to the last valid value in range [L, R]\n    if (R - b1) % a1:\n        R -= (R - b1) % a1\n    else:\n        R -= (R - b1) % a2\n\n    # Calculate the number of valid values in the range [L, R]\n    count = ((R - L) // common_diff) + 1\n    print(max(0, count))"}
{"solution": "def max_cake_pieces(n, a, b):\n    # Ensure the total number of pieces can cover the plates\n    if a + b < n:\n        return 0\n    \n    # Try to maximize the minimum number of pieces per plate\n    for x in range(min(a, b), 0, -1):\n        # Check if pieces can be distributed evenly with at least x pieces per plate\n        if (a - x) <= (n - 1) * x and (b - x) <= (n - 1) * x:\n            return x\n    \n    # If no distribution works, return 1 (each plate gets at least one piece)\n    return 1\n\n# Example usage based on provided inputs\nn, a, b = map(int, input().split())\nprint(max_cake_pieces(n, a, b))"}
{"solution": "def check_flag(n, m, flag):\n    color_counts = {'R': 0, 'G': 0, 'B': 0}\n\n    for row in flag:\n        for color in set(row):\n            color_counts[color] += 1\n\n    valid_stripe_count = n // 3\n\n    for color, count in color_counts.items():\n        if count not in [0, valid_stripe_count]:\n            return \"NO\"\n\n    stripe_heights = [0, 0, 0]\n    for i in range(3):\n        for j in range(i * valid_stripe_count, (i + 1) * valid_stripe_count):\n            stripe_heights[i] += len(set(flag[j]))\n\n    if sorted(stripe_heights) != [m, m, m]:\n        return \"NO\"\n\n    return \"YES\"\n\n# Reading input\nn, m = map(int, input().split())\nflag = [input() for _ in range(n)]\n\n# Printing output\nprint(check_flag(n, m, flag))"}
{"solution": "def move_in_hex_spiral(n):\n    \"\"\"\n    Given a number n, this function calculates the coordinates (x, y) on a hexagonal grid\n    after n moves along a spiral starting from (0, 0).\n    \"\"\"\n    x, y = 0, 0\n    direction = 0  # 0: NE, 1: SE, 2: SW, 3: NW, 4: N, 5: S\n    side_length = 1\n    while n > 0:\n        if direction % 2 == 0:\n            side_length += 1\n        for _ in range(side_length):\n            if direction == 0:\n                x += 1\n            elif direction == 1:\n                x, y = x + 1, y - 1\n            elif direction == 2:\n                y -= 1\n            elif direction == 3:\n                y, x = y - 1, x - 1\n            elif direction == 4:\n                x -= 1\n            else:  # direction == 5\n                y, x = y + 1, x + 1\n            n -= 1\n            if n == 0:\n                return x, y\n        direction = (direction + 1) % 6\n    return x, y\n\n# Reading input\nn = int(input().strip())\n\n# Calculating and printing output\nprint(*move_in_hex_spiral(n))"}
{"solution": "a, b, c = map(int, input().split())\nfor x in range(c // a + 1):\n    if (c - a * x) % b == 0:\n        print(\"Yes\")\n        break\nelse:\n    print(\"No\")"}
{"solution": "def check_tracks(barriers1, barriers2, track_length):\n    for i in range(len(barriers1)):\n        shifted = [(barriers1[j] - barriers1[i] + track_length) % track_length for j in range(len(barriers1))]\n        if shifted == barriers2:\n            return \"YES\"\n    return \"NO\"\n\ndef main():\n    n, L = map(int, input().split())\n    kefa_barriers = list(map(int, input().split()))\n    sasha_barriers = list(map(int, input().split()))\n    result = check_tracks(kefa_barriers, sasha_barriers, L)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def longest_non_palindrome_substring(s):\n    \"\"\"\n    Finds the longest substring that is not a palindrome.\n    If all substrings are palindromes, returns 0.\n    \"\"\"\n    def is_palindrome(sub):\n        return sub == sub[::-1]\n\n    max_len = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if not is_palindrome(s[i:j]):\n                max_len = max(max_len, j-i)\n    return max_len if max_len > 0 else 0\n\n# Example usage\ninput_str = input()\nprint(longest_non_palindrome_substring(input_str))"}
{"solution": "def is_round_rated(n, ratings):\n    unchanged = all(r[0] == r[1] for r in ratings)\n    ordered = all(ratings[i][0] >= ratings[i+1][0] for i in range(n-1))\n    \n    if unchanged and ordered:\n        return \"maybe\"\n    elif unchanged:\n        return \"unrated\"\n    else:\n        return \"rated\"\n\ndef main():\n    n = int(input())\n    ratings = [list(map(int, input().split())) for _ in range(n)]\n    print(is_round_rated(n, ratings))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    # Forward pass\n    last_zero = -1\n    for i in range(n):\n        if arr[i] == 0:\n            last_zero = i\n        arr[i] = i - last_zero\n    \n    # Backward pass\n    last_zero = n\n    for i in range(n-1, -1, -1):\n        if arr[i] == 0:\n            last_zero = i\n        arr[i] = min(arr[i], last_zero - i)\n    \n    print(*arr)\n\nsolve()"}
{"solution": "from math import gcd\n\ndef z_function(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            z[i] = min(r - i + 1, z[i - l])\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > r:\n            l, r = i, i + z[i] - 1\n    return z\n\ndef solve():\n    n = int(input())\n    s = input()\n    m = len(s)\n    z = z_function(s)\n    ans = (1 << n) - (1 << (n - m))\n    for i in range(1, m):\n        if z[i] + i == m:\n            period = i\n            g = gcd(n, period)\n            ans += (1 << (n - n // g))\n    print(ans)\n\nsolve()"}
{"solution": "from math import atan2, pi\n\ndef find_min_angle_vectors():\n    n = int(input())\n    vectors = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        angle = atan2(y, x)\n        if angle < 0:\n            angle += 2 * pi\n        vectors.append((angle, _ + 1))\n\n    vectors.sort()\n    min_diff = 2 * pi\n    result = (0, 0)\n\n    for i in range(n):\n        for j in range(i + 1, min(i + 3, n)):\n            diff = vectors[j][0] - vectors[i][0]\n            if diff > pi:\n                diff = 2 * pi - diff\n            if diff < min_diff:\n                min_diff = diff\n                result = (vectors[i][1], vectors[j][1])\n\n    # Check the angle between the last and first vector\n    diff = 2 * pi - (vectors[-1][0] - vectors[0][0])\n    if diff < min_diff:\n        result = (vectors[0][1], vectors[-1][1])\n\n    print(*result)\n\nfind_min_angle_vectors()"}
{"solution": "def min_time_to_post_office(d, k, a, b, t):\n    if d % k == 0:\n        repair_times = d // k - 1\n    else:\n        repair_times = d // k\n    \n    time_by_car_with_repairs = (d // k) * a + repair_times * t\n    time_by_foot = d * b\n    \n    return min(time_by_car_with_repairs, time_by_foot)\n\nd, k, a, b, t = map(int, input().split())\nprint(min_time_to_post_office(d, k, a, b, t))"}
{"solution": "import math\n\ndef find_sequence(n, k):\n    gcd = n // k\n    sequence = [gcd * i for i in range(1, k)]\n    remainder = n - sum(sequence)\n    sequence.append(remainder + gcd * (k))\n    if min(sequence) < 1:\n        return [-1]\n    else:\n        return sequence\n\ndef main():\n    n, k = map(int, input().split())\n    result = find_sequence(n, k)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_pairs(n, m):\n    \"\"\"\n    Counts the number of pairs (x, y) such that 1 \u2264 x \u2264 n, 1 \u2264 y \u2264 m and (x + y) is divisible by 5.\n    \"\"\"\n    # Initialize the result\n    result = 0\n    \n    # Precompute counts of numbers modulo 5 for both sequences\n    mod_counts_n = [0] * 5\n    mod_counts_m = [0] * 5\n    \n    # Count for sequence 1 to n\n    for i in range(1, n + 1):\n        mod_counts_n[i % 5] += 1\n    \n    # Count for sequence 1 to m\n    for j in range(1, m + 1):\n        mod_counts_m[j % 5] += 1\n    \n    # Calculate pairs where (x + y) % 5 == 0\n    result += mod_counts_n[0] * mod_counts_m[0]  # (0+0)%5==0\n    for i in range(1, 5):\n        if (5 - i) % 5 != 0:  # Avoid double counting for remainder 0\n            result += mod_counts_n[i] * mod_counts_m[(5 - i) % 5]\n    \n    return result // 2  # Each pair is counted twice\n\n# Read input\nn, m = map(int, input().split())\n\n# Output the result\nprint(count_pairs(n, m))"}
{"solution": "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n, x = map(int, input().split())\n    arr = list(map(int, input().split()))\n\n    dp = [[0 for _ in range(3)] for _ in range(n + 1)]\n    ans = 0\n\n    for i in range(1, n + 1):\n        dp[i][0] = max(dp[i - 1][0] + arr[i - 1], arr[i - 1])\n        dp[i][1] = max(dp[i - 1][0] + arr[i - 1] * x, dp[i - 1][1] + arr[i - 1] * x)\n        dp[i][2] = max(dp[i - 1][1] + arr[i - 1], dp[i - 1][2] + arr[i - 1])\n\n        ans = max(ans, dp[i][0], dp[i][1], dp[i][2])\n\n    print(ans)\n\nsolve()"}
{"solution": "import sys\nimport math\n\ndef count_less_equal(x, n, m):\n    count = 0\n    for i in range(1, n + 1):\n        count += min(m, x // i)\n    return count\n\ndef kth_largest(n, m, k):\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_less_equal(mid, n, m) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\nn, m, k = map(int, sys.stdin.readline().split())\nprint(kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    digit_length = 1\n    while k > digit_length * 9 * 10 ** (digit_length - 1):\n        k -= digit_length * 9 * 10 ** (digit_length - 1)\n        digit_length += 1\n    \n    quotient, remainder = divmod(k - 1, digit_length)\n    number = 10 ** (digit_length - 1) + quotient\n    \n    return int(str(number)[remainder])\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "def max_profit(n, m, r, s, b):\n    dp = [[0] * (r + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = 0\n    \n    for j in range(1, r + 1):\n        dp[0][j] = j\n    \n    for i in range(1, n + 1):\n        for j in range(1, r + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= s[i - 1]:\n                for k in range(m):\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - s[i - 1]] + b[k] * (j // s[i - 1]))\n    \n    return dp[n][r]\n\nn, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(max_profit(n, m, r, s, b))"}
{"solution": "def find_overlap(text):\n    n = len(text)\n    for i in range(1, n // 2 + 1):\n        if text[:n-i] == text[i:]:\n            return text[:n-i]\n    return None\n\nt = input().strip()\ns = find_overlap(t)\n\nif s is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(s)"}
{"solution": "def find_teams(n):\n    \"\"\"\n    Finds the number of teams that can be invited so that the tournament needs exactly n games.\n    :param n: Total number of games to be played.\n    :return: A list of possible numbers of teams or -1 if not possible.\n    \"\"\"\n    possible_teams = []\n    while n > 0:\n        # Check if current n can be reached by the given process\n        m = 1\n        while n - m > 0 and (n - m) % m == 0:\n            if n - m == m * ((m - 1) // 2) or m == 1:\n                possible_teams.append(m + 2 * ((n - m) // m))\n            m *= 2\n        if m > n:\n            break\n        n -= m\n        m //= 2\n        while m > 0 and n % m == 0:\n            n //= m\n            m //= 2\n    return possible_teams if possible_teams else [-1]\n\n# Example usage\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    result = find_teams(n)\n    for team_count in result:\n        print(team_count)"}
{"solution": "from collections import Counter\n\ndef max_antipalindromic_beauty(n, s, b):\n    \"\"\"\n    Calculate the maximum possible beauty of an antipalindromic permutation of string s.\n    \n    :param n: Length of the string s (even number)\n    :param s: String consisting of n lowercase Latin letters\n    :param b: List of n integers representing the beauty of each index\n    :return: Maximum possible beauty of an antipalindromic permutation of s\n    \"\"\"\n    char_count = Counter(s)\n    if any(count > n // 2 for count in char_count.values()):\n        return \"It's not possible to form an antipalindromic string with the given input.\"\n    \n    sorted_indices = sorted(range(n), key=lambda x: -b[x])\n    result = [None] * n\n    half = n // 2\n    \n    char_positions = {char: [] for char in char_count}\n    for i, char in enumerate(s):\n        char_positions[char].append(i)\n    \n    used_chars = set()\n    for i in range(half):\n        pos1 = sorted_indices[i]\n        pos2 = sorted_indices[half + i]\n        \n        for char, positions in char_positions.items():\n            if char in used_chars or len(positions) < 2:\n                continue\n            \n            if pos1 in positions and pos2 in positions:\n                continue\n            \n            p1, p2 = positions[-2:]\n            del char_positions[char][-2:]\n            \n            if p1 == pos1:\n                result[pos1], result[pos2] = char, char.swapcase()\n            else:\n                result[pos2], result[pos1] = char, char.swapcase()\n            \n            used_chars.add(char)\n            break\n    \n    return sum(b[i] for i in range(n) if s[i] == result[i])\n\n# Input reading\nn = int(input())\ns = input().strip()\nb = list(map(int, input().split()))\n\nprint(max_antipalindromic_beauty(n, s, b))"}
{"solution": "def can_weigh(w, m):\n    if m == 0:\n        return \"YES\"\n    balances = {0}\n    for i in range(101):\n        new_balances = set()\n        for b in balances:\n            new_balances.add(b + w ** i)\n            new_balances.add(abs(b - w ** i))\n        balances = new_balances\n        if m in balances or -m in balances:\n            return \"YES\"\n    return \"NO\"\n\nw, m = map(int, input().split())\nprint(can_weigh(w, m))"}
{"solution": "import sys\n\ndef solve(n, k):\n    bits = []\n    while n:\n        bits.append(n & -n)\n        n -= n & -n\n    if len(bits) > k:\n        return False\n    diff = k - len(bits)\n    for _ in range(diff):\n        bits.append(1)\n    bits.sort(reverse=True)\n    ans = [0] * k\n    val = 0\n    for i in range(k):\n        while bits and bits[-1] <= val:\n            bits.pop()\n        if not bits:\n            return False\n        ans[i] = int.bit_length(bits.pop()) - 1\n        val = ans[i]\n    return ans\n\ninput = sys.stdin.readline\nn, k = map(int, input().split())\nres = solve(n, k)\nif res:\n    print('Yes')\n    print(' '.join(map(str, res)))\nelse:\n    print('No')"}
{"solution": "def pour_champagne(n, t):\n    levels = [[0] * (i + 1) for i in range(n)]\n    levels[0][0] = t\n    for i in range(n):\n        for j in range(len(levels[i])):\n            if i > 0:\n                overflow_from_above = (levels[i-1][j] // 2) if j > 0 else 0\n                overflow_from_above += (levels[i-1][j-1] // 2) if j-1 >= 0 else 0\n                levels[i][j] += overflow_from_above\n            if levels[i][j] >= 1:\n                overflow = levels[i][j] - 1\n                levels[i][j] = 1\n                if i != n-1:\n                    levels[i+1][j] += overflow / 2\n                    levels[i+1][j+1] += overflow / 2 if j+1 < len(levels[i+1]) else 0\n    return sum(1 for row in levels for glass in row if glass == 1)\n\n# Reading input\nn, t = map(int, input().split())\n\n# Processing and printing output\nprint(pour_champagne(n, t))"}
{"solution": "def calculate_area(points):\n    x_coords = sorted([point[0] for point in points])\n    y_coords = sorted([point[1] for point in points])\n\n    width = x_coords[-1] - x_coords[0]\n    height = y_coords[-1] - y_coords[0]\n\n    return width * height\n\ndef can_determine_area(n, vertices):\n    if n < 2:\n        return -1\n\n    unique_x = len(set(vertex[0] for vertex in vertices))\n    unique_y = len(set(vertex[1] for vertex in vertices))\n\n    if unique_x == 1 or unique_y == 1:\n        return -1\n\n    if (unique_x == 2 and unique_y == 2) or n == 4:\n        return calculate_area(vertices)\n\n    return -1\n\nn = int(input())\nvertices = [list(map(int, input().split())) for _ in range(n)]\n\nprint(can_determine_area(n, vertices))"}
{"solution": "def min_wooden_bars(n, a, b):\n    total_length_needed = 4 * a + 2 * b\n    if n >= total_length_needed:\n        return 1\n    else:\n        return -(-total_length_needed // n)  # Equivalent to ceil division\n\n# Reading input\nn = int(input())\na = int(input())\nb = int(input())\n\n# Output\nprint(min_wooden_bars(n, a, b))"}
{"solution": "def can_sort_by_swaps(n, a, swaps):\n    forbidden = set()\n    for i in range(n-1):\n        if swaps[i] == '0':\n            forbidden.add(a[i])\n            forbidden.add(a[i+1])\n    \n    last_seen = {}\n    for i, val in enumerate(a):\n        last_seen[val] = i\n    \n    for num in range(1, n+1):\n        if num in forbidden:\n            continue\n        prev_pos = -1\n        for num2 in range(num, n+1, 2):\n            if num2 in forbidden:\n                break\n            if num2 not in last_seen:\n                break\n            if last_seen[num2] <= prev_pos:\n                return \"NO\"\n            prev_pos = last_seen[num2]\n        else:\n            continue\n        break\n    else:\n        return \"YES\"\n    \n    for num in range(1, n+1):\n        if num in forbidden:\n            continue\n        prev_pos = -1\n        for num2 in range(num, 1, -1):\n            if num2 in forbidden:\n                break\n            if num2 not in last_seen:\n                break\n            if last_seen[num2] <= prev_pos:\n                return \"NO\"\n            prev_pos = last_seen[num2]\n        else:\n            continue\n        break\n    else:\n        return \"YES\"\n    \n    return \"NO\"\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\nswaps = input()\n\nprint(can_sort_by_swaps(n, a, swaps))"}
{"solution": "def calculate_wait_time(seat_info: str) -> int:\n    \"\"\"\n    Calculates the wait time for Vasya to get his lunch based on his seat information.\n    \"\"\"\n    row, seat = seat_info[:-1], seat_info[-1]\n    row_num = int(row)\n    seconds = 0\n    current_row_first_attendant = 1\n    current_row_second_attendant = 3\n    move_by = 1\n\n    while True:\n        if current_row_first_attendant == row_num or current_row_second_attendant == row_num:\n            break\n        seconds += 6 * move_by + move_by\n        current_row_first_attendant += move_by\n        current_row_second_attendant += move_by\n        move_by = 3 if move_by == 1 else 1\n\n    seat_order = 'fedcba'\n    seat_seconds = seat_order.index(seat) + 1\n    if current_row_first_attendant == row_num:\n        seconds += seat_seconds\n    else:\n        seconds += 6 + seat_seconds\n\n    return seconds\n\n# Reading input\nseat_info = input().strip()\n\n# Calculating and printing the result\nprint(calculate_wait_time(seat_info))"}
{"solution": "def convert_to_decimal(digits, base):\n    return sum(int(digit) * (base ** i) for i, digit in enumerate(reversed(digits)))\n\ndef compare_numbers(n, bx, x_digits, m, by, y_digits):\n    x_decimal = convert_to_decimal(x_digits, bx)\n    y_decimal = convert_to_decimal(y_digits, by)\n    \n    if x_decimal == y_decimal:\n        return '='\n    elif x_decimal < y_decimal:\n        return '<'\n    else:\n        return '>'\n\n# Input\nn, bx = map(int, input().split())\nx_digits = input().split()\nm, by = map(int, input().split())\ny_digits = input().split()\n\nprint(compare_numbers(n, bx, x_digits, m, by, y_digits))"}
{"solution": "from functools import reduce\nfrom operator import xor\n\ndef game_winner():\n    # Read number of elements\n    n = int(input())\n    \n    # Read the sequence of numbers\n    sequence = list(map(int, input().split()))\n    \n    # Calculate the xor of all elements in the sequence\n    xor_result = reduce(xor, sequence)\n    \n    # If xor_result is 0, BitAryo wins; otherwise, BitLGM wins\n    if xor_result == 0:\n        print(\"BitAryo\")\n    else:\n        print(\"BitLGM\")\n\n# Call the function to determine the winner\ngame_winner()"}
{"solution": "from math import gcd\n\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef prefix_gcd(arr):\n    n = len(arr)\n    prefix = [0] * n\n    prefix[0] = arr[0]\n    for i in range(1, n):\n        prefix[i] = gcd(prefix[i-1], arr[i])\n    return prefix\n\ndef suffix_gcd(arr):\n    n = len(arr)\n    suffix = [0] * n\n    suffix[-1] = arr[-1]\n    for i in range(n-2, -1, -1):\n        suffix[i] = gcd(suffix[i+1], arr[i])\n    return suffix\n\ndef solve():\n    n, k = read_ints()\n    cards = read_ints()\n    \n    if all(gcd(x, k) != 1 for x in cards):\n        print(n * (n + 1) // 2 - n + 1)\n        return\n    \n    prefix = prefix_gcd(cards)\n    suffix = suffix_gcd(cards)\n    \n    count = 0\n    for i in range(n):\n        left_gcd = prefix[i] if i > 0 else 1\n        right_gcd = suffix[i] if i < n - 1 else 1\n        if gcd(left_gcd, right_gcd, k) == 1:\n            continue\n        \n        if i == 0 or gcd(prefix[i-1], k) == 1:\n            left = i + 1\n        else:\n            left = 1\n        \n        if i == n - 1 or gcd(suffix[i+1], k) == 1:\n            right = n - i\n        else:\n            right = 1\n        \n        count += left * right\n    \n    print(count)\n\nsolve()"}
{"solution": "def can_distribute_balloons(n, k, s):\n    from collections import Counter\n    balloon_counts = Counter(s)\n    max_count = max(balloon_counts.values())\n    return \"YES\" if max_count <= k else \"NO\"\n\n# Example usage would be:\n# n, k = map(int, input().split())\n# s = input()\n# print(can_distribute_balloons(n, k, s))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\nmin_val = min(a)\npositions = [i for i, x in enumerate(a) if x == min_val]\nprint(min(positions[i+1] - positions[i] for i in range(len(positions)-1)))"}
{"solution": "from math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(t, w, b):\n    if w == b:\n        numerator = t // w + 1\n        denominator = 2 * (t // w + 1)\n    else:\n        max_steps_w = (t - 1) // w\n        max_steps_b = (t - 1) // b\n        lcm_wb = lcm(w, b)\n        cycle_length = (lcm_wb // w) * (lcm_wb // b)\n        ties_in_cycle = 0\n        \n        for i in range(max_steps_w + 1):\n            for j in range(max_steps_b + 1):\n                if w * i == b * j and w * i <= t:\n                    ties_in_cycle += 1\n        \n        full_cycles = t // lcm_wb\n        remainder = t % lcm_wb\n        ties = full_cycles * ties_in_cycle\n        \n        for i in range(max_steps_w + 1):\n            if w * i <= remainder and w * i % (lcm_wb // b) == 0:\n                ties += 1\n        \n        numerator = ties\n        denominator = t\n    \n    common_divisor = gcd(numerator, denominator)\n    return f\"{numerator // common_divisor}/{denominator // common_divisor}\"\n\n# Reading input\nt, w, b = map(int, input().split())\n\n# Calculating and printing the result\nprint(solve(t, w, b))"}
{"solution": "def determine_vote_outcome(x, y, z):\n    if z == 0:\n        if x > y:\n            return \"+\"\n        elif y > x:\n            return \"-\"\n        else:\n            return \"0\"\n    \n    diff = x - y\n    max_possible_diff = diff + z\n    min_possible_diff = diff - z\n    \n    if max_possible_diff < 0 or min_possible_diff > 0:\n        return \"?\"\n    elif max_possible_diff == 0 and min_possible_diff == 0:\n        return \"0\"\n    elif max_possible_diff > 0 and min_possible_diff < 0:\n        return \"?\"\n    elif max_possible_diff > 0:\n        return \"+\"\n    else:\n        return \"-\"\n\n# Read input\nx, y, z = map(int, input().split())\n\n# Determine and print the outcome\nprint(determine_vote_outcome(x, y, z))"}
{"solution": "def min_operations_to_target(n, ops, target):\n    x, y = 0, 0\n    min_x, max_x = 0, 0\n    min_y, max_y = 0, 0\n    for i, op in enumerate(ops):\n        if op == 'R':\n            x += 1\n            max_x = i + 1\n        elif op == 'L':\n            x -= 1\n            min_x = i + 1\n        elif op == 'U':\n            y += 1\n            max_y = i + 1\n        else:\n            y -= 1\n            min_y = i + 1\n\n    dx, dy = abs(target[0]), abs(target[1])\n    if dx + dy < n and (dx - (n - max_y - min_y)) % 2 == 0 and (dy - (n - max_x - min_x)) % 2 == 0:\n        return n - max(max_y + max_x, min_y + min_x) - (dx + dy - n)\n    elif dx + dy == n:\n        return n if (dx - max_x - min_x) % 2 == 0 and (dy - max_y - min_y) % 2 == 0 else -1\n    else:\n        return -1\n\n# Example usage\nn = int(input())\nops = input()\ntarget = list(map(int, input().split()))\nprint(min_operations_to_target(n, ops, target))"}
{"solution": "from collections import defaultdict\n\ndef solve_balance_prefixes(s, x):\n    \"\"\"\n    Solves for the number of prefixes of t with a balance equal to x.\n    If the number of such prefixes is infinite, returns -1.\n    \"\"\"\n    balance = 0\n    prefix_counts = defaultdict(int)\n    prefix_counts[0] = 1\n    cycle_balance = 0\n    cycle_length = len(s)\n\n    for char in s:\n        balance += 1 if char == '1' else -1\n        cycle_balance += 1 if char == '1' else -1\n        if balance + x in prefix_counts:\n            return prefix_counts[balance + x]\n        prefix_counts[balance] += 1\n\n    if cycle_balance == 0:\n        return -1 if balance + x in prefix_counts else 0\n\n    full_cycles = (x * cycle_length) // (-cycle_balance)\n    if (x * cycle_length) % (-cycle_balance) != 0:\n        full_cycles += 1\n\n    result = sum(prefix_counts.values()) * (full_cycles - 1)\n    remaining_balance = balance\n    for _ in range(full_cycles * cycle_length - len(s)):\n        remaining_balance += 1 if s[_ % cycle_length] == '1' else -1\n        if remaining_balance == balance + x:\n            break\n    else:\n        return result + prefix_counts[balance + x]\n    \n    return result + prefix_counts[balance + x]\n\n# Reading inputs\nT = int(input())\nresults = []\nfor _ in range(T):\n    n, x = map(int, input().split())\n    s = input()\n    results.append(solve_balance_prefixes(s, x))\n\n# Printing outputs\nprint('\\n'.join(map(str, results)))"}
{"solution": "def min_deletions_to_divisible(n, k):\n    n_str = str(n)\n    zeros_needed = k\n    non_zero_count = 0\n    result = 0\n\n    for i in range(len(n_str) - 1, -1, -1):\n        if zeros_needed > 0:\n            if n_str[i] == '0':\n                zeros_needed -= 1\n            else:\n                result += 1\n        else:\n            if n_str[i] != '0':\n                non_zero_count += 1\n            else:\n                result += 1\n\n    return len(n_str) - non_zero_count - result if non_zero_count > 0 else k\n\n# Example usage\nn, k = map(int, input().split())\nprint(min_deletions_to_divisible(n, k))"}
{"solution": "def literature_lesson(n, m, k, x, y):\n    # Calculate the total number of students\n    total_students = n * m\n    \n    # Calculate the number of complete cycles\n    complete_cycles = k // total_students\n    remaining_questions = k % total_students\n    \n    # Calculate the number of times each student is asked in complete cycles\n    min_questions = complete_cycles\n    max_questions = complete_cycles\n    \n    # Calculate the number of times each student is asked in the remaining questions\n    up_rows = (remaining_questions + m - 1) // m\n    down_rows = remaining_questions // m\n    \n    if up_rows > down_rows:\n        max_questions += 1\n    if up_rows + down_rows > 0 and up_rows + down_rows < n:\n        min_questions += 1\n    \n    # Calculate the number of times Sergei is asked\n    sergei_questions = complete_cycles * (m if n > 1 else 1)\n    \n    if remaining_questions >= (x - 1) * m + y:\n        sergei_questions += 1\n    \n    return max_questions, min_questions, sergei_questions\n\n# Read input\nn, m, k, x, y = map(int, input().split())\n\n# Calculate and print the result\nprint(*literature_lesson(n, m, k, x, y))"}
{"solution": "from collections import Counter\n\ndef max_ribbon_beauty(s):\n    counts = Counter(s)\n    most_common, _ = counts.most_common(1)[0]\n    return counts[most_common]\n\ndef determine_winner(n, kuro, shiro, katie):\n    length = len(kuro)\n    \n    kuro_beauty = max_ribbon_beauty(kuro)\n    shiro_beauty = max_ribbon_beauty(shiro)\n    katie_beauty = max_ribbon_beauty(katie)\n    \n    # After n turns, the maximum possible beauty is the length of the ribbon\n    if n >= length:\n        if kuro_beauty == shiro_beauty == katie_beauty == length:\n            return \"Draw\"\n        else:\n            return [\"Kuro\", \"Shiro\", \"Katie\"][max(kuro_beauty, shiro_beauty, katie_beauty) // length]\n    \n    # If n < length, calculate the maximum beauty achievable\n    max_possible_beauty = length - n\n    if kuro_beauty >= max_possible_beauty and shiro_beauty >= max_possible_beauty and katie_beauty >= max_possible_beauty:\n        return \"Draw\"\n    elif kuro_beauty >= max_possible_beauty:\n        return \"Kuro\"\n    elif shiro_beauty >= max_possible_beauty:\n        return \"Shiro\"\n    elif katie_beauty >= max_possible_beauty:\n        return \"Katie\"\n    else:\n        return [\"Kuro\", \"Shiro\", \"Katie\"][max(kuro_beauty, shiro_beauty, katie_beauty)]\n\n# Reading input\nn = int(input())\nkuro = input()\nshiro = input()\nkatie = input()\n\n# Determine and print the winner\nprint(determine_winner(n, kuro, shiro, katie))"}
{"solution": "def days_to_finish_book(c, v0, v1, a, l):\n    total_pages_read = 0\n    current_speed = v0\n    days = 0\n    \n    while total_pages_read < c:\n        days += 1\n        if current_speed + l * (days - 1) > v1:\n            current_speed = v1\n        else:\n            current_speed = min(v1, v0 + a * (days - 1))\n        \n        pages_this_day = min(c - total_pages_read, current_speed)\n        if days > 1:\n            pages_this_day -= l\n        \n        total_pages_read += pages_this_day\n    \n    return days\n\nc, v0, v1, a, l = map(int, input().split())\nprint(days_to_finish_book(c, v0, v1, a, l))"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nn = int(input())\n\nif is_prime(n):\n    print(1)\n    print(n)\nelse:\n    for i in range(2, n):\n        if is_prime(i) and is_prime(n - i - 2):\n            print(3)\n            print(2, i, n - i - 2)\n            break\n    else:\n        print(2)\n        for i in range(2, n):\n            if is_prime(i) and is_prime(n - i):\n                print(i, n - i)\n                break"}
{"solution": "def solve():\n    from collections import Counter\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n)]\n    \n    row_counts = [row.count('*') for row in grid]\n    col_counts = [col.count('*') for col in zip(*grid)]\n    \n    total_walls = sum(row_counts)\n    \n    if total_walls == 0:\n        print(\"YES\")\n        print(1, 1)\n        return\n    \n    for i in range(n):\n        for j in range(m):\n            if row_counts[i] + col_counts[j] == total_walls:\n                print(\"YES\")\n                print(i + 1, j + 1)\n                return\n    \n    print(\"NO\")\n\nsolve()"}
{"solution": "def min_cost(n, m, a, b):\n    remainder = n % m\n    if remainder == 0:\n        return 0\n    cost_build = (m - remainder) * a if (n < (m - remainder)) else ((n + (m - remainder)) * a - n * b)\n    cost_demolish = remainder * b if (n > remainder) else ((n - remainder) * b - (n - m) * a)\n    return min(cost_build, cost_demolish)\n\nn, m, a, b = map(int, input().split())\nprint(min_cost(n, m, a, b))"}
{"solution": "def max_odd_subsequence_sum():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    max_even_sum = 0\n    max_odd_sum = float('-inf')\n    \n    for num in arr:\n        if num % 2 == 0:\n            max_even_sum = max(max_even_sum + num, 0)\n        else:\n            max_odd_sum = max(max_odd_sum, max_even_sum + num)\n            max_even_sum = max(max_even_sum, 0)\n    \n    print(max_odd_sum)\n\nmax_odd_subsequence_sum()"}
{"solution": "from collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef solve():\n    n, T = map(int, input().split())\n    songs = []\n    for _ in range(n):\n        t, g = map(int, input().split())\n        songs.append((t, g))\n\n    dp = [[[0 for _ in range(4)] for _ in range(T + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 1\n\n    for i in range(n):\n        ti, gi = songs[i]\n        for t in range(T + 1):\n            for g in range(4):\n                if g == 0 or g != gi:\n                    dp[i + 1][t][gi] += dp[i][t][g]\n                    dp[i + 1][t][gi] %= MOD\n                if t >= ti and (g == 0 or g != gi):\n                    dp[i + 1][t][gi] += dp[i][t - ti][g]\n                    dp[i + 1][t][gi] %= MOD\n\n    result = sum(dp[n][T][g] for g in range(1, 4)) % MOD\n    print(result)\n\nsolve()"}
{"solution": "from math import gcd\nMOD = 10**9 + 7\n\ndef mod_inverse(x):\n    return pow(x, MOD-2, MOD)\n\ndef solve(m):\n    dp = [0] * (m+1)\n    dp[1] = 1\n    for x in range(2, m+1):\n        lcm_x = x\n        dp[x] = (1 + sum(dp[gcd(x, y)] for y in range(1, m+1) if x != y and gcd(x, y) == 1)) % MOD\n    total_sum = sum(dp[i] for i in range(1, m+1))\n    return (total_sum * mod_inverse(m)) % MOD\n\nm = int(input())\nprint(solve(m))"}
{"solution": "from math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_good_pairs(l, r, x, y):\n    count = 0\n    for a in range(max(l, x), min(r + 1, y // x) + 1):\n        if y % a == 0:\n            b = y // a\n            if gcd(a, b) == x and a <= r and b >= l:\n                count += 1 if a == b else 2\n    return count\n\ndef main():\n    l, r, x, y = map(int, input().split())\n    print(count_good_pairs(l, r, x, y))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef find_min_k(a, b):\n    min_lcm = lcm(a, b)\n    result_k = 0\n    \n    # Check for k in range 0 to difference between a and b\n    for k in range(abs(a - b) + 1):\n        current_lcm = lcm(a + k, b + k)\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            result_k = k\n            \n    return result_k\n\na, b = map(int, input().split())\nprint(find_min_k(a, b))"}
{"solution": "def min_hacks(n, k, marks):\n    current_sum = sum(marks)\n    target_sum = ((n + 100) * k) // 10 // 9 * 9 + ((n + 100) * k) % 10\n    \n    return max(0, (target_sum - current_sum + k - 1) // k)\n\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\nprint(min_hacks(n, k, marks))"}
{"solution": "def find_divisor(arr):\n    \"\"\"\n    Finds a divisor d such that after dividing each element of arr by d,\n    at least half of the elements are positive.\n    Returns the divisor if found, otherwise returns 0.\n    \"\"\"\n    n = len(arr)\n    ceil_half = -(-n // 2)  # Equivalent to math.ceil(n / 2)\n\n    for d in range(-1000, 1001):\n        if d == 0:\n            continue\n        positive_count = sum(1 for x in arr if x / d > 0)\n        if positive_count >= ceil_half:\n            return d\n\n    return 0\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Processing and printing output\nprint(find_divisor(arr))"}
{"solution": "n = int(input())\nmod = n % 10\nif mod == 0:\n    print(n // 5 * (n // 5 - 1))\nelif mod <= 5:\n    print((n // 5 + 1) * mod - 1)\nelse:\n    print((n // 5 + 1) * (10 - mod) - 1)"}
{"solution": "from math import gcd\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\ns1 = a1 * b1\ns2 = a2 * b2\n\nif s1 == s2:\n    print(0)\n    print(f\"{a1} {b1}\")\n    print(f\"{a2} {b2}\")\nelse:\n    steps = 0\n    found = False\n    \n    def adjust_size(s1, s2, steps):\n        nonlocal found\n        if s1 % 2 == 0:\n            s1 //= 2\n            steps += 1\n            if s1 == s2:\n                found = True\n                return s1, s2, steps\n            else:\n                return adjust_size(s1, s2, steps)\n        elif s1 % 3 == 0:\n            s1 //= 3\n            steps += 1\n            if s1 == s2:\n                found = True\n                return s1, s2, steps\n            else:\n                return adjust_size(s1, s2, steps)\n        return s1, s2, steps\n    \n    if s1 > s2:\n        s1, s2, steps = adjust_size(s1, s2, steps)\n    else:\n        s1, s2, steps = adjust_size(s2, s1, steps)\n    \n    if found:\n        d1 = gcd(a1, b1)\n        d2 = gcd(a2, b2)\n        a1 //= d1\n        b1 //= d1\n        a2 //= d2\n        b2 //= d2\n        \n        if s1 == s2:\n            print(steps)\n            print(f\"{a1} {b1}\")\n            print(f\"{a2} {b2}\")\n        else:\n            print(-1)\n    else:\n        print(-1)"}
{"solution": "def game_winner(xp, yp, xv, yv):\n    # Check if Polycarp can win in one move\n    if xp == 0 and yp == 0:\n        return \"Polycarp\"\n    \n    # Check if Vasiliy can win in one move\n    if xv == 0 and yv == 0:\n        return \"Vasiliy\"\n    \n    # Calculate minimum moves needed for Polycarp and Vasiliy to reach (0, 0)\n    polycarp_moves = xp + yp\n    vasiliy_moves = xv + yv - min(xv, yv)\n    \n    # Check if Polycarp can reach (0, 0) in an odd number of moves\n    if polycarp_moves % 2 == 1:\n        return \"Polycarp\"\n    \n    # If Vasiliy can reach (0, 0) in fewer or equal moves, he wins\n    if vasiliy_moves <= polycarp_moves:\n        return \"Vasiliy\"\n    \n    # Otherwise, Polycarp wins\n    return \"Polycarp\"\n\n# Read input\nxp, yp, xv, yv = map(int, input().split())\n\n# Output the winner\nprint(game_winner(xp, yp, xv, yv))"}
{"solution": "def calendar_columns(month, first_day):\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    total_days = days_in_month[month - 1]\n    full_weeks, extra_days = divmod(total_days + first_day - 1, 7)\n    return full_weeks + (1 if extra_days > 0 else 0)\n\n# Reading input\nm, d = map(int, input().split())\n\n# Calculating and printing the result\nprint(calendar_columns(m, d))"}
{"solution": "import math\n\ndef count_zeros_in_range(start, end):\n    def count_for_year(year):\n        if year == 0:\n            return 0\n        exp = math.floor(math.log(year, 2))\n        base = 2 ** exp\n        high_bit = year - base\n        pairs = (base + 1) // 2\n        offset = year - (base + high_bit)\n        return pairs - (offset + 1)\n\n    return count_for_year(end + 1) - count_for_year(start)\n\nif __name__ == \"__main__\":\n    a, b = map(int, input().split())\n    print(count_zeros_in_range(a, b))"}
{"solution": "def min_layers(N):\n    return N * (N + 1) // 2\n\n# Example check (This line is not part of the solution and should be removed if copied to a solution)\nprint(min_layers(4))  # Expected output: 6"}
{"solution": "from math import factorial\n\ndef solve_cubes(n, k, S, cubes):\n    dp = [[[0 for _ in range(S + 1)] for _ in range(k + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        val, fact_val = cubes[i - 1], factorial(cubes[i - 1])\n        for j in range(k + 1):\n            for s in range(S + 1):\n                if s >= val:\n                    dp[i][j][s] += dp[i - 1][j][s - val]\n                if j > 0 and s >= fact_val:\n                    dp[i][j][s] += dp[i - 1][j - 1][s - fact_val]\n\n    return dp[n][k][S]\n\nn, k, S = map(int, input().split())\ncubes = list(map(int, input().split()))\nprint(solve_cubes(n, k, S, cubes))"}
{"solution": "from collections import Counter\n\ndef can_achieve_array(n, k, a):\n    power_counts = Counter()\n    max_power = 0\n    for value in a:\n        if value == 0:\n            continue\n        if value > k ** (max_power + 1):\n            return \"NO\"\n        while value > 0:\n            max_power += 1\n            power = max_power\n            while power_counts[power]:\n                power += 1\n                max_power = max(max_power, power)\n                if k ** power > value:\n                    return \"NO\"\n            power_counts[power] += 1\n            value -= k ** power\n    return \"YES\"\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        n, k = map(int, input().split())\n        a = list(map(int, input().split()))\n        print(can_achieve_array(n, k, a))\n\nsolve()"}
{"solution": "MOD = 1073741824\n\ndef divisors_count(n):\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n        i += 1\n    return count\n\ndef compute_sum(a, b, c):\n    result = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                result += divisors_count(i * j * k)\n                result %= MOD\n    return result\n\na, b, c = map(int, input().split())\nprint(compute_sum(a, b, c))"}
{"solution": "# Capture the initial configurations of Bessie's and Elsie's puzzles\nbessie_puzzle = [input() for _ in range(2)]\nelsie_puzzle = [input() for _ in range(2)]\n\n# Flatten the puzzles for easier manipulation\nbessie_flat = ''.join(bessie_puzzle)\nelsie_flat = ''.join(elsie_puzzle)\n\n# Check if the puzzles are already in the same configuration\nif bessie_flat == elsie_flat:\n    print(\"YES\")\nelse:\n    # Identify the index of the empty space ('X') in both puzzles\n    bessie_empty_index = bessie_flat.index('X')\n    elsie_empty_index = elsie_flat.index('X')\n\n    # Generate possible states for Bessie's puzzle by swapping the empty space with its neighbors\n    possible_states = []\n    for i in range(4):\n        if i != bessie_empty_index:\n            # Swap the empty space with another tile\n            new_state = list(bessie_flat)\n            new_state[i], new_state[bessie_empty_index] = new_state[bessie_empty_index], new_state[i]\n            possible_states.append(''.join(new_state))\n\n    # Check if any of Bessie's possible states match Elsie's puzzle\n    if elsie_flat in possible_states:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "def convert_to_decimal(n, k):\n    k = str(k)\n    length = len(k)\n    low, high = 0, 10**18\n\n    while low < high:\n        mid = (low + high) // 2\n        temp, power = 0, 1\n\n        for i in range(length - 1, -1, -1):\n            temp += int(k[i]) * power\n            if power > (10**18):\n                break\n            power *= n\n\n        if power > (10**18):\n            high = mid\n            continue\n\n        if temp == mid:\n            return mid\n        elif temp < mid:\n            low = mid\n        else:\n            high = mid\n\n    return low\n\nn = int(input())\nk = int(input())\nprint(convert_to_decimal(n, k))"}
{"solution": "def is_unimodal(arr):\n    n = len(arr)\n    increasing = True\n    constant_started = False\n    for i in range(1, n):\n        if increasing:\n            if arr[i] < arr[i - 1]:\n                increasing = False\n                constant_started = False\n            elif arr[i] == arr[i - 1]:\n                constant_started = True\n        else:\n            if arr[i] >= arr[i - 1]:\n                return False\n    return True if not increasing or constant_started else False\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(\"YES\" if is_unimodal(arr) else \"NO\")"}
{"solution": "import math\n\ndef find_max_value(n, k):\n    \"\"\"\n    Finds the maximum value that appears in at least k paths from 1 to n.\n    \"\"\"\n    def path_length(x):\n        length = 0\n        while x > 1:\n            x = x // 2 if x % 2 == 0 else x - 1\n            length += 1\n        return length\n    \n    low, high = 1, int(2e18)\n    \n    while low < high:\n        mid = (low + high + 1) // 2\n        # Calculate the number of paths with length at least ceil(log2(mid + 1))\n        # and subtract the number of paths with length at least ceil(log2(mid))\n        count = n - (2 ** math.ceil(math.log2(mid + 1))) + 1 - (n - (2 ** math.ceil(math.log2(mid)))) + 1\n        if count >= k:\n            low = mid\n        else:\n            high = mid - 1\n            \n    return low\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(find_max_value(n, k))"}
{"solution": "def find_pocket(n, m, x, y, vx, vy):\n    if vx == 0 and vy == 0:\n        return -1\n\n    if vx == 0:\n        if vy > 0:\n            return 0 if y + vy * m == m else -1\n        else:\n            return 0 if y + vy * m == 0 else -1\n\n    if vy == 0:\n        if vx > 0:\n            return 0 if x + vx * m == m else -1\n        else:\n            return 0 if x + vx * m == 0 else -1\n\n    slope = abs(vy / vx)\n    if vx > 0 and vy > 0:\n        meet_y = (m - y) / slope\n        meet_x = n - x\n        if meet_y > meet_x:\n            return (n, 0) if (x + vx * meet_x) % (2 * n) == 0 else -1\n        else:\n            return (0, m) if (y + vy * meet_y) % (2 * m) == m else -1\n    elif vx < 0 and vy > 0:\n        meet_y = (m - y) / slope\n        meet_x = x\n        if meet_y > meet_x:\n            return (0, 0) if (x + vx * meet_x) % (2 * n) == 0 else -1\n        else:\n            return (0, m) if (y + vy * meet_y) % (2 * m) == m else -1\n    elif vx < 0 and vy < 0:\n        meet_y = y\n        meet_x = x\n        if meet_y > meet_x:\n            return (0, 0) if (x + vx * meet_x) % (2 * n) == 0 else -1\n        else:\n            return (0, 0) if (y + vy * meet_y) % (2 * m) == 0 else -1\n    elif vx > 0 and vy < 0:\n        meet_y = y\n        meet_x = n - x\n        if meet_y > meet_x:\n            return (n, 0) if (x + vx * meet_x) % (2 * n) == 0 else -1\n        else:\n            return (0, 0) if (y + vy * meet_y) % (2 * m) == 0 else -1\n\nn, m, x, y, vx, vy = map(int, input().split())\nprint(find_pocket(n, m, x, y, vx, vy))"}
{"solution": "def can_place_paintings(board_dim, painting_dims):\n    \"\"\"\n    Determines if two paintings can be placed on a board without overlapping.\n    \n    :param board_dim: Tuple (a1, b1) representing dimensions of the board.\n    :param painting_dims: List of tuples [(a2, b2), (a3, b3)] representing dimensions of the paintings.\n    :return: \"YES\" if paintings can be placed on the board, \"NO\" otherwise.\n    \"\"\"\n    # Sort the board dimensions\n    board_dim = sorted(board_dim)\n    \n    # Sort the painting dimensions\n    painting_dims = [sorted(dim) for dim in painting_dims]\n    \n    # Check all possible configurations\n    for config in ((0, 1), (1, 0)):\n        if (painting_dims[0][config[0]] + painting_dims[1][config[1]] <= board_dim[0] and\n            painting_dims[0][config[1]] + painting_dims[1][config[0]] <= board_dim[1]):\n            return \"YES\"\n        if (max(painting_dims[0][config[0]], painting_dims[1][config[1]]) <= board_dim[0] and\n            max(painting_dims[0][config[1]], painting_dims[1][config[0]]) <= board_dim[1]):\n            return \"YES\"\n    \n    return \"NO\"\n\n# Reading input\nboard_dim = list(map(int, input().split()))\npainting1_dim = list(map(int, input().split()))\npainting2_dim = list(map(int, input().split()))\n\n# Output result\nprint(can_place_paintings(board_dim, [painting1_dim, painting2_dim]))"}
{"solution": "import math\nfrom collections import defaultdict\n\ndef solve(b1, q, l, m, bad):\n    if q == 0:\n        if abs(b1) <= l and b1 not in bad:\n            return 1\n        else:\n            return 0\n\n    bad_set = set(bad)\n\n    def count_terms(b1, q, l):\n        count = 0\n        current = b1\n        while abs(current) <= l:\n            if current not in bad_set:\n                count += 1\n            current *= q\n        return count\n\n    forward_count = count_terms(b1, q, l)\n    backward_count = count_terms(-b1, q, l) - (b1 == 0 and q != 0)\n\n    # Adjust for the middle term if b1 is within bounds and not bad\n    middle_term = 1 if abs(b1) <= l and b1 not in bad_set else 0\n\n    total_count = forward_count + backward_count + middle_term\n\n    return total_count if q != 1 and q != -1 else 'inf'\n\nb1, q, l, m = map(int, input().split())\nbad = list(map(int, input().split()))\n\nprint(solve(b1, q, l, m, bad))"}
{"solution": "import sys\n\ndef find_frame(n, m, screen):\n    top, bottom, left, right = None, None, None, None\n\n    # Find top, bottom, left, right boundaries of the white pixels\n    for i in range(n):\n        if 'w' in screen[i]:\n            if top is None:\n                top = i\n            bottom = i\n            for j, char in enumerate(screen[i]):\n                if char == 'w':\n                    if left is None or j < left:\n                        left = j\n                    if right is None or j > right:\n                        right = j\n\n    if top is None or left is None:\n        return -1\n\n    # Calculate the side length of the smallest square frame\n    side_length = min(bottom - top + 1, right - left + 1)\n\n    # Draw the frame\n    result = []\n    for i in range(n):\n        row = ''\n        for j in range(m):\n            if (top <= i <= top + side_length - 1 and left <= j <= left + side_length - 1 and\n                    (i == top or i == top + side_length - 1 or j == left or j == left + side_length - 1)):\n                row += '+'\n            else:\n                row += screen[i][j]\n        result.append(row)\n\n    return '\\n'.join(result)\n\n# Reading input\nn, m = map(int, input().split())\nscreen = [input() for _ in range(n)]\n\n# Processing and printing the result\nprint(find_frame(n, m, screen))"}
{"solution": "def solve(n, a, b):\n    if a == b:\n        if n % a == 0:\n            return \"YES\\n{} 0\".format(n // a)\n        else:\n            return \"NO\"\n    \n    for x in range(n // a + 1):\n        y = (n - a * x) / b\n        if y.is_integer() and y >= 0:\n            return \"YES\\n{} {}\".format(x, int(y))\n    return \"NO\"\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = int(input())\n    b = int(input())\n    print(solve(n, a, b))"}
{"solution": "def number_to_words(n):\n    if n == 0:\n        return \"zero\"\n    under_20 = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n                \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    \n    if n < 20:\n        return under_20[n]\n    elif n < 100:\n        if n % 10 == 0:\n            return tens[n // 10]\n        else:\n            return tens[n // 10] + \"-\" + under_20[n % 10]\n\nn = int(input())\nprint(number_to_words(n))"}
{"solution": "def max_elements_to_erase(n, a):\n    min_val, max_val = a[0], a[-1]\n    max_erased = min(n, max_val - min_val + 1 - n)\n    for i in range(n):\n        for j in range(i, n):\n            sub_min, sub_max = a[i], a[j]\n            erased = (sub_max - sub_min + 1) - (j - i + 1)\n            max_erased = max(max_erased, erased + n - (j - i + 1))\n    return max_erased - n if max_erased > n else 0\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(max_elements_to_erase(n, a))"}
{"solution": "def find_equator_day():\n    n = int(input())\n    problems = list(map(int, input().split()))\n    \n    total_problems = sum(problems)\n    solved = 0\n    \n    for i in range(n):\n        solved += problems[i]\n        if solved * 2 >= total_problems:\n            return i + 1\n\nprint(find_equator_day())"}
{"solution": "from heapq import heappush, heappop\nimport sys\n\ndef solve():\n    N = int(input())\n    board = [list(map(int, input().split())) for _ in range(N)]\n    \n    # Helper function to calculate Manhattan distance\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n    \n    # Helper function to check if a move is within the board's boundaries\n    def in_bounds(x, y):\n        return 0 <= x < N and 0 <= y < N\n    \n    # Generate possible moves for each piece\n    knight_moves = [(dx, dy) for dx, dy in ((2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)) if in_bounds(0 + dx, 0 + dy)]\n    bishop_moves = []\n    for dx in range(-N, N):\n        for dy in range(-N, N):\n            if dx != 0 and dy != 0 and abs(dx) == abs(dy):\n                bishop_moves.append((dx, dy))\n    rook_moves = []\n    for dx in range(-N, N):\n        if dx != 0:\n            rook_moves.append((dx, 0))\n            rook_moves.append((0, dx))\n    \n    # Mapping of pieces to their respective moves\n    moves = {'knight': knight_moves, 'bishop': bishop_moves, 'rook': rook_moves}\n    \n    # Priority queue for A* search\n    pq = []\n    # Add initial state (starting at 1 with any piece)\n    for piece in moves:\n        heappush(pq, (0, 0, -1, board[0][0] - 1, 0, piece))\n    \n    # Visited set to avoid rechecking states\n    visited = set()\n    \n    while pq:\n        cost, piece_changes, prev_piece, curr_val, x, piece = heappop(pq)\n        \n        # If we've already visited this state, skip it\n        if (curr_val, x, piece) in visited:\n            continue\n        visited.add((curr_val, x, piece))\n        \n        # If we're at the last value, return the result\n        if curr_val == N * N - 1:\n            return cost, piece_changes\n        \n        # Find the next value's position\n        next_val = curr_val + 1\n        next_x, next_y = divmod(next_val, N), next_val // N\n        \n        # Try moving with the current piece\n        for dx, dy in moves[piece]:\n            nx, ny = x + dx, y + dy\n            if in_bounds(nx, ny) and board[nx][ny] == next_val + 1:\n                heappush(pq, (cost + 1, piece_changes, piece, next_val, nx, piece))\n                \n        # Try changing to another piece\n        for new_piece in ('knight', 'bishop', 'rook'):\n            if new_piece != piece:\n                heappush(pq, (cost + manhattan_distance(x, y, next_x, next_y) + 1, piece_changes + 1, piece, next_val, next_x, new_piece))\n    \n    # If no solution is found (which shouldn't happen given the constraints)\n    return -1, -1\n\n# Read input and call solve function\nN = int(input())\nboard = [list(map(int, input().split())) for _ in range(N)]\nresult = solve()\n\n# Output the result\nprint(*result)"}
{"solution": "def min_time_to_reach(n, m, k, a, b):\n    def get_coords(apart):\n        apart -= 1\n        apt = apart % (m * k)\n        flr = (apart - apt) // (m * k)\n        fl = apt // k\n        rm = apt % k\n        return [flr, fl, rm]\n\n    def travel_time(f1, f2, use_elevator):\n        if use_elevator:\n            return 10 + abs(f1 - f2)\n        else:\n            return 5 * abs(f1 - f2)\n\n    edw = get_coords(a)\n    nat = get_coords(b)\n\n    time = float('inf')\n    for use_elevator in [True, False]:\n        # Same floor\n        t = travel_time(edw[1], nat[1], use_elevator)\n        if edw[0] == nat[0]:\n            time = min(time, t)\n        else:\n            # Clockwise\n            t += 15 * min(abs(edw[0] - nat[0]), n - abs(edw[0] - nat[0]))\n            time = min(time, t)\n            # Anti-clockwise\n            t = travel_time(edw[1], nat[1], use_elevator)\n            t += 15 * min(n - abs(edw[0] - nat[0]), abs(edw[0] - nat[0]))\n            time = min(time, t)\n\n    return time\n\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\nprint(min_time_to_reach(n, m, k, a, b))"}
{"solution": "def can_form_divisible_by_64(binary_str):\n    # Check if the string can form a number divisible by 64 after removals\n    # A number is divisible by 64 if the last 6 digits form a number divisible by 64\n    # Remove all trailing zeros as they do not affect divisibility by 64\n    while binary_str.endswith('0'):\n        binary_str = binary_str[:-1]\n\n    # Check substrings of the last 6 bits\n    for i in range(len(binary_str) - 6, len(binary_str)):\n        if i < 0:\n            continue\n        if int(binary_str[i:i+6], 2) % 64 == 0:\n            return \"yes\"\n    return \"no\"\n\n# Read input\nbinary_str = input().strip()\n\n# Process and print output\nprint(can_form_divisible_by_64(binary_str))"}
{"solution": "from collections import Counter\n\ndef next_char(c):\n    return 'a' if c == 'z' else chr(ord(c) + 1)\n\ndef solve(s):\n    char_count = Counter(s)\n    result = []\n    used_chars = set()\n    \n    for char in 'abcdefghijklmnopqrstuvwxyz':\n        if char not in char_count:\n            return \"-1\"\n        while char_count[char] > 0:\n            if char not in used_chars:\n                result.append(char)\n                used_chars.add(char)\n            char_count[char] -= 1\n            next_c = next_char(char)\n            while next_c in used_chars:\n                next_c = next_char(next_c)\n            if ord(next_c) - ord(char) > 1:\n                return \"-1\"\n            char_count[next_c] += 1\n    \n    # Fill remaining characters\n    for char in sorted(char_count.keys(), reverse=True):\n        result.extend([char] * char_count[char])\n    \n    return ''.join(result)\n\ns = input().strip()\nprint(solve(s))"}
{"solution": "import math\n\ndef max_expected_fish():\n    n, m, r, k = map(int, input().split())\n    total_cells = (n - r + 1) * (m - r + 1)\n    \n    # Calculate the maximum number of fish that can fit within the scoop-net\n    max_fish_in_scoop = min(k, r * r)\n    \n    # Calculate the maximum possible expected number of caught fishes\n    # The strategy is to place the fish in a way that maximizes overlap with the scoop-net\n    # This is done by placing them in a grid of r x r size if possible\n    # Otherwise, place them in a way that spreads out evenly\n    if k <= r * r:\n        # If we can fit all fish within a scoop-net, the expected value is simply the number of fish\n        expected_value = max_fish_in_scoop\n    else:\n        # If we have more fish than can fit in a scoop-net, distribute them evenly\n        # Calculate the number of full scoop-nets that can fit on the pond\n        full_scoops = min((n - r + 1) * (m - r + 1), k // (r * r))\n        \n        # Calculate the remaining fish that don't fit in a full scoop-net\n        remaining_fish = k % (r * r)\n        \n        # Calculate the expected value for the remaining fish\n        # The remaining fish will be distributed over the entire pond\n        # Calculate the number of cells where these fish can be placed\n        remaining_cells = n * m - full_scoops * r * r\n        \n        # Calculate the probability of catching a fish in each cell\n        prob_catch = (full_scoops * r * r + remaining_fish) / (n * m)\n        \n        # Calculate the expected number of fish caught\n        expected_value = full_scoops * r * r + prob_catch * total_cells * remaining_fish\n    \n    return expected_value / total_cells\n\nprint(max_expected_fish())"}
{"solution": "def max_product_array():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    all_negative = True\n    non_positive_count = 0\n    min_positive = float('inf')\n    max_negative = float('-inf')\n\n    for num in a:\n        if num > 0:\n            min_positive = min(min_positive, num)\n        elif num <= 0:\n            non_positive_count += 1\n            max_negative = max(max_negative, num)\n            all_negative = False\n\n    if all_negative or (non_positive_count == n and n % 2 == 1):\n        # If all are negative or odd count of non-positive with all negatives\n        for i in range(n):\n            a[i] = -a[i] - 1\n    else:\n        # Convert all positives and even count of negatives\n        for i in range(n):\n            if a[i] > 0 or (a[i] < 0 and non_positive_count % 2 == 0):\n                a[i] = -a[i] - 1\n            if a[i] == min_positive:\n                a[i] = -a[i] - 1\n\n    print(*a)\n\nmax_product_array()"}
{"solution": "import math\n\ndef find_kth_divisor(n, k):\n    divisors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n\n    divisors.sort()\n\n    if len(divisors) < k:\n        return -1\n    else:\n        return divisors[k - 1]\n\nn, k = map(int, input().split())\nprint(find_kth_divisor(n, k))"}
{"solution": "def can_build_all_numbers_up_to_x(cubes_faces):\n    from collections import Counter\n    n = len(cubes_faces)\n    face_counts = [Counter(cube) for cube in cubes_faces]\n    one_count = sum(count[1] for count in face_counts)\n    \n    if one_count == 0:\n        return 0\n    \n    usable_digits = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n    unusable_cubes = [cube for cube in cubes_faces if set(cube) - usable_digits]\n    usable_cubes = [cube for cube in cubes_faces if cube not in unusable_cubes]\n    \n    if not usable_cubes:\n        return 0\n    \n    eight_count = sum(8 in cube for cube in usable_cubes)\n    zero_count = sum(0 in cube for cube in usable_cubes)\n    \n    result = 1\n    while True:\n        current = str(result)\n        digit_counts = Counter(current)\n        if digit_counts[1] > one_count:\n            break\n        \n        if '8' in current and digit_counts[8] > eight_count:\n            break\n        \n        if '0' in current and digit_counts[0] > zero_count:\n            break\n        \n        if any(digit_counts[digit] > sum(digit in cube for cube in usable_cubes) for digit in map(int, current)):\n            break\n        \n        result += 1\n    \n    return result - 1\n\n# Input reading\nn = int(input())\ncubes_faces = [list(map(int, input().split())) for _ in range(n)]\n\n# Output\nprint(can_build_all_numbers_up_to_x(cubes_faces))"}
{"solution": "def k_rounding(n, k):\n    if k == 0:\n        return n\n    power_of_five = 0\n    power_of_two = 0\n    temp_n = n\n    while temp_n % 5 == 0:\n        power_of_five += 1\n        temp_n //= 5\n    temp_n = n\n    while temp_n % 2 == 0:\n        power_of_two += 1\n        temp_n //= 2\n    required_zeros = max(power_of_five, power_of_two) + k\n    result = n * (10 ** (required_zeros - max(power_of_five, power_of_two)))\n    return result\n\nn, k = map(int, input().split())\nprint(k_rounding(n, k))"}
{"solution": "def solve(A):\n    n, m = len(A), len(A[0])\n    operations = []\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1:\n                operations.append((i + 1, j + 1))\n                for x in range(i, i + 2):\n                    for y in range(j, j + 2):\n                        A[x][y] = 0\n    # Check if there's any 1 left in the last row or column\n    for i in range(n):\n        if A[i][-1] == 1:\n            return [-1]\n    for j in range(m):\n        if A[-1][j] == 1:\n            return [-1]\n    return operations\n\n# Read input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve and print output\nresult = solve(A)\nif result == [-1]:\n    print(-1)\nelse:\n    print(len(result))\n    for op in result:\n        print(*op)"}
{"solution": "from math import gcd\nr, s, p = map(int,input().split())\ntot = r+s+p\ndef prob(x,y):\n    g = gcd(x,y)\n    return (x//g,y//g)\n\ndef solve(a,b,c):\n    x1,y1 = prob(a,c)\n    x2,y2 = prob(b,c)\n    return (y1+x1)*(y2+x2)-x1*y2,y1*x2*(y2+x2)\n\nn,d = solve(r,s,p)\nprint(f'{n/d} 0 {1-n/d}' if p==0 else f'0 {n/d} {1-n/d}' if r==0 else f'{1-(n/d)} {n/d} 0' if s==0 else f'{n/d} {(solve(s,p,r)[0]/solve(s,p,r)[1])} {(solve(r,p,s)[0]/solve(r,p,s)[1])}')"}
{"solution": "def calculate_meeting_time(sonya_start, sonya_end, filya_start, filya_end, prink_time):\n   \u5171\u540c\u65f6\u95f4\u5f00\u59cb = max(sonya_start, filya_start)\n    \u5171\u540c\u65f6\u95f4\u7ed3\u675f = min(sonya_end, filya_end)\n\n    if \u5171\u540c\u65f6\u95f4\u5f00\u59cb >= \u5171\u540c\u65f6\u95f4\u7ed3\u675f:\n        return 0\n\n    if \u5171\u540c\u65f6\u95f4\u5f00\u59cb < prink_time < \u5171\u540c\u65f6\u95f4\u7ed3\u675f:\n        \u5171\u540c\u65f6\u95f4\u7ed3\u675f = prink_time\n\n    return \u5171\u540c\u65f6\u95f4\u7ed3\u675f - \u5171\u540c\u65f6\u95f4\u5f00\u59cb\n\nl_1, r_1, l_2, r_2, k = map(int, input().split())\nprint(calculate_meeting_time(l_1, r_1, l_2, r_2, k))"}
{"solution": "from typing import List\nimport bisect\n\ndef cross_product(p1: List[int], p2: List[int]) -> int:\n    return p1[0] * p2[1] - p1[1] * p2[0]\n\ndef solve(N: int, M: int, ABC: List[List[int]], DEF: List[List[int]]) -> None:\n    AB = []\n    for a, b, c in ABC:\n        AB.append([a, 1, c])\n        AB.append([b, -1, c])\n    AB.sort()\n    \n    CD = []\n    for d, e, f in DEF:\n        CD.append([d, 1, e, f])\n        CD.append([e, -1, f, e])\n    CD.sort()\n    \n    x_list = [0]\n    y_list = [0]\n    for ab in AB:\n        if ab[1] > 0:\n            x_list.append(ab[0])\n        else:\n            x_list.pop()\n    for cd in CD:\n        if cd[1] > 0:\n            y_list.append(cd[2])\n        else:\n            y_list.pop()\n    \n    x_list.sort()\n    y_list.sort()\n    \n    area = 0\n    for i in range(1, len(x_list)):\n        for j in range(1, len(y_list)):\n            x1, x2 = x_list[i-1], x_list[i]\n            y1, y2 = y_list[j-1], y_list[j]\n            \n            flag = True\n            for ab in AB:\n                if ab[1] > 0 and ab[0] == x1:\n                    index = bisect.bisect_left(CD, [ab[2], 0, 0])\n                    if index < len(CD) and CD[index][2] <= y2 and CD[index][3] >= y1:\n                        flag = False\n                        break\n            if flag:\n                for ab in AB:\n                    if ab[1] < 0 and ab[0] == x2:\n                        index = bisect.bisect_left(CD, [ab[2], 0, 0])\n                        if index < len(CD) and CD[index][2] <= y2 and CD[index][3] >= y1:\n                            flag = False\n                            break\n            if flag:\n                for cd in CD:\n                    if cd[1] > 0 and cd[2] == y1:\n                        index = bisect.bisect_left(AB, [cd[0], 0, 0])\n                        if index < len(AB) and AB[index][2] <= x2 and AB[index][2] >= x1:\n                            flag = False\n                            break\n            if flag:\n                for cd in CD:\n                    if cd[1] < 0 and cd[3] == y2:\n                        index = bisect.bisect_left(AB, [cd[0], 0, 0])\n                        if index < len(AB) and AB[index][2] <= x2 and AB[index][2] >= x1:\n                            flag = False\n                            break\n            if flag:\n                area += (x2 - x1) * (y2 - y1)\n    \n    if area == 0:\n        print('INF')\n    else:\n        print(area)"}
{"solution": "def will_pineapple_bark(t, s, x):\n    if x == t:\n        return \"YES\"\n    elif x > t:\n        adjusted_x = x - t\n        if adjusted_x % (s + 1) == 0 or adjusted_x % (s + 1) == 1:\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        return \"NO\"\n\n# Reading input\nt, s, x = map(int, input().split())\n\n# Processing and printing output\nprint(will_pineapple_bark(t, s, x))"}
{"solution": "def find_nested_segments():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n = data[0]\n    data = data[1:]\n    segments = [(data[2 * i], data[2 * i + 1]) for i in range(n)]\n\n    segments_with_index = [(segments[i], i + 1) for i in range(n)]\n    segments_with_index.sort(key=lambda x: (x[0][0], x[0][1]))\n\n    ans = [-1, -1]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if segments_with_index[j][0][0] <= segments_with_index[i][0][0] and segments_with_index[j][0][1] >= segments_with_index[i][0][1]:\n                ans = [segments_with_index[i][1], segments_with_index[j][1]]\n                break\n        if ans != [-1, -1]:\n            break\n\n    print(' '.join(map(str, ans)))\n\nfind_nested_segments()"}
{"solution": "def decode_genome(n, s):\n    \"\"\"\n    Decodes the genome by replacing unrecognized nucleotides with 'A', 'C', 'G', or 'T'\n    so that the number of each type of nucleotide becomes equal.\n    \"\"\"\n    from collections import Counter\n\n    nucleotides = {'A', 'C', 'G', 'T'}\n    cnt = Counter(s)\n    question_marks = cnt['?']\n    \n    if (n + question_marks) % 4 != 0:\n        return \"===\"\n\n    required_each = (n + question_marks) // 4\n    \n    for nt in nucleotides:\n        if cnt[nt] > required_each:\n            return \"===\"\n    \n    for i, ch in enumerate(s):\n        if ch == '?':\n            for nt in 'ACGT':\n                if cnt[nt] < required_each:\n                    s = s[:i] + nt + s[i+1:]\n                    cnt[nt] += 1\n                    break\n    \n    return s\n\n# Example usage\nn = int(input())\ns = input()\nprint(decode_genome(n, s))"}
{"solution": "import itertools\n\ndef can_ilya_win(grid):\n    \"\"\"\n    Determines if Ilya can win the game by making a single turn.\n    \n    :param grid: List of strings representing the 4x4 tic-tac-toe board\n    :return: \"YES\" if Ilya can win with one move, \"NO\" otherwise\n    \"\"\"\n    # Check rows and columns\n    for i in range(4):\n        for combo in ('...x', '..x.', '.x..', 'x...', 'o...'):\n            s = ''.join(grid[i])\n            t = ''.join(grid[j][i] for j in range(4))\n            if combo in s or combo in t:\n                return \"YES\"\n    \n    # Check diagonals\n    diagonal1 = ''.join(grid[i][i] for i in range(4))\n    diagonal2 = ''.join(grid[3-i][i] for i in range(4))\n    for combo in ('...x', '..x.', '.x..', 'x...', 'o...'):\n        if combo in diagonal1 or combo in diagonal2:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\ngrid = [input() for _ in range(4)]\n\n# Output result\nprint(can_ilya_win(grid))"}
{"solution": "def can_divide_after_move(n, arr):\n    total_sum = sum(arr)\n    if total_sum % 2 != 0:\n        return \"NO\"\n    \n    target_sum = total_sum // 2\n    prefix_sum = 0\n    suffix_sum = 0\n    \n    for i in range(n):\n        suffix_sum = arr[i]\n        if prefix_sum + suffix_sum == target_sum:\n            if i > 0 and prefix_sum == target_sum or i < n - 1 and suffix_sum == target_sum:\n                return \"YES\"\n        else:\n            prefix_sum += arr[i]\n    \n    return \"NO\"\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Processing and printing output\nprint(can_divide_after_move(n, arr))"}
{"solution": "def can_recover_sequence(n, k, a, b):\n    a_sorted = sorted(a)\n    b_sorted = sorted(b, reverse=True)\n    \n    prev_value = 0\n    for i in range(n):\n        if a[i] == 0:\n            if i < n - 1 and b_sorted and b_sorted[-1] < a[i + 1]:\n                return \"No\"\n            a[i] = b_sorted.pop() if b_sorted else 0\n        if a[i] < prev_value:\n            return \"Yes\"\n        prev_value = a[i]\n    \n    return \"No\" if not b_sorted else \"Yes\"\n\n# Example usage\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(can_recover_sequence(n, k, a, b))"}
{"solution": "def can_make_happy(x, y, z, a, b, c):\n    # Check if Andrew can get enough green grapes\n    if a < x:\n        return \"NO\"\n    \n    # After Andrew takes his share\n    a -= x\n    \n    # Check if Dmitry can get enough non-black grapes\n    if b < y:\n        if a + b < y:\n            return \"NO\"\n        else:\n            b = 0\n            a -= (y - b)\n    else:\n        b -= y\n    \n    # Check if Michal can get enough grapes\n    if a + b + c < z:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input values\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Determine if it's possible to make everyone happy\nresult = can_make_happy(x, y, z, a, b, c)\n\n# Output result\nprint(result)"}
{"solution": "def check_accident(lights):\n    for i in range(4):\n        if lights[i][3] == 1:  # Pedestrian light is green\n            for j in [0, 1, 2]:  # Check left, straight, right lights\n                if lights[i][j] == 1:\n                    return \"YES\"\n            opp_part = (i + 2) % 4\n            for j in [0, 1, 2]:\n                if lights[opp_part][j] == 1:\n                    return \"YES\"\n    return \"NO\"\n\nlights = []\nfor _ in range(4):\n    lights.append(list(map(int, input().split())))\n\nprint(check_accident(lights))"}
{"solution": "def is_unique_sequence(n, number):\n    # Mapping of digits to their possible alternatives based on finger movements\n    alternatives = {\n        '1': '1', '2': '25', '3': '36', '4': '48', '5': '258', \n        '6': '369', '7': '7', '8': '458', '9': '69', '0': '0'\n    }\n    \n    # Generate all possible numbers based on finger movements\n    possible_numbers = set([number])\n    for i in range(n):\n        new_possible_numbers = set()\n        for num in possible_numbers:\n            for j in range(n):\n                digit = num[j]\n                for alt in alternatives[digit]:\n                    new_num = num[:j] + alt + num[j+1:]\n                    new_possible_numbers.add(new_num)\n        possible_numbers = new_possible_numbers\n    \n    # Check if there is more than one unique number\n    return len(possible_numbers) == 1\n\n# Read input\nn = int(input())\nnumber = input()\n\n# Check and print result\nprint(\"YES\" if is_unique_sequence(n, number) else \"NO\")"}
{"solution": "import heapq\n\ndef max_products_sold():\n    n, f = map(int, input().split())\n    days = [list(map(int, input().split())) for _ in range(n)]\n\n    # Calculate potential sales for each day (max possible sales - original sales)\n    potential_sales = [(max(0, 2 * k - l) - max(0, k - l), max(0, k - l)) for k, l in days]\n    potential_sales.sort(reverse=True)\n\n    sold = sum(max(0, k - l) for k, l in days)\n    heap = []\n\n    for ps, s in potential_sales[:f]:\n        sold += ps\n        heapq.heappush(heap, s)\n\n    for ps, s in potential_sales[f:]:\n        if s < heap[0]:\n            sold -= heapq.heappop(heap)\n            sold += ps\n            heapq.heappush(heap, s)\n\n    print(sold)\n\nmax_products_sold()"}
{"solution": "import sys\n\ndef max_messiness(n, k):\n    # Calculate the maximum messiness based on the number of cows and the time available for swaps\n    return min(n * (n - 1) // 2, n * k)\n\n# Reading input\ninput_data = sys.stdin.read().split()\nn, k = map(int, input_data)\n\n# Calculating and printing the result\nprint(max_messiness(n, k))"}
{"solution": "def min_coins_gift(N, M, K, L):\n    if N - K < L:\n        return -1\n    elif N < M:\n        return -1\n    else:\n        return max((L + M - 1) // M, (N + M - K - 1) // M)\n\nN, M, K, L = map(int, input().split())\nprint(min_coins_gift(N, M, K, L))"}
{"solution": "def min_paintings(n, m, grid):\n    top, bottom, left, right = -1, -1, m, -1\n    black_count = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                black_count += 1\n                top = min(top, i)\n                bottom = max(bottom, i)\n                left = min(left, j)\n                right = max(right, j)\n\n    if top == -1:\n        return 1 if black_count == 0 else -1\n\n    side = right - left\n    if side < 0:\n        return -1\n\n    total_paintings = (side + 1) ** 2\n    additional_paintings = total_paintings - black_count\n\n    if bottom - top != side:\n        return -1\n\n    for i in range(top, bottom + 1):\n        if grid[i][left] == 'W' or grid[i][right] == 'W':\n            return -1\n\n    for j in range(left + 1, right):\n        if grid[top][j] == 'W' or grid[bottom][j] == 'W':\n            return -1\n\n    return additional_paintings if additional_paintings >= 0 else -1\n\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\nprint(min_paintings(n, m, grid))"}
{"solution": "def check_stone_piles(x, y):\n    changes = []\n    for xi, yi in zip(x, y):\n        if xi > yi:\n            changes.append((xi - yi, 'remove'))\n        elif yi > xi:\n            changes.append((yi - xi, 'add'))\n\n    changes.sort()\n    deficit = 0\n    for change in changes:\n        if change[1] == 'remove':\n            if deficit > change[0]:\n                return \"No\"\n            deficit += change[0]\n        else:\n            if deficit > change[0]:\n                return \"No\"\n            deficit -= change[0]\n\n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    n = int(input())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n\n    print(check_stone_piles(x, y))"}
{"solution": "def min_pizza_diff(n, angles):\n    total_angle = sum(angles)\n    half_angle = total_angle / 2\n    dp = [0] * (n + 1)\n    angle_sum = 0\n    \n    for i in range(n):\n        angle_sum += angles[i]\n        for j in range(i, -1, -1):\n            if angle_sum > half_angle:\n                break\n            dp[j + 1] = dp[j] + angles[i]\n            if dp[j + 1] > half_angle:\n                dp[j + 1] = half_angle\n\n    closest = min(dp, key=lambda x: abs(x - half_angle))\n    return int(abs(total_angle - 2 * closest))\n\n# Reading input\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(min_pizza_diff(n, angles))"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_pow(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef solve(n, m):\n    if n > m:\n        return 0\n    elif n == m or n == 1:\n        return mod_pow(2, m) - 1\n    else:\n        return (mod_pow(2, m) - 1 - m) % MOD\n\nn, m = map(int, input().split())\nprint(solve(n, m))"}
{"solution": "def find_pythagorean_triple(n):\n    if n == 1:\n        return [-1]\n    if n % 2 == 1:\n        m = (n ** 2 - 1) // 2\n        k = (n ** 2 + 1) // 2\n    else:\n        m = (n ** 2) // 4 - 1\n        k = (n ** 2) // 4 + 1\n    return [m, k]\n\nn = int(input())\nresult = find_pythagorean_triple(n)\nprint(' '.join(map(str, result)))"}
{"solution": "def check_distinct_remainders(n, k):\n    seen = set()\n    for i in range(1, min(k + 1, n + 1)):\n        remainder = n % i\n        if remainder in seen:\n            return \"No\"\n        seen.add(remainder)\n    return \"Yes\"\n\n# Read input\nn, k = map(int, input().split())\n\n# Check and print result\nprint(check_distinct_remainders(n, k))"}
{"solution": "def compare_large_numbers():\n    a = raw_input().strip()\n    b = raw_input().strip()\n\n    # Remove leading zeros for comparison\n    a = a.lstrip('0')\n    b = b.lstrip('0')\n\n    # If both strings become empty after removing leading zeros, they are equal\n    if not a and not b:\n        print('=')\n        return\n\n    # Directly compare strings if they are not empty\n    if a > b:\n        print('>')\n    elif a < b:\n        print('<')\n    else:\n        print('=')\n\ncompare_large_numbers()"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_pow(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef solve(n, p, c):\n    # Counting fixed colors\n    fixed_black = sum(1 for color in c if color == 0)\n    fixed_white = sum(1 for color in c if color == 1)\n    \n    # Counting free colors\n    free = n - fixed_black - fixed_white\n    \n    # Total ways to connect all nodes\n    total_ways = mod_pow(2, (n * (n - 1)) // 2)\n    \n    # Ways to choose free colors\n    free_ways = mod_pow(2, free)\n    \n    # Calculating parity\n    fixed_odd = (fixed_black * fixed_white) % 2\n    if p == 1:\n        # If odd parity is required\n        if fixed_odd == 1:\n            # All combinations work\n            return (total_ways * free_ways) % MOD\n        else:\n            # Splitting free colors into even and odd\n            even_ways = mod_pow(2, free - 1)\n            return (total_ways * (free_ways - even_ways)) % MOD\n    else:\n        # If even parity is required\n        if fixed_odd == 0:\n            # All combinations work\n            return (total_ways * free_ways) % MOD\n        else:\n            # Splitting free colors into even and odd\n            even_ways = mod_pow(2, free - 1)\n            return (total_ways * even_ways) % MOD\n\n# Reading input\nn, p = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Solving and printing output\nprint(solve(n, p, c))"}
{"solution": "import sys\n\nn, a, b, c = map(int, sys.stdin.readline().split())\n\ncosts = [float('inf')] * 4\ncosts[1] = a\ncosts[2] = min(b, 2 * a)\ncosts[3] = min(c, a + b, 3 * a)\n\ntarget = 4 - (n % 4)\nif target == 4:\n    target = 0\n\nprint(min(costs[target], costs[(target + 1) % 4] + costs[3], costs[(target + 2) % 4] + costs[2], costs[(target + 3) % 4] + costs[1]) if target != 0 else 0)"}
{"solution": "from collections import defaultdict\n\ndef dfs(node, visited, recStack, graph):\n    visited[node] = True\n    recStack[node] = True\n\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            if dfs(neighbor, visited, recStack, graph):\n                return True\n        elif recStack[neighbor]:\n            return True\n\n    recStack[node] = False\n    return False\n\ndef isCyclic(graph, n):\n    visited = [False] * n\n    recStack = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if dfs(node, visited, recStack, graph):\n                return True\n    return False\n\ndef checkAcyclicAfterEdgeRemoval(graph, n, m):\n    hasCycle = isCyclic(graph, n)\n\n    if not hasCycle:\n        return \"YES\"\n\n    for i in range(m):\n        graph[i[0]].remove(i[1])\n        if not isCyclic(graph, n):\n            return \"YES\"\n        graph[i[0]].append(i[1])\n\n    return \"NO\"\n\ndef main():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    edges = []\n\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u - 1].append(v - 1)\n        edges.append((u - 1, v - 1))\n\n    print(checkAcyclicAfterEdgeRemoval(graph, n, m))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from typing import List\n\ndef min_coins_for_coverage(n: int, m: int, antennas: List[List[int]]) -> int:\n    \"\"\"\n    Calculates the minimum number of coins required to cover all positions from 1 to m with at least one antenna.\n    \n    :param n: Number of antennas.\n    :param m: Last position to be covered.\n    :param antennas: List of [position, scope] for each antenna.\n    :return: Minimum number of coins required.\n    \"\"\"\n    antennas.sort()\n    dp = [float('inf')] * (m + 1)\n    dp[0] = 0\n    for x, s in antennas:\n        left = max(0, x - s)\n        right = min(m, x + s)\n        for pos in range(right, left - 1, -1):\n            dp[pos] = min(dp[pos], dp[left] + (pos - (x + s)) ** 2)\n\n    return dp[m]\n\n# Function to read input and call the above function\ndef solve():\n    n, m = map(int, input().split())\n    antennas = [list(map(int, input().split())) for _ in range(n)]\n    print(min_coins_for_coverage(n, m, antennas))\n\nsolve()"}
{"solution": "def max_subset_weight(W, weights):\n    \"\"\"\n    Calculate the maximum possible weight of a good subset of items.\n    \"\"\"\n    # Initialize the result\n    result = 0\n    \n    # Iterate through each weight starting from the highest\n    for i in range(7, -1, -1):\n        # Calculate how much weight can be added without exceeding W\n        add_weight = min(W // (i + 1), weights[i])\n        # Update the result and reduce W accordingly\n        result += add_weight * (i + 1)\n        W -= add_weight * (i + 1)\n    \n    return result\n\n# Read input\nW = int(input())\nweights = list(map(int, input().split()))\n\n# Print the result\nprint(max_subset_weight(W, weights))"}
{"solution": "import heapq\n\ndef min_cost_lemonade(n, L, costs):\n    \"\"\"\n    Calculate the minimum cost to buy at least L liters of lemonade.\n    \n    :param n: Number of types of bottles available.\n    :param L: Required amount of lemonade in liters.\n    :param costs: List of costs for each type of bottle.\n    :return: Minimum cost to buy at least L liters of lemonade.\n    \"\"\"\n    volumes = [2**i - 1 for i in range(1, n + 1)]\n    cost_heap = [(cost, volume) for cost, volume in zip(costs, volumes)]\n    heapq.heapify(cost_heap)\n\n    total_cost = 0\n    while L > 0:\n        cost, volume = heapq.heappop(cost_heap)\n        if volume <= L:\n            total_cost += cost\n            L -= volume\n        else:\n            # Calculate the cost for the exact amount needed\n            remaining_volume = volume - (volume // 2)\n            exact_cost = cost * (L // remaining_volume) + costs[volumes.index(remaining_volume)] * (L % remaining_volume != 0)\n            total_cost += exact_cost\n            break\n\n    return total_cost\n\n# Example usage\nif __name__ == \"__main__\":\n    n, L = map(int, input().split())\n    costs = list(map(int, input().split()))\n    print(min_cost_lemonade(n, L, costs))"}
{"solution": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\ndef find_max_mex(arr):\n    n = len(arr)\n    arr.sort()\n    \n    mex = 1\n    count = defaultdict(int)\n\n    for num in arr:\n        if num >= mex:\n            count[num] += 1\n            if count[mex] > 0:\n                count[mex] -= 1\n            else:\n                mex += 1\n\n    return mex\n\nn = int(input())\na = list(map(int, input().split()))\n\nprint(find_max_mex(a))"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(map(int, digits))\n    segment_sum = 0\n    segments = []\n\n    for digit in digits:\n        segment_sum += int(digit)\n        if segment_sum * (n - len(segments)) == total_sum:\n            segments.append(segment_sum)\n            segment_sum = 0\n\n    return \"YES\" if len(segments) > 1 else \"NO\"\n\n# Read input\nn = int(input())\ndigits = input()\n\n# Print result\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_chars = set(username)\n    if len(distinct_chars) % 2 == 0:\n        print(\"IGNORE HIM!\")\n    else:\n        print(\"CHAT WITH HER!\")\n\nusername = input().strip()\ndetermine_gender(username)"}
{"solution": "def max_diff_after_closures(n, k, tabs):\n    from itertools import accumulate\n\n    max_diff = 0\n    acc_tabs = list(accumulate(tabs, initial=0))\n\n    for start in range(1, n + 1):\n        diff = acc_tabs[start - 1]\n        if start + (n - start) // k * k > n:\n            diff -= acc_tabs[n]\n            diff += acc_tabs[start - 1 + (n - start) // k * k]\n        else:\n            diff -= acc_tabs[start - 1 + (n - start) // k * k]\n\n        max_diff = max(max_diff, abs(diff))\n\n    return max_diff\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    tabs = list(map(int, input().split()))\n    print(max_diff_after_closures(n, k, tabs))"}
{"solution": "def min_cost(n, c0, c1):\n    from math import sqrt\n    if c0 == c1:\n        return n * c0 * (sqrt(2*n)-1)\n    elif c0 > c1:\n        c0, c1 = c1, c0\n    if c0 == 0:\n        return (n-1)*c1\n    k = (sqrt((n-1)*(c0*c1+c0**2)+c0**2)-c0)/c1\n    m = k*(k+1)//2\n    s = k*(c0+c1)+(c0+c1*(m-k))*(m-k+1)//2\n    return s + min_cost(n-m-1, c0, c1)\n\nn, c0, c1 = map(int, input().split())\nprint(min_cost(n, c0, c1))"}
{"solution": "def check_meet(n, a, x, b, y):\n    daniel_path = set()\n    current_d = a\n    while current_d != x:\n        daniel_path.add(current_d)\n        current_d += 1\n        if current_d > n:\n            current_d = 1\n    \n    current_v = b\n    while current_v != y:\n        if current_v in daniel_path:\n            return \"YES\"\n        current_v -= 1\n        if current_v < 1:\n            current_v = n\n    \n    return \"NO\" if x not in daniel_path else \"YES\"\n\n# Function to take input and call the above function\ndef solve():\n    n, a, x, b, y = map(int, input().split())\n    print(check_meet(n, a, x, b, y))\n\nsolve()"}
{"solution": "import math\n\ndef is_unlucky_year(x, y, n):\n    max_power = int(math.log(n, max(x, y))) + 1\n    for a in range(max_power + 1):\n        for b in range(max_power + 1):\n            if x**a + y**b == n:\n                return True\n    return False\n\ndef max_golden_age_length(x, y, l, r):\n    golden_age_start = -1\n    golden_age_length = 0\n    \n    for year in range(l, r + 1):\n        if not is_unlucky_year(x, y, year):\n            if golden_age_start == -1:\n                golden_age_start = year\n        else:\n            if golden_age_start != -1:\n                current_length = year - golden_age_start\n                golden_age_length = max(golden_age_length, current_length)\n                golden_age_start = -1\n    \n    if golden_age_start != -1:\n        current_length = r + 1 - golden_age_start\n        golden_age_length = max(golden_age_length, current_length)\n    \n    return golden_age_length\n\nx, y, l, r = map(int, input().split())\nprint(max_golden_age_length(x, y, l, r))"}
{"solution": "def min_tax(burles):\n    if burles % 2 == 0:\n        return burles // 2\n    else:\n        return burles // 2 + 1\n\nincome = int(input())\nprint(min_tax(income))"}
{"solution": "def is_vowel(ch):\n    return ch in 'aeiou'\n\ndef fix_typo(word):\n    i = 0\n    result = []\n    while i < len(word):\n        j = i + 1\n        while j < len(word) and not is_vowel(word[j]) and word[j] == word[i]:\n            j += 1\n        if j - i >= 3:\n            result.append(word[i:j])\n            i = j\n        else:\n            k = j\n            while k < len(word) and not is_vowel(word[k]) and word[k] != word[i]:\n                k += 1\n            if k - i >= 3:\n                result.append(word[i:j])\n                i = j\n            else:\n                result.append(word[i:k])\n                i = k\n    return ' '.join(result)\n\nword = input().strip()\nprint(fix_typo(word))"}
{"solution": "import sys\nfrom typing import List, Tuple\n\ndef read_ints() -> List[int]:\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef read_single_int() -> int:\n    return int(sys.stdin.readline().strip())\n\nclass PotionPreparation:\n    def __init__(self, n: int, m: int, k: int, x: int, s: int, a: List[int], b: List[int], c: List[int], d: List[int]):\n        self.n = n\n        self.m = m\n        self.k = k\n        self.x = x\n        self.s = s\n        self.a = a\n        self.b = b\n        self.c = c\n        self.d = d\n        self.first_type_spells = list(zip(a, b))\n        self.second_type_spells = list(zip(c, d))\n\n    def find_min_time(self) -> int:\n        self.first_type_spells.sort(key=lambda x: x[0])\n        self.second_type_spells.sort(key=lambda x: x[1])\n\n        best_spell = (self.x, 0)\n        for spell in self.first_type_spells:\n            if spell[0] * self.n < best_spell[0] * self.n:\n                best_spell = spell\n\n        max_c = [0] * (self.s + 1)\n        for c, d in self.second_type_spells:\n            for j in range(self.s, d - 1, -1):\n                max_c[j] = max(max_c[j], max_c[j - d] + c)\n\n        result = self.x * self.n\n        for cost, time in self.first_type_spells:\n            remaining_cost = self.s - cost\n            remaining_potions = self.n - max_c[remaining_cost]\n            result = min(result, time * remaining_potions + (self.n - remaining_potions))\n\n        return result\n\ndef solve():\n    n, m, k = read_ints()\n    x, s = read_ints()\n    a = read_ints()\n    b = read_ints()\n    c = read_ints()\n    d = read_ints()\n\n    potion_prep = PotionPreparation(n, m, k, x, s, a, b, c, d)\n    print(potion_prep.find_min_time())\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def max_points(n, k, M, t):\n    t.sort()\n    prefix_sums = [0]\n    for time in t:\n        prefix_sums.append(prefix_sums[-1] + time)\n    \n    full_tasks = 0\n    while full_tasks < n and prefix_sums[k] <= M:\n        M -= prefix_sums[k]\n        full_tasks += 1\n    \n    points = full_tasks * k + full_tasks\n    \n    i = 0\n    while M >= t[i] and i < k:\n        M -= t[i]\n        points += 1\n        i += 1\n    \n    return points\n\n# Reading input\nn, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Printing output\nprint(max_points(n, k, M, t))"}
{"solution": "MOD = 998244353\n\nfac = [1]\nfor i in range(1, 10**6 + 1):\n    fac.append(fac[-1] * i % MOD)\n\nrfac = [pow(fac[-1], MOD - 2, MOD)]\nfor i in range(1, 10**6 + 1)[::-1]:\n    rfac.append(rfac[-1] * i % MOD)\nrfac.reverse()\n\ndef C(n, k):\n    return fac[n] * rfac[k] * rfac[n - k] % MOD\n\ndef solve(n):\n    if n == 1:\n        return 1\n    if n % 2 == 1:\n        return 0\n    m = n // 2\n    return C(m - 1, m - 1) * pow(2, m, MOD) % MOD\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def find_lara_position(n, m, k):\n    cycle_length = 2 * (m + n - 2)\n    adjusted_k = k % cycle_length\n    \n    if adjusted_k < m:\n        return (1 + adjusted_k // m, 1 + adjusted_k % m)\n    else:\n        adjusted_k -= m\n        if adjusted_k < n - 1:\n            return (n - adjusted_k, m)\n        else:\n            adjusted_k -= (n - 1)\n            if adjusted_k < m - 1:\n                return (1, m - adjusted_k)\n            else:\n                return (adjusted_k - (m - 1), 1)\n\nn, m, k = map(int, input().split())\nrow, col = find_lara_position(n, m, k)\nprint(row, col)"}
{"solution": "import math\n\ndef find_pair(X):\n    for i in range(1, int(math.sqrt(X)) + 1, 1):\n        if X % i == 0:\n            return (i, X // i)\n    return (X, 1)\n\nX = int(input())\na, b = find_pair(X)\nprint(a, b)"}
{"solution": "def max_compote_fruits():\n    a = int(input())\n    b = int(input())\n    c = int(input())\n\n    min_lemons = 0\n    if c >= 4 and b >= 2:\n        min_lemons = min(a, b // 2, c // 4)\n\n    return 7 * min_lemons\n\nprint(max_compote_fruits())"}
{"solution": "def can_ensure_victory(n, ratings):\n    ratings.sort()\n    return 'YES' if ratings[-1] > ratings[n-1] else 'NO'\n\n# Reading input\nn = int(input())\nratings = list(map(int, input().split()))\n\n# Printing output\nprint(can_ensure_victory(n, ratings))"}
{"solution": "import math\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef make_coprime(arr):\n    n = len(arr)\n    insertions = 0\n    new_arr = []\n\n    for i in range(n - 1):\n        if gcd(arr[i], arr[i + 1]) > 1:\n            insertions += 1\n            new_arr.append(arr[i])\n            new_arr.append(1)  # Inserting 1 as it is co-prime with all numbers\n        else:\n            new_arr.append(arr[i])\n\n    new_arr.append(arr[-1])\n\n    return insertions, new_arr\n\nn = int(input())\na = list(map(int, input().split()))\n\ninsertions, new_arr = make_coprime(a)\n\nprint(insertions)\nprint(*new_arr)"}
{"solution": "def solve(n, k, arr):\n    total = sum(arr)\n    divisors = [i for i in range(1, int(total**0.5) + 1) if total % i == 0]\n    divisors.extend([total // i for i in divisors if i * i != total])\n    divisors.sort(reverse=True)\n    \n    for divisor in divisors:\n        mod_arr = sorted([a % divisor for a in arr])\n        left_sum = sum(mod_arr)\n        right_sum = 0\n        for i in range(n):\n            left_sum -= mod_arr[i]\n            if left_sum == divisor * (n - i - right_sum):\n                if right_sum <= k:\n                    return divisor\n                break\n            right_sum += divisor - mod_arr[i]\n\n    return 1\n\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\nprint(solve(n, k, arr))"}
{"solution": "def find_transformation(x):\n    operations = []\n    # Find the next power of 2 greater than or equal to x\n    next_power_of_2 = 1\n    while next_power_of_2 <= x:\n        next_power_of_2 <<= 1\n    target = next_power_of_2 - 1\n\n    # Apply Operation A\n    xor_mask = target ^ x\n    n = 0\n    while xor_mask > 0:\n        if xor_mask & 1:\n            operations.append(n)\n        xor_mask >>= 1\n        n += 1\n\n    # Calculate the number of Operation B needed\n    num_b_operations = (target - x) if len(operations) % 2 == 0 else (target - x + 1)\n\n    # Ensure total operations do not exceed 40\n    max_a_operations = 40 - num_b_operations\n    operations = operations[:max_a_operations]\n\n    # Prepare the output\n    result = [len(operations) + num_b_operations]\n    result.extend(operations)\n    return result\n\n# Read input\nx = int(input())\n\n# Output the result\nprint(*find_transformation(x))"}
{"solution": "# Import necessary library\nfrom math import ceil\n\ndef min_hours_to_water_garden(n, k, segments):\n    \"\"\"\n    Finds the minimum number of hours required to water the entire garden.\n    \"\"\"\n    # Find the maximum segment length that divides k without remainder\n    max_efficient_segment = max([length for length in segments if k % length == 0])\n    # Calculate and return the minimum hours needed\n    return ceil(k / max_efficient_segment)\n\n# Read input values\nn, k = map(int, input().split())\nsegments = list(map(int, input().split()))\n\n# Output the result\nprint(min_hours_to_water_garden(n, k, segments))"}
{"solution": "def can_grasshopper_reach(n, k, line):\n    start = line.find('G')\n    target = line.find('T')\n    step = k\n\n    if abs(target - start) % k != 0:\n        return \"NO\"\n\n    current = start\n    while current != target:\n        next_positions = [current + step, current - step]\n        valid_next_positions = [pos for pos in next_positions if 0 <= pos < n and line[pos] != '#']\n\n        if not valid_next_positions:\n            return \"NO\"\n\n        current = valid_next_positions[0]\n\n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\nline = input()\n\n# Print the result\nprint(can_grasshopper_reach(n, k, line))"}
{"solution": "from math import fabs\n\nEPS = 1e-8\n\ndef equals(a, b):\n    return fabs(a - b) <= EPS\n\ndef solve(y1, y2, yw, xb, yb, r):\n    k = (y2 - y1) / (yw - xb)\n    c = y1 - k * xb\n\n    xw = (yb - c) / k + r * (1 + k * k) / (k * k)\n\n    if equals(k * xw + c, yb + r):\n        return xw\n\n    return -1\n\nif __name__ == \"__main__\":\n    y1, y2, yw, xb, yb, r = map(int, input().split())\n    print(solve(y1, y2, yw, xb, yb, r))"}
{"solution": "def min_missed_meals(b, d, s):\n    total_meals = b + d + s\n    full_days = min(b, d, s)\n    remaining_meals = total_meals - 3 * full_days\n    missed_meals = 0\n    \n    if remaining_meals == 0:\n        return 0\n    elif remaining_meals == 1:\n        return 0\n    elif remaining_meals == 2:\n        return 1\n    else:\n        return 3 - remaining_meals\n\nb, d, s = map(int, input().split())\nprint(min_missed_meals(b, d, s))"}
{"solution": "from math import gcd\n\ndef get_position(val, x, y):\n    row = (val - 1) // y + 1\n    col = (val - 1) % y + 1\n    return row, col\n\ndef check_path(x, y, path):\n    for i in range(1, len(path)):\n        row1, col1 = get_position(path[i-1], x, y)\n        row2, col2 = get_position(path[i], x, y)\n        if abs(row2 - row1) + abs(col2 - col1) != 1:\n            return False\n    return True\n\ndef find_dimensions(n, path):\n    min_val = min(path)\n    max_val = max(path)\n    total_cells = max_val\n    if total_cells < n:\n        print(\"NO\")\n        return\n\n    x, y = divmod(total_cells, min_val)\n    if y == 0:\n        x -= 1\n\n    factors = []\n    for i in range(1, int(total_cells ** 0.5) + 1):\n        if total_cells % i == 0:\n            factors.append(i)\n            if i != total_cells // i:\n                factors.append(total_cells // i)\n\n    for factor in sorted(factors):\n        if factor >= n:\n            break\n        x, y = total_cells // factor, factor\n        if check_path(x, y, path):\n            print(\"YES\")\n            print(x, y)\n            return\n\n    print(\"NO\")\n\nn = int(input())\npath = list(map(int, input().split()))\nfind_dimensions(n, path)"}
{"solution": "def find_min_subseq(a, b):\n    n, m = len(a), len(b)\n    dp = [[-1] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = i\n\n    for j in range(1, m + 1):\n        dp[0][j] = -1\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = i\n            elif dp[i - 1][j] != -1:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = -1\n\n    result = []\n    i, j = n, m\n    while i >= 0 and j >= 0 and dp[i][j] != -1:\n        while dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        result.append(a[i - 1])\n        i -= 1\n        j -= 1\n\n    if not result:\n        print(\"-\")\n    else:\n        print(\"\".join(result[::-1]))\n\n# Read input\na = input().strip()\nb = input().strip()\n\nfind_min_subseq(a, b)"}
{"solution": "def min_stones_after_operations(n, operations):\n    min_stones = 0\n    current_stones = 0\n    \n    for op in operations:\n        if op == '+':\n            current_stones += 1\n        else:  # op == '-'\n            current_stones -= 1\n            min_stones = max(min_stones, current_stones)\n    \n    return max(min_stones, 1)\n\n# Read input\nn = int(input())\noperations = input()\n\n# Calculate and print the result\nprint(min_stones_after_operations(n, operations))"}
{"solution": "def max_kefir_liters(n, a, b, c):\n    def calculate_with_glass_bottles(money):\n        # Buy as many glass bottles as possible\n        bottles = money // b\n        # Calculate remaining money after buying glass bottles\n        remaining_money = money % b + (bottles * c)\n        # Use remaining money to buy additional glass bottles\n        additional_bottles = remaining_money // b\n        # Return total liters of kefir\n        return bottles + additional_bottles + (remaining_money % b) // c\n\n    def calculate_with_plastic_bottles(money):\n        # Simply divide the money by the cost of a plastic bottle\n        return money // a\n\n    # Calculate the maximum liters of kefir with both options\n    glass_liters = calculate_with_glass_bottles(n)\n    plastic_liters = calculate_with_plastic_bottles(n)\n\n    # Return the maximum of the two\n    return max(glass_liters, plastic_liters)\n\n# Read input values\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate and print the result\nprint(max_kefir_liters(n, a, b, c))"}
{"solution": "def read_ints():\n    return list(map(int, input().split()))\n\ndef simulate_game(cards1, cards2):\n    fights = 0\n    while cards1 and cards2:\n        if cards1[0] > cards2[0]:\n            cards1.append(cards2.pop(0))\n            cards1.append(cards1.pop(0))\n        else:\n            cards2.append(cards1.pop(0))\n            cards2.append(cards2.pop(0))\n        fights += 1\n        if fights > 10**6: return -1\n    return (fights, 1 if cards1 else 2)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    k1 = read_ints()[0]\n    cards1 = read_ints()\n    k2 = read_ints()[0]\n    cards2 = read_ints()\n\n    result = simulate_game(cards1, cards2)\n    if result == -1:\n        print(-1)\n    else:\n        print(*result)"}
{"solution": "import re\n\npassword = input().strip()\n\n# Check for the complexity of the password\nis_long_enough = len(password) >= 5\nhas_uppercase = bool(re.search(r'[A-Z]', password))\nhas_lowercase = bool(re.search(r'[a-z]', password))\nhas_digit = bool(re.search(r'\\d', password))\n\n# Determine if the password is too weak\nif is_long_enough and has_uppercase and has_lowercase and has_digit:\n    print(\"Correct\")\nelse:\n    print(\"Too weak\")"}
{"solution": "from collections import Counter\n\ndef min_exchanges_to_equalize_groups():\n    n = int(input())\n    group_a = Counter(map(int, input().split()))\n    group_b = Counter(map(int, input().split()))\n\n    # Check if it's impossible to equalize groups\n    if any(group_a[i] + group_b[i] % 2 for i in range(1, 6)):\n        print(-1)\n        return\n\n    exchanges = 0\n    surplus_a = []\n    surplus_b = []\n\n    # Calculate surpluses in each group\n    for grade in range(1, 6):\n        diff = group_a[grade] - group_b[grade]\n        if diff > 0:\n            surplus_a.extend([grade] * (diff // 2))\n        elif diff < 0:\n            surplus_b.extend([grade] * (-diff // 2))\n\n    # Balance out surpluses\n    while surplus_a and surplus_b:\n        exchanges += 1\n        surplus_a.pop()\n        surplus_b.pop()\n\n    print(exchanges)\n\nmin_exchanges_to_equalize_groups()"}
{"solution": "def is_reachable(n, m, h_streets, v_streets):\n    h_left_to_right = False\n    h_right_to_left = False\n    v_top_to_bottom = False\n    v_bottom_to_top = False\n    \n    for street in h_streets:\n        if street == '>':\n            h_left_to_right = True\n        else:\n            h_right_to_left = True\n            \n    for street in v_streets:\n        if street == 'v':\n            v_top_to_bottom = True\n        else:\n            v_bottom_to_top = True\n            \n    if (h_left_to_right and h_right_to_left and v_top_to_bottom and v_bottom_to_top):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Reading input\nn, m = map(int, input().split())\nh_streets = input()\nv_streets = input()\n\n# Printing output\nprint(is_reachable(n, m, h_streets, v_streets))"}
{"solution": "def find_bracket-placement(n, a):\n    count_ones = sum(a)\n    if count_ones == n or count_ones == 0:\n        return [\"NO\"]\n    \n    result_expression = []\n    ones_to_skip = max(0, count_ones - 1)\n    open_parentheses = 0\n    \n    for i, value in enumerate(a):\n        if value == 1:\n            if ones_to_skip > 0:\n                result_expression.append('1')\n                ones_to_skip -= 1\n            else:\n                open_parentheses += 1\n                result_expression.append('(')\n                result_expression.append('1')\n        else:\n            while open_parentheses > 0:\n                result_expression.append(')')\n                open_parentheses -= 1\n            if i != n - 1 and a[i + 1] == 1:\n                open_parentheses += 1\n                result_expression.append('(')\n            result_expression.append('0')\n        \n        if i < n - 1:\n            result_expression.append('->')\n    \n    while open_parentheses > 0:\n        result_expression.append(')')\n        open_parentheses -= 1\n    \n    return [\"YES\", \"\".join(result_expression)]\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Processing and printing output\noutput = find_bracket_placement(n, a)\nprint('\\n'.join(output))"}
{"solution": "def process_sequence(a, b):\n    while a > 0 and b > 0:\n        if a >= 2 * b:\n            a %= 2 * b\n        elif b >= 2 * a:\n            b %= 2 * a\n        else:\n            break\n    return a, b\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    result_a, result_b = process_sequence(n, m)\n    print(result_a, result_b)"}
{"solution": "import math\n\nk, a, b = map(int, input().split())\n\n# Calculate the start point\nstart = math.ceil(a / k) * k\n\n# Calculate the end point\nend = (b // k) * k\n\n# Calculate the number of k-divisible numbers in the range\nresult = (end - start) // k + 1\n\n# Handle the case where start is less than a\nif start < a:\n    result = max(0, result)\n\nprint(result)"}
{"solution": "def find_kth_digit(k):\n    n = 1\n    digit_count = 1\n    while k > digit_count * 9 * (10 ** (n - 1)):\n        k -= digit_count * 9 * (10 ** (n - 1))\n        n += 1\n        digit_count *= 2\n\n    if k % n == 0:\n        quotient = k // n\n        start_number = 10 ** (n - 1) + quotient - 1\n        return int(str(start_number)[-1])\n    else:\n        quotient = k // n\n        remainder = k % n\n        start_number = 10 ** (n - 1) + quotient\n        return int(str(start_number)[remainder - 1])\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "def can_win_vasya(n, s):\n    from collections import Counter\n    \n    if s[0] != '8':\n        return \"NO\"\n    \n    c = Counter(s)\n    \n    if c['8'] == 1 and s[0] == '8':\n        return \"NO\"\n    \n    if c['8'] >= 2:\n        for digit in map(str, range(10)):\n            if c[digit] >= 2:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\ns = input()\n\n# Print result\nprint(can_win_vasya(n, s))"}
{"solution": "MOD = 10**9 + 7\n\ndef fact(n):\n    f = [1] * (n + 1)\n    for i in range(2, n + 1):\n        f[i] = f[i-1] * i % MOD\n    return f\n\ndef inv_fact(n, f, inv):\n    inv_f = [1] * (n + 1)\n    inv_f[n] = pow(f[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        inv_f[i - 1] = inv_f[i] * i % MOD\n    return inv_f\n\ndef C(n, k, f, inv_f):\n    return f[n] * inv_f[k] * inv_f[n - k] % MOD\n\ndef solve():\n    n, x, pos = map(int, input().split())\n    f = fact(n)\n    inv = [pow(i, MOD - 2, MOD) for i in range(1, n + 1)]\n    inv_f = inv_fact(n, f, inv)\n\n    ans = 0\n    for k in range(pos + 1, n + 1):\n        ans += C(k - 1, pos, f, inv_f) * C(n - k, n - k - (n - x), f, inv_f) % MOD * f[n - k] * f[k - 1] % MOD\n        ans %= MOD\n    print(ans)\n\nsolve()"}
{"solution": "def decode_message(s, k):\n    i, n, result = 0, len(s), \"\"\n    while len(result) < k and i < n:\n        if s[i].isalpha():\n            result += s[i]\n            if len(result) > k:\n                return \"Impossible\"\n            if '?' in s[i+1:i+s.count('*', i)+2]:\n                i += s[i+1:i+s.count('*', i)+2].index('?') + 1\n            else:\n                i += s[i+1:i+s.count('*', i)+2].rfind('*') + 1\n        i += 1\n    if len(result) == k:\n        return result\n    elif len(result) < k and '*' in s:\n        for j in range(i, n):\n            if s[j] == '*':\n                result += s[j-1] * (k - len(result))\n                break\n    return result if len(result) == k else \"Impossible\"\n\n# Read inputs\ns = input().strip()\nk = int(input().strip())\n\n# Print decoded message\nprint(decode_message(s, k))"}
{"solution": "def min_rotations(x):\n    x = x % 360  # Normalize angle to be within 0-359 degrees\n    if x <= 90: return x // 90\n    elif x <= 180: return (180 - x) // 90 + 1\n    elif x <= 270: return (270 - x) // 90 + 2\n    else: return (360 - x) // 90 + 3\n\nx = int(input())\nprint(min_rotations(x))"}
{"solution": "def can_achieve_spheres(a, b, c, x, y, z):\n    extra = (a - x) + (b - y) + (c - z)\n    deficit = max(0, x - a) + max(0, y - b) + max(0, z - c)\n    return 'Yes' if 2 * deficit <= extra else 'No'\n\n# Reading input directly if needed\n# a, b, c = map(int, input().split())\n# x, y, z = map(int, input().split())\n# print(can_achieve_spheres(a, b, c, x, y, z))"}
{"solution": "def solve(n, k, m):\n    mod = m\n    dp = [0] * (k + 1)\n    dp[0] = 1\n    for _ in range(1, n + 1):\n        new_dp = [0] * (k + 1)\n        power_10 = pow(10, _ - 1, mod)\n        inv_power_10 = pow(power_10, -1, mod)\n        for j in range(k + 1):\n            if not dp[j]:\n                continue\n            for d in range(10):\n                if _ == 1 and d == 0:\n                    continue\n                new_j = (j * 10 + d) % k\n                new_dp[new_j] += dp[j]\n                new_dp[new_j] %= mod\n        dp = new_dp\n    return dp[0]\n\ndef main():\n    n, k, m = map(int, input().split())\n    print(solve(n, k, m))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_team_size(l, r, a):\n    min_side = min(l + a, r + a)\n    return min_side * 2\n\n# To use this function:\n# l, r, a = map(int, input().split())\n# print(max_team_size(l, r, a))"}
{"solution": "def min_moves(n, k):\n    # Initialize DP table\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Fill DP table\n    for length in range(2, n + 1):\n        for start in range(1, n - length + 2):\n            end = start + length - 1\n            dp[start][end] = float('inf')\n            for mid in range(start, end):\n                moves = dp[start][mid] + dp[mid + 1][end] + end - start + 1\n                dp[start][end] = min(dp[start][end], moves)\n    \n    # Calculate result considering the starting position\n    result = sum(range(1, n)) - (k - 1) + dp[1][n]\n    return result\n\n# Read input\nn, k = map(int, input().split())\n\n# Compute and print the result\nprint(min_moves(n, k))"}
{"solution": "import heapq\n\ndef min_max_tower_height(n, m):\n    \"\"\"\n    Finds the minimum height of the tallest tower that can be built by students\n    using pieces of two or three blocks, ensuring all towers have unique heights.\n    \"\"\"\n    h = [3]\n    heapq.heapify(h)\n    for _ in range(1, n + m):\n        smallest = heapq.heappop(h)\n        next_smallest = smallest + 3\n        while next_smallest % 2 == 0 or next_smallest % 3 == 0:\n            next_smallest += 1\n        heapq.heappush(h, smallest + 2)\n        heapq.heappush(h, next_smallest)\n    return h[0]\n\n# Input\nn, m = map(int, input().split())\n\n# Compute and print the result\nprint(min_max_tower_height(n, m))"}
{"solution": "def can_play_fair_game(n, cards):\n    from collections import Counter\n    \n    card_counts = Counter(cards)\n    sorted_cards = sorted(card_counts.items(), key=lambda x: x[1], reverse=True)\n    \n    for i in range(len(sorted_cards)):\n        for j in range(i + 1, len(sorted_cards)):\n            petya, petya_count = sorted_cards[i]\n            vasya, vasya_count = sorted_cards[j]\n            \n            if petya != vasya and (petya_count + vasya_count) == n // 2:\n                return True, (petya, vasya)\n    \n    return False, None\n\nn = int(input())\ncards = [int(input()) for _ in range(n)]\n\nfair, numbers = can_play_fair_game(n, cards)\n\nif fair:\n    print(\"YES\")\n    print(*numbers)\nelse:\n    print(\"NO\")"}
{"solution": "def can_arrange_army(rows, groups):\n    total_seats = rows * 8\n    group_counts = [0] * (max(groups) + 1)\n    for group in groups:\n        group_counts[group] += 1\n\n    for count in range(len(group_counts) - 1, 0, -1):\n        if group_counts[count] > 0:\n            needed_rows = (count + 7) // 8\n            if needed_rows * count < group_counts[count]:\n                return \"NO\"\n            total_seats -= min(needed_rows * group_counts[count], total_seats)\n            if total_seats <= 0:\n                break\n\n    return \"YES\" if total_seats >= 0 else \"NO\"\n\n# Reading input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculating and printing result\nprint(can_arrange_army(n, a))"}
{"solution": "def find_optimal_t_and_cost(stick_lengths):\n    stick_lengths.sort()\n    n = len(stick_lengths)\n    \n    # Calculate prefix sums to make range sum queries efficient\n    prefix_sums = [0]\n    for length in stick_lengths:\n        prefix_sums.append(prefix_sums[-1] + length)\n    \n    min_cost = float('inf')\n    optimal_t = None\n    \n    # Try each possible t in the sorted list\n    for i in range(n):\n        t = stick_lengths[i]\n        current_cost = 0\n        \n        # Calculate cost for elements before t\n        if i > 0:\n            current_cost += 2 * (prefix_sums[i] - i * t)\n        \n        # Calculate cost for elements after t\n        current_cost += 2 * ((n - i) * t - (prefix_sums[n] - prefix_sums[i]))\n        \n        if current_cost < min_cost:\n            min_cost = current_cost\n            optimal_t = t\n    \n    return optimal_t, min_cost\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Compute and print result\nresult_t, result_cost = find_optimal_t_and_cost(a)\nprint(result_t, result_cost)"}
{"solution": "def min_square_side(n, m, sky):\n    star_rows = []\n    star_cols = []\n\n    for i in range(n):\n        for j in range(m):\n            if sky[i][j] == '*':\n                star_rows.append(i)\n                star_cols.append(j)\n\n    row_length = max(star_rows) - min(star_rows) + 1\n    col_length = max(star_cols) - min(star_cols) + 1\n\n    return max(row_length, col_length)\n\nn, m = map(int, input().split())\nsky = [input() for _ in range(n)]\n\nprint(min_square_side(n, m, sky))"}
{"solution": "MOD = 10**9 + 7\n\ndef modinv(x):\n    return pow(x, MOD-2, MOD)\n\ndef solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    ones = a.count(1)\n    zeros = n - ones\n    \n    if abs(ones - zeros) > 1:\n        print(0)\n        return\n    \n    # Calculate the initial number of inversions\n    inversions = sum(a[i] > a[j] for i in range(n) for j in range(i+1, n))\n    \n    if k % 2 == 0 or inversions == 0:\n        result = 1\n    else:\n        result = n * (n - 1) // 2 - inversions\n    \n    result %= MOD\n    total_swaps = pow((n * (n - 1) // 2), k, MOD)\n    \n    if total_swaps == 0:\n        print(0)\n    else:\n        print((result * modinv(total_swaps)) % MOD)\n\nsolve()"}
{"solution": "x, y = map(int, input().split())\nprint(x - y)"}
{"solution": "from math import sqrt\n\ndef min_norm_degenerate(a, b, c, d):\n    det = a * d - b * c\n    if det == 0:\n        return 0.0\n    else:\n        n1 = abs(a * d - b * b)\n        n2 = abs(a * d - c * c)\n        n3 = abs(a * c - b * d)\n        n4 = abs(d * c - b * c)\n        return sqrt(min(n1, n2, n3, n4) / det)\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\nprint(min_norm_degenerate(a, b, c, d))"}
{"solution": "import sys\n\n# Parse input\nn, a, b = map(int, sys.stdin.readline().split())\nt = list(map(int, sys.stdin.readline().split()))\n\n# Initialize variables\ndenied = 0\none_seater = a\ntwo_seater = b\n\nfor group in t:\n    if group == 1:  # Group of one person\n        if one_seater > 0:\n            one_seater -= 1\n        elif two_seater > 0:\n            two_seater -= 1\n        elif two_seater < b:\n            denied += 1\n            two_seater += 1\n        else:\n            denied += 1\n    else:  # Group of two people\n        if two_seater > 0:\n            two_seater -= 1\n        else:\n            denied += 2\n\nprint(denied)"}
{"solution": "def failed_students(A, B, C, N):\n    both_restaurants = C\n    only_bugdonalds = A - C\n    only_beaverking = B - C\n    \n    # Check for valid conditions\n    if (only_bugdonalds < 0 or only_beaverking < 0 or\n        (only_bugdonalds + only_beaverking + both_restaurants > N)):\n        return -1\n    \n    failed = N - (only_bugdonalds + only_beaverking + both_restaurants)\n    return failed if failed >= 1 else -1\n\n# Read input values\nA, B, C, N = map(int, input().split())\n\n# Calculate and print the result\nprint(failed_students(A, B, C, N))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(x, k):\n    def matrix_mult(a, b):\n        return [[sum(a[i][k] * b[k][j] for k in range(2)) % MOD for j in range(2)] for i in range(2)]\n\n    def matrix_power(m, n):\n        result = [[1, 0], [0, 1]]  # identity matrix\n        while n > 0:\n            if n % 2 == 1:\n                result = matrix_mult(result, m)\n            m = matrix_mult(m, m)\n            n //= 2\n        return result\n\n    if k == 0:\n        return (2 * x) % MOD\n\n    # Transition matrix for the process\n    transition_matrix = [[1, 1], [1, 0]]\n    powered_matrix = matrix_power(transition_matrix, k)\n\n    # Initial state vector (x dresses, 0 eaten)\n    state_vector = [x, 0]\n\n    # Final state vector after k steps\n    final_state = matrix_mult(powered_matrix, [[state_vector[0]], [state_vector[1]]])\n\n    return (final_state[0][0] + final_state[1][0]) % MOD\n\nx, k = map(int, input().split())\nprint(solve(x, k))"}
{"solution": "MOD = 998244353\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef solve():\n    from math import gcd\n    n = int(input())\n    probs = [list(map(int, input().split())) for _ in range(n)]\n    \n    numerator = 1\n    denominator = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            a, b = probs[i]\n            c, d = probs[j]\n            intersection = max(0, min(b, d) - max(a, c) + 1)\n            union = (b - a + 1) * (d - c + 1)\n            if intersection:\n                numerator *= intersection\n                denominator *= union\n                numerator %= MOD\n                denominator %= MOD\n                \n    # Simplify the fraction\n    common_divisor = gcd(numerator, denominator)\n    numerator //= common_divisor\n    denominator //= common_divisor\n    \n    # Find modular inverse of denominator\n    denominator_inv = modinv(denominator)\n    \n    # Calculate the final result\n    result = (numerator * denominator_inv) % MOD\n    print(result)\n\nsolve()"}
{"solution": "def count_ways_to_form_rectangle(n):\n    \"\"\"\n    Counts the number of ways to split a stick of length n into four parts\n    so that it's possible to form a rectangle but not a square.\n    \"\"\"\n    ways = 0\n    for x in range(1, n // 2):\n        if n % 2 == 0 and 2 * x < n:  # Ensure 2x < n to leave room for other parts\n            ways += 1\n    return ways\n\n# Read input\nn = int(input())\n\n# Compute and print result\nprint(count_ways_to_form_rectangle(n))"}
{"solution": "import sys\nfrom typing import List\n\ndef min_kvass_volume(n: int, s: int, volumes: List[int]) -> int:\n    if sum(volumes) < s:\n        return -1\n\n    min_volume = max(0, min(volumes) - s)\n    max_volume = max(volumes)\n\n    while min_volume < max_volume:\n        mid_volume = (min_volume + max_volume + 1) // 2\n        total = sum(max(0, volume - mid_volume) for volume in volumes)\n\n        if total >= s:\n            min_volume = mid_volume\n        else:\n            max_volume = mid_volume - 1\n\n    return min_volume if min_volume >= 0 else -1\n\n# Reading input from stdin\nn, s = map(int, sys.stdin.readline().split())\nvolumes = list(map(int, sys.stdin.readline().split()))\n\n# Calculating and printing the result\nresult = min_kvass_volume(n, s, volumes)\nprint(result)"}
{"solution": "def caterpillar_and_apple():\n    h1, h2 = map(int, input().split())\n    a, b = map(int, split())\n\n    net_daily_progress = (8 * a) - (12 * b)\n    initial_day_progress = (6 * a)\n\n    if net_daily_progress <= 0 and h2 > h1 + initial_day_progress:\n        return -1\n\n    if h2 <= h1 + initial_day_progress:\n        return 0\n\n    days_needed = ((h2 - h1) + (8 * b) - 1) // (8 * (a - b))\n\n    if h1 + (days_needed * (8 * a - 12 * b)) + (8 * a) >= h2:\n        return days_needed\n\n    return days_needed + 1\n\nprint(caterpillar_and_apple())"}
{"solution": "def max_joy_units(c, hr, hb, wr, wb):\n    max_joy = 0\n    max_joy = max(max_joy, ((c // wr) * hr))\n    max_joy = max(max_joy, ((c // wb) * hb))\n    \n    x = c // (wr + wb)\n    mod_c = c % (wr + wb)\n    max_joy = max(max_joy, ((x * (hr + hb)) + ((mod_c // wr) * hr)))\n    max_joy = max(max_joy, ((x * (hr + hb)) + ((mod_c // wb) * hb)))\n    \n    return max_joy\n\nif __name__ == \"__main__\":\n    c, hr, hb, wr, wb = map(int, input().split())\n    print(max_joy_units(c, hr, hb, wr, wb))"}
{"solution": "def min_steps(start, end):\n    x1, y1 = start\n    x2, y2 = end\n    dx = abs(x1 - x2)\n    dy = abs(y1 - y2)\n    return max(dx, dy)\n\nstart = tuple(map(int, input().split()))\nend = tuple(map(int, input().split()))\nprint(min_steps(start, end))"}
{"solution": "def vote_outcome(n, fractions):\n    d_count = 0\n    r_count = 0\n    d_skips = 0\n    r_skips = 0\n    current_round = 1\n    index = 0\n    \n    while True:\n        if fractions[index % n] == 'D':\n            if d_skips > d_count:\n                d_count += 1\n                if r_count > 0:\n                    r_count -= 1\n                    r_skips = current_round + 1\n            else:\n                d_skips = current_round + 1\n        else:\n            if r_skips > r_count:\n                r_count += 1\n                if d_count > 0:\n                    d_count -= 1\n                    d_skips = current_round + 1\n            else:\n                r_skips = current_round + 1\n        \n        index += 1\n        current_round += 1\n        \n        if d_count == 0 or r_count == 0:\n            break\n    \n    return 'D' if d_count > 0 else 'R'\n\nn = int(input())\nfractions = input().strip()\nprint(vote_outcome(n, fractions))"}
{"solution": "from math import gcd\n\na, b, x, y = map(int, input().split())\n\ngcd_xy = gcd(x, y)\n\nx //= gcd_xy\ny //= gcd_xy\n\nmin_val = min(a // x, b // y)\n\nresult = min_val - (min_val % gcd(x, y)) + (gcd(x, y) > 1 and min_val % gcd(x, y) != 0)\n\nprint(result)"}
{"solution": "from collections import defaultdict\n\ndef maxPowerOf(p, n):\n    count = 0\n    i = p\n    while i <= n:\n        count += n // i\n        i *= p\n    return count\n\ndef solve(n, b):\n    factors = defaultdict(int)\n    \n    i = 2\n    while i * i <= b:\n        cnt = 0\n        while b % i == 0:\n            b //= i\n            cnt += 1\n        if cnt:\n            factors[i] = cnt\n        i += 1\n    \n    if b > 1:\n        factors[b] = 1\n    \n    ans = float('inf')\n    for p in factors:\n        ans = min(ans, maxPowerOf(p, n) // factors[p])\n    \n    return ans\n\nif __name__ == \"__main__\":\n    n, b = map(int, input().split())\n    print(solve(n, b))"}
{"solution": "def calculate_sum(m, a, b):\n    gcd = a * b // math.gcd(a, b)\n    if a + b <= m + 1:\n        k = (m + 1) // (a + b)\n        res = (2 + (k - 1) * (a + b)) * k // 2\n        res += (m + 1 - k * (a + b))\n    else:\n        res = m + 1\n\n    if gcd <= m:\n        k = (m) // gcd\n        res -= (gcd * (k + 1) - (m + 1))\n\n    return res\n\nimport math\nm, a, b = map(int, input().split())\nprint(calculate_sum(m, a, b))"}
{"solution": "def can_divide_into_odds(n, seq):\n    odd_count = 0\n    start = -1\n    \n    for i in range(n):\n        if seq[i] % 2 == 1:\n            if start == -1:\n                start = i\n        else:\n            if start != -1:\n                odd_count += 1\n                start = -1\n    \n    # Check last segment if it ends with an odd number\n    if start != -1 and seq[-1] % 2 == 1:\n        odd_count += 1\n    \n    return \"Yes\" if odd_count % 2 == 1 else \"No\"\n\n# Reading input\nn = int(input())\nseq = list(map(int, input().split()))\n\n# Printing output\nprint(can_divide_into_odds(n, seq))"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    if x1 == x2:\n        x3, x4 = x1, x2\n        y3, y4 = y2, y2\n    elif y1 == y2:\n        y3, y4 = y1, y2\n        x3, x4 = x2, x2\n    else:\n        if abs(x1 - x2) == abs(y1 - y2):\n            x3, x4 = x2, x1\n            y3, y4 = y1, y2\n        else:\n            return -1\n\n    if -1000 <= x3 <= 1000 and -1000 <= y3 <= 1000 and -1000 <= x4 <= 1000 and -1000 <= y4 <= 1000:\n        return x3, y3, x4, y4\n    else:\n        return -1\n\nx1, y1, x2, y2 = map(int, input().split())\nresult = find_remaining_trees(x1, y1, x2, y2)\nprint(*result) if result != -1 else print(-1)"}
{"solution": "MOD = 1000000007\n\ndef solve(x, y, n):\n    if n == 1:\n        return x % MOD\n    elif n == 2:\n        return y % MOD\n    \n    # Calculate the period length\n    a, b = x, y\n    period_length = 2\n    while True:\n        a, b = b, (a - b) % MOD\n        period_length += 1\n        if a == x and b == y:\n            break\n    \n    # Calculate f_n using the periodicity\n    n = ((n - 1) % (period_length - 2)) + 1\n    if n == 1:\n        return x % MOD\n    elif n == 2:\n        return y % MOD\n    else:\n        return (y - x) % MOD\n\nimport sys\nx, y = map(int, input().split())\nn = int(input())\nprint(solve(x, y, n))"}
{"solution": "def find_splits(arr):\n    n = len(arr)\n    start = 0\n    splits = []\n\n    for end in range(n):\n        # Check if current sum from start to end is non-zero\n        if sum(arr[start:end+1]) != 0:\n            # If non-zero, add this segment as a valid split\n            splits.append((start, end))\n            # Move start to the next position for new segment\n            start = end + 1\n\n    # If no valid splits found, return 'NO'\n    if not splits:\n        return \"NO\"\n    else:\n        # Prepare the output\n        result = [\"YES\", str(len(splits))]\n        for split in splits:\n            result.append(f\"{split[0] + 1} {split[1] + 1}\")\n        return \"\\n\".join(result)\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(find_splits(arr))"}
{"solution": "MOD = 1000000009\n\ndef min_score(n, m, k):\n    if k >= m:\n        return m\n    if k == 0:\n        return 0\n    full_sequences, extra_correct = divmod(m, k)\n    base_score = (k * (full_sequences + 1) + extra_correct) % MOD\n    doubling_score = ((2 ** full_sequences) * base_score) % MOD\n    return doubling_score\n\nif __name__ == \"__main__\":\n    n, m, k = map(int, input().split())\n    print(min_score(n, m, k))"}
{"solution": "def find_divisible_by_8(n: str):\n    \"\"\"\n    Finds a subsequence of the digits in n that forms a number divisible by 8.\n    If such a subsequence exists, prints 'YES' followed by the subsequence.\n    Otherwise, prints 'NO'.\n    \"\"\"\n    length = len(n)\n    # Check for single digit divisible by 8\n    if n[-1] in ['0', '8']:\n        return \"YES\\n\" + n[-1]\n    # Check for two-digit combinations\n    for i in range(length - 1, 0, -1):\n        if int(n[i-1:i+1]) % 8 == 0:\n            return \"YES\\n\" + n[i-1:i+1]\n    # Check for three-digit combinations\n    for i in range(length - 1, 1, -1):\n        if int(n[i-2:i+1]) % 8 == 0:\n            return \"YES\\n\" + n[i-2:i+1]\n    return \"NO\"\n\n# Read input\nn = input().strip()\n\n# Process and print the result\nprint(find_divisible_by_8(n))"}
{"solution": "def find_floor(n, memories):\n    possible_flats = set()\n\n    for k, f in memories:\n        if k % f == 0:\n            possible_flats.add(k // f)\n        else:\n            possible_flats.add(k // f + 1)\n\n    consistent_flats = set.intersection(*[set(range(1, 101, x)) for x in possible_flats])\n\n    floors_n = {x for x in consistent_flats if n % x == 0} or {max(consistent_flats)}\n\n    if len(floors_n) != 1:\n        return -1\n    else:\n        return n // list(floors_n)[0]\n\nn, m = map(int, input().split())\nmemories = [tuple(map(int, input().split())) for _ in range(m)]\nprint(find_floor(n, memories))"}
{"solution": "from typing import List, Tuple\n\ndef max_bishwocks(board: List[str]) -> int:\n    \"\"\"\n    Calculate the maximum number of bishwocks that can be placed on a 2xN board without overlapping\n    or placing on squares occupied by pawns.\n    \"\"\"\n    n = len(board[0])\n    dp = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1]\n        if board[0][i - 1] == '0':\n            if board[1][i - 1] == '0':\n                dp[i] = max(dp[i], 1 + (dp[i - 2] if i > 1 else 0))\n            else:\n                dp[i] = max(dp[i], dp[i - 1])\n        elif board[1][i - 1] == '0':\n            dp[i] = max(dp[i - 1], dp[i - 2])\n\n    return dp[n]\n\n# Read input\nboard = [input() for _ in range(2)]\n\n# Output result\nprint(max_bishwocks(board))"}
{"solution": "def max_pretty_positions(n, s):\n    count = 0\n    last_upper = -1\n    lower_set = set()\n\n    for i in range(n):\n        if s[i].islower():\n            if i - 1 > last_upper:\n                lower_set.add(s[i])\n                count += 1\n                last_upper = i\n            elif s[i] not in lower_set:\n                lower_set.add(s[i])\n                count += 1\n                last_upper = i\n        else:\n            last_upper = i\n\n    return count\n\n# Read input\nn = int(input())\ns = input()\n\n# Calculate and print the result\nprint(max_pretty_positions(n, s))"}
{"solution": "# Importing necessary library\nfrom functools import reduce\n\ndef max_diff_sum():\n    \"\"\"Function to calculate the maximum difference of sums of two partitions\"\"\"\n    # Read the number of elements\n    _ = int(input())\n    # Read the sequence of integers\n    sequence = list(map(int, input().split()))\n    # Calculate the total sum of the sequence\n    total_sum = reduce(lambda x, y: x + y, sequence)\n    # Calculate the maximum possible value of B - C\n    max_diff = total_sum if total_sum > 0 else 0\n    print(max_diff)\n\n# Call the function and read inputs\nmax_diff_sum()"}
{"solution": "import math\n\ndef min_refuels(a, b, f, k):\n    if b >= 2 * a - f:\n        return k - 1\n    if b < f:\n        return -1\n    \n    rounds_to_empty = math.floor(b / f)\n    \n    if b % f == 0:\n        rounds_to_empty -= 1\n    \n    if b - f * rounds_to_empty < a - f:\n        rounds_to_empty -= 1\n    \n    if rounds_to_empty == 0:\n        return -1\n    \n    res = math.ceil(k / (rounds_to_empty * 2 + 1))\n    \n    if k % (rounds_to_empty * 2 + 1) == 0:\n        res -= 1\n        \n    return res + k - 1\n\na, b, f, k = map(int, input().split())\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(s, p, q):\n    n = len(s)\n    parts = []\n    \n    while s:\n        if len(s) >= p:\n            parts.append(s[:p])\n            s = s[p:]\n        elif len(s) >= q:\n            parts.append(s[:q])\n            s = s[q:]\n        else:\n            return [-1]\n    \n    if n != sum(len(part) for part in parts):\n        return [-1]\n    \n    return [len(parts)] + parts\n\nif __name__ == \"__main__\":\n    n, p, q = map(int, input().split())\n    s = input()\n    result = split_string(s, p, q)\n    \n    if result[0] == -1:\n        print(-1)\n    else:\n        print(result[0])\n        for part in result[1:]:\n            print(part)"}
{"solution": "def can_reach_finish(n, m, s, d, obstacles):\n    obstacles_set = set(obstacles)\n    current_position = 0\n    path = []\n\n    while current_position < m:\n        if current_position in obstacles_set:\n            # Find the next position to jump to\n            jump_to = min(m + 1, current_position + d + 1)\n            while jump_to - 1 in obstacles_set and jump_to > current_position + s:\n                jump_to -= 1\n            if jump_to == current_position + s:\n                return [\"IMPOSSIBLE\"]\n            path.append(f\"RUN {s}\")\n            path.append(f\"JUMP {jump_to - (current_position + s)}\")\n            current_position = jump_to\n        else:\n            path.append(f\"RUN {1}\")\n            current_position += 1\n\n    # Remove last RUN if it's not needed\n    if path and path[-1].startswith(\"RUN\"):\n        path.pop()\n\n    return path\n\n# Read input\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\n# Solve and print output\nresult = can_reach_finish(n, m, s, d, obstacles)\nfor step in result:\n    print(step)"}
{"solution": "def count_pairs(s, x):\n    if s > 0 and x == 0:\n        return 0 if s % 2 == 0 else 1\n    if s <= x or (s - x) % 2 == 1:\n        return 0\n    return 2\n\ns, x = map(int, input().split())\nprint(count_pairs(s, x))"}
{"solution": "def solve(n, k):\n    import math\n    l = math.ceil(n / (2 * k + 1))\n    print(l)\n    for i in range(l):\n        print(1 + i * (2 * k + 1), end=\" \")\n    print()\n\n# Example usage\nn, k = map(int, input().split())\nsolve(n, k)"}
{"solution": "from math import sqrt, floor\n\ndef is_square(n):\n    root = int(sqrt(n))\n    return root * root == n\n\ndef solve(n):\n    str_n = str(n)\n    min_operations = float('inf')\n\n    for mask in range(1 << len(str_n)):\n        new_num_str = ''\n        for i in range(len(str_n)):\n            if not mask & (1 << i):\n                new_num_str += str_n[i]\n\n        if new_num_str and new_num_str[0] != '0':\n            new_num = int(new_num_str)\n            if is_square(new_num):\n                min_operations = min(min_operations, len(str_n) - len(new_num_str))\n\n    return min_operations if min_operations != float('inf') else -1\n\nn = int(input())\nprint(solve(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef add(x, y):\n    return (x + y) % MOD\n\ndef mul(x, y):\n    return (x * y) % MOD\n\nclass Factorial:\n    def __init__(self, n, mod):\n        self.fact = [1] * (n + 1)\n        self.invfact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            self.fact[i] = self.fact[i - 1] * i % mod\n        self.invfact[n] = pow(self.fact[n], mod - 2, mod)\n        for i in range(n, 0, -1):\n            self.invfact[i - 1] = self.invfact[i] * i % mod\n\n    def factorial(self, n):\n        return self.fact[n]\n\n    def ifactorial(self, n):\n        return self.invfact[n]\n\n    def comb(self, n, k):\n        return self.fact[n] * self.invfact[k] % MOD * self.invfact[n - k] % MOD\n\nn = int(input())\nfactorial = Factorial(n, MOD)\nprimes = [True] * (n + 1)\nprime_numbers = []\nfor i in range(2, n + 1):\n    if primes[i]:\n        prime_numbers.append(i)\n        for j in range(i * i, n + 1, i):\n            primes[j] = False\n\ndp = [0] * (n + 1)\ndp[1] = 1\nfor p in prime_numbers:\n    for i in range(n, p - 1, -1):\n        dp[i] = add(dp[i], mul(dp[i - p], i - p + 1))\n        dp[i] = add(dp[i], MOD - mul(dp[i - p], factorial.ifactorial(i - p)))\nans = 0\nfor i in range(n, 0, -1):\n    ans = add(ans, mul(dp[i], factorial.factorial(n - i)))\nprint(ans)"}
{"solution": "def min_jump_ability(s):\n    vowels = \"AEIOUY\"\n    positions = [i for i, char in enumerate(s) if char in vowels]\n    \n    if not positions:\n        return len(s)\n    \n    max_gap = max(positions[0], len(s) - positions[-1])\n    for i in range(1, len(positions)):\n        max_gap = max(max_gap, positions[i] - positions[i - 1])\n    \n    return max_gap\n\n# Read input\ns = input().strip()\n\n# Calculate and print the result\nprint(min_jump_ability(s))"}
{"solution": "def candy_distribution(a):\n    total_candies = sum(a)\n    if total_candies % 2 != 0:\n        return \"NO\"\n    \n    a.sort()\n    for i in range(1, 4):\n        if a[0] + a[i] == a[1] + a[3-i]:\n            return \"YES\"\n    return \"NO\"\n\na = list(map(int, input().split()))\nprint(candy_distribution(a))"}
{"solution": "def pie_sharing(slices):\n    n = len(slices)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for length in range(1, n + 1):\n        for start in range(n - length + 1):\n            end = start + length\n            if length == 1:\n                dp[start][end] = slices[start]\n            else:\n                bob_takes = slices[start] + dp[start + 1][end]\n                alice_takes = slices[end - 1] + dp[start][end - 1]\n                dp[start][end] = max(bob_takes, alice_takes)\n    \n    return dp[0][n], sum(slices) - dp[0][n]\n\nif __name__ == \"__main__\":\n    n = int(input())\n    slices = list(map(int, input().split()))\n    alice, bob = pie_sharing(slices)\n    print(alice, bob)"}
{"solution": "from collections import defaultdict\nfrom math import log2, ceil\n\ndef min_variables(n, sequence):\n    if n == 1:\n        return 1\n    \n    sequence.sort()\n    required_numbers = set(sequence)\n    combinations = defaultdict(set)\n    \n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            sum_ij = sequence[i] + sequence[j]\n            if sum_ij in required_numbers:\n                combinations[sum_ij].add(sequence[i])\n                combinations[sum_ij].add(sequence[j])\n    \n    # Check if it's possible to form all numbers\n    for number in sequence[1:]:\n        if number not in combinations or len(combinations[number]) < 2:\n            return -1\n    \n    # Calculate the minimum number of variables needed\n    max_exponent = 0\n    for number in combinations:\n        exponent = int(log2(len(combinations[number])))\n        max_exponent = max(max_exponent, exponent)\n    \n    return 2 ** max_exponent\n\n# Reading input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Calculating and printing the answer\nprint(min_variables(n, sequence))"}
{"solution": "def main():\n    n = int(input())\n    piles = list(map(int, input().split()))\n    alice_turn = True\n    piles.sort(reverse=True)\n    while piles.count(0) < n // 2:\n        if alice_turn:\n            # Alice takes max and second max\n            if len(piles) >= 2:\n                piles[0] -= 1\n                piles[1] -= 1\n                piles = [x for x in piles if x > 0]  # Remove zeros\n                piles.sort(reverse=True)\n                alice_turn = False\n            else:\n                break\n        else:\n            # Bob takes any two non-empty piles\n            if len(piles) >= 2:\n                piles[0] -= 1\n                piles[-1] -= 1\n                piles = [x for x in piles if x > 0]  # Remove zeros\n                piles.sort(reverse=True)\n                alice_turn = True\n            else:\n                break\n    if alice_turn:  # If it's Alice's turn and she can't move, Bob wins\n        print(\"Bob\")\n    else:\n        print(\"Alice\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_make_equal(arr):\n    n = len(arr)\n    min_val = min(arr)\n    for x in range(2 * (max(arr) - min_val) + 1):\n        changes = [0] * (2 * x + 1)\n        for num in arr:\n            target = num - x\n            diff = num - target\n            if 0 <= diff <= 2 * x:\n                changes[diff] += 1\n        for i in range(1, len(changes)):\n            changes[i] += changes[i - 1]\n        for i in range(x + 1):\n            if (changes[2 * x] == changes[i - 1] + (n - changes[i]) and\n                    changes[x - 1] == changes[i - 1] + (changes[x] - changes[i])):\n                return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output result\nprint(can_make_equal(arr))"}
{"solution": "def solve():\n    n = int(input())\n    s = input()\n    \n    def is_valid(l):\n        seen = set()\n        for i in range(n - l + 1):\n            if s[i:i+l] in seen:\n                return True\n            seen.add(s[i:i+l])\n        return False\n    \n    low, high = 1, n // 2\n    result = 0\n    while low <= high:\n        mid = (low + high) // 2\n        if is_valid(mid):\n            result = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    print(result)\n\nsolve()"}
{"solution": "def min_time_to_reach_house(n, a):\n    if a == 1 or a == n:\n        return 1\n    if a <= n // 2:\n        return a\n    else:\n        return n - a + 1\n\nn, a = map(int, input().split())\nprint(min_time_to_reach_house(n, a))"}
{"solution": "def check_interval\u53ef\u884c\u6027(n, m, lightsabers, color_counts):\n    total_count = sum(color_counts)\n    \n    # \u9884\u8ba1\u7b97\u524d\u7f00\u548c\u4ee5\u4fbf\u5feb\u901f\u67e5\u8be2\u533a\u95f4\u548c\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + (1 if lightsabers[i - 1] == 1 else 0)\n\n    # \u4f7f\u7528\u6ed1\u52a8\u7a97\u53e3\u68c0\u67e5\u662f\u5426\u5b58\u5728\u7b26\u5408\u6761\u4ef6\u7684\u533a\u95f4\n    for start in range(n - total_count + 1):\n        end = start + total_count - 1\n        counts = [0] * (m + 1)\n        \n        for i in range(start, end + 1):\n            counts[lightsabers[i]] += 1\n        \n        if counts == color_counts:\n            return \"YES\"\n    \n    return \"NO\"\n\n# \u8bfb\u53d6\u8f93\u5165\nn, m = map(int, input().split())\nlightsabers = list(map(int, input().split()))\ncolor_counts = list(map(int, input().split()))\n\n# \u8c03\u7528\u51fd\u6570\u5e76\u8f93\u51fa\u7ed3\u679c\nprint(check_interval\u53ef\u884c\u6027(n, m, lightsabers, color_counts))"}
{"solution": "def determine_winner(n, rounds):\n    mishka_wins = 0\n    chris_wins = 0\n    \n    for m, c in rounds:\n        if m > c:\n            mishka_wins += 1\n        elif c > m:\n            chris_wins += 1\n    \n    if mishka_wins > chris_wins:\n        print(\"Mishka\")\n    elif chris_wins > mishka_wins:\n        print(\"Chris\")\n    else:\n        print(\"Friendship is magic!^^\")\n\n# Reading input\nn = int(input())\nrounds = [list(map(int, input().split())) for _ in range(n)]\n\n# Determining and printing the winner\ndetermine_winner(n, rounds)"}
{"solution": "def is_valid_minesweeper_field(n, m, field):\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n\n    def count_bombs(x, y):\n        count = 0\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and field[nx][ny] == '*':\n                count += 1\n        return count\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '.':\n                if any(field[i + dx][j + dy] == '*' for dx, dy in directions if 0 <= i + dx < n and 0 <= j + dy < m):\n                    return \"NO\"\n            elif field[i][j] == '*':\n                continue\n            else:\n                expected_bombs = int(field[i][j])\n                actual_bombs = count_bombs(i, j)\n                if actual_bombs != expected_bombs:\n                    return \"NO\"\n\n    return \"YES\"\n\n# Reading input\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\n# Output result\nprint(is_valid_minesweeper_field(n, m, field))"}
{"solution": "import math\n\ndef min_k_value(n):\n    k = 1\n    while True:\n        remaining_candies = n\n        vasya_candies = 0\n        while remaining_candies > 0:\n            remaining_candies -= k\n            vasya_candies += k\n            if remaining_candies > 0:\n                petya_candies = min(remaining_candies // 10, remaining_candies)\n                remaining_candies -= petya_candies\n        if vasya_candies >= n / 2:\n            return k\n        k += 1\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    print(min_k_value(n))"}
{"solution": "def solve_necklace(necklace):\n    n = len(necklace)\n    pearl_positions = [i for i, char in enumerate(necklace) if char == 'o']\n    num_pearls = len(pearl_positions)\n\n    if num_pearls <= 1:\n        return \"YES\"\n\n    link_counts = []\n    for i in range(num_pearls):\n        start = pearl_positions[i]\n        end = pearl_positions[(i + 1) % num_pearls]\n        link_count = end - start - 1\n        if start < end:\n            link_counts.append(link_count)\n        else:\n            link_counts.append(n - start + end - 1)\n\n    max_links = max(link_counts)\n    min_links = min(link_counts)\n\n    if max_links == min_links:\n        return \"YES\"\n    elif max_links - min_links == num_pearls - 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nnecklace = input().strip()\n\n# Solve and print result\nprint(solve_necklace(necklace))"}
{"solution": "def max_pillows_for_frodo(n, m, k):\n    low, high = 1, m\n    while low <= high:\n        mid = (low + high) // 2\n        required = calculate_required_pillows(n, k, mid)\n        if required <= m:\n            equal_distribution = (m - required) // (n - 1)\n            total_pillows_for_frodo = mid + equal_distribution\n            if (mid > 1 and calculate_required_pillows(n, k, mid + 1) <= m) or total_pillows_for_frodo - 1 >= mid:\n                low = mid + 1\n            else:\n                high = mid - 1\n        else:\n            high = mid - 1\n    return low if low > 1 else 1\n\ndef calculate_required_pillows(n, k, pillows_for_frodo):\n    left_extra = max(0, pillows_for_frodo - 1)\n    right_extra = max(0, pillows_for_frodo - 1)\n    total_extra = (left_extra * (left_extra + 1)) // 2 + (right_extra * (right_extra + 1)) // 2\n    if k > 1:\n        total_extra -= (left_extra * (left_extra + 1)) // 2\n        left_extra = max(0, pillows_for_frodo - 2)\n        total_extra += (left_extra * (left_extra + 1)) // 2\n    if k < n:\n        total_extra -= (right_extra * (right_extra + 1)) // 2\n        right_extra = max(0, pillows_for_frodo - 2)\n        total_extra += (right_extra * (right_extra + 1)) // 2\n    return n + total_extra\n\nn, m, k = map(int, input().split())\nprint(max_pillows_for_frodo(n, m, k))"}
{"solution": "from collections import deque\n\ndef max_subarray_cost(arr, m, k):\n    n = len(arr)\n    dp = [0] * (n + 1)\n    dq = deque()\n    sum_a = 0\n    max_cost = 0\n\n    for i in range(1, n + 1):\n        sum_a += arr[i - 1]\n        while dq and dq[0][1] < i - m:\n            dq.popleft()\n        if not dq:\n            cur_cost = sum_a\n        else:\n            cur_cost = sum_a - k * (i - dq[0][1]) + dq[0][0]\n        while dq and cur_cost >= dq[-1][0]:\n            dq.pop()\n        dq.append((cur_cost, i))\n        max_cost = max(max_cost, cur_cost)\n\n    return max_cost\n\n# Reading input\nn, m, k = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Printing output\nprint(max_subarray_cost(arr, m, k))"}
{"solution": "def main():\n    n, m = map(int, input().split())\n    if n > m:\n        n, m = m, n\n    \n    if n == 0:\n        print(f\"0 {1}\")\n        print(f\"0 {m}\")\n        print(f\"0 {0}\")\n        print(f\"0 {m-1}\")\n    elif n == 1:\n        print(f\"1 {m}\")\n        print(f\"0 {0}\")\n        print(f\"1 {0}\")\n        print(f\"0 {m}\")\n    else:\n        print(f\"{n} {m}\")\n        print(f\"0 {0}\")\n        print(f\"{n} {0}\")\n        print(f\"0 {m}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_smallest_number(s, t):\n    import collections\n    \n    s_counter = collections.Counter(s)\n    t_counter = collections.Counter(t)\n    \n    result = []\n    remaining = list(s)\n    \n    for i in range(1, len(s)):\n        current_counter = collections.Counter(s[:i])\n        suffix = s[i:]\n        \n        k = int(t) if t else 0\n        \n        if i == k:\n            if current_counter == t_counter:\n                return ''.join(result) + t\n        \n        for digit in sorted(current_counter.keys()):\n            while current_counter[digit] > 0 and digit in t_counter:\n                if t_counter[digit] > 0:\n                    result.append(digit)\n                    t_counter[digit] -= 1\n                    current_counter[digit] -= 1\n                    s_counter[digit] -= 1\n        \n        for digit in sorted(s_counter.keys()):\n            while s_counter[digit] > 0:\n                remaining.remove(digit)\n                result.append(digit)\n                s_counter[digit] -= 1\n                \n        if t_counter == t_counter - t_counter:\n            return ''.join(result) + t\n    \n    return ''.join(sorted(remaining))[:len(s)-len(t)] + t\n\ninput_string = input().strip()\nsubstring = input().strip()\n\nprint(find_smallest_number(input_string, substring))"}
{"solution": "def check_temperatures(n, m, min_temp, max_temp, temps):\n    if min(temps) < min_temp or max(temps) > max_temp:\n        return \"Incorrect\"\n    if n == m:\n        if min_temp == max_temp == temps[0]:\n            return \"Correct\"\n        else:\n            return \"Incorrect\"\n    if min_temp not in temps and (m == 1 or min_temp < min(temps)):\n        if n - m >= temps.count(min(temps)) + 1:\n            return \"Correct\"\n        else:\n            return \"Incorrect\"\n    if max_temp not in temps and (m == 1 or max_temp > max(temps)):\n        if n - m >= temps.count(max(temps)) + 1:\n            return \"Correct\"\n        else:\n            return \"Incorrect\"\n    return \"Correct\"\n\nif __name__ == \"__main__\":\n    n, m, min_temp, max_temp = map(int, input().split())\n    temps = list(map(int, input().split()))\n    print(check_temperatures(n, m, min_temp, max_temp, temps))"}
{"solution": "def find_n(m):\n    def count_trailing_zeros(n):\n        cnt = 0\n        while n % 10 == 0:\n            n //= 10\n            cnt += 1\n        return cnt\n\n    def find_factorial_trailing_zeros(m):\n        fact = 1\n        i = 1\n        while True:\n            fact *= i\n            if count_trailing_zeros(fact) > m:\n                break\n            i += 1\n        return i - 1\n\n    start = find_factorial_trailing_zeros(m)\n    if start == 0 and m == 0:\n        return [0]\n    end = find_factorial_trailing_zeros(m + 1)\n\n    result = []\n    for n in range(start, end):\n        fact = 1\n        for j in range(1, n + 1):\n            fact *= j\n        if count_trailing_zeros(fact) == m:\n            result.append(n)\n    return result\n\nm = int(input())\nresult = find_n(m)\nprint(len(result))\nprint(' '.join(map(str, result)))"}
{"solution": "from heapq import heappush, heappop\nfrom collections import defaultdict\n\ndef dijkstra(graph, start):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    heap = [(0, start)]\n\n    while heap:\n        current_distance, current_vertex = heappop(heap)\n\n        if current_distance > distances[current_vertex]:\n            continue\n\n        for neighbor, weight in graph[current_vertex].items():\n            distance = max(current_distance, weight)\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heappush(heap, (distance, neighbor))\n\n    return distances\n\ndef process_special_vertices(n, m, k, special_vertices, edges):\n    # Build the graph\n    graph = defaultdict(dict)\n    for u, v, w in edges:\n        graph[u][v] = w\n        graph[v][u] = w\n\n    # Compute distances from all special vertices to all other vertices\n    all_distances = {vertex: dijkstra(graph, vertex) for vertex in special_vertices}\n\n    # Find the farthest special vertex for each special vertex\n    results = []\n    for vertex in special_vertices:\n        max_distance = max((all_distances[vertex][other] for other in special_vertices if other != vertex), default=0)\n        results.append(max_distance)\n\n    return results\n\n# Reading input\nn, m, k = map(int, input().split())\nspecial_vertices = list(map(int, input().split()))\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Processing\nresults = process_special_vertices(n, m, k, special_vertices, edges)\n\n# Output\nprint(' '.join(map(str, results)))"}
{"solution": "def find_initial_position(moves, final_shell):\n    # Determine the effect of an even or odd number of moves on the shell positions\n    if moves % 2 == 0:\n        # For even number of moves, the positions transform as follows:\n        transformed_positions = {0: 0, 1: 2, 2: 1}\n    else:\n        # For odd number of moves, the positions transform differently:\n        transformed_positions = {0: 1, 1: 0, 2: 2}\n\n    # Find the initial position by reversing the transformation\n    initial_position = transformed_positions[final_shell]\n    return initial_position\n\n# Read input values\nn = int(input())\nx = int(input())\n\n# Calculate and print the initial position\nprint(find_initial_position(n, x))"}
{"solution": "def check_square(rectangles):\n    import collections\n    \n    Point = collections.namedtuple('Point', ['x', 'y'])\n    \n    def is_square(points):\n        if len(points) != 4:\n            return False\n        \n        def distance(p1, p2):\n            return ((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2) ** 0.5\n        \n        distances = [distance(points[i], points[(i + 1) % 4]) for i in range(4)]\n        diagonal_distance = distance(points[0], points[2])\n        \n        return all(d == distances[0] for d in distances) and diagonal_distance == distances[0] * (2 ** 0.5)\n    \n    points = set()\n    \n    for x1, y1, x2, y2 in rectangles:\n        points.add(Point(x1, y1))\n        points.add(Point(x2, y1))\n        points.add(Point(x1, y2))\n        points.add(Point(x2, y2))\n    \n    return 'YES' if is_square(list(points)) else 'NO'\n\n# Reading input\nn = int(input())\nrectangles = [list(map(int, input().split())) for _ in range(n)]\n\n# Printing output\nprint(check_square(rectangles))"}
{"solution": "def count_really_big_numbers(n, s):\n    def count_digits(num):\n        return sum(int(digit) for digit in str(num))\n    \n    count = 0\n    for x in range(1, n + 1):\n        if x - count_digits(x) >= s:\n            count += 1\n    return count\n\n# Reading input\nn, s = map(int, input().split())\n\n# Processing and printing output\nprint(count_really_big_numbers(n, s))"}
{"solution": "from collections import defaultdict\ndef check(points):\n    slopes = defaultdict(int)\n    for (x1, y1) in points:\n        for (x2, y2) in points:\n            if (x1, y1) != (x2, y2):\n                dx = x2 - x1\n                dy = y2 - y1\n                gcd = abs(dx) + abs(dy)  # Simplify the slope\n                dx //= gcd\n                dy //= gcd\n                slopes[(dx, dy)] += 1\n    return max(slopes.values()) >= len(points) // 2\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\nprint('YES' if check(points) else 'NO')"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(a, b, k, t):\n    dp = [[0] * (2 * k + 1) for _ in range(t + 1)]\n    mid = k\n    dp[0][mid] = 1\n\n    for turn in range(1, t + 1):\n        new_dp = [0] * (2 * k + 1)\n        for diff in range(2 * k + 1):\n            for x in range(-k, k + 1):\n                prev_diff = diff - x\n                if 0 <= prev_diff < 2 * k + 1:\n                    new_dp[diff] += dp[turn - 1][prev_diff]\n                    new_dp[diff] %= MOD\n        dp[turn] = new_dp\n\n    result = 0\n    for diff in range(k + 1, 2 * k + 1):  # Only positive differences where Memory wins\n        adjusted_diff = diff - (b - a)\n        if 0 <= adjusted_diff < 2 * k + 1:\n            result += dp[t][adjusted_diff]\n            result %= MOD\n\n    return result\n\n# Read input\na, b, k, t = map(int, input().split())\nprint(solve(a, b, k, t))"}
{"solution": "def min_marks(n, l, x, y, marks):\n    def find_mark(distance):\n        lo, hi = 0, n\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if marks[mid] == distance:\n                return True\n            elif marks[mid] < distance:\n                lo = mid + 1\n            else:\n                hi = mid\n        return False\n\n    missing_x = x not in marks[1:-1]\n    missing_y = y not in marks[1:-1]\n\n    if missing_x and missing_y:\n        result = [x, y]\n    elif missing_x:\n        result = [x]\n    elif missing_y:\n        result = [y]\n    else:\n        result = []\n\n    return len(result), result\n\nif __name__ == \"__main__\":\n    n, l, x, y = map(int, input().split())\n    marks = list(map(int, input().split()))\n    v, positions = min_marks(n, l, x, y, marks)\n    print(v)\n    print(' '.join(map(str, positions)))"}
{"solution": "import math\n\ndef cake_volume(radius, height):\n    return math.pi * radius**2 * height\n\ndef max_cake_volume(n, cakes):\n    volumes = [cake_volume(r, h) for r, h in cakes]\n    dp = [0] * n\n    result = 0\n\n    for i in range(n):\n        dp[i] = volumes[i]\n        for j in range(i):\n            if volumes[i] > volumes[j] and dp[i] < dp[j] + volumes[i]:\n                dp[i] = dp[j] + volumes[i]\n        if result < dp[i]:\n            result = dp[i]\n\n    return result\n\nif __name__ == \"__main__\":\n    n = int(input())\n    cakes = [tuple(map(int, input().split())) for _ in range(n)]\n    print(max_cake_volume(n, cakes))"}
{"solution": "def min_good_slices(n, k, heights):\n    \"\"\"\n    Calculate the minimum number of good slices to make all towers have the same height.\n    \"\"\"\n    def is_possible(cuts):\n        cut_sum = 0\n        target_height = float('inf')\n        for height in heights:\n            if height > target_height:\n                cut_sum += height - target_height\n            else:\n                target_height = min(target_height, height + cuts)\n            if cut_sum > k:\n                return False\n        return True\n\n    low, high = 0, max(heights) - min(heights) + 1\n    while low < high:\n        mid = (low + high) // 2\n        if is_possible(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\n# Example check function (not part of the solution)\ndef check_solution():\n    assert min_good_slices(5, 5, [3, 1, 2, 2, 4]) == 2\n    assert min_good_slices(4, 5, [2, 3, 4, 5]) == 2\n    print(\"All tests passed!\")\n\ncheck_solution()"}
{"solution": "def max_game_score(n, cards):\n    \"\"\"\n    Calculate the maximum score Alice can achieve in the card game.\n    \"\"\"\n    prefix_sum = [0]\n    for card in cards:\n        prefix_sum.append(prefix_sum[-1] + card)\n\n    max_score = float('-inf')\n    left_prefix_sum = [0] * (n + 2)\n    right_prefix_sum = [0] * (n + 2)\n\n    for i in range(1, n + 1):\n        max_score = max(max_score, prefix_sum[i] - left_prefix_sum[i])\n        left_prefix_sum[i + 1] = max(left_prefix_sum[i], prefix_sum[i] - prefix_sum[i - 2])\n\n    for i in range(n, 0, -1):\n        max_score = max(max_score, prefix_sum[n] - prefix_sum[i] - right_prefix_sum[i])\n        right_prefix_sum[i - 1] = max(right_prefix_sum[i], prefix_sum[n] - prefix_sum[i - 1] - prefix_sum[n - 2] + prefix_sum[i - 3])\n\n    return max_score\n\n# Reading input\nn = int(input())\ncards = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(max_game_score(n, cards))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(k1, k2, k3):\n    lcm12 = lcm(k1, k2)\n    lcm13 = lcm(k1, k3)\n    lcm23 = lcm(k2, k3)\n    lcm123 = lcm(lcm12, k3)\n\n    # Check if there's any moment where all are off\n    if lcm123 == lcm12 or lcm123 == lcm13 or lcm123 == lcm23:\n        return \"NO\"\n    else:\n        return \"YES\"\n\n# Read input\nk1, k2, k3 = map(int, input().split())\n\n# Output result\nprint(solve(k1, k2, k3))"}
{"solution": "def min_operations_to_delete(s):\n    n = len(s)\n    dp = [1] * n  # Initialize DP array with 1s, as each character is a single group by itself\n    \n    for i in range(n - 2, -1, -1):\n        if s[i] == s[i + 1]:\n            dp[i] = dp[i + 1]\n        else:\n            dp[i] = 1 + dp[i + 1]\n    \n    return dp[0]\n\n# Read input\nn = int(input())\ns = input()\n\n# Calculate and print result\nprint(min_operations_to_delete(s))"}
{"solution": "def max_dance_pairs():\n    \"\"\"This function reads the number of boys and their dancing skills, \n    the number of girls and their dancing skills, and returns the maximum \n    number of pairs that can be formed such that the difference in dancing \n    skills between partners is at most one.\"\"\"\n    n = int(input())\n    boys = list(map(int, input().split()))\n    m = int(input())\n    girls = list(map(int, input().split()))\n\n    boys.sort()\n    girls.sort()\n\n    max_pairs = 0\n    i, j = 0, 0\n    while i < n and j < m:\n        if abs(boys[i] - girls[j]) <= 1:\n            max_pairs += 1\n            i += 1\n            j += 1\n        elif boys[i] < girls[j]:\n            i += 1\n        else:\n            j += 1\n\n    return max_pairs\n\nresult = max_dance_pairs()\nprint(result)"}
{"solution": "def team_victory(a, b, c, d):\n    # Checking if Team 1 can guarantee a win\n    if max(a[1], b[1]) > min(c[0], d[0]) and max(a[0], b[0]) > min(c[1], d[1]):\n        return \"Team 1\"\n    # Checking if Team 2 can guarantee a win\n    if max(c[1], d[1]) > min(a[0], b[0]) and max(c[0], d[0]) > min(a[1], b[1]):\n        return \"Team 2\"\n    # If neither team can guarantee a win\n    return \"Draw\"\n\n# Reading input\nplayers = [list(map(int, input().split())) for _ in range(4)]\n\n# Determining and printing the winner or declaring a draw\nprint(team_victory(players[0], players[1], players[2], players[3]))"}
{"solution": "import heapq\nimport math\nfrom typing import List\n\ndef solve_meat_grilling(N: int, K: int, meats: List[List[int]]) -> float:\n    def is_k_or_more_ready(t: float) -> bool:\n        # Find K closest points based on the distance * c_i\n        closest = [(math.inf, -1) for _ in range(K)]\n        for i, (x, y, c) in enumerate(meats):\n            dist = math.sqrt(x ** 2 + y ** 2)\n            time_to_cook = c * dist\n            if time_to_cook <= t:\n                heapq.heappush(closest, (time_to_cook, i))\n                if len(closest) > K:\n                    heapq.heappop(closest)\n\n        return closest[0][0] <= t\n\n    # Binary search for the minimum time\n    left, right = 0.0, 10000.0\n    while right - left > 1e-6:\n        mid = (left + right) / 2\n        if is_k_or_more_ready(mid):\n            right = mid\n        else:\n            left = mid\n\n    return (left + right) / 2\n\n# Reading input\nN, K = map(int, input().split())\nmeats = [list(map(int, input().split())) for _ in range(N)]\n\n# Solving and printing the result\nprint(solve_meat_grilling(N, K, meats))"}
{"solution": "def main():\n    n = int(input())\n    ticket = input()\n    \n    left_sum, right_sum = 0, 0\n    left_q, right_q = 0, 0\n    \n    for i, char in enumerate(ticket):\n        if i < n // 2:\n            left_q += char == '?'\n            left_sum += 0 if char == '?' else int(char)\n        else:\n            right_q += char == '?'\n            right_sum += 0 if char == '?' else int(char)\n    \n    q_diff = abs(left_q - right_q)\n    sum_diff = abs(left_sum - right_sum)\n    \n    if sum_diff != 9 * (q_diff // 2):\n        print(\"Monocarp\")\n    else:\n        print(\"Bicarp\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_bus_route(n, t, routes):\n    closest_time = float('inf')\n    closest_route = None\n\n    for i, (s, d) in enumerate(routes, start=1):\n        if s < t:\n            # Calculate the arrival time of the next bus\n            arrival_time = s + ((t - s) // d + (1 if (t - s) % d != 0 else 0)) * d\n        else:\n            arrival_time = s\n\n        if arrival_time < closest_time:\n            closest_time = arrival_time\n            closest_route = i\n\n    return closest_route\n\n# Reading input\nn, t = map(int, input().split())\nroutes = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Outputting the result\nprint(find_bus_route(n, t, routes))"}
{"solution": "def count_set_bits(n):\n    count = 0\n    while n:\n        n &= (n - 1)\n        count += 1\n    return count\n\ndef find_n(m, k):\n    low, high = 1, 10**18\n    while low <= high:\n        mid = (low + high) // 2\n        count = sum(1 for i in range(mid + 1, 2 * mid + 1) if count_set_bits(i) == k)\n        if count == m:\n            return mid\n        elif count < m:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\nm, k = map(int, input().split())\nprint(find_n(m, k))"}
{"solution": "def is_good_level(level_str):\n    n = len(level_str)\n    for d in range(1, n // 4 + 1):\n        for i in range(n - 4 * d + 1):\n            if (level_str[i] == '*' and level_str[i + d] == '*' and\n                    level_str[i + 2 * d] == '*' and level_str[i + 3 * d] == '*' and\n                    level_str[i + 4 * d] == '*'):\n                return \"yes\"\n    return \"no\"\n\n# Reading input\nn = int(input())\nlevel_scheme = input()\n\n# Printing output\nprint(is_good_level(level_scheme))"}
{"solution": "import numpy as np\n\ndef find_magic_square_value(n, grid):\n    grid = np.array(grid)\n    zero_pos = np.argwhere(grid == 0)[0]\n    \n    if zero_pos[0] == zero_pos[1]:  # Main diagonal\n        diag_sum = np.sum(grid[i, i] for i in range(n))\n        target_val = diag_sum - np.sum(grid[i, i] for i in range(n) if i != zero_pos[0])\n    elif zero_pos[0] + zero_pos[1] == n - 1:  # Secondary diagonal\n        diag_sum = np.sum(grid[i, n - 1 - i] for i in range(n))\n        target_val = diag_sum - np.sum(grid[i, n - 1 - i] for i in range(n) if i != zero_pos[0])\n    else:\n        row_sum = np.sum(grid[zero_pos[0]])\n        col_sum = np.sum(grid[:, zero_pos[1]])\n        \n        if np.sum(grid[0]) != col_sum or np.any(np.sum(grid, axis=1) != col_sum) or np.any(np.sum(grid, axis=0) != col_sum):\n            return -1\n        \n        if zero_pos[0] == 0:\n            target_val = col_sum - np.sum(grid[zero_pos[0], :zero_pos[1]] + grid[zero_pos[0], zero_pos[1] + 1:])\n        elif zero_pos[1] == 0:\n            target_val = row_sum - np.sum(grid[zero_pos[0], :zero_pos[1]] + grid[zero_pos[0], zero_pos[1] + 1:])\n        else:\n            target_val_row = col_sum - np.sum(grid[zero_pos[0], :zero_pos[1]] + grid[zero_pos[0], zero_pos[1] + 1:])\n            target_val_col = row_sum - np.sum(grid[zero_pos[0], :zero_pos[1]] + grid[zero_pos[0], zero_pos[1] + 1:])\n            \n            if target_val_row != target_val_col:\n                return -1\n            \n            target_val = target_val_row\n    \n    if target_val > 0 and (zero_pos[0] == 0 or zero_pos[1] == 0 or zero_pos[0] + zero_pos[1] == n - 1):\n        return target_val\n    else:\n        return -1\n\n# Example usage\nn = int(input().strip())\ngrid = [list(map(int, input().strip().split())) for _ in range(n)]\nprint(find_magic_square_value(n, grid))"}
{"solution": "def min_max_people(n, m, benches):\n    benches.sort()\n    \n    # Calculate minimum k\n    min_k = (m + n - 1) // n\n    extra_people = m - (min_k - 1) * n\n    min_k = max(min_k, max(benches) + extra_people)\n    \n    # Calculate maximum k\n    max_k = benches[0] + m\n    \n    for i in range(1, n):\n        diff = benches[i] - benches[i - 1]\n        max_k = min(max_k + diff, benches[i] + m)\n    \n    return min_k, max_k\n\n# Read input\nn = int(input())\nm = int(input())\nbenches = [int(input()) for _ in range(n)]\n\n# Calculate and print result\nresult = min_max_people(n, m, benches)\nprint(result[0], result[1])"}
{"solution": "MOD = 10**9 + 7\n\ndef calculate_ways(n, m):\n    if n < m:\n        return 0\n    ways = 1\n    for i in range(1, m + 1):\n        ways = (ways * pow(2, i, MOD) * pow(i, n - i, MOD)) % MOD\n    return ways\n\nn, m = map(int, input().split())\nprint(calculate_ways(n, m))"}
{"solution": "from itertools import combinations\n\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef bit_set(bits, pos):\n    return bits & (1 << pos) > 0\n\ndef main():\n    n, m = read_ints()\n    friends = [0] * n\n    for i in range(n):\n        _, *ingredients = read_ints()\n        for ingredient in ingredients:\n            friends[i] |= 1 << (ingredient - 1)\n    \n    pizzas = []\n    for _ in range(m):\n        cost, *ingredients = read_ints()\n        bitset = 0\n        for ingredient in ingredients:\n            bitset |= 1 << (ingredient - 1)\n        pizzas.append((cost, bitset))\n    \n    best_pleasure = -1\n    best_cost = float('inf')\n    best_pair = None\n    \n    for (cost1, ingredients1), (cost2, ingredients2) in combinations(pizzas, 2):\n        total_ingredients = ingredients1 | ingredients2\n        pleasure = sum(1 for friend in friends if not (friend & ~total_ingredients))\n        \n        if pleasure > best_pleasure or (pleasure == best_pleasure and cost1 + cost2 < best_cost):\n            best_pleasure = pleasure\n            best_cost = cost1 + cost2\n            best_pair = (ingredients1, ingredients2, cost1, cost2)\n    \n    index1 = next(i for i, (_, bitset, _) in enumerate(pizzas) if bitset == best_pair[0])\n    index2 = next(i for i, (_, bitset, _) in enumerate(pizzas) if bitset == best_pair[1])\n    print(index1 + 1, index2 + 1)\n\nmain()"}
{"solution": "def find_min_max_numbers(m, s):\n    \"\"\"\n    Finds the minimum and maximum numbers with length m and digit sum s.\n    \"\"\"\n    def build_min(s, m):\n        num = []\n        while m > 1 and s >= 9:\n            num.append(9)\n            s -= 9\n            m -= 1\n        if s == 0 and m > 1:\n            return -1\n        num.append(s)\n        num.extend([0] * (m - len(num)))\n        return int(''.join(map(str, reversed(num))))\n\n    def build_max(s, m):\n        num = []\n        for i in range(m - 1):\n            if s > 0:\n                num.append(9)\n                s -= 9\n        if s > 0:\n            num.append(s)\n        else:\n            return -1\n        return int(''.join(map(str, num)))\n\n    min_val = build_min(s, m)\n    max_val = build_max(s, m)\n\n    return min_val, max_val\n\n# Reading input\nm, s = map(int, input().split())\nmin_num, max_num = find_min_max_numbers(m, s)\nprint(min_num, max_num)"}
{"solution": "MOD = 998244353\n\ndef count_digits(n):\n    return len(str(n))\n\ndef next_number(n, k):\n    if n == 0:\n        return 1\n    digits = [int(d) for d in str(n)]\n    unique_digits = list(set(digits))\n    \n    if len(unique_digits) <= k and len(digits) > 1:\n        # If the current number already fits the criteria and has more than one digit,\n        # the next valid number could be the next integer.\n        next_num = n + 1\n    else:\n        # Otherwise, try to form the next valid number by incrementing digits.\n        next_num = ''\n        for i, digit in enumerate(digits):\n            if len(set(next_num + str(digit))) <= k:\n                next_num += str(digit)\n            else:\n                # If adding the current digit exceeds unique digits limit, find next valid digit.\n                for next_d in range(digit + 1, 10):\n                    if len(set(next_num + str(next_d))) <= k:\n                        next_num += str(next_d)\n                        break\n                break\n        else:  # No break occurred, meaning we can use all digits.\n            if len(set(next_num)) <= k:\n                next_num = int(next_num) + 1\n            else:\n                next_num = ''  # Reset if no valid next number found.\n    \n    # Handle case where no valid next number exists within the same length.\n    if not next_num or len(next_num) > len(str(n)):\n        next_num = '1' * (len(str(n)) - len(next_num) + 1)\n    \n    return int(next_num)\n\ndef sum_numbers(l, r, k):\n    total_sum = 0\n    current = max(1, l - 1)\n    while current <= r:\n        if count_digits(current) <= k:\n            total_sum += current\n            total_sum %= MOD\n        current = next_number(current, k)\n    return total_sum\n\n# Reading input\nl, r, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(sum_numbers(l, r, k))"}
{"solution": "def can_distribute_pencils(n, k, d, pencils):\n    pencils.sort()\n    box_start = 0\n    for i in range(1, n):\n        if pencils[i] - pencils[box_start] > d or (i - box_start + 1) == k:\n            box_start = i\n    boxes_needed = (n - box_start) % k\n    return \"YES\" if boxes_needed == 0 else \"NO\"\n\n# Example usage:\n# n, k, d = map(int, input().split())\n# pencils = list(map(int, input().split()))\n# print(can_distribute_pencils(n, k, d, pencils))"}
{"solution": "def count_dead_bulbs(garland_str):\n    colors = 'RGBY'\n    color_counts = {color: 0 for color in colors}\n    total_count = {color: 0 for color in colors}\n    \n    for i in range(len(garland_str)):\n        if garland_str[i] == '!':\n            prev_color = garland_str[i-1] if i > 0 else None\n            next_color = garland_str[(i+1)%len(garland_str)]\n            \n            for color in colors:\n                if color != prev_color and color != next_color:\n                    color_counts[color] += 1\n                    break\n        else:\n            total_count[garland_str[i]] += 1\n    \n    for color in colors:\n        if total_count[color] > 0:\n            color_counts[color] = max(0, color_counts[color] - total_count[color])\n    \n    return ' '.join(str(color_counts[color]) for color in 'RGBY')\n\n# Example usage\nprint(count_dead_bulbs('RYBGRYBGR'))  # Output: 0 0 0 0\nprint(count_dead_bulbs('!RGYB'))      # Output: 0 1 0 0\nprint(count_dead_bulbs('!!!!YGRB'))   # Output: 1 1 1 1\nprint(count_dead_bulbs('!GB!RG!Y!'))  # Output: 2 1 1 0\n# Note: This function directly processes the input string and prints the output.\n# It assumes the input string is correctly formatted as per the problem statement."}
{"solution": "from collections import defaultdict, deque\nimport sys\ninput = sys.stdin.readline\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.graph = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    def bfs(self, start):\n        queue = deque([start])\n        dist = {start: 0}\n        order = []\n        while queue:\n            u = queue.popleft()\n            order.append(u)\n            for v in self.graph[u]:\n                if v not in dist:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return order, dist\n\ndef solve():\n    N, M = map(int, input().split())\n    g = Graph(N)\n    for _ in range(M):\n        u, v = map(int, input().split())\n        g.add_edge(u, v)\n    \n    _, dist = g.bfs(1)\n    dp = [float('inf')] * N\n    dp[N] = 0\n    for u in reversed(g.bfs(1)[0]):\n        if u == 1:\n            break\n        total = sum(dp[v] for v in g.graph[u]) + len(g.graph[u])\n        dp[u] = total / len(g.graph[u])\n    \n    min_expectation = dp[1]\n    for v in g.graph[1]:\n        blocked = [dp[w] for w in g.graph[1] if w != v]\n        if blocked:\n            expectation = (sum(blocked) + len(g.graph[1]) - 1) / (len(g.graph[1]) - 1) + dist[v] - dist[1]\n            min_expectation = min(min_expectation, expectation)\n    print(f\"{min_expectation:.10f}\")\n\nsolve()"}
{"solution": "def round_to_nearest_ten(n):\n    last_digit = n % 10\n    if last_digit < 5:\n        return n - last_digit\n    else:\n        return n + (10 - last_digit)\n\nn = int(input())\nresult = round_to_nearest_ten(n)\nprint(result)"}
{"solution": "def solve(s, t):\n    if s == t:\n        return [0]\n\n    from collections import defaultdict\n    swaps = []\n    indexes = defaultdict(list)\n\n    for i, (char_s, char_t) in enumerate(zip(s, t)):\n        if char_s != char_t:\n            indexes[char_s].append(i)\n            indexes[char_t].append(i)\n\n    for char_s, char_t in zip(s, t):\n        if char_s != char_t:\n            if indexes[char_s][-1] == indexes[char_t][0]:\n                swaps.append((char_s, char_t))\n                indexes[char_s].pop()\n                indexes[char_t].pop(0)\n\n    if len(indexes) > 0:\n        return [-1]\n\n    return [len(swaps)] + swaps\n\nif __name__ == \"__main__\":\n    s = input().strip()\n    t = input().strip()\n\n    result = solve(s, t)\n    if result[0] == -1:\n        print(-1)\n    else:\n        print(result[0])\n        for swap in result[1:]:\n            print(\" \".join(swap))"}
{"solution": "def earliest_login(first_name, last_name):\n    for i in range(1, len(first_name) + 1):\n        for j in range(1, len(last_name) + 1):\n            login = first_name[:i] + last_name[:j]\n            return login  # Returning the first possible login, which is also the earliest alphabetically\n    return \"\"  # Fallback, should not reach here if input constraints are met\n\n# Reading input\nfirst_name, last_name = input().split()\n\n# Processing and printing output\nprint(earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(sequence):\n    def draw_part(part, level=0):\n        if not part:\n            return [\"\"] * level\n        mid = len(part) // 2\n        left = draw_part(part[:mid], level + 1)\n        right = draw_part(part[mid + 1:], level + 1)\n        max_len = max(len(left), len(right))\n        top = ['+' + ('-' * (max_len * 2 - 1)) + '+' + ('-' * 2) + '+' + ('-' * (max_len * 2 - 1)) + '+']\n        combined = [l + ' ' + r for l, r in zip(left[-max_len:], right[-max_len:])]\n        combined.extend(left[max_len:])\n        combined.extend(right[max_len:])\n        result = [top[0]] + ['|' + line + ' | ' + line + ' |' for line in combined]\n        return result\n\n    parts = []\n    stack = []\n    for bracket in sequence:\n        if bracket == '[':\n            if stack:\n                parts.append(''.join(stack))\n                stack = []\n            stack.append(bracket)\n        else:\n            stack.append(bracket)\n            if len(stack) == 2:\n                parts.append(''.join(stack))\n                stack = []\n\n    if stack:\n        parts.append(''.join(stack))\n\n    drawings = [draw_part(part) for part in parts]\n    max_height = max(len(drawing) for drawing in drawings)\n    final_drawing = ['' for _ in range(max_height)]\n\n    for i, drawing in enumerate(drawings):\n        for j, line in enumerate(drawing):\n            if i > 0 and j == 0:\n                final_drawing[j] += ' ' + line\n            else:\n                final_drawing[j] += line\n        if i < len(drawings) - 1:\n            final_drawing[0] += ' ' * (max_height * 2 - 1)\n\n    return '\\n'.join(final_drawing)\n\nn = int(input())\nsequence = input().strip()\nprint(draw_brackets(sequence))"}
{"solution": "from math import sqrt\n\nq = (1 + sqrt(5)) / 2\nq_map = {0: 0, 1: q}\n\ndef golden_to_decimal(golden_str):\n    global q_map\n    # Extend q_map if necessary\n    current_len = len(q_map)\n    for i in range(current_len, len(golden_str) + 1):\n        q_map[i] = q_map[i - 1] * q\n    \n    decimal_value = 0\n    for i, digit in enumerate(reversed(golden_str)):\n        if digit == '1':\n            decimal_value += q_map[i]\n    return decimal_value\n\n# Read inputs\nnum1 = input().strip()\nnum2 = input().strip()\n\n# Convert to decimal\ndec_num1 = golden_to_decimal(num1)\ndec_num2 = golden_to_decimal(num2)\n\n# Compare and print result\nif dec_num1 > dec_num2:\n    print('>')\nelif dec_num1 < dec_num2:\n    print('<')\nelse:\n    print('=')"}
{"solution": "def find_absent_gems(colors_seen):\n    gem_colors = {\n        \"purple\": \"Power\",\n        \"green\": \"Time\",\n        \"blue\": \"Space\",\n        \"orange\": \"Soul\",\n        \"red\": \"Reality\",\n        \"yellow\": \"Mind\"\n    }\n\n    gems_present = set()\n    for color in colors_seen:\n        gems_present.add(gem_colors[color])\n\n    all_gems = set(gem_colors.values())\n    absent_gems = all_gems - gems_present\n\n    print(len(absent_gems))\n    for gem in absent_gems:\n        print(gem)\n\n# Example usage\nif __name__ == \"__main__\":\n    n = int(input())\n    colors_seen = [input() for _ in range(n)]\n    find_absent_gems(colors_seen)"}
{"solution": "def find_meeting_round(n, a, b):\n    while a != b:\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n //= 2\n        if n == 1 and a == b:\n            return \"Final!\"\n    return n\n\nn, a, b = map(int, input().split())\nprint(find_meeting_round(n, min(a, b), max(a, b)))"}
{"solution": "from collections import defaultdict\n\ndef find_cycle_length(n, p, b):\n    visited = [False] * (n + 1)\n    cycle_lengths = []\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            length = 0\n            j = i\n            while not visited[j]:\n                visited[j] = True\n                length += 1\n                j = p[j - 1]\n            cycle_lengths.append(length)\n    \n    changes_needed = 0\n    for length in cycle_lengths:\n        if length % 2 == 0:\n            changes_needed += 1\n    \n    return changes_needed\n\ndef main():\n    n = int(input())\n    p = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    # Adjust p to be 1-indexed\n    for i in range(n):\n        p[i] -= 1\n\n    # Build graph\n    graph = defaultdict(list)\n    for i in range(n):\n        graph[i].append((p[i], b[i]))\n\n    # Find cycles and their lengths\n    visited = [False] * n\n    cycles = []\n\n    def dfs(node, cycle):\n        if visited[node]:\n            return\n        visited[node] = True\n        cycle.append(node)\n        next_node, reverse = graph[node][0]\n        dfs(next_node, cycle)\n\n    for i in range(n):\n        if not visited[i]:\n            cycle = []\n            dfs(i, cycle)\n            cycles.append(len(cycle))\n\n    # Calculate minimum changes needed\n    min_changes = 0\n    for length in cycles:\n        if length % 2 == 0:\n            min_changes += 1\n\n    print(min_changes)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_distance(v1, v2, t, d):\n    import math\n    if d == 0 or v1 == v2:\n        return v1 * t\n    else:\n        meet_time = (v1 - v2 + d) / (2 * d)\n        if meet_time >= t - 1:\n            slow_down_time = v1 / d\n            if slow_down_time >= t:\n                return 0.5 * d * t ** 2\n            elif slow_down_time + (v1 + v2) / d <= t:\n                return 0.5 * d * (slow_down_time ** 2) + (v1 + v2) / d * (t - slow_down_time) - 0.5 * d * ((t - slow_down_time) ** 2)\n            else:\n                return v2 * t + d * (t - (v1 + v2) / (2 * d)) ** 2\n        else:\n            return v2 * t + d * (t - (v1 + v2) / (2 * d)) ** 2\n\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\nprint(int(max_distance(v1, v2, t, d)))"}
{"solution": "from bisect import bisect_left\nfrom itertools import accumulate\n\ndef check(D):\n    pos = [0] + [D * i for i in range(1, N + 1)]\n    for i in range(M):\n        left = bisect_left(pos, L[i])\n        right = bisect_left(pos, L[i] + D)\n        if sum(W[max(0, left - 1):right]) > V[i]:\n            return False\n    return True\n\nN, M = map(int, input().split())\nW = list(map(int, input().split()))\nL, V = zip(*[map(int, input().split()) for _ in range(M)])\nacc = [0] + list(accumulate(W))\nleft, right = 0, sum(W)\n\nwhile right - left > 1:\n    mid = (left + right) // 2\n    if check(mid):\n        right = mid\n    else:\n        left = mid\n\nif check(left):\n    print(left)\nelse:\n    print(-1)"}
{"solution": "from math import factorial\n\ndef last_digit_of_factorial_division(a, b):\n    \"\"\"\n    Calculate the last digit of the division of two factorials.\n    \"\"\"\n    if b >= 5 and a >= 5:\n        return 0\n\n    last_digit_a = 1 if a == 0 else factorial(a) % 10\n    last_digit_b = 1 if b == 0 else factorial(b) % 10\n\n    # Find the last digit of the division result\n    for i in range(a + 1, b + 1):\n        last_digit_a = (last_digit_a * (i % 10)) % 10\n\n    return last_digit_a\n\n# Read input\na, b = map(int, input().split())\n\n# Output the last digit\nprint(last_digit_of_factorial_division(a, b))"}
{"solution": "def min_jumps(n, d, lily_pads):\n    dp = [float('inf')] * n\n    dp[0] = 0\n    for i in range(1, n):\n        for j in range(max(0, i-d), i):\n            if lily_pads[i] == '1' and lily_pads[j] == '1':\n                dp[i] = min(dp[i], dp[j] + 1)\n    return dp[-1] if dp[-1] != float('inf') else -1\n\nif __name__ == \"__main__\":\n    n, d = map(int, input().split())\n    lily_pads = input()\n    print(min_jumps(n, d, lily_pads))"}
{"solution": "def find_counterexample(n):\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\ndef is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num ** 0. 5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\nn = int(input())\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all(n):\n    if n < 1234:\n        return \"NO\"\n\n    for a in range(n // 1234567 + 1):\n        remaining_after_houses = n - a * 1234567\n        max_b = remaining_after_houses // 123456\n\n        for b in range(max_b + 1):\n            remaining_after_cars = remaining_after_houses - b * 123456\n            if remaining_after_cars % 1234 == 0:\n                return \"YES\"\n    return \"NO\"\n\nn = int(input())\nprint(can_spend_all(n))"}
{"solution": "from sys import stdin, stdout\nfrom math import gcd\n\ndef input(): return stdin.readline().strip()\ndef write(*args, sep=\" \"): return stdout.write(sep.join(map(str, args)) + \"\\n\")\n\ndef solve():\n    n = int(input())\n    x1, x2 = map(int, input().split())\n    lines = []\n    for _ in range(n):\n        k, b = map(int, input().split())\n        lines.append((k, b))\n    \n    # Sort lines based on their intersection with vertical line x = x1\n    lines.sort(key=lambda line: line[0]*x1 + line[1])\n    \n    for i in range(n):\n        ki, bi = lines[i]\n        for j in range(i+1, n):\n            kj, bj = lines[j]\n            # Calculate intersection point\n            x_intersect = (bj - bi) / (ki - kj)\n            # Check if intersection point is within the strip\n            if x1 < x_intersect < x2:\n                write(\"YES\")\n                return\n    write(\"NO\")\n\nsolve()"}
{"solution": "def count_possible_weights(n):\n    return min(n, (1 + 8 * n) ** 0.5 // 2)\n\n# Reading an integer from the input\nn = int(input())\n\n# Printing the result\nprint(int(count_possible_weights(n)))"}
{"solution": "def find_good_apartments(n, k):\n    if k == 0:\n        min_good = 0\n        max_good = 0\n    else:\n        min_good = (k - 1)\n        max_good = n - k\n\n    if k >= n - 1:\n        min_good = n - k\n        max_good = n - 1\n\n    print(min_good, max_good)\n\nn, k = map(int, input().split())\nfind_good_apartments(n, k)"}
{"solution": "def max_games(winner):\n    games_played = 0\n    remaining_players = winner - 1\n\n    while remaining_players > 0:\n        games_to_play = min(games_played + 1, remaining_players)\n        games_played += games_to_play\n        remaining_players -= games_to_play\n\n    return games_played\n\nn = int(input())\nprint(max_games(n))"}
{"solution": "def max_vk_occurrences(s):\n    n = len(s)\n    vk_count = 0\n    v_count = 0\n    k_after_v = 0\n\n    for i in range(n):\n        if s[i] == 'V':\n            v_count += 1\n            k_after_v = 0\n        elif s[i] == 'K' and v_count > 0:\n            vk_count += 1\n            v_count -= 1\n        else:\n            k_after_v = 1 if v_count > 0 else 0\n\n    possible_extra = min(v_count, 1) + k_after_v\n\n    return vk_count + possible_extra\n\n# Read input\ns = input().strip()\n\n# Calculate and print the result\nprint(max_vk_occurrences(s))"}
{"solution": "def min_segments(n):\n    return 2 * ((n // 2) + (n % 2))\n\n# Reading input\nn = int(input())\n\n# Calculating and printing output\nprint(min_segments(n))"}
{"solution": "def bear_weights(a, b):\n    years = 0\n    while a <= b:\n        a *= 3\n        b *= 2\n        years += 1\n    return years\n\na, b = map(int, input().split())\nprint(bear_weights(a, b))"}
{"solution": "def calculate_visited_nodes(h, n):\n    \"\"\"\n    Calculate the number of nodes visited before reaching the exit in a perfect binary tree.\n    \n    :param h: Height of the tree.\n    :param n: The exit node number.\n    :return: Number of nodes visited before reaching the exit.\n    \"\"\"\n    result = 0\n    for i in range(h - 1, -1, -1):\n        half_level_size = 2 ** i\n        if n > half_level_size:\n            result += 1 << i\n            n -= half_level_size\n        result += 1\n    return result - 1\n\n# Read input\nh, n = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_visited_nodes(h, n))"}
{"solution": "from math import sqrt\n\ndef find_tables(x):\n    def calculate_squares(n, m):\n        return sum(min(n, m - i) for i in range(m))\n\n    result = []\n    max_n = int(sqrt(2 * x)) + 1\n    for n in range(1, max_n + 1):\n        low, high = 1, max_n\n        while low <= high:\n            m = (low + high) // 2\n            num_squares = calculate_squares(n, m)\n            if num_squares == x:\n                result.append((n, m))\n                break\n            elif num_squares < x:\n                low = m + 1\n            else:\n                high = m - 1\n    return result\n\nx = int(input())\ntables = find_tables(x)\nprint(len(tables))\nfor table in sorted(tables):\n    print(*table)"}
{"solution": "def is_leap(year):\n    return year % 400 == 0 or (year % 4 == 0 and year % 100 != 0)\n\ndef check_months(days):\n    feb_days = 29 if is_leap(2000) else 28\n    months = [31, feb_days, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    for i in range(12):\n        if all(months[(i + j) % 12] == d for j, d in enumerate(days)):\n            return True\n    return False\n\nn = int(input())\na = list(map(int, input().split()))\n\nprint(\"Yes\" if check_months(a) else \"No\")"}
{"solution": "from math import gcd\n\ndef find_sequence(n):\n    \"\"\"\n    Finds a sequence of fractions that sum up to 1 - 1/n.\n    \"\"\"\n    def decompose(target, divisors, used):\n        if target[0] == 0:\n            return []\n        for divisor in divisors:\n            if divisor in used:\n                continue\n            a, b = target\n            if b % divisor == 0:\n                new_a = a * (b // divisor)\n                new_b = b\n                if new_a < new_b:\n                    remaining = (new_a, new_b)\n                    used.add(divisor)\n                    subsequence = decompose(remaining, divisors, used)\n                    if subsequence is not None:\n                        return [(new_a, new_b)] + subsequence\n                    used.remove(divisor)\n        return None\n\n    divisors = {d for d in range(2, n) if n % d == 0}\n    target = (n - 1, n)\n    sequence = decompose(target, divisors, set())\n    if sequence is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(len(sequence))\n        for a, b in sequence:\n            print(f\"{a} {b}\")\n\ndef main():\n    n = int(input())\n    find_sequence(n)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef min_unattractiveness(n, limits, heights):\n    a, b = limits\n    dp = [[sys.maxsize] * 2 for _ in range(n + 1)]\n    dp[0][0], dp[0][1] = 0, 0\n    a_used, b_used = [0] * (n + 1), [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        for j in range(2):\n            color = j ^ 1\n            new_a_used, new_b_used = a_used[i - 1], b_used[i - 1]\n            if color == 0:\n                new_a_used += heights[i - 1]\n            else:\n                new_b_used += heights[i - 1]\n\n            if (color == 0 and new_a_used <= a) or (color == 1 and new_b_used <= b):\n                cost = dp[i - 1][j] + (1 if j != color else 0)\n                if cost < dp[i][color]:\n                    dp[i][color] = cost\n                    a_used[i] = new_a_used\n                    b_used[i] = new_b_used\n\n    if min(a_used[n], b_used[n]) > max(a, b):\n        return -1\n\n    return min(dp[n])\n\n# Reading input\nn = int(input())\nlimits = list(map(int, input().split()))\nheights = list(map(int, input().split()))\n\nprint(min_unattractiveness(n, limits, heights))"}
{"solution": "from math import gcd\n\ndef solve(n, m, k):\n    area = n * m // k\n    if area * 2 > n * m:\n        return \"NO\"\n    \n    # Check if we can form a triangle with the given area\n    if n % 2 == 0 or m % 2 == 0 or area % 2 == 0:\n        if n >= 1 and m >= 2 * area:\n            return \"YES\", [(0, 0), (0, 2 * area), (1, m)]\n        elif m >= 1 and n >= 2 * area:\n            return \"YES\", [(0, 0), (2 * area, 0), (n, 1)]\n    else:\n        g = gcd(n, m)\n        if g >= 2 * area:\n            return \"YES\", [(0, 0), (g, 0), (0, g)]\n    \n    return \"NO\"\n\n# Reading input\nn, m, k = map(int, input().split())\n\nresult = solve(n, m, k)\nprint(result[0])\nif result[0] == \"YES\":\n    for point in result[1]:\n        print(*point)"}
{"solution": "def sasha_wins(n, k):\n    remaining_sticks = n\n    moves = 0\n    \n    while remaining_sticks >= k:\n        remaining_sticks -= k\n        moves += 1\n    \n    # Sasha wins if he makes more moves than Lena\n    return \"YES\" if moves % 2 == 1 else \"NO\"\n\n# Read input from stdin\nn, k = map(int, input().split())\n\n# Print the result to stdout\nprint(sasha_wins(n, k))"}
{"solution": "def main():\n    n = int(input())\n    exercises = list(map(int, input().split()))\n    \n    chest = biceps = back = 0\n    for i, e in enumerate(exercises):\n        if i % 3 == 0:\n            chest += e\n        elif i % 3 == 1:\n            biceps += e\n        else:\n            back += e\n    \n    if chest > biceps and chest > back:\n        print(\"chest\")\n    elif biceps > chest and biceps > back:\n        print(\"biceps\")\n    else:\n        print(\"back\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_redo_for_grade_five(n, grades):\n    \"\"\"\n    Calculate the minimum number of lab works Vasya needs to redo to get a grade of 5.\n    \"\"\"\n    total = sum(grades)\n    redo_count = 0\n    \n    # Try to increase the average to 5 by redoing the minimum number of lab works.\n    while True:\n        if (total + 5 * redo_count) // (n + redo_count) < 5:\n            redo_count += 1\n        else:\n            break\n    \n    return redo_count\n\n# Reading input\nn = int(input())\ngrades = list(map(int, input().split()))\n\n# Printing output\nprint(min_redo_for_grade_five(n, grades))"}
{"solution": "def solve(u, v):\n    if v < u:\n        return [-1]\n\n    if u == 0:\n        return [v] if v % 2 == 0 else [2, (v - 2) // 2, (v - 2) // 2]\n    \n    n = 1 + bin(u).count('1')\n    if v < n * (u & -u):\n        n = v // (u & -u)\n        if v % (u & -u) > 0: n += 1\n    \n    a = [u & -u] * (n - 1) + [u + (n - 1) * (u & -u)]\n    if sum(a) != v: a[-1] = u + (n - 1) * (u & -u) - ((n) * (u & -u) - v)\n    return [len(a)] + a\n\nu, v = map(int, input().split())\nresult = solve(u, v)\nprint(result[0])\nprint(' '.join(map(str, result[1:])))"}
{"solution": "def min_ones(n):\n    ones = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    for i in range(11, n + 1):\n        min_val = float('inf')\n        j = 1\n        while j <= len(str(i)) + 1 and j * 11 <= i:\n            min_val = min(min_val, ones[i - j * 11], min_val)\n            j *= 10\n        ones.append(min_val + 1)\n    return ones[n]\n\n# Reading the input\nn = int(input())\n# Printing the output\nprint(min_ones(n))"}
{"solution": "def can_reach_treasure(start, target, move_values):\n    dx = target[0] - start[0]\n    dy = target[1] - start[1]\n\n    gcd_val = gcd(move_values[0], move_values[1])\n\n    return (dx % gcd_val == 0) and (dy % gcd_val == 0)\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\nstart_position = (x1, y1)\ntreasure_position = (x2, y2)\npotion_values = (x, y)\n\n# Check if Captain Bill the Hummingbird can reach the treasure\nif can_reach_treasure(start_position, treasure_position, potion_values):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "from collections import Counter\nfrom math import factorial\n\ndef find_permutations(counter):\n    total = factorial(sum(counter.values()))\n    for count in counter.values():\n        total //= factorial(count)\n    return total\n\ndef solve(n):\n    str_n = str(n)\n    digits = sorted(set(str_n))\n    total_permutations = 0\n\n    for digit in digits:\n        if digit != '0':\n            temp_counter = Counter(str_n)\n            if digit == '0':\n                temp_counter[digit] -= 1\n            total_permutations += find_permutations(temp_counter)\n\n    return total_permutations\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def max_suit_value():\n    a = int(input())  # Ties\n    b = int(input())  # Scarves\n    c = int(input())  # Vests\n    d = int(input())  # Jackets\n    e = int(input())  # Cost of suit type 1\n    f = int(input())  # Cost of suit type 2\n\n    # Calculate max suits for each type based on jackets available\n    max_type1 = min(a, d)\n    max_type2 = min(b, c, d)\n\n    if e >= f:\n        # Prioritize type 1 if it's equal or more valuable\n        value = max_type1 * e\n        remaining_jackets = d - max_type1\n        value += min(max_type2, remaining_jackets) * f\n    else:\n        # Prioritize type 2 if it's more valuable\n        value = max_type2 * f\n        remaining_jackets = d - max_type2\n        value += min(max_type1, remaining_jackets) * e\n\n    print(value)\n\nmax_suit_value()"}
{"solution": "from math import gcd\nfrom itertools import accumulate\n\ndef prepare_inverse(p):\n    \"\"\"\n    Prepare a list of modular inverses for all numbers up to p-1 under modulo p.\n    \"\"\"\n    inverses = [0] * p\n    inverses[1] = 1\n    for i in range(2, p):\n        inverses[i] = (-(p // i) * inverses[p % i]) % p\n    return inverses\n\ndef prepare_factorial(p, MOD):\n    \"\"\"\n    Prepare lists of factorials and their modular inverses up to p under modulo MOD.\n    \"\"\"\n    fact = [1] * p\n    ifact = [1] * p\n    for i in range(1, p):\n        fact[i] = (fact[i - 1] * i) % MOD\n    ifact[-1] = pow(fact[-1], MOD - 2, MOD)\n    for i in range(p - 1, 0, -1):\n        ifact[i - 1] = (i * ifact[i]) % MOD\n    return fact, ifact\n\ndef prepare_pow(a, p, MOD):\n    \"\"\"\n    Precompute powers of 'a' modulo MOD for all exponents from 0 to p-1.\n    \"\"\"\n    return [pow(a, i, MOD) for i in range(p)]\n\ndef solve(a, b, p, x):\n    MOD = p\n    inv = prepare_inverse(MOD)\n    fact, ifact = prepare_factorial(MOD, MOD)\n    pa = prepare_pow(a, MOD, MOD)\n\n    def C(n, k):\n        \"\"\"Calculate binomial coefficient nCk modulo MOD.\"\"\"\n        return fact[n] * ifact[k] % MOD * ifact[n - k] % MOD\n\n    def P(n, k):\n        \"\"\"Calculate the number of k-permutations of n modulo MOD.\"\"\"\n        return fact[n] * ifact[n - k] % MOD\n\n    def S(n, k):\n        \"\"\"Calculate Stirling number of the second kind nS2k modulo MOD.\"\"\"\n        return C(n - 1, k - 1) * pow(k, n, MOD) % MOD * inv[k] % MOD\n\n    ans = 0\n    if b == 0:\n        if a == 1:\n            ans = (x // MOD) * (MOD - 1) + min(x % MOD, MOD - 1)\n        else:\n            ans = x // MOD\n        print(ans)\n        return\n\n    for i in range(MOD):\n        if pa[i] * b % MOD != 1:\n            continue\n        c = i\n        if c == 0:\n            ans += (x // MOD) * MOD + min(x % MOD, c)\n            continue\n        cur = 0\n        for k in range(1, MOD):\n            cur += S(MOD, k) * P(k, c) * inv[k]\n            cur %= MOD\n        cur *= (x // MOD)\n        cur %= MOD\n        cur += sum(pa[i] * cur for i in range(1, min(x % MOD, c) + 1))\n        cur %= MOD\n        ans += cur\n    print(ans % MOD)\n\nsolve(*list(map(int, input().split())))"}
{"solution": "def max_sum(k2, k3, k5, k6):\n    # Calculate the maximum number of '256' that can be formed\n    num_256 = min(k2, k5, k6)\n    \n    # Update counts after forming '256'\n    k2 -= num_256\n    k5 -= num_256\n    k6 -= num_256\n    \n    # Calculate the maximum number of '32' that can be formed with remaining digits\n    num_32 = min(k2, k3)\n    \n    # Calculate total sum\n    total_sum = num_256 * 256 + num_32 * 32\n    return total_sum\n\n# Read input\nk2, k3, k5, k6 = map(int, input().split())\n\n# Output result\nprint(max_sum(k2, k3, k5, k6))"}
{"solution": "def min_seconds(n, x, y, c):\n    if c == 1:\n        return 0\n    max_dist = max(abs(n - x) + abs(n - y), x + y - 1)\n    area = 1 + max_dist * 8\n    if c <= area:\n        return max_dist\n    additional_cells = c - area\n    full_squares, remainder = divmod(additional_cells, 8 * 4)\n    total_seconds = max_dist + full_squares\n    if remainder > 0:\n        total_seconds += 1\n    return total_seconds\n\nn, x, y, c = map(int, input().split())\nprint(min_seconds(n, x, y, c))"}
{"solution": "def solve(l, r):\n    if l == r:\n        return 0\n    else:\n        xor = l ^ r\n        while xor & (xor - 1) > 0:\n            xor &= xor - 1\n        return xor + ((r - l) & (r - l + 1))\n\nl, r = map(int, input().split())\nprint(solve(l, r))"}
{"solution": "import math\n\ndef min_height(n, k):\n    left, right = 0, int(1e18)\n    while left < right:\n        mid = (left + right) // 2\n        if sum(max(0, mid - i) for i in range(n + 1)) >= k:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef main():\n    n, k = map(int, input().split())\n    result = min_height(n, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    # Calculate time using stairs\n    stairs_time = abs(y - x) * t1\n    \n    # Calculate time using elevator\n    to_elevator_time = abs(z - x) * t2 + t3\n    travel_time = abs(y - z) * t2 + t3\n    elevator_time = to_elevator_time + travel_time\n    \n    return \"YES\" if elevator_time <= stairs_time else \"NO\"\n\n# Example usage\nx, y, z, t1, t2, t3 = map(int, input().split())\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "def find_best_choice(n, m):\n    # Calculate the optimal choice for Andrew\n    if m == 1:\n        return 2\n    elif m == n:\n        return n - 1\n    else:\n        return m - 1\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(find_best_choice(n, m))"}
{"solution": "def university_schedule(n, schedule):\n    stay = 0\n    consecutive_zeros = 0\n\n    for i in range(n):\n        if schedule[i] == 1:\n            stay += 1\n            consecutive_zeros = 0\n        else:\n            if consecutive_zeros == 1:\n                stay += 1\n            consecutive_zeros += 1\n            if consecutive_zeros == 2:\n                consecutive_zeros = 0\n\n    return stay\n\n# Reading input\nn = int(input())\nschedule = list(map(int, input().split()))\n\n# Calculating result\nresult = university_schedule(n, schedule)\n\n# Printing output\nprint(result)"}
{"solution": "def min_days_for_candies(n, k, candies):\n    total_given = 0\n    for day in range(n):\n        total_given += min(8, candies[day])\n        if total_given >= k:\n            return day + 1\n    return -1\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    candies = list(map(int, input().split()))\n    print(min_days_for_candies(n, k, candies))"}
{"solution": "def min_additional_walks(n, k, walks):\n    additional = 0\n    schedule = [0] * n\n    prev = k\n    \n    for i in range(n):\n        needed = max(prev - walks[i], 0)\n        schedule[i] = walks[i] + needed\n        additional += needed\n        prev = schedule[i]\n    \n    # Ensure the last day meets the requirement for the next day (which is assumed to have k walks)\n    if schedule[-1] < k:\n        diff = k - schedule[-1]\n        schedule[-1] += diff\n        additional += diff\n\n    return additional, schedule\n\n# Read input\nn, k = map(int, input().split())\nwalks = list(map(int, input().split()))\n\n# Calculate result\nadditional, schedule = min_additional_walks(n, k, walks)\n\n# Print output\nprint(additional)\nprint(' '.join(map(str, schedule)))"}
{"solution": "def rhombus_cells(n):\n    if n == 1:\n        return 1\n    else:\n        return 4 * n - 3 + rhombus_cells(n - 1)\n\n# Example usage:\n# Uncomment the following lines to test\n\"\"\"\nn = int(input())\nprint(rhombus_cells(n))\n\"\"\""}
{"solution": "def check_pangram(length):\n    text = input().strip()\n    alphabet = set('abcdefghijklmnopqrstuvwxyz')\n    text_set = set(text.lower())\n    return \"YES\" if alphabet.issubset(text_set) else \"NO\"\n\nn = int(input())\nprint(check_pangram(n))"}
{"solution": "from datetime import datetime, timedelta\n\n# Read the current time and minutes to add from stdin\ncurrent_time_str = input().strip()\nminutes_to_add = int(input().strip())\n\n# Convert the current time string to a datetime object\ncurrent_time = datetime.strptime(current_time_str, '%H:%M')\n\n# Add the specified number of minutes to the current time\nnew_time = current_time + timedelta(minutes=minutes_to_add)\n\n# Format and print the new time\nprint(new_time.strftime('%H:%M'))"}
{"solution": "from sys import stdin\nfrom itertools import accumulate\n\ndef solve(switches, lamps):\n    mat = [list(map(int, line.strip())) for line in stdin]\n    row_sums = list(accumulate(map(sum, mat), initial=0))\n    \n    for i in range(switches):\n        if row_sums[i] == row_sums[-1] - row_sums[i]:\n            col_sums = [sum(x) for x in zip(*mat)]\n            if all(col_sum >= 1 for col_sum in col_sums[:i] + col_sums[i+1:]):\n                return \"YES\"\n    return \"NO\"\n\nn, m = map(int, stdin.readline().split())\nprint(solve(n, m))"}
{"solution": "def min_time_to_even_sums(n, dominoes):\n    top_sum, bottom_sum = 0, 0\n    odd_top, odd_bottom = [], []\n    \n    for top, bottom in dominoes:\n        top_sum += top\n        bottom_sum += bottom\n        \n        if top % 2 != 0:\n            odd_top.append((top, bottom))\n        if bottom % 2 != 0:\n            odd_bottom.append((top, bottom))\n    \n    if (top_sum % 2 == 0 and bottom_sum % 2 == 0) or (len(odd_top) >= 1 and len(odd_bottom) >= 1):\n        return 0\n    \n    if top_sum % 2 != 0 and bottom_sum % 2 != 0:\n        if len(odd_top) > 0 and len(odd_bottom) > 0:\n            return 1\n        else:\n            return -1\n    \n    if top_sum % 2 != 0:\n        if len(odd_top) >= 1:\n            return 1\n        elif len(odd_bottom) >= 2:\n            return 2\n        else:\n            return -1\n    \n    if bottom_sum % 2 != 0:\n        if len(odd_bottom) >= 1:\n            return 1\n        elif len(odd_top) >= 2:\n            return 2\n        else:\n            return -1\n\n# Reading input\nn = int(input())\ndominoes = [list(map(int, input().split())) for _ in range(n)]\n\n# Printing output\nprint(min_time_to_even_sums(n, dominoes))"}
{"solution": "from math import sqrt\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef remaining_area(a, b):\n    return a * a - b * b\n\nt = int(input())\nfor _ in range(t):\n    a, b = map(int, input().split())\n    area = remaining_area(a, b)\n    print(\"YES\" if is_prime(area) else \"NO\")"}
{"solution": "def check_points(n, points):\n    points.sort(key=lambda p: p[0])\n\n    for i in range(1, n):\n        if (points[i][0] * points[i - 1][0] > 0 and\n                points[i][1] * points[i - 1][1] >= 0):\n            return \"Yes\"\n    return \"No\"\n\nn = int(input())\npoints = [list(map(int, input().split())) for _ in range(n)]\nprint(check_points(n, points))"}
{"solution": "def gcd_factorials(A, B):\n    min_val = min(A, B)\n    gcd = 1\n    for i in range(2, min_val + 1):\n        gcd *= i\n    return gcd\n\n# Reading input\nA, B = map(int, input().split())\n\n# Calculating and printing result\nprint(gcd_factorials(A, B))"}
{"solution": "def find_composite_pair(n):\n    \"\"\"\n    Finds two composite integers a and b such that a - b = n.\n    \"\"\"\n    # Starting with the smallest even composite number\n    a = 4\n    b = a - n\n    \n    # Ensure b is positive and composite\n    while b < 2 or b in {1, 2, 3}:\n        a += 2\n        b = a - n\n    \n    print(a, b)\n\n# Read input from stdin\nn = int(input().strip())\n\n# Solve and print the result\nfind_composite_pair(n)"}
{"solution": "from collections import defaultdict, deque\n\ndef solve():\n    N, M, P = map(int, input().split())\n    graph = defaultdict(list)\n    rev_graph = defaultdict(list)\n    edges = []\n    \n    for _ in range(M):\n        A, B, C = map(int, input().split())\n        graph[A].append((B, C))\n        rev_graph[B].append((A, C))\n        edges.append((A, B, C))\n\n    def bfs(start, target, graph):\n        visited = [False] * (N + 1)\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            node, dist = queue.popleft()\n            if node == target:\n                return dist\n            for next_node, _ in graph[node]:\n                if not visited[next_node]:\n                    visited[next_node] = True\n                    queue.append((next_node, dist + 1))\n        return -1\n\n    path_length = bfs(1, N, graph)\n\n    min_cost = float('inf')\n    for A, B, C in edges:\n        if A == 1 and B == N:\n            min_cost = min(min_cost, C)\n\n    if path_length == -1 or min_cost == float('inf'):\n        print(-1)\n    else:\n        max_coins = 0\n        for A, B, C in edges:\n            if bfs(A, N, graph) != -1 and bfs(B, N, graph) != -1:\n                time_to_N_via_A = bfs(A, N, graph)\n                time_to_N_via_B = bfs(B, N, graph)\n                coins_via_A = C * time_to_N_via_A\n                coins_via_B = C * time_to_N_via_B\n                max_coins = max(max_coins, coins_via_A - P * time_to_N_via_A, coins_via_B - P * time_to_N_via_B)\n\n        if path_length * min_cost >= P * path_length:\n            max_coins = max(max_coins, path_length * min_cost - P * path_length)\n\n        print(max_coins)\n\nsolve()"}
{"solution": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    N = int(input())\n    strings = [input().split() for _ in range(N)]\n\n    costs = defaultdict(lambda: float('inf'))\n    center = float('inf')\n    for s, c in strings:\n        if s == s[::-1]:\n            center = min(center, int(c))\n        costs[s] = min(costs[s], int(c))\n        costs[s[::-1]] = min(costs[s[::-1]], int(c))\n\n    dp = {'' : 0}\n    for s, c in strings:\n        new_dp = dp.copy()\n        for palindrome, cost in dp.items():\n            ns = s + palindrome + s[::-1]\n            new_dp[ns] = min(new_dp.get(ns, float('inf')), cost + 2 * c)\n            if len(palindrome) % 2 == 1:\n                msp = palindrome[len(palindrome) // 2]\n                ns = s + palindrome[:len(palindrome) // 2] + msp + palindrome[len(palindrome) // 2:] + s[::-1]\n                new_dp[ns] = min(new_dp.get(ns, float('inf')), cost + 2 * c + center)\n        dp = new_dp\n\n    ans = min(dp.values(), default=-1)\n    print(ans)\n\nsolve()"}
{"solution": "def max_xor_sum(n, k):\n    \"\"\"\n    Calculate the maximum xor-sum of k numbers from 1 to n.\n    \"\"\"\n    # If we can include all numbers, calculate the xor of all numbers up to n\n    if n <= 2 * k:\n        return xor_all_up_to_n(n)\n    else:\n        # Otherwise, calculate the xor of all numbers up to 2k and subtract the xor of k+1 to 2k\n        return xor_all_up_to_n(2 * k) ^ xor_all_up_to_n(k + 1)\n\ndef xor_all_up_to_n(n):\n    \"\"\"\n    Helper function to compute xor of all numbers up to n.\n    \"\"\"\n    # The pattern repeats every 4 numbers\n    mod = n % 4\n    if mod == 0:\n        return n\n    elif mod == 1:\n        return 1\n    elif mod == 2:\n        return n + 1\n    else:  # mod == 3\n        return 0\n\n# Read input\nn, k = map(int, input().split())\n\n# Compute and print the result\nprint(max_xor_sum(n, k))"}
{"solution": "def min_side_length(n, points):\n    max_x = max_y = 0\n    for x, y in points:\n        max_x = max(max_x, x)\n        max_y = max(max_y, y)\n    return min(max_x + max_y - min(max_x, max_y), max_x + max_y)\n\n# Reading input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculating and printing output\nprint(min_side_length(n, points))"}
{"solution": "from collections import Counter\n\ndef max_nineteens(s):\n    count = Counter(s)\n    result = min(count['n'], count['i'] // 2, count['e'] // 2)\n    return result\n\n# Read input\ns = input().strip()\n\n# Calculate and print the result\nprint(max_nineteens(s))"}
{"solution": "def find_highest_suitable_branch(p, y):\n    \"\"\"\n    Finds the highest branch that cannot be reached by any of the grasshoppers.\n    \n    :param p: int, the highest branch occupied by grasshoppers.\n    :param y: int, the total number of branches.\n    :return: int, the number of the highest suitable branch or -1 if there are none.\n    \"\"\"\n    if p == y:\n        return -1\n    \n    # Adjusting p to be the next branch after the last occupied one\n    p += 1\n    \n    # If p is within the range, it might be the answer\n    if p <= y:\n        return p\n    \n    # Check for the highest branch that is not a multiple of any branch from 2 to p\n    for i in range(2, int(y ** 0.5) + 2):\n        if p % i == 0:\n            while p % i == 0:\n                p //= i\n            if p > y:\n                return -1\n    \n    return p if p <= y else -1\n\n# Read input\np, y = map(int, input().split())\n\n# Output the result\nprint(find_highest_suitable_branch(p, y))"}
{"solution": "def find_closest_house(n, m, k, prices):\n    # Filter houses that Zane can afford\n    affordable_houses = [i for i, price in enumerate(prices) if 0 < price <= k]\n\n    # Calculate distances from m to all affordable houses\n    distances = [abs(i - (m - 1)) * 10 for i in affordable_houses]\n\n    # Return the minimum distance\n    return min(distances)\n\n# Reading input\nn, m, k = map(int, input().split())\nprices = list(map(int, input().split()))\n\n# Output result\nprint(find_closest_house(n, m, k, prices))"}
{"solution": "def can_transform(a, b):\n    n, m = len(a), len(a[0])\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != b[j][i]:\n                return False\n    return True\n\ndef main():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    b = [list(map(int, input().split())) for _ in range(n)]\n\n    if a == b or can_transform(a, b):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def longest_uncommon_subsequence(a, b):\n    \"\"\"\n    Finds the length of the longest uncommon subsequence between two strings.\n    If no such subsequence exists, returns -1.\n    \"\"\"\n    if a == b:\n        return -1\n    else:\n        # If the strings are different, the longest uncommon subsequence\n        # would be the longer string itself, since it cannot be a subsequence of the shorter string.\n        return max(len(a), len(b))\n\n# Reading input strings\na = input().strip()\nb = input().strip()\n\n# Printing the result\nprint(longest_uncommon_subsequence(a, b))"}
{"solution": "def find_scream_time(a, b, c, d):\n    \"\"\"\n    Finds the first time Rick and Morty will scream at the same time.\n    If they never scream at the same time, returns -1.\n    \"\"\"\n    if a == 0 and c == 0:\n        return b if b == d else -1\n    elif a == 0:\n        return d if (d - b) % c == 0 else -1\n    elif c == 0:\n        return b if (b - d) % a == 0 else -1\n    \n    lcm = a * c // math.gcd(a, c)\n    x = (d - b) % lcm\n    if x % c != 0:\n        return -1\n    t = (x // c) * c + b\n    return t if t >= b and t >= d else -1\n\nimport math\na, b = map(int, input().split())\nc, d = map(int, input().split())\nprint(find_scream_time(a, b, c, d))"}
{"solution": "def find_numbers(n):\n    if n % 3 == 0:\n        a = n // 3 - 1\n        b = n // 3 - 1\n        c = n // 3 + 2\n    elif n % 3 == 1:\n        a = n // 3 + 1\n        b = n // 3\n        c = n // 3\n    else:\n        a = n // 3\n        b = n // 3\n        c = n // 3 + 1\n    return a, b, c\n\nn = int(input())\na, b, c = find_numbers(n)\nprint(a, b, c)"}
{"solution": "def count_valid_squares(n, a, b, c, d):\n    \"\"\"\n    Counts the number of valid 3x3 squares given the constraints.\n    \"\"\"\n    valid_count = 0\n    for x1 in range(1, n + 1):\n        for x2 in range(1, n + 1):\n            s = 2 * (a + x1) - (b + c)\n            t = 2 * (a + x2) - (b + c)\n            if 1 <= s <= n and 1 <= t <= n:\n                y1 = 2 * (x1 + x2) - (a + d)\n                if 1 <= y1 <= n:\n                    y2 = 2 * (s + t) - (a + d)\n                    if 1 <= y2 <= n:\n                        valid_count += 1\n    return valid_count\n\n# Read input\nn, a, b, c, d = map(int, input().split())\n\n# Output result\nprint(count_valid_squares(n, a, b, c, d))"}
{"solution": "def snowball_weight(w, h, stone1, stone2):\n    # Unpack stones\n    u1, d1 = stone1\n    u2, d2 = stone2\n\n    # Ensure d1 < d2 for processing\n    if d1 > d2:\n        u1, u2, d1, d2 = u2, u1, d2, d1\n\n    while h > 0:\n        w += h\n        h -= 1\n\n        if h == d1:\n            w = max(0, w - u1)\n        elif h == d2:\n            w = max(0, w - u2)\n\n    return w\n\n# Read input\nw, h = map(int, input().split())\nstone1 = list(map(int, input().split()))\nstone2 = list(map(int, input().split()))\n\n# Calculate and print result\nprint(snowball_weight(w, h, stone1, stone2))"}
{"solution": "def find_passing_rate():\n    m = int(input())\n    scores = list(map(int, input().split()))\n    x, y = map(int, input().split())\n\n    prefix_sum = [0]\n    for score in scores:\n        prefix_sum.append(prefix_sum[-1] + score)\n\n    for k in range(m, 0, -1):\n        beginners = prefix_sum[k]\n        intermediates = prefix_sum[m] - beginners\n        if x <= beginners <= y and x <= intermediates <= y:\n            return k\n    return 0\n\nprint(find_passing_rate())"}
{"solution": "def min_cost(n, k, A, B):\n    costs = [float('inf')] * (n + 1)\n    costs[1] = 0\n    operations = [None] * (n + 1)\n\n    for x in range(2, n + 1):\n        # Cost of subtracting 1 until reaching 1\n        cost_subtract = costs[x - 1] + A\n        costs[x] = cost_subtract\n\n        if x % k == 0:\n            # Calculate cost if we divide by k\n            cost_divide = costs[x // k] + B\n            if cost_divide < cost_subtract:\n                costs[x] = cost_divide\n                operations[x] = (x // k, 'divide')\n\n        # If not divisible, only option is to subtract\n        else:\n            operations[x] = (x - 1, 'subtract')\n\n    return costs[n]\n\n# Read inputs\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\n# Calculate and print the minimum cost\nprint(min_cost(n, k, A, B))"}
{"solution": "from math import sqrt\n\ndef min_value_and_operations(n):\n    factors = []\n    for i in range(2, int(sqrt(n)) + 1):\n        while n % (i * i) == 0:\n            factors.append(i)\n            n //= (i * i)\n    if n > 1:\n        factors.append(n)\n    \n    if not factors:\n        return (n, 0)\n    \n    min_val = min(factors)\n    operations = len(factors) + 1  # +1 for final sqrt operation\n    \n    return (min_val, operations)\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print result\nresult = min_value_and_operations(n)\nprint(*result)"}
{"solution": "import sys\ninput = sys.stdin.readline\n\ndef main():\n    N, K = map(int, input().split())\n    R, S, P = map(int, input().split())\n    T = input().rstrip()\n    \n    dp = [[0]*3 for _ in range(N+1)]\n    \n    for i in range(1, N+1):\n        if T[i-1] == 'r':\n            dp[i][0] = max(dp[i-1])\n            dp[i][1] = dp[i-1][1] + P if i-K <= 0 else max(dp[i-K][1], dp[i-K][2]) + P\n            dp[i][2] = dp[i-1][2] + S if i-K <= 0 else max(dp[i-K][0], dp[i-K][2]) + S\n        elif T[i-1] == 's':\n            dp[i][0] = dp[i-1][0] + R if i-K <= 0 else max(dp[i-K][0], dp[i-K][1]) + R\n            dp[i][1] = max(dp[i-1])\n            dp[i][2] = dp[i-1][2] + P if i-K <= 0 else max(dp[i-K][0], dp[i-K][1]) + P\n        else:\n            dp[i][0] = dp[i-1][0] + R if i-K <= 0 else max(dp[i-K][0], dp[i-K][2]) + R\n            dp[i][1] = dp[i-1][1] + P if i-K <= 0 else max(dp[i-K][0], dp[i-K][1]) + P\n            dp[i][2] = max(dp[i-1])\n            \n    print(max(dp[N]))\n    \nmain()"}
{"solution": "def max_good_string_length(a, b, c):\n    \"\"\"\n    Calculate the maximum length of a good string that can be formed.\n    \"\"\"\n    # Minimum of a and b ensures the base alternating pattern\n    min_ab = min(a, b)\n    # Length contributed by the minimum of a and b\n    length = 2 * min_ab\n    \n    # Excess of a or b after forming 'ab' pairs\n    excess = abs(a - b)\n    \n    # All 'ab' strings can be used\n    length += 2 * c\n    \n    # If there are 'ab' strings, we can use an extra 'a' or 'b' from the excess\n    if c > 0 and excess > 0:\n        length += 1\n    \n    # Add remaining excess to the length\n    length += min(1, excess)\n    \n    return length\n\n# Read input from stdin\na, b, c = map(int, input().split())\n\n# Output the result\nprint(max_good_string_length(a, b, c))"}
{"solution": "def find_marks(n, k, p, x, y, marks):\n    if k == 0:\n        if (n + 1) // 2 * y > x:\n            return [-1]\n        return [y] * ((n + 1) // 2) + [1] * (n - (n + 1) // 2)\n\n    current_sum = sum(marks)\n    needed_sum = x - current_sum\n\n    if (n - k) * p < needed_sum:\n        return [-1]\n\n    if (n + 1) // 2 <= k:\n        min_marks = sorted(marks)[(n - 1) // 2]\n        if min_marks < y:\n            return [-1]\n        return marks + [1] * (n - k)\n\n    marks += [1] * ((n + 1) // 2 - k - 1)\n    marks += [y] * 1\n    current_median = y\n    remaining = n - len(marks)\n\n    if current_median < y:\n        marks[-1] = y + 1\n        current_median = y + 1\n        remaining -= 1\n\n    while (n + 1) // 2 - k > len([m for m in marks if m >= y]):\n        marks.append(y)\n        remaining -= 1\n\n    if sum(marks) + remaining * p > x:\n        return [-1]\n\n    marks += [1] * remaining\n    shuffle(marks)\n\n    return marks\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    n, k, p, x, y = data[:5]\n    marks = data[5:5 + k]\n    result = find_marks(n, k, p, x, y, marks)\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_berlanese(word):\n    vowels = 'aouie'\n    prev_char = ''\n    for char in word:\n        if char not in vowels and prev_char != 'n':\n            return \"NO\"\n        prev_char = char\n    return \"YES\" if prev_char == 'n' or prev_char in vowels else \"NO\"\n\n# Read input\ns = input()\n# Print output\nprint(is_berlanese(s))"}
{"solution": "\"\"\"\nCode for solving the Domino Placement Problem based on the given specifications.\n\"\"\"\n\nfrom collections import defaultdict\n\ndef solve(n, edges):\n    # Create adjacency list\n    adj = [set() for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    # Calculate degrees\n    degrees = [len(neighbors) for neighbors in adj]\n\n    # Find maximum degree\n    max_degree = max(degrees)\n\n    # Initialize result\n    result = 0\n\n    # Track used nodes\n    used = set()\n\n    # Process each node with max degree\n    for i, deg in enumerate(degrees):\n        if deg == max_degree and i not in used:\n            # Add max degree to result\n            result += max_degree\n            # Mark connected nodes as used\n            for neighbor in adj[i]:\n                used.add(neighbor)\n            used.add(i)\n\n    # Check remaining edges\n    for i, deg in enumerate(degrees):\n        if i not in used:\n            result += min(deg, 2)\n\n    return result // 2\n\n# Reading input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Solving and printing the result\nprint(solve(n, edges))"}
{"solution": "import heapq\n\ndef jeopardy_max_score(n, m, prices, auctions):\n    def max_points(prices, auctions, start=0):\n        auctions = set(auctions)\n        heap = []\n        for price in prices:\n            if len(heap) > 0 and price in auctions:\n                update_price = heapq.heappop(heap)\n                yield update_price + price\n                heapq.heappush(heap, max(update_price, price))\n            else:\n                heapq.heappush(heap, price)\n                yield start\n            start = max(start, heap[0])\n\n    prices = list(reversed(sorted(prices)))\n    auctions = list(reversed(sorted(auctions)))\n    return next(max_points(prices, auctions))\n\ndef main():\n    n, m = map(int, input().split())\n    prices = list(map(int, input().split()))\n    auctions = list(map(int, input().split()))\n    result = jeopardy_max_score(n, m, prices, auctions)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_score(m, w, hs, hu):\n    base_scores = [500, 1000, 1500, 2000, 2500]\n    total_score = 0\n\n    for i in range(5):\n        score = max(0.3 * base_scores[i], (1 - m[i] / 250) * base_scores[i] - 50 * w[i])\n        total_score += int(score)\n\n    total_score += 100 * hs - 50 * hu\n    return total_score\n\nm = list(map(int, input().split()))\nw = list(map(int, input().split()))\nhs, hu = map(int, input().split())\n\nprint(calculate_score(m, w, hs, hu))"}
{"solution": "MOD = 998244353\n\ndef solve(n, m, L, R):\n    if (n * m) % 2 == 1:\n        return 0\n    total_cells = n * m\n    half_cells = total_cells // 2\n    valid_grids = pow(R - L + 1, half_cells, MOD)\n    return valid_grids\n\ndef main():\n    n, m, L, R = map(int, input().split())\n    result = solve(n, m, L, R)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n# This code snippet is designed to solve the problem as described without including any test cases within the code."}
{"solution": "def is_possible(n, m, a, b):\n    a_sorted = sorted(set(sum(a, [])))\n    b_sorted = sorted(set(sum(b, [])))\n\n    mapping = {}\n    for i in range(min(len(a_sorted), len(b_sorted))):\n        mapping[a_sorted[i]] = b_sorted[i]\n\n    def check(matrix, reverse_mapping):\n        for row in matrix:\n            for i in range(len(row) - 1):\n                if reverse_mapping[row[i]] >= reverse_mapping[row[i + 1]]:\n                    return False\n        for col in zip(*matrix):\n            for i in range(len(col) - 1):\n                if reverse_mapping[col[i]] >= reverse_mapping[col[i + 1]]:\n                    return False\n        return True\n\n    reverse_mapping = {v: k for k, v in mapping.items()}\n    reverse_mapping.update({k: k for k in set(sum(b, [])) - set(mapping.values())})\n\n    return \"Possible\" if check(a, mapping) and check(b, reverse_mapping) else \"Impossible\"\n\ndef main():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    b = [list(map(int, input().split())) for _ in range(n)]\n    print(is_possible(n, m, a, b))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_string_length(n, limits):\n    \"\"\"\n    Calculate the maximum possible length of a string with given constraints.\n    \"\"\"\n    limits.sort(reverse=True)\n    total_length = 0\n    next_slot = 1\n    \n    for limit in limits:\n        if limit >= next_slot:\n            total_length += next_slot\n            next_slot += 1\n        else:\n            total_length += limit\n            if limit < next_slot:\n                next_slot -= limit\n                limit = 0\n            while next_slot > 0 and limit == 0:\n                next_slot -= 1\n                limit = 1\n    return total_length\n\n# Reading input\nn = int(input())\nlimits = list(map(int, input().split()))\n\n# Calculating and printing result\nprint(max_string_length(n, limits))"}
{"solution": "def min_extra_problems(n, k, difficulties):\n    max_difficulty = max(difficulties)\n    steps = 0\n    current_max_difficulty = k\n    \n    while current_max_difficulty < max_difficulty:\n        next_max_difficulty = (current_max_difficulty * 2) + 1\n        current_max_difficulty = next_max_difficulty\n        steps += 1\n    \n    for diff in difficulties:\n        if diff > k and diff // 2 <= k:\n            steps -= 1\n            break\n    \n    return steps\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    difficulties = list(map(int, input().split()))\n    print(min_extra_problems(n, k, difficulties))"}
{"solution": "def distribute_diplomas(n, limits):\n    min_1, max_1 = limits[0]\n    min_2, max_2 = limits[1]\n    min_3, max_3 = limits[2]\n\n    # Maximize first degree diplomas\n    first_degree = min(n, max_1)\n    remaining = n - first_degree\n\n    # Ensure minimum requirements for second and third degrees\n    if remaining < min_2 + min_3:\n        first_degree -= (min_2 + min_3 + min_1) - n\n        remaining = n - first_degree\n\n    # Maximize second degree diplomas\n    second_degree = min(remaining, max_2)\n    remaining -= second_degree\n\n    # The rest go to third degree diplomas\n    third_degree = remaining\n\n    return first_degree, second_degree, third_degree\n\n# Reading input\nn = int(input())\nlimits = [tuple(map(int, input().split())) for _ in range(3)]\n\n# Calculate and print the result\nresult = distribute_diplomas(n, limits)\nprint(*result)"}
{"solution": "def moon_cycle Observation_days, observations):\n    cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n             14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    \n    last_observation = observations[-1]\n    index_in_cycle = cycle.index(last_observation)\n    \n    if len(observations) == 1:\n        if last_observation in [7, 8]:\n            return \"UP\"\n        elif last_observation in [12, 13]:\n            return \"DOWN\"\n        else:\n            return -1\n    \n    previous_observation = observations[-2]\n    prev_index_in_cycle = cycle.index(previous_observation)\n    \n    if prev_index_in_cycle < index_in_cycle:\n        if index_in_cycle >= 15:\n            return \"DOWN\"\n        else:\n            return -1\n    else:\n        if index_in_cycle <= 7:\n            return \"UP\"\n        else:\n            return -1\n\n# Reading input\nObservation_days = int(input())\nobservations = list(map(int, input().split()))\n\n# Getting the result\nresult = moon_cycle(Observation_days, observations)\n\n# Printing the result\nprint(result)"}
{"solution": "def can_transform(s, t):\n    vowels = set('aeiou')\n    if len(s) != len(t):\n        return \"No\"\n    for cs, ct in zip(s, t):\n        if (cs in vowels and ct not in vowels) or (cs not in vowels and ct in vowels):\n            return \"No\"\n    return \"Yes\"\n\ns = input().strip()\nt = input().strip()\nprint(can_transform(s, t))"}
{"solution": "def pawn_chess_winner(board):\n    min_white = 8\n    max_black = 1\n\n    for i, row in enumerate(board):\n        for j, cell in enumerate(row):\n            if cell == 'W':\n                min_white = min(min_white, i)\n            elif cell == 'B':\n                max_black = max(max_black, i)\n\n    return 'A' if min_white < max_black else 'B'\n\n# Read input\nboard = [input() for _ in range(8)]\n\n# Print output\nprint(pawn_chess_winner(board))"}
{"solution": "def find_max_length(n, a, m, b):\n    sa, sb = sum(a), sum(b)\n    if sa != sb: return -1\n    i, j, x, y = 0, 0, sa, sb\n    while i < n:\n        x -= a[i]\n        while j < m and x == y:\n            y -= b[j]\n            j += 1\n        if x == 0: return min(n - i, m - j) + max(j, i)\n        i += 1\n        while i < n and x == y:\n            y -= b[j]\n            j += 1\n        if x == 0: return min(n - i, m - j) + max(j, i)\n        x += a[i]\n        y += b[j] if j < m else 0\n        j += 1\n    return min(n, m)\n\nn = int(input())\na = list(map(int, input().split()))\nm = int(input())\nb = list(map(int, input().split()))\nprint(find_max_length(n, a, m, b))"}
{"solution": "def check_friend_name(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    for friend in friends:\n        count = problem_name.count(friend)\n        if count == 1:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nproblem_name = input().strip()\n\n# Check and print result\nprint(check_friend_name(problem_name))"}
{"solution": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(math.sqrt(n)) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef min_l(a, b, k):\n    primes = [i for i in range(a, b+1) if is_prime(i)]\n    if len(primes) < k:\n        return -1\n    l = 1\n    while True:\n        valid = True\n        for i in range(a, b-l+2):\n            if sum(is_prime(j) for j in range(i, i+l)) < k:\n                valid = False\n                break\n        if valid:\n            return l\n        l += 1\n\na, b, k = map(int, input().split())\nprint(min_l(a, b, k))"}
{"solution": "from math import inf\n\ndef min_distance(a, h, w):\n    for n in range(1, 1000000001):\n        for m in range(1, 1000000001):\n            x = (h - n * a) / (n + 1)\n            y = (w - m * a) / (m + 1)\n            if x >= 0 and y >= 0:\n                max_xy = max(x, y)\n                if abs(h - (n + 1 + (n > 0)) * max_xy - n * a) < 1e-9 and \\\n                   abs(w - (m + 1 + (m > 0)) * max_xy - m * a) < 1e-9:\n                    return max_xy\n    return -1\n\na, h, w = map(int, input().split())\nprint(min_distance(a, h, w))"}
{"solution": "def chapters_left():\n    n = int(input())\n    chapters = [list(map(int, input().split())) for _ in range(n)]\n    k = int(input())\n\n    unread_chapters = 0\n    for start, end in chapters:\n        if k > end:\n            continue\n        else:\n            unread_chapters += 1\n\n    print(unread_chapters)\n\nchapters_left()"}
{"solution": "def check_banner(banner):\n    target = \"CODEFORCES\"\n    i = 0\n    for char in banner:\n        if i < len(target) and char == target[i]:\n            i += 1\n        if i == len(target):\n            return \"YES\"\n    return \"NO\"\n\nbanner = input()\nprint(check_banner(banner))"}
{"solution": "def min_triangulation_weight(n):\n    \"\"\"\n    Calculate the minimum weight of triangulation of a regular polygon with n vertices.\n    \"\"\"\n    if n == 3:\n        return 6\n    dp = [[0] * n for _ in range(n)]\n    for gap in range(2, n):\n        for i in range(n - gap):\n            start, end = i + 1, (i + gap + 1) % n\n            dp[start][end] = float('inf')\n            for k in range(start, end):\n                weight = (start * k * end) + dp[start][k] + dp[k][end]\n                dp[start][end] = min(dp[start][end], weight)\n    return dp[1][0]\n\n# Function to read input and print output\ndef process_input_and_print_output():\n    n = int(input())\n    print(min_triangulation_weight(n))\n\nprocess_input_and_print_output()"}
{"solution": "def count_digits(n):\n    if n < 10:\n        return n\n    digits = 1\n    while 10 ** digits <= n:\n        digits += 1\n    return (n - 10 ** (digits - 1)) * digits + (10 ** (digits - 1) - 1) * (digits - 1)\n\nn = int(input())\nprint(count_digits(n))"}
{"solution": "def find_bob_winning_color(n, a, colors):\n    from collections import Counter\n    \n    alice_count = 0\n    max_diff = 0\n    color_counter = Counter()\n    \n    for color in colors:\n        if color == a:\n            alice_count += 1\n            max_diff += 1\n        else:\n            color_counter[color] += 1\n            max_diff = max(max_diff, alice_count - color_counter[color])\n    \n    for color, count in color_counter.items():\n        if count + max_diff >= alice_count:\n            return color\n    \n    return -1\n\n# Read input\nn, a = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Find and print the result\nresult = find_bob_winning_color(n, a, colors)\nprint(result)"}
{"solution": "def check_crossword(encoding, length):\n    if not encoding and length != 0:\n        return \"NO\"\n    if not encoding and length == 0:\n        return \"YES\"\n    current_position = 0\n    for segment in encoding:\n        current_position += segment + 1\n        if current_position > length:\n            return \"NO\"\n    if current_position - 1 != length:\n        return \"NO\"\n    return \"YES\"\n\nif __name__ == \"__main__\":\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(check_crossword(a, x))"}
{"solution": "import math\n\nn, S = map(int, input().split())\nprint(math.ceil(S / n))"}
{"solution": "from collections import Counter\n\ndef min_changes_palindrome(s):\n    letter_counts = Counter(s)\n    odd_count_letters = [ch for ch, count in letter_counts.items() if count % 2]\n    middle = ''\n    \n    if len(odd_count_letters) > 1:\n        middle = odd_count_letters[0]\n        letter_counts[middle] -= 1\n        if letter_counts[middle] == 0:\n            del letter_counts[middle]\n    \n    half_palindrome = ''.join([ch * (count // 2) for ch, count in sorted(letter_counts.items())])\n    return half_palindrome + middle + half_palindrome[::-1]\n\n# Read input\ns = input().strip()\n# Compute and print the result\nprint(min_changes_palindrome(s))"}
{"solution": "def chess_position_strength(board):\n    piece_weights = {'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n                     'q': -9, 'r': -5, 'b': -3, 'n': -3, 'p': -1}\n    strength = 0\n    for row in board:\n        for cell in row:\n            strength += piece_weights.get(cell, 0)\n    return strength\n\ndef evaluate_position(board):\n    strength = chess_position_strength(board)\n    if strength > 0:\n        return \"White\"\n    elif strength < 0:\n        return \"Black\"\n    else:\n        return \"Draw\"\n\n# Read input from stdin\nboard = [input() for _ in range(8)]\n\n# Output result to stdout\nprint(evaluate_position(board))"}
{"solution": "import sys\nfrom functools import lru_cache\n\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nN, M = map(int, readline().split())\nS = readline().strip()\n\n@lru_cache(maxsize=None)\ndef dp(n):\n    if S[n] == '1':\n        return None\n    if n == N:\n        return ()\n    res = None\n    for m in range(1, M + 1):\n        tmp = dp(n + m)\n        if tmp is not None:\n            tmp = (m, ) + tmp\n            if res is None:\n                res = tmp\n            elif len(res) > len(tmp):\n                res = tmp\n            elif len(res) == len(tmp):\n                res = min(res, tmp)\n    return res\n\nans = dp(0)\nif ans is None:\n    write('-1')\nelse:\n    write(' '.join(map(str, ans)))"}
{"solution": "from collections import deque, defaultdict\nimport math\n\ndef solve(K, X, Y):\n    if K == 0:\n        return \"-1\" if X or Y else \"0\"\n    \n    # Manhattan distance\n    def dist(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n    \n    # Check if the move is possible\n    if dist(0, 0, X, Y) % K != 0:\n        return \"-1\"\n    \n    # Directions to move towards the target\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    \n    queue = deque([(0, 0, 0)])\n    visited = defaultdict(int)\n    visited[(0, 0)] = 1\n    \n    while queue:\n        x, y, steps = queue.popleft()\n        \n        for dx, dy in directions:\n            nx, ny = x + K * dx, y + K * dy\n            if (nx, ny) not in visited and dist(nx, ny, X, Y) >= 0:\n                if (nx, ny) == (X, Y):\n                    return f\"{steps + 1}\\n{' '.join([str(nx), str(ny)])}\"\n                visited[(nx, ny)] = 1\n                queue.append((nx, ny, steps + 1))\n    \n    return \"-1\"\n\n# Reading input\nK = int(input())\nX, Y = map(int, input().split())\n\nprint(solve(K, X, Y))"}
{"solution": "from math import sqrt\n\ndef find_smallest_n(m):\n    \"\"\"\n    Finds the smallest possible value of n such that there are exactly m ways\n    the thieves could have taken the chocolates, given there are 4 thieves\n    and each thief takes k times more than the previous one.\n    Returns -1 if no such n exists.\n    \"\"\"\n    max_k = int(sqrt(sqrt(m))) + 1\n    for n in range(8, 10**15):\n        count = 0\n        for k in range(2, max_k):\n            total = 0\n            for i in range(4):\n                total += k ** i\n                if total > n:\n                    break\n            else:\n                if total <= n:\n                    count += 1\n        if count == m:\n            return n\n    return -1\n\n# Function to directly calculate the result based on the formula derived from the pattern\ndef calculate_smallest_n(m):\n    \"\"\"\n    Direct calculation of the smallest possible value of n based on the pattern observed.\n    Returns -1 if no such n exists.\n    \"\"\"\n    for x in range(1, 63):\n        val = (x * (x + 1) * (2 * x + 1) * (3 * x + 1)) // 12\n        if val == m:\n            return (3 * x + 1) * (x + 1) * (2 * x + 1) - 1\n        if val > m:\n            return -1\n    return -1\n\n# Example usage\nm = int(input())\nprint(calculate_smallest_n(m))"}
{"solution": "import math\n\ndef intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\n    if d >= r1 + r2:\n        return 0\n    elif d <= abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n    else:\n        phi1 = math.acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        phi2 = math.acos((r2 ** 2 + d ** 2 - r1 ** 2) / (2 * r2 * d))\n        A1 = phi1 * r1 ** 2 - r1 ** 2 * math.sin(2 * phi1) / 2\n        A2 = phi2 * r2 ** 2 - r2 ** 2 * math.sin(2 * phi2) / 2\n        return A1 + A2\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\nprint(intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "def min_value(n):\n    for x in range(2, int(n**0.5) + 1):\n        if n % x == 0:\n            div = x\n            while n % div == 0:\n                n //= div\n            return min_value(n)\n    return n if n > 1 else 1\n\nv = int(input())\nprint(min_value(v))"}
{"solution": "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\ndef build_tree(n, edges):\n    tree = defaultdict(list)\n    for i, edge in enumerate(edges, start=2):\n        tree[edge].append(i)\n    return tree\n\ndef dfs(tree, values, node=1, depth=0):\n    value = values[node - 1]\n    children_value = 0\n    for child in tree[node]:\n        child_value, child_depth = dfs(tree, values, child, depth + 1)\n        value = max(value, child_value)\n        if child_depth % 2 == 1:\n            value += child_value\n            children_value += child_value\n    value = max(value, sum(values[child - 1] for child in tree[node]) - children_value)\n    return value, depth\n\nn = int(input())\nparents = list(map(int, input().split()))\nvalues = list(map(int, input().split()))\n\ntree = build_tree(n, parents)\nresult, _ = dfs(tree, values)\nprint(result)"}
{"solution": "def count_possible_words(n, s, t):\n    \"\"\"\n    Counts the number of possible words of length n+1 that can be transformed into both s and t by deleting exactly one character.\n    \"\"\"\n    start, end = 0, n - 1\n    while s[start] == t[start]:\n        start += 1\n    while s[end] == t[end]:\n        end -= 1\n\n    return 2 - (s[start+1:end+1] == t[start:end] or s[start:end] == t[start+1:end+1])\n\n# Reading input\nn = int(input())\ns = input()\nt = input()\n\n# Printing output\nprint(count_possible_words(n, s, t))"}
{"solution": "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\ndef dfs(v, p):\n    global ans\n    if ans < 0:\n        return\n    mx = -1\n    for u in g[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n        mx = max(mx, strength[u])\n    if mx >= 0:\n        ans = min(ans, strength[v] + int(mx >= strength[v]))\n\nn = int(input())\nstrength = list(map(int, input().split()))\ng = defaultdict(list)\nfor _ in range(n-1):\n    u, v = map(int, input().split())\n    g[u-1].append(v-1)\n    g[v-1].append(u-1)\n\nans = max(strength)\ndfs(strength.index(ans), -1)\nprint(ans if ans >= 0 else max(strength))"}
{"solution": "def max_groups(n, m):\n    return min(n, m + 1)\n\nn, m = map(int, input().split())\nprint(max_groups(n, m))"}
{"solution": "def min_shovels(k, r):\n    n = 1\n    while (n * k) % 10 != r:\n        n += 1\n    return n\n\nk, r = map(int, input().split())\nprint(min_shovels(k, r))"}
{"solution": "def is_rectangle_possible(puzzle):\n    min_row, max_row, min_col, max_col = None, None, None, None\n    row_counts = []\n    \n    for i, row in enumerate(puzzle):\n        count_x = sum(1 for c in row if c == 'X')\n        if count_x > 0:\n            row_counts.append(count_x)\n            if min_row is None:\n                min_row, min_col = i, row.find('X')\n                max_col = min_col\n            max_row = i\n            max_col = max(max_col, row.rfind('X'))\n    \n    if min_row is None or len(set(row_counts)) != 1:\n        return False\n    \n    return (max_col - min_col + 1) * 2 >= max_row - min_row + 1\n\ndef main():\n    n, m = map(int, input().split())\n    puzzle = [input() for _ in range(n)]\n    \n    if is_rectangle_possible(puzzle):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Importing necessary functionality\nfrom collections import defaultdict\n\ndef min_segments(x1, y1, x2, y2, x3, y3):\n    \"\"\"\n    Calculate the minimum number of segments needed to connect three points\n    with a polyline consisting of segments parallel to the coordinate axes.\n    \"\"\"\n    # Mapping x and y coordinates to their occurrences\n    x_map = defaultdict(int)\n    y_map = defaultdict(int)\n    \n    # Populating the maps with given points\n    x_map[x1] += 1\n    x_map[x2] += 1\n    x_map[x3] += 1\n    y_map[y1] += 1\n    y_map[y2] += 1\n    y_map[y3] += 1\n    \n    # Calculating shared x and y values\n    shared_x = sum(1 for x in x_map.values() if x > 1)\n    shared_y = sum(1 for y in y_map.values() if y > 1)\n    \n    # Determining the minimum segments based on shared coordinates\n    if shared_x == 2 or shared_y == 2:\n        return 2\n    else:\n        return 3\n\n# Reading input\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\n# Printing the result\nprint(min_segments(x1, y1, x2, y2, x3, y3))"}
{"solution": "def print_graph(n, edges):\n    print(\"YES\")\n    print(n, len(edges))\n    for edge in edges:\n        print(edge[0], edge[1])\n\ndef build_k_regular_graph(k):\n    if k == 1:\n        print_graph(2, [(1, 2)])\n    elif k % 2 == 0:\n        print(\"NO\")\n    else:\n        n = k + 1\n        edges = []\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                if j - i != 1 and j - i != n - 1:\n                    edges.append((i, j))\n        for i in range(1, n):\n            edges.append((i, n))\n        print_graph(n, edges)\n\nk = int(input())\nbuild_k_regular_graph(k)"}
{"solution": "def z_function(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            z[i] = min(r - i + 1, z[i - l])\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > r:\n            l, r = i, i + z[i] - 1\n    return z\n\ndef preprocess(s, t):\n    concatenated = t + '$' + s\n    z_values = z_function(concatenated)\n    n = len(s)\n    m = len(t)\n    occurrences = [0] * (n + 1)\n    for i, z in enumerate(z_values[m+1:], start=m+1):\n        if z == m:\n            occurrences[i - m] += 1\n        occurrences[i] -= 1\n    for i in range(1, n + 1):\n        occurrences[i] += occurrences[i - 1]\n    return occurrences\n\ndef solve():\n    n, m, q = map(int, input().split())\n    s = input()\n    t = input()\n    occurrences = preprocess(s, t)\n    \n    for _ in range(q):\n        l, r = map(int, input().split())\n        print(occurrences[r - 1] - occurrences[l - 1])\n\nsolve()"}
{"solution": "MOD = 10**9 + 7\n\ndef calculate_paths(n, k, d):\n    dp = [[0] * (n + 1) for _ in range(d + 1)]\n    for j in range(1, min(k + 1, n + 1)):\n        dp[1][j] = 1\n\n    for i in range(2, d + 1):\n        for j in range(1, n + 1):\n            for l in range(1, min(j, k) + 1):\n                dp[i][j] += dp[i - 1][j - l]\n                dp[i][j] %= MOD\n\n    result = 0\n    for j in range(d, n + 1):\n        for l in range(1, min(k + 1, n + 1)):\n            result += dp[d - 1][j - l]\n            result %= MOD\n\n    return result\n\nn, k, d = map(int, input().split())\nprint(calculate_paths(n, k, d))"}
{"solution": "def solve(row):\n    groups = []\n    count = 0\n    for i, cell in enumerate(row):\n        if cell == 'B':\n            count += 1\n        if cell == 'W' or i == len(row) - 1:\n            if count > 0:\n                groups.append(count)\n                count = 0\n    return groups\n\nn = int(input())\nrow = input()\n\nresult = solve(row)\n\nprint(len(result))\nif len(result) > 0:\n    print(' '.join(map(str, result)))\nelse:\n    print(0)"}
{"solution": "def process_operations(s, ops, p):\n    pairs = [-1] * len(s)\n    stack = []\n    for i, ch in enumerate(s):\n        if ch == '(':\n            stack.append(i)\n        else:\n            pairs[stack.pop()] = i\n            pairs[i] = stack[-1] if stack else -1\n\n    for op in ops:\n        if op == 'L':\n            p = next((i for i in range(p-1, -1, -1) if pairs[i] != -1), 0)\n        elif op == 'R':\n            p = next((i for i in range(p+1, len(s)) if pairs[i] != -1), len(s)-1)\n        else:\n            start, end = sorted([p, pairs[p]])\n            s = s[:start] + s[end+1:]\n            pairs = [p if i > p else p-2*(p-i) for i, p in enumerate(pairs) if p != -1 and p < start or p > end]\n            p = next((i for i in range(start, len(s)) if pairs[i] != -1), len(s)-1)\n\n    return s\n\nn, m, p = map(int, input().split())\ns = input()\nops = input()\nprint(process_operations(s, ops, p-1))"}
{"solution": "def find_possible_y(questions):\n    constraints = []\n    for q in questions:\n        op, x, ans = q.split()\n        x = int(x)\n        if ans == 'Y':\n            if op == '>':\n                constraints.append((x, float('-inf')))\n            elif op == '<':\n                constraints.append((x, float('inf')))\n            elif op == '>=':\n                constraints.append((x - 1, float('-inf')))\n            elif op == '<=':\n                constraints.append((x + 1, float('inf')))\n        else:\n            if op == '>':\n                constraints.append((x, float('inf')))\n            elif op == '<':\n                constraints.append((x, float('-inf')))\n            elif op == '>=':\n                constraints.append((x, float('inf')))\n            elif op == '<=':\n                constraints.append((x, float('-inf')))\n\n    constraints.sort()\n    last_inf = float('-inf')\n    for val, inf in constraints:\n        if inf == float('inf') and last_inf < val:\n            return val\n        last_inf = max(last_inf, val)\n    return 'Impossible'\n\nn = int(input())\nquestions = [input() for _ in range(n)]\nprint(find_possible_y(questions))"}
{"solution": "from math import gcd\n\ndef number_of_periods(a, b):\n    return a + b - gcd(a, b)\n\na, b = map(int, input().split())\nprint(number_of_periods(a, b))"}
{"solution": "def find_names(n, k, notes):\n    names = [chr(65 + i % 26) for i in range(n)]\n    for i in range(n - k + 1):\n        if notes[i] == 'NO':\n            for j in range(k):\n                if names[i + j] == names[i + j + 1]:\n                    names[i + j] += 'a'\n                    break\n    return names\n\ndef main():\n    n, k = map(int, input().split())\n    notes = input().split()\n    names = find_names(n, k, notes)\n    print(' '.join(names))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from math import inf\n\ndef min_operations_to_equal(a, b):\n    if a == b:\n        return 0\n\n    def operations_needed(x, y):\n        steps = 0\n        while x > y:\n            steps += 1\n            if x % 5 == 0:\n                x //= 5\n            elif x % 3 == 0:\n                x //= 3\n            elif x % 2 == 0:\n                x //= 2\n            else:\n                break\n            if x <= y:\n                return inf\n        return steps\n\n    operations = min(operations_needed(a, b), operations_needed(b, a))\n    return operations if operations != inf else -1\n\n# Example usage\na, b = map(int, input().split())\nprint(min_operations_to_equal(a, b))"}
{"solution": "def min_cost_palindrome(n, a, b, c):\n    dp = [[float('inf')] * (1 << n) for _ in range(n)]\n    for mask in range(1 << n):\n        for j in range(n):\n            if mask & (1 << j):\n                symm_pos = n - 1 - j\n                symm_mask = 1 << symm_pos\n                if c[j] == c[symm_pos] or c[j] == 2 or c[symm_pos] == 2:\n                    prev_mask = mask ^ symm_mask ^ (1 << j)\n                    cost = 0\n                    if c[j] == 2 and c[symm_pos] != c[j]:\n                        cost = min(a, b)\n                    elif c[symm_pos] == 2 and c[j] != c[symm_pos]:\n                        cost = min(a, b)\n                    dp[j][mask] = min(dp[j][mask], cost + dp[symm_pos][prev_mask])\n    return dp[0][(1 << n) - 1] if dp[0][(1 << n) - 1] < float('inf') else -1\n\n# Reading input\nn, a, b = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Printing output\nprint(min_cost_palindrome(n, a, b, c))"}
{"solution": "def solve_cube(k):\n    if k == 1:\n        print(-1)\n        return\n\n    for z in range(k):\n        for y in range(k):\n            for x in range(k):\n                # Alternating pattern, but flip the pattern every other layer\n                color = 'w' if (x + y + z) % 2 == 0 else 'b'\n                print(color, end='')\n            print()\n        print()\n\nk = int(input().strip())\nsolve_cube(k)"}
{"solution": "import math\n\ndef largest_lovely_divisor(n):\n    max_lovely = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % (i * i) == 0:\n            max_lovely = max(max_lovely, n // (i * i))\n    return max_lovely if max_lovely > 1 else n\n\nn = int(input())\nprint(largest_lovely_divisor(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    if n == 1:\n        return \"Yes\"\n    \n    prev = seating[0]\n    for i in range(1, n):\n        if seating[i] == '1':\n            if prev == '1' or (i != n-1 and seating[i+1] == '1'):\n                return \"No\"\n            if prev == '0' and i != n-1 and seating[i+1] == '0':\n                return \"No\"\n        prev = seating[i]\n    \n    return \"Yes\""}
{"solution": "def possible_k_values(n, a):\n    from math import gcd\n\n    # Calculate differences\n    diffs = [a[i] - a[i - 1] for i in range(1, len(a))]\n\n    possible_ks = set()\n\n    # Check each potential k\n    for k in range(1, n + 1):\n        valid = True\n        base_gcd = None\n        for i in range(k):\n            current_gcd = diffs[i]\n            for j in range(i + k, n, k):\n                current_gcd = gcd(current_gcd, diffs[j])\n            if base_gcd is None:\n                base_gcd = current_gcd\n            elif base_gcd != current_gcd:\n                valid = False\n                break\n        if valid:\n            possible_ks.add(k)\n\n    return sorted(list(possible_ks))\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Processing and printing output\nresult = possible_k_values(n, a)\nprint(len(result))\nprint(\" \".join(map(str, result)))"}
{"solution": "from itertools import combinations\n\ndef can_form_equal_teams(scores):\n    \"\"\"\n    Determines if it's possible to form two teams with equal scores from six given scores.\n    \n    :param scores: List of six integers representing the scores of participants.\n    :return: \"YES\" if it's possible to form two teams with equal scores, \"NO\" otherwise.\n    \"\"\"\n    total_sum = sum(scores)\n    if total_sum % 2 != 0:\n        return \"NO\"\n    \n    target = total_sum // 2\n    for team1 in combinations(scores, 3):\n        if sum(team1) == target:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nscores = list(map(int, input().split()))\n\n# Output result\nprint(can_form_equal_teams(scores))"}
{"solution": "import math\n\ndef is_2_3_integer(n):\n    if n == 1:\n        return True\n    while n % 2 == 0:\n        n //= 2\n    while n % 3 == 0:\n        n //= 3\n    return n == 1\n\ndef count_2_3_integers(l, r):\n    return sum(is_2_3_integer(i) for i in range(max(1, l), r + 1))\n\nif __name__ == \"__main__\":\n    l, r = map(int, input().split())\n    print(count_2_3_integers(l, r))"}
{"solution": "def candies_eaten(n, k):\n    if k == 0 and n == 1:\n        return 1\n    if k >= n * (n + 1) // 2:\n        return n - 1\n    diff = n * (n + 1) // 2 - k\n    eaten = (-1 + int((1 + 4 * 2 * diff)**0.5)) // 2\n    return n - eaten - (eaten * (eaten + 1) // 2 - diff)\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(candies_eaten(n, k))"}
{"solution": "def can_form_triangle(n, segments):\n    segments.sort()\n    for i in range(n - 2):\n        if segments[i] + segments[i + 1] > segments[i + 2]:\n            return \"YES\"\n    return \"NO\"\n\nn = int(input())\nsegments = list(map(int, input().split()))\nprint(can_form_triangle(n, segments))"}
{"solution": "def is_possible(x, y):\n    if y > x + 1:\n        return \"No\"\n    while x > 0 or y > 1:\n        if y >= 1 and y <= x + 1:\n            if x % 2 == 0 and y - 1 == x // 2:\n                return \"Yes\"\n            else:\n                return \"No\"\n        if x >= 2:\n            x -= 2\n            y += 1\n        elif y >= 1:\n            y -= 1\n            x += 1\n        else:\n            return \"No\"\n    return \"Yes\"\n\nx, y = map(int, input().split())\nprint(is_possible(x, y))"}
{"solution": "def max_rating(n, k, skills):\n    skills.sort(reverse=True)\n    total = sum(x // 10 for x in skills)\n    avg = sum(skills) // (10 * n)\n\n    while True:\n        needed = sum(max(0, avg * 10 - x) for x in skills)\n        if needed <= k:\n            return avg * n + total\n        avg -= 1\n\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\nprint(max_rating(n, k, skills))"}
{"solution": "def smallest_pretty_integer():\n    n, m = map(int, input().split())\n    a = set(map(int, input().split()))\n    b = set(map(int, input().split()))\n\n    # Try to find the smallest number with at least one digit from each set\n    for i in range(1, 10):\n        if i in a and i in b:\n            return i\n\n    # Construct the smallest number using digits from both sets\n    min_a = min(a)\n    min_b = min(b)\n\n    if min_a < min_b:\n        return str(min_a) + str(min_b)\n    else:\n        return str(min_b) + str(min_a)\n\nprint(smallest_pretty_integer())"}
{"solution": "def contest_problems(n, k):\n    total_time = 240  # Total time from 20:00 to midnight\n    time_needed_for_travel = k\n    time_for_contest = total_time - time_needed_for_travel\n    \n    # Calculate how many problems can be solved\n    problems_solved = 0\n    current_time = 0\n    for i in range(1, n + 1):\n        current_time += 5 * i\n        if current_time > time_for_contest:\n            break\n        problems_solved += 1\n    \n    return problems_solved\n\n# Read input from stdin\nn, k = map(int, input().split())\n\n# Process and print the result\nprint(contest_problems(n, k))"}
{"solution": "def max_teams(n, x, y, pages):\n    pages.sort()\n    for i in range(n):\n        pages[i] -= y\n    x_pages = 2 * x\n    teams = 0\n    for pages_needed in pages:\n        if x_pages >= pages_needed:\n            x_pages -= pages_needed\n            teams += 1\n        else:\n            break\n    return teams\n\nn, x, y = map(int, input().split())\npages = list(map(int, input().split()))\nprint(max_teams(n, x, y, pages))"}
{"solution": "def solve(b):\n    import math\n    factors = []\n    while b % 2 == 0:\n        factors.append(2)\n        b //= 2\n    f = 3\n    while f * f <= b:\n        if b % f == 0:\n            factors.append(f)\n            b //= f\n        else:\n            f += 2\n    if b != 1:\n        factors.append(b)\n\n    distinct_values = set()\n    for factor in factors:\n        distinct_values.add(factor)\n        current_lcm = factor\n        for other_factor in factors:\n            if other_factor != factor:\n                current_lcm = (current_lcm * other_factor) // math.gcd(current_lcm, other_factor)\n                distinct_values.add(current_lcm)\n    return len(distinct_values) + 1\n\nb = int(input())\nprint(solve(b))"}
{"solution": "def count_falling_positions(bumpers):\n    n = len(bumpers)\n    left_sequence = 0\n    right_sequence = 0\n    max_left_sequence = 0\n    max_right_sequence = 0\n    \n    # Counting the longest sequence of '<' from left to right\n    for bumper in bumpers:\n        if bumper == '<':\n            left_sequence += 1\n        else:\n            max_left_sequence = max(max_left_sequence, left_sequence)\n            left_sequence = 0\n            \n    max_left_sequence = max(max_left_sequence, left_sequence)\n    \n    # Counting the longest sequence of '>' from right to left\n    for bumper in reversed(bumpers):\n        if bumper == '>':\n            right_sequence += 1\n        else:\n            max_right_sequence = max(max_right_sequence, right_sequence)\n            right_sequence = 0\n            \n    max_right_sequence = max(max_right_sequence, right_sequence)\n    \n    # Calculating the number of positions from which the ball will fall\n    falling_positions = (n - max_left_sequence - max_right_sequence) if (max_left_sequence + max_right_sequence < n) else 0\n    \n    return falling_positions\n\n# Reading input\nn = int(input())\nbumpers = input()\n\n# Printing output\nprint(count_falling_positions(bumpers))"}
{"solution": "from collections import Counter\nimport sys\n\ninput = sys.stdin.readline\n\nn = int(input())\nstick_lengths = list(map(int, input().split()))\n\nstick_count = Counter(stick_lengths)\n\ntotal_area = 0\n\nfor length in sorted(stick_count):\n    while stick_count[length] >= 4:\n        total_area += length * length\n        stick_count[length] -= 4\n\n    if stick_count[length] >= 2 and stick_count.get(length - 1, 0) >= 2:\n        total_area += length * (length - 1)\n        stick_count[length] -= 2\n        stick_count[length - 1] -= 2\n\nprint(total_area)"}
{"solution": "from collections import defaultdict, Counter\nimport sys\n\ninput = sys.stdin.read\nreader = (s.split() for s in input().split('\\n'))\nir = iter(reader)\nnext(ir)\n\ndef decode(digits, mapping):\n    return int(''.join(str(mapping[d]) for d in digits))\n\ndef solve():\n    strings = [s for s in ir if s]\n    digit_counts = [Counter(s) for s in strings]\n\n    digit_groups = defaultdict(list)\n    for i, counts in enumerate(digit_counts):\n        for d, count in counts.items():\n            digit_groups[count].append((d, i))\n\n    mapping = {}\n    min_sum = float('inf')\n    \n    for perm in permutations('0123456789', len(digit_groups)):\n        for count, digits in digit_groups.items():\n            if len(digits) > 1 and '0' in perm[:count]:\n                break\n            for d, _ in digits:\n                mapping[d] = perm[count - 1]\n        else:\n            sum_ = sum(decode(s, mapping) for s in strings)\n            min_sum = min(min_sum, sum_)\n    \n    return min_sum\n\nprint(solve())"}
{"solution": "def max_teams(n, m):\n    min_teams = min(n, m//2)  # Maximum teams by A's method\n    remaining_newbies = m - 2*min_teams  # Newbies left after forming A's teams\n    \n    extra_experts = n - min_teams  # Extra experienced members after forming A's teams\n    b_teams_from_extra = remaining_newbies // (2*extra_experts + 1) if extra_experts > 0 else 0  # B's teams possible from remaining\n    \n    return min_teams + b_teams_from_extra\n\n# Reading input\nn, m = map(int, input().split())\n\n# Calculating and printing output\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    \"\"\"\n    Checks if the string s contains two non-overlapping substrings \"AB\" and \"BA\".\n    \"\"\"\n    ab_count = s.count(\"AB\")\n    ba_count = s.count(\"BA\")\n\n    # If both substrings are present and their sum of positions do not exceed the string length,\n    # it means they are non-overlapping.\n    has_ab = \"AB\" in s\n    has_ba = \"BA\" in s\n\n    if has_ab and has_ba:\n        last_ab_index = s.rfind(\"AB\")\n        first_ba_index = s.find(\"BA\")\n\n        # Ensure AB comes before BA and they do not overlap\n        if last_ab_index + 2 <= first_ba_index or (last_ab_index < first_ba_index and last_ab_index + 2 > first_ba_index):\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\ns = input().strip()\n\n# Print output\nprint(check_substrings(s))"}
{"solution": "def can_transform(initial, final):\n    stack = []\n    j = 0\n    for weight in reversed(initial):\n        stack.append(weight)\n        while stack and j < len(final) and stack[-1] <= final[j]:\n            stack.pop()\n            j += 1\n    return j == len(final)\n\ndef simulate_eating(initial, final):\n    i, j = 0, 0\n    n, k = len(initial), len(final)\n    actions = []\n\n    while i < n and j < k:\n        if initial[i] == final[j]:\n            j += 1\n        elif i + 1 < n and initial[i] + initial[i + 1] == final[j]:\n            if actions and actions[-1] == (i - 1, 'R'):\n                print(\"NO\")\n                return\n            actions.append((i, 'R'))\n            initial[i] += initial[i + 1]\n            del initial[i + 1]\n        else:\n            print(\"NO\")\n            return\n        i += 1\n\n    if j == k and i == n:\n        print(\"YES\")\n        for pos, direction in actions:\n            print(f\"{pos + 1} {direction}\")\n    else:\n        print(\"NO\")\n\ndef solve():\n    n = int(input())\n    initial = list(map(int, input().split()))\n    k = int(input())\n    final = list(map(int, input().split()))\n    \n    if not can_transform(initial[:], final):\n        print(\"NO\")\n        return\n    \n    simulate_eating(initial, final)\n\nsolve()"}
{"solution": "import sys\nfrom typing import List, Tuple\n\nPoint = Tuple[int, int]\n\ndef cross_product(o: Point, a: Point, b: Point) -> int:\n    \"\"\"\n    Returns the cross product of vectors OA and OB.\n    Positive if OAB makes a counter-clockwise turn,\n    negative for a clockwise turn, and zero if the points are collinear.\n    \"\"\"\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef can_connect_without_crossing(points: List[Point], matches: List[int]) -> bool:\n    n = len(points)\n    for i in range(n):\n        for k in range(i + 1, n):\n            if cross_product(points[i], points[matches[i]], points[matches[k]]) > 0:\n                return False\n    return True\n\ndef find_matching(rebels: List[Point], bases: List[Point]) -> str:\n    n = len(rebels)\n    m = len(bases)\n\n    if n != m:\n        return \"No\"\n\n    # Sort rebels by their polar angle with respect to the center of mass\n    com_x = sum(x for x, _ in rebels + bases) / (n + m)\n    com_y = sum(y for _, y in rebels + bases) / (n + m)\n    rebels_sorted = sorted(rebels, key=lambda p: (p[0] - com_x, p[1] - com_y))\n\n    # Assign bases to sorted rebels directly\n    matches = {rebels_sorted[i]: bases[i] for i in range(n)}\n\n    # Check if connections cross each other\n    if can_connect_without_crossing(list(matches.keys()) + list(matches.values()), [bases.index(matches[r]) for r in rebels_sorted]):\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Reading input\nr, b = map(int, sys.stdin.readline().split())\nrebels = [tuple(map(int, sys.stdin.readline().split())) for _ in range(r)]\nbases = [tuple(map(int, sys.stdin.readline().split())) for _ in range(b)]\n\n# Output result\nprint(find_matching(rebels, bases))"}
{"solution": "def max_power_of_two(n, arr):\n    max_power = 0\n    count = 0\n    for num in arr:\n        current_power = 0\n        while num % 2 == 0:\n            num //= 2\n            current_power += 1\n        if current_power > max_power:\n            max_power = current_power\n            count = 1\n        elif current_power == max_power:\n            count += 1\n    return 2 ** max_power, count\n\nn = int(input())\na = list(map(int, input().split()))\nr, cnt = max_power_of_two(n, a)\nprint(r, cnt)"}
{"solution": "def min_clicks(n, m):\n    if n == m:\n        return 0\n    if n > m:\n        return n - m\n    \n    steps = 0\n    while n != m:\n        if m % 2 == 0 and n < m:\n            m //= 2\n        else:\n            m += 1\n        steps += 1\n    return steps\n\nn, m = map(int, input().split())\nprint(min_clicks(n, m))"}
{"solution": "from collections import defaultdict\n\ndef check_tree(n, segments):\n    graph = defaultdict(set)\n    endpoints = []\n\n    for i, (l, r) in enumerate(segments):\n        endpoints.append((l, 'start', i))\n        endpoints.append((r, 'end', i))\n\n    endpoints.sort(key=lambda x: (x[0], x[1] == 'end'))\n\n    intersections = set()\n    last_end = None\n\n    for pos, typ, seg_id in endpoints:\n        if typ == 'start':\n            for other_seg in intersections:\n                graph[seg_id].add(other_seg)\n                graph[other_seg].add(seg_id)\n            intersections.add(seg_id)\n        else:\n            intersections.remove(seg_id)\n\n            if last_end and last_end != pos:\n                return \"NO\"\n            last_end = pos\n\n    for node in graph.values():\n        if len(node) != 2:\n            return \"NO\"\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor == parent:\n                continue\n            if not dfs(neighbor, node):\n                return False\n        return True\n\n    if not dfs(next(iter(graph)), -1):\n        return \"NO\"\n\n    return \"YES\" if len(visited) == n else \"NO\"\n\n# Reading input\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(check_tree(n, segments))"}
{"solution": "def max_ddos_period(n, requests):\n    \"\"\"\n    Finds the maximum length of a continuous period considered as a DDoS attack.\n    \"\"\"\n    from collections import deque\n    max_length = 0\n    q = deque()\n    sum_requests = 0\n    for i in range(n):\n        while q and q[0] < i:\n            sum_requests -= requests[q[0]]\n            q.popleft()\n        while sum_requests > 100 * (i - len(q) + 1):\n            if q:\n                sum_requests -= requests[q.pop()]\n        sum_requests += requests[i]\n        q.append(i)\n        if sum_requests > 100 * (i - len(q) + 1):\n            max_length = max(max_length, i - len(q) + 1)\n    return max_length\n\n# Reading input\nn = int(input())\nrequests = list(map(int, input().split()))\n\n# Printing output\nprint(max_ddos_period(n, requests))"}
{"solution": "def check_dissatisfaction(n, k, episodes):\n    from itertools import groupby\n\n    # Replace '?' with both possibilities and check\n    for replace in [\"Y\", \"N\"]:\n        temp = episodes.replace(\"?\", replace)\n        max_gap = max((sum(1 for _ in g) for k, g in groupby(temp) if k == 'N'), default=0)\n\n        if max_gap == k:\n            return \"YES\"\n\n    return \"NO\"\n\n# Example usage\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    episodes = input().strip()\n    print(check_dissatisfaction(n, k, episodes))"}
{"solution": "import sys\ninput = sys.stdin.readline\n\ndef main():\n    N, X, D = map(int, input().split())\n    if D == 0:\n        if N % 2 == 0:\n            print(1)\n        else:\n            print(2)\n    else:\n        ans = 2 * N - 1\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\ngood_performance = False\n\nfor _ in range(n):\n    name, before, after = input().split()\n    before = int(before)\n    after = int(after)\n    \n    if before >= 2400 and after > before:\n        good_performance = True\n\nif good_performance:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_trains_missed(binary_time):\n    \"\"\"\n    Given a binary string representing the time Team BowWow arrived at the station,\n    this function calculates the number of trains that have departed strictly before that time.\n    \n    :param binary_time: A string representing the arrival time in binary format without leading zeroes.\n    :return: The number of trains missed.\n    \"\"\"\n    missed_count = 0\n    binary_time = binary_time[::-1]  # Reverse the string to process from least significant bit\n    \n    for bit in binary_time:\n        if bit == '1':\n            missed_count += 1\n            if missed_count >= 64:  # Optimization: no need to continue if missed_count exceeds 63\n                break\n            missed_count = missed_count * 2\n    \n    return missed_count\n\n# Read input from stdin\nimport sys\nbinary_time = sys.stdin.readline().strip()\n\n# Calculate and print the result\nprint(count_trains_missed(binary_time))"}
{"solution": "# Import necessary library\nimport sys\n\n# Read input from stdin\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\n\n# Initialize variable to store the result\nmin_rows = 1\n\n# Iterate through each column\nfor col in zip(*matrix_a):\n    # Convert the current column to a string for easy comparison\n    col_str = ''.join(map(str, col))\n    # Check if the current column or its reverse exists in the remaining columns\n    if col_str not in [''.join(map(str, matrix_a[row])) for row in range(min_rows, n)] and \\\n       col_str[::-1] not in [''.join(map(str, matrix_a[row])) for row in range(min_rows, n)]:\n        min_rows += 1\n\n# Output the result\nprint(min_rows)"}
{"solution": "import heapq\n\ndef max_acceptable_orders(n, intervals):\n    intervals.sort(key=lambda x: x[1])\n    heap = []\n    for start, end in intervals:\n        if not heap or heap[0] <= start:\n            heapq.heappush(heap, end)\n        else:\n            heapq.heappushpop(heap, end)\n    return len(heap)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    intervals = [list(map(int, input().split())) for _ in range(n)]\n    print(max_acceptable_orders(n, intervals))"}
{"solution": "def check_boredom(n, k, x, y):\n    current_tables, current_formulas = 0, 0\n    prev_page_tables, prev_page_formulas = 0, 0\n\n    for i in range(n):\n        # Calculate new tables and formulas for the current page\n        current_tables += x[i]\n        current_formulas += y[i]\n\n        # Check if we can rearrange without exceeding k\n        if current_tables - prev_page_formulas > k or current_formulas - prev_page_tables > k:\n            return \"NO\"\n\n        # Update previous page values\n        prev_page_tables = current_tables\n        prev_page_formulas = current_formulas\n\n        # Reset counts if both are present on the page\n        if x[i] > 0 and y[i] > 0:\n            current_tables = 0\n            current_formulas = 0\n\n    # Final check\n    if current_tables > k or current_formulas > k:\n        return \"NO\"\n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Output result\nprint(check_boredom(n, k, x, y))"}
{"solution": "def can_human_win(n, k, coefficients):\n    # Track which indices have been set\n    set_indices = [coeff != '?' for coeff in coefficients]\n    \n    # Determine whose turn it is based on the last set index\n    computer_turn = sum(set_indices) % 2 == 1\n    \n    # Check divisibility condition\n    required_coeffs = [(coefficients[i] if set_indices[i] else 0) + (0 if i == 0 else required_coeffs[-1]) for i in range(n + 1)]\n    required_coeffs[0] = 0  # Adjust for initial condition\n    \n    # Fill in unset coefficients to check if we can satisfy divisibility\n    for i in range(n + 1):\n        if not set_indices[i]:\n            required_coeffs[i] = '?' if required_coeffs[i] == 0 else required_coeffs[i]\n    \n    # Determine if human can force a win\n    for i in range(n + 1):\n        if not set_indices[i] and (required_coeffs[i] != '?' or computer_turn):\n            return 'No'\n        computer_turn = not computer_turn\n    \n    return 'Yes'\n\n# Read input\nn, k = map(int, input().split())\ncoefficients = [input().strip() for _ in range(n + 1)]\n\n# Output result\nprint(can_human_win(n, k, coefficients))"}
{"solution": "from math import sqrt\nfrom bisect import bisect_left\n\n# Sieve of Eratosthenes for generating primes\nMAX_PRIME = 10**6 + 1\nis_prime = [True] * MAX_PRIME\nprimes = []\nfor i in range(2, MAX_PRIME):\n    if is_prime[i]:\n        primes.append(i)\n        for j in range(i*i, MAX_PRIME, i):\n            is_prime[j] = False\n\ndef find_smallest_X0(X2):\n    for i in range(bisect_left(primes, 2), bisect_left(primes, X2 - 1) + 1):\n        p = primes[i]\n        X0_candidate = ((X2 - 1) // p) * p\n        if X0_candidate >= X2 - 1:\n            X0_candidate += p\n        if X0_candidate < X2:\n            return X0_candidate\n    return X2\n\nif __name__ == \"__main__\":\n    X2 = int(input())\n    print(find_smallest_X0(X2))"}
{"solution": "def min_p_binary_summands(n, p):\n    if n == 1 and p != 0:\n        return -1\n    if p <= 0:\n        count = 0\n        while n > 0:\n            remainder = n % (-p)\n            n -= remainder\n            count += remainder\n            if n >= 0:\n                n -= 1\n                count += 1\n        return count\n    else:\n        binary_representation = bin(n)[2:]  # Convert n to binary and remove the '0b' prefix\n        return len(binary_representation)\n\n# Example usage\nif __name__ == \"__main__\":\n    n, p = map(int, input().split())\n    print(min_p_binary_summands(n, p))"}
{"solution": "def minify_number(n, k, S):\n    S = list(map(int, S))\n    changes = 0\n    for i in range(n):\n        if changes < k and S[i] > 0:\n            if i == 0 and S[i] != 1:  # Special case for the first digit\n                S[i] = 1\n                changes += 1\n            else:\n                S[i] = 0\n                changes += 1\n        if changes >= k:\n            break\n    # Ensure the number has n digits and doesn't start with zero\n    if S[0] == 0:\n        S[0] = 1\n    return ''.join(map(str, S))\n\n# Reading input\nn, k = map(int, input().split())\nS = input()\n\n# Processing and printing output\nprint(minify_number(n, k, S))"}
{"solution": "def solve(cnt_1, cnt_2, x, y):\n    lcm = x * y\n    a = cnt_1 + cnt_2\n    b = (cnt_1 * (x - 1) // x) + (cnt_2 * (y - 1) // y)\n    c = (cnt_1 * cnt_2 * (lcm - 1)) // (x * y)\n    return a + b - c\n\nif __name__ == \"__main__\":\n    cnt_1, cnt_2, x, y = map(int, input().split())\n    print(solve(cnt_1, cnt_2, x, y))"}
{"solution": "def final_position(n, sx, sy, dx, dy, t):\n    for _ in range(t):\n        k = sx + sy - 2\n        dx += k\n        dy += k\n        sx = ((sx + dx - 1) % n) + 1\n        sy = ((sy + dy - 1) % n) + 1\n        # Optimizing for large t by breaking the loop once the pattern repeats\n        if sx == ((sx + dx - 1) % n) + 1 and sy == ((sy + dy - 1) % n) + 1:\n            break\n    return sx, sy\n\n# Reading input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Calculating and printing the result\nresult = final_position(n, sx, sy, dx, dy, t)\nprint(*result)"}
{"solution": "def solve(s):\n    from collections import Counter\n    s = list(s)\n    cnt = Counter(s)\n    if '?' not in cnt or len(s) - cnt['?'] < 26:\n        if '?' in cnt: del cnt['?']\n        if max(cnt.values()) > 1:\n            return '-1'\n    \n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    used = set()\n    for i, ch in enumerate(s):\n        if ch == '?':\n            s[i] = ''\n        else:\n            used.add(ch)\n    \n    for ch in alphabet:\n        if ch not in used:\n            for i in range(len(s)):\n                if s[i] == '':\n                    s[i] = ch\n                    break\n    \n    left = ''.join(s)\n    right = alphabet[len(used):]\n    if len(left) + len(right) < 26:\n        return '-1'\n    \n    for i in range(len(s)-1, -1, -1):\n        if s[i] == '':\n            s[i] = right[-1]\n            right = right[:-1]\n            if len(right) == 0:\n                break\n    \n    return ''.join(s)\n\nif __name__ == \"__main__\":\n    s = input().strip()\n    print(solve(s))"}
{"solution": "def can_divide_apples(n, weights):\n    total_weight = sum(weights)\n    if total_weight % 2 != 0:\n        return \"NO\"\n    else:\n        target_weight = total_weight // 2\n        current_weight = 0\n        can_be_divided = \"YES\" if target_weight == 0 else \"NO\"\n        weights_count_100 = weights.count(100)\n        \n        if weights_count_100 % 2 == 0 or target_weight == 100 * weights_count_100:\n            can_be_divided = \"YES\"\n        \n        return can_be_divided\n\nif __name__ == \"__main__\":\n    n = int(input())\n    weights = list(map(int, input().split()))\n    print(can_divide_apples(n, weights))"}
{"solution": "import sys\nfrom functools import lru_cache\n\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\ndef solve():\n    n, m = map(int, input().split())\n    floors = [input() for _ in range(n)]\n    \n    @lru_cache(maxsize=None)\n    def dp(floor, last_pos):\n        if floor == n:\n            return 0\n        \n        # Left Stair\n        if last_pos == 0:\n            lights = [(pos, int(val)) for pos, val in enumerate(floors[floor]) if pos not in (0, m+1)]\n        # Right Stair\n        elif last_pos == m+1:\n            lights = [(pos, int(val)) for pos, val in enumerate(floors[floor]) if pos not in (0, m+1)][::-1]\n        else:\n            lights = [(pos, int(val)) for pos, val in enumerate(floors[floor]) if pos != last_pos and pos not in (0, m+1)]\n        \n        min_time = float('inf')\n        for i, (pos, state) in enumerate(lights):\n            if state == 0:\n                continue\n            \n            time_to_pos = abs(last_pos - pos)\n            time_to_left_stair = abs(pos - 0)\n            time_to_right_stair = abs(pos - (m+1))\n            \n            if i == 0:  # First light is on, check both stairs\n                min_time = min(min_time, time_to_pos + time_to_left_stair + dp(floor + 1, 0),\n                               time_to_pos + time_to_right_stair + dp(floor + 1, m+1))\n            else:  # Move to the next light\n                prev_pos, _ = lights[i-1]\n                time_to_next_light = abs(pos - prev_pos)\n                min_time = min(min_time, time_to_next_light + dp(floor, pos))\n                \n        return min_time\n    \n    print(dp(0, 0))\n\nsolve()"}
{"solution": "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\ndef dfs(node, visited, cycles, costs, adj):\n    stack = [node]\n    while stack:\n        node = stack[-1]\n        if node in visited:\n            stack.pop()\n            continue\n        visited.add(node)\n        if node in cycles:\n            cost = costs[node]\n            while stack and stack[-1] not in cycles:\n                cost = min(cost, costs[stack.pop()])\n            if stack and stack[-1] in cycles:\n                cost = min(cost, costs[stack.pop()])\n            cycles[cycles[node]] = cost\n            return\n        else:\n            cycles[node] = costs[node]\n            stack.append(adj[node-1])\n\nn = int(input())\ncosts = list(map(int, input().split()))\nadj = list(map(int, input().split()))\n\nvisited = set()\ncycles = {}\n\nfor i in range(n):\n    if i not in visited:\n        dfs(i, visited, cycles, costs, adj)\n\nprint(sum(cycles.values()))"}
{"solution": "def find_entrance(n, a, b):\n    result = (a + b - 1) % n + 1\n    print(result)\n\n# The following lines are for reading input and do not pertain to the solution logic.\nn, a, b = map(int, input().split())\nfind_entrance(n, a, b)"}
{"solution": "from collections import defaultdict\n\ndef min_arithmetic_progressions(n, sequence):\n    \"\"\"\n    Finds the minimum number of arithmetic progressions needed to form the given sequence.\n    \"\"\"\n    if n == 1:\n        return 1\n\n    dp = [1] * n  # Initialize DP table\n    last = defaultdict(lambda: defaultdict(int))  # Track the last occurrence of a value with a specific difference\n\n    for i in range(n - 1, -1, -1):\n        if sequence[i] != -1:\n            for j in range(i + 1, n):\n                if sequence[j] != -1:\n                    diff = sequence[j] - sequence[i]\n                    if diff >= 0:\n                        last[i][diff] = j\n\n    for i in range(n - 2, -1, -1):\n        if sequence[i] != -1:\n            for diff, j in last[i].items():\n                if sequence[j] != -1 and (sequence[j] - sequence[i] == diff):\n                    dp[i] = max(dp[i], 1 + dp[j])\n                elif sequence[j] == -1:\n                    for k in range(j + 1, n):\n                        if sequence[k] != -1:\n                            new_diff = sequence[k] - sequence[i]\n                            if new_diff == diff:\n                                dp[i] = max(dp[i], 1 + dp[k])\n                            break\n                    else:\n                        dp[i] = max(dp[i], 1 + dp[j])\n\n    return n - max(dp)\n\n# Reading input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(min_arithmetic_progressions(n, sequence))"}
{"solution": "def max_beauty(n, k, s):\n    max_len = 0\n    left = 0\n    count_a = 0\n    count_b = 0\n\n    for right in range(n):\n        if s[right] == 'a':\n            count_a += 1\n        else:\n            count_b += 1\n\n        while min(count_a, count_b) > k:\n            if s[left] == 'a':\n                count_a -= 1\n            else:\n                count_b -= 1\n            left += 1\n\n        max_len = max(max_len, right - left + 1)\n\n    return max_len\n\n# Reading input\nn, k = map(int, input().split())\ns = input()\n\n# Calculating and printing the result\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, parties):\n    alice_party = parties[0]\n    total_seats = sum(parties)\n    coalition_seats = alice_party\n    coalition = [1]\n\n    for i in range(1, n):\n        if alice_party >= 2 * parties[i]:\n            coalition_seats += parties[i]\n            coalition.append(i + 1)\n\n    if coalition_seats > total_seats // 2:\n        print(len(coalition))\n        print(' '.join(map(str, coalition)))\n    else:\n        print(0)\n\n# Reading input\nn = int(input())\nparties = list(map(int, input().split()))\n\nfind_coalition(n, parties)"}
{"solution": "import math\n\ndef max_reward(n):\n    return math.log2(n + 1)\n\nn = int(input())\nprint(max_reward(n))"}
{"solution": "def santa_gifts(n):\n    kids = []\n    i = 1\n    while n > 0:\n        if n - i >= 0:\n            kids.append(i)\n            n -= i\n            i += 1\n        else:\n            break\n    if n > 0:\n        kids[-1] += n\n    return len(kids), kids\n\nn = int(input())\nk, candies = santa_gifts(n)\nprint(k)\nprint(' '.join(map(str, candies)))"}
{"solution": "n = int(input())\nm = int(input())\n\nprint(m % (2**n))"}
{"solution": "def correct_word(s):\n    vowels = \"aeiouy\"\n    i = 0\n    while i < len(s) - 1:\n        if s[i] in vowels and s[i + 1] in vowels:\n            s = s[:i] + s[i+1:]\n        else:\n            i += 1\n    return s\n\nn = int(input())\ns = input()\nprint(correct_word(s))"}
{"solution": "def max_students(n, a, b, seats):\n    dp = [[0 for _ in range(3)] for _ in range(n + 1)]\n    dp[0][0], dp[0][1], dp[0][2] = 0, -float('inf'), -float('inf')\n    \n    for i in range(1, n + 1):\n        if seats[i - 1] == '*':\n            dp[i][0] = dp[i - 1][0]\n            dp[i][1] = dp[i - 1][1]\n            dp[i][2] = dp[i - 1][2]\n        else:\n            dp[i][0] = max(dp[i - 1])\n            dp[i][1] = dp[i - 1][0] + 1\n            dp[i][2] = max(dp[i - 1][1], dp[i - 1][0]) + 1\n    \n    count = max(dp[n])\n    \n    if count > a + b:\n        return min(a, b) * 2\n    elif a < b:\n        return a + min(b - a, count - a)\n    else:\n        return b + min(a - b, count - b)\n\ndef solve():\n    n, a, b = map(int, input().split())\n    seats = input()\n    print(max_students(n, a, b, seats))\n\nsolve()"}
{"solution": "import math\nr = int(input())\na = -1 + math.sqrt(1 + 4 * (r - 1))\na = int(a // 2)\nif a * (a + 1) == r - 1:\n    print(1, r - 2)\nelif a * (a + 2) < r - 1 < (a + 1) * (a + 3):\n    print(a + 2, r - 1 - a * (a + 2))\nelse:\n    print(\"NO\")"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    total = sum(a)\n    for i in range(1, n):\n        for subset in range(1 << i):\n            grigory_sum = sum(a[j] for j in range(i) if subset & (1 << j))\n            andrew_sum = total - grigory_sum - a[i]\n            if grigory_sum != andrew_sum and grigory_sum != a[i] and andrew_sum != a[i]:\n                print(i + 1)\n                print(\" \".join(str(j + 1) for j in range(i) if subset & (1 << j)) + \" \" + str(i + 1))\n                return\n    print(-1)\n\nsolve()"}
{"solution": "def min_diff_digits(n):\n    # Calculate the minimal number of different digits\n    min_diff = 1 if n <= 9 else len(str(n))\n    \n    # Adjust min_diff based on divisibility by 9\n    if n > 9:\n        remainder = n % 9\n        if remainder != 0:\n            min_diff = 2  # At most 2 different digits (9's and the remainder)\n    \n    # Prepare the result list\n    result = []\n    if min_diff == 1 or n < 9:\n        result = [n]\n    else:\n        quotient = n // 9\n        remainder = n % 9\n        result = [9] * quotient\n        if remainder != 0:\n            result.append(remainder)\n    \n    return min_diff, result\n\n# Read input\nn = int(input())\n\n# Get the minimal different digits and their counts\nmin_diff, digits = min_diff_digits(n)\n\n# Output the result\nprint(len(digits))\nprint(' '.join(map(str, digits)))"}
{"solution": "from collections import Counter\nimport math\nimport sys\ninput = sys.stdin.readline\n\ndef is_prime(n):\n    if n == 2 or n == 3: return True\n    if n < 2 or n%2 == 0: return False\n    if n < 9: return True\n    if n%3 == 0: return False\n    r = int(n**0.5)\n    f = 5\n    while f <= r:\n        if n%f == 0: return False\n        if n%(f+2) == 0: return False\n        f +=6\n    return True  \n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    count = Counter(a)\n    primes = [2]\n    non_primes = []\n    two_count = count[2]\n    odd_counts = []\n\n    for num in count:\n        if num == 2:\n            continue\n        elif num % 2 == 0:\n            non_primes.append(num)\n        else:\n            if is_prime(num):\n                primes.append(num)\n            else:\n                odd_counts.append((num, count[num]))\n\n    # Handle even numbers (only 2s matter)\n    result = [2] * min(1, two_count)\n\n    # Add primes\n    for prime in primes:\n        result.extend([prime] * count[prime])\n\n    # Add max 2 of any non-prime odd numbers\n    odd_counts.sort(key=lambda x: -x[1])\n    for num, cnt in odd_counts[:2]:\n        result.extend([num] * cnt)\n\n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def greatest_beautiful_divisor(n):\n    max_divisor = 0\n    for k in range(1, 17):  # Limiting k to a reasonable range\n        candidate = (2**k - 1) * (2**k)\n        if candidate <= n and candidate > max_divisor:\n            max_divisor = candidate\n    return max_divisor\n\n# Read input\nn = int(input())\n\n# Compute and print the result\nprint(greatest_beautiful_divisor(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef pow_mod(x, n):\n    result = 1\n    while n > 0:\n        if n & 1:\n            result = result * x % MOD\n        x = x * x % MOD\n        n >>= 1\n    return result\n\ndef count_d_magic(m, d, a, b):\n    n = len(a)\n    dp = [[[0 for _ in range(2)] for _ in range(m)] for _ in range(n + 1)]\n    dp[0][0][1] = 1\n\n    for i in range(1, n + 1):\n        for j in range(m):\n            for k in range(2):\n                for digit in range(10):\n                    if (digit == d and i % 2 == 0) or (digit != d and i % 2 != 0):\n                        continue\n                    new_val = (j * 10 + digit) % m\n                    dp[i][new_val][k] += dp[i - 1][j][k]\n                    dp[i][new_val][k] %= MOD\n                if k == 1:\n                    dp[i][(j * 10) % m][0] += dp[i - 1][j][1]\n                    dp[i][(j * 10) % m][0] %= MOD\n\n    def calculate_range(start, end):\n        result = 0\n        for i in range(n):\n            for digit in range(int(start[i])):\n                for j in range(m):\n                    result += dp[i][j][1] * pow_mod(10, n - 1 - i) * pow_mod(10, i) * (end[i] - digit)\n                    result %= MOD\n            start = list(map(int, start))\n            end = list(map(int, end))\n            for j in range(m):\n                result += dp[n][j][start == end and 1 or 0]\n                result %= MOD\n        return result\n\n    return (calculate_range(a, b) - calculate_range('0' * n, a)) % MOD\n\nm, d = map(int, input().split())\na = input()\nb = input()\n\nprint(count_d_magic(m, d, a, b))"}
{"solution": "def last_child_home(n, m, desires):\n    queue = list(range(1, n + 1))\n    for desire in desires:\n        m_given = 0\n        while True:\n            current_child = queue.pop(0)\n            if m_given + m >= desire:\n                break\n            queue.append(current_child)\n            m_given += m\n            desire -= m\n        if queue:\n            last_child = queue[-1]\n        else:\n            last_child = current_child\n    return last_child\n\n# Reading input\nn, m = map(int, input().split())\ndesires = list(map(int, input().split()))\n\n# Providing output\nprint(last_child_home(n, m, desires))"}
{"solution": "# Import necessary package\nfrom math import inf\n\ndef min_bills(n):\n    # Denominations of dollar bills\n    denominations = [100, 20, 10, 5, 1]\n    \n    # Initialize count of bills\n    count = 0\n    \n    # Loop through each denomination\n    for denom in denominations:\n        # Calculate how many bills of current denomination can be used\n        count += n // denom\n        # Subtract value of bills from total amount\n        n %= denom\n    \n    # Return total count of bills\n    return count\n\n# Read input\nn = int(input())\n\n# Print the result\nprint(min_bills(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef modinv(x):\n    return pow(x, MOD-2, MOD)\n\ndef precompute_factorials(n):\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    invfact[n] = modinv(fact[n])\n    for i in range(n, 0, -1):\n        invfact[i-1] = invfact[i] * i % MOD\n    return fact, invfact\n\ndef C(n, k, fact, invfact):\n    return fact[n] * invfact[k] * invfact[n-k] % MOD\n\ndef dp(n, k, fact, invfact):\n    dp = [[0] * (k+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        for j in range(k+1):\n            dp[i][j] = dp[i-1][j]\n            if j > 0:\n                dp[i][j] += 2 * dp[i-1][j-1]\n                if i > 1 and j > 1:\n                    dp[i][j] -= dp[i-2][j-2]\n            dp[i][j] %= MOD\n            if i >= j:\n                dp[i][j] *= fact[i-j]\n                dp[i][j] %= MOD\n    return dp[n][k]\n\ndef solve(n, k):\n    fact, invfact = precompute_factorials(n)\n    return dp(n, k, fact, invfact)\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    print(solve(n, k))"}
{"solution": "import heapq\nfrom collections import defaultdict\n\ndef max_beauty(n, k, beauties, colors):\n    color_counts = defaultdict(list)\n    for b, c in zip(beauties, colors):\n        heapq.heappush(color_counts[c], -b)\n\n    if len(color_counts) < 2 or k == 1:\n        return -1\n\n    total_max_beauty = 0\n    min_count = float('inf')\n    for count in color_counts.values():\n        min_count = min(min_count, len(count))\n        total_max_beauty += -count[0]\n\n    if min_count >= k:\n        return -1\n\n    for _ in range(k - 1):\n        for count in color_counts.values():\n            heapq.heappop(count)\n            total_max_beauty += -count[0]\n\n    return total_max_beauty\n\n# Example usage\nn, k = map(int, input().split())\nbeauties = list(map(int, input().split()))\ncolors = input()\nprint(max_beauty(n, k, beauties, colors))"}
{"solution": "import sys\n\ndef continued_fraction_to_rational(a):\n    n = len(a)\n    if n == 1:\n        return (a[0], 1)\n    p1, q1 = continued_fraction_to_rational(a[:n//2])\n    p2, q2 = continued_fraction_to_rational(a[n//2:])\n    return (p2 * p1 + q2, q2 * p1)\n\ndef main():\n    p, q = map(int, sys.stdin.readline().split())\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    \n    cf_p, cf_q = continued_fraction_to_rational(a)\n    \n    if p * cf_q == q * cf_p:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def shift_stick(expression):\n    parts = expression.split('+=')\n    a = parts[0].count('|')\n    c = parts[1].count('|')\n\n    b_plus, b_equals = parts[1][:2], parts[1][2:]\n    b = b_plus.count('|') - 1 if '+' in b_plus else 0\n\n    if a + b == c:\n        return expression  # Already correct\n\n    # Try moving one stick from C to A\n    if a + b + 1 == c - 1 and c > 1:\n        return f\"{a * '|'}+={b * '|'}|{c - 2 * '|'}\"\n\n    # Try moving one stick from A to C\n    if a - 1 + b == c + 1 and a > 1:\n        return f\"{(a - 2) * '|'}|+={b * '|'}{c + 2 * '|'}\"\n\n    # Check for impossible conditions\n    if a + b != c and not (a + b + 1 == c - 1 or a - 1 + b == c + 1):\n        return \"Impossible\"\n\nexpression = input().strip()\nprint(shift_stick(expression))"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial_mod(n, mod):\n    fact = 1\n    for i in range(1, n + 1):\n        fact = (fact * i) % mod\n    return fact\n\ndef inverse_factorial(n, fact, mod):\n    inv = pow(fact[n], mod - 2, mod)\n    return inv\n\ndef comb_mod(n, k, fact, ifact, mod):\n    return (fact[n] * ifact[k] * ifact[n - k]) % mod\n\ndef main():\n    n, k = map(int, input().split())\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n    ifact = [1] * (n + 1)\n    ifact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        ifact[i - 1] = (ifact[i] * i) % MOD\n\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            for d in range(max(0, j - i), min(j, i - 1) + 1):\n                dp[i][j] += dp[i - 1][j - d - 1] * comb_mod(i - 1, d, fact, ifact, MOD)\n                dp[i][j] %= MOD\n\n    ans = dp[n][k] * fact[n] % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import defaultdict\nimport math\nimport copy\n\ndef solve(points):\n    n = len(points)\n    if n == 1:\n        x, y = points[0]\n        return [max(abs(x), abs(y))], [f\"{'' if x >= 0 else 'D' * abs(x)}{'R' * abs(x) if x >= 0 else ''}{'' if y >= 0 else 'D' * abs(y)}{'U' * abs(y) if y >= 0 else ''}\"]\n    \n    # Find the minimum number of segments needed\n    min_segments = float('inf')\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dx = points[i][0] - points[j][0]\n                dy = points[i][1] - points[j][1]\n                min_segments = min(min_segments, max(abs(dx), abs(dy)))\n    \n    # Build the robot arm configuration\n    arm_config = [min_segments]\n    arm_modes = []\n    \n    # Calculate modes for each point\n    modes = []\n    for x, y in points:\n        mode = ''\n        if x < 0:\n            mode += 'L' * (-x // min_segments)\n        elif x > 0:\n            mode += 'R' * (x // min_segments)\n        \n        if y < 0:\n            mode += 'D' * (-y // min_segments)\n        elif y > 0:\n            mode += 'U' * (y // min_segments)\n        \n        modes.append(mode)\n    \n    # Extend the arm if necessary\n    while len(modes[0]) < 40:\n        arm_config.append(arm_config[-1])\n        for k in range(n):\n            modes[k] += modes[k][-1]\n    \n    return arm_config, modes\n\n# Read input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Solve and print output\nresult = solve(points)\nif result is None:\n    print(-1)\nelse:\n    arm_config, modes = result\n    print(len(arm_config))\n    print(' '.join(map(str, arm_config)))\n    for mode in modes:\n        print(mode)"}
{"solution": "n = int(input())\ns = input()\n\ni = 0\nwhile i < len(s):\n    if s[i:i+3] == 'ogo':\n        count = 3\n        while i + count <= len(s) and s[i:i+count] == 'ogo'[:count]:\n            count += 2\n        s = s[:i] + \"***\" + s[count-3:]\n    i += 1\n\nprint(s)"}
{"solution": "from math import sqrt\n\ndef prime_factors(n):\n    i = 2\n    factors = set()\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.add(i)\n    if n > 1:\n        factors.add(n)\n    return factors\n\ndef max_divisible(n, p):\n    res = 1\n    while n % p == 0:\n        res *= p\n        n //= p\n    return res\n\ndef power_mod(base, exp, mod):\n    result = 1\n    base %= mod\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        exp = exp >> 1\n        base = (base * base) % mod\n    return result\n\nMOD = 10**9 + 7\nx, n = map(int, input().split())\nprimes = prime_factors(x)\n\nresult = 1\nfor p in primes:\n    count = 0\n    cur_n = n\n    while cur_n > 0:\n        cur_n //= p\n        count += cur_n\n    result = (result * power_mod(p, count, MOD)) % MOD\n\nprint(result)"}
{"solution": "from collections import defaultdict\n\ndef sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    max_x = 10**9\n    # Create a map to store possible ranges for s(x)\n    s_range = defaultdict(lambda: [float('inf'), -float('inf')])\n    for x in range(1, max_x):\n        s_x = sum_of_digits(x)\n        if x == b * s_x**a + c:\n            solutions.append(x)\n        s_range[s_x][0] = min(s_range[s_x][0], x)\n        s_range[s_x][1] = max(s_range[s_x][1], x)\n    \n    # Check for potential solutions based on s(x) values\n    for s_x in range(1, 82):  # Maximum s(x) for x < 10^9 is 81\n        left, right = s_range[s_x]\n        if left <= b * s_x**a + c <= right:\n            x = b * s_x**a + c\n            if left <= x <= right and x not in solutions:\n                solutions.append(x)\n    \n    return sorted(solutions)\n\nif __name__ == \"__main__\":\n    a, b, c = map(int, input().split())\n    solutions = find_solutions(a, b, c)\n    print(len(solutions))\n    print(' '.join(map(str, solutions)))"}
{"solution": "def can_solve_with_one_turn(colors):\n    from collections import Counter\n    \n    def is_solved_with_one_move(face):\n        return len(set(face)) == 1 or len(set(face)) == 2 and max(Counter(face).values()) == 3\n    \n    # Define the faces of the cube based on the input order\n    faces = [\n        (0, 1, 5, 6),  # Top face\n        (2, 3, 7, 8),  # Bottom face\n        (0, 4, 7, 13), # Left face\n        (1, 4, 8, 14), # Front face\n        (5, 4, 11, 17),# Right face\n        (6, 4, 10, 16) # Back face\n    ]\n    \n    for face in faces:\n        if is_solved_with_one_move([colors[i] for i in face]):\n            return \"YES\"\n    return \"NO\"\n\n# Reading input\ncolors = list(map(int, input().split()))\n\n# Processing and printing output\nprint(can_solve_with_one_turn(colors))"}
{"solution": "def find_min_hacks(p, x, y):\n    def simulate(s):\n        i = (s // 50) % 475\n        for _ in range(25):\n            if 26 + i == p:\n                return True\n            i = (i * 96 + 42) % 475\n        return False\n\n    min_hacks = float('inf')\n    for s in range(y, 20001):\n        if simulate(s):\n            needed_points = s - x\n            hacks, remainder = divmod(needed_points, 100)\n            unsuccessful_hacks = 0\n            if remainder != 0:\n                unsuccessful_hacks = (50 - remainder) // 50\n                if (50 - remainder) % 50 != 0:\n                    unsuccessful_hacks += 1\n            min_hacks = min(min_hacks, hacks + unsuccessful_hacks)\n\n    return min_hacks\n\np, x, y = map(int, input().split())\nprint(find_min_hacks(p, x, y))"}
{"solution": "def min_distance(n, a, b, c):\n    if n == 1:\n        return 0\n    else:\n        return min(a, b) + (n - 2) * min(a, b, c)\n\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nprint(min_distance(n, a, b, c))"}
{"solution": "def min_total_distance():\n    x1, x2, x3 = map(int, input().split())\n    # Sort the coordinates to find the middle point\n    coords = sorted([x1, x2, x3])\n    meeting_point = coords[1]  # The middle coordinate\n    # Calculate total distance to the meeting point\n    total_distance = abs(x1 - meeting_point) + abs(x2 - meeting_point) + abs(x3 - meeting_point)\n    print(total_distance)\n\nmin_total_distance()"}
{"solution": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\ndef min_operations(n, x, arr):\n    bit_counts = [0] * 20  # Assuming max value in arr is within given limit\n    for num in arr:\n        for bit in range(20):\n            if num & (1 << bit):\n                bit_counts[bit] += 1\n\n    x_bits = [bit for bit in range(20) if x & (1 << bit)]\n    \n    def can_form_value(value_bits):\n        needed_changes = 0\n        for bit in value_bits:\n            if bit_counts[bit] < 2:\n                needed_changes += 1\n        return needed_changes\n    \n    # Try forming values using x's bits\n    best_result = float('inf')\n    for mask in range(1 << len(x_bits)):\n        value_bits = [x_bits[i] for i in range(len(x_bits)) if mask & (1 << i)]\n        changes_needed = can_form_value(value_bits)\n        if changes_needed < best_result:\n            best_result = changes_needed\n    \n    return best_result if best_result != float('inf') else -1\n\n# Reading inputs\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\nprint(min_operations(n, x, arr))"}
{"solution": "def is_cross(picture):\n    h, w = len(picture), len(picture[0])\n    center = None\n\n    for y in range(h):\n        for x in range(w):\n            if picture[y][x] == '*':\n                if center is None:\n                    center = (y, x)\n                else:\n                    # Check for more than one '*' before finding the center\n                    if center != (y, x):\n                        return False\n\n    if center is None:\n        return False\n\n    cy, cx = center\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    arms = []\n\n    for dy, dx in directions:\n        length = 0\n        y, x = cy + dy, cx + dx\n        while 0 <= y < h and 0 <= x < w and picture[y][x] == '*':\n            length += 1\n            y += dy\n            x += dx\n        if length == 0:\n            return False\n        arms.append(length)\n\n    min_arm_length = min(arms)\n    for i, (dy, dx) in enumerate(directions):\n        y, x = cy + dy * min_arm_length, cx + dx * min_arm_length\n        if (0 <= y < h and 0 <= x < w and picture[y][x] == '*') or \\\n           (cy + dy * arms[i], cx + dx * arms[i]) == center:\n            return False\n\n    return True\n\nif __name__ == \"__main__\":\n    h, w = map(int, input().split())\n    picture = [input() for _ in range(h)]\n    print(\"YES\" if is_cross(picture) else \"NO\")"}
{"solution": "def generate_adjacency_matrix(n, a, b):\n    if a + b - 1 > n:\n        print(\"NO\")\n        return\n    print(\"YES\")\n    components = [1] * a\n    components[-1] += n - sum(components)\n    idx = 0\n    matrix = [['0'] * n for _ in range(n)]\n    for i in range(1, a):\n        for j in range(components[idx], n):\n            matrix[idx][j] = '1'\n            matrix[j][idx] = '1'\n        idx += components[idx]\n    for row in matrix:\n        print(''.join(row))\n\ndef solve():\n    n, a, b = map(int, input().split())\n    if a == n and b == n:\n        print(\"NO\")\n    elif min(a, b) == 1 and max(a, b) != n:\n        print(\"NO\")\n    else:\n        generate_adjacency_matrix(n, a if a <= b else b, a if a > b else b)\n\nsolve()"}
{"solution": "def min_problems_needed():\n    c, d = map(int, input().split())\n    n, m = map(int, input().split())\n    k = int(input())\n\n    needed_slots = n * m - k\n    if needed_slots <= 0:\n        return 0\n\n    max_main_rounds = needed_slots // n\n    if needed_slots % n > 0:\n        max_main_rounds += 1\n\n    min_problems = float('inf')\n    for main_rounds in range(max_main_rounds + 1):\n        additional_rounds = max(0, (needed_slots - main_rounds * n) // 1)\n        current_problems = main_rounds * c + additional_rounds * d\n        min_problems = min(min_problems, current_problems)\n\n    return min_problems\n\nprint(min_problems_needed())"}
{"solution": "def solve(s):\n    if s.count('X') > 1:\n        return \"Impossible\"\n    \n    first_row = 'X' + s[:12] + s[12] * 11\n    second_row = s[13] * 13 + 'X' + s[14:26]\n    \n    return first_row, second_row\n\ns = input()\nresult = solve(s)\nif isinstance(result, str):\n    print(result)\nelse:\n    print(result[0])\n    print(result[1])"}
{"solution": "import math\nx, y = map(int, input().split())\nif x == y:\n    print('=')\nelse:\n    x_log = y * math.log(x)\n    y_log = x * math.log(y)\n    if x_log > y_log:\n        print('>')\n    else:\n        print('<')"}
{"solution": "3\nimport sys\nfrom math import pi\n\n# Define a function to calculate the maximum number of balloons\ndef max_balloons(r, h):\n    \"\"\"\n    Calculate the maximum number of balloons that can fit in the cupboard.\n    \n    :param r: Radius of the semicircle (top of the cupboard)\n    :param h: Height of the walls (sides of the cupboard)\n    :return: Maximum number of balloons that can fit\n    \"\"\"\n    # Calculate the number of balloons that can fit in the height\n    vertical_balloons = (h + r) // r\n    # Calculate the number of balloons that can fit in the width (semicircle diameter)\n    horizontal_balloons = r // (r / 2)\n    # Total number of balloons is the product of vertical and horizontal fits\n    return vertical_balloons * horizontal_balloons\n\n# Read input from stdin\nr, h = map(int, sys.stdin.readline().strip().split())\n\n# Calculate and print the result\nprint(max_balloons(r, h))"}
{"solution": "from collections import Counter\n\n# Reading input\nt = list(map(int, input().split()))\n\n# Counting occurrences\ncount = Counter(t)\n\n# Sum of all cards\ntotal_sum = sum(t)\n\n# Minimum sum to remove\nmin_to_remove = float('inf')\n\n# Trying to remove 2 or 3 cards with the same number\nfor num, freq in count.items():\n    if freq >= 2:\n        min_to_remove = min(min_to_remove, 2 * num)\n    if freq >= 3:\n        min_to_remove = min(min_to_remove, 3 * num)\n\n# If we found a way to remove cards, subtract from total sum\nif min_to_remove != float('inf'):\n    total_sum -= min_to_remove\n\nprint(total_sum)"}
{"solution": "def min_distance(n, a, xs):\n    xs.append(a)\n    xs.sort()\n    a_idx = xs.index(a)\n    \n    left_dist = xs[a_idx - 1] if a_idx > 0 else float('-inf')\n    right_dist = xs[a_idx + 1] if a_idx < n else float('inf')\n    \n    if left_dist == float('-inf'):\n        return right_dist - a\n    elif right_dist == float('inf'):\n        return a - left_dist\n    else:\n        return min((right_dist - a) + (xs[-2] - xs[0]), (a - left_dist) + (xs[-1] - xs[1]))\n\nn, a = map(int, input().split())\nxs = list(map(int, input().split()))\nprint(min_distance(n, a, xs))"}
{"solution": "import math\n\ndef sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef find_smallest_root(n):\n    \"\"\"\n    Finds the smallest positive integer root of the equation x^2 + s(x)*x - n = 0,\n    where s(x) is the sum of digits of x. Returns -1 if no such root exists.\n    \"\"\"\n    upper_limit = int(math.sqrt(n)) + 1000\n    for x in range(1, upper_limit + 1):\n        if x**2 + sum_of_digits(x) * x - n == 0:\n            return x\n    return -1\n\n# Example usage\nn = int(input().strip())\nprint(find_smallest_root(n))"}
{"solution": "def bedtime(s, t):\n    sh, sm = int(s[:2]), int(s[3:])\n    th, tm = int(t[:2]), int(t[3:])\n    \n    mh = 0 if sm >= tm else 1\n    sm = (sm - tm + 60) % 60\n    sh = (sh - th - mh + 24) % 24\n    \n    return f\"{sh:02d}:{sm:02d}\"\n\ns = input()\nt = input()\nprint(bedtime(s, t))"}
{"solution": "def max_mean_subsegment_length():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    # Calculate prefix sums\n    prefix_sums = [0]\n    for i in range(n):\n        prefix_sums.append(prefix_sums[-1] + a[i])\n\n    # Initialize variables to track the maximum mean and corresponding segment length\n    max_mean = float('-inf')\n    max_length = 0\n\n    # Use a sliding window approach to find the subsegment with the maximum mean\n    for r in range(1, n + 1):\n        for l in range(r):\n            current_mean = (prefix_sums[r] - prefix_sums[l]) / (r - l)\n            if current_mean > max_mean:\n                max_mean = current_mean\n                max_length = r - l\n            elif current_mean == max_mean:\n                if r - l > max_length:\n                    max_length = r - l\n\n    return max_length\n\nprint(max_mean_subsegment_length())"}
{"solution": "MOD = 998244353\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef comb(n, k):\n    if k > n:\n        return 0\n    num = den = 1\n    for i in range(k):\n        num = (num * (n - i)) % MOD\n        den = (den * (i + 1)) % MOD\n    return (num * modinv(den)) % MOD\n\ndef solve(n, m, k):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            dp[i][j] = (dp[i - 1][j] + (dp[i - 1][j - 1] if j > 0 else 0)) % MOD\n    ans = 0\n    for j in range(k + 1):\n        ans = (ans + (comb(n - 1, j) * dp[n - j][k - j]) % MOD * (m * pow(m - 1, j, MOD)) % MOD) % MOD\n    return ans\n\nn, m, k = map(int, input().split())\nprint(solve(n, m, k))"}
{"solution": "def is_magic_number(n):\n    patterns = ['1', '14', '144']\n    def search(s, index=0):\n        if index == len(s):\n            return True\n        for p in patterns:\n            if s.startswith(p, index):\n                if search(s, index + len(p)):\n                    return True\n        return False\n    return \"YES\" if search(str(n)) else \"NO\"\n\n# Example usage:\n# n = int(input())\n# print(is_magic_number(n))"}
{"solution": "def min_moves_to_corner(n, m, i, j, a, b):\n    def dist(x1, y1, x2, y2):\n        return abs(x1 - x2), abs(y1 - y2)\n    \n    corners = [(1, 1), (1, m), (n, 1), (n, m)]\n    res = []\n    \n    for x, y in corners:\n        dx, dy = dist(i, j, x, y)\n        \n        if dx % a == 0 and dy % b == 0:\n            k = min(dx // a, dy // b)\n            if (dx // a - k) * (dy // b - k) <= 0:\n                res.append(k)\n            else:\n                if ((dx // a) % 2) == ((dy // b) % 2):\n                    res.append(k + 2)\n                else:\n                    res.append(k + 1)\n    \n    if res:\n        return min(res)\n    else:\n        return \"Poor Inna and pony!\"\n\n# Example check (Uncomment to test)\n# print(min_moves_to_corner(5, 7, 1, 3, 2, 2))  # Output: 2\n# print(min_moves_to_corner(5, 5, 2, 3, 1, 1))  # Output: Poor Inna and pony!"}
{"solution": "def max_removals(s):\n    \"\"\"\n    Given a string s, returns the maximum number of characters that can be removed\n    such that a character s[i] is removed if at least one of its adjacent characters\n    is the previous letter in the Latin alphabet for s[i].\n    \"\"\"\n    removed = 0\n    change = True\n    while change:\n        change = False\n        max_char = ''\n        max_index = -1\n        for i in range(len(s)):\n            prev = ord(s[i]) - 1\n            if i > 0 and ord(s[i-1]) == prev or i < len(s)-1 and ord(s[i+1]) == prev:\n                if s[i] > max_char:\n                    max_char = s[i]\n                    max_index = i\n                    change = True\n        if max_index != -1:\n            s = s[:max_index] + s[max_index+1:]\n            removed += 1\n    return removed\n\n# Read input\nn = int(input())\ns = input()\n\n# Calculate and print the result\nprint(max_removals(s))"}
{"solution": "import bisect\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nq = int(input())\n\nposs = set()\nfor i in range(n):\n    for cnt in range(1, k + 1):\n        poss.add((cnt, a[i] * cnt))\n\nposs = sorted(list(poss), key=lambda x: x[1])\n\nfor _ in range(q):\n    x = int(input())\n    res = float('inf')\n    for cnt in range(1, k + 1):\n        idx = bisect.bisect_left(poss, (0, x - cnt * a[0]), hi=len(poss))\n        while idx > 0 and abs(poss[idx - 1][1] - x) <= cnt * a[0]:\n            if poss[idx - 1][1] == x - cnt * a[0] and poss[idx - 1][0] + cnt <= k:\n                res = min(res, poss[idx - 1][0] + cnt)\n            idx -= 1\n    print(res if res != float('inf') else -1)"}
{"solution": "import math\n\ndef find_min_time(s, x1, x2, t1, t2, p, d):\n    if t2 <= t1:\n        return abs(x2 - x1) * t2\n\n    def time_to_meet(x1, x2, p, d):\n        if d == 1:\n            if p < x1:\n                return (x1 - p) * t1, x1\n            else:\n                return abs(p - x1) * t1 / (t1 + t2), (x1 + p) / 2.0\n        else:\n            if p > x1:\n                return (p - x1) * t1, x1\n            else:\n                return abs(p - x1) * t1 / (t1 + t2), (x1 + p) / 2.0\n\n    def time_to_reach_end(p, d):\n        if d == 1:\n            return (s - p) * t1, s\n        else:\n            return p * t1, 0\n\n    min_time = abs(x2 - x1) * t2\n    current_p = p\n    while True:\n        meet_time, meet_pos = time_to_meet(x1, x2, current_p, d)\n        end_time, end_pos = time_to_reach_end(current_p, d)\n        if d == 1:\n            next_p = 0 if end_pos == s else s\n        else:\n            next_p = s if end_pos == 0 else 0\n\n        if meet_pos == x2 or end_pos == x2:\n            min_time = min(min_time, meet_time + abs(meet_pos - x2) * t1)\n            break\n        else:\n            min_time = min(min_time, meet_time + abs(x2 - meet_pos) * t2,\n                           end_time + abs(x2 - end_pos) * t2,\n                           meet_time + time_to_meet(meet_pos, x2, next_p, -d)[0])\n\n        if meet_time > end_time:\n            break\n        current_p = next_p\n        d *= -1\n\n    return min_time\n\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\nprint(find_min_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "import math\n\nn, x = map(int, input().split())\nprint(min(n, x // n) * 2 - (math.gcd(x, n) > n - min(n, x // n)))"}
{"solution": "def generate_password(n, k):\n    password = []\n    alphabet = [chr(97 + i) for i in range(k)]  # First k letters of the alphabet\n    \n    # Fill most of the password\n    for i in range(n - 1):\n        password.append(alphabet[i % k])\n    \n    # Add a different character at the end if necessary\n    if n > 1 and k > 1:\n        last_char = alphabet[(n - 1) % k]\n        prev_char = password[-1]\n        last_char = next(c for c in alphabet if c != prev_char)\n        password.append(last_char)\n    else:\n        password.append(alphabet[0])\n    \n    return ''.join(password)\n\n# Read input\nn, k = map(int, input().split())\n\n# Generate and print the password\nprint(generate_password(n, k))"}
{"solution": "def main():\n    n = int(input())\n    directions = input()\n    coordinates = list(map(int, input().split()))\n    \n    closest_collision_time = float('inf')\n    \n    for i in range(n - 1):\n        if directions[i] == 'R' or directions[i + 1] == 'L':\n            continue\n        \n        distance = coordinates[i + 1] - coordinates[i]\n        if directions[i] == 'L' and directions[i + 1] == 'L':\n            collision_time = distance // 2\n        else:\n            collision_time = distance\n        \n        closest_collision_time = min(closest_collision_time, collision_time)\n    \n    if closest_collision_time == float('inf'):\n        print(-1)\n    else:\n        print(closest_collision_time)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_seal_area(n, a, b, seals):\n    areas = sorted(min(x, y) * min(a // x, b // y) * (x * y) for x, y in seals for _ in range(2))\n    return 0 if len(areas) < 2 else areas[-1] + areas[-2]\n\nn, a, b = map(int, input().split())\nseals = [tuple(map(int, input().split())) for _ in range(n)]\nprint(max_seal_area(n, a, b, seals))"}
{"solution": "def find_odd_one_out(n, points):\n    x_counts, y_counts = {}, {}\n    \n    for x, y in points:\n        x_counts[x] = x_counts.get(x, 0) + 1\n        y_counts[y] = y_counts.get(y, 0) + 1\n\n    for x, y in points:\n        if x_counts[x] > n or y_counts[y] > n:\n            continue\n        else:\n            return x, y\n\nif __name__ == \"__main__\":\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(4 * n + 1)]\n    result = find_odd_one_out(n, points)\n    print(*result)"}
{"solution": "def max_digit_product(n):\n    if n < 10:\n        return n\n    digits = []\n    while n > 0:\n        digits.append(n % 10)\n        n //= 10\n    digits.sort(reverse=True)\n    product = 1\n    for d in digits:\n        if d == 0:\n            digits.remove(d)\n        else:\n            product *= d\n    if product == 1 and 0 in digits:\n        return max(digits)\n    while digits and digits[-1] == 1:\n        digits.pop()\n    if len(digits) >= 10:\n        digits[-10] -= 1\n        digits.extend([9] * 9)\n    else:\n        digits.extend([9] * (10 - len(digits)))\n    result = 1\n    for d in digits:\n        result *= d\n    return result\nn = int(input())\nprint(max_digit_product(n))"}
{"solution": "def find_min_k_to_win(e_votes):\n    n = len(e_votes)\n    e_votes.sort()\n\n    min_k = max(e_votes)\n    awruk_votes = 0\n    e_total_votes = sum(e_votes)\n\n    for i in range(n):\n        awruk_votes += (min_k - e_votes[i])\n        if awruk_votes > e_total_votes - e_votes[i]:\n            return min_k\n        elif awruk_votes == e_total_votes - e_votes[i]:\n            min_k += 1\n            awruk_votes += 1\n            continue\n\n    return min_k\n\nn = int(input())\na = list(map(int, input().split()))\n\nprint(find_min_k_to_win(a))"}
{"solution": "def count_operations_until_stable(points: str) -> int:\n    operations = 0\n    while True:\n        prev_length = len(points)\n        points = ''.join(char for i, char in enumerate(points) if (i == 0 or points[i-1] == char) and (i == len(points)-1 or points[i+1] == char))\n        if len(points) == prev_length:\n            break\n        operations += 1\n    return operations\n\n# Example usage:\n# points = input().strip()\n# print(count_operations_until_stable(points))"}
{"solution": "import heapq\n\ndef find_min_product_triplets(n, arr):\n    \"\"\"\n    Finds the number of minimum product triplets in the array.\n    \"\"\"\n    min_heap = []\n    for i, val in enumerate(arr):\n        # Keep only the smallest three elements in the heap\n        if len(min_heap) > 2:\n            heapq.heappushpop(min_heap, (val, i))\n        else:\n            heapq.heappush(min_heap, (val, i))\n\n    # Heap should now contain the three smallest values and their indices\n    min_vals = sorted([heapq.heappop(min_heap)[1] for _ in range(3)])\n\n    # Count occurrences of each value\n    counts = [0] * 4\n    for i, val in enumerate(arr):\n        if val in min_vals:\n            counts[min_vals.index(val)] += 1\n\n    result = 0\n    if counts[0] >= 3:\n        # If the smallest value appears at least three times\n        result += counts[0] * (counts[0] - 1) * (counts[0] - 2) // 6\n    if counts[0] >= 1 and counts[1] >= 1 and counts[2] >= 1:\n        # If all three different values appear at least once\n        result += counts[0] * counts[1] * counts[2]\n\n    print(result)\n\n# Example usage\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    arr = list(map(int, input().strip().split()))\n    find_min_product_triplets(n, arr)"}
{"solution": "def min_cuts(n):\n    if n == 0: return 0\n    if n == 1: return 1\n    if n <= 3: return n\n    return n - 1 + (n + 1) % 2\n\n# Example usage:\n# n = int(input())\n# print(min_cuts(n))"}
{"solution": "def max_bank_balance(n):\n    str_n = str(n)\n    if n > 0:\n        return max(int(str_n[:-1]), int(str_n[1:]))\n    else:\n        if len(str_n) == 2:\n            return 0\n        else:\n            max_val = int(str_n)\n            for i in range(1, len(str_n)-1):\n                new_val = int(str_n[:i] + str_n[i+1:])\n                max_val = max(max_val, new_val)\n            return max_val\n\nn = int(input())\nprint(max_bank_balance(n))"}
{"solution": "def spinner_direction(start, end, n):\n    positions = {'v': 0, '<': 1, '^': 2, '>': 3}\n    start_pos = positions[start]\n    end_pos = positions[end]\n    \n    diff = (start_pos - end_pos) % 4\n    if n % 4 == 0:\n        return 'undefined' if diff != 0 else 'undefined'\n    elif (4 - diff) % 4 == n % 4:\n        return 'cw'\n    elif diff % 4 == n % 4:\n        return 'ccw'\n    else:\n        return 'undefined'\n\n# Read input\nstart, end = input().split()\nn = int(input())\n\n# Print output\nprint(spinner_direction(start, end, n))"}
{"solution": "def remaining_dominoes(n, pushes):\n    pushes = 'L' + pushes + 'R'\n    count = 0\n    i = 1\n    while i < len(pushes) - 1:\n        if pushes[i] == '.':\n            if pushes[i-1] == pushes[i+1]:\n                count += (pushes[i+1] == 'R')\n            else:\n                count += 1\n        i += 1\n    return count\n\nn = int(input())\npushes = input().strip()\nprint(remaining_dominoes(n, pushes))"}
{"solution": "def find_permutation(n, m, leaders):\n    # Initialize the permutation list with -1 values\n    perm = [-1] * n\n    \n    # Track the last position for each element\n    last_pos = {i: -1 for i in range(1, n + 1)}\n    \n    for i in range(m):\n        leader = leaders[i]\n        \n        if i == m - 1:\n            # Last leader can have any value not yet used\n            for j in range(n):\n                if perm[j] == -1:\n                    perm[leader - 1] = j + 1\n                    break\n        else:\n            next_leader = leaders[i + 1]\n            \n            if last_pos[leader] != -1:\n                # Calculate the required value based on the previous position\n                val = (next_leader - last_pos[leader] - 1) % n + 1\n            else:\n                # First occurrence, calculate based on current position\n                val = (next_leader - leader) % n\n            \n            # Assign the calculated value to the current leader's position\n            perm[leader - 1] = val\n            \n        # Update the last position of the current leader\n        last_pos[leader] = (leader - 1 + val - 1) % n + 1\n    \n    # Check if all positions are filled\n    if -1 in perm:\n        return -1\n    else:\n        return perm\n\n# Read input\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\n# Find and print the permutation or -1\nresult = find_permutation(n, m, leaders)\nprint(*result) if isinstance(result, list) else print(result)"}
{"solution": "import sys\n\ndef read_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef solve():\n    a, k = read_ints()\n    s = str(a)\n    n = len(s)\n\n    # Precompute the minimum digit at each position for all suffixes\n    min_suffix = [n] * n\n    for i in reversed(range(n - 1)):\n        min_suffix[i] = min(i, min_suffix[i + 1])\n\n    result = list(s)\n    for i in range(n):\n        if k <= 0: break\n        j = min_suffix[i]\n        if i == j: continue  # No need to swap if the current digit is already the smallest in the suffix\n\n        # Find the farthest possible position we can swap with, considering the remaining swaps\n        while j > i and j - i > k:\n            j -= 1\n\n        # Swap the digits\n        result[i], result[j] = result[j], result[i]\n        k -= j - i\n\n    print(''.join(result))\n\nsolve()"}
{"solution": "def next_in_sequence(a, b, c, d):\n    # Check for arithmetic progression\n    if (b - a) == (c - b) == (d - c):\n        return d + (b - a)\n    \n    # Check for geometric progression\n    elif (b / a) == (c / b) == (d / c) and b % a == 0 and c % b == 0 and d % c == 0:\n        return int(d * (b / a))\n    \n    # Neither arithmetic nor geometric\n    else:\n        return 42\n\n# Read input\na, b, c, d = map(int, input().split())\n\n# Calculate and print the result\nprint(next_in_sequence(a, b, c, d))"}
{"solution": "def max_distance(n, colors):\n    max_dist = 0\n    color_index = {}\n\n    for i in range(n):\n        if colors[i] not in color_index:\n            color_index[colors[i]] = i\n        else:\n            for color, index in color_index.items():\n                if color != colors[i]:\n                    max_dist = max(max_dist, i - index)\n\n    return max_dist\n\n# Example usage\nn = int(input())\ncolors = list(map(int, input().split()))\nprint(max_distance(n, colors))"}
{"solution": "def find_santa_seat(n, m, k):\n    lane = (k - 1) // (m * 2) + 1\n    desk = ((k - 1) % (m * 2)) // 2 + 1\n    side = \"L\" if ((k - 1) % 2 == 0) else \"R\"\n    return f\"{lane} {desk} {side}\"\n\nn, m, k = map(int, input().split())\nprint(find_santa_seat(n, m, k))"}
{"solution": "def final_card_color(n, cards):\n    colors = {'B': 0, 'G': 0, 'R': 0}\n    for card in cards:\n        colors[card] += 1\n\n    all_colors_present = all(count % 2 != 0 for count in colors.values())\n    odd_color_count = sum(count % 2 for count in colors.values())\n\n    if odd_color_count == 1:\n        result = [color for color, count in colors.items() if count % 2 != 0]\n    elif odd_color_count == 3 or (odd_color_count == 0 and all_colors_present):\n        result = ['B', 'G', 'R']\n    else:\n        result = [color for color, count in colors.items() if count % 2 != 0]\n\n    result.sort()\n    return ''.join(result)\n\n# Reading input and calling the function\nn = int(input())\ncards = input().strip()\nprint(final_card_color(n, cards))"}
