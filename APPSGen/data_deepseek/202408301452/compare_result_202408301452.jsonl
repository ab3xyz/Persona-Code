{"solution": "def max_accordion_length(s):\n    if len(s) < 4 or s.count('[') < 1 or s.count(']') < 1 or s.count(':') < 2:\n        return -1\n\n    first_open_bracket = s.find('[')\n    last_close_bracket = s.rfind(']')\n    if first_open_bracket >= last_close_bracket:\n        return -1\n\n    first_colon_after_open = s.find(':', first_open_bracket, last_close_bracket)\n    last_colon_before_close = s.rfind(':', first_open_bracket, last_close_bracket)\n    if first_colon_after_open == -1 or last_colon_before_close == -1 or first_colon_after_open >= last_colon_before_close:\n        return -1\n\n    vertical_lines_count = s.count('|', first_colon_after_open, last_colon_before_close)\n    return 4 + vertical_lines_count\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(max_accordion_length(s))"}
{"solution": "def max_digit_sum_number(x):\n    num_str = str(x)\n    max_sum_num = ''\n    flag = False\n    for digit in num_str:\n        if flag:\n            max_sum_num += '9'\n        else:\n            if digit != '0':\n                new_digit = str(int(digit) - 1)\n                max_sum_num += new_digit\n                flag = True\n            else:\n                max_sum_num += '0'\n    if not flag:\n        max_sum_num = num_str\n    else:\n        max_sum_num = max_sum_num[:-1] + '9'\n    return int(max_sum_num)\n\n# Read input\nx = int(input().strip())\n\n# Find and print the result\nprint(max_digit_sum_number(x))"}
{"solution": "def next_lucky_year(year):\n    year_str = str(year)\n    next_year = year + 1\n    while True:\n        if len(set(str(next_year))) == 1 and '0' not in str(next_year):\n            return next_year - year\n        next_year += 1\n\n# Read input\nyear = int(input().strip())\n\n# Output the result\nprint(next_lucky_year(year))"}
{"solution": "def max_painted_sections(n, q, painters):\n    # Initialize a list to keep track of painted sections\n    painted = [0] * (n + 1)\n    \n    # Calculate the total number of sections each painter covers\n    for l, r in painters:\n        painted[l - 1] += 1\n        painted[r] -= 1\n    \n    # Apply prefix sum to determine the number of painters covering each section\n    for i in range(1, n + 1):\n        painted[i] += painted[i - 1]\n    \n    # Convert the painted list to a binary list indicating whether a section is painted\n    painted = [1 if x > 0 else 0 for x in painted[:-1]]\n    \n    # Calculate prefix sums of the painted sections for efficient range sum queries\n    prefix_sums = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + painted[i - 1]\n    \n    # Initialize the maximum number of painted sections\n    max_painted = 0\n    \n    # Try excluding each pair of painters and calculate the maximum painted sections\n    for i in range(q):\n        for j in range(i + 1, q):\n            # Copy the current state of painted sections\n            current_painted = painted[:]\n            \n            # Exclude the i-th and j-th painters\n            for k in range(painters[i][0] - 1, painters[i][1]):\n                current_painted[k] = max(0, current_painted[k] - 1)\n            for k in range(painters[j][0] - 1, painters[j][1]):\n                current_painted[k] = max(0, current_painted[k] - 1)\n            \n            # Calculate the number of painted sections after excluding the painters\n            painted_count = sum(current_painted)\n            max_painted = max(max_painted, painted_count)\n    \n    return max_painted\n\n# Read input\nn, q = map(int, input().split())\npainters = [list(map(int, input().split())) for _ in range(q)]\n\n# Output the result\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def find_snooze_count(x, hh, mm):\n    if '7' in f\"{hh:02d}{mm:02d}\":\n        return 0\n    \n    snooze_count = 0\n    while '7' not in f\"{hh:02d}{mm:02d}\":\n        mm -= x\n        if mm < 0:\n            mm += 60\n            hh -= 1\n        if hh < 0:\n            hh += 24\n        snooze_count += 1\n    \n    return snooze_count\n\n# Read input\nx = int(input())\nhh, mm = map(int, input().split())\n\n# Output the result\nprint(find_snooze_count(x, hh, mm))"}
{"solution": "def min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0\n    elif l == 1:\n        return abs(r - pos) + 1\n    elif r == n:\n        return abs(pos - l) + 1\n    else:\n        return min(abs(pos - l), abs(pos - r)) + (r - l) + 2\n\n# Read input\nn, pos, l, r = map(int, input().split())\n\n# Calculate and print the result\nprint(min_seconds_to_close_tabs(n, pos, l, r))"}
{"solution": "def min_blows_to_defeat_zmei(t, queries):\n    results = []\n    for n, x, blows in queries:\n        max_damage = max_net_damage = 0\n        for d, h in blows:\n            max_damage = max(max_damage, d)\n            max_net_damage = max(max_net_damage, d - h)\n        \n        if max_damage >= x:\n            results.append(1)\n        elif max_net_damage > 0:\n            results.append((x - max_damage + max_net_damage - 1) // max_net_damage + 1)\n        else:\n            results.append(-1)\n    return results\n\n# Reading input\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Getting results\nresults = min_blows_to_defeat_zmei(t, queries)\n\n# Printing output\nfor result in results:\n    print(result)"}
{"solution": "def find_empty_day(n, m):\n    day = 0\n    while n > 0:\n        day += 1\n        if n < day:\n            break\n        n -= day\n        n += m\n    return day\n\n# Read input\nn, m = map(int, input().split())\n\n# Output the result\nprint(find_empty_day(n, m))"}
{"solution": "def min_extra_tiles_to_win(tiles):\n    # Sort tiles to make it easier to find sequences\n    tiles.sort(key=lambda x: (x[1], int(x[0])))\n    \n    # Check for existing koutsu or shuntsu\n    for i in range(3):\n        if tiles[i][0] == tiles[i+1][0] == tiles[i+2][0] and tiles[i][1] == tiles[i+1][1] == tiles[i+2][1]:\n            return 0  # Found a koutsu\n        if i < 1 and tiles[i][1] == tiles[i+1][1] == tiles[i+2][1] and int(tiles[i][0]) + 1 == int(tiles[i+1][0]) and int(tiles[i+1][0]) + 1 == int(tiles[i+2][0]):\n            return 0  # Found a shuntsu\n    \n    # Check for potential koutsu or shuntsu with one extra tile\n    for i in range(3):\n        for j in range(i+1, 4):\n            if tiles[i][0] == tiles[j][0] and tiles[i][1] == tiles[j][1]:\n                return 1  # Can form a koutsu with one extra tile\n            if tiles[i][1] == tiles[j][1] and abs(int(tiles[i][0]) - int(tiles[j][0])) < 3:\n                return 1  # Can form a shuntsu with one extra tile\n    \n    # Check for potential koutsu or shuntsu with two extra tiles\n    for i in range(3):\n        for j in range(i+1, 4):\n            if tiles[i][1] == tiles[j][1]:\n                if abs(int(tiles[i][0]) - int(tiles[j][0])) == 1:\n                    return 2  # Can form a shuntsu with two extra tiles\n                if abs(int(tiles[i][0]) - int(tiles[j][0])) == 2:\n                    return 2  # Can form a shuntsu with two extra tiles\n    \n    # If no koutsu or shuntsu can be formed, she needs to draw three extra tiles\n    return 3\n\n# Read input\ntiles = input().split()\n\n# Print the result\nprint(min_extra_tiles_to_win(tiles))"}
{"solution": "def find_maks_sofa(d, n, m, sofas, conditions):\n    cnt_l, cnt_r, cnt_t, cnt_b = conditions\n    left = [0] * d\n    right = [0] * d\n    top = [0] * d\n    bottom = [0] * d\n\n    for i in range(d):\n        for j in range(d):\n            if i != j:\n                if (sofas[i][0] < sofas[j][0] or sofas[i][2] < sofas[j][2]) and (sofas[i][1] == sofas[j][1] or sofas[i][3] == sofas[j][3]):\n                    left[i] += 1\n                if (sofas[i][0] > sofas[j][0] or sofas[i][2] > sofas[j][2]) and (sofas[i][1] == sofas[j][1] or sofas[i][3] == sofas[j][3]):\n                    right[i] += 1\n                if (sofas[i][1] < sofas[j][1] or sofas[i][3] < sofas[j][3]) and (sofas[i][0] == sofas[j][0] or sofas[i][2] == sofas[j][2]):\n                    top[i] += 1\n                if (sofas[i][1] > sofas[j][1] or sofas[i][3] > sofas[j][3]) and (sofas[i][0] == sofas[j][0] or sofas[i][2] == sofas[j][2]):\n                    bottom[i] += 1\n\n    for i in range(d):\n        if left[i] == cnt_l and right[i] == cnt_r and top[i] == cnt_t and bottom[i] == cnt_b:\n            return i + 1\n    return -1\n\n# Read input\nd = int(input())\nn, m = map(int, input().split())\nsofas = [list(map(int, input().split())) for _ in range(d)]\nconditions = list(map(int, input().split()))\n\n# Find and print the result\nprint(find_maks_sofa(d, n, m, sofas, conditions))"}
{"solution": "def calculate_days_off(n):\n    min_days_off = (n // 7) * 2 + (0 if n % 7 < 5 else 1 if n % 7 == 5 else 2)\n    max_days_off = (n // 7) * 2 + (0 if n % 7 < 6 else 2)\n    return min_days_off, max_days_off\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the result\nmin_days_off, max_days_off = calculate_days_off(n)\nprint(min_days_off, max_days_off)"}
{"solution": "def max_chocolates(n, a, b, p, q):\n    # Calculate the number of tiles divisible by a, b, and both a and b\n    count_a = n // a\n    count_b = n // b\n    count_ab = n // (a * b)\n    \n    # Calculate the number of tiles divisible by a but not b and vice versa\n    count_a_not_b = count_a - count_ab\n    count_b_not_a = count_b - count_ab\n    \n    # Calculate the maximum number of chocolates\n    # Paint the tiles divisible by both a and b with the color that gives more chocolates\n    max_chocolates = max(p, q) * count_ab + p * count_a_not_b + q * count_b_not_a\n    \n    return max_chocolates\n\n# Read input\nn, a, b, p, q = map(int, input().split())\n\n# Print the output\nprint(max_chocolates(n, a, b, p, q))"}
{"solution": "def max_golden_subsegment_after_swap(n, trophies):\n    golden_segments = []\n    current_length = 0\n    total_gold = 0\n\n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n            total_gold += 1\n        else:\n            if current_length > 0:\n                golden_segments.append(current_length)\n                current_length = 0\n    if current_length > 0:\n        golden_segments.append(current_length)\n\n    if not golden_segments:\n        return 0\n\n    max_length = max(golden_segments)\n    second_max_length = 0\n    for length in golden_segments:\n        if length != max_length and length > second_max_length:\n            second_max_length = length\n\n    if total_gold == n:\n        return n\n\n    max_length += 1 if total_gold > max_length else 0\n    max_length += second_max_length if second_max_length > 0 else 0\n\n    return min(max_length, total_gold)\n\n# Read input\nn = int(input())\ntrophies = input().strip()\n\n# Output the result\nprint(max_golden_subsegment_after_swap(n, trophies))"}
{"solution": "from collections import defaultdict, deque\n\ndef topological_sort(graph, in_degree, n):\n    queue = deque()\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    order = []\n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        for dependent in graph[course]:\n            in_degree[dependent] -= 1\n            if in_degree[dependent] == 0:\n                queue.append(dependent)\n    \n    return order\n\ndef main():\n    n, k = map(int, input().split())\n    main_courses = list(map(int, input().split()))\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    \n    for i in range(1, n + 1):\n        data = list(map(int, input().split()))\n        t_i = data[0]\n        dependencies = data[1:]\n        for dep in dependencies:\n            graph[dep].append(i)\n            in_degree[i] += 1\n    \n    order = topological_sort(graph, in_degree, n)\n    \n    if len(order) != n:\n        print(-1)\n        return\n    \n    required_courses = set(main_courses)\n    for course in order:\n        if course in required_courses:\n            required_courses.remove(course)\n        if not required_courses:\n            break\n    \n    if required_courses:\n        print(-1)\n    else:\n        print(len(order))\n        print(' '.join(map(str, order)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def restore_stack_sortable_permutation(n, k, p):\n    if k == 1:\n        # If only one element is given, we can arrange the rest in descending order\n        # to maximize lexicographical order and ensure stack-sortability.\n        return p + list(range(n, p[0], -1))\n    \n    # Check if the given k elements are already not stack-sortable\n    stack = []\n    b = []\n    for i in range(k):\n        while stack and stack[-1] < p[i]:\n            b.append(stack.pop())\n        stack.append(p[i])\n    while stack:\n        b.append(stack.pop())\n    if b != sorted(p[:k]):\n        return -1\n    \n    # If the given k elements are stack-sortable, we can try to maximize the remaining elements\n    remaining = sorted(set(range(1, n+1)) - set(p), reverse=True)\n    for i in range(k, n):\n        p.append(remaining.pop(0))\n    \n    return p\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = restore_stack_sortable_permutation(n, k, p)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "def is_in_sequence(a, b, c):\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    if (b - a) % c == 0 and ((b - a) // c >= 0):\n        return \"YES\"\n    else:\n        return \"NO\"\n\na, b, c = map(int, input().split())\nprint(is_in_sequence(a, b, c))"}
{"solution": "def can_form_regular_bracket_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    if cnt_1 == cnt_4:\n        if cnt_1 == 0:\n            return 1 if cnt_3 == 0 else 0\n        else:\n            return 1 if cnt_3 <= cnt_1 + cnt_2 else 0\n    else:\n        return 0\n\n# Read input\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\n# Output result\nprint(can_form_regular_bracket_sequence(cnt_1, cnt_2, cnt_3, cnt_4))"}
{"solution": "def mexican_wave_spectators(n, k, t):\n    if t <= k:\n        return t\n    elif t <= n:\n        return k\n    else:\n        return n + k - t\n\n# Read input\nn, k, t = map(int, input().split())\n\n# Output the result\nprint(mexican_wave_spectators(n, k, t))"}
{"solution": "import sys\nfrom collections import deque\n\ndef play_game(s):\n    s = deque(s)\n    t = []\n    u = []\n    \n    while s or t:\n        if not t:\n            t.append(s.popleft())\n        elif not s:\n            u.append(t.pop())\n        else:\n            if s[0] < t[-1]:\n                t.append(s.popleft())\n            else:\n                u.append(t.pop())\n    \n    return ''.join(u)\n\n# Read input from stdin\ns = sys.stdin.readline().strip()\n\n# Output the result\nprint(play_game(s))"}
{"solution": "def is_valid_stats(n, stats):\n    prev_plays, prev_clears = stats[0]\n    if prev_clears > prev_plays:\n        return \"NO\"\n    for i in range(1, n):\n        plays, clears = stats[i]\n        if plays < prev_plays or clears < prev_clears or clears > plays or plays - prev_plays < clears - prev_clears:\n            return \"NO\"\n        prev_plays, prev_clears = plays, clears\n    return \"YES\"\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        stats = [tuple(map(int, input().split())) for _ in range(n)]\n        print(is_valid_stats(n, stats))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_palindrome(time):\n    return time == time[::-1]\n\ndef find_next_palindrome_time(hh, mm):\n    minutes_to_sleep = 0\n    while True:\n        if is_palindrome(f\"{hh:02d}:{mm:02d}\".replace(\":\", \"\")):\n            return minutes_to_sleep\n        minutes_to_sleep += 1\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n        if hh == 24:\n            hh = 0\n\ninput_time = input().strip()\nhh, mm = map(int, input_time.split(\":\"))\nprint(find_next_palindrome_time(hh, mm))"}
{"solution": "def max_distance_after_one_swap(n, a):\n    min_index = a.index(1)\n    max_index = a.index(n)\n    return max(max_index, n - 1 - max_index, max_index + n - 1 - min_index, min_index, n - 1 - min_index)\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Printing the result\nprint(max_distance_after_one_swap(n, a))"}
{"solution": "def is_s_palindrome(s):\n    return \"TAK\" if s == s[::-1] else \"NIE\"\n\n# Read input\ns = input().strip()\n\n# Output result\nprint(is_s_palindrome(s))"}
{"solution": "from itertools import permutations\n\ndef max_permutation_less_than_b(a, b):\n    a_digits = sorted(str(a), reverse=True)\n    b_digits = str(b)\n    max_num = -1\n\n    def is_valid_permutation(perm):\n        num = int(''.join(perm))\n        return num <= b and num > max_num\n\n    for perm in permutations(a_digits):\n        if perm[0] == '0':\n            continue\n        if is_valid_permutation(perm):\n            max_num = int(''.join(perm))\n\n    return max_num\n\n# Read input\na = int(input().strip())\nb = int(input().strip())\n\n# Output the result\nprint(max_permutation_less_than_b(a, b))"}
{"solution": "def can_win_in_one_turn(board):\n    directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n    \n    def count_consecutive(r, c, dr, dc):\n        count = 0\n        for i in range(1, 5):\n            nr, nc = r + dr * i, c + dc * i\n            if 0 <= nr < 10 and 0 <= nc < 10 and board[nr][nc] == 'X':\n                count += 1\n            else:\n                break\n        for i in range(1, 5):\n            nr, nc = r - dr * i, c - dc * i\n            if 0 <= nr < 10 and 0 <= nc < 10 and board[nr][nc] == 'X':\n                count += 1\n            else:\n                break\n        return count\n\n    for r in range(10):\n        for c in range(10):\n            if board[r][c] == '.':\n                for dr, dc in directions:\n                    if count_consecutive(r, c, dr, dc) >= 4:\n                        return 'YES'\n    return 'NO'\n\n# Read input\nboard = [input().strip() for _ in range(10)]\n\n# Output result\nprint(can_win_in_one_turn(board))"}
{"solution": "def generate_symmetrical_matrix(n, k):\n    if k > n * n:\n        return -1\n    \n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        if k <= 0:\n            break\n        for j in range(i, n):\n            if k <= 0:\n                break\n            if i == j:\n                if k > 0:\n                    matrix[i][j] = 1\n                    k -= 1\n            else:\n                if k > 1:\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n                elif k == 1:\n                    matrix[i][i] = 1\n                    k -= 1\n    \n    if k > 0:\n        return -1\n    \n    return matrix\n\ndef print_matrix(matrix):\n    for row in matrix:\n        print(' '.join(map(str, row)))\n\nn, k = map(int, input().split())\nresult = generate_symmetrical_matrix(n, k)\nif result == -1:\n    print(result)\nelse:\n    print_matrix(result)"}
{"solution": "import math\n\ndef evaluate_expressions(x, y, z):\n    expressions = [\n        x**(y**z), x**(z**y), (x**y)**z, (x**z)**y,\n        y**(x**z), y**(z**x), (y**x)**z, (y**z)**x,\n        z**(x**y), z**(y**x), (z**x)**y, (z**y)**x\n    ]\n    return expressions\n\ndef find_max_expression(x, y, z):\n    expressions = evaluate_expressions(x, y, z)\n    max_value = max(expressions)\n    max_index = expressions.index(max_value)\n    \n    # Mapping index to the corresponding expression string\n    expression_strings = [\n        \"x^y^z\", \"x^z^y\", \"(x^y)^z\", \"(x^z)^y\",\n        \"y^x^z\", \"y^z^x\", \"(y^x)^z\", \"(y^z)^x\",\n        \"z^x^y\", \"z^y^x\", \"(z^x)^y\", \"(z^y)^x\"\n    ]\n    \n    return expression_strings[max_index]\n\n# Read input\nx, y, z = map(float, input().split())\n\n# Find and print the maximum expression\nprint(find_max_expression(x, y, z))"}
{"solution": "def min_operations_to_type_string(n, s):\n    if n <= 1:\n        return n\n    \n    min_ops = n\n    for i in range(1, n):\n        if s[:i] == s[i:2*i]:\n            min_ops = min(min_ops, i + 1 + (n - 2 * i))\n    \n    return min_ops\n\n# Read input\nn = int(input())\ns = input()\n\n# Output the result\nprint(min_operations_to_type_string(n, s))"}
{"solution": "def generate_move_commands(n, test_files):\n    examples = []\n    regular_tests = []\n    for name, type_ in test_files:\n        if type_ == '1':\n            examples.append(name)\n        else:\n            regular_tests.append(name)\n    \n    script = []\n    e = len(examples)\n    for i, example in enumerate(examples, start=1):\n        script.append(f\"move {example} {i}\")\n    for i, regular_test in enumerate(regular_tests, start=e+1):\n        script.append(f\"move {regular_test} {i}\")\n    \n    return len(script), script\n\n# Read input\nn = int(input().strip())\ntest_files = [input().strip().split() for _ in range(n)]\n\n# Generate and print the script\nnum_commands, script = generate_move_commands(n, test_files)\nprint(num_commands)\nfor command in script:\n    print(command)"}
{"solution": "def min_replacements_to_make_lucky(ticket):\n    first_half_sum = sum(int(digit) for digit in ticket[:3])\n    second_half_sum = sum(int(digit) for digit in ticket[3:])\n    \n    replacements = 0\n    while first_half_sum != second_half_sum:\n        replacements += 1\n        if first_half_sum > second_half_sum:\n            max_diff = max(int(digit) for digit in ticket[:3]) - min(int(digit) for digit in ticket[3:])\n            first_half_sum -= min(max_diff, 9)\n        else:\n            max_diff = max(int(digit) for digit in ticket[3:]) - min(int(digit) for digit in ticket[:3])\n            second_half_sum -= min(max_diff, 9)\n    \n    return replacements\n\n# Read input\nticket = input().strip()\n\n# Output the result\nprint(min_replacements_to_make_lucky(ticket))"}
{"solution": "import math\n\ndef min_traps_to_catch_mouse(m, x):\n    # Since GCD(x, m) = 1, x is a generator modulo m, meaning it will eventually reach all rooms.\n    # We need to find the number of distinct cycles in the sequence of rooms visited by the mouse.\n    # This is equivalent to finding the number of distinct sets of the form {i * x^k mod m | k >= 0} for each i.\n    # Since x is a generator, each such set will eventually include all rooms, so we only need to consider\n    # the number of distinct starting points that lead to unique sequences.\n    # Given GCD(x, m) = 1, the Euler's totient function \u03c6(m) gives the count of numbers less than m that are coprime to m.\n    # These numbers can serve as unique starting points, leading to \u03c6(m) distinct sequences.\n    # Therefore, the minimum number of traps needed is \u03c6(m).\n    \n    def euler_totient(n):\n        result = n\n        p = 2\n        while p * p <= n:\n            if n % p == 0:\n                while n % p == 0:\n                    n //= p\n                result -= result // p\n            p += 1\n        if n > 1:\n            result -= result // n\n        return result\n    \n    return euler_totient(m)\n\n# Read input\nm, x = map(int, input().split())\n\n# Output the result\nprint(min_traps_to_catch_mouse(m, x))"}
{"solution": "import sys\nfrom math import gcd\n\nMOD = 10**6 + 3\n\ndef mod_inverse(a, m):\n    return pow(a, m - 2, m)\n\ndef solve(n, k):\n    if k == 2:\n        return 1, 2**n\n    if 2**n < k:\n        return 1, 1\n    \n    # Calculate the probability of no shared birthdays\n    no_shared_birthdays = 1\n    for i in range(k - 1):\n        no_shared_birthdays = (no_shared_birthdays * (2**n - i)) % MOD\n    no_shared_birthdays = (no_shared_birthdays * mod_inverse(2**(n * (k - 1)), MOD)) % MOD\n    \n    # Calculate the probability of at least one shared birthday\n    shared_birthdays = (1 - no_shared_birthdays) % MOD\n    \n    # Find A and B such that shared_birthdays = A / B\n    B = 2**(n * k) % MOD\n    A = (shared_birthdays * B) % MOD\n    \n    # Ensure A and B are coprime\n    g = gcd(A, B)\n    A //= g\n    B //= g\n    \n    return A, B\n\n# Read input\nn, k = map(int, sys.stdin.readline().split())\n\n# Solve the problem\nA, B = solve(n, k)\n\n# Print the result\nprint(A, B)"}
{"solution": "def is_valid_journey(n, instructions):\n    current_position = 0  # Starting at the North Pole\n\n    for t, dir in instructions:\n        if dir == \"North\":\n            if current_position < t:\n                return \"NO\"\n            current_position -= t\n        elif dir == \"South\":\n            if current_position + t > 20000:\n                return \"NO\"\n            current_position += t\n        elif dir == \"West\" or dir == \"East\":\n            if current_position == 0 or current_position == 20000:\n                return \"NO\"\n\n    return \"YES\" if current_position == 0 else \"NO\"\n\n# Reading input\nn = int(input().strip())\ninstructions = [input().strip().split() for _ in range(n)]\ninstructions = [(int(t), dir) for t, dir in instructions]\n\n# Output the result\nprint(is_valid_journey(n, instructions))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef find_common_terms_count(a1, b1, a2, b2, L, R):\n    # Ensure a1 is the larger of the two common divisors\n    if a1 < a2:\n        a1, a2 = a2, a1\n        b1, b2 = b2, b1\n    \n    # Calculate the GCD of a1 and a2\n    g = gcd(a1, a2)\n    \n    # If the difference between b1 and b2 is not divisible by g, there are no common terms\n    if (b1 - b2) % g != 0:\n        return 0\n    \n    # Calculate the least common multiple of a1 and a2\n    lcm = a1 * a2 // g\n    \n    # Calculate the first common term\n    k = 0\n    while a1 * k + b1 < L:\n        k += 1\n    first_common_term = a1 * k + b1\n    \n    # If the first common term is greater than R, there are no common terms\n    if first_common_term > R:\n        return 0\n    \n    # Calculate the last common term within the range [L, R]\n    last_common_term = (R - b1) // a1 * a1 + b1\n    \n    # Calculate the number of common terms\n    num_common_terms = (last_common_term - first_common_term) // lcm + 1\n    \n    return num_common_terms\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Print the result\nprint(find_common_terms_count(a1, b1, a2, b2, L, R))"}
{"solution": "def max_min_pieces_per_plate(n, a, b):\n    max_x = min(a, b, n)\n    while max_x > 0:\n        if a // max_x + b // max_x >= n:\n            return max_x\n        max_x -= 1\n    return 0\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(max_min_pieces_per_plate(n, a, b))"}
{"solution": "def is_valid_flag(n, m, flag):\n    if n % 3 != 0 and m % 3 != 0:\n        return \"NO\"\n    \n    if n % 3 == 0:\n        stripe_height = n // 3\n        colors = [flag[i * stripe_height][0] for i in range(3)]\n        if len(set(colors)) != 3:\n            return \"NO\"\n        for i in range(3):\n            for j in range(stripe_height):\n                if flag[i * stripe_height + j] != colors[i] * m:\n                    return \"NO\"\n        return \"YES\"\n    \n    if m % 3 == 0:\n        stripe_width = m // 3\n        colors = [flag[0][i * stripe_width] for i in range(3)]\n        if len(set(colors)) != 3:\n            return \"NO\"\n        for i in range(3):\n            for j in range(n):\n                if flag[j][i * stripe_width:(i + 1) * stripe_width] != colors[i]:\n                    return \"NO\"\n        return \"YES\"\n    \n    return \"NO\"\n\nn, m = map(int, input().split())\nflag = [input() for _ in range(n)]\nprint(is_valid_flag(n, m, flag))"}
{"solution": "def find_coordinates_after_moves(n):\n    # Determine the layer of the spiral (k) where Ayrat is located\n    k = 0\n    while True:\n        if n < 6 * k:\n            break\n        n -= 6 * k\n        k += 1\n\n    # Determine the coordinates based on the layer and the remaining moves\n    if k == 0:\n        return 0, 0\n    else:\n        x, y = k - 1, 1\n        directions = [(1, 1), (1, -1), (-1, -1), (-1, 1), (-1, 0), (1, 0)]\n        for i in range(n):\n            dx, dy = directions[i // k]\n            x += dx\n            y += dy\n        return x, y\n\n# Read input\nn = int(input().strip())\n\n# Find and print the coordinates\nx, y = find_coordinates_after_moves(n)\nprint(x, y)"}
{"solution": "def can_break_shield(a, b, c):\n    for i in range(c // a + 1):\n        if (c - i * a) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Read input\na, b, c = map(int, input().split())\n\n# Output result\nprint(can_break_shield(a, b, c))"}
{"solution": "def tracks_coincide(n, L, kefa_distances, sasha_distances):\n    for i in range(n):\n        if all((kefa_distances[(i + j) % n] + L - kefa_distances[i]) % L == sasha_distances[j] for j in range(n)):\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output result\nprint(tracks_coincide(n, L, kefa_distances, sasha_distances))"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    if n == 1:\n        return 0\n    for length in range(n, 0, -1):\n        for start in range(n - length + 1):\n            substring = s[start:start + length]\n            if not is_palindrome(substring):\n                return length\n    return 0\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(longest_non_palindrome_substring(s))"}
{"solution": "def determine_round_status(n, ratings):\n    rated = False\n    unrated = False\n    \n    for i in range(n):\n        before, after = ratings[i]\n        if before != after:\n            return \"rated\"\n        if i > 0 and ratings[i][0] > ratings[i-1][0]:\n            unrated = True\n    \n    return \"unrated\" if unrated else \"maybe\"\n\n# Read input\nn = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Determine and print the round status\nprint(determine_round_status(n, ratings))"}
{"solution": "def nearest_zero_distances(n, arr):\n    distances = [float('inf')] * n\n    last_zero = -float('inf')\n    \n    for i in range(n):\n        if arr[i] == 0:\n            last_zero = i\n        distances[i] = min(distances[i], i - last_zero)\n    \n    last_zero = float('inf')\n    for i in range(n - 1, -1, -1):\n        if arr[i] == 0:\n            last_zero = i\n        distances[i] = min(distances[i], last_zero - i)\n    \n    return distances\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(*nearest_zero_distances(n, arr))"}
{"solution": "def count_distinct_cyclical_strings(n, s):\n    len_s = len(s)\n    if len_s > n:\n        return 0\n    if len_s == n:\n        return 1\n    if len_s == 1:\n        return 2 ** n\n    \n    # Calculate the number of distinct cyclical strings\n    # that can contain s as a substring.\n    # We need to consider the number of positions where s can start\n    # within a cyclical string of length n.\n    # For each position, we need to check if the substring formed\n    # by that position and the subsequent len_s characters contains s.\n    # Since we are looking for distinct cyclical strings, we need to\n    # consider all possible strings of length n and then check if they\n    # contain s after any cyclical shift.\n    \n    # The number of distinct cyclical strings of length n is 2^n.\n    # We need to subtract the number of strings that do not contain s\n    # as a substring. This is a complex problem, so we use a dynamic\n    # programming approach to solve it.\n    \n    # Initialize a DP array to store the number of valid strings\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case: empty string\n    \n    # Fill the DP array\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] * 2  # Each position can be either 0 or 1\n        if i >= len_s:\n            # Check if the last len_s characters can form s\n            if s in '01' * (i // len_s) + '01'[:i % len_s]:\n                dp[i] -= dp[i - len_s]\n    \n    return dp[n]\n\n# Read input\nn = int(input())\ns = input()\n\n# Print output\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import sys\nimport math\n\ndef find_min_angle_pair(vectors):\n    min_angle = float('inf')\n    min_pair = None\n    n = len(vectors)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            dot_product = vectors[i][0] * vectors[j][0] + vectors[i][1] * vectors[j][1]\n            magnitude_product = math.sqrt((vectors[i][0] ** 2 + vectors[i][1] ** 2) * (vectors[j][0] ** 2 + vectors[j][1] ** 2))\n            angle = math.acos(dot_product / magnitude_product)\n            if angle < min_angle:\n                min_angle = angle\n                min_pair = (i + 1, j + 1)\n    \n    return min_pair\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    vectors = []\n    for _ in range(n):\n        x, y = map(int, sys.stdin.readline().strip().split())\n        vectors.append((x, y))\n    \n    a, b = find_min_angle_pair(vectors)\n    print(a, b)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def minimal_time_to_post_office(d, k, a, b, t):\n    if d <= k:\n        return d * a\n    full_trips = d // k\n    remaining_distance = d % k\n    time_with_repairs = full_trips * (k * a + t)\n    if remaining_distance == 0:\n        return time_with_repairs - t\n    else:\n        time_with_repairs -= t\n        time_with_repairs += remaining_distance * a\n        time_without_repairs = (full_trips * k) * a + remaining_distance * b\n        return min(time_with_repairs, time_without_repairs)\n\n# Read input\nd, k, a, b, t = map(int, input().split())\n\n# Calculate and print the result\nprint(minimal_time_to_post_office(d, k, a, b, t))"}
{"solution": "def max_gcd_sequence(n, k):\n    if k > n or (n // k == 1 and n % k != 0):\n        return -1\n    sequence = []\n    for i in range(1, k):\n        sequence.append(i)\n        n -= i\n    sequence.append(n)\n    return ' '.join(map(str, sequence))\n\n# Read input\nn, k = map(int, input().split())\n\n# Output the result\nprint(max_gcd_sequence(n, k))"}
{"solution": "def count_pairs(n, m):\n    count = 0\n    for x in range(1, n + 1):\n        for y in range(1, m + 1):\n            if (x + y) % 5 == 0:\n                count += 1\n    return count\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))"}
{"solution": "def max_subarray_sum(arr):\n    max_ending_here = max_so_far = arr[0]\n    for x in arr[1:]:\n        max_ending_here = max(x, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max(max_so_far, 0)\n\ndef max_beauty_after_multiplication(n, x, a):\n    max_sum = max_subarray_sum(a)\n    if x > 0:\n        # If x is positive, we can multiply the subarray with the maximum sum by x\n        max_ending_here = max_so_far = 0\n        for i in range(n):\n            max_ending_here = max(a[i], max_ending_here + a[i])\n            max_so_far = max(max_so_far, max_ending_here)\n            max_sum = max(max_sum, max_so_far * x)\n    else:\n        # If x is non-positive, we need to find the subarray that will maximize the sum after multiplication\n        max_ending_here = max_so_far = 0\n        for i in range(n):\n            max_ending_here = min(a[i], max_ending_here + a[i])\n            max_so_far = min(max_so_far, max_ending_here)\n            max_sum = max(max_sum, max_subarray_sum(a[:i]) + max_subarray_sum(a[i:]) - max_so_far * x)\n    \n    return max_sum\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_beauty_after_multiplication(n, x, a))"}
{"solution": "def count_numbers_less_than_or_equal(x, n, m):\n    count = 0\n    for i in range(1, n + 1):\n        count += min(x // i, m)\n    return count\n\ndef find_kth_largest_number(n, m, k):\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_numbers_less_than_or_equal(mid, n, m) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\nn, m, k = map(int, input().split())\nprint(find_kth_largest_number(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    length = 1\n    count = 9\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n    index = k - 1\n    start = 10**(length - 1)\n    num = start + index // length\n    digit_index = index % length\n    return str(num)[digit_index]\n\n# Read input\nk = int(input().strip())\n\n# Output the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "def max_bourles_after_evening(n, m, r, s, b):\n    # Find the minimum price to buy shares\n    min_buy_price = min(s)\n    # Find the maximum price to sell shares\n    max_sell_price = max(b)\n    \n    # If the best selling price is higher than the best buying price,\n    # calculate the profit by buying as many shares as possible with the initial bourles\n    # and then selling them all at the best selling price.\n    if max_sell_price > min_buy_price:\n        shares_bought = r // min_buy_price\n        profit = shares_bought * (max_sell_price - min_buy_price)\n        return r + profit\n    else:\n        # If it's not profitable to trade, just return the initial amount of bourles.\n        return r\n\n# Read input\nn, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_bourles_after_evening(n, m, r, s, b))"}
{"solution": "def find_original_message(t):\n    n = len(t)\n    for i in range(1, n):\n        if t.startswith(t[i:]):\n            return \"YES\\n\" + t[:i]\n    return \"NO\"\n\n# Read input\nt = input().strip()\n\n# Output result\nprint(find_original_message(t))"}
{"solution": "def find_teams(n):\n    # Function to calculate the number of teams for a given number of games\n    def num_teams_for_games(games):\n        teams = 1\n        while teams * (teams - 1) // 2 < games:\n            teams += 1\n        return teams if teams * (teams - 1) // 2 == games else -1\n\n    # List to store all possible numbers of teams\n    possible_teams = []\n\n    # Check for all possible scenarios where the number of games could be n\n    for i in range(64):  # 64 is an arbitrary large number to ensure we cover all possibilities\n        # Calculate the number of teams after i stages of elimination\n        teams_after_elimination = 2 ** i\n        # Calculate the number of games played in the round robin stage\n        round_robin_games = n - i\n        # If the number of round robin games is valid, find the corresponding number of teams\n        if round_robin_games >= 0:\n            teams_for_round_robin = num_teams_for_games(round_robin_games)\n            # If the number of teams is valid and it matches the teams after elimination, add it to the list\n            if teams_for_round_robin != -1 and teams_for_round_robin == teams_after_elimination:\n                possible_teams.append(teams_after_elimination)\n            # If the number of teams is valid and it's a round robin with more than one team, add it to the list\n            elif teams_for_round_robin != -1 and teams_for_round_robin > teams_after_elimination:\n                possible_teams.append(teams_for_round_robin)\n\n    # If there are no possible numbers of teams, return -1\n    if not possible_teams:\n        return -1\n    # Return the list of possible numbers of teams in ascending order\n    return sorted(possible_teams)\n\n# Read input\nn = int(input())\n\n# Find and print all possible numbers of teams\nresult = find_teams(n)\nif result == -1:\n    print(result)\nelse:\n    for num in result:\n        print(num)"}
{"solution": "def max_antipalindromic_beauty(n, s, b):\n    # Sort the indices based on beauty values in descending order\n    sorted_indices = sorted(range(n), key=lambda i: b[i], reverse=True)\n    \n    # Initialize the result string t with all '?' to indicate unassigned positions\n    t = ['?'] * n\n    \n    # Assign characters to t based on the sorted indices to maximize beauty\n    for i in sorted_indices:\n        # Check if placing s[i] at the current position would break antipalindromic property\n        if t[i] == '?' and t[n - i - 1] == '?':\n            t[i] = s[i]\n            t[n - i - 1] = s[i]\n        else:\n            # If the position is already taken, try the next available character\n            for j in range(n):\n                if t[j] == '?' and t[n - j - 1] == '?':\n                    t[j] = s[i]\n                    t[n - j - 1] = s[i]\n                    break\n    \n    # Calculate the beauty of t\n    beauty = sum(b[i] for i in range(n) if s[i] == t[i])\n    \n    return beauty\n\n# Read input\nn = int(input())\ns = input().strip()\nb = list(map(int, input().split()))\n\n# Output the result\nprint(max_antipalindromic_beauty(n, s, b))"}
{"solution": "def can_weight(w, m):\n    while m > 0:\n        remainder = m % w\n        if remainder == 0 or remainder == 1:\n            m //= w\n        elif remainder == w - 1:\n            m = (m + 1) // w\n        else:\n            return \"NO\"\n    return \"YES\"\n\n# Read input\nw, m = map(int, input().split())\n\n# Output result\nprint(can_weight(w, m))"}
{"solution": "def find_sequence(n, k):\n    if k > n or k < 1:\n        return \"No\"\n    if k == 1:\n        return \"Yes\\n\" + str(n)\n    \n    # Start with the largest power of 2 that fits into n\n    power = 1\n    while (1 << power) <= n:\n        power += 1\n    power -= 1\n    \n    sequence = []\n    while k > 0:\n        if (1 << power) <= n:\n            n -= 1 << power\n            sequence.append(power)\n            k -= 1\n        else:\n            power -= 1\n    \n    # If n is not zero, it means we couldn't find a valid sequence\n    if n != 0:\n        return \"No\"\n    \n    # Sort the sequence to be lexicographically largest\n    sequence.sort(reverse=True)\n    \n    # Adjust the sequence to make the largest number as small as possible\n    # and still be lexicographically largest\n    for i in range(len(sequence)):\n        while sequence[i] > 0 and k < len(sequence):\n            sequence[i] -= 1\n            sequence.append(sequence[i])\n            k += 1\n    \n    return \"Yes\\n\" + \" \".join(map(str, sequence))\n\n# Read input\nn, k = map(int, input().split())\n\n# Output the result\nprint(find_sequence(n, k))"}
{"solution": "def full_glasses(n, t):\n    # Initialize a 2D list to represent the pyramid with empty glasses\n    pyramid = [[0] * (i + 1) for i in range(n)]\n    \n    for second in range(t):\n        overflow = 0\n        for level in range(n):\n            for glass in range(level + 1):\n                # Calculate the amount of champagne to add to this glass\n                to_add = 1 - pyramid[level][glass] if pyramid[level][glass] < 1 else 0\n                pyramid[level][glass] += to_add\n                overflow += max(0, pyramid[level][glass] - 1)\n                pyramid[level][glass] = min(1, pyramid[level][glass])\n                \n                # Distribute overflow to glasses below\n                if level < n - 1:\n                    pyramid[level + 1][glass] += overflow / 2\n                    pyramid[level + 1][glass + 1] += overflow / 2\n                overflow = 0\n    \n    # Count the number of full glasses\n    full_count = sum(row.count(1) for row in pyramid)\n    return full_count\n\n# Read input\nn, t = map(int, input().split())\n\n# Output the result\nprint(full_glasses(n, t))"}
{"solution": "def find_rectangle_area(n, vertices):\n    if n < 2:\n        return -1\n    elif n == 2:\n        # Check if the two points are diagonally opposite\n        x_diff = abs(vertices[0][0] - vertices[1][0])\n        y_diff = abs(vertices[0][1] - vertices[1][1])\n        if x_diff == 0 or y_diff == 0:\n            return -1\n        return x_diff * y_diff\n    elif n == 3:\n        # Find the two points that are on the same axis\n        x_coords = sorted(set(v[0] for v in vertices))\n        y_coords = sorted(set(v[1] for v in vertices))\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            return (x_coords[1] - x_coords[0]) * (y_coords[1] - y_coords[0])\n        else:\n            return -1\n    else:  # n == 4\n        x_coords = sorted(set(v[0] for v in vertices))\n        y_coords = sorted(set(v[1] for v in vertices))\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            return (x_coords[1] - x_coords[0]) * (y_coords[1] - y_coords[0])\n        else:\n            return -1\n\n# Read input\nn = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Find and print the area\nprint(find_rectangle_area(n, vertices))"}
{"solution": "def min_bars_needed(n, a, b):\n    # Calculate the total length needed for two doors\n    total_length_needed = 4 * a + 2 * b\n    # Calculate the number of full bars needed\n    full_bars_needed = total_length_needed // n\n    # Check if there's any remainder that requires an additional bar\n    if total_length_needed % n != 0:\n        full_bars_needed += 1\n    return full_bars_needed\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\n\n# Output the result\nprint(min_bars_needed(n, a, b))"}
{"solution": "def can_sort_array(n, a, swaps):\n    i = 0\n    while i < n - 1:\n        if swaps[i] == '1':\n            j = i\n            while j < n - 1 and swaps[j] == '1':\n                j += 1\n            a[i:j+1] = sorted(a[i:j+1])\n            i = j\n        i += 1\n    return \"YES\" if a == sorted(a) else \"NO\"\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\nswaps = input()\n\n# Output result\nprint(can_sort_array(n, a, swaps))"}
{"solution": "def calculate_wait_time(n, s):\n    # Calculate the number of full cycles the flight attendants have completed\n    full_cycles = (n - 1) // 4\n    \n    # Calculate the time spent on full cycles\n    time_spent = full_cycles * 12\n    \n    # Calculate the remaining rows after full cycles\n    remaining_rows = (n - 1) % 4\n    \n    # Add the time spent on the remaining rows\n    if remaining_rows == 1:\n        time_spent += 6\n    elif remaining_rows == 2:\n        time_spent += 7\n    elif remaining_rows == 3:\n        time_spent += 10\n    \n    # Add the time spent on serving the specific seat\n    seat_order = ['f', 'e', 'd', 'c', 'b', 'a']\n    time_spent += seat_order.index(s) + 1\n    \n    return time_spent\n\n# Read input\nimport sys\ninput = sys.stdin.read().strip()\nn = int(input[:-1])\ns = input[-1]\n\n# Calculate and print the result\nprint(calculate_wait_time(n, s))"}
{"solution": "def convert_to_base_10(digits, base):\n    value = 0\n    for digit in digits:\n        value = value * base + digit\n    return value\n\ndef compare_numbers():\n    # Read input for X\n    n, b_x = map(int, input().split())\n    x_digits = list(map(int, input().split()))\n    \n    # Read input for Y\n    m, b_y = map(int, input().split())\n    y_digits = list(map(int, input().split()))\n    \n    # Convert both numbers to base 10\n    x_value = convert_to_base_10(x_digits, b_x)\n    y_value = convert_to_base_10(y_digits, b_y)\n    \n    # Compare the values\n    if x_value < y_value:\n        print('<')\n    elif x_value > y_value:\n        print('>')\n    else:\n        print('=')\n\ncompare_numbers()"}
{"solution": "def game_winner(n, a):\n    if n == 1:\n        return \"BitLGM\" if a[0] else \"BitAryo\"\n    elif n == 2:\n        dp = [[False] * 301 for _ in range(301)]\n        for i in range(301):\n            for j in range(301):\n                if not dp[i][j]:\n                    for k in range(1, 301 - i):\n                        dp[i + k][j] = True\n                    for k in range(1, 301 - j):\n                        dp[i][j + k] = True\n                    for k in range(1, 301 - min(i, j)):\n                        dp[i + k][j + k] = True\n        return \"BitLGM\" if dp[a[0]][a[1]] else \"BitAryo\"\n    else:  # n == 3\n        return \"BitLGM\" if a[0] ^ a[1] ^ a[2] else \"BitAryo\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the winner\nprint(game_winner(n, a))"}
{"solution": "from math import gcd\nfrom functools import reduce\n\ndef prime_factors(n):\n    factors = {}\n    for i in range(2, int(n**0.5) + 1):\n        while n % i == 0:\n            factors[i] = factors.get(i, 0) + 1\n            n //= i\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef product(numbers):\n    result = 1\n    for number in numbers:\n        result *= number\n    return result\n\ndef count_ways(n, k, cards):\n    prime_k = prime_factors(k)\n    left = [0] * n\n    right = [0] * n\n    current = {}\n    \n    for i in range(n):\n        for factor in prime_k:\n            if cards[i] % factor == 0:\n                count = 0\n                temp = cards[i]\n                while temp % factor == 0:\n                    temp //= factor\n                    count += 1\n                current[factor] = current.get(factor, 0) + count\n        left[i] = dict(current)\n    \n    current = {}\n    for i in range(n-1, -1, -1):\n        for factor in prime_k:\n            if cards[i] % factor == 0:\n                count = 0\n                temp = cards[i]\n                while temp % factor == 0:\n                    temp //= factor\n                    count += 1\n                current[factor] = current.get(factor, 0) + count\n        right[i] = dict(current)\n    \n    ways = 0\n    for i in range(n):\n        for j in range(i, n):\n            combined = {factor: left[i-1][factor] + right[j+1][factor] for factor in prime_k} if i > 0 and j < n-1 else (left[i-1] if i > 0 else right[j+1] if j < n-1 else {})\n            if all(combined.get(factor, 0) >= prime_k[factor] for factor in prime_k):\n                ways += 1\n    return ways\n\nn, k = map(int, input().split())\ncards = list(map(int, input().split()))\nprint(count_ways(n, k, cards))"}
{"solution": "def can_distribute_balloons(n, k, s):\n    color_count = {}\n    for color in s:\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n    \n    for count in color_count.values():\n        if count > k:\n            return \"NO\"\n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ns = input()\n\n# Output result\nprint(can_distribute_balloons(n, k, s))"}
{"solution": "def nearest_minimum_distance(n, arr):\n    min_val = min(arr)\n    min_indices = [i for i, val in enumerate(arr) if val == min_val]\n    return min(min_indices[i+1] - min_indices[i] for i in range(len(min_indices) - 1)) + 1\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output the result\nprint(nearest_minimum_distance(n, arr))"}
{"solution": "from math import gcd\nfrom sys import stdin\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef main():\n    t, w, b = map(int, stdin.readline().split())\n    min_step = min(w, b)\n    lcm_wb = lcm(w, b)\n    tie_count = (t // lcm_wb) * min_step + min(min_step - 1, t % lcm_wb)\n    g = gcd(tie_count, t)\n    print(f\"{tie_count // g}/{t // g}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def nauuo_votes(x, y, z):\n    if z == 0:\n        return '+' if x > y else '-' if y > x else '0'\n    else:\n        if (x + z > y) and (y + z > x):\n            return '?'\n        else:\n            return '+' if x + z > y else '-' if y + z > x else '0'\n\n# Read input\nx, y, z = map(int, input().split())\n\n# Print output\nprint(nauuo_votes(x, y, z))"}
{"solution": "def min_subsegment_change(n, operations, x, y):\n    # Calculate prefix sums for horizontal and vertical movements\n    prefix_x = [0] * (n + 1)\n    prefix_y = [0] * (n + 1)\n    \n    for i, op in enumerate(operations):\n        prefix_x[i + 1] = prefix_x[i]\n        prefix_y[i + 1] = prefix_y[i]\n        if op == 'U':\n            prefix_y[i + 1] += 1\n        elif op == 'D':\n            prefix_y[i + 1] -= 1\n        elif op == 'L':\n            prefix_x[i + 1] -= 1\n        elif op == 'R':\n            prefix_x[i + 1] += 1\n    \n    # Check if the final position is reachable\n    if prefix_x[n] == x and prefix_y[n] == y:\n        return 0\n    \n    # Function to check if a subsegment can be changed to reach (x, y)\n    def can_reach(length):\n        for start in range(n - length + 1):\n            end = start + length\n            current_x = prefix_x[start] + (prefix_x[n] - prefix_x[end])\n            current_y = prefix_y[start] + (prefix_y[n] - prefix_y[end])\n            dx = abs(x - current_x)\n            dy = abs(y - current_y)\n            if dx + dy <= length and (length - (dx + dy)) % 2 == 0:\n                return True\n        return False\n    \n    # Binary search to find the minimum length of the subsegment to change\n    left, right = 0, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_reach(mid):\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left if can_reach(left) else -1\n\n# Read input\nn = int(input())\noperations = input().strip()\nx, y = map(int, input().split())\n\n# Output the result\nprint(min_subsegment_change(n, operations, x, y))"}
{"solution": "def calculate_prefix_balance(n, x, s):\n    balance = s.count('0') - s.count('1')\n    if balance == 0:\n        if x == 0:\n            return -1\n        elif x == balance:\n            return 1\n        else:\n            return 0\n    elif balance > 0:\n        if x < 0:\n            return 0\n        elif x % balance == 0:\n            return x // balance\n        else:\n            return 0\n    else:\n        if x > 0:\n            return 0\n        elif x % balance == 0:\n            return x // balance\n        else:\n            return 0\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        n = int(data[index])\n        x = int(data[index + 1])\n        s = data[index + 2]\n        index += 3\n        \n        result = calculate_prefix_balance(n, x, s)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_digits_to_remove(n, k):\n    n_str = str(n)\n    zeros_needed = k\n    zeros_found = 0\n    digits_to_remove = 0\n\n    # Count trailing zeros first\n    for digit in reversed(n_str):\n        if digit == '0':\n            zeros_found += 1\n            if zeros_found == zeros_needed:\n                break\n        else:\n            digits_to_remove += 1\n\n    # If we don't have enough zeros, we need to remove all digits except for the last one\n    if zeros_found < zeros_needed:\n        digits_to_remove = len(n_str) - 1\n\n    return digits_to_remove\n\n# Read input\nn, k = map(int, input().split())\n\n# Output the result\nprint(min_digits_to_remove(n, k))"}
{"solution": "def solve(n, m, k, x, y):\n    if n == 1:\n        cycle_length = m\n        cycles = k // cycle_length\n        remainder = k % cycle_length\n        max_questions = cycles + (1 if remainder > 0 else 0)\n        min_questions = cycles\n        sergei_questions = cycles + (1 if y <= remainder else 0)\n    else:\n        cycle_length = 2 * (n * m) - 2 * m\n        cycles = k // cycle_length\n        remainder = k % cycle_length\n        max_questions = cycles * 2\n        if remainder > n * m:\n            max_questions += 1\n        if remainder > 0:\n            max_questions += 1\n        min_questions = cycles\n        if remainder > m:\n            min_questions += 1\n        sergei_questions = cycles\n        if x != n and x != 1:\n            sergei_questions *= 2\n        if remainder > (x - 1) * m + y:\n            sergei_questions += 1\n        if x != n and remainder > (2 * n - x - 1) * m + y:\n            sergei_questions += 1\n    return max_questions, min_questions, sergei_questions\n\n# Read input\nn, m, k, x, y = map(int, input().split())\n\n# Solve and print the result\nmax_questions, min_questions, sergei_questions = solve(n, m, k, x, y)\nprint(max_questions, min_questions, sergei_questions)"}
{"solution": "from collections import Counter\n\ndef calculate_beauty(ribbon, turns):\n    counter = Counter(ribbon)\n    most_common_count = counter.most_common(1)[0][1]\n    if most_common_count - turns >= 0:\n        return min(most_common_count, len(ribbon)) if most_common_count - turns == 0 else most_common_count - turns\n    else:\n        return len(ribbon)\n\ndef determine_winner(n, ribbons):\n    beauties = [calculate_beauty(ribbon, n) for ribbon in ribbons]\n    max_beauty = max(beauties)\n    winners = [i for i, beauty in enumerate(beauties) if beauty == max_beauty]\n    \n    if len(winners) > 1:\n        return \"Draw\"\n    else:\n        return [\"Kuro\", \"Shiro\", \"Katie\"][winners[0]]\n\n# Read input\nn = int(input())\nribbons = [input().strip() for _ in range(3)]\n\n# Determine the winner\nwinner = determine_winner(n, ribbons)\nprint(winner)"}
{"solution": "def calculate_days_to_finish_book(c, v_0, v_1, a, l):\n    days = 0\n    read_so_far = 0\n    current_speed = v_0\n    \n    while read_so_far < c:\n        if days > 0:\n            read_so_far -= l\n        read_so_far += current_speed\n        days += 1\n        current_speed = min(current_speed + a, v_1)\n    \n    return days\n\n# Read input\nc, v_0, v_1, a, l = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_days_to_finish_book(c, v_0, v_1, a, l))"}
{"solution": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef find_prime_sum(n):\n    if is_prime(n):\n        return [n]\n    for i in range(2, n):\n        if is_prime(i) and is_prime(n - i):\n            return [i, n - i]\n    for i in range(2, n):\n        if is_prime(i):\n            for j in range(2, n - i):\n                if is_prime(j) and is_prime(n - i - j):\n                    return [i, j, n - i - j]\n    return []\n\nn = int(input())\nprimes = find_prime_sum(n)\nprint(len(primes))\nprint(*primes)"}
{"solution": "def can_wipe_out_all_walls(n, m, field):\n    row_walls = [0] * n\n    col_walls = [0] * m\n    \n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                row_walls[i] += 1\n                col_walls[j] += 1\n    \n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and row_walls[i] + col_walls[j] - 1 == sum(row_walls):\n                return \"YES\", i + 1, j + 1\n            elif field[i][j] == '.' and row_walls[i] + col_walls[j] == sum(row_walls):\n                return \"YES\", i + 1, j + 1\n    \n    return \"NO\", None, None\n\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\nresult, x, y = can_wipe_out_all_walls(n, m, field)\nprint(result)\nif result == \"YES\":\n    print(x, y)"}
{"solution": "def minimal_cost_to_satisfy_delegations(n, m, a, b):\n    # Calculate the remainder when n is divided by m\n    remainder = n % m\n    \n    # If the remainder is 0, no action is needed\n    if remainder == 0:\n        return 0\n    \n    # Calculate the cost to build enough boxes to make n divisible by m\n    build_cost = (m - remainder) * a\n    \n    # Calculate the cost to demolish enough boxes to make n divisible by m\n    demolish_cost = remainder * b\n    \n    # Return the minimum of the two costs\n    return min(build_cost, demolish_cost)\n\n# Read input\nn, m, a, b = map(int, input().split())\n\n# Output the result\nprint(minimal_cost_to_satisfy_delegations(n, m, a, b))"}
{"solution": "def max_odd_sum_subsequence(n, a):\n    max_sum = float('-inf')\n    max_odd_negative = float('-inf')\n    current_sum = 0\n\n    for num in a:\n        if num % 2 == 0:\n            current_sum += num if num > 0 else 0\n        else:\n            if current_sum % 2 == 0:\n                current_sum += num if num > 0 else 0\n            else:\n                if current_sum + num > max_sum:\n                    max_sum = current_sum + num\n                if num < 0 and num > max_odd_negative:\n                    max_odd_negative = num\n\n    if current_sum % 2 != 0:\n        return max(current_sum, max_sum)\n    else:\n        return max(current_sum - max_odd_negative, max_sum)\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_odd_sum_subsequence(n, a))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_playlists(n, T, songs):\n    dp = [[[0 for _ in range(4)] for _ in range(T+1)] for _ in range(1 << n)]\n    for i in range(n):\n        if songs[i][0] <= T:\n            dp[1 << i][songs[i][0]][songs[i][1]] += 1\n\n    for mask in range(1 << n):\n        for i in range(n):\n            if mask & (1 << i):\n                continue\n            for t in range(T + 1):\n                for g in range(1, 4):\n                    if t + songs[i][0] <= T and g != songs[i][1]:\n                        dp[mask | (1 << i)][t + songs[i][0]][songs[i][1]] += dp[mask][t][g]\n                        dp[mask | (1 << i)][t + songs[i][0]][songs[i][1]] %= MOD\n\n    result = 0\n    for mask in range(1 << n):\n        for g in range(1, 4):\n            result += dp[mask][T][g]\n            result %= MOD\n\n    return result\n\nn, T = map(int, input().split())\nsongs = [list(map(int, input().split())) for _ in range(n)]\n\nprint(count_playlists(n, T, songs))"}
{"solution": "MOD = 10**9 + 7\n\ndef modinv(a, m):\n    return pow(a, m - 2, m)\n\ndef expected_length(m):\n    # Calculate the expected length using the formula derived from the problem statement\n    expected = 0\n    for i in range(1, m + 1):\n        expected += modinv(i, MOD)\n        expected %= MOD\n    return expected\n\n# Read input\nm = int(input())\n\n# Calculate and print the result\nprint(expected_length(m))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_good_pairs(l, r, x, y):\n    if y % x != 0:\n        return 0\n    \n    count = 0\n    for a in range(x, int(y**0.5)+1, x):\n        if y % a == 0:\n            b = y // a\n            if l <= a <= r and l <= b <= r and gcd(a, b) == x:\n                count += 1\n                if a != b:\n                    count += 1\n    return count\n\n# Read input\nl, r, x, y = map(int, input().split())\n\n# Output the result\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef find_smallest_k(a, b):\n    if a > b:\n        a, b = b, a\n    min_lcm = float('inf')\n    best_k = 0\n    for d in range(1, int(b**0.5) + 1):\n        if b % d == 0:\n            k = (d - a % d) % d\n            lcm = (a + k) * (b + k) // gcd(a + k, b + k)\n            if lcm < min_lcm:\n                min_lcm = lcm\n                best_k = k\n            k = (b // d - a % (b // d)) % (b // d)\n            lcm = (a + k) * (b + k) // gcd(a + k, b + k)\n            if lcm < min_lcm:\n                min_lcm = lcm\n                best_k = k\n    return best_k\n\na, b = map(int, input().split())\nprint(find_smallest_k(a, b))"}
{"solution": "def minimal_additional_marks(n, k, marks):\n    current_sum = sum(marks)\n    target_sum = k * (n + 1) - current_sum\n    if target_sum <= 0:\n        return 0\n    return target_sum\n\n# Read input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(minimal_additional_marks(n, k, marks))"}
{"solution": "def find_divisor(n, arr):\n    for d in range(-1000, 1001):\n        if d == 0:\n            continue\n        positive_count = sum(1 for a in arr if a / d > 0)\n        if positive_count >= (n + 1) // 2:\n            return d\n    return 0\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(find_divisor(n, arr))"}
{"solution": "def count_pairs_with_max_nines(n):\n    def count_nines(x):\n        return (x % 10 == 9) + (x // 10 > 0)\n\n    max_nines = 0\n    count = 0\n\n    for i in range(1, n + 1):\n        total_cost = i + (i + 1)\n        if total_cost > 2 * n:\n            break\n        nines = count_nines(total_cost)\n        if nines > max_nines:\n            max_nines = nines\n            count = 1\n        elif nines == max_nines:\n            count += 1\n\n    return count\n\nn = int(input().strip())\nprint(count_pairs_with_max_nines(n))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef find_common_segments(a1, b1, a2, b2):\n    segments1 = a1 * b1\n    segments2 = a2 * b2\n    \n    if segments1 == segments2:\n        return 0, a1, b1, a2, b2\n    \n    # Using BFS to find the minimum number of operations\n    from collections import deque\n    queue = deque([(segments1, segments2, 0, a1, b1, a2, b2)])\n    visited = set()\n    \n    while queue:\n        seg1, seg2, minutes, a1, b1, a2, b2 = queue.popleft()\n        if (seg1, seg2) in visited:\n            continue\n        visited.add((seg1, seg2))\n        \n        if seg1 == seg2:\n            return minutes, a1, b1, a2, b2\n        \n        # Try to break the first bar\n        if seg1 % 2 == 0:\n            new_seg1 = seg1 // 2\n            new_a1, new_b1 = a1, b1 // 2 if a1 == 1 else a1 // 2, b1\n            queue.append((new_seg1, seg2, minutes + 1, new_a1, new_b1, a2, b2))\n        if seg1 % 3 == 0:\n            new_seg1 = seg1 // 3 * 2\n            new_a1, new_b1 = a1, b1 // 3 * 2 if a1 == 1 else a1 // 3 * 2, b1\n            queue.append((new_seg1, seg2, minutes + 1, new_a1, new_b1, a2, b2))\n        \n        # Try to break the second bar\n        if seg2 % 2 == 0:\n            new_seg2 = seg2 // 2\n            new_a2, new_b2 = a2, b2 // 2 if a2 == 1 else a2 // 2, b2\n            queue.append((seg1, new_seg2, minutes + 1, a1, b1, new_a2, new_b2))\n        if seg2 % 3 == 0:\n            new_seg2 = seg2 // 3 * 2\n            new_a2, new_b2 = a2, b2 // 3 * 2 if a2 == 1 else a2 // 3 * 2, b2\n            queue.append((seg1, new_seg2, minutes + 1, a1, b1, new_a2, new_b2))\n    \n    return -1, 0, 0, 0, 0\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\nminutes, a1_final, b1_final, a2_final, b2_final = find_common_segments(a1, b1, a2, b2)\n\nif minutes == -1:\n    print(-1)\nelse:\n    print(minutes)\n    print(a1_final, b1_final)\n    print(a2_final, b2_final)"}
{"solution": "def determine_winner(x_p, y_p, x_v, y_v):\n    # Polycarp can win if he can reach the diagonal (x == y) or (0, 0) first\n    if x_p + y_p <= max(x_v, y_v):\n        return \"Polycarp\"\n    # Vasiliy can win if he can reach (0, 0) before Polycarp\n    if x_v == y_v or min(x_v, y_v) == 0:\n        return \"Vasiliy\"\n    # If neither can immediately win, check who can force the win\n    if x_p <= x_v and y_p <= y_v:\n        return \"Polycarp\"\n    if x_p >= x_v and y_p >= y_v:\n        return \"Vasiliy\"\n    # If both players are on different sides of the diagonal, the one closer to the diagonal wins\n    if x_p + y_p <= x_v + y_v:\n        return \"Polycarp\"\n    return \"Vasiliy\"\n\n# Read input\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Determine and print the winner\nprint(determine_winner(x_p, y_p, x_v, y_v))"}
{"solution": "def number_of_columns(m, d):\n    # Days in each month\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    # Calculate the number of days in the given month\n    days = days_in_month[m - 1]\n    # Calculate the number of columns needed\n    columns = 1\n    current_day = d\n    while days > 0:\n        if current_day == 8:\n            current_day = 1\n            columns += 1\n        current_day += 1\n        days -= 1\n    return columns\n\n# Read input\nm, d = map(int, input().split())\n\n# Print output\nprint(number_of_columns(m, d))"}
{"solution": "def count_years_with_one_zero(a, b):\n    def has_exactly_one_zero(n):\n        binary_str = bin(n)[2:]\n        return binary_str.count('0') == 1\n\n    count = 0\n    for year in range(a, b + 1):\n        if has_exactly_one_zero(year):\n            count += 1\n    return count\n\n# Read input\na, b = map(int, input().split())\n\n# Output the result\nprint(count_years_with_one_zero(a, b))"}
{"solution": "def minimal_layers(N):\n    # Initialize the number of layers to 0\n    layers = 0\n    \n    # Loop through each possible starting point of the segments\n    for start in range(N):\n        # Calculate the number of segments starting at 'start'\n        segments_starting_here = N - start\n        \n        # Each starting point requires a new layer for its segments\n        layers += segments_starting_here\n    \n    return layers\n\n# Read input\nN = int(input().strip())\n\n# Output the result\nprint(minimal_layers(N))"}
{"solution": "from math import factorial\nfrom itertools import combinations\n\ndef count_ways(n, k, S, cubes):\n    ways = 0\n    for r in range(1, n + 1):\n        for chosen_cubes in combinations(cubes, r):\n            for marks in range(k + 1):\n                for marked_cubes in combinations(chosen_cubes, marks):\n                    current_sum = sum(factorial(cube) if cube in marked_cubes else cube for cube in chosen_cubes)\n                    if current_sum == S:\n                        ways += 1\n    return ways\n\n# Read input\nn, k, S = map(int, input().split())\ncubes = list(map(int, input().split()))\n\n# Output the result\nprint(count_ways(n, k, S, cubes))"}
{"solution": "def can_achieve_array(n, k, a):\n    max_a = max(a)\n    for i in range(n):\n        while a[i] > 0:\n            highest_power = 0\n            while k**highest_power <= a[i]:\n                highest_power += 1\n            highest_power -= 1\n            a[i] -= k**highest_power\n            for j in range(n):\n                if j != i and a[j] >= k**highest_power:\n                    return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    for _ in range(T):\n        n = int(data[index])\n        k = int(data[index + 1])\n        a = list(map(int, data[index + 2: index + 2 + n]))\n        index += 2 + n\n        results.append(can_achieve_array(n, k, a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_divisors(n):\n    divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        count = 0\n        while n % i == 0:\n            n //= i\n            count += 1\n        divisors *= (count + 1)\n    if n > 1:\n        divisors *= 2\n    return divisors\n\ndef main():\n    a, b, c = map(int, input().split())\n    mod = 1073741824  # 2^30\n    sum_divisors = 0\n\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                sum_divisors += count_divisors(i * j * k)\n                sum_divisors %= mod\n\n    print(sum_divisors)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    neighbors = []\n    empty_pos = state.index('X')\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    for dx, dy in directions:\n        new_pos = empty_pos + dx + 2 * dy\n        if 0 <= new_pos < 4:\n            new_state = list(state)\n            new_state[empty_pos], new_state[new_pos] = new_state[new_pos], new_state[empty_pos]\n            neighbors.append(''.join(new_state))\n    return neighbors\n\ndef bfs(start, target):\n    queue = deque([(start, 0)])\n    visited = set()\n    visited.add(start)\n    while queue:\n        current, steps = queue.popleft()\n        if current == target:\n            return True\n        for neighbor in get_neighbors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, steps + 1))\n    return False\n\ndef main():\n    bessie_puzzle = ''.join(input().strip() for _ in range(2))\n    elsie_puzzle = ''.join(input().strip() for _ in range(2))\n    \n    if bfs(bessie_puzzle, elsie_puzzle):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_decimal_from_base_n(n, k):\n    k_digits = [int(digit) for digit in str(k)]\n    result = 0\n    power = 1\n    for digit in reversed(k_digits):\n        result += digit * power\n        power *= n\n    return result\n\n# Read input\nn = int(input().strip())\nk = int(input().strip())\n\n# Output the result\nprint(min_decimal_from_base_n(n, k))"}
{"solution": "def is_unimodal(n, arr):\n    increasing = decreasing = True\n    for i in range(1, n):\n        if arr[i] > arr[i - 1]:\n            if not increasing:\n                return \"NO\"\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n        else:\n            if decreasing:\n                increasing = False\n            decreasing = False\n    return \"YES\"\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(is_unimodal(n, arr))"}
{"solution": "def max_value_in_at_least_k_paths(n, k):\n    # Function to generate the path for a given number x\n    def path(x):\n        p = []\n        while x > 1:\n            p.append(x)\n            if x % 2 == 0:\n                x //= 2\n            else:\n                x -= 1\n        p.append(1)\n        return p\n\n    # Dictionary to count occurrences of each number in paths\n    occurrences = {}\n    for x in range(1, n + 1):\n        p = path(x)\n        for num in p:\n            if num in occurrences:\n                occurrences[num] += 1\n            else:\n                occurrences[num] = 1\n\n    # Find the maximum value that occurs in at least k paths\n    max_value = 1\n    for num, count in occurrences.items():\n        if count >= k:\n            max_value = max(max_value, num)\n\n    return max_value\n\n# Read input\nn, k = map(int, input().split())\n\n# Output the result\nprint(max_value_in_at_least_k_paths(n, k))"}
{"solution": "def will_fall_into_pocket(n, m, x, y, vx, vy):\n    # If the ball is moving vertically and is already on a vertical edge\n    if vx == 0:\n        if x == 0 or x == n:\n            return f\"{x} {0 if y == 0 else m}\"\n        else:\n            return -1\n    \n    # If the ball is moving horizontally and is already on a horizontal edge\n    if vy == 0:\n        if y == 0 or y == m:\n            return f\"{0 if x == 0 else n} {y}\"\n        else:\n            return -1\n    \n    # If the ball is moving at a 45-degree angle\n    if abs(vx) == abs(vy):\n        # Calculate the number of bounces needed to reach a pocket\n        bounces_x = (n - x) // vx if vx > 0 else x // -vx\n        bounces_y = (m - y) // vy if vy > 0 else y // -vy\n        \n        # If the number of bounces is the same for both axes, the ball will fall into a pocket\n        if bounces_x == bounces_y:\n            return f\"{0 if vx < 0 else n} {0 if vy < 0 else m}\"\n        else:\n            return -1\n    \n    return -1\n\n# Read input\nn, m, x, y, vx, vy = map(int, input().split())\n\n# Output the result\nprint(will_fall_into_pocket(n, m, x, y, vx, vy))"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    # Check all possible orientations for the paintings\n    for i in range(2):\n        for j in range(2):\n            # Rotate paintings if necessary\n            (a2, b2), (a3, b3) = (b2, a2), (b3, a3)\n            # Check if paintings can fit side by side\n            if a2 + a3 <= a1 and max(b2, b3) <= b1:\n                return \"YES\"\n            # Check if paintings can fit one above the other\n            if max(a2, a3) <= a1 and b2 + b3 <= b1:\n                return \"YES\"\n    return \"NO\"\n\n# Read input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\n# Output result\nprint(can_place_paintings(a1, b1, a2, b2, a3, b3))"}
{"solution": "def count_written_numbers(b_1, q, l, m, bad_integers):\n    if abs(b_1) > l:\n        return 0\n    if b_1 == 0:\n        return \"inf\" if 0 not in bad_integers else 0\n    if q == 0:\n        if 0 in bad_integers:\n            return 1 if b_1 not in bad_integers else 0\n        else:\n            return \"inf\"\n    if q == 1:\n        return \"inf\" if b_1 not in bad_integers else 0\n    if q == -1:\n        return \"inf\" if b_1 not in bad_integers and -b_1 not in bad_integers else 0\n\n    written_count = 0\n    current_term = b_1\n    while abs(current_term) <= l:\n        if current_term not in bad_integers:\n            written_count += 1\n        current_term *= q\n\n    return written_count\n\n# Read input\nb_1, q, l, m = map(int, input().split())\nbad_integers = set(map(int, input().split()))\n\n# Calculate and print the result\nresult = count_written_numbers(b_1, q, l, m, bad_integers)\nprint(result if result != \"inf\" else \"inf\")"}
{"solution": "def find_smallest_frame(n, m, screen):\n    white_pixels = []\n    for i in range(n):\n        for j in range(m):\n            if screen[i][j] == 'w':\n                white_pixels.append((i, j))\n\n    min_x = min(white_pixels, key=lambda x: x[0])[0]\n    max_x = max(white_pixels, key=lambda x: x[0])[0]\n    min_y = min(white_pixels, key=lambda x: x[1])[1]\n    max_y = max(white_pixels, key=lambda x: x[1])[1]\n\n    width = max_y - min_y + 1\n    height = max_x - min_x + 1\n\n    if width != height and width - height != 2 and height - width != 2:\n        return -1\n\n    if width == height:\n        size = width\n    else:\n        size = max(width, height)\n\n    for i in range(min_x, min_x + size):\n        for j in range(min_y, min_y + size):\n            if screen[i][j] == '.':\n                if i == min_x or i == min_x + size - 1 or j == min_y or j == min_y + size - 1:\n                    screen[i] = screen[i][:j] + '+' + screen[i][j+1:]\n\n    return '\\n'.join(screen)\n\n# Read input\nn, m = map(int, input().split())\nscreen = [input() for _ in range(n)]\n\n# Find and print the smallest frame\nresult = find_smallest_frame(n, m, screen)\nprint(result)"}
{"solution": "def can_spend_exactly(n, a, b):\n    for x in range(n // a + 1):\n        if (n - x * a) % b == 0:\n            y = (n - x * a) // b\n            return \"YES\", x, y\n    return \"NO\", 0, 0\n\nn = int(input())\na = int(input())\nb = int(input())\n\nresult, x, y = can_spend_exactly(n, a, b)\nprint(result)\nif result == \"YES\":\n    print(x, y)"}
{"solution": "def number_to_words(n):\n    under_20 = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \n                \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    \n    if n < 20:\n        return under_20[n]\n    elif n < 100:\n        if n % 10 == 0:\n            return tens[n // 10]\n        else:\n            return tens[n // 10] + \"-\" + under_20[n % 10]\n\n# Read input\nscore = int(input().strip())\n\n# Output the result\nprint(number_to_words(score))"}
{"solution": "def max_eraseable_elements(n, arr):\n    if n <= 2:\n        return 0\n    max_erase = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            diff = arr[j] - arr[i]\n            count = 0\n            last = arr[j]\n            for k in range(j + 1, n):\n                if arr[k] - last == diff:\n                    count += 1\n                    last = arr[k]\n            max_erase = max(max_erase, count)\n    return max_erase\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(max_eraseable_elements(n, arr))"}
{"solution": "def find_equator_day(n, a):\n    total_problems = sum(a)\n    half_problems = (total_problems + 1) // 2\n    solved_problems = 0\n    for i in range(n):\n        solved_problems += a[i]\n        if solved_problems >= half_problems:\n            return i + 1\n\nn = int(input())\na = list(map(int, input().split()))\nprint(find_equator_day(n, a))"}
{"solution": "from collections import deque\n\ndef get_moves(piece, x, y, N):\n    if piece == 'knight':\n        moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    elif piece == 'bishop':\n        moves = [(i, i) for i in range(-N+1, N) if i != 0] + [(i, -i) for i in range(-N+1, N) if i != 0]\n    elif piece == 'rook':\n        moves = [(i, 0) for i in range(N)] + [(0, i) for i in range(N)]\n    return [(x+dx, y+dy) for dx, dy in moves if 0 <= x+dx < N and 0 <= y+dy < N]\n\ndef bfs(board, N):\n    target = N * N\n    queue = deque([('knight', 0, 0, 0, 0, 0)])  # piece, x, y, steps, replacements, visited\n    visited = [[False] * N for _ in range(N)]\n    visited[0][0] = True\n    while queue:\n        piece, x, y, steps, replacements, visited_mask = queue.popleft()\n        current_num = board[x][y]\n        if current_num == target:\n            return steps, replacements\n        for new_piece in ['knight', 'bishop', 'rook']:\n            if new_piece != piece:\n                new_steps, new_replacements = steps + 1, replacements + 1\n                for nx, ny in get_moves(new_piece, x, y, N):\n                    if not visited[nx][ny]:\n                        visited[nx][ny] = True\n                        queue.append((new_piece, nx, ny, new_steps, new_replacements, visited_mask | (1 << board[nx][ny])))\n            else:\n                new_steps, new_replacements = steps + 1, replacements\n                for nx, ny in get_moves(piece, x, y, N):\n                    if not visited[nx][ny]:\n                        visited[nx][ny] = True\n                        queue.append((piece, nx, ny, new_steps, new_replacements, visited_mask | (1 << board[nx][ny])))\n    return -1, -1  # If no solution is found, which shouldn't happen given the problem constraints\n\nN = int(input().strip())\nboard = [list(map(int, input().split())) for _ in range(N)]\nsteps, replacements = bfs(board, N)\nprint(steps, replacements)"}
{"solution": "def calculate_time(n, m, k, a, b):\n    # Calculate the entrance, floor, and apartment within the floor for both Edward and Natasha\n    edward_entrance = (a - 1) // (m * k)\n    natasha_entrance = (b - 1) // (m * k)\n    edward_floor = ((a - 1) % (m * k)) // k\n    natasha_floor = ((b - 1) % (m * k)) // k\n\n    # Calculate the time to reach the first floor by elevator\n    elevator_time_edward = 10 + edward_floor  # 10 seconds waiting + 1 second per floor\n    elevator_time_natasha = 10 + natasha_floor\n\n    # Calculate the time to walk between entrances\n    clockwise_time = (natasha_entrance - edward_entrance) % n * 15\n    counterclockwise_time = (edward_entrance - natasha_entrance) % n * 15\n    walk_time = min(clockwise_time, counterclockwise_time)\n\n    # Calculate the time to reach Natasha's floor from the first floor\n    stairs_time = abs(natasha_floor - 0) * 5  # 5 seconds per floor\n\n    # Calculate total time for the optimal path\n    if edward_entrance == natasha_entrance:\n        # If they are in the same entrance, only consider elevator and stairs time\n        total_time = abs(edward_floor - natasha_floor) * 5\n    else:\n        # If they are in different entrances, consider all components\n        total_time = elevator_time_edward + walk_time + stairs_time\n\n    return total_time\n\n# Read input\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_time(n, m, k, a, b))"}
{"solution": "def can_form_divisible_by_64(s):\n    # A number is divisible by 64 if its binary representation ends with '0000000'\n    return '0000000' in s\n\n# Read input\ns = input().strip()\n\n# Output result\nprint(\"yes\" if can_form_divisible_by_64(s) else \"no\")"}
{"solution": "def transform_to_alphabet_subsequence(s):\n    target = \"abcdefghijklmnopqrstuvwxyz\"\n    current_char = 'a'\n    result = []\n\n    for char in s:\n        if char <= current_char and char != 'z':\n            result.append(current_char)\n            if current_char < 'z':\n                current_char = chr(ord(current_char) + 1)\n        else:\n            result.append(char)\n\n    if ''.join(result).find(target) != -1:\n        return ''.join(result)\n    else:\n        return \"-1\"\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(transform_to_alphabet_subsequence(s))"}
{"solution": "from heapq import heappush, heappop\n\ndef calculate_expected_value(n, m, r, k):\n    def count_covered_positions(x, y):\n        return (min(n - r + 1, x + r) - max(1, x)) * (min(m - r + 1, y + r) - max(1, y))\n\n    def add_neighbors(x, y):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= n - r + 1 and 1 <= ny <= m - r + 1 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                heappush(max_heap, (-count_covered_positions(nx, ny), nx, ny))\n\n    visited = set()\n    max_heap = []\n    start_x, start_y = (n - r + 1) // 2, (m - r + 1) // 2\n    visited.add((start_x, start_y))\n    heappush(max_heap, (-count_covered_positions(start_x, start_y), start_x, start_y))\n\n    total_expected_value = 0\n    total_positions = (n - r + 1) * (m - r + 1)\n\n    for _ in range(k):\n        _, x, y = heappop(max_heap)\n        total_expected_value -= count_covered_positions(x, y)\n        add_neighbors(x, y)\n\n    return total_expected_value / total_positions\n\nn, m, r, k = map(int, input().split())\nprint(f\"{calculate_expected_value(n, m, r, k):.10f}\")"}
{"solution": "def maximize_product(n, a):\n    if n == 1:\n        return a\n    \n    negative_count = 0\n    zero_count = 0\n    max_negative = float('-inf')\n    max_negative_index = -1\n    \n    for i in range(n):\n        if a[i] < 0:\n            negative_count += 1\n            if a[i] > max_negative:\n                max_negative = a[i]\n                max_negative_index = i\n        elif a[i] == 0:\n            zero_count += 1\n    \n    result = []\n    for i in range(n):\n        if a[i] == 0:\n            result.append(-1)\n        else:\n            result.append(-a[i] - 1)\n    \n    if negative_count % 2 == 0:\n        return result\n    else:\n        result[max_negative_index] = -result[max_negative_index] - 1\n        return result\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Getting the result and printing it\nresult = maximize_product(n, a)\nprint(' '.join(map(str, result)))"}
{"solution": "import math\n\ndef kth_smallest_divisor(n, k):\n    divisors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.sort()\n    if k > len(divisors):\n        return -1\n    else:\n        return divisors[k - 1]\n\n# Read input\nn, k = map(int, input().split())\n\n# Output the result\nprint(kth_smallest_divisor(n, k))"}
{"solution": "def can_form_number(cubes, number):\n    number_str = str(number)\n    for digit in number_str:\n        found = False\n        for cube in cubes:\n            if int(digit) in cube:\n                found = True\n                break\n        if not found:\n            return False\n    return True\n\ndef find_max_number(n, cubes):\n    max_number = 0\n    for i in range(1, 10**(n*6)+1):\n        if not can_form_number(cubes, i):\n            return max_number\n        max_number = i\n    return max_number\n\nn = int(input())\ncubes = [list(map(int, input().split())) for _ in range(n)]\n\nprint(find_max_number(n, cubes))"}
{"solution": "import math\n\ndef k_rounding(n, k):\n    if k == 0:\n        return n\n    factor = 10 ** k\n    return (n * factor) // math.gcd(n, factor)\n\n# Read input\nn, k = map(int, input().split())\n\n# Output the k-rounding of n\nprint(k_rounding(n, k))"}
{"solution": "def transform_matrices(n, m, A):\n    operations = []\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                operations.append((i + 1, j + 1))\n    \n    B = [[0 for _ in range(m)] for _ in range(n)]\n    for x, y in operations:\n        B[x - 1][y - 1] = B[x - 1][y] = B[x][y - 1] = B[x][y] = 1\n    \n    if A == B:\n        return len(operations), operations\n    else:\n        return -1\n\n# Read input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\n# Process and output result\nresult = transform_matrices(n, m, A)\nif result == -1:\n    print(result)\nelse:\n    k, operations = result\n    print(k)\n    for op in operations:\n        print(*op)"}
{"solution": "def calculate_probabilities(r, s, p):\n    # Initialize the DP table\n    dp = [[[0.0 for _ in range(p+1)] for _ in range(s+1)] for _ in range(r+1)]\n    dp[r][s][p] = 1.0  # The probability at the start is 1\n\n    # Total number of individuals\n    total = r + s + p\n\n    # Dynamic programming to calculate probabilities\n    for i in range(r, -1, -1):\n        for j in range(s, -1, -1):\n            for k in range(p, -1, -1):\n                if i == 0 and j == 0:  # No rocks and scissors, only papers\n                    continue\n                if i == 0 and k == 0:  # No rocks and papers, only scissors\n                    continue\n                if j == 0 and k == 0:  # No scissors and papers, only rocks\n                    continue\n\n                # Calculate the probability of meeting two individuals\n                prob_meet = i * j + j * k + k * i\n                if i > 0 and j > 0:\n                    dp[i][j-1][k] += dp[i][j][k] * (i * j) / prob_meet\n                if j > 0 and k > 0:\n                    dp[i][j][k-1] += dp[i][j][k] * (j * k) / prob_meet\n                if k > 0 and i > 0:\n                    dp[i-1][j][k] += dp[i][j][k] * (k * i) / prob_meet\n\n    # Calculate the final probabilities\n    prob_r = sum(dp[i][0][0] for i in range(1, r+1))\n    prob_s = sum(dp[0][j][0] for j in range(1, s+1))\n    prob_p = sum(dp[0][0][k] for k in range(1, p+1))\n\n    return prob_r, prob_s, prob_p\n\n# Read input\nr, s, p = map(int, input().split())\n\n# Calculate and print probabilities\nprob_r, prob_s, prob_p = calculate_probabilities(r, s, p)\nprint(f\"{prob_r:.12f} {prob_s:.12f} {prob_p:.12f}\")"}
{"solution": "def calculate_meeting_time(l_1, r_1, l_2, r_2, k):\n    # Calculate the intersection of the two time intervals\n    intersection_start = max(l_1, l_2)\n    intersection_end = min(r_1, r_2)\n    \n    # If there's no intersection, they cannot meet\n    if intersection_start > intersection_end:\n        return 0\n    \n    # Calculate the total time they can spend together\n    total_time = intersection_end - intersection_start + 1\n    \n    # Subtract the time when Sonya is prinking, if it's within the intersection\n    if intersection_start <= k <= intersection_end:\n        total_time -= 1\n    \n    return total_time\n\n# Read input\nl_1, r_1, l_2, r_2, k = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_meeting_time(l_1, r_1, l_2, r_2, k))"}
{"solution": "def find_intersecting_lines(lines, point):\n    intersections = []\n    for line in lines:\n        if line[0] <= point[0] <= line[1] or line[0] >= point[0] >= line[1]:\n            intersections.append(line[2])\n    return intersections\n\ndef calculate_reachable_area(n, m, ns_lines, ew_lines):\n    # Find the intersections at (0, 0)\n    ns_intersections = find_intersecting_lines(ns_lines, (0, 0))\n    ew_intersections = find_intersecting_lines(ew_lines, (0, 0))\n    \n    # If there are no intersections, the area is infinite\n    if not ns_intersections and not ew_intersections:\n        return \"INF\"\n    \n    # Sort intersections to find the boundaries\n    ns_intersections.sort()\n    ew_intersections.sort()\n    \n    # Calculate the area within the boundaries\n    max_x = ns_intersections[-1] if ns_intersections else float('inf')\n    min_x = ns_intersections[0] if ns_intersections else -float('inf')\n    max_y = ew_intersections[-1] if ew_intersections else float('inf')\n    min_y = ew_intersections[0] if ew_intersections else -float('inf')\n    \n    # If any boundary is infinite, the area is infinite\n    if max_x == float('inf') or min_x == -float('inf') or max_y == float('inf') or min_y == -float('inf'):\n        return \"INF\"\n    \n    # Calculate the area\n    area = (max_x - min_x) * (max_y - min_y)\n    return area\n\n# Read input\nn, m = map(int, input().split())\nns_lines = [tuple(map(int, input().split())) for _ in range(n)]\new_lines = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Calculate and print the reachable area\nprint(calculate_reachable_area(n, m, ns_lines, ew_lines))"}
{"solution": "def will_pineapple_bark(t, s, x):\n    if x < t:\n        return \"NO\"\n    if x == t:\n        return \"YES\"\n    if (x - t) % s == 0 or (x - t - 1) % s == 0:\n        return \"YES\"\n    return \"NO\"\n\n# Read input\nt, s, x = map(int, input().split())\n\n# Output result\nprint(will_pineapple_bark(t, s, x))"}
{"solution": "def find_nested_segments(n, segments):\n    # Sort segments by their left endpoint, then by their right endpoint in reverse\n    sorted_segments = sorted(enumerate(segments, 1), key=lambda x: (x[1][0], -x[1][1]))\n    \n    # Initialize variables to store the maximum right endpoint found so far and its index\n    max_right = -1\n    max_right_index = -1\n    \n    # Iterate through the sorted segments to find a nested segment\n    for i, (l, r) in sorted_segments:\n        if r <= max_right:  # If the current segment is nested within the segment with max_right\n            return max_right_index, i  # Return the indices of the nested segments\n        if r > max_right:  # Update the max_right and its index if the current segment's right endpoint is larger\n            max_right = r\n            max_right_index = i\n    \n    # If no nested segments are found, return -1 -1\n    return -1, -1\n\n# Read input\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Find and print the result\nprint(*find_nested_segments(n, segments))"}
{"solution": "def decode_mammoth_genome(n, s):\n    if n % 4 != 0:\n        return \"===\"\n    \n    nucleotides = ['A', 'C', 'G', 'T']\n    counts = {nuc: s.count(nuc) for nuc in nucleotides}\n    total_question_marks = s.count('?')\n    required_counts = n // 4\n    \n    for nuc in nucleotides:\n        if counts[nuc] > required_counts:\n            return \"===\"\n    \n    decoded_genome = list(s)\n    for i in range(n):\n        if decoded_genome[i] == '?':\n            for nuc in nucleotides:\n                if counts[nuc] < required_counts:\n                    decoded_genome[i] = nuc\n                    counts[nuc] += 1\n                    break\n    \n    return ''.join(decoded_genome)\n\n# Reading input\nn = int(input().strip())\ns = input().strip()\n\n# Printing output\nprint(decode_mammoth_genome(n, s))"}
{"solution": "def can_ilya_win(board):\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                # Try placing an 'x' in this empty cell and check if it wins\n                board[i][j] = 'x'\n                if is_winning_move(board, i, j):\n                    return \"YES\"\n                # Reset the cell to empty after checking\n                board[i][j] = '.'\n    return \"NO\"\n\ndef is_winning_move(board, x, y):\n    # Check horizontal, vertical, and both diagonals\n    directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n    for dx, dy in directions:\n        count = 1\n        # Check in the positive direction\n        count += count_in_direction(board, x, y, dx, dy)\n        # Check in the negative direction\n        count += count_in_direction(board, x, y, -dx, -dy)\n        if count >= 3:\n            return True\n    return False\n\ndef count_in_direction(board, x, y, dx, dy):\n    count = 0\n    for i in range(1, 3):\n        nx, ny = x + dx * i, y + dy * i\n        if 0 <= nx < 4 and 0 <= ny < 4 and board[nx][ny] == 'x':\n            count += 1\n        else:\n            break\n    return count\n\n# Read input\nboard = [list(input().strip()) for _ in range(4)]\n\n# Output result\nprint(can_ilya_win(board))"}
{"solution": "def can_divide_array(n, a):\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return \"NO\"\n    \n    half_sum = total_sum // 2\n    prefix_sum = 0\n    \n    for i in range(n):\n        prefix_sum += a[i]\n        if prefix_sum == half_sum:\n            return \"YES\"\n        if prefix_sum > half_sum:\n            break\n    \n    suffix_sum = 0\n    for i in range(n-1, -1, -1):\n        suffix_sum += a[i]\n        if suffix_sum == half_sum:\n            return \"YES\"\n        if suffix_sum > half_sum:\n            break\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output result\nprint(can_divide_array(n, a))"}
{"solution": "def can_make_non_increasing(n, k, a, b):\n    # Sort the elements of b in descending order to use them to replace zeros\n    b.sort(reverse=True)\n    \n    # Replace zeros in a with elements from b\n    b_index = 0\n    for i in range(n):\n        if a[i] == 0:\n            a[i] = b[b_index]\n            b_index += 1\n    \n    # Check if the resulting sequence is not increasing\n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            return \"Yes\"\n    \n    return \"No\"\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Output result\nprint(can_make_non_increasing(n, k, a, b))"}
{"solution": "def can_distribute_grapes(x, y, z, a, b, c):\n    # First, satisfy Andrew's need for green grapes\n    if a >= x:\n        a -= x\n    else:\n        return \"NO\"\n    \n    # Next, satisfy Dmitry's need for green and purple grapes\n    if a + b >= y:\n        total_for_dmitry = min(a, y) + min(b, y - min(a, y))\n        a -= min(a, y)\n        b -= y - min(a, y)\n    else:\n        return \"NO\"\n    \n    # Finally, satisfy Michal's need for any grapes\n    if a + b + c >= z:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Output result\nprint(can_distribute_grapes(x, y, z, a, b, c))"}
{"solution": "def is_accident_possible(lights):\n    for i in range(4):\n        if lights[i][3] == 1 and (lights[i][0] == 1 or lights[i][1] == 1 or lights[i][2] == 1):\n            return \"YES\"\n        if i < 3 and lights[i][2] == 1 and lights[i + 1][0] == 1:\n            return \"YES\"\n        if i == 2 and lights[i][2] == 1 and lights[0][0] == 1:\n            return \"YES\"\n        if i == 0 and lights[i][2] == 1 and lights[3][0] == 1:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nlights = []\nfor _ in range(4):\n    lights.append(list(map(int, input().split())))\n\n# Output result\nprint(is_accident_possible(lights))"}
{"solution": "def same_finger_movements(n, number):\n    # Define the keyboard layout\n    keyboard = {\n        '0': (0, 0), '1': (0, 1), '2': (0, 2), '3': (0, 3),\n        '4': (1, 1), '5': (1, 2), '6': (1, 3),\n        '7': (2, 1), '8': (2, 2), '9': (2, 3)\n    }\n    \n    # Check if there's another number with the same finger movements\n    for i in range(10):\n        for j in range(10):\n            if i != j:\n                if all(keyboard[number[k]] == keyboard[str(i) if k % 2 == 0 else str(j)] for k in range(n)):\n                    return \"NO\"\n    return \"YES\"\n\n# Read input\nn = int(input().strip())\nnumber = input().strip()\n\n# Output result\nprint(same_finger_movements(n, number))"}
{"solution": "def max_sold_products(n, f, days):\n    # Calculate the potential gain from doubling the products for each day\n    potential_gains = [(min(2 * k, l) - min(k, l), k, l) for k, l in days]\n    # Sort by the potential gain in descending order\n    potential_gains.sort(reverse=True)\n    \n    total_sold = 0\n    # For the f days with the highest potential gain, double the products\n    for i in range(f):\n        _, k, l = potential_gains[i]\n        total_sold += min(2 * k, l)\n    \n    # For the remaining days, sell as many products as possible without doubling\n    for i in range(f, n):\n        _, k, l = potential_gains[i]\n        total_sold += min(k, l)\n    \n    return total_sold\n\n# Read input\nn, f = map(int, input().split())\ndays = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(max_sold_products(n, f, days))"}
{"solution": "def max_messiness(n, k):\n    # The maximum messiness is achieved by reversing the array as much as possible\n    # within the given number of swaps. Each swap can increase the messiness by up to\n    # the number of inversions in the array, which is n*(n-1)/2 for a fully sorted array.\n    # However, we can only reverse the array completely if k is at least n/2, since we\n    # need at least n/2 swaps to reverse an array of size n.\n    \n    # If k is less than n/2, we can only perform k swaps, which will increase the messiness\n    # by up to k*(n-k) since each swap can affect two positions and we can choose the optimal\n    # pairs to maximize the messiness.\n    \n    if k >= n // 2:\n        return n * (n - 1) // 2\n    else:\n        return k * (n - k)\n\n# Read input\nn, k = map(int, input().split())\n\n# Output the result\nprint(max_messiness(n, k))"}
{"solution": "def min_coins_to_gift(N, M, K, L):\n    # Calculate the total number of new coins needed\n    total_new_needed = L\n    \n    # Calculate the number of coins each friend needs to gift\n    coins_per_friend = (total_new_needed + K - 1) // M  # Ceiling division\n    \n    # Check if it's possible to meet the conditions\n    if coins_per_friend * M > N - K or coins_per_friend > N - K:\n        return -1\n    \n    # Return the minimum number of coins one friend can gift\n    return coins_per_friend\n\n# Read input\nN, M, K, L = map(int, input().split())\n\n# Print the result\nprint(min_coins_to_gift(N, M, K, L))"}
{"solution": "def min_cells_to_paint_square(n, m, grid):\n    black_cells = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                black_cells.append((i, j))\n    \n    if not black_cells:\n        return 1\n    \n    min_row = min(black_cells, key=lambda x: x[0])[0]\n    max_row = max(black_cells, key=lambda x: x[0])[0]\n    min_col = min(black_cells, key=lambda x: x[1])[1]\n    max_col = max(black_cells, key=lambda x: x[1])[1]\n    \n    square_side = max(max_row - min_row + 1, max_col - min_col + 1)\n    \n    if square_side > n or square_side > m:\n        return -1\n    \n    total_black_needed = square_side ** 2\n    current_black = len(black_cells)\n    \n    return total_black_needed - current_black\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Output the result\nprint(min_cells_to_paint_square(n, m, grid))"}
{"solution": "def can_be_correct(n, x, y):\n    return \"Yes\" if sum(x) >= sum(y) else \"No\"\n\n# Read input\nn = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Output result\nprint(can_be_correct(n, x, y))"}
{"solution": "def min_angle_difference(n, angles):\n    total_angle = 360\n    min_diff = total_angle\n    for i in range(n):\n        for j in range(i, n):\n            current_sum = sum(angles[i:j+1])\n            min_diff = min(min_diff, abs(total_angle - 2 * current_sum))\n    return min_diff\n\n# Read input\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Output the result\nprint(min_angle_difference(n, angles))"}
{"solution": "MOD = 10**9 + 7\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef solve(n, m):\n    return power(2, n * m - n, MOD)\n\nn, m = map(int, input().split())\nprint(solve(n, m))"}
{"solution": "import math\n\ndef find_pythagorean_triple(n):\n    if n == 1 or n == 2:\n        return -1\n    \n    if n % 2 == 0:\n        # For even n, we can use the formula (n, (n/2)^2 - 1, (n/2)^2 + 1)\n        m = (n // 2) ** 2 - 1\n        k = (n // 2) ** 2 + 1\n    else:\n        # For odd n, we can use the formula (n, (n^2 - 1)/2, (n^2 + 1)/2)\n        m = (n ** 2 - 1) // 2\n        k = (n ** 2 + 1) // 2\n    \n    # Check if the generated triple is valid\n    if n**2 + m**2 == k**2:\n        return m, k\n    else:\n        return -1\n\n# Read input\nn = int(input())\n\n# Find and print the Pythagorean triple\nresult = find_pythagorean_triple(n)\nif result == -1:\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "def distinct_remainders(n, k):\n    if k >= n:\n        return \"No\"\n    if k > 1 and n % 2 == 0 and k >= n // 2:\n        return \"No\"\n    return \"Yes\"\n\nn, k = map(int, input().split())\nprint(distinct_remainders(n, k))"}
{"solution": "import sys\n\n# Fast input reading\na = sys.stdin.readline().strip()\nb = sys.stdin.readline().strip()\n\n# Removing leading zeros for correct comparison\na = a.lstrip('0') or '0'\nb = b.lstrip('0') or '0'\n\n# Comparison\nif len(a) > len(b):\n    print('>')\nelif len(a) < len(b):\n    print('<')\nelse:\n    if a > b:\n        print('>')\n    elif a < b:\n        print('<')\n    else:\n        print('=')"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, p, colors):\n    # Initialize the dp array\n    dp = [[[0 for _ in range(2)] for _ in range(2)] for _ in range(n+1)]\n    dp[0][0][0] = 1  # Base case: no pieces, no paths, score parity 0\n\n    # Iterate over each piece\n    for i in range(1, n+1):\n        c = colors[i-1]\n        for has_arrow in range(2):  # Whether there's an arrow ending at i\n            for prev_color in range(2):  # Color of the previous piece\n                for cur_color in range(2):  # Color of the current piece\n                    if c == -1 or c == cur_color:  # If the piece is uncolored or matches the current color\n                        # Calculate the new parity\n                        new_parity = (prev_color ^ cur_color) if has_arrow else 0\n                        # Update the dp array\n                        dp[i][has_arrow][new_parity] += dp[i-1][prev_color][has_arrow]\n                        dp[i][has_arrow][new_parity] %= MOD\n\n    # Sum up the ways that match the desired parity\n    result = 0\n    for has_arrow in range(2):\n        result += dp[n][has_arrow][p]\n        result %= MOD\n\n    return result\n\n# Read input\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_ways(n, p, colors))"}
{"solution": "def min_rubles_to_buy_copybooks(n, a, b, c):\n    # If n is already divisible by 4, no need to buy more copybooks\n    if n % 4 == 0:\n        return 0\n    \n    # Calculate the remainder when n is divided by 4\n    remainder = n % 4\n    \n    # Calculate the number of copybooks needed to make n + k divisible by 4\n    k = 4 - remainder\n    \n    # Initialize the minimum cost to a large number\n    min_cost = float('inf')\n    \n    # Check all possible combinations of buying copybooks to minimize the cost\n    for i in range(4):\n        for j in range(4):\n            for l in range(4):\n                if (i + 2 * j + 3 * l) % 4 == k % 4 and i + 2 * j + 3 * l >= k:\n                    cost = i * a + j * b + l * c\n                    min_cost = min(min_cost, cost)\n    \n    return min_cost\n\n# Read input\nn, a, b, c = map(int, input().split())\n\n# Print the result\nprint(min_rubles_to_buy_copybooks(n, a, b, c))"}
{"solution": "def is_acyclic_after_removal(n, edges):\n    graph = {i: [] for i in range(1, n + 1)}\n    for u, v in edges:\n        graph[u].append(v)\n\n    def dfs(node, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, stack):\n                    return True\n            elif stack[neighbor]:\n                return True\n        stack[node] = False\n        return False\n\n    def has_cycle():\n        visited = [False] * (n + 1)\n        stack = [False] * (n + 1)\n        for node in range(1, n + 1):\n            if not visited[node]:\n                if dfs(node, visited, stack):\n                    return True\n        return False\n\n    if not has_cycle():\n        return \"YES\"\n\n    for u, v in edges:\n        graph[u].remove(v)\n        if not has_cycle():\n            return \"YES\"\n        graph[u].append(v)\n\n    return \"NO\"\n\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nprint(is_acyclic_after_removal(n, edges))"}
{"solution": "def min_coins_to_modernize(n, m, antennas):\n    antennas.sort()\n    dp = [float('inf')] * (m + 1)\n    dp[0] = 0\n\n    for i in range(n):\n        x, s = antennas[i]\n        left = max(1, x - s)\n        right = min(m, x + s)\n        for j in range(left, right + 1):\n            dp[j] = min(dp[j], dp[left - 1])\n        for j in range(1, m + 1):\n            if j < left:\n                dp[j] = min(dp[j], dp[j - 1] + 1)\n            elif j > right:\n                dp[j] = min(dp[j], dp[right] + (j - right))\n\n    return dp[m]\n\n# Read input\nn, m = map(int, input().split())\nantennas = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(min_coins_to_modernize(n, m, antennas))"}
{"solution": "def max_good_subset_weight(W, cnt):\n    # Initialize the maximum weight to 0\n    max_weight = 0\n    \n    # Try to use as many items with weight 8 as possible without exceeding W\n    for use_8 in range(min(cnt[7], W // 8) + 1):\n        remaining_weight = W - use_8 * 8\n        current_weight = use_8 * 8\n        \n        # Try to use items with weight 7, 6, ..., 1 without exceeding the remaining weight\n        for i in range(6, -1, -1):\n            max_use = min(cnt[i], remaining_weight // (i + 1))\n            current_weight += max_use * (i + 1)\n            remaining_weight -= max_use * (i + 1)\n        \n        # Update the maximum weight if the current configuration yields a higher weight\n        max_weight = max(max_weight, current_weight)\n    \n    return max_weight\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Calculate and print the maximum possible weight of a good subset of items\nprint(max_good_subset_weight(W, cnt))"}
{"solution": "def min_cost_to_buy_lemonade(n, L, costs):\n    # Convert costs to a list of tuples (volume, cost)\n    bottles = [(2**i - 1, cost) for i, cost in enumerate(costs)]\n    \n    # Sort bottles by cost per liter in ascending order\n    bottles.sort(key=lambda x: x[1] / (2**(x.index(x[0]))))\n    \n    total_cost = 0\n    while L > 0:\n        # Find the most cost-effective bottle that can be used\n        for volume, cost in reversed(bottles):\n            if volume <= L:\n                num_bottles = L // volume\n                total_cost += num_bottles * cost\n                L -= num_bottles * volume\n                break\n    \n    return total_cost\n\n# Read input\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Output the result\nprint(min_cost_to_buy_lemonade(n, L, costs))"}
{"solution": "def max_mex(n, arr):\n    arr.sort()\n    mex = 1\n    for num in arr:\n        if num >= mex:\n            mex += 1\n    return mex\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output the result\nprint(max_mex(n, arr))"}
{"solution": "def is_lucky_ticket(n, ticket):\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            sum1 = sum(ticket[:i])\n            sum2 = sum(ticket[i:j])\n            sum3 = sum(ticket[j:])\n            if sum1 == sum2 and sum2 == sum3:\n                return \"YES\"\n    return \"NO\"\n\nn = int(input())\nticket = [int(digit) for digit in input().strip()]\nprint(is_lucky_ticket(n, ticket))"}
{"solution": "def determine_gender(username):\n    distinct_chars = len(set(username))\n    return \"CHAT WITH HER!\" if distinct_chars % 2 == 0 else \"IGNORE HIM!\"\n\n# Read input from the user\nusername = input().strip()\n\n# Output the result\nprint(determine_gender(username))"}
{"solution": "def max_abs_difference(n, k, tabs):\n    max_diff = 0\n    for b in range(n):\n        test_tabs = 0\n        social_tabs = 0\n        for i in range(n):\n            if (i - b) % k != 0:\n                if tabs[i] == 1:\n                    test_tabs += 1\n                else:\n                    social_tabs += 1\n        max_diff = max(max_diff, abs(test_tabs - social_tabs))\n    return max_diff\n\n# Read input\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Output the result\nprint(max_abs_difference(n, k, tabs))"}
{"solution": "def min_total_cost(n, c_0, c_1):\n    # Calculate the minimum number of bits required to represent n letters\n    # using a binary tree approach where each level doubles the number of leaves\n    bits = 0\n    while 2**bits < n:\n        bits += 1\n    \n    # Calculate the total cost for the bits used\n    total_cost = bits * (c_0 + c_1)\n    \n    return total_cost\n\n# Read input\nn, c_0, c_1 = map(int, input().split())\n\n# Calculate and print the output\nprint(min_total_cost(n, c_0, c_1))"}
{"solution": "def will_meet(n, a, x, b, y):\n    while a != x and b != y:\n        if a == b:\n            return \"YES\"\n        a = a % n + 1\n        b = (b - 2) % n + 1\n    return \"YES\" if a == b else \"NO\"\n\n# Read input\nn, a, x, b, y = map(int, input().split())\n\n# Output result\nprint(will_meet(n, a, x, b, y))"}
{"solution": "def max_golden_age_length(x, y, l, r):\n    unlucky_years = set()\n    for a in range(64):  # 64 to cover the range of 10^18\n        for b in range(64):\n            year = x**a + y**b\n            if l <= year <= r:\n                unlucky_years.add(year)\n    \n    unlucky_years = sorted(unlucky_years)\n    max_length = 0\n    prev = l - 1\n    \n    for year in unlucky_years:\n        max_length = max(max_length, year - prev - 1)\n        prev = year\n    \n    max_length = max(max_length, r - prev)\n    \n    return max_length\n\n# Read input\nx, y, l, r = map(int, input().split())\n\n# Output the result\nprint(max_golden_age_length(x, y, l, r))"}
{"solution": "def min_tax(n):\n    if n == 2:\n        return 1\n    if n % 2 == 0:\n        return 2\n    # Check if n is a prime number\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return 3\n    return 1\n\n# Read input\nn = int(input())\n\n# Output the result\nprint(min_tax(n))"}
{"solution": "def insert_spaces_to_avoid_typos(word):\n    vowels = 'aeiou'\n    result = []\n    consonant_block = ''\n\n    for char in word:\n        if char in vowels:\n            if len(consonant_block) >= 3 and len(set(consonant_block)) > 1:\n                result.append(' ')\n            result.append(consonant_block)\n            result.append(char)\n            consonant_block = ''\n        else:\n            if len(consonant_block) >= 3 and len(set(consonant_block)) > 1:\n                result.append(' ')\n                consonant_block = char\n            else:\n                consonant_block += char\n\n    if consonant_block:\n        if len(consonant_block) >= 3 and len(set(consonant_block)) > 1:\n            result.append(' ')\n        result.append(consonant_block)\n\n    return ''.join(result)\n\n# Read input\nword = input().strip()\n\n# Process and print output\nprint(insert_spaces_to_avoid_typos(word))"}
{"solution": "import sys\n\ndef min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d):\n    # Initialize the minimum time to the worst case scenario\n    min_time = n * x\n    \n    # Check spells of the first type\n    for i in range(m):\n        if b[i] <= s:\n            # Calculate the remaining potions after using a spell of the first type\n            remaining_potions = n\n            current_time = a[i]\n            \n            # Check spells of the second type\n            for j in range(k):\n                if d[j] <= s - b[i]:\n                    # Use the spell of the second type to instantly create potions\n                    remaining_potions = max(0, remaining_potions - c[j])\n            \n            # Calculate the total time after using the spells\n            total_time = remaining_potions * current_time\n            min_time = min(min_time, total_time)\n    \n    # Check spells of the second type without using any spell of the first type\n    for j in range(k):\n        if d[j] <= s:\n            # Calculate the remaining potions after using a spell of the second type\n            remaining_potions = max(0, n - c[j])\n            # Calculate the total time after using the spell\n            total_time = remaining_potions * x\n            min_time = min(min_time, total_time)\n    \n    return min_time\n\n# Read input\ninput_data = sys.stdin.readlines()\nn, m, k = map(int, input_data[0].split())\nx, s = map(int, input_data[1].split())\na = list(map(int, input_data[2].split()))\nb = list(map(int, input_data[3].split()))\nc = list(map(int, input_data[4].split()))\nd = list(map(int, input_data[5].split()))\n\n# Calculate and print the minimum time\nprint(min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d))"}
{"solution": "def max_points(n, k, M, t):\n    t.sort()\n    total_time = 0\n    points = 0\n    for i in range(k):\n        if total_time + t[i] * n <= M:\n            total_time += t[i] * n\n            points += n\n        else:\n            points += (M - total_time) // t[i]\n            break\n    if total_time <= M and points == n * k:\n        points += n\n    return points\n\n# Read input\nn, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Output the result\nprint(max_points(n, k, M, t))"}
{"solution": "MOD = 998244353\n\ndef count_perfectly_balanced_striped_bst(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 0\n    \n    # Initialize dp array\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    # Calculate the number of perfectly balanced striped BSTs for each number of vertices\n    for i in range(2, n + 1):\n        # Calculate the number of ways to split the vertices into left and right subtrees\n        for j in range(1, i):\n            if (i - 1) % 2 == j % 2:\n                dp[i] = (dp[i] + dp[j] * dp[i - 1 - j]) % MOD\n    \n    return dp[n]\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(count_perfectly_balanced_striped_bst(n))"}
{"solution": "def lara_position(n, m, k):\n    # Calculate the number of complete cycles Lara has completed\n    cycles = k // (2 * m)\n    # Calculate the remaining moves after completing the cycles\n    remaining_moves = k % (2 * m)\n    \n    # Determine the row and column based on the remaining moves\n    if remaining_moves < m:\n        row = cycles * 2 + 1\n        col = remaining_moves + 1\n    else:\n        row = cycles * 2 + 2\n        col = 2 * m - remaining_moves + 1\n    \n    return row, col\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Get Lara's current position\nrow, col = lara_position(n, m, k)\n\n# Print the result\nprint(row, col)"}
{"solution": "import math\n\ndef find_pair_with_min_max_lcm(X):\n    if X == 1:\n        return 1, 1\n    for i in range(2, int(math.sqrt(X)) + 1):\n        if X % i == 0:\n            a = i\n            b = X // i\n            if math.gcd(a, b) == 1:\n                return b, a\n    return 1, X\n\nX = int(input().strip())\na, b = find_pair_with_min_max_lcm(X)\nprint(a, b)"}
{"solution": "def max_compote(a, b, c):\n    # Find the limiting factor for each fruit type based on the recipe ratio\n    lemons_limit = a\n    apples_limit = b // 2\n    pears_limit = c // 4\n    \n    # The maximum number of sets of fruits Nikolay can use is limited by the least available in ratio\n    max_sets = min(lemons_limit, apples_limit, pears_limit)\n    \n    # Calculate the total number of fruits in the maximum sets\n    total_fruits = max_sets + (max_sets * 2) + (max_sets * 4)\n    \n    return total_fruits\n\n# Read input\na = int(input())\nb = int(input())\nc = int(input())\n\n# Output the result\nprint(max_compote(a, b, c))"}
{"solution": "def can_beroil_win(n, ratings):\n    ratings.sort()\n    return \"YES\" if ratings[n] > ratings[n - 1] else \"NO\"\n\n# Read input\nn = int(input())\nratings = list(map(int, input().split()))\n\n# Output result\nprint(can_beroil_win(n, ratings))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef make_coprime_array(n, arr):\n    result = []\n    moves = 0\n    for i in range(n - 1):\n        result.append(arr[i])\n        if gcd(arr[i], arr[i + 1]) != 1:\n            for j in range(2, 10**9 + 1):\n                if gcd(arr[i], j) == 1 and gcd(arr[i + 1], j) == 1:\n                    result.append(j)\n                    moves += 1\n                    break\n    result.append(arr[-1])\n    return moves, result\n\nn = int(input())\narr = list(map(int, input().split()))\n\nmoves, new_arr = make_coprime_array(n, arr)\nprint(moves)\nprint(' '.join(map(str, new_arr)))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef find_max_divisor(N, K, A):\n    total_sum = sum(A)\n    divisors = set()\n    \n    # Find all possible divisors of the total sum\n    for i in range(1, int(total_sum ** 0.5) + 1):\n        if total_sum % i == 0:\n            divisors.add(i)\n            divisors.add(total_sum // i)\n    \n    # Sort divisors in descending order to start checking from the largest\n    divisors = sorted(divisors, reverse=True)\n    \n    # Check each divisor to see if it can be the maximum possible positive integer\n    for divisor in divisors:\n        remainder = [a % divisor for a in A]\n        remainder.sort()\n        total_remainder = sum(remainder)\n        \n        # Calculate the number of operations needed to make all elements divisible by the divisor\n        operations_needed = sum([divisor - r for r in remainder if r > 0])\n        \n        # If operations needed are within the allowed K, then this divisor is the answer\n        if operations_needed <= K and (K - operations_needed) % divisor == 0:\n            return divisor\n    \n    return 1  # If no divisor works, the answer is 1\n\n# Read input\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Output the result\nprint(find_max_divisor(N, K, A))"}
{"solution": "def cat_furrier_transform(x):\n    operations = []\n    m = 0\n    while x != (1 << (m + 1)) - 1 and len(operations) < 40:\n        if len(operations) % 2 == 0:\n            # Find the highest bit that can be flipped to get closer to 2^m - 1\n            for n in range(30, -1, -1):\n                if x & (1 << n) == 0:\n                    x ^= (1 << (n + 1)) - 1\n                    operations.append(n + 1)\n                    break\n        else:\n            x += 1\n        m += 1\n    return len(operations), operations\n\n# Read input\nx = int(input().strip())\n\n# Perform the Cat Furrier Transform\nt, operations = cat_furrier_transform(x)\n\n# Print the result\nprint(t)\nif t > 0:\n    print(*operations)"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nmin_hours = float('inf')\nfor bucket in a:\n    if k % bucket == 0:\n        min_hours = min(min_hours, k // bucket)\n\nprint(min_hours)"}
{"solution": "def can_grasshopper_reach_insect(n, k, line):\n    grasshopper_pos = line.index('G')\n    insect_pos = line.index('T')\n    \n    if grasshopper_pos < insect_pos:\n        start, end, step = grasshopper_pos, insect_pos, k\n    else:\n        start, end, step = grasshopper_pos, insect_pos, -k\n    \n    for i in range(start, end, step):\n        if line[i] == '#':\n            return \"NO\"\n        if i == insect_pos:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Reading input\nn, k = map(int, input().split())\nline = input()\n\n# Output result\nprint(can_grasshopper_reach_insect(n, k, line))"}
{"solution": "import math\n\ndef calculate_aiming_point(y1, y2, yw, xb, yb, r):\n    # Calculate the necessary angle to hit the goal\n    angle_to_goal = math.atan2(y2 - r - yb, xb)\n    \n    # Calculate the angle to the wall\n    angle_to_wall = math.atan2(yw - r - yb, xb)\n    \n    # If the angle to the goal is greater than the angle to the wall, it's impossible to score\n    if angle_to_goal >= angle_to_wall:\n        return -1\n    \n    # Calculate the distance to the wall\n    distance_to_wall = xb / math.cos(angle_to_wall)\n    \n    # Calculate the y-coordinate where the ball hits the wall\n    y_hit_wall = yb + distance_to_wall * math.sin(angle_to_wall)\n    \n    # Calculate the x-coordinate of the aiming point\n    xw = (y_hit_wall - yw) * xb / (yw - yb)\n    \n    return xw\n\n# Read input\ny1, y2, yw, xb, yb, r = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_aiming_point(y1, y2, yw, xb, yb, r)\nprint(f\"{result:.10f}\" if result != -1 else result)"}
{"solution": "def min_missed_meals(b, d, s):\n    # Sort the meals to find the maximum count\n    meals = sorted([b, d, s])\n    \n    # Calculate the missed meals for dinner and supper\n    missed = max(0, meals[2] - meals[1] - 1) + max(0, meals[2] - meals[0] - 1)\n    \n    return missed\n\n# Read input\nb, d, s = map(int, input().split())\n\n# Print the result\nprint(min_missed_meals(b, d, s))"}
{"solution": "def find_matrix_dimensions(n, path):\n    if n == 1:\n        return \"YES\", 1, path[0]\n    \n    for i in range(1, n):\n        if path[i] == path[i-1]:\n            return \"NO\"\n    \n    max_val = max(path)\n    for x in range(1, int(max_val**0.5) + 1):\n        if max_val % x == 0:\n            y = max_val // x\n            if is_valid_path(x, y, path):\n                return \"YES\", x, y\n    return \"NO\"\n\ndef is_valid_path(x, y, path):\n    current_i, current_j = get_coordinates(x, y, path[0])\n    for a in path[1:]:\n        next_i, next_j = get_coordinates(x, y, a)\n        if not is_adjacent(current_i, current_j, next_i, next_j):\n            return False\n        current_i, current_j = next_i, next_j\n    return True\n\ndef get_coordinates(x, y, value):\n    i = (value - 1) // y + 1\n    j = (value - 1) % y + 1\n    return i, j\n\ndef is_adjacent(i1, j1, i2, j2):\n    return abs(i1 - i2) + abs(j1 - j2) == 1\n\n# Reading input\nn = int(input())\npath = list(map(int, input().split()))\n\n# Finding and printing the result\nresult, *dimensions = find_matrix_dimensions(n, path)\nif result == \"YES\":\n    print(result)\n    print(dimensions[0], dimensions[1])\nelse:\n    print(result)"}
{"solution": "def find_longest_subsequence(a, b):\n    if set(b).issubset(set(a)):\n        b_idx = 0\n        b_len = len(b)\n        subsequence = []\n        for char in a:\n            if b_idx < b_len and char == b[b_idx]:\n                subsequence.append(char)\n                b_idx += 1\n        return ''.join(subsequence) if subsequence else '-'\n    else:\n        return '-'\n\n# Read input\na = input().strip()\nb = input().strip()\n\n# Output the result\nprint(find_longest_subsequence(a, b))"}
{"solution": "n = int(input())\ns = input()\nstones = 0\nfor op in s:\n    if op == '+':\n        stones += 1\n    elif op == '-' and stones > 0:\n        stones -= 1\nprint(stones)"}
{"solution": "def max_kefir_liters(n, a, b, c):\n    if n < b:\n        return n // a\n    else:\n        return max((n - c) // (b - c), n // a)\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate and print the result\nprint(max_kefir_liters(n, a, b, c))"}
{"solution": "def card_game(n, k1, cards1, k2, cards2):\n    fights = 0\n    visited = set()\n    \n    while cards1 and cards2:\n        fight = (tuple(cards1), tuple(cards2))\n        if fight in visited:\n            return -1\n        visited.add(fight)\n        \n        card1 = cards1.pop(0)\n        card2 = cards2.pop(0)\n        fights += 1\n        \n        if card1 > card2:\n            cards1.append(card2)\n            cards1.append(card1)\n        else:\n            cards2.append(card1)\n            cards2.append(card2)\n    \n    winner = 1 if cards1 else 2\n    return fights, winner\n\n# Read input\nn = int(input())\nk1 = int(input())\ncards1 = list(map(int, input().split()))\nk2 = int(input())\ncards2 = list(map(int, input().split()))\n\n# Get result and print\nresult = card_game(n, k1, cards1, k2, cards2)\nif result == -1:\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    has_large_letter = any(c.isupper() for c in password)\n    has_small_letter = any(c.islower() for c in password)\n    has_digit = any(c.isdigit() for c in password)\n    if has_large_letter and has_small_letter and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\"\n\n# Read input\npassword = input().strip()\n\n# Check and print the result\nprint(check_password_complexity(password))"}
{"solution": "def min_exchanges(n, a, b):\n    from collections import Counter\n    \n    # Count the occurrences of each performance in both groups\n    count_a = Counter(a)\n    count_b = Counter(b)\n    \n    # Calculate the difference for each performance level\n    diff = {i: count_a[i] - count_b[i] for i in range(1, 6)}\n    \n    # Check if it's possible to balance the groups\n    if sum(diff.values()) != 0:\n        return -1\n    \n    # Calculate the minimum number of exchanges needed\n    exchanges = 0\n    for i in range(1, 6):\n        if diff[i] > 0:\n            exchanges += diff[i] // 2\n    \n    return exchanges\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Print the result\nprint(min_exchanges(n, a, b))"}
{"solution": "def can_reach_any_junction_from_any_other(n, m, horizontal_directions, vertical_directions):\n    # Check if there's at least one horizontal street that allows movement in both directions\n    horizontal_bidirectional = any(h == '>' for h in horizontal_directions) and any(h == '<' for h in horizontal_directions)\n    \n    # Check if there's at least one vertical street that allows movement in both directions\n    vertical_bidirectional = any(v == 'v' for v in vertical_directions) and any(v == '^' for v in vertical_directions)\n    \n    # If both horizontal and vertical streets have bidirectional movement, return \"YES\"\n    if horizontal_bidirectional and vertical_bidirectional:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nhorizontal_directions = input().strip()\nvertical_directions = input().strip()\n\n# Output the result\nprint(can_reach_any_junction_from_any_other(n, m, horizontal_directions, vertical_directions))"}
{"solution": "def can_make_false(n, args):\n    if n == 1:\n        if args[0] == '0':\n            return \"YES\\n0\"\n        else:\n            return \"NO\"\n    \n    if '0' not in args:\n        return \"NO\"\n    \n    if n == 2:\n        if args == ['1', '1']:\n            return \"NO\"\n        else:\n            return \"YES\\n(1->0)\"\n    \n    # Find the first '0' to make the expression false\n    first_zero_index = args.index('0')\n    \n    # If the first '0' is at the end, we need to handle it differently\n    if first_zero_index == n - 1:\n        return \"YES\\n\" + \"->\".join(args[:-1]) + \"->(1->0)\"\n    \n    # Otherwise, we can place the brackets to make the expression false\n    left_part = \"->\".join(args[:first_zero_index + 1])\n    right_part = \"->\".join(args[first_zero_index + 1:])\n    \n    return \"YES\\n({})->({})\".format(left_part, right_part)\n\n# Read input\nn = int(input().strip())\nargs = input().strip().split()\n\n# Output the result\nprint(can_make_false(n, args))"}
{"solution": "def process_variables(a, b):\n    while True:\n        if a == 0 or b == 0:\n            break\n        elif a >= 2 * b:\n            a %= 2 * b\n        elif b >= 2 * a:\n            b %= 2 * a\n        else:\n            break\n    return a, b\n\n# Read input\nn, m = map(int, input().split())\n\n# Process and output the result\na, b = process_variables(n, m)\nprint(a, b)"}
{"solution": "def count_k_divisible_numbers(k, a, b):\n    if a % k == 0:\n        start = a // k\n    else:\n        start = a // k + 1\n    end = b // k\n    return max(0, end - start + 1)\n\n# Read input\nk, a, b = map(int, input().split())\n\n# Output the result\nprint(count_k_divisible_numbers(k, a, b))"}
{"solution": "def find_kth_digit(k):\n    length = 0\n    i = 1\n    while True:\n        length += len(str(i))\n        if length >= k:\n            return str(i)[-1 - (length - k)]\n        i += 1\n\n# Read input\nk = int(input())\n\n# Output the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "def has_vasya_winning_strategy(n, s):\n    if n == 11:\n        return s[0] == '8'\n    if s[0] != '8':\n        return False\n    vasya_moves = (n - 11) // 2\n    for i in range(1, vasya_moves + 1):\n        if s[i] != '8':\n            return True\n    return False\n\nn = int(input())\ns = input()\n\nprint(\"YES\" if has_vasya_winning_strategy(n, s) else \"NO\")"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial(n):\n    f = 1\n    for i in range(1, n + 1):\n        f = (f * i) % MOD\n    return f\n\ndef binomial_coefficient(n, k):\n    if k > n:\n        return 0\n    result = factorial(n)\n    result = (result * pow(factorial(k), MOD - 2, MOD)) % MOD\n    result = (result * pow(factorial(n - k), MOD - 2, MOD)) % MOD\n    return result\n\ndef count_valid_permutations(n, x, pos):\n    less = x - 1\n    greater = n - x\n    left = 0\n    right = n\n    middle = 0\n    valid_less = 0\n    valid_greater = 0\n\n    while left < right:\n        middle = (left + right) // 2\n        if middle <= pos:\n            if middle < pos:\n                valid_less += 1\n            left = middle + 1\n        else:\n            valid_greater += 1\n            right = middle\n\n    if valid_less > less or valid_greater > greater:\n        return 0\n\n    return (binomial_coefficient(less, valid_less) * factorial(valid_less) *\n            binomial_coefficient(greater, valid_greater) * factorial(valid_greater) *\n            factorial(n - valid_less - valid_greater - 1)) % MOD\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Calculate and print the result\nprint(count_valid_permutations(n, x, pos))"}
{"solution": "def decrypt_message(s, k):\n    letters = []\n    wildcards = 0\n\n    for i, char in enumerate(s):\n        if char == '*' or char == '?':\n            wildcards += 1\n        else:\n            if i == 0 or s[i-1] not in ['*', '?']:\n                letters.append(char)\n            else:\n                continue\n\n    min_length = len(letters) - wildcards\n    max_length = len(letters) + sum(1 for c in letters if s[s.index(c) + 1] == '*') * (k - min_length)\n\n    if k < min_length or k > max_length:\n        return \"Impossible\"\n\n    if k == len(letters):\n        return ''.join(letters)\n\n    result = []\n    extra_needed = k - min_length\n\n    for i in range(len(letters)):\n        if s[i] in ['*', '?']:\n            continue\n        if s[i + 1] == '?' or (s[i + 1] == '*' and extra_needed == 0):\n            result.append(letters[i])\n        elif s[i + 1] == '*' and extra_needed > 0:\n            result.append(letters[i] * (1 + extra_needed))\n            extra_needed = 0\n        else:\n            result.append(letters[i])\n\n    return ''.join(result)\n\n# Read input\ns = input().strip()\nk = int(input().strip())\n\n# Output result\nprint(decrypt_message(s, k))"}
{"solution": "def min_turns_to_vertical(angle):\n    # Normalize the angle to be within [0, 360)\n    angle = angle % 360\n    if angle < 0:\n        angle += 360\n    \n    # Calculate the minimum number of turns needed\n    # Possible angles after 0, 1, 2, 3 turns of 90 degrees clockwise\n    possible_angles = [(angle - 90 * i) % 360 for i in range(4)]\n    # Find the minimum deviation from vertical (0 degrees)\n    min_deviation = min(possible_angles, key=lambda x: min(x, 360 - x))\n    # Return the number of turns needed to achieve the minimum deviation\n    return possible_angles.index(min_deviation)\n\n# Read input\nangle = int(input().strip())\n\n# Output the result\nprint(min_turns_to_vertical(angle))"}
{"solution": "def can_transform_spheres(a, b, c, x, y, z):\n    # Calculate the excess or deficit of each color\n    blue_diff = a - x\n    violet_diff = b - y\n    orange_diff = c - z\n\n    # Check if we have enough to cover deficits by converting excesses\n    if blue_diff < 0:\n        violet_diff += blue_diff // 2\n        orange_diff += blue_diff // 2\n    if violet_diff < 0:\n        blue_diff += violet_diff // 2\n        orange_diff += violet_diff // 2\n    if orange_diff < 0:\n        blue_diff += orange_diff // 2\n        violet_diff += orange_diff // 2\n\n    # If all deficits are covered or we have exactly the right amount, return \"Yes\"\n    if blue_diff >= 0 and violet_diff >= 0 and orange_diff >= 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Output result\nprint(can_transform_spheres(a, b, c, x, y, z))"}
{"solution": "def count_numbers(n, k, m):\n    # Initialize the count of valid numbers\n    count = 0\n    \n    # Helper function to calculate the number of valid suffixes for a given prefix\n    def valid_suffixes(prefix, length):\n        if length == 0:\n            return 1 if int(prefix) % k == 0 else 0\n        total = 0\n        for digit in range(10):\n            new_prefix = prefix + str(digit)\n            if int(new_prefix) % k == 0:\n                total += valid_suffixes('', length - 1)\n        return total\n    \n    # Iterate over all possible prefixes of length n-1\n    for prefix_length in range(n):\n        for prefix_digit in range(1, 10):  # Prefix cannot start with 0\n            count += valid_suffixes(str(prefix_digit), n - 1 - prefix_length)\n            count %= m\n    \n    return count\n\n# Read input\nn, k, m = map(int, input().split())\n\n# Output the result\nprint(count_numbers(n, k, m))"}
{"solution": "def max_team_size(l, r, a):\n    while a > 0:\n        if l < r:\n            l += 1\n        else:\n            r += 1\n        a -= 1\n    return min(l, r) * 2\n\n# Read input\nl, r, a = map(int, input().split())\n\n# Output the result\nprint(max_team_size(l, r, a))"}
{"solution": "def min_moves_to_pick_coins(n, k):\n    if k == 1 or k == n:\n        return n * 3 - 2\n    else:\n        return min(k * 3 - 2, (n - k) * 3 + 1) + (n - 1) * 3\n\nn, k = map(int, input().split())\nprint(min_moves_to_pick_coins(n, k))"}
{"solution": "def min_tallest_tower(n, m):\n    max_height = 0\n    two_block_heights = [2 * (i + 1) for i in range(n)]\n    three_block_heights = [3 * (i + 1) for i in range(m)]\n    \n    all_heights = set(two_block_heights + three_block_heights)\n    \n    while len(all_heights) < n + m:\n        if len(two_block_heights) < n:\n            next_height = two_block_heights[-1] + 2\n            while next_height in all_heights:\n                next_height += 2\n            two_block_heights.append(next_height)\n            all_heights.add(next_height)\n        if len(three_block_heights) < m:\n            next_height = three_block_heights[-1] + 3\n            while next_height in all_heights:\n                next_height += 3\n            three_block_heights.append(next_height)\n            all_heights.add(next_height)\n    \n    return max(all_heights)\n\n# Read input\nn, m = map(int, input().split())\n\n# Output the result\nprint(min_tallest_tower(n, m))"}
{"solution": "def can_play_fair(n, cards):\n    card_counts = {}\n    for card in cards:\n        if card in card_counts:\n            card_counts[card] += 1\n        else:\n            card_counts[card] = 1\n    \n    # Check if there are exactly two numbers with counts that sum up to n\n    counts = list(card_counts.values())\n    if len(counts) != 2 or sum(counts) != n or n // 2 not in counts:\n        return \"NO\", None, None\n    \n    # Find the two distinct numbers\n    petya_number = vasya_number = None\n    for number, count in card_counts.items():\n        if count == n // 2:\n            if petya_number is None:\n                petya_number = number\n            else:\n                vasya_number = number\n    \n    return \"YES\", petya_number, vasya_number\n\n# Read input\nn = int(input())\ncards = [int(input()) for _ in range(n)]\n\n# Determine if the game can be fair and print the result\nresult, petya, vasya = can_play_fair(n, cards)\nprint(result)\nif result == \"YES\":\n    print(petya, vasya)"}
{"solution": "def can_place_soldiers(n, k, groups):\n    seats_per_row = 8\n    total_seats = n * seats_per_row\n    total_soldiers = sum(groups)\n    \n    if total_soldiers > total_seats:\n        return \"NO\"\n    \n    # Calculate the maximum number of soldiers that can be placed without neighbors\n    max_non_neighboring_seats = n * 5  # 5 pairs of non-neighboring seats per row\n    \n    # Check if the total number of soldiers can fit in non-neighboring seats\n    if total_soldiers <= max_non_neighboring_seats:\n        return \"YES\"\n    \n    # Calculate the remaining soldiers that need to be placed in neighboring seats\n    remaining_soldiers = total_soldiers - max_non_neighboring_seats\n    \n    # Check if the remaining soldiers can fit in the remaining seats (neighboring seats)\n    if remaining_soldiers <= (total_seats - max_non_neighboring_seats):\n        return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Output result\nprint(can_place_soldiers(n, k, groups))"}
{"solution": "def find_optimal_t_and_cost(n, a):\n    min_cost = float('inf')\n    optimal_t = 0\n    \n    for t in range(1, 101):\n        cost = 0\n        for length in a:\n            if abs(length - t) > 1:\n                cost += abs(length - t) - 1\n        if cost < min_cost:\n            min_cost = cost\n            optimal_t = t\n    \n    return optimal_t, min_cost\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Finding and printing the result\nt, cost = find_optimal_t_and_cost(n, a)\nprint(t, cost)"}
{"solution": "def min_square_side(n, m, sky_map):\n    min_i = n\n    max_i = 0\n    min_j = m\n    max_j = 0\n    \n    for i in range(n):\n        for j in range(m):\n            if sky_map[i][j] == '*':\n                if i < min_i:\n                    min_i = i\n                if i > max_i:\n                    max_i = i\n                if j < min_j:\n                    min_j = j\n                if j > max_j:\n                    max_j = j\n    \n    return max(max_i - min_i + 1, max_j - min_j + 1)\n\n# Reading input\nn, m = map(int, input().split())\nsky_map = [input() for _ in range(n)]\n\n# Getting the result\nresult = min_square_side(n, m, sky_map)\n\n# Printing the result\nprint(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef modinv(a, m):\n    return pow(a, m - 2, m)\n\ndef solve(n, k, a):\n    if sorted(a) == a:\n        return 1\n    if k == 1:\n        return 0\n    \n    # Count the number of 0s and 1s\n    zeros = a.count(0)\n    ones = n - zeros\n    \n    # If there's only one type of number, the array will always be sorted\n    if zeros == 0 or ones == 0:\n        return 1\n    \n    # Calculate the number of ways to sort the array\n    dp = [[0] * (zeros + 1) for _ in range(zeros + 1)]\n    dp[0][0] = 1\n    for i in range(1, zeros + 1):\n        dp[i][0] = dp[i - 1][0] * modinv(i, MOD) % MOD\n        for j in range(1, i + 1):\n            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) * modinv(2, MOD) % MOD\n    \n    # Calculate the probability\n    prob = 0\n    for i in range(zeros + 1):\n        prob = (prob + dp[zeros][i] * pow(modinv(2, MOD), k, MOD) % MOD * modinv(zeros - i, MOD) % MOD) % MOD\n    \n    return prob\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Solve the problem and print the result\nprint(solve(n, k, a))"}
{"solution": "def min_seconds_to_devolve(x, y):\n    if x == y:\n        return 0\n    if y == 1:\n        return x - 1\n    return (x - y) + (y - 1)\n\n# Read input\nx, y = map(int, input().split())\n\n# Calculate and print the result\nprint(min_seconds_to_devolve(x, y))"}
{"solution": "def min_norm_of_difference(a, b, c, d):\n    # Calculate the determinant of A\n    det_A = a * d - b * c\n    \n    # If A is already degenerate, return 0\n    if det_A == 0:\n        return 0.0\n    \n    # Calculate the minimum possible value of ||A - B||\n    # by finding the minimum absolute difference that makes the determinant zero\n    # We have two cases to consider: changing a or changing d\n    min_norm = float('inf')\n    \n    # Case 1: Change a to make the determinant zero\n    if d != 0:\n        new_a = b * c / d\n        min_norm = min(min_norm, abs(a - new_a))\n    \n    # Case 2: Change d to make the determinant zero\n    if a != 0:\n        new_d = b * c / a\n        min_norm = min(min_norm, abs(d - new_d))\n    \n    # Case 3: Change b to make the determinant zero\n    if c != 0:\n        new_b = a * d / c\n        min_norm = min(min_norm, abs(b - new_b))\n    \n    # Case 4: Change c to make the determinant zero\n    if b != 0:\n        new_c = a * d / b\n        min_norm = min(min_norm, abs(c - new_c))\n    \n    return min_norm\n\n# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Output the result\nprint(\"{:.10f}\".format(min_norm_of_difference(a, b, c, d)))"}
{"solution": "def restaurant_service_denial(n, a, b, groups):\n    denied_count = 0\n    one_seater_tables = a\n    two_seater_tables = b\n    two_seater_tables_with_one_person = 0\n\n    for group in groups:\n        if group == 1:\n            if one_seater_tables > 0:\n                one_seater_tables -= 1\n            elif two_seater_tables > 0:\n                two_seater_tables -= 1\n                two_seater_tables_with_one_person += 1\n            elif two_seater_tables_with_one_person > 0:\n                two_seater_tables_with_one_person -= 1\n            else:\n                denied_count += 1\n        elif group == 2:\n            if two_seater_tables > 0:\n                two_seater_tables -= 1\n            else:\n                denied_count += 2\n\n    return denied_count\n\n# Reading input\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Output the result\nprint(restaurant_service_denial(n, a, b, groups))"}
{"solution": "def calculate_failed_students(A, B, C, N):\n    # Calculate the total number of students who celebrated\n    total_celebrated = A + B - C\n    # If the total number of students who celebrated is greater than or equal to N,\n    # or if any of the inputs are invalid (less than 0 or greater than N), return -1\n    if total_celebrated >= N or A < 0 or B < 0 or C < 0 or N < 0 or C > A or C > B:\n        return -1\n    # Calculate the number of students who didn't pass the exam\n    failed_students = N - total_celebrated\n    # If the number of failed students is less than 1 (since Vasya didn't pass), return -1\n    if failed_students < 1:\n        return -1\n    return failed_students\n\n# Read input\nA, B, C, N = map(int, input().split())\n\n# Output the result\nprint(calculate_failed_students(A, B, C, N))"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_pow(base, exponent, modulus):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % modulus\n        base = (base * base) % modulus\n        exponent //= 2\n    return result\n\ndef expected_dresses(x, k):\n    if x == 0:\n        return 0\n    # Calculate the expected number of dresses after k months\n    # The formula is derived from the problem statement\n    # E(x, k) = x * (2^(k+1) - 2^k + 1)\n    two_pow_k_plus_1 = mod_pow(2, k + 1, MOD)\n    two_pow_k = mod_pow(2, k, MOD)\n    expected = (x * (two_pow_k_plus_1 - two_pow_k + 1)) % MOD\n    return expected\n\n# Read input\nx, k = map(int, input().split())\n\n# Print output\nprint(expected_dresses(x, k))"}
{"solution": "MOD = 998244353\n\ndef modinv(a, m):\n    return pow(a, m - 2, m)\n\ndef solve(n, ranges):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    total_ways = 1\n    for i in range(1, n + 1):\n        l, r = ranges[i - 1]\n        total_ways = total_ways * (r - l + 1) % MOD\n        for j in range(i + 1):\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * (r - l + 1)) % MOD\n            if j < i:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j] * max(0, min(r, ranges[i - 2][1]) - max(l, ranges[i - 2][0]) + 1)) % MOD\n    \n    no_inversions = dp[n][n // 2]\n    return no_inversions * modinv(total_ways, MOD) % MOD\n\nn = int(input())\nranges = [list(map(int, input().split())) for _ in range(n)]\nprint(solve(n, ranges))"}
{"solution": "def count_ways_to_cut_stick(n):\n    if n % 2 != 0:\n        return 0\n    half_n = n // 2\n    if half_n % 2 == 0:\n        return half_n // 2 - 1\n    else:\n        return half_n // 2\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(count_ways_to_cut_stick(n))"}
{"solution": "def max_kvass_level(n, s, v):\n    if sum(v) < s:\n        return -1\n    \n    min_kvass = min(v)\n    total_kvass_to_pour = s\n    \n    for i in range(n):\n        total_kvass_to_pour -= (v[i] - min_kvass)\n        v[i] = min_kvass\n    \n    if total_kvass_to_pour <= 0:\n        return min_kvass\n    \n    remaining_kvass = total_kvass_to_pour\n    min_kvass -= (remaining_kvass + n - 1) // n\n    \n    return min_kvass\n\nn, s = map(int, input().split())\nv = list(map(int, input().split()))\n\nprint(max_kvass_level(n, s, v))"}
{"solution": "def caterpillar_days_to_apple(h_1, h_2, a, b):\n    if a <= b and h_1 + 8 * a < h_2:\n        return -1\n    if h_1 + 8 * a >= h_2:\n        return 0\n    \n    height_after_day = h_1 + 8 * a\n    height_after_night = height_after_day - 4 * b\n    days = 1\n    \n    while height_after_day < h_2:\n        height_after_day = height_after_night + 12 * a\n        if height_after_day >= h_2:\n            return days\n        height_after_night = height_after_day - 12 * b\n        days += 1\n    \n    return days\n\n# Read input\nh_1, h_2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(caterpillar_days_to_apple(h_1, h_2, a, b))"}
{"solution": "def max_joy_units(C, Hr, Hb, Wr, Wb):\n    max_joy = 0\n    # Check all possible combinations of red and blue candies\n    for i in range(C // Wr + 1):  # Number of red candies Om Nom can eat\n        if i * Wr <= C:  # Check if Om Nom can eat i red candies\n            blue_candies = (C - i * Wr) // Wb  # Calculate how many blue candies Om Nom can eat\n            joy = i * Hr + blue_candies * Hb  # Calculate total joy units\n            max_joy = max(max_joy, joy)  # Update max joy units if current joy is greater\n    return max_joy\n\n# Read input\nC, Hr, Hb, Wr, Wb = map(int, input().split())\n\n# Calculate and print the maximum number of joy units\nprint(max_joy_units(C, Hr, Hb, Wr, Wb))"}
{"solution": "def min_steps_to_reach_target(x1, y1, x2, y2):\n    return max(abs(x2 - x1), abs(y2 - y1))\n\n# Read input\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\n# Calculate and print the result\nprint(min_steps_to_reach_target(x1, y1, x2, y2))"}
{"solution": "def predict_vote_outcome(n, employees):\n    depublicans = employees.count('D')\n    remocrats = n - depublicans\n    \n    while depublicans > 0 and remocrats > 0:\n        for employee in employees:\n            if employee == 'D':\n                if depublicans > 0:\n                    if remocrats > 0:\n                        remocrats -= 1\n                    else:\n                        return 'D'\n                else:\n                    continue\n            elif employee == 'R':\n                if remocrats > 0:\n                    if depublicans > 0:\n                        depublicans -= 1\n                    else:\n                        return 'R'\n                else:\n                    continue\n    \n    return 'D' if depublicans > 0 else 'R'\n\n# Read input\nn = int(input())\nemployees = input().strip()\n\n# Predict the outcome\nprint(predict_vote_outcome(n, employees))"}
{"solution": "import math\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef count_tv_sets(a, b, x, y):\n    # Find the greatest common divisor of x and y\n    g = gcd(x, y)\n    \n    # Reduce the aspect ratio to its simplest form\n    x //= g\n    y //= g\n    \n    # Calculate the maximum width and height that fit the aspect ratio\n    max_width = a // x\n    max_height = b // y\n    \n    # The number of different variants is the minimum of max_width and max_height\n    return min(max_width, max_height)\n\n# Read input\na, b, x, y = map(int, input().split())\n\n# Calculate and print the result\nprint(count_tv_sets(a, b, x, y))"}
{"solution": "import math\n\ndef prime_factors(n):\n    factors = {}\n    d = 2\n    while d * d <= n:\n        while (n % d) == 0:\n            factors[d] = factors.get(d, 0) + 1\n            n //= d\n        d += 1\n    if n > 1:\n       factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef count_factor_in_factorial(n, p):\n    count = 0\n    while n:\n        n //= p\n        count += n\n    return count\n\ndef count_trailing_zeros(n, b):\n    factors = prime_factors(b)\n    min_zeros = float('inf')\n    for p, exp in factors.items():\n        count = count_factor_in_factorial(n, p)\n        min_zeros = min(min_zeros, count // exp)\n    return min_zeros\n\nn, b = map(int, input().split())\nprint(count_trailing_zeros(n, b))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(m, a, b):\n    MOD = 10**9 + 7\n    g = gcd(a, b)\n    max_reachable = (m // g) * g + g - 1 if m % g != 0 else m\n    dp = [0] * (max_reachable + 1)\n    dp[0] = 1\n    sum_dp = 1\n    result = 1\n    for i in range(1, max_reachable + 1):\n        if i >= a and dp[i - a] > 0:\n            dp[i] = dp[i - a] + (dp[i - b] if i >= b else 0)\n        elif i >= b and dp[i - b] > 0:\n            dp[i] = dp[i - b]\n        sum_dp += dp[i]\n        if i <= m:\n            result += sum_dp\n        else:\n            result += sum_dp - (i - m - 1) * dp[i]\n    return result\n\n# Read input\nm, a, b = map(int, input().split())\n\n# Solve the problem and print the result\nprint(solve(m, a, b))"}
{"solution": "def can_divide_into_odd_subsegments(n, sequence):\n    if n % 2 == 0:\n        return \"No\"\n    if sequence[0] % 2 == 0 or sequence[-1] % 2 == 0:\n        return \"No\"\n    return \"Yes\"\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Output result\nprint(can_divide_into_odd_subsegments(n, sequence))"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    if x1 == x2:\n        side_length = abs(y2 - y1)\n        x3, y3 = x1 + side_length, y1\n        x4, y4 = x2 + side_length, y2\n    elif y1 == y2:\n        side_length = abs(x2 - x1)\n        x3, y3 = x1, y1 + side_length\n        x4, y4 = x2, y2 + side_length\n    else:\n        if abs(x2 - x1) != abs(y2 - y1):\n            return -1\n        x3, y3 = x1, y2\n        x4, y4 = x2, y1\n    \n    return f\"{x3} {y3} {x4} {y4}\"\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\n\n# Find and print the remaining trees' coordinates\nprint(find_remaining_trees(x1, y1, x2, y2))"}
{"solution": "MOD = 1000000007\n\ndef calculate_fn(x, y, n):\n    # The sequence repeats every 6 numbers due to the given property\n    # f_1 = x, f_2 = y, f_3 = y - x, f_4 = -x, f_5 = -y, f_6 = x - y, f_7 = x (same as f_1)\n    sequence = [x, y, y - x, -x, -y, x - y]\n    return sequence[(n - 1) % 6] % MOD\n\n# Read input\nx, y = map(int, input().split())\nn = int(input())\n\n# Calculate and print the result\nprint(calculate_fn(x, y, n))"}
{"solution": "def split_array(n, A):\n    if all(a == 0 for a in A):\n        return \"NO\"\n    \n    if sum(A) != 0:\n        return \"YES\\n1\\n1 {}\".format(n)\n    \n    for i in range(n):\n        if sum(A[:i+1]) != 0:\n            return \"YES\\n2\\n1 {}\\n{} {}\".format(i+1, i+2, n)\n    \n    return \"NO\"\n\nn = int(input())\nA = list(map(int, input().split()))\n\nresult = split_array(n, A)\nprint(result)"}
{"solution": "MOD = 1000000009\n\ndef min_score(n, m, k):\n    # Calculate the number of bonus opportunities Manao has\n    bonus_opportunities = n // k\n    \n    # If Manao answered more questions than the bonus opportunities,\n    # he could have potentially doubled his score for some answers\n    if m > bonus_opportunities:\n        # Calculate the number of times Manao can double his score\n        double_times = (m - bonus_opportunities + k - 2) // (k - 1) - 1\n        \n        # Calculate the score from doubling\n        score_from_doubling = (pow(2, double_times + 1, MOD) - 2) * k % MOD\n        \n        # Calculate the remaining correct answers after doubling\n        remaining_correct = m - (double_times + 1) * k + k\n        \n        # Calculate the total score\n        total_score = (score_from_doubling + remaining_correct) % MOD\n    else:\n        # If Manao didn't have enough correct answers to trigger doubling,\n        # his score is simply the number of correct answers\n        total_score = m\n    \n    return total_score\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Print the output\nprint(min_score(n, m, k))"}
{"solution": "def is_divisible_by_8(n):\n    return int(n) % 8 == 0\n\ndef find_divisible_by_8(n):\n    # Check all possible combinations of the last three digits\n    for i in range(len(n)):\n        for j in range(i + 1, len(n)):\n            for k in range(j + 1, len(n)):\n                if is_divisible_by_8(n[i] + n[j] + n[k]):\n                    return \"YES\\n\" + n[i] + n[j] + n[k]\n    \n    # Check all possible combinations of the last two digits\n    for i in range(len(n)):\n        for j in range(i + 1, len(n)):\n            if is_divisible_by_8(n[i] + n[j]):\n                return \"YES\\n\" + n[i] + n[j]\n    \n    # Check all possible single digits\n    for i in range(len(n)):\n        if is_divisible_by_8(n[i]):\n            return \"YES\\n\" + n[i]\n    \n    return \"NO\"\n\n# Read input\nn = input().strip()\n\n# Find and print the result\nprint(find_divisible_by_8(n))"}
{"solution": "def restore_floor(n, m, memory):\n    possible_floors = set(range(1, 101))\n    \n    for k, f in memory:\n        new_possible_floors = set()\n        for floor_count in possible_floors:\n            if (k - 1) // floor_count + 1 == f:\n                new_possible_floors.add(floor_count)\n        possible_floors = new_possible_floors\n    \n    if len(possible_floors) == 1:\n        floor_count = next(iter(possible_floors))\n        return (n - 1) // floor_count + 1\n    else:\n        return -1\n\n# Read input\nn, m = map(int, input().split())\nmemory = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output the result\nprint(restore_floor(n, m, memory))"}
{"solution": "def max_bishwocks(board):\n    n = len(board[0])\n    dp = [0] * (n + 1)\n    for i in range(n):\n        count_empty = (1 if board[0][i] == '0' else 0) + (1 if board[1][i] == '0' else 0)\n        if i > 0:\n            count_empty += dp[i - 1]\n        dp[i + 1] = dp[i]\n        if count_empty >= 3:\n            dp[i + 1] = max(dp[i + 1], dp[i - 1] + 1)\n            if i > 1 and board[0][i - 1] == '0' and board[0][i - 2] == '0' and board[1][i - 1] == '0' and board[1][i - 2] == '0':\n                dp[i + 1] = max(dp[i + 1], dp[i - 2] + 2)\n    return dp[n]\n\n# Read input\nboard = [input().strip(), input().strip()]\n\n# Output the result\nprint(max_bishwocks(board))"}
{"solution": "def max_pretty_set_size(n, s):\n    max_count = 0\n    current_count = 0\n    current_letters = set()\n    \n    for i in range(n):\n        if s[i].islower():\n            if s[i] not in current_letters:\n                current_letters.add(s[i])\n                current_count += 1\n                max_count = max(max_count, current_count)\n        else:\n            current_count = 0\n            current_letters.clear()\n    \n    return max_count\n\n# Reading input\nn = int(input())\ns = input()\n\n# Output the result\nprint(max_pretty_set_size(n, s))"}
{"solution": "def max_difference(n, a):\n    a.sort()\n    B = sum(a[n//2:])\n    C = sum(a[:n//2])\n    return B - C\n\nn = int(input())\na = list(map(int, input().split()))\nprint(max_difference(n, a))"}
{"solution": "def min_refuels(a, b, f, k):\n    if b < f or b < (a - f):\n        return -1\n    if k > 1 and b < 2 * (a - f):\n        return -1\n    if k > 2 and b < 2 * f:\n        return -1\n\n    fuel = b\n    refuels = 0\n    for journey in range(k):\n        if journey % 2 == 0:  # Going to a\n            if fuel < (a - f) and fuel < a:\n                fuel = b\n                refuels += 1\n            fuel -= a\n        else:  # Returning to 0\n            if fuel < f and fuel < a:\n                fuel = b\n                refuels += 1\n            fuel -= a\n\n    return refuels\n\n# Read input\na, b, f, k = map(int, input().split())\n\n# Output the result\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    for i in range(n // p + 1):\n        for j in range(n // q + 1):\n            if i * p + j * q == n:\n                result = []\n                for k in range(i):\n                    result.append(s[k * p:(k + 1) * p])\n                for k in range(j):\n                    result.append(s[i * p + k * q:i * p + (k + 1) * q])\n                return len(result), result\n    return -1, []\n\nn, p, q = map(int, input().split())\ns = input()\n\nk, result = split_string(n, p, q, s)\nif k == -1:\n    print(k)\nelse:\n    print(k)\n    for line in result:\n        print(line)"}
{"solution": "def can_reach_finish(n, m, s, d, obstacles):\n    obstacles.sort()\n    actions = []\n    current_position = 0\n    \n    i = 0\n    while i < len(obstacles):\n        # Find the next obstacle that we need to jump over\n        next_obstacle = obstacles[i]\n        \n        # Check if we can run to the next obstacle without jumping\n        if next_obstacle - current_position >= s:\n            actions.append(f\"RUN {next_obstacle - current_position}\")\n            current_position = next_obstacle\n        else:\n            # Find the furthest obstacle we can jump over\n            jump_end = next_obstacle - 1\n            while i + 1 < len(obstacles) and obstacles[i + 1] - obstacles[i] <= d:\n                i += 1\n                jump_end = obstacles[i] - 1\n            \n            # Check if we can jump over the furthest obstacle\n            if jump_end - current_position >= d:\n                actions.append(f\"JUMP {jump_end - current_position}\")\n                current_position = jump_end\n            else:\n                return \"IMPOSSIBLE\"\n        \n        i += 1\n    \n    # After jumping over all obstacles, check if we can run to the finish\n    if m - current_position > 0:\n        actions.append(f\"RUN {m - current_position}\")\n    \n    return \"\\n\".join(actions)\n\n# Read input\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\n# Output result\nprint(can_reach_finish(n, m, s, d, obstacles))"}
{"solution": "def count_pairs(s, x):\n    if (s - x) % 2 != 0:\n        return 0\n    a_plus_b = s\n    a_xor_b = x\n    a_and_b = (a_plus_b - a_xor_b) // 2\n    \n    if a_and_b < 0 or a_xor_b < 0 or a_and_b & a_xor_b != 0:\n        return 0\n    \n    count = 1 << (bin(a_xor_b).count('1'))\n    \n    if (a_plus_b - a_xor_b) == a_xor_b:\n        count -= 2\n    \n    return count\n\ns, x = map(int, input().split())\nprint(count_pairs(s, x))"}
{"solution": "def min_actions_to_turn_over_skewers(n, k):\n    actions = []\n    for i in range(1, n + 1, 2 * k + 1):\n        actions.append(i + k if i + k <= n else i)\n    return len(actions), actions\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nnum_actions, actions = min_actions_to_turn_over_skewers(n, k)\nprint(num_actions)\nprint(' '.join(map(str, actions)))"}
{"solution": "def min_operations_to_square(n):\n    n_str = str(n)\n    length = len(n_str)\n    min_ops = float('inf')\n\n    for i in range(1, 2**length):\n        candidate = ''\n        for j in range(length):\n            if i & (1 << j):\n                candidate += n_str[j]\n        if candidate and candidate[0] != '0':\n            candidate_int = int(candidate)\n            if candidate_int ** 0.5 == int(candidate_int ** 0.5):\n                min_ops = min(min_ops, length - len(candidate))\n\n    return min_ops if min_ops != float('inf') else -1\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(min_operations_to_square(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_permutations(n):\n    if n == 2:\n        return 1\n    if n == 3:\n        return 4\n    \n    # For n > 3, the maximum value of f(p) is 2, and the number of such permutations\n    # is (n-1)! because we can place any number at the first position and then\n    # arrange the remaining n-1 numbers in any order.\n    result = 1\n    for i in range(1, n):\n        result = (result * i) % MOD\n    return result\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the result\nprint(count_permutations(n))"}
{"solution": "def min_jump_ability(s):\n    vowels = set('AEIOUY')\n    last_vowel_index = -1\n    max_gap = 0\n    \n    for i, char in enumerate(s):\n        if char in vowels:\n            gap = i - last_vowel_index\n            max_gap = max(max_gap, gap)\n            last_vowel_index = i\n    \n    # Consider the gap from the last vowel to the end of the string\n    max_gap = max(max_gap, len(s) - last_vowel_index)\n    \n    return max_gap\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(min_jump_ability(s))"}
{"solution": "def can_distribute_equally(a1, a2, a3, a4):\n    total_candies = a1 + a2 + a3 + a4\n    if total_candies % 2 != 0:\n        return \"NO\"\n    half_candies = total_candies // 2\n    if a1 + a2 == half_candies or a1 + a3 == half_candies or a1 + a4 == half_candies:\n        return \"YES\"\n    if a2 + a3 == half_candies or a2 + a4 == half_candies or a3 + a4 == half_candies:\n        return \"YES\"\n    return \"NO\"\n\n# Read input\na1, a2, a3, a4 = map(int, input().split())\n\n# Output result\nprint(can_distribute_equally(a1, a2, a3, a4))"}
{"solution": "def optimal_pie_distribution(N, slice_sizes):\n    alice_total = 0\n    bob_total = 0\n    left = 0\n    right = N - 1\n    alice_turn = False\n\n    while left <= right:\n        if alice_turn:\n            alice_total += slice_sizes[left]\n            left += 1\n        else:\n            bob_total += slice_sizes[left]\n            left += 1\n            alice_turn = True\n\n        if left <= right:\n            if alice_turn:\n                if slice_sizes[right] > slice_sizes[left]:\n                    alice_total += slice_sizes[right]\n                    right -= 1\n                else:\n                    left += 1\n            else:\n                if slice_sizes[right] > slice_sizes[left]:\n                    bob_total += slice_sizes[right]\n                    right -= 1\n                else:\n                    left += 1\n                    alice_turn = True\n\n    return alice_total, bob_total\n\n# Read input\nN = int(input())\nslice_sizes = list(map(int, input().split()))\n\n# Calculate and print the result\nalice_total, bob_total = optimal_pie_distribution(N, slice_sizes)\nprint(alice_total, bob_total)"}
{"solution": "def min_variables_needed(n, sequence):\n    sequence.sort()\n    if sequence[0] != 1:\n        return -1\n    for i in range(1, n):\n        if sequence[i] > 2 * sequence[i - 1]:\n            return -1\n    return 2\n\nn = int(input())\nsequence = list(map(int, input().split()))\nprint(min_variables_needed(n, sequence))"}
{"solution": "def game_winner(n, piles):\n    piles.sort()\n    if piles[n//2-1] == piles[n//2]:\n        return \"Bob\"\n    return \"Alice\"\n\nn = int(input())\npiles = list(map(int, input().split()))\nprint(game_winner(n, piles))"}
{"solution": "def can_make_equal(n, arr):\n    unique_values = set(arr)\n    if len(unique_values) > 3:\n        return \"NO\"\n    if len(unique_values) == 1:\n        return \"YES\"\n    if len(unique_values) == 2:\n        return \"YES\"\n    # If there are 3 unique values, check if one is the sum of the other two\n    sorted_values = sorted(unique_values)\n    if sorted_values[1] - sorted_values[0] == sorted_values[2] - sorted_values[1]:\n        return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output result\nprint(can_make_equal(n, arr))"}
{"solution": "def max_non_overlapping_substring_length(N, S):\n    max_len = 0\n    for len in range(1, N):\n        seen = set()\n        for i in range(N - len + 1):\n            substring = S[i:i+len]\n            if substring in seen:\n                max_len = len\n                break\n            seen.add(substring)\n    return max_len\n\n# Read input\nN = int(input())\nS = input()\n\n# Output the result\nprint(max_non_overlapping_substring_length(N, S))"}
{"solution": "def min_time_to_reach(n, a):\n    if a % 2 == 1:\n        return (a + 1) // 2\n    else:\n        return (n - a) // 2 + 1\n\n# Read input\nn, a = map(int, input().split())\n\n# Output the result\nprint(min_time_to_reach(n, a))"}
{"solution": "def can_select_knights(n, m, colors, k_counts):\n    for start in range(n - sum(k_counts) + 1):\n        end = start + sum(k_counts)\n        interval_colors = colors[start:end]\n        if all(interval_colors.count(color + 1) == count for color, count in enumerate(k_counts)):\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\nk_counts = list(map(int, input().split()))\n\n# Output result\nprint(can_select_knights(n, m, colors, k_counts))"}
{"solution": "n = int(input())\nmishka_wins = 0\nchris_wins = 0\n\nfor _ in range(n):\n    m, c = map(int, input().split())\n    if m > c:\n        mishka_wins += 1\n    elif c > m:\n        chris_wins += 1\n\nif mishka_wins > chris_wins:\n    print(\"Mishka\")\nelif chris_wins > mishka_wins:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")"}
{"solution": "def is_valid_minesweeper_field(n, m, field):\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                continue\n            bomb_count = 0\n            for x in range(max(0, i - 1), min(n, i + 2)):\n                for y in range(max(0, j - 1), min(m, j + 2)):\n                    if field[x][y] == '*':\n                        bomb_count += 1\n            if (field[i][j] == '.' and bomb_count != 0) or (field[i][j].isdigit() and int(field[i][j]) != bomb_count):\n                return \"NO\"\n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\n# Output result\nprint(is_valid_minesweeper_field(n, m, field))"}
{"solution": "import math\n\ndef find_minimal_k(n):\n    total_eaten_by_vasya = 0\n    left = n\n    k = 0\n    while left > 0:\n        k = max(k, math.ceil(left / 11))\n        vasya_eats = min(left, k)\n        total_eaten_by_vasya += vasya_eats\n        left -= vasya_eats\n        petya_eats = left // 10\n        left -= petya_eats\n        if total_eaten_by_vasya >= n / 2:\n            return k\n    return k\n\nn = int(input().strip())\nprint(find_minimal_k(n))"}
{"solution": "def can_equalize_links(necklace):\n    pearls = necklace.count('o')\n    links = necklace.count('-')\n    \n    if pearls == 0 or links % pearls == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nnecklace = input().strip()\n\n# Output result\nprint(can_equalize_links(necklace))"}
{"solution": "def max_pillows_for_frodo(n, m, k):\n    left = 1\n    right = m\n    while left < right:\n        mid = (left + right + 1) // 2\n        if m - mid >= (k - 1) * (mid - 1) + (n - k) * (mid - 1) + (mid - 1):\n            left = mid\n        else:\n            right = mid - 1\n    return left\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Output the result\nprint(max_pillows_for_frodo(n, m, k))"}
{"solution": "def max_subarray_cost(n, m, k, a):\n    max_cost = 0\n    current_sum = 0\n    penalty = 0\n    for i in range(n):\n        current_sum += a[i]\n        penalty = k * ((i - l + 1) // m + 1)\n        while current_sum - penalty < 0:\n            current_sum -= a[l]\n            l += 1\n            penalty = k * ((i - l + 1) // m + 1)\n        max_cost = max(max_cost, current_sum - penalty)\n    return max_cost\n\n# Read input\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_subarray_cost(n, m, k, a))"}
{"solution": "def longest_polyline(n, m):\n    if n == 0:\n        return [0, 1], [0, m], [0, 0], [0, m-1]\n    elif m == 0:\n        return [1, 0], [n, 0], [0, 0], [n-1, 0]\n    else:\n        # Calculate the maximum possible length by considering the diagonal and edges\n        diagonal_length = ((n ** 2 + m ** 2) ** 0.5)\n        edge_length = n + m\n        \n        # If the diagonal is longer than or equal to the sum of two edges, choose the diagonal\n        if diagonal_length >= edge_length:\n            return [0, 0], [n, m], [n, 0], [0, m]\n        else:\n            # Otherwise, choose the edges\n            return [0, m], [n, 0], [0, 0], [n, m]\n\nn, m = map(int, input().split())\npoints = longest_polyline(n, m)\nfor point in points:\n    print(point[0], point[1])"}
{"solution": "def restore_number(shuffled, remembered):\n    from collections import Counter\n    \n    # Count the digits in the shuffled string and the remembered substring\n    shuffled_count = Counter(shuffled)\n    remembered_count = Counter(remembered)\n    \n    # Find the number of digits in the original number n\n    k = len(shuffled) - len(remembered)\n    \n    # Function to check if a number can be formed with the given counts\n    def can_form_number(num_count):\n        for digit, count in num_count.items():\n            if shuffled_count[digit] < count:\n                return False\n        return True\n    \n    # Start with the smallest possible number and increment until we find a valid one\n    for num_len in range(1, k + 1):\n        for num in range(10**(num_len - 1), 10**num_len):\n            if len(str(num)) == num_len and can_form_number(Counter(str(num)) + remembered_count):\n                # Check if we can form the remembered substring with the remaining digits\n                remaining_count = shuffled_count - Counter(str(num)) - remembered_count\n                if all(remaining_count[digit] >= 0 for digit in remaining_count):\n                    # Check if the remaining digits can form the remembered substring\n                    if remembered in ''.join(sorted((Counter(str(num)) + remaining_count).elements())):\n                        return str(num) + remembered\n    \n    return \"No solution found\"\n\n# Read input\nshuffled = input().strip()\nremembered = input().strip()\n\n# Output the result\nprint(restore_number(shuffled, remembered))"}
{"solution": "def check_temperatures(n, m, min_temp, max_temp, reported_temps):\n    if max_temp not in reported_temps:\n        if m < n:\n            reported_temps.append(max_temp)\n            m += 1\n        else:\n            return 'Incorrect'\n    if min_temp not in reported_temps:\n        if m < n:\n            reported_temps.append(min_temp)\n            m += 1\n        else:\n            return 'Incorrect'\n    return 'Correct'\n\n# Read input\nn, m, min_temp, max_temp = map(int, input().split())\nreported_temps = list(map(int, input().split()))\n\n# Check and print the result\nprint(check_temperatures(n, m, min_temp, max_temp, reported_temps))"}
{"solution": "def trailing_zeroes(n):\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count\n\ndef find_n_with_m_zeroes(m):\n    low, high = 0, 5 * m\n    while low < high:\n        mid = (low + high) // 2\n        if trailing_zeroes(mid) < m:\n            low = mid + 1\n        else:\n            high = mid\n    \n    result = []\n    while trailing_zeroes(low) == m:\n        result.append(low)\n        low += 1\n    \n    return result\n\nm = int(input().strip())\nn_values = find_n_with_m_zeroes(m)\nprint(len(n_values))\nif len(n_values) > 0:\n    print(' '.join(map(str, n_values)))"}
{"solution": "from heapq import heappop, heappush\n\ndef dijkstra(graph, start, n):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            if max(d, weight) < dist[v]:\n                dist[v] = max(d, weight)\n                heappush(pq, (dist[v], v))\n    return dist\n\ndef solve(n, m, k, special_vertices, edges):\n    graph = {i: [] for i in range(1, n + 1)}\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    distances = []\n    for sv in special_vertices:\n        dist = dijkstra(graph, sv, n)\n        max_dist = max(dist[v] for v in special_vertices)\n        distances.append(max_dist)\n    \n    return distances\n\n# Read input\nn, m, k = map(int, input().split())\nspecial_vertices = list(map(int, input().split()))\nedges = [list(map(int, input().split())) for _ in range(m)]\n\n# Solve the problem\nresult = solve(n, m, k, special_vertices, edges)\n\n# Print the output\nprint(' '.join(map(str, result)))"}
{"solution": "def find_initial_position(n, x):\n    # The pattern of swaps repeats every 6 moves, so we can reduce n modulo 6\n    n %= 6\n    \n    # Simulate the swaps for the reduced number of moves\n    for i in range(n, 0, -1):\n        if i % 2 == 1:\n            # Odd move: swap left (0) and middle (1)\n            if x == 0:\n                x = 1\n            elif x == 1:\n                x = 0\n        else:\n            # Even move: swap middle (1) and right (2)\n            if x == 1:\n                x = 2\n            elif x == 2:\n                x = 1\n    \n    return x\n\n# Read input\nn = int(input())\nx = int(input())\n\n# Find and print the initial position\nprint(find_initial_position(n, x))"}
{"solution": "def rectangles_form_square(n, rectangles):\n    min_x = min(rect[0] for rect in rectangles)\n    max_x = max(rect[2] for rect in rectangles)\n    min_y = min(rect[1] for rect in rectangles)\n    max_y = max(rect[3] for rect in rectangles)\n    \n    side_length = max(max_x - min_x, max_y - min_y)\n    if side_length != max_x - min_x or side_length != max_y - min_y:\n        return \"NO\"\n    \n    total_area = sum((rect[2] - rect[0]) * (rect[3] - rect[1]) for rect in rectangles)\n    if total_area == side_length * side_length:\n        return \"YES\"\n    else:\n        return \"NO\"\n\nn = int(input().strip())\nrectangles = [list(map(int, input().strip().split())) for _ in range(n)]\nprint(rectangles_form_square(n, rectangles))"}
{"solution": "def count_really_big_numbers(n, s):\n    count = 0\n    for x in range(1, n + 1):\n        if x - sum(int(digit) for digit in str(x)) >= s:\n            count += 1\n    return count\n\n# Read input\nn, s = map(int, input().split())\n\n# Output the result\nprint(count_really_big_numbers(n, s))"}
{"solution": "def can_cover_with_two_lines(n, points):\n    if n <= 2:\n        return \"YES\"\n    \n    # Sort points by x, then by y\n    points.sort()\n    \n    # Try to find two lines that can cover all points\n    # First line: through the first and last points\n    # Second line: through the second and second-to-last points\n    # Third line: through the third and third-to-last points\n    for i in range(3):\n        line1_points = set()\n        line2_points = set()\n        \n        # Define the first line\n        if i < 2:\n            for j in range(n):\n                if (points[j][0] - points[i][0]) * (points[n-1][1] - points[i][1]) == (points[j][1] - points[i][1]) * (points[n-1][0] - points[i][0]):\n                    line1_points.add(j)\n                else:\n                    line2_points.add(j)\n        else:\n            line1_points = set(range(n))\n        \n        # Check if the second line can cover all remaining points\n        if len(line2_points) <= 2:\n            return \"YES\"\n        \n        valid = True\n        for j in range(1, len(line2_points)):\n            if (points[list(line2_points)[j]][0] - points[list(line2_points)[0]][0]) * (points[list(line2_points)[1]][1] - points[list(line2_points)[0]][1]) != (points[list(line2_points)[j]][1] - points[list(line2_points)[0]][1]) * (points[list(line2_points)[1]][0] - points[list(line2_points)[0]][0]):\n                valid = False\n                break\n        \n        if valid:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input().strip())\npoints = [tuple(map(int, input().strip().split())) for _ in range(n)]\n\n# Output result\nprint(can_cover_with_two_lines(n, points))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_winning_games(a, b, k, t):\n    # Calculate the total possible scores after t turns\n    total_score_range = (2 * k + 1) ** t\n    \n    # Calculate the difference in starting scores\n    score_diff = b - a\n    \n    # Initialize the count of winning games\n    winning_games_count = 0\n    \n    # Iterate through all possible final score differences\n    for final_diff in range(-total_score_range + 1, total_score_range):\n        # Calculate the required score difference in each turn\n        required_turn_diff = (final_diff - score_diff) // (2 * t)\n        \n        # Check if the required turn difference is within the range\n        if -k <= required_turn_diff <= k:\n            # Calculate the number of ways to achieve the required turn difference\n            ways_to_achieve = min(k - required_turn_diff, k) + min(k + required_turn_diff, k) + 1\n            \n            # Multiply by the number of combinations for t turns\n            ways_to_achieve = (ways_to_achieve ** t) % MOD\n            \n            # Add to the total count of winning games\n            winning_games_count = (winning_games_count + ways_to_achieve) % MOD\n    \n    return winning_games_count\n\n# Read input\na, b, k, t = map(int, input().split())\n\n# Print the result\nprint(count_winning_games(a, b, k, t))"}
{"solution": "def can_measure(marks, distance):\n    for mark in marks:\n        if mark + distance in marks or mark - distance in marks:\n            return True\n    return False\n\ndef find_additional_marks(n, l, x, y, marks):\n    add_x, add_y = not can_measure(marks, x), not can_measure(marks, y)\n    additional_marks = []\n\n    if add_x and add_y:\n        for mark in marks:\n            if mark + x <= l and not can_measure(marks, mark + x):\n                if mark + x + y <= l or mark + x - y >= 0:\n                    return 1, [mark + x]\n            if mark - x >= 0 and not can_measure(marks, mark - x):\n                if mark - x + y <= l or mark - x - y >= 0:\n                    return 1, [mark - x]\n        return 2, [x, y]\n    else:\n        if add_x:\n            additional_marks.append(x)\n        if add_y:\n            additional_marks.append(y)\n        return len(additional_marks), additional_marks\n\nn, l, x, y = map(int, input().split())\nmarks = set(map(int, input().split()))\n\nnum_additional_marks, additional_marks = find_additional_marks(n, l, x, y, marks)\nprint(num_additional_marks)\nif num_additional_marks > 0:\n    print(' '.join(map(str, additional_marks)))"}
{"solution": "def max_cake_volume(n, cakes):\n    import sys\n    sys.setrecursionlimit(10**6)\n\n    cakes = sorted(enumerate(cakes), key=lambda x: x[1][0] * x[1][1], reverse=True)\n    dp = {}\n    def dfs(i, prev_volume):\n        if i == n:\n            return 0\n        if (i, prev_volume) in dp:\n            return dp[(i, prev_volume)]\n        volume = cakes[i][1][0] ** 2 * cakes[i][1][1] * 3.141592653589793\n        if volume < prev_volume:\n            dp[(i, prev_volume)] = dfs(i + 1, prev_volume)\n        else:\n            dp[(i, prev_volume)] = max(dfs(i + 1, prev_volume), volume + dfs(i + 1, volume))\n        return dp[(i, prev_volume)]\n\n    return dfs(0, 0)\n\nn = int(input().strip())\ncakes = [tuple(map(int, input().strip().split())) for _ in range(n)]\nprint(\"{:.9f}\".format(max_cake_volume(n, cakes)))"}
{"solution": "def min_good_slices(n, k, heights):\n    heights.sort()\n    total_slices = 0\n    current_height = heights[-1]\n    removed_cubes = 0\n\n    for height in reversed(heights):\n        if height < current_height:\n            if removed_cubes <= k:\n                total_slices += 1\n            else:\n                break\n            removed_cubes += current_height - height\n            current_height = height\n\n    return total_slices\n\n# Read input\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Output the result\nprint(min_good_slices(n, k, heights))"}
{"solution": "def max_score(n, a):\n    max_sum = 0\n    for i in range(n):\n        min_val = a[i]\n        current_sum = 0\n        for j in range(i, n):\n            min_val = min(min_val, a[j])\n            current_sum += a[j]\n            max_sum = max(max_sum, current_sum - min_val)\n    return max_sum\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_score(n, a))"}
{"solution": "def can_decorate_tree(k1, k2, k3):\n    # Sort the intervals to simplify the logic\n    intervals = sorted([k1, k2, k3])\n    \n    # Check if the two smallest intervals are 1 or 2, which can always cover all seconds\n    if intervals[0] == 1 or intervals[1] == 1:\n        return \"YES\"\n    if intervals[0] == 2 and intervals[1] == 2:\n        return \"YES\"\n    \n    # Check if one of the intervals is 2 and the other two can form a valid pattern\n    if intervals[0] == 2:\n        if intervals[1] == 4 and intervals[2] == 4:\n            return \"YES\"\n        if intervals[1] == 3:\n            return \"YES\"\n    \n    # Check if the intervals are 3, 3, and 3, which can also form a valid pattern\n    if intervals == [3, 3, 3]:\n        return \"YES\"\n    \n    # If none of the above conditions are met, it's not possible to decorate the tree\n    return \"NO\"\n\n# Read input\nk1, k2, k3 = map(int, input().split())\n\n# Output result\nprint(can_decorate_tree(k1, k2, k3))"}
{"solution": "def min_operations_to_delete(s):\n    n = len(s)\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] + 1\n        for j in range(i - 1, 0, -1):\n            if s[j - 1] == s[i - 1]:\n                dp[i] = min(dp[i], dp[j - 1] + 1)\n    return dp[n]\n\n# Read input\nn = int(input())\ns = input()\n\n# Output the result\nprint(min_operations_to_delete(s))"}
{"solution": "def max_pairs(boys, girls):\n    boys.sort()\n    girls.sort()\n    pairs = 0\n    i, j = 0, 0\n    while i < len(boys) and j < len(girls):\n        if abs(boys[i] - girls[j]) <= 1:\n            pairs += 1\n            i += 1\n            j += 1\n        elif boys[i] < girls[j]:\n            i += 1\n        else:\n            j += 1\n    return pairs\n\n# Read input\nn = int(input())\nboys = list(map(int, input().split()))\nm = int(input())\ngirls = list(map(int, input().split()))\n\n# Output the result\nprint(max_pairs(boys, girls))"}
{"solution": "def determine_winner(a1, b1, a2, b2, a3, b3, a4, b4):\n    # Check all possible combinations for Team 1 to win\n    if (a1 > b3 and b2 > a4 and a1 > b4 and b2 > a3) or \\\n       (a2 > b3 and b1 > a4 and a2 > b4 and b1 > a3):\n        return \"Team 1\"\n    \n    # Check all possible combinations for Team 2 to win\n    if (a3 > b1 and b4 > a2 and a3 > b2 and b4 > a1) or \\\n       (a4 > b1 and b3 > a2 and a4 > b2 and b3 > a1):\n        return \"Team 2\"\n    \n    # If neither team can guarantee a win\n    return \"Draw\"\n\n# Read input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\na4, b4 = map(int, input().split())\n\n# Determine the winner\nprint(determine_winner(a1, b1, a2, b2, a3, b3, a4, b4))"}
{"solution": "import sys\nimport math\n\ndef read_input():\n    N, K = map(int, input().split())\n    meats = [list(map(int, input().split())) for _ in range(N)]\n    return N, K, meats\n\ndef calculate_time(N, K, meats, X, Y):\n    times = [c * math.sqrt((X - x)**2 + (Y - y)**2) for x, y, c in meats]\n    times.sort()\n    return times[K - 1]\n\ndef find_optimal_heat_source(N, K, meats):\n    min_time = float('inf')\n    for i in range(N):\n        for j in range(N):\n            if i == j: continue\n            for k in range(N):\n                if k in (i, j): continue\n                for l in range(N):\n                    if l in (i, j, k): continue\n                    X = (meats[i][0] + meats[j][0] + meats[k][0] + meats[l][0]) / 4\n                    Y = (meats[i][1] + meats[j][1] + meats[k][1] + meats[l][1]) / 4\n                    time = calculate_time(N, K, meats, X, Y)\n                    min_time = min(min_time, time)\n    return min_time\n\ndef main():\n    N, K, meats = read_input()\n    result = find_optimal_heat_source(N, K, meats)\n    print(\"{:.6f}\".format(result))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def determine_winner(n, ticket):\n    left_sum = 0\n    right_sum = 0\n    left_missing = 0\n    right_missing = 0\n\n    for i in range(n // 2):\n        if ticket[i] == '?':\n            left_missing += 1\n        else:\n            left_sum += int(ticket[i])\n        if ticket[n // 2 + i] == '?':\n            right_missing += 1\n        else:\n            right_sum += int(ticket[n // 2 + i])\n\n    if left_missing != right_missing:\n        if left_missing > right_missing:\n            left_missing, right_missing = right_missing, left_missing\n            left_sum, right_sum = right_sum, left_sum\n\n        diff_missing = right_missing - left_missing\n        if right_sum - left_sum > diff_missing * 9 / 2:\n            return \"Monocarp\"\n        else:\n            return \"Bicarp\"\n    else:\n        if left_sum == right_sum:\n            return \"Bicarp\"\n        else:\n            return \"Monocarp\"\n\n# Read input\nn = int(input())\nticket = input()\n\n# Determine the winner and print the result\nprint(determine_winner(n, ticket))"}
{"solution": "def find_bus_route(n, t, bus_routes):\n    earliest_bus_time = float('inf')\n    chosen_route = -1\n    \n    for i, (s_i, d_i) in enumerate(bus_routes):\n        if s_i >= t:\n            current_bus_time = s_i\n        else:\n            current_bus_time = s_i + ((t - s_i + d_i - 1) // d_i) * d_i\n        \n        if current_bus_time < earliest_bus_time:\n            earliest_bus_time = current_bus_time\n            chosen_route = i + 1\n    \n    return chosen_route\n\n# Read input\nn, t = map(int, input().split())\nbus_routes = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Find and print the bus route\nprint(find_bus_route(n, t, bus_routes))"}
{"solution": "def find_n(m, k):\n    low, high = 1, 10**18\n    while low < high:\n        mid = (low + high) // 2\n        count = 0\n        for i in range(k):\n            count += mid // (2**i)\n        if count >= m:\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\n# Read input\nm, k = map(int, input().split())\n\n# Find and print the required number n\nprint(find_n(m, k))"}
{"solution": "def is_good_level(n, level_scheme):\n    for jump_length in range(1, n):\n        for start in range(n - 4 * jump_length):\n            if all(level_scheme[start + i * jump_length] == '*' for i in range(5)):\n                return \"yes\"\n    return \"no\"\n\n# Reading input\nn = int(input().strip())\nlevel_scheme = input().strip()\n\n# Output result\nprint(is_good_level(n, level_scheme))"}
{"solution": "def find_magic_number(grid, n):\n    # Find the position of the empty cell\n    empty_row, empty_col = None, None\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                empty_row, empty_col = i, j\n                break\n        if empty_row is not None:\n            break\n\n    # Calculate the target sum by excluding the empty cell's row\n    target_sum = sum(grid[empty_row - 1]) if empty_row > 0 else sum(grid[(empty_row + 1) % n])\n\n    # Calculate the current sum of the empty cell's row\n    current_sum = sum(grid[empty_row])\n\n    # Determine the number to fill in the empty cell\n    magic_number = target_sum - current_sum\n\n    # Check if the magic number is positive\n    if magic_number <= 0:\n        return -1\n\n    # Replace the empty cell with the magic number\n    grid[empty_row][empty_col] = magic_number\n\n    # Verify if the grid becomes a magic square\n    for i in range(n):\n        if sum(grid[i]) != target_sum:\n            return -1\n        if sum(grid[j][i] for j in range(n)) != target_sum:\n            return -1\n    if sum(grid[i][i] for i in range(n)) != target_sum:\n        return -1\n    if sum(grid[i][n - 1 - i] for i in range(n)) != target_sum:\n        return -1\n\n    return magic_number\n\n# Read input\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\n# Find and print the magic number\nprint(find_magic_number(grid, n))"}
{"solution": "def calculate_k(n, m, a):\n    max_initial = max(a)\n    total_people = sum(a) + m\n    \n    # Calculate the minimum possible k\n    min_k = max_initial\n    remaining_people = m\n    for bench_people in sorted(a):\n        seats_to_add = min(remaining_people, max_initial - bench_people)\n        remaining_people -= seats_to_add\n        bench_people += seats_to_add\n        min_k = max(min_k, bench_people)\n        if remaining_people == 0:\n            break\n    \n    # If there are still people left, distribute them evenly\n    if remaining_people > 0:\n        min_k += remaining_people // n\n        if remaining_people % n != 0:\n            min_k += 1\n    \n    # Calculate the maximum possible k\n    max_k = max_initial + m\n    \n    return min_k, max_k\n\n# Read input\nn = int(input())\nm = int(input())\na = [int(input()) for _ in range(n)]\n\n# Calculate and print the result\nmin_k, max_k = calculate_k(n, m, a)\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, m):\n    # Initialize the result\n    result = 1\n    \n    # Calculate the number of ways for each passenger\n    for i in range(m):\n        # Each passenger can choose either front or back entrance\n        # and can be assigned any seat from 1 to n\n        result = (result * 2 * n) % MOD\n    \n    return result\n\n# Read input\nn, m = map(int, input().split())\n\n# Print the result\nprint(count_ways(n, m))"}
{"solution": "from itertools import combinations\nfrom sys import stdin\n\ndef read_ints():\n    return list(map(int, stdin.readline().strip().split()))\n\ndef can_please(pizza1, pizza2, favorites):\n    combined_ingredients = set(pizza1) | set(pizza2)\n    pleased_count = 0\n    for fav in favorites:\n        if fav.issubset(combined_ingredients):\n            pleased_count += 1\n    return pleased_count\n\ndef main():\n    n, m = read_ints()\n    favorites = []\n    for _ in range(n):\n        fav = set(read_ints()[1:])\n        favorites.append(fav)\n    \n    pizzas = []\n    for _ in range(m):\n        c_j, r_j, *ingredients = read_ints()\n        pizzas.append((c_j, ingredients))\n    \n    max_pleased = -1\n    min_price = float('inf')\n    best_pair = (-1, -1)\n    \n    for j1, j2 in combinations(range(m), 2):\n        pleased_count = can_please(pizzas[j1][1], pizzas[j2][1], favorites)\n        if pleased_count > max_pleased or (pleased_count == max_pleased and pizzas[j1][0] + pizzas[j2][0] < min_price):\n            max_pleased = pleased_count\n            min_price = pizzas[j1][0] + pizzas[j2][0]\n            best_pair = (j1 + 1, j2 + 1)\n    \n    print(*best_pair)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_numbers(m, s):\n    if s == 0:\n        return \"-1 -1\" if m > 1 else \"0 0\"\n    if s > 9 * m:\n        return \"-1 -1\"\n\n    # Find the smallest number\n    smallest = [0] * m\n    sum_left = s\n    for i in range(m):\n        if sum_left > 9:\n            smallest[i] = 9\n            sum_left -= 9\n        else:\n            smallest[i] = sum_left\n            break\n    if smallest[0] == 0:\n        for i in range(m):\n            if smallest[i] > 0:\n                smallest[i] -= 1\n                smallest[0] = 1\n                break\n\n    # Find the largest number\n    largest = [0] * m\n    sum_left = s\n    for i in range(m):\n        if sum_left > 9:\n            largest[i] = 9\n            sum_left -= 9\n        else:\n            largest[i] = sum_left\n            break\n\n    return ''.join(map(str, smallest)) + ' ' + ''.join(map(str, largest))\n\n# Read input\nm, s = map(int, input().split())\n\n# Print output\nprint(find_numbers(m, s))"}
{"solution": "MOD = 998244353\n\ndef sum_of_numbers_with_k_digits(l, r, k):\n    def count_digits(num):\n        return len(set(str(num)))\n    \n    def sum_of_range(start, end):\n        return (end * (end + 1) // 2 - start * (start - 1) // 2) % MOD\n    \n    total_sum = 0\n    current = l\n    \n    while current <= r:\n        if count_digits(current) <= k:\n            next_invalid = current + 1\n            while next_invalid <= r and count_digits(next_invalid) <= k:\n                next_invalid += 1\n            total_sum += sum_of_range(current, min(next_invalid - 1, r))\n            current = next_invalid\n        else:\n            current += 1\n    \n    return total_sum % MOD\n\n# Read input\nl, r, k = map(int, input().split())\n\n# Calculate and print the result\nprint(sum_of_numbers_with_k_digits(l, r, k))"}
{"solution": "def can_distribute_pencils(n, k, d, saturations):\n    saturations.sort()\n    dp = [False] * (n + 1)\n    dp[0] = True\n    last_true = 0\n\n    for i in range(1, n + 1):\n        if i >= k and dp[i - k]:\n            last_true = i - k\n        while last_true < i and saturations[i - 1] - saturations[last_true] > d:\n            last_true += 1\n        dp[i] = last_true < i and dp[last_true]\n\n    return \"YES\" if dp[n] else \"NO\"\n\n# Read input\nn, k, d = map(int, input().split())\nsaturations = list(map(int, input().split()))\n\n# Output result\nprint(can_distribute_pencils(n, k, d, saturations))"}
{"solution": "def count_dead_bulbs(s):\n    # Initialize counters for each color\n    dead_counts = {'R': 0, 'B': 0, 'Y': 0, 'G': 0}\n    \n    # Find the positions of the first working bulb of each color\n    positions = {'R': None, 'B': None, 'Y': None, 'G': None}\n    for i, bulb in enumerate(s):\n        if bulb in positions:\n            positions[bulb] = i % 4\n    \n    # Count dead bulbs based on the pattern\n    for i, bulb in enumerate(s):\n        if bulb == '!':\n            for color, pos in positions.items():\n                if i % 4 == pos:\n                    dead_counts[color] += 1\n                    break\n    \n    return dead_counts\n\n# Read input\ns = input().strip()\n\n# Get the counts of dead bulbs\ndead_counts = count_dead_bulbs(s)\n\n# Print the result\nprint(dead_counts['R'], dead_counts['B'], dead_counts['Y'], dead_counts['G'])"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    N, M = map(int, sys.stdin.readline().split())\n    passages = [tuple(map(int, sys.stdin.readline().split())) for _ in range(M)]\n    return N, M, passages\n\ndef solve(N, M, passages):\n    graph = defaultdict(list)\n    for s, t in passages:\n        graph[s].append(t)\n    \n    # Calculate the expected number of passages Takahashi takes before he reaches Room N\n    # without blocking any passage\n    def expected_value(graph):\n        ev = [0] * (N + 1)\n        for i in range(N - 1, 0, -1):\n            ev[i] = 1 + sum(ev[j] for j in graph[i]) / len(graph[i])\n        return ev[1]\n\n    # Calculate the expected value with the optimal blocking strategy\n    min_ev = expected_value(graph)\n    for s, t in passages:\n        if len(graph[s]) > 1:\n            # Temporarily remove the passage\n            graph[s].remove(t)\n            ev = expected_value(graph)\n            min_ev = min(min_ev, ev)\n            # Restore the passage\n            graph[s].append(t)\n\n    return min_ev\n\ndef main():\n    N, M, passages = read_input()\n    result = solve(N, M, passages)\n    print(f\"{result:.10f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\nif n % 10 == 0:\n    print(n)\nelse:\n    last_digit = n % 10\n    if last_digit <= 5:\n        print(n - last_digit)\n    else:\n        print(n + (10 - last_digit))"}
{"solution": "def find_key_swaps(s, t):\n    if s == t:\n        return \"0\"\n    \n    swaps = []\n    positions = {}\n    \n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if s[i] in positions and positions[s[i]] == t[i]:\n                continue\n            elif t[i] in positions and positions[t[i]] == s[i]:\n                swaps.append((s[i], t[i]))\n            else:\n                positions[s[i]] = t[i]\n                positions[t[i]] = s[i]\n    \n    for key in positions:\n        if positions[key] != key and (positions[key], key) not in swaps:\n            swaps.append((key, positions[key]))\n    \n    if len(swaps) > 0 and len(swaps) != len(set(swaps)):\n        return \"-1\"\n    \n    result = f\"{len(swaps)}\\n\"\n    for swap in swaps:\n        result += f\"{swap[0]} {swap[1]}\\n\"\n    \n    return result.strip()\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Output result\nprint(find_key_swaps(s, t))"}
{"solution": "def alphabetically_earliest_login(first_name, last_name):\n    earliest_login = \"\"\n    for i in range(1, len(first_name) + 1):\n        for j in range(1, len(last_name) + 1):\n            login = first_name[:i] + last_name[:j]\n            if not earliest_login or login < earliest_login:\n                earliest_login = login\n    return earliest_login\n\n# Read input\nfirst_name, last_name = input().strip().split()\n\n# Output the result\nprint(alphabetically_earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(sequence):\n    n = len(sequence)\n    height = 0\n    current_height = 0\n    for bracket in sequence:\n        if bracket == '[':\n            current_height += 1\n            height = max(height, current_height)\n        else:\n            current_height -= 1\n\n    height = 2 * height - 1\n    rows = [[' ' for _ in range(n * 4 + 1)] for _ in range(height)]\n\n    def draw_vertical(row, col, length):\n        for i in range(length):\n            rows[row + i][col] = '|'\n\n    def draw_horizontal(row, col, length):\n        for i in range(length):\n            rows[row][col + i] = '-'\n\n    col = 0\n    for i in range(n):\n        if sequence[i] == '[':\n            if i > 0 and sequence[i - 1] == ']':\n                col += 1\n            draw_horizontal(0, col + 1, 2)\n            draw_horizontal(height - 1, col + 1, 2)\n            draw_vertical(1, col, height - 1)\n            draw_vertical(1, col + 3, height - 1)\n            col += 4\n        else:\n            col -= 4\n            draw_horizontal(0, col + 1, 2)\n            draw_horizontal(height - 1, col + 1, 2)\n            draw_vertical(1, col, height - 1)\n            draw_vertical(1, col + 3, height - 1)\n\n    for row in rows:\n        print(''.join(row).rstrip())\n\n# Read input\nn = int(input())\nsequence = input()\n\n# Draw the bracket sequence\ndraw_brackets(sequence)"}
{"solution": "import math\n\ndef golden_to_decimal(s, q):\n    value = 0\n    for i, digit in enumerate(reversed(s)):\n        if digit == '1':\n            value += q ** i\n    return value\n\ndef compare_golden_numbers(s1, s2):\n    q = (math.sqrt(5) + 1) / 2\n    val1 = golden_to_decimal(s1, q)\n    val2 = golden_to_decimal(s2, q)\n    \n    if val1 > val2:\n        return \">\"\n    elif val1 < val2:\n        return \"<\"\n    else:\n        return \"=\"\n\n# Read input\ns1 = input().strip()\ns2 = input().strip()\n\n# Compare and print result\nprint(compare_golden_numbers(s1, s2))"}
{"solution": "def determine_absent_gems(n, seen_colors):\n    all_gems = {\n        \"purple\": \"Power\",\n        \"green\": \"Time\",\n        \"blue\": \"Space\",\n        \"orange\": \"Soul\",\n        \"red\": \"Reality\",\n        \"yellow\": \"Mind\"\n    }\n    \n    absent_gems = [all_gems[color] for color in all_gems if color not in seen_colors]\n    \n    print(len(absent_gems))\n    for gem in absent_gems:\n        print(gem)\n\n# Read input\nn = int(input())\nseen_colors = [input().strip() for _ in range(n)]\n\n# Determine and print absent gems\ndetermine_absent_gems(n, seen_colors)"}
{"solution": "def find_meeting_round(n, a, b):\n    round_number = 1\n    while n > 1:\n        if (a + 1) // 2 == (b + 1) // 2:\n            return \"Final!\" if n == 2 else round_number\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n //= 2\n        round_number += 1\n    return round_number\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Find and print the round number\nprint(find_meeting_round(n, a, b))"}
{"solution": "def min_changes_to_permutation_and_sequence(n, p, b):\n    # Check if the permutation is already a valid cycle\n    visited = [False] * n\n    cycles = []\n    for i in range(n):\n        if not visited[i]:\n            cycle = []\n            while not visited[i]:\n                visited[i] = True\n                cycle.append(i)\n                i = p[i] - 1\n            cycles.append(cycle)\n    \n    # Check if we need to change the permutation\n    changes_needed = 0\n    for cycle in cycles:\n        if len(cycle) > 1:\n            changes_needed += 1\n    \n    # Check if we need to change the sequence b\n    if changes_needed == 0:\n        # If there's only one cycle and it's a self-loop, we need to change at least one b\n        if len(cycles[0]) == 1:\n            return 1\n        # If there are multiple self-loops, we don't need to change anything\n        return 0\n    else:\n        # If there are cycles, we need to ensure that at least one b in each cycle is 1\n        for cycle in cycles:\n            if len(cycle) > 1:\n                if all(b[i] == 0 for i in cycle):\n                    changes_needed += 1\n                    break\n    \n    return changes_needed\n\n# Read input\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Output the result\nprint(min_changes_to_permutation_and_sequence(n, p, b))"}
{"solution": "def max_path_length(v_1, v_2, t, d):\n    speeds = [0] * t\n    speeds[0] = v_1\n    speeds[-1] = v_2\n    \n    for i in range(1, t-1):\n        speeds[i] = min(speeds[i-1] + d, v_2 + d * (t - 1 - i))\n    \n    return sum(speeds)\n\n# Read input\nv_1, v_2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Output the result\nprint(max_path_length(v_1, v_2, t, d))"}
{"solution": "from itertools import permutations\n\ndef can_cross_bridge(N, M, weights, bridge_parts):\n    min_distance = float('inf')\n    \n    for perm in permutations(range(N)):\n        distances = [0] * (N - 1)\n        valid = True\n        \n        for l, v in bridge_parts:\n            max_distance = 0\n            for i in range(N - 1):\n                for j in range(i + 1, N):\n                    if sum(weights[perm[k]] for k in range(i + 1, j)) > v:\n                        max_distance = max(max_distance, sum(distances[k] for k in range(i, j - 1)))\n                        if max_distance >= l:\n                            break\n                    else:\n                        max_distance = max(max_distance, l)\n                    if max_distance >= l:\n                        break\n                if max_distance >= l:\n                    break\n            if max_distance < l:\n                valid = False\n                break\n        \n        if valid:\n            total_distance = sum(distances)\n            min_distance = min(min_distance, total_distance)\n    \n    return min_distance if min_distance != float('inf') else -1\n\n# Read input\nN, M = map(int, input().split())\nweights = list(map(int, input().split()))\nbridge_parts = [tuple(map(int, input().split())) for _ in range(M)]\n\n# Calculate and print the result\nresult = can_cross_bridge(N, M, weights, bridge_parts)\nprint(result)"}
{"solution": "def last_digit_of_phoenix_reincarnations(a, b):\n    if a == 0:\n        return 0\n    if a == b:\n        return 1\n    if b % 4 == 0 and b != 0:\n        return 6\n    if b % 4 == 1:\n        return 2\n    if b % 4 == 2:\n        return 4\n    if b % 4 == 3:\n        return 8\n\n# Read input\na, b = map(int, input().split())\n\n# Output the result\nprint(last_digit_of_phoenix_reincarnations(a, b))"}
{"solution": "def min_jumps_to_home(n, d, s):\n    jumps = 0\n    current_position = 0\n    \n    while current_position < n - 1:\n        found_lily = False\n        for jump_length in range(d, 0, -1):\n            if current_position + jump_length < n and s[current_position + jump_length] == '1':\n                current_position += jump_length\n                jumps += 1\n                found_lily = True\n                break\n        if not found_lily:\n            return -1\n    \n    return jumps\n\n# Read input\nn, d = map(int, input().split())\ns = input()\n\n# Output the result\nprint(min_jumps_to_home(n, d, s))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_counterexample(n):\n    m = 1\n    while True:\n        if not is_prime(n * m + 1):\n            return m\n        m += 1\n\nn = int(input())\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all_coins(n):\n    house_cost = 1234567\n    car_cost = 123456\n    computer_cost = 1234\n    \n    # Start with the maximum number of houses\n    for a in range(n // house_cost + 1):\n        remaining_after_houses = n - a * house_cost\n        \n        # Then try with the maximum number of cars\n        for b in range(remaining_after_houses // car_cost + 1):\n            remaining_after_cars = remaining_after_houses - b * car_cost\n            \n            # Check if the remaining can be spent on computers\n            if remaining_after_cars % computer_cost == 0:\n                return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input().strip())\n\n# Output result\nprint(can_spend_all_coins(n))"}
{"solution": "def find_intersection_inside_strip(n, x1, x2, lines):\n    # Sort lines based on their y-values at x1 and x2\n    lines_at_x1 = sorted([(k * x1 + b, i) for i, (k, b) in enumerate(lines)])\n    lines_at_x2 = sorted([(k * x2 + b, i) for i, (k, b) in enumerate(lines)])\n    \n    # Check if the order of lines at x1 and x2 is different\n    for i in range(n):\n        if lines_at_x1[i][1] != lines_at_x2[i][1]:\n            return \"Yes\"\n    return \"No\"\n\n# Read input\nn = int(input().strip())\nx1, x2 = map(int, input().strip().split())\nlines = [tuple(map(int, input().strip().split())) for _ in range(n)]\n\n# Output result\nprint(find_intersection_inside_strip(n, x1, x2, lines))"}
{"solution": "def different_weights(n):\n    weights = set()\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            weights.add(i)\n            weights.add(n // i)\n    return len(weights)\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(different_weights(n))"}
{"solution": "def find_good_apartments(n, k):\n    if k == 0:\n        return 0, 0\n    min_good = max(0, 2 - k)\n    max_good = max(0, n - k * 2)\n    return min_good, max_good\n\nn, k = map(int, input().split())\nmin_good, max_good = find_good_apartments(n, k)\nprint(min_good, max_good)"}
{"solution": "import math\n\ndef max_games_winner_can_play(n):\n    return math.floor(math.log2(n))\n\n# Read input\nn = int(input())\n\n# Output the result\nprint(max_games_winner_can_play(n))"}
{"solution": "def max_vk_occurrences(s):\n    count = 0\n    can_change = True\n    for i in range(len(s) - 1):\n        if s[i:i+2] == 'VK':\n            count += 1\n        elif can_change and (s[i] == 'V' and (i + 2 >= len(s) or s[i + 2] != 'K')):\n            can_change = False\n            count += 1\n        elif can_change and (s[i] == 'K' and (i == 0 or s[i - 1] != 'V')):\n            can_change = False\n            count += 1\n    return count\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(max_vk_occurrences(s))"}
{"solution": "def min_segments_to_draw_squares(n):\n    # Sofia can draw a square with 2 segments using a ruler, and then use those segments\n    # as a guide for the remaining segments of the square. For each additional square,\n    # she can use the already drawn segments as a guide for 2 more segments, and only\n    # needs to draw 1 new segment with a ruler for each additional square.\n    # Therefore, the minimum number of segments she needs to draw with a ruler is\n    # the integer part of the square root of n, plus 2 for the first square.\n    return int(n**0.5) + 2\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(min_segments_to_draw_squares(n))"}
{"solution": "a, b = map(int, input().split())\nyears = 0\n\nwhile a <= b:\n    a *= 3\n    b *= 2\n    years += 1\n\nprint(years)"}
{"solution": "def count_visited_nodes(h, n):\n    visited_nodes = 0\n    current_node = 1\n    depth = 0\n    direction = 'L'\n\n    while True:\n        if current_node == n:\n            break\n        if direction == 'L':\n            if current_node * 2 <= 2 ** h and current_node * 2 not in visited:\n                current_node *= 2\n                visited.add(current_node)\n                visited_nodes += 1\n                depth += 1\n                direction = 'R'\n            elif current_node * 2 + 1 <= 2 ** h and current_node * 2 + 1 not in visited:\n                current_node = current_node * 2 + 1\n                visited.add(current_node)\n                visited_nodes += 1\n                depth += 1\n                direction = 'R'\n            else:\n                direction = 'R'\n        else:\n            if current_node * 2 + 1 <= 2 ** h and current_node * 2 + 1 not in visited:\n                current_node = current_node * 2 + 1\n                visited.add(current_node)\n                visited_nodes += 1\n                depth += 1\n                direction = 'L'\n            elif current_node * 2 <= 2 ** h and current_node * 2 not in visited:\n                current_node *= 2\n                visited.add(current_node)\n                visited_nodes += 1\n                depth += 1\n                direction = 'L'\n            else:\n                direction = 'L'\n\n        if direction == 'L' and direction == prev_direction:\n            current_node //= 2\n            depth -= 1\n        prev_direction = direction\n\n    return visited_nodes\n\n# Read input\nh, n = map(int, input().split())\nvisited = set([1])\nprint(count_visited_nodes(h, n))"}
{"solution": "def find_tables(x):\n    pairs = []\n    for n in range(1, int(x**0.5) + 1):\n        m = (x + n**2 - n) // (2 * n)\n        if n * m + n * (n - 1) * m * (m - 1) // 4 == x:\n            pairs.append((n, m))\n            if n != m:\n                pairs.append((m, n))\n    pairs.sort()\n    return pairs\n\ndef main():\n    x = int(input())\n    pairs = find_tables(x)\n    print(len(pairs))\n    for n, m in pairs:\n        print(n, m)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_leap_year(year):\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\ndef can_be_months(n, days):\n    month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    for i in range(12):\n        year = 0\n        while year < 2:\n            valid = True\n            for j in range(n):\n                month_index = (i + j) % 12\n                expected_days = month_days[month_index]\n                if month_index == 1 and is_leap_year(year + 2000):\n                    expected_days += 1\n                if days[j] != expected_days:\n                    valid = False\n                    break\n            if valid:\n                return \"YES\"\n            year += 1\n    return \"NO\"\n\nn = int(input().strip())\ndays = list(map(int, input().strip().split()))\nprint(can_be_months(n, days))"}
{"solution": "def find_sequence(n):\n    # Check if n is a prime number greater than 2\n    if n > 2 and all(n % i != 0 for i in range(2, int(n**0.5) + 1)):\n        print(\"NO\")\n        return\n\n    # Start with the fraction 1/n\n    sequence = [(1, n)]\n\n    # Find the remaining fractions to sum up to 1 - 1/n\n    remaining = 1 - 1/n\n    denominator = n - 1\n\n    while remaining > 0 and len(sequence) <= 100000:\n        if remaining >= 1/denominator:\n            sequence.append((1, denominator))\n            remaining -= 1/denominator\n        denominator -= 1\n\n    if remaining == 0:\n        print(\"YES\")\n        print(len(sequence))\n        for fraction in sequence:\n            print(fraction[0], fraction[1])\n    else:\n        print(\"NO\")\n\n# Read input\nn = int(input())\nfind_sequence(n)"}
{"solution": "def min_unattractiveness(n, a, b, heights):\n    total_area = sum(heights)\n    if a + b < total_area:\n        return -1\n    \n    heights.sort()\n    red_area = 0\n    green_area = 0\n    unattractiveness = 0\n    prev_color = None\n    \n    for i in range(n):\n        if red_area + heights[i] <= a and (prev_color == 'green' or prev_color is None):\n            red_area += heights[i]\n            if prev_color == 'green':\n                unattractiveness += heights[i-1]\n            prev_color = 'red'\n        elif green_area + heights[i] <= b and (prev_color == 'red' or prev_color is None):\n            green_area += heights[i]\n            if prev_color == 'red':\n                unattractiveness += heights[i-1]\n            prev_color = 'green'\n        else:\n            return -1\n    \n    return unattractiveness\n\n# Read input\nn = int(input())\na, b = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_unattractiveness(n, a, b, heights))"}
{"solution": "def find_triangle_points(n, m, k):\n    if 2 * m * n % k != 0:\n        return \"NO\"\n    \n    area = 2 * m * n // k\n    for x1 in range(n + 1):\n        y1 = area // x1\n        if y1 <= m and x1 * y1 == area:\n            return \"YES\\n0 0\\n{} {}\\n{} {}\".format(x1, 0, 0, y1)\n    \n    return \"NO\"\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Output result\nprint(find_triangle_points(n, m, k))"}
{"solution": "def game_result(n, k):\n    # Calculate the total number of full turns that can be made\n    full_turns = n // k\n    \n    # Sasha wins if the number of full turns is odd, because he moves first\n    if full_turns % 2 == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input from the user\nn, k = map(int, input().split())\n\n# Print the result of the game\nprint(game_result(n, k))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nchest = sum(a[i] for i in range(0, n, 3))\nbiceps = sum(a[i] for i in range(1, n, 3))\nback = sum(a[i] for i in range(2, n, 3))\n\nmax_muscle = max(chest, biceps, back)\n\nif chest == max_muscle:\n    print(\"chest\")\nelif biceps == max_muscle:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "def min_lab_works_to_redo(n, grades):\n    total = sum(grades)\n    if total / n >= 4.5:\n        return 0\n    grades.sort()\n    for i in range(n):\n        total += 5 - grades[i]\n        if total / n >= 4.5:\n            return i + 1\n\nn = int(input())\ngrades = list(map(int, input().split()))\nprint(min_lab_works_to_redo(n, grades))"}
{"solution": "def find_shortest_array(u, v):\n    if u > v or (v - u) % 2 != 0:\n        return -1\n    if u == v:\n        if u == 0:\n            return 0\n        return 1, [u]\n    x = (v - u) // 2\n    if u & x == 0:\n        return 2, [u + x, x]\n    return 3, [u, x, x]\n\nu, v = map(int, input().split())\nresult = find_shortest_array(u, v)\nif result == -1:\n    print(-1)\nelse:\n    n, array = result\n    print(n)\n    if n > 0:\n        print(*array)"}
{"solution": "def min_ones_sum(n):\n    count = 0\n    while n > 0:\n        count += n % 10\n        n //= 10\n    return count\n\n# Read input\nn = int(input())\n\n# Output the result\nprint(min_ones_sum(n))"}
{"solution": "def can_reach_treasure(x_1, y_1, x_2, y_2, x, y):\n    # Check if the difference in x and y coordinates can be divided by x and y respectively\n    if (x_2 - x_1) % x == 0 and (y_2 - y_1) % y == 0:\n        # Check if the number of steps needed in x and y direction are the same\n        if abs((x_2 - x_1) // x) % 2 == abs((y_2 - y_1) // y) % 2:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nx_1, y_1, x_2, y_2 = map(int, input().split())\nx, y = map(int, input().split())\n\n# Output result\nprint(can_reach_treasure(x_1, y_1, x_2, y_2, x, y))"}
{"solution": "from math import factorial\nfrom collections import Counter\n\ndef count_permutations(n):\n    counter = Counter(str(n))\n    total_permutations = factorial(len(str(n)))\n    for count in counter.values():\n        total_permutations //= factorial(count)\n    return total_permutations\n\ndef count_variants(n):\n    str_n = str(n)\n    if len(str_n) == 1:\n        return 1\n    # Count permutations without leading zeros\n    total_variants = count_permutations(str_n)\n    # Subtract permutations with leading zeros\n    for i in range(1, len(str_n)):\n        if str_n[i] == '0':\n            continue\n        # Create a new number with the first non-zero digit at the beginning\n        new_number = str_n[i] + str_n[:i] + str_n[i+1:]\n        total_variants += count_permutations(new_number)\n    return total_variants\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(count_variants(n))"}
{"solution": "def max_suit_cost(a, b, c, d, e, f):\n    # Calculate the maximum number of suits of each type that can be made\n    # Start with the second type since it requires more items and might limit the first type\n    max_second_type = min(b, c, d)\n    max_first_type = min(a, d - max_second_type)  # Subtract jackets used for second type\n\n    # Calculate the cost if we prioritize the second type suits\n    cost_prioritize_second = max_second_type * f + max_first_type * e\n\n    # Calculate the maximum number of first type suits without considering the second type\n    max_first_type_only = min(a, d)\n\n    # Calculate the remaining jackets after making first type suits\n    remaining_jackets = d - max_first_type_only\n\n    # Calculate the maximum number of second type suits with the remaining jackets\n    max_second_type_only = min(b, c, remaining_jackets)\n\n    # Calculate the cost if we prioritize the first type suits\n    cost_prioritize_first = max_first_type_only * e + max_second_type_only * f\n\n    # Return the maximum of the two strategies\n    return max(cost_prioritize_second, cost_prioritize_first)\n\n# Read input\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\n# Calculate and print the result\nprint(max_suit_cost(a, b, c, d, e, f))"}
{"solution": "def solve(a, b, p, x):\n    count = 0\n    a_inv = pow(a, p - 2, p)\n    current = b\n    for n in range(1, p):\n        if current == b and n != 1:\n            break\n        if n * current % p == b:\n            max_n = (x - n) // (p - 1)\n            count += max_n + 1\n        current = current * a_inv % p\n    return count\n\n# Read input\na, b, p, x = map(int, input().split())\n\n# Output the result\nprint(solve(a, b, p, x))"}
{"solution": "def max_possible_sum(k_2, k_3, k_5, k_6):\n    # First, try to form as many 256 as possible\n    count_256 = min(k_2, k_5, k_6)\n    k_2 -= count_256\n    k_5 -= count_256\n    k_6 -= count_256\n    \n    # Then, try to form as many 32 as possible\n    count_32 = min(k_2, k_3)\n    \n    # Calculate the sum\n    return count_256 * 256 + count_32 * 32\n\n# Read input\nk_2, k_3, k_5, k_6 = map(int, input().split())\n\n# Print the result\nprint(max_possible_sum(k_2, k_3, k_5, k_6))"}
{"solution": "def seconds_to_happiness(n, x, y, c):\n    def count_painted(time):\n        painted = 1  # The initial cell\n        for t in range(1, time + 1):\n            # Cells that can be reached in t seconds from the initial cell\n            for dx, dy in [(-t, 0), (t, 0), (0, -t), (0, t)]:\n                nx, ny = x + dx, y + dy\n                if 1 <= nx <= n and 1 <= ny <= n:\n                    painted += min(t, nx - 1, n - nx, ny - 1, n - ny)\n        return painted\n\n    low, high = 0, 2 * n\n    while low < high:\n        mid = (low + high) // 2\n        if count_painted(mid) >= c:\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\n# Read input\nn, x, y, c = map(int, input().split())\n\n# Output the result\nprint(seconds_to_happiness(n, x, y, c))"}
{"solution": "def max_xor(l, r):\n    xor = l ^ r\n    significant_bit = 0\n    while xor:\n        significant_bit += 1\n        xor >>= 1\n    return (1 << significant_bit) - 1\n\nl, r = map(int, input().split())\nprint(max_xor(l, r))"}
{"solution": "def min_height(n, k):\n    # Calculate the total number of odd x-coordinates\n    odd_count = n\n    \n    # If the area k is less than or equal to the number of odd points,\n    # we can achieve the area by increasing the height of each odd point by 1\n    if k <= odd_count:\n        return 1\n    \n    # If k is greater than the number of odd points, we need to distribute\n    # the area among the odd points. The minimum height will be the ceiling\n    # of the division of k by the number of odd points.\n    return -(-k // odd_count)  # Equivalent to math.ceil(k / odd_count)\n\n# Read input\nn, k = map(int, input().split())\n\n# Output the result\nprint(min_height(n, k))"}
{"solution": "def choose_transport(x, y, z, t1, t2, t3):\n    stairs_time = abs(x - y) * t1\n    elevator_time = abs(x - z) * t2 + abs(x - y) * t2 + 3 * t3\n    if stairs_time < elevator_time:\n        return \"NO\"\n    else:\n        return \"YES\"\n\n# Read input\nx, y, z, t1, t2, t3 = map(int, input().split())\n\n# Output result\nprint(choose_transport(x, y, z, t1, t2, t3))"}
{"solution": "def optimal_choice(n, m):\n    if m > n // 2:\n        return 1\n    else:\n        return n\n\nn, m = map(int, input().split())\nprint(optimal_choice(n, m))"}
{"solution": "def calculate_pairs_at_university(n, schedule):\n    pairs_at_university = 0\n    for i in range(n):\n        if schedule[i] == 1:\n            pairs_at_university += 1\n        elif i > 0 and schedule[i-1] == 1 and (i == n-1 or schedule[i+1] == 1):\n            pairs_at_university += 1\n    return pairs_at_university\n\n# Read input\nn = int(input())\nschedule = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(calculate_pairs_at_university(n, schedule))"}
{"solution": "def min_days_to_give_candies(n, k, candies_per_day):\n    total_candies = 0\n    for day in range(n):\n        total_candies += candies_per_day[day]\n        give_to_bran = min(total_candies, 8)\n        k -= give_to_bran\n        total_candies -= give_to_bran\n        if k <= 0:\n            return day + 1\n    return -1\n\n# Read input\nn, k = map(int, input().split())\ncandies_per_day = list(map(int, input().split()))\n\n# Output the result\nprint(min_days_to_give_candies(n, k, candies_per_day))"}
{"solution": "def min_additional_walks(n, k, a):\n    additional_walks = 0\n    b = a[:]\n    for i in range(1, n):\n        if b[i] + b[i-1] < k:\n            additional_walks += k - (b[i] + b[i-1])\n            b[i] += k - (b[i] + b[i-1])\n    return additional_walks, b\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nadditional_walks, b = min_additional_walks(n, k, a)\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "def number_of_cells_in_nth_order_rhombus(n):\n    if n == 1:\n        return 1\n    return number_of_cells_in_nth_order_rhombus(n - 1) + 4 * (n - 1)\n\n# Read input\nn = int(input())\n\n# Output the result\nprint(number_of_cells_in_nth_order_rhombus(n))"}
{"solution": "def is_pangram(n, s):\n    if n < 26:\n        return \"NO\"\n    letters = set()\n    for char in s:\n        letters.add(char.lower())\n    if len(letters) == 26:\n        return \"YES\"\n    else:\n        return \"NO\"\n\nn = int(input())\ns = input()\nprint(is_pangram(n, s))"}
{"solution": "def find_time_after_minutes(current_time, a):\n    hh, mm = map(int, current_time.split(':'))\n    total_minutes = hh * 60 + mm + a\n    new_hh = total_minutes // 60 % 24\n    new_mm = total_minutes % 60\n    return f\"{new_hh:02d}:{new_mm:02d}\"\n\n# Read input\ncurrent_time = input().strip()\na = int(input().strip())\n\n# Output the result\nprint(find_time_after_minutes(current_time, a))"}
{"solution": "def can_ignore_switch(n, m, matrix):\n    for i in range(n):\n        # Create a copy of the matrix without the current switch\n        temp_matrix = [row[:] for row in matrix]\n        temp_matrix.pop(i)\n        \n        # Check if all lamps can be turned on without the current switch\n        lamps_on = [False] * m\n        for row in temp_matrix:\n            for j in range(m):\n                if row[j] == '1':\n                    lamps_on[j] = True\n        \n        # If all lamps are on, we can ignore the current switch\n        if all(lamps_on):\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nmatrix = [list(input().strip()) for _ in range(n)]\n\n# Output result\nprint(can_ignore_switch(n, m, matrix))"}
{"solution": "def min_rotations_to_even_sum(n, dominoes):\n    upper_sum = sum(x for x, _ in dominoes)\n    lower_sum = sum(y for _, y in dominoes)\n    upper_odd_count = sum(1 for x, _ in dominoes if x % 2 != 0)\n    lower_odd_count = sum(1 for _, y in dominoes if y % 2 != 0)\n\n    if upper_sum % 2 == 0 and lower_sum % 2 == 0:\n        return 0\n    if (upper_sum % 2 != 0 and lower_sum % 2 == 0) or (upper_sum % 2 == 0 and lower_sum % 2 != 0):\n        return -1\n    if upper_odd_count != lower_odd_count:\n        return -1\n    return 1\n\nn = int(input().strip())\ndominoes = [tuple(map(int, input().strip().split())) for _ in range(n)]\nprint(min_rotations_to_even_sum(n, dominoes))"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        a, b = map(int, input().split())\n        area = a**2 - b**2\n        if is_prime(area):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_remove_point(n, points):\n    left_half = False\n    right_half = False\n    \n    for x, _ in points:\n        if x < 0:\n            left_half = True\n        else:\n            right_half = True\n    \n    if left_half and right_half:\n        # Check if we can remove one point to satisfy the condition\n        for i in range(n):\n            temp_left_half = left_half\n            temp_right_half = right_half\n            for j in range(n):\n                if i != j:\n                    if points[j][0] < 0:\n                        temp_right_half = False\n                    else:\n                        temp_left_half = False\n            if not (temp_left_half and temp_right_half):\n                return \"Yes\"\n        return \"No\"\n    else:\n        return \"Yes\"\n\n# Read input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(can_remove_point(n, points))"}
{"solution": "import math\n\ndef gcd_of_factorials(A, B):\n    return math.factorial(min(A, B))\n\n# Read input\nA, B = map(int, input().split())\n\n# Output the result\nprint(gcd_of_factorials(A, B))"}
{"solution": "def find_composite_pair(n):\n    # If n is even, we can use 4 and (4-n) as they are both composite if (4-n) > 1\n    if n % 2 == 0:\n        a = 4\n        b = 4 - n\n    else:\n        # If n is odd, we can use 9 (which is composite) and (9-n) which will be even and thus composite if (9-n) > 1\n        a = 9\n        b = 9 - n\n    \n    # Ensure b is at least 2 to be composite\n    if b < 2:\n        b += 2\n        a += 2\n    \n    return a, b\n\n# Read input\nn = int(input())\n\n# Find and print the composite pair\na, b = find_composite_pair(n)\nprint(a, b)"}
{"solution": "import sys\nfrom collections import deque\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef main():\n    N, M, P = map(int, read_input().split())\n    edges = [list(map(int, read_input().split())) for _ in range(M)]\n    \n    # Create adjacency list and edge cost list\n    adj_list = [[] for _ in range(N + 1)]\n    edge_costs = []\n    for A_i, B_i, C_i in edges:\n        adj_list[A_i].append(B_i)\n        edge_costs.append((A_i, B_i, C_i))\n    \n    # Bellman-Ford algorithm to find the maximum score\n    dist = [-float('inf')] * (N + 1)\n    dist[1] = 0\n    for _ in range(N - 1):\n        for A_i, B_i, C_i in edge_costs:\n            if dist[A_i] != -float('inf') and dist[A_i] + C_i > dist[B_i]:\n                dist[B_i] = dist[A_i] + C_i\n    \n    # Check for negative cycles that can affect the result\n    cycle = [False] * (N + 1)\n    for _ in range(N):\n        for A_i, B_i, C_i in edge_costs:\n            if dist[A_i] != -float('inf') and dist[A_i] + C_i > dist[B_i]:\n                dist[B_i] = dist[A_i] + C_i\n                cycle[B_i] = True\n            if cycle[A_i]:\n                cycle[B_i] = True\n    \n    # If there's a cycle on the path to N, the score is unbounded\n    if cycle[N]:\n        print(-1)\n    else:\n        # Calculate the maximum score after paying the cost\n        max_score = dist[N] - P * (dist[N] // P)\n        print(max(max_score, 0))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_cost_to_make_palindrome(N, strings_with_costs):\n    # Initialize the minimum cost to a large number\n    min_cost = float('inf')\n    \n    # Helper function to check if a string can be part of a palindrome\n    def can_be_palindrome_part(s):\n        return s == s[::-1]\n    \n    # Helper function to calculate the cost of making a palindrome\n    def calculate_cost(strings_to_use):\n        return sum(cost * count for s, cost, count in strings_to_use)\n    \n    # Try all combinations of strings to find the minimum cost\n    from itertools import combinations_with_replacement\n    for r in range(1, N + 1):  # Try combinations of 1 to N strings\n        for combo in combinations_with_replacement(strings_with_costs, r):\n            # Check if the combination can form a palindrome\n            all_strings = ''.join(s * count for s, cost, count in combo)\n            if all_strings == all_strings[::-1]:\n                min_cost = min(min_cost, calculate_cost(combo))\n    \n    # If min_cost is still the initial large number, it means no palindrome can be formed\n    return -1 if min_cost == float('inf') else min_cost\n\n# Read input\nN = int(input())\nstrings_with_costs = [input().split() for _ in range(N)]\nstrings_with_costs = [(s, int(c), 1) for s, c in strings_with_costs]  # Format: (string, cost, count)\n\n# Output the result\nprint(min_cost_to_make_palindrome(N, strings_with_costs))"}
{"solution": "def largest_xor_sum(n, k):\n    if k == 1:\n        return n\n    if k == 2:\n        return n if n == 1 else n ^ (n - 1)\n    max_xor = 1\n    while max_xor <= n:\n        max_xor <<= 1\n    return max_xor - 1\n\nn, k = map(int, input().split())\nprint(largest_xor_sum(n, k))"}
{"solution": "def min_length_of_shorter_side(n, points):\n    max_x = max(points, key=lambda p: p[0])[0]\n    max_y = max(points, key=lambda p: p[1])[1]\n    return max(max_x, max_y)\n\nn = int(input().strip())\npoints = [tuple(map(int, input().strip().split())) for _ in range(n)]\nprint(min_length_of_shorter_side(n, points))"}
{"solution": "def max_nineteen_count(s):\n    # Count the occurrences of each character in the string\n    char_count = {'n': 0, 'i': 0, 'e': 0, 't': 0}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n    \n    # 'n' appears 3 times in \"nineteen\", but after the first occurrence, it only appears twice\n    char_count['n'] = (char_count['n'] - 1) // 2\n    \n    # 'e' appears 3 times in \"nineteen\"\n    char_count['e'] //= 3\n    \n    # The maximum number of \"nineteen\"s is limited by the least frequent required character\n    return min(char_count.values())\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(max_nineteen_count(s))"}
{"solution": "def highest_branch(p, y):\n    for i in range(y, p, -1):\n        for j in range(2, p + 1):\n            if i % j == 0:\n                break\n        else:\n            return i\n    return -1\n\n# Read input\np, y = map(int, input().split())\n\n# Output the result\nprint(highest_branch(p, y))"}
{"solution": "def find_minimum_distance(n, m, k, prices):\n    min_distance = float('inf')\n    for i in range(n):\n        if prices[i] > 0 and prices[i] <= k:\n            distance = abs(m - 1 - i) * 10\n            if distance < min_distance:\n                min_distance = distance\n    return min_distance\n\n# Read input\nn, m, k = map(int, input().split())\nprices = list(map(int, input().split()))\n\n# Find and print the minimum distance\nprint(find_minimum_distance(n, m, k, prices))"}
{"solution": "def can_transform(n, m, A, B):\n    from collections import Counter\n    \n    # Check if the frequency of elements in each row and column match\n    for i in range(n):\n        if Counter(A[i]) != Counter(B[i]):\n            return \"NO\"\n    \n    for j in range(m):\n        col_A = [A[i][j] for i in range(n)]\n        col_B = [B[i][j] for i in range(n)]\n        if Counter(col_A) != Counter(col_B):\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nB = [list(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(can_transform(n, m, A, B))"}
{"solution": "def longest_uncommon_subsequence(a, b):\n    if a == b:\n        return -1\n    return max(len(a), len(b))\n\n# Read input\na = input().strip()\nb = input().strip()\n\n# Output the result\nprint(longest_uncommon_subsequence(a, b))"}
{"solution": "def find_common_scream_time(a, b, c, d):\n    for t in range(max(b, d), 10001):\n        if (t - b) % a == 0 and (t - d) % c == 0:\n            return t\n    return -1\n\n# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Output the result\nprint(find_common_scream_time(a, b, c, d))"}
{"solution": "def split_into_three_non_multiples_of_three(n):\n    if n % 3 == 0:\n        a = b = 1\n        c = n - 2\n    elif n % 3 == 1:\n        a = b = 1\n        c = n - 2\n    else:  # n % 3 == 2\n        a = b = 2\n        c = n - 4\n    \n    return a, b, c\n\n# Read input\nn = int(input().strip())\n\n# Get the result\na, b, c = split_into_three_non_multiples_of_three(n)\n\n# Print the result\nprint(a, b, c)"}
{"solution": "def count_valid_squares(n, a, b, c, d):\n    count = 0\n    for x in range(1, n + 1):\n        for y in range(1, n + 1):\n            for z in range(1, n + 1):\n                for w in range(1, n + 1):\n                    if (a + b == x + y and\n                        b + d == y + w and\n                        d + c == w + z and\n                        c + a == z + x):\n                        count += 1\n    return count\n\n# Read input\nn, a, b, c, d = map(int, input().split())\n\n# Calculate and print the number of distinct valid squares\nprint(count_valid_squares(n, a, b, c, d))"}
{"solution": "def final_weight_of_snowball(w, h, u1, d1, u2, d2):\n    while h > 0:\n        w += h\n        if h == d1:\n            w = max(0, w - u1)\n        if h == d2:\n            w = max(0, w - u2)\n        h -= 1\n    return w\n\n# Read input\nw, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\n# Calculate and print the final weight of the snowball\nprint(final_weight_of_snowball(w, h, u1, d1, u2, d2))"}
{"solution": "def find_passing_rate(m, c, x, y):\n    for k in range(1, m + 1):\n        beginner_group = sum(c[:k])\n        intermediate_group = sum(c[k:])\n        if x <= beginner_group <= y and x <= intermediate_group <= y:\n            return k\n    return 0\n\n# Read input\nm = int(input())\nc = list(map(int, input().split()))\nx, y = map(int, input().split())\n\n# Find and print the passing rate\nprint(find_passing_rate(m, c, x, y))"}
{"solution": "def min_coins_to_reduce_to_one(n, k, A, B):\n    coins = 0\n    while n > 1:\n        if n % k == 0:\n            potential_save = (n - n // k) * A\n            if potential_save > B:\n                coins += B\n                n //= k\n            else:\n                coins += (n - 1) * A\n                n = 1\n        else:\n            coins += (n % k) * A\n            n -= n % k\n    return coins\n\n# Read input\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\n# Output the result\nprint(min_coins_to_reduce_to_one(n, k, A, B))"}
{"solution": "import math\n\ndef min_value_and_operations(n):\n    operations = 0\n    while n > 1:\n        sqrt_n = math.isqrt(n)\n        if sqrt_n * sqrt_n == n:\n            n = sqrt_n\n            operations += 1\n        else:\n            break\n    return n, operations\n\ndef main():\n    n = int(input().strip())\n    min_n, min_ops = min_value_and_operations(n)\n    print(min_n, min_ops)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_score(N, K, R, S, P, T):\n    # Initialize the score\n    score = 0\n    # Initialize a list to keep track of the hands played\n    played = [None] * N\n    \n    # Dictionary to map the machine's hand to the player's winning hand and points\n    win_map = {'r': ('P', P), 's': ('R', R), 'p': ('S', S)}\n    \n    # Iterate over each round\n    for i in range(N):\n        machine_hand = T[i]\n        # Check if we can use the same hand as we used K rounds ago\n        if i >= K and played[i - K] == win_map[machine_hand][0]:\n            continue\n        # If we can, play the winning hand and add the points\n        played[i] = win_map[machine_hand][0]\n        score += win_map[machine_hand][1]\n    \n    return score\n\n# Read input\nN, K = map(int, input().split())\nR, S, P = map(int, input().split())\nT = input()\n\n# Calculate and print the maximum score\nprint(max_score(N, K, R, S, P, T))"}
{"solution": "def max_good_string_length(a, b, c):\n    # Start with the minimum of 'a' and 'b' to ensure alternating 'a' and 'b'\n    length = 2 * min(a, b)\n    \n    # If 'a' is greater than 'b', we can add 'ab' strings to the end of 'b'\n    # Otherwise, if 'b' is greater, we can add 'ab' strings to the end of 'a'\n    if a != b:\n        length += 2 * min(abs(a - b), c)\n    \n    # If 'a' equals 'b', we can add 'ab' strings between them\n    else:\n        length += c\n    \n    # Add any remaining 'ab' strings that couldn't be paired with 'a' or 'b'\n    length += (c - min(abs(a - b), c)) // 2 if a != b else 0\n    \n    return length\n\n# Read input\na, b, c = map(int, input().split())\n\n# Print output\nprint(max_good_string_length(a, b, c))"}
{"solution": "def solve(n, k, p, x, y, a):\n    if k >= n or x < n or y > p or x > n * p or y < 1:\n        return \"-1\"\n    \n    total_needed = x - sum(a)\n    median_needed = (n + 1) // 2 - sum(1 for mark in a if mark >= y)\n    \n    if total_needed < (n - k) or median_needed > (n - k):\n        return \"-1\"\n    \n    result = []\n    for _ in range(median_needed):\n        result.append(y)\n        total_needed -= y\n    \n    for _ in range(n - k - median_needed):\n        mark = min(total_needed, p)\n        result.append(mark)\n        total_needed -= mark\n    \n    if total_needed < 0:\n        return \"-1\"\n    \n    return ' '.join(map(str, result))\n\n# Read input\nn, k, p, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\n# Solve the problem and print the result\nprint(solve(n, k, p, x, y, a))"}
{"solution": "def is_berlanese(s):\n    vowels = \"aouie\"\n    for i in range(len(s)):\n        if s[i] not in vowels:\n            if s[i] == 'n':\n                continue\n            if i == len(s) - 1 or s[i + 1] not in vowels:\n                return \"NO\"\n    return \"YES\"\n\n# Read input\ns = input().strip()\n\n# Output result\nprint(is_berlanese(s))"}
{"solution": "def max_dominoes(n, m, edges):\n    if m == 0:\n        return 0\n    \n    # Create a graph representation\n    graph = {i: [] for i in range(1, n+1)}\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Find the vertex with the maximum degree\n    max_degree_vertex = max(graph, key=lambda k: len(graph[k]))\n    max_degree = len(graph[max_degree_vertex])\n    \n    # Calculate the maximum number of dominoes that can be placed\n    max_domino_count = 0\n    for vertex in graph:\n        if vertex == max_degree_vertex:\n            max_domino_count += max_degree\n        else:\n            max_domino_count += len(graph[vertex])\n    \n    return max_domino_count\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output the result\nprint(max_dominoes(n, m, edges))"}
{"solution": "def max_points(n, m, prices, auction_questions):\n    prices.sort(reverse=True)\n    auction_questions = set(auction_questions)\n    points_r2 = 0\n    current_points = 0\n\n    for i in range(n):\n        if i < n - m:  # Regular questions\n            if prices[i] <= current_points:\n                points_r2 += prices[i]\n                current_points += prices[i]\n        else:  # Auction questions\n            if prices[i] <= current_points:\n                new_price = min(current_points, 2 * prices[i])\n                points_r2 += new_price\n                current_points += new_price\n\n    return points_r2\n\n# Read input\nn, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauction_questions = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_points(n, m, prices, auction_questions))"}
{"solution": "def calculate_score(m, w, hs, hu):\n    problem_points = [500, 1000, 1500, 2000, 2500]\n    score = 0\n    for i in range(5):\n        score += max(0.3 * problem_points[i], (1 - m[i] / 250) * problem_points[i] - 50 * w[i])\n    score += 100 * hs\n    score -= 50 * hu\n    return int(score)\n\n# Read input\nm = list(map(int, input().split()))\nw = list(map(int, input().split()))\nhs, hu = map(int, input().split())\n\n# Calculate and print the score\nprint(calculate_score(m, w, hs, hu))"}
{"solution": "MOD = 998244353\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef solve(n, m, L, R):\n    total_cells = n * m\n    total_heights = R - L + 1\n    if total_cells % 2 == 1:\n        return power(total_heights, total_cells, MOD)\n    else:\n        even_heights = (R // 2) - ((L - 1) // 2)\n        odd_heights = total_heights - even_heights\n        return (power(even_heights + odd_heights, total_cells, MOD) + power(even_heights - odd_heights, total_cells, MOD)) * power(2, MOD - 2, MOD) % MOD\n\nn, m, L, R = map(int, input().split())\nprint(solve(n, m, L, R))"}
{"solution": "def is_possible(n, m, a, b):\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] > b[i][j]:\n                a[i][j], b[i][j] = b[i][j], a[i][j]\n    \n    for i in range(n):\n        for j in range(1, m):\n            if a[i][j] <= a[i][j - 1] or b[i][j] <= b[i][j - 1]:\n                return \"Impossible\"\n    \n    for j in range(m):\n        for i in range(1, n):\n            if a[i][j] <= a[i - 1][j] or b[i][j] <= b[i - 1][j]:\n                return \"Impossible\"\n    \n    return \"Possible\"\n\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nb = [list(map(int, input().split())) for _ in range(n)]\n\nprint(is_possible(n, m, a, b))"}
{"solution": "def max_string_length(n, limits):\n    limits.sort(reverse=True)\n    max_length = 0\n    prev_count = float('inf')\n    \n    for i in range(n):\n        if limits[i] >= prev_count:\n            limits[i] = prev_count - 1\n        if limits[i] <= 0:\n            break\n        max_length += limits[i]\n        prev_count = limits[i]\n    \n    return max_length\n\n# Read input\nn = int(input())\nlimits = list(map(int, input().split()))\n\n# Output the result\nprint(max_string_length(n, limits))"}
{"solution": "def min_problems_to_solve(n, k, difficulties):\n    difficulties.sort()\n    count = 0\n    max_solved = k\n    \n    for difficulty in difficulties:\n        while difficulty > 2 * max_solved:\n            max_solved *= 2\n            count += 1\n        max_solved = max(max_solved, difficulty)\n    \n    return count\n\n# Read input\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Output the result\nprint(min_problems_to_solve(n, k, difficulties))"}
{"solution": "def distribute_diplomas(n, min_max_1, min_max_2, min_max_3):\n    min_1, max_1 = min_max_1\n    min_2, max_2 = min_max_2\n    min_3, max_3 = min_max_3\n\n    # Start by maximizing the number of first-degree diplomas\n    first_degree = min(max_1, n - min_2 - min_3)\n    remaining = n - first_degree\n\n    # Then maximize the number of second-degree diplomas\n    second_degree = min(max_2, remaining - min_3)\n    remaining -= second_degree\n\n    # The rest will be third-degree diplomas\n    third_degree = remaining\n\n    return first_degree, second_degree, third_degree\n\n# Read input\nn = int(input())\nmin_max_1 = tuple(map(int, input().split()))\nmin_max_2 = tuple(map(int, input().split()))\nmin_max_3 = tuple(map(int, input().split()))\n\n# Calculate and print the result\nresult = distribute_diplomas(n, min_max_1, min_max_2, min_max_3)\nprint(result[0], result[1], result[2])"}
{"solution": "def predict_moon_phase(n, sizes):\n    if n == 1:\n        if sizes[0] == 0:\n            return \"UP\"\n        elif sizes[0] == 15:\n            return \"DOWN\"\n        else:\n            return -1\n    else:\n        if sizes[-1] == 15:\n            return \"DOWN\"\n        elif sizes[-1] == 0:\n            return \"UP\"\n        else:\n            return \"UP\" if sizes[-1] - sizes[-2] == 1 else \"DOWN\"\n\n# Read input\nn = int(input())\nsizes = list(map(int, input().split()))\n\n# Predict and print the output\nprint(predict_moon_phase(n, sizes))"}
{"solution": "def can_transform(s, t):\n    vowels = 'aeiou'\n    if len(s) != len(t):\n        return \"No\"\n    for i in range(len(s)):\n        if (s[i] in vowels) != (t[i] in vowels):\n            return \"No\"\n    return \"Yes\"\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Output result\nprint(can_transform(s, t))"}
{"solution": "def pawn_chess_winner(board):\n    white_moves = float('inf')\n    black_moves = float('inf')\n\n    # Check for the minimum moves required for white pawns to reach row 1\n    for r in range(8):\n        for c in range(8):\n            if board[r][c] == 'W':\n                can_move = True\n                for i in range(r - 1, -1, -1):\n                    if board[i][c] != '.':\n                        can_move = False\n                        break\n                if can_move:\n                    white_moves = min(white_moves, r)\n\n    # Check for the minimum moves required for black pawns to reach row 8\n    for r in range(7, -1, -1):\n        for c in range(8):\n            if board[r][c] == 'B':\n                can_move = True\n                for i in range(r + 1, 8):\n                    if board[i][c] != '.':\n                        can_move = False\n                        break\n                if can_move:\n                    black_moves = min(black_moves, 7 - r)\n\n    # Determine the winner based on the minimum moves required\n    if white_moves <= black_moves:\n        return 'A'\n    else:\n        return 'B'\n\n# Read input\nboard = [input().strip() for _ in range(8)]\n\n# Output the result\nprint(pawn_chess_winner(board))"}
{"solution": "def max_equal_length(n, A, m, B):\n    i, j = 0, 0\n    sum_a, sum_b = 0, 0\n    max_length = 0\n\n    while i < n and j < m:\n        if sum_a == sum_b:\n            max_length += 1\n            sum_a = A[i]\n            sum_b = B[j]\n            i += 1\n            j += 1\n        elif sum_a < sum_b:\n            if i < n:\n                sum_a += A[i]\n                i += 1\n        else:\n            if j < m:\n                sum_b += B[j]\n                j += 1\n\n    while i < n:\n        sum_a += A[i]\n        i += 1\n\n    while j < m:\n        sum_b += B[j]\n        j += 1\n\n    if sum_a == sum_b:\n        return max_length\n    else:\n        return -1\n\n# Read input\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\n# Output the result\nprint(max_equal_length(n, A, m, B))"}
{"solution": "def is_from_contest(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    count = sum(problem_name.count(friend) for friend in friends)\n    return \"YES\" if count == 1 else \"NO\"\n\n# Read input\nproblem_name = input().strip()\n\n# Output result\nprint(is_from_contest(problem_name))"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_min_l(a, b, k):\n    primes = [0] * (b - a + 1)\n    for i in range(a, b + 1):\n        primes[i - a] = is_prime(i)\n    \n    left, right = 1, b - a + 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        found = False\n        prime_count = 0\n        for i in range(mid):\n            if primes[i]:\n                prime_count += 1\n        if prime_count >= k:\n            found = True\n        for i in range(mid, b - a + 1):\n            if primes[i - mid]:\n                prime_count -= 1\n            if primes[i]:\n                prime_count += 1\n            if prime_count >= k:\n                found = True\n        if found:\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    return result\n\na, b, k = map(int, input().split())\nprint(find_min_l(a, b, k))"}
{"solution": "def min_distance(a, h, w):\n    if a > h or a > w:\n        return -1\n    if a == h and a == w:\n        return 0\n    \n    # Calculate the maximum number of photos that can fit in each dimension\n    max_rows = h // a\n    max_cols = w // a\n    \n    # Calculate the maximum x that can be achieved with the maximum number of photos\n    x_max_rows = (h - max_rows * a) / (max_rows + 1)\n    x_max_cols = (w - max_cols * a) / (max_cols + 1)\n    \n    # The minimum x is the maximum of the two calculated x values\n    min_x = max(x_max_rows, x_max_cols)\n    \n    return min_x\n\n# Read input\na, h, w = map(int, input().split())\n\n# Calculate and print the result\nprint(\"{:.6f}\".format(min_distance(a, h, w)))"}
{"solution": "def chapters_to_read(n, chapters, k):\n    chapters_not_read = 0\n    for chapter in chapters:\n        if k <= chapter[1]:\n            chapters_not_read += 1\n    return chapters_not_read\n\nn = int(input())\nchapters = [tuple(map(int, input().split())) for _ in range(n)]\nk = int(input())\n\nprint(chapters_to_read(n, chapters, k))"}
{"solution": "def can_form_codeforces(banner):\n    target = \"CODEFORCES\"\n    n = len(banner)\n    m = len(target)\n    \n    # Check if the banner already contains the target word\n    if target in banner:\n        return \"YES\"\n    \n    # Check if we can cut out a substring to form the target word\n    for i in range(m + 1):\n        if banner[:i] + banner[i + (n - m):] == target:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nbanner = input().strip()\n\n# Output result\nprint(can_form_codeforces(banner))"}
{"solution": "def min_triangulation_weight(n):\n    # Initialize a 2D array to store the minimum weights for subproblems\n    dp = [[0] * n for _ in range(n)]\n\n    # Base case: for a triangle, the weight is simply the product of its vertices\n    for i in range(n - 2):\n        dp[i][i + 2] = (i + 1) * (i + 2) * (i + 3)\n\n    # Fill the dp table for larger polygons\n    for length in range(3, n):\n        for i in range(n - length):\n            j = i + length\n            dp[i][j] = float('inf')\n            for k in range(i + 1, j):\n                # Calculate the weight of the triangulation using the k-th vertex as a split point\n                weight = dp[i][k] + dp[k][j] + (i + 1) * (k + 1) * (j + 1)\n                dp[i][j] = min(dp[i][j], weight)\n\n    return dp[0][n - 1]\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(min_triangulation_weight(n))"}
{"solution": "def count_digits(n):\n    digits = 0\n    length = 1\n    while n >= 10**length:\n        digits += length * (10**length - 10**(length - 1))\n        length += 1\n    digits += length * (n - 10**(length - 1) + 1)\n    return digits\n\nn = int(input())\nprint(count_digits(n))"}
{"solution": "def find_winning_color(n, A, car_colors):\n    color_counts = {}\n    for color in car_colors:\n        if color != A:\n            color_counts[color] = color_counts.get(color, 0) + 1\n        else:\n            color_counts = {c: count - 1 for c, count in color_counts.items() if count > 0}\n    \n    for color, count in color_counts.items():\n        if count == 0:\n            return color\n    return -1\n\n# Read input\nn, A = map(int, input().split())\ncar_colors = list(map(int, input().split()))\n\n# Find and print the winning color\nprint(find_winning_color(n, A, car_colors))"}
{"solution": "def check_crossword(n, x, encoding):\n    total_ones = sum(encoding)\n    min_length = total_ones + len(encoding) - 1\n    max_length = total_ones + (len(encoding) - 1) * 10000\n    \n    if min_length <= x <= max_length:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, x = map(int, input().split())\nencoding = list(map(int, input().split()))\n\n# Output result\nprint(check_crossword(n, x, encoding))"}
{"solution": "def min_coins(n, S):\n    # The minimum number of coins required to get sum S is to use the largest coin value as much as possible\n    # Therefore, the minimum number of coins is S divided by n, rounded up\n    return (S + n - 1) // n\n\n# Read input\nn, S = map(int, input().split())\n\n# Output the result\nprint(min_coins(n, S))"}
{"solution": "from collections import Counter\n\ndef min_changes_to_palindrome(s):\n    n = len(s)\n    changes = 0\n    s_counter = Counter(s)\n    \n    # Count the number of changes needed to make the string a palindrome\n    for letter, count in s_counter.items():\n        if count % 2 != 0:\n            changes += 1\n    \n    # If the string length is odd, we can have one odd count letter in the middle\n    changes = max(0, (changes - 1)) // 2\n    \n    # Create the lexicographically smallest palindrome\n    half = (n // 2)\n    palindrome = [''] * n\n    left_half = []\n    \n    for letter, count in sorted(s_counter.items()):\n        # Use half of the letters for the left half of the palindrome\n        while count >= 2:\n            left_half.append(letter)\n            count -= 2\n        s_counter[letter] = count\n    \n    # Fill the left half and mirror it to the right half\n    for i in range(half):\n        palindrome[i] = left_half[i]\n        palindrome[n - i - 1] = left_half[i]\n    \n    # If the string length is odd, place the remaining odd count letter in the middle\n    if n % 2 == 1:\n        for letter, count in s_counter.items():\n            if count == 1:\n                palindrome[half] = letter\n                break\n    \n    return ''.join(palindrome)\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(min_changes_to_palindrome(s))"}
{"solution": "def calculate_weight(board):\n    weights = {'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n               'q': -9, 'r': -5, 'b': -3, 'n': -3, 'p': -1}\n    total_weight = 0\n    for row in board:\n        for piece in row:\n            if piece in weights:\n                total_weight += weights[piece]\n    return total_weight\n\ndef main():\n    board = [input().strip() for _ in range(8)]\n    weight = calculate_weight(board)\n    if weight > 0:\n        print(\"White\")\n    elif weight < 0:\n        print(\"Black\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import deque\n\ndef solve_sugoroku(N, M, S):\n    # Initialize a queue for BFS and a list to store the minimum turns to reach each square\n    queue = deque([(0, [])])\n    min_turns = [float('inf')] * (N + 1)\n    min_turns[0] = 0\n\n    # Perform BFS to find the shortest path\n    while queue:\n        current_square, path = queue.popleft()\n        current_turn = len(path)\n\n        # If we reached the goal, return the path\n        if current_square == N:\n            return ' '.join(map(str, path))\n\n        # Explore all possible moves\n        for move in range(1, M + 1):\n            next_square = current_square + move\n            if next_square <= N and S[next_square] == '0' and current_turn + 1 < min_turns[next_square]:\n                min_turns[next_square] = current_turn + 1\n                queue.append((next_square, path + [move]))\n\n    # If no path is found, return -1\n    return -1\n\n# Read input\nN, M = map(int, input().split())\nS = input()\n\n# Solve the problem and print the result\nprint(solve_sugoroku(N, M, S))"}
{"solution": "def solve(K, X, Y):\n    if (X + Y) % 2 != 0 and K % 2 == 0:\n        return -1\n    \n    if abs(X) + abs(Y) < K and (abs(X) + abs(Y)) % K != 0:\n        return -1\n    \n    path = []\n    x, y = 0, 0\n    while abs(X - x) + abs(Y - y) > K:\n        if abs(X - x) > abs(Y - y):\n            if X > x:\n                x += K\n            else:\n                x -= K\n        else:\n            if Y > y:\n                y += K\n            else:\n                y -= K\n        path.append((x, y))\n    \n    if abs(X - x) + abs(Y - y) == K:\n        path.append((X, Y))\n    else:\n        if (X + Y) % 2 == 0:\n            path.append((X, Y))\n        else:\n            path.append((x + (X - x) // 2, y + (Y - y) // 2))\n            path.append((X, Y))\n    \n    return path\n\nK = int(input())\nX, Y = map(int, input().split())\n\nresult = solve(K, X, Y)\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for x, y in result:\n        print(x, y)"}
{"solution": "def find_smallest_n(m):\n    if m == 1:\n        return 8\n    elif m == 8:\n        return 54\n    elif m == 10:\n        return -1\n    else:\n        return -1\n\n# Read input\nm = int(input().strip())\n\n# Find and print the smallest n\nprint(find_smallest_n(m))"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    \n    # If the circles do not intersect\n    if d >= r1 + r2:\n        return 0.0\n    \n    # If one circle is inside the other\n    if d <= abs(r1 - r2):\n        return math.pi * min(r1, r2)**2\n    \n    # Using the formula for the area of intersection of two circles\n    # https://mathworld.wolfram.com/Circle-CircleIntersection.html\n    r1_sq, r2_sq = r1**2, r2**2\n    d1 = (r1_sq - r2_sq + d**2) / (2 * d)\n    d2 = d - d1\n    intersection_area = (r1_sq * math.acos(d1 / r1) - d1 * math.sqrt(r1_sq - d1**2) +\n                         r2_sq * math.acos(d2 / r2) - d2 * math.sqrt(r2_sq - d2**2))\n    \n    return intersection_area\n\n# Read input\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\n# Calculate and print the area of intersection\nprint(\"{:.20f}\".format(circle_intersection_area(x1, y1, r1, x2, y2, r2)))"}
{"solution": "def minimize_n(v):\n    if v == 1:\n        return 1\n    return 1\n\n# Read input\nv = int(input().strip())\n\n# Output the result\nprint(minimize_n(v))"}
{"solution": "def max_citizens_caught(n, p, a):\n    # Initialize a list to store the maximum citizens that can be caught from each square\n    max_caught = [0] * n\n    # Initialize the result with the citizens on the main square\n    result = a[0]\n    \n    # Iterate over each square starting from the last one\n    for i in range(n - 1, 0, -1):\n        # Update the maximum citizens that can be caught from the current square\n        max_caught[i] = max(max_caught[i], a[i])\n        # Update the parent square's maximum citizens that can be caught\n        max_caught[p[i - 1] - 1] = max(max_caught[p[i - 1] - 1], max_caught[i])\n        # Update the result with the maximum citizens that can be caught from the current square\n        result = max(result, max_caught[i])\n    \n    # Return the final result\n    return result\n\n# Read input\nn = int(input())\np = list(map(int, input().split()))\na = list(map(int, input().split()))\n\n# Print the output\nprint(max_citizens_caught(n, p, a))"}
{"solution": "def count_possible_words(n, S, T):\n    count = 0\n    for i in range(n + 1):\n        if S[:i] == T[:i] and S[i:] == T[i:]:\n            count += 1\n    return count\n\n# Read input\nn = int(input())\nS = input().strip()\nT = input().strip()\n\n# Calculate and print the result\nprint(count_possible_words(n, S, T))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_ints():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef read_int():\n    return int(sys.stdin.readline().strip())\n\ndef min_computer_strength(n, strengths, connections):\n    # Create a graph from the connections\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Sort banks by their strength\n    banks = sorted([(strengths[i-1], i) for i in range(1, n+1)])\n    \n    # Initialize the strength of Inzane's computer\n    computer_strength = 0\n    \n    # Keep track of offline banks\n    offline = set()\n    \n    # Process each bank in increasing order of strength\n    for strength, bank in banks:\n        # Check if the bank is neighboring to an offline bank\n        if any(neighbor in offline for neighbor in graph[bank]):\n            # Update the computer strength if necessary\n            computer_strength = max(computer_strength, strength)\n            # Mark the bank as offline\n            offline.add(bank)\n    \n    return computer_strength\n\n# Read input\nn = read_int()\nstrengths = read_ints()\nconnections = [read_ints() for _ in range(n-1)]\n\n# Compute and print the result\nprint(min_computer_strength(n, strengths, connections))"}
{"solution": "def max_groups(n, m):\n    if m == 0:\n        return 1\n    return min(n - m, m)\n\n# Read input\nn, m = map(int, input().split())\n\n# Output the result\nprint(max_groups(n, m))"}
{"solution": "k, r = map(int, input().split())\n\nfor i in range(1, 11):\n    if (k * i) % 10 == 0 or (k * i) % 10 == r:\n        print(i)\n        break"}
{"solution": "def can_form_rectangle(n, m, piece):\n    # Find the top-left and bottom-right corners of the 'X' region\n    top_left = (n, m)\n    bottom_right = (0, 0)\n    for i in range(n):\n        for j in range(m):\n            if piece[i][j] == 'X':\n                top_left = (min(top_left[0], i), min(top_left[1], j))\n                bottom_right = (max(bottom_right[0], i), max(bottom_right[1], j))\n\n    # Check if the region from top_left to bottom_right is fully filled with 'X'\n    for i in range(top_left[0], bottom_right[0] + 1):\n        for j in range(top_left[1], bottom_right[1] + 1):\n            if piece[i][j] != 'X':\n                return \"NO\"\n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\npiece = [input() for _ in range(n)]\n\n# Output result\nprint(can_form_rectangle(n, m, piece))"}
{"solution": "def min_segments(x1, y1, x2, y2, x3, y3):\n    # Sort points by x-coordinate, then by y-coordinate\n    points = sorted([(x1, y1), (x2, y2), (x3, y3)])\n    \n    # Initialize segment count\n    segments = 0\n    \n    # Check for vertical segments first\n    if points[0][0] == points[1][0]:\n        segments += 1\n    else:\n        segments += 2\n    \n    if points[1][0] == points[2][0]:\n        segments += 1\n    else:\n        segments += 2\n    \n    # Check for horizontal segments connecting the middle point\n    if points[0][1] == points[1][1] or points[1][1] == points[2][1]:\n        segments += 1\n    else:\n        segments += 2\n    \n    return segments\n\n# Read input\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\n# Output the result\nprint(min_segments(x1, y1, x2, y2, x3, y3))"}
{"solution": "def generate_k_regular_graph_with_bridge(k):\n    if k == 1:\n        return \"YES\\n2 1\\n1 2\"\n    if k % 2 == 0:\n        n = k + 2\n        edges = []\n        for i in range(1, k + 1):\n            edges.append((i, i + 1))\n        edges.append((k + 1, 1))\n        for i in range(1, k + 1, 2):\n            for j in range(k + 2, n + 1):\n                edges.append((i, j))\n                edges.append((i + 1, j))\n        return f\"YES\\n{n} {len(edges)}\\n\" + \"\\n\".join(f\"{a} {b}\" for a, b in edges)\n    return \"NO\"\n\nk = int(input().strip())\nprint(generate_k_regular_graph_with_bridge(k))"}
{"solution": "def count_occurrences(s, t, queries):\n    n, m = len(s), len(t)\n    results = []\n    for l, r in queries:\n        count = 0\n        for i in range(l - 1, r - m + 1):\n            if s[i:i + m] == t:\n                count += 1\n        results.append(count)\n    return results\n\n# Read input\nn, m, q = map(int, input().split())\ns = input().strip()\nt = input().strip()\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Process queries and print results\nresults = count_occurrences(s, t, queries)\nfor result in results:\n    print(result)"}
{"solution": "MOD = 1000000007\n\ndef count_paths(n, k, d):\n    dp = [[0 for _ in range(2)] for _ in range(n+1)]\n    dp[0][0] = 1  # Base case: 1 way to make weight 0 without using any edge of weight at least d\n\n    for weight in range(1, n+1):\n        for child_weight in range(1, k+1):\n            if weight >= child_weight:\n                if child_weight >= d:\n                    dp[weight][1] = (dp[weight][1] + dp[weight-child_weight][0] + dp[weight-child_weight][1]) % MOD\n                else:\n                    dp[weight][0] = (dp[weight][0] + dp[weight-child_weight][0]) % MOD\n                    dp[weight][1] = (dp[weight][1] + dp[weight-child_weight][1]) % MOD\n\n    return dp[n][1]\n\n# Read input\nn, k, d = map(int, input().split())\n\n# Calculate and print the result\nprint(count_paths(n, k, d))"}
{"solution": "def encrypt_row(n, row):\n    groups = []\n    count = 0\n    for square in row:\n        if square == 'B':\n            count += 1\n        elif count > 0:\n            groups.append(count)\n            count = 0\n    if count > 0:\n        groups.append(count)\n    return len(groups), groups\n\nn = int(input())\nrow = input()\n\nk, sizes = encrypt_row(n, row)\nprint(k)\nif k > 0:\n    print(' '.join(map(str, sizes)))"}
{"solution": "def process_operations(n, m, p, cbs, operations):\n    stack = []\n    pairs = [0] * n\n    for i, bracket in enumerate(cbs):\n        if bracket == '(':\n            stack.append(i)\n        else:\n            left = stack.pop()\n            pairs[left] = i\n            pairs[i] = left\n\n    cursor = p - 1\n    deleted = [False] * n\n    for operation in operations:\n        if operation == 'L':\n            cursor -= 1\n        elif operation == 'R':\n            cursor += 1\n        elif operation == 'D':\n            start, end = cursor, pairs[cursor]\n            if start > end:\n                start, end = end, start\n            for i in range(start, end + 1):\n                deleted[i] = True\n            cursor = end + 1\n            while cursor < n and deleted[cursor]:\n                cursor += 1\n            if cursor == n:\n                cursor = start - 1\n                while cursor >= 0 and deleted[cursor]:\n                    cursor -= 1\n\n    result = []\n    for i, bracket in enumerate(cbs):\n        if not deleted[i]:\n            result.append(bracket)\n    return ''.join(result)\n\n# Read input\nn, m, p = map(int, input().split())\ncbs = input().strip()\noperations = input().strip()\n\n# Process and print output\nprint(process_operations(n, m, p, cbs, operations))"}
{"solution": "def find_y(n, questions_answers):\n    min_y = -2 * 10**9\n    max_y = 2 * 10**9\n    \n    for qa in questions_answers:\n        sign, x, answer = qa.split()\n        x = int(x)\n        \n        if sign == '>':\n            if answer == 'Y':\n                min_y = max(min_y, x + 1)\n            else:\n                max_y = min(max_y, x)\n        elif sign == '<':\n            if answer == 'Y':\n                max_y = min(max_y, x - 1)\n            else:\n                min_y = max(min_y, x)\n        elif sign == '>=':\n            if answer == 'Y':\n                min_y = max(min_y, x)\n            else:\n                max_y = min(max_y, x - 1)\n        elif sign == '<=':\n            if answer == 'Y':\n                max_y = min(max_y, x)\n            else:\n                min_y = max(min_y, x + 1)\n    \n    if min_y > max_y:\n        return \"Impossible\"\n    else:\n        return min_y\n\n# Read input\nn = int(input())\nquestions_answers = [input() for _ in range(n)]\n\n# Find and print y\nprint(find_y(n, questions_answers))"}
{"solution": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef count_periods(a, b):\n    if a == b:\n        return a + 1\n    elif a > b:\n        return a // gcd(a, b) + 1\n    else:\n        return b // gcd(a, b) + 1\n\na, b = map(int, input().split())\nprint(count_periods(a, b))"}
{"solution": "def generate_unique_name():\n    import string\n    import random\n    return ''.join(random.choice(string.ascii_uppercase) + ''.join(random.choice(string.ascii_lowercase) for _ in range(random.randint(0, 9))))\n\ndef solve(n, k, effectiveness):\n    names = [''] * n\n    for i in range(n - k + 1):\n        if effectiveness[i] == 'YES':\n            # Ensure the next k names are unique\n            seen = set()\n            for j in range(i, i + k):\n                if names[j] == '':\n                    new_name = generate_unique_name()\n                    while new_name in seen:\n                        new_name = generate_unique_name()\n                    names[j] = new_name\n                    seen.add(new_name)\n        else:\n            # If NO, ensure at least two names are the same if not already named\n            if i > 0 and names[i - 1] != '' and names[i + k - 1] == '':\n                names[i + k - 1] = names[i - 1]\n            elif i + k < n and names[i + k] != '' and names[i] == '':\n                names[i] = names[i + k]\n            elif names[i] == '' and names[i + 1] == '':\n                name = generate_unique_name()\n                names[i] = name\n                names[i + 1] = name\n    # Fill in any remaining empty names\n    for i in range(n):\n        if names[i] == '':\n            names[i] = generate_unique_name()\n    return ' '.join(names)\n\n# Read input\nn, k = map(int, input().split())\neffectiveness = input().split()\n\n# Solve the problem and print the output\nprint(solve(n, k, effectiveness))"}
{"solution": "def min_operations_to_equal_cheese(a, b):\n    operations = 0\n    while a != b:\n        if a % 2 == 0 and a // 2 >= b:\n            a //= 2\n        elif a % 3 == 0 and a // 3 >= b:\n            a //= 3\n        elif a % 5 == 0 and a // 5 >= b:\n            a //= 5\n        elif b % 2 == 0 and b // 2 >= a:\n            b //= 2\n        elif b % 3 == 0 and b // 3 >= a:\n            b //= 3\n        elif b % 5 == 0 and b // 5 >= a:\n            b //= 5\n        else:\n            return -1\n        operations += 1\n    return operations\n\n# Read input\na, b = map(int, input().split())\n\n# Output the result\nprint(min_operations_to_equal_cheese(a, b))"}
{"solution": "def min_cost_to_form_palindrome(n, a, b, c):\n    cost = 0\n    for i in range(n // 2):\n        left, right = c[i], c[n - 1 - i]\n        if left == 2 and right == 2:\n            cost += 2 * min(a, b)\n        elif left == 2:\n            cost += a if right == 0 else b\n        elif right == 2:\n            cost += a if left == 0 else b\n        elif left != right:\n            return -1\n    if n % 2 == 1 and c[n // 2] == 2:\n        cost += min(a, b)\n    return cost\n\n# Read input\nn, a, b = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Output the result\nprint(min_cost_to_form_palindrome(n, a, b, c))"}
{"solution": "def paint_cube(k):\n    if k == 1:\n        return -1\n    if k % 2 == 0:\n        pattern = ['b', 'w']\n    else:\n        pattern = ['b', 'w', 'b']\n    \n    for layer in range(k):\n        for row in range(k):\n            for col in range(k):\n                print(pattern[(row + col + layer) % len(pattern)], end='')\n            print()\n        print()\n\nk = int(input())\nresult = paint_cube(k)\nif result == -1:\n    print(result)"}
{"solution": "import math\n\ndef largest_lovely_divisor(n):\n    # Start from the largest possible square divisor and reduce until we find a lovely number\n    for i in range(int(math.sqrt(n)), 1, -1):\n        if n % (i**2) == 0:\n            n //= i\n    return n\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(largest_lovely_divisor(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    for i in range(n):\n        if seating[i] == '1':\n            if i > 0 and seating[i - 1] == '1':\n                return \"No\"\n            if i < n - 1 and seating[i + 1] == '1':\n                return \"No\"\n        else:\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                return \"No\"\n    return \"Yes\"\n\n# Read input\nn = int(input())\nseating = input()\n\n# Output result\nprint(is_maximal_seating(n, seating))"}
{"solution": "def find_possible_k(n, a):\n    possible_k = []\n    for k in range(1, n + 1):\n        valid = True\n        for i in range(k, n):\n            if a[i] - a[i - 1] != a[i - k] - a[i - k - 1]:\n                valid = False\n                break\n        if valid:\n            possible_k.append(k)\n    return possible_k\n\nn = int(input().strip())\na = [0] + list(map(int, input().strip().split()))\n\npossible_k = find_possible_k(n, a)\n\nprint(len(possible_k))\nprint(' '.join(map(str, possible_k)))"}
{"solution": "def can_form_equal_teams(scores):\n    total_score = sum(scores)\n    if total_score % 2 != 0:\n        return \"NO\"\n    half_score = total_score // 2\n    for i in range(6):\n        for j in range(i+1, 6):\n            for k in range(j+1, 6):\n                if scores[i] + scores[j] + scores[k] == half_score:\n                    return \"YES\"\n    return \"NO\"\n\n# Read input\nscores = list(map(int, input().split()))\n\n# Output result\nprint(can_form_equal_teams(scores))"}
{"solution": "def count_2_3_integers(l, r):\n    count = 0\n    x = 0\n    while 2**x <= r:\n        y = 0\n        while 2**x * 3**y <= r:\n            if l <= 2**x * 3**y:\n                count += 1\n            y += 1\n            if 2**x * 3**y > r:\n                break\n        x += 1\n        if 2**x > r:\n            break\n    return count\n\n# Read input\nl, r = map(int, input().split())\n\n# Output the result\nprint(count_2_3_integers(l, r))"}
{"solution": "def find_eaten_candies(n, k):\n    # Calculate the maximum possible candies that could be put in the box\n    max_put = (n * (n + 1)) // 2 - (n - 1)\n    \n    # Calculate the number of candies put in the box\n    put = max_put - k\n    \n    # Binary search to find the number of candies eaten\n    left, right = 0, n\n    while left < right:\n        mid = (left + right) // 2\n        if (mid * (mid + 1)) // 2 <= put:\n            left = mid + 1\n        else:\n            right = mid\n    \n    # The number of candies eaten is the number of actions minus the number of candies put\n    eaten = n - left + 1\n    return eaten\n\n# Read input\nn, k = map(int, input().split())\n\n# Output the result\nprint(find_eaten_candies(n, k))"}
{"solution": "def can_form_triangle(n, lengths):\n    lengths.sort()\n    for i in range(n - 2):\n        if lengths[i] + lengths[i + 1] > lengths[i + 2]:\n            return \"YES\"\n    return \"NO\"\n\nn = int(input())\nlengths = list(map(int, input().split()))\nprint(can_form_triangle(n, lengths))"}
{"solution": "def can_get_toys(x, y):\n    # Imp starts with 1 original toy and 0 copies\n    original = 1\n    copies = 0\n    \n    # If y is less than 1, it's impossible since Imp starts with 1 original\n    if y < 1:\n        return \"No\"\n    \n    # If y is 1, we need to check if x is 0 since we can't apply the machine to a copy if we don't have any\n    if y == 1:\n        return \"Yes\" if x == 0 else \"No\"\n    \n    # We need to apply the machine (y-1) times to the original toy to get (y-1) more originals and (y-1) copies\n    original += (y - 1)\n    copies += (y - 1)\n    \n    # After that, we need to check if we have enough copies to reach x\n    # We need to have exactly x - (y - 1) more copies, which we can get by applying the machine to the existing copies\n    if x - (y - 1) >= 0 and (x - (y - 1)) % 2 == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input\nx, y = map(int, input().split())\n\n# Print output\nprint(can_get_toys(x, y))"}
{"solution": "def maximize_rating(n, k, skills):\n    skills.sort(key=lambda x: (x % 10, x))\n    for i in range(n):\n        if k == 0:\n            break\n        while skills[i] < 100 and k > 0:\n            increment = min(10 - skills[i] % 10, k)\n            skills[i] += increment\n            k -= increment\n            if skills[i] % 10 == 0:\n                break\n    return sum(skill // 10 for skill in skills)\n\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\nprint(maximize_rating(n, k, skills))"}
{"solution": "def smallest_pretty_integer(n, m, a, b):\n    # Find the smallest digit common to both lists, if any\n    common_digits = set(a).intersection(set(b))\n    if common_digits:\n        return min(common_digits)\n    \n    # If no common digits, find the smallest from each list and combine\n    smallest_a = min(a)\n    smallest_b = min(b)\n    return min(smallest_a, smallest_b) * 10 + max(smallest_a, smallest_b)\n\n# Read input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Output the result\nprint(smallest_pretty_integer(n, m, a, b))"}
{"solution": "n, k = map(int, input().split())\n\ntime_left = 240 - k\nproblems_solved = 0\ntime_spent = 0\n\nfor i in range(1, n + 1):\n    time_spent += 5 * i\n    if time_spent <= time_left:\n        problems_solved += 1\n    else:\n        break\n\nprint(problems_solved)"}
{"solution": "def max_teams_with_full_tasks(n, x, y, a):\n    a.sort()\n    left, right = 0, n\n    while left < right:\n        mid = (left + right + 1) // 2\n        total_pages = sum(a[:mid])\n        double_sided_pages = min(total_pages // 2, x)\n        single_sided_pages = min(total_pages - 2 * double_sided_pages, y)\n        if double_sided_pages + single_sided_pages >= total_pages:\n            left = mid\n        else:\n            right = mid - 1\n    return left\n\n# Read input\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_teams_with_full_tasks(n, x, y, a))"}
{"solution": "import math\n\ndef count_distinct_lcm_ratios(b):\n    distinct_numbers = set()\n    for i in range(1, int(math.sqrt(b)) + 1):\n        if b % i == 0:\n            distinct_numbers.add(i)\n            distinct_numbers.add(b // i)\n    return len(distinct_numbers)\n\n# Read input\nb = int(input().strip())\n\n# Output the result\nprint(count_distinct_lcm_ratios(b))"}
{"solution": "def count_falling_positions(n, bumpers):\n    left_count = 0\n    right_count = 0\n    \n    for bumper in bumpers:\n        if bumper == '<':\n            left_count += 1\n        else:\n            break\n    \n    for bumper in reversed(bumpers):\n        if bumper == '>':\n            right_count += 1\n        else:\n            break\n    \n    return left_count + right_count\n\n# Read input\nn = int(input())\nbumpers = input()\n\n# Calculate and print the result\nprint(count_falling_positions(n, bumpers))"}
{"solution": "from collections import Counter\nimport heapq\n\ndef max_rectangle_area(n, lengths):\n    lengths_counter = Counter(lengths)\n    pairs = []\n    singles = []\n    \n    for length, count in lengths_counter.items():\n        if count >= 4:\n            num_rectangles = count // 4\n            pairs.extend([length] * (num_rectangles * 2))\n            if count % 4 >= 2:\n                pairs.append(length)\n            elif count % 4 == 1:\n                singles.append(length)\n        elif count >= 2:\n            pairs.append(length)\n        elif count == 1:\n            singles.append(length)\n    \n    # Use the instrument to reduce the length of the sticks\n    singles.sort()\n    while len(singles) > 1 and singles[-1] - 1 >= singles[0]:\n        pairs.append(singles.pop() - 1)\n        singles.pop(0)\n    \n    pairs.sort()\n    max_area = 0\n    for i in range(0, len(pairs) - 1, 2):\n        max_area += pairs[i] * pairs[i + 1]\n    \n    return max_area\n\n# Reading input\nn = int(input())\nlengths = list(map(int, input().split()))\n\n# Output the result\nprint(max_rectangle_area(n, lengths))"}
{"solution": "def min_sum_of_restored_numbers(n, numbers):\n    from itertools import permutations\n    \n    # Create a mapping from letters to digits\n    letters = 'abcdefghij'\n    min_sum = float('inf')\n    \n    # Try all permutations of digits for the letters\n    for perm in permutations(range(10)):\n        digit_map = {letters[i]: str(perm[i]) for i in range(10)}\n        \n        # Check if any number starts with 'a' and the corresponding digit is 0\n        if any(num[0] == 'a' and digit_map['a'] == '0' for num in numbers):\n            continue\n        \n        # Convert the numbers using the current permutation\n        converted_numbers = [int(''.join(digit_map[ch] for ch in num)) for num in numbers]\n        \n        # Calculate the sum of the converted numbers\n        current_sum = sum(converted_numbers)\n        \n        # Update the minimum sum if the current sum is smaller\n        min_sum = min(min_sum, current_sum)\n    \n    return min_sum\n\n# Read input\nn = int(input())\nnumbers = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(min_sum_of_restored_numbers(n, numbers))"}
{"solution": "def max_teams(n, m):\n    teams = 0\n    while n > 0 and m > 0:\n        if n > m:\n            n -= 2\n            m -= 1\n        else:\n            n -= 1\n            m -= 2\n        if n >= 0 and m >= 0:\n            teams += 1\n        else:\n            break\n    return teams\n\n# Read input\nn, m = map(int, input().split())\n\n# Output the result\nprint(max_teams(n, m))"}
{"solution": "def has_non_overlapping_ab_ba(s):\n    ab_index = s.find('AB')\n    ba_index = s.find('BA')\n    \n    if ab_index != -1 and 'BA' in s[ab_index+2:]:\n        return \"YES\"\n    if ba_index != -1 and 'AB' in s[ba_index+2:]:\n        return \"YES\"\n    \n    return \"NO\"\n\n# Read input\ns = input().strip()\n\n# Output result\nprint(has_non_overlapping_ab_ba(s))"}
{"solution": "def can_reach_final_queue(n, initial_weights, k, final_weights):\n    if n == k:\n        return \"YES\" if initial_weights == final_weights else \"NO\"\n    \n    # Helper function to find the sequence of eatings\n    def find_eating_sequence(initial, final):\n        sequence = []\n        i, j = 0, 0\n        while i < len(initial) and j < len(final):\n            if initial[i] == final[j]:\n                i += 1\n                j += 1\n            else:\n                if i + 1 < len(initial) and initial[i] + initial[i + 1] == final[j]:\n                    sequence.append((i + 1, 'L'))\n                    initial[i] += initial[i + 1]\n                    del initial[i + 1]\n                    j += 1\n                elif i + 1 < len(initial) and initial[i] + initial[i + 1] > final[j]:\n                    found = False\n                    for k in range(i + 2, len(initial)):\n                        if initial[i] + initial[k] == final[j]:\n                            sequence.extend([(i + 2, 'R') for _ in range(k - i - 1)])\n                            sequence.append((i + 1, 'R'))\n                            initial[i] += initial[k]\n                            del initial[k]\n                            found = True\n                            break\n                    if not found:\n                        return \"NO\"\n                    j += 1\n                else:\n                    return \"NO\"\n        return sequence if i == len(initial) and j == len(final) else \"NO\"\n\n    result = find_eating_sequence(initial_weights, final_weights)\n    if result == \"NO\":\n        return \"NO\"\n    else:\n        print(\"YES\")\n        for action in result:\n            print(action[0], action[1])\n        return \"\"\n\n# Read input\nn = int(input())\ninitial_weights = list(map(int, input().split()))\nk = int(input())\nfinal_weights = list(map(int, input().split()))\n\n# Output result\nprint(can_reach_final_queue(n, initial_weights, k, final_weights))"}
{"solution": "def can_assign_spaceships_to_bases(R, B, spaceships, bases):\n    if R != B:\n        return \"No\"\n    \n    spaceships.sort(key=lambda x: (x[0], x[1]))\n    bases.sort(key=lambda x: (x[0], x[1]))\n    \n    for i in range(R):\n        if spaceships[i][0] == bases[i][0] or spaceships[i][1] == bases[i][1]:\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nR, B = map(int, input().split())\nspaceships = [tuple(map(int, input().split())) for _ in range(R)]\nbases = [tuple(map(int, input().split())) for _ in range(B)]\n\n# Output result\nprint(can_assign_spaceships_to_bases(R, B, spaceships, bases))"}
{"solution": "def max_power_of_two_divisor(n, a):\n    max_power = 0\n    count = 0\n    for num in a:\n        power = 0\n        while num % 2 == 0:\n            num //= 2\n            power += 1\n        if power > max_power:\n            max_power = power\n            count = 1\n        elif power == max_power:\n            count += 1\n    return 2**max_power, count\n\nn = int(input())\na = list(map(int, input().split()))\nr, count = max_power_of_two_divisor(n, a)\nprint(r, count)"}
{"solution": "def min_clicks_to_get_m(n, m):\n    clicks = 0\n    while m > n:\n        if m % 2 == 0:\n            m //= 2\n        else:\n            m += 1\n        clicks += 1\n    return clicks + (n - m)\n\n# Read input\nn, m = map(int, input().split())\n\n# Output the result\nprint(min_clicks_to_get_m(n, m))"}
{"solution": "def find(parent, i):\n    if parent[i] == i:\n        return i\n    return find(parent, parent[i])\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef is_tree(n, segments):\n    parent = [i for i in range(n)]\n    rank = [0] * n\n    edges = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if segments[i][0] < segments[j][0] < segments[i][1] or segments[i][0] < segments[j][1] < segments[i][1]:\n                if find(parent, i) == find(parent, j):\n                    return \"NO\"\n                union(parent, rank, i, j)\n                edges += 1\n\n    return \"YES\" if edges == n - 1 else \"NO\"\n\nn = int(input().strip())\nsegments = [tuple(map(int, input().strip().split())) for _ in range(n)]\nprint(is_tree(n, segments))"}
{"solution": "def longest_ddos_period(n, requests):\n    max_length = 0\n    for start in range(n):\n        total_requests = 0\n        for end in range(start, n):\n            total_requests += requests[end]\n            if total_requests > 100 * (end - start + 1):\n                max_length = max(max_length, end - start + 1)\n    return max_length\n\n# Read input\nn = int(input())\nrequests = list(map(int, input().split()))\n\n# Output the result\nprint(longest_ddos_period(n, requests))"}
{"solution": "def can_dissatisfaction_be_k(n, k, sequence):\n    if k == 0:\n        return \"YES\" if \"N\" not in sequence else \"NO\"\n    \n    for i in range(n - k + 1):\n        if sequence[i] != \"Y\":\n            continue\n        if all(sequence[j] != \"N\" for j in range(i, i + k)):\n            if (i + k == n or sequence[i + k] != \"Y\") and (i == 0 or sequence[i - 1] != \"Y\"):\n                return \"YES\"\n    \n    for i in range(n - k + 1):\n        if sequence[i] != \"N\":\n            continue\n        if all(sequence[j] != \"Y\" for j in range(i, i + k)):\n            if (i + k == n or sequence[i + k] != \"N\") and (i == 0 or sequence[i - 1] != \"N\"):\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\nsequence = input().strip()\n\n# Output result\nprint(can_dissatisfaction_be_k(n, k, sequence))"}
{"solution": "def count_possible_values(N, X, D):\n    if D == 0:\n        return 1 if X == 0 else N + 1\n    \n    if D < 0:\n        X, D = -X, -D\n    \n    from collections import defaultdict\n    intervals = defaultdict(list)\n    \n    for k in range(N + 1):\n        left = k * (k - 1) // 2\n        right = k * (2 * N - k - 1) // 2\n        offset = k * X\n        intervals[offset % D].append((left, right, offset // D))\n    \n    result = 0\n    for key in intervals:\n        intervals[key].sort()\n        current_left = -float('inf')\n        current_right = -float('inf')\n        \n        for left, right, offset in intervals[key]:\n            left += offset\n            right += offset\n            if current_right < left:\n                result += current_right - current_left + 1\n                current_left = left\n                current_right = right\n            else:\n                current_right = max(current_right, right)\n        \n        result += current_right - current_left + 1\n    \n    return result\n\n# Read input\nN, X, D = map(int, input().split())\n\n# Output the result\nprint(count_possible_values(N, X, D))"}
{"solution": "def did_anton_perform_good(n, participants):\n    for participant in participants:\n        name, before, after = participant\n        if before >= 2400 and after > before:\n            return \"YES\"\n    return \"NO\"\n\n# Reading input\nn = int(input())\nparticipants = [input().split() for _ in range(n)]\nparticipants = [(name, int(before), int(after)) for name, before, after in participants]\n\n# Output result\nprint(did_anton_perform_good(n, participants))"}
{"solution": "def count_missed_trains(s):\n    s_decimal = int(s, 2)\n    count = 0\n    power_of_4 = 1\n    while power_of_4 < s_decimal:\n        count += 1\n        power_of_4 *= 4\n    return count\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(count_missed_trains(s))"}
{"solution": "def min_rows_for_mirroring(n, m, matrix_a):\n    for i in range(n // 2):\n        if matrix_a[i] != matrix_a[n - i - 1]:\n            return n\n    return n // 2 + n % 2\n\n# Read input\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(min_rows_for_mirroring(n, m, matrix_a))"}
{"solution": "def max_orders(n, orders):\n    orders.sort(key=lambda x: x[1])  # Sort by finish time\n    count = 0\n    last_finish = -1\n    for order in orders:\n        if order[0] > last_finish:\n            count += 1\n            last_finish = order[1]\n    return count\n\n# Read input\nn = int(input())\norders = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_orders(n, orders))"}
{"solution": "def can_vova_avoid_boredom(n, k, tables, formulas):\n    max_tables_in_row = max_formulas_in_row = 0\n    current_tables_in_row = current_formulas_in_row = 0\n\n    for i in range(n):\n        current_tables_in_row += tables[i]\n        current_formulas_in_row += formulas[i]\n\n        # Adjust the counts to ensure no more than k in a row\n        if current_tables_in_row > k:\n            current_tables_in_row = tables[i]\n            current_formulas_in_row = formulas[i]\n        if current_formulas_in_row > k:\n            current_formulas_in_row = formulas[i]\n            current_tables_in_row = tables[i]\n\n        # Update the maximum counts\n        max_tables_in_row = max(max_tables_in_row, current_tables_in_row)\n        max_formulas_in_row = max(max_formulas_in_row, current_formulas_in_row)\n\n        # If at any point the current counts exceed k, it's not possible\n        if max_tables_in_row > k or max_formulas_in_row > k:\n            return \"NO\"\n\n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ntables = list(map(int, input().split()))\nformulas = list(map(int, input().split()))\n\n# Output result\nprint(can_vova_avoid_boredom(n, k, tables, formulas))"}
{"solution": "def can_human_win(n, k, coefficients):\n    # Check if the polynomial is already divisible by Q(x) = x - k\n    if k == 0:\n        # If k is 0, we only need to check if the constant term is 0\n        if coefficients[0] == '?':\n            return \"Yes\"  # Human can set it to 0\n        elif coefficients[0] == 0:\n            return \"Yes\"  # It's already 0\n        else:\n            return \"No\"  # It's not 0 and can't be changed\n    else:\n        # Calculate the remainder of the polynomial when divided by x - k\n        remainder = 0\n        for i in range(n, -1, -1):\n            if coefficients[i] == '?':\n                # If there's an undefined coefficient, human can always set it to make the remainder 0\n                return \"Yes\"\n            remainder = (remainder * k + coefficients[i])\n        # If the remainder is 0, the polynomial is already divisible by x - k\n        return \"Yes\" if remainder == 0 else \"No\"\n\n# Read input\nn, k = map(int, input().split())\ncoefficients = [input().strip() if i == '?' else int(i) for i in [input().strip() for _ in range(n + 1)]]\n\n# Determine if human can guarantee victory\nresult = can_human_win(n, k, coefficients)\nprint(result)"}
{"solution": "def smallest_prime_factor(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return i\n    return n\n\ndef find_smallest_X0(X2):\n    p1 = smallest_prime_factor(X2)\n    if X2 % (p1 * p1) == 0:\n        return p1\n    else:\n        return X2 // p1\n\n# Read input\nX2 = int(input())\n\n# Find and print the smallest possible X0\nprint(find_smallest_X0(X2))"}
{"solution": "def min_p_binary_summands(n, p):\n    def can_represent(target, count):\n        for x in range(32):  # Considering powers of 2 up to 2^31\n            if target >= 0 and bin(target).count('1') <= count and count <= target:\n                return True\n            target -= p\n        return False\n\n    for count in range(1, 32 * abs(p) + 1):  # Upper bound for possible count\n        if can_represent(n, count):\n            return count\n    return -1\n\n# Read input\nn, p = map(int, input().split())\n\n# Output the result\nprint(min_p_binary_summands(n, p))"}
{"solution": "def minimize_integer(n, k, S):\n    S = list(S)\n    changes = 0\n    for i in range(n):\n        if changes == k:\n            break\n        if S[i] != '0':\n            S[i] = '0'\n            changes += 1\n    if S[0] == '0' and n > 1:\n        for i in range(1, n):\n            if S[i] != '0':\n                S[0], S[i] = S[i], '0'\n                break\n    return ''.join(S)\n\n# Reading input\nn, k = map(int, input().split())\nS = input().strip()\n\n# Output the result\nprint(minimize_integer(n, k, S))"}
{"solution": "def find_min_v(cnt_1, cnt_2, x, y):\n    def count_valid_numbers(v, x, y):\n        return v - v // x - v // y + v // (x * y)\n\n    low, high = 1, 10**18\n    while low < high:\n        mid = (low + high) // 2\n        if count_valid_numbers(mid, x, y) >= cnt_1 + cnt_2:\n            high = mid\n        else:\n            low = mid + 1\n\n    return low\n\n# Read input\ncnt_1, cnt_2, x, y = map(int, input().split())\n\n# Find and print the answer\nprint(find_min_v(cnt_1, cnt_2, x, y))"}
{"solution": "def predict_bear_position(n, sx, sy, dx, dy, t):\n    for _ in range(t):\n        k = sx + sy  # Number of raspberry bushes in the current cell\n        dx += k\n        dy += k\n        sx = ((sx + dx - 1) % n) + 1\n        sy = ((sy + dy - 1) % n) + 1\n    return sx, sy\n\n# Read input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Predict and print the output\nprint(*predict_bear_position(n, sx, sy, dx, dy, t))"}
{"solution": "def solve(s):\n    if len(s) < 26:\n        return \"-1\"\n    \n    for i in range(len(s) - 25):\n        substring = s[i:i+26]\n        if '?' in substring:\n            missing_letters = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ') - set(substring.replace('?', ''))\n            if len(missing_letters) == substring.count('?'):\n                new_substring = list(substring)\n                for j in range(26):\n                    if new_substring[j] == '?':\n                        new_substring[j] = missing_letters.pop()\n                s = s[:i] + ''.join(new_substring) + s[i+26:]\n                return s.replace('?', 'A')\n    return \"-1\"\n\n# Read input\ns = input().strip()\n\n# Solve the problem and print the result\nprint(solve(s))"}
{"solution": "def can_divide_apples(n, weights):\n    count_100 = weights.count(100)\n    count_200 = weights.count(200)\n    \n    # Check if the total weight is even\n    if (count_100 * 100 + count_200 * 200) % 200 != 0:\n        return \"NO\"\n    \n    # If there are even number of 200-gram apples, they can be divided equally\n    if count_200 % 2 == 0:\n        return \"YES\"\n    \n    # If there are odd number of 200-gram apples, we need at least one 100-gram apple to balance\n    if count_200 % 2 == 1 and count_100 >= 2:\n        return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\nweights = list(map(int, input().split()))\n\n# Output result\nprint(can_divide_apples(n, weights))"}
{"solution": "def min_time_to_turn_off_lights(n, m, building):\n    total_time = 0\n    for i in range(n - 1, -1, -1):\n        floor = building[i]\n        left_lights = floor.find('1')\n        right_lights = floor.rfind('1')\n        \n        if left_lights == -1:  # No lights on this floor\n            total_time += 1  # Just move up one floor\n            continue\n        \n        if i == n - 1:  # Ground floor\n            total_time += right_lights  # Move to the last light on the ground floor\n        else:\n            # Calculate the time to turn off lights considering the previous floor's strategy\n            total_time += min(2 * (m + 1) - 2 - left_lights, right_lights) + 1\n    \n    return total_time\n\n# Read input\nn, m = map(int, input().split())\nbuilding = [input().strip() for _ in range(n)]\n\n# Calculate and print the result\nprint(min_time_to_turn_off_lights(n, m, building))"}
{"solution": "def min_burles_to_catch_mouse(n, c, a):\n    visited = [False] * n\n    min_cost = 0\n\n    for i in range(n):\n        if not visited[i]:\n            current_room = i\n            path = []\n            while not visited[current_room]:\n                visited[current_room] = True\n                path.append(current_room)\n                current_room = a[current_room] - 1\n\n            if current_room in path:\n                cycle_start = path.index(current_room)\n                min_trap_cost = min(c[room] for room in path[cycle_start:])\n                min_cost += min_trap_cost\n\n    return min_cost\n\n# Reading input\nn = int(input())\nc = list(map(int, input().split()))\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_burles_to_catch_mouse(n, c, a))"}
{"solution": "def determine_entrance(n, a, b):\n    return (a + b - 1) % n + 1\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Output the result\nprint(determine_entrance(n, a, b))"}
{"solution": "def min_arithmetic_progressions(n, a):\n    if n == 0:\n        return 0\n    \n    progressions = 0\n    i = 0\n    \n    while i < n:\n        if a[i] == -1:\n            i += 1\n            continue\n        \n        progressions += 1\n        diff = None\n        \n        for j in range(i + 1, n):\n            if a[j] == -1:\n                continue\n            elif diff is None:\n                diff = a[j] - a[i]\n            elif a[j] - a[i] != diff * (j - i):\n                break\n        \n        i = j\n    \n    return progressions\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_arithmetic_progressions(n, a))"}
{"solution": "def max_beauty(n, k, s):\n    max_len = 0\n    for char in ['a', 'b']:\n        changes = 0\n        left = 0\n        for right in range(n):\n            if s[right] != char:\n                changes += 1\n            while changes > k:\n                if s[left] != char:\n                    changes -= 1\n                left += 1\n            max_len = max(max_len, right - left + 1)\n    return max_len\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, a):\n    total_seats = sum(a)\n    majority_seats = total_seats // 2 + 1\n    alice_seats = a[0]\n    \n    if alice_seats >= majority_seats:\n        return [1]\n    \n    coalition = [1]\n    coalition_seats = alice_seats\n    \n    for i in range(1, n):\n        if alice_seats >= 2 * a[i]:\n            coalition.append(i + 1)\n            coalition_seats += a[i]\n            if coalition_seats >= majority_seats:\n                return coalition\n    \n    return [0]\n\nn = int(input())\na = list(map(int, input().split()))\n\ncoalition = find_coalition(n, a)\nif coalition[0] == 0:\n    print(0)\nelse:\n    print(len(coalition))\n    print(' '.join(map(str, coalition)))"}
{"solution": "def max_prize(n):\n    total_reward = 0.0\n    remaining_opponents = n\n    \n    while remaining_opponents > 0:\n        max_mistakes = remaining_opponents // 2\n        if remaining_opponents % 2 == 0:\n            max_mistakes -= 1\n        total_reward += max_mistakes / remaining_opponents\n        remaining_opponents -= max_mistakes\n    \n    return total_reward\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the maximum prize\nprint(f\"{max_prize(n):.12f}\")"}
{"solution": "def distribute_candies(n):\n    candies_per_child = []\n    current_sum = 0\n    for i in range(1, n + 1):\n        if current_sum + i <= n:\n            candies_per_child.append(i)\n            current_sum += i\n        else:\n            candies_per_child[-1] += n - current_sum\n            break\n    return len(candies_per_child), candies_per_child\n\nn = int(input().strip())\nk, distribution = distribute_candies(n)\nprint(k)\nprint(*distribution)"}
{"solution": "def calculate_mod(n, m):\n    return m % (2 ** n)\n\n# Read input\nn = int(input().strip())\nm = int(input().strip())\n\n# Calculate and print the result\nprint(calculate_mod(n, m))"}
{"solution": "def correct_word(n, s):\n    vowels = 'aeiouy'\n    i = 0\n    while i < len(s) - 1:\n        if s[i] in vowels and s[i + 1] in vowels:\n            s = s[:i] + s[i + 1:]\n        else:\n            i += 1\n    return s\n\n# Read input\nn = int(input())\ns = input()\n\n# Output the corrected word\nprint(correct_word(n, s))"}
{"solution": "def max_students(n, a, b, carriage):\n    students = 0\n    i = 0\n    while i < n:\n        if carriage[i] == '.':\n            if i > 0 and carriage[i-1] in 'AB':\n                if carriage[i-1] == 'A' and b > 0:\n                    carriage = carriage[:i] + 'B' + carriage[i+1:]\n                    b -= 1\n                    students += 1\n                elif carriage[i-1] == 'B' and a > 0:\n                    carriage = carriage[:i] + 'A' + carriage[i+1:]\n                    a -= 1\n                    students += 1\n            else:\n                if a > b and a > 0:\n                    carriage = carriage[:i] + 'A' + carriage[i+1:]\n                    a -= 1\n                    students += 1\n                elif b > 0:\n                    carriage = carriage[:i] + 'B' + carriage[i+1:]\n                    b -= 1\n                    students += 1\n        i += 1\n    return students\n\n# Read input\nn, a, b = map(int, input().split())\ncarriage = input()\n\n# Output the result\nprint(max_students(n, a, b, carriage))"}
{"solution": "def find_pair(r):\n    for x in range(1, int(r**0.5) + 1):\n        if (r - x**2 - x - 1) % (2 * x) == 0:\n            y = (r - x**2 - x - 1) // (2 * x)\n            if y > 0:\n                return x, y\n    return \"NO\"\n\n# Read input\nr = int(input().strip())\n\n# Find and print the result\nresult = find_pair(r)\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "from itertools import combinations\n\ndef divide_balloons(n, a):\n    if n == 1:\n        return -1\n    for k in range(1, n):\n        for grigory_packets in combinations(range(n), k):\n            grigory_total = sum(a[i] for i in grigory_packets)\n            andrew_packets = set(range(n)) - set(grigory_packets)\n            andrew_total = sum(a[i] for i in andrew_packets)\n            if grigory_total != andrew_total:\n                return k, list(grigory_packets)\n    return -1\n\nn = int(input())\na = list(map(int, input().split()))\n\nresult = divide_balloons(n, a)\nif result == -1:\n    print(result)\nelse:\n    k, packets = result\n    print(k)\n    print(*packets)"}
{"solution": "def minimal_digit_partition(n):\n    # Start with the largest digit to minimize the number of different digits\n    digit = 9\n    digits = []\n    while n > 0 and digit > 0:\n        if n >= digit:\n            n -= digit\n            digits.append(digit)\n        else:\n            digit -= 1\n    return digits\n\n# Read input\nn = int(input())\n\n# Get the minimal digit partition\nresult = minimal_digit_partition(n)\n\n# Print the result\nprint(len(result))\nprint(' '.join(map(str, result)))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_simple_subset(n, a):\n    a.sort()\n    subset = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_prime(a[i] + a[j]):\n                subset = [a[i], a[j]]\n                break\n        if subset:\n            break\n    if not subset:\n        subset = [a[0]]\n    return subset\n\nn = int(input())\na = list(map(int, input().split()))\n\nsubset = find_simple_subset(n, a)\nprint(len(subset))\nprint(*subset)"}
{"solution": "def is_beautiful(num):\n    k = 1\n    while (2**k - 1) * (2**k) <= num:\n        if num % ((2**k - 1) * (2**k)) == 0:\n            return True\n        k += 1\n    return False\n\ndef greatest_beautiful_divisor(n):\n    for i in range(n, 0, -1):\n        if n % i == 0 and is_beautiful(i):\n            return i\n\nn = int(input())\nprint(greatest_beautiful_divisor(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_d_magic_numbers(m, d, a, b):\n    def is_d_magic(num, d):\n        num_str = str(num)\n        for i, digit in enumerate(num_str):\n            if (i % 2 == 0) != (digit == str(d)):\n                return False\n        return True\n\n    def count_d_magic_in_range(start, end):\n        count = 0\n        for num in range(start, end + 1):\n            if num % m == 0 and is_d_magic(num, d):\n                count += 1\n        return count % MOD\n\n    return count_d_magic_in_range(int(a), int(b))\n\n# Read input\nm, d = map(int, input().split())\na = input().strip()\nb = input().strip()\n\n# Output the result\nprint(count_d_magic_numbers(m, d, a, b))"}
{"solution": "def last_child(n, m, a):\n    line = list(range(1, n + 1))\n    candies = [0] * n\n    last_child = None\n\n    while line:\n        current_child = line.pop(0)\n        candies[current_child - 1] += m\n        if candies[current_child - 1] < a[current_child - 1]:\n            line.append(current_child)\n        else:\n            last_child = current_child\n\n    return last_child\n\n# Read input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(last_child(n, m, a))"}
{"solution": "def min_bills(n):\n    denominations = [100, 20, 10, 5, 1]\n    count = 0\n    for denomination in denominations:\n        count += n // denomination\n        n %= denomination\n    return count\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(min_bills(n))"}
{"solution": "MOD = 1000000007\n\ndef binomial_mod(n, k, mod=MOD):\n    if k > n or k < 0:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)\n    c = 1\n    for i in range(k):\n        c = c * (n - i) * pow(i + 1, mod - 2, mod) % mod\n    return c\n\ndef count_permutations(n, k):\n    dp = [0] * (k + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, k), 0, -1):\n            dp[j] = (dp[j] * j + dp[j - 1] * (i - j + 1)) % MOD\n        dp[0] = dp[0] * i % MOD\n    return dp[k]\n\ndef main():\n    n, k = map(int, input().split())\n    result = count_permutations(n, k) * binomial_mod(n, k) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_beauty_bouquet(n, k, beauties, colors):\n    roses = sorted(zip(beauties, colors), key=lambda x: -x[0])\n    max_beauty = -1\n    for color in set(colors):\n        if colors.count(color) < k:\n            continue\n        current_beauty = sum(b for b, c in roses[:k] if c == color)\n        if current_beauty > max_beauty:\n            max_beauty = current_beauty\n    return max_beauty\n\nn, k = map(int, input().split())\nbeauties = list(map(int, input().split()))\ncolors = input()\n\nprint(max_beauty_bouquet(n, k, beauties, colors))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef reduce_fraction(p, q):\n    common_divisor = gcd(p, q)\n    return p // common_divisor, q // common_divisor\n\ndef evaluate_continued_fraction(a):\n    numerator, denominator = a[-1], 1\n    for i in range(len(a) - 2, -1, -1):\n        numerator, denominator = a[i] * numerator + denominator, numerator\n    return numerator, denominator\n\ndef main():\n    p, q = map(int, input().split())\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    p, q = reduce_fraction(p, q)\n    numerator, denominator = evaluate_continued_fraction(a)\n    numerator, denominator = reduce_fraction(numerator, denominator)\n\n    if p == numerator and q == denominator:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def correct_expression(expression):\n    # Split the expression into parts\n    a, sign, b, eq, c = expression.split(' ')\n    \n    # Convert sticks to numbers\n    a_num = len(a)\n    b_num = len(b)\n    c_num = len(c)\n    \n    # Check if the expression is already correct\n    if a_num + b_num == c_num:\n        return expression\n    \n    # Try to shift one stick from A to C\n    if a_num > 1 and a_num - 1 + b_num == c_num + 1:\n        return '|' * (a_num - 1) + ' ' + sign + ' ' + b + ' ' + eq + ' ' + '|' * (c_num + 1)\n    \n    # Try to shift one stick from B to C\n    if b_num > 1 and a_num + b_num - 1 == c_num + 1:\n        return a + ' ' + sign + ' ' + '|' * (b_num - 1) + ' ' + eq + ' ' + '|' * (c_num + 1)\n    \n    # Try to shift one stick from C to A\n    if c_num > 1 and a_num + 1 + b_num == c_num - 1:\n        return '|' * (a_num + 1) + ' ' + sign + ' ' + b + ' ' + eq + ' ' + '|' * (c_num - 1)\n    \n    # Try to shift one stick from C to B\n    if c_num > 1 and a_num + b_num + 1 == c_num - 1:\n        return a + ' ' + sign + ' ' + '|' * (b_num + 1) + ' ' + eq + ' ' + '|' * (c_num - 1)\n    \n    # If no solution is found, return \"Impossible\"\n    return \"Impossible\"\n\n# Read input from the user\nexpression = input()\n\n# Print the result\nprint(correct_expression(expression))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_permutations_with_oddness(n, k):\n    dp = [[0] * (n * n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(n * n + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= i:\n                dp[i][j] = (dp[i][j] + dp[i][j - i]) % MOD\n    \n    return dp[n][k]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    \n    result = count_permutations_with_oddness(n, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_reach_all_points(N, points):\n    # Check if it's possible to reach all points with a robot arm\n    # This is a placeholder function, you need to implement the logic\n    return True\n\ndef find_robot_arm_configuration(N, points):\n    # Find a robot arm configuration that can reach all points\n    # This is a placeholder function, you need to implement the logic\n    m = 2  # Example value for m\n    d = [1, 2]  # Example values for d_i\n    ways = [\"RL\", \"UU\", \"DR\"]  # Example ways to reach each point\n    return m, d, ways\n\ndef main():\n    N = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(N)]\n    \n    if not can_reach_all_points(N, points):\n        print(-1)\n        return\n    \n    m, d, ways = find_robot_arm_configuration(N, points)\n    \n    print(m)\n    print(\" \".join(map(str, d)))\n    for way in ways:\n        print(way)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def replace_fillers(n, s):\n    result = \"\"\n    i = 0\n    while i < n:\n        if i + 2 < n and s[i:i+3] == \"ogo\":\n            # Found the start of a filler, now find its end\n            j = i + 3\n            while j + 1 < n and s[j:j+2] == \"go\":\n                j += 2\n            result += \"***\"\n            i = j\n        else:\n            result += s[i]\n            i += 1\n    return result\n\n# Read input\nn = int(input())\ns = input()\n\n# Process and print output\nprint(replace_fillers(n, s))"}
{"solution": "def prime_factors(n):\n    factors = set()\n    while n % 2 == 0:\n        factors.add(2)\n        n //= 2\n    for i in range(3, int(n**0.5)+1, 2):\n        while n % i == 0:\n            factors.add(i)\n            n //= i\n    if n > 2:\n        factors.add(n)\n    return factors\n\ndef g(x, p):\n    k = 0\n    while x % p == 0:\n        k += 1\n        x //= p\n    return p**k\n\ndef f(x, y):\n    product = 1\n    for p in prime_factors(x):\n        product *= g(y, p)\n    return product\n\ndef calculate_product_f(x, n):\n    MOD = 10**9 + 7\n    result = 1\n    primes = prime_factors(x)\n    for p in primes:\n        power = 0\n        for i in range(1, n+1):\n            temp = i\n            while temp % p == 0:\n                power += 1\n                temp //= p\n        result = (result * pow(p, power, MOD)) % MOD\n    return result\n\n# Read input\nx, n = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_product_f(x, n))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for sx in range(1, 82):  # s(x) can be at most 81 for x < 10^9\n        x = b * sx**a + c\n        if 0 < x < 10**9 and sum_of_digits(x) == sx:\n            solutions.append(x)\n    return sorted(solutions)\n\na, b, c = map(int, input().split())\nsolutions = find_solutions(a, b, c)\nprint(len(solutions))\nif len(solutions) > 0:\n    print(*solutions)"}
{"solution": "def can_solve_with_one_move(cube):\n    # Define the possible rotations for a 2x2x2 Rubik's cube\n    rotations = [\n        # Rotating the front face clockwise\n        [0, 1, 18, 19, 4, 5, 14, 12, 2, 3, 15, 13, 8, 9, 6, 7, 10, 11, 20, 21, 22, 23, 16, 17],\n        # Rotating the back face clockwise\n        [22, 23, 2, 3, 6, 7, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0, 1, 20, 21],\n        # Rotating the left face clockwise\n        [20, 21, 2, 3, 1, 0, 6, 7, 5, 4, 10, 11, 9, 8, 14, 15, 13, 12, 18, 19, 17, 16, 22, 23],\n        # Rotating the right face clockwise\n        [0, 1, 16, 17, 4, 5, 2, 3, 7, 6, 10, 11, 8, 9, 14, 15, 12, 13, 19, 18, 22, 23, 20, 21],\n        # Rotating the top face clockwise\n        [2, 0, 3, 1, 6, 4, 7, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23],\n        # Rotating the bottom face clockwise\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 19, 16, 18, 21, 23, 20, 22]\n    ]\n    \n    # Check if any rotation can solve the cube\n    for rotation in rotations:\n        if all(cube[rotation[i]] == cube[rotation[i + 1]] for i in range(0, len(rotation), 2)):\n            return \"YES\"\n    return \"NO\"\n\n# Read input\ncube = list(map(int, input().split()))\n\n# Output result\nprint(can_solve_with_one_move(cube))"}
{"solution": "def is_tshirt_winner(s, p):\n    i = (s // 50) % 475\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        if 26 + i == p:\n            return True\n    return False\n\ndef min_successful_hacks(p, x, y):\n    for successful_hacks in range(0, 475):\n        score = x + successful_hacks * 100\n        while score >= y:\n            if is_tshirt_winner(score, p):\n                return successful_hacks\n            score -= 50\n    return 475  # This line should never be reached due to problem constraints\n\n# Read input\np, x, y = map(int, input().split())\n\n# Output the result\nprint(min_successful_hacks(p, x, y))"}
{"solution": "def min_distance_to_eat(n, a, b, c):\n    # Start at Rabbit's house\n    if n == 1:\n        return 0  # No need to move if only eating once\n    # If eating more than once, choose the shortest path to the next house\n    return min(a, b) + (n - 2) * min(a, b, c)\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate and print the result\nprint(min_distance_to_eat(n, a, b, c))"}
{"solution": "def min_total_distance(x1, x2, x3):\n    return abs(x1 - x2) + abs(x2 - x3) + abs(x3 - x1) // 2\n\n# Read input\nx1, x2, x3 = map(int, input().split())\n\n# Print output\nprint(min_total_distance(x1, x2, x3))"}
{"solution": "def min_operations_to_equalize(n, x, arr):\n    seen = set()\n    duplicates = set()\n    for num in arr:\n        if num in seen:\n            duplicates.add(num)\n        else:\n            seen.add(num)\n    \n    if len(duplicates) > 0:\n        return 0\n    \n    for num in arr:\n        if num & x != num and num & x in seen:\n            return 1\n        seen.add(num & x)\n    \n    if len(duplicates) > 0:\n        return 1\n    \n    return -1\n\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\nprint(min_operations_to_equalize(n, x, arr))"}
{"solution": "def has_single_plus_shape(h, w, picture):\n    center = None\n    for i in range(1, h - 1):\n        for j in range(1, w - 1):\n            if picture[i][j] == '*' and picture[i-1][j] == '*' and picture[i+1][j] == '*' and picture[i][j-1] == '*' and picture[i][j+1] == '*':\n                if center is not None:\n                    return \"NO\"\n                center = (i, j)\n\n    if center is None:\n        return \"NO\"\n\n    i, j = center\n    if any(picture[i][k] == '*' for k in range(j)) or any(picture[i][k] == '*' for k in range(j + 1, w)):\n        return \"NO\"\n    if any(picture[k][j] == '*' for k in range(i)) or any(picture[k][j] == '*' for k in range(i + 1, h)):\n        return \"NO\"\n\n    for di in range(-1, 2, 2):\n        ni = i + di\n        while 0 <= ni < h and picture[ni][j] == '*':\n            picture[ni][j] = '.'\n            ni += di\n\n    for dj in range(-1, 2, 2):\n        nj = j + dj\n        while 0 <= nj < w and picture[i][nj] == '*':\n            picture[i][nj] = '.'\n            nj += dj\n\n    picture[i][j] = '.'\n\n    for row in picture:\n        if '*' in row:\n            return \"NO\"\n\n    return \"YES\"\n\nh, w = map(int, input().split())\npicture = [list(input().strip()) for _ in range(h)]\n\nprint(has_single_plus_shape(h, w, picture))"}
{"solution": "def find_adjacency_matrix(n, a, b):\n    if a + b > n + 1 or a * b != n:\n        print(\"NO\")\n        return\n\n    matrix = [[0] * n for _ in range(n)]\n\n    # Connect components for the original graph\n    for i in range(a - 1):\n        for j in range(i + 1, a):\n            matrix[i][j] = matrix[j][i] = 1\n\n    # Connect components for the complement graph\n    for i in range(a, n):\n        for j in range(i + 1, n):\n            if i - a + j - a < b - 1:\n                matrix[i][j] = matrix[j][i] = 1\n\n    # Connect the last component of the complement graph to the original graph\n    for i in range(a):\n        matrix[i][a] = matrix[a][i] = 1\n\n    print(\"YES\")\n    for row in matrix:\n        print(''.join(map(str, row)))\n\n# Example usage:\n# find_adjacency_matrix(3, 1, 2)\n# find_adjacency_matrix(3, 3, 3)"}
{"solution": "def min_problems_to_prepare(c, d, n, m, k):\n    # Calculate the number of winners needed from elimination rounds\n    needed_winners = n * m - k\n    \n    # If no additional winners are needed, return 0\n    if needed_winners <= 0:\n        return 0\n    \n    # Calculate the maximum number of winners from main rounds\n    max_main_winners = n * m\n    \n    # Calculate the minimum number of problems needed\n    # Start with the maximum possible from main rounds\n    min_problems = max_main_winners * c\n    \n    # Try to replace main rounds with additional rounds to minimize problems\n    for main_rounds in range(max_main_winners // n + 1):\n        remaining_winners = needed_winners - main_rounds * n\n        additional_rounds = max(0, remaining_winners)\n        total_problems = main_rounds * c + additional_rounds * d\n        min_problems = min(min_problems, total_problems)\n    \n    return min_problems\n\n# Read input\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\n# Calculate and print the result\nprint(min_problems_to_prepare(c, d, n, m, k))"}
{"solution": "def find_grid_path(s):\n    if len(s) != 27:\n        return \"Impossible\"\n    \n    # Create a 2x13 grid\n    grid = [['' for _ in range(13)] for _ in range(2)]\n    \n    # Function to check if a tile is adjacent to the current position\n    def is_adjacent(x1, y1, x2, y2):\n        return abs(x1 - x2) <= 1 and abs(y1 - y2) <= 1\n    \n    # Function to find the next position in the grid\n    def next_position(x, y):\n        if y == 12:\n            return 1, 12\n        return x, y + 1\n    \n    # Start from the top-left corner\n    x, y = 0, 0\n    grid[x][y] = s[0]\n    \n    # Try to fill the grid with the path\n    for i in range(1, 27):\n        found = False\n        for dx in range(-1, 2):\n            for dy in range(-1, 2):\n                if dx == 0 and dy == 0:\n                    continue\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < 2 and 0 <= ny < 13 and grid[nx][ny] == '':\n                    if is_adjacent(x, y, nx, ny):\n                        x, y = nx, ny\n                        grid[x][y] = s[i]\n                        found = True\n                        break\n            if found:\n                break\n        if not found:\n            return \"Impossible\"\n    \n    # Convert the grid to the required output format\n    return ''.join(grid[0]) + '\\n' + ''.join(grid[1])\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(find_grid_path(s))"}
{"solution": "import sys\nimport math\n\n# Read input from stdin\nx, y = map(int, sys.stdin.readline().split())\n\n# Use logarithms to avoid overflow and compare the values efficiently\nif x == y:\n    print('=')\nelse:\n    # Compare x^y and y^x using logarithms\n    left = y * math.log(x)\n    right = x * math.log(y)\n    \n    if left < right:\n        print('<')\n    elif left > right:\n        print('>')\n    else:\n        print('=')"}
{"solution": "def max_balloons(r, h):\n    # Calculate the number of balloons that can fit in the semicircle part\n    semicircle_capacity = (r // (r / 2)) * (r // (r / 2)) // 2\n    \n    # Calculate the number of balloons that can fit in the rectangular part\n    rectangular_capacity = ((h + r) // (r / 2)) * (r // (r / 2))\n    \n    # The total capacity is the sum of the capacities of the semicircle and rectangular parts\n    total_capacity = semicircle_capacity + rectangular_capacity\n    \n    return total_capacity\n\n# Read input\nr, h = map(int, input().split())\n\n# Print the output\nprint(max_balloons(r, h))"}
{"solution": "def min_sum_after_discard(t1, t2, t3, t4, t5):\n    card_counts = {}\n    for t in [t1, t2, t3, t4, t5]:\n        card_counts[t] = card_counts.get(t, 0) + 1\n    \n    min_sum = sum([t1, t2, t3, t4, t5])\n    for card, count in card_counts.items():\n        if count == 2 or count == 3:\n            min_sum = min(min_sum, sum([t1, t2, t3, t4, t5]) - card * count)\n        elif count > 3:\n            min_sum = min(min_sum, sum([t1, t2, t3, t4, t5]) - card * 3)\n    \n    return min_sum\n\n# Example usage:\n# t1, t2, t3, t4, t5 = 7, 3, 7, 3, 20\n# print(min_sum_after_discard(t1, t2, t3, t4, t5))  # Output: 26"}
{"solution": "def min_distance_to_checkpoints(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    return min(abs(a - checkpoints[n - 2]), abs(a - checkpoints[1])) + checkpoints[n - 2] - checkpoints[1]\n\n# Read input\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_distance_to_checkpoints(n, a, checkpoints))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_root(n):\n    for x in range(1, 10**9):\n        if x**2 + sum_of_digits(x) * x - n == 0:\n            return x\n    return -1\n\nn = int(input().strip())\nprint(find_root(n))"}
{"solution": "def time_to_minutes(time_str):\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    minutes = minutes % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef calculate_bedtime(current_time, sleep_duration):\n    current_minutes = time_to_minutes(current_time)\n    sleep_minutes = time_to_minutes(sleep_duration)\n    bedtime_minutes = (current_minutes - sleep_minutes) % (24 * 60)\n    return minutes_to_time(bedtime_minutes)\n\n# Read input\ncurrent_time = input().strip()\nsleep_duration = input().strip()\n\n# Calculate and print the bedtime\nprint(calculate_bedtime(current_time, sleep_duration))"}
{"solution": "def find_longest_subsegment_with_max_mean(n, a):\n    max_val = max(a)\n    max_len = 0\n    current_len = 0\n    \n    for num in a:\n        if num == max_val:\n            current_len += 1\n            max_len = max(max_len, current_len)\n        else:\n            current_len = 0\n    \n    return max_len\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Finding and printing the result\nprint(find_longest_subsegment_with_max_mean(n, a))"}
{"solution": "MOD = 998244353\n\ndef modinv(a, m):\n    return pow(a, m - 2, m)\n\ndef nCr_mod(n, r, mod):\n    if r > n:\n        return 0\n    if r == 0 or n == r:\n        return 1\n    num = 1\n    den = 1\n    for i in range(r):\n        num = (num * (n - i)) % mod\n        den = (den * (i + 1)) % mod\n    return (num * modinv(den, mod)) % mod\n\ndef count_ways(n, m, k):\n    return (nCr_mod(n - 1, k, MOD) * m * pow(m - 1, k, MOD)) % MOD\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Calculate and print the result\nprint(count_ways(n, m, k))"}
{"solution": "def is_magic_number(n):\n    while n > 0:\n        if n % 1000 == 144:\n            n //= 1000\n        elif n % 100 == 14:\n            n //= 100\n        elif n % 10 == 1:\n            n //= 10\n        else:\n            return \"NO\"\n    return \"YES\"\n\n# Read input\nn = int(input().strip())\n\n# Output result\nprint(is_magic_number(n))"}
{"solution": "def min_moves(n, m, i, j, a, b):\n    def can_reach_corner(x, y, a, b):\n        return (x - 1) % a == 0 and (y - 1) % b == 0 and ((x - 1) // a) % 2 == ((y - 1) // b) % 2\n\n    if not (can_reach_corner(i, j, a, b) or can_reach_corner(n - i + 1, j, a, b) or can_reach_corner(i, m - j + 1, a, b) or can_reach_corner(n - i + 1, m - j + 1, a, b)):\n        return \"Poor Inna and pony!\"\n\n    moves = []\n    for corner in [(1, 1), (1, m), (n, 1), (n, m)]:\n        if (abs(corner[0] - i) % a == 0 and abs(corner[1] - j) % b == 0 and (abs(corner[0] - i) // a) % 2 == (abs(corner[1] - j) // b) % 2):\n            moves.append(abs(corner[0] - i) // a + abs(corner[1] - j) // b)\n\n    return min(moves) if moves else \"Poor Inna and pony!\"\n\n# Read input\nn, m, i, j, a, b = map(int, input().split())\n\n# Output the result\nprint(min_moves(n, m, i, j, a, b))"}
{"solution": "def max_removals(s):\n    removals = 0\n    stack = []\n    for char in s:\n        if stack and stack[-1] == chr(ord(char) - 1):\n            stack.pop()\n            removals += 1\n        else:\n            stack.append(char)\n    return removals\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Process input\ns = data[1]\n\n# Output the result\nprint(max_removals(s))"}
{"solution": "def atm_withdrawal(n, k, denominations, q, requests):\n    results = []\n    for amount in requests:\n        min_bills = float('inf')\n        for i in range(n):\n            for j in range(i, n):\n                for bill_count in range(1, k + 1):\n                    for second_bill_count in range(0, k - bill_count + 1):\n                        if (bill_count * denominations[i] + second_bill_count * denominations[j] == amount):\n                            min_bills = min(min_bills, bill_count + second_bill_count)\n        results.append(min_bills if min_bills != float('inf') else -1)\n    return results\n\n# Read input\nn, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\nrequests = [int(input()) for _ in range(q)]\n\n# Process requests and print results\nresults = atm_withdrawal(n, k, denominations, q, requests)\nfor result in results:\n    print(result)"}
{"solution": "def min_time_to_reach(s, x1, x2, t1, t2, p, d):\n    if x1 == x2:\n        return 0\n    \n    # If Igor is faster than the tram or the tram is not moving towards Igor's destination, walk\n    if t2 <= t1 or (d == 1 and x1 > x2) or (d == -1 and x1 < x2):\n        return abs(x2 - x1) * t2\n    \n    # Calculate the time if Igor waits for the tram and then uses it\n    if d == 1:\n        if p <= x1:\n            tram_time_to_x1 = (x1 - p) * t1\n        else:\n            tram_time_to_x1 = (s - p) * t1 + s * t1 + x1 * t1\n    else:\n        if p >= x1:\n            tram_time_to_x1 = (p - x1) * t1\n        else:\n            tram_time_to_x1 = p * t1 + s * t1 + (s - x1) * t1\n    \n    # Time for Igor to reach x2 using the tram\n    if d == 1:\n        if x2 >= x1:\n            tram_time_to_x2 = (x2 - x1) * t1\n        else:\n            tram_time_to_x2 = (s - x1) * t1 + s * t1 + x2 * t1\n    else:\n        if x2 <= x1:\n            tram_time_to_x2 = (x1 - x2) * t1\n        else:\n            tram_time_to_x2 = x1 * t1 + s * t1 + (s - x2) * t1\n    \n    # Compare walking time and tram time\n    walk_time = abs(x2 - x1) * t2\n    tram_time = tram_time_to_x1 + tram_time_to_x2\n    \n    return min(walk_time, tram_time)\n\n# Read input\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Output the result\nprint(min_time_to_reach(s, x1, x2, t1, t2, p, d))"}
{"solution": "def count_occurrences_in_table(n, x):\n    count = 0\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            j = x // i\n            if i <= n and j <= n:\n                count += 1 if i == j else 2\n    return count\n\nn, x = map(int, input().split())\nprint(count_occurrences_in_table(n, x))"}
{"solution": "import string\n\ndef generate_password(n, k):\n    letters = string.ascii_lowercase[:k]\n    password = []\n    while len(password) < n:\n        for letter in letters:\n            if len(password) < n:\n                password.append(letter)\n            else:\n                break\n    return ''.join(password)\n\n# Read input\nn, k = map(int, input().split())\n\n# Generate and print the password\nprint(generate_password(n, k))"}
{"solution": "def find_first_collision(n, directions, coordinates):\n    if 'L' not in directions or 'R' not in directions:\n        return -1\n    \n    first_collision = float('inf')\n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            collision_time = (coordinates[i + 1] - coordinates[i]) // 2\n            first_collision = min(first_collision, collision_time)\n    \n    return first_collision if first_collision != float('inf') else -1\n\n# Read input\nn = int(input())\ndirections = input().strip()\ncoordinates = list(map(int, input().split()))\n\n# Find and print the first collision\nprint(find_first_collision(n, directions, coordinates))"}
{"solution": "def largest_area(n, a, b, seals):\n    max_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for width1, height1 in [(seals[i][0], seals[i][1]), (seals[i][1], seals[i][0])]:\n                for width2, height2 in [(seals[j][0], seals[j][1]), (seals[j][1], seals[j][0])]:\n                    if (width1 + width2 <= a and height1 <= b and height2 <= b) or \\\n                       (width1 + width2 <= b and height1 <= a and height2 <= a) or \\\n                       (height1 + height2 <= a and width1 <= b and width2 <= b) or \\\n                       (height1 + height2 <= b and width1 <= a and width2 <= a):\n                        max_area = max(max_area, width1 * height1 + width2 * height2)\n    return max_area\n\n# Read input\nn, a, b = map(int, input().split())\nseals = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(largest_area(n, a, b, seals))"}
{"solution": "def find_outlier(points):\n    x_counts = {}\n    y_counts = {}\n    for x, y in points:\n        x_counts[x] = x_counts.get(x, 0) + 1\n        y_counts[y] = y_counts.get(y, 0) + 1\n    \n    outlier_x = [x for x, count in x_counts.items() if count < len(points) // 2][0]\n    outlier_y = [y for y, count in y_counts.items() if count < len(points) // 2][0]\n    \n    return outlier_x, outlier_y\n\ndef main():\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(4 * n + 1)]\n    outlier_x, outlier_y = find_outlier(points)\n    print(outlier_x, outlier_y)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_digit_product(n):\n    def product_of_digits(x):\n        product = 1\n        while x > 0:\n            product *= x % 10\n            x //= 10\n        return product\n\n    max_product = product_of_digits(n)\n    str_n = str(n)\n    for i in range(len(str_n)):\n        if str_n[i] != '0':\n            new_number = str_n[:i] + str(int(str_n[i]) - 1) + '9' * (len(str_n) - i - 1)\n            max_product = max(max_product, product_of_digits(int(new_number)))\n\n    return max_product\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(max_digit_product(n))"}
{"solution": "def find_smallest_k(n, votes):\n    max_ai = max(votes)\n    total_votes_for_elodreip = sum(votes)\n    k = max_ai\n    while True:\n        total_votes_for_awruk = sum(k - ai for ai in votes)\n        if total_votes_for_awruk > total_votes_for_elodreip:\n            return k\n        k += 1\n\nn = int(input().strip())\nvotes = list(map(int, input().strip().split()))\nprint(find_smallest_k(n, votes))"}
{"solution": "def count_operations(s):\n    operations = 0\n    while True:\n        to_delete = [False] * len(s)\n        deleted = False\n        for i in range(1, len(s) - 1):\n            if s[i - 1] != s[i] and s[i] != s[i + 1]:\n                to_delete[i] = True\n                deleted = True\n        if not deleted:\n            break\n        s = ''.join(s[i] for i in range(len(s)) if not to_delete[i])\n        operations += 1\n    return operations\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(count_operations(s))"}
{"solution": "def count_triples(n, a):\n    a.sort()\n    min_product = a[0] * a[1] * a[2]\n    count = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if a[i] * a[j] * a[k] == min_product:\n                    count += 1\n                elif a[i] * a[j] * a[k] > min_product:\n                    break\n    return count\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(count_triples(n, a))"}
{"solution": "def min_cuts_for_pizza(n):\n    if n == 0:\n        return 0\n    if n % 2 == 0:\n        return n // 2\n    return n\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the result\nprint(min_cuts_for_pizza(n))"}
{"solution": "def maximize_bank_account(n):\n    if n >= 0:\n        return n\n    else:\n        n_str = str(n)\n        last_digit_removed = int(n_str[:-1])\n        second_last_digit_removed = int(n_str[:-2] + n_str[-1])\n        return max(last_digit_removed, second_last_digit_removed)\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(maximize_bank_account(n))"}
{"solution": "def determine_direction(start, end, n):\n    positions = ['v', '>', '^', '<']\n    start_index = positions.index(start)\n    end_index = positions.index(end)\n    \n    # Calculate the difference in positions\n    diff = (end_index - start_index) % 4\n    \n    # Check if the difference matches the number of seconds for both directions\n    if diff == n % 4:\n        return \"cw\"\n    elif (4 - diff) % 4 == n % 4:\n        return \"ccw\"\n    else:\n        return \"undefined\"\n\n# Read input\nstart, end = input().split()\nn = int(input())\n\n# Determine and print the direction\nprint(determine_direction(start, end, n))"}
{"solution": "def count_vertical_dominoes(n, s):\n    if 'L' not in s and 'R' not in s:\n        return n\n    \n    vertical_count = 0\n    last_pushed = None\n    for i in range(n):\n        if s[i] == '.':\n            if last_pushed is None:\n                vertical_count += 1\n        else:\n            if last_pushed is None:\n                last_pushed = s[i]\n            elif last_pushed == s[i]:\n                vertical_count = 0\n            else:\n                if last_pushed == 'R':\n                    vertical_count = (vertical_count + 1) // 2\n                else:\n                    vertical_count = 0\n                last_pushed = s[i]\n    \n    if last_pushed == 'L':\n        vertical_count = 0\n    \n    return vertical_count\n\n# Read input\nn = int(input())\ns = input()\n\n# Output the result\nprint(count_vertical_dominoes(n, s))"}
{"solution": "def find_permutation(n, m, leaders):\n    permutation = [0] * n\n    used = [False] * (n + 1)\n    \n    for i in range(m - 1):\n        current_leader = leaders[i] - 1\n        next_leader = leaders[i + 1] - 1\n        steps = (next_leader - current_leader) % n\n        if steps == 0:\n            steps = n\n        if permutation[current_leader] == 0 and not used[steps]:\n            permutation[current_leader] = steps\n            used[steps] = True\n        elif permutation[current_leader] != steps:\n            return -1\n    \n    for i in range(n):\n        if permutation[i] == 0:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    permutation[i] = j\n                    used[j] = True\n                    break\n    \n    return permutation\n\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\nresult = find_permutation(n, m, leaders)\nif result == -1:\n    print(result)\nelse:\n    print(*result)"}
{"solution": "def max_number_with_swaps(a, k):\n    digits = list(str(a))\n    n = len(digits)\n    \n    for i in range(n):\n        if k == 0:\n            break\n        max_digit = digits[i]\n        max_index = i\n        for j in range(i + 1, min(n, i + k + 1)):\n            if digits[j] > max_digit:\n                max_digit = digits[j]\n                max_index = j\n        \n        for j in range(max_index, i, -1):\n            digits[j], digits[j - 1] = digits[j - 1], digits[j]\n            k -= 1\n            if k == 0:\n                break\n    \n    return int(''.join(digits))\n\n# Read input\na, k = map(int, input().split())\n\n# Output the result\nprint(max_number_with_swaps(a, k))"}
{"solution": "def find_next_number(sequence):\n    a, b, c, d = sequence\n    \n    # Check for arithmetic progression\n    if b - a == c - b == d - c:\n        return d + (d - c)\n    \n    # Check for geometric progression\n    if b / a == c / b == d / c:\n        next_element = d * (d / c)\n        return int(next_element) if next_element.is_integer() else 42\n    \n    return 42\n\n# Read input\nsequence = list(map(int, input().split()))\n\n# Print output\nprint(find_next_number(sequence))"}
{"solution": "def max_distance(n, colors):\n    # Find the first and last occurrence of each color\n    first_occurrence = {}\n    last_occurrence = {}\n    for i, color in enumerate(colors):\n        if color not in first_occurrence:\n            first_occurrence[color] = i\n        last_occurrence[color] = i\n\n    # Find the maximum distance between different colors\n    max_dist = 0\n    for color in first_occurrence:\n        for other_color in last_occurrence:\n            if color != other_color:\n                max_dist = max(max_dist, abs(first_occurrence[color] - last_occurrence[other_color]))\n\n    return max_dist\n\n# Read input\nn = int(input())\ncolors = list(map(int, input().split()))\n\n# Output the result\nprint(max_distance(n, colors))"}
{"solution": "def find_santa_place(n, m, k):\n    lane = (k - 1) // (2 * m) + 1\n    desk = ((k - 1) // 2) % m + 1\n    side = 'L' if k % 2 != 0 else 'R'\n    return lane, desk, side\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Find and print Santa's place\nr, d, s = find_santa_place(n, m, k)\nprint(r, d, s)"}
{"solution": "def possible_final_card_colors(n, s):\n    colors = {'B': 0, 'G': 0, 'R': 0}\n    for color in s:\n        colors[color] += 1\n    \n    possible_colors = []\n    \n    if colors['B'] > 0 and (colors['G'] > 0 or colors['R'] > 0):\n        possible_colors.append('B')\n    elif colors['B'] > 1 and colors['G'] == 0 and colors['R'] == 0:\n        possible_colors.append('B')\n    \n    if colors['G'] > 0 and (colors['B'] > 0 or colors['R'] > 0):\n        possible_colors.append('G')\n    elif colors['G'] > 1 and colors['B'] == 0 and colors['R'] == 0:\n        possible_colors.append('G')\n    \n    if colors['R'] > 0 and (colors['B'] > 0 or colors['G'] > 0):\n        possible_colors.append('R')\n    elif colors['R'] > 1 and colors['B'] == 0 and colors['G'] == 0:\n        possible_colors.append('R')\n    \n    return ''.join(sorted(possible_colors))\n\n# Read input\nn = int(input())\ns = input()\n\n# Output the result\nprint(possible_final_card_colors(n, s))"}
