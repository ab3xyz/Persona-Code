{"solution": "def max_accordion_length(s):\n    # Check if the string can contain an accordion at all\n    if '[' not in s or ']' not in s or ':' not in s:\n        return -1\n\n    # Find the first opening bracket and the last closing bracket\n    first_open = s.find('[')\n    last_close = s.rfind(']')\n\n    # Check if there is a pair of brackets\n    if first_open >= last_close:\n        return -1\n\n    # Find the first colon after the first opening bracket\n    first_colon = s.find(':', first_open, last_close)\n    if first_colon == -1:\n        return -1\n\n    # Find the last colon before the last closing bracket\n    last_colon = s.rfind(':', first_open, last_close)\n    if last_colon == -1 or last_colon == first_colon:\n        return -1\n\n    # Count the vertical lines between the two colons\n    vertical_lines = s.count('|', first_colon, last_colon)\n\n    # The length of the accordion is 4 (brackets and colons) plus the number of vertical lines\n    return 4 + vertical_lines\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(max_accordion_length(s))"}
{"solution": "def max_sum_of_digits(x):\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(n))\n\n    # Start from the largest possible number with all 9s that does not exceed x\n    max_sum = 0\n    result = x\n    str_x = str(x)\n    length = len(str_x)\n\n    for i in range(length):\n        if str_x[i] == '0':\n            continue\n        # Form a number by changing the current digit to one less and making all following digits 9s\n        candidate = int(str_x[:i] + str(int(str_x[i]) - 1) + '9' * (length - i - 1))\n        if candidate <= x:\n            candidate_sum = sum_of_digits(candidate)\n            if candidate_sum > max_sum or (candidate_sum == max_sum and candidate > result):\n                max_sum = candidate_sum\n                result = candidate\n\n    return result\n\n# Read input\nx = int(input().strip())\n\n# Output the result\nprint(max_sum_of_digits(x))"}
{"solution": "def next_lucky_year(current_year):\n    year = current_year + 1\n    while True:\n        if len(set(str(year))) <= 2 and '0' not in str(year):\n            return year - current_year\n        year += 1\n\n# Example usage:\n# print(next_lucky_year(4))    # Output: 1\n# print(next_lucky_year(201))  # Output: 99\n# print(next_lucky_year(4000)) # Output: 1000"}
{"solution": "def maximize_painted_sections(n, q, painters):\n    # Initialize a list to keep track of painted sections\n    painted = [0] * (n + 1)\n    \n    # Calculate the total number of sections painted by all painters\n    for l, r in painters:\n        painted[l - 1] += 1\n        painted[r] -= 1\n    \n    # Convert the painted list to prefix sum to get the actual painted sections\n    for i in range(1, n + 1):\n        painted[i] += painted[i - 1]\n    \n    # Remove the last element which is not needed\n    painted.pop()\n    \n    # Find the maximum number of painted sections by excluding two painters\n    max_painted = 0\n    for i in range(q):\n        # Create a copy of the painted sections to simulate the exclusion of painter i\n        current_painted = painted[:]\n        for j in range(q):\n            if i != j:\n                l, r = painters[j]\n                for k in range(l - 1, r):\n                    current_painted[k] -= 1\n        \n        # Count the number of sections that are still painted after excluding two painters\n        count_painted = sum(1 for p in current_painted if p > 0)\n        max_painted = max(max_painted, count_painted)\n    \n    return max_painted\n\n# Read input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output the result\nprint(maximize_painted_sections(n, q, painters))"}
{"solution": "def contains_seven(hh, mm):\n    return '7' in str(hh) or '7' in str(mm)\n\ndef find_snooze_count(x, hh, mm):\n    snooze_count = 0\n    while not contains_seven(hh, mm):\n        mm -= x\n        if mm < 0:\n            mm += 60\n            hh -= 1\n        if hh < 0:\n            hh += 24\n        snooze_count += 1\n    return snooze_count\n\n# Read input\nx = int(input())\nhh, mm = map(int, input().split())\n\n# Find and print the result\nprint(find_snooze_count(x, hh, mm))"}
{"solution": "def min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0\n    elif l == 1:\n        return abs(pos - r) + 1\n    elif r == n:\n        return abs(pos - l) + 1\n    else:\n        return min(abs(pos - l), abs(pos - r)) + (r - l) + 2\n\n# Example usage:\nn, pos, l, r = map(int, input().split())\nprint(min_seconds_to_close_tabs(n, pos, l, r))"}
{"solution": "def min_blows_to_defeat_zmei_gorynich(t, queries):\n    results = []\n    for n, x, blows in queries:\n        max_damage = max_self_heal = 0\n        for d, h in blows:\n            max_damage = max(max_damage, d)\n            max_self_heal = max(max_self_heal, d - h)\n        \n        if max_damage >= x:\n            results.append(1)\n        elif max_self_heal <= 0:\n            results.append(-1)\n        else:\n            # Calculate the number of blows needed\n            blows_needed = (x - max_damage + max_self_heal - 1) // max_self_heal\n            results.append(blows_needed + 1)\n    \n    return results\n\n# Example usage:\n# t = 3\n# queries = [\n#     (3, 10, [(6, 3), (8, 2), (1, 4)]),\n#     (4, 10, [(4, 1), (3, 2), (2, 6), (1, 100)]),\n#     (2, 15, [(10, 11), (14, 100)])\n# ]\n# print(min_blows_to_defeat_zmei_gorynich(t, queries))"}
{"solution": "def determine_empty_day(n, m):\n    day = 0\n    while n > 0:\n        day += 1\n        if n >= m:\n            n -= m\n        else:\n            n = 0\n        n -= day\n        if n < 0:\n            n = 0\n    return day\n\n# Read input\nn, m = map(int, input().split())\n\n# Output the result\nprint(determine_empty_day(n, m))"}
{"solution": "def min_draws_to_win(tiles):\n    # Parse the input tiles\n    tile1, tile2, tile3 = tiles.split()\n    \n    # Extract numbers and suits\n    num1, suit1 = int(tile1[0]), tile1[1]\n    num2, suit2 = int(tile2[0]), tile2[1]\n    num3, suit3 = int(tile3[0]), tile3[1]\n    \n    # Check for koutsu (triplet)\n    if tile1 == tile2 == tile3:\n        return 0\n    \n    # Check for shuntsu (sequence)\n    def is_shuntsu(n1, n2, n3):\n        return sorted([n1, n2, n3]) in [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9]]\n    \n    if suit1 == suit2 == suit3 and is_shuntsu(num1, num2, num3):\n        return 0\n    \n    # Check for possible koutsu with one more draw\n    if tile1 == tile2 or tile1 == tile3 or tile2 == tile3:\n        return 1\n    \n    # Check for possible shuntsu with one more draw\n    def needs_one_for_shuntsu(n1, n2):\n        return abs(n1 - n2) == 1 or abs(n1 - n2) == 2\n    \n    if suit1 == suit2 and needs_one_for_shuntsu(num1, num2):\n        return 1\n    if suit1 == suit3 and needs_one_for_shuntsu(num1, num3):\n        return 1\n    if suit2 == suit3 and needs_one_for_shuntsu(num2, num3):\n        return 1\n    \n    # If no koutsu or shuntsu can be formed with one more draw, return 2\n    return 2\n\n# Example usage\nprint(min_draws_to_win(\"1s 2s 3s\"))  # Output: 0\nprint(min_draws_to_win(\"9m 9m 9m\"))  # Output: 0\nprint(min_draws_to_win(\"3p 9m 2p\"))  # Output: 1"}
{"solution": "def find_maks_sofa(d, n, m, sofas, conditions):\n    cnt_l, cnt_r, cnt_t, cnt_b = conditions\n\n    # Initialize counters for each sofa\n    left_counts = [0] * d\n    right_counts = [0] * d\n    top_counts = [0] * d\n    bottom_counts = [0] * d\n\n    # Calculate the number of sofas to the left, right, top, and bottom for each sofa\n    for i in range(d):\n        for j in range(d):\n            if i != j:\n                # Check if sofa j is to the left of sofa i\n                if (sofas[j][0] < sofas[i][0] or sofas[j][2] < sofas[i][0]) or \\\n                   (sofas[j][0] < sofas[i][2] or sofas[j][2] < sofas[i][2]):\n                    left_counts[i] += 1\n                # Check if sofa j is to the right of sofa i\n                if (sofas[j][0] > sofas[i][0] or sofas[j][2] > sofas[i][0]) or \\\n                   (sofas[j][0] > sofas[i][2] or sofas[j][2] > sofas[i][2]):\n                    right_counts[i] += 1\n                # Check if sofa j is to the top of sofa i\n                if (sofas[j][1] < sofas[i][1] or sofas[j][3] < sofas[i][1]) or \\\n                   (sofas[j][1] < sofas[i][3] or sofas[j][3] < sofas[i][3]):\n                    top_counts[i] += 1\n                # Check if sofa j is to the bottom of sofa i\n                if (sofas[j][1] > sofas[i][1] or sofas[j][3] > sofas[i][1]) or \\\n                   (sofas[j][1] > sofas[i][3] or sofas[j][3] > sofas[i][3]):\n                    bottom_counts[i] += 1\n\n    # Find the sofa that matches the conditions\n    for i in range(d):\n        if left_counts[i] == cnt_l and right_counts[i] == cnt_r and \\\n           top_counts[i] == cnt_t and bottom_counts[i] == cnt_b:\n            return i + 1  # Sofas are numbered starting from 1\n\n    return -1\n\n# Read input\nd = int(input())\nn, m = map(int, input().split())\nsofas = [list(map(int, input().split())) for _ in range(d)]\nconditions = list(map(int, input().split()))\n\n# Find and print the result\nprint(find_maks_sofa(d, n, m, sofas, conditions))"}
{"solution": "def mars_days_off(n):\n    full_weeks = n // 7\n    remaining_days = n % 7\n    \n    min_days_off = full_weeks * 2\n    max_days_off = full_weeks * 2 + min(remaining_days, 2)\n    \n    return min_days_off, max_days_off\n\n# Assuming the input is provided through standard input (stdin)\nn = int(input())\nmin_days_off, max_days_off = mars_days_off(n)\nprint(min_days_off, max_days_off)"}
{"solution": "def max_chocolates(n, a, b, p, q):\n    # Calculate the number of tiles divisible by a, b, and both a and b\n    count_a = n // a\n    count_b = n // b\n    count_ab = n // (a * b)\n    \n    # Calculate the number of tiles that can be exclusively painted Red or Blue\n    exclusive_a = count_a - count_ab\n    exclusive_b = count_b - count_ab\n    \n    # Determine the optimal choice for tiles that can be either Red or Blue\n    if p > q:\n        # Paint tiles that can be either Red or Blue as Red\n        max_chocolates = exclusive_a * p + exclusive_b * q + count_ab * p\n    else:\n        # Paint tiles that can be either Red or Blue as Blue\n        max_chocolates = exclusive_a * p + exclusive_b * q + count_ab * q\n    \n    return max_chocolates\n\n# Read input\nn, a, b, p, q = map(int, input().split())\n\n# Calculate and print the result\nprint(max_chocolates(n, a, b, p, q))"}
{"solution": "def max_golden_subsegment_length(n, trophies):\n    # Count the total number of golden trophies\n    total_gold = trophies.count('G')\n    \n    # If there are no golden trophies or all trophies are golden, return the total number of golden trophies\n    if total_gold == 0 or total_gold == n:\n        return total_gold\n    \n    # Split the trophies string by silver trophies to get segments of golden trophies\n    gold_segments = trophies.split('S')\n    \n    # Initialize the maximum length of a golden subsegment\n    max_length = 0\n    \n    # Initialize the length of the last golden segment\n    last_length = 0\n    \n    # Iterate through the golden segments to find the maximum length\n    for segment in gold_segments:\n        if len(segment) > max_length:\n            max_length = len(segment)\n        last_length = len(segment)\n    \n    # Initialize the count of segments that can be combined with one swap\n    combine_count = 0\n    \n    # Check if we can combine two segments with one swap\n    for segment in gold_segments:\n        if len(segment) == max_length or len(segment) == max_length - 1:\n            combine_count += 1\n    \n    # If we can combine two segments, add one to the max_length\n    if combine_count >= 2:\n        max_length += 1\n    \n    # If the total number of golden trophies is greater than the max_length, add one more to the max_length\n    if total_gold > max_length:\n        max_length += 1\n    \n    return max_length\n\n# Read input\nn = int(input())\ntrophies = input()\n\n# Print the result\nprint(max_golden_subsegment_length(n, trophies))"}
{"solution": "from collections import defaultdict, deque\n\ndef topological_sort(graph, in_degree, n):\n    queue = deque()\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    order = []\n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        for dependent in graph[course]:\n            in_degree[dependent] -= 1\n            if in_degree[dependent] == 0:\n                queue.append(dependent)\n    \n    return order\n\ndef main():\n    n, k = map(int, input().split())\n    main_courses = list(map(int, input().split()))\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    \n    for i in range(1, n + 1):\n        data = list(map(int, input().split()))\n        t_i = data[0]\n        dependencies = data[1:]\n        for dep in dependencies:\n            graph[dep].append(i)\n            in_degree[i] += 1\n    \n    order = topological_sort(graph, in_degree, n)\n    \n    if len(order) != n:\n        print(-1)\n        return\n    \n    required_courses = set(main_courses)\n    for course in order:\n        if course in required_courses:\n            required_courses.remove(course)\n        if not required_courses:\n            break\n    \n    if required_courses:\n        print(-1)\n    else:\n        print(len(order))\n        print(' '.join(map(str, order)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def restore_stack_sortable_permutation(n, k, given_elements):\n    if k == 1:\n        # If only one element is given, we can arrange the rest in descending order\n        # to maximize lexicographical order and ensure stack-sortability.\n        remaining_elements = sorted(set(range(1, n + 1)) - set(given_elements), reverse=True)\n        return given_elements + remaining_elements\n    \n    # Check if the given elements are already not stack-sortable\n    stack = []\n    sorted_elements = sorted(given_elements)\n    i = 0\n    for element in sorted_elements:\n        while i < k and given_elements[i] <= element:\n            stack.append(given_elements[i])\n            i += 1\n        if not stack or stack[-1] != element:\n            return -1\n        stack.pop()\n    \n    # If the given elements are stack-sortable, we can arrange the remaining elements\n    # in descending order to maximize lexicographical order and ensure stack-sortability.\n    remaining_elements = sorted(set(range(1, n + 1)) - set(given_elements), reverse=True)\n    return given_elements + remaining_elements\n\n# Read input\nn, k = map(int, input().split())\ngiven_elements = list(map(int, input().split()))\n\n# Get the result and print it\nresult = restore_stack_sortable_permutation(n, k, given_elements)\nprint(\" \".join(map(str, result)) if result != -1 else -1)"}
{"solution": "def does_b_appear_in_sequence(a, b, c):\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n# Assuming the input is provided in the format specified\na, b, c = map(int, input().split())\nprint(does_b_appear_in_sequence(a, b, c))"}
{"solution": "def can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    if cnt_1 == cnt_4:\n        return 1\n    else:\n        return 0\n\n# Read input\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\n# Output result\nprint(can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4))"}
{"solution": "def mexican_wave_standing_spectators(n, k, t):\n    if t <= k:\n        return t\n    elif t <= n:\n        return k\n    else:\n        return n + k - t\n\n# Read input\nn, k, t = map(int, input().split())\n\n# Calculate and print the number of standing spectators at time t\nprint(mexican_wave_standing_spectators(n, k, t))"}
{"solution": "def lexicographically_minimal_string(s):\n    t = []\n    u = []\n    min_char = min(s)\n    s = list(s)\n    \n    while s or t:\n        if t and (not s or t[-1] <= min_char):\n            u.append(t.pop())\n        else:\n            char = s.pop(0)\n            t.append(char)\n            if s:\n                min_char = min(s)\n    \n    return ''.join(u)\n\n# Input\ns = input().strip()\nprint(lexicographically_minimal_string(s))"}
{"solution": "def check_stats_consistency(T, test_cases):\n    results = []\n    for n, stats in test_cases:\n        valid = True\n        prev_plays, prev_clears = stats[0]\n        if prev_plays < prev_clears:\n            valid = False\n        for plays, clears in stats[1:]:\n            if plays < prev_plays or clears < prev_clears or plays < clears or clears - prev_clears > plays - prev_plays:\n                valid = False\n                break\n            prev_plays, prev_clears = plays, clears\n        results.append(\"YES\" if valid else \"NO\")\n    return results\n\n# Example usage (for testing purposes, not part of the final solution)\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    test_cases = []\n    \n    for _ in range(T):\n        n = int(data[index])\n        index += 1\n        stats = []\n        for _ in range(n):\n            p_i = int(data[index])\n            c_i = int(data[index + 1])\n            stats.append((p_i, c_i))\n            index += 2\n        test_cases.append((n, stats))\n    \n    results = check_stats_consistency(T, test_cases)\n    for result in results:\n        print(result)"}
{"solution": "def is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindromic_time(hh, mm):\n    minutes = hh * 60 + mm\n    for i in range(minutes, minutes + 1440):  # Check within the next 24 hours\n        current_time = i % 1440\n        current_hh, current_mm = divmod(current_time, 60)\n        time_str = f\"{current_hh:02d}:{current_mm:02d}\"\n        if is_palindrome(time_str.replace(\":\", \"\")):\n            return i - minutes\n    return 1440  # If no palindromic time found within 24 hours, which is impossible given the constraints\n\n# Read input\ntime_input = input().strip()\nhh, mm = map(int, time_input.split(\":\"))\n\n# Calculate and print the result\nprint(next_palindromic_time(hh, mm))"}
{"solution": "def maximize_distance(n, permutation):\n    min_index = permutation.index(1)\n    max_index = permutation.index(n)\n    \n    # Calculate the maximum distance by considering the best swap\n    # We can either swap the min to the end, max to the end, or swap them with each other\n    max_distance = max(max_index, n - 1 - max_index, min_index, n - 1 - min_index)\n    \n    return max_distance\n\n# Read input\nn = int(input())\npermutation = list(map(int, input().split()))\n\n# Output the result\nprint(maximize_distance(n, permutation))"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    mid = n // 2\n    if n % 2 == 0:\n        first_half = s[:mid]\n        second_half = s[mid:]\n    else:\n        first_half = s[:mid]\n        second_half = s[mid+1:]\n    \n    if first_half == second_half[::-1]:\n        return \"TAK\"\n    else:\n        return \"NIE\"\n\n# Example usage:\ns = input().strip()\nprint(is_s_palindrome(s))"}
{"solution": "from itertools import permutations\n\ndef max_permutation_not_exceeding(a, b):\n    a_digits = list(str(a))\n    b_digits = list(str(b))\n    \n    # Sort the digits of a in descending order to get the maximum possible number\n    a_digits.sort(reverse=True)\n    \n    # If the maximum permutation of a is still less than b, return it\n    if int(''.join(a_digits)) <= b:\n        return ''.join(a_digits)\n    \n    # Otherwise, find the largest permutation of a that does not exceed b\n    for perm in sorted(set(permutations(a_digits)), reverse=True):\n        if perm[0] == '0':  # Skip permutations that start with 0\n            continue\n        perm_num = int(''.join(perm))\n        if perm_num <= b:\n            return str(perm_num)\n    \n    # This line should never be reached since it's guaranteed that an answer exists\n    return None\n\n# Read input\na = int(input().strip())\nb = int(input().strip())\n\n# Print output\nprint(max_permutation_not_exceeding(a, b))"}
{"solution": "def can_alice_win_in_one_turn(board):\n    def check_line(x, y, dx, dy):\n        count = 0\n        for i in range(5):\n            nx, ny = x + i * dx, y + i * dy\n            if 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n            else:\n                break\n        return count == 5\n\n    def check_win(x, y):\n        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n        for dx, dy in directions:\n            if check_line(x, y, dx, dy) or check_line(x, y, -dx, -dy):\n                return True\n        return False\n\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i][j] = 'X'\n                if check_win(i, j):\n                    return 'YES'\n                board[i][j] = '.'\n    return 'NO'\n\n# Example usage:\n# board = [list(input().strip()) for _ in range(10)]\n# print(can_alice_win_in_one_turn(board))"}
{"solution": "def symmetric_lexicographically_maximal_matrix(n, k):\n    if k > n * n:\n        return -1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        for j in range(i, n):\n            if k <= 0:\n                break\n            if i == j:\n                if k > 0:\n                    matrix[i][j] = 1\n                    k -= 1\n            else:\n                if k > 1:\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n                elif k == 1:\n                    matrix[i][i] = 1\n                    k -= 1\n    \n    if k > 0:\n        return -1\n    \n    return matrix\n\ndef print_matrix(matrix):\n    for row in matrix:\n        print(' '.join(map(str, row)))\n\n# Read input\nn, k = map(int, input().split())\n\n# Get the result\nresult = symmetric_lexicographically_maximal_matrix(n, k)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    print_matrix(result)"}
{"solution": "import math\n\ndef evaluate_expressions(x, y, z):\n    expressions = [\n        x**(y**z), x**(z**y), (x**y)**z, (x**z)**y,\n        y**(x**z), y**(z**x), (y**x)**z, (y**z)**x,\n        z**(x**y), z**(y**x), (z**x)**y, (z**y)**x\n    ]\n    return expressions\n\ndef find_max_expression(x, y, z):\n    expressions = evaluate_expressions(x, y, z)\n    max_value = max(expressions)\n    max_index = expressions.index(max_value)\n    \n    # Mapping index to the corresponding expression string\n    expression_strings = [\n        \"x^y^z\", \"x^z^y\", \"(x^y)^z\", \"(x^z)^y\",\n        \"y^x^z\", \"y^z^x\", \"(y^x)^z\", \"(y^z)^x\",\n        \"z^x^y\", \"z^y^x\", \"(z^x)^y\", \"(z^y)^x\"\n    ]\n    \n    return expression_strings[max_index]\n\n# Read input\nx, y, z = map(float, input().split())\n\n# Find and print the maximum expression\nprint(find_max_expression(x, y, z))"}
{"solution": "def min_operations_to_type_string(n, s):\n    # Initialize the minimum operations to the length of the string\n    min_ops = n\n    \n    # Check for the possibility of copying the string at some point\n    for i in range(1, n):\n        # If the substring from the start to the current position i\n        # is a prefix of the remaining string, we can consider copying it\n        if s[:i] == s[i:2*i]:\n            # Operations are the length of the prefix plus 1 for copying\n            # plus the remaining characters after the copy\n            min_ops = min(min_ops, i + 1 + (n - 2*i))\n    \n    return min_ops\n\n# Read input\nn = int(input())\ns = input()\n\n# Output the result\nprint(min_operations_to_type_string(n, s))"}
{"solution": "def generate_rename_script(n, files):\n    examples = []\n    regular = []\n    for name, type_ in files:\n        if type_ == '1':\n            examples.append(name)\n        else:\n            regular.append(name)\n    \n    # Sort examples and regular tests to maintain order\n    examples.sort()\n    regular.sort()\n    \n    # Create a list to hold the move commands\n    moves = []\n    \n    # Rename examples first\n    for i, example in enumerate(examples, start=1):\n        moves.append(f\"move {example} {i}\")\n    \n    # Rename regular tests next\n    for i, reg in enumerate(regular, start=len(examples) + 1):\n        moves.append(f\"move {reg} {i}\")\n    \n    # Print the number of moves\n    print(len(moves))\n    \n    # Print the move commands\n    for move in moves:\n        print(move)\n\n# Read input\nn = int(input().strip())\nfiles = [input().strip().split() for _ in range(n)]\n\n# Generate and print the rename script\ngenerate_rename_script(n, files)"}
{"solution": "def min_replacements_to_make_ticket_lucky(ticket):\n    # Calculate the sum of the first and last three digits\n    sum_first_half = sum(int(digit) for digit in ticket[:3])\n    sum_second_half = sum(int(digit) for digit in ticket[3:])\n    \n    # If the ticket is already lucky, no replacements are needed\n    if sum_first_half == sum_second_half:\n        return 0\n    \n    # Convert the ticket string to a list of integers for easier manipulation\n    ticket_digits = [int(digit) for digit in ticket]\n    \n    # Determine which half has the greater sum and needs to be adjusted\n    if sum_first_half > sum_second_half:\n        larger_sum_digits = ticket_digits[:3]\n        smaller_sum_digits = ticket_digits[3:]\n    else:\n        larger_sum_digits = ticket_digits[3:]\n        smaller_sum_digits = ticket_digits[:3]\n    \n    # Calculate the difference that needs to be compensated\n    difference = abs(sum_first_half - sum_second_half)\n    \n    # Sort the digits of the half with the larger sum in descending order\n    # and the digits of the half with the smaller sum in ascending order\n    larger_sum_digits.sort(reverse=True)\n    smaller_sum_digits.sort()\n    \n    # Initialize the count of replacements needed\n    replacements = 0\n    \n    # Use a two-pointer technique to find the minimum number of replacements\n    i, j = 0, 0\n    while difference > 0:\n        # Calculate the potential reduction in difference\n        reduce_from_larger = larger_sum_digits[i] - 0\n        increase_to_smaller = 9 - smaller_sum_digits[j]\n        \n        # Choose the maximum possible reduction in the difference\n        if reduce_from_larger > increase_to_smaller:\n            difference -= reduce_from_larger\n            i += 1\n        else:\n            difference -= increase_to_smaller\n            j += 1\n        \n        # Increment the replacement count\n        replacements += 1\n    \n    return replacements\n\n# Example usage:\n# print(min_replacements_to_make_ticket_lucky(\"000000\"))  # Output: 0\n# print(min_replacements_to_make_ticket_lucky(\"123456\"))  # Output: 2\n# print(min_replacements_to_make_ticket_lucky(\"111000\"))  # Output: 1"}
{"solution": "def minimum_traps(m, x):\n    return m - 1"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    m0, x0, x1 = m, 0, 1\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    return x1 + m0 if x1 < 0 else x1\n\ndef mod_exp(base, exp, mod):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return result\n\ndef solve(n, k):\n    MOD = 10**6 + 3\n    if k > 2**n:\n        return 1, 1\n    \n    # Calculate the probability of no shared birthdays\n    no_shared_prob = 1\n    for i in range(k - 1):\n        no_shared_prob = (no_shared_prob * (2**n - i)) % MOD\n    \n    # Calculate the total number of possible combinations\n    total_combinations = mod_exp(2**n, k - 1, MOD)\n    \n    # Calculate the probability of at least one shared birthday\n    shared_prob = (total_combinations - no_shared_prob + MOD) % MOD\n    \n    # Calculate the modular inverse of total_combinations\n    total_combinations_inv = mod_inverse(total_combinations, MOD)\n    \n    # Calculate A and B\n    A = shared_prob\n    B = total_combinations\n    \n    # Ensure A and B are coprime\n    g = gcd(A, B)\n    A //= g\n    B //= g\n    \n    # Return A and B modulo MOD\n    return A % MOD, B % MOD\n\n# Read input\nn, k = map(int, input().split())\n\n# Solve the problem and print the result\nA, B = solve(n, k)\nprint(A, B)"}
{"solution": "def is_valid_journey(n, journey_parts):\n    current_position = 0  # 0 represents North Pole, 20000 represents South Pole\n\n    for t_i, dir_i in journey_parts:\n        if dir_i == \"North\":\n            if current_position < t_i:\n                return \"NO\"\n            current_position -= t_i\n        elif dir_i == \"South\":\n            if current_position + t_i > 20000:\n                return \"NO\"\n            current_position += t_i\n        elif dir_i == \"West\" or dir_i == \"East\":\n            if current_position == 0 or current_position == 20000:\n                return \"NO\"\n\n    return \"YES\" if current_position == 0 else \"NO\"\n\n# Reading input\nn = int(input().strip())\njourney_parts = [input().split() for _ in range(n)]\njourney_parts = [(int(t_i), dir_i) for t_i, dir_i in journey_parts]\n\n# Checking and printing the result\nprint(is_valid_journey(n, journey_parts))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef find_common_elements(a1, b1, a2, b2, L, R):\n    # Shift the range to start from 0 to simplify calculations\n    L = max(L, max(b1, b2))\n    if L > R:\n        return 0\n\n    # Calculate the least common multiple of a1 and a2\n    lcm = a1 * a2 // gcd(a1, a2)\n\n    # Find the first common element in the shifted range\n    start = max(b1, b2)\n    while start % a1 != b1 % a1 or start % a2 != b2 % a2:\n        start += 1\n        if start > R:\n            return 0\n\n    # Calculate the number of common elements in the range [L, R]\n    first_common = start\n    last_common = (R - first_common) // lcm * lcm + first_common\n    count = ((last_common - first_common) // lcm + 1) if first_common <= R else 0\n\n    return count\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Print the result\nprint(find_common_elements(a1, b1, a2, b2, L, R))"}
{"solution": "def max_min_pieces_per_plate(n, a, b):\n    max_x = min(a, b, n)  # The maximum possible x is limited by the smallest cake pieces count or the number of plates\n    while max_x > 0:\n        # Check if we can distribute the cakes such that each plate has at least max_x pieces\n        if (a // max_x) + (b // max_x) >= n:\n            return max_x\n        max_x -= 1\n    return 0  # This should never happen given the problem constraints\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(max_min_pieces_per_plate(n, a, b))"}
{"solution": "def is_valid_flag(n, m, field):\n    # Check if the field can be divided into three equal stripes\n    if n % 3 != 0 and m % 3 != 0:\n        return \"NO\"\n    \n    # Determine the height of each stripe\n    stripe_height = n // 3 if n % 3 == 0 else m // 3\n    stripe_width = m if n % 3 == 0 else n\n    \n    # Check each stripe\n    colors = set()\n    for i in range(3):\n        start_row = i * stripe_height if n % 3 == 0 else 0\n        start_col = i * stripe_height if m % 3 == 0 else 0\n        color = field[start_row][start_col]\n        if color in colors:\n            return \"NO\"\n        colors.add(color)\n        \n        for j in range(stripe_height):\n            for k in range(stripe_width):\n                row = start_row + j if n % 3 == 0 else start_row\n                col = start_col + k if m % 3 == 0 else start_col + j\n                if field[row][col] != color:\n                    return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\n# Output result\nprint(is_valid_flag(n, m, field))"}
{"solution": "def spiral_hex_move(n):\n    # Define the pattern of movement in the spiral\n    # Each cycle consists of 6 moves, each move is a step in one of the 6 directions\n    # The length of each move increases every 6 moves\n    # The directions are: right, up-right, up-left, left, down-left, down-right\n    \n    # Determine the cycle and the position within the cycle\n    cycle = n // 6\n    position_in_cycle = n % 6\n    \n    # Calculate the coordinates based on the cycle and position\n    # The first move (right) does not change y coordinate, the second (up-right) increases y by 1, etc.\n    # The x coordinate changes according to the direction of movement\n    x, y = cycle * -1, 0\n    if position_in_cycle == 0:  # Right\n        x += cycle\n    elif position_in_cycle == 1:  # Up-right\n        x += cycle\n        y += 1\n    elif position_in_cycle == 2:  # Up-left\n        x += cycle - 1\n        y += 2\n    elif position_in_cycle == 3:  # Left\n        x += cycle - 1\n        y += 2\n    elif position_in_cycle == 4:  # Down-left\n        x += cycle - 1\n        y += 1\n    elif position_in_cycle == 5:  # Down-right\n        x += cycle\n        y += 1\n    \n    # Adjust the coordinates based on the position within the cycle\n    if position_in_cycle > 0:\n        x += 1\n    if position_in_cycle > 2:\n        y -= 1\n    if position_in_cycle > 4:\n        x -= 1\n    \n    return x, y\n\n# Example usage:\n# n = 3\n# print(spiral_hex_move(n))  # Output: -2 0\n# n = 7\n# print(spiral_hex_move(n))  # Output: 3 2"}
{"solution": "import math\n\ndef can_break_shield(a, b, c):\n    gcd_ab = math.gcd(a, b)\n    return \"Yes\" if c % gcd_ab == 0 else \"No\"\n\na, b, c = map(int, input().split())\nprint(can_break_shield(a, b, c))"}
{"solution": "def can_tracks_coincide(n, L, kefa_barriers, sasha_barriers):\n    # Calculate distances between consecutive barriers for Kefa\n    kefa_distances = [(kefa_barriers[(i + 1) % n] - kefa_barriers[i]) % L for i in range(n)]\n    # Calculate distances between consecutive barriers for Sasha\n    sasha_distances = [(sasha_barriers[(i + 1) % n] - sasha_barriers[i]) % L for i in range(n)]\n    \n    # Double the kefa_distances to handle circular rotation\n    doubled_kefa_distances = kefa_distances + kefa_distances\n    \n    # Check if sasha_distances is a sublist of doubled_kefa_distances\n    for i in range(n):\n        if doubled_kefa_distances[i:i + n] == sasha_distances:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_barriers, sasha_barriers))"}
{"solution": "def longest_non_palindromic_substring(s):\n    # Check if the string is a palindrome\n    if s == s[::-1]:\n        # If the string is a single character or all characters are the same,\n        # there is no non-palindromic substring\n        if len(s) == 1 or len(set(s)) == 1:\n            return 0\n        # Otherwise, the longest non-palindromic substring is the string minus one character\n        else:\n            return len(s) - 1\n    # If the string is not a palindrome, the longest non-palindromic substring is the string itself\n    else:\n        return len(s)\n\n# Read input\ns = input().strip()\n\n# Print the result\nprint(longest_non_palindromic_substring(s))"}
{"solution": "def determine_round_status(n, ratings):\n    rated = False\n    unrated = False\n    \n    for i in range(n):\n        before, after = ratings[i]\n        if before != after:\n            rated = True\n        if i > 0 and ratings[i][1] > ratings[i - 1][1]:\n            unrated = True\n    \n    if rated:\n        return \"rated\"\n    elif unrated:\n        return \"unrated\"\n    else:\n        return \"maybe\"\n\n# Example usage:\n# n = 6\n# ratings = [(3060, 3060), (2194, 2194), (2876, 2903), (2624, 2624), (3007, 2991), (2884, 2884)]\n# print(determine_round_status(n, ratings))"}
{"solution": "def nearest_zero_distances(n, arr):\n    # Initialize the result array with a large number\n    result = [float('inf')] * n\n    \n    # First pass: left to right\n    last_zero = -float('inf')\n    for i in range(n):\n        if arr[i] == 0:\n            last_zero = i\n        result[i] = min(result[i], i - last_zero)\n    \n    # Second pass: right to left\n    last_zero = float('inf')\n    for i in range(n - 1, -1, -1):\n        if arr[i] == 0:\n            last_zero = i\n        result[i] = min(result[i], last_zero - i)\n    \n    return result\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Getting the result and printing it\nresult = nearest_zero_distances(n, arr)\nprint(' '.join(map(str, result)))"}
{"solution": "def count_distinct_cyclical_strings(n, s):\n    from itertools import product\n    \n    def is_substring_in_cyclical_shifts(t, s):\n        t_extended = t + t\n        return any(s in t_extended[i:i+len(t)] for i in range(len(t)))\n    \n    distinct_cyclical_strings = set()\n    \n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if is_substring_in_cyclical_shifts(t, s):\n            distinct_cyclical_strings.add(t)\n    \n    return len(distinct_cyclical_strings)\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Print output\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import math\n\ndef minimal_non_oriented_angle(vectors):\n    def angle_between(v1, v2):\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        magnitudes = math.sqrt(v1[0]**2 + v1[1]**2) * math.sqrt(v2[0]**2 + v2[1]**2)\n        cos_theta = dot_product / magnitudes\n        angle = math.acos(cos_theta)\n        return angle\n\n    min_angle = math.pi\n    min_pair = None\n\n    for i in range(len(vectors)):\n        for j in range(i + 1, len(vectors)):\n            angle = angle_between(vectors[i], vectors[j])\n            if angle < min_angle:\n                min_angle = angle\n                min_pair = (i + 1, j + 1)\n\n    return min_pair\n\n# Read input\nn = int(input())\nvectors = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Find and print the result\nresult = minimal_non_oriented_angle(vectors)\nprint(result[0], result[1])"}
{"solution": "def minimal_time(d, k, a, b, t):\n    if d <= k:\n        return d * a\n    \n    full_segments = d // k\n    remaining_distance = d % k\n    \n    time_for_full_segments = full_segments * k * a + (full_segments - 1) * t\n    \n    if remaining_distance == 0:\n        return time_for_full_segments\n    else:\n        time_drive_remaining = remaining_distance * a + t\n        time_walk_remaining = remaining_distance * b\n        \n        return time_for_full_segments + min(time_drive_remaining, time_walk_remaining)"}
{"solution": "def find_gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef max_gcd_sequence(n, k):\n    if k > n or k == 1:\n        return [-1]\n    \n    # The maximum GCD we can achieve is n // k\n    max_gcd = n // k\n    \n    # Start the sequence with the maximum GCD\n    sequence = [max_gcd]\n    \n    # Fill the rest of the sequence to sum up to n\n    remaining_sum = n - max_gcd\n    for i in range(2, k + 1):\n        next_element = min(remaining_sum - (k - i), max_gcd * i - sum(sequence))\n        if next_element <= 0:\n            return [-1]\n        sequence.append(next_element)\n        remaining_sum -= next_element\n    \n    # Check if the sequence sums up to n and has the maximum possible GCD\n    if sum(sequence) == n and find_gcd(sequence[0], sequence[1]) == max_gcd:\n        return sequence\n    else:\n        return [-1]\n\n# Read input\nn, k = map(int, input().split())\n\n# Get the sequence\nresult = max_gcd_sequence(n, k)\n\n# Print the result\nprint(' '.join(map(str, result)))"}
{"solution": "def count_pairs_divisible_by_5(n, m):\n    count = 0\n    # Count how many numbers in each column have remainder 0, 1, 2, 3, 4 when divided by 5\n    n_remainders = [n // 5 + (1 if n % 5 >= i else 0) for i in range(5)]\n    m_remainders = [m // 5 + (1 if m % 5 >= i else 0) for i in range(5)]\n    \n    # For each possible remainder in the first column, find the corresponding remainder in the second column\n    # that makes the sum divisible by 5 and multiply their counts\n    for i in range(5):\n        count += n_remainders[i] * m_remainders[(5 - i) % 5]\n    \n    return count\n\n# Read input\nn, m = map(int, input().split())\n\n# Print output\nprint(count_pairs_divisible_by_5(n, m))"}
{"solution": "def max_beauty_after_multiplication(n, x, a):\n    # Initialize variables to keep track of the best subarray sum and the current subarray sum\n    best = 0\n    current_sum = 0\n    # Initialize variables to keep track of the best subarray sum after multiplication and the current subarray sum after multiplication\n    best_after_mult = 0\n    current_mult_sum = 0\n\n    for num in a:\n        # Update the current subarray sum\n        current_sum = max(num, current_sum + num)\n        # Update the best subarray sum\n        best = max(best, current_sum)\n        \n        # Update the current subarray sum after multiplication\n        current_mult_sum = max(num * x, current_mult_sum + num * x)\n        # Update the best subarray sum after multiplication\n        best_after_mult = max(best_after_mult, current_mult_sum)\n        \n        # Update the best overall sum considering both the normal and the multiplied subarrays\n        best = max(best, current_mult_sum + best - current_mult_sum, best_after_mult)\n\n    return best\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate and print the maximum possible beauty of array a after applying the operation\nprint(max_beauty_after_multiplication(n, x, a))"}
{"solution": "def find_kth_largest(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(m, x // i)\n        return count\n\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_less_equal(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\n# Assuming the input is provided in the correct format as described\nn, m, k = map(int, input().split())\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    # Initialize variables\n    length = 0\n    chunk = 1\n    next_chunk_start = 1\n\n    # Find the chunk where the k-th digit is located\n    while k > length + (next_chunk_start - 1) * chunk:\n        length += (next_chunk_start - 1) * chunk\n        chunk += 1\n        next_chunk_start *= 10\n\n    # Calculate the exact number and digit within that chunk\n    remaining_length = k - length\n    number = (remaining_length - 1) // chunk + next_chunk_start // 10\n    digit_position = (remaining_length - 1) % chunk\n\n    # Convert the number to string to access the digit_position\n    return int(str(number)[digit_position])\n\n# Read input\nk = int(input())\n\n# Output the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "def max_bourles_after_evening(n, m, r, s, b):\n    # Find the minimum buying price and maximum selling price\n    min_buy_price = min(s)\n    max_sell_price = max(b)\n    \n    # If it's profitable to trade\n    if min_buy_price < max_sell_price:\n        # Calculate the number of shares we can buy with our bourles\n        shares_to_buy = r // min_buy_price\n        # Calculate the total bourles after selling all bought shares\n        total_bourles = shares_to_buy * max_sell_price\n        return total_bourles\n    else:\n        # It's not profitable to trade, so we keep our bourles\n        return r\n\n# Read input\nn, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_bourles_after_evening(n, m, r, s, b))"}
{"solution": "def find_original_message(t):\n    n = len(t)\n    \n    for overlap in range(1, n // 2 + 1):\n        if t[:overlap] == t[-overlap:]:\n            s = t[:-overlap]\n            if s + t[-overlap:] == t:\n                return \"YES\", s\n    \n    return \"NO\", None\n\nt = input().strip()\n\nresult, s = find_original_message(t)\n\nprint(result)\nif result == \"YES\":\n    print(s)"}
{"solution": "def find_teams(n):\n    # Function to calculate the number of teams for a given number of games\n    def calculate_teams(games):\n        teams = 1\n        while games > 0:\n            if teams % 2 == 0:\n                games -= teams // 2\n                teams += teams // 2\n            else:\n                round_robin_games = (teams * (teams - 1)) // 2\n                if games >= round_robin_games:\n                    games -= round_robin_games\n                    teams += teams\n                else:\n                    return -1\n        return teams if games == 0 else -1\n\n    # Start with the smallest possible number of teams and find all valid numbers\n    possible_teams = []\n    teams = 1\n    while True:\n        result = calculate_teams(n)\n        if result == -1:\n            break\n        if result > 0:\n            possible_teams.append(result)\n        teams += 1\n\n    return possible_teams if possible_teams else [-1]\n\n# Read input\nn = int(input().strip())\n\n# Find and print all possible numbers of teams\nfor teams in find_teams(n):\n    print(teams)"}
{"solution": "def max_antipalindromic_beauty(n, s, b):\n    # Initialize the maximum beauty to 0\n    max_beauty = 0\n    \n    # Iterate through the string to find the maximum beauty\n    for i in range(n // 2):\n        # Calculate the beauty if we leave the characters as they are\n        beauty_same = b[i] + b[n - i - 1]\n        # Calculate the beauty if we swap the characters\n        beauty_swap = max(b[i], b[n - i - 1])\n        \n        # Update the maximum beauty considering both possibilities\n        max_beauty += max(beauty_same, beauty_swap)\n    \n    return max_beauty\n\n# Read input\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\n# Calculate and print the maximum possible beauty\nprint(max_antipalindromic_beauty(n, s, b))"}
{"solution": "def can_weigh_item(w, m):\n    while m > 0:\n        remainder = m % w\n        if remainder == 0:\n            m //= w\n        elif remainder == 1:\n            m = (m - 1) // w\n        elif remainder == w - 1:\n            m = (m + 1) // w\n        else:\n            return 'NO'\n    return 'YES'\n\n# Read input\nw, m = map(int, input().split())\n\n# Output result\nprint(can_weigh_item(w, m))"}
{"solution": "def find_sequence(n, k):\n    # Check if it's possible to find such a sequence\n    if k > n or (k == 1 and n != 1):\n        return \"No\"\n    \n    # Special case when n is 1\n    if n == 1:\n        return \"Yes\\n\" + \" \".join([\"0\"] * k)\n    \n    # Find the largest power of 2 that is less than or equal to n\n    max_power = 1\n    while max_power <= n:\n        max_power *= 2\n    max_power //= 2\n    \n    # Start with the largest power of 2 and fill the sequence\n    sequence = []\n    while max_power > 0:\n        if n >= max_power and k > 0:\n            count = min(k, n // max_power)\n            sequence.extend([int(math.log2(max_power))] * count)\n            n -= max_power * count\n            k -= count\n        max_power //= 2\n    \n    # If there are still elements left to fill, use negative powers of 2\n    if k > 0:\n        if n == 0:\n            # If n is already 0, we need to replace some elements with smaller ones\n            for i in range(len(sequence)):\n                if k == 0:\n                    break\n                power = sequence[i]\n                while power > -200 and k > 0:  # Assuming -10^18 is approximately -2^60\n                    sequence[i] -= 1\n                    k -= 1\n                    n += 2 ** (sequence[i] + 1) - 2 ** sequence[i]\n        else:\n            # If n is not 0, we can directly use negative powers of 2\n            power = -1\n            while k > 0:\n                sequence.append(power)\n                k -= 1\n                n -= 2 ** power\n                power -= 1\n    \n    # Check if we successfully found a sequence\n    if n != 0:\n        return \"No\"\n    \n    # Sort the sequence to be lexicographically largest\n    sequence.sort(reverse=True)\n    return \"Yes\\n\" + \" \".join(map(str, sequence))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\n\n# Print the result\nprint(find_sequence(n, k))"}
{"solution": "def full_glasses(n, t):\n    # Initialize a 2D list to represent the glasses in the pyramid\n    glasses = [[0] * (i + 1) for i in range(n)]\n    \n    for second in range(t):\n        overflow = 1  # Amount of champagne poured each second\n        for level in range(n):\n            for glass in range(level + 1):\n                # Distribute the overflow to the current glass\n                added_champagne = min(overflow, 1 - glasses[level][glass])\n                glasses[level][glass] += added_champagne\n                overflow -= added_champagne\n                \n                # If the glass overflows, distribute the excess to the glasses below\n                if glasses[level][glass] > 1:\n                    overflow += (glasses[level][glass] - 1) * 2\n                    glasses[level][glass] = 1\n                \n                # If there's no overflow left, break the loop\n                if overflow == 0:\n                    break\n            if overflow == 0:\n                break\n    \n    # Count the number of completely full glasses\n    full_count = sum(glass == 1 for level in glasses for glass in level)\n    return full_count\n\n# Read input\nn, t = map(int, input().split())\n\n# Print the output\nprint(full_glasses(n, t))"}
{"solution": "def calculate_area(n, vertices):\n    if n == 1:\n        return -1\n    elif n == 2:\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        if x1 != x2 and y1 != y2:\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 3:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 4:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n\n# Example usage:\nn = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\nprint(calculate_area(n, vertices))"}
{"solution": "def minimal_wooden_bars(n, a, b):\n    # Calculate the total length needed for two doors\n    total_length_needed = 4 * a + 2 * b\n    \n    # Calculate the minimal number of bars needed\n    minimal_bars = (total_length_needed + n - 1) // n  # This is equivalent to ceil(total_length_needed / n)\n    \n    return minimal_bars\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\n\n# Calculate and print the result\nprint(minimal_wooden_bars(n, a, b))"}
{"solution": "def can_sort_array(n, a, swaps):\n    # Find the positions where swaps are allowed\n    swap_positions = [i for i in range(n - 1) if swaps[i] == '1']\n    \n    # Check if we can sort the array by only swapping at allowed positions\n    for i in range(n):\n        # Find the correct position for a[i]\n        correct_pos = a.index(i + 1)\n        \n        # Move element a[i] to its correct position if possible\n        while i != correct_pos:\n            if i + 1 in swap_positions:\n                # Swap a[i] with a[i + 1]\n                a[i], a[i + 1] = a[i + 1], a[i]\n                # Update the correct position\n                correct_pos -= 1\n            else:\n                # If we can't swap to reach the correct position, return NO\n                return \"NO\"\n    \n    # If we successfully moved all elements to their correct positions, return YES\n    return \"YES\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nswaps = input()\n\n# Output the result\nprint(can_sort_array(n, a, swaps))"}
{"solution": "def calculate_waiting_time(n, s):\n    # Define the sequence of moves for the flight attendants\n    move_sequence = [2, 1]\n    \n    # Calculate the total number of moves needed to reach row n\n    total_moves = 0\n    while total_moves + move_sequence[0] < n - 1:\n        total_moves += move_sequence[0]\n        move_sequence = move_sequence[::-1]  # Reverse the sequence\n    \n    # Determine which attendant serves Vasya's row\n    serving_attendant = 1 if total_moves + move_sequence[0] >= n - 1 else 2\n    \n    # Calculate the time taken to reach Vasya's row\n    time_to_row = total_moves * 2 + serving_attendant  # Each move takes 2 seconds (1 sec for move, 1 sec for service)\n    \n    # Calculate the time taken to serve passengers in Vasya's row\n    seats_right = ['f', 'e', 'd']\n    seats_left = ['c', 'b', 'a']\n    \n    if s in seats_right:\n        time_to_serve = seats_right.index(s) + 1\n    else:\n        time_to_serve = len(seats_right) + seats_left.index(s) + 1\n    \n    # Total waiting time is the sum of time to reach the row and time to serve Vasya\n    total_waiting_time = time_to_row + time_to_serve\n    \n    return total_waiting_time\n\n# Read input\nimport sys\ninput = sys.stdin.read().strip()\nn = int(input[:-1])\ns = input[-1]\n\n# Calculate and print the result\nprint(calculate_waiting_time(n, s))"}
{"solution": "def convert_to_base_10(digits, base):\n    value = 0\n    for digit in digits:\n        value = value * base + digit\n    return value\n\ndef compare_numbers(n, b_x, x_digits, m, b_y, y_digits):\n    x_value = convert_to_base_10(x_digits, b_x)\n    y_value = convert_to_base_10(y_digits, b_y)\n    \n    if x_value < y_value:\n        return '<'\n    elif x_value > y_value:\n        return '>'\n    else:\n        return '='\n\n# Read input\nn, b_x = map(int, input().split())\nx_digits = list(map(int, input().split()))\nm, b_y = map(int, input().split())\ny_digits = list(map(int, input().split()))\n\n# Compare and print the result\nprint(compare_numbers(n, b_x, x_digits, m, b_y, y_digits))"}
{"solution": "def game_winner(n, a):\n    if n == 1:\n        return \"BitLGM\" if a[0] != 0 else \"BitAryo\"\n    elif n == 2:\n        dp = [[False] * 300 for _ in range(300)]\n        for i in range(300):\n            for j in range(300):\n                if not dp[i][j]:\n                    for k in range(1, 300 - i):\n                        dp[i + k][j] = True\n                    for k in range(1, 300 - j):\n                        dp[i][j + k] = True\n                    for k in range(1, 300 - min(i, j)):\n                        dp[i + k][j + k] = True\n        return \"BitLGM\" if dp[a[0]][a[1]] else \"BitAryo\"\n    else:  # n == 3\n        return \"BitLGM\" if a[0] ^ a[1] ^ a[2] != 0 else \"BitAryo\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the winner\nprint(game_winner(n, a))"}
{"solution": "from math import gcd\nfrom functools import reduce\n\ndef prime_factors(n):\n    factors = {}\n    for i in range(2, int(n**0.5) + 1):\n        while n % i == 0:\n            factors[i] = factors.get(i, 0) + 1\n            n //= i\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef product_of_slice(deck, start, end):\n    return reduce(lambda x, y: x * y, deck[start:end], 1)\n\ndef count_ways(n, k, deck):\n    factors_k = prime_factors(k)\n    left = 0\n    right = 0\n    product = 1\n    ways = 0\n    factors_count = {factor: 0 for factor in factors_k}\n\n    while right <= n:\n        # Check if the current window satisfies the condition\n        if all(factors_count[factor] >= count for factor, count in factors_k.items()):\n            ways += n - right + 1\n            # Move the left pointer to shrink the window\n            if left < n:\n                product //= deck[left]\n                for factor in prime_factors(deck[left]):\n                    factors_count[factor] -= 1\n                left += 1\n            else:\n                break\n        else:\n            # Move the right pointer to expand the window\n            if right < n:\n                product *= deck[right]\n                for factor in prime_factors(deck[right]):\n                    factors_count[factor] += 1\n                right += 1\n            else:\n                break\n\n    return ways\n\n# Read input\nn, k = map(int, input().split())\ndeck = list(map(int, input().split()))\n\n# Calculate and print the number of ways\nprint(count_ways(n, k, deck))"}
{"solution": "def can_distribute_balloons(n, k, s):\n    # Create a dictionary to count the occurrences of each color\n    color_count = {}\n    for color in s:\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n    \n    # Check if any color appears more times than the number of friends\n    for count in color_count.values():\n        if count > k:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ns = input()\n\n# Print the result\nprint(can_distribute_balloons(n, k, s))"}
{"solution": "def find_nearest_minimum_distance(n, arr):\n    min_value = min(arr)\n    last_min_index = -1\n    min_distance = n\n\n    for i in range(n):\n        if arr[i] == min_value:\n            if last_min_index != -1:\n                min_distance = min(min_distance, i - last_min_index)\n            last_min_index = i\n\n    return min_distance\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Finding and printing the result\nprint(find_nearest_minimum_distance(n, arr))"}
{"solution": "from math import gcd\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef solve(t, w, b):\n    # Calculate the least common multiple of w and b\n    lcm_wb = lcm(w, b)\n    \n    # Calculate the number of ties\n    min_step = min(w, b)\n    ties = (t // lcm_wb) * min_step + min(min_step - 1, t % lcm_wb)\n    \n    # Calculate the gcd of ties and t to make the fraction irreducible\n    common_divisor = gcd(ties, t)\n    ties //= common_divisor\n    t //= common_divisor\n    \n    return f\"{ties}/{t}\"\n\n# Read input\nt, w, b = map(int, input().split())\n\n# Output the result\nprint(solve(t, w, b))"}
{"solution": "def determine_vote_result(x, y, z):\n    # Calculate the minimum and maximum possible upvotes\n    min_upvotes = x\n    max_upvotes = x + z\n    \n    # Calculate the minimum and maximum possible downvotes\n    min_downvotes = y\n    max_downvotes = y + z\n    \n    # Determine the result based on the possible upvotes and downvotes\n    if max_upvotes > min_downvotes and min_upvotes > max_downvotes:\n        return \"+\"\n    elif max_downvotes > min_upvotes and min_downvotes > max_upvotes:\n        return \"-\"\n    elif min_upvotes == max_downvotes or max_upvotes == min_downvotes:\n        return \"0\"\n    else:\n        return \"?\"\n\n# Read input\nx, y, z = map(int, input().split())\n\n# Print the result\nprint(determine_vote_result(x, y, z))"}
{"solution": "def min_subsegment_change(n, operations, x, y):\n    # Calculate the prefix sums for horizontal and vertical movements\n    prefix_x = [0] * (n + 1)\n    prefix_y = [0] * (n + 1)\n    \n    for i, op in enumerate(operations):\n        prefix_x[i + 1] = prefix_x[i]\n        prefix_y[i + 1] = prefix_y[i]\n        if op == 'U':\n            prefix_y[i + 1] += 1\n        elif op == 'D':\n            prefix_y[i + 1] -= 1\n        elif op == 'L':\n            prefix_x[i + 1] -= 1\n        elif op == 'R':\n            prefix_x[i + 1] += 1\n    \n    # Function to check if it's possible to reach (x, y) by changing a subsegment of length 'length'\n    def can_reach(length):\n        for start in range(n - length + 1):\n            end = start + length\n            current_x = prefix_x[start] + (prefix_x[n] - prefix_x[end])\n            current_y = prefix_y[start] + (prefix_y[n] - prefix_y[end])\n            # Check if the distance to (x, y) is less than or equal to 'length' and can be adjusted with the remaining moves\n            if abs(x - current_x) + abs(y - current_y) <= length and (length - abs(x - current_x) - abs(y - current_y)) % 2 == 0:\n                return True\n        return False\n    \n    # Binary search to find the minimum length of the subsegment that needs to be changed\n    left, right = 0, n\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if can_reach(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\n# Read input\nn = int(input())\noperations = input().strip()\nx, y = map(int, input().split())\n\n# Output the result\nprint(min_subsegment_change(n, operations, x, y))"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    \n    results = []\n    \n    for _ in range(T):\n        n = int(data[index])\n        x = int(data[index + 1])\n        s = data[index + 2]\n        index += 3\n        \n        balance_s = s.count('0') - s.count('1')\n        prefix_balances = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix_balances[i + 1] = prefix_balances[i] + (1 if s[i] == '0' else -1)\n        \n        if balance_s == 0:\n            if x in prefix_balances:\n                results.append(-1)\n            else:\n                results.append(0)\n        else:\n            count = 0\n            for b in prefix_balances:\n                if (x - b) % balance_s == 0 and (x - b) // balance_s >= 0:\n                    count += 1\n            results.append(count)\n    \n    for result in results:\n        print(result)"}
{"solution": "def min_digits_to_delete(n, k):\n    # Convert the number to a string for easier manipulation\n    n_str = str(n)\n    \n    # Initialize the count of digits to delete\n    digits_to_delete = 0\n    \n    # Start from the end of the string and move backwards\n    for i in range(len(n_str) - 1, -1, -1):\n        # If we have found enough zeros to make the number divisible by 10^k, break\n        if k == 0:\n            break\n        \n        # If the current digit is '0', decrement k\n        if n_str[i] == '0':\n            k -= 1\n        else:\n            # If the current digit is not '0', increment the count of digits to delete\n            digits_to_delete += 1\n    \n    # If k is not zero, it means we didn't find enough zeros, so we need to delete all digits except the first one\n    if k != 0:\n        return len(n_str) - 1\n    \n    return digits_to_delete\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the result\nprint(min_digits_to_delete(n, k))"}
{"solution": "def calculate_questions(n, m, k, x, y):\n    # Calculate the number of complete cycles of asking questions\n    full_cycles = k // (m * n)\n    # Calculate the remaining questions after the full cycles\n    remaining_questions = k % (m * n)\n    \n    # Initialize the counts for maximum, minimum, and Sergei's questions\n    max_questions = full_cycles + (1 if remaining_questions > 0 else 0)\n    min_questions = full_cycles\n    sergei_questions = full_cycles\n    \n    # If there's more than one row, adjust the max and min questions\n    if n > 1:\n        max_questions *= 2\n        min_questions = full_cycles * 2 - full_cycles // (n - 1)\n    \n    # Calculate Sergei's questions based on his position\n    if x == 1 or x == n:\n        sergei_questions *= 1\n    else:\n        sergei_questions *= 2\n    \n    # Handle the remaining questions\n    for i in range(1, remaining_questions + 1):\n        row = (i - 1) // m + 1\n        col = (i - 1) % m + 1\n        if row == x and col == y:\n            sergei_questions += 1\n        if row == 1 or row == n or (row < n and (full_cycles % (n - 1) >= n - row)):\n            max_questions += 1\n    \n    return max_questions, min_questions, sergei_questions\n\n# Read input\nn, m, k, x, y = map(int, input().split())\n\n# Calculate and print the result\nmax_q, min_q, sergei_q = calculate_questions(n, m, k, x, y)\nprint(max_q, min_q, sergei_q)"}
{"solution": "from collections import Counter\n\ndef calculate_beauty(ribbon, n):\n    counter = Counter(ribbon)\n    most_common_count = counter.most_common(1)[0][1]\n    if n == 0:\n        return most_common_count\n    if most_common_count == 1:\n        return min(len(ribbon), n)\n    if most_common_count + n > len(ribbon):\n        return len(ribbon) if most_common_count + n == len(ribbon) + 1 else len(ribbon) - 1\n    return most_common_count + n\n\ndef determine_winner(n, ribbons):\n    beauties = [calculate_beauty(ribbon, n) for ribbon in ribbons]\n    max_beauty = max(beauties)\n    winners = [i for i, beauty in enumerate(beauties) if beauty == max_beauty]\n    \n    if len(winners) > 1:\n        return \"Draw\"\n    else:\n        return [\"Kuro\", \"Shiro\", \"Katie\"][winners[0]]\n\n# Read input\nn = int(input())\nribbons = [input().strip() for _ in range(3)]\n\n# Determine the winner\nwinner = determine_winner(n, ribbons)\nprint(winner)"}
{"solution": "def calculate_days_to_finish_book(c, v_0, v_1, a, l):\n    days = 0\n    total_read = 0\n    current_speed = v_0\n\n    while total_read < c:\n        if days > 0:\n            total_read -= l\n        total_read += min(current_speed, v_1)\n        current_speed += a\n        days += 1\n\n    return days\n\n# Example usage:\n# c, v_0, v_1, a, l = map(int, input().split())\n# print(calculate_days_to_finish_book(c, v_0, v_1, a, l))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_prime_sum(n):\n    if is_prime(n):\n        return 1, [n]\n    for i in range(2, n):\n        if is_prime(i) and is_prime(n - i):\n            return 2, [i, n - i]\n    for i in range(2, n):\n        if is_prime(i):\n            for j in range(i, n - i):\n                if is_prime(j) and is_prime(n - i - j):\n                    return 3, [i, j, n - i - j]\n\nn = int(input())\nk, primes = find_prime_sum(n)\nprint(k)\nprint(*primes)"}
{"solution": "def can_wipe_out_all_walls(n, m, grid):\n    row_walls = [0] * n\n    col_walls = [0] * m\n    total_walls = 0\n\n    # Count walls in each row and column\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*':\n                row_walls[i] += 1\n                col_walls[j] += 1\n                total_walls += 1\n\n    # Check each cell for potential bomb placement\n    for i in range(n):\n        for j in range(m):\n            walls_cleared = row_walls[i] + col_walls[j]\n            if grid[i][j] == '*':  # Subtract overlap if cell (i, j) has a wall\n                walls_cleared -= 1\n            if walls_cleared == total_walls:\n                return \"YES\", i + 1, j + 1  # Convert to 1-based indexing\n\n    return \"NO\", None, None\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Solve the problem\nresult, x, y = can_wipe_out_all_walls(n, m, grid)\n\n# Print the output\nprint(result)\nif result == \"YES\":\n    print(x, y)"}
{"solution": "def minimal_cost_to_satisfy_delegations(n, m, a, b):\n    # Calculate the remainder when n is divided by m\n    remainder = n % m\n    \n    # If the remainder is 0, no action is needed\n    if remainder == 0:\n        return 0\n    \n    # Calculate the cost to build enough boxes to make n divisible by m\n    build_cost = (m - remainder) * a\n    \n    # Calculate the cost to demolish boxes to make n divisible by m\n    demolish_cost = remainder * b\n    \n    # Return the minimum of the two costs\n    return min(build_cost, demolish_cost)\n\n# Read input from standard input\nn, m, a, b = map(int, input().split())\n\n# Output the result\nprint(minimal_cost_to_satisfy_delegations(n, m, a, b))"}
{"solution": "def max_odd_sum_subsequence(n, sequence):\n    # Separate positive and negative numbers\n    positives = [x for x in sequence if x > 0]\n    negatives = [x for x in sequence if x < 0]\n    \n    # Sort positives in descending order and negatives in ascending order\n    positives.sort(reverse=True)\n    negatives.sort()\n    \n    # Initialize the maximum sum and current sum\n    max_sum = 0\n    current_sum = 0\n    \n    # Try to include as many positive numbers as possible while keeping the sum even\n    for num in positives:\n        if (current_sum + num) % 2 == 0:\n            current_sum += num\n        else:\n            max_sum = max(max_sum, current_sum + num)\n            break\n    \n    # If the current sum is odd, it's already the maximum odd sum\n    if current_sum % 2 != 0:\n        return current_sum\n    \n    # If the current sum is even, try to replace the smallest positive with the largest negative to make the sum odd\n    if positives:\n        smallest_positive = positives[-1]\n        for neg in negatives:\n            if neg % 2 != 0:\n                max_sum = max(max_sum, current_sum - smallest_positive + neg)\n                break\n    \n    return max_sum\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Print the result\nprint(max_odd_sum_subsequence(n, sequence))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_playlists(n, T, songs):\n    dp = [[[0 for _ in range(4)] for _ in range(T+1)] for _ in range(1 << n)]\n    for i in range(n):\n        if songs[i][0] <= T:\n            dp[1 << i][songs[i][0]][songs[i][1]] = 1\n    \n    for mask in range(1 << n):\n        for i in range(n):\n            if mask & (1 << i):\n                continue\n            for t in range(T + 1):\n                for g in range(1, 4):\n                    if t + songs[i][0] <= T and g != songs[i][1]:\n                        dp[mask | (1 << i)][t + songs[i][0]][songs[i][1]] += dp[mask][t][g]\n                        dp[mask | (1 << i)][t + songs[i][0]][songs[i][1]] %= MOD\n    \n    result = 0\n    for mask in range(1 << n):\n        for g in range(1, 4):\n            result += dp[mask][T][g]\n            result %= MOD\n    \n    return result\n\n# Read input\nn, T = map(int, input().split())\nsongs = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(count_playlists(n, T, songs))"}
{"solution": "MOD = 10**9 + 7\n\ndef modinv(a, m):\n    return pow(a, m - 2, m)\n\ndef expected_length(m):\n    # Calculate the expected length of the array a\n    # The expected length can be represented as the sum of a geometric series\n    # where the common ratio is the probability of not getting a 1 (i.e., (m-1)/m)\n    # and the first term is 1 (since we start with one element).\n    # The formula for the sum of an infinite geometric series is a / (1 - r)\n    # Here, a = 1 and r = (m-1)/m\n    r = (m - 1) * modinv(m, MOD) % MOD\n    expected_len = modinv(1 - r, MOD)\n    return expected_len\n\n# Read input\nm = int(input())\n\n# Calculate and print the result\nprint(expected_length(m))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_good_pairs(l, r, x, y):\n    if y % x != 0:\n        return 0\n    \n    count = 0\n    for a in range(l, r + 1):\n        if a % x == 0 and y % a == 0:\n            b = y // a\n            if l <= b <= r and gcd(a, b) == x:\n                count += 1\n    return count\n\n# Read input\nl, r, x, y = map(int, input().split())\n\n# Calculate and print the result\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef find_smallest_k(a, b):\n    if a == b:\n        return 0\n    if a < b:\n        a, b = b, a\n    diff = a - b\n    smallest_k = 0\n    min_lcm = (a * b) // gcd(a, b)\n    for i in range(1, int(diff**0.5) + 1):\n        if diff % i == 0:\n            k = (i - (a % i)) % i\n            lcm = ((a + k) * (b + k)) // gcd(a + k, b + k)\n            if lcm < min_lcm or (lcm == min_lcm and k < smallest_k):\n                min_lcm = lcm\n                smallest_k = k\n            j = diff // i\n            k = (j - (a % j)) % j\n            lcm = ((a + k) * (b + k)) // gcd(a + k, b + k)\n            if lcm < min_lcm or (lcm == min_lcm and k < smallest_k):\n                min_lcm = lcm\n                smallest_k = k\n    return smallest_k\n\n# Read input\na, b = map(int, input().split())\n\n# Find and print the smallest k\nprint(find_smallest_k(a, b))"}
{"solution": "def minimal_additional_marks(n, k, marks):\n    current_sum = sum(marks)\n    target_average = k - 0.5  # We need the average to be at least k - 0.5 to round up to k\n    additional_marks_needed = 0\n    \n    while True:\n        new_average = (current_sum + additional_marks_needed * k) / (n + additional_marks_needed)\n        if new_average >= target_average:\n            break\n        additional_marks_needed += 1\n    \n    return additional_marks_needed\n\n# Reading input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(minimal_additional_marks(n, k, marks))"}
{"solution": "def find_divisor(n, arr):\n    for d in range(-1000, 1001):\n        if d == 0:\n            continue\n        positive_count = sum(1 for a in arr if a / d > 0)\n        if positive_count >= (n + 1) // 2:\n            return d\n    return 0\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Find and print the divisor\nprint(find_divisor(n, arr))"}
{"solution": "def max_nines_pairs(n):\n    # Function to calculate the number of pairs with the maximum number of nines at the end of their sum\n    def count_pairs_with_nines(target):\n        # Count pairs that sum up to 'target'\n        return (target // 10) if target <= n else (n - target // 10 + 1)\n    \n    # Start with the maximum number of nines possible, which is when the sum ends with 999...9 (k nines)\n    max_nines = 0\n    target = 9\n    while target <= 2 * n:\n        pairs_count = count_pairs_with_nines(target)\n        if pairs_count > 0:\n            max_nines = pairs_count\n        target = target * 10 + 9\n    \n    return max_nines\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(max_nines_pairs(n))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef min_minutes_to_equalize(a1, b1, a2, b2):\n    # Calculate the initial number of squares in each bar\n    size1 = a1 * b1\n    size2 = a2 * b2\n    \n    # If they are already equal, no minutes are needed\n    if size1 == size2:\n        return 0, a1, b1, a2, b2\n    \n    # Find the least common multiple of the two sizes\n    target_size = lcm(size1, size2)\n    \n    # Calculate the number of minutes needed to reach the target size for each bar\n    minutes1 = 0\n    while size1 < target_size:\n        if target_size % (size1 * 2) == 0:\n            size1 *= 2\n        elif target_size % (size1 * 3) == 0:\n            size1 *= 3\n        else:\n            return -1, None, None, None, None\n        minutes1 += 1\n    \n    minutes2 = 0\n    while size2 < target_size:\n        if target_size % (size2 * 2) == 0:\n            size2 *= 2\n        elif target_size % (size2 * 3) == 0:\n            size2 *= 3\n        else:\n            return -1, None, None, None, None\n        minutes2 += 1\n    \n    # Determine the final sizes of the bars\n    final_a1, final_b1 = a1, b1\n    for _ in range(minutes1):\n        if final_a1 % 2 == 0:\n            final_a1 //= 2\n        elif final_b1 % 2 == 0:\n            final_b1 //= 2\n        elif final_a1 % 3 == 0:\n            final_a1 //= 3\n            final_a1 *= 2\n        elif final_b1 % 3 == 0:\n            final_b1 //= 3\n            final_b1 *= 2\n    \n    final_a2, final_b2 = a2, b2\n    for _ in range(minutes2):\n        if final_a2 % 2 == 0:\n            final_a2 //= 2\n        elif final_b2 % 2 == 0:\n            final_b2 //= 2\n        elif final_a2 % 3 == 0:\n            final_a2 //= 3\n            final_a2 *= 2\n        elif final_b2 % 3 == 0:\n            final_b2 //= 3\n            final_b2 *= 2\n    \n    return max(minutes1, minutes2), final_a1, final_b1, final_a2, final_b2\n\n# Read input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\n# Calculate and print the result\nminutes, final_a1, final_b1, final_a2, final_b2 = min_minutes_to_equalize(a1, b1, a2, b2)\nif minutes == -1:\n    print(minutes)\nelse:\n    print(minutes)\n    print(final_a1, final_b1)\n    print(final_a2, final_b2)"}
{"solution": "def determine_winner(x_p, y_p, x_v, y_v):\n    # Polycarp can always move diagonally towards (0, 0) if he is on the diagonal or closer to the diagonal than Vasiliy\n    if x_p + y_p <= max(x_v, y_v):\n        return \"Polycarp\"\n    # If Vasiliy is closer to one of the axes than Polycarp, he can move towards that axis and win\n    elif x_v <= x_p and y_v <= y_p:\n        return \"Vasiliy\"\n    # If neither condition is met, the game is a draw or requires further analysis\n    else:\n        return \"Vasiliy\" if max(x_v, y_v) < max(x_p, y_p) else \"Polycarp\"\n\n# Read input\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Determine the winner and print the result\nprint(determine_winner(x_p, y_p, x_v, y_v))"}
{"solution": "def calculate_columns(m, d):\n    # Days in each month\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    # Calculate the number of days in the given month\n    days = days_in_month[m - 1]\n    \n    # Calculate the number of full weeks and the remaining days\n    full_weeks = (days - (8 - d)) // 7\n    remaining_days = (days - (8 - d)) % 7\n    \n    # Add one more column if there are remaining days\n    columns = full_weeks + 1 + (1 if remaining_days > 0 else 0)\n    \n    return columns\n\n# Read input\nm, d = map(int, input().split())\n\n# Calculate and print the number of columns\nprint(calculate_columns(m, d))"}
{"solution": "def count_years_with_one_zero(a, b):\n    def has_exactly_one_zero(n):\n        binary_str = bin(n)[2:]\n        return binary_str.count('0') == 1\n    \n    count = 0\n    for year in range(a, b + 1):\n        if has_exactly_one_zero(year):\n            count += 1\n    return count\n\n# Read input\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(count_years_with_one_zero(a, b))"}
{"solution": "def minimal_layers(N):\n    return (N * (N + 1)) // 2\n\n# Assuming the input is provided through a standard input method\nN = int(input().strip())\nprint(minimal_layers(N))"}
{"solution": "from math import factorial\n\ndef count_ways(n, k, S, cubes):\n    def factorial_or_number(x, with_factorial):\n        return factorial(x) if with_factorial else x\n\n    def count_combinations(index, remaining_stickers, current_sum):\n        if current_sum == S:\n            return 1\n        if index == n or current_sum > S or remaining_stickers == 0:\n            return 0\n        \n        ways = 0\n        # Include the cube with a sticker\n        if remaining_stickers > 0:\n            ways += count_combinations(index + 1, remaining_stickers - 1, current_sum + factorial_or_number(cubes[index], True))\n        # Include the cube without a sticker\n        ways += count_combinations(index + 1, remaining_stickers, current_sum + factorial_or_number(cubes[index], False))\n        # Exclude the cube\n        ways += count_combinations(index + 1, remaining_stickers, current_sum)\n        \n        return ways\n\n    return count_combinations(0, k, 0)\n\n# Read input\nn, k, S = map(int, input().split())\ncubes = list(map(int, input().split()))\n\n# Calculate and print the number of ways\nprint(count_ways(n, k, S, cubes))"}
{"solution": "def can_transform_array(n, k, a):\n    # Create a frequency map for the powers of k needed to form array a\n    freq = {}\n    for value in a:\n        # Decompose each element into the sum of powers of k\n        while value > 0:\n            power = 0\n            while k ** (power + 1) <= value:\n                power += 1\n            value -= k ** power\n            if power in freq:\n                freq[power] += 1\n            else:\n                freq[power] = 1\n            # If any power is used more than once, return NO\n            if freq[power] > 1:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        n = int(data[index])\n        k = int(data[index + 1])\n        a = list(map(int, data[index + 2: index + 2 + n]))\n        index += 2 + n\n        results.append(can_transform_array(n, k, a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def number_of_divisors(n):\n    divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        count = 0\n        while n % i == 0:\n            n //= i\n            count += 1\n        divisors *= (count + 1)\n    if n > 1:\n        divisors *= 2\n    return divisors\n\ndef calculate_sum(a, b, c):\n    MOD = 1073741824  # 2^30\n    total_sum = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                total_sum += number_of_divisors(i * j * k)\n                if total_sum >= MOD:\n                    total_sum %= MOD\n    return total_sum\n\n# Read input\na, b, c = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_sum(a, b, c))"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    neighbors = []\n    idx = state.index('X')\n    if idx == 0:\n        neighbors.append(swap(state, 0, 1))\n        neighbors.append(swap(state, 0, 2))\n    elif idx == 1:\n        neighbors.append(swap(state, 1, 0))\n        neighbors.append(swap(state, 1, 3))\n    elif idx == 2:\n        neighbors.append(swap(state, 2, 0))\n        neighbors.append(swap(state, 2, 3))\n    elif idx == 3:\n        neighbors.append(swap(state, 3, 1))\n        neighbors.append(swap(state, 3, 2))\n    return neighbors\n\ndef swap(state, i, j):\n    state = list(state)\n    state[i], state[j] = state[j], state[i]\n    return ''.join(state)\n\ndef bfs(start):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        current = queue.popleft()\n        for neighbor in get_neighbors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return visited\n\ndef can_be_same_configuration(bessie, elsie):\n    bessie_start = ''.join(bessie)\n    elsie_start = ''.join(elsie)\n    \n    bessie_reachable = bfs(bessie_start)\n    elsie_reachable = bfs(elsie_start)\n    \n    return not bessie_reachable.isdisjoint(elsie_reachable)\n\n# Input reading\nbessie = [input().strip() for _ in range(2)]\nelsie = [input().strip() for _ in range(2)]\n\nif can_be_same_configuration(bessie, elsie):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_decimal_from_base_n(n, k):\n    k_digits = [int(digit) for digit in str(k)]\n    result = 0\n    power = 1\n    for digit in reversed(k_digits):\n        result += digit * power\n        power *= n\n    return result\n\n# Read input\nn = int(input().strip())\nk = input().strip()\n\n# Output the result\nprint(min_decimal_from_base_n(n, k))"}
{"solution": "def is_unimodal(n, arr):\n    # Check for strictly increasing part\n    i = 0\n    while i < n - 1 and arr[i] < arr[i + 1]:\n        i += 1\n    \n    # Check for constant part\n    while i < n - 1 and arr[i] == arr[i + 1]:\n        i += 1\n    \n    # Check for strictly decreasing part\n    while i < n - 1 and arr[i] > arr[i + 1]:\n        i += 1\n    \n    # If we have reached the end of the array, it is unimodal\n    return \"YES\" if i == n - 1 else \"NO\"\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output result\nprint(is_unimodal(n, arr))"}
{"solution": "def max_value_in_at_least_k_paths(n, k):\n    # Initialize the maximum value to be returned\n    max_value = 1\n    \n    # We will use a dictionary to count occurrences of each value in paths\n    occurrences = {}\n    \n    # Function to generate path for a given value and update occurrences\n    def generate_path(x):\n        while x > 1:\n            if x in occurrences:\n                occurrences[x] += 1\n            else:\n                occurrences[x] = 1\n            if x % 2 == 0:\n                x //= 2\n            else:\n                x -= 1\n        # Count occurrence of 1 as well\n        if 1 in occurrences:\n            occurrences[1] += 1\n        else:\n            occurrences[1] = 1\n    \n    # Generate paths for all values from 1 to n\n    for i in range(1, n + 1):\n        generate_path(i)\n    \n    # Find the maximum value that occurs in at least k paths\n    for value, count in occurrences.items():\n        if count >= k:\n            max_value = max(max_value, value)\n    \n    return max_value\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the output\nprint(max_value_in_at_least_k_paths(n, k))"}
{"solution": "def billiard_ball_pocket(n, m, x, y, vx, vy):\n    # If the ball is moving vertically but not horizontally, or vice versa,\n    # it will fall into a pocket directly.\n    if vx == 0:\n        return f\"0 {y}\" if vy < 0 else f\"{n} {y}\"\n    if vy == 0:\n        return f\"{x} 0\" if vx < 0 else f\"{x} {m}\"\n\n    # If the ball is moving at a 45-degree angle, we need to check if it will\n    # eventually fall into a pocket.\n    if abs(vx) == abs(vy):\n        # Calculate the number of bounces needed to reach a pocket.\n        bounces_x = (n - x) // abs(vx) if vx > 0 else x // abs(vx)\n        bounces_y = (m - y) // abs(vy) if vy > 0 else y // abs(vy)\n\n        # If the number of bounces to reach a pocket is the same for both axes,\n        # the ball will fall into a pocket.\n        if bounces_x == bounces_y:\n            final_x = 0 if vx < 0 else n\n            final_y = 0 if vy < 0 else m\n            return f\"{final_x} {final_y}\"\n        else:\n            # If the number of bounces is not the same, the ball will move indefinitely.\n            return -1\n\n    # If the ball is moving at an angle that is not 45 degrees, it will move indefinitely.\n    return -1\n\n# Example usage:\n# n, m, x, y, vx, vy = 4, 3, 2, 2, -1, 1\n# print(billiard_ball_pocket(n, m, x, y, vx, vy))  # Output: 0 0"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    def fits(w1, h1, w2, h2, W, H):\n        return (w1 + w2 <= W and max(h1, h2) <= H) or (h1 + h2 <= H and max(w1, w2) <= W)\n    \n    if (fits(a2, b2, a3, b3, a1, b1) or fits(b2, a2, a3, b3, a1, b1) or\n        fits(a2, b2, b3, a3, a1, b1) or fits(b2, a2, b3, a3, a1, b1) or\n        fits(a3, b3, a2, b2, a1, b1) or fits(b3, a3, a2, b2, a1, b1) or\n        fits(a3, b3, b2, a2, a1, b1) or fits(b3, a3, b2, a2, a1, b1)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input from standard input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\n# Print the result\nprint(can_place_paintings(a1, b1, a2, b2, a3, b3))"}
{"solution": "def geometric_progression_terms(b_1, q, l, m, bad_integers):\n    if abs(b_1) > l:\n        return 0\n    if b_1 == 0:\n        return \"inf\" if 0 not in bad_integers else 0\n    if q == 0:\n        if 0 in bad_integers:\n            return 1 if b_1 not in bad_integers else 0\n        else:\n            return \"inf\"\n    if q == 1:\n        return \"inf\" if b_1 not in bad_integers else 0\n    if q == -1:\n        if b_1 in bad_integers and -b_1 in bad_integers:\n            return 0\n        else:\n            return \"inf\"\n\n    written_terms = 0\n    current_term = b_1\n    while abs(current_term) <= l:\n        if current_term not in bad_integers:\n            written_terms += 1\n        current_term *= q\n\n    return written_terms\n\n# Read input\nb_1, q, l, m = map(int, input().split())\nbad_integers = set(map(int, input().split()))\n\n# Calculate and print the result\nresult = geometric_progression_terms(b_1, q, l, m, bad_integers)\nprint(result if result != \"inf\" else \"inf\")"}
{"solution": "def find_smallest_frame(n, m, screen):\n    white_pixels = []\n    for i in range(n):\n        for j in range(m):\n            if screen[i][j] == 'w':\n                white_pixels.append((i, j))\n    \n    if not white_pixels:\n        return -1\n    \n    min_x = min(white_pixels, key=lambda x: x[0])[0]\n    max_x = max(white_pixels, key=lambda x: x[0])[0]\n    min_y = min(white_pixels, key=lambda x: x[1])[1]\n    max_y = max(white_pixels, key=lambda x: x[1])[1]\n    \n    frame_size = max(max_x - min_x + 1, max_y - min_y + 1)\n    \n    if frame_size > n or frame_size > m:\n        return -1\n    \n    for i in range(min_x, max_x + 1):\n        for j in range(min_y, max_y + 1):\n            if i == min_x or i == max_x or j == min_y or j == max_y:\n                if screen[i][j] != 'w':\n                    screen[i][j] = '+'\n            elif screen[i][j] == 'w':\n                return -1\n    \n    return screen\n\ndef print_screen(screen):\n    if screen == -1:\n        print(-1)\n    else:\n        for row in screen:\n            print(''.join(row))\n\n# Read input\nn, m = map(int, input().split())\nscreen = [list(input().strip()) for _ in range(n)]\n\n# Find and print the smallest frame\nresult = find_smallest_frame(n, m, screen)\nprint_screen(result)"}
{"solution": "def can_spend_exactly(n, a, b):\n    for x in range(n // a + 1):\n        if (n - x * a) % b == 0:\n            y = (n - x * a) // b\n            return \"YES\", x, y\n    return \"NO\", 0, 0\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\n\n# Process and output the result\nresult, x, y = can_spend_exactly(n, a, b)\nprint(result)\nif result == \"YES\":\n    print(x, y)"}
{"solution": "def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\n# Assuming the input is provided through a function call or another mechanism\n# s = int(input())\n# print(number_to_words(s))"}
{"solution": "def max_elements_to_erase(n, arr):\n    # The maximum number of consecutive elements that can be erased is determined by\n    # the minimum gap between consecutive elements in the array.\n    max_erase = 0\n    for i in range(1, n):\n        # Calculate the gap between the current element and the previous one.\n        gap = arr[i] - arr[i - 1] - 1\n        # Update the maximum number of elements that can be erased if the current gap is larger.\n        max_erase = max(max_erase, gap)\n    return max_erase\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output the result\nprint(max_elements_to_erase(n, arr))"}
{"solution": "def find_equator_day(n, a):\n    total_problems = sum(a)\n    half_problems = (total_problems + 1) // 2\n    \n    cumulative_problems = 0\n    for i in range(n):\n        cumulative_problems += a[i]\n        if cumulative_problems >= half_problems:\n            return i + 1\n\n# Example usage (commented out as per request):\n# n = 4\n# a = [1, 3, 2, 1]\n# print(find_equator_day(n, a))  # Output: 2\n\n# n = 6\n# a = [2, 2, 2, 2, 2, 2]\n# print(find_equator_day(n, a))  # Output: 3"}
{"solution": "from collections import deque\n\ndef get_moves(piece, x, y, N):\n    if piece == 'knight':\n        moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    elif piece == 'bishop':\n        moves = [(i, i) for i in range(-N+1, N) if i != 0] + [(i, -i) for i in range(-N+1, N) if i != 0]\n    elif piece == 'rook':\n        moves = [(i, 0) for i in range(-N+1, N) if i != 0] + [(0, i) for i in range(-N+1, N) if i != 0]\n    else:\n        return []\n    \n    valid_moves = [(x+dx, y+dy) for dx, dy in moves if 0 < x+dx <= N and 0 < y+dy <= N]\n    return valid_moves\n\ndef bfs(start, end, N, board):\n    queue = deque([(start, 'knight', 0, 0)])  # (position, piece, steps, replacements)\n    visited = set()\n    \n    while queue:\n        (x, y), piece, steps, replacements = queue.popleft()\n        \n        if (x, y) == end:\n            return steps, replacements\n        \n        if (x, y, piece) in visited:\n            continue\n        visited.add((x, y, piece))\n        \n        # Move with the current piece\n        for (nx, ny) in get_moves(piece, x, y, N):\n            if (nx, ny, piece) not in visited:\n                queue.append(((nx, ny), piece, steps + 1, replacements))\n        \n        # Replace the piece\n        for new_piece in ['knight', 'bishop', 'rook']:\n            if new_piece != piece and (x, y, new_piece) not in visited:\n                queue.append(((x, y), new_piece, steps + 1, replacements + 1))\n    \n    return float('inf'), float('inf')\n\ndef solve(N, board):\n    positions = {board[i][j]: (i+1, j+1) for i in range(N) for j in range(N)}\n    total_steps, total_replacements = 0, 0\n    \n    for i in range(1, N*N):\n        start = positions[i]\n        end = positions[i+1]\n        steps, replacements = bfs(start, end, N, board)\n        total_steps += steps\n        total_replacements += replacements\n    \n    return total_steps, total_replacements\n\n# Input\nN = int(input())\nboard = [list(map(int, input().split())) for _ in range(N)]\n\n# Solve the problem\nsteps, replacements = solve(N, board)\nprint(steps, replacements)"}
{"solution": "def calculate_time(n, m, k, a, b):\n    # Calculate the position of Edward and Natasha in terms of entrance, floor, and apartment within the floor\n    edward_entrance = (a - 1) // (m * k)\n    edward_floor = ((a - 1) % (m * k)) // k\n    natasha_entrance = (b - 1) // (m * k)\n    natasha_floor = ((b - 1) % (m * k)) // k\n\n    # Calculate the time to move between entrances\n    entrance_distance = min((edward_entrance - natasha_entrance) % n, (natasha_entrance - edward_entrance) % n)\n    entrance_time = entrance_distance * 15\n\n    # Calculate the time to move between floors using stairs or elevator\n    if edward_entrance == natasha_entrance:\n        # If they are in the same entrance, calculate the time to move between floors\n        floor_difference = abs(edward_floor - natasha_floor)\n        stairs_time = floor_difference * 5\n        elevator_time = 10 + floor_difference  # 10 seconds waiting + 1 second per floor\n        floor_time = min(stairs_time, elevator_time)\n    else:\n        # If they are in different entrances, calculate the time to move to the first floor\n        # Edward needs to go to the first floor of his entrance\n        edward_to_first_floor_time = edward_floor * 5 if edward_floor else 0\n        # Natasha needs to go to the first floor of her entrance\n        natasha_to_first_floor_time = natasha_floor * 5 if natasha_floor else 0\n        floor_time = edward_to_first_floor_time + natasha_to_first_floor_time\n\n    # Total time is the sum of time to move between entrances and floors\n    total_time = entrance_time + floor_time\n    return total_time\n\n# Read input\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_time(n, m, k, a, b))"}
{"solution": "def can_form_divisible_by_64(s):\n    # A number is divisible by 64 if its binary representation ends with at least 6 zeros\n    # because 64 in binary is 1000000, which has 6 trailing zeros.\n    return \"yes\" if \"0\" * 6 in s else \"no\"\n\n# Read input\ns = input().strip()\n\n# Output result\nprint(can_form_divisible_by_64(s))"}
{"solution": "def transform_to_alphabet_subsequence(s):\n    # Initialize the target alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    # Initialize a pointer for the alphabet\n    alpha_ptr = 0\n    # Initialize a list to store the transformed string\n    transformed = []\n    \n    for char in s:\n        # If we haven't reached the end of the alphabet and the current character\n        # can be transformed into the current target alphabet character\n        if alpha_ptr < len(alphabet) and char <= alphabet[alpha_ptr]:\n            # Append the target alphabet character to the transformed list\n            transformed.append(alphabet[alpha_ptr])\n            # Move the pointer to the next character in the alphabet\n            alpha_ptr += 1\n        else:\n            # If the current character cannot help form the alphabet subsequence,\n            # keep it as it is\n            transformed.append(char)\n    \n    # If we have successfully transformed the string to contain the alphabet as a subsequence\n    if alpha_ptr == len(alphabet):\n        return ''.join(transformed)\n    else:\n        return '-1'\n\n# Read input\ns = input().strip()\n# Print output\nprint(transform_to_alphabet_subsequence(s))"}
{"solution": "from heapq import heappush, heappop\n\ndef calculate_expected_value(n, m, r, k):\n    def count_covered_cells(x, y):\n        return (min(n - r + 1, x + r) - max(1, x)) * (min(m - r + 1, y + r) - max(1, y))\n\n    def add_to_heap(x, y):\n        if 1 <= x <= n and 1 <= y <= m and not visited[x][y]:\n            visited[x][y] = True\n            heappush(max_heap, (-count_covered_cells(x, y), x, y))\n\n    visited = [[False] * (m + 1) for _ in range(n + 1)]\n    max_heap = []\n    total_covered = 0\n    positions = (n - r + 1) * (m - r + 1)\n\n    # Start from the center of the pond\n    start_x = (n + 1) // 2\n    start_y = (m + 1) // 2\n    add_to_heap(start_x, start_y)\n\n    for _ in range(k):\n        _, x, y = heappop(max_heap)\n        total_covered += count_covered_cells(x, y)\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            add_to_heap(x + dx, y + dy)\n\n    return total_covered / positions\n\n# Read input\nn, m, r, k = map(int, input().split())\n\n# Calculate and print the maximum possible expected number of caught fishes\nprint(f\"{calculate_expected_value(n, m, r, k):.10f}\")"}
{"solution": "def maximize_product(n, a):\n    # If there's only one element and it's non-negative, we can't improve the product.\n    if n == 1 and a[0] >= 0:\n        return a\n    \n    # Count the number of negative elements and check for zeros.\n    negative_count = sum(1 for x in a if x < 0)\n    zero_count = a.count(0)\n    \n    # If there are zeros, we can make all non-zero elements negative to maximize the product.\n    if zero_count > 0:\n        return [-x - 1 if x != 0 else 0 for x in a]\n    \n    # If the count of negative elements is even, we can make all elements negative.\n    if negative_count % 2 == 0:\n        return [-x - 1 for x in a]\n    \n    # If the count of negative elements is odd, we should keep one positive element\n    # to maximize the product, and make the rest negative.\n    max_neg_index = a.index(max(a))\n    result = [-x - 1 for x in a]\n    result[max_neg_index] = a[max_neg_index]\n    return result\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the array with the maximal possible product\nresult = maximize_product(n, a)\n\n# Print the result\nprint(' '.join(map(str, result)))"}
{"solution": "import math\n\ndef kth_smallest_divisor(n, k):\n    # Find all divisors up to the square root of n\n    divisors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    \n    # Sort the divisors to find the k-th smallest\n    divisors.sort()\n    \n    # Check if k is within the range of found divisors\n    if k <= len(divisors):\n        return divisors[k - 1]\n    else:\n        return -1\n\n# Read input\nn, k = map(int, input().split())\n\n# Output the result\nprint(kth_smallest_divisor(n, k))"}
{"solution": "def can_form_number(cubes, number):\n    number_str = str(number)\n    for digit in number_str:\n        if not any(digit in cube for cube in cubes):\n            return False\n    return True\n\ndef max_number_to_x(n, cube_faces):\n    cubes = [set(cube) for cube in cube_faces]\n    x = 0\n    while can_form_number(cubes, x + 1):\n        x += 1\n    return x\n\n# Read input\nn = int(input())\ncube_faces = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(max_number_to_x(n, cube_faces))"}
{"solution": "def k_rounding(n, k):\n    # Calculate the number of trailing zeros by finding the least power of 10 that is divisible by n\n    x = 10 ** k\n    # Find the least common multiple (LCM) of n and 10^k\n    # Since 10^k is always divisible by 2 and 5, we can simplify the LCM calculation\n    # by finding the maximum power of 2 and 5 in n's factorization and multiplying by 10^k\n    for factor in (2, 5):\n        power = 0\n        while n % factor == 0:\n            n //= factor\n            power += 1\n        if power < k:\n            x *= factor ** (k - power)\n    return x\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the k-rounding of n\nprint(k_rounding(n, k))"}
{"solution": "def transform_matrix(n, m, A):\n    operations = []\n    B = [[0] * m for _ in range(n)]\n    \n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                operations.append((i + 1, j + 1))\n                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1\n    \n    for i in range(n):\n        for j in range(m):\n            if A[i][j] != B[i][j]:\n                return -1\n    \n    return operations\n\n# Input reading\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\n# Process the transformation\nresult = transform_matrix(n, m, A)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for x, y in result:\n        print(x, y)"}
{"solution": "def bad_luck_island(r, s, p):\n    # Initialize the DP table\n    dp = [[[0.0 for _ in range(p+1)] for _ in range(s+1)] for _ in range(r+1)]\n    dp[r][s][p] = 1.0  # The probability of the current state is 1.0\n\n    # Calculate the probabilities using dynamic programming\n    for i in range(r, -1, -1):\n        for j in range(s, -1, -1):\n            for k in range(p, -1, -1):\n                total = i * j + j * k + k * i\n                if total == 0:  # If there are no possible meetings, skip\n                    continue\n                if i > 0:\n                    dp[i-1][j][k] += dp[i][j][k] * (i * k) / total  # Rock kills paper\n                if j > 0:\n                    dp[i][j-1][k] += dp[i][j][k] * (i * j) / total  # Scissors kill rock\n                if k > 0:\n                    dp[i][j][k-1] += dp[i][j][k] * (j * k) / total  # Paper kills scissors\n\n    # Calculate the final probabilities\n    prob_r, prob_s, prob_p = 0.0, 0.0, 0.0\n    for i in range(1, r+1):\n        prob_r += dp[i][0][0]\n    for j in range(1, s+1):\n        prob_s += dp[0][j][0]\n    for k in range(1, p+1):\n        prob_p += dp[0][0][k]\n\n    return prob_r, prob_s, prob_p\n\n# Read input\nr, s, p = map(int, input().split())\n\n# Calculate probabilities\nprob_r, prob_s, prob_p = bad_luck_island(r, s, p)\n\n# Print the result\nprint(f\"{prob_r:.12f} {prob_s:.12f} {prob_p:.12f}\")"}
{"solution": "def calculate_meeting_time(l_1, r_1, l_2, r_2, k):\n    # Calculate the overlap between Sonya's and Filya's time intervals\n    overlap_start = max(l_1, l_2)\n    overlap_end = min(r_1, r_2)\n    \n    # If there is no overlap, they cannot meet\n    if overlap_start > overlap_end:\n        return 0\n    \n    # Calculate the total overlap time\n    overlap_time = overlap_end - overlap_start + 1\n    \n    # Subtract the minute Sonya prinks if it falls within the overlap\n    if overlap_start <= k <= overlap_end:\n        overlap_time -= 1\n    \n    return overlap_time\n\n# Read input from standard input\nl_1, r_1, l_2, r_2, k = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_meeting_time(l_1, r_1, l_2, r_2, k))"}
{"solution": "def calculate_reachable_area(N, M, north_south_lines, east_west_lines):\n    # Initialize the boundary points for the reachable area\n    min_x, max_x, min_y, max_y = float('-inf'), float('inf'), float('-inf'), float('inf')\n\n    # Process north-south lines to update the boundaries\n    for A_i, B_i, C_i in north_south_lines:\n        if C_i == 0:\n            if A_i <= 0 <= B_i:\n                return \"INF\"\n            elif B_i < 0:\n                max_x = min(max_x, B_i)\n            elif A_i > 0:\n                min_x = max(min_x, A_i)\n        else:\n            if A_i <= 0 <= B_i:\n                min_y = max(min_y, C_i)\n            elif B_i < 0:\n                max_x = min(max_x, B_i)\n                min_y = max(min_y, C_i)\n            elif A_i > 0:\n                min_x = max(min_x, A_i)\n                min_y = max(min_y, C_i)\n\n    # Process east-west lines to update the boundaries\n    for D_j, E_j, F_j in east_west_lines:\n        if D_j == 0:\n            if E_j <= 0 <= F_j:\n                return \"INF\"\n            elif F_j < 0:\n                max_y = min(max_y, F_j)\n            elif E_j > 0:\n                min_y = max(min_y, E_j)\n        else:\n            if E_j <= 0 <= F_j:\n                min_x = max(min_x, D_j)\n            elif F_j < 0:\n                max_y = min(max_y, F_j)\n                min_x = max(min_x, D_j)\n            elif E_j > 0:\n                min_y = max(min_y, E_j)\n                min_x = max(min_x, D_j)\n\n    # Calculate the area if it's finite\n    if min_x == float('-inf') or max_x == float('inf') or min_y == float('-inf') or max_y == float('inf'):\n        return \"INF\"\n    else:\n        return (max_x - min_x) * (max_y - min_y)\n\n# Read input\nN, M = map(int, input().split())\nnorth_south_lines = [tuple(map(int, input().split())) for _ in range(N)]\neast_west_lines = [tuple(map(int, input().split())) for _ in range(M)]\n\n# Calculate and print the result\nprint(calculate_reachable_area(N, M, north_south_lines, east_west_lines))"}
{"solution": "def will_pineapple_bark(t, s, x):\n    if x < t:\n        return \"NO\"\n    if x == t:\n        return \"YES\"\n    if (x - t) % s == 0 or (x - t - 1) % s == 0:\n        return \"YES\"\n    return \"NO\"\n\n# Read input\nt, s, x = map(int, input().split())\n\n# Output result\nprint(will_pineapple_bark(t, s, x))"}
{"solution": "def find_nested_segments(n, segments):\n    # Sort segments by their left endpoint, then by their right endpoint in reverse\n    sorted_segments = sorted(enumerate(segments, 1), key=lambda x: (x[1][0], -x[1][1]))\n    \n    # Initialize variables to store the best pair found\n    best_pair = (-1, -1)\n    \n    # Initialize the rightmost endpoint seen so far\n    rightmost_end = -1\n    \n    # Iterate through the sorted segments\n    for i, (l, r) in sorted_segments:\n        # If the current segment's right endpoint is within the rightmost endpoint seen so far\n        if r <= rightmost_end:\n            # We found a nested segment\n            best_pair = (i, next(j for j, (lj, rj) in reversed(sorted_segments) if rj == rightmost_end and lj == l))\n            break\n        # Update the rightmost endpoint seen so far\n        rightmost_end = max(rightmost_end, r)\n    \n    return best_pair\n\n# Read input\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Find and print the result\nprint(*find_nested_segments(n, segments))"}
{"solution": "def decode_genome(n, s):\n    # Count the number of each nucleotide and '?'\n    counts = {'A': 0, 'C': 0, 'G': 0, 'T': 0, '?': 0}\n    for nucleotide in s:\n        counts[nucleotide] += 1\n    \n    # Calculate the required number of each nucleotide\n    required_count = (n // 4)\n    \n    # Check if it's possible to distribute the nucleotides equally\n    if n % 4 != 0 or any(counts[nucleotide] > required_count for nucleotide in 'ACGT'):\n        return \"===\"\n    \n    # Replace '?' with the missing nucleotides\n    result = list(s)\n    for i in range(n):\n        if result[i] == '?':\n            for nucleotide in 'ACGT':\n                if counts[nucleotide] < required_count:\n                    result[i] = nucleotide\n                    counts[nucleotide] += 1\n                    break\n    \n    return ''.join(result)\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Output the decoded genome\nprint(decode_genome(n, s))"}
{"solution": "def can_ilya_win(board):\n    # Check horizontal and vertical lines\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                # Try placing 'x' and check if it wins\n                board[i][j] = 'x'\n                if check_win(board, i, j):\n                    return \"YES\"\n                board[i][j] = '.'\n    return \"NO\"\n\ndef check_win(board, row, col):\n    # Check horizontal\n    if board[row].count('x') == 3:\n        return True\n    # Check vertical\n    if [board[i][col] for i in range(4)].count('x') == 3:\n        return True\n    # Check diagonal (if applicable)\n    if row == col or row + col == 3:\n        diag1 = [board[i][i] for i in range(4)]\n        diag2 = [board[i][3-i] for i in range(4)]\n        if diag1.count('x') == 3 or diag2.count('x') == 3:\n            return True\n    return False\n\n# Read input\nboard = [list(input().strip()) for _ in range(4)]\n\n# Output result\nprint(can_ilya_win(board))"}
{"solution": "def can_balance_array(n, a):\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return \"NO\"\n    \n    half_sum = total_sum // 2\n    current_sum = 0\n    for i in range(n):\n        current_sum += a[i]\n        if current_sum == half_sum:\n            return \"YES\"\n        if current_sum > half_sum:\n            break\n    \n    current_sum = 0\n    for i in range(n-1, -1, -1):\n        current_sum += a[i]\n        if current_sum == half_sum:\n            return \"YES\"\n        if current_sum > half_sum:\n            break\n    \n    return \"NO\"\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(can_balance_array(n, a))"}
{"solution": "def can_make_non_increasing(n, k, a, b):\n    # Sort the elements that will replace the zeros in descending order\n    b.sort(reverse=True)\n    \n    # Replace zeros in a with elements from b\n    b_index = 0\n    for i in range(n):\n        if a[i] == 0:\n            a[i] = b[b_index]\n            b_index += 1\n    \n    # Check if the resulting sequence is not increasing\n    for i in range(1, n):\n        if a[i] >= a[i - 1]:\n            return \"Yes\"\n    \n    return \"No\"\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Output result\nprint(can_make_non_increasing(n, k, a, b))"}
{"solution": "def can_distribute_grapes(x, y, z, a, b, c):\n    # First, try to satisfy Andrew's requirement with green grapes\n    if a < x:\n        return \"NO\"\n    a -= x\n\n    # Next, try to satisfy Dmitry's requirement with remaining green grapes and purple grapes\n    if a + b < y:\n        return \"NO\"\n    total_for_dmitry = a + b\n    total_for_dmitry -= y\n\n    # Finally, try to satisfy Michal's requirement with the remaining grapes\n    if total_for_dmitry + c < z:\n        return \"NO\"\n\n    return \"YES\"\n\n# Read input\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Output the result\nprint(can_distribute_grapes(x, y, z, a, b, c))"}
{"solution": "def is_accident_possible(lights):\n    for i in range(4):\n        if lights[i][3] == 1 and (lights[i][0] == 1 or lights[i][1] == 1 or lights[i][2] == 1):\n            return \"YES\"\n        if i < 3 and lights[i][2] == 1 and lights[i + 1][0] == 1:\n            return \"YES\"\n        if i == 2 and lights[i][2] == 1 and lights[0][0] == 1:\n            return \"YES\"\n        if i > 0 and lights[i][0] == 1 and lights[i - 1][2] == 1:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nlights = []\nfor _ in range(4):\n    lights.append(list(map(int, input().split())))\n\n# Output result\nprint(is_accident_possible(lights))"}
{"solution": "def get_coordinates(digit):\n    keypad = {\n        '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2),\n        '0': (3, 1)\n    }\n    return keypad[digit]\n\ndef get_vectors(number):\n    vectors = []\n    for i in range(len(number) - 1):\n        x1, y1 = get_coordinates(number[i])\n        x2, y2 = get_coordinates(number[i + 1])\n        vectors.append((x2 - x1, y2 - y1))\n    return vectors\n\ndef is_unique_finger_movement(n, number):\n    original_vectors = get_vectors(number)\n    for i in range(10**(n-1), 10**n):\n        candidate = str(i).zfill(n)\n        if candidate != number:\n            if get_vectors(candidate) == original_vectors:\n                return \"NO\"\n    return \"YES\"\n\n# Input reading\nn = int(input())\nnumber = input().strip()\n\n# Output the result\nprint(is_unique_finger_movement(n, number))"}
{"solution": "def maximize_sales(n, f, days):\n    # Calculate the potential additional sales from doubling the products on each day\n    additional_sales = [(min(2 * k, l) - min(k, l), i) for i, (k, l) in enumerate(days)]\n    # Sort by the potential additional sales in descending order\n    additional_sales.sort(reverse=True)\n    \n    # Select the top f days for sell-outs\n    sell_out_days = set(day_index for _, day_index in additional_sales[:f])\n    \n    total_sales = 0\n    for i, (k, l) in enumerate(days):\n        # If the day is chosen for sell-out, double the products\n        if i in sell_out_days:\n            k *= 2\n        # Add the number of sold products to the total\n        total_sales += min(k, l)\n    \n    return total_sales\n\n# Read input\nn, f = map(int, input().split())\ndays = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(maximize_sales(n, f, days))"}
{"solution": "def max_messiness(n, k):\n    # The maximum messiness for any permutation of n cows is the number of inversions in the sorted order,\n    # which is n * (n - 1) // 2.\n    max_inversions = n * (n - 1) // 2\n    \n    # If we can perform more swaps than the number of cows minus one, we can achieve the maximum messiness.\n    if k >= n - 1:\n        return max_inversions\n    \n    # If we can perform fewer swaps than the number of cows minus one, we can only achieve a partial messiness.\n    # The maximum messiness we can achieve with k swaps is the sum of the k largest elements in the sequence\n    # of the first n natural numbers, which corresponds to the number of inversions we can create with k swaps.\n    # This is equivalent to the sum of the first n - k - 1 natural numbers subtracted from the total max_inversions.\n    return max_inversions - (n - k) * (n - k - 1) // 2\n\n# Read input\nn, k = map(int, input().split())\n\n# Output the result\nprint(max_messiness(n, k))"}
{"solution": "def min_coins_to_gift(N, M, K, L):\n    # Check if it's possible to satisfy all conditions\n    if L > N - K:  # Not enough different coins to satisfy the new coins condition\n        return -1\n    if M * (N - K) < L:  # Not enough friends to gift the required number of new coins\n        return -1\n    \n    # Calculate the minimum number of coins each friend needs to gift\n    coins_per_friend = (L + M - 1) // M  # This is equivalent to ceil(L / M)\n    \n    return coins_per_friend\n\n# Read input\nN, M, K, L = map(int, input().split())\n\n# Output the result\nprint(min_coins_to_gift(N, M, K, L))"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    # Find the bounds of the black cells\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # If no black cells are found\n    if min_row == n:\n        return 1\n    \n    # Calculate the side length of the square\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    \n    # Check if the square can fit within the grid\n    if side_length > n or side_length > m:\n        return -1\n    \n    # Count the number of white cells within the square\n    min_paint = float('inf')\n    for i in range(n - side_length + 1):\n        for j in range(m - side_length + 1):\n            paint_count = 0\n            for x in range(i, i + side_length):\n                for y in range(j, j + side_length):\n                    if grid[x][y] == 'W':\n                        paint_count += 1\n            min_paint = min(min_paint, paint_count)\n    \n    return min_paint"}
{"solution": "def can_be_correct(n, x, y):\n    # Calculate the total number of stones in both sequences\n    total_stones_x = sum(x)\n    total_stones_y = sum(y)\n    \n    # If the total number of stones is not the same, the sequences cannot be consistent\n    if total_stones_x != total_stones_y:\n        return \"No\"\n    \n    # Check if the difference in the number of stones in each pile can be accounted for by moving stones\n    for i in range(n):\n        if x[i] > y[i]:\n            for j in range(n):\n                if i != j and x[j] < y[j] and x[i] - y[i] == y[j] - x[j]:\n                    x[i] -= 1\n                    x[j] += 1\n                    break\n    \n    # If after attempting to move stones, the sequences match, return \"Yes\"\n    if x == y:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input\nn = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Print output\nprint(can_be_correct(n, x, y))"}
{"solution": "def minimal_angle_difference(n, angles):\n    total_angle = 360\n    min_diff = total_angle\n    current_sum = 0\n    \n    # Two pointers approach to find the minimal difference\n    left = 0\n    right = 0\n    \n    while right < n:\n        if current_sum < total_angle / 2:\n            current_sum += angles[right]\n            right += 1\n        else:\n            current_sum -= angles[left]\n            left += 1\n        \n        # Calculate the difference\n        diff = abs(total_angle - 2 * current_sum)\n        min_diff = min(min_diff, diff)\n    \n    # Check the remaining subarrays\n    while left < n:\n        current_sum -= angles[left]\n        left += 1\n        diff = abs(total_angle - 2 * current_sum)\n        min_diff = min(min_diff, diff)\n    \n    return min_diff\n\n# Reading input\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Output the result\nprint(minimal_angle_difference(n, angles))"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_pow(base, exponent, modulus):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % modulus\n        base = (base * base) % modulus\n        exponent //= 2\n    return result\n\ndef count_packing_ways(n, m):\n    # The problem can be reduced to finding the number of ways to distribute\n    # n distinct kinds of presents into m distinct boxes with the condition\n    # that each kind of present must appear in at least one box.\n    # This is equivalent to calculating the number of surjections from a set\n    # of size n to a set of size m, which is given by the formula:\n    # sum((-1)^k * C(m, k) * (m - k)^n for k in range(m + 1))\n    # However, since we need to consider the distinctness of the boxes, we\n    # multiply this by m! (m factorial).\n    # Since the answer can be huge, we compute it modulo 10^9 + 7.\n    \n    # First, compute m! modulo MOD\n    factorial_m = 1\n    for i in range(1, m + 1):\n        factorial_m = (factorial_m * i) % MOD\n    \n    # Now, compute the sum for the surjection count\n    surjection_count = 0\n    for k in range(m + 1):\n        term = mod_pow(m - k, n, MOD)\n        if k % 2 == 1:\n            term = -term\n        term = (term + MOD) % MOD  # Ensure the term is non-negative\n        term = (term * mod_pow(factorial_m, MOD - 2, MOD)) % MOD  # Multiply by inverse of (m choose k)\n        surjection_count = (surjection_count + term) % MOD\n    \n    # Multiply by m! to account for the distinctness of the boxes\n    result = (surjection_count * factorial_m) % MOD\n    \n    return result\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(count_packing_ways(n, m))"}
{"solution": "import math\n\ndef find_pythagorean_triple(n):\n    if n == 1 or n == 2:\n        return -1  # No Pythagorean triple exists for n = 1 or n = 2\n    \n    # If n is odd\n    if n % 2 == 1:\n        m = (n**2 - 1) // 2\n        k = m + 1\n        return m, k\n    \n    # If n is even\n    if n % 2 == 0:\n        m = (n**2 // 4) - 1\n        k = m + 2\n        return m, k\n\n# Read input\nn = int(input())\n\n# Find and print the Pythagorean triple\nresult = find_pythagorean_triple(n)\nif result == -1:\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "def distinct_remainders(n, k):\n    # If k is greater than n, there will be at least one pair of remainders that are the same\n    # because the maximum remainder is n-1.\n    if k > n:\n        return \"No\"\n    # If k is greater than 1, then for any n, the remainder when n is divided by 1 is 0,\n    # and if k is also greater than n, there will be another number i (2 <= i <= k) such that\n    # n % i == n % 1 == 0, making the remainders not distinct.\n    elif k > 1 and n % 2 == 0:\n        return \"No\"\n    # For k <= n and n odd, or k == 1, the remainders will always be distinct.\n    else:\n        return \"Yes\"\n\n# Read input\nn, k = map(int, input().split())\n\n# Output result\nprint(distinct_remainders(n, k))"}
{"solution": "import sys\n\n# Fast input method\ninput = sys.stdin.readline\n\n# Read input\na = input().strip()\nb = input().strip()\n\n# Remove leading zeroes\na = a.lstrip('0') or '0'\nb = b.lstrip('0') or '0'\n\n# Compare lengths first\nif len(a) > len(b):\n    print('>')\nelif len(a) < len(b):\n    print('<')\nelse:\n    # If lengths are equal, compare lexicographically\n    if a > b:\n        print('>')\n    elif a < b:\n        print('<')\n    else:\n        print('=')"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, p, colors):\n    # Initialize the DP table\n    dp = [[[0 for _ in range(2)] for _ in range(2)] for _ in range(n+1)]\n    dp[0][0][0] = 1  # Base case: no pieces, no paths, even score\n\n    for i in range(1, n+1):\n        for has_arrow in range(2):\n            for score_parity in range(2):\n                # If the piece is already colored\n                if colors[i-1] != -1:\n                    dp[i][has_arrow][score_parity] += dp[i-1][has_arrow][score_parity]\n                    dp[i][has_arrow][score_parity] %= MOD\n                    if has_arrow:\n                        dp[i][has_arrow][score_parity] += dp[i-1][0][score_parity ^ colors[i-1]]\n                        dp[i][has_arrow][score_parity] %= MOD\n                else:\n                    # If the piece is uncolored, we can color it either black or white\n                    for color in range(2):\n                        dp[i][has_arrow][score_parity] += dp[i-1][has_arrow][score_parity]\n                        dp[i][has_arrow][score_parity] %= MOD\n                        if has_arrow:\n                            dp[i][has_arrow][score_parity] += dp[i-1][0][score_parity ^ color]\n                            dp[i][has_arrow][score_parity] %= MOD\n\n    return dp[n][1][p]\n\n# Read input\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_ways(n, p, colors))"}
{"solution": "def min_rubles_to_pay(n, a, b, c):\n    # Calculate the remainder when n is divided by 4\n    remainder = n % 4\n    \n    # If n is already divisible by 4, no additional copybooks are needed\n    if remainder == 0:\n        return 0\n    \n    # Calculate the number of additional copybooks needed to make n + k divisible by 4\n    additional_needed = 4 - remainder\n    \n    # Initialize the minimum cost to a large number\n    min_cost = float('inf')\n    \n    # Check each possible combination of packs to find the minimum cost\n    for i in range(additional_needed + 1):\n        for j in range(additional_needed + 1 - i):\n            k = additional_needed - i - j\n            if i + 2*j + 3*k == additional_needed:\n                cost = i * a + j * b + k * c\n                min_cost = min(min_cost, cost)\n    \n    return min_cost\n\n# Read input\nn, a, b, c = map(int, input().split())\n\n# Print the result\nprint(min_rubles_to_pay(n, a, b, c))"}
{"solution": "def is_acyclic_after_one_removal(n, m, edges):\n    # Create adjacency list and in-degree array\n    adj_list = {i: [] for i in range(1, n + 1)}\n    in_degree = {i: 0 for i in range(1, n + 1)}\n    \n    for u, v in edges:\n        adj_list[u].append(v)\n        in_degree[v] += 1\n    \n    # Function to perform topological sort\n    def topological_sort():\n        # Count of vertices with in-degree 0\n        zero_in_degree_count = 0\n        for v in in_degree.values():\n            if v == 0:\n                zero_in_degree_count += 1\n        \n        # If there's not exactly one vertex with in-degree 0, it's not a DAG\n        if zero_in_degree_count != 1:\n            return False\n        \n        # Perform BFS for topological sort\n        queue = [v for v, degree in in_degree.items() if degree == 0]\n        visited = set(queue)\n        \n        while queue:\n            node = queue.pop(0)\n            for neighbor in adj_list[node]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n                    visited.add(neighbor)\n        \n        # If all nodes are visited, it's a DAG\n        return len(visited) == n\n    \n    # Check if the graph is already acyclic\n    if topological_sort():\n        return \"YES\"\n    \n    # Try removing each edge and check if the graph becomes acyclic\n    for u, v in edges:\n        in_degree[v] -= 1\n        if topological_sort():\n            return \"YES\"\n        in_degree[v] += 1  # Restore the edge\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output result\nprint(is_acyclic_after_one_removal(n, m, edges))"}
{"solution": "def min_coins_to_modernize_street(n, m, antennas):\n    # Sort antennas by their position\n    antennas.sort()\n    \n    # Initialize the dynamic programming table\n    # dp[i] will represent the minimum cost to cover all positions up to i\n    dp = [float('inf')] * (m + 1)\n    dp[0] = 0  # Base case: no cost to cover 0 positions\n    \n    for x, s in antennas:\n        # Calculate the leftmost and rightmost positions this antenna can cover\n        left = max(1, x - s)\n        right = min(m, x + s)\n        \n        # Update the dp table for each position this antenna can cover\n        for i in range(left, right + 1):\n            # Calculate the cost to extend the scope to cover position i\n            cost = max(0, left - 1)\n            dp[i] = min(dp[i], dp[left - 1] + cost)\n    \n    # The answer is the minimum cost to cover all positions up to m\n    return dp[m]\n\n# Read input\nn, m = map(int, input().split())\nantennas = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(min_coins_to_modernize_street(n, m, antennas))"}
{"solution": "def max_good_subset_weight(W, cnt):\n    # Initialize the maximum weight to 0\n    max_weight = 0\n    \n    # Iterate through each weight from 1 to 8\n    for weight in range(1, 9):\n        # While we can add this weight to the subset and stay within the limit W\n        while cnt[weight - 1] > 0 and max_weight + weight <= W:\n            # Add the weight to the subset\n            max_weight += weight\n            # Decrease the count of items with this weight\n            cnt[weight - 1] -= 1\n    \n    return max_weight\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_good_subset_weight(W, cnt))"}
{"solution": "def min_cost_to_buy_lemonade(n, L, costs):\n    # Create a list to store the cost per liter for each bottle type\n    cost_per_liter = [0] * n\n    for i in range(n):\n        cost_per_liter[i] = costs[i] / (2**i - 1)\n    \n    # Sort the costs per liter and keep track of the original indices\n    sorted_cost_per_liter = sorted([(cost_per_liter[i], i) for i in range(n)])\n    \n    # Initialize the total cost\n    total_cost = 0\n    \n    # Start buying from the cheapest cost per liter\n    while L > 0:\n        cheapest_cost, index = sorted_cost_per_liter[0]\n        # Calculate the number of bottles needed\n        bottles_needed = L // (2**index - 1)\n        # If the remainder is not zero, buy one more bottle\n        if L % (2**index - 1) != 0:\n            bottles_needed += 1\n        # Update the total cost and the remaining liters needed\n        total_cost += bottles_needed * costs[index]\n        L -= bottles_needed * (2**index - 1)\n        # Remove the current cheapest option from the list\n        sorted_cost_per_liter.pop(0)\n    \n    return total_cost\n\n# Read input\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_cost_to_buy_lemonade(n, L, costs))"}
{"solution": "def max_mex(n, a):\n    a.sort()\n    mex = 1\n    for num in a:\n        if num >= mex:\n            mex += 1\n    return mex\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = max_mex(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(int(digit) for digit in digits)\n    \n    for segment_sum in range(1, total_sum + 1):\n        if total_sum % segment_sum == 0:\n            current_sum = 0\n            valid_partition = True\n            for digit in digits:\n                current_sum += int(digit)\n                if current_sum > segment_sum:\n                    valid_partition = False\n                    break\n                elif current_sum == segment_sum:\n                    current_sum = 0\n            if valid_partition and current_sum == 0:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn = int(input())\ndigits = input().strip()\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\"\n\n# Example usage:\nusername = input().strip()\nprint(determine_gender(username))"}
{"solution": "def max_absolute_difference(n, k, tabs):\n    max_diff = 0\n    for b in range(1, n + 1):\n        remaining_test = 0\n        remaining_social = 0\n        closed_tabs = set()\n        \n        # Calculate the tabs that would be closed\n        for i in range(n):\n            c = b + i * k\n            if 1 <= c <= n:\n                closed_tabs.add(c)\n        \n        # Calculate the remaining tabs after closing\n        for i in range(1, n + 1):\n            if i not in closed_tabs:\n                if tabs[i - 1] == 1:\n                    remaining_test += 1\n                else:\n                    remaining_social += 1\n        \n        # Calculate the absolute difference\n        diff = abs(remaining_test - remaining_social)\n        max_diff = max(max_diff, diff)\n    \n    return max_diff\n\n# Read input\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Output the result\nprint(max_absolute_difference(n, k, tabs))"}
{"solution": "def min_total_cost(n, c_0, c_1):\n    # Calculate the minimum possible total cost of the whole alphabet\n    # The optimal encoding for n letters is to use binary representation\n    # of numbers from 0 to n-1, which ensures no prefix property is maintained.\n    \n    # Calculate the number of bits needed to represent n-1 in binary\n    bits_needed = n.bit_length()\n    \n    # Calculate the total number of '0's and '1's used in the encoding\n    total_zeros = 0\n    total_ones = 0\n    \n    # For each bit position, calculate the number of '0's and '1's\n    for bit_position in range(bits_needed):\n        # Count of numbers with '1' at the current bit position\n        count_ones = (n >> bit_position) - ((n >> (bit_position + 1)) << 1)\n        # Count of numbers with '0' at the current bit position\n        count_zeros = n - count_ones\n        \n        # Update the total counts of '0's and '1's\n        total_zeros += count_zeros * (bit_position + 1)\n        total_ones += count_ones * (bit_position + 1)\n    \n    # Calculate the total cost\n    total_cost = total_zeros * c_0 + total_ones * c_1\n    \n    return total_cost\n\n# Read input\nn, c_0, c_1 = map(int, input().split())\n\n# Output the result\nprint(min_total_cost(n, c_0, c_1))"}
{"solution": "def will_meet(n, a, x, b, y):\n    while a != x and b != y:\n        if a == b:\n            return \"YES\"\n        a = a + 1 if a < n else 1\n        b = b - 1 if b > 1 else n\n    return \"YES\" if a == b else \"NO\""}
{"solution": "def max_golden_age_length(x, y, l, r):\n    unlucky_years = set()\n    \n    # Generate all possible unlucky years within the range [l, r]\n    for a in range(64):  # 64 to cover the range of 10^18 for x and y\n        if x**a > r:\n            break\n        for b in range(64):\n            unlucky_year = x**a + y**b\n            if unlucky_year > r:\n                break\n            if unlucky_year >= l:\n                unlucky_years.add(unlucky_year)\n    \n    # Sort the unlucky years to find the intervals\n    sorted_unlucky_years = sorted(unlucky_years)\n    \n    # Find the maximum length of The Golden Age\n    max_length = 0\n    prev_year = l - 1  # Start from just before the start of the interval\n    for year in sorted_unlucky_years:\n        if year > r:\n            break\n        if year > prev_year + 1:\n            max_length = max(max_length, year - prev_year - 1)\n        prev_year = year\n    \n    # Check the interval after the last unlucky year\n    if r > prev_year:\n        max_length = max(max_length, r - prev_year)\n    \n    return max_length\n\n# Read input\nx, y, l, r = map(int, input().split())\n\n# Print the output\nprint(max_golden_age_length(x, y, l, r))"}
{"solution": "def min_tax(n):\n    # If n is a prime number, the maximum divisor (not equal to n) is 1,\n    # but since parts cannot be 1, we need to split it. The best way to split\n    # a prime number is into two parts where one part is 2 and the other is n-2.\n    # This ensures that the tax is minimized.\n    if n == 2:\n        return 1  # The only way to split 2 is into 1+1, but since parts cannot be 1, it stays as 2, tax is 1.\n    elif n % 2 == 0:\n        # If n is even, we can split it into two equal parts, each with a tax of 1.\n        return 2\n    else:\n        # If n is odd and not prime, we need to check if it's a product of a prime and 2 (like 9, 15, etc.).\n        # If it is, we can split it into those two numbers, and the tax will be 1 + the prime.\n        # If it's not, we split it into 3 and n-3, where 3 is the smallest prime number greater than 2.\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return 1 + min_tax(n // i)  # Found a divisor, split n into i and n//i.\n        # If no divisors are found, n is a prime number greater than 2, so we split it into 2 and n-2.\n        return 3\n\n# Read input\nn = int(input())\n\n# Print output\nprint(min_tax(n))"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    n = len(word)\n    result = []\n    i = 0\n    \n    while i < n:\n        result.append(word[i])\n        if word[i] not in vowels:\n            start = i\n            while i < n and word[i] not in vowels:\n                i += 1\n            if i - start >= 3:\n                block = word[start:i]\n                if len(set(block)) > 1:\n                    result.append(' ')\n        i += 1\n    \n    return ''.join(result)"}
{"solution": "def min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d):\n    # Initialize the minimum time with the case when no spells are used\n    min_time = x * n\n    \n    # Check spells of the first type to reduce the preparation time per potion\n    for i in range(m):\n        if b[i] <= s:\n            # Calculate the remaining potions after using a spell of the first type\n            remaining_potions = n\n            current_time_per_potion = a[i]\n            \n            # Check spells of the second type to instantly prepare some potions\n            for j in range(k):\n                if b[i] + d[j] <= s:\n                    # Update the remaining potions and the total time\n                    remaining_potions = max(0, n - c[j])\n                    total_time = current_time_per_potion * remaining_potions\n                    min_time = min(min_time, total_time)\n                else:\n                    # If no more spells can be used, calculate the time for the remaining potions\n                    total_time = current_time_per_potion * remaining_potions\n                    min_time = min(min_time, total_time)\n                    break\n    \n    # Check spells of the second type alone to see if they can instantly prepare all potions\n    for j in range(k):\n        if d[j] <= s and c[j] >= n:\n            min_time = 0\n            break\n    \n    return min_time\n\n# Read input\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\n# Calculate and print the minimum time\nprint(min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d))"}
{"solution": "def max_points(n, k, M, t):\n    t.sort()\n    total_time = 0\n    points = 0\n    for i in range(k):\n        if total_time + t[i] * n <= M:\n            total_time += t[i] * n\n            points += n\n        else:\n            points += (M - total_time) // t[i]\n            break\n    # Check if Polycarp can complete any task fully\n    for i in range(k):\n        if total_time + sum(t[:i+1]) <= M:\n            total_time += sum(t[:i+1])\n            points += 1\n        else:\n            break\n    return points\n\n# Read input\nn, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Output the result\nprint(max_points(n, k, M, t))"}
{"solution": "MOD = 998244353\n\ndef count_perfectly_balanced_striped_bst(n):\n    # Initialize a dynamic programming table to store the number of ways to form trees\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case: an empty tree is trivially perfectly balanced and striped\n\n    # Precompute the factorial and inverse factorial for fast combinatorics\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n    inv_fact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n - 1, 0, -1):\n        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD\n\n    def comb(n, k):\n        if k > n or k < 0:\n            return 0\n        return (fact[n] * inv_fact[k] % MOD) * inv_fact[n - k] % MOD\n\n    # Fill the dp table\n    for i in range(1, n + 1):\n        for j in range(i):\n            left_size = j\n            right_size = i - 1 - j\n            # Check the striped condition: root and left child must have different parity, root and right child must have the same parity\n            if (j % 2) != ((i - 1) % 2):\n                dp[i] += comb(i - 1, j) * dp[left_size] % MOD * dp[right_size] % MOD\n                dp[i] %= MOD\n\n    return dp[n]\n\n# Read input\nn = int(input().strip())\n\n# Compute and print the result\nprint(count_perfectly_balanced_striped_bst(n))"}
{"solution": "def determine_current_position(n, m, k):\n    # Calculate the number of complete cycles Lara has made\n    cycles = k // (2 * m)\n    \n    # Calculate the remaining moves after the complete cycles\n    remaining_moves = k % (2 * m)\n    \n    # Determine the current row based on the remaining moves\n    if remaining_moves < m:\n        current_row = cycles * 2 + 1\n    else:\n        current_row = cycles * 2 + 2\n    \n    # Determine the current column based on the remaining moves\n    if remaining_moves < m:\n        current_column = remaining_moves + 1\n    else:\n        current_column = 2 * m - remaining_moves\n    \n    return current_row, current_column\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Determine and print the current position\ncurrent_row, current_column = determine_current_position(n, m, k)\nprint(current_row, current_column)"}
{"solution": "def find_min_max_pair_for_lcm(X):\n    # The strategy is to find the largest factor of X that is less than or equal to the square root of X.\n    # This factor will be one of the numbers, and the other number will be X divided by this factor.\n    # This ensures that the maximum of the two numbers is minimized while maintaining their LCM as X.\n    \n    # Start with the assumption that the smallest factor (other than 1) is X itself,\n    # which means the pair will be (1, X) if no other factors are found.\n    a = X\n    b = 1\n    \n    # Check for factors up to the square root of X\n    for i in range(2, int(X**0.5) + 1):\n        if X % i == 0:\n            # i is a factor of X, check if it gives a smaller max(a, b)\n            if max(i, X // i) < a:\n                a = X // i\n                b = i\n    \n    return a, b\n\n# Read input\nX = int(input().strip())\n\n# Find and print the pair\na, b = find_min_max_pair_for_lcm(X)\nprint(a, b)"}
{"solution": "def max_fruits_for_compote(a, b, c):\n    # Calculate the maximum number of complete sets for each fruit type\n    max_sets_lemons = a // 1\n    max_sets_apples = b // 2\n    max_sets_pears = c // 4\n    \n    # Find the limiting factor (minimum number of complete sets)\n    max_complete_sets = min(max_sets_lemons, max_sets_apples, max_sets_pears)\n    \n    # Calculate the total number of fruits used in the compote\n    total_fruits = max_complete_sets * (1 + 2 + 4)\n    \n    return total_fruits\n\n# Read input\na = int(input())\nb = int(input())\nc = int(input())\n\n# Print output\nprint(max_fruits_for_compote(a, b, c))"}
{"solution": "def can_divide_teams(n, ratings):\n    ratings.sort()\n    for i in range(n):\n        if ratings[i] >= ratings[i + n]:\n            return \"NO\"\n    return \"YES\""}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef make_coprime_array(n, arr):\n    result = []\n    moves = 0\n    \n    for i in range(n - 1):\n        result.append(arr[i])\n        if gcd(arr[i], arr[i + 1]) != 1:\n            result.append(1)  # Insert 1 as it is co-prime with any number\n            moves += 1\n    result.append(arr[-1])\n    \n    return moves, result\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Processing the problem\nmoves, new_arr = make_coprime_array(n, arr)\n\n# Printing the output\nprint(moves)\nprint(' '.join(map(str, new_arr)))"}
{"solution": "import math\nfrom functools import reduce\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef compute_gcd_of_list(lst):\n    return reduce(gcd, lst)\n\ndef max_divisor_after_operations(N, K, A):\n    if N == 1:\n        return A[0]\n    \n    # Compute the GCD of the differences between all pairs\n    diffs = [abs(A[i] - A[j]) for i in range(N) for j in range(i + 1, N)]\n    initial_gcd = compute_gcd_of_list(diffs)\n    \n    # Check all divisors of the initial GCD\n    max_divisor = 1\n    for d in range(1, initial_gcd + 1):\n        if initial_gcd % d == 0:\n            # Check if we can make all elements divisible by d\n            if all((a % d) <= K for a in A):\n                max_divisor = d\n    \n    return max_divisor\n\n# Read input\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Compute and print the result\nprint(max_divisor_after_operations(N, K, A))"}
{"solution": "def cat_furrier_transform(x):\n    operations = []\n    while x != 0 and len(operations) < 40:\n        # Find the highest bit that is not set\n        n = x.bit_length()\n        while x & (1 << (n - 1)):\n            n -= 1\n        # Perform Operation A\n        x ^= (1 << n) - 1\n        operations.append(n - 1)\n        # Check if x is now a perfect longcat\n        if x == (1 << n) - 1:\n            break\n        # Perform Operation B\n        x += 1\n    \n    # Output the result\n    print(len(operations))\n    if operations:\n        print(*operations)\n\n# Read input\nx = int(input())\n\n# Perform the Cat Furrier Transform\ncat_furrier_transform(x)"}
{"solution": "def min_hours_to_water_garden(n, k, buckets):\n    min_hours = float('inf')\n    for a_i in buckets:\n        if k % a_i == 0:\n            min_hours = min(min_hours, k // a_i)\n    return min_hours\n\n# Reading input\nn, k = map(int, input().split())\nbuckets = list(map(int, input().split()))\n\n# Output the result\nprint(min_hours_to_water_garden(n, k, buckets))"}
{"solution": "def can_grasshopper_reach_insect(n, k, line):\n    # Find the positions of the grasshopper and the insect\n    grasshopper_pos = line.index('G')\n    insect_pos = line.index('T')\n    \n    # Determine the direction of the jump based on their positions\n    step = k if grasshopper_pos < insect_pos else -k\n    \n    # Start jumping from the grasshopper's position\n    pos = grasshopper_pos\n    while pos >= 0 and pos < n:\n        if line[pos] == '#':  # If an obstacle is encountered, stop\n            return \"NO\"\n        if line[pos] == 'T':  # If the insect is reached, success\n            return \"YES\"\n        pos += step  # Make the next jump\n    \n    # If the loop ends without finding the insect, it's unreachable\n    return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\nline = input().strip()\n\n# Output the result\nprint(can_grasshopper_reach_insect(n, k, line))"}
{"solution": "import math\n\ndef calculate_aiming_point(y1, y2, yw, xb, yb, r):\n    # Check if the ball is already within the goal range\n    if y1 <= yb <= y2 and xb <= 0:\n        return 0  # The ball is already in the goal range, no need to bounce\n\n    # Calculate the necessary angle to bounce off the wall and hit the goal\n    # Using trigonometry to find the angle of incidence and reflection\n    theta = math.atan2(y2 - yb, xb)\n    if theta <= 0:\n        return -1  # The ball cannot bounce off the wall and hit the goal\n\n    # Calculate the distance from the ball to the wall where it will bounce\n    xw = xb * (yw - yb) / (y2 - yb)\n\n    # Check if the ball will hit the wall within the goal range after bouncing\n    if xw <= 0:\n        return -1  # The ball will not hit the wall within the goal range\n\n    # Check if the ball will hit the goal post or the other wall after bouncing\n    y_bounce = yb + (yw - yb) * xb / xw\n    if not (y1 <= y_bounce <= y2):\n        return -1  # The ball will not hit the goal after bouncing\n\n    return xw\n\n# Read input\ny1, y2, yw, xb, yb, r = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_aiming_point(y1, y2, yw, xb, yb, r)\nprint(f\"{result:.10f}\" if result != -1 else \"-1\")"}
{"solution": "def min_missed_meals(b, d, s):\n    # Sort the meals to find the maximum count\n    meals = sorted([b, d, s])\n    \n    # Start by assuming Vasiliy could have missed all meals before the first meal he had\n    missed = meals[2] - meals[1] + meals[2] - meals[0]\n    \n    # Subtract the meals that could not have been missed on the arrival and departure days\n    missed -= min(meals[2] - meals[1], meals[1])  # Missed dinners before the first dinner\n    missed -= min(meals[2] - meals[0], meals[0])  # Missed breakfasts before the first breakfast\n    \n    return max(missed, 0)  # Ensure the result is not negative\n\n# Read input\nb, d, s = map(int, input().split())\n\n# Print the result\nprint(min_missed_meals(b, d, s))"}
{"solution": "def find_matrix_dimensions(n, path):\n    # Function to calculate the possible dimensions of the matrix\n    def possible_dimensions(a1, a2):\n        # Calculate the possible x and y based on two consecutive numbers in the path\n        for x in range(1, int(a2 ** 0.5) + 1):\n            if a2 % x == 0:\n                y = a2 // x\n                if a1 == y * (x - 1) + 1:\n                    return x, y\n        return None, None\n\n    # Check for each pair of consecutive numbers in the path\n    for i in range(1, n):\n        x, y = possible_dimensions(path[i - 1], path[i])\n        if x is not None:\n            # Validate the entire path with the found dimensions\n            valid = True\n            for j in range(1, n):\n                if not (1 <= path[j] <= x * y and (path[j] - 1) % y + 1 == (path[j - 1] - 1) // y - (path[j] - 1) // y <= 1):\n                    valid = False\n                    break\n            if valid:\n                return \"YES\", x, y\n\n    return \"NO\", None, None\n\n# Read input\nn = int(input().strip())\npath = list(map(int, input().strip().split()))\n\n# Find and print the result\nresult, x, y = find_matrix_dimensions(n, path)\nprint(result)\nif result == \"YES\":\n    print(x, y)"}
{"solution": "def find_subsequence(a, b):\n    # Initialize pointers for both strings\n    pointer_a = 0\n    pointer_b = 0\n    \n    # Lists to keep track of the indices where characters from b are found in a\n    indices = []\n    \n    # Traverse both strings to find the longest subsequence\n    while pointer_a < len(a) and pointer_b < len(b):\n        if a[pointer_a] == b[pointer_b]:\n            indices.append(pointer_a)\n            pointer_b += 1\n        pointer_a += 1\n    \n    # If we didn't find all characters of b in a, return \"-\"\n    if pointer_b != len(b):\n        return \"-\"\n    \n    # Reconstruct the subsequence using the indices\n    subsequence = ''.join([a[i] for i in indices])\n    \n    return subsequence\n\n# Read input\na = input().strip()\nb = input().strip()\n\n# Find and print the subsequence\nprint(find_subsequence(a, b))"}
{"solution": "def minimal_stones(n, s):\n    current_stones = 0\n    min_stones = 0\n    \n    for char in s:\n        if char == '+':\n            current_stones += 1\n        elif char == '-':\n            current_stones -= 1\n        min_stones = min(min_stones, current_stones)\n    \n    return max(0, -min_stones)\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Print output\nprint(minimal_stones(n, s))"}
{"solution": "def max_liters_of_kefir(n, a, b, c):\n    # If the cost of a glass bottle minus the return value is less than the cost of a plastic bottle,\n    # it's more profitable to buy glass bottles and return them if possible.\n    if b - c < a:\n        # Calculate the maximum number of glass bottles Kolya can buy with his initial money.\n        # He can always buy at least one glass bottle if he has enough money for it.\n        glass_bottles = n // b\n        # Calculate the remaining money after buying the glass bottles.\n        remaining_money = n - glass_bottles * b\n        # Calculate the additional plastic bottles Kolya can buy with the remaining money\n        # after returning the glass bottles.\n        additional_plastic_bottles = (remaining_money + glass_bottles * c) // a\n        # The total liters of kefir is the sum of glass bottles and additional plastic bottles.\n        return glass_bottles + additional_plastic_bottles\n    else:\n        # If it's not more profitable to buy glass bottles, Kolya should buy only plastic bottles.\n        return n // a\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate and print the result\nprint(max_liters_of_kefir(n, a, b, c))"}
{"solution": "def card_war(n, k1, cards1, k2, cards2):\n    fights = 0\n    seen_states = set()\n    \n    while cards1 and cards2:\n        # Simulate a fight\n        fight = (tuple(cards1), tuple(cards2))\n        if fight in seen_states:\n            # If we've seen this state before, the game will never end\n            return -1\n        seen_states.add(fight)\n        \n        card1 = cards1.pop(0)\n        card2 = cards2.pop(0)\n        fights += 1\n        \n        if card1 > card2:\n            cards1.append(card2)\n            cards1.append(card1)\n        else:\n            cards2.append(card1)\n            cards2.append(card2)\n    \n    winner = 1 if cards1 else 2\n    return fights, winner\n\n# Read input\nn = int(input())\nk1 = int(input())\ncards1 = list(map(int, input().split()))\nk2 = int(input())\ncards2 = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = card_war(n, k1, cards1, k2, cards2)\nif result == -1:\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    \n    has_upper = False\n    has_lower = False\n    has_digit = False\n    \n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n    \n    if has_upper and has_lower and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\""}
{"solution": "def min_exchanges(n, group_a, group_b):\n    # Count the occurrences of each academic performance in both groups\n    count_a = [0] * 6\n    count_b = [0] * 6\n    \n    for perf in group_a:\n        count_a[perf] += 1\n    for perf in group_b:\n        count_b[perf] += 1\n    \n    # Calculate the total number of students for each performance\n    total_count = [count_a[i] + count_b[i] for i in range(6)]\n    \n    # Check if it's possible to balance the groups\n    for i in range(1, 6):\n        if total_count[i] % 2 != 0:\n            return -1\n    \n    # Calculate the number of students to exchange for each performance\n    exchanges = 0\n    for i in range(1, 6):\n        exchanges += abs(count_a[i] - count_b[i]) // 2\n    \n    # Since each exchange affects two students, divide by 2\n    return exchanges // 2\n\n# Read input\nn = int(input())\ngroup_a = list(map(int, input().split()))\ngroup_b = list(map(int, input().split()))\n\n# Print the result\nprint(min_exchanges(n, group_a, group_b))"}
{"solution": "def can_reach_any_junction_from_any_other(n, m, horizontal_directions, vertical_directions):\n    # Check if there's at least one horizontal street that allows movement in both directions\n    horizontal_bidirectional = any(horizontal_directions[i] != horizontal_directions[i + 1] for i in range(n - 1))\n    \n    # Check if there's at least one vertical street that allows movement in both directions\n    vertical_bidirectional = any(vertical_directions[i] != vertical_directions[i + 1] for i in range(m - 1))\n    \n    # If there's at least one bidirectional street in either direction, the pattern is valid\n    return \"YES\" if horizontal_bidirectional or vertical_bidirectional else \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nhorizontal_directions = input().strip()\nvertical_directions = input().strip()\n\n# Output the result\nprint(can_reach_any_junction_from_any_other(n, m, horizontal_directions, vertical_directions))"}
{"solution": "def can_make_false(n, args):\n    if '1' not in args or '0' not in args:\n        return \"NO\"\n    \n    if n == 1:\n        return \"YES\\n0\" if args[0] == '0' else \"NO\"\n    \n    # Find the first '1' followed by a '0' to create a false implication\n    for i in range(n - 1):\n        if args[i] == '1' and args[i + 1] == '0':\n            # Create the false implication by grouping the '1' and '0' together\n            result = \"->\".join(args[:i]) + \"->(\" + args[i] + \"->\" + args[i + 1] + \")\" + \"->\" + \"->\".join(args[i + 2:])\n            return \"YES\\n\" + result\n    \n    # If no such pair is found, it's not possible to make the expression false\n    return \"NO\"\n\n# Read input\nn = int(input())\nargs = input().split()\n\n# Output result\nprint(can_make_false(n, args))"}
{"solution": "def process_variables(a, b):\n    while a != 0 and b != 0:\n        if a >= 2 * b:\n            a %= 2 * b\n        elif b >= 2 * a:\n            b %= 2 * a\n        else:\n            break\n    return a, b\n\n# Assuming the input is provided correctly as per the problem statement\nn, m = map(int, input().split())\na, b = process_variables(n, m)\nprint(a, b)"}
{"solution": "def count_k_divisible_numbers(k, a, b):\n    # Adjust the range to start from the next k-divisible number if a is not divisible by k\n    if a % k != 0:\n        a = a + (k - a % k)\n    # Adjust b to the previous k-divisible number if b is not divisible by k\n    if b % k != 0:\n        b = b - b % k\n    # If a becomes greater than b after adjustment, there are no k-divisible numbers in the range\n    if a > b:\n        return 0\n    # Calculate the number of k-divisible numbers in the range\n    return (b - a) // k + 1\n\n# Read input\nk, a, b = map(int, input().split())\n\n# Print the result\nprint(count_k_divisible_numbers(k, a, b))"}
{"solution": "def find_kth_digit(k):\n    # Initialize the length of the current number and the total length of the sequence\n    length = 0\n    number_length = 1\n    \n    # Find the number range where the k-th digit falls into\n    while length + 9 * (10 ** (number_length - 1)) * number_length < k:\n        length += 9 * (10 ** (number_length - 1)) * number_length\n        number_length += 1\n    \n    # Find the exact number and the digit within that number\n    number = 10 ** (number_length - 1) + (k - length - 1) // number_length\n    digit_position = (k - length - 1) % number_length\n    \n    # Return the k-th digit\n    return str(number)[digit_position]\n\n# Read input\nk = int(input())\n\n# Print the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "def can_vasya_win(n, s):\n    # Calculate the number of moves each player will make\n    moves_each = (n - 11) // 2\n    \n    # Count the number of '8's in the first n - 10 characters\n    count_8s = s[:n - 10].count('8')\n    \n    # Vasya wins if there are more '8's than the number of moves Petya can make\n    if count_8s > moves_each:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Determine if Vasya has a winning strategy\nresult = can_vasya_win(n, s)\nprint(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial(n):\n    f = 1\n    for i in range(1, n + 1):\n        f = (f * i) % MOD\n    return f\n\ndef binomial_coefficient(n, k):\n    if k > n:\n        return 0\n    result = factorial(n)\n    result = (result * pow(factorial(k), MOD - 2, MOD)) % MOD\n    result = (result * pow(factorial(n - k), MOD - 2, MOD)) % MOD\n    return result\n\ndef count_valid_permutations(n, x, pos):\n    less_than_x = x - 1\n    greater_than_x = n - x\n    left = 0\n    right = n\n    middle = 0\n    valid_less = 0\n    valid_greater = 0\n    \n    while left < right:\n        middle = (left + right) // 2\n        if middle <= pos:\n            if middle < pos:\n                valid_less += 1\n            left = middle + 1\n        else:\n            valid_greater += 1\n            right = middle\n    \n    if valid_less > less_than_x or valid_greater > greater_than_x:\n        return 0\n    \n    permutations = (binomial_coefficient(less_than_x, valid_less) * factorial(valid_less)) % MOD\n    permutations = (permutations * binomial_coefficient(greater_than_x, valid_greater)) % MOD\n    permutations = (permutations * factorial(valid_greater)) % MOD\n    permutations = (permutations * factorial(n - valid_less - valid_greater - 1)) % MOD\n    \n    return permutations\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Calculate and print the result\nprint(count_valid_permutations(n, x, pos))"}
{"solution": "def decrypt_message(s, k):\n    # Count the number of letters that can be manipulated\n    manipulable_letters = sum(1 for i in range(len(s) - 1) if s[i + 1] in '?*')\n    \n    # Count the number of fixed letters\n    fixed_letters = len(s) - manipulable_letters\n    \n    # If k is less than the number of fixed letters minus manipulable letters, or more than the total length including all possible repetitions, it's impossible\n    if k < fixed_letters - manipulable_letters or k > len(s) - s.count('?') - s.count('*') * 2:\n        return \"Impossible\"\n    \n    # Start building the message\n    message = []\n    extra_letters = k - fixed_letters\n    \n    for i in range(len(s)):\n        if s[i] in '?*':\n            continue\n        if i + 1 < len(s) and s[i + 1] == '?':\n            if extra_letters > 0:\n                message.append(s[i])\n                extra_letters -= 1\n        elif i + 1 < len(s) and s[i + 1] == '*':\n            if extra_letters > 0:\n                message.append(s[i])\n                extra_letters -= 1\n            while extra_letters > 0:\n                message.append(s[i])\n                extra_letters -= 1\n        else:\n            message.append(s[i])\n    \n    return ''.join(message)\n\n# Read input\ns = input().strip()\nk = int(input().strip())\n\n# Output the result\nprint(decrypt_message(s, k))"}
{"solution": "def min_turns_to_correct_orientation(angle):\n    # Normalize the angle to be within the range [0, 360)\n    normalized_angle = angle % 360\n    if normalized_angle < 0:\n        normalized_angle += 360\n    \n    # Calculate the minimum number of 90-degree clockwise turns needed\n    # by finding the closest multiple of 90 to the normalized angle\n    turns = min(normalized_angle % 360, 360 - normalized_angle % 360) // 90\n    \n    return turns\n\n# Read input\nimport sys\ninput = sys.stdin.read\nangle = int(input().strip())\n\n# Calculate and print the result\nprint(min_turns_to_correct_orientation(angle))"}
{"solution": "def can_transform_spheres(a, b, c, x, y, z):\n    # Calculate the excess or deficit of each color\n    blue_diff = a - x\n    violet_diff = b - y\n    orange_diff = c - z\n\n    # Check if we have enough to cover deficits by transforming excesses\n    if blue_diff >= 0 and violet_diff >= 0 and orange_diff >= 0:\n        # We have enough, now check if we can transform without creating deficits\n        if blue_diff // 2 + violet_diff // 2 + orange_diff // 2 >= (blue_diff % 2 + violet_diff % 2 + orange_diff % 2):\n            return \"Yes\"\n    elif blue_diff <= 0 and violet_diff <= 0 and orange_diff <= 0:\n        # We have deficits, check if we can transform to cover them\n        if -blue_diff // 2 + -violet_diff // 2 + -orange_diff // 2 <= (a // 2 + b // 2 + c // 2):\n            return \"Yes\"\n    else:\n        # Mixed situation, check if we can balance excesses and deficits\n        excesses = [val for val in [blue_diff, violet_diff, orange_diff] if val > 0]\n        deficits = [val for val in [blue_diff, violet_diff, orange_diff] if val < 0]\n        total_excess = sum(excesses)\n        total_deficit = -sum(deficits)\n        if total_excess // 2 >= total_deficit:\n            return \"Yes\"\n\n    return \"No\"\n\n# Read input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Output result\nprint(can_transform_spheres(a, b, c, x, y, z))"}
{"solution": "def count_valid_numbers(n, k, m):\n    # Initialize the count of valid numbers\n    count = 0\n    \n    # Helper function to calculate the number of valid suffixes of length 'length'\n    def valid_suffixes(length):\n        if length == 0:\n            return 1\n        # The number of valid suffixes of length 'length' is 10 times the number of valid suffixes of length 'length - 1'\n        # because we can prepend any digit from 0 to 9 to a valid suffix of length 'length - 1'\n        # but we need to subtract the invalid ones (those that do not form a number divisible by k when appended)\n        return (10 * valid_suffixes(length - 1) - valid_suffixes(length - 1) // k * k) % m\n    \n    # Calculate the number of valid numbers of length 'n'\n    for length in range(1, n + 1):\n        count = (count + valid_suffixes(length)) % m\n    \n    return count\n\n# Read input\nn, k, m = map(int, input().split())\n\n# Print the result\nprint(count_valid_numbers(n, k, m))"}
{"solution": "def max_team_size(l, r, a):\n    while a > 0:\n        if l < r:\n            l += 1\n        else:\n            r += 1\n        a -= 1\n    return 2 * min(l, r)\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nl = int(data[0])\nr = int(data[1])\na = int(data[2])\n\n# Print the result\nprint(max_team_size(l, r, a))"}
{"solution": "def min_moves_to_pick_all_coins(n, k):\n    # Calculate the moves needed to open the nearest manholes first\n    moves = 0\n    \n    # If Nastya is not at the first or last manhole, she needs to throw stones to the ends first\n    if k != 1:\n        moves += 1  # Throw stone to the leftmost manhole\n    if k != n:\n        moves += 1  # Throw stone to the rightmost manhole\n    \n    # Now, Nastya can start picking coins from the nearest end\n    # She needs to move to each manhole and open it, which takes 2 moves per manhole\n    # She starts from her current position and moves towards the nearest end\n    if k <= n // 2:\n        # If Nastya is closer to the left end\n        moves += 2 * (k - 1)  # Move to each manhole on the left and open it\n        moves += 2 * (n - k)  # Move to each manhole on the right and open it\n    else:\n        # If Nastya is closer to the right end\n        moves += 2 * (n - k)  # Move to each manhole on the right and open it\n        moves += 2 * (k - 1)  # Move to each manhole on the left and open it\n    \n    return moves\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the result\nprint(min_moves_to_pick_all_coins(n, k))"}
{"solution": "def min_tallest_tower(n, m):\n    # Start with the smallest possible tower heights\n    two_block_heights = [2 * i for i in range(1, n + 1)]\n    three_block_heights = [3 * i for i in range(1, m + 1)]\n    \n    # Combine the heights and sort them\n    all_heights = sorted(two_block_heights + three_block_heights)\n    \n    # Ensure no two towers have the same height\n    for i in range(1, len(all_heights)):\n        if all_heights[i] <= all_heights[i - 1]:\n            all_heights[i] = all_heights[i - 1] + 1\n    \n    # Return the tallest tower height\n    return all_heights[-1]\n\n# Read input\nn, m = map(int, input().split())\n\n# Print the result\nprint(min_tallest_tower(n, m))"}
{"solution": "def can_play_fair(n, cards):\n    # Count the frequency of each number on the cards\n    frequency = {}\n    for card in cards:\n        if card in frequency:\n            frequency[card] += 1\n        else:\n            frequency[card] = 1\n    \n    # Check if there are exactly two numbers with the same frequency\n    values = list(frequency.values())\n    if len(values) != 2:\n        return \"NO\", None, None\n    \n    # Check if the frequencies are equal and sum up to n\n    if values[0] == values[1] and values[0] + values[1] == n:\n        numbers = list(frequency.keys())\n        return \"YES\", numbers[0], numbers[1]\n    else:\n        return \"NO\", None, None\n\n# Read input\nn = int(input())\ncards = [int(input()) for _ in range(n)]\n\n# Determine if the game can be fair and print the result\nresult, petya_number, vasya_number = can_play_fair(n, cards)\nprint(result)\nif result == \"YES\":\n    print(petya_number, vasya_number)"}
{"solution": "def can_place_soldiers(n, k, groups):\n    # Calculate the total number of soldiers\n    total_soldiers = sum(groups)\n    \n    # Calculate the total number of seats\n    total_seats = n * 8\n    \n    # If there are more soldiers than seats, it's impossible to place them\n    if total_soldiers > total_seats:\n        return \"NO\"\n    \n    # Calculate the maximum number of soldiers that can be placed without violating the neighbor rule\n    max_soldiers_without_conflict = n * 6  # 2 seats per row cannot be used due to neighbor rule\n    \n    # If the number of soldiers is less than or equal to the maximum without conflict, it's possible to place them\n    if total_soldiers <= max_soldiers_without_conflict:\n        return \"YES\"\n    \n    # Calculate the remaining soldiers that need to be placed after using the max_soldiers_without_conflict seats\n    remaining_soldiers = total_soldiers - max_soldiers_without_conflict\n    \n    # Calculate the number of additional seats that can be used without causing conflicts\n    additional_seats = n * 2  # 1 additional seat per row can be used for the remaining soldiers\n    \n    # If the remaining soldiers can fit into the additional seats, it's possible to place them\n    if remaining_soldiers <= additional_seats:\n        return \"YES\"\n    \n    # If none of the above conditions are met, it's impossible to place the soldiers\n    return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Print output\nprint(can_place_soldiers(n, k, groups))"}
{"solution": "def min_cost_to_make_sticks_almost_good(n, a):\n    min_cost = float('inf')\n    optimal_t = 0\n    \n    # Since the lengths of the sticks are between 1 and 100, we only need to consider t values in that range\n    for t in range(1, 101):\n        current_cost = 0\n        for length in a:\n            if abs(length - t) > 1:  # If the stick length is not almost good for t, calculate the cost to make it almost good\n                current_cost += min(abs(length - t + 1), abs(length - t - 1))\n        if current_cost < min_cost:\n            min_cost = current_cost\n            optimal_t = t\n    \n    return optimal_t, min_cost\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Finding the optimal t and minimum cost\nt, cost = min_cost_to_make_sticks_almost_good(n, a)\nprint(t, cost)"}
{"solution": "def min_square_side(n, m, sky_map):\n    min_x = min_y = float('inf')\n    max_x = max_y = -float('inf')\n    \n    for i in range(n):\n        for j in range(m):\n            if sky_map[i][j] == '*':\n                min_x = min(min_x, i)\n                max_x = max(max_x, i)\n                min_y = min(min_y, j)\n                max_y = max(max_y, j)\n    \n    side_x = max_x - min_x + 1\n    side_y = max_y - min_y + 1\n    \n    return max(side_x, side_y)\n\n# \u0427\u0442\u0435\u043d\u0438\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\nn, m = map(int, input().split())\nsky_map = [input() for _ in range(n)]\n\n# \u0412\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u0438 \u0432\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\nprint(min_square_side(n, m, sky_map))"}
{"solution": "MOD = 10**9 + 7\n\ndef modinv(a, m=MOD):\n    return pow(a, m-2, m)\n\ndef solve(n, k, a):\n    # If the array is already sorted, the probability is 1\n    if all(a[i] <= a[i+1] for i in range(n-1)):\n        return 1\n    \n    # If there's only one operation or the array is of length 2,\n    # the array can only be sorted if it's already sorted\n    if k == 1 or n == 2:\n        return 0\n    \n    # Count the number of 0s and 1s in the array\n    zeros = a.count(0)\n    ones = n - zeros\n    \n    # If the number of 0s or 1s is 0, the array will always be sorted\n    if zeros == 0 or ones == 0:\n        return 1\n    \n    # Calculate the number of ways to sort the array\n    # This is a simplified approach assuming k is large enough\n    # to make the array sorted with high probability\n    # The exact calculation would involve combinatorics and dynamic programming\n    # but for the sake of this example, we'll use a simplified approach\n    \n    # Calculate the factorial of k to approximate the number of combinations\n    fact_k = 1\n    for i in range(1, k+1):\n        fact_k = (fact_k * i) % MOD\n    \n    # The denominator is the factorial of k, since each operation is equiprobable\n    Q = fact_k\n    \n    # The numerator is more complex to calculate exactly, but we can approximate\n    # it by assuming the array will be sorted with high probability for large k\n    P = 1  # Placeholder for the actual calculation\n    \n    # Since P and Q are coprime, we can find P * Q^{-1} mod MOD\n    result = (P * modinv(Q)) % MOD\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Solve the problem and print the result\nprint(solve(n, k, a))"}
{"solution": "def min_seconds_to_devolve_triangle(x, y):\n    # The minimum number of operations is the difference between x and y\n    # because in each operation, we can reduce one side by 1 and adjust the other two sides\n    # to maintain a non-degenerate triangle.\n    return x - y\n\n# Read input from stdin\nx, y = map(int, input().split())\n\n# Calculate and print the result\nprint(min_seconds_to_devolve_triangle(x, y))"}
{"solution": "def min_norm_degenerate_matrix(a, b, c, d):\n    # Calculate the determinant of A\n    det_A = a * d - b * c\n    \n    # If A is already degenerate, return 0\n    if det_A == 0:\n        return 0.0\n    \n    # Initialize the minimum norm to a large number\n    min_norm = float('inf')\n    \n    # Try making each element of B equal to the corresponding element of A\n    # and adjust the other elements to make B degenerate\n    for i in range(4):\n        if i == 0:  # Adjust a\n            B = [a, b, c, d]\n            B[1] = a * B[3] / (a - B[0]) if a != B[0] else B[1]\n            B[2] = a * B[3] / (a - B[0]) if a != B[0] else B[2]\n        elif i == 1:  # Adjust b\n            B = [a, b, c, d]\n            B[0] = b * B[2] / (b - B[1]) if b != B[1] else B[0]\n            B[3] = b * B[2] / (b - B[1]) if b != B[1] else B[3]\n        elif i == 2:  # Adjust c\n            B = [a, b, c, d]\n            B[0] = c * B[3] / (c - B[2]) if c != B[2] else B[0]\n            B[1] = c * B[3] / (c - B[2]) if c != B[2] else B[1]\n        elif i == 3:  # Adjust d\n            B = [a, b, c, d]\n            B[1] = d * B[2] / (d - B[3]) if d != B[3] else B[1]\n            B[0] = d * B[2] / (d - B[3]) if d != B[3] else B[0]\n        \n        # Calculate the norm of A - B\n        norm_A_B = max(abs(a - B[0]), abs(b - B[1]), abs(c - B[2]), abs(d - B[3]))\n        \n        # Update the minimum norm\n        min_norm = min(min_norm, norm_A_B)\n    \n    return min_norm\n\n# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate and print the result\nprint(\"{:.10f}\".format(min_norm_degenerate_matrix(a, b, c, d)))"}
{"solution": "def restaurant_service(n, a, b, groups):\n    denied_service = 0\n    one_seater_tables = a\n    two_seater_tables = b\n    single_occupants = 0\n\n    for group in groups:\n        if group == 1:\n            if one_seater_tables > 0:\n                one_seater_tables -= 1\n            elif two_seater_tables > 0:\n                two_seater_tables -= 1\n                single_occupants += 1\n            elif single_occupants > 0:\n                single_occupants -= 1\n            else:\n                denied_service += 1\n        elif group == 2:\n            if two_seater_tables > 0:\n                two_seater_tables -= 1\n            else:\n                denied_service += 2\n\n    return denied_service\n\n# Reading input\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(restaurant_service(n, a, b, groups))"}
{"solution": "def determine_students_not_passing(A, B, C, N):\n    # Check for contradictions in the data\n    if C > A or C > B or A + B - C >= N:\n        return -1\n    # Calculate the number of students who didn't pass the exam\n    not_passing = N - (A + B - C)\n    return not_passing\n\n# Read input\nA, B, C, N = map(int, input().split())\n\n# Output the result\nprint(determine_students_not_passing(A, B, C, N))"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_pow(base, exponent, modulus):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % modulus\n        base = (base * base) % modulus\n        exponent //= 2\n    return result\n\ndef expected_dresses(x, k):\n    if x == 0:\n        return 0\n    # Calculate the expected number of dresses after k months\n    # The formula is derived from the problem statement and properties of geometric series\n    # The expected number of dresses after doubling and possibly losing one is (2x - 1) * 2^k\n    # We need to take this modulo 10^9 + 7\n    return (x * mod_pow(2, k + 1, MOD) - mod_pow(2, k, MOD) + 1) % MOD\n\n# Read input\nx, k = map(int, input().split())\n\n# Calculate and print the expected number of dresses\nprint(expected_dresses(x, k))"}
{"solution": "MOD = 998244353\n\ndef modinv(a, m):\n    return pow(a, m - 2, m)\n\ndef solve(n, ranges):\n    # Initialize the dp array to store the number of ways to have no inversions\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    # Calculate the total number of possible outcomes for each problem\n    total_outcomes = 1\n    for l, r in ranges:\n        total_outcomes = total_outcomes * (r - l + 1) % MOD\n    \n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(i):\n            # Calculate the number of ways to have no inversions for the first i problems\n            for k in range(ranges[i - 1][0], ranges[i - 1][1] + 1):\n                for m in range(ranges[j][0], ranges[j][1] + 1):\n                    if k < m:\n                        dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD\n                    else:\n                        dp[i][j + 1] = (dp[i][j + 1] + dp[i - 1][j]) % MOD\n    \n    # The number of ways to have no inversions for all n problems\n    no_inversions = dp[n][n]\n    \n    # Calculate the probability\n    probability = no_inversions * modinv(total_outcomes, MOD) % MOD\n    \n    return probability\n\n# Read input\nn = int(input())\nranges = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem and print the result\nprint(solve(n, ranges))"}
{"solution": "def count_ways_to_cut_stick(n):\n    # A rectangle can be formed if we have two pairs of equal lengths.\n    # A square is a special case of rectangle, so we need to avoid having all four parts of equal length.\n    # The number of ways to cut the stick depends on whether n is even or odd.\n    \n    # If n is odd, it's impossible to cut it into four parts that can form a rectangle.\n    if n % 2 != 0:\n        return 0\n    \n    # If n is even, we can cut it into two pairs of equal lengths.\n    # The number of valid ways to cut the stick is determined by how many pairs of equal lengths we can form.\n    # We need to ensure that we don't form a square, so the maximum length of a part should be less than n/2.\n    # The number of ways is (n/2 - 1) // 2 because we can't have all four parts of the same length.\n    return (n // 2 - 1) // 2\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(count_ways_to_cut_stick(n))"}
{"solution": "def max_kvass_in_least_keg(n, s, v):\n    # Sort the volumes to easily find the minimum after pouring\n    v.sort()\n    \n    # Check if it's possible to pour s liters\n    if sum(v) < s:\n        return -1\n    \n    # Start pouring from the largest keg to maintain the minimum as much as possible\n    for i in range(n-1, 0, -1):\n        # Calculate how much we can take from the current keg without making it less than the next smallest\n        pour_amount = min(v[i] - v[i-1], s)\n        v[i] -= pour_amount\n        s -= pour_amount\n        \n        # If we've poured enough, break\n        if s == 0:\n            break\n    \n    # If there's still kvass to pour, take it from the smallest keg\n    if s > 0:\n        v[0] -= s\n    \n    # The minimum volume in any keg after pouring is the answer\n    return v[0]\n\n# Read input\nn, s = map(int, input().split())\nv = list(map(int, input().split()))\n\n# Get the result and print it\nprint(max_kvass_in_least_keg(n, s, v))"}
{"solution": "def caterpillar_to_apple(h_1, h_2, a, b):\n    # Calculate the net gain per day\n    net_gain_per_day = (a * 10) - (b * 12)\n    \n    # If the caterpillar can't make progress in a day, it will never reach the apple\n    if net_gain_per_day <= 0 and (h_1 + a * 8) < h_2:\n        return -1\n    \n    # Calculate the initial progress on the first day\n    initial_progress = h_1 + a * 8\n    \n    # If the initial progress is already enough to reach the apple\n    if initial_progress >= h_2:\n        return 0\n    \n    # Calculate the remaining distance to the apple after the first day\n    remaining_distance = h_2 - initial_progress\n    \n    # Calculate the number of full days needed to reach the apple\n    full_days_needed = (remaining_distance + net_gain_per_day - 1) // net_gain_per_day\n    \n    return full_days_needed\n\n# Read input\nh_1, h_2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(caterpillar_to_apple(h_1, h_2, a, b))"}
{"solution": "def max_joy_units(C, Hr, Hb, Wr, Wb):\n    # If one type of candy is significantly heavier but provides less joy,\n    # it's better to prioritize the other type.\n    if Wr * Hb > Wb * Hr:\n        Wr, Wb = Wb, Wr\n        Hr, Hb = Hb, Hr\n    \n    # Start by eating as many of the more efficient candies as possible.\n    max_joy = 0\n    for i in range(int(C / Wr) + 1):  # +1 because range goes up to but does not include the end\n        if C - i * Wr >= 0:\n            # Calculate joy for eating i candies of type with weight Wr\n            joy_with_Wr = i * Hr\n            # Calculate remaining capacity and corresponding joy with Wb\n            remaining_capacity = C - i * Wr\n            joy_with_Wb = (remaining_capacity // Wb) * Hb\n            # Update max_joy if current combination yields more joy\n            max_joy = max(max_joy, joy_with_Wr + joy_with_Wb)\n    \n    return max_joy\n\n# Read input\nC, Hr, Hb, Wr, Wb = map(int, input().split())\n\n# Output the result\nprint(max_joy_units(C, Hr, Hb, Wr, Wb))"}
{"solution": "def minimal_steps_to_finish(x_1, y_1, x_2, y_2):\n    # Calculate the absolute differences in x and y coordinates\n    dx = abs(x_2 - x_1)\n    dy = abs(y_2 - y_1)\n    \n    # The minimal number of steps is the maximum of the differences\n    # because the robot can move diagonally or straight\n    return max(dx, dy)\n\n# Read input from the user\nx_1, y_1 = map(int, input().split())\nx_2, y_2 = map(int, input().split())\n\n# Calculate and print the minimal number of steps\nprint(minimal_steps_to_finish(x_1, y_1, x_2, y_2))"}
{"solution": "def predict_vote_outcome(n, employees):\n    depublicans = employees.count('D')\n    remocrats = n - depublicans\n    \n    # Simulate the voting process using a queue for each fraction\n    d_queue = deque(range(n)[i] for i in range(n) if employees[i] == 'D')\n    r_queue = deque(range(n)[i] for i in range(n) if employees[i] == 'R')\n    \n    while d_queue and r_queue:\n        # Process the next employee from each queue\n        d_turn = d_queue.popleft()\n        r_turn = r_queue.popleft()\n        \n        # Each employee denies the other fraction's next voter\n        d_queue.append(d_turn)\n        r_queue.append(r_turn)\n    \n    # The outcome is determined by the remaining queue\n    return 'D' if d_queue else 'R'\n\n# Read input\nn = int(input())\nemployees = input().strip()\n\n# Predict and print the outcome\nprint(predict_vote_outcome(n, employees))"}
{"solution": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef count_valid_tv_sets(a, b, x, y):\n    # Find the greatest common divisor (GCD) of x and y to normalize the aspect ratio\n    g = gcd(x, y)\n    x //= g\n    y //= g\n    \n    # Calculate the maximum width and height that fit within the constraints while maintaining the aspect ratio\n    max_width = a // x\n    max_height = b // y\n    \n    # The number of valid TV sets is the minimum of max_width and max_height\n    return min(max_width, max_height)\n\n# Read input\na, b, x, y = map(int, input().split())\n\n# Calculate and print the number of valid TV sets\nprint(count_valid_tv_sets(a, b, x, y))"}
{"solution": "import math\n\ndef prime_factors(n):\n    factors = {}\n    # Count the number of times 2 divides into n\n    while n % 2 == 0:\n        factors[2] = factors.get(2, 0) + 1\n        n //= 2\n    # Check for odd factors from 3 onwards\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            factors[i] = factors.get(i, 0) + 1\n            n //= i\n    # If n is a prime number greater than 2\n    if n > 2:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef count_factor_in_factorial(n, p):\n    count = 0\n    while n:\n        n //= p\n        count += n\n    return count\n\ndef count_trailing_zeros(n, b):\n    factors = prime_factors(b)\n    min_trailing_zeros = float('inf')\n    for prime, exponent in factors.items():\n        count_in_factorial = count_factor_in_factorial(n, prime)\n        min_trailing_zeros = min(min_trailing_zeros, count_in_factorial // exponent)\n    return min_trailing_zeros\n\n# Read input\nn, b = map(int, input().split())\n\n# Calculate and print the number of trailing zeros\nprint(count_trailing_zeros(n, b))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(m, a, b):\n    MOD = 10**9 + 7\n    g = gcd(a, b)\n    max_reachable = (m // g) * g + g - 1 if m % g != 0 else m\n    \n    dp = [0] * (max_reachable + 1)\n    dp[0] = 1\n    reachable_count = 1\n    sum_f = 1\n    \n    for i in range(1, max_reachable + 1):\n        if i >= a:\n            reachable_count += dp[i - a]\n        if i >= b:\n            reachable_count -= dp[i - b]\n        dp[i] = reachable_count\n        if i <= m:\n            sum_f += dp[i]\n    \n    if m > max_reachable:\n        sum_f += (m - max_reachable) * (max_reachable // g + 1)\n    \n    return sum_f\n\n# Read input\nm, a, b = map(int, input().split())\n\n# Output the result\nprint(solve(m, a, b))"}
{"solution": "def can_divide_into_odd_subsegments(n, sequence):\n    # Check if the sequence length is odd and the first and last elements are odd\n    if n % 2 == 1 and sequence[0] % 2 == 1 and sequence[-1] % 2 == 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Output the result\nprint(can_divide_into_odd_subsegments(n, sequence))"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    # Check if the trees are on a vertical or horizontal line\n    if x1 == x2:\n        side_length = abs(y2 - y1)\n        x3, y3 = x1 + side_length, y1\n        x4, y4 = x2 + side_length, y2\n    elif y1 == y2:\n        side_length = abs(x2 - x1)\n        x3, y3 = x1, y1 + side_length\n        x4, y4 = x2, y2 + side_length\n    else:\n        # Check if the trees form a diagonal of the square\n        if abs(x2 - x1) != abs(y2 - y1):\n            return -1  # The trees do not form a square\n        x3, y3 = x1, y2\n        x4, y4 = x2, y1\n    \n    return f\"{x3} {y3} {x4} {y4}\"\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\n\n# Find and print the remaining trees' coordinates\nprint(find_remaining_trees(x1, y1, x2, y2))"}
{"solution": "MOD = 1000000007\n\ndef calculate_f_n(x, y, n):\n    # Since the sequence follows the recurrence relation f_i = f_{i-1} + f_{i+1},\n    # we can observe that the sequence will cycle every 6 terms due to the nature\n    # of the recurrence relation. This allows us to reduce n modulo 6.\n    n = (n - 1) % 6\n    \n    # We can now calculate f_n based on the reduced n.\n    if n == 0:\n        return x % MOD\n    elif n == 1:\n        return y % MOD\n    elif n == 2:\n        return (y - x) % MOD\n    elif n == 3:\n        return (-x) % MOD\n    elif n == 4:\n        return (-y) % MOD\n    else:  # n == 5\n        return (x - y) % MOD\n\n# Read input\nx, y = map(int, input().split())\nn = int(input())\n\n# Calculate and print the result\nprint(calculate_f_n(x, y, n))"}
{"solution": "def split_array(n, A):\n    # Check if the entire array sum is zero\n    if sum(A) == 0:\n        return \"NO\"\n    \n    # Initialize the result list\n    result = []\n    \n    # Iterate through the array to find subarrays with non-zero sum\n    current_sum = 0\n    start = 0\n    for i in range(n):\n        current_sum += A[i]\n        if current_sum != 0:\n            continue\n        else:\n            # If the sum is zero, add the previous subarray to the result\n            result.append((start + 1, i))\n            start = i + 1\n            current_sum = 0\n    \n    # If there's a remaining subarray with non-zero sum, add it to the result\n    if start < n:\n        result.append((start + 1, n))\n    \n    # Prepare the output\n    output = [\"YES\"]\n    output.append(str(len(result)))\n    for l, r in result:\n        output.append(f\"{l} {r}\")\n    \n    return \"\\n\".join(output)\n\n# Read input\nn = int(input())\nA = list(map(int, input().split()))\n\n# Print output\nprint(split_array(n, A))"}
{"solution": "MOD = 1000000009\n\ndef min_score(n, m, k):\n    # Calculate the number of bonus opportunities Manao has\n    bonus_opportunities = n // k\n    \n    # If Manao answered fewer questions correctly than the bonus opportunities,\n    # or the number of correct answers is less than k, he cannot benefit from the bonus\n    if m <= bonus_opportunities or k > m:\n        return m\n    \n    # Calculate the number of times Manao can use the bonus\n    bonus_uses = (m - bonus_opportunities + k - 2) // (k - 1)\n    \n    # Calculate the score Manao would get from the bonus uses\n    bonus_score = (pow(2, bonus_uses + 1, MOD) - 2) * k % MOD\n    \n    # Calculate the remaining correct answers after using the bonus\n    remaining_correct = m - bonus_uses * (k - 1)\n    \n    # Calculate the total score\n    total_score = (bonus_score + remaining_correct) % MOD\n    \n    return total_score\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Print the output\nprint(min_score(n, m, k))"}
{"solution": "def is_divisible_by_8(n):\n    # Check if the number is divisible by 8\n    return int(n) % 8 == 0\n\ndef find_divisible_by_8(n):\n    # Convert the number to a list of digits\n    digits = list(n)\n    length = len(digits)\n    \n    # Check all possible combinations of digits to find one divisible by 8\n    for i in range(length):\n        for j in range(i + 1, length):\n            for k in range(j + 1, length):\n                # Form a number with three digits\n                num = digits[i] + digits[j] + digits[k]\n                if is_divisible_by_8(num):\n                    return \"YES\\n\" + num\n    \n    for i in range(length):\n        for j in range(i + 1, length):\n            # Form a number with two digits\n            num = digits[i] + digits[j]\n            if is_divisible_by_8(num):\n                return \"YES\\n\" + num\n    \n    for i in range(length):\n        # Check single digit numbers\n        if is_divisible_by_8(digits[i]):\n            return \"YES\\n\" + digits[i]\n    \n    # If no combination is found, return \"NO\"\n    return \"NO\"\n\n# Read input\nn = input().strip()\n\n# Print the result\nprint(find_divisible_by_8(n))"}
{"solution": "def determine_floor(n, m, memory):\n    possible_flats_per_floor = set(range(1, 101))  # Start with all possibilities\n\n    for k, f in memory:\n        new_possibilities = set()\n        for flats_per_floor in possible_flats_per_floor:\n            if (k - 1) // flats_per_floor + 1 == f:\n                new_possibilities.add(flats_per_floor)\n        possible_flats_per_floor = new_possibilities\n\n    unique_floor = None\n    for flats_per_floor in possible_flats_per_floor:\n        floor = (n - 1) // flats_per_floor + 1\n        if unique_floor is None:\n            unique_floor = floor\n        elif unique_floor != floor:\n            return -1\n\n    return unique_floor\n\n# Read input\nn, m = map(int, input().split())\nmemory = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Determine and print the floor\nprint(determine_floor(n, m, memory))"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    board = [[board1[i], board2[i]] for i in range(n)]\n    \n    # Define the four possible shapes of the bishwock\n    bishwock_shapes = [\n        [(0, 0), (0, 1), (1, 0)],  # Original L shape\n        [(0, 0), (0, 1), (1, 1)],  # Rotated 90 degrees\n        [(0, 1), (1, 0), (1, 1)],  # Rotated 180 degrees\n        [(0, 0), (1, 0), (1, 1)]   # Rotated 270 degrees\n    ]\n    \n    def can_place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            if nx >= 2 or ny >= n or board[ny][nx] == 'X':\n                return False\n        return True\n    \n    def place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            board[ny][nx] = 'X'\n    \n    count = 0\n    for y in range(n):\n        for x in range(2):\n            for shape in bishwock_shapes:\n                if can_place_bishwock(x, y, shape):\n                    place_bishwock(x, y, shape)\n                    count += 1\n                    break\n    \n    return count"}
{"solution": "def max_pretty_set_length(n, s):\n    max_length = 0\n    current_set = set()\n    \n    for char in s:\n        if char.islower():\n            current_set.add(char)\n        else:\n            max_length = max(max_length, len(current_set))\n            current_set.clear()\n    \n    # Check the last segment\n    max_length = max(max_length, len(current_set))\n    \n    return max_length\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult = max_pretty_set_length(n, s)\n\n# Print the result\nprint(result)"}
{"solution": "def max_difference(n, a):\n    # Sort the sequence to make it easier to partition\n    a.sort()\n    \n    # Initialize sums for B and C\n    B = 0\n    C = 0\n    \n    # Assign elements to B or C to maximize B - C\n    for element in a:\n        if element >= 0:\n            B += element\n        else:\n            C += element\n    \n    # Return the maximum possible value of B - C\n    return B - C\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_difference(n, a))"}
{"solution": "def min_refuels(a, b, f, k):\n    if b < f or b < (a - f):\n        return -1\n    \n    fuel = b\n    refuels = 0\n    for i in range(k):\n        if i % 2 == 0:  # Going from 0 to a\n            if i == k - 1:  # Last journey\n                if fuel < (a - f) and fuel < a:\n                    refuels += 1\n                    fuel = b - (a - f)\n                if fuel < a - (a - f):\n                    return -1\n            else:\n                if fuel < 2 * (a - f):\n                    refuels += 1\n                    fuel = b - (a - f)\n                else:\n                    fuel -= a\n        else:  # Going from a to 0\n            if i == k - 1:  # Last journey\n                if fuel < f and fuel < a:\n                    refuels += 1\n                    fuel = b - f\n                if fuel < a - f:\n                    return -1\n            else:\n                if fuel < 2 * f:\n                    refuels += 1\n                    fuel = b - f\n                else:\n                    fuel -= a\n    \n    return refuels\n\n# Read input\na, b, f, k = map(int, input().split())\n\n# Print output\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    # Check if it's possible to split the string using only p or only q\n    if n % p == 0:\n        return [s[i:i+p] for i in range(0, n, p)], n // p\n    elif n % q == 0:\n        return [s[i:i+q] for i in range(0, n, q)], n // q\n    \n    # Try to find a combination of p and q that works\n    for i in range(1, n // p + 1):\n        remaining = n - i * p\n        if remaining % q == 0:\n            parts = [s[j:j+p] for j in range(0, i*p, p)]\n            parts += [s[i*p+k:i*p+k+q] for k in range(0, remaining, q)]\n            return parts, i + remaining // q\n    \n    return -1, -1\n\n# Read input\nn, p, q = map(int, input().split())\ns = input()\n\n# Solve the problem\nresult, count = split_string(n, p, q, s)\n\n# Print the output\nif result == -1:\n    print(-1)\nelse:\n    print(count)\n    for part in result:\n        print(part)"}
{"solution": "def can_reach_finish(n, m, s, d, obstacles):\n    obstacles.sort()\n    actions = []\n    current_position = 0\n    \n    while current_position < m:\n        # Find the next obstacle or the finish line\n        next_obstacle = next((obs for obs in obstacles if obs > current_position), m)\n        \n        # Calculate the distance to the next obstacle or finish\n        distance_to_next = next_obstacle - current_position\n        \n        if distance_to_next < s:\n            # Not enough space to take a run before jumping\n            return \"IMPOSSIBLE\"\n        \n        # Run to the point just before the next obstacle\n        actions.append(f\"RUN {distance_to_next - 1}\")\n        current_position += distance_to_next - 1\n        \n        # Find the next safe landing spot after jumping over the obstacle\n        next_safe_spot = next((obs for obs in obstacles if obs > current_position + d), m)\n        \n        # Calculate the jump distance\n        jump_distance = min(next_safe_spot - current_position, d)\n        \n        if jump_distance <= 0:\n            # No safe spot to land after jumping\n            return \"IMPOSSIBLE\"\n        \n        # Jump over the obstacle\n        actions.append(f\"JUMP {jump_distance}\")\n        current_position += jump_distance\n    \n    return \"\\n\".join(actions)\n\n# Read input\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\n# Output the result\nprint(can_reach_finish(n, m, s, d, obstacles))"}
{"solution": "def count_ordered_pairs(s, x):\n    # Check if s - x is even and positive\n    if (s - x) % 2 != 0 or s < x:\n        return 0\n    \n    # Calculate b\n    b = (s - x) // 2\n    \n    # Check if a and b are positive integers\n    if b < 0 or s - b < 0:\n        return 0\n    \n    # Check if there are no conflicts with the XOR operation\n    if b & x != 0:\n        return 0\n    \n    # If there are no conflicts, there are 2 solutions for each valid pair\n    return 2\n\n# Read input\ns, x = map(int, input().split())\n\n# Print the number of solutions\nprint(count_ordered_pairs(s, x))"}
{"solution": "def min_actions_to_turn_over_skewers(n, k):\n    actions = []\n    for i in range(1, n + 1, 2 * k + 1):\n        actions.append(i + k if i + k <= n else i)\n    return len(actions), actions\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nnum_actions, actions = min_actions_to_turn_over_skewers(n, k)\nprint(num_actions)\nprint(' '.join(map(str, actions)))"}
{"solution": "import math\n\ndef min_operations_to_square(n):\n    n_str = str(n)\n    n_len = len(n_str)\n    \n    # Generate all possible squares up to the maximum possible value\n    max_square_root = int(math.sqrt(2 * 10**9)) + 1\n    squares = [str(i * i) for i in range(1, max_square_root + 1)]\n    \n    def is_subsequence(small, large):\n        it = iter(large)\n        return all(char in it for char in small)\n    \n    min_deletions = float('inf')\n    \n    for square in squares:\n        if is_subsequence(square, n_str):\n            deletions = n_len - len(square)\n            min_deletions = min(min_deletions, deletions)\n    \n    return min_deletions if min_deletions != float('inf') else -1\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(min_operations_to_square(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_permutations(n):\n    if n == 2:\n        return 1\n    if n == 3:\n        return 4\n    \n    # Calculate f_max(n)\n    f_max = 0\n    for i in range(1, n+1):\n        if gcd(i, i-1) == 1:\n            f_max += 1\n        else:\n            break\n    \n    # Count permutations with f(p) = f_max\n    count = 1\n    for i in range(f_max):\n        count = (count * (n - i)) % MOD\n    \n    return count\n\n# Read input\nn = int(input().strip())\n\n# Print output\nprint(count_permutations(n))"}
{"solution": "def minimum_jump_ability(s):\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    positions = [-1]  # Start position before the first character\n    \n    # Collect positions of all vowels\n    for i, char in enumerate(s):\n        if char in vowels:\n            positions.append(i)\n    \n    positions.append(len(s))  # End position after the last character\n    \n    # Calculate maximum distance between consecutive positions\n    max_distance = 0\n    for i in range(1, len(positions)):\n        max_distance = max(max_distance, positions[i] - positions[i - 1])\n    \n    return max_distance\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(minimum_jump_ability(s))"}
{"solution": "def can_distribute_equally(a1, a2, a3, a4):\n    # Calculate the total number of candies\n    total_candies = a1 + a2 + a3 + a4\n    \n    # Check if the total number of candies is even\n    if total_candies % 2 != 0:\n        return \"NO\"\n    \n    # Calculate the half of the total number of candies\n    half_candies = total_candies // 2\n    \n    # Check if any combination of three bags sums up to half of the total candies\n    if (a1 + a2 == half_candies) or (a1 + a3 == half_candies) or (a1 + a4 == half_candies) or \\\n       (a2 + a3 == half_candies) or (a2 + a4 == half_candies) or (a3 + a4 == half_candies) or \\\n       (a1 == half_candies) or (a2 == half_candies) or (a3 == half_candies) or (a4 == half_candies):\n        return \"YES\"\n    \n    return \"NO\"\n\n# Read input\na1, a2, a3, a4 = map(int, input().split())\n\n# Output result\nprint(can_distribute_equally(a1, a2, a3, a4))"}
{"solution": "def optimal_pie_distribution(N, slice_sizes):\n    alice_total = 0\n    bob_total = 0\n    alice_turn = False\n\n    while slice_sizes:\n        if alice_turn:\n            # Alice will take the largest slice available to maximize her pie\n            alice_total += slice_sizes.pop()\n        else:\n            # Bob will take the largest slice available to maximize his pie\n            bob_total += slice_sizes.pop()\n            # After Bob takes a slice, it's Alice's turn to decide\n            alice_turn = True\n\n    return alice_total, bob_total\n\n# Read input\nN = int(input().strip())\nslice_sizes = list(map(int, input().strip().split()))\n\n# Ensure the slices are sorted in descending order for optimal decision-making\nslice_sizes.sort(reverse=True)\n\n# Calculate the optimal distribution\nalice_total, bob_total = optimal_pie_distribution(N, slice_sizes)\n\n# Print the result\nprint(alice_total, bob_total)"}
{"solution": "def min_variables_needed(n, sequence):\n    # Sort the sequence to make it easier to find the minimum number of variables needed\n    sequence.sort()\n    \n    # If the sequence contains only one number, only one variable is needed\n    if n == 1:\n        return 1\n    \n    # If the smallest number is not 1, it's impossible to generate the sequence\n    if sequence[0] != 1:\n        return -1\n    \n    # Initialize the count of variables needed\n    variables_needed = 1\n    \n    # Use a set to keep track of the sums we can generate with the variables\n    sums_generated = {1}\n    \n    # Iterate through the sequence starting from the second element\n    for num in sequence[1:]:\n        # If the current number is not in the set of generated sums, we need another variable\n        if num not in sums_generated:\n            variables_needed += 1\n            # Update the set of generated sums with the new number and all possible sums\n            new_sums = set()\n            for s in sums_generated:\n                new_sums.add(s + num)\n            sums_generated.update(new_sums)\n        # Update the set of generated sums with the current number\n        sums_generated.add(num)\n    \n    return variables_needed\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Print the result\nprint(min_variables_needed(n, sequence))"}
{"solution": "def determine_winner(n, piles):\n    odd_count = sum(1 for pile in piles if pile % 2 != 0)\n    if odd_count % 2 == 0:\n        return \"Alice\"\n    else:\n        return \"Bob\"\n\n# Read input\nn = int(input())\npiles = list(map(int, input().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, piles))"}
{"solution": "def can_make_equal(n, arr):\n    unique_values = set(arr)\n    if len(unique_values) > 3:\n        return \"NO\"\n    elif len(unique_values) == 1:\n        return \"YES\"\n    else:\n        sorted_values = sorted(unique_values)\n        if len(sorted_values) == 2:\n            return \"YES\"\n        elif len(sorted_values) == 3 and sorted_values[1] - sorted_values[0] == sorted_values[2] - sorted_values[1]:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output the result\nprint(can_make_equal(n, arr))"}
{"solution": "def longest_non_overlapping_substring(N, S):\n    max_len = 0\n    for len in range(1, N):\n        seen = set()\n        for i in range(N - len + 1):\n            substring = S[i:i+len]\n            if substring in seen:\n                max_len = len\n                break\n            seen.add(substring)\n    return max_len\n\n# Read input\nN = int(input())\nS = input()\n\n# Output the result\nprint(longest_non_overlapping_substring(N, S))"}
{"solution": "def minimum_time_to_house(n, a):\n    if a % 2 == 1:\n        # a is odd\n        return (a + 1) // 2\n    else:\n        # a is even\n        return (n - a + 2) // 2\n\n# Read input\nn, a = map(int, input().split())\n\n# Calculate and print the result\nprint(minimum_time_to_house(n, a))"}
{"solution": "def can_select_jedi_knights(n, m, lightsaber_colors, desired_counts):\n    from collections import Counter\n\n    # Convert the list of desired counts into a dictionary for easy lookup\n    desired_counts_dict = {i + 1: desired_counts[i] for i in range(m)}\n\n    # Initialize the left pointer of the sliding window\n    left = 0\n\n    # Use a Counter to keep track of the counts of each color in the current window\n    window_counts = Counter()\n\n    # Iterate over the right pointer of the sliding window\n    for right in range(n):\n        # Add the current knight's lightsaber color to the window\n        window_counts[lightsaber_colors[right]] += 1\n\n        # Check if the current window meets the desired counts\n        while all(window_counts[color] >= desired_counts_dict[color] for color in desired_counts_dict):\n            # If the window size matches the total desired counts, return \"YES\"\n            if sum(window_counts.values()) == sum(desired_counts):\n                return \"YES\"\n\n            # If not, move the left pointer to shrink the window and adjust the counts\n            window_counts[lightsaber_colors[left]] -= 1\n            left += 1\n\n    # If no valid window is found, return \"NO\"\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nlightsaber_colors = list(map(int, input().split()))\ndesired_counts = list(map(int, input().split()))\n\n# Output the result\nprint(can_select_jedi_knights(n, m, lightsaber_colors, desired_counts))"}
{"solution": "def determine_winner(n, rounds):\n    mishka_wins = 0\n    chris_wins = 0\n    \n    for m, c in rounds:\n        if m > c:\n            mishka_wins += 1\n        elif c > m:\n            chris_wins += 1\n    \n    if mishka_wins > chris_wins:\n        return \"Mishka\"\n    elif chris_wins > mishka_wins:\n        return \"Chris\"\n    else:\n        return \"Friendship is magic!^^\"\n\n# Read input from standard input\nn = int(input())\nrounds = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Determine and print the winner\nprint(determine_winner(n, rounds))"}
{"solution": "def is_valid_minesweeper_field(n, m, field):\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] != '.' and field[i][j] != '*':\n                bomb_count = 0\n                for x in range(max(0, i - 1), min(n, i + 2)):\n                    for y in range(max(0, j - 1), min(m, j + 2)):\n                        if field[x][y] == '*':\n                            bomb_count += 1\n                if bomb_count != int(field[i][j]):\n                    return \"NO\"\n            elif field[i][j] == '.':\n                for x in range(max(0, i - 1), min(n, i + 2)):\n                    for y in range(max(0, j - 1), min(m, j + 2)):\n                        if field[x][y] == '*':\n                            return \"NO\"\n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\n# Output result\nprint(is_valid_minesweeper_field(n, m, field))"}
{"solution": "def can_vasya_eat_half(n, k):\n    total_candies = n\n    vasya_eaten = 0\n    \n    while total_candies > 0:\n        # Vasya eats k candies\n        vasya_eaten += min(k, total_candies)\n        total_candies -= min(k, total_candies)\n        \n        # Petya eats 10% of the remaining candies\n        petya_eaten = total_candies // 10\n        total_candies -= petya_eaten\n    \n    return vasya_eaten >= (n + 1) // 2\n\ndef find_min_k(n):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Read input\nn = int(input().strip())\n\n# Find and print the minimal k\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace(s):\n    p = s.count('o')\n    l = s.count('-')\n    \n    if p == 0 or p == 1:\n        return \"YES\"\n    if l % p == 0:\n        return \"YES\"\n    return \"NO\""}
{"solution": "def max_frodo_pillows(n, m, k):\n    left = 1\n    right = m\n    while left < right:\n        mid = (left + right + 1) // 2\n        if is_valid_distribution(n, m, k, mid):\n            left = mid\n        else:\n            right = mid - 1\n    return left\n\ndef is_valid_distribution(n, m, k, frodo_pillows):\n    total_pillows = frodo_pillows\n    # Calculate pillows needed for the left side\n    for i in range(k - 1, 0, -1):\n        total_pillows += max(1, frodo_pillows - (k - i))\n        if total_pillows > m:\n            return False\n    # Calculate pillows needed for the right side\n    for i in range(k + 1, n + 1):\n        total_pillows += max(1, frodo_pillows - (i - k))\n        if total_pillows > m:\n            return False\n    return total_pillows <= m\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Output the result\nprint(max_frodo_pillows(n, m, k))"}
{"solution": "def max_subarray_cost(n, m, k, a):\n    max_cost = 0\n    current_sum = 0\n    penalty = 0\n    queue = []\n\n    for i in range(n):\n        current_sum += a[i]\n        if queue and queue[0] + m <= i:\n            current_sum -= a[queue.pop(0)]\n        penalty = k * ((i - queue[0] + 1 + m - 1) // m) if queue else 0\n        current_cost = current_sum - penalty\n\n        max_cost = max(max_cost, current_cost)\n\n        while queue and current_sum - k * ((i - queue[0] + 1 + m - 1) // m) <= (current_sum - a[queue[0]]) - k * ((i - queue[0] + m) // m):\n            current_sum -= a[queue.pop(0)]\n\n        queue.append(i)\n\n    return max_cost\n\n# Reading input\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_subarray_cost(n, m, k, a))"}
{"solution": "def longest_polyline(n, m):\n    # The strategy to maximize the length is to use the corners of the grid\n    # and the midpoints to create the longest segments possible.\n    if n == 0:\n        # Special case where the grid is a vertical line\n        return [\n            (0, 1),\n            (0, m),\n            (0, 0),\n            (0, m-1)\n        ]\n    elif m == 0:\n        # Special case where the grid is a horizontal line\n        return [\n            (1, 0),\n            (n, 0),\n            (0, 0),\n            (n-1, 0)\n        ]\n    else:\n        # General case for a rectangular grid\n        return [\n            (n, m),\n            (0, 0),\n            (n, 0),\n            (0, m)\n        ]\n\n# Read input\nn, m = map(int, input().split())\n\n# Get the points for the longest polyline\npoints = longest_polyline(n, m)\n\n# Print the points\nfor point in points:\n    print(point[0], point[1])"}
{"solution": "def find_smallest_n(shuffled_str, remembered_substr):\n    from collections import Counter\n    \n    # Count occurrences of each digit in the shuffled string and remembered substring\n    shuffled_counter = Counter(shuffled_str)\n    remembered_counter = Counter(remembered_substr)\n    \n    # Calculate the length of the original number n\n    k = len(shuffled_str) - len(remembered_substr)\n    \n    # Find the smallest possible n by trying to construct it from the digits in shuffled_str\n    # while ensuring that the remembered_substr can be formed and no leading zeroes are present\n    n_digits = []\n    for digit in range(10):\n        digit_str = str(digit)\n        while shuffled_counter[digit_str] > remembered_counter[digit_str]:\n            n_digits.append(digit_str)\n            shuffled_counter[digit_str] -= 1\n            remembered_counter[digit_str] -= 1\n    \n    # Ensure that the remembered_substr can be formed with the remaining digits\n    for digit in remembered_substr:\n        if shuffled_counter[digit] <= 0:\n            return \"Impossible to form the remembered substring with the remaining digits.\"\n        shuffled_counter[digit] -= 1\n    \n    # Combine the digits to form the smallest possible n\n    n_str = ''.join(n_digits)\n    \n    # If n_str is empty, it means the original number was zero\n    if not n_str:\n        n_str = '0'\n    \n    return n_str\n\n# Example usage:\nshuffled_str = \"003512\"\nremembered_substr = \"021\"\nprint(find_smallest_n(shuffled_str, remembered_substr))  # Output: 30021\n\nshuffled_str = \"199966633300\"\nremembered_substr = \"63\"\nprint(find_smallest_n(shuffled_str, remembered_substr))  # Output: 3036366999"}
{"solution": "def check_temperatures(n, m, min_temp, max_temp, temps):\n    # Check if the minimum and maximum temperatures are already in the list\n    if min_temp not in temps:\n        temps.append(min_temp)\n    if max_temp not in temps:\n        temps.append(max_temp)\n    \n    # Check if we can achieve the required number of temperatures\n    if len(temps) <= n:\n        return 'Correct'\n    else:\n        return 'Incorrect'\n\n# Read input\nn, m, min_temp, max_temp = map(int, input().split())\ntemps = list(map(int, input().split()))\n\n# Check and print the result\nprint(check_temperatures(n, m, min_temp, max_temp, temps))"}
{"solution": "def trailing_zeroes_count(n):\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count\n\ndef find_numbers_with_m_trailing_zeroes(m):\n    low, high = 0, 5 * m\n    while low < high:\n        mid = (low + high) // 2\n        if trailing_zeroes_count(mid) < m:\n            low = mid + 1\n        else:\n            high = mid\n    \n    result = []\n    while trailing_zeroes_count(low) == m:\n        result.append(low)\n        low += 1\n    \n    return result\n\ndef main():\n    m = int(input().strip())\n    numbers = find_numbers_with_m_trailing_zeroes(m)\n    print(len(numbers))\n    if len(numbers) > 0:\n        print(' '.join(map(str, numbers)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import heapq\n\ndef dijkstra(graph, start, n):\n    # Initialize distances with infinity\n    distances = [float('inf')] * n\n    distances[start] = 0\n    max_cost = [0] * n\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_vertex = heapq.heappop(pq)\n        \n        for neighbor, weight in graph[current_vertex]:\n            # Update the maximum cost encountered so far\n            cost = max(max_cost[current_vertex], weight)\n            # If we found a better path to the neighbor through current_vertex\n            if cost < max_cost[neighbor]:\n                max_cost[neighbor] = cost\n                heapq.heappush(pq, (cost, neighbor))\n    \n    return max_cost\n\ndef solve(n, m, k, special_vertices, edges):\n    # Create adjacency list for the graph\n    graph = {i: [] for i in range(n)}\n    for u, v, w in edges:\n        graph[u-1].append((v-1, w))\n        graph[v-1].append((u-1, w))\n    \n    # Convert special vertices to indices starting from 0\n    special_indices = [v-1 for v in special_vertices]\n    \n    # For each special vertex, find the farthest special vertex\n    result = []\n    for sv in special_indices:\n        max_cost = dijkstra(graph, sv, n)\n        # Find the maximum distance among special vertices\n        max_distance = max(max_cost[i] for i in special_indices)\n        result.append(max_distance)\n    \n    return result\n\n# Read input\nn, m, k = map(int, input().split())\nspecial_vertices = list(map(int, input().split()))\nedges = [list(map(int, input().split())) for _ in range(m)]\n\n# Solve the problem and print the result\nresult = solve(n, m, k, special_vertices, edges)\nprint(' '.join(map(str, result)))"}
{"solution": "def initial_position(n, x):\n    # The pattern of swaps can be reduced to a simple formula due to the repetitive nature:\n    # - After an even number of moves, the ball's position is shifted by n % 2 to the right.\n    # - After an odd number of moves, the ball's position remains the same or is shifted to the left.\n    # This can be simplified to: initial_position = (x - n % 3 + 3) % 3\n    return (x - n % 3 + 3) % 3\n\n# Read input\nn = int(input())\nx = int(input())\n\n# Calculate and print the initial position\nprint(initial_position(n, x))"}
{"solution": "def rectangles_form_square(rectangles):\n    # Find the bounding box\n    min_x = min_y = float('inf')\n    max_x = max_y = -float('inf')\n    \n    for x1, y1, x2, y2 in rectangles:\n        min_x = min(min_x, x1)\n        max_x = max(max_x, x2)\n        min_y = min(min_y, y1)\n        max_y = max(max_y, y2)\n    \n    bounding_box_width = max_x - min_x\n    bounding_box_height = max_y - min_y\n    \n    # Check if the bounding box is a square\n    if bounding_box_width != bounding_box_height:\n        return \"NO\"\n    \n    # Check if the union of rectangles covers the entire bounding box\n    covered_area = set()\n    for x1, y1, x2, y2 in rectangles:\n        for x in range(x1, x2):\n            for y in range(y1, y2):\n                point = (x, y)\n                if point in covered_area:\n                    return \"NO\"  # Overlap detected\n                covered_area.add(point)\n    \n    # Check if all points in the bounding box are covered\n    for x in range(min_x, max_x):\n        for y in range(min_y, max_y):\n            if (x, y) not in covered_area:\n                return \"NO\"  # Gap detected\n    \n    return \"YES\"\n\n# Read input\nn = int(input())\nrectangles = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(rectangles_form_square(rectangles))"}
{"solution": "def count_really_big_numbers(n, s):\n    count = 0\n    for x in range(s, n + 1):\n        if x - sum(int(digit) for digit in str(x)) >= s:\n            count += 1\n    return count\n\n# Read input\nn, s = map(int, input().split())\n\n# Output the result\nprint(count_really_big_numbers(n, s))"}
{"solution": "def can_cover_with_two_lines(n, points):\n    if n <= 2:\n        return \"YES\"\n    \n    # Function to check if all points lie on the same line\n    def is_collinear(p1, p2, p3):\n        return (p1[0] - p2[0]) * (p1[1] - p3[1]) == (p1[0] - p3[0]) * (p1[1] - p2[1])\n    \n    # Try all combinations of three points to find two lines\n    for i in range(3):\n        collinear_points = set()\n        for j in range(n):\n            if is_collinear(points[i], points[(i+1)%3], points[j]):\n                collinear_points.add(j)\n        \n        # If we found a line that covers all points, return \"YES\"\n        if len(collinear_points) == n:\n            return \"YES\"\n        \n        # Otherwise, try to find a second line among the remaining points\n        remaining_points = [points[k] for k in range(n) if k not in collinear_points]\n        if len(remaining_points) <= 2:\n            return \"YES\"\n        \n        # Check if all remaining points are collinear\n        all_collinear = True\n        for k in range(2, len(remaining_points)):\n            if not is_collinear(remaining_points[0], remaining_points[1], remaining_points[k]):\n                all_collinear = False\n                break\n        \n        if all_collinear:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(can_cover_with_two_lines(n, points))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_winning_games(a, b, k, t):\n    # Calculate the maximum and minimum possible scores after t turns\n    max_score_diff = (2 * k + 1) ** t\n    \n    # Initialize a list to store the number of ways to achieve each score difference\n    dp = [0] * (2 * max_score_diff + 1)\n    dp[max_score_diff] = 1  # There's one way to have a score difference of 0\n    \n    # Dynamic programming to calculate the number of ways to achieve each score difference\n    for _ in range(t):\n        new_dp = [0] * (2 * max_score_diff + 1)\n        for i in range(len(dp)):\n            if dp[i] > 0:\n                for j in range(-k, k + 1):\n                    new_dp[i + j] = (new_dp[i + j] + dp[i]) % MOD\n        dp = new_dp\n    \n    # Calculate the number of ways Memory can end with a strictly higher score than Lexa\n    winning_games = 0\n    for i in range(max_score_diff + 1, len(dp)):\n        score_diff = i - max_score_diff\n        if a + score_diff > b:\n            winning_games = (winning_games + dp[i]) % MOD\n    \n    return winning_games\n\n# Read input\na, b, k, t = map(int, input().split())\n\n# Calculate and print the result\nprint(count_winning_games(a, b, k, t))"}
{"solution": "def min_additional_marks(n, l, x, y, marks):\n    # Function to check if a distance can be measured\n    def can_measure(distance):\n        for mark in marks:\n            if mark + distance in marks or mark - distance in marks:\n                return True\n        return False\n\n    # Check if x and y can already be measured\n    can_measure_x = can_measure(x)\n    can_measure_y = can_measure(y)\n\n    # If both can be measured, no additional marks are needed\n    if can_measure_x and can_measure_y:\n        return 0, []\n\n    # If only one can be measured, add a mark for the other\n    if can_measure_x or can_measure_y:\n        distance_to_add = y if can_measure_x else x\n        for mark in marks:\n            if mark + distance_to_add not in marks and 0 <= mark + distance_to_add <= l:\n                return 1, [mark + distance_to_add]\n            if mark - distance_to_add not in marks and 0 <= mark - distance_to_add <= l:\n                return 1, [mark - distance_to_add]\n\n    # If neither can be measured, try to find a position to add two marks\n    for mark in marks:\n        if mark + x not in marks and 0 <= mark + x <= l:\n            if mark + x + y not in marks and 0 <= mark + x + y <= l:\n                return 1, [mark + x]\n            if mark + x - y not in marks and 0 <= mark + x - y <= l:\n                return 1, [mark + x]\n        if mark - x not in marks and 0 <= mark - x <= l:\n            if mark - x + y not in marks and 0 <= mark - x + y <= l:\n                return 1, [mark - x]\n            if mark - x - y not in marks and 0 <= mark - x - y <= l:\n                return 1, [mark - x]\n        if mark + y not in marks and 0 <= mark + y <= l:\n            if mark + y + x not in marks and 0 <= mark + y + x <= l:\n                return 1, [mark + y]\n            if mark + y - x not in marks and 0 <= mark + y - x <= l:\n                return 1, [mark + y]\n        if mark - y not in marks and 0 <= mark - y <= l:\n            if mark - y + x not in marks and 0 <= mark - y + x <= l:\n                return 1, [mark - y]\n            if mark - y - x not in marks and 0 <= mark - y - x <= l:\n                return 1, [mark - y]\n\n    # If no optimal solution is found, add two marks for x and y\n    return 2, [x, y]\n\n# Read input\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Get the result\nnum_marks_to_add, new_marks = min_additional_marks(n, l, x, y, marks)\n\n# Print the result\nprint(num_marks_to_add)\nif num_marks_to_add > 0:\n    print(' '.join(map(str, new_marks)))"}
{"solution": "def max_cake_volume(n, cakes):\n    # Calculate the volume of each cake\n    volumes = [cake[0]**2 * cake[1] for cake in cakes]\n    \n    # Initialize a list to store the maximum volume achievable up to each cake\n    max_volumes = [0] * n\n    max_volumes[0] = volumes[0]\n    \n    # Dynamic programming to find the maximum volume\n    for i in range(1, n):\n        max_volumes[i] = volumes[i]\n        for j in range(i):\n            if volumes[j] < volumes[i]:\n                max_volumes[i] = max(max_volumes[i], max_volumes[j] + volumes[i])\n    \n    # The maximum volume is the highest value in max_volumes\n    return max(max_volumes) * 3.141592653589793\n\n# Read input\nn = int(input())\ncakes = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the maximum volume\nprint(\"{:.9f}\".format(max_cake_volume(n, cakes)))"}
{"solution": "def min_good_slices(n, k, heights):\n    # Sort the heights to easily find the cost of slicing at each possible height\n    heights.sort()\n    \n    # Initialize variables to keep track of the total cost and the number of good slices\n    total_cost = 0\n    good_slices = 0\n    \n    # Use a two-pointer technique to find the minimum number of good slices\n    left = 0\n    right = 0\n    \n    while right < n:\n        # Calculate the cost of slicing at the current height (heights[right])\n        if right > 0:\n            total_cost += (heights[right] - heights[right - 1]) * (right - left)\n        \n        # If the cost exceeds k, move the left pointer to the right to reduce the cost\n        while total_cost > k:\n            total_cost -= heights[right] - heights[left]\n            left += 1\n        \n        # A good slice is found, increment the count\n        good_slices += 1\n        right += 1\n    \n    return good_slices\n\n# Read input\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_good_slices(n, k, heights))"}
{"solution": "def max_score(n, a):\n    # Calculate prefix sums\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n    \n    max_score = float('-inf')\n    \n    # Iterate over all possible segments [l, r]\n    for l in range(n):\n        max_in_segment = float('-inf')\n        for r in range(l, n):\n            # Update the maximum value in the current segment\n            max_in_segment = max(max_in_segment, a[r])\n            # Calculate the sum of the current segment\n            segment_sum = prefix_sum[r + 1] - prefix_sum[l]\n            # Calculate the score after Bob removes the max value\n            score = segment_sum - max_in_segment\n            # Update the maximum score\n            max_score = max(max_score, score)\n    \n    return max_score\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_score(n, a))"}
{"solution": "def can_garlands_be_lit(k1, k2, k3):\n    # Sort the intervals to simplify the logic\n    intervals = sorted([k1, k2, k3])\n    \n    # Check if the smallest two intervals are 1 and 2, or if the smallest interval is 1 and the sum of the other two is less than or equal to 3\n    if (intervals[0] == 1 and intervals[1] == 2) or (intervals[0] == 1 and intervals[1] + intervals[2] <= 3):\n        return \"YES\"\n    \n    # Check if any two intervals are the same and the third one is less than or equal to 2\n    if (k1 == k2 and k3 <= 2) or (k1 == k3 and k2 <= 2) or (k2 == k3 and k1 <= 2):\n        return \"YES\"\n    \n    # Check if all intervals are the same and equal to 1\n    if k1 == k2 == k3 == 1:\n        return \"YES\"\n    \n    # If none of the above conditions are met, it's not possible\n    return \"NO\"\n\n# Read input\nk1, k2, k3 = map(int, input().split())\n\n# Output result\nprint(can_garlands_be_lit(k1, k2, k3))"}
{"solution": "def min_operations_to_delete_string(n, s):\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = 1\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j-1]\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n    \n    return dp[0][n-1]\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Print output\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "def max_pairs(boys, girls):\n    boys.sort()\n    girls.sort()\n    pairs = 0\n    i, j = 0, 0\n\n    while i < len(boys) and j < len(girls):\n        if abs(boys[i] - girls[j]) <= 1:\n            pairs += 1\n            i += 1\n            j += 1\n        elif boys[i] < girls[j]:\n            i += 1\n        else:\n            j += 1\n\n    return pairs\n\n# Read input\nn = int(input())\nboys_skills = list(map(int, input().split()))\nm = int(input())\ngirls_skills = list(map(int, input().split()))\n\n# Output the result\nprint(max_pairs(boys_skills, girls_skills))"}
{"solution": "def determine_winner(a1, b1, a2, b2, a3, b3, a4, b4):\n    # Possible configurations for Team 1\n    team1_configs = [\n        ((a1, b1), (a2, b2)),  # Player 1 in attack, Player 2 in defense\n        ((a2, b2), (a1, b1))   # Player 2 in attack, Player 1 in defense\n    ]\n    \n    # Possible configurations for Team 2\n    team2_configs = [\n        ((a3, b3), (a4, b4)),  # Player 3 in attack, Player 4 in defense\n        ((a4, b4), (a3, b3))   # Player 4 in attack, Player 3 in defense\n    ]\n    \n    for (team1_attack, team1_defense) in team1_configs:\n        for (team2_attack, team2_defense) in team2_configs:\n            if team1_defense > team2_attack and team1_attack > team2_defense:\n                return \"Team 1\"\n            if team2_defense > team1_attack and team2_attack > team1_defense:\n                return \"Team 2\"\n    \n    return \"Draw\"\n\n# Read input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\na4, b4 = map(int, input().split())\n\n# Determine the winner\nprint(determine_winner(a1, b1, a2, b2, a3, b3, a4, b4))"}
{"solution": "import sys\nimport math\n\ndef read_input():\n    N, K = map(int, input().split())\n    meats = [list(map(int, input().split())) for _ in range(N)]\n    return N, K, meats\n\ndef calculate_time(X, Y, meat):\n    x_i, y_i, c_i = meat\n    return c_i * math.sqrt((X - x_i) ** 2 + (Y - y_i) ** 2)\n\ndef find_optimal_heat_source(N, K, meats):\n    # Define the search space for X and Y\n    search_space = (-1000, 1000)\n    precision = 1e-6\n    step = 100\n\n    while step > precision:\n        min_time = float('inf')\n        best_X, best_Y = None, None\n\n        for X in range(search_space[0], search_space[1], step):\n            for Y in range(search_space[0], search_space[1], step):\n                times = [calculate_time(X, Y, meat) for meat in meats]\n                times.sort()\n                current_time = times[K - 1]\n\n                if current_time < min_time:\n                    min_time = current_time\n                    best_X, best_Y = X, Y\n\n        # Refine the search space around the best found point\n        search_space = (best_X - step, best_X + step, best_Y - step, best_Y + step)\n        step /= 10\n\n    return min_time\n\ndef main():\n    N, K, meats = read_input()\n    result = find_optimal_heat_source(N, K, meats)\n    print(f\"{result:.6f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def determine_winner(n, ticket):\n    # Initialize counters for the sums of the first and second halves\n    sum_first_half = 0\n    sum_second_half = 0\n    # Counters for the number of erased digits in each half\n    erased_first_half = 0\n    erased_second_half = 0\n\n    # Calculate the sums and counts of erased digits for each half\n    for i in range(n // 2):\n        if ticket[i] != '?':\n            sum_first_half += int(ticket[i])\n        else:\n            erased_first_half += 1\n        if ticket[n // 2 + i] != '?':\n            sum_second_half += int(ticket[n // 2 + i])\n        else:\n            erased_second_half += 1\n\n    # Calculate the difference in sums and the net number of erased digits\n    sum_diff = sum_first_half - sum_second_half\n    net_erased = erased_first_half - erased_second_half\n\n    # Determine the winner based on the optimal play\n    if net_erased == 0:\n        return \"Bicarp\" if sum_diff == 0 else \"Monocarp\"\n    elif net_erased > 0:\n        # Monocarp has more opportunities to make the sum different\n        return \"Monocarp\" if sum_diff <= 9 * net_erased else \"Bicarp\"\n    else:\n        # Bicarp has more opportunities to make the sum equal\n        return \"Monocarp\" if sum_diff >= -9 * net_erased else \"Bicarp\"\n\n# Read input\nn = int(input())\nticket = input()\n\n# Determine and print the winner\nprint(determine_winner(n, ticket))"}
{"solution": "def find_bus_route(n, t, bus_routes):\n    earliest_time = float('inf')\n    chosen_route = -1\n    \n    for i in range(n):\n        s_i, d_i = bus_routes[i]\n        \n        if s_i >= t:\n            next_bus_time = s_i\n        else:\n            # Calculate the next bus time after t\n            if (t - s_i) % d_i == 0:\n                next_bus_time = t\n            else:\n                next_bus_time = s_i + ((t - s_i) // d_i + 1) * d_i\n        \n        if next_bus_time < earliest_time:\n            earliest_time = next_bus_time\n            chosen_route = i + 1\n    \n    return chosen_route\n\n# Read input\nn, t = map(int, input().split())\nbus_routes = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(find_bus_route(n, t, bus_routes))"}
{"solution": "def find_n(m, k):\n    # Initialize n to a value that will be adjusted based on the conditions\n    n = 1\n    \n    # Function to count numbers with exactly k '1's in their binary representation within a range\n    def count_numbers_with_k_ones(start, end, k):\n        count = 0\n        for number in range(start, end + 1):\n            if bin(number).count('1') == k:\n                count += 1\n        return count\n    \n    # Increment n until we find a range that satisfies the condition\n    while True:\n        if count_numbers_with_k_ones(n + 1, 2 * n, k) == m:\n            return n\n        n += 1\n\n# Example usage:\n# m, k = map(int, input().split())\n# print(find_n(m, k))"}
{"solution": "def is_good_level(n, level_scheme):\n    # Iterate through the level scheme to find sequences of platforms\n    for i in range(n):\n        # Check if there's enough space for a sequence of 5 platforms with equal intervals\n        for interval in range(1, (n - i) // 4 + 1):\n            if all(level_scheme[i + j * interval] == '*' for j in range(5)):\n                return \"yes\"\n    return \"no\"\n\n# Read input\nn = int(input())\nlevel_scheme = input()\n\n# Check if the level is good and print the result\nprint(is_good_level(n, level_scheme))"}
{"solution": "def find_magic_square_number(n, grid):\n    # Find the position of the empty cell\n    empty_row, empty_col = None, None\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                empty_row, empty_col = i, j\n                break\n        if empty_row is not None:\n            break\n\n    # Calculate the target sum by summing up a row or column that doesn't contain the empty cell\n    target_sum = sum(grid[empty_row - 1]) if empty_row > 0 else sum(grid[empty_row + 1])\n\n    # Calculate the current sum of the row with the empty cell\n    current_sum = sum(grid[empty_row])\n\n    # The number to fill in is the difference between the target sum and the current sum\n    x = target_sum - current_sum\n\n    # Check if the number is positive and within the given constraints\n    if x <= 0 or x > 10**18:\n        return -1\n\n    # Place the number in the grid to check if it forms a magic square\n    grid[empty_row][empty_col] = x\n\n    # Verify the magic square properties\n    for i in range(n):\n        if sum(grid[i]) != target_sum or sum(grid[j][i] for j in range(n)) != target_sum:\n            return -1\n    if sum(grid[i][i] for i in range(n)) != target_sum or sum(grid[i][n - i - 1] for i in range(n)) != target_sum:\n        return -1\n\n    return x\n\n# Read input\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\n# Find and print the result\nprint(find_magic_square_number(n, grid))"}
{"solution": "import math\n\ndef calculate_min_max_k(n, m, a):\n    max_k = max(a) + m\n    total_people = sum(a) + m\n    min_k = math.ceil(total_people / n)\n    return min_k, max_k\n\n# Read input\nn = int(input())\nm = int(input())\na = [int(input()) for _ in range(n)]\n\n# Calculate and print the result\nmin_k, max_k = calculate_min_max_k(n, m, a)\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, m):\n    # Initialize the result as 1 (identity for multiplication)\n    result = 1\n    \n    # Calculate the number of ways to assign seats and entrances\n    for i in range(1, m + 1):\n        # Each passenger can be assigned any of the n seats\n        result = (result * n) % MOD\n        # Each passenger can choose either the front or back entrance\n        result = (result * 2) % MOD\n    \n    return result\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(count_ways(n, m))"}
{"solution": "from itertools import combinations\nfrom collections import defaultdict\n\ndef read_input():\n    n, m = map(int, input().split())\n    friends_preferences = [set(map(int, input().split()[1:])) for _ in range(n)]\n    pizzas = [list(map(int, input().split())) for _ in range(m)]\n    return n, m, friends_preferences, pizzas\n\ndef solve(n, m, friends_preferences, pizzas):\n    pizza_ingredients = [(set(p[2:]), p[0]) for p in pizzas]\n    max_pleased = 0\n    min_cost = float('inf')\n    best_pair = None\n\n    for (i, (ingredients1, cost1)), (j, (ingredients2, cost2)) in combinations(enumerate(pizza_ingredients), 2):\n        combined_ingredients = ingredients1 | ingredients2\n        pleased_friends = sum(all(pref.intersection(combined_ingredients) for pref in friends_preferences) for pref in friends_preferences)\n        \n        if pleased_friends > max_pleased or (pleased_friends == max_pleased and cost1 + cost2 < min_cost):\n            max_pleased = pleased_friends\n            min_cost = cost1 + cost2\n            best_pair = (i + 1, j + 1)\n\n    return best_pair\n\ndef main():\n    n, m, friends_preferences, pizzas = read_input()\n    result = solve(n, m, friends_preferences, pizzas)\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_numbers(m, s):\n    if s == 0:\n        return \"-1 -1\" if m > 1 else \"0 0\"\n    \n    if s > 9 * m:\n        return \"-1 -1\"\n    \n    # Find the smallest number\n    smallest = []\n    sum_digits = s\n    for i in range(m):\n        for digit in range(10):\n            if (i > 0 or digit > 0) and (sum_digits - digit <= 9 * (m - i - 1)):\n                smallest.append(str(digit))\n                sum_digits -= digit\n                break\n    \n    # Find the largest number\n    largest = []\n    sum_digits = s\n    for i in range(m):\n        for digit in range(9, -1, -1):\n            if (i > 0 or digit > 0) and (sum_digits - digit >= 0):\n                largest.append(str(digit))\n                sum_digits -= digit\n                break\n    \n    return ''.join(smallest) + ' ' + ''.join(largest)\n\n# Read input\nm, s = map(int, input().split())\n\n# Print output\nprint(find_numbers(m, s))"}
{"solution": "MOD = 998244353\n\ndef count_digits(n):\n    return len(set(str(n)))\n\ndef sum_with_constraints(l, r, k):\n    total_sum = 0\n    for number in range(l, r + 1):\n        if count_digits(number) <= k:\n            total_sum += number\n            total_sum %= MOD\n    return total_sum\n\n# Read input\nl, r, k = map(int, input().split())\n\n# Calculate and print the result\nprint(sum_with_constraints(l, r, k))"}
{"solution": "def can_distribute_pencils(n, k, d, saturations):\n    # Sort the saturations to make it easier to check the difference condition\n    saturations.sort()\n    \n    # Initialize a dynamic programming array to keep track of possible distributions\n    dp = [False] * (n + 1)\n    dp[0] = True  # Base case: 0 pencils can be distributed trivially\n    \n    # Iterate over the pencils\n    for i in range(1, n + 1):\n        # Check if we can start a new box with the current pencil as the first one\n        if not dp[i - 1]:\n            continue\n        \n        # Try to form a box starting from the current pencil\n        for j in range(i, n + 1):\n            if j - i + 1 >= k and (i == 1 or saturations[j - 1] - saturations[i - 2] <= d):\n                dp[j] = True\n                break\n    \n    # The answer is whether we can distribute all pencils (dp[n] is True)\n    return \"YES\" if dp[n] else \"NO\"\n\n# Read input\nn, k, d = map(int, input().split())\nsaturations = list(map(int, input().split()))\n\n# Output the result\nprint(can_distribute_pencils(n, k, d, saturations))"}
{"solution": "def count_dead_bulbs(garland):\n    # Initialize a dictionary to store the count of dead bulbs for each color\n    dead_bulbs = {'R': 0, 'B': 0, 'Y': 0, 'G': 0}\n    \n    # Initialize a dictionary to store the positions of working bulbs for each color\n    positions = {'R': None, 'B': None, 'Y': None, 'G': None}\n    \n    # Find the positions of working bulbs for each color\n    for i, bulb in enumerate(garland):\n        if bulb in positions:\n            positions[bulb] = i % 4\n    \n    # Count the dead bulbs based on the positions of working bulbs\n    for i, bulb in enumerate(garland):\n        if bulb == '!':\n            for color, pos in positions.items():\n                if i % 4 == pos:\n                    dead_bulbs[color] += 1\n                    break\n    \n    # Return the count of dead bulbs for each color\n    return dead_bulbs['R'], dead_bulbs['B'], dead_bulbs['Y'], dead_bulbs['G']\n\n# Read input\ngarland = input().strip()\n\n# Get the count of dead bulbs for each color\nkr, kb, ky, kg = count_dead_bulbs(garland)\n\n# Print the result\nprint(kr, kb, ky, kg)"}
{"solution": "import sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    # Initialize distances with infinity\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heapq.heappush(pq, (dist[v], v))\n    return dist\n\ndef main():\n    input = sys.stdin.readline\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    reverse_graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        s, t = map(int, input().split())\n        graph[s].append((t, 1))\n        reverse_graph[t].append((s, 1))\n\n    # Calculate the shortest path from Room 1 to all other rooms\n    dist_to_exit = dijkstra(graph, 1, n)\n    # Calculate the shortest path from each room to Room N\n    dist_to_entrance = dijkstra(reverse_graph, n, n)\n\n    # Calculate the expected number of passages without blocking any\n    expected_passages = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if dist_to_exit[i] != float('inf'):\n            expected_passages[i] = dist_to_exit[i] + sum(1 / len(graph[j]) for j in range(1, i) if dist_to_exit[j] + 1 == dist_to_exit[i])\n\n    # Find the minimum expected number of passages by blocking one passage\n    min_expected = expected_passages[n]\n    for u in range(1, n + 1):\n        if not graph[u]:\n            continue\n        for v, _ in graph[u]:\n            if dist_to_exit[u] + 1 == dist_to_exit[v]:\n                # Temporarily block this passage and recalculate the expected number of passages\n                temp_graph = [graph[i][:] for i in range(n + 1)]\n                temp_graph[u] = [x for x in temp_graph[u] if x[0] != v]\n                temp_dist_to_exit = dijkstra(temp_graph, 1, n)\n                if temp_dist_to_exit[n] == float('inf'):\n                    continue\n                temp_expected = temp_dist_to_exit[n] + sum(1 / len(temp_graph[j]) for j in range(1, n) if temp_dist_to_exit[j] + 1 == temp_dist_to_exit[n])\n                min_expected = min(min_expected, temp_expected)\n\n    print(f\"{min_expected:.10f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def round_to_nearest_zero(n):\n    if n % 10 == 0:\n        return n\n    lower = n - n % 10\n    upper = lower + 10\n    return lower if n - lower <= upper - n else upper\n\n# Assuming the input is provided through a standard input method (e.g., input() function in Python)\nn = int(input())\nprint(round_to_nearest_zero(n))"}
{"solution": "def find_swaps(s, t):\n    if len(s) != len(t):\n        return -1\n    \n    mismatches = {}\n    \n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if s[i] in mismatches and mismatches[s[i]] != t[i]:\n                return -1\n            if t[i] in mismatches and mismatches[t[i]] != s[i]:\n                return -1\n            mismatches[s[i]] = t[i]\n            mismatches[t[i]] = s[i]\n    \n    visited = set()\n    swaps = []\n    \n    for key in mismatches:\n        if key not in visited:\n            cycle = []\n            current = key\n            while current not in visited:\n                visited.add(current)\n                cycle.append(current)\n                current = mismatches[current]\n            if len(cycle) != 2:\n                return -1\n            swaps.append((cycle[0], cycle[1]))\n    \n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0], swap[1])"}
{"solution": "def alphabetically_earliest_login(first_name, last_name):\n    earliest_login = None\n    for i in range(1, len(first_name) + 1):\n        for j in range(1, len(last_name) + 1):\n            login = first_name[:i] + last_name[:j]\n            if earliest_login is None or login < earliest_login:\n                earliest_login = login\n    return earliest_login\n\n# Assuming the input is provided in the format specified\nfirst_name, last_name = input().split()\nprint(alphabetically_earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(sequence):\n    n = len(sequence)\n    height = 0\n    current_height = 0\n    max_height = 0\n\n    # Calculate the height of the output\n    for bracket in sequence:\n        if bracket == '[':\n            current_height += 1\n            max_height = max(max_height, current_height)\n        else:\n            current_height -= 1\n    height = max_height * 2 - 1\n\n    # Initialize the output matrix\n    output = [[' ' for _ in range(n * 4)] for _ in range(height)]\n\n    # Function to draw a single bracket\n    def draw_bracket(x, y, is_open):\n        nonlocal output\n        for i in range(height // 2):\n            output[i][y] = '|'\n            output[height - 1 - i][y] = '|'\n        output[height // 2][y] = '+'\n        if is_open:\n            output[height // 2][y + 1] = '-'\n            output[height // 2][y + 2] = '-'\n            output[height // 2][y + 3] = '+'\n        else:\n            output[height // 2][y - 1] = '+'\n            output[height // 2][y - 2] = '-'\n            output[height // 2][y - 3] = '-'\n\n    # Draw the sequence\n    x, y = 0, 0\n    for i in range(n):\n        if sequence[i] == '[':\n            draw_bracket(x, y, True)\n            y += 4\n        else:\n            y -= 4\n            draw_bracket(x, y + 3, False)\n\n    # Print the output\n    for row in output:\n        print(''.join(row).rstrip())\n\n# Example usage:\n# draw_brackets(\"[[][]][]\")"}
{"solution": "def normalize_golden_number(golden_number):\n    golden_number = list(map(int, golden_number))\n    n = len(golden_number)\n    \n    for i in range(n - 1, 0, -1):\n        if golden_number[i] > 1:\n            golden_number[i] -= 2\n            golden_number[i - 1] += 1\n            if i - 2 >= 0:\n                golden_number[i - 2] += 1\n    \n    while len(golden_number) > 1 and golden_number[0] == 0:\n        golden_number.pop(0)\n    \n    return golden_number\n\ndef compare_golden_numbers(num1, num2):\n    norm_num1 = normalize_golden_number(num1)\n    norm_num2 = normalize_golden_number(num2)\n    \n    if len(norm_num1) > len(norm_num2):\n        return \">\"\n    elif len(norm_num1) < len(norm_num2):\n        return \"<\"\n    \n    for digit1, digit2 in zip(norm_num1, norm_num2):\n        if digit1 > digit2:\n            return \">\"\n        elif digit1 < digit2:\n            return \"<\"\n    \n    return \"=\"\n\nnum1 = input().strip()\nnum2 = input().strip()\n\nresult = compare_golden_numbers(num1, num2)\nprint(result)"}
{"solution": "def determine_absent_gems(n, seen_colors):\n    all_gems = {\n        \"purple\": \"Power\",\n        \"green\": \"Time\",\n        \"blue\": \"Space\",\n        \"orange\": \"Soul\",\n        \"red\": \"Reality\",\n        \"yellow\": \"Mind\"\n    }\n    \n    # Determine the absent colors by subtracting seen colors from all colors\n    absent_colors = set(all_gems.keys()) - set(seen_colors)\n    \n    # Convert absent colors to their corresponding gem names\n    absent_gems = [all_gems[color] for color in absent_colors]\n    \n    return len(absent_gems), absent_gems\n\n# Read input\nn = int(input().strip())\nseen_colors = [input().strip() for _ in range(n)]\n\n# Determine and print the output\nm, absent_gems = determine_absent_gems(n, seen_colors)\nprint(m)\nfor gem in absent_gems:\n    print(gem)"}
{"solution": "def determine_meeting_round(n, a, b):\n    round_number = 1\n    while n > 1:\n        # Check if a and b are in the same pair in the current round\n        if (a + 1) // 2 == (b + 1) // 2:\n            break\n        # Move to the next round\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n //= 2\n        round_number += 1\n    \n    # If the round is the final one\n    if n == 2:\n        return \"Final!\"\n    else:\n        return round_number\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Output the result\nprint(determine_meeting_round(n, a, b))"}
{"solution": "def min_changes_to_permutation_and_sequence(n, p, b):\n    # Check if the permutation is already a cycle that visits all positions\n    visited = [False] * n\n    cycles = []\n    for i in range(n):\n        if not visited[i]:\n            cycle = []\n            while not visited[i]:\n                visited[i] = True\n                cycle.append(i)\n                i = p[i] - 1\n            cycles.append(cycle)\n    \n    # If there's only one cycle and all elements in b are 0, we need to change one element in b\n    if len(cycles) == 1 and all(x == 0 for x in b):\n        return 1\n    \n    # If there are multiple cycles, we need to change the permutation to form a single cycle\n    # and ensure that at least one element in b is 1 to reverse a skewer\n    changes = 0\n    if len(cycles) > 1:\n        changes += len(cycles) - 1  # Merge cycles to form a single cycle\n    if all(x == 0 for x in b):\n        changes += 1  # Ensure at least one reversal\n    \n    return changes\n\n# Read input\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_changes_to_permutation_and_sequence(n, p, b))"}
{"solution": "def max_path_length(v_1, v_2, t, d):\n    # Initialize the path length\n    path_length = 0\n    \n    # Calculate the speeds for each second from the start to the end\n    for i in range(t):\n        # Calculate the maximum speed possible at the current second\n        # from both the start and the end\n        current_speed = min(v_1 + i * d, v_2 + (t - i - 1) * d)\n        # Add the current speed to the total path length\n        path_length += current_speed\n    \n    return path_length\n\n# Read input\nv_1, v_2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Calculate and print the maximum possible length of the path segment\nprint(max_path_length(v_1, v_2, t, d))"}
{"solution": "from itertools import permutations\n\ndef can_cross_bridge(N, M, weights, bridge_parts):\n    def check_arrangement(arrangement, distances):\n        for l, v in bridge_parts:\n            max_weight_in_part = 0\n            for i in range(N - 1):\n                for j in range(i + 1, N):\n                    if distances[i] < l and distances[j] - distances[i] < l:\n                        max_weight_in_part = max(max_weight_in_part, sum(weights[arrangement[k] - 1] for k in range(i, j + 1))))\n            if max_weight_in_part > v:\n                return False\n        return True\n\n    min_distance = float('inf')\n    for arrangement in permutations(range(1, N + 1)):\n        low, high = 0, sum(l for l, _ in bridge_parts)\n        while low < high:\n            mid = (low + high) // 2\n            distances = [0] + [mid // (N - 1)] * (N - 1)\n            if check_arrangement(arrangement, distances):\n                high = mid\n                min_distance = min(min_distance, mid)\n            else:\n                low = mid + 1\n\n    return min_distance if min_distance != float('inf') else -1\n\n# Read input\nN, M = map(int, input().split())\nweights = list(map(int, input().split()))\nbridge_parts = [tuple(map(int, input().split())) for _ in range(M)]\n\n# Output result\nprint(can_cross_bridge(N, M, weights, bridge_parts))"}
{"solution": "def last_digit_of_phoenix_reincarnations(a, b):\n    # If a is 0, then a! is 1, and any b! divided by 1 is b!, which ends in 0 for b >= 5\n    if a == 0:\n        return 0\n    # If b is greater than a, then b! will include a! as a factor, so b!/a! is an integer\n    # and the last digit of a! will be 0 for a >= 5\n    if b > a:\n        return 0\n    # If a and b are equal, then the result is simply the last digit of a!\n    if a == b:\n        # The last digit of factorials for a >= 5 is 0, but for smaller a, we can calculate\n        last_digit = 1\n        for i in range(1, a + 1):\n            last_digit *= i\n            last_digit %= 10\n        return last_digit\n    # If b is less than a, we need to find the last digit of (a!/b!) which is a complex calculation\n    # However, since we are only interested in the last digit, we can observe that the last digit\n    # of factorials cycles every 10 numbers. Therefore, we only need to consider the last digit of a and b.\n    last_digit_a = a % 10\n    last_digit_b = b % 10\n    # Since b < a, and we are only interested in the last digit, we can simplify the problem\n    # by noting that the last digit of the quotient of two factorials where b < a will cycle\n    # based on the last digit of a and the difference between a and b.\n    # For simplicity, we can assume the last digit of the quotient is the same as the last digit of a.\n    return last_digit_a\n\n# Read input\na, b = map(int, input().split())\n\n# Output the last digit\nprint(last_digit_of_phoenix_reincarnations(a, b))"}
{"solution": "from collections import deque\n\ndef min_jumps_to_home(n, d, s):\n    # Initialize a queue for BFS with starting point and jump count\n    queue = deque([(1, 0)])\n    visited = [False] * (n + 1)\n    visited[1] = True\n    \n    while queue:\n        current, jumps = queue.popleft()\n        \n        # Check all possible jumps from the current position\n        for jump in range(1, d + 1):\n            next_point = current + jump\n            \n            # If the next point is the home, return the jumps count + 1\n            if next_point == n:\n                return jumps + 1\n            \n            # If the next point has a lily and hasn't been visited, enqueue it\n            if next_point <= n and s[next_point - 1] == '1' and not visited[next_point]:\n                visited[next_point] = True\n                queue.append((next_point, jumps + 1))\n    \n    # If the queue is empty and the home hasn't been reached, return -1\n    return -1\n\n# Read input\nn, d = map(int, input().split())\ns = input()\n\n# Output the result\nprint(min_jumps_to_home(n, d, s))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_counterexample(n):\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\n# Read input\nn = int(input().strip())\n\n# Find and print the counterexample\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all_coins(n):\n    # Define the costs of houses, cars, and computers\n    house_cost = 1234567\n    car_cost = 123456\n    computer_cost = 1234\n    \n    # Iterate over possible number of houses\n    for a in range(n // house_cost + 1):\n        remaining_after_houses = n - a * house_cost\n        \n        # Iterate over possible number of cars after buying houses\n        for b in range(remaining_after_houses // car_cost + 1):\n            remaining_after_cars = remaining_after_houses - b * car_cost\n            \n            # Check if the remaining amount can be spent on computers\n            if remaining_after_cars % computer_cost == 0:\n                return \"YES\"\n    \n    # If no combination is found, return \"NO\"\n    return \"NO\"\n\n# Read input\nn = int(input().strip())\n\n# Output result\nprint(can_spend_all_coins(n))"}
{"solution": "def find_intersection_in_strip(n, x1, x2, lines):\n    # Sort lines based on their y-values at x1 and x2\n    lines_at_x1 = sorted([(k * x1 + b, i) for i, (k, b) in enumerate(lines)])\n    lines_at_x2 = sorted([(k * x2 + b, i) for i, (k, b) in enumerate(lines)])\n\n    # Check if the order of lines at x1 and x2 is different\n    for i in range(n):\n        if lines_at_x1[i][1] != lines_at_x2[i][1]:\n            return \"Yes\"\n\n    return \"No\"\n\n# Read input\nn = int(input())\nx1, x2 = map(int, input().split())\nlines = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(find_intersection_in_strip(n, x1, x2, lines))"}
{"solution": "def count_different_weights(n):\n    # The maximum weight of a split is n if all elements are 1\n    # The minimum weight of a split is 1 if there's only one element\n    # For any split, the weight is determined by the first element, which can be from 1 to n\n    # However, for weights greater than 2, the split must be nonincreasing, so we need to consider\n    # that the weight cannot exceed n/2 for weights greater than 2.\n    # Therefore, the number of different weights is the number of integers from 1 to n/2 + 1\n    # (including the case where the weight is n itself)\n    return min(n, n // 2 + 1)\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(count_different_weights(n))"}
{"solution": "def find_good_apartments(n, k):\n    if k == 0:\n        min_good = 0\n        max_good = 0\n    else:\n        min_good = 1\n        max_good = min(n - k, 2 * k)\n    \n    return min_good, max_good\n\n# Example usage:\nn, k = 6, 3\nmin_good, max_good = find_good_apartments(n, k)\nprint(min_good, max_good)  # Output: 1 3"}
{"solution": "import math\n\ndef max_games_winner_can_play(n):\n    return math.floor(math.log2(n))\n\n# Read input\nn = int(input())\n\n# Output the result\nprint(max_games_winner_can_play(n))"}
{"solution": "def max_vk_occurrences(s):\n    # Initialize the count of \"VK\" occurrences\n    count = 0\n    # Flag to check if we have made a change\n    changed = False\n    \n    # Iterate through the string to find \"VK\" and potential changes\n    i = 0\n    while i < len(s) - 1:\n        # If we find \"VK\", increment the count and move two steps forward\n        if s[i] == 'V' and s[i + 1] == 'K':\n            count += 1\n            i += 2\n        # If we find \"VV\" and haven't changed yet, and the next character is not 'K'\n        elif s[i] == 'V' and s[i + 1] == 'V' and not changed and (i + 2 >= len(s) or s[i + 2] != 'K'):\n            changed = True\n            count += 1\n            i += 2\n        # If we find \"KK\" and haven't changed yet, and the previous character is not 'V'\n        elif s[i] == 'K' and s[i + 1] == 'K' and not changed and (i == 0 or s[i - 1] != 'V'):\n            changed = True\n            count += 1\n            i += 2\n        else:\n            i += 1\n    \n    return count\n\n# Read input from the user\ns = input().strip()\n\n# Output the result\nprint(max_vk_occurrences(s))"}
{"solution": "import math\n\ndef min_segments(n):\n    a = int(math.sqrt(n))\n    b = (n + a - 1) // a  # This is equivalent to math.ceil(n / a)\n    return a + b + 2\n\n# Read input\nn = int(input().strip())\nprint(min_segments(n))"}
{"solution": "def years_to_outweigh(a, b):\n    years = 0\n    while a <= b:\n        a *= 3\n        b *= 2\n        years += 1\n    return years\n\n# Read input from the user\na, b = map(int, input().split())\n\n# Calculate and print the number of years\nprint(years_to_outweigh(a, b))"}
{"solution": "def count_visited_nodes(h, n):\n    # Initialize the count of visited nodes\n    visited_nodes = 0\n    # Initialize the current level and the current node index\n    current_level = 0\n    current_node_index = 1\n    # Initialize the direction (0 for left, 1 for right)\n    direction = 0\n    \n    # Loop until we reach the desired leaf node\n    while current_level < h:\n        # Calculate the next node index based on the direction\n        next_node_index = current_node_index * 2 if direction == 0 else current_node_index * 2 + 1\n        # Check if the next node is the desired leaf node\n        if next_node_index == n:\n            # If it is, we add the remaining levels to the visited nodes count\n            visited_nodes += (h - current_level)\n            break\n        # If not, we move to the next node and increment the visited nodes count\n        current_node_index = next_node_index\n        visited_nodes += 1\n        # Switch direction\n        direction = 1 - direction\n        # If we have skipped two consecutive commands, go back to the parent node\n        if direction == 0:\n            current_node_index //= 2\n            visited_nodes += 1\n        # Increment the current level\n        current_level += 1\n    \n    return visited_nodes\n\n# Read input\nh, n = map(int, input().split())\n\n# Calculate and print the number of visited nodes\nprint(count_visited_nodes(h, n))"}
{"solution": "def find_pairs(x):\n    pairs = []\n    # We iterate through possible values of n and m to find pairs that satisfy the condition\n    for n in range(1, int(x**0.5) + 1):\n        if x % n == 0:\n            m = x // n\n            # Calculate the number of distinct squares for the current pair (n, m)\n            total_squares = sum((n - i) * (m - i) for i in range(min(n, m)))\n            if total_squares == x:\n                pairs.append((n, m))\n                if n != m:  # Avoid adding the square grid twice\n                    pairs.append((m, n))\n    # Sort the pairs according to the problem's requirements\n    pairs.sort(key=lambda pair: (pair[0], pair[1]))\n    return pairs\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    x = int(data[0])\n    \n    pairs = find_pairs(x)\n    \n    print(len(pairs))\n    for pair in pairs:\n        print(pair[0], pair[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_leap_year(year):\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\ndef check_month_sequence(n, months):\n    month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    for start_month in range(12):\n        for year in range(2):  # Check for both leap and non-leap years\n            valid = True\n            for i in range(n):\n                month_index = (start_month + i) % 12\n                expected_days = month_days[month_index]\n                if month_index == 1 and year == 1:  # February in a leap year\n                    expected_days = 29\n                if months[i] != expected_days:\n                    valid = False\n                    break\n            if valid:\n                return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\nmonths = list(map(int, input().split()))\n\n# Check and print the result\nprint(check_month_sequence(n, months))"}
{"solution": "def find_fraction_sequence(n):\n    # Check if n is even, as we need to find a sequence that sums up to 1 - 1/n\n    if n % 2 == 0:\n        # We can always use n/2 and n/2 as b_i for two fractions to sum up to 1 - 1/n\n        k = 2\n        sequence = [(1, n // 2), (1, n // 2)]\n        return \"YES\", k, sequence\n    else:\n        # If n is odd, we cannot find such a sequence because we need b_i to divide n and be less than n\n        return \"NO\", None, None\n\n# Read input\nn = int(input())\n\n# Find the sequence\nresult, k, sequence = find_fraction_sequence(n)\n\n# Print the result\nprint(result)\nif result == \"YES\":\n    print(k)\n    for fraction in sequence:\n        print(fraction[0], fraction[1])"}
{"solution": "def min_unattractiveness(n, a, b, heights):\n    # Calculate the total area of the fence\n    total_area = sum(heights)\n    \n    # Check if it's possible to paint the fence with the given areas\n    if total_area > a + b:\n        return -1\n    \n    # Initialize the minimum unattractiveness to a large number\n    min_unattractiveness = float('inf')\n    \n    # Try all possible partitions of the fence into red and green parts\n    for red_area in range(a + 1):\n        if red_area <= a and (total_area - red_area) <= b:\n            # Calculate the unattractiveness for this partition\n            unattractiveness = 0\n            current_color = None\n            for i in range(n):\n                if heights[i] <= red_area:\n                    if current_color == 'G':\n                        unattractiveness += heights[i]\n                    current_color = 'R'\n                    red_area -= heights[i]\n                else:\n                    if current_color == 'R':\n                        unattractiveness += heights[i]\n                    current_color = 'G'\n            min_unattractiveness = min(min_unattractiveness, unattractiveness)\n    \n    return min_unattractiveness\n\n# Read input\nn = int(input())\na, b = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_unattractiveness(n, a, b, heights))"}
{"solution": "def find_triangle_points(n, m, k):\n    # Check if it's possible to form a triangle with the given area\n    if 2 * n * m % k != 0:\n        return \"NO\"\n    \n    # Calculate the area of the triangle\n    area = (n * m) // k\n    \n    # Find the factors of k to determine the sides of the rectangle\n    a, b = k, 1\n    for i in range(2, int(k**0.5) + 1):\n        if k % i == 0:\n            a, b = k // i, i\n            break\n    \n    # Determine the dimensions of the rectangle that will form the triangle\n    width, height = n, m\n    if a <= n and b <= m:\n        width, height = a, b\n    elif a <= m and b <= n:\n        width, height = b, a\n    else:\n        # Adjust dimensions if necessary to fit within the bounds\n        if 2 * area <= n * m:\n            for i in range(1, n + 1):\n                if (2 * area) % i == 0 and (2 * area) // i <= m:\n                    width, height = i, (2 * area) // i\n                    break\n        else:\n            return \"NO\"\n    \n    # Calculate the coordinates of the triangle points\n    x1, y1 = 0, 0\n    x2, y2 = width, 0\n    x3, y3 = 0, height\n    \n    return \"YES\\n{} {}\\n{} {}\\n{} {}\".format(x1, y1, x2, y2, x3, y3)\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Output the result\nprint(find_triangle_points(n, m, k))"}
{"solution": "def determine_winner(n, k):\n    # Calculate the total number of moves each player can make\n    total_moves = n // k\n    \n    # Sasha wins if the total number of moves is odd, as he moves first\n    if total_moves % 2 == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input from standard input\nn, k = map(int, input().split())\n\n# Output the result\nprint(determine_winner(n, k))"}
{"solution": "def determine_most_exercised_muscle(n, repetitions):\n    # Initialize counters for each muscle group\n    chest_count = 0\n    biceps_count = 0\n    back_count = 0\n    \n    # Iterate through the repetitions and assign them to the corresponding muscle group\n    for i in range(n):\n        if i % 3 == 0:\n            chest_count += repetitions[i]\n        elif i % 3 == 1:\n            biceps_count += repetitions[i]\n        else:\n            back_count += repetitions[i]\n    \n    # Determine which muscle group has the highest count\n    max_count = max(chest_count, biceps_count, back_count)\n    \n    # Return the corresponding muscle group\n    if max_count == chest_count:\n        return \"chest\"\n    elif max_count == biceps_count:\n        return \"biceps\"\n    else:\n        return \"back\"\n\n# Read input\nn = int(input())\nrepetitions = list(map(int, input().split()))\n\n# Output the result\nprint(determine_most_exercised_muscle(n, repetitions))"}
{"solution": "def min_redos_to_get_five(n, grades):\n    current_sum = sum(grades)\n    target_sum = n * 4.5\n    \n    if current_sum >= target_sum:\n        return 0\n    \n    grades.sort()\n    redos = 0\n    \n    for grade in grades:\n        if current_sum >= target_sum:\n            break\n        current_sum += (5 - grade)\n        redos += 1\n    \n    return redos\n\n# Example usage:\nn = int(input())\ngrades = list(map(int, input().split()))\nprint(min_redos_to_get_five(n, grades))"}
{"solution": "def find_shortest_array(u, v):\n    # If u is greater than v or the parity of u and v is different, no solution exists\n    if u > v or (u % 2 != v % 2):\n        return -1\n    \n    # If u and v are both 0, the array is empty\n    if u == 0 and v == 0:\n        return 0, []\n    \n    # If u equals v, the array contains only one element u\n    if u == v:\n        return 1, [u]\n    \n    # Calculate the half difference between v and u\n    x = (v - u) // 2\n    \n    # If u and x have no bits in common (u & x == 0), the array can be [u + x, x]\n    if u & x == 0:\n        return 2, [u + x, x]\n    \n    # Otherwise, the array is [u, x, x]\n    return 3, [u, x, x]\n\n# Read input\nu, v = map(int, input().split())\n\n# Find the shortest array\nn, array = find_shortest_array(u, v)\n\n# Print the result\nif n == -1:\n    print(n)\nelse:\n    print(n)\n    if n > 0:\n        print(*array)"}
{"solution": "def min_ones_sum(n):\n    count = 0\n    while n > 0:\n        count += n % 10\n        n //= 10\n    return count\n\n# Read input\nn = int(input())\n\n# Output the result\nprint(min_ones_sum(n))"}
{"solution": "def can_reach_treasure(x_1, y_1, x_2, y_2, x, y):\n    # Calculate the differences in coordinates\n    dx = abs(x_2 - x_1)\n    dy = abs(y_2 - y_1)\n    \n    # Check if the differences can be expressed as multiples of x and y\n    if dx % x == 0 and dy % y == 0:\n        # Check if the number of steps in both directions is the same\n        if dx // x == dy // y:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nx_1, y_1, x_2, y_2 = map(int, input().split())\nx, y = map(int, input().split())\n\n# Output the result\nprint(can_reach_treasure(x_1, y_1, x_2, y_2, x, y))"}
{"solution": "from itertools import permutations\n\ndef count_valid_bus_numbers(n):\n    # Convert the number to a string to extract digits\n    digits = list(str(n))\n    \n    # Generate all unique permutations of the digits\n    all_permutations = set(permutations(digits))\n    \n    # Filter out permutations that start with '0'\n    valid_permutations = set()\n    for perm in all_permutations:\n        if perm[0] != '0':\n            valid_permutations.add(perm)\n    \n    # Return the count of valid permutations\n    return len(valid_permutations)\n\n# Read input\nn = int(input().strip())\n\n# Get the count of valid bus numbers\nresult = count_valid_bus_numbers(n)\n\n# Print the result\nprint(result)"}
{"solution": "def max_possible_cost(a, b, c, d, e, f):\n    # Calculate the maximum number of suits of each type that can be made\n    max_first_type = min(a, d)\n    max_second_type = min(b, c, d)\n    \n    # Initialize the maximum cost\n    max_cost = 0\n    \n    # Determine the optimal strategy based on the costs of the suits\n    if e > f:\n        # Prioritize making suits of the first type\n        suits_first_type = min(max_first_type, d)\n        max_cost += suits_first_type * e\n        d -= suits_first_type\n        max_cost += min(max_second_type, d) * f\n    else:\n        # Prioritize making suits of the second type\n        suits_second_type = min(max_second_type, d)\n        max_cost += suits_second_type * f\n        d -= suits_second_type\n        max_cost += min(max_first_type, d) * e\n    \n    return max_cost\n\n# Read input\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\n# Calculate and print the maximum possible cost\nprint(max_possible_cost(a, b, c, d, e, f))"}
{"solution": "def solve(a, b, p, x):\n    count = 0\n    a_inv = pow(a, p - 2, p)  # Fermat's Little Theorem for modular inverse\n    current = b\n    \n    for n in range(1, p):\n        if current <= x and (n * p + current) % p == 0:\n            count += 1\n        current = (current * a_inv) % p\n    \n    return count\n\n# Read input\na, b, p, x = map(int, input().split())\n\n# Output the result\nprint(solve(a, b, p, x))"}
{"solution": "def max_possible_sum(k_2, k_3, k_5, k_6):\n    # First, try to form as many 256 as possible\n    count_256 = min(k_2, k_5, k_6)\n    k_2 -= count_256\n    k_5 -= count_256\n    k_6 -= count_256\n    \n    # Then, try to form as many 32 as possible with the remaining 2's and 3's\n    count_32 = min(k_2, k_3)\n    \n    # Calculate the total sum\n    total_sum = count_256 * 256 + count_32 * 32\n    \n    return total_sum\n\n# Read input\nk_2, k_3, k_5, k_6 = map(int, input().split())\n\n# Calculate and print the result\nprint(max_possible_sum(k_2, k_3, k_5, k_6))"}
{"solution": "def calculate_seconds_to_happiness(n, x, y, c):\n    # Directions for side-adjacent cells: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Function to count the number of switched on cells after a given number of seconds\n    def count_switched_on_cells(seconds):\n        # Initialize the queue with the initial switched on cell\n        queue = [(x - 1, y - 1)]\n        visited = set(queue)\n        for _ in range(seconds):\n            new_queue = []\n            for row, col in queue:\n                for dx, dy in directions:\n                    new_row, new_col = row + dx, col + dy\n                    if 0 <= new_row < n and 0 <= new_col < n and (new_row, new_col) not in visited:\n                        visited.add((new_row, new_col))\n                        new_queue.append((new_row, new_col))\n            queue = new_queue\n        return len(visited)\n    \n    # Binary search to find the minimum number of seconds needed\n    left, right = 0, 2 * n\n    while left < right:\n        mid = (left + right) // 2\n        if count_switched_on_cells(mid) >= c:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Read input\nn, x, y, c = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_seconds_to_happiness(n, x, y, c))"}
{"solution": "def max_xor(l, r):\n    x = l ^ r\n    significant_bit = 0\n    while x:\n        significant_bit += 1\n        x >>= 1\n    return (1 << significant_bit) - 1\n\n# Read input\nl, r = map(int, input().split())\n\n# Output the result\nprint(max_xor(l, r))"}
{"solution": "def minimum_height(n, k):\n    left, right = 1, k  # The height cannot be more than k because the area is k\n    \n    while left < right:\n        mid = (left + right) // 2\n        if n * mid >= k:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Read input\nn, k = map(int, input().split())\n\n# Output the result\nprint(minimum_height(n, k))"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    stairs_time = abs(x - y) * t1\n    \n    elevator_to_masha_time = abs(z - x) * t2 + t3\n    elevator_to_egor_time = abs(x - y) * t2 + 2 * t3\n    elevator_time = elevator_to_masha_time + elevator_to_egor_time\n    \n    if stairs_time < elevator_time:\n        return \"NO\"\n    else:\n        return \"YES\"\n\n# Example usage:\nx, y, z, t1, t2, t3 = map(int, input().split())\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "def optimal_a(n, m):\n    # If Misha's number is in the first half of the range, Andrew should choose the maximum possible number\n    if m <= n // 2:\n        return n\n    # Otherwise, Andrew should choose the minimum possible number\n    else:\n        return 1\n\n# Read input\nn, m = map(int, input().split())\n\n# Output the optimal value for a\nprint(optimal_a(n, m))"}
{"solution": "def calculate_pairs_at_university(n, schedule):\n    pairs_at_university = 0\n    i = 0\n    while i < n:\n        if schedule[i] == 1:\n            pairs_at_university += 1\n            if i > 0 and schedule[i - 1] == 0:\n                # Check if the previous pair was a break of at least two pairs\n                if i > 1 and schedule[i - 2] == 0:\n                    # Alena goes home, skip the break\n                    i += 1\n            i += 1\n        else:\n            i += 1\n    return pairs_at_university\n\n# Read input\nn = int(input())\nschedule = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(calculate_pairs_at_university(n, schedule))"}
{"solution": "def min_days_to_give_candies(n, k, candies_per_day):\n    total_candies = 0\n    for day in range(n):\n        total_candies += candies_per_day[day]\n        give_to_bran = min(total_candies, 8)\n        k -= give_to_bran\n        total_candies -= give_to_bran\n        if k <= 0:\n            return day + 1\n    return -1\n\n# Reading input\nn, k = map(int, input().split())\ncandies_per_day = list(map(int, input().split()))\n\n# Output the result\nprint(min_days_to_give_candies(n, k, candies_per_day))"}
{"solution": "def minimum_additional_walks(n, k, a):\n    b = a[:]\n    additional_walks = 0\n    \n    for i in range(n - 1):\n        if b[i] + b[i + 1] < k:\n            needed_walks = k - (b[i] + b[i + 1])\n            b[i + 1] += needed_walks\n            additional_walks += needed_walks\n    \n    return additional_walks, b\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nadditional_walks, b = minimum_additional_walks(n, k, a)\n\n# Print the result\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "def number_of_cells_in_nth_order_rhombus(n):\n    if n == 1:\n        return 1\n    else:\n        return number_of_cells_in_nth_order_rhombus(n - 1) + 4 * (n - 1)\n\n# Read input\nn = int(input())\n\n# Output the result\nprint(number_of_cells_in_nth_order_rhombus(n))"}
{"solution": "def is_pangram(n, s):\n    if n < 26:\n        return \"NO\"\n    letters = set(s.lower())\n    return \"YES\" if len(letters) == 26 else \"NO\"\n\n# Assuming the input is provided correctly as per the problem statement\nn = int(input())\ns = input()\n\nprint(is_pangram(n, s))"}
{"solution": "def calculate_time_after_minutes(current_time, minutes_to_add):\n    # Split the current time into hours and minutes\n    hours, minutes = map(int, current_time.split(':'))\n    \n    # Calculate the total minutes after adding the given minutes\n    total_minutes = hours * 60 + minutes + minutes_to_add\n    \n    # Calculate the new hours and minutes\n    new_hours = total_minutes // 60 % 24\n    new_minutes = total_minutes % 60\n    \n    # Format the new time to ensure two digits for hours and minutes\n    new_time = f\"{new_hours:02d}:{new_minutes:02d}\"\n    \n    return new_time\n\n# Read input from the user\ncurrent_time = input().strip()\nminutes_to_add = int(input().strip())\n\n# Calculate and print the new time\nprint(calculate_time_after_minutes(current_time, minutes_to_add))"}
{"solution": "def can_ignore_one_switch(n, m, matrix):\n    # Check if there's a switch that can be ignored\n    for i in range(n):\n        # Create a copy of the matrix without the current switch\n        temp_matrix = [row[:] for row in matrix]\n        temp_matrix.pop(i)\n        \n        # Check if all lamps can be turned on without the current switch\n        all_lamps_on = True\n        for j in range(m):\n            lamp_on = False\n            for k in range(n - 1):\n                if temp_matrix[k][j] == '1':\n                    lamp_on = True\n                    break\n            if not lamp_on:\n                all_lamps_on = False\n                break\n        \n        if all_lamps_on:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nmatrix = [input().strip() for _ in range(n)]\n\n# Output result\nprint(can_ignore_one_switch(n, m, matrix))"}
{"solution": "def min_rotations_for_even_sums(n, dominoes):\n    upper_sum = sum(x for x, _ in dominoes)\n    lower_sum = sum(y for _, y in dominoes)\n    \n    # If both sums are already even, no rotations are needed\n    if upper_sum % 2 == 0 and lower_sum % 2 == 0:\n        return 0\n    \n    # If one sum is even and the other is odd, it's impossible to make both even\n    if upper_sum % 2 != lower_sum % 2:\n        return -1\n    \n    # If both sums are odd, we need to check if there's at least one domino\n    # that can be rotated to make both sums even\n    for x, y in dominoes:\n        if (x % 2 != y % 2):\n            return 1\n    \n    # If no such domino exists, it's impossible to make both sums even\n    return -1\n\n# Reading input\nn = int(input())\ndominoes = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Printing the result\nprint(min_rotations_for_even_sums(n, dominoes))"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        a, b = map(int, input().split())\n        area = (a - b) * (a + b)\n        print(\"YES\" if is_prime(area) else \"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_remove_one_point(n, points):\n    positive_count = 0\n    negative_count = 0\n    \n    for x, y in points:\n        if x > 0:\n            positive_count += 1\n        else:\n            negative_count += 1\n    \n    if positive_count <= 1 or negative_count <= 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Reading input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_remove_one_point(n, points))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n\ndef gcd_of_factorials(A, B):\n    # Since factorial of a number includes all factors up to that number,\n    # the GCD of A! and B! will be the factorial of the smaller number.\n    return factorial(min(A, B))\n\n# Read input\nA, B = map(int, input().split())\n\n# Output the result\nprint(gcd_of_factorials(A, B))"}
{"solution": "def find_composite_pair(n):\n    # If n is even, we can use n+4 and 4, both are composite (4 is the smallest composite number)\n    if n % 2 == 0:\n        return n + 4, 4\n    # If n is odd, we need to find the smallest composite odd number greater than n\n    # We can use n+9 and 9, both are composite (9 is the smallest composite odd number)\n    else:\n        return n + 9, 9\n\n# Read input\nn = int(input())\n\n# Find and print the composite pair\na, b = find_composite_pair(n)\nprint(a, b)"}
{"solution": "import sys\nfrom collections import deque\n\ndef read_input():\n    N, M, P = map(int, sys.stdin.readline().split())\n    edges = [list(map(int, sys.stdin.readline().split())) for _ in range(M)]\n    return N, M, P, edges\n\ndef solve(N, M, P, edges):\n    # Create adjacency list and reverse adjacency list for graph and reversed graph\n    graph = [[] for _ in range(N + 1)]\n    reversed_graph = [[] for _ in range(N + 1)]\n    for A_i, B_i, C_i in edges:\n        graph[A_i].append((B_i, C_i))\n        reversed_graph[B_i].append(A_i)\n    \n    # Perform a BFS on the reversed graph to find all vertices that can reach Vertex N\n    reachable_from_N = [False] * (N + 1)\n    reachable_from_N[N] = True\n    queue = deque([N])\n    while queue:\n        current = queue.popleft()\n        for neighbor in reversed_graph[current]:\n            if not reachable_from_N[neighbor]:\n                reachable_from_N[neighbor] = True\n                queue.append(neighbor)\n    \n    # Filter edges to only include those that lead to a vertex that can reach Vertex N\n    filtered_edges = [(A_i, B_i, C_i) for A_i, B_i, C_i in edges if reachable_from_N[B_i]]\n    \n    # Bellman-Ford algorithm to find the maximum score\n    # Initialize distances with a large negative number to represent the maximum score\n    distances = [-float('inf')] * (N + 1)\n    distances[1] = 0\n    \n    # Relax edges N-1 times\n    for _ in range(N - 1):\n        for A_i, B_i, C_i in filtered_edges:\n            if distances[A_i] + C_i > distances[B_i]:\n                distances[B_i] = distances[A_i] + C_i\n    \n    # Check for positive cycles that affect the maximum score\n    for A_i, B_i, C_i in filtered_edges:\n        if distances[A_i] + C_i > distances[B_i] and reachable_from_N[A_i]:\n            return -1  # Positive cycle found\n    \n    # Calculate the maximum score after paying the penalty\n    max_score = distances[N] - P * (N - 1)\n    return max(max_score, -1)\n\n# Read input and solve the problem\nN, M, P, edges = read_input()\nresult = solve(N, M, P, edges)\nprint(result)"}
{"solution": "def min_cost_to_palindrome(N, strings_costs):\n    # Initialize the minimum cost to a large number\n    min_cost = float('inf')\n\n    # Helper function to check if a string can form a palindrome\n    def can_form_palindrome(s):\n        from collections import Counter\n        count = Counter(s)\n        odd_count = sum(1 for k, v in count.items() if v % 2 != 0)\n        return odd_count <= 1\n\n    # Helper function to calculate the cost of forming a palindrome\n    def calculate_cost(strings):\n        return sum(strings_costs[s] for s in strings)\n\n    # Try all combinations of strings to find the minimum cost\n    from itertools import combinations\n    for r in range(1, N + 1):  # Try combinations of 1 to N strings\n        for combo in combinations(strings_costs.keys(), r):\n            combined_string = ''.join(combo)\n            if can_form_palindrome(combined_string):\n                min_cost = min(min_cost, calculate_cost(combo))\n\n    return min_cost if min_cost != float('inf') else -1\n\n# Read input\nN = int(input())\nstrings_costs = {}\nfor _ in range(N):\n    S_i, C_i = input().split()\n    strings_costs[S_i] = int(C_i)\n\n# Output the result\nprint(min_cost_to_palindrome(N, strings_costs))"}
{"solution": "def largest_xor_sum(n, k):\n    # Find the number of bits in n\n    num_bits = n.bit_length()\n    # The largest possible xor-sum\n    max_xor_sum = (1 << num_bits) - 1\n    return max_xor_sum\n\n# Read input from stdin\nn, k = map(int, input().split())\n# Print the output\nprint(largest_xor_sum(n, k))"}
{"solution": "def min_shorter_side_length(points):\n    # Find the maximum x and y coordinates among all points\n    max_x = max(point[0] for point in points)\n    max_y = max(point[1] for point in points)\n    \n    # The minimum length of the shorter side of the triangle is the maximum of max_x and max_y\n    return max(max_x, max_y)\n\n# Read input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(min_shorter_side_length(points))"}
{"solution": "from collections import Counter\n\ndef max_nineteens(s):\n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # Define the required frequency of each character in the word \"nineteen\"\n    required_counts = {'n': 3, 'i': 1, 'e': 3, 't': 1}\n    \n    # Calculate the maximum number of \"nineteen\" words that can be formed\n    max_nineteens = float('inf')\n    for char, required in required_counts.items():\n        if char in char_count:\n            max_nineteens = min(max_nineteens, char_count[char] // required)\n        else:\n            return 0  # If any required character is missing, we can't form \"nineteen\"\n    \n    return max_nineteens\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(max_nineteens(s))"}
{"solution": "def highest_branch(p, y):\n    # Function to check if a number is a multiple of any number from 2 to p\n    def is_multiple_of_range(num, p):\n        for i in range(2, p + 1):\n            if num % i == 0:\n                return True\n        return False\n\n    # Start checking from y downwards to find the highest branch that cannot be reached\n    for branch in range(y, p, -1):\n        if not is_multiple_of_range(branch, p):\n            return branch\n    return -1\n\n# Example usage:\n# p, y = map(int, input().split())\n# print(highest_branch(p, y))"}
{"solution": "def find_minimum_distance(n, m, k, house_prices):\n    # Initialize the minimum distance to a large number\n    min_distance = float('inf')\n    \n    # Iterate through each house to find the closest affordable one\n    for i in range(n):\n        # Check if the house is affordable and unoccupied\n        if house_prices[i] > 0 and house_prices[i] <= k:\n            # Calculate the distance to the crush's house\n            distance = abs(i + 1 - m) * 10\n            # Update the minimum distance if this house is closer\n            if distance < min_distance:\n                min_distance = distance\n                \n    return min_distance\n\n# Read input\nn, m, k = map(int, input().split())\nhouse_prices = list(map(int, input().split()))\n\n# Find and print the minimum distance\nprint(find_minimum_distance(n, m, k, house_prices))"}
{"solution": "def can_transform(n, m, A, B):\n    # Create frequency maps for rows and columns of both matrices\n    freq_A = [{}, {}]\n    freq_B = [{}, {}]\n    \n    for i in range(n):\n        for j in range(m):\n            freq_A[0][A[i][j]] = freq_A[0].get(A[i][j], 0) + 1\n            freq_A[1][A[j][i]] = freq_A[1].get(A[j][i], 0) + 1\n            freq_B[0][B[i][j]] = freq_B[0].get(B[i][j], 0) + 1\n            freq_B[1][B[j][i]] = freq_B[1].get(B[j][i], 0) + 1\n    \n    # Compare the frequency maps to determine if transformation is possible\n    return freq_A == freq_B\n\n# Read input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nB = [list(map(int, input().split())) for _ in range(n)]\n\n# Check if transformation is possible and print result\nprint(\"YES\" if can_transform(n, m, A, B) else \"NO\")"}
{"solution": "def longest_uncommon_subsequence(a, b):\n    if a == b:\n        return -1\n    return max(len(a), len(b))\n\n# Read input\na = input().strip()\nb = input().strip()\n\n# Output the result\nprint(longest_uncommon_subsequence(a, b))"}
{"solution": "def find_intersection(a, b, c, d):\n    # Rick's screams are at times b + ka (k = 0, 1, 2, ...)\n    # Morty's screams are at times d + lc (l = 0, 1, 2, ...)\n    # We need to find the smallest t such that b + ka = d + lc\n    # This can be rearranged to ka - lc = d - b\n    # This is a linear Diophantine equation, and we need to find the smallest positive integer solution for t\n\n    # First, check if a and c are multiples of each other\n    if a % c == 0:\n        k = (d - b) // c\n        if k >= 0 and b + k * a == d + k * c:\n            return b + k * a\n    elif c % a == 0:\n        l = (b - d) // a\n        if l >= 0 and b + l * a == d + l * c:\n            return b + l * a\n    else:\n        # Use the extended Euclidean algorithm to find the gcd and the coefficients\n        def egcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                g, y, x = egcd(b % a, a)\n                return (g, x - (b // a) * y, y)\n\n        g, x, y = egcd(a, c)\n        if (d - b) % g != 0:\n            return -1  # No solution exists\n\n        # Scale the solution to the original equation\n        x *= (d - b) // g\n        y *= (d - b) // g\n\n        # Adjust the solution to get the smallest positive t\n        while x < 0 or y < 0:\n            x += c // g\n            y += a // g\n\n        return b + x * a\n\n    return -1  # If no solution is found\n\n# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Find and print the result\nprint(find_intersection(a, b, c, d))"}
{"solution": "def split_number(n):\n    # Since we need to ensure none of a, b, c is a multiple of 3, we can start by checking n modulo 3\n    if n % 3 == 0:\n        # If n is divisible by 3, we can split it into 1, 1, and n-2 to ensure none of them is a multiple of 3\n        a, b, c = 1, 1, n - 2\n    elif n % 3 == 1:\n        # If n modulo 3 is 1, we can split it into 1, 1, and n-2\n        a, b, c = 1, 1, n - 2\n    else:  # n % 3 == 2\n        # If n modulo 3 is 2, we can split it into 2, 2, and n-4\n        a, b, c = 2, 2, n - 4\n    \n    return a, b, c\n\n# Read input\nn = int(input())\n\n# Get the solution\na, b, c = split_number(n)\n\n# Print the solution\nprint(a, b, c)"}
{"solution": "def count_valid_squares(n, a, b, c, d):\n    # Calculate the sum of the top-left 2x2 square\n    sum_top_left = a + b + c + d\n    \n    # Initialize the count of valid squares\n    valid_squares_count = 0\n    \n    # Iterate through all possible values for the missing corners\n    for top_left in range(1, n + 1):\n        for top_right in range(1, n + 1):\n            for bottom_left in range(1, n + 1):\n                for bottom_right in range(1, n + 1):\n                    # Check if the sum of each 2x2 square equals the sum of the top-left 2x2 square\n                    if (a + top_left + b + top_right == sum_top_left and\n                        b + top_right + c + bottom_right == sum_top_left and\n                        c + bottom_right + d + bottom_left == sum_top_left and\n                        d + bottom_left + a + top_left == sum_top_left):\n                        valid_squares_count += 1\n    \n    return valid_squares_count\n\n# Read input\nn, a, b, c, d = map(int, input().split())\n\n# Calculate and print the number of distinct valid squares\nprint(count_valid_squares(n, a, b, c, d))"}
{"solution": "def calculate_final_weight(w, h, u1, d1, u2, d2):\n    while h > 0:\n        w += h  # Weight increases by current height\n        if h == d1:\n            w = max(0, w - u1)  # Subtract weight of the first stone if at the same height\n        if h == d2:\n            w = max(0, w - u2)  # Subtract weight of the second stone if at the same height\n        h -= 1  # Move one meter down\n    return w\n\n# Read input\nw, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\n# Calculate and print the final weight\nprint(calculate_final_weight(w, h, u1, d1, u2, d2))"}
{"solution": "def find_passing_rate(m, c, x, y):\n    total_students = sum(c)\n    for k in range(1, m + 1):\n        beginners = sum(c[:k])\n        intermediates = total_students - beginners\n        \n        if x <= beginners <= y and x <= intermediates <= y:\n            return k\n    return 0\n\n# Read input\nm = int(input())\nc = list(map(int, input().split()))\nx, y = map(int, input().split())\n\n# Find and print the passing rate\nprint(find_passing_rate(m, c, x, y))"}
{"solution": "def min_coins_to_make_x_equal_to_1(n, k, A, B):\n    coins = 0\n    while n > 1:\n        if n % k == 0:\n            potential_savings = (n - n // k) * A\n            if potential_savings > B:\n                n //= k\n                coins += B\n            else:\n                coins += (n - 1) * A\n                n = 1\n        else:\n            subtract_to = max(n - n % k, 1)\n            coins += (n - subtract_to) * A\n            n = subtract_to\n    return coins\n\n# Reading input\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\n# Output the result\nprint(min_coins_to_make_x_equal_to_1(n, k, A, B))"}
{"solution": "import math\n\ndef min_value_and_operations(n):\n    operations = 0\n    while n > 1:\n        sqrt_n = math.isqrt(n)\n        if sqrt_n * sqrt_n == n:\n            n = sqrt_n\n            operations += 1\n        else:\n            largest_factor = n // sqrt_n\n            n //= largest_factor\n            operations += 1\n    return n, operations\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the result\nmin_n, min_ops = min_value_and_operations(n)\nprint(min_n, min_ops)"}
{"solution": "def max_score_rps_battle(N, K, R, S, P, T):\n    # Initialize the score\n    score = 0\n    \n    # Dictionary to map machine's hand to player's winning hand and points\n    win_map = {'r': ('P', P), 's': ('R', R), 'p': ('S', S)}\n    \n    # List to keep track of the player's hands to enforce the rule of not repeating K rounds ago\n    last_hands = [None] * K\n    \n    for i in range(N):\n        machine_hand = T[i]\n        player_win_hand, points = win_map[machine_hand]\n        \n        # Check if the player can use the winning hand without violating the rule\n        if last_hands[i % K] != player_win_hand:\n            score += points\n            last_hands[i % K] = player_win_hand\n        else:\n            last_hands[i % K] = None  # Player forfeits this round to avoid penalty in future rounds\n    \n    return score\n\n# Read input\nN, K = map(int, input().split())\nR, S, P = map(int, input().split())\nT = input()\n\n# Calculate and print the maximum score\nprint(max_score_rps_battle(N, K, R, S, P, T))"}
{"solution": "def longest_good_string(a, b, c):\n    # Start by using the 'ab' strings to alternate between 'a' and 'b'\n    # as they already form a good string part.\n    length = 2 * min(a, b)\n    \n    # Determine which of 'a' or 'b' has more remaining after pairing with 'ab'\n    if a > b:\n        a -= b\n        b = 0\n    else:\n        b -= a\n        a = 0\n    \n    # Add the remaining 'a' or 'b' strings, which can be added directly\n    # to the end of the good string without breaking the rule.\n    length += 2 * min(a, c)\n    length += 2 * min(b, c)\n    \n    # If there are any 'ab' strings left after pairing with 'a' and 'b',\n    # they can be added to the end of the string.\n    c -= min(a, c)\n    c -= min(b, c)\n    length += 2 * c\n    \n    return length\n\n# Read input\na, b, c = map(int, input().split())\n\n# Print output\nprint(longest_good_string(a, b, c))"}
{"solution": "def determine_marks(n, k, p, x, y, a):\n    # Calculate the remaining tests and the sum of current marks\n    remaining_tests = n - k\n    current_sum = sum(a)\n    \n    # Calculate how many marks need to be at least y to ensure the median is y\n    marks_needed_for_median = (n + 1) // 2 - sum(mark >= y for mark in a)\n    marks_needed_for_median = max(0, marks_needed_for_median)\n    \n    # If we need more marks than remaining tests or the sum exceeds x, it's impossible\n    if marks_needed_for_median > remaining_tests or current_sum + marks_needed_for_median * y + (remaining_tests - marks_needed_for_median) > x:\n        return \"-1\"\n    \n    # Determine the marks Vova should get\n    marks_to_get = [y] * marks_needed_for_median + [1] * (remaining_tests - marks_needed_for_median)\n    \n    return ' '.join(map(str, marks_to_get))\n\n# Read input\nn, k, p, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(determine_marks(n, k, p, x, y, a))"}
{"solution": "def is_berlanese(s):\n    vowels = \"aouie\"\n    for i in range(len(s)):\n        if s[i] not in vowels:  # If it's a consonant\n            if s[i] == 'n':\n                continue  # 'n' can be followed by any letter\n            if i == len(s) - 1 or s[i + 1] not in vowels:\n                return \"NO\"  # If it's the last letter or next letter is not a vowel\n    return \"YES\"\n\n# Read input\ns = input().strip()\n\n# Output result\nprint(is_berlanese(s))"}
{"solution": "def max_dominoes(n, m, edges):\n    # If there are no edges, no dominoes can be placed\n    if m == 0:\n        return 0\n\n    # Create a degree list to keep track of the number of edges for each vertex\n    degree = [0] * (n + 1)\n    for a, b in edges:\n        degree[a] += 1\n        degree[b] += 1\n\n    # The maximum number of dominoes that can be placed is determined by the vertex with the maximum degree\n    # Since each vertex must have the same number of dots on the halves of dominoes directed towards it,\n    # we can place at most as many dominoes as the maximum degree of any vertex.\n    max_degree = max(degree)\n\n    # However, we must also consider that we can only use each type of domino once, and there are only 6 types\n    # of dots (1 through 6). Therefore, if the maximum degree is greater than 6, we can only place 6 dominoes\n    # per vertex at most.\n    return min(max_degree, 6) * n\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Calculate and print the result\nprint(max_dominoes(n, m, edges))"}
{"solution": "def maximize_r2_points(n, m, prices, auction_questions):\n    # Sort the prices in descending order to always pick the highest value question first\n    sorted_prices = sorted(enumerate(prices, 1), key=lambda x: x[1], reverse=True)\n    \n    # Initialize variables\n    r2_points = 0\n    current_points = 0\n    \n    # Keep track of auction questions that have been used\n    used_auctions = set()\n    \n    for idx, price in sorted_prices:\n        if idx in auction_questions and idx not in used_auctions:\n            # If it's an auction question and R2 has more points than the question's price,\n            # R2 can set the price to their current points to maximize gain\n            if current_points > price:\n                r2_points += current_points\n                current_points -= price  # Since R2 sets the price to current points, no change in points\n            else:\n                # If R2 doesn't have enough points to change the price, they can still answer it normally\n                r2_points += price\n                current_points += price\n            used_auctions.add(idx)  # Mark this auction question as used\n        else:\n            # For regular questions, R2 simply answers and adds the points\n            r2_points += price\n            current_points += price\n    \n    return r2_points\n\n# Read input\nn, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauction_questions = set(map(int, input().split()))\n\n# Calculate and print the result\nprint(maximize_r2_points(n, m, prices, auction_questions))"}
{"solution": "def compute_final_score(m, w, hs, hu):\n    problem_points = [500, 1000, 1500, 2000, 2500]\n    score = 0\n    \n    for i in range(5):\n        score += max(0.3 * problem_points[i], (1 - m[i] / 250) * problem_points[i] - 50 * w[i])\n    \n    score += 100 * hs\n    score -= 50 * hu\n    \n    return int(score)\n\n# Read input\nm = list(map(int, input().split()))\nw = list(map(int, input().split()))\nhs, hu = map(int, input().split())\n\n# Compute and print the final score\nprint(compute_final_score(m, w, hs, hu))"}
{"solution": "MOD = 998244353\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef solve(n, m, L, R):\n    total_cells = n * m\n    total_heights = R - L + 1\n    odd_heights = (total_heights + 1) // 2\n    even_heights = total_heights // 2\n    \n    if total_cells % 2 == 1:\n        return power(total_heights, total_cells, MOD)\n    else:\n        return (power(total_heights, total_cells, MOD) + (odd_heights - even_heights) * power(2, total_cells - 1, MOD)) % MOD\n\n# Read input\nn, m, L, R = map(int, input().split())\n\n# Output the result\nprint(solve(n, m, L, R))"}
{"solution": "def is_possible_to_make_increasing(n, m, matrix_a, matrix_b):\n    for i in range(n):\n        for j in range(m):\n            # Ensure that matrix_a[i][j] is the smaller or equal element\n            if matrix_a[i][j] > matrix_b[i][j]:\n                matrix_a[i][j], matrix_b[i][j] = matrix_b[i][j], matrix_a[i][j]\n    \n    # Check rows for strictly increasing property\n    for i in range(n):\n        for j in range(1, m):\n            if matrix_a[i][j] <= matrix_a[i][j-1] or matrix_b[i][j] <= matrix_b[i][j-1]:\n                return \"Impossible\"\n    \n    # Check columns for strictly increasing property\n    for j in range(m):\n        for i in range(1, n):\n            if matrix_a[i][j] <= matrix_a[i-1][j] or matrix_b[i][j] <= matrix_b[i-1][j]:\n                return \"Impossible\"\n    \n    return \"Possible\""}
{"solution": "def max_length_string(n, limits):\n    limits.sort(reverse=True)\n    max_length = 0\n    distinct_counts = []\n\n    for i in range(n):\n        for j in range(1, limits[i] + 1):\n            if j not in distinct_counts:\n                distinct_counts.append(j)\n                max_length += j\n                break\n\n    return max_length\n\n# Reading input\nn = int(input())\nlimits = list(map(int, input().split()))\n\n# Output the result\nprint(max_length_string(n, limits))"}
{"solution": "def min_problems_to_solve(n, k, difficulties):\n    difficulties.sort(reverse=True)\n    problems_to_solve = 0\n    i = 0\n    while i < n:\n        if k >= difficulties[i] / 2:\n            k = difficulties[i]\n            i += 1\n        else:\n            k *= 2\n            problems_to_solve += 1\n    return problems_to_solve\n\n# Reading input\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Output the result\nprint(min_problems_to_solve(n, k, difficulties))"}
{"solution": "def distribute_diplomas(n, min_max_1, min_max_2, min_max_3):\n    min_1, max_1 = min_max_1\n    min_2, max_2 = min_max_2\n    min_3, max_3 = min_max_3\n    \n    # Start by maximizing the number of first-degree diplomas\n    first_degree = min(max_1, n - min_2 - min_3)\n    remaining_n = n - first_degree\n    \n    # Then, maximize the number of second-degree diplomas\n    second_degree = min(max_2, remaining_n - min_3)\n    remaining_n -= second_degree\n    \n    # The rest will get third-degree diplomas, ensuring it's within the limit\n    third_degree = min(max_3, remaining_n)\n    \n    return first_degree, second_degree, third_degree\n\n# Read input\nn = int(input())\nmin_max_1 = tuple(map(int, input().split()))\nmin_max_2 = tuple(map(int, input().split()))\nmin_max_3 = tuple(map(int, input().split()))\n\n# Calculate and print the result\nresult = distribute_diplomas(n, min_max_1, min_max_2, min_max_3)\nprint(result[0], result[1], result[2])"}
{"solution": "def predict_moon_phase(n, observations):\n    # Check if there's enough data to predict the next phase\n    if n == 1:\n        if observations[0] == 0:\n            return \"UP\"\n        elif observations[0] == 15:\n            return \"DOWN\"\n        else:\n            return -1\n    \n    # Determine the trend based on the last two observations\n    last_observation = observations[-1]\n    second_last_observation = observations[-2]\n    \n    if last_observation > second_last_observation:\n        # If the last observation is greater, the moon is waxing\n        if last_observation == 15:\n            return \"DOWN\"\n        else:\n            return \"UP\"\n    else:\n        # If the last observation is smaller, the moon is waning\n        if last_observation == 0:\n            return \"UP\"\n        else:\n            return \"DOWN\"\n\n# Read input\nn = int(input())\nobservations = list(map(int, input().split()))\n\n# Predict and print the result\nprint(predict_moon_phase(n, observations))"}
{"solution": "def can_transform(s, t):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    # Check if lengths are the same\n    if len(s) != len(t):\n        return \"No\"\n    \n    # Check each character\n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels) != (char_t in vowels):\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(can_transform(s, t))"}
{"solution": "def determine_winner(board):\n    # Initialize the minimum steps for both players to a large number\n    min_steps_A = 8\n    min_steps_B = 8\n\n    # Iterate through each cell on the board\n    for r in range(8):\n        for c in range(8):\n            if board[r][c] == 'W':\n                # Check for the minimum steps for player A to reach row 1\n                steps_A = r\n                for i in range(r - 1, -1, -1):\n                    if board[i][c] != '.':\n                        steps_A = 8  # Set to a large number if path is blocked\n                        break\n                min_steps_A = min(min_steps_A, steps_A)\n            elif board[r][c] == 'B':\n                # Check for the minimum steps for player B to reach row 8\n                steps_B = 7 - r\n                for i in range(r + 1, 8):\n                    if board[i][c] != '.':\n                        steps_B = 8  # Set to a large number if path is blocked\n                        break\n                min_steps_B = min(min_steps_B, steps_B)\n\n    # Determine the winner based on the minimum steps required\n    if min_steps_A <= min_steps_B:\n        return 'A'\n    else:\n        return 'B'\n\n# Read the board from input\nboard = [input().strip() for _ in range(8)]\n\n# Determine the winner and print the result\nprint(determine_winner(board))"}
{"solution": "def max_equal_length(n, A, m, B):\n    if sum(A) != sum(B):\n        return -1\n    \n    i, j = 0, 0\n    sumA, sumB = 0, 0\n    count = 0\n    \n    while i < n and j < m:\n        sumA += A[i]\n        sumB += B[j]\n        \n        if sumA == sumB:\n            count += 1\n            sumA = 0\n            sumB = 0\n            i += 1\n            j += 1\n        elif sumA < sumB:\n            i += 1\n        else:\n            j += 1\n    \n    return count\n\n# Read input\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\n# Output the result\nprint(max_equal_length(n, A, m, B))"}
{"solution": "def is_contest_problem(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    count = sum(problem_name.count(friend) for friend in friends)\n    return \"YES\" if count == 1 else \"NO\"\n\n# Assuming the input is provided through a predefined variable or function call\n# problem_name = input().strip()\n# print(is_contest_problem(problem_name))"}
{"solution": "def sieve(n):\n    is_prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (is_prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n    is_prime[0], is_prime[1] = False, False  # 0 and 1 are not primes\n    return is_prime\n\ndef count_primes_in_range(is_prime, a, b):\n    prime_count = [0] * (b + 1)\n    for i in range(a, b + 1):\n        prime_count[i] = prime_count[i - 1] + (1 if is_prime[i] else 0)\n    return prime_count\n\ndef min_length_with_k_primes(a, b, k):\n    is_prime = sieve(b)\n    prime_count = count_primes_in_range(is_prime, a, b)\n    \n    def has_k_primes_in_length(l):\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] >= k:\n                return True\n        return False\n    \n    left, right = 1, b - a + 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if has_k_primes_in_length(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\n# Input\na, b, k = map(int, input().split())\n\n# Output\nprint(min_length_with_k_primes(a, b, k))"}
{"solution": "import math\n\ndef min_distance(a, h, w):\n    if a > h or a > w:\n        return -1\n    \n    # Calculate the maximum number of photos that can fit in each dimension\n    max_rows = h // a\n    max_cols = w // a\n    \n    # Initialize the minimum distance to a large number\n    min_x = float('inf')\n    \n    # Try different combinations of rows and columns\n    for rows in range(1, max_rows + 1):\n        for cols in range(1, max_cols + 1):\n            # Calculate the total height and width occupied by the photos and the gaps\n            total_height = rows * a + (rows - 1) * x\n            total_width = cols * a + (cols - 1) * x\n            \n            # Check if the total height and width fit within the wall dimensions\n            if total_height <= h and total_width <= w:\n                # Calculate the distance x based on the current configuration\n                x = min((h - rows * a) / (rows - 1), (w - cols * a) / (cols - 1))\n                min_x = min(min_x, x)\n    \n    return min_x if min_x != float('inf') else -1\n\n# Read input\na, h, w = map(int, input().split())\n\n# Calculate and print the minimum value of x\nresult = min_distance(a, h, w)\nprint(\"{:.6f}\".format(result) if result != -1 else -1)"}
{"solution": "def chapters_to_read(n, chapter_ranges, k):\n    chapters_not_read = 0\n    for l_i, r_i in chapter_ranges:\n        if k <= r_i:\n            chapters_not_read += 1\n    return chapters_not_read\n\n# Read input\nn = int(input())\nchapter_ranges = [tuple(map(int, input().split())) for _ in range(n)]\nk = int(input())\n\n# Calculate and print the result\nprint(chapters_to_read(n, chapter_ranges, k))"}
{"solution": "def can_form_codeforces(word):\n    target = \"CODEFORCES\"\n    n = len(word)\n    m = len(target)\n    \n    if n < m:\n        return \"NO\"\n    \n    for i in range(m + 1):\n        if word[:i] == target[:i] and word[n - (m - i):] == target[i:]:\n            return \"YES\"\n    \n    return \"NO\""}
{"solution": "def min_weight_triangulation(n):\n    if n < 3:\n        return 0\n    if n == 3:\n        return 1 * 2 * 3\n    \n    # Initialize a 2D array to store the minimum weights\n    dp = [[float('inf')] * n for _ in range(n)]\n    \n    # Base case: a triangle has weight equal to the product of its vertices\n    for i in range(n):\n        dp[i][(i+2)%n] = (i+1) * (i+2) * (i+3)\n    \n    # Fill the dp table\n    for length in range(3, n):\n        for i in range(n):\n            j = (i + length) % n\n            for k in range(i + 1, i + length):\n                k_mod = k % n\n                dp[i][j] = min(dp[i][j], dp[i][k_mod] + dp[k_mod][j] + (i+1)*(k_mod+1)*(j+1))\n    \n    # The result is the minimum weight triangulation of the entire polygon\n    return min(dp[i][(i+n-1)%n] for i in range(n))\n\n# Read input\nn = int(input().strip())\n\n# Print output\nprint(min_weight_triangulation(n))"}
{"solution": "def count_digits_for_books(n):\n    digits = 0\n    length = 1\n    start = 1\n    \n    while start <= n:\n        end = start * 10 - 1\n        if end > n:\n            end = n\n        digits += (end - start + 1) * length\n        start *= 10\n        length += 1\n    \n    return digits\n\n# Read input\nn = int(input())\n\n# Output the result\nprint(count_digits_for_books(n))"}
{"solution": "def find_winning_color(n, A, car_colors):\n    # Initialize a dictionary to count occurrences of each color\n    color_counts = {}\n    # Initialize a variable to track the maximum count of Alice's color\n    max_A_count = 0\n    \n    # Iterate through the car colors to count occurrences and find the maximum count of Alice's color\n    for color in car_colors:\n        if color == A:\n            max_A_count += 1\n        else:\n            if color not in color_counts:\n                color_counts[color] = 0\n            color_counts[color] += 1\n    \n    # Check if there is any color that Bob can choose to win\n    for color, count in color_counts.items():\n        if count >= max_A_count:\n            return color\n    \n    # If no such color exists, return -1\n    return -1\n\n# Read input\nn, A = map(int, input().split())\ncar_colors = list(map(int, input().split()))\n\n# Find and print the winning color for Bob\nprint(find_winning_color(n, A, car_colors))"}
{"solution": "def can_form_unique_crossword(n, x, encoding):\n    # Calculate the total length required by the encoding\n    total_length_required = sum(encoding) + len(encoding) - 1\n    \n    # Check if the total length required exceeds the given length x\n    if total_length_required > x:\n        return \"NO\"\n    \n    # Check if the difference between x and total_length_required is even\n    # This is to ensure we can alternate 1's and 0's to fit the encoding\n    if (x - total_length_required) % 2 != 0:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, x = map(int, input().split())\nencoding = list(map(int, input().split()))\n\n# Print the result\nprint(can_form_unique_crossword(n, x, encoding))"}
{"solution": "def min_coins_to_sum(n, S):\n    # The minimum number of coins required to get sum S is to use the largest coin values possible.\n    # Since we have coins from 1 to n, the largest coin value we can use repeatedly is n.\n    # Therefore, the minimum number of coins is the ceiling of S divided by n.\n    return (S + n - 1) // n\n\n# Read input\nn, S = map(int, input().split())\n\n# Output the result\nprint(min_coins_to_sum(n, S))"}
{"solution": "def min_changes_to_palindrome(s):\n    n = len(s)\n    changes = 0\n    for i in range(n // 2):\n        if s[i] != s[n - i - 1]:\n            changes += 1\n    if changes == 0:\n        return s  # It's already a palindrome\n\n    # Count the frequency of each character\n    freq = {}\n    for char in s:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n\n    # Determine the lexicographically smallest palindrome\n    palindrome = []\n    used_chars = set()\n    for i in range(n // 2):\n        left = s[i]\n        right = s[n - i - 1]\n        if left != right:\n            # Choose the lexicographically smaller character that has an even frequency\n            for char in sorted([left, right]):\n                if freq[char] % 2 == 0:\n                    palindrome.append(char)\n                    used_chars.add(char)\n                    freq[char] -= 2\n                    break\n            else:\n                # If no even frequency character is found, use the smaller one\n                palindrome.append(min(left, right))\n                used_chars.add(min(left, right))\n                freq[min(left, right)] -= 2\n        else:\n            palindrome.append(left)\n            used_chars.add(left)\n            freq[left] -= 2\n\n    # If the length of the string is odd, add the middle character\n    if n % 2 == 1:\n        for char in sorted(freq.keys()):\n            if freq[char] % 2 == 1:\n                middle_char = char\n                freq[char] -= 1\n                break\n        else:\n            middle_char = min(freq.keys())\n        palindrome.append(middle_char)\n\n    # Add the second half of the palindrome\n    palindrome.extend(reversed(palindrome[:n // 2]))\n\n    return ''.join(palindrome)\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(min_changes_to_palindrome(s))"}
{"solution": "def calculate_weight(board):\n    piece_weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n    }\n    \n    white_weight = 0\n    black_weight = 0\n    \n    for row in board:\n        for piece in row:\n            if piece in piece_weights:\n                if piece.isupper():\n                    white_weight += piece_weights[piece]\n                else:\n                    black_weight += piece_weights[piece]\n    \n    if white_weight > black_weight:\n        return \"White\"\n    elif black_weight > white_weight:\n        return \"Black\"\n    else:\n        return \"Draw\""}
{"solution": "from collections import deque\n\ndef solve_sugoroku(N, M, S):\n    # Initialize a queue for BFS and a list to store the path\n    queue = deque([(0, [])])  # Each element is a tuple (current_position, path)\n    visited = [False] * (N + 1)\n    visited[0] = True\n\n    while queue:\n        current, path = queue.popleft()\n\n        # Try all possible moves from 1 to M\n        for move in range(1, M + 1):\n            next_pos = current + move\n\n            # Check if the next position is valid and not visited\n            if next_pos <= N and S[next_pos] == '0' and not visited[next_pos]:\n                # If we reach the goal, return the path with the current move added\n                if next_pos == N:\n                    return path + [move]\n\n                # Mark the position as visited and add to the queue\n                visited[next_pos] = True\n                queue.append((next_pos, path + [move]))\n\n    # If we cannot reach the goal, return -1\n    return -1\n\n# Read input\nN, M = map(int, input().split())\nS = input()\n\n# Solve the problem and print the result\nresult = solve_sugoroku(N, M, S)\nif result == -1:\n    print(result)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "def solve_golf_problem(K, X, Y):\n    # Check if the goal is reachable directly\n    if (X + Y) % 2 != 0 and K % 2 == 0:\n        return -1\n    \n    # Initialize the path\n    path = []\n    \n    # Function to add a move to the path\n    def add_move(x, y):\n        nonlocal X, Y\n        path.append((x, y))\n        X -= x\n        Y -= y\n    \n    # Move towards the goal in steps of size K\n    while abs(X) + abs(Y) > K:\n        if abs(X) > abs(Y):\n            direction = 1 if X > 0 else -1\n            add_move(direction * K, 0)\n        else:\n            direction = 1 if Y > 0 else -1\n            add_move(0, direction * K)\n    \n    # Adjust the last move if necessary\n    if abs(X) + abs(Y) != K:\n        if (X + Y) % 2 == 0:\n            # Move in a direction that balances the remaining distance\n            if abs(X) > abs(Y):\n                direction = 1 if X > 0 else -1\n                add_move(direction * (K - abs(Y)), Y)\n            else:\n                direction = 1 if Y > 0 else -1\n                add_move(X, direction * (K - abs(X)))\n        else:\n            # Make an extra move to balance the remaining distance\n            add_move(X // 2, Y // 2)\n            add_move(X - X // 2, Y - Y // 2)\n    else:\n        add_move(X, Y)\n    \n    # Output the solution\n    print(len(path))\n    for x, y in path:\n        print(x, y)\n\n# Read input\nK = int(input())\nX, Y = map(int, input().split())\n\n# Solve the problem\nsolve_golf_problem(K, X, Y)"}
{"solution": "def find_smallest_n(m):\n    if m == 1:\n        return 8\n    elif m == 8:\n        return 54\n    elif m == 10:\n        return -1\n    else:\n        # Binary search to find the smallest n\n        left, right = 8, 10**15\n        while left < right:\n            mid = (left + right) // 2\n            ways = count_ways(mid)\n            if ways == m:\n                right = mid\n            elif ways < m:\n                left = mid + 1\n            else:\n                right = mid - 1\n        if count_ways(left) == m:\n            return left\n        else:\n            return -1\n\ndef count_ways(n):\n    ways = 0\n    for k in range(2, n):\n        if (k**4 - 1) // (k - 1) > n:\n            break\n        max_first_theft = n // ((k**3 * (k - 1)) // (k**3 - 1))\n        ways += max_first_theft\n        if max_first_theft == 0:\n            break\n    return ways\n\n# Read input\nm = int(input().strip())\n\n# Find and print the smallest n\nprint(find_smallest_n(m))"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    \n    # If the circles do not intersect\n    if d >= r1 + r2:\n        return 0.0\n    \n    # If one circle is inside the other\n    if d <= abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n    \n    # Calculate the area of intersection\n    r1_sq, r2_sq = r1 ** 2, r2 ** 2\n    d1 = (r1_sq - r2_sq + d ** 2) / (2 * d)\n    d2 = d - d1\n    h1 = math.sqrt(r1_sq - d1 ** 2)\n    h2 = math.sqrt(r2_sq - d2 ** 2)\n    \n    # Area of the two segments\n    segment1 = r1_sq * math.acos(d1 / r1) - d1 * h1\n    segment2 = r2_sq * math.acos(d2 / r2) - d2 * h2\n    \n    return segment1 + segment2\n\n# Read input\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\n# Calculate and print the area of intersection\nprint(\"{:.20f}\".format(circle_intersection_area(x1, y1, r1, x2, y2, r2)))"}
{"solution": "def minimize_n(v):\n    # The strategy to minimize n is to always subtract the largest non-divisor\n    # that is less than n. However, since the goal is to minimize n as quickly\n    # as possible, we can observe that the smallest possible value of n after\n    # any number of operations is 1, which can be achieved by subtracting\n    # n-1 (if n-1 is not a divisor of n, which it can't be since n-1 < n).\n    # Therefore, the minimum value of n is always 1.\n    return 1\n\n# Read input\nv = int(input().strip())\n\n# Output the result\nprint(minimize_n(v))"}
{"solution": "def max_citizens_caught(n, roads, citizens):\n    # Initialize a list to store the maximum number of citizens that can be caught at each square\n    max_caught = [0] * n\n    \n    # Traverse the city from the main square to the leaves\n    for i in range(1, n):\n        parent = roads[i - 2]  # The parent square of the current square\n        # Update the maximum number of citizens that can be caught at the parent square\n        max_caught[parent - 1] = max(max_caught[parent - 1], citizens[i] + max_caught[i])\n    \n    # The bandit will catch the maximum number of citizens at the main square\n    return max_caught[0] + citizens[0]\n\n# Read input\nn = int(input())\nroads = list(map(int, input().split()))\ncitizens = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_citizens_caught(n, roads, citizens))"}
{"solution": "def count_typo_words(n, S, T):\n    count = 0\n    for i in range(n + 1):\n        # Construct W by inserting a character at position i in both S and T\n        if i == 0:\n            W1 = S[0] + S\n            W2 = T[0] + T\n        elif i == n:\n            W1 = S + S[-1]\n            W2 = T + T[-1]\n        else:\n            W1 = S[:i] + S[i] + S[i:]\n            W2 = T[:i] + T[i] + T[i:]\n        \n        # Check if the constructed words are the same\n        if W1 == W2:\n            count += 1\n    \n    return count\n\n# Example usage:\nn = int(input())\nS = input().strip()\nT = input().strip()\nprint(count_typo_words(n, S, T))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_ints():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef min_computer_strength(n, strengths, connections):\n    # Create a graph from the connections\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Sort banks by their strength to consider hacking the weakest first\n    banks = sorted([(strengths[i-1], i) for i in range(1, n+1)])\n    \n    # Initialize the minimum strength needed for the computer\n    min_strength = 0\n    \n    # Keep track of hacked banks\n    hacked = set()\n    \n    for strength, bank in banks:\n        # Check if this bank can be hacked (it's either isolated or connected to a hacked bank)\n        can_hack = True\n        for neighbor in graph[bank]:\n            if neighbor not in hacked:\n                can_hack = False\n                break\n        \n        if can_hack:\n            hacked.add(bank)\n            min_strength = max(min_strength, strength)\n    \n    return min_strength\n\n# Read input\nn = int(sys.stdin.readline().strip())\nstrengths = read_ints()\nconnections = [read_ints() for _ in range(n-1)]\n\n# Calculate and print the result\nprint(min_computer_strength(n, strengths, connections))"}
{"solution": "def max_groups(n, m):\n    return min(m, n - m)\n\n# Read input\nn, m = map(int, input().split())\n\n# Print output\nprint(max_groups(n, m))"}
{"solution": "def min_shovels(k, r):\n    shovels = 1\n    while (shovels * k) % 10 != 0 and (shovels * k) % 10 != r:\n        shovels += 1\n    return shovels\n\n# Read input\nk, r = map(int, input().split())\n\n# Output the result\nprint(min_shovels(k, r))"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # Dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Extract the bounding box\n    piece = []\n    for i in range(min_row, max_row + 1):\n        piece.append(grid[i][min_col:max_col + 1])\n    \n    # Check horizontal placement\n    if width * 2 == m:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j] != piece[i][j + width]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    # Check vertical placement\n    if height * 2 == n:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j] != piece[i + height][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "def min_segments(x1, y1, x2, y2, x3, y3):\n    # Check if all points are collinear on the x-axis or y-axis\n    if x1 == x2 == x3 or y1 == y2 == y3:\n        return 1\n    # Check if two points share the same x or y coordinate\n    elif x1 == x2 or x1 == x3 or x2 == x3 or y1 == y2 or y1 == y3 or y2 == y3:\n        return 2\n    # In all other cases, three segments are needed\n    else:\n        return 3\n\n# Read input\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\n# Output the result\nprint(min_segments(x1, y1, x2, y2, x3, y3))"}
{"solution": "def construct_k_regular_graph_with_bridge(k):\n    if k == 1:\n        return \"YES\\n2 1\\n1 2\"\n    elif k % 2 == 0:\n        return \"NO\"\n    else:\n        n = 2 * k - 1\n        m = k * (k - 1) // 2 + 1\n        graph_description = f\"YES\\n{n} {m}\"\n        for i in range(1, k):\n            for j in range(i + 1, k + 1):\n                graph_description += f\"\\n{i} {j}\"\n        for i in range(k, 2 * k - 1):\n            graph_description += f\"\\n{i} {i + 1}\"\n        graph_description += f\"\\n{2 * k - 1} 1\"\n        return graph_description\n\n# Read input\nk = int(input().strip())\n\n# Construct and print the graph or state that it doesn't exist\nprint(construct_k_regular_graph_with_bridge(k))"}
{"solution": "def preprocess(s, t):\n    n = len(s)\n    m = len(t)\n    prefix_counts = [0] * (n + 1)\n    \n    for i in range(n - m + 1):\n        if s[i:i + m] == t:\n            prefix_counts[i + m] += 1\n    \n    for i in range(1, n + 1):\n        prefix_counts[i] += prefix_counts[i - 1]\n    \n    return prefix_counts\n\ndef count_occurrences(s, t, queries):\n    prefix_counts = preprocess(s, t)\n    results = []\n    \n    for l, r in queries:\n        l -= 1  # Adjusting for 0-based indexing\n        r -= len(t)  # Adjusting the right boundary to include the full length of t\n        if r < l:\n            results.append(0)\n        else:\n            results.append(prefix_counts[r + 1] - prefix_counts[l])\n    \n    return results\n\n# Reading input\nn, m, q = map(int, input().split())\ns = input().strip()\nt = input().strip()\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Processing queries and printing results\nfor result in count_occurrences(s, t, queries):\n    print(result)"}
{"solution": "MOD = 1000000007\n\ndef count_paths(n, k, d):\n    # Initialize a DP table where dp[i][j] represents the number of ways to achieve weight i\n    # with j indicating whether a path has included an edge of weight at least d (j=1) or not (j=0)\n    dp = [[0 for _ in range(2)] for _ in range(n+1)]\n    dp[0][0] = 1  # Base case: one way to achieve weight 0 without any edges\n\n    for weight in range(1, n+1):\n        for edge_weight in range(1, k+1):\n            if weight >= edge_weight:\n                if edge_weight >= d:\n                    dp[weight][1] = (dp[weight][1] + dp[weight-edge_weight][0]) % MOD\n                else:\n                    dp[weight][0] = (dp[weight][0] + dp[weight-edge_weight][0]) % MOD\n                    dp[weight][1] = (dp[weight][1] + dp[weight-edge_weight][1]) % MOD\n\n    return dp[n][1]\n\n# Read input\nn, k, d = map(int, input().split())\n\n# Calculate and print the result\nprint(count_paths(n, k, d))"}
{"solution": "def encrypt_japanese_crossword(n, row):\n    groups = []\n    count = 0\n    \n    for char in row:\n        if char == 'B':\n            count += 1\n        else:\n            if count > 0:\n                groups.append(count)\n                count = 0\n    \n    if count > 0:\n        groups.append(count)\n    \n    print(len(groups))\n    if groups:\n        print(\" \".join(map(str, groups)))\n\n# Example usage:\n# n = int(input())\n# row = input().strip()\n# encrypt_japanese_crossword(n, row)"}
{"solution": "class TextEditor:\n    def __init__(self, n, m, p, cbs, operations):\n        self.n = n\n        self.m = m\n        self.p = p\n        self.cbs = list(cbs)\n        self.operations = operations\n        self.pair_map = self.create_pair_map()\n\n    def create_pair_map(self):\n        stack = []\n        pair_map = {}\n        for i, bracket in enumerate(self.cbs):\n            if bracket == '(':\n                stack.append(i)\n            else:\n                paired_index = stack.pop()\n                pair_map[i] = paired_index\n                pair_map[paired_index] = i\n        return pair_map\n\n    def perform_operations(self):\n        for operation in self.operations:\n            if operation == 'L':\n                self.p = max(1, self.p - 1)\n            elif operation == 'R':\n                self.p = min(self.n, self.p + 1)\n            elif operation == 'D':\n                start, end = sorted([self.p - 1, self.pair_map[self.p - 1]])\n                self.cbs = self.cbs[:start] + self.cbs[end + 1:]\n                self.n -= (end - start + 1)\n                if self.p - 1 == end:\n                    self.p = max(1, start)\n                else:\n                    self.p = min(self.n, start + 1)\n                self.pair_map = self.create_pair_map()\n        return ''.join(self.cbs)\n\ndef main():\n    n, m, p = map(int, input().split())\n    cbs = input().strip()\n    operations = input().strip()\n    editor = TextEditor(n, m, p, cbs, operations)\n    result = editor.perform_operations()\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_valid_y(n, questions_answers):\n    min_y = -2 * 10**9\n    max_y = 2 * 10**9\n    \n    for qa in questions_answers:\n        sign, x, answer = qa.split()\n        x = int(x)\n        \n        if sign == '>':\n            if answer == 'Y':\n                min_y = max(min_y, x + 1)\n            else:\n                max_y = min(max_y, x)\n        elif sign == '<':\n            if answer == 'Y':\n                max_y = min(max_y, x - 1)\n            else:\n                min_y = max(min_y, x)\n        elif sign == '>=':\n            if answer == 'Y':\n                min_y = max(min_y, x)\n            else:\n                max_y = min(max_y, x - 1)\n        elif sign == '<=':\n            if answer == 'Y':\n                max_y = min(max_y, x)\n            else:\n                min_y = max(min_y, x + 1)\n    \n    if min_y > max_y:\n        return \"Impossible\"\n    else:\n        return min_y\n\n# Read input\nn = int(input())\nquestions_answers = [input() for _ in range(n)]\n\n# Find and print the result\nprint(find_valid_y(n, questions_answers))"}
{"solution": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef count_periods(a, b):\n    if a == 0 or b == 0:\n        return 1\n    total_length = a + b\n    gcd_ab = gcd(a, b)\n    min_period = total_length // max(a // gcd_ab, b // gcd_ab)\n    max_period = total_length // gcd_ab\n    return max_period - min_period + 1\n\n# Read input\na, b = map(int, input().split())\n\n# Calculate and print the number of different periods\nprint(count_periods(a, b))"}
{"solution": "def generate_names(n, k, conditions):\n    # Predefined list of unique names\n    names = [\"Adam\", \"Bob\", \"Charlie\", \"David\", \"Edward\", \"Frank\", \"George\", \"Henry\", \"Isaac\", \"Jack\",\n             \"Kyle\", \"Liam\", \"Mason\", \"Noah\", \"Oliver\", \"Parker\", \"Quinn\", \"Ryan\", \"Samuel\", \"Thomas\",\n             \"Ulysses\", \"Victor\", \"William\", \"Xavier\", \"Yusuf\", \"Zachary\"]\n    \n    # Initialize the result list with the first k names\n    result = names[:k]\n    \n    for i in range(1, n - k + 1):\n        if conditions[i - 1] == \"YES\":\n            # If the group should be effective, add a new unique name\n            result.append(names[k + i - 1])\n        else:\n            # If the group should not be effective, repeat the last name\n            result.append(result[-1])\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\nconditions = input().split()\n\n# Generate and print the names\nnames = generate_names(n, k, conditions)\nprint(\" \".join(names))"}
{"solution": "def min_operations_to_equal(a, b):\n    def count_factors(n, factor):\n        count = 0\n        while n % factor == 0:\n            n //= factor\n            count += 1\n        return count, n\n\n    a2, a = count_factors(a, 2)\n    a3, a = count_factors(a, 3)\n    a5, a = count_factors(a, 5)\n    \n    b2, b = count_factors(b, 2)\n    b3, b = count_factors(b, 3)\n    b5, b = count_factors(b, 5)\n    \n    if a != b:\n        return -1\n    \n    operations = abs(a2 - b2) + abs(a3 - b3) + abs(a5 - b5)\n    \n    return operations\n\n# Read input\na, b = map(int, input().split())\n\n# Print output\nprint(min_operations_to_equal(a, b))"}
{"solution": "def min_cost_to_palindrome(n, a, b, c):\n    # Initialize the cost to 0\n    cost = 0\n    \n    # Iterate through the first half of the dancers\n    for i in range(n // 2):\n        left = c[i]\n        right = c[n - 1 - i]\n        \n        # If both dancers need suits, choose the cheaper one for both\n        if left == 2 and right == 2:\n            cost += 2 * min(a, b)\n        # If one dancer needs a suit, choose the suit color based on the other dancer\n        elif left == 2:\n            cost += a if right == 0 else b\n        elif right == 2:\n            cost += a if left == 0 else b\n        # If both dancers have suits but they are different, it's impossible to form a palindrome\n        elif left != right:\n            return -1\n    \n    # If there's a middle dancer in an odd-numbered group and they need a suit, choose the cheaper one\n    if n % 2 == 1 and c[n // 2] == 2:\n        cost += min(a, b)\n    \n    return cost\n\n# Read input\nn, a, b = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_cost_to_palindrome(n, a, b, c))"}
{"solution": "def paint_cube(k):\n    if k == 1:\n        return -1\n    \n    # Initialize the cube with 'b' (black)\n    cube = [['b' for _ in range(k)] for _ in range(k)]\n    \n    # Paint the cube according to the conditions\n    for layer in range(k):\n        for row in range(k):\n            for col in range(k):\n                # Paint every second unit cube in the layer white\n                if (layer + row + col) % 2 == 0:\n                    cube[layer][row][col] = 'w'\n    \n    return cube\n\ndef print_cube(cube):\n    if cube == -1:\n        print(cube)\n    else:\n        for layer in cube:\n            for row in layer:\n                print(''.join(row))\n            print()  # Print an extra line between layers\n\n# Read input\nk = int(input())\n\n# Solve the problem and print the result\nresult = paint_cube(k)\nprint_cube(result)"}
{"solution": "def largest_lovely_number(n):\n    import math\n    from collections import Counter\n\n    def prime_factors(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            while (n % i) == 0:\n                factors.append(i)\n                n //= i\n            i += 1\n        if n > 1:\n            factors.append(n)\n        return factors\n\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n    \n    lovely_number = 1\n    for prime, count in factor_counts.items():\n        lovely_number *= prime\n    \n    return lovely_number\n\n# Read input\nn = int(input())\n\n# Print output\nprint(largest_lovely_number(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    # Check for adjacent occupied seats\n    for i in range(n - 1):\n        if seating[i] == '1' and seating[i + 1] == '1':\n            return \"No\"\n    \n    # Check for possible additional seating\n    for i in range(n):\n        if seating[i] == '0':\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nn = int(input().strip())\nseating = input().strip()\n\n# Print output\nprint(is_maximal_seating(n, seating))"}
{"solution": "def find_possible_k(n, a):\n    possible_k = []\n    \n    # Check each possible value of k from 1 to n\n    for k in range(1, n + 1):\n        valid = True\n        # Calculate the expected differences based on k\n        differences = [a[i] - a[i - 1] for i in range(1, n + 1)]\n        for i in range(k, n):\n            if differences[i] != differences[i % k]:\n                valid = False\n                break\n        if valid:\n            possible_k.append(k)\n    \n    return possible_k\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\na = [0] + a  # Add a_0 which is always 0\n\n# Find all possible values of k\npossible_k = find_possible_k(n, a)\n\n# Output the result\nprint(len(possible_k))\nprint(' '.join(map(str, possible_k)))"}
{"solution": "def can_form_equal_teams(scores):\n    total_score = sum(scores)\n    # Since we need to form two teams of three, the total score must be even\n    if total_score % 2 != 0:\n        return \"NO\"\n    \n    half_score = total_score // 2\n    # Check if we can find a combination of three scores that sum up to half the total score\n    for i in range(6):\n        for j in range(i + 1, 6):\n            for k in range(j + 1, 6):\n                if scores[i] + scores[j] + scores[k] == half_score:\n                    return \"YES\"\n    return \"NO\"\n\n# Read input\nscores = list(map(int, input().split()))\n\n# Output result\nprint(can_form_equal_teams(scores))"}
{"solution": "def count_2_3_integers(l, r):\n    count = 0\n    x = 0\n    while 2**x <= r:\n        y = 0\n        while 2**x * 3**y <= r:\n            if l <= 2**x * 3**y:\n                count += 1\n            y += 1\n            if 2**x * 3**y > r:\n                break\n        x += 1\n        if 2**x > r:\n            break\n    return count\n\n# Read input\nl, r = map(int, input().split())\n\n# Output the result\nprint(count_2_3_integers(l, r))"}
{"solution": "def find_candies_eaten(n, k):\n    # Initialize the number of candies eaten\n    candies_eaten = 0\n    \n    # Calculate the maximum number of candies that could be in the box if only adding candies\n    max_candies = (n * (n + 1)) // 2 - (n - 1)\n    \n    # If the final number of candies is less than or equal to the maximum possible by adding only,\n    # then the number of candies eaten is the difference between the maximum and the final count\n    if k <= max_candies:\n        candies_eaten = max_candies - k\n    else:\n        # If the final number of candies is more than the maximum possible by adding only,\n        # then we need to find the exact number of candies eaten by solving the equation\n        # (n * (n + 1)) // 2 - x * (x + 1) // 2 = k, where x is the number of candies eaten\n        # This can be solved using binary search since it's a monotonic function\n        left, right = 0, n\n        while left < right:\n            mid = (left + right) // 2\n            if (n * (n + 1)) // 2 - (mid * (mid + 1)) // 2 >= k:\n                left = mid + 1\n            else:\n                right = mid\n        candies_eaten = left\n    \n    return candies_eaten\n\n# Read input\nn, k = map(int, input().split())\n\n# Find and print the number of candies eaten\nprint(find_candies_eaten(n, k))"}
{"solution": "def can_form_triangle(n, lengths):\n    lengths.sort()\n    for i in range(n - 2):\n        if lengths[i] + lengths[i + 1] > lengths[i + 2]:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\nlengths = list(map(int, input().split()))\n\n# Output result\nprint(can_form_triangle(n, lengths))"}
{"solution": "def can_achieve_configuration(x, y):\n    # Check if it's possible to achieve the desired configuration\n    # Imp starts with 1 original toy, so y must be at least 1\n    # The machine can only create copies if there are already copies, so x must be even if y is 1\n    # For each additional original toy created, the number of copies must be even\n    if y < 1:\n        return \"No\"\n    if y == 1:\n        return \"Yes\" if x == 0 else \"No\"\n    # If y > 1, we need to check if it's possible to create (y-1) original toys and x copies\n    # Each original toy creation (except the first one) consumes one original toy and produces one original toy and one copy\n    # So, we need to check if we can create (y-1) original toys and have enough operations left to create x copies\n    # Each original toy creation operation can also create one copy, so we need to account for that\n    if (y - 1) <= x and (x - (y - 1)) % 2 == 0:\n        return \"Yes\"\n    return \"No\"\n\n# Read input\nx, y = map(int, input().split())\n\n# Output result\nprint(can_achieve_configuration(x, y))"}
{"solution": "def maximize_rating(n, k, skills):\n    # Calculate the initial total rating\n    initial_rating = sum(a // 10 for a in skills)\n    \n    # Calculate the number of units needed to increase each skill to the next multiple of 10\n    units_needed = [(10 - (a % 10)) % 10 for a in skills]\n    \n    # Sort skills based on the number of units needed to reach the next multiple of 10\n    sorted_skills = sorted(enumerate(skills), key=lambda x: (10 - (x[1] % 10)) % 10)\n    \n    # Allocate units to increase skills\n    for idx, skill in sorted_skills:\n        if k >= units_needed[idx] and skill < 100:\n            # Calculate the maximum units we can use for this skill\n            max_units_for_skill = min(k, units_needed[idx], 100 - skill)\n            # Update the skill and the remaining units\n            skills[idx] += max_units_for_skill\n            k -= max_units_for_skill\n    \n    # Recalculate the total rating after allocating units\n    final_rating = sum(a // 10 for a in skills)\n    \n    return final_rating\n\n# Read input\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Output the maximum total rating\nprint(maximize_rating(n, k, skills))"}
{"solution": "def find_smallest_pretty_integer(n, m, list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    common_digits = set1.intersection(set2)\n    if common_digits:\n        return min(common_digits)\n    \n    min1 = min(list1)\n    min2 = min(list2)\n    \n    smallest_pretty = min(int(str(min1) + str(min2)), int(str(min2) + str(min1)))\n    return smallest_pretty\n\n# Reading input\nn, m = map(int, input().split())\nlist1 = list(map(int, input().split()))\nlist2 = list(map(int, input().split()))\n\n# Output the result\nprint(find_smallest_pretty_integer(n, m, list1, list2))"}
{"solution": "def max_problems_solved(n, k):\n    total_time_available = 240 - k  # Total time available to solve problems\n    problems_solved = 0\n    time_spent = 0\n\n    for i in range(1, n + 1):\n        time_to_solve = 5 * i\n        if time_spent + time_to_solve <= total_time_available:\n            time_spent += time_to_solve\n            problems_solved += 1\n        else:\n            break\n\n    return problems_solved\n\n# Reading input\nn, k = map(int, input().split())\n\n# Printing output\nprint(max_problems_solved(n, k))"}
{"solution": "def max_teams(n, x, y, a):\n    a.sort()\n    double_sided = x\n    single_sided = y\n    count = 0\n\n    for pages in a:\n        double_needed = pages // 2\n        single_needed = pages % 2\n\n        if double_needed <= double_sided:\n            double_sided -= double_needed\n            if single_needed <= single_sided:\n                single_sided -= single_needed\n                count += 1\n            else:\n                double_sided += double_needed\n                break\n        else:\n            remaining_pages = pages - 2 * double_sided\n            if remaining_pages <= single_sided:\n                single_sided -= remaining_pages\n                double_sided = 0\n                count += 1\n            else:\n                break\n\n    return count\n\n# \u0427\u0442\u0435\u043d\u0438\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\n# \u0412\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\nprint(max_teams(n, x, y, a))"}
{"solution": "def count_divisors(n):\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return len(divisors)\n\n# Read input\nb = int(input().strip())\n\n# Calculate the number of distinct values\nresult = count_divisors(b)\n\n# Print the result\nprint(result)"}
{"solution": "def count_falling_positions(n, bumpers):\n    # Initialize the count of positions where the ball will fall\n    count = 0\n    \n    # Check for '<' at the beginning and '>' at the end\n    for i in range(n):\n        if bumpers[i] == '<' or bumpers[n - 1 - i] == '>':\n            count += 1\n        else:\n            break\n    \n    return count\n\n# Read input\nn = int(input())\nbumpers = input()\n\n# Calculate and print the result\nprint(count_falling_positions(n, bumpers))"}
{"solution": "def max_rectangle_area(n, lengths):\n    from collections import Counter\n    \n    # Count the occurrences of each length\n    length_counter = Counter(lengths)\n    \n    # Lists to store the pairs of lengths that can form rectangles\n    pairs = []\n    \n    # Process each unique length\n    for length in list(length_counter):\n        # Reduce the length if there are more than 2 sticks of the same length\n        while length_counter[length] >= 2:\n            pairs.append(length)\n            length_counter[length] -= 2\n        \n        # If there's one stick left, try reducing its length by 1 and check again\n        if length_counter[length] == 1 and length > 2:\n            length_counter[length - 1] += 1\n            length_counter[length] -= 1\n    \n    # Sort the pairs in descending order to maximize the area\n    pairs.sort(reverse=True)\n    \n    # Calculate the maximum total area\n    max_area = 0\n    for i in range(0, len(pairs) - 1, 2):\n        max_area += pairs[i] * pairs[i + 1]\n    \n    return max_area\n\n# Read input\nn = int(input())\nlengths = list(map(int, input().split()))\n\n# Output the result\nprint(max_rectangle_area(n, lengths))"}
{"solution": "from collections import defaultdict\nfrom itertools import permutations\n\ndef restore_numbers(n, numbers):\n    # Create a dictionary to map each unique letter to a digit\n    letter_to_digit = {}\n    unique_letters = set(''.join(numbers))\n    \n    # Generate all possible permutations of digits 0-9 for the unique letters\n    min_sum = float('inf')\n    for perm in permutations(range(10), len(unique_letters)):\n        # Skip if the first letter is mapped to 0 and it's used as a leading character\n        if perm[0] == 0 and any(num[0] == list(unique_letters)[0] for num in numbers):\n            continue\n        \n        # Map letters to digits based on the current permutation\n        letter_to_digit = {letter: str(digit) for letter, digit in zip(unique_letters, perm)}\n        \n        # Restore the numbers and calculate their sum\n        restored_sum = sum(int(''.join(letter_to_digit[letter] for letter in num)) for num in numbers)\n        min_sum = min(min_sum, restored_sum)\n    \n    return min_sum\n\n# Read input\nn = int(input())\nnumbers = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(restore_numbers(n, numbers))"}
{"solution": "def max_teams(n, m):\n    # Binary search to find the maximum number of teams\n    low, high = 0, min(n, m, (n + m) // 3)\n    \n    while low < high:\n        mid = (low + high + 1) // 2\n        if mid <= n and mid <= m and 2 * mid <= n + m:\n            low = mid\n        else:\n            high = mid - 1\n    \n    return low\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    n = len(s)\n    \n    # Check for \"AB\" followed by \"BA\"\n    found_AB = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"AB\":\n            found_AB = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"BA\":\n                    print(\"YES\")\n                    return\n            break\n    \n    # Check for \"BA\" followed by \"AB\"\n    found_BA = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"BA\":\n            found_BA = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"AB\":\n                    print(\"YES\")\n                    return\n            break\n    \n    # If neither condition is met\n    print(\"NO\")\n\n# Example usage\ns = input().strip()\ncheck_substrings(s)"}
{"solution": "def can_monsters_eat(n, initial_weights, k, final_weights):\n    if n != k + sum(final_weights):\n        return \"NO\"\n    \n    def find_eaters(weights, target_weights):\n        eaters = []\n        stack = []\n        for weight in weights:\n            if weight in target_weights:\n                if stack:\n                    eaters.append(stack)\n                    stack = []\n            stack.append(weight)\n        if stack:\n            eaters.append(stack)\n        return eaters\n    \n    def simulate_eating(eaters, target_weights):\n        actions = []\n        for i, eater_group in enumerate(eaters):\n            while len(eater_group) > 1:\n                j = 0\n                while j < len(eater_group) - 1:\n                    if eater_group[j] > eater_group[j + 1]:\n                        eater_group[j] += eater_group[j + 1]\n                        actions.append((i + len(actions) + 1, 'L'))\n                        eater_group.pop(j + 1)\n                    else:\n                        j += 1\n                eater_group = eater_group[::-1]\n                j = 0\n                while j < len(eater_group) - 1:\n                    if eater_group[j] > eater_group[j + 1]:\n                        eater_group[j] += eater_group[j + 1]\n                        actions.append((len(eater_group) - j, 'R'))\n                        eater_group.pop(j + 1)\n                    else:\n                        j += 1\n                eater_group = eater_group[::-1]\n        return actions\n    \n    eaters = find_eaters(initial_weights, final_weights)\n    actions = simulate_eating(eaters, final_weights)\n    \n    if len(actions) == n - k:\n        result = [\"YES\"]\n        for action in actions:\n            result.append(f\"{action[0]} {action[1]}\")\n        return \"\\n\".join(result)\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ninitial_weights = list(map(int, input().split()))\nk = int(input())\nfinal_weights = list(map(int, input().split()))\n\n# Output result\nprint(can_monsters_eat(n, initial_weights, k, final_weights))"}
{"solution": "def is_possible_to_assign(R, B, spaceships, bases):\n    if R != B:\n        return \"No\"\n    \n    # Sort spaceships and bases by their x-coordinate for a greedy approach\n    spaceships.sort(key=lambda x: x[0])\n    bases.sort(key=lambda x: x[0])\n    \n    # Check for intersection of paths\n    for i in range(R):\n        # Path from spaceship to base\n        for j in range(i + 1, R):\n            # Check if the lines intersect\n            if do_lines_intersect(spaceships[i], bases[i], spaceships[j], bases[j]):\n                return \"No\"\n    \n    return \"Yes\"\n\ndef do_lines_intersect(p1, q1, p2, q2):\n    # Check if the two line segments intersect using orientation\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n    \n    # General case\n    if o1 != o2 and o3 != o4:\n        return True\n    \n    # Special Cases\n    # p1, q1 and p2 are collinear and p2 lies on segment p1q1\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    \n    # p1, q1 and q2 are collinear and q2 lies on segment p1q1\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    \n    # p2, q2 and p1 are collinear and p1 lies on segment p2q2\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    \n    # p2, q2 and q1 are collinear and q1 lies on segment p2q2\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n    \n    return False\n\ndef orientation(p, q, r):\n    # To find orientation of ordered triplet (p, q, r).\n    # The function returns following values\n    # 0 --> p, q and r are collinear\n    # 1 --> Clockwise\n    # 2 --> Counterclockwise\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0\n    return 1 if val > 0 else 2\n\ndef on_segment(p, q, r):\n    # Given three collinear points p, q, r, the function checks if\n    # point q lies on line segment 'pr'\n    return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and \\\n           q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])\n\n# Read input\nR, B = map(int, input().split())\nspaceships = [tuple(map(int, input().split())) for _ in range(R)]\nbases = [tuple(map(int, input().split())) for _ in range(B)]\n\n# Output result\nprint(is_possible_to_assign(R, B, spaceships, bases))"}
{"solution": "def max_power_of_two_divisor(sequence):\n    max_power = 0\n    count = 0\n    for number in sequence:\n        power = 0\n        while number % 2 == 0:\n            number //= 2\n            power += 1\n        if power > max_power:\n            max_power = power\n            count = 1\n        elif power == max_power:\n            count += 1\n    return max_power, count\n\ndef main():\n    n = int(input())\n    sequence = list(map(int, input().split()))\n    r, count = max_power_of_two_divisor(sequence)\n    print(2**r, count)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_clicks_to_transform(n, m):\n    clicks = 0\n    while m > n:\n        if m % 2 == 0:\n            m //= 2\n        else:\n            m += 1\n        clicks += 1\n    return clicks + (n - m)\n\n# Read input\nn, m = map(int, input().split())\n\n# Output the result\nprint(min_clicks_to_transform(n, m))"}
{"solution": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            if self.rank[rootX] > self.rank[rootY]:\n                self.parent[rootY] = rootX\n            elif self.rank[rootX] < self.rank[rootY]:\n                self.parent[rootX] = rootY\n            else:\n                self.parent[rootY] = rootX\n                self.rank[rootX] += 1\n            return True\n        return False\n\ndef isTree(n, segments):\n    uf = UnionFind(n)\n    edges = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if segments[i][0] < segments[j][0] < segments[i][1] < segments[j][1] or \\\n               segments[j][0] < segments[i][0] < segments[j][1] < segments[i][1]:\n                continue\n            if segments[i][0] < segments[j][0] < segments[j][1] < segments[i][1] or \\\n               segments[j][0] < segments[i][0] < segments[i][1] < segments[j][1]:\n                continue\n            if not uf.union(i, j):\n                return \"NO\"\n            edges += 1\n            if edges == n - 1:\n                break\n    return \"YES\" if edges == n - 1 else \"NO\"\n\nn = int(input().strip())\nsegments = [tuple(map(int, input().strip().split())) for _ in range(n)]\nprint(isTree(n, segments))"}
{"solution": "def longest_ddos_period(n, requests):\n    max_length = 0\n    for start in range(n):\n        total_requests = 0\n        for end in range(start, n):\n            total_requests += requests[end]\n            if total_requests > 100 * (end - start + 1):\n                max_length = max(max_length, end - start + 1)\n    return max_length\n\n# Reading input\nn = int(input())\nrequests = list(map(int, input().split()))\n\n# Output the result\nprint(longest_ddos_period(n, requests))"}
{"solution": "def can_dissatisfaction_be_exactly_k(n, k, sequence):\n    if k == 0:\n        return \"YES\" if 'N' not in sequence else \"NO\"\n    \n    max_dissatisfaction = 0\n    current_dissatisfaction = 0\n    \n    for episode in sequence:\n        if episode == 'N':\n            current_dissatisfaction += 1\n            max_dissatisfaction = max(max_dissatisfaction, current_dissatisfaction)\n        else:\n            current_dissatisfaction = 0\n    \n    if max_dissatisfaction == k:\n        return \"YES\"\n    \n    for i in range(n - k + 1):\n        if sequence[i:i+k].count('?') == k:\n            if (i == 0 or sequence[i-1] != 'N') and (i + k == n or sequence[i+k] != 'N'):\n                return \"YES\"\n    \n    return \"NO\"\n\n# Reading input\nn, k = map(int, input().split())\nsequence = input().strip()\n\n# Output the result\nprint(can_dissatisfaction_be_exactly_k(n, k, sequence))"}
{"solution": "def count_possible_values(N, X, D):\n    # If D is 0, the sequence is a constant sequence, and the difference is always 0\n    if D == 0:\n        return 1\n    \n    # Calculate the sequence\n    sequence = [X + i * D for i in range(N)]\n    \n    # The minimum and maximum possible sums of Takahashi's and Aoki's sets\n    min_sum_Takahashi = min(sequence)\n    max_sum_Aoki = sum(sequence) - min_sum_Takahashi\n    \n    # The range of possible values of S - T\n    min_diff = min_sum_Takahashi - max_sum_Aoki\n    max_diff = -min_diff\n    \n    # The number of possible values of S - T is the range divided by the common difference (D) plus 1\n    # We need to handle the case where D is negative by taking its absolute value\n    return (max_diff - min_diff) // abs(D) + 1\n\n# Read input\nN, X, D = map(int, input().split())\n\n# Output the result\nprint(count_possible_values(N, X, D))"}
{"solution": "def did_anton_perform_good(n, participants):\n    for participant in participants:\n        handle, before, after = participant\n        if before >= 2400 and after > before:\n            return \"YES\"\n    return \"NO\"\n\n# Reading input\nn = int(input())\nparticipants = [input().split() for _ in range(n)]\nparticipants = [(handle, int(before), int(after)) for handle, before, after in participants]\n\n# Outputting the result\nprint(did_anton_perform_good(n, participants))"}
{"solution": "def count_missed_trains(s):\n    # Convert the binary string to an integer\n    s_decimal = int(s, 2)\n    \n    # Initialize the count of missed trains\n    count = 0\n    \n    # Initialize the power of 4\n    power_of_4 = 1\n    \n    # Loop until the power of 4 is less than s_decimal\n    while power_of_4 < s_decimal:\n        # Increment the count of missed trains\n        count += 1\n        \n        # Calculate the next power of 4\n        power_of_4 *= 4\n    \n    return count\n\n# Read the input\ns = input().strip()\n\n# Output the result\nprint(count_missed_trains(s))"}
{"solution": "def min_rows_for_mirroring(n, m, matrix_a):\n    # Function to check if two rows are symmetric\n    def is_symmetric(row1, row2):\n        return row1 == row2\n\n    # Start with the assumption that the minimum number of rows is n\n    min_rows = n\n\n    # Check for symmetry and determine the minimum number of rows needed\n    for i in range(n // 2):\n        if is_symmetric(matrix_a[i], matrix_a[n - i - 1]):\n            continue\n        else:\n            min_rows = n - i\n            break\n\n    return min_rows\n\n# Read input\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(min_rows_for_mirroring(n, m, matrix_a))"}
{"solution": "def max_orders(n, orders):\n    # Sort orders by their finish time\n    orders.sort(key=lambda x: x[1])\n    \n    # Initialize variables to keep track of the last end time and the count of accepted orders\n    last_end_time = -1\n    accepted_orders_count = 0\n    \n    # Iterate through the sorted orders\n    for order in orders:\n        start_time, end_time = order\n        # If the start time of the current order is after the last end time, accept this order\n        if start_time > last_end_time:\n            accepted_orders_count += 1\n            last_end_time = end_time\n    \n    return accepted_orders_count\n\n# Read input\nn = int(input())\norders = [list(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nprint(max_orders(n, orders))"}
{"solution": "def can_vova_avoid_boredom(n, k, tables, formulas):\n    max_tables_in_row = 0\n    max_formulas_in_row = 0\n    current_tables_in_row = 0\n    current_formulas_in_row = 0\n\n    for i in range(n):\n        current_tables_in_row += tables[i]\n        current_formulas_in_row += formulas[i]\n\n        # If the current row exceeds k, we need to rearrange\n        while current_tables_in_row > k or current_formulas_in_row > k:\n            # Try to rearrange by swapping tables and formulas\n            if current_tables_in_row > k and current_formulas_in_row < k:\n                # Swap as many tables as needed to keep below k\n                swap_count = min(current_tables_in_row - k, k - current_formulas_in_row)\n                current_tables_in_row -= swap_count\n                current_formulas_in_row += swap_count\n            elif current_formulas_in_row > k and current_tables_in_row < k:\n                # Swap as many formulas as needed to keep below k\n                swap_count = min(current_formulas_in_row - k, k - current_tables_in_row)\n                current_formulas_in_row -= swap_count\n                current_tables_in_row += swap_count\n            else:\n                # If we can't rearrange to keep both below k, it's impossible\n                return \"NO\"\n\n        # Update the max counts\n        max_tables_in_row = max(max_tables_in_row, current_tables_in_row)\n        max_formulas_in_row = max(max_formulas_in_row, current_formulas_in_row)\n\n        # Reset the counts if we reach exactly k to simulate a break\n        if current_tables_in_row == k:\n            current_tables_in_row = 0\n        if current_formulas_in_row == k:\n            current_formulas_in_row = 0\n\n    # If we never exceeded k, it's possible\n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ntables = list(map(int, input().split()))\nformulas = list(map(int, input().split()))\n\n# Output result\nprint(can_vova_avoid_boredom(n, k, tables, formulas))"}
{"solution": "def can_human_guarantee_victory(n, k, coefficients):\n    # Check if the polynomial is already divisible by Q(x) = x - k\n    def is_divisible_by_q(coefficients, k):\n        # Evaluate the polynomial at x = k\n        result = 0\n        for coeff in reversed(coefficients):\n            result = result * k + coeff\n        return result == 0\n\n    # If all coefficients are defined, check divisibility directly\n    if '?' not in coefficients:\n        return \"Yes\" if is_divisible_by_q(coefficients, k) else \"No\"\n\n    # If there are undefined coefficients, simulate optimal play\n    # The human can always guarantee a victory if they can set a coefficient\n    # to make the polynomial divisible by Q(x) = x - k\n    # The computer will try to prevent this by setting coefficients to non-zero values\n    # However, if the human can always find a way to set a coefficient to make the polynomial divisible,\n    # they can guarantee a victory.\n\n    # For simplicity, let's assume the human can always find a way to set a coefficient\n    # to make the polynomial divisible by Q(x) = x - k, given the optimal play.\n    # This assumption is based on the fact that the human can choose any real number as a coefficient,\n    # which gives them a lot of flexibility.\n\n    return \"Yes\"\n\n# Read input\nn, k = map(int, input().split())\ncoefficients = [input().strip() for _ in range(n + 1)]\ncoefficients = [int(coeff) if coeff != '?' else '?' for coeff in coefficients]\n\n# Determine if the human can guarantee a victory\nresult = can_human_guarantee_victory(n, k, coefficients)\n\n# Print the result\nprint(result)"}
{"solution": "def smallest_prime_factor(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return i\n    return n\n\ndef find_smallest_X0(X2):\n    # Start from the smallest possible X0 and check if it can lead to X2\n    for X0 in range(3, X2 + 1):\n        # Find the smallest prime factor for the current X0\n        p1 = smallest_prime_factor(X0)\n        # Calculate the next number after Alice's turn\n        X1 = X0 if X0 % p1 == 0 else ((X0 // p1) + 1) * p1\n        # Find the smallest prime factor for the next number\n        p2 = smallest_prime_factor(X1)\n        # Calculate the next number after Bob's turn\n        X2_candidate = X1 if X1 % p2 == 0 else ((X1 // p2) + 1) * p2\n        # If the calculated X2 matches the given X2, we found the smallest X0\n        if X2_candidate == X2:\n            return X0\n    return X2  # In case no smaller X0 is found, X2 itself is the smallest X0\n\n# Read input\nX2 = int(input().strip())\n\n# Output the result\nprint(find_smallest_X0(X2))"}
{"solution": "def min_p_binary_summands(n, p):\n    def can_form_n(n, count):\n        # Check if we can form n using 'count' number of p-binary numbers\n        target = n - count * p\n        if target <= 0:\n            return False\n        # Count the number of 1s in the binary representation of target\n        ones_count = bin(target).count('1')\n        return ones_count <= count and target >= count\n\n    for count in range(1, 32):  # Since 2^31 > 10^9, we don't need to check more than 31 summands\n        if can_form_n(n, count):\n            return count\n    return -1\n\n# Example usage:\n# n, p = map(int, input().split())\n# print(min_p_binary_summands(n, p))"}
{"solution": "def minimize_integer(n, k, S):\n    S = list(S)  # Convert the string to a list for easier manipulation\n    \n    # Change the first digit to '1' if it's not already '1' and we have changes left\n    if S[0] != '1' and k > 0:\n        S[0] = '1'\n        k -= 1\n    \n    # Change the rest of the digits to '0' if they're not already '0' and we have changes left\n    for i in range(1, n):\n        if S[i] != '0' and k > 0:\n            S[i] = '0'\n            k -= 1\n        if k == 0:\n            break\n    \n    return ''.join(S)  # Convert the list back to a string\n\n# Read input\nn, k = map(int, input().split())\nS = input().strip()\n\n# Output the result\nprint(minimize_integer(n, k, S))"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_min_v(cnt_1, cnt_2, x, y):\n    # Ensure x and y are prime numbers\n    assert is_prime(x) and is_prime(y), \"x and y must be prime numbers\"\n\n    # Start with the smallest possible v that could satisfy the conditions\n    v = max(cnt_1 * x, cnt_2 * y)\n\n    # Adjust v to ensure we can find enough numbers for both friends\n    while True:\n        # Calculate the number of valid numbers for each friend up to v\n        valid_for_1 = v - v // x\n        valid_for_2 = v - v // y\n        common_valid = v - v // x - v // y + v // (x * y)\n\n        # Check if we have enough valid numbers for both friends\n        if valid_for_1 >= cnt_1 and valid_for_2 >= cnt_2 and common_valid >= cnt_1 + cnt_2:\n            return v\n        v += 1\n\n# Example usage (commented out as per request)\n# cnt_1, cnt_2, x, y = 3, 1, 2, 3\n# print(find_min_v(cnt_1, cnt_2, x, y))  # Output: 5\n\n# cnt_1, cnt_2, x, y = 1, 3, 2, 3\n# print(find_min_v(cnt_1, cnt_2, x, y))  # Output: 4"}
{"solution": "def predict_bear_position(n, sx, sy, dx, dy, t):\n    # Initial speed increment\n    k = sx + sy\n    # Update speed with the initial increment\n    dx += k\n    dy += k\n    \n    # Function to calculate the new position after one second\n    def move(x, y, dx, dy):\n        x = (x + dx - 1) % n + 1\n        y = (y + dy - 1) % n + 1\n        return x, y\n    \n    # Simulate the bear's movement for t seconds\n    for _ in range(t):\n        sx, sy = move(sx, sy, dx, dy)\n        # After eating the raspberry, the bear increases his speed\n        k = sx + sy\n        dx += k\n        dy += k\n    \n    return sx, sy\n\n# Read input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Predict and print the final position\nprint(*predict_bear_position(n, sx, sy, dx, dy, t))"}
{"solution": "def make_nice_word(s):\n    if len(s) < 26:\n        return \"-1\"\n    \n    for i in range(len(s) - 25):\n        substring = s[i:i+26]\n        if '?' in substring:\n            missing_letters = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ') - set(substring.replace('?', ''))\n            if len(missing_letters) == substring.count('?'):\n                replacement_letters = list(missing_letters)\n                new_substring = list(substring)\n                for j in range(26):\n                    if new_substring[j] == '?':\n                        new_substring[j] = replacement_letters.pop(0)\n                s = s[:i] + ''.join(new_substring) + s[i+26:]\n                return s.replace('?', 'A')\n    \n    return \"-1\"\n\n# Read input\ns = input().strip()\n\n# Output result\nprint(make_nice_word(s))"}
{"solution": "def can_divide_apples(n, weights):\n    # Count the number of apples of each weight\n    count_100 = weights.count(100)\n    count_200 = weights.count(200)\n    \n    # If the total weight is not divisible by 200, it's impossible to divide equally\n    if (count_100 * 100 + count_200 * 200) % 200 != 0:\n        return \"NO\"\n    \n    # If there are an even number of 200-gram apples, they can be divided equally\n    if count_200 % 2 == 0:\n        return \"YES\"\n    \n    # If there are at least two 100-gram apples for each 200-gram apple that cannot be paired, it's possible\n    if count_100 >= 2 and count_200 % 2 == 1:\n        return \"YES\"\n    \n    # In all other cases, it's impossible to divide equally\n    return \"NO\"\n\n# Read input\nn = int(input())\nweights = list(map(int, input().split()))\n\n# Print output\nprint(can_divide_apples(n, weights))"}
{"solution": "def min_time_to_turn_off_lights(n, m, building):\n    total_time = 0\n    current_position = 0  # Starting at the left stairs\n\n    for floor in range(n):\n        # Find the leftmost and rightmost rooms with lights on\n        left_light = m + 1\n        right_light = 0\n        for room in range(1, m + 1):\n            if building[floor][room] == '1':\n                left_light = min(left_light, room)\n                right_light = max(right_light, room)\n\n        # If there are no lights on, skip this floor\n        if left_light > m and right_light == 0:\n            continue\n\n        # Calculate the time to turn off lights on this floor\n        if left_light == right_light:  # Only one light on\n            total_time += abs(current_position - left_light)\n        else:\n            # Determine the best path: left to right or right to left\n            left_to_right = abs(current_position - left_light) + (right_light - left_light)\n            right_to_left = abs(current_position - right_light) + (right_light - left_light)\n            total_time += min(left_to_right, right_to_left)\n\n        # Update current position to the rightmost light\n        current_position = right_light\n\n        # Add the time to go to the next floor\n        total_time += 1\n\n    # Subtract the last added 1 because we don't need to go to the next floor at the end\n    return total_time - 1\n\n# Read input\nn, m = map(int, input().split())\nbuilding = [input() for _ in range(n)]\n\n# Calculate and print the result\nprint(min_time_to_turn_off_lights(n, m, building))"}
{"solution": "def find_min_trap_cost(n, costs, transitions):\n    visited = [False] * n\n    in_stack = [False] * n\n    min_cost = 0\n\n    def dfs(node):\n        stack = []\n        while True:\n            if visited[node]:\n                if in_stack[node]:\n                    # Found a cycle, calculate the minimum cost in this cycle\n                    cycle_min_cost = float('inf')\n                    while stack:\n                        cycle_node = stack.pop()\n                        in_stack[cycle_node] = False\n                        cycle_min_cost = min(cycle_min_cost, costs[cycle_node])\n                        if cycle_node == node:\n                            break\n                    return cycle_min_cost\n                else:\n                    return 0\n            visited[node] = True\n            in_stack[node] = True\n            stack.append(node)\n            node = transitions[node] - 1\n\n    for i in range(n):\n        if not visited[i]:\n            min_cost += dfs(i)\n\n    return min_cost\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(find_min_trap_cost(n, costs, transitions))"}
{"solution": "def determine_entrance(n, a, b):\n    # Calculate the final position by adding b to a and taking modulo n\n    # If the result is 0, it means Vasya is at the last entrance (n)\n    final_position = (a + b - 1) % n + 1\n    return final_position\n\n# Read input from the user\nn, a, b = map(int, input().split())\n\n# Determine and print the final entrance number\nprint(determine_entrance(n, a, b))"}
{"solution": "def min_arithmetic_progressions(n, sequence):\n    # Initialize the count of progressions\n    progressions = 0\n    \n    # Initialize variables to track the current progression\n    current_start = None\n    current_diff = None\n    \n    # Iterate through the sequence\n    for i in range(n):\n        if sequence[i] == -1:\n            continue\n        \n        if current_start is None:\n            # Start a new progression\n            current_start = sequence[i]\n            last_known_index = i\n            progressions += 1\n        else:\n            # Calculate the expected difference if we continue the current progression\n            expected_diff = (sequence[i] - current_start) // (i - last_known_index)\n            \n            # Check if the current element fits the expected progression\n            if (sequence[i] - sequence[last_known_index]) % (i - last_known_index) == 0 and \\\n               (current_diff is None or expected_diff == current_diff):\n                current_diff = expected_diff\n                last_known_index = i\n            else:\n                # Start a new progression\n                current_start = sequence[i]\n                current_diff = None\n                last_known_index = i\n                progressions += 1\n    \n    return progressions\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Output the result\nprint(min_arithmetic_progressions(n, sequence))"}
{"solution": "def max_beauty(n, k, s):\n    max_len = 0\n    for char in ['a', 'b']:\n        changes = 0\n        left = 0\n        for right in range(n):\n            if s[right] != char:\n                changes += 1\n            while changes > k:\n                if s[left] != char:\n                    changes -= 1\n                left += 1\n            max_len = max(max_len, right - left + 1)\n    return max_len\n\n# Reading input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, a):\n    total_seats = sum(a)\n    majority_seats = total_seats // 2 + 1\n    alice_seats = a[0]\n\n    # If Alice's party alone has a strict majority, no need to form a coalition\n    if alice_seats >= majority_seats:\n        return [1], 1\n\n    # Sort parties by their seats in descending order, excluding Alice's party\n    other_parties = sorted([(a[i], i + 1) for i in range(1, n)], reverse=True)\n\n    # Try to form a coalition\n    for i in range(n - 1):\n        coalition_seats = alice_seats\n        coalition_parties = [1]\n        for j in range(i + 1):\n            if alice_seats >= 2 * other_parties[j][0]:\n                coalition_seats += other_parties[j][0]\n                coalition_parties.append(other_parties[j][1])\n                if coalition_seats >= majority_seats:\n                    return coalition_parties, len(coalition_parties)\n\n    return [], 0\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find and print the coalition\ncoalition, k = find_coalition(n, a)\nprint(k)\nif k > 0:\n    print(' '.join(map(str, coalition)))"}
{"solution": "def max_reward(n):\n    harmonic_sum = 0.0\n    for i in range(1, n + 1):\n        harmonic_sum += 1.0 / i\n    return harmonic_sum\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the maximum reward\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "def distribute_candies(n):\n    k = 0\n    total = 0\n    while total + k + 1 <= n:\n        k += 1\n        total += k\n    \n    remaining = n - total\n    distribution = list(range(1, k + 1))\n    \n    if remaining > 0:\n        distribution[-1] += remaining\n    \n    return k, distribution\n\n# Read input\nn = int(input())\n\n# Calculate and print the result\nk, distribution = distribute_candies(n)\nprint(k)\nprint(' '.join(map(str, distribution)))"}
{"solution": "def calculate_mod(n, m):\n    # Calculate m mod 2^n using bitwise AND operation\n    return m & ((1 << n) - 1)\n\n# Read input\nn = int(input().strip())\nm = int(input().strip())\n\n# Calculate and print the result\nprint(calculate_mod(n, m))"}
{"solution": "def word_corrector(n, s):\n    vowels = 'aeiouy'\n    i = 0\n    while i < len(s) - 1:\n        if s[i] in vowels and s[i + 1] in vowels:\n            s = s[:i] + s[i + 1:]\n        else:\n            i += 1\n    return s\n\n# Assuming the input is provided in the correct format as described in the problem statement\nn = int(input())\ns = input()\n\nprint(word_corrector(n, s))"}
{"solution": "def max_students(n, a, b, seats):\n    segments = []\n    i = 0\n    \n    # Identify segments of empty seats\n    while i < n:\n        if seats[i] == '.':\n            start = i\n            while i < n and seats[i] == '.':\n                i += 1\n            segments.append(i - start)\n        else:\n            i += 1\n    \n    total_students = 0\n    \n    # Place students in each segment\n    for length in segments:\n        # Calculate the number of students that can be placed in this segment\n        # We will place students in an alternating fashion\n        if a > b:\n            # Start with a student-programmer if more student-programmers are available\n            programmers = (length + 1) // 2\n            athletes = length // 2\n        else:\n            # Start with a student-athlete if more student-athletes are available\n            athletes = (length + 1) // 2\n            programmers = length // 2\n        \n        # Place the students\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n        \n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n    \n    return total_students\n\n# Read input\nn, a, b = map(int, input().split())\nseats = input().strip()\n\n# Output the result\nprint(max_students(n, a, b, seats))"}
{"solution": "def find_pair(r):\n    # Since H(x, y) = x^2 + 2xy + x + 1, we can rewrite it as H(x, y) = (x+1)^2 + y(x+1)\n    # Let z = x + 1, then H(x, y) = z^2 + yz\n    # We need to find z and y such that z^2 + yz = r\n    # Since z^2 <= r, we can iterate over possible values of z starting from 1\n    for z in range(1, int(r**0.5) + 1):\n        if r % z == 0:\n            y = r // z - z\n            if y > 0:\n                return z - 1, y\n    return \"NO\"\n\n# Read input\nr = int(input().strip())\n\n# Find and print the result\nresult = find_pair(r)\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "def divide_balloons(n, a):\n    if n == 1:\n        return -1  # Only one packet, impossible to divide\n\n    total_balloons = sum(a)\n    for i in range(1, 1 << n):  # Iterate over all subsets\n        grigory_balloons = 0\n        grigory_packets = []\n        for j in range(n):\n            if i & (1 << j):  # Check if the j-th packet is for Grigory\n                grigory_balloons += a[j]\n                grigory_packets.append(j + 1)\n        \n        if grigory_packets and grigory_balloons != total_balloons - grigory_balloons:\n            # Check if both got at least one packet and the total number of balloons is not equal\n            return len(grigory_packets), grigory_packets\n    \n    return -1  # No valid division found\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result and print\nresult = divide_balloons(n, a)\nif result == -1:\n    print(result)\nelse:\n    k, packets = result\n    print(k)\n    print(*packets)"}
{"solution": "def minimal_digit_partition(n):\n    # Start with the largest digit possible (9) and work downwards\n    digits = []\n    for digit in range(9, 0, -1):\n        # While the current digit can be subtracted from n, do so\n        while n >= digit:\n            digits.append(digit)\n            n -= digit\n    return digits\n\n# Read input\nn = int(input())\n\n# Get the minimal digit partition\npartition = minimal_digit_partition(n)\n\n# Output the result\nprint(len(partition))\nprint(' '.join(map(str, partition)))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_max_simple_subset(n, a):\n    # Sort the array to ensure we can check pairs in ascending order\n    a.sort()\n    \n    # Initialize the maximum subset size and the subset itself\n    max_subset_size = 0\n    max_subset = []\n    \n    # Try to build subsets starting with each element in the array\n    for i in range(n):\n        # Start a new subset with the current element\n        subset = [a[i]]\n        subset_size = 1\n        \n        # Check all pairs with the current element\n        for j in range(n):\n            if i != j:\n                # Check if adding a[j] to the subset keeps it simple\n                valid = True\n                for element in subset:\n                    if not is_prime(element + a[j]):\n                        valid = False\n                        break\n                if valid:\n                    subset.append(a[j])\n                    subset_size += 1\n        \n        # Update the maximum subset if the current one is larger\n        if subset_size > max_subset_size:\n            max_subset_size = subset_size\n            max_subset = subset\n    \n    return max_subset_size, max_subset\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum size simple subset\nmax_subset_size, max_subset = find_max_simple_subset(n, a)\n\n# Print the result\nprint(max_subset_size)\nprint(' '.join(map(str, max_subset)))"}
{"solution": "def is_beautiful(num):\n    # Check if the number is beautiful\n    k = 1\n    while (2**k - 1) * 2**k <= num:\n        if num % ((2**k - 1) * 2**k) == 0:\n            return True\n        k += 1\n    return False\n\ndef greatest_beautiful_divisor(n):\n    # Start from the largest possible divisor and go down to 1\n    for divisor in range(n, 0, -1):\n        if n % divisor == 0 and is_beautiful(divisor):\n            return divisor\n\n# Read input\nn = int(input().strip())\n\n# Output the greatest beautiful divisor\nprint(greatest_beautiful_divisor(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_d_magic_numbers(m, d, a, b):\n    def is_d_magic(number, d):\n        str_num = str(number)\n        for i, digit in enumerate(str_num):\n            if (i % 2 == 0 and int(digit) != d) or (i % 2 == 1 and int(digit) == d):\n                return False\n        return True\n\n    def count_d_magic_in_range(start, end):\n        count = 0\n        for number in range(start, end + 1):\n            if number % m == 0 and is_d_magic(number, d):\n                count += 1\n        return count % MOD\n\n    return count_d_magic_in_range(a, b)\n\n# Read input\nm, d = map(int, input().split())\na = int(input())\nb = int(input())\n\n# Calculate and print the result\nprint(count_d_magic_numbers(m, d, a, b))"}
{"solution": "def last_child_to_go_home(n, m, a):\n    queue = list(range(1, n + 1))\n    candies = {i: 0 for i in queue}\n    last_child = None\n\n    while queue:\n        current_child = queue.pop(0)\n        candies[current_child] += m\n        if candies[current_child] >= a[current_child - 1]:\n            last_child = current_child\n        else:\n            queue.append(current_child)\n\n    return last_child\n\n# Reading input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(last_child_to_go_home(n, m, a))"}
{"solution": "def min_bills(n):\n    denominations = [100, 20, 10, 5, 1]\n    count = 0\n    for denomination in denominations:\n        count += n // denomination\n        n %= denomination\n    return count\n\n# Assuming the input is provided through a standard input method (e.g., input() function in Python)\nn = int(input())\nprint(min_bills(n))"}
{"solution": "MOD = 1000000007\n\ndef binomial_mod(n, k, mod=MOD):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)\n    c = 1\n    for i in range(k):\n        c = c * (n - i) * pow(i + 1, mod - 2, mod) % mod\n    return c\n\ndef count_permutations(n, k):\n    # Dynamic programming to count permutations with exactly k good positions\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(0, k + 1):\n            dp[i][j] = (dp[i - 1][j] * (i - 1) + (dp[i - 1][j - 1] if j > 0 else 0)) % MOD\n    \n    # Calculate the final result using binomial coefficients\n    result = 0\n    for i in range(k + 1):\n        result = (result + dp[n][i] * binomial_mod(n, n - i) * (1 if i % 2 == 0 else -1)) % MOD\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the result\nprint(count_permutations(n, k))"}
{"solution": "def max_beauty_bouquet(n, k, beauties, colors):\n    # Separate roses by color\n    roses = {'W': [], 'O': [], 'R': []}\n    for beauty, color in zip(beauties, colors):\n        roses[color].append(beauty)\n    \n    # Sort each color's roses by beauty in descending order\n    for color in roses:\n        roses[color].sort(reverse=True)\n    \n    # Function to calculate the maximum beauty for a given color combination\n    def max_beauty_for_combination(color1, color2):\n        max_beauty = -1\n        # Calculate the maximum beauty for each possible split of k roses between the two colors\n        for i in range(k + 1):\n            if i <= len(roses[color1]) and k - i <= len(roses[color2]):\n                beauty = sum(roses[color1][:i]) + sum(roses[color2][:(k - i)])\n                max_beauty = max(max_beauty, beauty)\n        return max_beauty\n    \n    # Calculate the maximum beauty for valid color combinations\n    max_beauty = -1\n    if roses['W'] and roses['R']:\n        max_beauty = max(max_beauty, max_beauty_for_combination('W', 'O'))\n        max_beauty = max(max_beauty, max_beauty_for_combination('R', 'O'))\n    elif roses['W']:\n        max_beauty = max(max_beauty, max_beauty_for_combination('W', 'O'))\n    elif roses['R']:\n        max_beauty = max(max_beauty, max_beauty_for_combination('R', 'O'))\n    else:\n        max_beauty = -1\n    \n    return max_beauty\n\n# Read input\nn, k = map(int, input().split())\nbeauties = list(map(int, input().split()))\ncolors = input()\n\n# Compute and print the result\nprint(max_beauty_bouquet(n, k, beauties, colors))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef reduce_fraction(p, q):\n    common_divisor = gcd(p, q)\n    return p // common_divisor, q // common_divisor\n\ndef evaluate_continued_fraction(a):\n    numerator, denominator = a[-1], 1\n    for i in range(len(a) - 2, -1, -1):\n        numerator, denominator = a[i] * numerator + denominator, numerator\n    return numerator, denominator\n\ndef compare_fractions(p, q, n, a):\n    p, q = reduce_fraction(p, q)\n    numerator, denominator = evaluate_continued_fraction(a)\n    numerator, denominator = reduce_fraction(numerator, denominator)\n    return p == numerator and q == denominator\n\n# Read input\np, q = map(int, input().split())\nn = int(input())\na = list(map(int, input().split()))\n\n# Compare fractions and print result\nif compare_fractions(p, q, n, a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def correct_expression(expression):\n    # Split the expression into parts\n    parts = expression.split('+')\n    a_part, rest = parts[0], parts[1]\n    b_part, c_part = rest.split('=')\n    \n    # Convert parts to numbers\n    a = len(a_part)\n    b = len(b_part)\n    c = len(c_part)\n    \n    # Check if the expression is already correct\n    if a + b == c:\n        return expression\n    \n    # Try to shift one stick from A to B or C\n    if a > 1 and a - 1 + b == c + 1:\n        return '|' * (a - 1) + '+' + '|' * b + '=' + '|' * (c + 1)\n    if a > 1 and a - 1 + b + 1 == c:\n        return '|' * (a - 1) + '+' + '|' * (b + 1) + '=' + '|' * c\n    \n    # Try to shift one stick from B to A or C\n    if b > 1 and a + b - 1 == c + 1:\n        return '|' * a + '+' + '|' * (b - 1) + '=' + '|' * (c + 1)\n    if b > 1 and a + 1 + b - 1 == c:\n        return '|' * (a + 1) + '+' + '|' * (b - 1) + '=' + '|' * c\n    \n    # Try to shift one stick from C to A or B\n    if c > 1 and a + b == c - 1 + 1:\n        return '|' * a + '+' + '|' * b + '=' + '|' * (c - 1)\n    if c > 1 and a + 1 + b == c - 1:\n        return '|' * (a + 1) + '+' + '|' * b + '=' + '|' * (c - 1)\n    \n    # If no valid move is found, return \"Impossible\"\n    return \"Impossible\"\n\n# Read input from the user\nexpression = input().strip()\n\n# Output the result\nprint(correct_expression(expression))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_permutations_with_oddness(n, k):\n    # Initialize a 3D array to store the counts of permutations with a certain oddness\n    dp = [[[0 for _ in range(n * n + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 1  # Base case: 0 elements, 0 oddness, 1 permutation (the empty permutation)\n\n    # Fill the DP table\n    for i in range(1, n + 1):\n        for j in range(n + 1):\n            for l in range(n * n + 1):\n                dp[i][j][l] = dp[i - 1][j][l]  # If we don't use the i-th element\n                if j > 0 and l >= i:\n                    dp[i][j][l] = (dp[i][j][l] + dp[i - 1][j - 1][l - i]) % MOD  # If we use the i-th element\n\n    # The answer is the count of permutations of length n with oddness k\n    return dp[n][n][k]\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(count_permutations_with_oddness(n, k))"}
{"solution": "def can_reach_all_points(N, points):\n    # Check if it's possible to reach all points with a robot arm\n    # This is a placeholder function, you need to implement the logic\n    return True\n\ndef find_robot_arm_configuration(N, points):\n    # Find a robot arm configuration that can reach all points\n    # This is a placeholder function, you need to implement the logic\n    m = 2  # Example value for m\n    d = [1, 2]  # Example values for d_i\n    ways = [\"RL\", \"UU\", \"DR\"]  # Example ways to reach each point\n    return m, d, ways\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    points = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(N)]\n    \n    if not can_reach_all_points(N, points):\n        print(-1)\n        return\n    \n    m, d, ways = find_robot_arm_configuration(N, points)\n    \n    print(m)\n    print(\" \".join(map(str, d)))\n    for way in ways:\n        print(way)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import re\n\ndef replace_fillers(s):\n    # Regular expression to match the filler words\n    filler_pattern = r'ogo(go)*'\n    # Replace all occurrences of the filler pattern with \"***\"\n    return re.sub(filler_pattern, '***', s)\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Process and print the output\nprint(replace_fillers(s))"}
{"solution": "def prime_factors(n):\n    factors = set()\n    # Check for divisibility by 2\n    while n % 2 == 0:\n        factors.add(2)\n        n //= 2\n    # Check for odd factors\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            factors.add(i)\n            n //= i\n    # If n is a prime number greater than 2\n    if n > 2:\n        factors.add(n)\n    return factors\n\ndef g(x, p):\n    power = 0\n    while x % p == 0:\n        power += 1\n        x //= p\n    return p**power\n\ndef f(x, y):\n    product = 1\n    for p in prime_factors(x):\n        product *= g(y, p)\n    return product\n\ndef calculate_product_modulo(x, n):\n    MOD = 10**9 + 7\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * f(x, i)) % MOD\n    return result\n\n# Read input\nx, n = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_product_modulo(x, n))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for s in range(1, 82):  # s(x) can be at most 81\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and sum_of_digits(x) == s:\n            solutions.append(x)\n    solutions.sort()\n    return solutions\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find solutions\nsolutions = find_solutions(a, b, c)\n\n# Print results\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "def can_solve_with_one_move(cube_state):\n    # Define the possible rotations for a 2x2x2 Rubik's cube\n    rotations = {\n        'U': [0, 1, 2, 3, 8, 9, 10, 11, 6, 7, 12, 13, 4, 5, 14, 15],\n        'D': [4, 5, 6, 7, 0, 1, 2, 3, 12, 13, 14, 15, 8, 9, 10, 11],\n        'F': [0, 1, 8, 9, 4, 5, 2, 3, 12, 13, 6, 7, 10, 11, 14, 15],\n        'B': [2, 3, 12, 13, 6, 7, 10, 11, 0, 1, 8, 9, 4, 5, 14, 15],\n        'L': [4, 5, 0, 1, 6, 7, 2, 3, 8, 9, 10, 11, 12, 13, 14, 15],\n        'R': [2, 3, 6, 7, 0, 1, 4, 5, 10, 11, 8, 9, 14, 15, 12, 13]\n    }\n    \n    # Check if the cube is already solved\n    if all(cube_state.count(color) == 4 for color in set(cube_state)):\n        return \"YES\"\n    \n    # Try each rotation to see if it solves the cube\n    for rotation in rotations:\n        rotated_state = cube_state[:]\n        for i in range(16):\n            rotated_state[rotations[rotation][i]] = cube_state[rotations[rotation][(i + 2) % 16]]\n        \n        # Check if the rotated state is solved\n        if all(rotated_state.count(color) == 4 for color in set(rotated_state)):\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\ncube_state = list(map(int, input().split()))\n\n# Output result\nprint(can_solve_with_one_move(cube_state))"}
{"solution": "def calculate_hacks(p, x, y):\n    def is_winner(score):\n        i = (score // 50) % 475\n        for _ in range(25):\n            i = (i * 96 + 42) % 475\n            if 26 + i == p:\n                return True\n        return False\n\n    successful_hacks = 0\n    while x < y or not is_winner(x):\n        x += 50  # Each successful hack adds 100 points, but we also consider the unsuccessful hack that cancels out 50 points\n        successful_hacks += 1\n        if x >= y and is_winner(x):\n            break\n\n    return successful_hacks\n\n# Read input\np, x, y = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_hacks(p, x, y))"}
{"solution": "def min_distance_for_meals(n, a, b, c):\n    # If Winnie needs to eat only once, he doesn't need to travel at all\n    if n == 1:\n        return 0\n    \n    # Calculate the minimum distance for the first move\n    # Winnie starts at Rabbit's house, so he can move to Owl's or Eeyore's house\n    first_move_distance = min(a, b)\n    \n    # If Winnie moves to Owl's house, his next move will be to Eeyore's house (if needed)\n    # If Winnie moves to Eeyore's house, his next move will be to Owl's house (if needed)\n    # We choose the shorter path for the second move\n    second_move_distance = min(c, first_move_distance)\n    \n    # The total distance is the distance of the first move plus the distance of the second move\n    # multiplied by the number of times Winnie needs to move (n - 1 times)\n    total_distance = first_move_distance + second_move_distance * (n - 2)\n    \n    return total_distance\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate and print the minimum distance\nprint(min_distance_for_meals(n, a, b, c))"}
{"solution": "def min_total_distance(x1, x2, x3):\n    # Calculate the distances between each pair of friends\n    dist12 = abs(x1 - x2)\n    dist23 = abs(x2 - x3)\n    dist13 = abs(x1 - x3)\n    \n    # The minimum total distance is the sum of the two smallest distances\n    # because the friends should meet at the median point of the three\n    return dist12 + dist23 + dist13 - max(dist12, dist23, dist13)\n\n# Read input\nx1, x2, x3 = map(int, input().split())\n\n# Output the result\nprint(min_total_distance(x1, x2, x3))"}
{"solution": "def min_operations_to_equalize(n, x, arr):\n    # Check if there are already two equal elements\n    if len(set(arr)) < n:\n        return 0\n    \n    # Check if applying the operation once can make two elements equal\n    for a in arr:\n        if (a & x) in arr:\n            return 1\n    \n    # Check if applying the operation twice can make two elements equal\n    if len(set(a & x for a in arr)) < n:\n        return 2\n    \n    # If none of the above, it's impossible\n    return -1\n\n# Read input\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Print the result\nprint(min_operations_to_equalize(n, x, arr))"}
{"solution": "def has_single_plus_shape(h, w, picture):\n    center = None\n    for i in range(1, h - 1):\n        for j in range(1, w - 1):\n            if picture[i][j] == '*' and picture[i - 1][j] == '*' and picture[i + 1][j] == '*' and picture[i][j - 1] == '*' and picture[i][j + 1] == '*':\n                if center is not None:\n                    return \"NO\"  # More than one potential center found\n                center = (i, j)\n\n    if center is None:\n        return \"NO\"  # No center found\n\n    i, j = center\n    # Check in all directions from the center\n    up, down, left, right = i, i, j, j\n    while up >= 0 and picture[up][j] == '*':\n        picture[up][j] = '.'\n        up -= 1\n    while down < h and picture[down][j] == '*':\n        picture[down][j] = '.'\n        down += 1\n    while left >= 0 and picture[i][left] == '*':\n        picture[i][left] = '.'\n        left -= 1\n    while right < w and picture[i][right] == '*':\n        picture[i][right] = '.'\n        right += 1\n\n    # Check if all '*' are replaced by '.'\n    for row in picture:\n        if '*' in row:\n            return \"NO\"\n\n    return \"YES\"\n\n# Read input\nh, w = map(int, input().split())\npicture = [list(input().strip()) for _ in range(h)]\n\n# Output result\nprint(has_single_plus_shape(h, w, picture))"}
{"solution": "def generate_adjacency_matrix(n, a, b):\n    if a + b > n + 1 or a * b != n:\n        print(\"NO\")\n        return\n\n    # Initialize an empty adjacency matrix\n    adjacency_matrix = [[0] * n for _ in range(n)]\n\n    # Create a fully connected graph for the complement\n    for i in range(n):\n        for j in range(i + 1, n):\n            adjacency_matrix[i][j] = adjacency_matrix[j][i] = 1\n\n    # Create the required number of components in the complement graph\n    for component_start in range(0, n, b):\n        for i in range(component_start, min(component_start + b, n)):\n            for j in range(i + 1, min(component_start + b, n)):\n                adjacency_matrix[i][j] = adjacency_matrix[j][i] = 0\n\n    # Ensure the graph has the required number of components\n    for component_start in range(0, n, b):\n        if a > 1:\n            for i in range(component_start + b, min(component_start + 2 * b, n)):\n                adjacency_matrix[component_start][i] = adjacency_matrix[i][component_start] = 1\n            a -= 1\n\n    print(\"YES\")\n    for row in adjacency_matrix:\n        print(''.join(map(str, row)))\n\n# Example usage:\n# generate_adjacency_matrix(3, 1, 2)\n# generate_adjacency_matrix(3, 3, 3)"}
{"solution": "def min_problems_needed(c, d, n, m, k):\n    # Calculate the number of winners needed from elimination rounds\n    winners_needed = n * m - k\n    \n    # If no additional winners are needed, return 0\n    if winners_needed <= 0:\n        return 0\n    \n    # Calculate the maximum number of winners from main rounds\n    max_main_winners = (winners_needed // n) * n\n    problems_from_main = (max_main_winners // n) * c\n    \n    # Calculate the remaining winners needed from additional rounds\n    remaining_winners = winners_needed - max_main_winners\n    problems_from_additional = remaining_winners * d\n    \n    # Total problems needed\n    total_problems = problems_from_main + problems_from_additional\n    \n    return total_problems\n\n# Read input\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\n# Calculate and print the result\nprint(min_problems_needed(c, d, n, m, k))"}
{"solution": "def find_grid_path(s):\n    # Check if the string length is exactly 27\n    if len(s) != 27:\n        return \"Impossible\"\n\n    # Function to check if two characters are adjacent in a grid\n    def is_adjacent(a, b):\n        # Calculate the positions of a and b in the grid\n        pos_a = (0 if a in row1 else 1, row1.index(a) if a in row1 else row2.index(a))\n        pos_b = (0 if b in row1 else 1, row1.index(b) if b in row1 else row2.index(b))\n        # Check if they are adjacent\n        return abs(pos_a[0] - pos_b[0]) <= 1 and abs(pos_a[1] - pos_b[1]) <= 1\n\n    # Try to construct the grid and find a path\n    for i in range(13):\n        row1 = s[:i] + s[i+14:27]\n        row2 = s[i:i+13]\n        valid_path = True\n        for j in range(1, 27):\n            if not is_adjacent(s[j-1], s[j]):\n                valid_path = False\n                break\n        if valid_path:\n            return row1[:13] + \"\\n\" + row2\n\n    return \"Impossible\"\n\n# Read input\ns = input().strip()\n\n# Find and print the grid or \"Impossible\"\nprint(find_grid_path(s))"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<' if y > 1 else '='\n    elif y == 1:\n        return '>' if x > 1 else '='\n    else:\n        lhs = y * math.log(x)\n        rhs = x * math.log(y)\n        \n        if lhs < rhs:\n            return '<'\n        elif lhs > rhs:\n            return '>'\n        else:\n            return '='\n\n# Read input\nx, y = map(int, input().split())\n\n# Output the result of the comparison\nprint(compare_powers(x, y))"}
{"solution": "def max_balloons(r, h):\n    # Calculate the number of balloons that can fit in the semicircle part\n    semicircle_balloons = (r // (r / 2)) ** 2\n    \n    # Calculate the number of balloons that can fit in the rectangular part\n    rectangular_balloons = (h // (r / 2)) * (r // (r / 2))\n    \n    # The total number of balloons is the sum of the balloons in the semicircle and the rectangular part\n    total_balloons = semicircle_balloons + rectangular_balloons\n    \n    return total_balloons\n\n# Read input\nr, h = map(int, input().split())\n\n# Print the output\nprint(max_balloons(r, h))"}
{"solution": "def min_sum_after_discard(t1, t2, t3, t4, t5):\n    # Create a dictionary to count occurrences of each number\n    counts = {}\n    for num in [t1, t2, t3, t4, t5]:\n        counts[num] = counts.get(num, 0) + 1\n    \n    # Initialize the minimum sum to the sum of all numbers\n    min_sum = sum([t1, t2, t3, t4, t5])\n    \n    # Iterate through the counts to find if we can minimize the sum\n    for num, count in counts.items():\n        if count == 2 or count == 3:\n            # If there are exactly 2 or 3 cards with the same number, discard them\n            min_sum -= num * count\n        elif count > 3:\n            # If there are more than 3 cards with the same number, discard any 3\n            min_sum -= num * 3\n    \n    return min_sum\n\n# Example usage:\n# print(min_sum_after_discard(7, 3, 7, 3, 20))  # Output: 26\n# print(min_sum_after_discard(7, 9, 3, 1, 8))  # Output: 28\n# print(min_sum_after_discard(10, 10, 10, 10, 10))  # Output: 20"}
{"solution": "def min_distance_to_checkpoints(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    # Calculate distances to the furthest checkpoints from both ends\n    distance_to_furthest = max(abs(a - checkpoints[0]), abs(a - checkpoints[n-1]))\n    # Calculate the total distance if Vasya visits all checkpoints from one end to the other\n    distance_through_all = abs(checkpoints[n-1] - checkpoints[0])\n    # The minimum distance is the minimum of the two scenarios\n    return min(distance_to_furthest, distance_through_all)\n\n# Read input\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_distance_to_checkpoints(n, a, checkpoints))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_root(n):\n    for x in range(1, 10**9):  # Arbitrary large upper bound for x\n        if x**2 + sum_of_digits(x) * x - n == 0:\n            return x\n    return -1\n\n# Read input\nn = int(input().strip())\n\n# Find and print the result\nprint(find_root(n))"}
{"solution": "def time_to_minutes(time_str):\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    minutes = minutes % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef calculate_bedtime(current_time, sleep_duration):\n    current_minutes = time_to_minutes(current_time)\n    sleep_minutes = time_to_minutes(sleep_duration)\n    \n    bedtime_minutes = (current_minutes - sleep_minutes) % (24 * 60)\n    return minutes_to_time(bedtime_minutes)\n\n# Read input\ncurrent_time = input().strip()\nsleep_duration = input().strip()\n\n# Calculate and print the bedtime\nprint(calculate_bedtime(current_time, sleep_duration))"}
{"solution": "def find_longest_subsegment_with_max_mean(n, a):\n    max_val = max(a)\n    max_len = 0\n    current_len = 0\n    \n    for num in a:\n        if num == max_val:\n            current_len += 1\n            max_len = max(max_len, current_len)\n        else:\n            current_len = 0\n    \n    return max_len\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Finding and printing the result\nprint(find_longest_subsegment_with_max_mean(n, a))"}
{"solution": "MOD = 998244353\n\ndef modinv(a, m):\n    return pow(a, m - 2, m)\n\ndef nCr_mod(n, r, mod):\n    if r < 0 or n < r:\n        return 0\n    r = min(r, n - r)\n    num = 1\n    den = 1\n    for i in range(1, r + 1):\n        num = num * (n - i + 1) % mod\n        den = den * i % mod\n    return num * modinv(den, mod) % mod\n\ndef count_ways(n, m, k):\n    return nCr_mod(n - 1, k, MOD) * m * pow(m - 1, k, MOD) % MOD\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Calculate and print the result\nprint(count_ways(n, m, k))"}
{"solution": "import re\n\ndef is_magic_number(n):\n    pattern = re.compile(r'^(1|14|144)+$')\n    if pattern.match(str(n)):\n        return \"YES\"\n    else:\n        return \"NO\""}
{"solution": "def min_moves_to_corner(n, m, i, j, a, b):\n    # Function to check if a position is within the board boundaries\n    def is_valid(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n\n    # Function to calculate the minimum moves to reach a corner\n    def calculate_moves(corner_x, corner_y):\n        x_diff = abs(corner_x - i)\n        y_diff = abs(corner_y - j)\n        if x_diff % a == 0 and y_diff % b == 0:\n            x_moves = x_diff // a\n            y_moves = y_diff // b\n            if x_moves == y_moves:\n                return x_moves\n            elif (x_moves - y_moves) % 2 == 0:\n                return max(x_moves, y_moves)\n        return float('inf')\n\n    # Check all four corners\n    corners = [(1, 1), (1, m), (n, 1), (n, m)]\n    min_moves = float('inf')\n    for corner in corners:\n        min_moves = min(min_moves, calculate_moves(corner[0], corner[1]))\n\n    # If no valid moves found, return \"Poor Inna and pony!\"\n    if min_moves == float('inf'):\n        return \"Poor Inna and pony!\"\n    else:\n        return min_moves\n\n# Read input\nn, m, i, j, a, b = map(int, input().split())\n\n# Output the result\nprint(min_moves_to_corner(n, m, i, j, a, b))"}
{"solution": "def max_removals(s):\n    removals = 0\n    stack = []\n    \n    for char in s:\n        if stack and stack[-1] == chr(ord(char) - 1):\n            stack.pop()\n            removals += 1\n        else:\n            stack.append(char)\n    \n    return removals\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Extract the length of the string and the string itself\nlength_of_s = int(data[0])\ns = data[1]\n\n# Calculate and print the result\nprint(max_removals(s))"}
{"solution": "def atm_withdrawal(n, k, denominations, q, requests):\n    results = []\n    \n    for request in requests:\n        min_bills = float('inf')\n        for i in range(n):\n            for j in range(i, n):\n                if denominations[i] == denominations[j]:\n                    # Check if we can fulfill the request with one denomination\n                    if request % denominations[i] == 0 and request // denominations[i] <= k:\n                        min_bills = min(min_bills, request // denominations[i])\n                else:\n                    # Check if we can fulfill the request with two denominations\n                    for count_i in range(k + 1):\n                        remaining = request - count_i * denominations[i]\n                        if remaining < 0:\n                            break\n                        if remaining % denominations[j] == 0 and count_i + remaining // denominations[j] <= k:\n                            min_bills = min(min_bills, count_i + remaining // denominations[j])\n        if min_bills == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_bills)\n    \n    return results\n\n# Read input\nn, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\nrequests = [int(input()) for _ in range(q)]\n\n# Get results and print them\nresults = atm_withdrawal(n, k, denominations, q, requests)\nfor result in results:\n    print(result)"}
{"solution": "def min_time_to_reach(s, x1, x2, t1, t2, p, d):\n    # Calculate the time Igor would take to walk the entire distance\n    walking_time = abs(x2 - x1) * t2\n    \n    # If Igor's walking speed is equal to or faster than the tram's, he should walk\n    if t2 <= t1:\n        return walking_time\n    \n    # Calculate the time the tram would take to reach Igor's position from its current position\n    if d == 1:  # Tram moving towards Igor\n        if p <= x1:\n            tram_to_igor_time = (x1 - p) * t1\n        else:\n            tram_to_igor_time = (s - p + s + x1) * t1\n    else:  # Tram moving away from Igor\n        if p >= x1:\n            tram_to_igor_time = (p - x1) * t1\n        else:\n            tram_to_igor_time = (p + s + (s - x1)) * t1\n    \n    # Calculate the time the tram would take to reach the destination from Igor's position\n    if d == 1:  # If tram is moving towards the destination\n        if x1 <= x2:\n            tram_to_destination_time = (x2 - x1) * t1\n        else:\n            tram_to_destination_time = (s - x1 + s + x2) * t1\n    else:  # If tram is moving away from the destination\n        if x1 >= x2:\n            tram_to_destination_time = (x1 - x2) * t1\n        else:\n            tram_to_destination_time = (x1 + s + (s - x2)) * t1\n    \n    # Total time if Igor waits for the tram and then rides it to the destination\n    tram_time = tram_to_igor_time + tram_to_destination_time\n    \n    # Return the minimum of walking time or tram time\n    return min(walking_time, tram_time)\n\n# Read input\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Output the result\nprint(min_time_to_reach(s, x1, x2, t1, t2, p, d))"}
{"solution": "def count_occurrences_in_table(n, x):\n    count = 0\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            j = x // i\n            if i <= n and j <= n:\n                count += 1 if i == j else 2\n    return count\n\n# Reading input\nn, x = map(int, input().split())\n\n# Output the result\nprint(count_occurrences_in_table(n, x))"}
{"solution": "def generate_password(n, k):\n    # Define the set of lowercase Latin letters\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    \n    # Initialize the password with the first k distinct letters\n    password = letters[:k]\n    \n    # Fill the rest of the password with the first letter to ensure no consecutive symbols are the same\n    while len(password) < n:\n        password += letters[0]\n    \n    return password\n\n# Read input\nn, k = map(int, input().split())\n\n# Generate and print the password\nprint(generate_password(n, k))"}
{"solution": "def first_collision_time(n, directions, positions):\n    min_time = float('inf')\n    collision_found = False\n    \n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            collision_time = (positions[i + 1] - positions[i]) // 2\n            min_time = min(min_time, collision_time)\n            collision_found = True\n    \n    if collision_found:\n        return min_time\n    else:\n        return -1\n\n# Read input\nn = int(input())\ndirections = input().strip()\npositions = list(map(int, input().split()))\n\n# Output the result\nprint(first_collision_time(n, directions, positions))"}
{"solution": "def max_area_of_two_seals(n, a, b, seals):\n    max_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for orientation_i in [(seals[i][0], seals[i][1]), (seals[i][1], seals[i][0])]:\n                for orientation_j in [(seals[j][0], seals[j][1]), (seals[j][1], seals[j][0])]:\n                    if (orientation_i[0] + orientation_j[0] <= a and max(orientation_i[1], orientation_j[1]) <= b) or \\\n                       (orientation_i[1] + orientation_j[1] <= b and max(orientation_i[0], orientation_j[0]) <= a):\n                        max_area = max(max_area, orientation_i[0] * orientation_i[1] + orientation_j[0] * orientation_j[1])\n    return max_area\n\n# Read input\nn, a, b = map(int, input().split())\nseals = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(max_area_of_two_seals(n, a, b, seals))"}
{"solution": "def find_non_boundary_point(n, points):\n    # Create sets for each boundary condition\n    x_values = set()\n    y_values = set()\n    \n    for x, y in points:\n        x_values.add(x)\n        y_values.add(y)\n    \n    # Find the boundaries of the square\n    min_x = min(x_values)\n    max_x = max(x_values)\n    min_y = min(y_values)\n    max_y = max(y_values)\n    \n    # Check each point to see if it's on the boundary\n    for x, y in points:\n        if not (x == min_x or x == max_x or y == min_y or y == max_y):\n            return x, y\n    \n    return None\n\n# Read input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(4 * n + 1)]\n\n# Find and print the non-boundary point\nnon_boundary_point = find_non_boundary_point(n, points)\nprint(*non_boundary_point)"}
{"solution": "def max_digit_product(n):\n    def product_of_digits(x):\n        product = 1\n        while x > 0:\n            product *= x % 10\n            x //= 10\n        return product\n\n    def next_candidate(x):\n        digits = [int(d) for d in str(x)]\n        for i in range(len(digits) - 1, -1, -1):\n            if digits[i] != 9:\n                digits[i] -= 1\n                for j in range(i + 1, len(digits)):\n                    digits[j] = 9\n                break\n        return int(''.join(map(str, digits)))\n\n    max_product = product_of_digits(n)\n    candidate = next_candidate(n)\n    while candidate > 0:\n        max_product = max(max_product, product_of_digits(candidate))\n        candidate = next_candidate(candidate)\n\n    return max_product\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(max_digit_product(n))"}
{"solution": "def find_smallest_k(n, votes):\n    total_elodreip_votes = sum(votes)\n    max_ai = max(votes)\n    \n    for k in range(max_ai, total_elodreip_votes + 2):\n        awruk_votes = sum(k - ai for ai in votes)\n        if awruk_votes > total_elodreip_votes:\n            return k\n\n# Reading input\nn = int(input())\nvotes = list(map(int, input().split()))\n\n# Finding and printing the smallest k\nprint(find_smallest_k(n, votes))"}
{"solution": "def count_operations(colors):\n    operations = 0\n    while True:\n        to_delete = [False] * len(colors)\n        deleted = False\n        for i in range(1, len(colors) - 1):\n            if colors[i - 1] != colors[i] and colors[i] != colors[i + 1]:\n                to_delete[i] = True\n                deleted = True\n        if not deleted:\n            break\n        new_colors = []\n        for i in range(len(colors)):\n            if not to_delete[i]:\n                new_colors.append(colors[i])\n        colors = new_colors\n        operations += 1\n    return operations\n\n# Read input from stdin\ninput_colors = input().strip()\n\n# Output the result\nprint(count_operations(input_colors))"}
{"solution": "def count_min_product_triples(n, a):\n    # Sort the array to easily find the minimum product\n    a.sort()\n    \n    # The minimum product will be the product of the first three elements\n    min_product = a[0] * a[1] * a[2]\n    \n    # Initialize the count of such triples\n    count = 0\n    \n    # Iterate through the array to count the triples with the minimum product\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if a[i] * a[j] * a[k] == min_product:\n                    count += 1\n                elif a[i] * a[j] * a[k] > min_product:\n                    # Since the array is sorted, if the product exceeds the min_product,\n                    # we can break out of the loop early\n                    break\n    \n    return count\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the output\nprint(count_min_product_triples(n, a))"}
{"solution": "def min_cuts_for_equal_slices(n):\n    # If there are no friends, Shiro only needs to cut for herself\n    if n == 0:\n        return 0\n    # If the number of slices is a power of 2, the minimum cuts is equal to the number of slices\n    if (n + 1) & (n) == 0:\n        return n\n    # Otherwise, the minimum cuts is the number of slices minus 1\n    return n + 1\n\n# Read input from stdin\nn = int(input().strip())\n\n# Output the result\nprint(min_cuts_for_equal_slices(n))"}
{"solution": "def maximize_bank_account(n):\n    if n >= 0:\n        return n\n    else:\n        n_str = str(n)\n        last_digit_removed = int(n_str[:-1])\n        second_last_digit_removed = int(n_str[:-2] + n_str[-1])\n        return max(last_digit_removed, second_last_digit_removed)\n\n# Assuming the input is provided through a function call or an appropriate method\n# For example:\n# n = int(input())\n# print(maximize_bank_account(n))"}
{"solution": "def determine_spinner_direction(start, end, n):\n    # Define the sequence of positions\n    positions = ['v', '<', '^', '>']\n    \n    # Find the index of the start and end positions\n    start_index = positions.index(start)\n    end_index = positions.index(end)\n    \n    # Calculate the difference in positions\n    diff = (end_index - start_index) % 4\n    \n    # Determine the direction based on the difference and n\n    if diff == n % 4:\n        if diff == 1 or diff == 3:\n            return \"cw\" if diff == 1 else \"ccw\"\n        else:\n            return \"undefined\"\n    else:\n        return \"undefined\"\n\n# Read input\nstart, end = input().split()\nn = int(input())\n\n# Determine and print the direction\nprint(determine_spinner_direction(start, end, n))"}
{"solution": "def count_vertical_dominoes(n, s):\n    # Initialize the count of vertical dominoes\n    vertical_count = 0\n    \n    # Initialize a list to keep track of the final state of each domino\n    final_state = ['.'] * n\n    \n    # Iterate through the dominoes to determine their final state\n    for i in range(n):\n        if s[i] == 'L':\n            # If a domino is pushed to the left, mark all previous dominoes as falling left\n            j = i\n            while j >= 0 and final_state[j] == '.':\n                final_state[j] = 'L'\n                j -= 1\n        elif s[i] == 'R':\n            # If a domino is pushed to the right, mark all following dominoes as falling right\n            j = i\n            while j < n and final_state[j] == '.':\n                final_state[j] = 'R'\n                j += 1\n    \n    # Count the number of vertical dominoes\n    for i in range(n):\n        if final_state[i] == '.':\n            # Check if the current domino is being pushed from both sides\n            left_push = False\n            right_push = False\n            for j in range(i):\n                if s[j] == 'R' and final_state[j] == 'R':\n                    left_push = True\n                    break\n            for j in range(i+1, n):\n                if s[j] == 'L' and final_state[j] == 'L':\n                    right_push = True\n                    break\n            if not (left_push and right_push):\n                vertical_count += 1\n    \n    return vertical_count\n\n# Read input\nn = int(input())\ns = input()\n\n# Output the result\nprint(count_vertical_dominoes(n, s))"}
{"solution": "def restore_permutation(n, m, leaders):\n    # Initialize an array to keep track of the permutation\n    permutation = [0] * n\n    # Initialize a set to keep track of used numbers\n    used_numbers = set()\n    \n    # Function to find the next leader based on the current leader and the permutation value\n    def find_next_leader(current_leader, step_value):\n        return (current_leader + step_value - 1) % n + 1\n    \n    # Start with the first leader\n    current_leader = leaders[0]\n    \n    # Iterate through the steps to determine the permutation\n    for i in range(m - 1):\n        # Calculate the step value for the current leader\n        step_value = (leaders[i + 1] - current_leader + n) % n\n        if step_value == 0:\n            step_value = n\n        \n        # If the step value is already used, there's no solution\n        if step_value in used_numbers:\n            return -1\n        \n        # Assign the step value to the current leader's position in the permutation\n        permutation[current_leader - 1] = step_value\n        used_numbers.add(step_value)\n        \n        # Find the next leader\n        current_leader = find_next_leader(current_leader, step_value)\n    \n    # Fill in the remaining numbers in the permutation\n    for i in range(n):\n        if permutation[i] == 0:\n            for j in range(1, n + 1):\n                if j not in used_numbers:\n                    permutation[i] = j\n                    used_numbers.add(j)\n                    break\n    \n    return permutation\n\n# Read input\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\n# Restore the permutation and print the result\nresult = restore_permutation(n, m, leaders)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "def max_number_after_swaps(a, k):\n    digits = [int(d) for d in str(a)]\n    n = len(digits)\n    \n    for i in range(n):\n        if k == 0:\n            break\n        max_digit = digits[i]\n        max_index = i\n        for j in range(i + 1, min(n, i + k + 1)):\n            if digits[j] > max_digit:\n                max_digit = digits[j]\n                max_index = j\n        \n        if max_index != i:\n            for j in range(max_index, i, -1):\n                digits[j], digits[j - 1] = digits[j - 1], digits[j]\n                k -= 1\n                if k == 0:\n                    break\n    \n    return int(''.join(map(str, digits)))\n\n# Example usage:\n# a, k = 1990, 1\n# print(max_number_after_swaps(a, k))  # Output: 9190"}
{"solution": "def determine_next_number(sequence):\n    a1, a2, a3, a4 = sequence\n    \n    # Check for arithmetic progression\n    d = a2 - a1\n    if a3 - a2 == d and a4 - a3 == d:\n        return a4 + d\n    \n    # Check for geometric progression\n    if a1 != 0:\n        q = a2 / a1\n        if a3 / a2 == q and a4 / a3 == q:\n            next_element = a4 * q\n            if next_element.is_integer():\n                return int(next_element)\n    \n    # If neither, return 42\n    return 42\n\n# Read input\nsequence = list(map(int, input().split()))\n\n# Determine and print the next number\nprint(determine_next_number(sequence))"}
{"solution": "def max_distance(n, colors):\n    # Find the first and last occurrence of each color\n    first_occurrence = {}\n    last_occurrence = {}\n    \n    for i in range(n):\n        color = colors[i]\n        if color not in first_occurrence:\n            first_occurrence[color] = i\n        last_occurrence[color] = i\n    \n    # Get the list of unique colors\n    unique_colors = list(first_occurrence.keys())\n    \n    # Calculate the maximum distance\n    max_dist = 0\n    \n    # Compare distances from the first house to the last house of a different color\n    for color in unique_colors:\n        if colors[0] != color:\n            max_dist = max(max_dist, last_occurrence[color])\n        if colors[-1] != color:\n            max_dist = max(max_dist, n - 1 - first_occurrence[color])\n    \n    return max_dist\n\n# Read input\nn = int(input())\ncolors = list(map(int, input().split()))\n\n# Print the result\nprint(max_distance(n, colors))"}
{"solution": "def determine_santa_place(n, m, k):\n    # Calculate the lane number\n    lane = (k - 1) // (2 * m) + 1\n    # Calculate the desk number within the lane\n    desk = ((k - 1) // 2) % m + 1\n    # Determine if the place is on the left or right\n    side = 'L' if k % 2 != 0 else 'R'\n    \n    return lane, desk, side\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Determine and print the output\nr, d, s = determine_santa_place(n, m, k)\nprint(r, d, s)"}
{"solution": "def possible_final_colors(s):\n    # Count the occurrences of each color\n    counts = {'B': 0, 'G': 0, 'R': 0}\n    for color in s:\n        counts[color] += 1\n    \n    # Determine the possible final colors based on the parity of counts\n    final_colors = []\n    if counts['B'] % 2 == 1 or (counts['G'] % 2 == 0 and counts['R'] % 2 == 0):\n        final_colors.append('B')\n    if counts['G'] % 2 == 1 or (counts['B'] % 2 == 0 and counts['R'] % 2 == 0):\n        final_colors.append('G')\n    if counts['R'] % 2 == 1 or (counts['B'] % 2 == 0 and counts['G'] % 2 == 0):\n        final_colors.append('R')\n    \n    return ''.join(sorted(final_colors))\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Output the possible final colors\nprint(possible_final_colors(s))"}
