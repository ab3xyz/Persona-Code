{"solution": "def find_max_accordion_length(s):\n    # Initialize variables\n    open_bracket_index = -1\n    first_colon_index = -1\n    second_colon_index = -1\n    close_bracket_index = -1\n    max_length = -1\n\n    # Find the indices of the first occurrences of [, :, : and ]\n    for i in range(len(s)):\n        if s[i] == '[':\n            open_bracket_index = i\n        elif s[i] == ':' and first_colon_index == -1:\n            first_colon_index = i\n        elif s[i] == ':' and first_colon_index != -1 and second_colon_index == -1:\n            second_colon_index = i\n        elif s[i] == ']':\n            close_bracket_index = i\n\n        # If all required characters are found, calculate the length of the accordion\n        if open_bracket_index != -1 and first_colon_index != -1 and second_colon_index != -1 and close_bracket_index != -1:\n            # Check if the characters between the colons are all '|'\n            if all(c == '|' for c in s[first_colon_index+1:second_colon_index]):\n                max_length = max(max_length, second_colon_index - open_bracket_index + 1)\n            # Reset the second colon index to find the next possible accordion\n            second_colon_index = -1\n\n    return max_length\n\n# Read the input string\ns = input()\n\n# Print the maximum possible length of the resulting accordion\nprint(find_max_accordion_length(s))"}
{"solution": "def max_sum_digits(x):\n    # Convert the number to string\n    x = str(x)\n\n    # Initialize the result\n    result = ''\n\n    # Iterate over the digits\n    for i in range(len(x)):\n        # Find the maximum digit that can be placed at the current position\n        max_digit = '9'\n        for digit in '876543210':\n            if int(digit) <= int(x[i]):\n                max_digit = digit\n                break\n\n        # Add the maximum digit to the result\n        result += max_digit\n\n    # Convert the result back to integer\n    result = int(result)\n\n    # Return the result\n    return result\n\n# Read the input\nx = int(input())\n\n# Print the output\nprint(max_sum_digits(x))"}
{"solution": "def count_digits(n):\n    count = 0\n    while n > 0:\n        if n % 10 != 0:\n            count += 1\n        n //= 10\n    return count\n\ndef find_next_lucky_year(n):\n    while True:\n        n += 1\n        if count_digits(n) <= 1:\n            return n\n\nn = int(input())\nnext_lucky_year = find_next_lucky_year(n)\nprint(next_lucky_year - n)"}
{"solution": "def max_painted_sections(n, q, painters):\n    # Create a list to store the painted sections\n    painted = [0] * n\n\n    # Paint the sections for each painter\n    for l, r in painters:\n        for i in range(l-1, r):\n            painted[i] = 1\n\n    # Sort the painters based on the right endpoint\n    painters.sort(key=lambda x: x[1])\n\n    # Initialize the maximum number of painted sections\n    max_painted = sum(painted)\n\n    # Try removing each pair of painters\n    for i in range(q-1):\n        for j in range(i+1, q):\n            # Create a new list to store the painted sections\n            new_painted = painted[:]\n\n            # Unpaint the sections for the removed painters\n            for l, r in painters[i:j]:\n                for k in range(l-1, r):\n                    new_painted[k] = 0\n\n            # Update the maximum number of painted sections\n            max_painted = max(max_painted, sum(new_painted))\n\n    return max_painted\n\n# Read the input\nn, q = map(int, input().split())\npainters = [list(map(int, input().split())) for _ in range(q)]\n\n# Print the output\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def is_lucky(time):\n    return '7' in time\n\ndef format_time(time):\n    return '{:02d}:{:02d}'.format(*divmod(time, 60))\n\ndef solve(x, hh, mm):\n    time = hh * 60 + mm\n    for y in range(0, 61):\n        if is_lucky(format_time((time - y * x) % (24 * 60))):\n            return y\n\nx = int(input())\nhh, mm = map(int, input().split())\nprint(solve(x, hh, mm))"}
{"solution": "# Get the input\nn, pos, l, r = map(int, input().split())\n\n# Calculate the minimum number of seconds required\nif pos < l:\n    # Move the cursor to the leftmost tab of the segment and close all tabs to the right\n    time = l - pos + r - l\nelif pos > r:\n    # Move the cursor to the rightmost tab of the segment and close all tabs to the left\n    time = pos - r + r - l\nelse:\n    # Close all tabs to the left of the segment and all tabs to the right of the segment\n    time = min(pos - l, r - pos) + min(r - max(pos, l), max(pos, l) - 1)\n\n# Print the result\nprint(time)"}
{"solution": "import sys\nfrom typing import List\n\nread_input = sys.stdin.readline\n\ndef min_blows(n: int, x: int, blows: List[List[int]]) -> int:\n    blows.sort(key=lambda b: b[0] - b[1])\n    for i in range(n):\n        if blows[i][0] > blows[i][1]:\n            break\n        x -= blows[i][0]\n        x += blows[i][1]\n        if x <= 0:\n            return i + 1\n    if blows[-1][0] <= blows[-1][1]:\n        return -1\n    d, h = blows[-1]\n    return (x + d - h - 1) // (d - h) + n - 1\n\ndef main() -> None:\n    t = int(read_input())\n    for _ in range(t):\n        n, x = map(int, read_input().split())\n        blows = [list(map(int, read_input().split())) for _ in range(n)]\n        print(min_blows(n, x, blows))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Read the input\nn, m = map(int, input().split())\n\n# Initialize the number of days and the remaining grains in the barn\ndays = 0\nremaining_grains = n\n\n# Simulate the process day by day\nwhile remaining_grains > 0:\n    days += 1\n    remaining_grains += m\n    if remaining_grains > n:\n        remaining_grains = n\n    remaining_grains -= days\n\n# Print the result\nprint(days)"}
{"solution": "def check_mentsu(tiles):\n    tiles.sort()\n    for i in range(3):\n        if tiles[i] == tiles[i+1] == tiles[i+2]:\n            return True\n        if tiles[i] + 1 == tiles[i+1] and tiles[i] + 2 == tiles[i+2]:\n            return True\n    return False\n\ndef min_extra_tiles(hand):\n    suits = {'m': [], 'p': [], 's': []}\n    for tile in hand:\n        suits[tile[1]].append(int(tile[0]))\n    for suit in suits.values():\n        suit.sort()\n        for i in range(1, 8):\n            if i not in suit and i+1 in suit and i+2 in suit:\n                return 1\n            if suit.count(i) == 1 and suit.count(i+1) == 1:\n                return 1\n            if suit.count(i) == 2:\n                return 1\n    return 2\n\nhand = input().split()\nif check_mentsu(hand):\n    print(0)\nelse:\n    print(min_extra_tiles(hand))"}
{"solution": "def find_sofa(d, n, m, sofas, cnt):\n    left, right, top, bottom = cnt\n    for i, sofa in enumerate(sofas, 1):\n        x1, y1, x2, y2 = sofa\n        l, r, t, b = 0, 0, 0, 0\n        for j, other in enumerate(sofas, 1):\n            if i == j:\n                continue\n            ox1, oy1, ox2, oy2 = other\n            if x1 == ox1:\n                if y1 < oy1:\n                    t += 1\n                else:\n                    b += 1\n            elif y1 == oy1:\n                if x1 < ox1:\n                    l += 1\n                else:\n                    r += 1\n        if l == left and r == right and t == top and b == bottom:\n            return i\n    return -1\n\nd = int(input())\nn, m = map(int, input().split())\nsofas = [list(map(int, input().split())) for _ in range(d)]\ncnt = list(map(int, input().split()))\nprint(find_sofa(d, n, m, sofas, cnt))"}
{"solution": "# Read the number of days in a year on Mars\nn = int(input())\n\n# Calculate the number of full weeks in a year on Mars\nfull_weeks = n // 7\n\n# Calculate the remaining days after full weeks\nremaining_days = n % 7\n\n# The minimum possible number of days off is always 2 days per full week\nmin_days_off = full_weeks * 2\n\n# The maximum possible number of days off depends on the remaining days\n# If there are 6 or more remaining days, then the maximum possible number of days off is 2 per full week plus 1 day off for the remaining days\n# Otherwise, the maximum possible number of days off is 2 per full week plus the remaining days\nif remaining_days >= 6:\n    max_days_off = min_days_off + 1\nelse:\n    max_days_off = min_days_off + remaining_days\n\n# Print the minimum and maximum possible number of days off\nprint(min_days_off, max_days_off)"}
{"solution": "# Read the input\nn, a, b, p, q = map(int, input().split())\n\n# Calculate the least common multiple of a and b\nlcm = a * b // math.gcd(a, b)\n\n# Calculate the number of tiles that will be painted red\nred_tiles = n // a + n // b - n // lcm\n\n# Calculate the number of tiles that will be painted blue\nblue_tiles = n - red_tiles\n\n# Calculate the maximum number of chocolates Joty can get\nmax_chocolates = red_tiles * p + blue_tiles * q\n\n# Print the result\nprint(max_chocolates)"}
{"solution": "n = int(input())\ntrophies = list(input())\n\n# Initialize variables to keep track of the maximum length of a subsegment of golden trophies\nmax_length = 0\ncurrent_length = 0\n\n# Initialize variables to keep track of the indices of the silver trophies\nsilver_indices = []\n\n# Iterate over the trophies\nfor i in range(n):\n    if trophies[i] == 'G':\n        # If the current trophy is golden, increment the current length\n        current_length += 1\n    else:\n        # If the current trophy is silver, add its index to the list of silver indices\n        silver_indices.append(i)\n        # Reset the current length\n        current_length = 0\n    # Update the maximum length\n    max_length = max(max_length, current_length)\n\n# If there are no silver trophies, print the maximum length and exit\nif not silver_indices:\n    print(max_length)\n    exit()\n\n# Initialize variables to keep track of the maximum possible length of a subsegment of golden trophies\nmax_possible_length = max_length\n\n# Iterate over the silver indices\nfor i in silver_indices:\n    # If the current trophy is not the first or the last trophy\n    if i != 0 and i != n - 1:\n        # If the trophies before and after the current trophy are golden\n        if trophies[i - 1] == 'G' and trophies[i + 1] == 'G':\n            # Calculate the length of the subsegment of golden trophies that would be created by swapping the current trophy\n            length = 0\n            j = i - 1\n            while j >= 0 and trophies[j] == 'G':\n                length += 1\n                j -= 1\n            j = i + 1\n            while j < n and trophies[j] == 'G':\n                length += 1\n                j += 1\n            # Update the maximum possible length\n            max_possible_length = max(max_possible_length, length + 1)\n\n# Print the maximum possible length\nprint(max_possible_length)"}
{"solution": "from collections import defaultdict, deque\nimport sys\n\ndef topological_sort(graph, main_courses):\n    in_degree = defaultdict(int)\n    for course in graph:\n        for dependency in graph[course]:\n            in_degree[dependency] += 1\n\n    queue = deque([course for course in graph if course not in in_degree])\n    order = []\n\n    while queue:\n        course = queue.popleft()\n        if course in main_courses:\n            order.append(course)\n        for dependency in graph[course]:\n            in_degree[dependency] -= 1\n            if in_degree[dependency] == 0:\n                queue.append(dependency)\n\n    return order if len(order) == len(main_courses) else -1\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    main_courses = set(map(int, sys.stdin.readline().split()))\n    graph = defaultdict(list)\n\n    for i in range(1, n + 1):\n        dependencies = list(map(int, sys.stdin.readline().split()))[1:]\n        for dependency in dependencies:\n            graph[dependency].append(i)\n\n    order = topological_sort(graph, main_courses)\n\n    if order == -1:\n        print(-1)\n    else:\n        print(len(order))\n        print(' '.join(map(str, order)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\nfrom collections import deque\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    p = list(map(int, sys.stdin.readline().split()))\n\n    stack = deque()\n    b = []\n    i = 0\n\n    for num in range(1, n + 1):\n        if i < k and p[i] == num:\n            stack.append(p[i])\n            i += 1\n        elif stack and stack[-1] == num:\n            b.append(stack.pop())\n        else:\n            stack.append(num)\n\n    while stack:\n        b.append(stack.pop())\n\n    if b == sorted(b):\n        while i < k:\n            b.append(p[i])\n            i += 1\n        print(*b)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input\na, b, c = map(int, input().split())\n\n# If the difference is 0, check if the first element is equal to Vasya's favorite number\nif c == 0:\n    if a == b:\n        print('YES')\n    else:\n        print('NO')\n# If the difference is not 0, calculate the nth term of the sequence and check if Vasya's favorite number is in the sequence\nelse:\n    # Calculate the nth term of the sequence\n    n = (b - a) / c\n    # Check if n is a positive integer\n    if n > 0 and n == int(n):\n        print('YES')\n    else:\n        print('NO')"}
{"solution": "# Read the input\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\n# Check if it is possible to form a regular bracket sequence\nif cnt_1 > 0 and cnt_4 > 0:\n    if cnt_1 > cnt_4 or cnt_3 > cnt_4:\n        print(0)\n    else:\n        cnt_4 -= cnt_1\n        if cnt_2 > cnt_4 or cnt_3 > cnt_4:\n            print(0)\n        else:\n            print(1)\nelse:\n    print(1)"}
{"solution": "# Get the input\nn, k, t = map(int, input().split())\n\n# Calculate the number of standing spectators\nif t <= k:\n    # In the first k seconds, t spectators are standing\n    standing = t\nelif t <= n:\n    # From k+1 to n seconds, k spectators are standing\n    standing = k\nelse:\n    # After n seconds, the number of standing spectators decreases\n    standing = max(0, n - (t - n))\n\n# Print the result\nprint(standing)"}
{"solution": "s = input()\nt = ''\nu = ''\n\nwhile s:\n    # Extract the first character of s and append t with this character\n    t += s[0]\n    s = s[1:]\n\n    # If the first character of t is less than or equal to the last character of s,\n    # extract the last character of t and append u with this character\n    while t and (s == '' or t[-1] <= s[0]):\n        u += t[-1]\n        t = t[:-1]\n\n# If there are remaining characters in t, append them to u in reverse order\nwhile t:\n    u += t[-1]\n    t = t[:-1]\n\nprint(u)"}
{"solution": "def check_records(n, records):\n    prev_plays, prev_clears = records[0]\n    for plays, clears in records[1:]:\n        if plays < prev_plays or clears < prev_clears or clears > plays:\n            return \"NO\"\n        prev_plays, prev_clears = plays, clears\n    return \"YES\"\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        records = [tuple(map(int, input().split())) for _ in range(n)]\n        print(check_records(n, records))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def next_palindrome(time):\n    hour, minute = map(int, time.split(':'))\n    while True:\n        minute += 1\n        if minute == 60:\n            minute = 0\n            hour += 1\n            if hour == 24:\n                hour = 0\n        if str(hour).zfill(2) == str(minute).zfill(2)[::-1]:\n            return hour * 60 + minute\n\ndef min_sleep(time):\n    current_time = int(time[:2]) * 60 + int(time[3:])\n    next_palindrome_time = next_palindrome(time)\n    return (next_palindrome_time - current_time) % (24 * 60)\n\ntime = input()\nprint(min_sleep(time))"}
{"solution": "n = int(input())\narr = list(map(int, input().split()))\n\n# Find the indices of 1 and n\nidx_1 = arr.index(1)\nidx_n = arr.index(n)\n\n# Calculate the distance between 1 and n\ndist = abs(idx_1 - idx_n)\n\n# Calculate the maximum possible distance\nmax_dist = max(idx_1, idx_n, n - idx_1 - 1, n - idx_n - 1)\n\n# Print the result\nprint(max_dist - dist)"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    for i in range(n // 2):\n        if s[i] != s[n - i - 1]:\n            return \"NIE\"\n    return \"TAK\"\n\ns = input()\nprint(is_s_palindrome(s))"}
{"solution": "def max_permutation(a, b):\n    a = list(str(a))\n    b = list(str(b))\n    a.sort(reverse=True)\n    res = []\n    for digit in a:\n        if digit in b:\n            res.append(digit)\n            b.remove(digit)\n    for digit in b:\n        if digit <= res[-1]:\n            res.append(digit)\n            break\n    res.sort(reverse=True)\n    return int(''.join(res))\n\na = int(input())\nb = int(input())\nprint(max_permutation(a, b))"}
{"solution": "def check_win(board, player):\n    for i in range(10):\n        for j in range(10):\n            if i < 6 and board[i][j] == board[i+1][j] == board[i+2][j] == board[i+3][j] == board[i+4][j] == player:\n                return True\n            if j < 6 and board[i][j] == board[i][j+1] == board[i][j+2] == board[i][j+3] == board[i][j+4] == player:\n                return True\n            if i < 6 and j < 6 and board[i][j] == board[i+1][j+1] == board[i+2][j+2] == board[i+3][j+3] == board[i+4][j+4] == player:\n                return True\n            if i < 6 and j > 3 and board[i][j] == board[i+1][j-1] == board[i+2][j-2] == board[i+3][j-3] == board[i+4][j-4] == player:\n                return True\n    return False\n\nboard = [list(input()) for _ in range(10)]\n\nfor i in range(10):\n    for j in range(10):\n        if board[i][j] == '.':\n            board[i][j] = 'X'\n            if check_win(board, 'X'):\n                print('YES')\n                exit()\n            board[i][j] = '.'\n\nprint('NO')"}
{"solution": "n, k = map(int, input().split())\n\n# Check if it's possible to create such a matrix\nif k > n * n or (n * n % 2 == 1 and k > n * n // 2):\n    print(-1)\nelse:\n    # Create an empty n x n matrix\n    matrix = [[0] * n for _ in range(n)]\n\n    # Fill the matrix\n    for i in range(n):\n        for j in range(i, n):\n            if k >= n - i:\n                matrix[i][j] = matrix[j][i] = 1\n                k -= n - i\n            if k == 0:\n                break\n\n    # Print the matrix\n    for row in matrix:\n        print(' '.join(map(str, row)))"}
{"solution": "# Get the input values\nx, y, z = map(float, input().split())\n\n# Calculate all the expressions\nexpressions = [\n    x ** y ** z,\n    x ** z ** y,\n    (x ** y) ** z,\n    (x ** z) ** y,\n    y ** x ** z,\n    y ** z ** x,\n    (y ** x) ** z,\n    (y ** z) ** x,\n    z ** x ** y,\n    z ** y ** x,\n    (z ** x) ** y,\n    (z ** y) ** x\n]\n\n# Find the maximum value and its index\nmax_value = max(expressions)\nmax_index = expressions.index(max_value) + 1\n\n# Define the expressions as strings\nexpression_strings = [\n    \"x^y^z\",\n    \"x^z^y\",\n    \"(x^y)^z\",\n    \"(x^z)^y\",\n    \"y^x^z\",\n    \"y^z^x\",\n    \"(y^x)^z\",\n    \"(y^z)^x\",\n    \"z^x^y\",\n    \"z^y^x\",\n    \"(z^x)^y\",\n    \"(z^y)^x\"\n]\n\n# Print the expression corresponding to the maximum value\nprint(expression_strings[max_index - 1])"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize the minimum number of operations as the length of the string\nmin_operations = n\n\n# Iterate over all possible lengths of the prefix\nfor i in range(1, n // 2 + 1):\n    # Check if the prefix repeats to form the string\n    if s[:i] * (n // i) == s[:n // i * i]:\n        # Calculate the number of operations required\n        operations = i + 1 if n % i > 0 else i\n        # Update the minimum number of operations\n        min_operations = min(min_operations, operations)\n\nprint(min_operations)"}
{"solution": "n = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = [file[0] for file in files if file[1] == '1']\nregular = [file[0] for file in files if file[1] == '0']\n\nscript = []\n\n# Rename examples\nfor i, example in enumerate(examples, start=1):\n    script.append(f'move {example} {i}')\n\n# Rename regular tests\nfor i, regular_test in enumerate(regular, start=len(examples)+1):\n    script.append(f'move {regular_test} {i}')\n\nprint(len(script))\nfor line in script:\n    print(line)"}
{"solution": "# Get the input ticket number as a string\nticket = input()\n\n# Calculate the sum of the first three digits\nsum_first_half = sum(int(digit) for digit in ticket[:3])\n\n# Calculate the sum of the last three digits\nsum_second_half = sum(int(digit) for digit in ticket[3:])\n\n# Calculate the difference between the two sums\ndifference = abs(sum_first_half - sum_second_half)\n\n# If the difference is less than or equal to 9, then we can make the ticket lucky by replacing one digit\n# Otherwise, we need to replace two digits\nif difference <= 9:\n    print(1)\nelse:\n    print(2)"}
{"solution": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef order(x, m):\n    if gcd(x, m) != 1:\n        return -1\n    k = 1\n    while pow(x, k, m) != 1:\n        k += 1\n    return k\n\nm, x = map(int, input().split())\nprint(order(x, m))"}
{"solution": "MOD = 10**6 + 3\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef nCr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * power(den, p - 2, p)) % p\n\ndef solve(n, k):\n    p = 2**n\n    A = p\n    B = p\n    for i in range(2, k + 1):\n        A = (A * (p - i + 1) % MOD) % MOD\n        B = (B * nCr(p, i, MOD) % MOD) % MOD\n    return A, B\n\nn, k = map(int, input().split())\nA, B = solve(n, k)\nprint(A, B)"}
{"solution": "n = int(input())\nx, y = 0, 20000\n\nfor _ in range(n):\n    t, dir = input().split()\n    t = int(t)\n\n    if dir == \"North\":\n        y += t\n    elif dir == \"South\":\n        y -= t\n    elif dir == \"East\":\n        x += t\n    elif dir == \"West\":\n        x -= t\n\n    if y > 20000 or y < 0:\n        print(\"NO\")\n        exit()\n\n    if x > 40000:\n        x -= 40000\n    elif x < 0:\n        x += 40000\n\nif y == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def solve(a1, b1, a2, b2, L, R):\n    if a1 == a2:\n        if b1 == b2 and L <= b1 <= R:\n            return R - L + 1\n        elif (b2 - b1) % a1 == 0 and L <= b1 <= R:\n            return (R - b1) // a1 + 1\n        else:\n            return 0\n    else:\n        if (b2 - b1) % (a1 - a2) == 0:\n            k = (b2 - b1) // (a1 - a2)\n            x = a1 * k + b1\n            if x >= L and x <= R and k >= 0:\n                return 1\n        return 0\n\na1, b1, a2, b2, L, R = map(int, input().split())\nprint(solve(a1, b1, a2, b2, L, R))"}
{"solution": "# Get the input\nn, a, b = map(int, input().split())\n\n# Initialize the maximum possible number of pieces on a plate\nx = 0\n\n# While it's possible to distribute the cakes according to the conditions\nwhile a >= x + 1 and b >= x + 1 and a + b >= n:\n    # Calculate the number of plates that can be filled with pieces from the first cake\n    plates_from_first_cake = min(a, n // 2)\n    # Calculate the number of plates that can be filled with pieces from the second cake\n    plates_from_second_cake = min(b, n - plates_from_first_cake)\n    # If it's possible to distribute the cakes according to the conditions\n    if plates_from_first_cake + plates_from_second_cake >= n:\n        # Update the maximum possible number of pieces on a plate\n        x += 1\n        # Update the number of pieces of the first cake\n        a -= plates_from_first_cake\n        # Update the number of pieces of the second cake\n        b -= plates_from_second_cake\n    else:\n        # It's not possible to distribute the cakes according to the conditions\n        break\n\n# Print the maximum possible number of pieces on a plate\nprint(x)"}
{"solution": "def check_flag(n, m, flag):\n    colors = ['R', 'G', 'B']\n    color_count = {color: 0 for color in colors}\n\n    # Check rows\n    for i in range(n):\n        color = flag[i][0]\n        if color not in colors:\n            return False\n        if all(c == color for c in flag[i]):\n            color_count[color] += 1\n        else:\n            return False\n\n    # Check columns\n    for j in range(m):\n        color = flag[0][j]\n        if color not in colors:\n            return False\n        if all(flag[i][j] == color for i in range(n)):\n            color_count[color] += 1\n        else:\n            return False\n\n    # Check if each color is used exactly once\n    return all(count == 2 for count in color_count.values())\n\nn, m = map(int, input().split())\nflag = [input() for _ in range(n)]\n\nif check_flag(n, m, flag):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "# Get the input value for the number of moves\nn = int(input())\n\n# Initialize the current coordinates to (0, 0)\nx, y = 0, 0\n\n# Define the six directions that Ayrat can move in\ndirections = [(1, 0), (1, -1), (0, -1), (-1, 0), (-1, 1), (0, 1)]\n\n# Initialize a variable to keep track of the current direction index\ndirection_index = 0\n\n# Initialize a variable to keep track of the number of moves made in the current direction\nmoves_in_direction = 1\n\n# Loop until Ayrat has made n moves\nwhile n > 0:\n    # Get the current direction\n    direction = directions[direction_index]\n\n    # Calculate the number of moves that Ayrat can make in the current direction\n    moves_to_make = min(n, moves_in_direction)\n\n    # Update the current coordinates based on the number of moves made in the current direction\n    x += moves_to_make * direction[0]\n    y += moves_to_make * direction[1]\n\n    # Update the number of moves remaining\n    n -= moves_to_make\n\n    # Update the current direction index\n    direction_index = (direction_index + 1) % 6\n\n    # If Ayrat has completed a full cycle of the spiral, increment the number of moves in the current direction\n    if direction_index == 0:\n        moves_in_direction += 1\n\n# Print the current coordinates\nprint(x, y)"}
{"solution": "# Get the input\na, b, c = map(int, input().split())\n\n# Check if it's possible to deal exactly c damage\nfor i in range(c // a + 1):\n    if (c - i * a) % b == 0:\n        print(\"Yes\")\n        break\nelse:\n    print(\"No\")"}
{"solution": "def solve():\n    n, L = map(int, input().split())\n    kefa = list(map(int, input().split()))\n    sasha = list(map(int, input().split()))\n\n    # Calculate the differences between consecutive barriers for both Kefa and Sasha\n    kefa_diff = [kefa[i] - kefa[i - 1] for i in range(1, n)] + [L - kefa[-1] + kefa[0]]\n    sasha_diff = [sasha[i] - sasha[i - 1] for i in range(1, n)] + [L - sasha[-1] + sasha[0]]\n\n    # Check if the differences are equal or reversed\n    if kefa_diff == sasha_diff or kefa_diff == sasha_diff[::-1]:\n        print('YES')\n    else:\n        print('NO')\n\nsolve()"}
{"solution": "def longest_non_palindrome_substring(s):\n    n = len(s)\n    max_length = 0\n\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substring = s[i:j]\n            if substring != substring[::-1]:\n                max_length = max(max_length, len(substring))\n\n    return max_length\n\ns = input()\nprint(longest_non_palindrome_substring(s))"}
{"solution": "n = int(input())\nratings = [list(map(int, input().split())) for _ in range(n)]\n\n# Check if any rating has changed\nif any(a != b for a, b in ratings):\n    print(\"rated\")\nelse:\n    # Check if there is a pair of participants with lower and higher ratings but lower-rated participant is ahead\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if ratings[i][0] > ratings[j][0]:\n                print(\"maybe\")\n                exit()\n    print(\"unrated\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize the result list\nd = [0] * n\n\n# Initialize the last zero index\nlast_zero = float('-inf')\n\n# Iterate over the array from left to right\nfor i in range(n):\n    # If the current element is zero, update the last zero index\n    if a[i] == 0:\n        last_zero = i\n    # Otherwise, calculate the distance to the last zero index\n    else:\n        d[i] = i - last_zero\n\n# Initialize the last zero index\nlast_zero = float('inf')\n\n# Iterate over the array from right to left\nfor i in range(n-1, -1, -1):\n    # If the current element is zero, update the last zero index\n    if a[i] == 0:\n        last_zero = i\n    # Otherwise, update the distance to the last zero index if it's smaller\n    else:\n        d[i] = min(d[i], last_zero - i)\n\n# Print the result\nprint(*d)"}
{"solution": "def cyclical_binary_strings(n, s):\n    # Create a double length string to handle cyclical shifts\n    double_s = s + s\n    # Initialize count of distinct cyclical binary strings\n    count = 0\n    # Iterate over all possible starting points of the substring\n    for i in range(len(s)):\n        # Create a binary string of length n\n        t = double_s[i:i+n]\n        # Check if t is a valid cyclical binary string\n        if '0' in t and '1' in t:\n            # Check if s is a substring of t\n            if s in t:\n                # Increment count\n                count += 1\n    # Return count\n    return count\n\n# Read input\nn = int(input())\ns = input()\n# Print output\nprint(cyclical_binary_strings(n, s))"}
{"solution": "import math\n\ndef find_min_angle_vectors(vectors):\n    n = len(vectors)\n    angles = [math.atan2(y, x) for x, y in vectors]\n    angles.sort()\n    angles += [angle + 2 * math.pi for angle in angles]\n    min_angle = float('inf')\n    pair = (0, 0)\n    for i in range(n):\n        angle_diff = angles[i + n] - angles[i]\n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            pair = (i + 1, i + n + 1 - n)\n    return pair\n\nn = int(input())\nvectors = [tuple(map(int, input().split())) for _ in range(n)]\nresult = find_min_angle_vectors(vectors)\nprint(*result)"}
{"solution": "def min_time(d, k, a, b, t):\n    time = 0\n    while d > 0:\n        if d > k:\n            time += k * a\n            d -= k\n            if a < b:\n                time += t\n        else:\n            time += d * a\n            d = 0\n        if d > 0 and a >= b:\n            time += (d * (b - a))\n            d = 0\n    return time\n\nd, k, a, b, t = map(int, input().split())\nprint(min_time(d, k, a, b, t))"}
{"solution": "def max_gcd_sequence(n, k):\n    # If the sum is less than the number of elements, return -1\n    if n < k:\n        return [-1]\n\n    # Calculate the sum of an arithmetic sequence\n    arithmetic_sum = k * (k + 1) // 2\n\n    # If the sum is less than n, return -1\n    if arithmetic_sum < n:\n        return [-1]\n\n    # Calculate the difference between the sum of the arithmetic sequence and n\n    diff = arithmetic_sum - n\n\n    # If the difference is greater than k - 1, return -1\n    if diff > k - 1:\n        return [-1]\n\n    # Create the sequence\n    sequence = list(range(1, k - diff)) + [k - diff + (k - diff + 1) // 2] * 2\n\n    # Add the remaining elements to the sequence\n    sequence += list(range(k - diff + 1 + (k - diff) % 2, k + 1))\n\n    return sequence\n\n# Read the input\nn, k = map(int, input().split())\n\n# Print the output\nprint(*max_gcd_sequence(n, k))"}
{"solution": "def count_pairs(n, m):\n    count = 0\n    for x in range(1, n + 1):\n        for y in range(1, m + 1):\n            if (x + y) % 5 == 0:\n                count += 1\n    return count\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))"}
{"solution": "def max_beauty(n, x, a):\n    max_ending_here = max_so_far = 0\n    for i in range(n):\n        max_ending_here = max(x * a[i], max_ending_here + x * a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\nprint(max_beauty(n, x, a))"}
{"solution": "def find_kth_largest(n, m, k):\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if sum(min(mid // i, m) for i in range(1, n + 1)) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\nn, m, k = map(int, input().split())\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    if k <= 9:\n        return k\n\n    count = 9\n    i = 1\n    while k > count * i:\n        k -= count * i\n        i += 1\n        count *= 10\n\n    start_number = 10 ** (i - 1)\n    number = start_number + (k - 1) // i\n    digit_index = (k - 1) % i\n\n    return int(str(number)[digit_index])\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "# Get the input\nn, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Find the minimum price to buy\nmin_buy = min(s)\n\n# Calculate the maximum number of shares that can be bought\nmax_shares = r // min_buy\n\n# Find the maximum price to sell\nmax_sell = max(b)\n\n# Calculate the maximum number of bourles that can be held after the evening\nmax_bourles = r + max_shares * (max_sell - min_buy)\n\n# Print the result\nprint(max_bourles)"}
{"solution": "def solve(t):\n    n = len(t)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0 and t[:i] * (n // i) == t:\n            return t[:i]\n    return None\n\nt = input()\ns = solve(t)\nif s is None:\n    print('NO')\nelse:\n    print('YES')\n    print(s)"}
{"solution": "# Read the input\nn = int(input())\n\n# Initialize an empty list to store the possible numbers of teams\nteams = []\n\n# Calculate the number of teams that will yield exactly n games\n# Start with the smallest possible number of teams\nnum_teams = 1\nwhile True:\n    # Calculate the number of games played in the first stage\n    games_first_stage = num_teams // 2\n\n    # Calculate the number of teams remaining after the first stage\n    remaining_teams = num_teams // 2\n\n    # Calculate the number of games played in the round-robin tournament\n    games_round_robin = remaining_teams * (remaining_teams - 1) // 2\n\n    # Calculate the total number of games played\n    total_games = games_first_stage + games_round_robin\n\n    # If the total number of games is equal to n, add the number of teams to the list\n    if total_games == n:\n        teams.append(num_teams)\n\n    # If the total number of games is greater than n, stop calculating\n    if total_games > n:\n        break\n\n    # Increment the number of teams\n    num_teams += 1\n\n# If there are no possible numbers of teams, print -1\nif not teams:\n    print(-1)\n# Otherwise, print the possible numbers of teams in ascending order\nelse:\n    for team in teams:\n        print(team)"}
{"solution": "from collections import Counter\n\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\n# Count the frequency of each character in the string\nfreq = Counter(s)\n\n# Initialize the maximum possible beauty of t\nmax_beauty = 0\n\n# Iterate over the characters in the string\nfor i in range(n // 2):\n    # If the characters at positions i and n - i - 1 are different\n    if s[i] != s[n - i - 1]:\n        # Add the beauty of the index i to the maximum possible beauty\n        max_beauty += b[i]\n        # Add the beauty of the index n - i - 1 to the maximum possible beauty\n        max_beauty += b[n - i - 1]\n    # If the characters at positions i and n - i - 1 are the same\n    else:\n        # If the frequency of the character is greater than 2\n        if freq[s[i]] > 2:\n            # Add the beauty of the index i to the maximum possible beauty\n            max_beauty += b[i]\n            # Add the beauty of the index n - i - 1 to the maximum possible beauty\n            max_beauty += b[n - i - 1]\n            # Decrease the frequency of the character by 2\n            freq[s[i]] -= 2\n        # If the frequency of the character is equal to 2\n        elif freq[s[i]] == 2:\n            # Add the beauty of the index i or n - i - 1 to the maximum possible beauty\n            max_beauty += max(b[i], b[n - i - 1])\n            # Decrease the frequency of the character by 2\n            freq[s[i]] -= 2\n\nprint(max_beauty)"}
{"solution": "# Read the input\nw, m = map(int, input().split())\n\n# Check if it is possible to weigh the item\nif m % w == 0 or (m + w) % w == 0:\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def solve(n, k):\n    if n < k or (n & (n - 1)) < k - 1:\n        return \"No\"\n    ans = []\n    while n:\n        if n & 1:\n            ans.append(0)\n            k -= 1\n        n >>= 1\n        if n and k > 1:\n            ans.append(1)\n            k -= 1\n    ans += [max(ans)] * k\n    return \"Yes\\n\" + \" \".join(map(str, ans[::-1]))\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "def champagne_tower(n, t):\n    # Initialize the tower with 0s\n    tower = [[0.0] * k for k in range(1, n+2)]\n\n    # Pour the champagne\n    tower[1][1] = t\n\n    # Simulate the flow of champagne\n    for r in range(1, n):\n        for c in range(1, r+1):\n            q = (tower[r][c] - 1.0) / 2.0\n            if q > 0:\n                tower[r+1][c] += q\n                tower[r+1][c+1] += q\n\n    # Count the full glasses\n    full_glasses = 0\n    for r in range(1, n+1):\n        for c in range(1, r+1):\n            if tower[r][c] >= 1.0:\n                full_glasses += 1\n\n    return full_glasses\n\n# Read the input\nn, t = map(int, input().split())\n\n# Print the output\nprint(champagne_tower(n, t))"}
{"solution": "# Read the number of remaining vertices\nn = int(input())\n\n# Initialize an empty list to store the remaining vertices\nvertices = []\n\n# Read the remaining vertices\nfor i in range(n):\n    x, y = map(int, input().split())\n    vertices.append((x, y))\n\n# If there is only one vertex remaining, it's not enough to determine the area\nif n == 1:\n    print(-1)\nelse:\n    # Sort the vertices by x-coordinate and then by y-coordinate\n    vertices.sort()\n\n    # Calculate the area of the rectangle\n    area = abs(vertices[0][0] - vertices[-1][0]) * abs(vertices[0][1] - vertices[-1][1])\n\n    # Print the area\n    print(area)"}
{"solution": "# Get the input\nn = int(input())\na = int(input())\nb = int(input())\n\n# Calculate the total length of wood needed for two doors\ntotal_length = 2 * (2 * a + b)\n\n# Calculate the minimal number of wooden bars needed\nmin_bars = total_length // n\n\n# If the total length is not a multiple of n, an additional bar is needed\nif total_length % n != 0:\n    min_bars += 1\n\n# Print the result\nprint(min_bars)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\ns = input()\n\n# Create a list of indices where swapping is allowed\nallowed_swaps = [i for i in range(n - 1) if s[i] == '1']\n\n# Create a list of tuples where each tuple contains the value and its index\nval_index = sorted((val, idx) for idx, val in enumerate(a))\n\n# Create a list of the sorted indices\nsorted_indices = [idx for val, idx in val_index]\n\n# Create a list to keep track of visited indices\nvisited = [False] * n\n\n# Iterate over the sorted indices\nfor i in sorted_indices:\n    # If the index has not been visited\n    if not visited[i]:\n        # Create a list to keep track of the cycle\n        cycle = []\n        # While the index has not been visited\n        while not visited[i]:\n            # Mark the index as visited\n            visited[i] = True\n            # Add the index to the cycle\n            cycle.append(i)\n            # Update the index to the next index in the cycle\n            i = sorted_indices[i]\n        # If the cycle length is greater than 2 and there are not enough allowed swaps\n        if len(cycle) > 2 and cycle.index(min(cycle)) + 1 < len(cycle) - cycle.index(max(cycle)) and not all(j in allowed_swaps for j in range(min(cycle), max(cycle))):\n            # Print \"NO\" and exit\n            print(\"NO\")\n            exit()\n\n# Print \"YES\"\nprint(\"YES\")"}
{"solution": "# Get the input\nseat = input()\n\n# Extract the row number and seat letter\nrow = int(seat[:-1])\nseat_letter = seat[-1]\n\n# Define the seat order\nseat_order = ['f', 'e', 'd', 'c', 'b', 'a']\n\n# Calculate the time it takes for the flight attendants to serve the rows before Vasya's row\ntime = 0\ncurrent_row = 1\nwhile current_row < row:\n    time += 6  # Serve 6 seats in the current row\n    if current_row % 2 == 1:\n        current_row += 2  # Move to the next row served by the first flight attendant\n    else:\n        current_row += 1  # Move to the next row served by the second flight attendant\n\n# Calculate the time it takes for the flight attendants to serve the seats before Vasya's seat\ntime += seat_order.index(seat_letter)\n\n# Print the result\nprint(time)"}
{"solution": "# Read input\nn, bx = map(int, input().split())\nx = list(map(int, input().split()))\nm, by = map(int, input().split())\ny = list(map(int, input().split()))\n\n# Convert to base 10\nx_dec = sum(x[i] * (bx ** (n - i - 1)) for i in range(n))\ny_dec = sum(y[i] * (by ** (m - i - 1)) for i in range(m))\n\n# Compare\nif x_dec < y_dec:\n    print(\"<\")\nelif x_dec > y_dec:\n    print(\">\")\nelse:\n    print(\"=\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# If there is a 0 in the list, BitAryo can always win by choosing x = 0\nif 0 in a:\n    print(\"BitAryo\")\n# If all numbers are equal, the game length is even, BitLGM wins; otherwise, BitAryo wins\nelif len(set(a)) == 1:\n    print(\"BitLGM\" if n % 2 == 0 else \"BitAryo\")\n# If there are two distinct numbers, BitAryo can always win by choosing the minimum number\nelse:\n    print(\"BitAryo\")"}
{"solution": "from math import gcd\nfrom collections import defaultdict\n\ndef factorize(n):\n    i = 2\n    factors = defaultdict(int)\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors[i] += 1\n    if n > 1:\n        factors[n] += 1\n    return factors\n\ndef solve(n, k, a):\n    factors = factorize(k)\n    count = 0\n    for i in range(n):\n        temp = defaultdict(int)\n        for key, value in factors.items():\n            temp[key] = value\n        j = i\n        while j < n and all(temp[key] > 0 for key in factors):\n            card_factors = factorize(a[j])\n            for key in card_factors:\n                if key in temp:\n                    temp[key] -= card_factors[key]\n            if all(temp[key] <= 0 for key in factors):\n                count += 1\n            j += 1\n    return count * (count - 1) // 2\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(solve(n, k, a))"}
{"solution": "n, k = map(int, input().split())\ns = input()\n\n# Count the occurrence of each color\ncolor_count = {}\nfor c in s:\n    if c in color_count:\n        color_count[c] += 1\n    else:\n        color_count[c] = 1\n\n# Check if it's possible to distribute the balloons\nfor count in color_count.values():\n    if count > k:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmin_val = min(a)\nmin_indices = [i for i, x in enumerate(a) if x == min_val]\n\nmin_dist = float('inf')\nfor i in range(1, len(min_indices)):\n    min_dist = min(min_dist, min_indices[i] - min_indices[i-1])\n\nprint(min_dist)"}
{"solution": "from math import gcd\n\ndef calculate_gcd(x, y):\n    while(y):\n        x, y = y, x % y\n    return x\n\ndef calculate_probability(t, w, b):\n    lcm = w * b // calculate_gcd(w, b)\n    total_steps = t // lcm\n    if w == b:\n        return f'{total_steps % 2}/{total_steps + 1}'\n    else:\n        willman_steps = t // w - total_steps\n        bolt_steps = t // b - total_steps\n        common_steps = total_steps\n        total_outcomes = willman_steps + bolt_steps + common_steps\n        return f'{common_steps}/{total_outcomes}'\n\nt, w, b = map(int, input().split())\nprint(calculate_probability(t, w, b))"}
{"solution": "# Get the input\nx, y, z = map(int, input().split())\n\n# Calculate the difference between upvotes and downvotes\ndiff = x - y\n\n# If the difference is greater than z, the result is \"+\"\nif diff > z:\n    print(\"+\")\n# If the difference is less than -z, the result is \"-\"\nelif diff < -z:\n    print(\"-\")\n# If the absolute difference is less than or equal to z, the result is \"0\"\nelif abs(diff) <= z:\n    print(\"0\")\n# Otherwise, the result is uncertain\nelse:\n    print(\"?\")"}
{"solution": "def min_steps(n, operations, x, y):\n    pos = [0, 0]\n    for op in operations:\n        if op == 'U':\n            pos[1] += 1\n        elif op == 'D':\n            pos[1] -= 1\n        elif op == 'L':\n            pos[0] -= 1\n        elif op == 'R':\n            pos[0] += 1\n\n    if pos[0] != x or pos[1] != y:\n        return -1\n\n    min_len = n\n    l = r = 0\n    while r < n:\n        if operations[r] == ('U' if y > 0 else 'D'):\n            y -= 1\n        elif operations[r] == ('D' if y < 0 else 'U'):\n            y += 1\n        elif operations[r] == ('L' if x > 0 else 'R'):\n            x -= 1\n        elif operations[r] == ('R' if x < 0 else 'L'):\n            x += 1\n\n        while x == 0 and y == 0:\n            min_len = min(min_len, r - l + 1)\n            if operations[l] == ('U' if y < 0 else 'D'):\n                y += 1\n            elif operations[l] == ('D' if y > 0 else 'U'):\n                y -= 1\n            elif operations[l] == ('L' if x < 0 else 'R'):\n                x += 1\n            elif operations[l] == ('R' if x > 0 else 'L'):\n                x -= 1\n            l += 1\n        r += 1\n\n    return min_len\n\nn = int(input())\noperations = input()\nx, y = map(int, input().split())\n\nprint(min_steps(n, operations, x, y))"}
{"solution": "from collections import defaultdict\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        n, x = map(int, input().split())\n        s = input()\n        balance = [0] * (n + 1)\n        for i in range(n):\n            balance[i + 1] = balance[i] + (1 if s[i] == '1' else -1)\n        count = defaultdict(int)\n        count[0] = 1\n        ans = 0\n        for i in range(1, n + 1):\n            if balance[i] - x in count:\n                ans += count[balance[i] - x]\n            count[balance[i]] += 1\n        if balance[n] == x:\n            ans += 1\n        if balance[n] == 0 and x == 0:\n            ans = -1\n        print(ans)\n\nsolve()"}
{"solution": "n, k = map(int, input().split())\nn = str(n)\n\n# Find the index of the k-th digit from the right\nindex = len(n) - k\n\n# Count the number of digits to be deleted\ncount = 0\nwhile index < len(n) and n[index] != '0':\n    count += 1\n    index += 1\n\n# If the number starts with '0', we may need to delete more digits\nif n[0] == '0' and len(n) > 1:\n    count += len(n) - 1\n\nprint(count)"}
{"solution": "def solve(n, m, k, x, y):\n    total_students = n * m\n    max_questions = k // total_students\n    k %= total_students\n    max_questions += 1 if k >= (x - 1) * m + y else 0\n    min_questions = k // total_students\n    min_questions += 1 if k % total_students >= (x - 1) * m + y else 0\n    sergei_questions = (k - 1) // (m * n) * 2 + 1\n    sergei_questions += 1 if (k - 1) % (m * n) + 1 >= (x - 1) * m + y else 0\n    return max_questions, min_questions, sergei_questions\n\nn, m, k, x, y = map(int, input().split())\nmax_questions, min_questions, sergei_questions = solve(n, m, k, x, y)\nprint(max_questions, min_questions, sergei_questions)"}
{"solution": "def max_beauty(ribbon, n):\n    length = len(ribbon)\n    max_subribbon_length = min(n + 1, length)\n    max_count = 0\n    for subribbon_length in range(1, max_subribbon_length + 1):\n        for start in range(length - subribbon_length + 1):\n            subribbon = ribbon[start:start + subribbon_length]\n            count = ribbon.count(subribbon)\n            max_count = max(max_count, count)\n    return max_count\n\nn = int(input())\nribbons = [input() for _ in range(3)]\nbeauties = [max_beauty(ribbon, n) for ribbon in ribbons]\nmax_beauty = max(beauties)\nwinners = [\"Kuro\", \"Shiro\", \"Katie\"]\nwinner_count = beauties.count(max_beauty)\nif winner_count == 1:\n    print(winners[beauties.index(max_beauty)])\nelse:\n    print(\"Draw\")"}
{"solution": "# Read the input\nc, v_0, v_1, a, l = map(int, input().split())\n\n# Initialize the days and the pages read\ndays = 1\npages_read = v_0\n\n# While the total pages read is less than the book length\nwhile pages_read < c:\n    # Calculate the pages read today\n    pages_read_today = min(v_0 + (days - 1) * a, v_1)\n\n    # Subtract the reread pages\n    pages_read_today -= l\n\n    # Update the total pages read\n    pages_read += pages_read_today\n\n    # Increment the days\n    days += 1\n\n# Print the number of days needed\nprint(days)"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True\n\ndef find_primes(n):\n    primes = []\n    i = 2\n    while i <= n:\n        if is_prime(i) and n - i >= 0:\n            primes.append(i)\n            n -= i\n        else:\n            i += 1\n    return primes\n\nn = int(input())\nprimes = find_primes(n)\nprint(len(primes))\nprint(' '.join(map(str, primes)))"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n\n    row_walls = [0] * n\n    col_walls = [0] * m\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*':\n                row_walls[i] += 1\n                col_walls[j] += 1\n\n    total_walls = sum(row_walls)\n\n    for i in range(n):\n        for j in range(m):\n            if row_walls[i] + col_walls[j] - (1 if grid[i][j] == '*' else 0) == total_walls:\n                print(\"YES\")\n                print(i + 1, j + 1)\n                return\n\n    print(\"NO\")\n\nsolve()"}
{"solution": "# Read input\nn, m, a, b = map(int, input().split())\n\n# Calculate the remainder of n divided by m\nremainder = n % m\n\n# If remainder is 0, no action is needed\nif remainder == 0:\n    print(0)\n# If building a box is cheaper than demolishing boxes\nelif a <= b:\n    # Calculate the number of boxes to build\n    boxes_to_build = m - remainder\n    print(boxes_to_build * a)\n# If demolishing a box is cheaper than building boxes\nelse:\n    # Calculate the cost of demolishing all boxes and building the necessary ones\n    cost_demolish_all = n * b\n    cost_build_necessary = (m - remainder) * a\n    # Print the minimum cost\n    print(min(cost_demolish_all, cost_build_necessary))"}
{"solution": "n = int(input())\nnumbers = list(map(int, input().split()))\n\n# Separate odd and even numbers\nodd_numbers = [num for num in numbers if num % 2 != 0]\neven_numbers = [num for num in numbers if num % 2 == 0]\n\n# Sort odd numbers in descending order\nodd_numbers.sort(reverse=True)\n\n# If there is at least one odd number, the maximum odd subsequence sum is the sum of all odd numbers\nif odd_numbers:\n    print(sum(odd_numbers))\n# If there are no odd numbers, the maximum odd subsequence sum is the maximum even number\nelse:\n    print(max(even_numbers))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve():\n    n, T = map(int, input().split())\n    songs = [list(map(int, input().split())) for _ in range(n)]\n\n    dp = [[[0] * 4 for _ in range(T + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(T + 1):\n            for k in range(4):\n                if j >= songs[i - 1][0]:\n                    for l in range(4):\n                        if l != songs[i - 1][1] and l != k:\n                            dp[i][j][songs[i - 1][1]] = (dp[i][j][songs[i - 1][1]] + dp[i - 1][j - songs[i - 1][0]][l]) % MOD\n                dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k]) % MOD\n\n    return sum(dp[n][T]) % MOD\n\nprint(solve())"}
{"solution": "import math\n\nMOD = 10**9 + 7\n\ndef inverse(n):\n    return pow(n, MOD - 2, MOD)\n\ndef expected_length(m):\n    phi = [i for i in range(m + 1)]\n    for i in range(2, m + 1):\n        if phi[i] == i:\n            for j in range(i, m + 1, i):\n                phi[j] -= phi[j] // i\n\n    numerator = 0\n    denominator = 1\n    for i in range(1, m + 1):\n        numerator = (numerator + denominator * phi[i]) % MOD\n        denominator = (denominator * (m // i)) % MOD\n\n    return (numerator * inverse(denominator)) % MOD\n\nm = int(input())\nprint(expected_length(m))"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\n\nl, r, x, y = map(int, input().split())\n\ncount = 0\nfor a in range(x, r + 1):\n    for b in range(a, r + 1):\n        if l <= a <= b <= r and gcd(a, b) == x and lcm(a, b) == y:\n            count += 1\n\nprint(count)"}
{"solution": "import math\n\ndef smallest_k(a, b):\n    gcd = math.gcd(a, b)\n    lcm = a * b // gcd\n    k = 0\n    while True:\n        if (a + k) % gcd != 0 or (b + k) % gcd != 0:\n            k += 1\n        else:\n            break\n    return k\n\na, b = map(int, input().split())\nprint(smallest_k(a, b))"}
{"solution": "# Read input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate current average\navg = sum(marks) / n\n\n# Calculate the number of marks needed to be added\n# to make the average equal to k\n# If the current average is already greater than or equal to k,\n# no additional marks are needed\nif avg >= k:\n    print(0)\nelse:\n    # Calculate the number of additional marks needed\n    # to make the average equal to k\n    # Round up the result to the nearest integer\n    additional_marks = int(n * k - sum(marks) + n - 1) // n\n    print(additional_marks)"}
{"solution": "n = int(input())\nnumbers = list(map(int, input().split()))\n\npositive_count = 0\nnegative_count = 0\nzero_count = 0\n\nfor num in numbers:\n    if num > 0:\n        positive_count += 1\n    elif num < 0:\n        negative_count += 1\n    else:\n        zero_count += 1\n\nif positive_count >= (n + 1) // 2:\n    print(1)\nelif negative_count >= (n + 1) // 2:\n    print(-1)\nelse:\n    print(0)"}
{"solution": "def count_pairs(n):\n    # Calculate the maximum possible number of nines at the end of total cost\n    max_nines = n // 9\n\n    # Calculate the maximum possible total cost\n    max_cost = 9 * max_nines\n\n    # Calculate the number of pairs that end with maximum possible number of nines\n    count = 0\n    for i in range(1, n):\n        if (i + max_cost - i) % 10 == 0:\n            count += 1\n\n    return count\n\n# Read the input\nn = int(input())\n\n# Print the output\nprint(count_pairs(n))"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef solve(a, b):\n    if a < b:\n        a, b = b, a\n    if a % b == 0:\n        return a // b - 1, a, b\n    else:\n        c = a // b\n        d = a % b\n        if d * 3 >= b:\n            return c, d, d\n        elif d * 2 >= b:\n            return c + 1, b, d\n        else:\n            return -1, 0, 0\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\nif a1 * b1 > a2 * b2:\n    a1, b1, a2, b2 = a2, b2, a1, b1\n\nif a1 * b1 == a2 * b2:\n    print(0)\n    print(a1, b1)\n    print(a2, b2)\nelse:\n    g = gcd(a1 * b1, a2 * b2)\n    a1 //= g\n    b1 //= g\n    a2 //= g\n    b2 //= g\n\n    if a1 * b1 > a2 * b2:\n        a1, b1, a2, b2 = a2, b2, a1, b1\n\n    m1, a1, b1 = solve(a1, b1)\n    m2, a2, b2 = solve(a2, b2)\n\n    if m1 == -1 or m2 == -1 or a1 * b1 != a2 * b2:\n        print(-1)\n    else:\n        print(m1 + m2)\n        print(a1 * g, b1 * g)\n        print(a2 * g, b2 * g)"}
{"solution": "# Get the input\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Calculate the sum of coordinates for both players\nsum_p = x_p + y_p\nsum_v = x_v + y_v\n\n# If the sum of coordinates for Polycarp is less than or equal to the sum of coordinates for Vasiliy,\n# then Polycarp will win, otherwise Vasiliy will win\nif sum_p <= sum_v:\n    print(\"Polycarp\")\nelse:\n    print(\"Vasiliy\")"}
{"solution": "# Get the input\nm, d = map(int, input().split())\n\n# Define the number of days in each month\ndays_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n# Calculate the number of days in the month\nnum_days = days_in_month[m - 1]\n\n# Calculate the number of columns in the calendar\n# The first day of the month is represented by (d - 1) empty cells\n# The remaining days are filled in 7-day chunks, so we add 6 to round up\nnum_columns = (num_days + d - 1) // 7 + (1 if (num_days + d - 1) % 7 > 0 else 0)\n\n# Print the result\nprint(num_columns)"}
{"solution": "def count_binary_numbers(a, b):\n    def count_zeros(n):\n        return bin(n).count('0') - 1\n\n    def count_numbers(n):\n        if n < 4:\n            return [0, 0, 0, 1][n]\n        s = str(bin(n))[2:]\n        l = len(s)\n        dp = [[0, 0] for _ in range(l)]\n        dp[0] = [1, 0]\n        for i in range(1, l):\n            dp[i][0] = dp[i - 1][0] + dp[i - 1][1]\n            dp[i][1] = dp[i - 1][0]\n        return sum(dp[-1]) - sum(count_zeros(n) == 1 for n in range(1, int(s, 2)))\n\n    return count_numbers(b) - count_numbers(a - 1)\n\na, b = map(int, input().split())\nprint(count_binary_numbers(a, b))"}
{"solution": "# Read the input\nn = int(input())\n\n# Initialize the number of layers required\nlayers = 0\n\n# Iterate through all possible endpoints\nfor i in range(n + 1):\n    # The number of segments ending at the current endpoint is i + 1\n    # Add the ceiling of this number to the total number of layers required\n    layers += (i + 1) // 2\n\n# Print the result\nprint(layers)"}
{"solution": "import sys\nfrom math import factorial\n\ndef solve(n, k, S, a):\n    # Calculate factorials up to 20\n    fact = [1]\n    for i in range(1, 21):\n        fact.append(fact[-1] * i)\n\n    # Initialize dp array\n    dp = [[0] * (k + 1) for _ in range(S + 1)]\n    dp[0][0] = 1\n\n    # Iterate over each cube\n    for i in range(n):\n        # Iterate over each possible sum\n        for j in range(S, -1, -1):\n            # Iterate over each possible number of stickers\n            for l in range(k, -1, -1):\n                # If we don't take the current cube\n                dp[j][l] += dp[j][l]\n                # If we take the current cube without a sticker\n                if j >= a[i]:\n                    dp[j][l] += dp[j - a[i]][l]\n                # If we take the current cube with a sticker\n                if j >= fact[a[i]] and l > 0:\n                    dp[j][l] += dp[j - fact[a[i]]][l - 1]\n\n    return dp[S][k]\n\n# Read input\nn, k, S = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\n\n# Print output\nprint(solve(n, k, S, a))"}
{"solution": "def solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    v = [0] * n\n    i = 0\n    while i < n:\n        if a[i] == v[i]:\n            i += 1\n            continue\n        if a[i] < v[i]:\n            return \"NO\"\n        if a[i] > v[i]:\n            if (a[i] - v[i]) % k**i != 0:\n                return \"NO\"\n            v[i] += k**i\n    return \"YES\"\n\nT = int(input())\nfor _ in range(T):\n    print(solve())"}
{"solution": "MOD = 1073741824\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n\na, b, c = map(int, input().split())\n\ntotal = 0\nfor i in range(1, a + 1):\n    for j in range(1, b + 1):\n        for k in range(1, c + 1):\n            total = (total + count_divisors(i * j * k)) % MOD\n\nprint(total)"}
{"solution": "def get_input():\n    return [input() for _ in range(4)]\n\ndef get_positions(puzzle):\n    positions = {}\n    for i in range(2):\n        for j in range(2):\n            if puzzle[i][j] != 'X':\n                positions[puzzle[i][j]] = (i, j)\n    return positions\n\ndef is_solvable(bessie, elsie):\n    bessie_positions = get_positions(bessie)\n    elsie_positions = get_positions(elsie)\n\n    for tile in 'ABC':\n        bessie_tile_pos = bessie_positions[tile]\n        elsie_tile_pos = elsie_positions[tile]\n\n        if (bessie_tile_pos[0] + elsie_tile_pos[0]) % 2 != 0:\n            return False\n\n    return True\n\ndef main():\n    bessie, elsie = get_input()[:2], get_input()[2:]\n    print(\"YES\" if is_solvable(bessie, elsie) else \"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Read input\nn = int(input())\nk = input()\n\n# Convert k to decimal\ndecimal_k = 0\nfor i, digit in enumerate(k[::-1]):\n    decimal_k += int(digit) * (n ** i)\n\n# Find the minimum decimal number\nmin_decimal = decimal_k\nwhile True:\n    # Convert min_decimal to base n\n    base_n = ''\n    temp = min_decimal\n    while temp:\n        base_n = str(temp % n) + base_n\n        temp //= n\n\n    # If base_n is equal to k, break the loop\n    if base_n == k:\n        break\n\n    # Increment min_decimal\n    min_decimal += 1\n\n# Print the result\nprint(min_decimal)"}
{"solution": "n = int(input())\narr = list(map(int, input().split()))\n\n# Find the index of the maximum element\nmax_index = arr.index(max(arr))\n\n# Check if the array is strictly increasing before the maximum element\nfor i in range(max_index):\n    if arr[i] >= arr[i+1]:\n        print(\"NO\")\n        exit()\n\n# Check if the array is constant after the maximum element\nfor i in range(max_index, n-1):\n    if arr[i] != arr[i+1]:\n        print(\"NO\")\n        exit()\n\n# Check if the array is strictly decreasing after the maximum element\nfor i in range(max_index, n-1):\n    if arr[i] <= arr[i+1]:\n        print(\"NO\")\n        exit()\n\nprint(\"YES\")"}
{"solution": "def f(x):\n    return x // 2 if x % 2 == 0 else x - 1\n\ndef path(x):\n    p = [x]\n    while x != 1:\n        x = f(x)\n        p.append(x)\n    return p\n\ndef max_y(n, k):\n    count = [0] * (n + 1)\n    for x in range(1, n + 1):\n        for y in path(x):\n            count[y] += 1\n    for y in range(n, 0, -1):\n        if count[y] >= k:\n            return y\n\nn, k = map(int, input().split())\nprint(max_y(n, k))"}
{"solution": "def billiard_table(n, m, x, y, vx, vy):\n    if vx == 0:\n        if vy > 0:\n            return n, y\n        else:\n            return 0, y\n    elif vy == 0:\n        if vx > 0:\n            return x, m\n        else:\n            return x, 0\n    elif vx == vy:\n        if vx > 0 and vy > 0:\n            return n, m\n        elif vx < 0 and vy < 0:\n            return 0, 0\n        elif vx > 0 and vy < 0:\n            return n, 0\n        else:\n            return 0, m\n    else:\n        return -1, -1\n\nn, m, x, y, vx, vy = map(int, input().split())\nresult = billiard_table(n, m, x, y, vx, vy)\nprint(*result)"}
{"solution": "def can_place_paintings(board_dimensions, painting_dimensions):\n    board_width, board_height = board_dimensions\n    painting_1_width, painting_1_height, painting_2_width, painting_2_height = painting_dimensions\n\n    # Try all possible orientations of the paintings\n    for _ in range(2):\n        for _ in range(2):\n            # Check if the paintings can be placed horizontally\n            if (painting_1_width + painting_2_width <= board_width and\n                max(painting_1_height, painting_2_height) <= board_height):\n                return True\n\n            # Check if the paintings can be placed vertically\n            if (max(painting_1_width, painting_2_width) <= board_width and\n                painting_1_height + painting_2_height <= board_height):\n                return True\n\n            # Rotate the second painting\n            painting_2_width, painting_2_height = painting_2_height, painting_2_width\n\n        # Rotate the first painting\n        painting_1_width, painting_1_height = painting_1_height, painting_1_width\n\n    return False\n\n# Read the input\nboard_dimensions = map(int, input().split())\npainting_dimensions = map(int, input().split() + input().split())\n\n# Check if the paintings can be placed on the board\nif can_place_paintings(board_dimensions, painting_dimensions):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def solve():\n    b1, q, l, m = map(int, input().split())\n    bad_numbers = set(map(int, input().split()))\n\n    if b1 == 0:\n        if 0 in bad_numbers:\n            print(0)\n        else:\n            print(1 if abs(b1) <= l else 0)\n        return\n\n    if q == 1:\n        print(1 if abs(b1) <= l and b1 not in bad_numbers else 0)\n        return\n\n    if q == -1:\n        if abs(b1) <= l and b1 not in bad_numbers:\n            print(2 if abs(b1) != l else 1)\n        else:\n            print(0)\n        return\n\n    if abs(q) > 1:\n        if abs(b1) > l or b1 in bad_numbers:\n            print(0)\n        else:\n            count = 1\n            while abs(b1) * abs(q) <= l and b1 * q not in bad_numbers:\n                b1 *= q\n                count += 1\n            print(count)\n    else:\n        if abs(b1) <= l and b1 not in bad_numbers:\n            print('inf')\n        else:\n            print(0)\n\nsolve()"}
{"solution": "def find_frame(grid):\n    n, m = len(grid), len(grid[0])\n    min_size = float('inf')\n    frame = None\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'w':\n                size = min(i, j, n - i - 1, m - j - 1)\n                if size < min_size:\n                    min_size = size\n                    frame = (i, j, size)\n\n    if frame is None:\n        return -1\n\n    i, j, size = frame\n    for k in range(j, j + size + 1):\n        grid[i][k] = '+'\n        grid[i + size][k] = '+'\n    for k in range(i, i + size + 1):\n        grid[k][j] = '+'\n        grid[k][j + size] = '+'\n\n    return '\\n'.join(''.join(row) for row in grid)\n\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\nprint(find_frame(grid))"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\n\nfor x in range(n // a + 1):\n    if (n - a * x) % b == 0:\n        y = (n - a * x) // b\n        print(\"YES\")\n        print(x, y)\n        break\nelse:\n    print(\"NO\")"}
{"solution": "# Define the number names\nnumbers = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\ntens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n# Get the input\ns = int(input())\n\n# If the number is less than 20, print the number name\nif s < 20:\n    print(numbers[s])\n# If the number is greater than or equal to 20, print the tens name and the ones name if necessary\nelse:\n    # Print the tens name\n    print(tens[s // 10], end=\"\")\n    # If the ones digit is not zero, print a hyphen and the ones name\n    if s % 10 != 0:\n        print(\"-\" + numbers[s % 10])"}
{"solution": "# Read the number of elements\nn = int(input())\n\n# Read the elements\na = list(map(int, input().split()))\n\n# Initialize the maximum number of consecutive elements that can be erased\nmax_erased = 0\n\n# Iterate over the elements\nfor i in range(1, n - 1):\n    # If the difference between the next and previous elements is greater than 2,\n    # then we can erase the current element\n    if a[i + 1] - a[i - 1] > 2:\n        max_erased = max(max_erased, 1)\n    # If the difference between the next and previous elements is exactly 2,\n    # then we can erase the current element and the next one\n    elif a[i + 1] - a[i - 1] == 2:\n        max_erased = max(max_erased, 2)\n\n# Print the maximum number of consecutive elements that can be erased\nprint(max_erased)"}
{"solution": "n = int(input())\nproblems = list(map(int, input().split()))\n\ntotal_problems = sum(problems)\nhalf_problems = total_problems // 2\nif total_problems % 2 == 0:\n    half_problems -= 1\n\nsolved_problems = 0\nfor i in range(n):\n    solved_problems += problems[i]\n    if solved_problems > half_problems:\n        print(i + 1)\n        break"}
{"solution": "import heapq\n\ndef bfs(board, start):\n    n = len(board)\n    q = [(0, 0, start, -1)]\n    visited = set([(start, -1)])\n    while q:\n        steps, replacements, (x, y), piece = heapq.heappop(q)\n        if board[x][y] == n*n:\n            return steps, replacements\n        for dx, dy, new_piece in [(2, 1, 0), (1, 2, 0), (-2, 1, 0), (-1, 2, 0), (2, -1, 0), (1, -2, 0), (-2, -1, 0), (-1, -2, 0), (1, 1, 1), (1, -1, 1), (-1, 1, 1), (-1, -1, 1), (1, 0, 2), (0, 1, 2), (-1, 0, 2), (0, -1, 2)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < n and (nx, ny) != (x, y):\n                if (nx, ny, new_piece) not in visited:\n                    visited.add((nx, ny, new_piece))\n                    new_steps = steps + 1\n                    new_replacements = replacements + (1 if new_piece != piece else 0)\n                    heapq.heappush(q, (new_steps, new_replacements, (nx, ny), new_piece))\n\nn = int(input())\nboard = [list(map(int, input().split())) for _ in range(n)]\nstart = None\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 1:\n            start = (i, j)\n            break\n    if start:\n        break\nsteps, replacements = bfs(board, start)\nprint(steps, replacements)"}
{"solution": "def min_time(n, m, k, a, b):\n    # Calculate the apartment numbers for the first and last apartments in each entrance\n    first_apts = [i*m*k + 1 for i in range(n)]\n    last_apts = [(i+1)*m*k for i in range(n)]\n\n    # Calculate the time it takes to go from apartment a to apartment b in the same entrance\n    same_entrance_time = abs((a-1)//(m*k) - (b-1)//(m*k)) * 15 + abs((a-1)%m - (b-1)%m) * 5\n\n    # Calculate the time it takes to go from apartment a to apartment b in the shortest direction\n    shortest_direction_time = min(abs(a-b), abs(n*m*k - abs(a-b))) * 5\n\n    # Calculate the time it takes to go from apartment a to apartment b using the lift\n    lift_time = 10 + abs((a-1)%m - (b-1)%m)\n\n    # Return the minimum time\n    return min(same_entrance_time, shortest_direction_time, lift_time)\n\n# Read the input\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Print the output\nprint(min_time(n, m, k, a, b))"}
{"solution": "def divisible_by_64(s):\n    # Count the number of zeros\n    count_zeros = s.count('0')\n\n    # If there are less than 6 zeros, it's impossible to get a number divisible by 64\n    if count_zeros < 6:\n        return 'no'\n\n    # Count the number of ones\n    count_ones = s.count('1')\n\n    # If there are no ones, it's impossible to get a number divisible by 64\n    if count_ones == 0:\n        return 'no'\n\n    # Find the index of the last '1'\n    last_one_index = s.rfind('1')\n\n    # Count the number of zeros after the last '1'\n    count_zeros_after_last_one = s[last_one_index:].count('0')\n\n    # If there are at least 6 zeros after the last '1', it's possible to get a number divisible by 64\n    if count_zeros_after_last_one >= 6:\n        return 'yes'\n    else:\n        return 'no'\n\n# Read the input\ns = input()\n\n# Print the result\nprint(divisible_by_64(s))"}
{"solution": "def solve(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    i = 0\n    for char in s:\n        if char == alphabet[i]:\n            i += 1\n        elif char < alphabet[i]:\n            s = s.replace(char, alphabet[i])\n            i += 1\n        if i == 26:\n            break\n    return s if i == 26 else '-1'\n\ns = input()\nprint(solve(s))"}
{"solution": "def calculate_max_expected_fish(n, m, r, k):\n    total_cells = n * m\n    total_scoop_positions = (n - r + 1) * (m - r + 1)\n    max_fish_in_scoop = r * r\n\n    if k >= max_fish_in_scoop:\n        return max_fish_in_scoop\n\n    probability_of_catch = k / total_cells\n    expected_fish_per_scoop = probability_of_catch * max_fish_in_scoop\n    max_expected_fish = expected_fish_per_scoop * total_scoop_positions\n\n    return max_expected_fish\n\nn, m, r, k = map(int, input().split())\nprint(calculate_max_expected_fish(n, m, r, k))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Count the number of negative numbers\nneg_count = sum(1 for num in a if num < 0)\n\n# If the number of negative numbers is odd, we need to find the smallest number\n# and transform it to make the product maximum\nif neg_count % 2 != 0:\n    min_num = min(a)\n    min_index = a.index(min_num)\n    a[min_index] = -min_num - 1\n\n# Transform all the numbers to their maximum possible value\nfor i in range(n):\n    a[i] = -abs(a[i]) - 1\n\nprint(*a)"}
{"solution": "import math\n\ndef find_kth_divisor(n, k):\n    divisors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        if len(divisors) >= k:\n            return sorted(list(divisors))[k - 1]\n    if len(divisors) < k:\n        return -1\n\nn, k = map(int, input().split())\nprint(find_kth_divisor(n, k))"}
{"solution": "def dfs(num, used, cubes, limit):\n    if num > limit:\n        return False\n    if all(used):\n        return True\n    for i in range(len(cubes)):\n        if not used[i]:\n            for j in range(6):\n                if num == 0 and cubes[i][j] == 0:\n                    continue\n                if dfs(num * 10 + cubes[i][j], used[:i] + [True] + used[i+1:], cubes, limit):\n                    return True\n    return False\n\ndef solve(cubes):\n    limit = 10000\n    for i in range(1, limit + 1):\n        if not dfs(i, [False] * len(cubes), cubes, limit):\n            return i - 1\n    return limit\n\nn = int(input())\ncubes = [list(map(int, input().split())) for _ in range(n)]\nprint(solve(cubes))"}
{"solution": "def k_rounding(n, k):\n    # Calculate the multiplier needed to reach the k-rounding\n    multiplier = 10 ** k\n    # Calculate the k-rounding\n    k_rounded = (n + multiplier - 1) // multiplier * multiplier\n    return k_rounded\n\n# Get the input\nn, k = map(int, input().split())\n# Print the k-rounding of n\nprint(k_rounding(n, k))"}
{"solution": "def solve(n, m, A):\n    B = [[0] * m for _ in range(n)]\n    operations = []\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] != B[i][j]:\n                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1\n                operations.append((i + 1, j + 1))\n\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] != B[i][j]:\n                return -1\n\n    return operations\n\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\nresult = solve(n, m, A)\n\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for op in result:\n        print(*op)"}
{"solution": "import sys\n\ndef calculate_probabilities(r, s, p):\n    total = r + s + p\n    dp = [[[0.0 for _ in range(p+1)] for _ in range(s+1)] for _ in range(r+1)]\n    dp[r][s][p] = 1.0\n\n    for t in range(total-1, 0, -1):\n        for i in range(r+1):\n            for j in range(s+1):\n                for k in range(p+1):\n                    if i > 0 and j > 0:\n                        dp[i][j-1][k] += dp[i][j][k] * i * j / t\n                        dp[i][j][k] -= dp[i][j][k] * i * j / t\n                    if j > 0 and k > 0:\n                        dp[i][j][k-1] += dp[i][j][k] * j * k / t\n                        dp[i][j][k] -= dp[i][j][k] * j * k / t\n                    if k > 0 and i > 0:\n                        dp[i-1][j][k] += dp[i][j][k] * k * i / t\n                        dp[i][j][k] -= dp[i][j][k] * k * i / t\n\n    prob_r = sum(dp[i][0][0] for i in range(1, r+1))\n    prob_s = sum(dp[0][j][0] for j in range(1, s+1))\n    prob_p = sum(dp[0][0][k] for k in range(1, p+1))\n\n    return prob_r, prob_s, prob_p\n\nif __name__ == \"__main__\":\n    r, s, p = map(int, sys.stdin.readline().split())\n    prob_r, prob_s, prob_p = calculate_probabilities(r, s, p)\n    print(f\"{prob_r:.10f} {prob_s:.10f} {prob_p:.10f}\")"}
{"solution": "# Get the input\nl_1, r_1, l_2, r_2, k = map(int, input().split())\n\n# Calculate the overlapping time\noverlap = min(r_1, r_2) - max(l_1, l_2)\n\n# Check if Sonya is prinking during the overlapping time\nif k >= max(l_1, l_2) and k <= min(r_1, r_2):\n    # If Sonya is prinking, subtract 1 minute from the overlapping time\n    overlap -= 1\n\n# Make sure the overlapping time is not negative\noverlap = max(0, overlap)\n\n# Print the result\nprint(overlap)"}
{"solution": "import sys\nfrom bisect import bisect_left as left, bisect_right as right\n\ndef main():\n    input = sys.stdin.readline\n\n    n, m = map(int, input().split())\n\n    horizontal_lines = []\n    vertical_lines = []\n\n    for _ in range(n):\n        a, b, c = map(int, input().split())\n        horizontal_lines.append((c, a, b))\n\n    for _ in range(m):\n        d, e, f = map(int, input().split())\n        vertical_lines.append((d, e, f))\n\n    horizontal_lines.sort()\n    vertical_lines.sort()\n\n    horizontal_positions = [0]\n    vertical_positions = [0]\n\n    for _, a, b in horizontal_lines:\n        horizontal_positions.append(a)\n        horizontal_positions.append(b)\n\n    for _, e, f in vertical_lines:\n        vertical_positions.append(e)\n        vertical_positions.append(f)\n\n    horizontal_positions = sorted(set(horizontal_positions))\n    vertical_positions = sorted(set(vertical_positions))\n\n    horizontal_lengths = [0] * (len(horizontal_positions) - 1)\n    vertical_lengths = [0] * (len(vertical_positions) - 1)\n\n    for c, a, b in horizontal_lines:\n        i = left(horizontal_positions, a)\n        j = right(horizontal_positions, b)\n        horizontal_lengths[i] = max(horizontal_lengths[i], c)\n        horizontal_lengths[j - 1] = max(horizontal_lengths[j - 1], c)\n\n    for d, e, f in vertical_lines:\n        i = left(vertical_positions, e)\n        j = right(vertical_positions, f)\n        vertical_lengths[i] = max(vertical_lengths[i], d)\n        vertical_lengths[j - 1] = max(vertical_lengths[j - 1], d)\n\n    for i in range(1, len(horizontal_lengths)):\n        horizontal_lengths[i] = max(horizontal_lengths[i], horizontal_lengths[i - 1])\n\n    for i in range(1, len(vertical_lengths)):\n        vertical_lengths[i] = max(vertical_lengths[i], vertical_lengths[i - 1])\n\n    total_area = 0\n    for i in range(len(horizontal_positions) - 1):\n        for j in range(len(vertical_positions) - 1):\n            if horizontal_lengths[i] < vertical_lengths[j]:\n                total_area += (horizontal_positions[i + 1] - horizontal_positions[i]) * (vertical_positions[j + 1] - vertical_positions[j])\n\n    print(total_area)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input\nt, s, x = map(int, input().split())\n\n# Calculate the first barking time after x\nfirst_bark_after_x = t + s * ((x - t) // s)\n\n# Check if the pineapple barks at time x\nif x == first_bark_after_x or x == first_bark_after_x + 1:\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "n = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r, i+1))\nsegments.sort()\n\nfor i in range(n-1):\n    if segments[i][1] >= segments[i+1][1]:\n        print(segments[i+1][2], segments[i][2])\n        exit()\nprint(-1, -1)"}
{"solution": "n = int(input())\ns = list(input())\n\ncounts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\nfor nucleotide in s:\n    if nucleotide != '?':\n        counts[nucleotide] += 1\n\nif n % 4 != 0 or max(counts.values()) > n // 4:\n    print(\"===\")\nelse:\n    for i in range(n):\n        if s[i] == '?':\n            for nucleotide in 'ACGT':\n                if counts[nucleotide] < n // 4:\n                    s[i] = nucleotide\n                    counts[nucleotide] += 1\n                    break\n    print(''.join(s))"}
{"solution": "def check_win(board):\n    for i in range(4):\n        if board[i][0] == board[i][1] == board[i][2] == 'x' or board[i][1] == board[i][2] == board[i][3] == 'x':\n            return True\n        if board[0][i] == board[1][i] == board[2][i] == 'x' or board[1][i] == board[2][i] == board[3][i] == 'x':\n            return True\n    if board[0][0] == board[1][1] == board[2][2] == 'x' or board[1][1] == board[2][2] == board[3][3] == 'x':\n        return True\n    if board[0][3] == board[1][2] == board[2][1] == 'x' or board[1][2] == board[2][1] == board[3][0] == 'x':\n        return True\n    return False\n\ndef can_win(board):\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                board[i][j] = 'x'\n                if check_win(board):\n                    return True\n                board[i][j] = '.'\n    return False\n\nboard = [input() for _ in range(4)]\nprint('YES' if can_win(board) else 'NO')"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nprefix_sum = 0\n\nfor i in range(n):\n    if prefix_sum == total_sum - prefix_sum - a[i]:\n        print('YES')\n        exit()\n    prefix_sum += a[i]\n\nprint('NO')"}
{"solution": "def solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    b.sort()\n    zero_indices = [i for i, x in enumerate(a) if x == 0]\n\n    for i, idx in enumerate(zero_indices):\n        a[idx] = b[k - i - 1]\n\n    for i in range(1, n):\n        if a[i] >= a[i - 1]:\n            return \"No\"\n\n    return \"Yes\"\n\nprint(solve())"}
{"solution": "# Get the input\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Check if Andrew can eat enough green grapes\nif x > a:\n    print(\"NO\")\nelse:\n    # Calculate the remaining green grapes after Andrew eats\n    remaining_green = a - x\n\n    # Check if Dmitry can eat enough non-black grapes\n    if y > remaining_green + b:\n        print(\"NO\")\n    else:\n        # Calculate the remaining non-black grapes after Dmitry eats\n        remaining_non_black = remaining_green + b - y\n\n        # Check if Michal can eat enough remaining grapes\n        if z > remaining_non_black + c:\n            print(\"NO\")\n        else:\n            print(\"YES\")"}
{"solution": "# Read the input\ntraffic_lights = [list(map(int, input().split())) for _ in range(4)]\n\n# Check for accidents\nfor i in range(4):\n    for j in range(3):\n        # If a pedestrian light and a car light are both green\n        if traffic_lights[i][3] == 1 and traffic_lights[i][j] == 1:\n            print(\"YES\")\n            exit(0)\n\n# If no accidents are possible\nprint(\"NO\")"}
{"solution": "# Define the finger movements for each digit\nfinger_movements = {\n    '1': '',\n    '2': 'AB',\n    '3': 'CD',\n    '4': 'AE',\n    '5': 'BF',\n    '6': 'CG',\n    '7': 'DE',\n    '8': 'FG',\n    '9': 'EH',\n    '0': 'DH'\n}\n\n# Get the input\nn = int(input())\nnumber = input()\n\n# Convert the number into finger movements\nmovements = ''.join(finger_movements[digit] for digit in number)\n\n# Check if there is any other number with the same finger movements\nif movements.count('A') > 1 or movements.count('B') > 2 or movements.count('C') > 2 or movements.count('D') > 2 or movements.count('E') > 2 or movements.count('F') > 1 or movements.count('G') > 1 or movements.count('H') > 1:\n    print('NO')\nelse:\n    print('YES')"}
{"solution": "import heapq\n\ndef max_sold_products(n, f, k, l):\n    # Create a list of tuples, each containing the difference in sales and the number of products\n    diff_sales = [(l[i] - k[i], k[i]) for i in range(n)]\n    # Sort the list in descending order based on the difference in sales\n    diff_sales.sort(reverse=True)\n\n    # Create a max heap to store the number of products\n    max_heap = []\n    total_sold = 0\n\n    # Iterate over the first f days\n    for i in range(f):\n        # Double the number of products for the day\n        products = diff_sales[i][1] * 2\n        # Add the number of products to the max heap\n        heapq.heappush(max_heap, products)\n        # Add the number of products that can be sold to the total\n        total_sold += min(products, l[i])\n\n    # Iterate over the remaining days\n    for i in range(f, n):\n        # If the number of products that can be sold on the day is less than the smallest number of products in the max heap\n        if l[i] < max_heap[0]:\n            # Remove the smallest number of products from the max heap\n            heapq.heappop(max_heap)\n            # Add the number of products that can be sold to the total\n            total_sold += min(diff_sales[i][1], l[i])\n            # Add the number of products to the max heap\n            heapq.heappush(max_heap, diff_sales[i][1])\n        else:\n            # Add the number of products that can be sold to the total\n            total_sold += l[i]\n\n    return total_sold\n\n# Read the input\nn, f = map(int, input().split())\nk = []\nl = []\nfor i in range(n):\n    ki, li = map(int, input().split())\n    k.append(ki)\n    l.append(li)\n\n# Print the output\nprint(max_sold_products(n, f, k, l))"}
{"solution": "# Read input\nn, k = map(int, input().split())\n\n# Calculate maximum messiness\nmax_messiness = 0\nfor i in range(1, min(k, n) + 1):\n    # Swap the cows in the first and last stalls\n    # The cow in the first stall moves to the last stall\n    # The cow in the last stall moves to the first stall\n    # All other cows remain in their stalls\n\n    # The number of cows that move to a stall with a smaller index\n    # is equal to the number of swaps performed\n    cows_to_smaller_index = i\n\n    # The number of cows that move to a stall with a larger index\n    # is equal to the number of cows that initially were not in the first or last stall\n    cows_to_larger_index = n - i\n\n    # The number of pairs (i, j) such that i < j and p_i > p_j\n    # is equal to the number of cows that move to a smaller index\n    # multiplied by the number of cows that move to a larger index\n    messiness = cows_to_smaller_index * cows_to_larger_index\n\n    # Add the messiness to the total\n    max_messiness += messiness\n\n# Print the maximum messiness\nprint(max_messiness)"}
{"solution": "# Get the input\nn, m, k, l = map(int, input().split())\n\n# Calculate the number of coins each friend needs to gift\ncoins_per_friend = (k + l) // m\n\n# Check if it's possible to meet all the terms\nif coins_per_friend > n or coins_per_friend * m < k + l:\n    print(-1)\nelse:\n    print(coins_per_friend)"}
{"solution": "n, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\ndef count_black(i, j, k):\n    count = 0\n    for x in range(i, i + k):\n        for y in range(j, j + k):\n            if grid[x][y] == 'W':\n                count += 1\n    return count\n\nmin_paint = float('inf')\nfor k in range(1, min(n, m) + 1):\n    for i in range(n - k + 1):\n        for j in range(m - k + 1):\n            min_paint = min(min_paint, count_black(i, j, k))\n\nprint(min_paint if min_paint != float('inf') else -1)"}
{"solution": "# Read the number of piles\nn = int(input())\n\n# Read the initial number of stones in each pile\nx = list(map(int, input().split()))\n\n# Read the final number of stones in each pile\ny = list(map(int, input().split()))\n\n# Calculate the difference between the initial and final number of stones\ndiff = [y[i] - x[i] for i in range(n)]\n\n# Calculate the total difference\ntotal_diff = sum(diff)\n\n# If the total difference is not zero, it's impossible to convert the first array into the second array\nif total_diff != 0:\n    print(\"No\")\nelse:\n    # If the total difference is zero, check if it's possible to move stones between piles\n    # to convert the first array into the second array\n    possible = True\n    for i in range(n):\n        if diff[i] < 0:\n            # If the difference is negative, we need to move stones from other piles to this pile\n            for j in range(n):\n                if i != j and diff[j] > 0:\n                    # Move stones from pile j to pile i\n                    move = min(diff[i], diff[j])\n                    diff[i] += move\n                    diff[j] -= move\n        if diff[i] != 0:\n            # If the difference is not zero, it's impossible to convert the first array into the second array\n            possible = False\n            break\n    if possible:\n        print(\"Yes\")\n    else:\n        print(\"No\")"}
{"solution": "n = int(input())\nangles = list(map(int, input().split()))\n\ntotal_sum = sum(angles)\nmin_diff = total_sum\ncurrent_sum = 0\n\nfor i in range(n):\n    current_sum += angles[i]\n    if abs(total_sum - 2 * current_sum) < min_diff:\n        min_diff = abs(total_sum - 2 * current_sum)\n\nprint(min_diff)"}
{"solution": "MOD = 10**9 + 7\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef findWays(n, m):\n    return power(2, n * m, MOD) - 1\n\nn, m = map(int, input().split())\nprint(findWays(n, m))"}
{"solution": "import math\n\ndef find_pythagorean_triple(n):\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            j = n // i\n            if (i % 2 == 0 and j % 2 == 1) or (i % 2 == 1 and j % 2 == 0):\n                if i < j:\n                    return i, j\n    return -1\n\nn = int(input())\nresult = find_pythagorean_triple(n)\nif result == -1:\n    print(-1)\nelse:\n    m, k = result\n    if n == m:\n        m, k = k, m\n    if n ** 2 == m ** 2 + k ** 2:\n        print(m, k)\n    else:\n        print(-1)"}
{"solution": "n, k = map(int, input().split())\nremainders = set()\n\nfor i in range(1, k + 1):\n    remainder = n % i\n    if remainder in remainders:\n        print(\"No\")\n        break\n    remainders.add(remainder)\nelse:\n    print(\"Yes\")"}
{"solution": "# Read the input\na = raw_input().strip('0')\nb = raw_input().strip('0')\n\n# Compare the lengths of the numbers\nif len(a) < len(b):\n    print('<')\nelif len(a) > len(b):\n    print('>')\nelse:\n    # Compare the numbers digit by digit\n    for i in range(len(a)):\n        if a[i] < b[i]:\n            print('<')\n            break\n        elif a[i] > b[i]:\n            print('>')\n            break\n    else:\n        print('=')"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, p, colors):\n    dp = [[0, 0] for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if colors[j] != -1:\n                if colors[j] == 0:\n                    dp[i][0] = (dp[i][0] + dp[j][1]) % MOD\n                else:\n                    dp[i][1] = (dp[i][1] + dp[j][0]) % MOD\n            else:\n                dp[i][0] = (dp[i][0] + dp[j][1]) % MOD\n                dp[i][1] = (dp[i][1] + dp[j][0]) % MOD\n\n    return dp[n][p]\n\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\nprint(solve(n, p, colors))"}
{"solution": "def min_cost(n, a, b, c):\n    # Calculate the number of copybooks Alyona needs to buy\n    k = (4 - n % 4) % 4\n\n    # Calculate the cost of buying k copybooks\n    cost = 0\n    if k > 0:\n        # Calculate the cost of buying k copybooks using the cheapest pack\n        pack_costs = sorted([a, b/2, c/3])\n        while k > 0:\n            if k >= 3:\n                cost += pack_costs[0] * 3\n                k -= 3\n            elif k == 2:\n                cost += pack_costs[1] * 2\n                k -= 2\n            else:\n                cost += pack_costs[0]\n                k -= 1\n\n    return int(cost)\n\n# Read the input\nn, a, b, c = map(int, input().split())\n\n# Print the minimum amount of rubles Alyona should pay\nprint(min_cost(n, a, b, c))"}
{"solution": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    graph = defaultdict(list)\n    reverse_graph = defaultdict(list)\n    in_degree = [0] * n\n\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        reverse_graph[v].append(u)\n        in_degree[v] += 1\n\n    def kosaraju(graph):\n        visited = [False] * n\n        stack = []\n\n        def dfs(node):\n            visited[node] = True\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    dfs(neighbor)\n            stack.append(node)\n\n        for node in range(n):\n            if not visited[node]:\n                dfs(node)\n\n        components = []\n\n        def reverse_dfs(node, component):\n            visited[node] = True\n            component.append(node)\n            for neighbor in reverse_graph[node]:\n                if not visited[neighbor]:\n                    reverse_dfs(neighbor, component)\n\n        visited = [False] * n\n        while stack:\n            node = stack.pop()\n            if not visited[node]:\n                component = []\n                reverse_dfs(node, component)\n                components.append(component)\n\n        return components\n\n    components = kosaraju(graph)\n    if len(components) != n:\n        return \"NO\"\n\n    for component in components:\n        if len(component) > 1:\n            continue\n        node = component[0]\n        if in_degree[node] <= 1:\n            return \"YES\"\n\n    return \"NO\"\n\nprint(solve())"}
{"solution": "import sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    antennas = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    antennas.sort()\n\n    dp = [0] + [float('inf')] * m\n    for x, s in antennas:\n        for i in range(max(1, x - s), x + s + 1):\n            dp[i] = min(dp[i], dp[max(1, i - s - 1)] + abs(i - x))\n\n    print(dp[m])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Read the input\nW = int(input())\nitems = list(map(int, input().split()))\n\n# Initialize the total weight of the good subset\ntotal_weight = 0\n\n# Iterate over the items in reverse order (from 8 to 1)\nfor i in range(8, 0, -1):\n    # If the total weight plus the weight of the current item does not exceed W\n    if total_weight + i * items[i - 1] <= W:\n        # Add the weight of all the current items to the total weight\n        total_weight += i * items[i - 1]\n    else:\n        # Otherwise, add as many items as possible to reach W\n        total_weight += (W // i) * i\n        break\n\n# Print the maximum possible weight of a good subset of items\nprint(total_weight)"}
{"solution": "# Read input\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Initialize minimum cost to a large number\nmin_cost = float('inf')\n\n# Iterate over all possible combinations of bottles\nfor i in range(1 << n):\n    total_cost = 0\n    total_volume = 0\n    # Iterate over each bottle type\n    for j in range(n):\n        # If the j-th bottle is included in the combination\n        if i & (1 << j):\n            total_cost += costs[j]\n            total_volume += (1 << j) - 1\n    # If the total volume is enough and the total cost is less than the current minimum cost\n    if total_volume >= L and total_cost < min_cost:\n        min_cost = total_cost\n\n# Print the minimum cost\nprint(min_cost)"}
{"solution": "# Read the number of elements\nn = int(input())\n\n# Read the elements of the array\narr = list(map(int, input().split()))\n\n# Sort the array\narr.sort()\n\n# Initialize the mex value\nmex = 1\n\n# Iterate over the sorted array\nfor i in range(n):\n    # If the current element is equal to mex, increment mex\n    if arr[i] == mex:\n        mex += 1\n\n# Print the maximum possible value of mex\nprint(mex)"}
{"solution": "# Get the number of digits in the ticket\nn = int(input())\n\n# Get the golden ticket as a string\nticket = input()\n\n# Convert the string to a list of integers\ndigits = [int(d) for d in ticket]\n\n# Calculate the total sum of the digits\ntotal_sum = sum(digits)\n\n# If the total sum is odd, the ticket cannot be divided into segments with equal sums\nif total_sum % 2 != 0:\n    print(\"NO\")\nelse:\n    # Calculate the target sum for each segment\n    target_sum = total_sum // 2\n\n    # Initialize the current sum and the number of segments\n    current_sum = 0\n    num_segments = 0\n\n    # Iterate over the digits in the ticket\n    for digit in digits:\n        # Add the digit to the current sum\n        current_sum += digit\n\n        # If the current sum is equal to the target sum, reset the current sum and increment the number of segments\n        if current_sum == target_sum:\n            current_sum = 0\n            num_segments += 1\n\n    # If the current sum is zero and the number of segments is greater than one, the ticket is lucky\n    if current_sum == 0 and num_segments > 1:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "# Get the user name\nuser_name = input()\n\n# Count the number of distinct characters\ndistinct_chars = len(set(user_name))\n\n# Check if the number of distinct characters is odd\nif distinct_chars % 2 != 0:\n    print(\"IGNORE HIM!\")\nelse:\n    print(\"CHAT WITH HER!\")"}
{"solution": "n, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\nmax_diff = 0\nfor b in range(1, n + 1):\n    closed_tabs = [i for i in range(b, n + 1, k)]\n    remaining_tabs = [tab for i, tab in enumerate(tabs, start=1) if i not in closed_tabs]\n    e = remaining_tabs.count(1)\n    s = remaining_tabs.count(-1)\n    max_diff = max(max_diff, abs(e - s))\n\nprint(max_diff)"}
{"solution": "# Get the input\nn, c0, c1 = map(int, input().split())\n\n# Calculate the minimum cost\nif c0 <= c1:\n    # If the cost of '0' is less than or equal to the cost of '1',\n    # then the optimal encoding is to use '0' as the first bit of all letters.\n    # The second bit of the first letter is '0', the second bit of the second letter is '1',\n    # the third bit of the third letter is '0', the fourth bit of the fourth letter is '1', and so on.\n    cost = c0 * n\n    for i in range(2, n.bit_length()):\n        cost += c1 * (n // 2**i)\nelse:\n    # If the cost of '0' is greater than the cost of '1',\n    # then the optimal encoding is to use the Huffman coding.\n    # The first letter is encoded as '1', the second letter is encoded as '01',\n    # the third letter is encoded as '001', the fourth letter is encoded as '0001', and so on.\n    cost = c1 * n\n    for i in range(1, n.bit_length()):\n        cost += c0 * (n - 2**i)\n\n# Print the minimum cost\nprint(cost)"}
{"solution": "n, a, x, b, y = map(int, input().split())\n\ndaniel_stations = [a]\nvlad_stations = [b]\n\nwhile daniel_stations[-1] != x:\n    daniel_stations.append((daniel_stations[-1] % n) + 1)\n\nwhile vlad_stations[-1] != y:\n    vlad_stations.append((vlad_stations[-1] - 2) % n + 1)\n\nif set(daniel_stations) & set(vlad_stations):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def unlucky_years(x, y, l, r):\n    unlucky = set()\n    a, b = 0, 0\n    while x**a <= r:\n        while y**b <= r:\n            if l <= x**a + y**b <= r:\n                unlucky.add(x**a + y**b)\n            b += 1\n        a += 1\n        b = 0\n\n    max_length = 0\n    prev = l - 1\n    for year in sorted(unlucky):\n        max_length = max(max_length, year - prev - 1)\n        prev = year\n    max_length = max(max_length, r - prev)\n\n    return max_length\n\nx, y, l, r = map(int, input().split())\nprint(unlucky_years(x, y, l, r))"}
{"solution": "def max_divisor(n):\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1\n\ndef min_tax(n):\n    if n == 2:\n        return 1\n    if n % 2 == 1:\n        return 1 + max_divisor(n - 1)\n    else:\n        return 2 + max_divisor(n // 2)\n\nn = int(input())\nprint(min_tax(n))"}
{"solution": "def check_consonants(word):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    prev_consonant = None\n\n    for char in word:\n        if char not in vowels:\n            if char == prev_consonant:\n                count = 0\n            else:\n                count += 1\n                if count == 3:\n                    return True\n            prev_consonant = char\n        else:\n            count = 0\n            prev_consonant = None\n\n    return False\n\ndef split_word(word):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    result = []\n    start = 0\n\n    for i in range(len(word)):\n        if i - start > 1 and word[i] not in vowels and word[i - 1] not in vowels and word[i - 2] not in vowels and word[i - 1] != word[i - 2]:\n            result.append(word[start:i - 1])\n            start = i - 1\n\n    result.append(word[start:])\n    return ' '.join(result)\n\nword = input()\nif check_consonants(word):\n    print(split_word(word))\nelse:\n    print(word)"}
{"solution": "import sys\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    x, s = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n    c = list(map(int, sys.stdin.readline().split()))\n    d = list(map(int, sys.stdin.readline().split()))\n\n    min_time = n * x\n\n    for i in range(m):\n        if b[i] <= s:\n            min_time = min(min_time, (n - c[-1]) * a[i] if n > c[-1] else 0)\n\n    for i in range(k):\n        if d[i] <= s:\n            min_time = min(min_time, (n - c[i]) * x + c[i] * (x - a[0]) if n > c[i] and b[0] > d[i] else c[i] * x)\n\n    min_time = min(min_time, n * x - n * (x - a[0]) if b[0] <= s else min_time)\n    min_time = min(min_time, c[-1] * x if d[-1] <= s else min_time)\n\n    print(min_time)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Sort the subtasks in ascending order of time required\nt.sort()\n\n# Initialize the maximum number of points\nmax_points = 0\n\n# Iterate over all possible number of tasks that can be completed\nfor i in range(min(n, M // sum(t)) + 1):\n    # Calculate the remaining time\n    remaining_time = M - i * sum(t)\n\n    # Calculate the number of subtasks that can be solved in the remaining time\n    j = 0\n    while j < k and remaining_time >= t[j]:\n        remaining_time -= t[j]\n        j += 1\n\n    # Calculate the total number of points\n    points = i * (k + 1) + j\n\n    # Update the maximum number of points\n    max_points = max(max_points, points)\n\n# Print the maximum number of points\nprint(max_points)"}
{"solution": "MODULO = 998244353\n\n# Get the input value for the number of vertices\nnumber_of_elements = int(input())\n\n# Initialize a list to store the number of trees for each possible number of vertices\ndynamic_programming_list = [0] * (number_of_elements + 1)\n\n# Set the base case for a single vertex\ndynamic_programming_list[1] = 1\n\n# Calculate the number of trees for each possible number of vertices using dynamic programming\nfor current_index in range(2, number_of_elements + 1):\n    # If the current index is odd, the number of trees is equal to the number of trees with one less vertex\n    if current_index % 2 == 1:\n        dynamic_programming_list[current_index] = dynamic_programming_list[current_index - 1]\n    else:\n        # If the current index is even, the number of trees is equal to the sum of the number of trees with i-1 vertices and the number of trees with current_index - i vertices, for all possible values of i\n        dynamic_programming_list[current_index] = sum(dynamic_programming_list[i - 1] * dynamic_programming_list[current_index - i] for i in range(1, current_index // 2 + 1)) % MODULO\n\n# Print the result for the given input n, modulo 998244353\nprint(dynamic_programming_list[number_of_elements])"}
{"solution": "def find_position(n, m, k):\n    # Lara moves down first\n    if k < n:\n        return k + 1, 1\n    k -= n\n\n    # Then she moves in a snake fashion\n    while k >= 2 * (m - 1):\n        k -= 2 * (m - 1)\n        n -= 1\n\n    # Now find the position in the snake pattern\n    if k < m - 1:\n        return n, k + 1\n    else:\n        return n - (k - (m - 1)), m\n\nn, m, k = map(int, input().split())\nrow, col = find_position(n, m, k)\nprint(row, col)"}
{"solution": "import math\n\ndef find_min_max_pair(X):\n    # If X is 1, the minimum possible value of max(a, b) is 1, and a = b = 1\n    if X == 1:\n        return 1, 1\n\n    # Initialize a and b as the square root of X and X divided by the square root of X respectively\n    a = int(math.sqrt(X))\n    b = X // a\n\n    # If a divides X, then a and b are the same, so we need to find the next smallest pair\n    while X % a == 0:\n        a -= 1\n        b = X // a\n\n    return a, b\n\n# Get the input\nX = int(input())\n\n# Find the pair\na, b = find_min_max_pair(X)\n\n# Print the output\nprint(a, b)"}
{"solution": "# Get the input\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate the maximum number of lemons that can be used\nlemons = min(a, b // 2, c // 4)\n\n# Calculate the maximum total number of fruits that can be used\ntotal_fruits = lemons * (1 + 2 + 4)\n\n# Print the result\nprint(total_fruits)"}
{"solution": "# Read the number of players\nn = int(input())\n\n# Read the ratings of players\nratings = list(map(int, input().split()))\n\n# Sort the ratings\nratings.sort()\n\n# Check if it's possible to divide the players\nif ratings[n] > ratings[n - 1]:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\ndef make_coprime(n, arr):\n    moves = 0\n    new_arr = []\n    for i in range(n):\n        new_arr.append(arr[i])\n        if i < n - 1:\n            if math.gcd(arr[i], arr[i + 1]) != 1:\n                new_arr.append(2)\n                moves += 1\n    return moves, new_arr\n\nn = int(input())\narr = list(map(int, input().split()))\nmoves, new_arr = make_coprime(n, arr)\nprint(moves)\nprint(' '.join(map(str, new_arr)))"}
{"solution": "import sys\nfrom math import gcd\nfrom functools import reduce\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Calculate the total sum of the array\n    total_sum = sum(a)\n\n    # Calculate the greatest common divisor of the total sum and k\n    g = gcd(total_sum, k)\n\n    # Calculate the minimum value in the array\n    min_val = min(a)\n\n    # Calculate the maximum possible positive integer that divides every element of A\n    result = min(min_val, g)\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def cat_furrier_transform(x):\n    operations = []\n    for _ in range(20):\n        n = x.bit_length()\n        x = x ^ ((1 << n) - 1)\n        operations.append(n)\n        x += 1\n    return operations\n\nx = int(input())\noperations = cat_furrier_transform(x)\nprint(len(operations))\nprint(' '.join(map(str, operations)))"}
{"solution": "# Read input\nn, k = map(int, input().split())\nbuckets = list(map(int, input().split()))\n\n# Initialize minimum hours to a large number\nmin_hours = float('inf')\n\n# Iterate over each bucket\nfor bucket in buckets:\n    # Calculate hours required to water the garden using this bucket\n    hours = k // bucket\n    if k % bucket != 0:\n        hours += 1\n    # Update minimum hours\n    min_hours = min(min_hours, hours)\n\n# Print minimum hours\nprint(min_hours)"}
{"solution": "n, k = map(int, input().split())\nline = input()\n\ngrasshopper_pos = line.index('G')\ninsect_pos = line.index('T')\n\nif (grasshopper_pos - insect_pos) % k == 0 and all(line[i] != '#' for i in range(min(grasshopper_pos, insect_pos), max(grasshopper_pos, insect_pos), k)):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def calculate_intersection():\n    y1, y2, yw, xb, yb, r = map(int, input().split())\n\n    # Calculate the slope of the line from the ball to the wall\n    m = (yw - yb) / xb\n\n    # Calculate the y-intercept of the line from the ball to the wall\n    b = yb - m * xb\n\n    # Calculate the discriminant of the quadratic equation\n    D = (2 * m * b - 2 * y1 + y2 - yw) ** 2 - 4 * (m ** 2 + 1) * (b ** 2 - 2 * b * y1 + y1 ** 2 - r ** 2)\n\n    # If the discriminant is negative, there is no solution\n    if D < 0:\n        return -1\n\n    # Calculate the x-coordinate of the intersection point\n    x1 = (-(2 * m * b - 2 * y1 + y2 - yw) + D ** 0.5) / (2 * (m ** 2 + 1))\n    x2 = (-(2 * m * b - 2 * y1 + y2 - yw) - D ** 0.5) / (2 * (m ** 2 + 1))\n\n    # If both intersection points are outside the goal, there is no solution\n    if x1 < 0 and x2 < 0:\n        return -1\n\n    # If one of the intersection points is inside the goal, return it\n    if 0 < x1 < xb:\n        return x1\n    elif 0 < x2 < xb:\n        return x2\n\n    # If both intersection points are inside the goal, return the one closer to the ball\n    return min(x1, x2)\n\nprint(calculate_intersection())"}
{"solution": "# Get the input\nb, d, s = map(int, input().split())\n\n# Calculate the minimum possible number of meals Vasiliy could have missed\nmin_missed = max(0, max(b, d, s) - (b + d + s - max(b, d, s)))\n\n# Print the result\nprint(min_missed)"}
{"solution": "def find_dimensions(path):\n    n = len(path)\n    x, y = 1, 1\n    visited = set()\n    visited.add(path[0])\n    for i in range(1, n):\n        diff = abs(path[i] - path[i - 1])\n        if diff == y:\n            x += 1\n        elif diff == 1:\n            y += 1\n        elif diff != x:\n            return \"NO\"\n        if path[i] in visited:\n            return \"NO\"\n        visited.add(path[i])\n    return \"YES\\n\" + str(x) + \" \" + str(y)\n\nn = int(input())\npath = list(map(int, input().split()))\nprint(find_dimensions(path))"}
{"solution": "def longest_common_subsequence(a, b):\n    m, n = len(a), len(b)\n    dp = [['' for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + a[i - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], key=len)\n\n    return dp[m][n]\n\na = input()\nb = input()\n\nresult = longest_common_subsequence(a, b)\n\nif len(result) == 0:\n    print('-')\nelse:\n    print(result)"}
{"solution": "# Get the number of operations\nn = int(input())\n\n# Get the string of operations\ns = input()\n\n# Initialize the number of stones in the pile\nstones = 0\n\n# Initialize the minimum number of stones in the pile\nmin_stones = 0\n\n# Iterate over the operations\nfor op in s:\n    # If Vasya took a stone\n    if op == '-':\n        # Decrease the number of stones in the pile\n        stones -= 1\n    # If Vasya added a stone\n    else:\n        # Increase the number of stones in the pile\n        stones += 1\n    # Update the minimum number of stones in the pile\n    min_stones = min(min_stones, stones)\n\n# Print the minimum number of stones in the pile\nprint(-min_stones)"}
{"solution": "# Get the input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate the maximum number of liters Kolya can drink\n# First, calculate the maximum number of plastic bottles Kolya can buy\nmax_plastic_bottles = n // a\n\n# Then, calculate the maximum number of glass bottles Kolya can buy\n# by considering the case where he returns the empty glass bottles\nmax_glass_bottles = (n // (b - c)) * 2\n\n# Finally, calculate the total number of liters Kolya can drink\nmax_liters = max(max_plastic_bottles, max_glass_bottles)\n\n# Print the result\nprint(max_liters)"}
{"solution": "def card_war(n, k1, cards1, k2, cards2):\n    rounds = 0\n    while cards1 and cards2:\n        card1 = cards1.pop(0)\n        card2 = cards2.pop(0)\n        rounds += 1\n        if card1 > card2:\n            cards1.append(card2)\n            cards1.append(card1)\n        else:\n            cards2.append(card1)\n            cards2.append(card2)\n        if rounds > n * n:\n            return -1, -1\n    if cards1:\n        return rounds, 1\n    else:\n        return rounds, 2\n\nn = int(input())\nk1 = int(input())\ncards1 = list(map(int, input().split()))\nk2 = int(input())\ncards2 = list(map(int, input().split()))\n\nrounds, winner = card_war(n, k1, cards1, k2, cards2)\n\nif winner != -1:\n    print(rounds, winner)\nelse:\n    print(-1)"}
{"solution": "import re\n\ndef check_password(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    if not re.search(\"[a-z]\", password):\n        return \"Too weak\"\n    if not re.search(\"[A-Z]\", password):\n        return \"Too weak\"\n    if not re.search(\"[0-9]\", password):\n        return \"Too weak\"\n    return \"Correct\"\n\npassword = input()\nprint(check_password(password))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ncount_a = [0] * 6\ncount_b = [0] * 6\n\nfor i in a:\n    count_a[i] += 1\n\nfor i in b:\n    count_b[i] += 1\n\nswaps = 0\nfor i in range(1, 6):\n    diff = abs(count_a[i] - count_b[i])\n    if diff % 2 != 0:\n        print(-1)\n        exit()\n    swaps += diff // 2\n\nprint(swaps)"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    horizontal = input()\n    vertical = input()\n\n    # Create a graph\n    graph = [[] for _ in range(n * m)]\n    for i in range(n):\n        for j in range(m - 1):\n            if horizontal[i] == '>':\n                graph[i * m + j].append(i * m + j + 1)\n            else:\n                graph[i * m + j + 1].append(i * m + j)\n    for i in range(n - 1):\n        for j in range(m):\n            if vertical[j] == 'v':\n                graph[i * m + j].append((i + 1) * m + j)\n            else:\n                graph[(i + 1) * m + j].append(i * m + j)\n\n    # Check if the graph is connected\n    visited = [False] * (n * m)\n    def dfs(u):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(v)\n    dfs(0)\n    return \"YES\" if all(visited) else \"NO\"\n\nprint(solve())"}
{"solution": "def solve(n, arr):\n    if n == 1:\n        if arr[0] == 0:\n            return \"YES\\n0\"\n        else:\n            return \"NO\"\n\n    if arr[0] == 0:\n        return \"YES\\n0->\" + solve(n-1, arr[1:])\n\n    if arr[-1] == 0:\n        return \"YES\\n(\" + solve(n-1, arr[:-1]) + \")->0\"\n\n    return \"NO\"\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(solve(n, arr))"}
{"solution": "def process(a, b):\n    while a != 0 and b != 0:\n        if a >= 2 * b:\n            a = a - 2 * b\n        elif b >= 2 * a:\n            b = b - 2 * a\n        else:\n            break\n    return a, b\n\nn, m = map(int, input().split())\nresult = process(n, m)\nprint(result[0], result[1])"}
{"solution": "def count_divisible_numbers(k, a, b):\n    # Calculate the number of multiples of k in the range [1, b]\n    count_b = b // k\n\n    # Calculate the number of multiples of k in the range [1, a-1]\n    count_a = (a - 1) // k\n\n    # The number of k-divisible numbers on the segment [a, b] is the difference between the two counts\n    return count_b - count_a\n\n# Read the input\nk, a, b = map(int, input().split())\n\n# Print the result\nprint(count_divisible_numbers(k, a, b))"}
{"solution": "# Read the input\nk = int(input())\n\n# Initialize the variables\nnum = 1\nlength = 1\n\n# Loop until the length of the number is greater than or equal to k\nwhile length < k:\n    # Increment the number\n    num += 1\n\n    # Calculate the length of the number\n    length += len(str(num))\n\n# Convert the number to string\nnum = str(num)\n\n# Print the k-th digit of the number\nprint(num[k - (length - len(num)) - 1])"}
{"solution": "n = int(input())\ns = input()\n\n# Check if Vasya can win the game\ndef can_win(s):\n    # If the length of the string is 11, check if it's a telephone number\n    if len(s) == 11:\n        return s[0] == '8'\n    # Try all possible moves for Vasya\n    for i in range(len(s)):\n        # If Petya can't win after Vasya's move, Vasya wins\n        if not can_win(s[:i] + s[i+1:]):\n            return True\n    # If Vasya can't win no matter which character he chooses, Petya wins\n    return False\n\n# Print the result\nif can_win(s):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial(n):\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n    return fact\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef find_permutations(n, x, pos):\n    fact = factorial(n)\n    if x != pos + 1:\n        return 0\n    return (fact[n - 1] * power(n - pos - 1, n - pos - 1, MOD)) % MOD\n\nn, x, pos = map(int, input().split())\nprint(find_permutations(n, x, pos))"}
{"solution": "def decode_string(s, k):\n    n = len(s)\n    dp = [[False] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            if s[i - 1].isalpha():\n                if j > 0:\n                    dp[i][j] = dp[i - 1][j - 1]\n            elif s[i - 1] == '?':\n                if j > 0:\n                    dp[i][j] = dp[i - 1][j - 1] or dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n            else:\n                if j > 0:\n                    dp[i][j] = dp[i - 1][j - 1]\n                for l in range(2, j + 1):\n                    if s[i - l].isalpha():\n                        dp[i][j] = dp[i][j] or dp[i - l][j - l + 1]\n    if not dp[n][k]:\n        return \"Impossible\"\n    res = []\n    i, j = n, k\n    while i > 0 and j > 0:\n        if s[i - 1].isalpha():\n            res.append(s[i - 1])\n            i -= 1\n            j -= 1\n        elif s[i - 1] == '?':\n            if j > 0 and dp[i - 1][j - 1]:\n                res.append(s[i - 2])\n                i -= 2\n                j -= 1\n            else:\n                i -= 1\n        else:\n            l = 1\n            while j - l >= 0 and not dp[i - l][j - l]:\n                l += 1\n            res.append(s[i - l])\n            i -= l + 1\n            j -= l\n    return ''.join(res[::-1])\n\ns = input()\nk = int(input())\nprint(decode_string(s, k))"}
{"solution": "# Get the input\nx = int(input())\n\n# Calculate the number of 90 degree turns\nturns = (x % 90) // 45\n\n# Print the result\nprint(turns)"}
{"solution": "# Get the input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Calculate the difference between the required and available spheres\ndiff_blue = x - a\ndiff_violet = y - b\ndiff_orange = z - c\n\n# If the difference is negative, it means the magician has more spheres than required\n# In this case, we can use these extra spheres to create new ones\nif diff_blue < 0:\n    a += diff_blue\n    diff_blue = 0\nif diff_violet < 0:\n    b += diff_violet\n    diff_violet = 0\nif diff_orange < 0:\n    c += diff_orange\n    diff_orange = 0\n\n# If the magician can transform two spheres of the same color into one sphere of any other color\n# He can use this ability to get the required number of spheres\n# The condition for this is that the sum of the differences of two colors should be greater than or equal to the difference of the third color\nif diff_blue + diff_violet >= diff_orange and diff_blue + diff_orange >= diff_violet and diff_violet + diff_orange >= diff_blue:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def solve(n, k, m):\n    dp = [0] * k\n    dp[0] = 1\n    power = 1\n    for _ in range(n):\n        new_dp = [0] * k\n        for j in range(k):\n            for digit in range(10):\n                new_dp[(j + digit * power) % k] += dp[j]\n        dp = [x % m for x in new_dp]\n        power = (power * 10) % k\n    return dp[0] - 1\n\nn, k, m = map(int, input().split())\nprint(solve(n, k, m))"}
{"solution": "# Get the input\nl, r, a = map(int, input().split())\n\n# Calculate the maximum possible size of the team\nteam_size = 2 * min(l, r) + 2 * min(a, abs(l - r))\n\n# Print the result\nprint(team_size)"}
{"solution": "# Read the input\nn, k = map(int, input().split())\n\n# Calculate the minimum number of moves\nif k == 1:\n    moves = 2 * n - 1\nelse:\n    moves = 2 * n - 2 + 2 * (k - 1)\n\n# Print the result\nprint(moves)"}
{"solution": "# Get the input\nn, m = map(int, input().split())\n\n# Calculate the maximum number of blocks used by a student using two-block pieces\nmax_two_blocks = 2 * n\n\n# Calculate the maximum number of blocks used by a student using three-block pieces\nmax_three_blocks = 3 * m\n\n# If the maximum number of blocks used by a student using two-block pieces is less than or equal to the maximum number of blocks used by a student using three-block pieces, then the minimum height necessary for the tallest of the students' towers is the maximum number of blocks used by a student using three-block pieces.\n# Otherwise, the minimum height necessary for the tallest of the students' towers is the smallest multiple of three that is greater than the maximum number of blocks used by a student using two-block pieces.\nif max_two_blocks <= max_three_blocks:\n    print(max_three_blocks)\nelse:\n    print(max_three_blocks + (3 - max_three_blocks % 3) % 3)"}
{"solution": "n = int(input())\ncards = [int(input()) for _ in range(n)]\n\nfrom collections import Counter\ncounts = Counter(cards)\n\nif len(counts) < 2 or any(count % 2 != 0 for count in counts.values()):\n    print('NO')\nelse:\n    print('YES')\n    petya_card, vasya_card = [card for card, count in counts.items() if count == n // 2]\n    print(petya_card, vasya_card)"}
{"solution": "# Read input\nn, k = map(int, input().split())\nsoldiers = list(map(int, input().split()))\n\n# Sort the soldiers in descending order\nsoldiers.sort(reverse=True)\n\n# Check if it's possible to arrange the soldiers\npossible = True\nfor s in soldiers:\n    # If there are not enough seats for the current group\n    if s > n * 4:\n        possible = False\n        break\n    # Otherwise, subtract the number of occupied seats from n\n    else:\n        n -= (s + 3) // 4\n\n# Print the result\nif possible:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\nsticks = list(map(int, input().split()))\n\nmin_cost = float('inf')\nt = 0\n\nfor i in range(1, 101):\n    cost = 0\n    for stick in sticks:\n        cost += min(abs(stick - i), abs(stick - i + 1), abs(stick - i - 1))\n    if cost < min_cost:\n        min_cost = cost\n        t = i\n\nprint(t, min_cost)"}
{"solution": "# Read input\nn, m = map(int, input().split())\nsky_map = [input() for _ in range(n)]\n\n# Find the boundaries of the stars\nmin_row, max_row, min_col, max_col = n, 0, m, 0\nfor i in range(n):\n    for j in range(m):\n        if sky_map[i][j] == '*':\n            min_row = min(min_row, i)\n            max_row = max(max_row, i)\n            min_col = min(min_col, j)\n            max_col = max(max_col, j)\n\n# Calculate the side length of the square\nside_length = max(max_row - min_row + 1, max_col - min_col + 1)\n\n# Print the result\nprint(side_length)"}
{"solution": "MOD = 10**9 + 7\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef solve(n, k, a):\n    zeros = a.count(0)\n    ones = n - zeros\n    total = n * (n - 1) // 2\n    if k >= total:\n        return 0\n    dp = [[0] * (ones + 1) for _ in range(zeros + 1)]\n    dp[zeros][ones] = 1\n    for _ in range(k):\n        ndp = [[0] * (ones + 1) for _ in range(zeros + 1)]\n        for i in range(zeros + 1):\n            for j in range(ones + 1):\n                if i < zeros:\n                    ndp[i + 1][j] += dp[i][j] * (zeros - i) * inv(total)\n                    ndp[i + 1][j] %= MOD\n                if j < ones:\n                    ndp[i][j + 1] += dp[i][j] * (ones - j) * inv(total)\n                    ndp[i][j + 1] %= MOD\n                ndp[i][j] += dp[i][j] * (total - (zeros - i) * (ones - j)) * inv(total)\n                ndp[i][j] %= MOD\n        dp = ndp\n    return dp[zeros][zeros]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(solve(n, k, a))"}
{"solution": "def min_seconds(x, y):\n    seconds = 0\n    while x > y:\n        if x % 2 == 0:\n            x //= 2\n        else:\n            x = (x - 1) // 2\n        seconds += 1\n    return seconds\n\nx, y = map(int, input().split())\nprint(min_seconds(x, y))"}
{"solution": "# Get the input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate the determinant\ndet = a * d - b * c\n\n# If the determinant is not zero, the matrix is not degenerate\nif det != 0:\n    print(0)\nelse:\n    # If the determinant is zero, the matrix is degenerate\n    # We need to find the minimum possible norm of the difference between A and B\n    # B is a degenerate matrix, so its determinant is zero\n    # This means that either b = 0 and d = 0, or a = 0 and c = 0\n    # We need to make one of these conditions true while keeping the other elements of B as close as possible to A\n    # The norm of the difference between A and B is the maximum of the absolute differences between the corresponding elements\n    # So we need to minimize the maximum of |a - b|, |b - d|, |c - b|, and |d - d|\n    # If a != 0, we can set b = d = 0\n    # If b != 0, we can set a = c = 0\n    # If both a and b are not zero, we can set a = d = 0\n    # If both c and d are not zero, we can set b = c = 0\n    # We choose the option that gives the smallest norm\n    if a != 0:\n        diff = max(abs(a), abs(b), abs(c))\n        print(diff)\n    elif b != 0:\n        diff = max(abs(b), abs(c), abs(d))\n        print(diff)\n    elif c != 0:\n        diff = max(abs(a), abs(c), abs(d))\n        print(diff)\n    else:\n        diff = max(abs(a), abs(b), abs(d))\n        print(diff)"}
{"solution": "# Read input\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Initialize variables\none_seaters = a\ntwo_seaters_full = 0\ntwo_seaters_single = 0\ndenied = 0\n\n# Iterate over groups\nfor group in groups:\n    # If group is of one person\n    if group == 1:\n        # Try to seat at one-seater table\n        if one_seaters > 0:\n            one_seaters -= 1\n        # If no one-seaters available, try to seat at two-seater table with one person\n        elif two_seaters_single > 0:\n            two_seaters_single -= 1\n            two_seaters_full += 1\n        # If no two-seaters with one person available, try to seat at full two-seater table\n        elif two_seaters_full > 0:\n            two_seaters_full -= 1\n            two_seaters_single += 1\n        # If no tables available, deny service\n        else:\n            denied += 1\n    # If group is of two persons\n    else:\n        # Try to seat at two-seater table\n        if two_seaters_full < b:\n            two_seaters_full += 1\n        # If no two-seaters available, deny service\n        else:\n            denied += 2\n\n# Print result\nprint(denied)"}
{"solution": "# Get the input\nA, B, C, N = map(int, input().split())\n\n# Check if the data is valid\nif A + B - C > N or A < C or B < C:\n    print(-1)\nelse:\n    # Calculate the number of students who didn't pass the exam\n    not_passed = N - (A + B - C)\n    # Check if at least one student stayed home\n    if not_passed > 0:\n        print(not_passed)\n    else:\n        print(-1)"}
{"solution": "MOD = 10**9 + 7\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef inverse(n, p):\n    return power(n, p - 2, p)\n\ndef solve(x, k):\n    if k == 0:\n        return x\n    else:\n        return (solve(x * 2, k - 1) + x * power(2, k, MOD) * inverse(2, MOD)) % MOD\n\nx, k = map(int, input().split())\nprint(solve(x, k))"}
{"solution": "MOD = 998244353\n\ndef inverse(n):\n    return pow(n, MOD - 2, MOD)\n\ndef solve():\n    n = int(input())\n    intervals = [list(map(int, input().split())) for _ in range(n)]\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(n):\n        new_dp = [0] * (n + 1)\n        for j in range(i + 1):\n            for k in range(intervals[i][0], intervals[i][1] + 1):\n                new_dp[min(j + (k > intervals[i][0]), i + 1)] += dp[j]\n                new_dp[min(j + (k > intervals[i][0]), i + 1)] %= MOD\n        dp = new_dp\n\n    return dp[n] * inverse(pow(n, n, MOD)) % MOD\n\nprint(solve())"}
{"solution": "# Get the input\nn = int(input())\n\n# Initialize the count of ways\ncount = 0\n\n# Loop through all possible lengths of the first part\nfor i in range(1, n // 4 + 1):\n    # Loop through all possible lengths of the second part\n    for j in range(i, (n - i) // 3 + 1):\n        # Calculate the length of the third part\n        k = n - i - j\n        # Check if the lengths form a rectangle but not a square\n        if i != j and i != k and j != k:\n            # Increment the count of ways\n            count += 1\n\n# Print the result\nprint(count)"}
{"solution": "# Read input\nn, s = map(int, input().split())\nkegs = list(map(int, input().split()))\n\n# Sort the kegs in ascending order\nkegs.sort()\n\n# Calculate the total volume of kvass\ntotal_volume = sum(kegs)\n\n# Check if it's possible to pour s liters of kvass\nif total_volume < s:\n    print(-1)\nelse:\n    # Calculate the minimum possible volume in the least keg\n    min_volume = max(kegs[0], (total_volume - s) // (n - 1))\n    print(min_volume)"}
{"solution": "# Read the input\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate the distance the caterpillar needs to cover each day\nday_distance = 12 * a\nnight_distance = 12 * b\n\n# Calculate the net distance the caterpillar covers each day\nnet_distance = day_distance - night_distance\n\n# If the caterpillar can't cover the distance in a day, it can't reach the apple\nif net_distance <= 0:\n    print(-1)\nelse:\n    # Calculate the distance the caterpillar needs to cover to reach the apple\n    total_distance = h2 - h1\n\n    # Calculate the number of days it takes for the caterpillar to reach the apple\n    days = (total_distance - 1) // net_distance + 1\n\n    # Print the result\n    print(days)"}
{"solution": "# Get the input\nC, Hr, Hb, Wr, Wb = map(int, input().split())\n\n# Calculate the maximum number of red candies Om Nom can eat\nmax_red_candies = min(C // Wr, C // Wb)\n\n# Calculate the maximum number of blue candies Om Nom can eat\nmax_blue_candies = min(C // Wr, C // Wb)\n\n# If Om Nom can eat more red candies for the same weight, do so\nwhile max_red_candies * Wr + max_blue_candies * Wb <= C and max_red_candies * Hr < (max_red_candies + 1) * Hr:\n    max_red_candies += 1\n    max_blue_candies = min(max_blue_candies, (C - max_red_candies * Wr) // Wb)\n\n# Calculate the maximum number of joy units Om Nom can get\nmax_joy_units = max_red_candies * Hr + max_blue_candies * Hb\n\n# Print the result\nprint(max_joy_units)"}
{"solution": "# Get the start and end coordinates\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\n# Calculate the absolute difference between the coordinates\ndx = abs(x1 - x2)\ndy = abs(y1 - y2)\n\n# The minimal number of steps is the maximum of dx and dy\nmin_steps = max(dx, dy)\n\n# Print the result\nprint(min_steps)"}
{"solution": "n = int(input())\nvotes = input()\n\ndepublicans = []\nremocrats = []\n\nfor i in range(n):\n    if votes[i] == 'D':\n        depublicans.append(i)\n    else:\n        remocrats.append(i)\n\nwhile depublicans and remocrats:\n    if depublicans[0] < remocrats[0]:\n        depublicans.pop(0)\n        if remocrats:\n            remocrats.pop(0)\n    else:\n        remocrats.pop(0)\n        if depublicans:\n            depublicans.pop(0)\n\nif depublicans:\n    print('D')\nelse:\n    print('R')"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\na, b, x, y = map(int, input().split())\n\n# Reduce the aspect ratio to its simplest form\ng = gcd(x, y)\nx //= g\ny //= g\n\n# Calculate the maximum possible width and height\nmax_width = b * x\nmax_height = a * y\n\n# Calculate the number of possible variants\nif max_width < a or max_height < b:\n    print(0)\nelse:\n    # The number of possible variants is the minimum of the number of possible widths and heights\n    print(min(max_width // x, max_height // y))"}
{"solution": "def factorization(n, b):\n    factors = []\n    for i in range(2, int(b**0.5) + 1):\n        if b % i == 0:\n            count = 0\n            while b % i == 0:\n                count += 1\n                b //= i\n            factors.append((i, count))\n    if b > 1:\n        factors.append((b, 1))\n    return factors\n\ndef count_trailing_zeros(n, b):\n    factors = factorization(n, b)\n    zeros = float('inf')\n    for factor, count in factors:\n        temp = 0\n        i = 1\n        while n // factor**i > 0:\n            temp += n // factor**i\n            i += 1\n        zeros = min(zeros, temp // count)\n    return zeros\n\nn, b = map(int, input().split())\nprint(count_trailing_zeros(n, b))"}
{"solution": "def frog_jumps(m, a, b):\n    if a == b:\n        return m + 1\n\n    if a < b:\n        a, b = b, a\n\n    max_reach = 0\n    sum_reach = 0\n    for i in range(m + 1):\n        if i >= max_reach:\n            max_reach = i + a\n            sum_reach += (i + 1) * (i + 2) // 2 - (i - b) * (i - b + 1) // 2\n        else:\n            sum_reach += (i + 1)\n\n    return sum_reach\n\nm, a, b = map(int, input().split())\nprint(frog_jumps(m, a, b))"}
{"solution": "n = int(input())\nnumbers = list(map(int, input().split()))\n\n# Check if the first and last numbers are odd\nif numbers[0] % 2 == 0 or numbers[-1] % 2 == 0:\n    print(\"No\")\nelse:\n    # Count the number of odd numbers in the sequence\n    odd_count = sum(1 for num in numbers if num % 2 != 0)\n    # If the number of odd numbers is even, it's not possible to divide the sequence into an odd number of subsegments\n    if odd_count % 2 == 0:\n        print(\"No\")\n    else:\n        print(\"Yes\")"}
{"solution": "# Get the coordinates of the two known trees\nx1, y1, x2, y2 = map(int, input().split())\n\n# Check if the two known trees are on the same horizontal or vertical line\nif x1 == x2 or y1 == y2:\n    # Calculate the coordinates of the two unknown trees\n    x3 = x1 if x1 != x2 else x1 + abs(y2 - y1)\n    y3 = y2 if y1 == y2 else y1\n    x4 = x2 if x1 == x2 else x1\n    y4 = y1 if y1 != y2 else y1 + abs(x2 - x1)\n    # Print the coordinates of the two unknown trees\n    print(x3, y3, x4, y4)\nelse:\n    # Check if the two known trees can form a square\n    if abs(x1 - x2) == abs(y1 - y2):\n        # Calculate the coordinates of the two unknown trees\n        x3 = x1\n        y3 = y2\n        x4 = x2\n        y4 = y1\n        # Print the coordinates of the two unknown trees\n        print(x3, y3, x4, y4)\n    else:\n        # If the two known trees cannot form a square, print -1\n        print(-1)"}
{"solution": "MOD = 10**9 + 7\n\ndef matrix_multiply(A, B):\n    C = [[0, 0], [0, 0]]\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD\n    return C\n\ndef matrix_power(A, n):\n    result = [[1, 0], [0, 1]]\n    while n > 0:\n        if n % 2 == 1:\n            result = matrix_multiply(result, A)\n        A = matrix_multiply(A, A)\n        n //= 2\n    return result\n\ndef solve(x, y, n):\n    if n == 1:\n        return x % MOD\n    elif n == 2:\n        return y % MOD\n    else:\n        A = [[1, 1], [1, 0]]\n        A_n_minus_2 = matrix_power(A, n - 2)\n        return (A_n_minus_2[0][0] * y + A_n_minus_2[0][1] * x) % MOD\n\nx, y = map(int, input().split())\nn = int(input())\nprint(solve(x, y, n))"}
{"solution": "n = int(input())\narr = list(map(int, input().split()))\n\n# Check if all elements are zero\nif all(x == 0 for x in arr):\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    # Initialize the number of subarrays and the starting index of the current subarray\n    k = 0\n    start = 0\n    # Iterate over the array\n    for i in range(n):\n        # If the sum of the current subarray is zero, create a new subarray\n        if sum(arr[start:i+1]) == 0:\n            print(k+1, i)\n            k += 1\n            start = i + 1\n    # Print the last subarray\n    print(k+1, n)"}
{"solution": "MOD = 1000000009\nn, m, k = map(int, input().split())\n\n# Calculate the number of times the score will double\ndoubles = m // k\n\n# Calculate the remaining correct answers that won't double the score\nremaining = m % k\n\n# Calculate the minimum score\nscore = (1 << doubles) - 1 + remaining\n\n# Print the remainder of the score when divided by MOD\nprint(score % MOD)"}
{"solution": "def find_divisible_by_eight(n):\n    for i in range(len(n)):\n        if int(n[i]) % 8 == 0:\n            return 'YES\\n' + n[i]\n        for j in range(i+1, len(n)):\n            if int(n[i:j]) % 8 == 0:\n                return 'YES\\n' + n[i:j]\n            for k in range(j+1, len(n)):\n                if int(n[i:j] + n[k]) % 8 == 0:\n                    return 'YES\\n' + n[i:j] + n[k]\n    return 'NO'\n\nn = input()\nprint(find_divisible_by_eight(n))"}
{"solution": "n, m = map(int, input().split())\nmemory = [list(map(int, input().split())) for _ in range(m)]\n\n# Sort memory by flat number\nmemory.sort()\n\n# Calculate differences between consecutive flats\ndiffs = [memory[i][0] - memory[i-1][0] for i in range(1, m)]\n\n# Check if differences are all equal\nif len(set(diffs)) == 1:\n    # Calculate flats per floor\n    flats_per_floor = diffs[0]\n    # Calculate the floor for the n-th flat\n    for flat, floor in memory:\n        if n <= flat:\n            result = (n - 1) // flats_per_floor + 1\n            break\n    else:\n        result = (n - memory[-1][0]) // flats_per_floor + memory[-1][1]\nelse:\n    result = -1\n\nprint(result)"}
{"solution": "def count_bishwocks(board):\n    n = len(board[0])\n    count = 0\n\n    for i in range(n - 1):\n        if board[0][i] == '0' and board[0][i + 1] == '0' and board[1][i] == '0':\n            count += 1\n            board[0][i] = board[0][i + 1] = board[1][i] = 'B'\n\n        if board[1][i] == '0' and board[1][i + 1] == '0' and board[0][i + 1] == '0':\n            count += 1\n            board[1][i] = board[1][i + 1] = board[0][i + 1] = 'B'\n\n    return count\n\nboard = [list(input()) for _ in range(2)]\nprint(count_bishwocks(board))"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize variables\nmax_pretty = 0\ncurrent_pretty = 0\nlast_upper = -1\nlast_lower = {}\n\n# Iterate over the string\nfor i in range(n):\n    # If the character is uppercase\n    if s[i].isupper():\n        # Update the last uppercase character position\n        last_upper = i\n        # Reset the current pretty set size\n        current_pretty = 0\n        # Reset the last lowercase characters dictionary\n        last_lower = {}\n    # If the character is lowercase\n    else:\n        # If the character was not in the previous pretty set\n        if s[i] not in last_lower:\n            # Add it to the last lowercase characters dictionary\n            last_lower[s[i]] = i\n        # If the character was in the previous pretty set\n        else:\n            # If the last uppercase character is before the last occurrence of the character\n            if last_upper < last_lower[s[i]]:\n                # Update the last occurrence of the character\n                last_lower[s[i]] = i\n            # If the last uppercase character is after the last occurrence of the character\n            else:\n                # Reset the current pretty set size\n                current_pretty = 0\n                # Update the last occurrence of the character\n                last_lower[s[i]] = i\n        # Increment the current pretty set size\n        current_pretty += 1\n        # Update the maximum pretty set size\n        max_pretty = max(max_pretty, current_pretty)\n\n# Print the maximum pretty set size\nprint(max_pretty)"}
{"solution": "# Get the number of elements\nn = int(input())\n\n# Get the list of elements\na = list(map(int, input().split()))\n\n# Calculate the total sum of the elements\ntotal_sum = sum(a)\n\n# Initialize the maximum possible value of B - C\nmax_diff = 0\n\n# Iterate over all possible subsets of a\nfor i in range(1 << n):\n    # Calculate the sum of the current subset\n    subset_sum = 0\n    for j in range(n):\n        if i & (1 << j):\n            subset_sum += a[j]\n\n    # Calculate the difference between the sum of the current subset and the sum of the remaining elements\n    diff = abs(subset_sum - (total_sum - subset_sum))\n\n    # Update the maximum possible value of B - C\n    max_diff = max(max_diff, diff)\n\n# Print the maximum possible value of B - C\nprint(max_diff)"}
{"solution": "def min_refills(a, b, f, k):\n    # distance covered without refueling\n    dist = 0\n    # number of refills\n    refills = 0\n    # current position of the bus\n    pos = 0\n    # direction of the bus (1 for right, -1 for left)\n    dir = 1\n\n    for _ in range(k):\n        # calculate the next position\n        next_pos = pos + dir * a\n\n        # check if the bus can reach the next position without refueling\n        if dist + abs(next_pos - pos) > b:\n            # check if the bus can reach the gas station\n            if dir * f > pos:\n                # calculate the distance to the gas station\n                dist_to_gas = abs(f - pos)\n                # check if the bus can reach the gas station without refueling\n                if dist_to_gas > b:\n                    # the bus cannot make all the journeys\n                    return -1\n                else:\n                    # refuel at the gas station\n                    dist = b - dist_to_gas\n                    pos = f\n            else:\n                # the bus cannot reach the gas station\n                return -1\n\n        # update the current position and distance covered\n        pos = next_pos\n        dist += abs(next_pos - pos)\n\n        # change the direction of the bus\n        dir *= -1\n\n        # refuel at the gas station if necessary\n        if pos == f:\n            dist = b\n            refills += 1\n\n    return refills\n\n# read the input\na, b, f, k = map(int, input().split())\n\n# print the result\nprint(min_refills(a, b, f, k))"}
{"solution": "n, p, q = map(int, input().split())\ns = input()\n\ndef split_string(s, p, q):\n    result = []\n    i = 0\n    while i < len(s):\n        if i + p <= len(s):\n            result.append(s[i:i+p])\n            i += p\n        elif i + q <= len(s):\n            result.append(s[i:i+q])\n            i += q\n        else:\n            return -1\n    return result\n\nresult = split_string(s, p, q)\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for r in result:\n        print(r)"}
{"solution": "def solve_problem():\n    n, m, s, d = map(int, input().split())\n    obstacles = sorted(map(int, input().split()))\n\n    current_position = 0\n    for obstacle in obstacles:\n        if obstacle - current_position < s:\n            print(\"IMPOSSIBLE\")\n            return\n        else:\n            print(f\"RUN {s}\")\n            print(f\"JUMP {obstacle - current_position}\")\n            current_position = obstacle + 1\n\n    if m - current_position < s:\n        print(\"IMPOSSIBLE\")\n    else:\n        print(f\"RUN {m - current_position}\")\n\nsolve_problem()"}
{"solution": "def count_pairs(s, x):\n    if s < x or (s + x) % 2 != 0:\n        return 0\n    a = (s + x) // 2\n    b = (s - a)\n    if a < 1 or b < 1:\n        return 0\n    if a & b == x:\n        return 2 if a != b else 1\n    return 0\n\ns, x = map(int, input().split())\nprint(count_pairs(s, x))"}
{"solution": "# Get the input\nn, k = map(int, input().split())\n\n# Calculate the minimum number of actions needed\nl = (n + 2 * k) // (2 * k + 1)\n\n# Calculate the skewers that need to be turned over at each step\nskewers = [(i - 1) * (2 * k + 1) + k + 1 for i in range(l)]\n\n# Print the output\nprint(l)\nprint(*skewers)"}
{"solution": "def min_operations(n):\n    n = str(n)\n    length = len(n)\n    min_ops = float('inf')\n\n    for mask in range(1 << length):\n        num = ''\n        for i in range(length):\n            if mask & (1 << i):\n                num += n[i]\n        if num:\n            num = int(num)\n            if int(num ** 0.5) ** 2 == num:\n                min_ops = min(min_ops, length - len(str(num)))\n\n    return -1 if min_ops == float('inf') else min_ops\n\nn = int(input())\nprint(min_operations(n))"}
{"solution": "import sys\n\nMOD = 10**9 + 7\n\ndef factorial(n):\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n    return fact\n\ndef power(x, n, mod):\n    result = 1\n    x = x % mod\n    while n > 0:\n        if n % 2:\n            result = (result * x) % mod\n            n -= 1\n        x = (x * x) % mod\n        n //= 2\n    return result\n\ndef nCr(n, r, fact):\n    return (fact[n] * power(fact[r], MOD - 2, MOD) * power(fact[n - r], MOD - 2, MOD)) % MOD\n\ndef f_max(n, fact):\n    if n == 2:\n        return 1\n    return n // 2\n\ndef count_permutations(n, fact):\n    f = f_max(n, fact)\n    return nCr(n, f, fact)\n\nn = int(sys.stdin.readline())\nfact = factorial(n)\nprint(count_permutations(n, fact))"}
{"solution": "# Get the input string\ns = input()\n\n# Define the vowels\nvowels = ['A', 'E', 'I', 'O', 'U', 'Y']\n\n# Initialize the maximum jump length and the current position\nmax_jump = 0\ncurrent_pos = 0\n\n# Iterate over the string\nwhile current_pos < len(s):\n    # Find the next vowel\n    next_vowel_pos = float('inf')\n    for vowel in vowels:\n        try:\n            next_vowel_pos = min(next_vowel_pos, s.index(vowel, current_pos))\n        except ValueError:\n            pass\n\n    # If there are no more vowels, break the loop\n    if next_vowel_pos == float('inf'):\n        break\n\n    # Update the maximum jump length\n    max_jump = max(max_jump, next_vowel_pos - current_pos)\n\n    # Move the current position to the next vowel\n    current_pos = next_vowel_pos\n\n# Print the result\nprint(max_jump)"}
{"solution": "# Get the input\na1, a2, a3, a4 = map(int, input().split())\n\n# Calculate the total sum of candies\ntotal_sum = a1 + a2 + a3 + a4\n\n# Check if the total sum is odd, if so, it's impossible to distribute the candies equally\nif total_sum % 2 != 0:\n    print(\"NO\")\nelse:\n    # Check if it's possible to distribute the candies equally\n    if (a1 + a2 == total_sum // 2) or (a1 + a3 == total_sum // 2) or (a1 + a4 == total_sum // 2) or (a2 + a3 == total_sum // 2) or (a2 + a4 == total_sum // 2) or (a3 + a4 == total_sum // 2):\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "# Get the number of slices\nn = int(input())\n\n# Get the sizes of the slices\nslices = list(map(int, input().split()))\n\n# Initialize the scores for Alice and Bob\nalice_score = 0\nbob_score = 0\n\n# Bob starts with the decider token\ndecider = 'Bob'\n\n# While there are still slices left\nwhile slices:\n    # If it's Bob's turn\n    if decider == 'Bob':\n        # Bob takes the largest slice\n        bob_score += max(slices)\n        slices.remove(max(slices))\n        # Bob gives the decider token to Alice\n        decider = 'Alice'\n    # If it's Alice's turn\n    else:\n        # Alice takes the largest slice\n        alice_score += max(slices)\n        slices.remove(max(slices))\n        # Alice gives the decider token to Bob\n        decider = 'Bob'\n\n# Print the scores\nprint(alice_score, bob_score)"}
{"solution": "def find_min_variables(n, a):\n    # Create a set to store the sums of values that can be obtained using the current variables\n    sums = set()\n    # Iterate through the input sequence\n    for i in range(n):\n        # Create a new set to store the sums that can be obtained using the current variable\n        new_sums = set()\n        # Add the current value to the new sums set\n        new_sums.add(a[i])\n        # Iterate through the existing sums\n        for s in sums:\n            # Add the sum of the current value and the existing sum to the new sums set\n            new_sums.add(a[i] + s)\n            # Add the existing sum to the new sums set\n            new_sums.add(s)\n        # Update the sums set with the new sums set\n        sums = new_sums\n    # Return the minimum number of variables required to obtain all the sums\n    return len(set(a) & sums)\n\n# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the minimum number of variables required\nprint(find_min_variables(n, a))"}
{"solution": "n = int(input())\npiles = list(map(int, input().split()))\n\n# If there are any piles with more than one stone, Alice can win by removing all stones from those piles\n# on her first move. Otherwise, Bob will win.\nif any(pile > 1 for pile in piles):\n    print(\"Alice\")\nelse:\n    print(\"Bob\")"}
{"solution": "n = int(input())\nnumbers = list(map(int, input().split()))\nnumbers.sort()\n\nif n == 1:\n    print(\"YES\")\nelif n == 2:\n    if numbers[1] - numbers[0] > 1 or (numbers[1] - numbers[0] == 1 and numbers[0] % 2 == 1):\n        print(\"NO\")\n    else:\n        print(\"YES\")\nelse:\n    diff1 = numbers[1] - numbers[0]\n    diff2 = numbers[2] - numbers[1]\n    if diff1 != diff2:\n        print(\"NO\")\n    else:\n        for i in range(1, n - 1):\n            if numbers[i + 1] - numbers[i] != diff1:\n                print(\"NO\")\n                break\n        else:\n            print(\"YES\")"}
{"solution": "def longest_repeated_substring(n, s):\n    length = 0\n    for i in range(n):\n        for j in range(i+length, n):\n            substring = s[i:j+1]\n            if s.count(substring) > 1:\n                length = max(length, len(substring))\n    return length\n\nn = int(input())\ns = input()\nprint(longest_repeated_substring(n, s))"}
{"solution": "# Get the input\nn, a = map(int, input().split())\n\n# Calculate the minimum time Vasya needs to reach house a\nif a <= n // 2:\n    # If house a is on the left side of the street\n    time = a\nelse:\n    # If house a is on the right side of the street\n    time = n - a + 1\n\n# Print the result\nprint(time)"}
{"solution": "def find_subarray(n, m, colors, target):\n    left = 0\n    right = 0\n    current = [0] * m\n    current[colors[0] - 1] += 1\n    while right < n:\n        if current == target:\n            return True\n        if right - left + 1 < sum(target):\n            right += 1\n            if right < n:\n                current[colors[right] - 1] += 1\n        else:\n            current[colors[left] - 1] -= 1\n            left += 1\n    return False\n\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\ntarget = list(map(int, input().split()))\n\nif find_subarray(n, m, colors, target):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "n = int(input())\nmishka_wins = 0\nchris_wins = 0\n\nfor _ in range(n):\n    mishka, chris = map(int, input().split())\n    if mishka > chris:\n        mishka_wins += 1\n    elif chris > mishka:\n        chris_wins += 1\n\nif mishka_wins > chris_wins:\n    print(\"Mishka\")\nelif chris_wins > mishka_wins:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")"}
{"solution": "def is_valid(field, n, m):\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                continue\n            elif field[i][j] == '.':\n                if not is_safe(field, i, j, n, m):\n                    return False\n            else:\n                if not is_valid_number(field, i, j, n, m):\n                    return False\n    return True\n\ndef is_safe(field, i, j, n, m):\n    for x in range(max(0, i-1), min(n, i+2)):\n        for y in range(max(0, j-1), min(m, j+2)):\n            if field[x][y] == '*':\n                return False\n    return True\n\ndef is_valid_number(field, i, j, n, m):\n    count = 0\n    for x in range(max(0, i-1), min(n, i+2)):\n        for y in range(max(0, j-1), min(m, j+2)):\n            if field[x][y] == '*':\n                count += 1\n    return count == int(field[i][j])\n\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\nprint('YES' if is_valid(field, n, m) else 'NO')"}
{"solution": "def min_candies(n):\n    k = 1\n    vasya_eaten = 0\n    petya_eaten = 0\n\n    while vasya_eaten < n / 2:\n        vasya_eaten += min(k, n)\n        n -= min(k, n)\n        petya_eaten += max(n // 10, 0)\n        n -= max(n // 10, 0)\n        k += 1\n\n    return k - 1\n\nn = int(input())\nprint(min_candies(n))"}
{"solution": "def check_necklace(s):\n    pearls = [i for i, x in enumerate(s) if x == 'o']\n    n = len(pearls)\n    diff = [pearls[(i+1)%n] - pearls[i] - 1 for i in range(n)]\n    return 'YES' if len(set(diff)) == 1 else 'NO'\n\ns = input()\nprint(check_necklace(s))"}
{"solution": "# Get the input\nn, m, k = map(int, input().split())\n\n# Calculate the maximum number of pillows Frodo can have\n# so that no one is hurt\nif n == 1:\n    # If there is only one hobbit, Frodo can have all the pillows\n    print(m)\nelse:\n    # Calculate the number of pillows Frodo can give to his neighbors\n    neighbors_pillows = min(k - 1, m - n)\n\n    # Frodo can have the remaining pillows\n    frodo_pillows = m - neighbors_pillows * 2\n\n    # Print the result\n    print(frodo_pillows)"}
{"solution": "import math\n\ndef max_cost_subarray(n, m, k, a):\n    max_cost = 0\n    curr_sum = 0\n    min_sum = 0\n    min_sum_index = -1\n    prefix_sum = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + a[i - 1]\n\n    for i in range(n):\n        curr_sum += a[i]\n        if i - min_sum_index >= m:\n            min_sum = min(min_sum, prefix_sum[i] - prefix_sum[min_sum_index + 1])\n            min_sum_index = i\n        max_cost = max(max_cost, curr_sum - k * math.ceil((i - min_sum_index + 1) / m))\n\n    return max_cost\n\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\nprint(max_cost_subarray(n, m, k, a))"}
{"solution": "# Get the input\nn, m = map(int, input().split())\n\n# If the grid is square or wider than it is tall\nif n >= m:\n    # If the grid is at least 2x2\n    if n > 1:\n        print(f\"{n} {m}\")\n        print(f\"{n-1} {m}\")\n        print(f\"{n} {m-1}\")\n        print(f\"{0} {m}\")\n    # If the grid is 1xN\n    else:\n        print(f\"{n} {m}\")\n        print(f\"{n} {m-1}\")\n        print(f\"{n} {m-2}\")\n        print(f\"{n} {m-3}\")\n# If the grid is taller than it is wide\nelse:\n    # If the grid is at least 2x2\n    if m > 1:\n        print(f\"{n} {m}\")\n        print(f\"{n} {m-1}\")\n        print(f\"{n-1} {m}\")\n        print(f\"{0} {m}\")\n    # If the grid is Nx1\n    else:\n        print(f\"{n} {m}\")\n        print(f\"{n-1} {m}\")\n        print(f\"{n-2} {m}\")\n        print(f\"{n-3} {m}\")"}
{"solution": "def smallest_number(shuffled, substring):\n    count = [0] * 10\n    for char in shuffled:\n        count[int(char)] += 1\n\n    sub_count = [0] * 10\n    for char in substring:\n        sub_count[int(char)] += 1\n\n    result = []\n    for i in range(10):\n        if i > 0 or sub_count[0] == 0:\n            result.extend([str(i)] * (count[i] - sub_count[i]))\n\n    result.append(substring)\n\n    if sub_count[0] > 0:\n        result.extend(['0'] * (count[0] - sub_count[0]))\n\n    return ''.join(result)\n\nshuffled = input()\nsubstring = input()\nprint(smallest_number(shuffled, substring))"}
{"solution": "# Read input\nn, m, min_temp, max_temp = map(int, input().split())\ntemps = list(map(int, input().split()))\n\n# Check if the data is consistent\nif min_temp in temps and max_temp in temps and len(set(temps)) == m:\n    if temps.count(min_temp) + temps.count(max_temp) >= m - 1:\n        print('Correct')\n    else:\n        print('Incorrect')\nelse:\n    print('Incorrect')"}
{"solution": "def count_trailing_zeroes(n):\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count\n\ndef find_n(m):\n    left = 0\n    right = 5 * m\n    while left < right:\n        mid = (left + right) // 2\n        if count_trailing_zeroes(mid) < m:\n            left = mid + 1\n        else:\n            right = mid\n    if count_trailing_zeroes(left) != m:\n        return 0, []\n    else:\n        k = 1\n        while count_trailing_zeroes(left + k) == m:\n            k += 1\n        return k, list(range(left, left + k))\n\nm = int(input())\nk, n_values = find_n(m)\nprint(k)\nprint(*n_values)"}
{"solution": "import heapq\n\ndef dijkstra(graph, start):\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n\n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n\n    return distances\n\ndef main():\n    n, m, k = map(int, input().split())\n    special_vertices = list(map(int, input().split()))\n\n    graph = {i: {} for i in range(1, n + 1)}\n\n    for _ in range(m):\n        u, v, w = map(int, input().split())\n        graph[u][v] = graph[v][u] = min(graph[u].get(v, float('infinity')), w)\n\n    results = []\n\n    for vertex in special_vertices:\n        distances = dijkstra(graph, vertex)\n        max_distance = max(distances[v] for v in special_vertices if v != vertex)\n        results.append(max_distance)\n\n    print(*results)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the number of movements made by the operator\nn = int(input())\n\n# Get the index of the shell where the ball was found after n movements\nx = int(input())\n\n# If the number of movements is even, the ball was initially placed in the same shell as it was found\nif n % 2 == 0:\n    print(x)\n# If the number of movements is odd, the ball was initially placed in the shell that was not swapped in the last movement\nelse:\n    if x == 0:\n        print(1)\n    elif x == 1:\n        print(0)\n    else:\n        print(2)"}
{"solution": "def check_square(rectangles):\n    x_coords = set()\n    y_coords = set()\n    for rect in rectangles:\n        x_coords.add(rect[0])\n        x_coords.add(rect[2])\n        y_coords.add(rect[1])\n        y_coords.add(rect[3])\n\n    x_coords = sorted(list(x_coords))\n    y_coords = sorted(list(y_coords))\n\n    if len(x_coords) != len(y_coords) or len(x_coords) != 2:\n        return False\n\n    x_len = x_coords[1] - x_coords[0]\n    y_len = y_coords[1] - y_coords[0]\n\n    if x_len != y_len:\n        return False\n\n    area = x_len * y_len\n    total_rect_area = 0\n    for rect in rectangles:\n        total_rect_area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n\n    return area == total_rect_area\n\nn = int(input())\nrectangles = []\nfor _ in range(n):\n    rect = list(map(int, input().split()))\n    rectangles.append(rect)\n\nprint(\"YES\" if check_square(rectangles) else \"NO\")"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef count_really_big_numbers(n, s):\n    count = 0\n    for i in range(1, n + 1):\n        if i - sum_of_digits(i) >= s:\n            count += 1\n    return count\n\nn, s = map(int, input().split())\nprint(count_really_big_numbers(n, s))"}
{"solution": "from collections import defaultdict\n\ndef check_possible(points):\n    x_dict = defaultdict(int)\n    y_dict = defaultdict(int)\n    xy_dict = defaultdict(int)\n    yx_dict = defaultdict(int)\n\n    for x, y in points:\n        x_dict[x] += 1\n        y_dict[y] += 1\n        xy_dict[x - y] += 1\n        yx_dict[y - x] += 1\n\n    for x, y in points:\n        if x_dict[x] > 1 and y_dict[y] > 1:\n            if xy_dict[x - y] > 1 or yx_dict[y - x] > 1:\n                return True\n    return False\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\nif check_possible(points):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "MOD = 10**9 + 7\n\ndef solve():\n    a, b, k, t = map(int, input().split())\n    dp = [[0] * (2 * k + 1) for _ in range(t + 1)]\n    dp[0][a - b + k] = 1\n    for i in range(1, t + 1):\n        for j in range(2 * k + 1):\n            for l in range(max(0, j - k), min(2 * k, j + k) + 1):\n                dp[i][j] = (dp[i][j] + dp[i - 1][l]) % MOD\n    return sum(dp[t][k + 1:]) % MOD\n\nprint(solve())"}
{"solution": "def solve(n, l, x, y, a):\n    marks = set(a)\n    if x in marks and y in marks:\n        return 0, []\n    elif x in marks:\n        if y - x in marks:\n            return 0, []\n        else:\n            return 1, [y]\n    elif y in marks:\n        if y - x in marks:\n            return 1, [x]\n        else:\n            return 0, []\n    else:\n        if x + y in marks:\n            return 1, [x]\n        elif y - x in marks:\n            return 1, [y - x]\n        else:\n            return 2, [x, y]\n\nn, l, x, y = map(int, input().split())\na = list(map(int, input().split()))\nv, p = solve(n, l, x, y, a)\nprint(v)\nprint(' '.join(map(str, p)))"}
{"solution": "import math\n\ndef max_volume(n, cakes):\n    # Sort the cakes in descending order of volume\n    cakes.sort(key=lambda x: math.pi * x[0] * x[0] * x[1], reverse=True)\n\n    # Initialize the maximum volume and the current volume\n    max_vol = 0\n    curr_vol = 0\n\n    # Iterate over the cakes\n    for i in range(n):\n        # Add the volume of the current cake to the current volume\n        curr_vol += math.pi * cakes[i][0] * cakes[i][0] * cakes[i][1]\n\n        # Update the maximum volume\n        max_vol = max(max_vol, curr_vol)\n\n        # If the current volume is negative, reset it to 0\n        if curr_vol < 0:\n            curr_vol = 0\n\n    # Return the maximum volume\n    return max_vol\n\n# Read the input\nn = int(input())\ncakes = []\nfor i in range(n):\n    r, h = map(int, input().split())\n    cakes.append((r, h))\n\n# Print the maximum volume\nprint(max_volume(n, cakes))"}
{"solution": "import sys\n\ndef min_slices(n, k, h):\n    h.sort()\n    min_height = h[0]\n    slices = 0\n    while h[-1] > min_height:\n        cost = 0\n        for i in range(n):\n            if h[i] > min_height:\n                cost += h[i] - min_height\n                h[i] = min_height\n        if cost > k:\n            break\n        slices += 1\n        min_height -= 1\n    return slices + h[-1] - min_height\n\nn, k = map(int, sys.stdin.readline().split())\nh = list(map(int, sys.stdin.readline().split()))\nprint(min_slices(n, k, h))"}
{"solution": "# Read the input\nn = int(input())\ncards = list(map(int, input().split()))\n\n# Calculate the prefix sum array\nprefix_sum = [0] * (n + 1)\nfor i in range(1, n + 1):\n    prefix_sum[i] = prefix_sum[i - 1] + cards[i - 1]\n\n# Initialize the maximum score\nmax_score = 0\n\n# Iterate over all possible segments\nfor l in range(1, n + 1):\n    for r in range(l, n + 1):\n        # Calculate the score if Bob removes the leftmost card\n        score1 = prefix_sum[r] - prefix_sum[l - 1] - cards[l - 1]\n        # Calculate the score if Bob removes the rightmost card\n        score2 = prefix_sum[r - 1] - prefix_sum[l - 1] - cards[r - 1]\n        # Update the maximum score\n        max_score = max(max_score, score1, score2)\n\n# Print the maximum score\nprint(max_score)"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(k1, k2, k3):\n    if k1 == 1 or k2 == 1 or k3 == 1:\n        return True\n    if k1 == k2 == k3:\n        return True\n    if k1 == k2 or k1 == k3 or k2 == k3:\n        return False\n    if k1 > k2:\n        k1, k2 = k2, k1\n    if k1 > k3:\n        k1, k3 = k3, k1\n    if k2 > k3:\n        k2, k3 = k3, k2\n    if k1 == 1 or k2 == 1:\n        return True\n    if k1 * 2 == k2 and k2 * 2 == k3:\n        return True\n    if k1 * 2 == k2 and k2 * 2 <= k3:\n        return False\n    if k1 * 2 == k2 and k2 * 2 > k3:\n        return True\n    if k1 * 2 > k2:\n        return False\n    if k1 * 2 < k2 and k2 <= k3:\n        return False\n    if k1 * 2 < k2 and k2 > k3:\n        l = lcm(k1, k2)\n        if l * 2 <= k3:\n            return False\n        if l * 2 > k3:\n            return True\n\nk1, k2, k3 = map(int, input().split())\nprint(\"YES\" if solve(k1, k2, k3) else \"NO\")"}
{"solution": "n = int(input())\ns = input()\n\nstack = []\n\nfor char in s:\n    if stack and stack[-1][0] == char:\n        stack[-1][1] += 1\n    else:\n        stack.append([char, 1])\n\noperations = 0\n\nwhile stack:\n    if stack[-1][1] == 1:\n        operations += 1\n        stack.pop()\n    else:\n        stack[-1][1] -= 1\n\nprint(operations)"}
{"solution": "n = int(input())\nboys = sorted(list(map(int, input().split())))\nm = int(input())\ngirls = sorted(list(map(int, input().split())))\n\npairs = 0\ni = 0\nj = 0\n\nwhile i < n and j < m:\n    if abs(boys[i] - girls[j]) <= 1:\n        pairs += 1\n        i += 1\n        j += 1\n    elif boys[i] < girls[j]:\n        i += 1\n    else:\n        j += 1\n\nprint(pairs)"}
{"solution": "# Read the input\nplayer1_def, player1_att = map(int, input().split())\nplayer2_def, player2_att = map(int, input().split())\nplayer3_def, player3_att = map(int, input().split())\nplayer4_def, player4_att = map(int, input().split())\n\n# Determine the optimal arrangement for each team\nteam1_def = max(player1_def, player2_def)\nteam1_att = max(player1_att, player2_att)\nteam2_def = max(player3_def, player4_def)\nteam2_att = max(player3_att, player4_att)\n\n# Check if either team can win\nif team1_def > team2_att and team1_att > team2_def:\n    print(\"Team 1\")\nelif team2_def > team1_att and team2_att > team1_def:\n    print(\"Team 2\")\nelse:\n    print(\"Draw\")"}
{"solution": "import numpy as np\nfrom scipy.optimize import minimize\n\n# Read input\nN, K = map(int, input().split())\nmeat = [list(map(int, input().split())) for _ in range(N)]\n\n# Define objective function\ndef objective(pos):\n    times = [np.sqrt((pos[0] - x)**2 + (pos[1] - y)**2) * c for x, y, c in meat]\n    times.sort()\n    return times[K - 1]\n\n# Optimize\nres = minimize(objective, x0=[0, 0], method='Nelder-Mead')\n\n# Print result\nprint(res.fun)"}
{"solution": "n = int(input())\nticket = input()\n\nleft_sum = 0\nright_sum = 0\nleft_question_marks = 0\nright_question_marks = 0\n\nfor i in range(n // 2):\n    if ticket[i] == '?':\n        left_question_marks += 1\n    else:\n        left_sum += int(ticket[i])\n\nfor i in range(n // 2, n):\n    if ticket[i] == '?':\n        right_question_marks += 1\n    else:\n        right_sum += int(ticket[i])\n\nif left_question_marks % 2 == 1 and right_question_marks % 2 == 1:\n    print(\"Monocarp\")\nelif abs(left_sum - right_sum) <= 45 * min(left_question_marks, right_question_marks):\n    print(\"Bicarp\")\nelse:\n    print(\"Monocarp\")"}
{"solution": "# Get the number of bus routes and the time Serval goes to the station\nn, t = map(int, input().split())\n\n# Initialize the earliest bus arrival time and the bus route\nearliest_arrival = float('inf')\nbus_route = -1\n\n# Iterate over each bus route\nfor i in range(1, n + 1):\n    # Get the time when the first bus of this route arrives and the interval between two buses of this route\n    s, d = map(int, input().split())\n\n    # Calculate the time of the first bus that arrives after or at time t\n    if s <= t:\n        first_bus_after_t = s + ((t - s) // d) * d\n        if t - first_bus_after_t > d:\n            first_bus_after_t += d\n    else:\n        first_bus_after_t = s\n\n    # Update the earliest bus arrival time and the bus route\n    if first_bus_after_t < earliest_arrival:\n        earliest_arrival = first_bus_after_t\n        bus_route = i\n\n# Print the bus route Serval will use\nprint(bus_route)"}
{"solution": "import sys\n\ndef count_numbers_with_k_bits(n, k):\n    # Count the number of integers in the range [1, n] that have exactly k bits set in their binary representation\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') == k:\n            count += 1\n    return count\n\ndef find_n(m, k):\n    # Use binary search to find the value of n that satisfies the given condition\n    left, right = 1, 10 ** 18\n    while left < right:\n        mid = (left + right) // 2\n        if count_numbers_with_k_bits(2 * mid, k) - count_numbers_with_k_bits(mid, k) < m:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\nm, k = map(int, sys.stdin.readline().split())\nprint(find_n(m, k))"}
{"solution": "n = int(input())\nlevel = input()\n\n# Find the indices of all platforms\nplatforms = [i for i in range(n) if level[i] == '*']\n\n# Check if there is a sequence of five platforms with the same interval\nfor i in range(len(platforms) - 4):\n    if platforms[i+4] - platforms[i+3] == platforms[i+3] - platforms[i+2] == platforms[i+2] - platforms[i+1] == platforms[i+1] - platforms[i]:\n        print('yes')\n        exit()\n\nprint('no')"}
{"solution": "def find_missing_number(matrix, n):\n    sum_diagonal = sum(matrix[i][i] for i in range(n))\n    sum_anti_diagonal = sum(matrix[i][n - i - 1] for i in range(n))\n    sum_rows = [sum(row) for row in matrix]\n    sum_cols = [sum(matrix[i][j] for i in range(n)) for j in range(n)]\n\n    if sum_diagonal != sum_anti_diagonal:\n        return -1\n\n    if n % 2 == 1:\n        expected_sum = sum_diagonal\n        missing_number = expected_sum * n - sum(sum_rows)\n        if all(sum_rows[i] == expected_sum for i in range(n)) and all(sum_cols[i] == expected_sum for i in range(n)):\n            return missing_number\n    else:\n        corner_sum = sum_rows[0]\n        if all(sum_rows[i] == corner_sum for i in range(1, n)) and all(sum_cols[i] == corner_sum for i in range(1, n)):\n            if sum_diagonal == corner_sum and sum_anti_diagonal == corner_sum:\n                return matrix[0][0]\n            else:\n                return -1\n        else:\n            return -1\n\n    return -1\n\nn = int(input())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\nprint(find_missing_number(matrix, n))"}
{"solution": "# Read the number of benches\nn = int(input())\n\n# Read the number of people coming to the park\nm = int(input())\n\n# Read the initial number of people on each bench\nbenches = [int(input()) for _ in range(n)]\n\n# Calculate the minimum possible k\nmin_k = max(benches) + (m // n)\nif m % n != 0:\n    min_k += 1\n\n# Calculate the maximum possible k\nmax_k = max(benches) + m\n\n# Print the minimum and maximum possible k\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef main():\n    n, m = map(int, input().split())\n\n    # Calculate factorials\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n\n    # Calculate inverse factorials\n    inv_fact = [1] * (n + 1)\n    inv_fact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD\n\n    # Calculate combinations\n    def C(n, k):\n        if k < 0 or k > n:\n            return 0\n        return (fact[n] * inv_fact[k] * inv_fact[n - k]) % MOD\n\n    # Calculate the number of ways\n    ways = 0\n    for i in range(m, n + 1):\n        ways = (ways + C(n, i) * pow(2, m - i, MOD) * fact[m - 1]) % MOD\n\n    print(ways)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip().split()\n\ndef main():\n    n, m = map(int, read_input())\n    friends = [0] * n\n    for i in range(n):\n        f_i, *b_i = map(int, read_input())\n        for b in b_i:\n            friends[i] |= 1 << (b - 1)\n\n    pizzas = [(0, 0)] * m\n    for i in range(m):\n        c_j, r_j, *a_j = map(int, read_input())\n        pizza = 0\n        for a in a_j:\n            pizza |= 1 << (a - 1)\n        pizzas[i] = (c_j, pizza)\n\n    pizzas.sort()\n    max_pleased = 0\n    best_pizzas = (-1, -1)\n    for i in range(m):\n        for j in range(i + 1, m):\n            combined_pizza = pizzas[i][1] | pizzas[j][1]\n            pleased = sum((friend & combined_pizza) == friend for friend in friends)\n            if pleased > max_pleased or (pleased == max_pleased and pizzas[i][0] + pizzas[j][0] < sum(pizzas[k][0] for k in best_pizzas)):\n                max_pleased = pleased\n                best_pizzas = (i, j)\n\n    print(*best_pizzas)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_min_max(m, s):\n    if s == 0 and m == 1:\n        return '0 0'\n    elif s == 0 or s > m * 9:\n        return '-1 -1'\n    else:\n        min_num = ['1'] + ['0'] * (m - 1)\n        s -= 1\n        for i in range(m - 1, 0, -1):\n            if s >= 9:\n                min_num[i] = '9'\n                s -= 9\n            else:\n                min_num[i] = str(s)\n                s = 0\n        min_num = ''.join(min_num)\n\n        max_num = ['0'] * m\n        for i in range(m - 1, -1, -1):\n            if s >= 9:\n                max_num[i] = '9'\n                s -= 9\n            else:\n                max_num[i] = str(s)\n                s = 0\n        max_num = ''.join(max_num)\n\n        return min_num + ' ' + max_num\n\nm, s = map(int, input().split())\nprint(find_min_max(m, s))"}
{"solution": "MOD = 998244353\n\ndef solve(l, r, k):\n    def f(n):\n        if n == 0:\n            return 0\n        s = str(n)\n        dp = [[0] * (1 << 10) for _ in range(len(s) + 1)]\n        dp[0][0] = 1\n        for i in range(len(s)):\n            for j in range(1 << 10):\n                for d in range(10):\n                    if (j >> d) & 1:\n                        dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % MOD\n                    elif j == 0 or bin(j).count('1') < k:\n                        dp[i + 1][j | (1 << d)] = (dp[i + 1][j | (1 << d)] + dp[i][j]) % MOD\n            if i < len(s) - 1:\n                dp[i + 1][0] = (dp[i + 1][0] + 45 * dp[i][0]) % MOD\n        return sum(dp[-1]) % MOD\n    return (f(r) - f(l - 1)) % MOD\n\nl, r, k = map(int, input().split())\nprint(solve(l, r, k))"}
{"solution": "def can_distribute_pencils(n, k, d, pencils):\n    pencils.sort()\n    i = 0\n    while i < n:\n        count = 1\n        while i + count < n and pencils[i + count] - pencils[i] <= d:\n            count += 1\n        if count < k:\n            return False\n        i += count\n    return True\n\nn, k, d = map(int, input().split())\npencils = list(map(int, input().split()))\n\nif can_distribute_pencils(n, k, d, pencils):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Get the input string\ns = input()\n\n# Initialize the count of dead light bulbs for each color\nk_r, k_b, k_y, k_g = 0, 0, 0, 0\n\n# Iterate over the string\nfor i in range(len(s)):\n    # Check the color of the light bulb\n    if s[i] == 'R':\n        # If the light bulb is red and dead, increment the count of dead red light bulbs\n        if i > 0 and s[i-1] == 'R':\n            k_r += 1\n        if i < len(s)-1 and s[i+1] == 'R':\n            k_r += 1\n    elif s[i] == 'B':\n        # If the light bulb is blue and dead, increment the count of dead blue light bulbs\n        if i > 0 and s[i-1] == 'B':\n            k_b += 1\n        if i < len(s)-1 and s[i+1] == 'B':\n            k_b += 1\n    elif s[i] == 'Y':\n        # If the light bulb is yellow and dead, increment the count of dead yellow light bulbs\n        if i > 0 and s[i-1] == 'Y':\n            k_y += 1\n        if i < len(s)-1 and s[i+1] == 'Y':\n            k_y += 1\n    elif s[i] == 'G':\n        # If the light bulb is green and dead, increment the count of dead green light bulbs\n        if i > 0 and s[i-1] == 'G':\n            k_g += 1\n        if i < len(s)-1 and s[i+1] == 'G':\n            k_g += 1\n\n# Print the count of dead light bulbs for each color\nprint(k_r, k_b, k_y, k_g)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        s, t = map(int, sys.stdin.readline().split())\n        graph[s].append(t)\n\n    dp = [0] * (n + 1)\n    dp[n] = 0\n    for i in range(n - 1, 0, -1):\n        total = 0\n        for j in graph[i]:\n            total += dp[j] + 1\n        dp[i] = total / len(graph[i])\n\n    min_expected_passages = float('inf')\n    for j in graph[1]:\n        expected_passages = dp[j] + 1\n        if len(graph[1]) > 1:\n            total = 0\n            for k in graph[1]:\n                if k != j:\n                    total += dp[k] + 1\n            expected_passages += total / (len(graph[1]) - 1)\n        min_expected_passages = min(min_expected_passages, expected_passages)\n\n    print(min_expected_passages)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input number\nn = int(input())\n\n# If the number ends with 0, print the number as it is\nif n % 10 == 0:\n    print(n)\n# If the number is less than 5, round it down to the nearest integer ending with 0\nelif n % 10 < 5:\n    print(n - n % 10)\n# If the number is greater than or equal to 5, round it up to the nearest integer ending with 0\nelse:\n    print(n + 10 - n % 10)"}
{"solution": "def find_swaps(s, t):\n    swaps = []\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if s[i] in t and t[i] in s:\n                swaps.append((s[i], t[i]))\n                s = s.replace(s[i], t[i])\n            else:\n                return -1\n    return swaps\n\ndef main():\n    s = input()\n    t = input()\n    swaps = find_swaps(s, t)\n    if swaps == -1:\n        print(-1)\n    else:\n        print(len(swaps))\n        for swap in swaps:\n            print(swap[0], swap[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the first and last names from the input\nfirst_name, last_name = input().split()\n\n# Initialize the login as the first letter of the first name\nlogin = first_name[0]\n\n# Iterate over the prefixes of the last name\nfor i in range(1, len(last_name) + 1):\n    # Create a new login using the current prefix of the last name\n    new_login = first_name[0] + last_name[:i]\n    # If the new login is alphabetically earlier than the current login, update the login\n    if new_login < login:\n        login = new_login\n\n# Print the alphabetically earliest possible login\nprint(login)"}
{"solution": "def draw_brackets(sequence):\n    n = len(sequence)\n    height = n // 2\n    width = 2 * n - 1\n    grid = [[' '] * width for _ in range(height)]\n\n    def draw(i, j, h):\n        if h == 1:\n            grid[0][j] = '+'\n            grid[1][j] = '|'\n            grid[2][j] = '+'\n            return\n        grid[0][j] = '+'\n        grid[h - 1][j] = '+'\n        grid[h // 2][j] = '|'\n        draw(i + 1, j + 1, h - 2)\n\n    i = 0\n    j = 0\n    for bracket in sequence:\n        if bracket == '[':\n            draw(i, j, height)\n            j += 2\n        else:\n            j += 1\n            grid[height // 2][j] = '|'\n            j += 1\n\n    return [''.join(row) for row in grid]\n\nn = int(input())\nsequence = input()\nprint('\\n'.join(draw_brackets(sequence)))"}
{"solution": "def golden_value(s):\n    q = (1 + 5 ** 0.5) / 2\n    value = 0\n    for i, digit in enumerate(reversed(s)):\n        value += int(digit) * q ** i\n    return value\n\ndef compare_golden_numbers():\n    s1 = input()\n    s2 = input()\n    value1 = golden_value(s1)\n    value2 = golden_value(s2)\n    if value1 > value2:\n        print('>')\n    elif value1 < value2:\n        print('<')\n    else:\n        print('=')\n\ncompare_golden_numbers()"}
{"solution": "# List of all the gems and their colors\ngems = {\n    'Purple': 'Power',\n    'Green': 'Time',\n    'Blue': 'Space',\n    'Orange': 'Soul',\n    'Red': 'Reality',\n    'Yellow': 'Mind'\n}\n\n# Number of gems Thanos has\nn = int(input())\n\n# List to store the gems Thanos has\nthanos_gems = []\n\n# Input the colors of the gems Thanos has\nfor _ in range(n):\n    color = input()\n    thanos_gems.append(gems[color])\n\n# List to store the names of the absent gems\nabsent_gems = []\n\n# Check for each gem if it's absent\nfor gem in gems.values():\n    if gem not in thanos_gems:\n        absent_gems.append(gem)\n\n# Output the number of absent gems\nprint(len(absent_gems))\n\n# Output the names of the absent gems\nfor gem in absent_gems:\n    print(gem)"}
{"solution": "def find_meeting_round(n, a, b):\n    round = 1\n    while n > 1:\n        if (a - 1) // 2 == (b - 1) // 2:\n            return round\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n //= 2\n        round += 1\n    return \"Final!\"\n\nn, a, b = map(int, input().split())\nprint(find_meeting_round(n, a, b))"}
{"solution": "import sys\nfrom typing import List\n\nread_input = sys.stdin.readline\n\ndef depth_first_search(node: int, graph: List[int], visited: List[bool]) -> int:\n    cycle_size = 1\n    visited[node] = True\n    next_node = graph[node]\n    while not visited[next_node]:\n        visited[next_node] = True\n        next_node = graph[next_node]\n        cycle_size += 1\n    return cycle_size\n\ndef main():\n    number_of_nodes = int(read_input())\n    permutation = list(map(int, read_input().split()))\n    permutation = [node - 1 for node in permutation]\n    sequence = list(map(int, read_input().split()))\n\n    visited = [False] * number_of_nodes\n    cycles = []\n    for node in range(number_of_nodes):\n        if not visited[node]:\n            cycle_size = depth_first_search(node, permutation, visited)\n            cycles.append(cycle_size)\n\n    ones_in_sequence = sum(sequence)\n    total_changes = 0\n    for cycle_size in cycles:\n        if cycle_size % 2 == 0:\n            if ones_in_sequence % cycle_size != 0:\n                total_changes += 1\n        else:\n            if ones_in_sequence % cycle_size != 0 and (ones_in_sequence + 1) % cycle_size != 0:\n                total_changes += 1\n\n    print(total_changes)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Read input\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Initialize maximum possible length\nmax_length = v1 * t\n\n# Initialize current speed\ncurrent_speed = v1\n\n# Calculate maximum possible length\nfor _ in range(t - 1):\n    # Calculate next possible speed\n    next_speed = min(v2, current_speed + d)\n\n    # Update maximum possible length\n    max_length += next_speed\n\n    # Update current speed\n    current_speed = next_speed\n\n# Print maximum possible length\nprint(max_length)"}
{"solution": "import sys\nfrom itertools import accumulate\nfrom bisect import bisect_left\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    weights = list(map(int, sys.stdin.readline().split()))\n    lengths, capacities = zip(*(map(int, sys.stdin.readline().split()) for _ in range(M)))\n\n    # Calculate prefix sum of weights\n    weight_sums = list(accumulate(weights))\n\n    # Calculate minimum possible distance between first and last camels\n    left, right = 0, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        prev = 0\n        for i in range(N):\n            # Check if bridge collapses\n            if weight_sums[i] - weight_sums[prev] > mid:\n                return -1\n            j = bisect_left(weight_sums, weight_sums[i] + mid, lo=prev)\n            if j == N:\n                break\n            if weight_sums[j] - weight_sums[i] > capacities[bisect_left(lengths, weight_sums[j] - weight_sums[i])]:\n                prev = i\n            else:\n                prev = j\n        right = mid\n    return right\n\nprint(solve())"}
{"solution": "def last_digit_factorial(n):\n    if n == 0:\n        return 1\n    last_digits = [1, 1, 2, 6, 4, 0, 0, 0, 0, 0]\n    return last_digits[n % 10]\n\ndef last_digit_quotient(a, b):\n    if a > b:\n        return 1\n    if a == b:\n        return last_digit_factorial(a)\n    if a == 0:\n        return 1\n    if b - a >= 5:\n        return 0\n    return (last_digit_factorial(b) * last_digit_quotient(a, b - 1)) % 10\n\na, b = map(int, input().split())\nprint(last_digit_quotient(a, b))"}
{"solution": "n, d = map(int, input().split())\nlilies = input()\n\njumps = 0\ncurrent_position = 0\n\nwhile current_position < n - 1:\n    found_lily = False\n    for i in range(min(n - 1, current_position + d), current_position, -1):\n        if lilies[i] == '1':\n            current_position = i\n            found_lily = True\n            break\n    if not found_lily:\n        print(-1)\n        break\n    jumps += 1\n\nif current_position == n - 1:\n    print(jumps)"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nn = int(input())\nfor m in range(1, 1001):\n    if not is_prime(n * m + 1):\n        print(m)\n        break"}
{"solution": "n = int(input())\n\n# prices of houses, cars, and computers\nhouse_price = 1234567\ncar_price = 123456\ncomputer_price = 1234\n\n# iterate through all possible numbers of houses Kolya could buy\nfor a in range(n // house_price + 1):\n    # iterate through all possible numbers of cars Kolya could buy\n    for b in range((n - a * house_price) // car_price + 1):\n        # calculate the remaining amount of money Kolya has\n        remaining = n - a * house_price - b * car_price\n        # check if Kolya could spend the remaining amount on computers\n        if remaining % computer_price == 0:\n            print(\"YES\")\n            exit()\n\n# if no solution is found, print \"NO\"\nprint(\"NO\")"}
{"solution": "def main():\n    n = int(input())\n    x1, x2 = map(int, input().split())\n    lines = [list(map(int, input().split())) for _ in range(n)]\n\n    slopes = {}\n    for k, b in lines:\n        if k not in slopes:\n            slopes[k] = [b]\n        else:\n            slopes[k].append(b)\n\n    for k in slopes:\n        slopes[k].sort()\n        for i in range(1, len(slopes[k])):\n            x = (slopes[k][i-1] - slopes[k][i]) / (-k)\n            if x1 < x < x2:\n                print(\"YES\")\n                return\n\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_splits(n):\n    count = 0\n    i = 1\n    while i <= n:\n        if n % i == 0:\n            count += 1\n        n -= i\n        i += 1\n    return count\n\nn = int(input())\nprint(count_splits(n))"}
{"solution": "# Read input\nn, k = map(int, input().split())\n\n# Calculate minimum possible number of good apartments\nmin_good = max(0, k - (n - k))\n\n# Calculate maximum possible number of good apartments\nmax_good = min(k, n - 1)\n\n# Print output\nprint(min_good, max_good)"}
{"solution": "def max_games(n):\n    # Initialize the number of games the winner can play in\n    games = 0\n\n    # While there are still players left in the tournament\n    while n > 1:\n        # The winner plays in a game\n        games += 1\n\n        # The loser is eliminated\n        n -= 1\n\n        # The winner can only play against a player who has played the same number of games or one less\n        # So, we pair up the players who have played the same number of games or one less\n        # This ensures that the winner can play in as many games as possible\n        if n % 2 == 1:\n            # If there is an odd number of players left, the winner can't play against the player who has played one less game\n            # So, we eliminate one player\n            n -= 1\n\n        # The winner moves on to the next round\n        n //= 2\n\n    return games\n\n# Read the input\nn = int(input())\n\n# Print the output\nprint(max_games(n))"}
{"solution": "s = input()\n\n# Initialize the count of \"VK\"\ncount = 0\n\n# Iterate over the string\nfor i in range(len(s) - 1):\n    # If \"VK\" is found, increment the count\n    if s[i] == 'V' and s[i + 1] == 'K':\n        count += 1\n    # If \"V?\" is found, check if changing ? to 'K' would increase the count\n    elif s[i] == 'V' and s[i + 1] != 'K':\n        if i + 2 < len(s) and s[i + 2] == 'K':\n            count += 1\n    # If \"?K\" is found, check if changing ? to 'V' would increase the count\n    elif s[i] != 'V' and s[i + 1] == 'K':\n        if i - 1 >= 0 and s[i - 1] == 'V':\n            count += 1\n\nprint(count)"}
{"solution": "# Get the input\nn = int(input())\n\n# Calculate the minimum number of segments that Sofia will have to draw with a ruler without a guide\n# For the first square, Sofia will have to draw 2 segments with a ruler\n# For each additional square, Sofia will have to draw 2 more segments with a ruler if she cannot use the existing segments as a guide\n# This happens when the number of squares is odd\n# So, the minimum number of segments that Sofia will have to draw with a ruler without a guide is 2 + 2 * (n - 1) if n is odd, and 2 * n if n is even\n\nif n % 2 == 0:\n    print(2 * n)\nelse:\n    print(2 + 2 * (n - 1))"}
{"solution": "# Get the input\na, b = map(int, input().split())\n\n# Initialize the number of years\nyears = 0\n\n# While Limak's weight is less than or equal to Bob's weight\nwhile a <= b:\n    # Triple Limak's weight and double Bob's weight\n    a *= 3\n    b *= 2\n\n    # Increment the number of years\n    years += 1\n\n# Print the number of years\nprint(years)"}
{"solution": "def solve(h, n):\n    visited = set()\n    current = 1\n    commands = \"LR\"\n    command_index = 0\n    steps = 0\n\n    while current != n:\n        visited.add(current)\n        next_node = current * 2 if commands[command_index] == 'L' else current * 2 + 1\n\n        if next_node in visited or next_node > 2 ** h:\n            command_index = (command_index + 1) % 2\n            if current != 1:\n                current = current // 2\n            else:\n                command_index = (command_index + 1) % 2\n        else:\n            current = next_node\n\n        steps += 1\n\n    return steps\n\nh, n = map(int, input().split())\nprint(solve(h, n))"}
{"solution": "import math\n\ndef find_pairs(x):\n    pairs = []\n    for n in range(1, int(math.sqrt(2 * x)) + 1):\n        if (2 * x) % n == 0:\n            m = (2 * x) // n\n            if n <= m and (n * m - x) % (n + m) == 0 and (n * m - x) // (n + m) > 0:\n                pairs.append((n, m))\n    return pairs\n\nx = int(input())\npairs = find_pairs(x)\nprint(len(pairs))\nfor pair in pairs:\n    print(*pair)"}
{"solution": "# Read the number of months\nn = int(input())\n\n# Read the list of days in each month\ndays = list(map(int, input().split()))\n\n# Define the list of days in each month of a non-leap year\nmonth_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n# Define a function to check if a sequence of days could be durations of consecutive months\ndef is_consecutive(days, month_days):\n    # Create a list of all possible sequences of months\n    sequences = []\n    for i in range(12):\n        sequence = month_days[i:] + month_days[:i]\n        sequences.append(sequence)\n\n    # Check if the given sequence of days is in any of the possible sequences\n    for sequence in sequences:\n        if days == sequence[:len(days)]:\n            return True\n\n    # If the given sequence of days is not in any of the possible sequences, return False\n    return False\n\n# Check if the given sequence of days could be durations of consecutive months\nif is_consecutive(days, month_days):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def find_fractions(n):\n    fractions = []\n    for i in range(2, n):\n        if n % i == 0:\n            a = 1\n            b = i\n            while a < b:\n                if (1 - 1/n) * b - a == 0:\n                    fractions.append((a, b))\n                    break\n                elif (1 - 1/n) * b - a < 0:\n                    break\n                else:\n                    a += 1\n    return fractions\n\nn = int(input())\nfractions = find_fractions(n)\nif len(fractions) > 0:\n    print(\"YES\")\n    print(len(fractions))\n    for fraction in fractions:\n        print(*fraction)\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\na, b = map(int, input().split())\nh = list(map(int, input().split()))\n\n# Calculate the total area of the fence\ntotal_area = sum(h)\n\n# Check if it is possible to paint the fence\nif total_area > a + b:\n    print(-1)\nelse:\n    # Initialize the minimum unattractiveness value\n    min_unattractiveness = float('inf')\n\n    # Iterate through all possible ways to paint the fence\n    for i in range(1 << (n - 1)):\n        # Initialize the current unattractiveness value\n        current_unattractiveness = 0\n\n        # Initialize the current red and green area\n        red_area = 0\n        green_area = 0\n\n        # Iterate through all boards\n        for j in range(n):\n            # If the current board is painted red\n            if (i >> j) & 1:\n                red_area += h[j]\n\n                # If the previous board is painted green\n                if j > 0 and not (i >> (j - 1)) & 1:\n                    current_unattractiveness += 1\n            # If the current board is painted green\n            else:\n                green_area += h[j]\n\n                # If the previous board is painted red\n                if j > 0 and (i >> (j - 1)) & 1:\n                    current_unattractiveness += 1\n\n        # Check if the current painting is valid\n        if red_area <= a and green_area <= b:\n            # Update the minimum unattractiveness value\n            min_unattractiveness = min(min_unattractiveness, current_unattractiveness)\n\n    # Print the minimum unattractiveness value\n    print(min_unattractiveness)"}
{"solution": "def find_points(n, m, k):\n    area = (n * m) / k\n    if area < 1:\n        return \"NO\"\n    for x1 in range(n + 1):\n        for y1 in range(m + 1):\n            for x2 in range(n + 1):\n                for y2 in range(m + 1):\n                    x3 = x1 + (y2 - y1) * area\n                    y3 = y1 + (x1 - x2) * area\n                    if 0 <= x3 <= n and 0 <= y3 <= m:\n                        return \"YES\\n{0} {1}\\n{2} {3}\\n{4} {5}\".format(x1, y1, x2, y2, int(x3), int(y3))\n    return \"NO\"\n\nn, m, k = map(int, input().split())\nprint(find_points(n, m, k))"}
{"solution": "n, k = map(int, input().split())\n\n# If Sasha can make more than half of the moves, he will win\nif n // k > (n - n // k) / k:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\nexercises = list(map(int, input().split()))\n\nchest = 0\nbiceps = 0\nback = 0\n\nfor i in range(n):\n    if i % 3 == 0:\n        chest += exercises[i]\n    elif i % 3 == 1:\n        biceps += exercises[i]\n    else:\n        back += exercises[i]\n\nif chest > biceps and chest > back:\n    print(\"chest\")\nelif biceps > chest and biceps > back:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "n = int(input())\ngrades = list(map(int, input().split()))\n\navg = sum(grades) / n\nrounded_avg = round(avg)\n\nif rounded_avg < 5:\n    diff = 5 - rounded_avg\n    grades.sort()\n    count = 0\n    for i in range(n):\n        if grades[i] < 5:\n            grades[i] = 5\n            count += 1\n            if sum(grades) / n >= 5:\n                break\n    print(count)\nelse:\n    print(0)"}
{"solution": "def solve(u, v):\n    if u == v == 0:\n        return [0]\n    if u > v or (u & 1) != (v & 1):\n        return [-1]\n    if u == v:\n        return [u]\n    if v > u * 2:\n        return [-1]\n    if (v - u) & (u + (v - u) // 2) == 0:\n        return [u, (v - u) // 2, (v - u) // 2]\n    return [u, v - u]\n\nu, v = map(int, input().split())\nresult = solve(u, v)\nif result[0] == -1:\n    print(-1)\nelse:\n    print(len(result))\n    print(' '.join(map(str, result)))"}
{"solution": "def min_digits(n):\n    count = 0\n    while n > 0:\n        if n % 10 != 0:\n            count += n % 10\n            n -= n % 10\n        else:\n            n //= 10\n    return count\n\nn = int(input())\nprint(min_digits(n))"}
{"solution": "# Get the input\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\n# Check if it is possible to reach the treasure\nif (x2 - x1) % x == 0 and (y2 - y1) % y == 0 and (x2 - x1) // x == (y2 - y1) // y:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "from collections import Counter\nfrom math import factorial\n\ndef count_variants(n):\n    digits = Counter(str(n))\n    total = factorial(len(str(n)))\n    for count in digits.values():\n        total //= factorial(count)\n    return total\n\nn = int(input())\nprint(count_variants(n))"}
{"solution": "# Get the input\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\n# Calculate the maximum number of suits of the first type that can be composed\nfirst_type_suits = min(a, d)\n\n# Calculate the maximum number of suits of the second type that can be composed\nsecond_type_suits = min(b, c, d)\n\n# Calculate the maximum possible cost of a set of suits\nmax_cost = first_type_suits * e + second_type_suits * f\n\n# Print the result\nprint(max_cost)"}
{"solution": "def solve(a, b, p, x):\n    # Calculate a^n (mod p) for all possible n\n    powers = [1]\n    for i in range(1, p):\n        powers.append((powers[-1] * a) % p)\n\n    # Calculate the multiplicative inverse of each power\n    inv_powers = [0] * p\n    inv_powers[1] = 1\n    for i in range(2, p):\n        inv_powers[powers[p - i]] = i\n\n    # Count the number of solutions\n    count = 0\n    for n in range(1, x + 1):\n        if n * powers[n] % p == b:\n            count += 1\n\n    return count\n\n# Read input\na, b, p, x = map(int, input().split())\n\n# Print output\nprint(solve(a, b, p, x))"}
{"solution": "# Read the input\nk2, k3, k5, k6 = map(int, input().split())\n\n# Calculate the number of 256 that can be made\nmin_256 = min(k2, k5, k6)\n\n# Calculate the remaining 2's after making 256\nremaining_2 = k2 - min_256\n\n# Calculate the number of 32 that can be made\nmin_32 = min(k3, remaining_2)\n\n# Calculate the final sum\nfinal_sum = min_256 * 256 + min_32 * 32\n\n# Print the final sum\nprint(final_sum)"}
{"solution": "def bender_happiness(n, x, y, c):\n    grid = [[0]*n for _ in range(n)]\n    grid[x-1][y-1] = 1\n    seconds = 0\n    on_cells = 1\n\n    while on_cells < c:\n        new_grid = [row[:] for row in grid]\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 0 and (\n                    (i > 0 and grid[i-1][j] == 1) or\n                    (i < n-1 and grid[i+1][j] == 1) or\n                    (j > 0 and grid[i][j-1] == 1) or\n                    (j < n-1 and grid[i][j+1] == 1)\n                ):\n                    new_grid[i][j] = 1\n                    on_cells += 1\n        grid = new_grid\n        seconds += 1\n\n    return seconds\n\nn, x, y, c = map(int, input().split())\nprint(bender_happiness(n, x, y, c))"}
{"solution": "# Read input\nl, r = map(int, input().split())\n\n# Calculate the maximum value of a ^ b\nmax_val = 0\nfor i in range(63, -1, -1):\n    if (l ^ max_val) & (1 << i):\n        if l + (1 << i) - 1 <= r:\n            max_val |= (1 << i)\n\n# Print the result\nprint(max_val)"}
{"solution": "def min_height(n, k):\n    left, right = 0, k\n    while left < right:\n        mid = (left + right) // 2\n        if (mid * (mid + 1)) // 2 > k or (mid * (mid + 1)) // 2 + mid * (n - mid) < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\nn, k = map(int, input().split())\nprint(min_height(n, k))"}
{"solution": "# Get the input\nx, y, z, t1, t2, t3 = map(int, input().split())\n\n# Calculate the time it takes to use the stairs\nstairs_time = abs(x - y) * t1\n\n# Calculate the time it takes to use the elevator\nelevator_time = abs(z - x) * t2 + t3 + abs(z - y) * t2 + t3\n\n# Compare the times and print the result\nif elevator_time <= stairs_time:\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "# Read the input\nn, m = map(int, input().split())\n\n# Calculate the optimal value for Andrew\nif m <= (n + 1) // 2:\n    a = n + 1 - m\nelse:\n    a = m\n\n# Print the output\nprint(a)"}
{"solution": "# Get the number of lessons\nn = int(input())\n\n# Get the schedule for the lessons\nschedule = list(map(int, input().split()))\n\n# Initialize the count of pairs Alena stays at the university\ncount = 0\n\n# Initialize a flag to check if Alena is currently at the university\nat_university = False\n\n# Iterate over the schedule\nfor i in range(n):\n    # If Alena has a pair\n    if schedule[i] == 1:\n        # Increment the count of pairs\n        count += 1\n        # Set the flag to True\n        at_university = True\n    # If Alena doesn't have a pair and is currently at the university\n    elif at_university:\n        # If this is the last break or the next pair is not a break\n        if i == n - 1 or schedule[i + 1] == 1:\n            # Increment the count of pairs\n            count += 1\n        # Set the flag to False\n        at_university = False\n\n# Print the result\nprint(count)"}
{"solution": "# Read input\nn, k = map(int, input().split())\ncandies = list(map(int, input().split()))\n\n# Initialize variables\nbran_candies = 0\ndays = 0\n\n# Iterate over the days\nfor i in range(n):\n    # Arya finds candies\n    arya_candies = candies[i]\n\n    # Arya gives Bran candies\n    if arya_candies >= 8:\n        bran_candies += 8\n        arya_candies -= 8\n    else:\n        bran_candies += arya_candies\n        arya_candies = 0\n\n    # Check if Bran has enough candies\n    if bran_candies >= k:\n        days = i + 1\n        break\n\n# Print the result\nif days == 0:\n    print(-1)\nelse:\n    print(days)"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize the additional walks and the schedule\nadditional_walks = 0\nb = [0] * n\n\n# For the first day\nif a[0] < k:\n    additional_walks += k - a[0]\n    b[0] = k\nelse:\n    b[0] = a[0]\n\n# For the remaining days\nfor i in range(1, n):\n    if a[i] < k:\n        if b[i - 1] < k:\n            additional_walks += k - b[i - 1]\n            b[i] = k\n        else:\n            b[i] = a[i]\n    else:\n        if a[i] < b[i - 1] + k:\n            additional_walks += b[i - 1] + k - a[i]\n            b[i] = b[i - 1] + k\n        else:\n            b[i] = a[i]\n\n# Print the result\nprint(additional_walks)\nprint(*b)"}
{"solution": "# Get the input value for the order of the rhombus\nn = int(input())\n\n# Calculate the number of cells in the rhombus using the formula for the sum of an arithmetic series\n# The first term of the series is 1, the last term is 2n-1, and there are n terms in the series\n# The formula for the sum of an arithmetic series is (n/2) * (first_term + last_term)\nnum_cells = (n * (1 + (2*n - 1))) // 2\n\n# Print the result\nprint(num_cells)"}
{"solution": "n = int(input())\ns = input().lower()\n\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n\nfor char in alphabet:\n    if char not in s:\n        print('NO')\n        break\nelse:\n    print('YES')"}
{"solution": "# Get the current time and the number of minutes to add\ncurrent_time = input().split(':')\nminutes_to_add = int(input())\n\n# Convert the current time to minutes\ncurrent_minutes = int(current_time[0]) * 60 + int(current_time[1])\n\n# Add the minutes\nnew_minutes = (current_minutes + minutes_to_add) % (24 * 60)\n\n# Convert the new time back to hours and minutes\nnew_hours = new_minutes // 60\nnew_minutes = new_minutes % 60\n\n# Print the new time\nprint(f'{new_hours:02d}:{new_minutes:02d}')"}
{"solution": "# Read input\nn, m = map(int, input().split())\nswitches = [list(map(int, input())) for _ in range(n)]\n\n# Check each switch\nfor i in range(n):\n    # Create a copy of switches without the i-th switch\n    switches_without_i = switches[:i] + switches[i+1:]\n\n    # Create a list to store the state of each lamp\n    lamps = [0] * m\n\n    # Press all the remaining switches\n    for switch in switches_without_i:\n        for j in range(m):\n            if switch[j] == 1:\n                lamps[j] = 1\n\n    # Check if all lamps are turned on\n    if all(lamps):\n        print(\"YES\")\n        break\n\n# If no such switch is found\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\nupper_sum = 0\nlower_sum = 0\nswaps = 0\n\nfor _ in range(n):\n    x, y = map(int, input().split())\n    upper_sum += x\n    lower_sum += y\n    if x % 2 != y % 2:\n        swaps += 1\n\nif upper_sum % 2 == 0 and lower_sum % 2 == 0:\n    print(0)\nelif upper_sum % 2 != 0 and lower_sum % 2 != 0 and swaps > 0:\n    print(1)\nelse:\n    print(-1)"}
{"solution": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = math.isqrt(n)\n    for i in range(3, sqrt_n + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef calculate_area(a, b):\n    return a**2 - b**2\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        a, b = map(int, input().split())\n        area = calculate_area(a, b)\n        if is_prime(area):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nsolve()"}
{"solution": "n = int(input())\npoints = [list(map(int, input().split())) for _ in range(n)]\n\n# Check the sign of the x-coordinate of the first point\nfirst_sign = points[0][0] > 0\n\n# Iterate over the remaining points\nfor i in range(1, n):\n    # If the sign of the x-coordinate of the current point is different from the first point,\n    # then there is a point that can be removed to make the remaining points lie on one side of the OY axis\n    if (points[i][0] > 0) != first_sign:\n        print(\"Yes\")\n        exit()\n\n# If all points have the same sign, then there is no point that can be removed\nprint(\"No\")"}
{"solution": "import math\n\n# Get the input\nA, B = map(int, input().split())\n\n# Calculate the factorials\nA_factorial = math.factorial(A)\nB_factorial = math.factorial(B)\n\n# Calculate the greatest common divisor\ngcd = math.gcd(A_factorial, B_factorial)\n\n# Print the result\nprint(gcd)"}
{"solution": "def is_composite(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False\n\ndef find_composites(n):\n    a = n + 4\n    while not is_composite(a):\n        a += 1\n    b = a - n\n    return a, b\n\nn = int(input())\na, b = find_composites(n)\nprint(a, b)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef bellman_ford(graph, start, end, cost, price):\n    dist = [float('-inf')] * len(graph)\n    dist[start] = 0\n\n    for _ in range(len(graph) - 1):\n        for u, v, c in graph:\n            if dist[u] != float('-inf') and dist[u] + c > dist[v]:\n                dist[v] = dist[u] + c\n\n    max_score = float('-inf')\n    for t in range(1, len(graph)):\n        score = dist[end] - t * price\n        max_score = max(max_score, score)\n\n    return max_score\n\ndef main():\n    n, m, p = map(int, sys.stdin.readline().split())\n    graph = []\n    for _ in range(m):\n        a, b, c = map(int, sys.stdin.readline().split())\n        graph.append((a - 1, b - 1, c))\n\n    max_score = bellman_ford(graph, 0, n - 1, defaultdict(int), p)\n    print(max_score)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef min_cost_palindrome(N, strings, costs):\n    dp = [[sys.maxsize] * N for _ in range(N)]\n    for i in range(N):\n        dp[i][i] = costs[i]\n\n    for length in range(2, N + 1):\n        for i in range(N - length + 1):\n            j = i + length - 1\n            if strings[i] == strings[j]:\n                dp[i][j] = min(dp[i][j], dp[i + 1][j - 1])\n            for k in range(i, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])\n            if strings[i] == strings[j - 1]:\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + costs[i])\n            if strings[i + 1] == strings[j]:\n                dp[i][j] = min(dp[i][j], dp[i + 1][j] + costs[j])\n\n    return dp[0][N - 1] if dp[0][N - 1] < sys.maxsize else -1\n\nN = int(input())\nstrings = []\ncosts = []\nfor _ in range(N):\n    s, c = input().split()\n    strings.append(s)\n    costs.append(int(c))\n\nprint(min_cost_palindrome(N, strings, costs))"}
{"solution": "def max_xor_sum(n, k):\n    if k == n:\n        return n if n % 4 < 2 else n ^ (1 << (n.bit_length() - 1))\n    else:\n        return n if k % 2 == 0 else n ^ (1 << (n.bit_length() - 1))\n\nn, k = map(int, input().split())\nprint(max_xor_sum(n, k))"}
{"solution": "n = int(input())\npoints = [list(map(int, input().split())) for _ in range(n)]\n\n# Sort points by x-coordinate\npoints.sort(key=lambda x: x[0])\n\n# Initialize minimum length of the shorter side of the triangle\nmin_length = float('inf')\n\n# Iterate through all possible x-coordinates for the vertex on the y-axis\nfor i in range(n):\n    # Calculate the maximum y-coordinate for the base of the triangle\n    max_y = max(points[j][1] for j in range(i + 1))\n\n    # Calculate the length of the shorter side of the triangle\n    length = max(max_y - points[j][1] for j in range(i + 1))\n\n    # Update the minimum length\n    min_length = min(min_length, length)\n\nprint(min_length)"}
{"solution": "def max_nineteens(s):\n    # Count the number of each character in the string\n    counts = {c: s.count(c) for c in set(s)}\n\n    # The limiting factor for the number of \"nineteen\"s is the number of 'n's and 'e's\n    # Each \"nineteen\" requires 3 'n's and 3 'e's\n    n_count = counts.get('n', 0)\n    e_count = counts.get('e', 0)\n\n    # The number of \"nineteen\"s is the minimum of n_count // 3 and e_count // 3\n    return min(n_count // 3, e_count // 3)\n\n# Read the input string\ns = input()\n\n# Print the maximum number of \"nineteen\"s that can be formed\nprint(max_nineteens(s))"}
{"solution": "import math\n\ndef find_branch(p, y):\n    for i in range(y, 1, -1):\n        is_suitable = True\n        for j in range(2, min(p, math.floor(math.sqrt(i))) + 1):\n            if i % j == 0 and i // j <= y:\n                is_suitable = False\n                break\n        if is_suitable:\n            return i\n    return -1\n\np, y = map(int, input().split())\nprint(find_branch(p, y))"}
{"solution": "# Get the input\nn, m, k = map(int, input().split())\nhouses = list(map(int, input().split()))\n\n# Initialize the minimum distance to a large number\nmin_distance = float('inf')\n\n# Iterate over all houses\nfor i in range(n):\n    # If the house is affordable\n    if houses[i] <= k:\n        # Calculate the distance to the girl's house\n        distance = abs(i - m + 1) * 10\n        # Update the minimum distance\n        min_distance = min(min_distance, distance)\n\n# Print the minimum distance\nprint(min_distance)"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(n)]\n    B = [list(map(int, input().split())) for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] != B[i][j]:\n                if i + 1 < n and j + 1 < m and A[i][j] == B[i+1][j] and A[i+1][j] == B[i][j+1] and A[i][j+1] == B[i+1][j+1] and A[i+1][j+1] == B[i][j]:\n                    A[i][j], A[i+1][j], A[i][j+1], A[i+1][j+1] = A[i+1][j], A[i+1][j+1], A[i][j+1], A[i][j]\n                else:\n                    print(\"NO\")\n                    return\n    print(\"YES\")\n\nsolve()"}
{"solution": "# Get the input strings\na = input()\nb = input()\n\n# If the strings are equal, there's no uncommon subsequence\nif a == b:\n    print(-1)\n# Otherwise, the longest uncommon subsequence is the length of the longer string\nelse:\n    print(max(len(a), len(b)))"}
{"solution": "# Get the input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate the first scream times for Rick and Morty\nrick_first_scream = b\nmorty_first_scream = d\n\n# If Rick and Morty scream at the same time in the first try\nif rick_first_scream == morty_first_scream:\n    print(rick_first_scream)\nelse:\n    # Calculate the difference between Rick and Morty's scream intervals\n    diff = abs(a - c)\n\n    # If the difference is 0, they will scream at the same time infinitely often\n    if diff == 0:\n        print(-1)\n    else:\n        # Calculate the time difference between the first screams of Rick and Morty\n        time_diff = abs(rick_first_scream - morty_first_scream)\n\n        # If the time difference is not a multiple of the difference between the intervals, they will never scream at the same time\n        if time_diff % diff != 0:\n            print(-1)\n        else:\n            # Calculate the number of intervals that need to be added to the first scream time of the one who screams first to reach the time of the first common scream\n            intervals_to_add = time_diff // diff\n\n            # Calculate and print the time of the first common scream\n            if rick_first_scream < morty_first_scream:\n                print(rick_first_scream + intervals_to_add * a)\n            else:\n                print(morty_first_scream + intervals_to_add * c)"}
{"solution": "n = int(input())\n\n# If n is not a multiple of 3, we can split it into 1, 1, and n-2\nif n % 3 != 0:\n    print(\"1 1\", n-2)\n# If n is a multiple of 3, we can split it into 1, 4, and n-5\nelse:\n    print(\"1 4\", n-5)"}
{"solution": "def find_squares(n, a, b, c, d):\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i + j + a + b == i + a + j + b == a + b + c + d == b + c + d + i:\n                count += 1\n    return count\n\nn, a, b, c, d = map(int, input().split())\nprint(find_squares(n, a, b, c, d))"}
{"solution": "# Get the initial weight and height of the snowball\nw, h = map(int, input().split())\n\n# Get the weight and height of the first stone\nu1, d1 = map(int, input().split())\n\n# Get the weight and height of the second stone\nu2, d2 = map(int, input().split())\n\n# Simulate the movement of the snowball\nwhile h > 0:\n    # Increase the weight of the snowball\n    w += h\n\n    # Check if the snowball hits a stone\n    if h == d1:\n        w = max(0, w - u1)\n    elif h == d2:\n        w = max(0, w - u2)\n\n    # Move the snowball down\n    h -= 1\n\n# Print the final weight of the snowball\nprint(w)"}
{"solution": "# Read input\nm = int(input())\nc = list(map(int, input().split()))\nx, y = map(int, input().split())\n\n# Initialize variables\nbeginners = 0\nintermediates = 0\nk = m\n\n# Iterate over scores\nfor i in range(m-1, -1, -1):\n    # Add students to beginner group\n    if beginners + c[i] <= y:\n        beginners += c[i]\n    # If beginner group is full, add students to intermediate group\n    else:\n        intermediates += c[i]\n    # Check if intermediate group is valid\n    if intermediates >= x and intermediates <= y:\n        k = i + 1\n        break\n\n# Print result\nprint(k if beginners >= x and beginners <= y else 0)"}
{"solution": "n = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\ncoins = 0\nwhile n != 1:\n    if n % k == 0 and B < A:\n        n /= k\n        coins += B\n    else:\n        n -= 1\n        coins += A\n\nprint(coins)"}
{"solution": "import math\n\ndef min_operations(n):\n    operations = 0\n    while n % 2 == 0:\n        n = math.sqrt(n)\n        operations += 1\n    while n % 3 == 0:\n        n /= 3\n        operations += 1\n    if n == 1:\n        return 1, operations\n    elif n % 2 == 0:\n        return 2, operations + 2\n    else:\n        return 1, operations + 1\n\nn = int(input())\nmin_n, min_operations = min_operations(n)\nprint(min_n, min_operations)"}
{"solution": "# Read input\nn, k = map(int, input().split())\nr, s, p = map(int, input().split())\nt = input()\n\n# Initialize score and last_played array\nscore = 0\nlast_played = [-1] * 3\n\n# Iterate over each round\nfor i in range(n):\n    # Determine the machine's move\n    if t[i] == 'r':\n        machine_move = 0\n    elif t[i] == 'p':\n        machine_move = 1\n    else:\n        machine_move = 2\n\n    # Determine the best move for the player\n    if machine_move == 0:  # Rock\n        best_move = 1  # Paper\n    elif machine_move == 1:  # Paper\n        best_move = 2  # Scissors\n    else:  # Scissors\n        best_move = 0  # Rock\n\n    # Check if the best move was played in the last k rounds\n    if i >= k and last_played[best_move] >= i - k:\n        # If it was, the player cannot use it and earns no points\n        continue\n\n    # Update the score and last_played array\n    if best_move == 0:\n        score += r\n    elif best_move == 1:\n        score += p\n    else:\n        score += s\n    last_played[best_move] = i\n\n# Print the maximum total score\nprint(score)"}
{"solution": "# Read the input\na, b, c = map(int, input().split())\n\n# Calculate the maximum possible length of the good string\n# The idea is to alternate 'a' and 'b' as much as possible\n# So, we take min(a, b) pairs of 'ab', then add the remaining 'a' or 'b'\n# Finally, we add 2 * c because each 'ab' string contributes 2 to the length\nmax_length = 2 * min(a, b) + max(a, b) + 2 * c\n\n# Print the result\nprint(max_length)"}
{"solution": "# Read input\nn, k, p, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate the sum of marks Vova has already got\nsum_marks = sum(marks)\n\n# Calculate the number of marks Vova needs to get for the remaining tests\n# to not exceed the sum of x\nremaining_sum = x - sum_marks\n\n# Calculate the number of marks Vova needs to get for the remaining tests\n# to ensure the median is not lower than y\nremaining_marks = n - k\nsorted_marks = sorted(marks)\nmedian_index = n // 2\ncurrent_median = sorted_marks[median_index] if k > 0 else 0\nneeded_median = y\n\n# If Vova's current median is already greater than or equal to the needed median,\n# he can get any marks for the remaining tests\nif current_median >= needed_median:\n    print(*[1] * remaining_marks)\nelse:\n    # Calculate the number of marks Vova needs to get to increase the median to the needed level\n    median_increase = needed_median - current_median\n    # If Vova needs to increase the median and the remaining sum is not enough, it's impossible to achieve the desired result\n    if median_increase * (median_index + 1) > remaining_sum:\n        print(-1)\n    else:\n        # Calculate the number of marks Vova needs to get for the remaining tests\n        # to increase the median to the needed level\n        median_marks = median_increase * (median_index + 1)\n        # Calculate the number of marks Vova needs to get for the remaining tests\n        # to not exceed the sum of x after increasing the median\n        remaining_sum -= median_marks\n        # Calculate the number of marks Vova needs to get for the remaining tests\n        # to ensure the sum is not greater than x\n        remaining_marks -= median_index + 1\n        # Print the marks Vova needs to get for the remaining tests\n        print(*([needed_median] * (median_index + 1) + [1] * remaining_marks + [p] * max(0, remaining_sum - remaining_marks)))"}
{"solution": "def is_berlanese(word):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    prev_char = word[0]\n    for char in word[1:]:\n        if prev_char not in vowels and prev_char != 'n' and char not in vowels:\n            return False\n        prev_char = char\n    if prev_char not in vowels and prev_char != 'n':\n        return False\n    return True\n\nword = input()\nif is_berlanese(word):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    colors = [0] * (n + 1)\n    def dfs(node, color):\n        if colors[node] != 0:\n            return colors[node] == color\n        colors[node] = color\n        for neighbor in graph[node]:\n            if not dfs(neighbor, -color):\n                return False\n        return True\n\n    for node in range(1, n + 1):\n        if colors[node] == 0:\n            if not dfs(node, 1):\n                print(0)\n                return\n\n    print(m)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = set(map(int, sys.stdin.readline().split()))\n\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            if i % 2 == 1:\n                if j > 0:\n                    dp[i][j] = dp[i - 1][j - 1] + a[i - 1]\n                if i in b:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j])\n                dp[i][j] = max(dp[i][j], dp[i - 1][j] - a[i - 1])\n            else:\n                if j > 0:\n                    dp[i][j] = dp[i - 1][j - 1]\n                if i in b:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + a[i - 1])\n                dp[i][j] = max(dp[i][j], dp[i - 1][j])\n\n    print(max(dp[n]))\n\nif __name__ == '__main__':\n    main()"}
{"solution": "# Input\nm = list(map(int, input().split()))\nw = list(map(int, input().split()))\nh = list(map(int, input().split()))\n\n# Problem points\npoints = [500, 1000, 1500, 2000, 2500]\n\n# Calculate score for each problem\nscore = [max(0.3 * points[i], (1 - m[i] / 250) * points[i] - 50 * w[i]) for i in range(5)]\n\n# Calculate total score\ntotal_score = sum(score) + h[0] * 100 - h[1] * 50\n\n# Print the result\nprint(int(total_score))"}
{"solution": "MOD = 998244353\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef find_grids(n, m, L, R):\n    if L == R:\n        return 1\n    if n == 1 or m == 1:\n        return (R - L + 1) % MOD\n    if L + 1 == R:\n        return (power(2, n * m - 1, MOD) * (n * m)) % MOD\n    return (power(2, n * m, MOD) * (R - L + 1)) % MOD\n\nn, m, L, R = map(int, input().split())\nprint(find_grids(n, m, L, R))"}
{"solution": "def check_possible(matrix1, matrix2, n, m):\n    for i in range(n):\n        for j in range(m):\n            if (i > 0 and matrix1[i][j] <= matrix1[i-1][j]) or (j > 0 and matrix1[i][j] <= matrix1[i][j-1]):\n                if (i > 0 and matrix2[i][j] <= matrix2[i-1][j]) or (j > 0 and matrix2[i][j] <= matrix2[i][j-1]):\n                    return False\n            elif (i > 0 and matrix2[i][j] <= matrix2[i-1][j]) or (j > 0 and matrix2[i][j] <= matrix2[i][j-1]):\n                if (i > 0 and matrix1[i][j] <= matrix1[i-1][j]) or (j > 0 and matrix1[i][j] <= matrix1[i][j-1]):\n                    return False\n    return True\n\nn, m = map(int, input().split())\nmatrix1 = [list(map(int, input().split())) for _ in range(n)]\nmatrix2 = [list(map(int, input().split())) for _ in range(n)]\n\nif check_possible(matrix1, matrix2, n, m):\n    print(\"Possible\")\nelse:\n    print(\"Impossible\")"}
{"solution": "# Get the number of letters in the alphabet\nn = int(input())\n\n# Get the list of limitations on the number of occurrences of each character\na = list(map(int, input().split()))\n\n# Sort the list of limitations in descending order\na.sort(reverse=True)\n\n# Initialize the maximum length of the string\nmax_length = 0\n\n# Initialize the number of occurrences of the current character\noccurrences = 1\n\n# Iterate over the sorted list of limitations\nfor i in range(n):\n    # If the current character can be added to the string\n    if occurrences <= a[i]:\n        # Add the current character to the string\n        max_length += occurrences\n        # Increment the number of occurrences of the current character\n        occurrences += 1\n    # If the current character cannot be added to the string\n    else:\n        # Break the loop\n        break\n\n# Print the maximum length of the string\nprint(max_length)"}
{"solution": "n, k = map(int, input().split())\nproblems = list(map(int, input().split()))\nproblems.sort()\n\nextra_problems = 0\nfor problem in problems:\n    if k < problem / 2:\n        extra_problems += 1\n        k = problem\n    else:\n        k = max(k, problem)\n\nprint(extra_problems)"}
{"solution": "def optimize_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3):\n    # Start from the maximum possible number of diplomas of the first degree\n    for first in range(max_1, min_1 - 1, -1):\n        # Check if it's possible to distribute this number of diplomas of the first degree\n        if first > n:\n            continue\n\n        # Start from the maximum possible number of diplomas of the second degree\n        for second in range(max_2, min_2 - 1, -1):\n            # Check if it's possible to distribute this number of diplomas of the second degree\n            if first + second > n:\n                continue\n\n            # Calculate the number of diplomas of the third degree\n            third = n - first - second\n            # Check if it's possible to distribute this number of diplomas of the third degree\n            if third < min_3 or third > max_3:\n                continue\n\n            # If we're here, we've found a valid distribution of diplomas\n            return first, second, third\n\n# Read the input\nn = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\n# Find the optimal distribution of diplomas\nfirst, second, third = optimize_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3)\n\n# Print the output\nprint(first, second, third)"}
{"solution": "# Get the number of days Vitya was watching the moon\nn = int(input())\n\n# Get Vitya's records\nrecords = list(map(int, input().split()))\n\n# Define the moon cycle\nmoon_cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n# Check if the records match the end of the moon cycle\nif records == moon_cycle[-n:]:\n    # If the records match the end of the moon cycle, the size of the visible part of the moon on day n + 1 will be 0\n    print(\"DOWN\")\n# Check if the records match the beginning of the moon cycle\nelif records == moon_cycle[:n]:\n    # If the records match the beginning of the moon cycle, the size of the visible part of the moon on day n + 1 will be 1\n    print(\"UP\")\n# If the records do not match the end or the beginning of the moon cycle, it's impossible to determine what exactly will happen with the moon\nelse:\n    print(\"-1\")"}
{"solution": "def is_transformable(s, t):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    for i in range(len(s)):\n        if s[i] in vowels:\n            if t[i] not in vowels:\n                return False\n        else:\n            if t[i] in vowels:\n                return False\n    return True\n\ns = input()\nt = input()\n\nif is_transformable(s, t):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "# Read the board\nboard = [input() for _ in range(8)]\n\n# Initialize the minimum number of moves for each player\nmin_moves_A = float('inf')\nmin_moves_B = float('inf')\n\n# Iterate over the board\nfor i in range(8):\n    for j in range(8):\n        # If there is a white pawn\n        if board[i][j] == 'W':\n            # Calculate the number of moves to reach the first row\n            moves = i\n            # If there is a black pawn in the same column,\n            # the white pawn cannot reach the first row\n            for k in range(i-1, -1, -1):\n                if board[k][j] == 'B':\n                    moves = float('inf')\n                    break\n            # Update the minimum number of moves for player A\n            min_moves_A = min(min_moves_A, moves)\n        # If there is a black pawn\n        elif board[i][j] == 'B':\n            # Calculate the number of moves to reach the last row\n            moves = 7 - i\n            # If there is a white pawn in the same column,\n            # the black pawn cannot reach the last row\n            for k in range(i+1, 8):\n                if board[k][j] == 'W':\n                    moves = float('inf')\n                    break\n            # Update the minimum number of moves for player B\n            min_moves_B = min(min_moves_B, moves)\n\n# Print the winner\nif min_moves_A <= min_moves_B:\n    print('A')\nelse:\n    print('B')"}
{"solution": "def max_length(A, B):\n    n, m = len(A), len(B)\n    i, j, sum_a, sum_b = 0, 0, 0, 0\n    max_len = 0\n\n    while i < n and j < m:\n        sum_a += A[i]\n        sum_b += B[j]\n\n        if sum_a == sum_b:\n            max_len = max(max_len, i + 1 + m - j - 1)\n            sum_a, sum_b = 0, 0\n            i += 1\n            j += 1\n        elif sum_a < sum_b:\n            i += 1\n        else:\n            j += 1\n\n    return max_len if sum_a == sum_b else -1\n\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\nprint(max_length(A, B))"}
{"solution": "# Get the input string\ns = input()\n\n# List of Alex's friends' names\nfriends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n\n# Initialize a counter for the number of friends' names found in the string\ncount = 0\n\n# Check each friend's name in the string\nfor friend in friends:\n    if friend in s:\n        count += 1\n\n# If exactly one friend's name is found in the string, print \"YES\"\nif count == 1:\n    print(\"YES\")\n# Otherwise, print \"NO\"\nelse:\n    print(\"NO\")"}
{"solution": "def sieve_of_eratosthenes(n):\n    primes = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (primes[p] == True):\n            for i in range(p * p, n+1, p):\n                primes[i] = False\n        p += 1\n    return primes\n\ndef count_primes(a, b, k):\n    primes = sieve_of_eratosthenes(b)\n    primes_count = [0] * (b - a + 2)\n    for i in range(a, b + 1):\n        if primes[i]:\n            primes_count[i - a] = 1\n    for i in range(1, b - a + 1):\n        primes_count[i] += primes_count[i - 1]\n    for l in range(1, b - a + 2):\n        if primes_count[l - 1 + k] - primes_count[l - 1] >= k:\n            return l\n    return -1\n\na, b, k = map(int, input().split())\nprint(count_primes(a, b, k))"}
{"solution": "def calculate_min_distance(a, h, w):\n    # Check if the wall is smaller than the photo\n    if a > h or a > w:\n        return -1\n\n    # Check if the wall is equal to the photo\n    if a == h and a == w:\n        return 0\n\n    # Calculate the maximum number of photos that can fit in the wall\n    max_photos_h = h // a\n    max_photos_w = w // a\n\n    # Calculate the minimum distance\n    min_distance_h = h / (max_photos_h + 1) if max_photos_h > 1 else float('inf')\n    min_distance_w = w / (max_photos_w + 1) if max_photos_w > 1 else float('inf')\n\n    return min(min_distance_h, min_distance_w)\n\n# Read the input\na, h, w = map(int, input().split())\n\n# Calculate the minimum distance\nresult = calculate_min_distance(a, h, w)\n\n# Print the result\nprint(result)"}
{"solution": "# Get the number of chapters\nn = int(input())\n\n# Initialize an empty list to store the chapters\nchapters = []\n\n# Get the chapters\nfor i in range(n):\n    l, r = map(int, input().split())\n    chapters.append((l, r))\n\n# Get the index of the marked page\nk = int(input())\n\n# Initialize a counter for the unread chapters\nunread_chapters = 0\n\n# Iterate over the chapters\nfor l, r in chapters:\n    # If the marked page is after the end of the chapter, the chapter is unread\n    if k > r:\n        unread_chapters += 1\n    # If the marked page is inside the chapter, the chapter is not fully read\n    elif l <= k <= r:\n        unread_chapters += 1\n        break\n\n# Print the number of unread chapters\nprint(unread_chapters)"}
{"solution": "def check_substring(s):\n    target = \"CODEFORCES\"\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            new_s = s[:i] + s[j+1:]\n            if target in new_s:\n                return True\n    return False\n\ns = input()\nif check_substring(s):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\n\n# If the polygon is a triangle, return the product of its vertices\nif n == 3:\n    print(6)\nelse:\n    # If the polygon is not a triangle, it should be divided into two triangles\n    # It's optimal to cut it using diagonal 1-(n//2 + 1)\n    # Calculate the weight of the two triangles and return their sum\n    print(1 * (n // 2) * (n // 2 + 1) + 1 * (n // 2 + 1) * (n % (n // 2 + 1)))"}
{"solution": "# Get the input\nn = int(input())\n\n# Initialize the count of digits\ndigits = 0\n\n# Loop through all numbers from 1 to n\nfor i in range(1, n + 1):\n    # Add the number of digits in the current number to the total count\n    digits += len(str(i))\n\n# Print the result\nprint(digits)"}
{"solution": "n, A = map(int, input().split())\ncars = list(map(int, input().split()))\n\ncount_A = 0\ncount_B = 0\nmax_count_B = 0\nB = -1\n\nfor car in cars:\n    if car == A:\n        count_A += 1\n    else:\n        count_B = cars[:cars.index(car)].count(car) + 1\n        if count_B >= count_A and count_B > max_count_B:\n            max_count_B = count_B\n            B = car\n\nprint(B)"}
{"solution": "# Read the input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate the total length of the segments\ntotal_length = sum(a)\n\n# Calculate the total length of the gaps between segments\ntotal_gaps = n - 1\n\n# Calculate the total length of the crossword\ntotal_crossword_length = total_length + total_gaps\n\n# Check if the total length of the crossword is equal to the length Mishka picked\nif total_crossword_length == x:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n, S = map(int, input().split())\n\ncoins = 0\nwhile S > 0:\n    if S >= n:\n        coins += S // n\n        S %= n\n    else:\n        n -= 1\n\nprint(coins)"}
{"solution": "from collections import Counter\n\ndef min_changes_palindrome(s):\n    counter = Counter(s)\n    odd_chars = [char for char, count in counter.items() if count % 2]\n    if len(odd_chars) > 1:\n        odd_chars.sort()\n        odd_chars = odd_chars[1:]\n    for char in odd_chars:\n        counter[char] -= 1\n    half_palindrome = ''.join(char * (counter[char] // 2) for char in sorted(counter))\n    return half_palindrome + ''.join(odd_chars) + half_palindrome[::-1]\n\ns = input()\nprint(min_changes_palindrome(s))"}
{"solution": "# Define the weights of the chess pieces\nweights = {'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1, 'q': -9, 'r': -5, 'b': -3, 'n': -3, 'p': -1}\n\n# Initialize the total weight of the white and black pieces\nwhite_weight = 0\nblack_weight = 0\n\n# Read the board description\nfor i in range(8):\n    row = input()\n    for piece in row:\n        # If the piece is not empty, add its weight to the total weight\n        if piece != '.':\n            if piece.isupper():\n                white_weight += weights[piece]\n            else:\n                black_weight += weights[piece]\n\n# Determine which player has the larger position weight\nif white_weight > black_weight:\n    print(\"White\")\nelif white_weight < black_weight:\n    print(\"Black\")\nelse:\n    print(\"Draw\")"}
{"solution": "import sys\nfrom collections import deque\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    s = sys.stdin.readline().strip()\n\n    # dp[i] is the minimum number of turns to reach square i\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    # prev[i] is the previous square that leads to square i in the optimal solution\n    prev = [-1] * (n + 1)\n\n    # moves[i] is the move that leads from the previous square to square i in the optimal solution\n    moves = [-1] * (n + 1)\n\n    # q is a deque of squares to process\n    q = deque([0])\n\n    while q:\n        curr = q.popleft()\n        for move in range(1, m + 1):\n            next = curr + move\n            if next > n or s[next] == '1':\n                continue\n            if dp[next] > dp[curr] + 1:\n                dp[next] = dp[curr] + 1\n                prev[next] = curr\n                moves[next] = move\n                q.append(next)\n\n    if dp[n] == float('inf'):\n        print(-1)\n    else:\n        path = []\n        curr = n\n        while curr != 0:\n            path.append(moves[curr])\n            curr = prev[curr]\n        print(*path[::-1])\n\nif __name__ == '__main__':\n    main()"}
{"solution": "def main():\n    K = int(input())\n    X, Y = map(int, input().split())\n\n    if K == 1:\n        print(-1)\n        return\n\n    if (abs(X) + abs(Y)) % 2 != K % 2:\n        print(-1)\n        return\n\n    if abs(X) + abs(Y) <= K:\n        print(1)\n        print(X, Y)\n        return\n\n    if K % 2 == 0:\n        if abs(X) > abs(Y):\n            print(3)\n            print(K, 0)\n            print(X, Y)\n        else:\n            print(3)\n            print(0, K)\n            print(X, Y)\n        return\n\n    print(4)\n    print(K, K)\n    print(K, -K)\n    print(-K, -K)\n    print(X, Y)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_n(m):\n    # Initialize the smallest possible value of n\n    n = 1\n\n    # Loop until we find the smallest possible value of n\n    while True:\n        # Initialize the number of ways to steal the chocolates\n        ways = 0\n\n        # Loop through all possible values of k\n        for k in range(2, 1000):\n            # Calculate the number of chocolates stolen by the first thief\n            first = 1\n\n            # Calculate the number of chocolates stolen by the second thief\n            second = first * k\n\n            # Calculate the number of chocolates stolen by the third thief\n            third = second * k\n\n            # Calculate the number of chocolates stolen by the fourth thief\n            fourth = third * k\n\n            # If the fourth thief stole more than n chocolates, break the loop\n            if fourth > n:\n                break\n\n            # If the fourth thief stole exactly n chocolates, increment the number of ways\n            if fourth == n:\n                ways += 1\n\n        # If we found the smallest possible value of n, return it\n        if ways == m:\n            return n\n\n        # Increment n and continue the loop\n        n += 1\n\n# Read the input value of m\nm = int(input())\n\n# Find the smallest possible value of n\nn = find_n(m)\n\n# Print the output\nprint(n)"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\n    if d > r1 + r2:\n        return 0\n    elif d < abs(r1 - r2):\n        return min(math.pi * r1**2, math.pi * r2**2)\n    else:\n        a = (r1**2 - r2**2 + d**2) / (2 * d)\n        h = math.sqrt(r1**2 - a**2)\n        theta1 = 2 * math.asin(h / r1)\n        theta2 = 2 * math.asin(h / r2)\n        area1 = 0.5 * r1**2 * (theta1 - math.sin(theta1))\n        area2 = 0.5 * r2**2 * (theta2 - math.sin(theta2))\n        return area1 + area2\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\nprint(circle_intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "# Get the input\nv = int(input())\n\n# If v is 1, the minimum value is 1\nif v == 1:\n    print(1)\n# If v is 2, the minimum value is 1\nelif v == 2:\n    print(1)\n# If v is 3, the minimum value is 1\nelif v == 3:\n    print(1)\n# If v is greater than 3, the minimum value is 2\nelse:\n    print(2)"}
{"solution": "import sys\nfrom collections import defaultdict\n\nsys.stdin.readline\n\ndef main():\n    n = int(input())\n    parents = list(map(int, input().split()))\n    citizens = list(map(int, input().split()))\n\n    graph = defaultdict(list)\n    for i, parent in enumerate(parents, 2):\n        graph[parent].append(i)\n\n    def dfs(node):\n        if not graph[node]:\n            return citizens[node - 1]\n        else:\n            children_citizens = [dfs(child) for child in graph[node]]\n            total_children_citizens = sum(children_citizens)\n            min_children_citizens = min(children_citizens)\n            bandit_takes = total_children_citizens - min_children_citizens\n            return bandit_takes + citizens[node - 1]\n\n    print(dfs(1))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\ns = input()\nt = input()\n\n# Check if the words can be obtained from the same word by deleting one character\ndef check(s, t):\n    count = 0\n    for i in range(n):\n        if s[i] != t[i]:\n            count += 1\n            if count > 1:\n                return 0\n            # Check if the remaining part of the words are equal\n            if s[i+1:] == t[i+1:]:\n                return 1\n            if s[i:] == t[i+1:]:\n                return 1\n    return 0\n\nprint(check(s, t))"}
{"solution": "import sys\nimport heapq\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n = int(read_input())\n    strengths = list(map(int, read_input().split()))\n    graph = [[] for _ in range(n)]\n\n    for _ in range(n - 1):\n        u, v = map(int, read_input().split())\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n\n    leaves = [i for i in range(n) if len(graph[i]) == 1]\n    heapq.heapify(leaves)\n    max_strength = 0\n\n    while leaves:\n        node = heapq.heappop(leaves)\n        max_strength = max(max_strength, strengths[node])\n        neighbor = graph[node][0]\n        graph[neighbor].remove(node)\n        strengths[neighbor] += 1\n        if len(graph[neighbor]) == 1:\n            heapq.heappush(leaves, neighbor)\n\n    print(max_strength)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input\nn, m = map(int, input().split())\n\n# Calculate the maximum possible number of groups\nif m == 0:\n    # If no cats have left, there is 1 group consisting of all cats\n    groups = 1\nelif m == n:\n    # If all cats have left, there are 0 groups\n    groups = 0\nelse:\n    # Otherwise, the maximum possible number of groups is m + 1\n    groups = m + 1\n\n# Print the output\nprint(groups)"}
{"solution": "k, r = map(int, input().split())\n\n# Start with buying one shovel\nfor i in range(1, k + 1):\n    # Check if the total price is divisible by 10\n    if (i * k) % 10 == r or (i * k) % 10 == 0:\n        print(i)\n        break"}
{"solution": "import sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(grid, visited, i, j, n, m):\n    if i < 0 or i >= n or j < 0 or j >= m or visited[i][j] or grid[i][j] == '.':\n        return 0\n    visited[i][j] = True\n    return 1 + dfs(grid, visited, i-1, j, n, m) + dfs(grid, visited, i+1, j, n, m) + dfs(grid, visited, i, j-1, n, m) + dfs(grid, visited, i, j+1, n, m)\n\ndef solve():\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n)]\n    visited = [[False]*m for _ in range(n)]\n    size = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X' and not visited[i][j]:\n                size = dfs(grid, visited, i, j, n, m)\n                break\n        if size:\n            break\n    if size % 2 == 0 and (size == n or size == m):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nsolve()"}
{"solution": "# Read the coordinates of the three points\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\n# Check if all points are aligned vertically\nif x1 == x2 == x3:\n    # Sort the points by y-coordinate\n    y1, y2, y3 = sorted([y1, y2, y3])\n    # The minimum number of segments is the difference between the highest and lowest y-coordinates\n    print(y3 - y1)\n# Check if all points are aligned horizontally\nelif y1 == y2 == y3:\n    # Sort the points by x-coordinate\n    x1, x2, x3 = sorted([x1, x2, x3])\n    # The minimum number of segments is the difference between the highest and lowest x-coordinates\n    print(x3 - x1)\n# If the points are not aligned, the minimum number of segments is 2\nelse:\n    print(2)"}
{"solution": "def create_graph(k):\n    if k % 2 != 0:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    n = k + 2\n    m = k * (k + 1) // 2\n    print(n, m)\n\n    for i in range(1, k + 1):\n        print(1, i + 1)\n\n    for i in range(2, k + 1):\n        print(i, i + 1)\n\n    for i in range(k + 2, n + 1):\n        print(i - k, i)\n\n    print(1, k + 2)\n\nk = int(input())\ncreate_graph(k)"}
{"solution": "def z_function(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            z[i] = min(r - i + 1, z[i - l])\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > r:\n            l = i\n            r = i + z[i] - 1\n    return z\n\ndef count_occurrences(s, t):\n    n, m = len(s), len(t)\n    concat = t + '#' + s\n    z = z_function(concat)\n    return [z[i:i+m].count(m) for i in range(m+1, n+m+1)]\n\nn, m, q = map(int, input().split())\ns = input()\nt = input()\nqueries = [list(map(int, input().split())) for _ in range(q)]\n\noccurrences = count_occurrences(s, t)\nfor l, r in queries:\n    print(occurrences[r-1] - (occurrences[l-2] if l > 1 else 0))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, k, d):\n    dp = [[0] * (n + 1) for _ in range(k + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, k + 1):\n        for j in range(n + 1):\n            for l in range(1, min(j, i) + 1):\n                if l >= d:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD\n\n    return sum(dp[k][n - d + 1:]) % MOD\n\nn, k, d = map(int, input().split())\nprint(solve(n, k, d))"}
{"solution": "n = int(input())\nrow = input()\n\nblack_squares = []\ncount = 0\n\nfor i in range(n):\n    if row[i] == 'B':\n        count += 1\n    elif row[i] == 'W' and count > 0:\n        black_squares.append(count)\n        count = 0\n\nif count > 0:\n    black_squares.append(count)\n\nprint(len(black_squares))\nprint(' '.join(map(str, black_squares)))"}
{"solution": "def solve(n, m, p, sequence, operations):\n    stack = []\n    for i in range(n):\n        if sequence[i] == '(':\n            stack.append(i)\n        else:\n            j = stack.pop()\n            sequence[i] = j\n            sequence[j] = i\n\n    cursor = p - 1\n    for op in operations:\n        if op == 'L':\n            cursor -= 1\n        elif op == 'R':\n            cursor += 1\n        else:\n            j = sequence[cursor]\n            sequence[cursor] = -1\n            sequence[j] = -1\n            if j < cursor:\n                cursor = j\n            else:\n                while cursor < n and sequence[cursor] == -1:\n                    cursor += 1\n                if cursor == n:\n                    cursor = j - 1\n\n    result = []\n    for i in range(n):\n        if sequence[i] != -1:\n            result.append(sequence[i])\n    return ''.join(result)\n\nn, m, p = map(int, input().split())\nsequence = list(input())\noperations = input()\nprint(solve(n, m, p, sequence, operations))"}
{"solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    lower_bound = -2 * 10**9\n    upper_bound = 2 * 10**9\n\n    for _ in range(n):\n        query = sys.stdin.readline().split()\n        sign = query[0]\n        x = int(query[1])\n        answer = query[2]\n\n        if answer == 'Y':\n            if sign == '>':\n                lower_bound = max(lower_bound, x + 1)\n            elif sign == '<':\n                upper_bound = min(upper_bound, x - 1)\n            elif sign == '>=':\n                lower_bound = max(lower_bound, x)\n            elif sign == '<=':\n                upper_bound = min(upper_bound, x)\n        else:\n            if sign == '>':\n                upper_bound = min(upper_bound, x)\n            elif sign == '<':\n                lower_bound = max(lower_bound, x)\n            elif sign == '>=':\n                upper_bound = min(upper_bound, x - 1)\n            elif sign == '<=':\n                lower_bound = max(lower_bound, x + 1)\n\n    if lower_bound <= upper_bound:\n        print(lower_bound)\n    else:\n        print('Impossible')\n\nif __name__ == '__main__':\n    main()"}
{"solution": "import math\n\ndef count_periods(a, b):\n    total_length = a + b\n    periods = set()\n\n    for i in range(1, int(math.sqrt(total_length)) + 1):\n        if total_length % i == 0:\n            periods.add(i)\n            periods.add(total_length // i)\n\n    for i in range(1, total_length):\n        if a % i == b % i:\n            periods.add(i)\n\n    return len(periods)\n\na, b = map(int, input().split())\nprint(count_periods(a, b))"}
{"solution": "def find_names(n, k, notes):\n    names = ['A'] * n\n    for i in range(n - k + 1):\n        if notes[i] == 'YES':\n            for j in range(i, i + k):\n                if names[j] == 'A':\n                    names[j] = chr(ord('A') + j)\n    return names\n\nn, k = map(int, input().split())\nnotes = input().split()\nnames = find_names(n, k, notes)\nprint(' '.join(names))"}
{"solution": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef count_steps(a, b):\n    if a == b:\n        return 0\n    if a < b:\n        a, b = b, a\n    if a % b == 0 or a % 2 != 0 and a % 3 != 0 and a % 5 != 0:\n        return -1\n    if a % 2 == 0:\n        return 1 + count_steps(a // 2, b)\n    if a % 3 == 0:\n        return 1 + count_steps(2 * a // 3, b)\n    if a % 5 == 0:\n        return 1 + count_steps(4 * a // 5, b)\n    return 1 + count_steps(a - b, b)\n\na, b = map(int, input().split())\nprint(count_steps(a, b))"}
{"solution": "def min_cost(n, a, b, suits):\n    cost = 0\n    for i in range(n // 2):\n        if suits[i] == 2 and suits[n - i - 1] == 2:\n            cost += min(a, b) * 2\n        elif suits[i] == 2:\n            cost += a if suits[n - i - 1] == 0 else b\n        elif suits[n - i - 1] == 2:\n            cost += a if suits[i] == 0 else b\n        elif suits[i] != suits[n - i - 1]:\n            return -1\n    if n % 2 == 1 and suits[n // 2] == 2:\n        cost += min(a, b)\n    return cost\n\nn, a, b = map(int, input().split())\nsuits = list(map(int, input().split()))\nprint(min_cost(n, a, b, suits))"}
{"solution": "def print_cube(k):\n    if k % 2 != 0:\n        print(-1)\n        return\n\n    for i in range(k):\n        for j in range(k):\n            if (i // 2 + j // 2) % 2 == 0:\n                print('w', end='')\n            else:\n                print('b', end='')\n        print()\n\nk = int(input())\nprint_cube(k)"}
{"solution": "import math\n\ndef biggest_lovely_number(n):\n    i = int(math.sqrt(n))\n    while i > 1:\n        if n % (i * i) == 0:\n            n //= (i * i)\n        i -= 1\n    return n\n\nn = int(input())\nprint(biggest_lovely_number(n))"}
{"solution": "n = int(input())\nseating = input()\n\n# Check if the first or last seat is occupied\nif seating[0] == '1' or seating[-1] == '1':\n    print(\"No\")\nelse:\n    # Check if there are any two adjacent occupied seats\n    for i in range(1, n - 1):\n        if seating[i] == '1' and seating[i - 1] == '1':\n            print(\"No\")\n            break\n    else:\n        # Check if there is an empty seat between two occupied seats\n        if '101' in seating:\n            print(\"No\")\n        else:\n            print(\"Yes\")"}
{"solution": "# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the list of possible lengths\npossible_lengths = []\n\n# Iterate over all possible lengths\nfor k in range(1, n + 1):\n    # Initialize the list x\n    x = [0] * k\n\n    # Calculate the elements of x\n    for i in range(1, n + 1):\n        x[(i - 1) % k] = a[i - 1] - a[i - 2]\n\n    # Check if x satisfies the requirements\n    valid = True\n    for i in range(1, n + 1):\n        if a[i - 1] != x[(i - 1) % k] + a[i - 2]:\n            valid = False\n            break\n\n    # If x satisfies the requirements, add k to the list of possible lengths\n    if valid:\n        possible_lengths.append(k)\n\n# Print the output\nprint(len(possible_lengths))\nprint(' '.join(map(str, possible_lengths)))"}
{"solution": "# Get the input scores\nscores = list(map(int, input().split()))\n\n# Calculate the total sum of scores\ntotal_sum = sum(scores)\n\n# Check if the total sum is odd, if so, it's impossible to split into two equal teams\nif total_sum % 2 != 0:\n    print(\"NO\")\nelse:\n    # If the total sum is even, try to find a subset of scores that sum up to half of the total sum\n    target_sum = total_sum // 2\n    # Sort the scores in descending order\n    scores.sort(reverse=True)\n    # Initialize the current sum and the index\n    current_sum = 0\n    index = 0\n    # Iterate over the scores\n    while index < len(scores) and current_sum < target_sum:\n        # Add the current score to the current sum\n        current_sum += scores[index]\n        # Move to the next score\n        index += 1\n    # Check if the current sum is equal to the target sum\n    if current_sum == target_sum:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "def count_2_3_integers(l, r):\n    # Initialize the count of 2-3 integers\n    count = 0\n\n    # Iterate over all possible powers of 2 and 3\n    i = 1\n    while i <= r:\n        j = i\n        while j <= r:\n            # If the number is within the range, increment the count\n            if l <= j <= r:\n                count += 1\n            # Multiply the current power of 2 by 3\n            j *= 3\n        # Multiply the current power of 2 by 2\n        i *= 2\n\n    return count\n\n# Read the input\nl, r = map(int, input().split())\n\n# Print the result\nprint(count_2_3_integers(l, r))"}
{"solution": "n, k = map(int, input().split())\n\n# The total number of candies Alya put in the box is the sum of numbers from 1 to n\ntotal_put = n * (n + 1) // 2\n\n# The total number of candies Alya ate is the total number of candies put in the box minus the number of candies in the box at the end\ntotal_ate = total_put - k\n\nprint(total_ate)"}
{"solution": "# Read the number of line segments\nn = int(input())\n\n# Read the lengths of line segments\nsegments = list(map(int, input().split()))\n\n# Sort the lengths of line segments\nsegments.sort()\n\n# Check if the sum of the lengths of the two smallest line segments is greater than the length of the largest line segment\nif segments[n - 3] + segments[n - 2] > segments[n - 1]:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "x, y = map(int, input().split())\n\n# If the number of original toys is less than the number of copies, it's not possible\nif y < x:\n    print(\"No\")\n# If the number of copies is odd, it's not possible\nelif x % 2 != 0:\n    print(\"No\")\n# If the number of original toys is less than half the number of copies, it's not possible\nelif y < x // 2:\n    print(\"No\")\n# If the number of original toys is equal to half the number of copies, it's possible\nelif y == x // 2:\n    print(\"Yes\")\n# If the number of original toys is greater than half the number of copies, it's possible\nelse:\n    print(\"Yes\")"}
{"solution": "# Read input\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Calculate initial rating\nrating = sum(skill // 10 for skill in skills)\n\n# Sort skills in ascending order\nskills.sort()\n\n# Use improvement units to increase skills\nfor i in range(n):\n    if k == 0:\n        break\n    # Calculate how many units are needed to increase the skill to the next level\n    units_needed = 10 - skills[i] % 10\n    if units_needed == 0:\n        continue\n    # Use all available units or just enough to increase the skill to the next level\n    units_used = min(k, units_needed)\n    skills[i] += units_used\n    k -= units_used\n    # Recalculate rating\n    rating = sum(skill // 10 for skill in skills)\n\n# Print the result\nprint(rating)"}
{"solution": "# Read input\nn, m = map(int, input().split())\na = set(map(int, input().split()))\nb = set(map(int, input().split()))\n\n# Find the smallest pretty integer\nfor i in range(1, 10000):\n    if any(digit in a for digit in str(i)) and any(digit in b for digit in str(i)):\n        print(i)\n        break"}
{"solution": "# Get the input\nn, k = map(int, input().split())\n\n# Calculate the total time available for solving problems\ntotal_time = 240 - k\n\n# Initialize the number of problems Limak can solve\nproblems_solved = 0\n\n# Initialize the time taken to solve problems\ntime_taken = 0\n\n# Loop through the problems\nfor i in range(1, n + 1):\n    # Calculate the time required to solve the current problem\n    problem_time = 5 * i\n\n    # If Limak has enough time to solve the problem\n    if time_taken + problem_time <= total_time:\n        # Update the time taken and the number of problems solved\n        time_taken += problem_time\n        problems_solved += 1\n\n# Print the maximum possible number of problems Limak can solve\nprint(problems_solved)"}
{"solution": "n, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\n# sort the list in descending order\na.sort(reverse=True)\n\n# initialize the number of teams that can be printed\nteams = 0\n\n# iterate over the list\nfor i in range(n):\n    # if the current team's task set can be printed using double-sided sheets\n    if a[i] <= 2 * x:\n        # update the number of teams that can be printed\n        teams += 1\n        # update the number of double-sided sheets\n        x -= a[i] // 2\n        # if the current team's task set has an odd number of pages\n        if a[i] % 2 == 1:\n            # use a single-sided sheet\n            y -= 1\n    # if the current team's task set can be printed using a single-sided sheet\n    elif a[i] <= y:\n        # update the number of teams that can be printed\n        teams += 1\n        # update the number of single-sided sheets\n        y -= a[i]\n    # if the current team's task set cannot be printed\n    else:\n        break\n\n# print the result\nprint(teams)"}
{"solution": "import math\n\ndef count_unique_fractions(b):\n    # Initialize the count of unique fractions to 1\n    count = 1\n\n    # Find the square root of b\n    sqrt_b = int(math.sqrt(b))\n\n    # Loop through all numbers from 2 to the square root of b\n    for i in range(2, sqrt_b + 1):\n        # If i is a factor of b, add it to the count of unique fractions\n        if b % i == 0:\n            count += 1\n            # Divide b by i until it is no longer a factor\n            while b % i == 0:\n                b //= i\n\n    # If b is greater than 1, add it to the count of unique fractions\n    if b > 1:\n        count += 1\n\n    # Return the count of unique fractions\n    return count\n\n# Read the input value of b\nb = int(input())\n\n# Print the number of unique fractions\nprint(count_unique_fractions(b))"}
{"solution": "# Read the input\nn = int(input())\nbumpers = input()\n\n# Initialize the count of positions where the ball will fall off\ncount = 0\n\n# Iterate over the bumpers\nfor i in range(n):\n    # Initialize the current position of the ball\n    pos = i\n\n    # Simulate the movement of the ball\n    while 0 <= pos < n:\n        if bumpers[pos] == '<':\n            pos -= 1\n        else:\n            pos += 1\n\n        # If the ball falls off the field, increment the count and break the loop\n        if pos < 0 or pos >= n:\n            count += 1\n            break\n\n# Print the result\nprint(count)"}
{"solution": "from collections import Counter\n\ndef max_rectangle_area(n, sticks):\n    counter = Counter(sticks)\n    pairs = 0\n    for length, count in counter.items():\n        pairs += count // 2\n    width = pairs // 2 * 2\n    length = min(counter[width], counter[width + 1]) if width + 1 in counter else 0\n    return width * length\n\nn = int(input())\nsticks = list(map(int, input().split()))\nprint(max_rectangle_area(n, sticks))"}
{"solution": "# Read the number of strings\nn = int(input())\n\n# Read the strings\nstrings = [input() for _ in range(n)]\n\n# Create a dictionary to store the sum of weights of each character\n# where weight of a character is its position in the number * 10^(max_length - position)\n# Initialize all weights to 0\nweights = {chr(i + 97): 0 for i in range(10)}\n\n# Calculate the maximum length of the strings\nmax_length = max(len(s) for s in strings)\n\n# Calculate the weights\nfor s in strings:\n    for i in range(len(s)):\n        weights[s[i]] += 10 ** (max_length - i)\n\n# Sort the characters by their weights\nsorted_chars = sorted(weights.keys(), key=lambda x: weights[x])\n\n# Assign the digits to the characters\ndigits = {sorted_chars[i]: str(i) for i in range(10)}\n\n# Calculate the sum of the restored numbers\ntotal_sum = 0\nfor s in strings:\n    # Replace the characters with digits\n    num = ''.join(digits[c] for c in s)\n    # Convert the string to an integer and add it to the total sum\n    total_sum += int(num)\n\n# Print the total sum\nprint(total_sum)"}
{"solution": "# Get the input\nn, m = map(int, input().split())\n\n# Initialize the number of teams\nteams = 0\n\n# While there are enough newbies for a team of one experienced and two newbies\nwhile n > 0 and m >= 2:\n    # Form a team\n    teams += 1\n    # Decrease the number of newbies by 2\n    m -= 2\n    # Decrease the number of experienced members by 1\n    n -= 1\n\n# While there are enough newbies for a team of two experienced and one newbie\nwhile n >= 2 and m > 0:\n    # Form a team\n    teams += 1\n    # Decrease the number of newbies by 1\n    m -= 1\n    # Decrease the number of experienced members by 2\n    n -= 2\n\n# Print the number of teams\nprint(teams)"}
{"solution": "def check_string(s):\n    # Check for AB...BA\n    if 'AB' in s:\n        first_index = s.index('AB')\n        if 'BA' in s[first_index+2:]:\n            return 'YES'\n\n    # Check for BA...AB\n    if 'BA' in s:\n        first_index = s.index('BA')\n        if 'AB' in s[first_index+2:]:\n            return 'YES'\n\n    return 'NO'\n\n# Get the input string\ns = input()\n\n# Print the result\nprint(check_string(s))"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    k = int(input())\n    b = list(map(int, input().split()))\n\n    eatings = []\n    while len(a) > k:\n        for i in range(len(a)):\n            if i > 0 and a[i] > a[i - 1]:\n                a[i] += a[i - 1]\n                a.pop(i - 1)\n                eatings.append(f\"{i + 1} L\")\n                break\n            elif i < len(a) - 1 and a[i] > a[i + 1]:\n                a[i] += a[i + 1]\n                a.pop(i + 1)\n                eatings.append(f\"{i + 1} R\")\n                break\n        else:\n            print(\"NO\")\n            return\n\n    if a == b:\n        print(\"YES\")\n        print(\"\\n\".join(eatings))\n    else:\n        print(\"NO\")\n\nsolve()"}
{"solution": "import sys\nfrom collections import deque\n\ndef bfs(graph, matchR, matchL, n):\n    queue = deque()\n    for i in range(n):\n        if matchR[i] == -1:\n            queue.append(i)\n            dist[i] = 0\n        else:\n            dist[i] = float('inf')\n    dist[-1] = float('inf')\n\n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            if dist[matchL[v]] == float('inf'):\n                dist[matchL[v]] = dist[u] + 1\n                queue.append(matchL[v])\n\n    return dist[-1] != float('inf')\n\ndef dfs(graph, matchR, matchL, u):\n    for v in graph[u]:\n        if matchL[v] == -1 or dfs(graph, matchR, matchL, matchL[v]):\n            matchL[v] = u\n            matchR[u] = v\n            return True\n    return False\n\ndef maxBipartiteMatch(graph, n):\n    matchR = [-1] * n\n    matchL = [-1] * n\n\n    while bfs(graph, matchR, matchL, n):\n        for i in range(n):\n            if matchR[i] == -1 and dfs(graph, matchR, matchL, i):\n                break\n\n    return sum(i != -1 for i in matchR)\n\ndef canFormLine(rebels, bases):\n    graph = [[] for _ in range(len(rebels))]\n    for i, (x1, y1) in enumerate(rebels):\n        for j, (x2, y2) in enumerate(bases):\n            if (x1 - x2) * (y1 - y2) > 0:\n                graph[i].append(j)\n    return maxBipartiteMatch(graph, len(rebels)) == len(rebels)\n\nR, B = map(int, sys.stdin.readline().split())\nrebels = [tuple(map(int, sys.stdin.readline().split())) for _ in range(R)]\nbases = [tuple(map(int, sys.stdin.readline().split())) for _ in range(B)]\n\nprint(\"Yes\" if canFormLine(rebels, bases) else \"No\")"}
{"solution": "n = int(input())\nnumbers = list(map(int, input().split()))\n\nmax_power = 0\ncount = 0\n\nfor num in numbers:\n    power = 0\n    while num % 2 == 0:\n        num //= 2\n        power += 1\n    if power > max_power:\n        max_power = power\n        count = 1\n    elif power == max_power:\n        count += 1\n\nprint(2**max_power, count)"}
{"solution": "# Get the input\nn, m = map(int, input().split())\n\n# Initialize the number of clicks\nclicks = 0\n\n# While n is not equal to m\nwhile n != m:\n    # If m is greater than n and m is even\n    if m > n and m % 2 == 0:\n        # Divide m by 2\n        m //= 2\n        # Increment the number of clicks\n        clicks += 1\n    # Otherwise\n    else:\n        # Decrement m\n        m -= 1\n        # Increment the number of clicks\n        clicks += 1\n\n# Print the number of clicks\nprint(clicks)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n = int(read_input())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, read_input().split())\n        segments.append((l, r, _))\n    segments.sort()\n\n    parent = list(range(n))\n    rank = [0] * n\n\n    def find(i):\n        if parent[i] != i:\n            parent[i] = find(parent[i])\n        return parent[i]\n\n    def union(i, j):\n        pi, pj = find(i), find(j)\n        if pi == pj:\n            return False\n        if rank[pi] > rank[pj]:\n            parent[pj] = pi\n        elif rank[pi] < rank[pj]:\n            parent[pi] = pj\n        else:\n            parent[pj] = pi\n            rank[pi] += 1\n        return True\n\n    last = [-1] * (2 * n + 1)\n    for l, r, i in segments:\n        j = last[l]\n        if j != -1 and segments[j][1] > l:\n            if not union(i, j):\n                print(\"NO\")\n                return\n        j = last[r]\n        if j != -1 and segments[j][1] > r:\n            if not union(i, j):\n                print(\"NO\")\n                return\n        last[l] = last[r] = i\n\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\nrequests = list(map(int, input().split()))\n\nmax_length = 0\ncurrent_length = 0\n\nfor i in range(n):\n    if requests[i] > 100 * (i + 1 - current_length):\n        current_length = i + 1\n    else:\n        max_length = max(max_length, current_length - max(0, i - 100 * (i + 1)))\n        current_length = i + 1\n\nmax_length = max(max_length, current_length - max(0, n - 100 * n))\n\nprint(max_length)"}
{"solution": "def check_dissatisfaction(n, k, episodes):\n    max_consecutive_missed = 0\n    current_consecutive_missed = 0\n\n    for i in range(n):\n        if episodes[i] == 'N':\n            current_consecutive_missed += 1\n        else:\n            max_consecutive_missed = max(max_consecutive_missed, current_consecutive_missed)\n            current_consecutive_missed = 0\n\n    max_consecutive_missed = max(max_consecutive_missed, current_consecutive_missed)\n\n    if max_consecutive_missed == k:\n        return \"YES\"\n    elif max_consecutive_missed < k:\n        if '?' in episodes and episodes.count('?') >= k - max_consecutive_missed:\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        return \"NO\"\n\nn, k = map(int, input().split())\nepisodes = input()\nprint(check_dissatisfaction(n, k, episodes))"}
{"solution": "# Read the input\nN, X, D = map(int, input().split())\n\n# Calculate the last element of the sequence\nlast_element = X + D * (N - 1)\n\n# If D is 0, there is only one possible value of S - T\nif D == 0:\n    print(1)\n# If D is not 0, there are 2 * N possible values of S - T\nelse:\n    # Calculate the sum of all elements in the sequence\n    total_sum = N * (X + last_element) // 2\n\n    # Calculate the maximum possible value of S - T\n    max_diff = abs(total_sum - X)\n\n    # Calculate the minimum possible value of S - T\n    min_diff = abs(total_sum - last_element)\n\n    # Calculate the number of possible values of S - T\n    num_possible_values = max_diff - min_diff + 1\n\n    # Print the result\n    print(num_possible_values)"}
{"solution": "n = int(input())\ngood_performance = False\n\nfor _ in range(n):\n    name, before, after = input().split()\n    before = int(before)\n    after = int(after)\n\n    if before >= 2400 and after > before:\n        good_performance = True\n\nif good_performance:\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "# Get the binary input from the user\ns = input()\n\n# Convert the binary input to an integer\ns = int(s, 2)\n\n# Initialize the count of trains missed\ncount = 0\n\n# Initialize the current train departure time\ntrain_time = 1\n\n# While the train departure time is less than the current time\nwhile train_time < s:\n    # Increment the count of trains missed\n    count += 1\n\n    # Calculate the next train departure time\n    train_time *= 4\n\n# Print the number of trains missed\nprint(count)"}
{"solution": "# Get the input\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Initialize the minimum number of rows\nmin_rows = n\n\n# Iterate over all possible numbers of rows\nfor i in range(1, n // 2 + 1):\n    # Check if the matrix can be mirrored to get the top i rows\n    if matrix[:i] == matrix[i:2*i][::-1]:\n        # Update the minimum number of rows\n        min_rows = i\n        break\n\n# Print the result\nprint(min_rows)"}
{"solution": "# Read the number of orders\nn = int(input())\n\n# Create a list to store the orders\norders = []\n\n# Read the orders and store them in the list\nfor _ in range(n):\n    l, r = map(int, input().split())\n    orders.append((l, r))\n\n# Sort the orders by their finish time\norders.sort(key=lambda x: x[1])\n\n# Initialize the count of accepted orders and the finish time of the last accepted order\ncount = 1\nlast_finish = orders[0][1]\n\n# Iterate over the orders\nfor i in range(1, n):\n    # If the current order starts after the last accepted order finishes, accept it\n    if orders[i][0] >= last_finish:\n        count += 1\n        last_finish = orders[i][1]\n\n# Print the maximal number of orders that can be accepted\nprint(count)"}
{"solution": "def solve(n, k, x, y):\n    tables, formulas = 0, 0\n    for i in range(n):\n        if tables + x[i] > k or formulas + y[i] > k:\n            return \"NO\"\n        tables = min(k, tables + x[i])\n        formulas = min(k, formulas + y[i])\n        if i < n - 1:\n            tables = max(0, tables + x[i] - k)\n            formulas = max(0, formulas + y[i] - k)\n    return \"YES\"\n\nn, k = map(int, input().split())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\nprint(solve(n, k, x, y))"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n, k = map(int, read_input().split())\n    a = [int(read_input()) if read_input() != '?' else None for _ in range(n + 1)]\n\n    # If it's computer's turn and there's no unknown coefficient,\n    # the game is already over.\n    if all(coeff is not None for coeff in a):\n        return 'No' if any((a[i] - a[i - 1]) % k == 0 for i in range(1, n + 1)) else 'Yes'\n\n    # If there are unknown coefficients, human can always win by setting\n    # the coefficient to a value that makes the difference between\n    # consecutive coefficients not divisible by k.\n    for i in range(n + 1):\n        if a[i] is None:\n            if i == 0 or (a[i - 1] - a[i - 2]) % k != 1:\n                a[i] = a[i - 1] + 1 if i > 0 else 0\n            else:\n                a[i] = a[i - 1] - 1\n\n    return 'Yes'\n\nprint(main())"}
{"solution": "def smallest_prime_factor(n):\n    spf = [0 for i in range(n+1)]\n    spf[1] = 1\n    for i in range(2, n+1):\n        spf[i] = i\n    for i in range(4, n+1, 2):\n        spf[i] = 2\n    for i in range(3, int(n**0.5)+1):\n        if spf[i] == i:\n            for j in range(i * i, n + 1, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\n\ndef solve(x):\n    spf = smallest_prime_factor(x)\n    p = spf[x]\n    q = x // p\n    if q == 1:\n        return p\n    else:\n        return p * q\n\nx = int(input())\nprint(solve(x))"}
{"solution": "n, p = map(int, input().split())\n\n# Check if it is impossible to represent n\nif n < p and p > 0:\n    print(-1)\nelse:\n    # Initialize the count of p-binary numbers\n    count = 0\n\n    # Loop until n becomes less than p\n    while n >= p:\n        # Find the largest power of 2 that is less than or equal to n - p\n        x = 0\n        while (1 << (x + 1)) <= n - p:\n            x += 1\n\n        # Subtract the p-binary number from n\n        n -= (1 << x) + p\n\n        # Increment the count\n        count += 1\n\n    # If n is not zero, it means that we need one more p-binary number\n    if n != 0:\n        count += 1\n\n    print(count)"}
{"solution": "n, k = map(int, input().split())\ns = list(input())\n\n# If the first digit is not 1, change it to 1\nif s[0] != '1' and k > 0:\n    s[0] = '1'\n    k -= 1\n\n# Change the remaining digits to 0\nfor i in range(1, n):\n    if s[i] != '0' and k > 0:\n        s[i] = '0'\n        k -= 1\n\nprint(''.join(s))"}
{"solution": "def sieve_of_eratosthenes(n):\n    primes = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (primes[p] == True):\n            for i in range(p * p, n+1, p):\n                primes[i] = False\n        p += 1\n    return primes\n\ndef count_numbers(cnt1, cnt2, x, y):\n    primes = sieve_of_eratosthenes(30000)\n    v = 1\n    while True:\n        if primes[v]:\n            cnt1_numbers = v - v//x\n            cnt2_numbers = v - v//y\n            if cnt1_numbers >= cnt1 and cnt2_numbers >= cnt2:\n                return v\n        v += 1\n\ncnt1, cnt2, x, y = map(int, input().split())\nprint(count_numbers(cnt1, cnt2, x, y))"}
{"solution": "def bear_position(n, sx, sy, dx, dy, t):\n    # Calculate the number of times the bear moves through the field\n    moves = t // (2 * n)\n\n    # Calculate the remaining time after moving through the field\n    t %= 2 * n\n\n    # Calculate the new speed of the bear after moving through the field\n    dx += moves * (dx + dy)\n    dy += moves * (dx + dy)\n\n    # Calculate the new position of the bear after moving through the field\n    sx = ((sx + dx - 1) % n) + 1\n    sy = ((sy + dy - 1) % n) + 1\n\n    # Calculate the number of raspberry bushes the bear eats in the remaining time\n    raspberries = (sx + sy - 2) * moves + t\n\n    # Calculate the new speed of the bear after eating the raspberries\n    dx += raspberries\n    dy += raspberries\n\n    # Calculate the new position of the bear after eating the raspberries\n    sx = ((sx + dx - 1) % n) + 1\n    sy = ((sy + dy - 1) % n) + 1\n\n    return sx, sy\n\n# Read the input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Calculate the final position of the bear\nfinal_position = bear_position(n, sx, sy, dx, dy, t)\n\n# Print the final position of the bear\nprint(*final_position)"}
{"solution": "def solve(s):\n    n = len(s)\n    if n < 26:\n        return -1\n\n    alphabet = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    missing = alphabet.copy()\n    result = list(s)\n\n    for i in range(n):\n        if s[i] != '?':\n            missing.discard(s[i])\n\n    for i in range(n):\n        if s[i] == '?':\n            for c in missing:\n                if i + 26 < n and all(c not in s[i+1:i+26] for c in missing):\n                    result[i] = c\n                    missing.remove(c)\n                    break\n\n    if missing:\n        return -1\n    return ''.join(result)\n\ns = input()\nprint(solve(s))"}
{"solution": "n = int(input())\nweights = list(map(int, input().split()))\n\ncount_100 = weights.count(100)\ncount_200 = weights.count(200)\n\nif count_100 % 2 == 0 and (count_100 > 0 or count_200 % 2 == 0):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_time(n, m, building):\n    dp = [[0] * (m + 2) for _ in range(n)]\n    for i in range(n):\n        for j in range(m + 2):\n            if building[i][j] == '1':\n                if i == 0:\n                    dp[i][j] = j\n                else:\n                    dp[i][j] = min(dp[i - 1][k] for k in range(m + 2)) + abs(k - j)\n    return min(dp[-1])\n\nn, m = map(int, input().split())\nbuilding = [input() for _ in range(n)]\nprint(min_time(n, m, building))"}
{"solution": "import sys\nfrom typing import List\n\nread_input = sys.stdin.readline\n\ndef find_min_cost(n: int, costs: List[int], moves: List[int]) -> int:\n    visited = [False] * n\n    min_costs = [float('inf')] * n\n\n    for i in range(n):\n        if visited[i]:\n            continue\n\n        cycle = []\n        j = i\n        while not visited[j]:\n            visited[j] = True\n            cycle.append(j)\n            j = moves[j] - 1\n\n        min_cycle_cost = min(costs[k] for k in cycle)\n        for k in cycle:\n            min_costs[k] = min_cycle_cost\n\n    return sum(min_costs)\n\ndef main() -> None:\n    n = int(read_input())\n    costs = list(map(int, read_input().split()))\n    moves = list(map(int, read_input().split()))\n\n    min_cost = find_min_cost(n, costs, moves)\n    print(min_cost)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input\nn, a, b = map(int, input().split())\n\n# Calculate the final position\nfinal_position = (a + b - 1) % n\n\n# If the final position is 0, it means Vasya is at the last entrance\nif final_position == 0:\n    final_position = n\n\n# Print the result\nprint(final_position)"}
{"solution": "def min_arithmetic_progressions(arr):\n    n = len(arr)\n    dp = [0] * n\n    last = [-1] * n\n\n    for i in range(n):\n        dp[i] = dp[i-1] + 1\n        j = i - 1\n        while j >= 0 and (arr[j] == -1 or arr[i] == -1 or arr[i] - arr[j] == arr[i//2] - arr[j//2]):\n            if last[j] == -1 or last[j] == arr[j] - arr[j//2]:\n                dp[i] = min(dp[i], dp[j-1] + 1)\n                last[i] = arr[i] - arr[j]\n                break\n            j -= 1\n\n    return dp[n-1]\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(min_arithmetic_progressions(arr))"}
{"solution": "def max_beauty(n, k, s):\n    max_len = 0\n    curr_len = 1\n    for i in range(1, n):\n        if s[i] == s[i-1]:\n            curr_len += 1\n        else:\n            max_len = max(max_len, curr_len)\n            curr_len = 1\n    max_len = max(max_len, curr_len)\n    return min(n, max_len + k)\n\nn, k = map(int, input().split())\ns = input()\nprint(max_beauty(n, k, s))"}
{"solution": "n = int(input())\nseats = list(map(int, input().split()))\n\n# Calculate the total number of seats\ntotal_seats = sum(seats)\n\n# Check if Alice's party can form a coalition on its own\nif seats[0] > total_seats // 2:\n    print(1)\n    print(1)\nelse:\n    # Sort the other parties based on the number of seats\n    other_parties = sorted([(seats[i], i + 1) for i in range(1, n)])\n\n    # Try to form a coalition with other parties\n    coalition_seats = seats[0]\n    coalition_parties = [1]\n    for party in other_parties:\n        if party[0] * 2 <= seats[0] and coalition_seats + party[0] > total_seats // 2:\n            coalition_seats += party[0]\n            coalition_parties.append(party[1])\n\n    # Print the result\n    if coalition_seats > total_seats // 2:\n        print(len(coalition_parties))\n        print(' '.join(map(str, coalition_parties)))\n    else:\n        print(0)"}
{"solution": "# Read the number of opponents\nn = int(input())\n\n# Initialize the total reward\ntotal_reward = 0.0\n\n# Calculate the total reward\nwhile n > 0:\n    total_reward += 1 / n\n    n -= 1\n\n# Print the maximum prize\nprint(\"{:.12f}\".format(total_reward))"}
{"solution": "n = int(input())\n\n# Initialize the number of children and the list of candies each child gets\nk = 0\ncandies = []\n\n# While Santa still has candies left\nwhile n > 0:\n    # Increase the number of children\n    k += 1\n    # Give the child the smallest possible number of candies that hasn't been given yet\n    candies.append(min(k, n))\n    # Subtract the number of candies given to the child from the total number of candies\n    n -= min(k, n)\n\n# Print the maximum number of children that can get candies\nprint(k)\n# Print the number of candies each child gets\nprint(' '.join(map(str, candies)))"}
{"solution": "# Read the input\nn = int(input())\nm = int(input())\n\n# Calculate m mod 2^n\nresult = m % (2 ** n)\n\n# Print the result\nprint(result)"}
{"solution": "# Get the length of the word\nn = int(input())\n\n# Get the word\ns = input()\n\n# Define the vowels\nvowels = 'aeiouy'\n\n# Initialize the corrected word\ncorrected_word = ''\n\n# Iterate over the word\nfor i in range(n):\n    # If the current character is a vowel and the previous character is not a vowel or it's the first character\n    if s[i] in vowels and (i == 0 or s[i - 1] not in vowels):\n        # Add the current character to the corrected word\n        corrected_word += s[i]\n    # If the current character is not a vowel or it's a vowel but the previous character is not a vowel\n    elif s[i] not in vowels or (i > 0 and s[i - 1] not in vowels):\n        # Add the current character to the corrected word\n        corrected_word += s[i]\n\n# Print the corrected word\nprint(corrected_word)"}
{"solution": "def solve(n, a, b, seats):\n    seats = list(seats)\n    count = 0\n    for i in range(n):\n        if seats[i] == '.':\n            if i > 0 and seats[i-1] != 'A':\n                seats[i] = 'A'\n                a -= 1\n                count += 1\n            elif i < n-1 and seats[i+1] != 'A' and a > b:\n                seats[i] = 'A'\n                a -= 1\n                count += 1\n            elif a <= b:\n                seats[i] = 'B'\n                b -= 1\n                count += 1\n    return count\n\nn, a, b = map(int, input().split())\nseats = input()\nprint(solve(n, a, b, seats))"}
{"solution": "import math\n\ndef find_pair(r):\n    for x in range(1, int(math.sqrt(r)) + 1):\n        if (r - x * x - x - 1) % (2 * x) == 0:\n            y = (r - x * x - x - 1) // (2 * x)\n            if y > 0:\n                return x, y\n    return \"NO\"\n\nr = int(input())\nprint(find_pair(r))"}
{"solution": "n = int(input())\nballoons = list(map(int, input().split()))\n\n# If there are only 1 or 2 packets, it's impossible to divide them\nif n <= 2:\n    print(-1)\nelse:\n    # Sort the packets in descending order\n    balloons.sort(reverse=True)\n\n    # Give the packet with the most balloons to Grigory\n    grigory_packets = [balloons[0]]\n    grigory_sum = balloons[0]\n\n    # Try to give the remaining packets to Grigory and Andrew in such a way\n    # that the total number of balloons in their packets is not equal\n    for i in range(1, n):\n        if grigory_sum > sum(balloons) - grigory_sum:\n            break\n        grigory_packets.append(balloons[i])\n        grigory_sum += balloons[i]\n\n    # If it's impossible to divide the packets, print -1\n    if grigory_sum == sum(balloons) - grigory_sum:\n        print(-1)\n    else:\n        # Print the number of packets to give to Grigory and their indices\n        print(len(grigory_packets))\n        for i in range(len(grigory_packets)):\n            print(balloons.index(grigory_packets[i]) + 1, end=' ')"}
{"solution": "n = int(input())\n\n# Start from 9 and go down to 1\nfor i in range(9, 0, -1):\n    # If n is divisible by i, then i is the digit that appears the most\n    if n % i == 0:\n        print(n // i)\n        print(' '.join([str(i)] * (n // i)))\n        break"}
{"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef max_simple_subset(a):\n    n = len(a)\n    freq = [0] * (10**6 + 1)\n    for num in a:\n        freq[num] += 1\n\n    simple_subset = []\n    for num in range(1, 10**6 + 1):\n        if freq[num] > 0:\n            is_valid = True\n            for subset_num in simple_subset:\n                if not is_prime(num + subset_num):\n                    is_valid = False\n                    break\n            if is_valid:\n                simple_subset.append(num)\n                freq[num] -= 1\n                if freq[num] > 0:\n                    simple_subset.append(num)\n\n    return simple_subset\n\nn = int(input())\na = list(map(int, input().split()))\n\nsimple_subset = max_simple_subset(a)\nprint(len(simple_subset))\nprint(*simple_subset)"}
{"solution": "def greatest_beautiful_divisor(n):\n    k = 1\n    while (2**(k+1) - 1) * (2**k) <= n:\n        k += 1\n    return (2**(k-1) - 1) * (2**(k-1))\n\nn = int(input())\nprint(greatest_beautiful_divisor(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(m, d, a, b):\n    a = list(map(int, str(a)))\n    b = list(map(int, str(b)))\n    n = len(a)\n\n    dp = [[0] * 2 for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(2):\n            for k in range(10):\n                if (i % 2 == 0 and k == d and j == 1) or (i % 2 != 0 and k != d and j == 1):\n                    continue\n                if k < a[i] or (k == a[i] and j == 0):\n                    continue\n                if k > b[i] or (k == b[i] and j == 0):\n                    continue\n                dp[i + 1][j or (k > 0)] = (dp[i + 1][j or (k > 0)] + dp[i][j]) % MOD\n\n    return (dp[n][1] - dp[n][0] + MOD) % MOD if m == 1 else dp[n][1] * pow(m, MOD - 2, MOD) % MOD\n\nm, d = map(int, input().split())\na = int(input())\nb = int(input())\n\nprint(solve(m, d, a, b))"}
{"solution": "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\nqueue = list(range(n))\nlast_child = -1\n\nwhile queue:\n    child = queue.pop(0)\n    a[child] -= m\n    if a[child] > 0:\n        queue.append(child)\n    else:\n        last_child = child + 1\n\nprint(last_child)"}
{"solution": "# Get the input\nn = int(input())\n\n# Initialize the count of bills\ncount = 0\n\n# Denominations of bills\ndenominations = [100, 20, 10, 5, 1]\n\n# Iterate over each denomination\nfor denomination in denominations:\n    # Count the number of bills of current denomination\n    count += n // denomination\n    # Update the remaining amount\n    n %= denomination\n\n# Print the minimum number of bills\nprint(count)"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, k):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, k) + 1):\n            dp[i][j] = (dp[i - 1][j] + (i - j) * dp[i - 1][j - 1]) % MOD\n    return dp[n][k]\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "from collections import defaultdict\n\ndef max_beauty(n, k, b, c):\n    roses = sorted(zip(b, c), key=lambda x: (-x[0], x[1]))\n    colors = defaultdict(int)\n    beauty = 0\n    for i in range(k):\n        beauty += roses[i][0]\n        colors[roses[i][1]] += 1\n    if len(colors) < 2:\n        return -1\n    max_beauty = beauty\n    for i in range(k, n):\n        if roses[i][1] not in colors:\n            beauty += roses[i][0] - roses[i-k][0]\n            colors[roses[i][1]] += 1\n            colors[roses[i-k][1]] -= 1\n            if colors[roses[i-k][1]] == 0:\n                del colors[roses[i-k][1]]\n            max_beauty = max(max_beauty, beauty)\n    return max_beauty\n\nn, k = map(int, input().split())\nb = list(map(int, input().split()))\nc = input()\nprint(max_beauty(n, k, b, c))"}
{"solution": "from fractions import Fraction\n\ndef continued_fraction(lst):\n    if len(lst) == 1:\n        return Fraction(lst[0])\n    else:\n        return Fraction(lst[0]) + Fraction(1, continued_fraction(lst[1:]))\n\np, q = map(int, input().split())\nn = int(input())\na = list(map(int, input().split()))\n\nfraction1 = Fraction(p, q)\nfraction2 = continued_fraction(a)\n\nprint(\"YES\" if fraction1 == fraction2 else \"NO\")"}
{"solution": "# Get the input expression\nexpression = input()\n\n# Split the expression into parts\nparts = expression.split('+')\na = parts[0].count('|')\nb = parts[1].split('=')[0].count('|')\nc = parts[1].split('=')[1].count('|')\n\n# Check if it's possible to make the expression correct\nif a + b == c:\n    print(expression)\nelif a + b + 1 == c:\n    print(expression.replace('=', '=|', 1))\nelif a + b - 1 == c:\n    print(expression.replace('|=', '=', 1))\nelif a + b + 2 == c:\n    print(expression.replace('=', '=||', 1))\nelif a + b - 2 == c:\n    print(expression.replace('||=', '=', 1))\nelse:\n    print('Impossible')"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, k):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(i * i):\n            for l in range(i + 1):\n                if j - l * (2 * i - l - 1) >= 0:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - l * (2 * i - l - 1)]) % MOD\n    return dp[n][k]\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "def solve(n, points):\n    def dfs(i, x, y):\n        if i == m:\n            if (x, y) in points:\n                return [(x, y)]\n            else:\n                return []\n        res = []\n        for dx, dy, d in [(1, 0, 'R'), (-1, 0, 'L'), (0, 1, 'U'), (0, -1, 'D')]:\n            nx, ny = x + dx * di[i], y + dy * di[i]\n            if abs(nx) > 10**9 or abs(ny) > 10**9:\n                continue\n            for j in dfs(i + 1, nx, ny):\n                res.append((j[0], j[1], d + j[2]))\n        return res\n\n    for m in range(1, 41):\n        for di in product(range(1, 10**12 + 1), repeat=m):\n            if all((0, 0, ''.join(w)) in dfs(0, 0, 0) for _, _, w in dfs(0, 0, 0)):\n                return m, di, [w for _, _, w in dfs(0, 0, 0)]\n    return -1\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\nres = solve(n, points)\nif res == -1:\n    print(-1)\nelse:\n    m, di, w = res\n    print(m)\n    print(' '.join(map(str, di)))\n    for s in w:\n        print(s)"}
{"solution": "n = int(input())\ns = input()\n\n# Replace all filler words with '*'\nwhile 'ogo' in s:\n    s = s.replace('ogo', '*')\n\n# Replace all '*' with '***'\ns = s.replace('*', '***')\n\nprint(s)"}
{"solution": "import sys\nfrom math import gcd\n\nMOD = 10**9 + 7\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef g(x, p):\n    k = 0\n    while x % p**(k+1) == 0:\n        k += 1\n    return p**k\n\ndef f(x, y):\n    factors = prime_factors(x)\n    product = 1\n    for p in factors:\n        product = (product * g(y, p)) % MOD\n    return product\n\ndef solve(x, n):\n    result = 1\n    for i in range(1, n+1):\n        result = (result * f(x, i)) % MOD\n    return result\n\nx, n = map(int, sys.stdin.readline().split())\nprint(solve(x, n))"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef solve(a, b, c):\n    solutions = []\n    dp = [[0] * 10 for _ in range(100000)]\n    for i in range(1, 10):\n        dp[i][i] = 1\n    for i in range(1, 100000):\n        for j in range(10):\n            for k in range(10):\n                dp[i][j] += dp[i - 1][j - k]\n    for x in range(1, 10**9):\n        s = sum(dp[x][i] * i for i in range(10))\n        if x == b * s**a + c:\n            solutions.append(x)\n    return solutions\n\na, b, c = map(int, input().split())\nsolutions = solve(a, b, c)\nprint(len(solutions))\nprint(*solutions)"}
{"solution": "def check_solvable(cube):\n    # Check if all faces of the cube have the same color\n    if len(set(cube[::4])) == 1:\n        return True\n    # Check if there are two faces with the same color\n    # and the other two faces also have the same color\n    colors = [cube[i::4] for i in range(4)]\n    if len(set(colors[0])) == 2 and len(set(colors[1])) == 2 and set(colors[0]) == set(colors[1]):\n        return True\n    return False\n\n# Read the input\ncube = list(map(int, input().split()))\n\n# Check if the cube is solvable\nif check_solvable(cube):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def solve(p, x, y):\n    s = y\n    i = (s // 50) % 475\n    t_shirts = set()\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        t_shirts.add(26 + i)\n    hacks = 0\n    while s < x or p not in t_shirts:\n        s += 100\n        hacks += 1\n        if s >= y:\n            i = (s // 50) % 475\n            t_shirts = set()\n            for _ in range(25):\n                i = (i * 96 + 42) % 475\n                t_shirts.add(26 + i)\n    return hacks\n\np, x, y = map(int, input().split())\nprint(solve(p, x, y))"}
{"solution": "# Get input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# If Winnie-the-Pooh only needs to have a meal once, the distance is 0\nif n == 1:\n    print(0)\nelse:\n    # Initialize minimum distance as a large number\n    min_distance = float('inf')\n\n    # Calculate the distance for each possible path\n    # Path: Rabbit -> Owl -> Rabbit -> Eeyore\n    distance1 = a + min(a, b) * (n - 2) + c\n    # Path: Rabbit -> Eeyore -> Rabbit -> Owl\n    distance2 = b + min(b, a) * (n - 2) + c\n    # Path: Owl -> Rabbit -> Owl -> Eeyore\n    distance3 = a + min(a, c) * (n - 2) + b\n    # Path: Eeyore -> Rabbit -> Eeyore -> Owl\n    distance4 = b + min(b, c) * (n - 2) + a\n\n    # Update minimum distance\n    min_distance = min(min_distance, distance1, distance2, distance3, distance4)\n\n    # Print the minimum distance\n    print(min_distance)"}
{"solution": "# Get the input\nx1, x2, x3 = map(int, input().split())\n\n# Sort the coordinates\ncoordinates = sorted([x1, x2, x3])\n\n# Calculate the minimum total distance\nmin_distance = coordinates[1] - coordinates[0] + coordinates[2] - coordinates[1]\n\n# Print the result\nprint(min_distance)"}
{"solution": "from collections import defaultdict\n\ndef solve():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    # Create a dictionary to store the count of each element in the array\n    count = defaultdict(int)\n    for i in range(n):\n        count[a[i]] += 1\n\n    # If there is already an element with count >= 2, return 0\n    if any(v >= 2 for v in count.values()):\n        return 0\n\n    # Create a new dictionary to store the count of each element after applying the operation\n    new_count = defaultdict(int)\n    for i in range(n):\n        new_count[a[i] & x] += 1\n\n    # If there is no element with count >= 2 in the new dictionary, return -1\n    if all(v < 2 for v in new_count.values()):\n        return -1\n\n    # Otherwise, return 1\n    return 1\n\nprint(solve())"}
{"solution": "def is_plus_shape(grid):\n    h = len(grid)\n    w = len(grid[0])\n    center = None\n\n    # Find the center\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*':\n                if center is None:\n                    center = (i, j)\n                else:\n                    return False\n\n    if center is None:\n        return False\n\n    # Check left\n    for j in range(center[1]-1, -1, -1):\n        if grid[center[0]][j] != '*':\n            break\n        if j == 0:\n            break\n\n    # Check right\n    for j in range(center[1]+1, w):\n        if grid[center[0]][j] != '*':\n            break\n        if j == w-1:\n            break\n\n    # Check up\n    for i in range(center[0]-1, -1, -1):\n        if grid[i][center[1]] != '*':\n            break\n        if i == 0:\n            break\n\n    # Check down\n    for i in range(center[0]+1, h):\n        if grid[i][center[1]] != '*':\n            break\n        if i == h-1:\n            break\n\n    # Check if all other cells are empty\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*' and (i, j) != center:\n                if i != center[0] and j != center[1]:\n                    return False\n\n    return True\n\nh, w = map(int, input().split())\ngrid = [input() for _ in range(h)]\nprint('YES' if is_plus_shape(grid) else 'NO')"}
{"solution": "def generate_matrix(n, a, b):\n    # Check if it's possible to generate the matrix\n    if a + b > n + 1 or a * b > n * (n - 1) // 2:\n        print(\"NO\")\n        return\n\n    # Initialize the matrix with zeroes\n    matrix = [[0] * n for _ in range(n)]\n\n    # Create 'a' connected components\n    for i in range(a - 1):\n        for j in range(i + 1, a):\n            matrix[i][j] = matrix[j][i] = 1\n\n    # Create 'b' connected components in the complement\n    remaining_edges = n * (n - 1) // 2 - (a - 1) * a // 2\n    for i in range(a, n):\n        for j in range(i + 1, n):\n            if remaining_edges > 0:\n                matrix[i][j] = matrix[j][i] = 1\n                remaining_edges -= 1\n\n    # Print the result\n    print(\"YES\")\n    for row in matrix:\n        print(\"\".join(map(str, row)))\n\n# Read the input\nn, a, b = map(int, input().split())\n\n# Generate the matrix\ngenerate_matrix(n, a, b)"}
{"solution": "# Read input\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\n# Calculate the number of main rounds needed\nmain_rounds = (n * m - k) // n\nif (n * m - k) % n != 0:\n    main_rounds += 1\n\n# Calculate the number of additional rounds needed\nadditional_rounds = n * m - k - main_rounds * n\n\n# Calculate the total number of problems needed\ntotal_problems = main_rounds * c + additional_rounds * d\n\n# Print the result\nprint(total_problems)"}
{"solution": "def solve(s):\n    grid = [[' ']*13 for _ in range(2)]\n    chars = list(s)\n    i, j = 0, 0\n    while chars:\n        grid[i][j] = chars.pop(0)\n        if not chars:\n            break\n        if i == 0:\n            if j < 12 and chars[0] not in [grid[0][j+1], grid[1][j], grid[1][j+1]]:\n                j += 1\n            elif j > 0 and chars[0] not in [grid[0][j-1], grid[1][j], grid[1][j-1]]:\n                j -= 1\n            else:\n                i = 1\n        else:\n            if j < 12 and chars[0] not in [grid[1][j+1], grid[0][j], grid[0][j+1]]:\n                j += 1\n            elif j > 0 and chars[0] not in [grid[1][j-1], grid[0][j], grid[0][j-1]]:\n                j -= 1\n            else:\n                i = 0\n    for row in grid:\n        print(''.join(row))\n\ns = input()\nsolve(s)"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    log_x_y = y * math.log(x)\n    log_y_x = x * math.log(y)\n\n    if log_x_y < log_y_x:\n        return '<'\n    elif log_x_y > log_y_x:\n        return '>'\n    else:\n        return '='\n\nx, y = map(int, input().split())\nprint(compare_powers(x, y))"}
{"solution": "import math\n\n# Get the input values for r and h\nr, h = map(int, input().split())\n\n# Calculate the number of balloons that can be placed in the semicircular part\nsemicircle_area = (math.pi * r**2) / 2\nballoon_area = (4/3) * math.pi * (r/2)**3\nsemicircle_balloons = int(semicircle_area / balloon_area)\n\n# Calculate the number of balloons that can be placed in the rectangular part\nrectangle_area = r * h\nrectangle_balloons = int(rectangle_area / balloon_area)\n\n# Calculate the total maximum number of balloons that can be placed in the cupboard\ntotal_balloons = semicircle_balloons + rectangle_balloons\n\n# Print the result\nprint(total_balloons)"}
{"solution": "from collections import Counter\n\n# Get the input\nnumbers = list(map(int, input().split()))\n\n# Count the occurrences of each number\ncounter = Counter(numbers)\n\n# Calculate the total sum\ntotal_sum = sum(numbers)\n\n# Find the minimum possible sum of numbers written on remaining cards\nmin_sum = total_sum\nfor number, count in counter.items():\n    if count >= 2:\n        min_sum = min(min_sum, total_sum - 2 * number)\n    if count >= 3:\n        min_sum = min(min_sum, total_sum - 3 * number)\n\n# Print the result\nprint(min_sum)"}
{"solution": "# Read input\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Sort checkpoints\ncheckpoints.sort()\n\n# Find the closest checkpoint to Vasya's starting position\nclosest_checkpoint = min(checkpoints, key=lambda x: abs(x - a))\n\n# Remove the closest checkpoint from the list\ncheckpoints.remove(closest_checkpoint)\n\n# Calculate the minimum distance Vasya has to travel\nmin_distance = abs(closest_checkpoint - a)\nfor i in range(n - 2):\n    min_distance += abs(checkpoints[i + 1] - checkpoints[i])\n\n# Print the result\nprint(min_distance)"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef smallest_root(n):\n    for x in range(1, n + 1):\n        if x**2 + sum_of_digits(x)*x - n == 0:\n            return x\n    return -1\n\nn = int(input())\nprint(smallest_root(n))"}
{"solution": "from datetime import datetime, timedelta\n\n# Get the current time and sleep duration as input\ncurrent_time = datetime.strptime(input(), \"%H:%M\")\nsleep_duration = datetime.strptime(input(), \"%H:%M\")\n\n# Calculate the time George went to bed\nbed_time = current_time - timedelta(hours=sleep_duration.hour, minutes=sleep_duration.minute)\n\n# Print the time George went to bed in the format \"hh:mm\"\nprint(bed_time.strftime(\"%H:%M\"))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmax_mean = float('-inf')\nmax_len = 0\ncurr_sum = 0\ncurr_len = 0\n\nfor i in range(n):\n    curr_sum += a[i]\n    curr_len += 1\n    curr_mean = curr_sum / curr_len\n\n    if curr_mean > max_mean:\n        max_mean = curr_mean\n        max_len = curr_len\n    elif curr_mean == max_mean:\n        max_len = max(max_len, curr_len)\n\n    while curr_sum < 0:\n        curr_sum -= a[i - curr_len + 1]\n        curr_len -= 1\n\nprint(max_len)"}
{"solution": "MOD = 998244353\n\ndef solve(n, m, k):\n    dp = [[0] * (k + 1) for _ in range(n)]\n    dp[0][0] = m\n\n    for i in range(1, n):\n        for j in range(k + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] * (m - 1) % MOD\n            else:\n                dp[i][j] = (dp[i - 1][j] * (m - 1) + dp[i - 1][j - 1]) % MOD\n\n    return sum(dp[n - 1]) % MOD\n\nn, m, k = map(int, input().split())\nprint(solve(n, m, k))"}
{"solution": "def is_magic_number(n):\n    while n > 0:\n        if n % 100 == 14:\n            n //= 100\n        elif n % 10 == 1:\n            n //= 10\n        elif n == 144:\n            return True\n        else:\n            return False\n    return True\n\nn = int(input())\nprint(\"YES\" if is_magic_number(n) else \"NO\")"}
{"solution": "def min_moves(n, m, i, j, a, b):\n    # Check if the candy is already in a corner\n    if (i == 1 and j == 1) or (i == 1 and j == m) or (i == n and j == 1) or (i == n and j == m):\n        return 0\n\n    # Initialize the minimum number of moves to infinity\n    min_moves = float('inf')\n\n    # Check if moving the candy to the left or right will bring it closer to a corner\n    if a <= j <= m - a:\n        min_moves = min(min_moves, 1 + min_moves(n, m, i, j - a, a, b), 1 + min_moves(n, m, i, j + a, a, b))\n    elif j < a:\n        min_moves = min(min_moves, 1 + min_moves(n, m, i, j + a, a, b))\n    elif j > m - a:\n        min_moves = min(min_moves, 1 + min_moves(n, m, i, j - a, a, b))\n\n    # Check if moving the candy up or down will bring it closer to a corner\n    if a <= i <= n - a:\n        min_moves = min(min_moves, 1 + min_moves(n, m, i - a, j, a, b), 1 + min_moves(n, m, i + a, j, a, b))\n    elif i < a:\n        min_moves = min(min_moves, 1 + min_moves(n, m, i + a, j, a, b))\n    elif i > n - a:\n        min_moves = min(min_moves, 1 + min_moves(n, m, i - a, j, a, b))\n\n    # Return the minimum number of moves or \"Poor Inna and pony!\" if it is not possible to move the candy to a corner\n    return min_moves if min_moves != float('inf') else \"Poor Inna and pony!\"\n\n# Get the input values\nn, m, i, j, a, b = map(int, input().split())\n\n# Print the minimum number of moves required to move the candy to a corner\nprint(min_moves(n, m, i, j, a, b))"}
{"solution": "# Get the length of the string\nn = int(input())\n\n# Get the string\ns = input()\n\n# Initialize the count of removable characters\ncount = 0\n\n# Iterate over the string\ni = 1\nwhile i < n - 1:\n    # Check if the current character is the next character of the previous character\n    if ord(s[i]) - ord(s[i - 1]) == 1:\n        # Check if the current character is the next character of the next character\n        if i + 1 < n and ord(s[i]) - ord(s[i + 1]) == 1:\n            # Remove the current character and increment the count\n            s = s[:i] + s[i + 1:]\n            count += 1\n            n -= 1\n        # If the current character is not the next character of the next character, move to the next character\n        else:\n            i += 1\n    # If the current character is not the next character of the previous character, move to the next character\n    else:\n        i += 1\n\n# Check if the first or last character can be removed\nif n > 1:\n    if ord(s[0]) - ord(s[1]) == 1:\n        count += 1\n    if ord(s[-1]) - ord(s[-2]) == 1:\n        count += 1\n\n# Print the count of removable characters\nprint(count)"}
{"solution": "from collections import defaultdict\n\ndef min_bills(denominations, k, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for coin in denominations:\n        for x in range(coin, amount + 1):\n            dp[x] = min(dp[x], dp[x - coin] + 1)\n    return dp[amount] if dp[amount] <= k else -1\n\nn, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\n\nfor _ in range(q):\n    amount = int(input())\n    print(min_bills(denominations, k, amount))"}
{"solution": "def min_time(s, x1, x2, t1, t2, p, d):\n    # Calculate the time Igor needs to reach the tram or the destination\n    time_to_tram = abs(p - x1) / t2\n    time_to_dest = abs(x2 - x1) / t2\n\n    # Calculate the time the tram needs to reach Igor's destination\n    time_tram_to_dest = abs(x2 - p) / t1\n\n    # If the tram is moving towards Igor's destination, wait for it\n    if (d == 1 and x2 > p) or (d == -1 and x2 < p):\n        return max(time_to_tram, time_tram_to_dest)\n    # Otherwise, go directly to the destination\n    else:\n        return time_to_dest\n\n# Read the input\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Print the minimum time Igor needs to get from x1 to x2\nprint(min_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "# Get input\nn, x = map(int, input().split())\n\n# Initialize count\ncount = 0\n\n# Iterate over rows\nfor i in range(1, n + 1):\n    # If x is divisible by i, then there is a cell with value x in the i-th row\n    if x % i == 0:\n        # Calculate the column number\n        j = x // i\n        # If the column number is less than or equal to n, then there is a cell with value x\n        if j <= n:\n            count += 1\n\n# Print the result\nprint(count)"}
{"solution": "n, k = map(int, input().split())\npassword = []\n\nfor i in range(k):\n    password.append(chr(ord('a') + i))\n\nfor i in range(k, n):\n    password.append(password[i - k])\n\nfor i in range(n - 1, 0, -2):\n    password[i], password[i - 1] = password[i - 1], password[i]\n\nprint(''.join(password))"}
{"solution": "# Read the input\nn = int(input())\ndirections = input()\npositions = list(map(int, input().split()))\n\n# Initialize the minimum time to infinity\nmin_time = float('inf')\n\n# Iterate over the particles\nfor i in range(n - 1):\n    # If the particles are moving towards each other\n    if directions[i] == 'R' and directions[i + 1] == 'L':\n        # Calculate the time to collision\n        time = (positions[i + 1] - positions[i]) // 2\n        # Update the minimum time\n        min_time = min(min_time, time)\n\n# Print the result\nif min_time == float('inf'):\n    print(-1)\nelse:\n    print(min_time)"}
{"solution": "def solve():\n    n, a, b = map(int, input().split())\n    seals = [list(map(int, input().split())) for _ in range(n)]\n\n    def fits(x, y):\n        return (x <= a and y <= b) or (x <= b and y <= a)\n\n    def area(x, y):\n        return x * y\n\n    def overlap(s1, s2):\n        x1, y1 = s1\n        x2, y2 = s2\n        return not (x1 >= x2 or x1 + y1 <= x2 or y1 >= y2 or y1 + x1 <= y2)\n\n    seals = [s for s in seals if fits(*s)]\n    seals.sort(key=lambda s: -area(*s))\n\n    for i in range(len(seals)):\n        for j in range(i+1, len(seals)):\n            if not overlap(seals[i], seals[j]):\n                return area(*seals[i]) + area(*seals[j])\n\n    return 0\n\nprint(solve())"}
{"solution": "n = int(input())\npoints = [list(map(int, input().split())) for _ in range(4*n + 1)]\n\nx_coords = [point[0] for point in points]\ny_coords = [point[1] for point in points]\n\nmin_x, max_x = min(x_coords), max(x_coords)\nmin_y, max_y = min(y_coords), max(y_coords)\n\nfor point in points:\n    if not (point[0] == min_x or point[0] == max_x or point[1] == min_y or point[1] == max_y):\n        print(point[0], point[1])\n        break"}
{"solution": "def max_product_digits(n):\n    if n < 10:\n        return n\n    else:\n        product = 1\n        while n > 0:\n            product *= (n % 10)\n            n //= 10\n        return product\n\ndef max_product(n):\n    if n < 10:\n        return n\n    else:\n        power = 10\n        while n >= power * 10:\n            power *= 10\n        max_prod = 0\n        for i in range(power, n + 1):\n            max_prod = max(max_prod, max_product_digits(i))\n        return max_prod\n\nn = int(input())\nprint(max_product(n))"}
{"solution": "# Get the number of students\nn = int(input())\n\n# Get the list of votes for Elodreip\nvotes = list(map(int, input().split()))\n\n# Find the maximum number of votes Elodreip gets from a student\nmax_votes = max(votes)\n\n# Calculate the total number of votes Elodreip gets\nelodreip_votes = sum(votes)\n\n# Calculate the total number of votes Awruk needs to win\nawruk_votes = elodreip_votes + n\n\n# Calculate the smallest winning number k for Awruk\nk = (awruk_votes + n - 1) // n\n\n# Make sure k is at least max_votes\nk = max(k, max_votes)\n\n# Print the result\nprint(k)"}
{"solution": "def solve(s):\n    stack = []\n    count = 0\n    for c in s:\n        if stack and stack[-1] != c:\n            while stack and stack[-1] != c:\n                stack.pop()\n            count += 1\n        stack.append(c)\n    return count\n\ns = input()\nprint(solve(s))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\na.sort()\nmin_prod = a[0] * a[1] * a[2]\ncount = 0\nfor i in range(n - 2):\n    for j in range(i + 1, n - 1):\n        for k in range(j + 1, n):\n            if a[i] * a[j] * a[k] == min_prod:\n                count += 1\nprint(count)"}
{"solution": "def min_cuts(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        cuts = 0\n        while n > 1:\n            if n % 2 == 0:\n                cuts += n // 2\n                n //= 2\n            else:\n                cuts += n\n                n -= 1\n        return cuts + 1\n\nn = int(input())\nprint(min_cuts(n))"}
{"solution": "# Get the input\nn = int(input())\n\n# Convert the number to a string for easier manipulation\nn_str = str(n)\n\n# If the number is positive, no change is needed\nif n >= 0:\n    print(n)\n# If the number is negative\nelse:\n    # If the last digit is less than the digit before last\n    if n_str[-1] < n_str[-2]:\n        # Remove the last digit\n        print(n_str[:-1])\n    # Otherwise\n    else:\n        # Remove the digit before last\n        print(n_str[:-2] + n_str[-1])"}
{"solution": "# Get the input\nstart, end = input().split()\nn = int(input())\n\n# Define the possible positions and their order\npositions = ['v', '<', '^', '>']\n\n# Find the starting position index\nstart_index = positions.index(start)\n\n# Calculate the ending position index\nend_index = (start_index + n) % 4\n\n# Determine the direction\nif positions[end_index] == end:\n    print('cw')\nelse:\n    end_index = (start_index - n) % 4\n    if positions[end_index] == end:\n        print('ccw')\n    else:\n        print('undefined')"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize an array to store the state of each domino\ndominoes = [0] * n\n\n# Set the state of each domino based on the input string\nfor i in range(n):\n    if s[i] == 'L':\n        dominoes[i] = -1\n    elif s[i] == 'R':\n        dominoes[i] = 1\n\n# Simulate the process\nfor _ in range(n):\n    for i in range(1, n):\n        if dominoes[i] == -1 and dominoes[i - 1] == 0:\n            dominoes[i - 1] = -1\n        elif dominoes[i] == 1 and dominoes[i - 1] == 0:\n            dominoes[i - 1] = 1\n    for i in range(n - 2, -1, -1):\n        if dominoes[i] == -1 and dominoes[i + 1] == 0:\n            dominoes[i + 1] = -1\n        elif dominoes[i] == 1 and dominoes[i + 1] == 0:\n            dominoes[i + 1] = 1\n\n# Count the number of dominoes that remain vertical\ncount = 0\nfor i in range(n):\n    if dominoes[i] == 0:\n        count += 1\n\nprint(count)"}
{"solution": "def solve(n, m, leaders):\n    a = [0] * n\n    for i in range(m - 1, 0, -1):\n        diff = leaders[i] - leaders[i - 1]\n        if diff <= 0:\n            diff += n\n        if a[leaders[i - 1] - 1] != 0 and a[leaders[i - 1] - 1] != diff:\n            return -1\n        a[leaders[i - 1] - 1] = diff\n    for i in range(n):\n        if a[i] == 0:\n            for j in range(1, n + 1):\n                if j not in a:\n                    a[i] = j\n                    break\n    return a\n\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\nresult = solve(n, m, leaders)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "def max_number(a, k):\n    a = list(str(a))\n    n = len(a)\n    for i in range(n):\n        if k <= 0:\n            break\n        max_idx = i\n        for j in range(i+1, min(n, i+k+1)):\n            if a[j] > a[max_idx]:\n                max_idx = j\n        k -= max_idx - i\n        a[i:max_idx+1] = [a[max_idx]] + a[i:max_idx]\n    return ''.join(a)\n\na, k = map(int, input().split())\nprint(max_number(a, k))"}
{"solution": "def is_arithmetic(seq):\n    return seq[1] - seq[0] == seq[2] - seq[1] == seq[3] - seq[2]\n\ndef is_geometric(seq):\n    return seq[1] / seq[0] == seq[2] / seq[1] == seq[3] / seq[2]\n\ndef next_element(seq):\n    if is_arithmetic(seq):\n        return seq[-1] + (seq[1] - seq[0])\n    elif is_geometric(seq):\n        return seq[-1] * (seq[1] / seq[0])\n    else:\n        return 42\n\nseq = list(map(int, input().split()))\nprint(next_element(seq))"}
{"solution": "# Read the input\nn = int(input())\ncolors = list(map(int, input().split()))\n\n# Initialize the maximum distance and the last occurrence of each color\nmax_distance = 0\nlast_occurrence = [-1] * (n + 1)\n\n# Iterate over the houses\nfor i in range(n):\n    # If the color of the current house has been seen before\n    if last_occurrence[colors[i]] != -1:\n        # Update the maximum distance\n        max_distance = max(max_distance, i - last_occurrence[colors[i]])\n    # Update the last occurrence of the current color\n    last_occurrence[colors[i]] = i\n\n# If the first house and the last house have different colors, update the maximum distance\nif colors[0] != colors[-1]:\n    max_distance = max(max_distance, n - last_occurrence[colors[-1]])\n\n# Print the maximum distance\nprint(max_distance)"}
{"solution": "# Get the input\nn, m, k = map(int, input().split())\n\n# Calculate the lane\nlane = (k - 1) // (2 * m) + 1\n\n# Calculate the desk\ndesk = ((k - 1) % (2 * m)) // 2 + 1\n\n# Calculate the side\nside = 'L' if k % 2 == 1 else 'R'\n\n# Print the output\nprint(lane, desk, side)"}
{"solution": "# Read the input\nn = int(input())\ns = input()\n\n# Count the number of red, green, and blue cards\nr = s.count('R')\ng = s.count('G')\nb = s.count('B')\n\n# If there are cards of all three colors, the final card can be any color\nif r > 0 and g > 0 and b > 0:\n    print('BGR')\n# If there are cards of two colors, the final card can be the third color\nelif r > 0 and g > 0:\n    print('B')\nelif r > 0 and b > 0:\n    print('G')\nelif g > 0 and b > 0:\n    print('R')\n# If there is only one color, the final card will be of that color\nelse:\n    print(s[0])"}
