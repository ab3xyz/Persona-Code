{"solution": "def find_longest_accordion(s):\n    # Initialize variables\n    open_bracket, close_bracket, colon1, colon2, pipes = 0, 0, 0, 0, 0\n    max_length = 0\n\n    # Iterate through the string\n    for char in s:\n        if char == '[':\n            open_bracket = 1\n        elif char == ':' and open_bracket == 1 and colon1 == 0:\n            colon1 = 1\n        elif char == '|' and colon1 == 1 and colon2 == 0:\n            pipes += 1\n        elif char == ':' and colon1 == 1 and colon2 == 0:\n            colon2 = 1\n        elif char == ']' and colon2 == 1:\n            close_bracket = 1\n            max_length = max(max_length, 2 + pipes + 2)\n            open_bracket, close_bracket, colon1, colon2, pipes = 0, 0, 0, 0, 0\n        else:\n            open_bracket, close_bracket, colon1, colon2, pipes = 0, 0, 0, 0, 0\n\n    # Return the maximum length if an accordion is possible, otherwise return -1\n    return max_length if max_length > 0 else -1\n\n# Read the input string\ns = input()\n\n# Print the result\nprint(find_longest_accordion(s))"}
{"solution": "def max_sum_digits(x):\n    # Convert the number to string for easy digit manipulation\n    x_str = str(x)\n\n    # Initialize the result as the input number\n    result = x_str\n\n    # Start from the leftmost digit\n    for i in range(len(x_str)):\n        # If the current digit is not 9,\n        # replace it with 9 and make all the following digits 9\n        if x_str[i] != '9':\n            result = x_str[:i] + '9' * (len(x_str) - i)\n            # Decrease the previous digit by 1\n            if i > 0:\n                result = result[:i-1] + str(int(result[i-1]) - 1) + result[i:]\n            break\n\n    # Convert the result back to integer and return\n    return int(result)\n\n# Read the input\nx = int(input())\n\n# Print the result\nprint(max_sum_digits(x))"}
{"solution": "def is_lucky_year(year):\n    # A year is lucky if it has no more than 1 non-zero digit\n    return sum(int(digit) > 0 for digit in str(year)) <= 1\n\ndef find_next_lucky_year(current_year):\n    # Iterate through the years until we find a lucky year\n    for year in range(current_year + 1, current_year + 10000):\n        if is_lucky_year(year):\n            return year\n\ndef years_until_next_lucky_year(current_year):\n    next_lucky_year = find_next_lucky_year(current_year)\n    return next_lucky_year - current_year\n\n# Read the current year from the input\ncurrent_year = int(input())\n\n# Calculate and print the number of years until the next lucky year\nprint(years_until_next_lucky_year(current_year))"}
{"solution": "def max_painted_sections(n, q, painters):\n    # Sort the painters based on their starting section\n    painters.sort(key=lambda x: x[0])\n\n    # Initialize a 2D DP table to store the maximum number of painted sections\n    dp = [[0] * (q - 2) for _ in range(n + 1)]\n\n    # Iterate through each section\n    for section in range(1, n + 1):\n        # Iterate through each painter\n        for painter in range(q):\n            # Iterate through each possible number of painters to hire\n            for num_painters in range(q - 2, -1, -1):\n                # Check if the current painter can paint the current section\n                if painters[painter][0] <= section <= painters[painter][1]:\n                    # Calculate the maximum number of painted sections\n                    dp[section][num_painters] = max(dp[section][num_painters], dp[painters[painter][0] - 1][num_painters - 1] + painters[painter][1] - painters[painter][0] + 1)\n                # If the current painter cannot paint the current section, copy the previous value\n                if num_painters > 0:\n                    dp[section][num_painters] = max(dp[section][num_painters], dp[section][num_painters - 1])\n\n    # Return the maximum number of painted sections\n    return dp[n][q - 3]\n\n# Read the input\nn, q = map(int, input().split())\npainters = [list(map(int, input().split())) for _ in range(q)]\n\n# Print the maximum number of painted sections\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def is_lucky(time):\n    return '7' in time\n\ndef format_time(time):\n    return f'{time:02d}'\n\ndef main():\n    x = int(input())\n    hh, mm = map(int, input().split())\n\n    snooze_count = 0\n    while True:\n        mm -= x\n        if mm < 0:\n            mm += 60\n            hh -= 1\n            if hh < 0:\n                hh += 24\n\n        if is_lucky(format_time(hh)) or is_lucky(format_time(mm)):\n            break\n\n        snooze_count += 1\n\n    print(snooze_count)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "def min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0\n    elif l == 1:\n        return abs(pos - r) + 1\n    elif r == n:\n        return abs(pos - l) + 1\n    else:\n        return min(abs(pos - l), abs(pos - r)) + (r - l) + 2\n\nn, pos, l, r = map(int, input().split())\nprint(min_seconds_to_close_tabs(n, pos, l, r))"}
{"solution": "def min_blows(n, x, blows):\n    # Sort blows in descending order of damage\n    blows.sort(key=lambda x: x[0], reverse=True)\n\n    # Initialize minimum number of blows to infinity\n    min_blows = float('inf')\n\n    # Iterate through all possible damage values\n    for d in range(1, x + 1):\n        # Calculate number of blows needed to decrease heads to 0\n        num_blows = 0\n        cur_x = x\n        for blow in blows:\n            while cur_x > 0 and blow[0] >= d:\n                cur_x = max(0, cur_x - d) + blow[1]\n                num_blows += 1\n\n        # Update minimum number of blows\n        if cur_x == 0:\n            min_blows = min(min_blows, num_blows)\n\n    # Return minimum number of blows or -1 if impossible\n    return min_blows if min_blows != float('inf') else -1\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [list(map(int, input().split())) for _ in range(n)]\n\n    # Print output\n    print(min_blows(n, x, blows))"}
{"solution": "# Read the input\nn, m = map(int, input().split())\n\n# Initialize the number of days and the remaining grains in the barn\ndays = 0\nremaining_grains = n\n\n# Simulate the days\nwhile remaining_grains > 0:\n    # Increment the number of days\n    days += 1\n\n    # Add m grains to the barn\n    remaining_grains += m\n\n    # Make sure the barn is not overfilled\n    if remaining_grains > n:\n        remaining_grains = n\n\n    # Subtract the grains eaten by the sparrows\n    remaining_grains -= days\n\n# Print the result\nprint(days)"}
{"solution": "def min_draws_to_win(tiles):\n    # Parse the input tiles\n    tile1, tile2, tile3 = tiles.split()\n\n    # Extract numbers and suits\n    num1, suit1 = int(tile1[0]), tile1[1]\n    num2, suit2 = int(tile2[0]), tile2[1]\n    num3, suit3 = int(tile3[0]), tile3[1]\n\n    # Check for koutsu (triplet)\n    if tile1 == tile2 == tile3:\n        return 0\n\n    # Check for shuntsu (sequence)\n    def is_shuntsu(n1, n2, n3):\n        return sorted([n1, n2, n3]) in [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9]]\n\n    if suit1 == suit2 == suit3 and is_shuntsu(num1, num2, num3):\n        return 0\n\n    # Check for possible koutsu with one more draw\n    if tile1 == tile2 or tile1 == tile3 or tile2 == tile3:\n        return 1\n\n    # Check for possible shuntsu with one more draw\n    def needs_one_for_shuntsu(n1, n2):\n        return abs(n1 - n2) == 1 or abs(n1 - n2) == 2\n\n    if suit1 == suit2 and needs_one_for_shuntsu(num1, num2):\n        return 1\n    if suit1 == suit3 and needs_one_for_shuntsu(num1, num3):\n        return 1\n    if suit2 == suit3 and needs_one_for_shuntsu(num2, num3):\n        return 1\n\n    # If no koutsu or shuntsu can be formed with one more draw, return 2\n    return 2\n\n# Read input tiles\ntiles = input()\n\n# Print the minimum number of extra suited tiles needed to win\nprint(min_draws_to_win(tiles))"}
{"solution": "def find_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b):\n    left, right, top, bottom = 0, 0, 0, 0\n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        if x1 == x2:  # horizontal sofa\n            if x1 < n // 2:\n                left += 1\n            else:\n                right += 1\n        else:  # vertical sofa\n            if y1 < m // 2:\n                top += 1\n            else:\n                bottom += 1\n    for i in range(d):\n        if (left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b):\n            return i + 1\n        x1, y1, x2, y2 = sofas[i]\n        if x1 == x2:  # horizontal sofa\n            if x1 < n // 2:\n                left -= 1\n            else:\n                right -= 1\n        else:  # vertical sofa\n            if y1 < m // 2:\n                top -= 1\n            else:\n                bottom -= 1\n    return -1\n\nd = int(input())\nn, m = map(int, input().split())\nsofas = [list(map(int, input().split())) for _ in range(d)]\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\nprint(find_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b))"}
{"solution": "def mars_days_off(n):\n    full_weeks = n // 7\n    remaining_days = n % 7\n\n    min_days_off = full_weeks * 2\n    max_days_off = full_weeks * 2 + min(remaining_days, 2)\n\n    return min_days_off, max_days_off\n\nn = int(input())\nmin_days_off, max_days_off = mars_days_off(n)\nprint(min_days_off, max_days_off)"}
{"solution": "def count_chocolates(n, a, b, p, q):\n    # Count the number of tiles divisible by a\n    red_tiles = n // a\n\n    # Count the number of tiles divisible by b\n    blue_tiles = n // b\n\n    # Count the number of tiles divisible by both a and b\n    common_tiles = n // (a * b)\n\n    # Use the principle of inclusion-exclusion\n    total_tiles = red_tiles + blue_tiles - common_tiles\n\n    # Decide whether to prioritize painting tiles Red or Blue\n    if p > q:\n        # Prioritize painting tiles Red\n        red_chocolates = red_tiles * p\n        blue_chocolates = min(blue_tiles, common_tiles) * q\n    else:\n        # Prioritize painting tiles Blue\n        red_chocolates = min(red_tiles, common_tiles) * p\n        blue_chocolates = blue_tiles * q\n\n    # Calculate the maximum number of chocolates Joty can get\n    max_chocolates = red_chocolates + blue_chocolates\n\n    return max_chocolates\n\n# Read the input\nn, a, b, p, q = map(int, input().split())\n\n# Calculate the maximum number of chocolates Joty can get\nresult = count_chocolates(n, a, b, p, q)\n\n# Print the result\nprint(result)"}
{"solution": "def max_golden_subsegment(n, trophies):\n    # Convert the string to a list for easier manipulation\n    trophies = list(trophies)\n\n    # Initialize variables to keep track of the maximum length of a golden subsegment\n    max_length = 0\n    current_length = 0\n\n    # Initialize variables to keep track of the indices of the silver trophies\n    silver_indices = []\n\n    # Iterate through the trophies\n    for i in range(n):\n        if trophies[i] == 'G':\n            # If the current trophy is golden, increment the current length\n            current_length += 1\n        else:\n            # If the current trophy is silver, add its index to the list of silver indices\n            silver_indices.append(i)\n\n            # Update the maximum length of a golden subsegment\n            max_length = max(max_length, current_length)\n\n            # Reset the current length\n            current_length = 0\n\n    # Update the maximum length of a golden subsegment for the last subsegment\n    max_length = max(max_length, current_length)\n\n    # If there are no silver trophies, return the maximum length\n    if not silver_indices:\n        return max_length\n\n    # Initialize variables to keep track of the maximum possible length of a golden subsegment\n    max_possible_length = max_length\n\n    # Iterate through the silver indices\n    for i in silver_indices:\n        # Calculate the length of the golden subsegment to the left of the current silver trophy\n        left_length = 0\n        j = i - 1\n        while j >= 0 and trophies[j] == 'G':\n            left_length += 1\n            j -= 1\n\n        # Calculate the length of the golden subsegment to the right of the current silver trophy\n        right_length = 0\n        j = i + 1\n        while j < n and trophies[j] == 'G':\n            right_length += 1\n            j += 1\n\n        # Update the maximum possible length of a golden subsegment\n        max_possible_length = max(max_possible_length, left_length + right_length + 1)\n\n    # Return the maximum possible length of a golden subsegment\n    return max_possible_length\n\n# Read the input\nn = int(input())\ntrophies = input()\n\n# Print the maximum possible length of a golden subsegment\nprint(max_golden_subsegment(n, trophies))"}
{"solution": "from collections import defaultdict, deque\n\n# Read input\nn, k = map(int, input().split())\nmain_courses = set(map(int, input().split()))\n\n# Create a graph and a dependency count for each course\ngraph = defaultdict(list)\ndependencies = [0] * (n + 1)\n\nfor i in range(1, n + 1):\n    prereqs = list(map(int, input().split()))[1:]\n    for prereq in prereqs:\n        graph[prereq].append(i)\n        dependencies[i] += 1\n\n# Initialize a queue and a list to store the order of courses\nqueue = deque([i for i in range(1, n + 1) if dependencies[i] == 0])\norder = []\n\n# Perform topological sort\nwhile queue:\n    course = queue.popleft()\n    order.append(course)\n    for next_course in graph[course]:\n        dependencies[next_course] -= 1\n        if dependencies[next_course] == 0:\n            queue.append(next_course)\n\n# Check if all main courses are in the order\nif all(course in order for course in main_courses):\n    # Print the minimum number of courses and the order\n    print(len([course for course in order if course in main_courses]))\n    print(' '.join(map(str, [course for course in order if course in main_courses])))\nelse:\n    print(-1)"}
{"solution": "import sys\nfrom bisect import bisect_left\nfrom collections import deque\n\ndef read_input():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    n, k = map(int, read_input().split())\n    p = list(map(int, read_input().split()))\n\n    # Create a stack and a list to store the elements\n    stack = deque()\n    b = []\n\n    # Create a list to store the remaining elements of the permutation\n    remaining = list(set(range(1, n + 1)) - set(p))\n\n    # Sort the remaining elements in descending order\n    remaining.sort(reverse=True)\n\n    # Iterate through the elements of the permutation\n    for i in range(n):\n        # If the stack is empty or the top element is less than or equal to the current element, push it onto the stack\n        if not stack or stack[-1] <= p[i]:\n            stack.append(p[i])\n        # Otherwise, append the top element of the stack to the list\n        else:\n            b.append(stack.pop())\n\n        # While the stack is not empty and the top element is less than or equal to the current remaining element, append it to the list\n        while stack and stack[-1] <= remaining[-1]:\n            b.append(stack.pop())\n\n        # If the current element is less than the current remaining element, append it to the list\n        if i < k and p[i] < remaining[-1]:\n            b.append(remaining.pop())\n\n    # If the stack is not empty, append the remaining elements in descending order\n    while stack:\n        b.append(stack.pop())\n\n    # Check if the list is sorted in non-descending order\n    if b == sorted(b):\n        # If it is, print the lexicographically maximal permutation\n        print(*p, *sorted(remaining, reverse=True))\n    else:\n        # Otherwise, print -1\n        print(-1)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "def does_b_appear_in_sequence(a, b, c):\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n# Get input\na, b, c = map(int, input().split())\n\n# Print output\nprint(does_b_appear_in_sequence(a, b, c))"}
{"solution": "def can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    if cnt_1 == cnt_4:\n        return 1\n    else:\n        return 0\n\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\nprint(can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4))"}
{"solution": "def calculate_standing_spectators(n, k, t):\n    # If t is less than or equal to k, all t spectators are standing\n    if t <= k:\n        return t\n    # If t is greater than n, no spectators are standing\n    elif t > n:\n        return 0\n    # If t is between k and n, calculate the number of standing spectators\n    else:\n        # The wave completes a full cycle every k spectators, so we can calculate the equivalent time within a cycle\n        t_within_cycle = t % k\n        # If the equivalent time is less than or equal to the remaining spectators after the wave has passed, those spectators are standing\n        if t_within_cycle <= n % k:\n            return k\n        # Otherwise, the number of standing spectators is the remaining spectators after the wave has passed, minus the spectators who have already sat down\n        else:\n            return n % k - (t_within_cycle - (n % k))\n\n# Get the input values\nn, k, t = map(int, input().split())\n# Calculate the number of standing spectators\nstanding_spectators = calculate_standing_spectators(n, k, t)\n# Print the result\nprint(standing_spectators)"}
{"solution": "def lexicographically_minimal_string(s):\n    t = []\n    u = []\n    min_char = min(s)\n    s = list(s)\n\n    while s or t:\n        if t and (not s or t[-1] <= min_char):\n            u.append(t.pop())\n        else:\n            char = s.pop(0)\n            t.append(char)\n            if s:\n                min_char = min(s)\n\n    return ''.join(u)\n\ns = input().strip()\nprint(lexicographically_minimal_string(s))"}
{"solution": "def check_records(n, records):\n    prev_plays, prev_clears = records[0]\n    for plays, clears in records[1:]:\n        if plays < prev_plays or clears < prev_clears or clears > plays:\n            return False\n        prev_plays, prev_clears = plays, clears\n    return True\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        records = [list(map(int, input().split())) for _ in range(n)]\n        if check_records(n, records):\n            print('YES')\n        else:\n            print('NO')\n\nif __name__ == '__main__':\n    main()"}
{"solution": "def next_palindrome(time):\n    hours, minutes = map(int, time.split(':'))\n    while True:\n        minutes += 1\n        if minutes == 60:\n            minutes = 0\n            hours = (hours + 1) % 24\n        time = f\"{hours:02d}:{minutes:02d}\"\n        if time == time[::-1]:\n            return minutes\n\ndef main():\n    time = input()\n    print(next_palindrome(time))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the indices of the minimum and maximum elements\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Calculate the current distance between the minimum and maximum elements\ncurrent_distance = abs(min_index - max_index)\n\n# Calculate the maximum possible distance by considering all possible swaps\nmax_distance = max(min_index, n - 1 - max_index, max_index, n - 1 - min_index)\n\n# Print the maximum possible distance\nprint(max_distance)"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    mid = n // 2\n    if n % 2 == 0:\n        first_half = s[:mid]\n        second_half = s[mid:]\n    else:\n        first_half = s[:mid]\n        second_half = s[mid+1:]\n\n    if first_half == second_half[::-1]:\n        return \"TAK\"\n    else:\n        return \"NIE\"\n\n# Read the input string\ns = input().strip()\n\n# Print the result\nprint(is_s_palindrome(s))"}
{"solution": "from collections import Counter\n\ndef max_permutation(a, b):\n    a_counter = Counter(str(a))\n    b_counter = Counter(str(b))\n\n    result = []\n    for digit in sorted(a_counter.keys(), reverse=True):\n        while a_counter[digit] > 0 and b_counter[digit] > 0:\n            result.append(digit)\n            a_counter[digit] -= 1\n            b_counter[digit] -= 1\n\n    for digit in sorted(a_counter.keys(), reverse=True):\n        while a_counter[digit] > 0:\n            result.append(digit)\n            a_counter[digit] -= 1\n\n    return ''.join(result)\n\na = int(input())\nb = int(input())\n\nprint(max_permutation(a, b))"}
{"solution": "def check_win(board, player):\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i][j] = player\n                if check_line(board, player, i, j, 1, 0) or check_line(board, player, i, j, 0, 1) or check_line(board, player, i, j, 1, 1) or check_line(board, player, i, j, 1, -1):\n                    return True\n                board[i][j] = '.'\n    return False\n\ndef check_line(board, player, x, y, dx, dy):\n    count = 1\n    for i in range(1, 5):\n        nx, ny = x + i * dx, y + i * dy\n        if 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == player:\n            count += 1\n        else:\n            break\n    for i in range(1, 5):\n        nx, ny = x - i * dx, y - i * dy\n        if 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == player:\n            count += 1\n        else:\n            break\n    return count >= 5\n\nboard = [list(input()) for _ in range(10)]\nif check_win(board, 'X'):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def solve(n, k):\n    if k > n * n or k < n:\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            if k >= n - i:\n                matrix[i][j] = matrix[j][i] = 1\n                k -= 2\n            if i == j and k > 0:\n                matrix[i][j] = 1\n                k -= 1\n\n    return matrix\n\nn, k = map(int, input().split())\nresult = solve(n, k)\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))"}
{"solution": "from itertools import permutations, product\n\n# Get the input\nx, y, z = map(float, input().split())\n\n# Generate all possible expressions\nexpressions = []\nfor order in permutations([x, y, z]):\n    for exp in product(range(2), repeat=3):\n        if exp == (0, 0, 0):\n            continue\n        expr = f\"{order[0]}^{order[1]}^{order[2]}\" if exp == (1, 1, 1) else f\"({order[0]}^{order[1]})^{order[2]}\" if exp == (1, 0, 1) else f\"({order[0]}^{order[2]})^{order[1]}\"\n        expressions.append((eval(expr), expr))\n\n# Find the maximum expression\nmax_expression = max(expressions, key=lambda x: x[0])\n\n# Print the result\nprint(max_expression[1])"}
{"solution": "def min_operations(n, s):\n    # Initialize the minimum operations as the length of the string\n    min_ops = n\n\n    # Iterate over all possible prefixes of the string\n    for i in range(1, n // 2 + 1):\n        # If the prefix repeats to form the string\n        if n % i == 0 and s[:i] * (n // i) == s:\n            # Update the minimum operations\n            min_ops = i + 1\n            break\n\n    return min_ops\n\n# Read the input\nn = int(input())\ns = input()\n\n# Print the minimum number of operations\nprint(min_operations(n, s))"}
{"solution": "# Read the number of files\nn = int(input())\n\n# Initialize lists for examples and regular tests\nexamples = []\nregular_tests = []\n\n# Read the files and their types\nfor _ in range(n):\n    name, type = input().split()\n    if type == '1':\n        examples.append(name)\n    else:\n        regular_tests.append(name)\n\n# Initialize the script and the counter for renaming\nscript = []\ncounter = 1\n\n# Rename examples\nfor example in examples:\n    script.append(f'move {example} {counter}')\n    counter += 1\n\n# Rename regular tests\nfor regular_test in regular_tests:\n    script.append(f'move {regular_test} {counter}')\n    counter += 1\n\n# Print the minimum number of lines in the script\nprint(len(script))\n\n# Print the script\nfor line in script:\n    print(line)"}
{"solution": "def min_changes_to_lucky(ticket):\n    # Calculate the sum of the first three digits and the last three digits\n    first_half_sum = sum(int(digit) for digit in ticket[:3])\n    second_half_sum = sum(int(digit) for digit in ticket[3:])\n\n    # If the sums are equal, no changes are needed\n    if first_half_sum == second_half_sum:\n        return 0\n\n    # Calculate the difference between the sums\n    diff = abs(first_half_sum - second_half_sum)\n\n    # Calculate the number of changes needed to balance the difference\n    # This is done by dividing the difference by 9 (maximum digit value)\n    # and rounding up to the nearest integer\n    changes_needed = (diff + 8) // 9\n\n    return changes_needed\n\n# Get the ticket number as input\nticket = input()\n\n# Print the minimum number of changes needed to make the ticket lucky\nprint(min_changes_to_lucky(ticket))"}
{"solution": "def minimum_traps(m, x):\n    return m - 1\n\n# Read input\nm, x = map(int, input().split())\n\n# Print output\nprint(minimum_traps(m, x))"}
{"solution": "def extended_euclidean(a, b):\n    if a == 0:\n        return b, 0, 1\n    else:\n        g, y, x = extended_euclidean(b % a, a)\n        return g, x - (b // a) * y, y\n\ndef mod_inverse(a, m):\n    g, x, y = extended_euclidean(a, m)\n    if g != 1:\n        raise Exception('The modular inverse does not exist.')\n    else:\n        return x % m\n\ndef birthday_paradox(n, k):\n    MOD = 10**6 + 3\n    days = pow(2, n, MOD)\n    numerator = denominator = 1\n\n    for i in range(days - k + 1, days + 1):\n        numerator = (numerator * i) % MOD\n\n    for i in range(1, k):\n        denominator = (denominator * i) % MOD\n\n    probability = (numerator * mod_inverse(denominator, MOD)) % MOD\n    return MOD - probability, MOD\n\nn, k = map(int, input().split())\nA, B = birthday_paradox(n, k)\nprint(A, B)"}
{"solution": "# Read the number of instructions\nn = int(input())\n\n# Initialize Limak's position\nposition = (0, 0)\n\n# Iterate through each instruction\nfor _ in range(n):\n    # Read the instruction\n    t, direction = input().split()\n    t = int(t)\n\n    # Update Limak's position based on the instruction\n    if direction == \"North\":\n        position = (position[0], position[1] + t)\n    elif direction == \"South\":\n        position = (position[0], position[1] - t)\n    elif direction == \"East\":\n        position = (position[0] + t, position[1])\n    elif direction == \"West\":\n        position = (position[0] - t, position[1])\n\n    # Check if Limak is on the North Pole and moving to the South\n    if position[1] > 0 and direction == \"South\":\n        print(\"NO\")\n        exit()\n\n    # Check if Limak is on the South Pole and moving to the North\n    if position[1] < 0 and direction == \"North\":\n        print(\"NO\")\n        exit()\n\n# Check if Limak is on the North Pole at the end of the journey\nif position[1] == 20000:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def find_common_integers(a1, b1, a2, b2, L, R):\n    # If the progressions have the same difference\n    if a1 == a2:\n        # If the first terms are equal or the difference is 0, all numbers in the range are common\n        if b1 == b2 or a1 == 0:\n            return max(0, min(R, (R - b1) // a1 + 1) - max(L, (L - b1) // a1))\n        # If the difference is not 0, check if there's a common number in the range\n        elif (b2 - b1) % a1 == 0:\n            x = b1 + (b2 - b1) // a1 * a1\n            return 1 if L <= x <= R else 0\n        else:\n            return 0\n    # If the progressions have different differences\n    else:\n        # Calculate the common difference\n        common_diff = abs(a1 * a2)\n        # Calculate the new first terms\n        new_b1 = b1 - L\n        new_b2 = b2 - L\n        # Calculate the number of common integers\n        if new_b1 % common_diff == new_b2 % common_diff:\n            return max(0, (min(R, L + max(new_b1, new_b2)) - max(L, L + min(new_b1, new_b2))) // common_diff + 1)\n        else:\n            return 0\n\n# Read the input\na1, b1, a2, b2, L, R = map(int, input().split())\n# Print the output\nprint(find_common_integers(a1, b1, a2, b2, L, R))"}
{"solution": "def max_cake_pieces(n, a, b):\n    # Initialize the maximum possible number of pieces on each plate\n    x = 0\n\n    # While it's possible to distribute the cakes according to the conditions\n    while a >= n and b >= n and a + b >= n:\n        # Distribute the cakes to the plates\n        if a >= n:\n            a -= n\n        else:\n            n -= a\n            a = 0\n\n        if b >= n:\n            b -= n\n        else:\n            n -= b\n            b = 0\n\n        # Increment the number of pieces on each plate\n        x += 1\n\n    # Return the maximum possible number of pieces on each plate\n    return x\n\n# Read the input\nn, a, b = map(int, input().split())\n\n# Calculate the maximum possible number of pieces on each plate\nresult = max_cake_pieces(n, a, b)\n\n# Print the result\nprint(result)"}
{"solution": "def check_flag(flag):\n    # Check if the flag is divisible into three equal stripes\n    if len(flag) % 3 != 0:\n        return False\n    stripe_height = len(flag) // 3\n\n    # Check if each stripe is of equal height\n    for i in range(0, len(flag), stripe_height):\n        if flag[i:i+stripe_height] != flag[i:i+stripe_height][0] * stripe_height:\n            return False\n\n    # Check if each color is used exactly once\n    colors = set(flag[0::stripe_height])\n    if len(colors) != 3 or 'R' not in colors or 'G' not in colors or 'B' not in colors:\n        return False\n\n    return True\n\n# Get the input\nn, m = map(int, input().split())\nflag = ''.join(input() for _ in range(n))\n\n# Check the flag and print the result\nif check_flag(flag):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def calculate_coordinates(n):\n    # Calculate the ring number and the number of moves in the current ring\n    ring = int((n + 1) ** 0.5)\n    if ring * (ring - 1) >= n:\n        ring -= 1\n    moves_in_ring = n - ring * (ring - 1)\n\n    # Calculate the x and y coordinates based on the ring number and the number of moves in the current ring\n    if moves_in_ring <= ring:\n        x = moves_in_ring - 1\n        y = ring - 1\n    elif moves_in_ring <= 2 * ring:\n        x = ring - 1\n        y = 2 * ring - moves_in_ring - 1\n    elif moves_in_ring <= 3 * ring:\n        x = 3 * ring - moves_in_ring - 1\n        y = -ring\n    elif moves_in_ring <= 4 * ring:\n        x = -ring\n        y = moves_in_ring - 3 * ring\n    elif moves_in_ring <= 5 * ring:\n        x = moves_in_ring - 5 * ring\n        y = ring\n    else:\n        x = ring\n        y = 5 * ring - moves_in_ring\n\n    return x, y\n\n# Get the input from the user\nn = int(input())\n\n# Calculate and print the coordinates\nx, y = calculate_coordinates(n)\nprint(x, y)"}
{"solution": "import math\n\ndef can_break_shield(a, b, c):\n    # Calculate the greatest common divisor of a and b\n    gcd_ab = math.gcd(a, b)\n\n    # Check if c is divisible by the gcd of a and b\n    if c % gcd_ab == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input values\na, b, c = map(int, input().split())\n\n# Output the result\nprint(can_break_shield(a, b, c))"}
{"solution": "def can_tracks_coincide(n, L, kefa_barriers, sasha_barriers):\n    # Calculate distances between consecutive barriers for Kefa\n    kefa_distances = [(kefa_barriers[(i + 1) % n] - kefa_barriers[i]) % L for i in range(n)]\n    # Calculate distances between consecutive barriers for Sasha\n    sasha_distances = [(sasha_barriers[(i + 1) % n] - sasha_barriers[i]) % L for i in range(n)]\n\n    # Double the kefa_distances to handle circular rotation\n    doubled_kefa_distances = kefa_distances + kefa_distances\n\n    # Check if sasha_distances is a sublist of doubled_kefa_distances\n    for i in range(n):\n        if doubled_kefa_distances[i:i + n] == sasha_distances:\n            return \"YES\"\n\n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_barriers, sasha_barriers))"}
{"solution": "def longest_non_palindrome_substring(s):\n    n = len(s)\n    max_length = 0\n\n    # Check all substrings\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            # Check if the substring is not a palindrome\n            if substring != substring[::-1]:\n                # Update the maximum length\n                max_length = max(max_length, len(substring))\n\n    return max_length\n\n# Read the input\ns = input()\n# Print the output\nprint(longest_non_palindrome_substring(s))"}
{"solution": "n = int(input())\nratings = [list(map(int, input().split())) for _ in range(n)]\n\n# Check if any rating has changed\nif any(a != b for a, b in ratings):\n    print(\"rated\")\nelse:\n    # Check if the standings are in non-increasing order of ratings\n    if all(ratings[i][0] >= ratings[i+1][0] for i in range(n-1)):\n        print(\"unrated\")\n    else:\n        print(\"maybe\")"}
{"solution": "# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Initialize the result array\nresult = [0] * n\n\n# Initialize the last zero index\nlast_zero_index = float('-inf')\n\n# Iterate over the array from left to right\nfor i in range(n):\n    # If the current element is zero, update the last zero index\n    if arr[i] == 0:\n        last_zero_index = i\n    # Otherwise, calculate the distance to the last zero index\n    else:\n        result[i] = i - last_zero_index\n\n# Initialize the last zero index\nlast_zero_index = float('inf')\n\n# Iterate over the array from right to left\nfor i in range(n-1, -1, -1):\n    # If the current element is zero, update the last zero index\n    if arr[i] == 0:\n        last_zero_index = i\n    # Otherwise, update the distance to the last zero index if it's closer\n    else:\n        result[i] = min(result[i], last_zero_index - i)\n\n# Print the result\nprint(*result)"}
{"solution": "def count_distinct_cyclical_strings(n, s):\n    from itertools import product\n\n    def is_substring_in_cyclical_shifts(t, s):\n        t_extended = t + t\n        return any(s in t_extended[i:i+len(t)] for i in range(len(t)))\n\n    distinct_cyclical_strings = set()\n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if is_substring_in_cyclical_shifts(t, s):\n            distinct_cyclical_strings.add(t)\n\n    return len(distinct_cyclical_strings)\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Print output\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import math\n\n# Function to calculate the angle between two vectors\ndef angle_between(v1, v2):\n    dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n    magnitude_product = math.sqrt(v1[0]**2 + v1[1]**2) * math.sqrt(v2[0]**2 + v2[1]**2)\n    return math.acos(dot_product / magnitude_product)\n\n# Function to find the pair of vectors with the minimal non-oriented angle\ndef find_min_angle(vectors):\n    min_angle = math.pi\n    min_pair = (0, 0)\n    for i in range(len(vectors)):\n        for j in range(i+1, len(vectors)):\n            angle = angle_between(vectors[i], vectors[j])\n            if angle < min_angle:\n                min_angle = angle\n                min_pair = (i, j)\n    return min_pair\n\n# Read the input\nn = int(input())\nvectors = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    vectors.append((x, y))\n\n# Find the pair of vectors with the minimal non-oriented angle\nmin_pair = find_min_angle(vectors)\n\n# Print the output\nprint(min_pair[0] + 1, min_pair[1] + 1)"}
{"solution": "def minimal_time(d, k, a, b, t):\n    if d <= k:\n        return d * a\n\n    # Full segments\n    full_segments = d // k\n    remaining_distance = d % k\n\n    # Time for full segments\n    time_for_full_segments = full_segments * k * a + (full_segments - 1) * t\n\n    # Time for remaining distance\n    if remaining_distance == 0:\n        return time_for_full_segments\n    else:\n        # Option 1: Drive the remaining distance\n        time_drive_remaining = remaining_distance * a + t\n        # Option 2: Walk the remaining distance\n        time_walk_remaining = remaining_distance * b\n\n        return time_for_full_segments + min(time_drive_remaining, time_walk_remaining)\n\n# Get input\nd, k, a, b, t = map(int, input().split())\n\n# Print output\nprint(minimal_time(d, k, a, b, t))"}
{"solution": "def solve(n, k):\n    # Calculate the sum of an arithmetic series\n    def sum_arithmetic_series(a, d, n):\n        return n * (2 * a + (n - 1) * d) // 2\n\n    # Check if it's possible to create the sequence\n    def is_possible(a, d, n, k):\n        return sum_arithmetic_series(a, d, k) <= n\n\n    # Binary search for the maximum difference\n    left, right = 1, n\n    while left < right:\n        mid = (left + right + 1) // 2\n        if is_possible(1, mid, k, n):\n            left = mid\n        else:\n            right = mid - 1\n\n    # Check if it's possible to create the sequence\n    if not is_possible(1, left, k, n):\n        return [-1]\n\n    # Create the sequence\n    sequence = list(range(1, left + 1))\n    remaining = n - sum_arithmetic_series(1, left, k)\n    sequence[-1] += remaining\n\n    return sequence\n\n# Read input\nn, k = map(int, input().split())\n\n# Print output\nprint(*solve(n, k))"}
{"solution": "def count_pairs(n, m):\n    # Count the number of multiples of 5 in the range [1, n] and [1, m]\n    n_multiples_of_5 = n // 5\n    m_multiples_of_5 = m // 5\n\n    # Count the number of pairs that sum to a multiple of 5\n    pairs = n_multiples_of_5 * m + m_multiples_of_5 * n - n_multiples_of_5 * m_multiples_of_5\n\n    return pairs\n\n# Read the input\nn, m = map(int, input().split())\n\n# Print the result\nprint(count_pairs(n, m))"}
{"solution": "def max_beauty(n, x, a):\n    # Initialize variables\n    max_sum = 0\n    current_sum = 0\n    max_subarray_sum = 0\n    max_subarray_sum_with_x = 0\n\n    # Iterate through the array\n    for i in range(n):\n        # Calculate current sum\n        current_sum = max(a[i], current_sum + a[i])\n\n        # Update max sum\n        max_sum = max(max_sum, current_sum)\n\n        # Calculate max subarray sum\n        max_subarray_sum = max(max_subarray_sum, current_sum - max_sum)\n\n        # Calculate max subarray sum with x\n        max_subarray_sum_with_x = max(max_subarray_sum_with_x, current_sum + max_subarray_sum * (x - 1))\n\n    # Return the maximum possible beauty\n    return max(max_sum, max_subarray_sum_with_x)\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print output\nprint(max_beauty(n, x, a))"}
{"solution": "def find_kth_largest(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(m, x // i)\n        return count\n\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_less_equal(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\nn, m, k = map(int, input().split())\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    if k < 10:\n        return k\n\n    base = 9\n    digits = 1\n\n    while k > base * digits:\n        k -= base * digits\n        base *= 10\n        digits += 1\n\n    start_number = 10 ** (digits - 1)\n    number = start_number + (k - 1) // digits\n    position = (k - 1) % digits\n\n    return int(str(number)[position])\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "# Read input\nn, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Find the minimum buying price and the maximum selling price\nmin_buy = min(s)\nmax_sell = max(b)\n\n# Calculate the maximum number of bourles that can be held after the evening\nif min_buy < max_sell:\n    # Buy shares at the minimum price and sell them at the maximum price\n    max_bourles = r // min_buy * max_sell + r % min_buy\nelse:\n    # Don't take any action\n    max_bourles = r\n\n# Print the result\nprint(max_bourles)"}
{"solution": "def find_original_message(t):\n    n = len(t)\n\n    # Iterate over all possible overlap lengths\n    for overlap in range(1, n // 2 + 1):\n        # Check if the string t can be split into two parts with overlap length\n        if t[:overlap] == t[-overlap:]:\n            s = t[:-overlap]\n            if s + t[-overlap:] == t:\n                return \"YES\", s\n\n    return \"NO\", None\n\n# Read input\nt = input().strip()\n\n# Find possible message s\nresult, s = find_original_message(t)\n\n# Print result\nprint(result)\nif result == \"YES\":\n    print(s)"}
{"solution": "def find_teams(n):\n    # INTJs are good at recognizing patterns and making connections\n    # In this problem, we can see that the number of games is a triangular number\n    # So, we need to find a triangular number that equals to n\n    # A triangular number is the sum of an arithmetic series: 1 + 2 + 3 + ... + k = k*(k+1)/2\n    # We can solve this equation to find k: k = (-1 + sqrt(1 + 8*n)) / 2\n    # If k is an integer, then n is a triangular number\n    # If k is not an integer, then n is not a triangular number\n    # If k is an integer, we can calculate the number of teams by adding 1 to k\n    # If k is not an integer, we can check if n - k*(k+1)/2 is a triangular number\n    # If it is, then the number of teams is k + 1\n    # If it is not, then there is no solution\n\n    k = (-1 + (1 + 8*n)**0.5) / 2\n    if k == int(k):\n        return int(k + 1)\n    else:\n        k = int(k)\n        if (n - k*(k+1)//2) * 2 == (k + 1) * (k + 2):\n            return k + 1\n        else:\n            return -1\n\nn = int(input())\nprint(find_teams(n))"}
{"solution": "# Read input\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\n# Sort characters and their beauty values in descending order\ns = sorted(s)\nb = sorted(b, reverse=True)\n\n# Initialize beauty of the result string\nmax_beauty = 0\n\n# Iterate over the first half of the string\nfor i in range(n // 2):\n    # Place the largest possible character in the antipalindromic position\n    if s[i] != s[n - i - 1]:\n        max_beauty += b[i]\n    else:\n        # If the characters are the same, place the larger beauty value in the result\n        max_beauty += max(b[i], b[n - i - 1])\n        # Remove the used beauty value\n        b.remove(max(b[i], b[n - i - 1]))\n\n# Print the maximum possible beauty\nprint(max_beauty)"}
{"solution": "def can_weigh(w, m):\n    # If the item's mass is less than or equal to the weight, it can be weighed\n    if m <= w:\n        return True\n\n    # If the item's mass is odd, it can be weighed if and only if the weight is odd\n    if m % 2 != 0:\n        return w % 2 != 0\n\n    # If the item's mass is even and the weight is odd, it can be weighed\n    if w % 2 != 0:\n        return True\n\n    # If the item's mass is even and the weight is even, it can be weighed if and only if\n    # half of the item's mass can be weighed using the given weights\n    return can_weigh(w, m // 2)\n\nw, m = map(int, input().split())\nprint('YES' if can_weigh(w, m) else 'NO')"}
{"solution": "def find_sequence(n, k):\n    sequence = []\n    i = 63  # start from the largest possible power of 2\n    while n > 0 and k > 0:\n        if n & (1 << i):  # check if the current power of 2 is less than or equal to n\n            sequence.append(i)\n            n -= (1 << i)\n            k -= 1\n        i -= 1\n    if n > 0 or k > 0:  # check if it's possible to find a valid sequence\n        return \"No\"\n    else:\n        return \"Yes\\n\" + \" \".join(map(str, sequence))\n\nn, k = map(int, input().split())\nprint(find_sequence(n, k))"}
{"solution": "def champagne_pyramid(n, t):\n    # Initialize the pyramid with 0s\n    pyramid = [[0.0] * i for i in range(1, n + 1)]\n\n    # Pour champagne into the top glass\n    pyramid[0][0] = t\n\n    # Simulate the flow of champagne\n    for i in range(n - 1):\n        for j in range(i + 1):\n            # If the current glass is full\n            if pyramid[i][j] >= 1:\n                # Distribute the overflow to the two glasses below\n                overflow = pyramid[i][j] - 1\n                pyramid[i][j] = 1\n                pyramid[i + 1][j] += overflow / 2\n                pyramid[i + 1][j + 1] += overflow / 2\n\n    # Count the number of full glasses\n    full_glasses = sum(glass == 1 for row in pyramid for glass in row)\n\n    return full_glasses\n\n# Read the input\nn, t = map(int, input().split())\n\n# Print the output\nprint(champagne_pyramid(n, t))"}
{"solution": "def calculate_area(n, vertices):\n    if n == 1:\n        return -1\n    elif n == 2:\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        if x1 != x2 and y1 != y2:\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 3:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 4:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n\n# Read input\nn = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the area\nprint(calculate_area(n, vertices))"}
{"solution": "# Get the input values\nn = int(input())\na = int(input())\nb = int(input())\n\n# Calculate the number of wooden bars needed for each side\nleft_right_bars = 2 * 2  # 2 doors, 2 sides each\ntop_bars = 2  # 2 doors, 1 top side each\n\n# Calculate the total length needed for all sides\ntotal_length = left_right_bars * a + top_bars * b\n\n# Calculate the minimal number of wooden bars needed\nmin_bars = total_length // n\nif total_length % n != 0:\n    min_bars += 1\n\n# Print the result\nprint(min_bars)"}
{"solution": "def can_sort_array(n, arr, swaps):\n    # Create a list of tuples, where each tuple contains the element and its index\n    indexed_arr = [(arr[i], i) for i in range(n)]\n\n    # Sort the list of tuples based on the elements\n    indexed_arr.sort()\n\n    # Iterate through the sorted list of tuples\n    for i in range(n):\n        # If the current element's index is not equal to its sorted index\n        if indexed_arr[i][1] != i:\n            # Find the index of the element that should be swapped with the current element\n            j = indexed_arr[i][1]\n\n            # Check if swapping is allowed between the current element and the element at index j\n            if swaps[j - 1] == '0':\n                # If swapping is not allowed, return False\n                return False\n\n            # Swap the elements in the original array\n            arr[i], arr[j] = arr[j], arr[i]\n\n            # Update the index of the swapped element in the sorted list of tuples\n            indexed_arr[i], indexed_arr[j] = indexed_arr[j], indexed_arr[i]\n\n    # If the loop completes without returning False, return True\n    return True\n\n# Read the input\nn = int(input())\narr = list(map(int, input().split()))\nswaps = input()\n\n# Check if the array can be sorted and print the result\nif can_sort_array(n, arr, swaps):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def calculate_time(seat):\n    row = int(seat[:-1])\n    column = seat[-1]\n\n    # Calculate the time taken to serve the rows before Vasya's row\n    time = (row - 1) // 2 * 6\n\n    # Calculate the time taken to serve the rows of Vasya's group\n    if row % 2 == 0:\n        time += (row // 2 - 1) * 6\n    else:\n        time += (row // 2) * 6\n\n    # Calculate the time taken to serve the seats before Vasya's seat\n    if column in ['f', 'e', 'd']:\n        time += 3\n    elif column in ['c', 'b']:\n        time += 2\n\n    return time\n\nseat = input()\nprint(calculate_time(seat))"}
{"solution": "def convert_base(number, base):\n    return int(''.join(str(digit) for digit in number), base)\n\ndef compare_numbers():\n    n, b_x = map(int, input().split())\n    x = list(map(int, input().split()))\n    m, b_y = map(int, input().split())\n    y = list(map(int, input().split()))\n\n    x = convert_base(x, b_x)\n    y = convert_base(y, b_y)\n\n    if x < y:\n        print('<')\n    elif x > y:\n        print('>')\n    else:\n        print('=')\n\ncompare_numbers()"}
{"solution": "def game(a):\n    # If all integers are 0, BitAryo wins\n    if all(x == 0 for x in a):\n        return \"BitAryo\"\n\n    # Try all possible moves\n    for i in range(len(a)):\n        for x in range(1, min(a[i], min(a)) + 1):\n            # Make a copy of the sequence\n            b = list(a)\n            # Apply the move\n            b[i] -= x\n            # If BitAryo loses, BitLGM wins\n            if game(b) == \"BitAryo\":\n                return \"BitLGM\"\n\n    # If no move leads to BitAryo's loss, BitAryo wins\n    return \"BitAryo\"\n\n# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the winner\nprint(game(a))"}
{"solution": "from math import gcd\n\ndef valid_decks(n, k, deck):\n    # Calculate prefix and suffix products\n    prefix_products = [0] * (n + 1)\n    suffix_products = [0] * (n + 1)\n    prefix_products[0] = 1\n    suffix_products[n] = 1\n    for i in range(1, n + 1):\n        prefix_products[i] = prefix_products[i - 1] * deck[i - 1] % k\n        suffix_products[n - i] = suffix_products[n - i + 1] * deck[n - i] % k\n\n    # Calculate the greatest common divisor of the prefix and suffix products\n    gcd_values = [gcd(prefix_products[i], suffix_products[i]) for i in range(n + 1)]\n\n    # Count the number of valid decks\n    count = 0\n    for i in range(n + 1):\n        if gcd_values[i] % k == 0:\n            count += 1\n\n    return count\n\n# Read input\nn, k = map(int, input().split())\ndeck = list(map(int, input().split()))\n\n# Print output\nprint(valid_decks(n, k, deck))"}
{"solution": "# Read input\nn, k = map(int, input().split())\ns = input()\n\n# Count the occurrence of each color\ncolor_count = {}\nfor color in s:\n    if color in color_count:\n        color_count[color] += 1\n    else:\n        color_count[color] = 1\n\n# Check if it's possible to distribute the balloons\nfor count in color_count.values():\n    if count > k:\n        print(\"NO\")\n        exit()\n\nprint(\"YES\")"}
{"solution": "# Read the size of the array\nn = int(input())\n\n# Read the elements of the array\narr = list(map(int, input().split()))\n\n# Initialize variables to store the minimum value and its indices\nmin_val = float('inf')\nmin_indices = []\n\n# Iterate through the array to find the minimum value and its indices\nfor i in range(n):\n    if arr[i] < min_val:\n        min_val = arr[i]\n        min_indices = [i]\n    elif arr[i] == min_val:\n        min_indices.append(i)\n\n# Initialize a variable to store the minimum distance between two minimum values\nmin_distance = float('inf')\n\n# Iterate through the indices of the minimum values to find the minimum distance\nfor i in range(1, len(min_indices)):\n    min_distance = min(min_distance, min_indices[i] - min_indices[i-1])\n\n# Print the minimum distance\nprint(min_distance)"}
{"solution": "import math\n\ndef calculate_probability(t, w, b):\n    # Calculate the greatest common divisor (GCD)\n    gcd = math.gcd(w, b)\n\n    # Calculate the least common multiple (LCM)\n    lcm = w * b // gcd\n\n    # Calculate the number of racetrack lengths that are multiples of the LCM\n    multiples_of_lcm = t // lcm\n\n    # Calculate the probability\n    probability = multiples_of_lcm / t\n\n    return probability\n\n# Read the input\nt, w, b = map(int, input().split())\n\n# Calculate the probability\nprobability = calculate_probability(t, w, b)\n\n# Convert the probability to an irreducible fraction\nnumerator = probability.numerator\ndenominator = probability.denominator\n\n# Print the result\nprint(f\"{numerator}/{denominator}\")"}
{"solution": "# Get the input\nx, y, z = map(int, input().split())\n\n# Calculate the difference between upvotes and downvotes\ndiff = x - y\n\n# If there are no unknown votes\nif z == 0:\n    # If the difference is positive, print '+'\n    if diff > 0:\n        print('+')\n    # If the difference is negative, print '-'\n    elif diff < 0:\n        print('-')\n    # If the difference is zero, print '0'\n    else:\n        print('0')\n# If there are unknown votes\nelse:\n    # If the difference is positive and greater than z, print '+'\n    if diff > z:\n        print('+')\n    # If the difference is negative and less than -z, print '-'\n    elif diff < -z:\n        print('-')\n    # If the difference is between -z and z, print '?'\n    else:\n        print('?')"}
{"solution": "def min_changes(n, operations, x, y):\n    pos = [0, 0]\n    for op in operations:\n        if op == 'U':\n            pos[1] += 1\n        elif op == 'D':\n            pos[1] -= 1\n        elif op == 'R':\n            pos[0] += 1\n        elif op == 'L':\n            pos[0] -= 1\n\n    if pos[0] != x or pos[1] != y:\n        return -1\n\n    changes = 0\n    pos = [0, 0]\n    target = [x, y]\n    for i, op in enumerate(operations):\n        if pos == target:\n            break\n        if op == 'U':\n            pos[1] += 1\n        elif op == 'D':\n            pos[1] -= 1\n        elif op == 'R':\n            pos[0] += 1\n        elif op == 'L':\n            pos[0] -= 1\n        if pos != target:\n            changes += 1\n            if target[0] > pos[0]:\n                pos[0] += 1\n            elif target[0] < pos[0]:\n                pos[0] -= 1\n            if target[1] > pos[1]:\n                pos[1] += 1\n            elif target[1] < pos[1]:\n                pos[1] -= 1\n\n    return changes\n\nn = int(input())\noperations = input()\nx, y = map(int, input().split())\nprint(min_changes(n, operations, x, y))"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    T = int(data[0])\n    index = 1\n\n    results = []\n\n    for _ in range(T):\n        n = int(data[index])\n        x = int(data[index + 1])\n        s = data[index + 2]\n        index += 3\n\n        balance_s = s.count('0') - s.count('1')\n        prefix_balances = [0] * (n + 1)\n\n        for i in range(n):\n            prefix_balances[i + 1] = prefix_balances[i] + (1 if s[i] == '0' else -1)\n\n        if balance_s == 0:\n            if x in prefix_balances:\n                results.append(-1)\n            else:\n                results.append(0)\n        else:\n            count = 0\n            for b in prefix_balances:\n                if (x - b) % balance_s == 0 and (x - b) // balance_s >= 0:\n                    count += 1\n            results.append(count)\n\n    for result in results:\n        print(result)\n\nsolve()"}
{"solution": "# Get the input\nn, k = map(int, input().split())\n\n# Convert the number to string\nn = str(n)\n\n# Calculate the number of digits to delete\n# Start from the end of the number and count the zeros\n# Stop when we reach the k-th zero from the end\ncount = 0\nfor i in range(len(n) - 1, -1, -1):\n    if n[i] == '0':\n        count += 1\n        if count == k:\n            break\n\n# If we didn't find k zeros, we need to delete more digits\n# The number of digits to delete is the length of the number minus the position of the k-th zero from the end\nif count < k:\n    print(len(n) - i - 1)\n# Otherwise, the number of digits to delete is the number of zeros we found\nelse:\n    print(count)"}
{"solution": "def calculate_questions(n, m, k, x, y):\n    total_students = n * m\n    cycle_length = 2 * (n - 1) if n > 1 else 1\n    full_cycles = k // total_students\n    remaining_questions = k % total_students\n\n    max_questions = full_cycles * cycle_length + min(remaining_questions, y + (n - x) * (cycle_length // 2))\n    min_questions = full_cycles * cycle_length + max(0, min(remaining_questions - (n - x) * m, y) - (n - x) * (cycle_length // 2))\n\n    sergei_questions = full_cycles * cycle_length\n    if remaining_questions >= (x - 1) * m + y:\n        sergei_questions += 1 + (remaining_questions - (x - 1) * m - y) // total_students\n\n    return max_questions, min_questions, sergei_questions\n\nn, m, k, x, y = map(int, input().split())\nmax_questions, min_questions, sergei_questions = calculate_questions(n, m, k, x, y)\nprint(max_questions, min_questions, sergei_questions)"}
{"solution": "def calculate_beauty(ribbon, n):\n    length = len(ribbon)\n    max_beauty = 0\n    for i in range(length):\n        count = 0\n        for j in range(i, length):\n            if ribbon[j] == ribbon[i]:\n                count += 1\n            else:\n                break\n        max_beauty = max(max_beauty, count)\n    return min(max_beauty + n, length)\n\nn = int(input())\nribbons = [input() for _ in range(3)]\nbeauties = [calculate_beauty(ribbon, n) for ribbon in ribbons]\nmax_beauty = max(beauties)\nwinners = [\"Kuro\", \"Shiro\", \"Katie\"]\nif beauties.count(max_beauty) > 1:\n    print(\"Draw\")\nelse:\n    print(winners[beauties.index(max_beauty)])"}
{"solution": "def calculate_days(c, v_0, v_1, a, l):\n    days = 1\n    read_pages = v_0\n    while read_pages < c:\n        read_pages -= l\n        if read_pages + a > v_1:\n            read_pages += v_1\n        else:\n            read_pages += a\n        days += 1\n    return days\n\nc, v_0, v_1, a, l = map(int, input().split())\nprint(calculate_days(c, v_0, v_1, a, l))"}
{"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_prime_representation(n):\n    primes = [i for i in range(2, n) if is_prime(i)]\n    for i in range(3, 0, -1):\n        for j in range(len(primes)):\n            if primes[j] > n:\n                continue\n            if i == 1:\n                if n - primes[j] in primes:\n                    return [primes[j], n - primes[j]]\n            else:\n                for k in range(j, len(primes)):\n                    if primes[j] + primes[k] > n:\n                        break\n                    if i == 2:\n                        if n - primes[j] - primes[k] in primes:\n                            return [primes[j], primes[k], n - primes[j] - primes[k]]\n\nn = int(input())\nrepresentation = find_prime_representation(n)\nprint(len(representation))\nprint(' '.join(map(str, representation)))"}
{"solution": "# Read input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Count walls in each row and column\nrow_walls = [row.count('*') for row in grid]\ncol_walls = [col.count('*') for col in zip(*grid)]\n\n# Total number of walls\ntotal_walls = sum(row_walls)\n\n# Check each cell\nfor i in range(n):\n    for j in range(m):\n        # If the sum of walls in row i and column j minus the overlap at (i, j) equals the total number of walls\n        if row_walls[i] + col_walls[j] - (grid[i][j] == '*') == total_walls:\n            print('YES')\n            print(i + 1, j + 1)\n            exit()\n\n# If no such cell exists\nprint('NO')"}
{"solution": "# Get the input\nn, m, a, b = map(int, input().split())\n\n# Calculate the remainder of n divided by m\nremainder = n % m\n\n# If remainder is 0, no action is needed\nif remainder == 0:\n    print(0)\n# If building a box is cheaper than demolishing boxes\nelif a <= b:\n    # Calculate the number of boxes to build\n    build = m - remainder\n    print(build * a)\n# If demolishing a box is cheaper than building boxes\nelse:\n    # Calculate the cost of demolishing all boxes and building the necessary ones\n    demolish_all = n * b\n    build = remainder\n    print(min(demolish_all, build * a))"}
{"solution": "# Read input\nn = int(input())\nseq = list(map(int, input().split()))\n\n# Separate odd and even numbers\nodd_nums = [num for num in seq if num % 2 != 0]\neven_nums = [num for num in seq if num % 2 == 0]\n\n# Sort odd numbers in descending order\nodd_nums.sort(reverse=True)\n\n# If there are odd numbers, the maximum odd-sum subsequence is the sum of all odd numbers\nif odd_nums:\n    print(sum(odd_nums))\nelse:\n    # If there are no odd numbers, the maximum odd-sum subsequence is the largest even number\n    print(max(even_nums))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_playlists(n, T, songs):\n    dp = [[[0] * 4 for _ in range(4)] for _ in range(T + 1)]\n    dp[0][0][0] = 1\n\n    for i in range(1, T + 1):\n        for j in range(1, n + 1):\n            for k in range(1, 4):\n                if songs[j - 1][0] <= i:\n                    for l in range(1, 4):\n                        if l != k:\n                            dp[i][j][k] = (dp[i][j][k] + dp[i - songs[j - 1][0]][j - 1][l]) % MOD\n\n    return sum(dp[T][n]) % MOD\n\nn, T = map(int, input().split())\nsongs = [list(map(int, input().split())) for _ in range(n)]\nprint(count_playlists(n, T, songs))"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_inverse(n):\n    return pow(n, MOD - 2, MOD)\n\ndef expected_length(m):\n    dp = [0] * (m + 1)\n    dp[1] = 1\n    for i in range(2, m + 1):\n        for j in range(1, i + 1):\n            if i % j == 0:\n                dp[i] = (dp[i] + dp[j]) % MOD\n        dp[i] = (dp[i] * mod_inverse(i)) % MOD\n    return sum((i * dp[i]) % MOD for i in range(1, m + 1)) % MOD\n\nm = int(input())\nprint(expected_length(m))"}
{"solution": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_good_pairs(l, r, x, y):\n    count = 0\n    for a in range(l, r + 1):\n        for b in range(a, r + 1):\n            if gcd(a, b) == x and lcm(a, b) == y:\n                count += 1\n    return count\n\nl, r, x, y = map(int, input().split())\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "import math\n\ndef smallest_k(a, b):\n    gcd = math.gcd(a, b)\n    lcm = a * b // gcd\n    k = 0\n    while True:\n        if (a + k) % gcd == 0 and (b + k) % gcd == 0:\n            return k\n        k += 1\n\na, b = map(int, input().split())\nprint(smallest_k(a, b))"}
{"solution": "# Get the input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate the current average\ncurrent_avg = sum(marks) / n\n\n# Calculate the target average\ntarget_avg = k\n\n# Calculate the difference between the target and current average\ndiff = target_avg * n - sum(marks)\n\n# Calculate the minimum number of additional marks needed\n# Round up the difference to the nearest integer\nadditional_marks = round(diff)\n\n# If the difference is less than 0, no additional marks are needed\nif additional_marks < 0:\n    additional_marks = 0\n\n# Print the result\nprint(additional_marks)"}
{"solution": "n = int(input())\nnumbers = list(map(int, input().split()))\n\n# Iterate through possible values of d\nfor d in range(-1000, 1001):\n    if d == 0:\n        continue\n    positive_count = 0\n    for num in numbers:\n        if num / d > 0:\n            positive_count += 1\n    if positive_count >= (n + 1) // 2:\n        print(d)\n        break\nelse:\n    print(0)"}
{"solution": "def max_nines_pairs(n):\n    # Calculate the maximum possible number of nines at the end of the sum\n    max_nines = n // 10\n\n    # Calculate the number of pairs that sum to a number ending in max_nines\n    count = 0\n    for i in range(1, n - max_nines + 1):\n        j = max_nines * 10 - i\n        if j > n or j <= i:\n            break\n        count += 1\n\n    return count\n\n# Read the input\nn = int(input())\n\n# Compute and print the result\nresult = max_nines_pairs(n)\nprint(result)"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef solve(a1, b1, a2, b2):\n    if a1 * b1 < a2 * b2:\n        a1, b1, a2, b2 = a2, b2, a1, b1\n    if a1 == a2 and b1 == b2:\n        return 0, a1, b1, a2, b2\n    if a1 % 2 == 0 and a1 // 2 * b1 == a2 * b2:\n        return 1, a1 // 2, b1, a2, b2\n    if b1 % 2 == 0 and a1 * b1 // 2 == a2 * b2:\n        return 1, a1, b1 // 2, a2, b2\n    if a1 % 3 == 0 and a1 // 3 * b1 == a2 * b2:\n        return 1, a1 // 3, b1, a2, b2\n    if b1 % 3 == 0 and a1 * b1 // 3 == a2 * b2:\n        return 1, a1, b1 // 3, a2, b2\n    if a2 % 2 == 0 and a1 * b1 == a2 // 2 * b2:\n        return 1, a1, b1, a2 // 2, b2\n    if b2 % 2 == 0 and a1 * b1 == a2 * b2 // 2:\n        return 1, a1, b1, a2, b2 // 2\n    if a2 % 3 == 0 and a1 * b1 == a2 // 3 * b2:\n        return 1, a1, b1, a2 // 3, b2\n    if b2 % 3 == 0 and a1 * b1 == a2 * b2 // 3:\n        return 1, a1, b1, a2, b2 // 3\n    if gcd(a1, a2) > 1:\n        return 2, a1 // gcd(a1, a2), b1, a2 // gcd(a1, a2), b2\n    if gcd(b1, b2) > 1:\n        return 2, a1, b1 // gcd(b1, b2), a2, b2 // gcd(b1, b2)\n    return -1, 0, 0, 0, 0\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\nm, a1, b1, a2, b2 = solve(a1, b1, a2, b2)\nprint(m)\nprint(a1, b1)\nprint(a2, b2)"}
{"solution": "def determine_winner(x_p, y_p, x_v, y_v):\n    # If either player is already at (0, 0), return the player's name\n    if (x_p, y_p) == (0, 0):\n        return \"Polycarp\"\n    if (x_v, y_v) == (0, 0):\n        return \"Vasiliy\"\n\n    # If Vasiliy is to the right or above Polycarp, he cannot win\n    if x_v >= x_p or y_v >= y_p:\n        return \"Polycarp\"\n\n    # Calculate the total number of moves needed for Polycarp to reach (0, 0)\n    total_moves_p = x_p + y_p\n\n    # Calculate the total number of moves needed for Vasiliy to reach (0, 0)\n    # Vasiliy can move diagonally, so we need to consider the maximum of x_v and y_v\n    total_moves_v = max(x_v, y_v)\n\n    # If Polycarp needs an even number of moves and Vasiliy needs an odd number of moves,\n    # or if Polycarp needs fewer moves, then Polycarp wins\n    if (total_moves_p % 2 == 0 and total_moves_v % 2 == 1) or total_moves_p < total_moves_v:\n        return \"Polycarp\"\n    else:\n        return \"Vasiliy\"\n\n# Get the input\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Print the winner\nprint(determine_winner(x_p, y_p, x_v, y_v))"}
{"solution": "# Define the number of days in each month\ndays_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n# Get the input\nm, d = map(int, input().split())\n\n# Calculate the number of days in the first partial week\nfirst_partial_week = 7 - d + 1\n\n# Calculate the number of full weeks\nfull_weeks = (days_in_month[m - 1] - first_partial_week) // 7\n\n# Calculate the number of days in the last partial week\nlast_partial_week = (days_in_month[m - 1] - first_partial_week) % 7\n\n# Calculate the total number of columns needed\nif last_partial_week == 0:\n    columns = full_weeks\nelse:\n    columns = full_weeks + 1\n\n# Print the result\nprint(columns)"}
{"solution": "def count_zeros(n):\n    binary = bin(n)[2:]\n    return binary.count('0')\n\ndef count_years(a, b):\n    count = 0\n    for year in range(a, b + 1):\n        if count_zeros(year) == 1:\n            count += 1\n    return count\n\na, b = map(int, input().split())\nprint(count_years(a, b))"}
{"solution": "def minimal_layers(N):\n    return (N * (N + 1)) // 2\n\nN = int(input())\nprint(minimal_layers(N))"}
{"solution": "import sys\nfrom math import factorial\n\ndef solve(n, k, S, a):\n    dp = [[0] * (S + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(S + 1):\n            dp[i][j] = dp[i - 1][j]\n            if a[i - 1] <= j:\n                dp[i][j] += dp[i - 1][j - a[i - 1]]\n            if k > 0 and a[i - 1] <= 20 and factorial(a[i - 1]) <= j:\n                dp[i][j] += dp[i - 1][j - factorial(a[i - 1])]\n\n    return dp[n][S]\n\ndef main():\n    n, k, S = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    print(solve(n, k, S, a))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_transform(n, k, a):\n    v = [0] * n\n    i = 0\n    while i < n:\n        if a[i] == v[i]:\n            i += 1\n        elif a[i] < v[i]:\n            return False\n        else:\n            diff = a[i] - v[i]\n            j = 0\n            while (k ** j) <= diff:\n                if (diff // (k ** j)) % k != 0:\n                    v[i] += k ** j\n                    diff -= k ** j\n                j += 1\n            if diff > 0:\n                return False\n    return True\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        n, k = map(int, input().split())\n        a = list(map(int, input().split()))\n        print(\"YES\" if can_transform(n, k, a) else \"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef calculate_sum(a, b, c):\n    mod = 1073741824\n    total = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                total = (total + count_divisors(i * j * k)) % mod\n    return total\n\na, b, c = map(int, input().split())\nprint(calculate_sum(a, b, c))"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    neighbors = []\n    idx = state.index('X')\n    if idx == 0:\n        neighbors.append(swap(state, 0, 1))\n        neighbors.append(swap(state, 0, 2))\n    elif idx == 1:\n        neighbors.append(swap(state, 1, 0))\n        neighbors.append(swap(state, 1, 3))\n    elif idx == 2:\n        neighbors.append(swap(state, 2, 0))\n        neighbors.append(swap(state, 2, 3))\n    elif idx == 3:\n        neighbors.append(swap(state, 3, 1))\n        neighbors.append(swap(state, 3, 2))\n    return neighbors\n\ndef swap(state, i, j):\n    state = list(state)\n    state[i], state[j] = state[j], state[i]\n    return ''.join(state)\n\ndef bfs(start):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        current = queue.popleft()\n        for neighbor in get_neighbors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return visited\n\ndef can_be_same_configuration(bessie, elsie):\n    bessie_start = ''.join(bessie)\n    elsie_start = ''.join(elsie)\n\n    bessie_reachable = bfs(bessie_start)\n    elsie_reachable = bfs(elsie_start)\n\n    return not bessie_reachable.isdisjoint(elsie_reachable)\n\n# Input reading\nbessie = [input().strip() for _ in range(2)]\nelsie = [input().strip() for _ in range(2)]\n\nif can_be_same_configuration(bessie, elsie):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def convert_to_decimal(n, k):\n    decimal = 0\n    power = 0\n    while k > 0:\n        decimal += (k % 10) * (n ** power)\n        k //= 10\n        power += 1\n    return decimal\n\ndef find_min_decimal(n, k):\n    decimal = convert_to_decimal(n, k)\n    power = 0\n    while (n ** power) <= decimal:\n        power += 1\n    return n ** power\n\nn = int(input())\nk = int(input())\nprint(find_min_decimal(n, k))"}
{"solution": "def is_unimodal(arr):\n    if len(arr) < 3:\n        return True\n\n    increasing = True\n    decreasing = False\n\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            if decreasing:\n                return False\n        elif arr[i] < arr[i - 1]:\n            if increasing:\n                increasing = False\n            decreasing = True\n        elif arr[i] == arr[i - 1]:\n            if not increasing and not decreasing:\n                return False\n\n    return True\n\nn = int(input())\narr = list(map(int, input().split()))\n\nif is_unimodal(arr):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_paths(x, n):\n    count = 0\n    while x <= n:\n        count += 1\n        x = x * 2 if x % 2 == 0 else x - 1\n    return count\n\ndef max_value(n, k):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right + 1) // 2\n        if count_paths(mid, n) >= k:\n            left = mid\n        else:\n            right = mid - 1\n    return left\n\nn, k = map(int, input().split())\nprint(max_value(n, k))"}
{"solution": "def billiard_table(n, m, x, y, vx, vy):\n    # Simulate the movement of the ball\n    while True:\n        # Calculate the next position of the ball\n        if vx > 0:\n            x_next = n\n        elif vx < 0:\n            x_next = 0\n        else:\n            x_next = x + (n - y) / vy * vx\n\n        if vy > 0:\n            y_next = m\n        elif vy < 0:\n            y_next = 0\n        else:\n            y_next = y + (m - x) / vx * vy\n\n        # Check if the ball falls into a pocket\n        if x_next == 0 and y_next == 0:\n            return (0, 0)\n        elif x_next == n and y_next == 0:\n            return (n, 0)\n        elif x_next == 0 and y_next == m:\n            return (0, m)\n        elif x_next == n and y_next == m:\n            return (n, m)\n\n        # Update the position and velocity of the ball\n        if x_next == x:\n            vy = -vy\n        elif y_next == y:\n            vx = -vx\n        else:\n            vx = -vx\n            vy = -vy\n        x = x_next\n        y = y_next\n\n# Read the input\nn, m, x, y, vx, vy = map(int, input().split())\n\n# Determine the outcome\nresult = billiard_table(n, m, x, y, vx, vy)\n\n# Print the output\nif result == (-1, -1):\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    # Check if two rectangles (a2, b2) and (a3, b3) can fit in (a1, b1)\n    def fits(w1, h1, w2, h2, W, H):\n        return (w1 + w2 <= W and max(h1, h2) <= H) or (h1 + h2 <= H and max(w1, w2) <= W)\n\n    # Check all combinations of orientations\n    if (fits(a2, b2, a3, b3, a1, b1) or fits(b2, a2, a3, b3, a1, b1) or\n        fits(a2, b2, b3, a3, a1, b1) or fits(b2, a2, b3, a3, a1, b1) or\n        fits(a3, b3, a2, b2, a1, b1) or fits(b3, a3, a2, b2, a1, b1) or\n        fits(a3, b3, b2, a2, a1, b1) or fits(b3, a3, b2, a2, a1, b1)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\n# Print output\nprint(can_place_paintings(a1, b1, a2, b2, a3, b3))"}
{"solution": "def solve_progression(b1, q, l, m, bad_nums):\n    if b1 == 0 and q == 0:\n        return 0 if b1 in bad_nums else 1\n    if b1 == 0 or abs(q) > l:\n        return 0\n    if q == 1:\n        return 'inf' if abs(b1) <= l and b1 not in bad_nums else 0\n    if q == -1:\n        return 1 if abs(b1) <= l and b1 not in bad_nums else 0\n    count = 0\n    while abs(b1) <= l:\n        if b1 not in bad_nums:\n            count += 1\n        b1 *= q\n    return count\n\nb1, q, l, m = map(int, input().split())\nbad_nums = set(map(int, input().split()))\nprint(solve_progression(b1, q, l, m, bad_nums))"}
{"solution": "def find_frame(grid):\n    n, m = len(grid), len(grid[0])\n    min_size = float('inf')\n    min_frame = None\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'w':\n                size = min(i, j, n - i - 1, m - j - 1)\n                if size < min_size:\n                    min_size = size\n                    min_frame = (i, j, size)\n\n    if min_frame is None:\n        return -1\n\n    i, j, size = min_frame\n    for k in range(j, j + size + 1):\n        grid[i][k] = '+' if grid[i][k] != 'w' else 'w'\n        grid[i + size][k] = '+' if grid[i + size][k] != 'w' else 'w'\n\n    for k in range(i, i + size + 1):\n        grid[k][j] = '+' if grid[k][j] != 'w' else 'w'\n        grid[k][j + size] = '+' if grid[k][j + size] != 'w' else 'w'\n\n    return '\\n'.join(''.join(row) for row in grid)\n\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\nprint(find_frame(grid))"}
{"solution": "def find_solution(n, a, b):\n    for x in range(n // a + 1):\n        for y in range(n // b + 1):\n            if x * a + y * b == n:\n                return x, y\n    return None\n\nn = int(input())\na = int(input())\nb = int(input())\n\nsolution = find_solution(n, a, b)\n\nif solution is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(*solution)"}
{"solution": "def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\n# Get the input\ns = int(input())\n# Print the output\nprint(number_to_words(s))"}
{"solution": "# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Initialize the maximum number of elements that can be erased\nmax_erased = 0\n\n# Iterate over all possible segments to erase\nfor i in range(n):\n    for j in range(i, n):\n        # Check if the segment can be restored\n        if (i == 0 or arr[i - 1] < arr[j] - (j - i)) and (j == n - 1 or arr[j + 1] > arr[i] + (j - i)):\n            # Update the maximum number of elements that can be erased\n            max_erased = max(max_erased, j - i + 1)\n\n# Print the result\nprint(max_erased)"}
{"solution": "# Read the input\nn = int(input())\nproblems = list(map(int, input().split()))\n\n# Calculate the total number of problems\ntotal_problems = sum(problems)\n\n# Calculate the cumulative sum of problems solved each day\ncumulative_sum = [0] * (n + 1)\nfor i in range(1, n + 1):\n    cumulative_sum[i] = cumulative_sum[i - 1] + problems[i - 1]\n\n# Find the first day when Polycarp will celebrate the equator\nfor i in range(1, n + 1):\n    if cumulative_sum[i] >= total_problems // 2:\n        print(i)\n        break"}
{"solution": "def min_steps_and_replacements(N, board):\n    # Initialize a 3D dp array to store the minimum number of steps and replacements\n    dp = [[[float('inf')] * 3 for _ in range(N)] for _ in range(N)]\n\n    # Define the possible moves for each piece\n    knight_moves = [(2, 1), (1, 2), (-2, 1), (-1, 2), (2, -1), (1, -2), (-2, -1), (-1, -2)]\n    bishop_moves = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\n    rook_moves = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    # Define a function to check if a move is valid\n    def is_valid_move(x, y):\n        return 0 <= x < N and 0 <= y < N\n\n    # Define a function to calculate the minimum number of steps and replacements\n    def calculate_dp(x, y, piece):\n        # Base case: if the current square is 1, return 0 steps and 0 replacements\n        if board[x][y] == 1:\n            return 0, 0\n\n        # If the value is already calculated, return it\n        if dp[x][y][piece] != float('inf'):\n            return dp[x][y][piece]\n\n        # Initialize the minimum number of steps and replacements\n        min_steps = float('inf')\n        min_replacements = float('inf')\n\n        # Try all possible moves for the current piece\n        if piece == 0:  # knight\n            moves = knight_moves\n        elif piece == 1:  # bishop\n            moves = bishop_moves\n        else:  # rook\n            moves = rook_moves\n\n        for dx, dy in moves:\n            new_x, new_y = x + dx, y + dy\n            if is_valid_move(new_x, new_y):\n                # Calculate the minimum number of steps and replacements for the new square\n                steps, replacements = calculate_dp(new_x, new_y, piece)\n                # Update the minimum number of steps and replacements\n                min_steps = min(min_steps, steps + 1)\n                min_replacements = min(min_replacements, replacements)\n\n        # Try replacing the current piece with another piece\n        for new_piece in range(3):\n            if new_piece != piece:\n                # Calculate the minimum number of steps and replacements for the new piece\n                steps, replacements = calculate_dp(x, y, new_piece)\n                # Update the minimum number of steps and replacements\n                min_steps = min(min_steps, steps)\n                min_replacements = min(min_replacements, replacements + 1)\n\n        # Store the minimum number of steps and replacements in the dp array\n        dp[x][y][piece] = (min_steps, min_replacements)\n        return dp[x][y][piece]\n\n    # Calculate the minimum number of steps and replacements for each square and piece\n    for x in range(N):\n        for y in range(N):\n            for piece in range(3):\n                calculate_dp(x, y, piece)\n\n    # Find the minimum number of steps and replacements for the last square\n    min_steps = float('inf')\n    min_replacements = float('inf')\n    for piece in range(3):\n        steps, replacements = dp[N - 1][N - 1][piece]\n        min_steps = min(min_steps, steps)\n        min_replacements = min(min_replacements, replacements)\n\n    return min_steps, min_replacements\n\n# Read the input\nN = int(input())\nboard = []\nfor _ in range(N):\n    row = list(map(int, input().split()))\n    board.append(row)\n\n# Calculate the minimum number of steps and replacements\nmin_steps, min_replacements = min_steps_and_replacements(N, board)\n\n# Print the output\nprint(min_steps, min_replacements)"}
{"solution": "def min_time(n, m, k, a, b):\n    # Calculate the position of Edward and Natasha\n    a_pos = (a - 1) // (m * k), ((a - 1) % (m * k)) // k\n    b_pos = (b - 1) // (m * k), ((b - 1) % (m * k)) // k\n\n    # Calculate the distance between Edward and Natasha\n    dist = min(abs(a_pos[0] - b_pos[0]), n - abs(a_pos[0] - b_pos[0]))\n\n    # Calculate the time to walk to the nearest entrance\n    time = min(a_pos[1], m - a_pos[1]) * 5\n\n    # Calculate the time to take the elevator\n    time += 10 + abs(a_pos[1] - b_pos[1])\n\n    # Calculate the time to walk to Natasha's apartment\n    time += min(dist * 15, (n - dist) * 15 + min(b_pos[1], m - b_pos[1]) * 5)\n\n    return time\n\n# Read the input\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Print the result\nprint(min_time(n, m, k, a, b))"}
{"solution": "def check_divisible_by_64(binary_string):\n    # Count the number of 1s in the binary string\n    count_of_ones = binary_string.count('1')\n\n    # If the count of 1s is less than 6, it's impossible to get a number divisible by 64\n    if count_of_ones < 6:\n        return False\n\n    # If the count of 1s is not a multiple of 6, it's impossible to get a number divisible by 64\n    if count_of_ones % 6 != 0:\n        return False\n\n    # If the length of the binary string is less than 6, it's impossible to get a number divisible by 64\n    if len(binary_string) < 6:\n        return False\n\n    # If the binary string ends with less than 6 zeros, it's impossible to get a number divisible by 64\n    if binary_string[-6:].count('0') < 6:\n        return False\n\n    # If the binary string contains a sequence of 6 or more zeros, it's possible to get a number divisible by 64\n    if '0' * 6 in binary_string:\n        return True\n\n    # If none of the above conditions are met, it's impossible to get a number divisible by 64\n    return False\n\n# Read the input\nbinary_string = input()\n\n# Check if it's possible to get a number divisible by 64\nif check_divisible_by_64(binary_string):\n    print('yes')\nelse:\n    print('no')"}
{"solution": "def transform_string(s):\n    # Initialize the target string\n    target = 'abcdefghijklmnopqrstuvwxyz'\n    # Initialize the index of the target string\n    target_index = 0\n    # Initialize the transformed string\n    transformed = ''\n    # Iterate over the input string\n    for char in s:\n        # If the current character is less than or equal to the current target character\n        if char <= target[target_index]:\n            # Replace the current character with the current target character\n            transformed += target[target_index]\n            # Move to the next target character\n            target_index += 1\n        # If the current character is greater than the current target character\n        else:\n            # Keep the current character as it is\n            transformed += char\n        # If all target characters have been used\n        if target_index == len(target):\n            # Break the loop\n            break\n    # If all target characters have been used\n    if target_index == len(target):\n        # Return the transformed string\n        return transformed\n    # If not all target characters have been used\n    else:\n        # Return -1\n        return -1\n\n# Read the input string\ns = input()\n# Print the transformed string or -1\nprint(transform_string(s))"}
{"solution": "def calculate_expected_value(n, m, r, k):\n    total_cells = n * m\n    total_scoop_positions = (n - r + 1) * (m - r + 1)\n    scoop_cells = r * r\n    max_fish_in_scoop = min(k, scoop_cells)\n\n    # Calculate the probability of catching a fish in a single scoop\n    p = max_fish_in_scoop / scoop_cells\n\n    # Calculate the expected value\n    expected_value = p * max_fish_in_scoop * total_scoop_positions / total_cells\n\n    return expected_value\n\n# Read input\nn, m, r, k = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_expected_value(n, m, r, k)\nprint(\"{:.10f}\".format(result))"}
{"solution": "def max_product(n, arr):\n    # Count the number of negative numbers\n    neg_count = sum(1 for num in arr if num < 0)\n\n    # If there is an odd number of negative numbers,\n    # we need to replace the smallest number with its negative and opposite\n    if neg_count % 2 != 0:\n        min_num = min(arr)\n        arr[arr.index(min_num)] = -min_num - 1\n\n    # Now, we need to make all numbers as negative and as large as possible\n    for i in range(n):\n        if arr[i] > 0:\n            arr[i] = -arr[i] - 1\n        elif arr[i] < 0:\n            arr[i] = -arr[i]\n\n    return arr\n\n# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Print the output\nprint(*max_product(n, arr))"}
{"solution": "import math\n\ndef find_kth_divisor(n, k):\n    divisors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.sort()\n    if k > len(divisors):\n        return -1\n    else:\n        return divisors[k - 1]\n\nn, k = map(int, input().split())\nprint(find_kth_divisor(n, k))"}
{"solution": "def can_form(num, cubes):\n    # Check if the number can be formed using the cubes\n    for digit in str(num):\n        if digit not in cubes:\n            return False\n        cubes.remove(digit)\n    return True\n\ndef solve(n, cubes):\n    # Try to form the largest number possible\n    for num in range(9876, -1, -1):\n        if can_form(num, cubes.copy()):\n            return num\n    return 0\n\n# Read input\nn = int(input())\ncubes = []\nfor _ in range(n):\n    cubes.extend(list(map(int, input().split())))\n\n# Solve and print output\nprint(solve(n, cubes))"}
{"solution": "def k_rounding(n, k):\n    # Calculate the multiplier needed to reach the k-rounding\n    multiplier = 10 ** k\n\n    # Calculate the k-rounding of n\n    k_rounded = ((n + multiplier - 1) // multiplier) * multiplier\n\n    return k_rounded\n\n# Get the input values\nn, k = map(int, input().split())\n\n# Print the k-rounding of n\nprint(k_rounding(n, k))"}
{"solution": "The provided Python code implements the logic to transform matrix B into matrix A using the specified operations. Here's a breakdown of the code:\n\n1. The `transform_matrix` function takes the dimensions of the matrices (n and m) and matrix A as input.\n2. It initializes an empty list `operations` to store the operations and a matrix `B` filled with zeros.\n3. The function then iterates through each possible top-left corner of a 2x2 submatrix in matrix A.\n4. If all elements of the submatrix are 1, the operation is recorded in the `operations` list and the corresponding elements in matrix B are updated to 1.\n5. After processing all possible submatrices, the function checks if matrix B matches matrix A.\n6. If not, the function returns -1, indicating that it is impossible to transform matrix B into matrix A.\n7. If matrix B matches matrix A, the function returns the list of operations.\n\nThe input is read from the user, and the `transform_matrix` function is called with the input values. The result is then printed in the required format."}
{"solution": "def calculate_probabilities(r, s, p):\n    prob = [[[0.0 for _ in range(p+1)] for _ in range(s+1)] for _ in range(r+1)]\n\n    # Base cases\n    for i in range(r+1):\n        for j in range(s+1):\n            prob[i][j][0] = 1.0 if i > 0 and j == 0 else 0.0\n\n    for i in range(r+1):\n        for k in range(p+1):\n            prob[i][0][k] = 1.0 if i == 0 and k > 0 else 0.0\n\n    for j in range(s+1):\n        for k in range(p+1):\n            prob[0][j][k] = 1.0 if j > 0 and k == 0 else 0.0\n\n    # Calculate probabilities\n    for i in range(r+1):\n        for j in range(s+1):\n            for k in range(p+1):\n                if i == 0 and j == 0 and k == 0:\n                    continue\n                if i > 0:\n                    prob[i][j][k] += i * j * prob[i-1][j][k]\n                if j > 0:\n                    prob[i][j][k] += i * k * prob[i][j][k-1]\n                if k > 0:\n                    prob[i][j][k] += j * k * prob[i+1][j-1][k]\n                prob[i][j][k] /= (i * j + i * k + j * k)\n\n    return prob[r][s][p], prob[s][p][r], prob[p][r][s]\n\n# Read input\nr, s, p = map(int, input().split())\n\n# Calculate probabilities\nprob_r, prob_s, prob_p = calculate_probabilities(r, s, p)\n\n# Print output\nprint(prob_r, prob_s, prob_p)"}
{"solution": "def calculate_overlap(l1, r1, l2, r2, k):\n    # Calculate the overlap of the two time intervals\n    overlap = max(0, min(r1, r2) - max(l1, l2) + 1)\n\n    # If Sonya prinks during the overlap, subtract that minute from the overlap\n    if max(l1, l2) <= k <= min(r1, r2):\n        overlap -= 1\n\n    return overlap\n\n# Get the input\nl1, r1, l2, r2, k = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_overlap(l1, r1, l2, r2, k)\nprint(result)"}
{"solution": "import sys\nfrom typing import List\n\ndef read_input() -> tuple:\n    N, M = map(int, sys.stdin.readline().split())\n    north_south_lines = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\n    east_west_lines = [list(map(int, sys.stdin.readline().split())) for _ in range(M)]\n    return N, M, north_south_lines, east_west_lines\n\ndef calculate_area(N: int, M: int, north_south_lines: List[List[int]], east_west_lines: List[List[int]]) -> int:\n    # Sort lines by their y-coordinate for north-south lines and x-coordinate for east-west lines\n    north_south_lines.sort(key=lambda x: x[2])\n    east_west_lines.sort(key=lambda x: x[0])\n\n    # Initialize variables to keep track of the current x and y boundaries\n    x_boundaries = [-10**9, 10**9]\n    y_boundaries = [-10**9, 10**9]\n\n    # Iterate through north-south lines and update x boundaries\n    for line in north_south_lines:\n        A, B, C = line\n        if A <= 0 <= B:\n            if A < x_boundaries[0]:\n                x_boundaries[0] = A\n            if B < x_boundaries[1]:\n                x_boundaries[1] = B\n\n    # Iterate through east-west lines and update y boundaries\n    for line in east_west_lines:\n        D, E, F = line\n        if E <= 0 <= F:\n            if E < y_boundaries[0]:\n                y_boundaries[0] = E\n            if F < y_boundaries[1]:\n                y_boundaries[1] = F\n\n    # Calculate the area\n    area = (x_boundaries[1] - x_boundaries[0]) * (y_boundaries[1] - y_boundaries[0])\n\n    # If the area is infinite, return -1\n    if area < 0:\n        return -1\n    else:\n        return area\n\ndef main() -> None:\n    N, M, north_south_lines, east_west_lines = read_input()\n    area = calculate_area(N, M, north_south_lines, east_west_lines)\n\n    if area == -1:\n        print(\"INF\")\n    else:\n        print(area)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input\nt, s, x = map(int, input().split())\n\n# Calculate the first barking time after x\nfirst_bark_after_x = t + s * ((x - t) // s)\n\n# Check if the pineapple barks at time x\nif x == first_bark_after_x or x == first_bark_after_x + 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r, i+1))\n\nsegments.sort(key=lambda x: (x[0], -x[1]))\n\nstack = []\nfor segment in segments:\n    while stack and stack[-1][1] <= segment[1]:\n        if stack[-1][0] <= segment[0] and stack[-1][1] >= segment[1]:\n            print(segment[2], stack[-1][2])\n            exit()\n        stack.pop()\n    stack.append(segment)\n\nprint(-1, -1)"}
{"solution": "n = int(input())\ns = list(input())\n\ncounts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\nfor nucleotide in s:\n    if nucleotide != '?':\n        counts[nucleotide] += 1\n\ntarget_count = n // 4\nfor i in range(n):\n    if s[i] == '?':\n        for nucleotide in 'ACGT':\n            if counts[nucleotide] < target_count:\n                s[i] = nucleotide\n                counts[nucleotide] += 1\n                break\n        else:\n            print(\"===\")\n            break\nelse:\n    print(''.join(s))"}
{"solution": "def check_win(board):\n    # Check rows\n    for row in board:\n        if row.count('x') == 3 and row.count('.') == 1:\n            return True\n\n    # Check columns\n    for col in range(4):\n        if [board[row][col] for row in range(4)].count('x') == 3 and [board[row][col] for row in range(4)].count('.') == 1:\n            return True\n\n    # Check diagonals\n    if [board[i][i] for i in range(4)].count('x') == 3 and [board[i][i] for i in range(4)].count('.') == 1:\n        return True\n    if [board[i][3-i] for i in range(4)].count('x') == 3 and [board[i][3-i] for i in range(4)].count('.') == 1:\n        return True\n\n    return False\n\ndef main():\n    board = [input() for _ in range(4)]\n    if check_win(board):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_balance(arr):\n    total_sum = sum(arr)\n    left_sum = 0\n\n    for i in range(len(arr)):\n        if left_sum == total_sum - left_sum - arr[i]:\n            return True\n        left_sum += arr[i]\n\n    return False\n\ndef solve(n, arr):\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                temp = arr[i]\n                arr[i] = arr[j]\n                arr[j] = temp\n                if can_balance(arr):\n                    return True\n                arr[j] = arr[i]\n                arr[i] = temp\n\n    return False\n\nn = int(input())\narr = list(map(int, input().split()))\n\nif solve(n, arr):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def solve(n, k, a, b):\n    a_zeros = [i for i, x in enumerate(a) if x == 0]\n    b.sort()\n\n    def backtrack(i):\n        if i == k:\n            return True\n        for j in a_zeros:\n            if (j == 0 or a[j - 1] > b[i]) and (j == n - 1 or a[j + 1] < b[i]):\n                a[j] = b[i]\n                if backtrack(i + 1):\n                    return True\n                a[j] = 0\n        return False\n\n    return backtrack(0)\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(\"Yes\" if solve(n, k, a, b) else \"No\")"}
{"solution": "# Get the input\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Check if Andrew can eat enough green grapes\nif x > a:\n    print(\"NO\")\nelse:\n    # Calculate the remaining green grapes after Andrew eats\n    remaining_green = a - x\n\n    # Check if Dmitry can eat enough non-black grapes\n    if y > remaining_green + b:\n        print(\"NO\")\n    else:\n        # Calculate the remaining non-black grapes after Dmitry eats\n        remaining_non_black = remaining_green + b - y\n\n        # Check if Michal can eat enough remaining grapes\n        if z > remaining_non_black + c:\n            print(\"NO\")\n        else:\n            print(\"YES\")"}
{"solution": "# Read the input\ntraffic_lights = [list(map(int, input().split())) for _ in range(4)]\n\n# Check for possible accidents\nfor i in range(4):\n    # If the pedestrian light is green\n    if traffic_lights[i][3] == 1:\n        # Check if any of the car lights are green\n        if traffic_lights[i][0] == 1 or traffic_lights[i][1] == 1 or traffic_lights[i][2] == 1:\n            print(\"YES\")\n            exit()\n\n# If no accidents are possible\nprint(\"NO\")"}
{"solution": "def get_coordinates(digit):\n    keypad = {\n        '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2),\n        '0': (3, 1)\n    }\n    return keypad[digit]\n\ndef get_vectors(number):\n    vectors = []\n    for i in range(len(number) - 1):\n        x1, y1 = get_coordinates(number[i])\n        x2, y2 = get_coordinates(number[i + 1])\n        vectors.append((x2 - x1, y2 - y1))\n    return vectors\n\ndef is_unique_finger_movement(n, number):\n    original_vectors = get_vectors(number)\n    for i in range(10**(n-1), 10**n):\n        candidate = str(i).zfill(n)\n        if candidate != number:\n            if get_vectors(candidate) == original_vectors:\n                return \"NO\"\n    return \"YES\"\n\n# Input reading\nn = int(input())\nnumber = input().strip()\n\n# Output the result\nprint(is_unique_finger_movement(n, number))"}
{"solution": "def max_sold_products(n, f, days):\n    days.sort(key=lambda x: (x[1] - x[0], x[0]), reverse=True)\n    for _ in range(f):\n        days[0] = (days[0][0] * 2, days[0][1])\n    total_sold = 0\n    for k, l in days:\n        total_sold += min(k, l)\n    return total_sold\n\nn, f = map(int, input().split())\ndays = [tuple(map(int, input().split())) for _ in range(n)]\nprint(max_sold_products(n, f, days))"}
{"solution": "def max_messiness(n, k):\n    # If there's only one cow, the maximum messiness is 0\n    if n == 1:\n        return 0\n\n    # If k is greater than or equal to n-1, we can swap every pair of cows\n    if k >= n - 1:\n        return (n * (n - 1)) // 2\n\n    # Otherwise, we can swap the first k cows with the last k cows\n    return k * (2 * n - k - 1)\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the maximum messiness\nprint(max_messiness(n, k))"}
{"solution": "# Read the input\nN, M, K, L = map(int, input().split())\n\n# Calculate the number of coins already owned by Ivan\nowned_coins = K\n\n# Calculate the number of unique coins that can be gifted to Ivan\nunique_coins = min(M, N - owned_coins)\n\n# Check if it's possible to meet all the conditions\nif unique_coins < M or unique_coins < L:\n    print(-1)\nelse:\n    # Calculate the minimum number of coins each friend needs to gift\n    coins_per_friend = L // M\n    if L % M != 0:\n        coins_per_friend += 1\n    print(coins_per_friend)"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n\n    # Find the bounds of the black cells\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n\n    # If no black cells are found\n    if min_row == n:\n        return 1\n\n    # Calculate the side length of the square\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n\n    # Check if the square can fit within the grid\n    if side_length > n or side_length > m:\n        return -1\n\n    # Count the number of white cells within the square\n    min_paint = float('inf')\n    for i in range(n - side_length + 1):\n        for j in range(m - side_length + 1):\n            paint_count = 0\n            for x in range(i, i + side_length):\n                for y in range(j, j + side_length):\n                    if grid[x][y] == 'W':\n                        paint_count += 1\n            min_paint = min(min_paint, paint_count)\n\n    return min_paint\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Print output\nprint(min_cells_to_paint(n, m, grid))"}
{"solution": "# Read the input\nn = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Calculate the difference between the two sequences\ndiff = [yi - xi for xi, yi in zip(x, y)]\n\n# Check if the difference is valid\nif all(d >= 0 for d in diff) and sum(diff) % 2 == 0:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "# Read the input\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Initialize the total sum of angles and the sum of angles for Vasya's sector\ntotal_sum = sum(angles)\nvasya_sum = 0\n\n# Initialize the minimum difference between the two sectors\nmin_diff = total_sum\n\n# Iterate through the angles\nfor angle in angles:\n    # Add the current angle to Vasya's sector\n    vasya_sum += angle\n\n    # Calculate the difference between the two sectors\n    diff = abs(vasya_sum - (total_sum - vasya_sum))\n\n    # Update the minimum difference\n    min_diff = min(min_diff, diff)\n\n# Print the minimum difference\nprint(min_diff)"}
{"solution": "MOD = 10**9 + 7\n\ndef calculate_ways(n, m):\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n\n    return dp[n][m]\n\nn, m = map(int, input().split())\nresult = calculate_ways(n, m)\nprint(result)"}
{"solution": "import math\n\ndef find_pythagorean_triple(n):\n    # Check if n is even\n    if n % 2 == 0:\n        m = n // 2\n        k = math.sqrt(m**2 + n**2)\n        # Check if k is an integer\n        if k.is_integer():\n            return m, int(k)\n    else:\n        # Iterate through possible values of m\n        for m in range(1, n, 2):\n            k = math.sqrt(m**2 + n**2)\n            # Check if k is an integer\n            if k.is_integer():\n                return m, int(k)\n    # No Pythagorean triple found\n    return -1\n\n# Read input\nn = int(input())\n# Find Pythagorean triple\nresult = find_pythagorean_triple(n)\n# Print output\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def check_distinct_remainders(n, k):\n    remainders = set()\n    for i in range(1, k + 1):\n        remainder = n % i\n        if remainder in remainders:\n            return False\n        remainders.add(remainder)\n    return True\n\nn, k = map(int, input().split())\nif check_distinct_remainders(n, k):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "# Read input efficiently\na = raw_input().strip('0')\nb = raw_input().strip('0')\n\n# Compare lengths\nif len(a) < len(b):\n    print(\"<\")\nelif len(a) > len(b):\n    print(\">\")\nelse:\n    # If lengths are equal, compare lexicographically\n    if a < b:\n        print(\"<\")\n    elif a > b:\n        print(\">\")\n    else:\n        print(\"=\")"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, p, colors):\n    # Initialize a 2D dynamic programming array dp[n+1][2]\n    dp = [[0, 0] for _ in range(n + 1)]\n\n    # Base case: dp[0][0] = 1 (no arrows and no paths)\n    dp[0][0] = 1\n\n    # Iterate through each piece\n    for i in range(1, n + 1):\n        # If the piece is already colored\n        if colors[i - 1] != -1:\n            # Copy the previous state to the current state\n            dp[i][0] = dp[i - 1][0]\n            dp[i][1] = dp[i - 1][1]\n\n            # If the current piece is black, update the number of paths ending with black\n            if colors[i - 1] == 0:\n                dp[i][1] = (dp[i][1] + dp[i - 1][0]) % MOD\n            # If the current piece is white, update the number of paths ending with white\n            else:\n                dp[i][0] = (dp[i][0] + dp[i - 1][1]) % MOD\n        # If the piece is not colored\n        else:\n            # Calculate the number of ways to place arrows and color the piece\n            dp[i][0] = (dp[i - 1][1] + dp[i - 1][0] * (n - i + 1)) % MOD\n            dp[i][1] = (dp[i - 1][0] + dp[i - 1][1] * (n - i + 1)) % MOD\n\n    # Return the number of ways to achieve the desired parity\n    return dp[n][p]\n\n# Read input\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Print the result\nprint(count_ways(n, p, colors))"}
{"solution": "def min_cost(n, a, b, c):\n    # Calculate the number of copybooks Alyona needs to buy\n    k = (4 - n % 4) % 4\n\n    # Calculate the cost of buying k copybooks using the most cost-effective packs\n    cost = 0\n    while k > 0:\n        if k >= 3 and c <= 2 * a:\n            cost += c\n            k -= 3\n        elif k >= 2 and b <= 2 * a:\n            cost += b\n            k -= 2\n        else:\n            cost += a\n            k -= 1\n\n    return cost\n\n# Read the input\nn, a, b, c = map(int, input().split())\n\n# Print the minimum amount of rubles Alyona should pay\nprint(min_cost(n, a, b, c))"}
{"solution": "import sys\n\ndef dfs(node, graph, visited, stack):\n    visited[node] = True\n    stack[node] = True\n\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            if dfs(neighbor, graph, visited, stack):\n                return True\n        elif stack[neighbor]:\n            return True\n\n    stack[node] = False\n    return False\n\ndef is_acyclic(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n\n    visited = [False] * n\n    stack = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if dfs(node, graph, visited, stack):\n                return False\n\n    return True\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n\n    if is_acyclic(n, m, edges):\n        print(\"YES\")\n    else:\n        for i in range(m):\n            if is_acyclic(n, m, edges[:i] + edges[i + 1:]):\n                print(\"YES\")\n                break\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_coins(n, m, antennas):\n    antennas.sort()\n    i = 0\n    coins = 0\n    max_right = 0\n    while i < n and max_right < m:\n        j = i\n        while j < n and antennas[j][0] - antennas[j][1] <= max_right + 1:\n            max_right = max(max_right, antennas[j][0] + antennas[j][1])\n            j += 1\n        if i == j:\n            return -1\n        coins += j - i - 1 + (antennas[j-1][0] - antennas[i][0] - (antennas[j-1][1] - antennas[i][1]))\n        i = j\n    if max_right < m:\n        return -1\n    return coins\n\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\nprint(min_coins(n, m, antennas))"}
{"solution": "def max_weight(W, cnt):\n    # Initialize a list to store the maximum weight for each possible weight\n    dp = [0] * (W + 1)\n\n    # Iterate over each possible weight from 1 to 8\n    for i in range(1, 9):\n        # Iterate over each possible total weight from the current weight to 0\n        for j in range(W, i - 1, -1):\n            # Iterate over each possible number of items with the current weight\n            for k in range(1, min(cnt[i - 1], j // i) + 1):\n                # Update the maximum weight for the current total weight\n                dp[j] = max(dp[j], dp[j - k * i] + k * i)\n\n    # Return the maximum weight\n    return dp[W]\n\n# Read the input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Print the output\nprint(max_weight(W, cnt))"}
{"solution": "def min_cost(n, L, costs):\n    # Create a list of tuples, where each tuple contains the volume and cost of a bottle\n    bottles = [(2**i - 1, costs[i]) for i in range(n)]\n\n    # Sort the bottles in descending order of volume\n    bottles.sort(key=lambda x: x[0], reverse=True)\n\n    # Initialize the total cost to 0\n    total_cost = 0\n\n    # Iterate through the bottles\n    for volume, cost in bottles:\n        # Calculate the number of bottles needed to reach the required volume\n        num_bottles = L // volume\n\n        # Update the total cost\n        total_cost += num_bottles * cost\n\n        # Update the required volume\n        L -= num_bottles * volume\n\n        # If the required volume is 0, return the total cost\n        if L == 0:\n            return total_cost\n\n    # If the required volume is still not 0, return the cost of the smallest bottle\n    return total_cost + bottles[-1][1]\n\n# Read the input\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Print the minimum cost\nprint(min_cost(n, L, costs))"}
{"solution": "def max_mex(n, a):\n    a.sort()\n    mex = 1\n    for num in a:\n        if num >= mex:\n            mex += 1\n    return mex\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = max_mex(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(int(digit) for digit in digits)\n\n    # Try every possible segment sum from 1 to total_sum\n    for segment_sum in range(1, total_sum + 1):\n        if total_sum % segment_sum == 0:\n            current_sum = 0\n            valid_partition = True\n            for digit in digits:\n                current_sum += int(digit)\n                if current_sum > segment_sum:\n                    valid_partition = False\n                    break\n                elif current_sum == segment_sum:\n                    current_sum = 0\n            if valid_partition and current_sum == 0:\n                return \"YES\"\n\n    return \"NO\"\n\n# Example usage:\nn = int(input())\ndigits = input().strip()\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\"\n\n# Take the username as input\nusername = input().strip()\n# Print the result\nprint(determine_gender(username))"}
{"solution": "def max_abs_diff(n, k, tabs):\n    max_diff = 0\n    for b in range(1, n + 1):\n        closed_tabs = [i for i in range(b, n + 1, k)]\n        remaining_tabs = [tabs[i] for i in range(n) if i + 1 not in closed_tabs]\n        e = remaining_tabs.count(1)\n        s = remaining_tabs.count(-1)\n        max_diff = max(max_diff, abs(e - s))\n    return max_diff\n\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\nprint(max_abs_diff(n, k, tabs))"}
{"solution": "def min_cost_encoding(n, c0, c1):\n    # If the cost of '0' is greater than or equal to the cost of '1',\n    # then assign '1' to the first letter and '0' to the remaining letters\n    if c0 >= c1:\n        return c1 + (n - 1) * c0\n\n    # Initialize the total cost\n    total_cost = 0\n\n    # Initialize the number of letters assigned with '0' and '1'\n    count_0 = 1\n    count_1 = 0\n\n    # Iterate through the remaining letters\n    for i in range(2, n + 1):\n        # Calculate the cost of assigning '0' to the current letter\n        cost_0 = total_cost + count_0 * c0 + (count_1 + 1) * c1\n\n        # Calculate the cost of assigning '1' to the current letter\n        cost_1 = total_cost + (count_0 + 1) * c0 + count_1 * c1\n\n        # Choose the minimum cost\n        if cost_0 <= cost_1:\n            total_cost = cost_0\n            count_0 += 1\n        else:\n            total_cost = cost_1\n            count_1 += 1\n\n    return total_cost\n\n# Read the input\nn, c0, c1 = map(int, input().split())\n\n# Calculate the minimum possible total cost\nmin_cost = min_cost_encoding(n, c0, c1)\n\n# Print the output\nprint(min_cost)"}
{"solution": "def will_meet(n, a, x, b, y):\n    while a != x and b != y:\n        if a == b:\n            return \"YES\"\n        a = a + 1 if a < n else 1\n        b = b - 1 if b > 1 else n\n    return \"YES\" if a == b else \"NO\"\n\nn, a, x, b, y = map(int, input().split())\nprint(will_meet(n, a, x, b, y))"}
{"solution": "def generate_unlucky_years(x, y, max_val):\n    unlucky_years = set()\n    powers_of_x = {1}\n    powers_of_y = {1}\n\n    while powers_of_x[-1] <= max_val:\n        powers_of_x.add(powers_of_x[-1] * x)\n\n    while powers_of_y[-1] <= max_val:\n        powers_of_y.add(powers_of_y[-1] * y)\n\n    for i in powers_of_x:\n        for j in powers_of_y:\n            if i + j <= max_val:\n                unlucky_years.add(i + j)\n\n    return unlucky_years\n\ndef find_max_golden_age(x, y, l, r):\n    unlucky_years = generate_unlucky_years(x, y, r)\n    max_length = 0\n    current_length = 0\n    last_unlucky_year = l - 1\n\n    for year in range(l, r + 1):\n        if year not in unlucky_years:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 0\n            last_unlucky_year = year\n\n    max_length = max(max_length, current_length)\n\n    if l <= last_unlucky_year < r and r not in unlucky_years:\n        max_length = max(max_length, r - last_unlucky_year)\n\n    return max_length\n\nx, y, l, r = map(int, input().split())\nprint(find_max_golden_age(x, y, l, r))"}
{"solution": "def min_tax(n):\n    if n % 2 == 0:\n        return n // 2\n    else:\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return n // i\n        return 1\n\nn = int(input())\nprint(min_tax(n))"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    n = len(word)\n    result = []\n    i = 0\n\n    while i < n:\n        result.append(word[i])\n        if word[i] not in vowels:\n            start = i\n            while i < n and word[i] not in vowels:\n                i += 1\n            if i - start >= 3:\n                block = word[start:i]\n                if len(set(block)) > 1:\n                    result.append(' ')\n        i += 1\n\n    return ''.join(result)\n\n# Read input\nword = input()\n\n# Print output\nprint(fix_typos(word))"}
{"solution": "def min_time(n, m, k, x, s, a, b, c, d):\n    # Initialize minimum time to prepare n potions without using any spell\n    min_time = n * x\n\n    # Check all possible combinations of spells\n    for i in range(m):\n        for j in range(k):\n            # If total manapoints spent does not exceed s\n            if b[i] + d[j] <= s:\n                # Calculate time to prepare n potions using these spells\n                time = max(c[j], n) * a[i] + (n - c[j]) * x\n                # Update minimum time\n                min_time = min(min_time, time)\n\n    # Return minimum time\n    return min_time\n\n# Read input\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\n# Print minimum time\nprint(min_time(n, m, k, x, s, a, b, c, d))"}
{"solution": "def max_points(n, k, M, t):\n    # dp[i][j] is the maximum number of points that can be earned in i minutes\n    # by solving j subtasks\n    dp = [[0] * (k + 1) for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, k + 1):\n            # If Polycarp has enough time to solve the j-th subtask,\n            # he can either solve it now and earn 1 point,\n            # or skip it and earn 0 points\n            if i >= t[j - 1]:\n                dp[i][j] = max(dp[i - t[j - 1]][j - 1] + 1, dp[i][j - 1])\n            else:\n                dp[i][j] = dp[i][j - 1]\n\n            # If Polycarp has solved all subtasks of a task, he can earn an extra point\n            if j == k and dp[i][j] == k:\n                dp[i][j] += 1\n\n    return dp[M][k]\n\nn, k, M = map(int, input().split())\nt = list(map(int, input().split()))\nprint(max_points(n, k, M, t))"}
{"solution": "MOD = 998244353\n\ndef count_trees(n):\n    # Initialize arrays to store the number of trees for each size\n    dp = [0] * (n + 1)\n    dp_odd = [0] * (n + 1)\n    dp_even = [0] * (n + 1)\n\n    # Base case: there is 1 tree with 0 vertices\n    dp[0] = 1\n    dp_odd[0] = 1\n    dp_even[0] = 1\n\n    # Calculate the number of trees for each size\n    for i in range(1, n + 1):\n        # Calculate the number of odd-rooted trees\n        dp_odd[i] = (dp_even[i - 1] * (2 * i - 1)) % MOD\n\n        # Calculate the number of even-rooted trees\n        dp_even[i] = (dp_odd[i - 1] * (2 * i)) % MOD\n\n        # Calculate the total number of trees\n        dp[i] = (dp_odd[i] + dp_even[i]) % MOD\n\n    return dp[n]\n\n# Read the input\nn = int(input())\n\n# Calculate the number of trees\nresult = count_trees(n)\n\n# Print the result\nprint(result)"}
{"solution": "def find_position(n, m, k):\n    # Lara's movement pattern is down, right, up, left\n    # Calculate the total number of moves in one cycle\n    cycle = 2 * n + 2 * (m - 2)\n\n    # Calculate the number of full cycles Lara has made\n    full_cycles = k // cycle\n\n    # Calculate the remaining moves\n    k %= cycle\n\n    # If Lara has made an even number of full cycles, she is at the top left corner\n    if full_cycles % 2 == 0:\n        x = 1\n        y = 1\n    # If Lara has made an odd number of full cycles, she is at the top right corner\n    else:\n        x = 1\n        y = m\n\n    # Simulate Lara's movements within the current cycle\n    for _ in range(k):\n        if y == 1 and x < n:\n            x += 1\n        elif x == n and y < m:\n            y += 1\n        elif y == m and x > 1:\n            x -= 1\n        else:\n            x -= 1\n\n    return x, y\n\n# Read the input\nn, m, k = map(int, input().split())\n\n# Find Lara's position\nx, y = find_position(n, m, k)\n\n# Print the output\nprint(x, y)"}
{"solution": "import math\n\ndef find_min_max_pair(X):\n    # If X is a prime number, return X and 1\n    if is_prime(X):\n        return 1, X\n\n    # Find the factors of X\n    factors = get_factors(X)\n\n    # Initialize a and b as the first two factors\n    a, b = factors[0], X // factors[0]\n\n    # Iterate through the factors to find the pair that minimizes max(a, b)\n    for factor in factors[1:]:\n        temp_b = X // factor\n        if max(factor, temp_b) < max(a, b):\n            a, b = factor, temp_b\n\n    return a, b\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(math.sqrt(n)) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef get_factors(n):\n    factors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            factors.append(i)\n            if i != n // i:\n                factors.append(n // i)\n    return sorted(factors)\n\n# Read the input\nX = int(input())\n\n# Find the pair\na, b = find_min_max_pair(X)\n\n# Print the output\nprint(a, b)"}
{"solution": "def max_fruits_for_compote(a, b, c):\n    # Calculate the maximum number of complete sets for each fruit type\n    max_sets_lemons = a // 1\n    max_sets_apples = b // 2\n    max_sets_pears = c // 4\n\n    # Find the limiting factor (minimum number of complete sets)\n    max_complete_sets = min(max_sets_lemons, max_sets_apples, max_sets_pears)\n\n    # Calculate the total number of fruits used in the compote\n    total_fruits = max_complete_sets * (1 + 2 + 4)\n\n    return total_fruits\n\n# Read the input\na = int(input())\nb = int(input())\nc = int(input())\n\n# Print the result\nprint(max_fruits_for_compote(a, b, c))"}
{"solution": "def can_divide_teams(n, ratings):\n    ratings.sort()\n    for i in range(n):\n        if ratings[i] >= ratings[i + n]:\n            return \"NO\"\n    return \"YES\"\n\nn = int(input())\nratings = list(map(int, input().split()))\nprint(can_divide_teams(n, ratings))"}
{"solution": "from math import gcd\n\ndef make_coprime(arr):\n    insertions = []\n    for i in range(len(arr) - 1):\n        if gcd(arr[i], arr[i + 1]) != 1:\n            insertions.append(max(arr[i], arr[i + 1]) + 1)\n            arr.insert(i + 1, insertions[-1])\n    return len(insertions), arr\n\nn = int(input())\narr = list(map(int, input().split()))\nk, new_arr = make_coprime(arr)\nprint(k)\nprint(*new_arr)"}
{"solution": "import math\nfrom functools import reduce\nfrom math import gcd\n\ndef compute_gcd_of_list(lst):\n    return reduce(gcd, lst)\n\ndef max_divisor_after_operations(N, K, A):\n    if N == 1:\n        return A[0]\n\n    # Compute the GCD of the differences between all pairs\n    diffs = [abs(A[i] - A[j]) for i in range(N) for j in range(i + 1, N)]\n    initial_gcd = compute_gcd_of_list(diffs)\n\n    # Check all divisors of the initial GCD\n    max_divisor = 1\n    for d in range(1, initial_gcd + 1):\n        if initial_gcd % d == 0:\n            # Check if we can make all elements divisible by d\n            if all((a % d) <= K for a in A):\n                max_divisor = d\n\n    return max_divisor\n\n# Read input\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Compute and print the result\nprint(max_divisor_after_operations(N, K, A))"}
{"solution": "def cat_furrier_transform(x):\n    operations = []\n    n = 0\n    while x != 2**n - 1 and len(operations) < 40:\n        x = x ^ (2**n - 1)\n        operations.append(n)\n        if x != 2**n - 1 and len(operations) < 40:\n            x += 1\n            operations.append(x)\n        n += 1\n    return operations\n\ndef print_operations(operations):\n    print(len(operations))\n    for i in range(0, len(operations), 2):\n        print(operations[i], end=' ')\n    print()\n\nx = int(input())\noperations = cat_furrier_transform(x)\nprint_operations(operations)"}
{"solution": "# Read the input\nn, k = map(int, input().split())\nbuckets = list(map(int, input().split()))\n\n# Initialize the minimum number of hours to a large value\nmin_hours = float('inf')\n\n# Iterate through the buckets\nfor bucket in buckets:\n    # Check if the bucket can water the garden in integer number of hours\n    if k % bucket == 0:\n        # Calculate the number of hours required\n        hours = k // bucket\n        # Update the minimum number of hours\n        min_hours = min(min_hours, hours)\n\n# Print the minimum number of hours required\nprint(min_hours)"}
{"solution": "def can_reach_insect(n, k, line):\n    # Find the positions of the grasshopper and the insect\n    g_pos = line.index('G')\n    t_pos = line.index('T')\n\n    # If the grasshopper is to the right of the insect, swap their positions\n    if g_pos > t_pos:\n        g_pos, t_pos = t_pos, g_pos\n\n    # Check if the grasshopper can reach the insect by jumping over obstacles\n    while g_pos < t_pos:\n        g_pos += k\n        if g_pos > n - 1 or line[g_pos] == '#':\n            return 'NO'\n        if g_pos == t_pos:\n            return 'YES'\n\n    return 'NO'\n\n# Read the input\nn, k = map(int, input().split())\nline = input()\n\n# Print the output\nprint(can_reach_insect(n, k, line))"}
{"solution": "import math\n\ndef calculate_intersection_point(y1, y2, yw, xb, yb, r):\n    # Calculate the slope of the ball's trajectory\n    m = (yb - yw) / xb\n\n    # Calculate the y-coordinate of the intersection point\n    y_intersect = yw - r / math.sqrt(1 + m**2)\n\n    # Check if the intersection point is within the goalposts\n    if y1 <= y_intersect <= y2:\n        # Calculate the x-coordinate of the intersection point\n        x_intersect = xb * (y_intersect - yb) / m + xb\n        return x_intersect\n    else:\n        return -1\n\n# Read the input values\ny1, y2, yw, xb, yb, r = map(int, input().split())\n\n# Calculate the intersection point\nresult = calculate_intersection_point(y1, y2, yw, xb, yb, r)\n\n# Print the result\nprint(result)"}
{"solution": "# Get the input\nb, d, s = map(int, input().split())\n\n# Calculate the total number of meals\ntotal_meals = b + d + s\n\n# Calculate the minimum number of days Vasiliy was in the sanatorium\nmin_days = max(b, d, s)\n\n# Calculate the minimum number of meals Vasiliy could have missed\nmissed_meals = max(0, 3 * min_days - total_meals)\n\n# Print the result\nprint(missed_meals)"}
{"solution": "from collections import defaultdict\n\ndef find_dimensions(path):\n    n = len(path)\n    positions = defaultdict(tuple)\n\n    # Store the position of each number in the matrix\n    for i in range(n):\n        positions[path[i]] = (i // n, i % n)\n\n    # Check if the movements are valid\n    for i in range(1, n):\n        prev_x, prev_y = positions[path[i - 1]]\n        curr_x, curr_y = positions[path[i]]\n\n        if abs(prev_x - curr_x) + abs(prev_y - curr_y) != 1:\n            return \"NO\"\n\n    # Find the possible dimensions of the matrix\n    max_x = max(x for x, _ in positions.values())\n    max_y = max(y for _, y in positions.values())\n\n    return \"YES\\n{} {}\\n\".format(max_x + 1, max_y + 1)\n\n# Read the input\nn = int(input())\npath = list(map(int, input().split()))\n\n# Print the output\nprint(find_dimensions(path))"}
{"solution": "def longest_common_subsequence(a, b):\n    len_a, len_b = len(a), len(b)\n    dp = [['' for _ in range(len_b + 1)] for _ in range(len_a + 1)]\n\n    for i in range(1, len_a + 1):\n        for j in range(1, len_b + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + a[i - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], key=len)\n\n    return dp[-1][-1]\n\na = input()\nb = input()\n\nresult = longest_common_subsequence(a, b)\n\nif not result:\n    print('-')\nelse:\n    print(result)"}
{"solution": "def minimal_stones(n, s):\n    current_stones = 0\n    min_stones = 0\n\n    for char in s:\n        if char == '+':\n            current_stones += 1\n        elif char == '-':\n            current_stones -= 1\n        min_stones = min(min_stones, current_stones)\n\n    return max(0, -min_stones)\n\n# Example usage:\nn = int(input())\ns = input().strip()\nprint(minimal_stones(n, s))"}
{"solution": "def max_kefir_liters(n, a, b, c):\n    # Calculate the maximum number of plastic bottles Kolya can buy\n    max_plastic_bottles = n // a\n\n    # Calculate the maximum number of glass bottles Kolya can buy and return\n    max_glass_bottles = (n // b) * 2\n    remaining_money = n % b\n    if remaining_money >= c:\n        max_glass_bottles += 1\n\n    # Return the maximum number of liters of kefir Kolya can drink\n    return max(max_plastic_bottles, max_glass_bottles)\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Print output\nprint(max_kefir_liters(n, a, b, c))"}
{"solution": "def play_war(n, deck1, deck2):\n    seen_configurations = set()\n    fights = 0\n\n    while deck1 and deck2:\n        # Check if the current configuration has been seen before\n        configuration = tuple(deck1 + deck2)\n        if configuration in seen_configurations:\n            return -1, None\n        seen_configurations.add(configuration)\n\n        # Each soldier plays a card\n        card1, card2 = deck1.pop(0), deck2.pop(0)\n\n        # The soldier with the higher card wins the fight\n        if card1 > card2:\n            deck1.append(card2)\n            deck1.append(card1)\n        else:\n            deck2.append(card1)\n            deck2.append(card2)\n\n        fights += 1\n\n    # Determine the winner\n    if deck1:\n        return fights, 1\n    else:\n        return fights, 2\n\n# Read input\nn = int(input())\nk1 = int(input())\ndeck1 = list(map(int, input().split()))\nk2 = n - k1\ndeck2 = list(map(int, input().split()))\n\n# Play the game\nfights, winner = play_war(n, deck1, deck2)\n\n# Print output\nif winner:\n    print(fights, winner)\nelse:\n    print(-1)"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n\n    has_upper = False\n    has_lower = False\n    has_digit = False\n\n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n\n    if has_upper and has_lower and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\"\n\n# Get user input\npassword = input().strip()\n# Print the result of the password complexity check\nprint(check_password_complexity(password))"}
{"solution": "n = int(input())\ngroup_a = list(map(int, input().split()))\ngroup_b = list(map(int, input().split()))\n\n# Count the number of students with each academic performance in both groups\ncount_a = [0] * 6\ncount_b = [0] * 6\n\nfor i in group_a:\n    count_a[i] += 1\n\nfor i in group_b:\n    count_b[i] += 1\n\n# Calculate the minimum number of exchanges needed\nexchanges = 0\nfor i in range(1, 6):\n    diff = abs(count_a[i] - count_b[i])\n    # If the difference is odd, it's impossible to balance the groups\n    if diff % 2 != 0:\n        print(-1)\n        exit()\n    # Add half of the difference to the total number of exchanges\n    exchanges += diff // 2\n\nprint(exchanges)"}
{"solution": "def dfs(x, y):\n    visited[x][y] = True\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]:\n            if (dx == 1 and grid[x][y] == '>') or (dx == -1 and grid[x][y] == '<') or (dy == 1 and grid[ny][x] == 'v') or (dy == -1 and grid[ny][x] == '^'):\n                dfs(nx, ny)\n\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\ndirections = input()\nvisited = [[False] * m for _ in range(n)]\n\ndfs(0, 0)\n\nif all(visited[i][j] for i in range(n) for j in range(m)):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def solve_implication(n, a):\n    # If there is a 0 followed by a 1, then it is possible to make the expression false\n    for i in range(n - 1):\n        if a[i] == 0 and a[i + 1] == 1:\n            # Add brackets around the first two arguments\n            a[i] = '(' + str(a[i])\n            a[i + 1] = '->' + str(a[i + 1]) + ')'\n            # Add brackets around the entire expression\n            a[0] = '(' + a[0]\n            a[-1] = a[-1] + ')'\n            return 'YES\\n' + ''.join(a)\n    return 'NO'\n\nn = int(input())\na = list(map(int, input().split()))\nprint(solve_implication(n, a))"}
{"solution": "def solve(a, b):\n    while a != 0 and b != 0:\n        if a >= 2 * b:\n            a -= 2 * b\n        elif b >= 2 * a:\n            b -= 2 * a\n        else:\n            break\n    return a, b\n\nn, m = map(int, input().split())\nresult = solve(n, m)\nprint(result[0], result[1])"}
{"solution": "def count_divisible_numbers(k, a, b):\n    # Calculate the number of k-divisible numbers in the segment [0, b]\n    count_b = b // k\n\n    # Calculate the number of k-divisible numbers in the segment [0, a-1]\n    count_a = (a - 1) // k\n\n    # The number of k-divisible numbers in the segment [a, b] is the difference between the two counts\n    return count_b - count_a\n\n# Read the input\nk, a, b = map(int, input().split())\n\n# Print the result\nprint(count_divisible_numbers(k, a, b))"}
{"solution": "def find_kth_digit(k):\n    if k < 10:\n        return k\n\n    length = 1\n    count = 9\n    start = 1\n\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    start += (k - 1) // length\n    return int(str(start)[(k - 1) % length])\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "def can_vasya_win(n, s):\n    # Calculate the number of moves each player will make\n    moves_each = (n - 11) // 2\n\n    # Count the number of '8's in the first n - 10 characters\n    count_8s = s[:n - 10].count('8')\n\n    # Vasya wins if there are more '8's than the number of moves Petya can make\n    if count_8s > moves_each:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Determine if Vasya has a winning strategy\nresult = can_vasya_win(n, s)\nprint(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial(n):\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n    return fact\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef find_permutations(n, x, pos):\n    fact = factorial(n)\n    if x == pos + 1:\n        return fact[n - 1]\n    elif x < pos + 1:\n        return (fact[n - 1] * power(fact[pos], MOD - 2, MOD) * power(fact[n - pos - 1], MOD - 2, MOD)) % MOD\n    else:\n        return (fact[n - 1] * power(fact[pos], MOD - 2, MOD) * power(fact[n - pos - 1], MOD - 2, MOD) * power(fact[n - x], MOD - 2, MOD)) % MOD\n\nn, x, pos = map(int, input().split())\nprint(find_permutations(n, x, pos))"}
{"solution": "def decode_string(s, k):\n    n = len(s)\n    dp = [[False] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            if s[i - 1].isalpha():\n                if j > 0:\n                    dp[i][j] = dp[i - 1][j - 1]\n            elif s[i - 1] == '?':\n                dp[i][j] = dp[i - 1][j] or (j > 0 and dp[i - 1][j - 1])\n            else:\n                for l in range(j + 1):\n                    dp[i][j] = dp[i][j] or dp[i - 1][j - l]\n    if not dp[n][k]:\n        return \"Impossible\"\n    res = []\n    i, j = n, k\n    while i > 0 and j > 0:\n        if s[i - 1].isalpha():\n            res.append(s[i - 1])\n            i -= 1\n            j -= 1\n        elif s[i - 1] == '?':\n            if j > 0 and dp[i - 1][j - 1]:\n                res.append(s[i - 2])\n                i -= 1\n                j -= 1\n            else:\n                i -= 1\n        else:\n            for l in range(j + 1):\n                if dp[i - 1][j - l]:\n                    res.append(s[i - 2] * l)\n                    i -= 1\n                    j -= l\n                    break\n    return ''.join(res[::-1])\n\ns = input()\nk = int(input())\nprint(decode_string(s, k))"}
{"solution": "def min_turns(angle):\n    # Normalize the angle to be in the range [0, 360)\n    angle = angle % 360\n\n    # If the angle is negative, convert it to positive\n    if angle < 0:\n        angle += 360\n\n    # Calculate the deviation from vertical\n    deviation = min(angle, 360 - angle)\n\n    # Calculate the minimum number of 90-degree turns needed\n    turns = deviation // 90\n\n    return turns\n\n# Read the input angle\nangle = int(input())\n\n# Print the minimum number of turns\nprint(min_turns(angle))"}
{"solution": "# Get the input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Calculate the difference between the required and available spheres\ndiff_blue = a - x\ndiff_violet = b - y\ndiff_orange = c - z\n\n# If the difference is negative for any color, it means that the magician doesn't have enough spheres\n# If the difference is positive for two colors, it means that the magician can transform excess spheres into the required ones\n# If the difference is positive for one color and zero or negative for the other two, it means that the magician can't transform spheres to meet the requirement\n# If the difference is zero or negative for all colors, it means that the magician has enough spheres or can transform available spheres to meet the requirement\n\nif diff_blue < 0 or diff_violet < 0 or diff_orange < 0:\n    print(\"No\")\nelif (diff_blue > 0 and diff_violet > 0) or (diff_blue > 0 and diff_orange > 0) or (diff_violet > 0 and diff_orange > 0):\n    print(\"Yes\")\nelif (diff_blue > 0 and diff_violet <= 0 and diff_orange <= 0) or (diff_violet > 0 and diff_blue <= 0 and diff_orange <= 0) or (diff_orange > 0 and diff_blue <= 0 and diff_violet <= 0):\n    print(\"No\")\nelse:\n    print(\"Yes\")"}
{"solution": "def solve(n, k, m):\n    dp = [[0] * k for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(k):\n            for digit in range(10):\n                new_j = (j * 10 + digit) % k\n                dp[i][new_j] = (dp[i][new_j] + dp[i - 1][j]) % m\n    return (sum(dp[n]) - 1) % m\n\nn, k, m = map(int, input().split())\nprint(solve(n, k, m))"}
{"solution": "def max_team_size(l, r, a):\n    if l > r:\n        l, r = r, l  # Ensure l is always the smaller or equal group\n\n    # Use ambidexters to balance the difference\n    d = r - l\n    if a >= d:\n        l += d\n        a -= d\n        # Now l == r, distribute remaining ambidexters equally\n        l += a // 2\n        r += a // 2\n    else:\n        l += a\n        # Not enough ambidexters to balance completely, r remains larger\n\n    # The maximum team size is twice the smaller group\n    return 2 * min(l, r)\n\n# Get input\nl, r, a = map(int, input().split())\n\n# Print output\nprint(max_team_size(l, r, a))"}
{"solution": "def min_moves(n, k):\n    # Initialize the number of moves\n    moves = 0\n\n    # Throw stones to the first manhole\n    moves += (k - 1) * 2\n\n    # Open the first manhole and pick the coin\n    moves += 1\n\n    # Throw stones from the first manhole to the last manhole\n    moves += (n - 1) * 2\n\n    # Open the last manhole and pick the coin\n    moves += 1\n\n    # Throw stones from the last manhole to the second manhole\n    moves += (n - 2) * 2\n\n    # Open the second manhole and pick the coin\n    moves += 1\n\n    # Repeat the process for the remaining manholes\n    for i in range(3, n + 1):\n        # Throw stones from the second manhole to the current manhole\n        moves += (i - 2) * 2\n\n        # Open the current manhole and pick the coin\n        moves += 1\n\n        # Throw stones from the current manhole to the second manhole\n        moves += (i - 2) * 2\n\n    return moves\n\n# Read the input\nn, k = map(int, input().split())\n\n# Print the minimum number of moves\nprint(min_moves(n, k))"}
{"solution": "def min_tower_height(n, m):\n    # Calculate the total number of students\n    total_students = n + m\n\n    # Calculate the maximum possible height of the tallest tower\n    max_height = n * 2 + m * 3\n\n    # Initialize the minimum possible height of the tallest tower\n    min_height = max_height\n\n    # Calculate the height of the tallest tower for each possible number of blocks\n    for i in range(1, total_students + 1):\n        # Calculate the height of the current tower\n        tower_height = (i + 1) // 2 * 2 if i <= n else (i - n) * 3 + n * 2\n\n        # Update the minimum possible height of the tallest tower\n        min_height = min(min_height, tower_height)\n\n    return min_height\n\n# Read the input\nn, m = map(int, input().split())\n\n# Print the output\nprint(min_tower_height(n, m))"}
{"solution": "from collections import Counter\n\ndef can_split_evenly(n, cards):\n    count = Counter(cards)\n    for card, freq in count.items():\n        if freq > n // 2:\n            return False\n        if freq == n // 2:\n            return True, card\n    return False\n\ndef find_fair_game(n, cards):\n    for petya_card in set(cards):\n        remaining_cards = [card for card in cards if card != petya_card]\n        vasya_result = can_split_evenly(n, remaining_cards)\n        if vasya_result:\n            _, vasya_card = vasya_result\n            return True, petya_card, vasya_card\n    return False\n\nn = int(input())\ncards = [int(input()) for _ in range(n)]\n\nresult = find_fair_game(n, cards)\nif result:\n    _, petya_card, vasya_card = result\n    print(\"YES\")\n    print(petya_card, vasya_card)\nelse:\n    print(\"NO\")"}
{"solution": "# Read input\nn, k = map(int, input().split())\nsoldiers = list(map(int, input().split()))\n\n# Sort the soldiers in descending order\nsoldiers.sort(reverse=True)\n\n# Check if it's possible to arrange the soldiers\nfor i in range(k):\n    # If the number of soldiers in a group is more than half the number of seats in a row\n    if soldiers[i] > 4 * n:\n        print(\"NO\")\n        exit()\n    # If the number of soldiers in a group is more than the number of seats in two rows\n    elif soldiers[i] > 8:\n        # Decrease the number of rows available by two\n        n -= 2\n        # Decrease the number of soldiers in the group by eight\n        soldiers[i] -= 8\n    # If the number of soldiers in a group is more than four but not more than eight\n    elif soldiers[i] > 4:\n        # Decrease the number of rows available by one\n        n -= 1\n        # Decrease the number of soldiers in the group by four\n        soldiers[i] -= 4\n    # If the number of soldiers in a group is less than or equal to four\n    else:\n        # Decrease the number of rows available by one\n        n -= 1\n\n# If all soldiers have been arranged successfully\nif n >= 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def calculate_min_cost(n, sticks):\n    min_cost = float('inf')\n    optimal_t = 0\n\n    for t in range(1, 101):  # Iterate through possible values of t\n        cost = 0\n        for stick in sticks:\n            cost += min(abs(stick - t), abs(stick - t - 1), abs(stick - t + 1))\n        if cost < min_cost:\n            min_cost = cost\n            optimal_t = t\n\n    return optimal_t, min_cost\n\nn = int(input())\nsticks = list(map(int, input().split()))\n\nt, min_cost = calculate_min_cost(n, sticks)\nprint(t, min_cost)"}
{"solution": "# Read the input\nn, m = map(int, input().split())\nsky_map = [input() for _ in range(n)]\n\n# Find the boundaries of the stars\nmin_x, max_x, min_y, max_y = m, 0, n, 0\nfor i in range(n):\n    for j in range(m):\n        if sky_map[i][j] == '*':\n            min_x = min(min_x, j)\n            max_x = max(max_x, j)\n            min_y = min(min_y, i)\n            max_y = max(max_y, i)\n\n# Calculate the side length of the square\nside_length = max(max_x - min_x + 1, max_y - min_y + 1)\n\n# Print the result\nprint(side_length)"}
{"solution": "# Import necessary libraries\nfrom sys import stdin, stdout\nfrom math import factorial\n\n# Define a constant for modulo operation\nMOD = 10**9 + 7\n\n# Function to calculate power with modulo\ndef power(base, exponent, modulus):\n    result = 1\n    base %= modulus\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % modulus\n        base = (base * base) % modulus\n        exponent //= 2\n    return result\n\n# Function to calculate inverse with modulo\ndef inverse(number, modulus):\n    return power(number, modulus - 2, modulus)\n\n# Function to calculate binomial coefficient with modulo\ndef binomial_coefficient(n, k, modulus):\n    if n < k:\n        return 0\n    if k > n - k:\n        k = n - k\n    result = 1\n    for i in range(k):\n        result = (result * (n - i)) % modulus\n        result = (result * inverse(i + 1, modulus)) % modulus\n    return result\n\n# Function to calculate the answer\ndef calculate_answer(n, k, arr):\n    # Count the number of 1s in the array\n    count_ones = arr.count(1)\n\n    # If the number of 1s is less than k, return 0\n    if count_ones < k:\n        return 0\n\n    # Calculate the number of ways to choose k 1s from the array\n    ways_to_choose = binomial_coefficient(count_ones, k, MOD)\n\n    # Calculate the total number of ways to perform k swaps on the array\n    total_ways = power(binomial_coefficient(n, 2, MOD), k, MOD)\n\n    # Calculate the answer using modular arithmetic\n    answer = (ways_to_choose * inverse(total_ways, MOD)) % MOD\n\n    return answer\n\n# Read input from stdin\nn, k = map(int, stdin.readline().split())\narr = list(map(int, stdin.readline().split()))\n\n# Calculate the answer\nanswer = calculate_answer(n, k, arr)\n\n# Print the answer to stdout\nstdout.write(str(answer))"}
{"solution": "def min_seconds(x, y):\n    seconds = 0\n    while x > y:\n        # If x is odd, reduce one side by 1\n        if x % 2 == 1:\n            x -= 1\n        # Divide all sides by 2\n        x //= 2\n        seconds += 1\n    return seconds\n\n# Read input\nx, y = map(int, input().split())\n\n# Print output\nprint(min_seconds(x, y))"}
{"solution": "import math\n\n# Get the matrix elements as input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate the determinant of matrix A\ndet_A = a * d - b * c\n\n# If the determinant is already zero, the matrix is degenerate, and the norm ||A - B|| is 0\nif det_A == 0:\n    print(0)\nelse:\n    # Calculate the scaling factor to make the determinant zero while minimizing the norm ||A - B||\n    scale_factor = abs(det_A) / (abs(a) + abs(b) + abs(c) + abs(d))\n\n    # Calculate the elements of matrix B\n    B_a = a - scale_factor * a / math.sqrt(a**2 + b**2)\n    B_b = b - scale_factor * b / math.sqrt(a**2 + b**2)\n    B_c = c - scale_factor * c / math.sqrt(c**2 + d**2)\n    B_d = d - scale_factor * d / math.sqrt(c**2 + d**2)\n\n    # Calculate the norm ||A - B||\n    norm_diff = math.sqrt((a - B_a)**2 + (b - B_b)**2 + (c - B_c)**2 + (d - B_d)**2)\n\n    print(norm_diff)"}
{"solution": "# Read input\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Initialize tables\none_seaters = a\ntwo_seaters = b\nsingle_in_two_seater = 0\n\n# Initialize denied people\ndenied = 0\n\n# Iterate over groups\nfor group in groups:\n    # If group is of one person\n    if group == 1:\n        # If there is a vacant one-seater\n        if one_seaters > 0:\n            one_seaters -= 1\n        # Else if there is a vacant two-seater\n        elif two_seaters > 0:\n            two_seaters -= 1\n        # Else if there is a single person in a two-seater\n        elif single_in_two_seater > 0:\n            single_in_two_seater -= 1\n        # Else deny service\n        else:\n            denied += 1\n    # If group is of two people\n    else:\n        # If there is a vacant two-seater\n        if two_seaters > 0:\n            two_seaters -= 1\n        # Else deny service\n        else:\n            denied += 2\n\n# Print denied people\nprint(denied)"}
{"solution": "# Get the input\nA, B, C, N = map(int, input().split())\n\n# Check if the data contradicts itself\nif A + B - C > N or A + C > N or B + C > N or A + B - C < 0 or A + C < 0 or B + C < 0:\n    print(-1)\nelse:\n    # Calculate the number of students who didn't pass the exam\n    didnt_pass = N - (A + B - C)\n    # Check if at least one student stayed home\n    if didnt_pass > 0:\n        print(didnt_pass)\n    else:\n        print(-1)"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(x, k):\n    for _ in range(k):\n        x = (x * 2) % MOD\n        x = (x + x * pow(2, MOD - 2, MOD)) % MOD\n    return x\n\nx, k = map(int, input().split())\nprint(solve(x, k))"}
{"solution": "MOD = 998244353\n\ndef power(x, y):\n    result = 1\n    while y > 0:\n        if y % 2 == 1:\n            result = (result * x) % MOD\n        x = (x * x) % MOD\n        y = y // 2\n    return result\n\ndef inverse(x):\n    return power(x, MOD - 2)\n\ndef calculate_probability(n, l, r):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            for k in range(l[i - 1], r[i - 1] + 1):\n                if k >= j:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD\n                else:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % MOD\n\n    total = power(r[0] - l[0] + 1, n)\n    return (dp[n][n] * inverse(total)) % MOD\n\nn = int(input())\nl = []\nr = []\nfor _ in range(n):\n    li, ri = map(int, input().split())\n    l.append(li)\n    r.append(ri)\n\nprobability = calculate_probability(n, l, r)\nprint(probability)"}
{"solution": "def count_ways(n):\n    # INTJs prefer a systematic approach, so let's start by checking all possible lengths\n    ways = 0\n    for a in range(1, n // 4 + 1):\n        for b in range(a, (n - a) // 3 + 1):\n            # INTJs use logical reasoning to ensure that the conditions are met\n            if (n - a - b) % 2 == 0 and a != (n - a - b) // 2 and b != (n - a - b) // 2:\n                ways += 1\n    return ways\n\n# Input\nn = int(input())\n\n# Output\nprint(count_ways(n))"}
{"solution": "def find_min_kvass(n, s, kegs):\n    # Sort the kegs in descending order\n    kegs.sort(reverse=True)\n\n    # Calculate the total volume of kvass\n    total_kvass = sum(kegs)\n\n    # Check if it's possible to pour s liters of kvass\n    if total_kvass < s:\n        return -1\n\n    # Calculate the maximum possible volume for the least keg\n    max_min_kvass = total_kvass // n\n\n    # Check if it's possible to pour s liters of kvass with the current max_min_kvass\n    if max_min_kvass * n + kegs[-1] < s:\n        return -1\n\n    # Calculate the remaining kvass to be poured\n    remaining_kvass = s - max_min_kvass * n\n\n    # Pour the remaining kvass from the largest kegs\n    for i in range(n):\n        if kegs[i] > max_min_kvass and remaining_kvass > 0:\n            diff = min(remaining_kvass, kegs[i] - max_min_kvass)\n            kegs[i] -= diff\n            remaining_kvass -= diff\n\n    # Return the minimum kvass in the least keg\n    return min(kegs)\n\n# Read the input\nn, s = map(int, input().split())\nkegs = list(map(int, input().split()))\n\n# Print the result\nprint(find_min_kvass(n, s, kegs))"}
{"solution": "# Get the input\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Initialize the days and the current height of the caterpillar\ndays = 0\ncurrent_height = h1\n\n# Loop until the caterpillar reaches the apple or slips below the ground\nwhile current_height < h2:\n    # The caterpillar climbs during the day\n    current_height += a * 8\n\n    # If the caterpillar has reached the apple, break the loop\n    if current_height >= h2:\n        break\n\n    # The caterpillar slips down during the night\n    current_height -= b * 12\n\n    # If the caterpillar has slipped below the ground, reset its height to the ground level\n    if current_height < 0:\n        current_height = 0\n\n    # Increment the number of days\n    days += 1\n\n# If the caterpillar has reached the apple, print the number of days\nif current_height >= h2:\n    print(days)\n# Otherwise, print -1\nelse:\n    print(-1)"}
{"solution": "# Get the input\nC, Hr, Hb, Wr, Wb = map(int, input().split())\n\n# Calculate the maximum number of red candies Om Nom can eat\nmax_red_candies = min(C // Wr, C // Hr)\n\n# Calculate the remaining weight after eating red candies\nremaining_weight = C - max_red_candies * Wr\n\n# Calculate the maximum number of blue candies Om Nom can eat\nmax_blue_candies = min(remaining_weight // Wb, remaining_weight // Hb)\n\n# Calculate the total joy units\ntotal_joy = max_red_candies * Hr + max_blue_candies * Hb\n\n# Print the result\nprint(total_joy)"}
{"solution": "def min_steps(x1, y1, x2, y2):\n    # Calculate the absolute difference between the coordinates\n    dx = abs(x1 - x2)\n    dy = abs(y1 - y2)\n\n    # The robot can move diagonally as far as possible\n    diagonal_steps = min(dx, dy)\n\n    # The remaining steps will be horizontal or vertical\n    remaining_steps = abs(dx - dy)\n\n    # Return the total number of steps\n    return diagonal_steps + remaining_steps\n\n# Read the input\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\n# Print the result\nprint(min_steps(x1, y1, x2, y2))"}
{"solution": "# Read the input\nn = int(input())\nemployees = input()\n\n# Initialize variables\ndemocrats = []\nrepublicans = []\n\n# Separate employees into their respective factions\nfor i in range(n):\n    if employees[i] == 'D':\n        democrats.append(i)\n    else:\n        republicans.append(i)\n\n# Simulate the voting procedure\nwhile len(democrats) > 0 and len(republicans) > 0:\n    # Democrats make statements\n    for d in democrats:\n        # Check if the employee has the right to vote\n        if d in democrats:\n            # Find the next republican employee\n            next_r = next((r for r in republicans if r > d), None)\n            # If there is a next republican employee, deny them the right to vote\n            if next_r is not None:\n                republicans.remove(next_r)\n\n    # Republicans make statements\n    for r in republicans:\n        # Check if the employee has the right to vote\n        if r in republicans:\n            # Find the next democrat employee\n            next_d = next((d for d in democrats if d > r), None)\n            # If there is a next democrat employee, deny them the right to vote\n            if next_d is not None:\n                democrats.remove(next_d)\n\n# Determine the outcome of the vote\nif len(democrats) > 0:\n    print('D')\nelse:\n    print('R')"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef count_tv_sets(a, b, x, y):\n    # Calculate the greatest common divisor of x and y\n    g = gcd(x, y)\n\n    # Divide x and y by their greatest common divisor\n    x //= g\n    y //= g\n\n    # Calculate the maximum possible width and height\n    max_width = a // x\n    max_height = b // y\n\n    # Calculate the number of different variants\n    num_variants = min(max_width, max_height)\n\n    return num_variants\n\n# Read the input\na, b, x, y = map(int, input().split())\n\n# Calculate the number of different variants\nnum_variants = count_tv_sets(a, b, x, y)\n\n# Print the output\nprint(num_variants)"}
{"solution": "def factorial_trailing_zeros(n, b):\n    # Initialize the count of trailing zeros\n    count = 0\n\n    # Find the greatest power of b that divides n!\n    i = b\n    while n / i >= 1:\n        count += n // i\n        i *= b\n\n    # If b is a power of 10, divide count by the power of 10\n    if b == 10:\n        count //= 9\n    elif b == 100:\n        count //= 25\n    elif b == 1000:\n        count //= 125\n    elif b == 10000:\n        count //= 625\n    elif b == 100000:\n        count //= 3125\n    elif b == 1000000:\n        count //= 15625\n    elif b == 10000000:\n        count //= 78125\n    elif b == 100000000:\n        count //= 390625\n    elif b == 1000000000:\n        count //= 1953125\n    elif b == 10000000000:\n        count //= 9765625\n    elif b == 100000000000:\n        count //= 48828125\n    elif b == 1000000000000:\n        count //= 244140625\n\n    return count\n\n# Read the input\nn, b = map(int, input().split())\n\n# Calculate the number of trailing zeros\nresult = factorial_trailing_zeros(n, b)\n\n# Print the result\nprint(result)"}
{"solution": "def frog_jumps(m, a, b):\n    # Initialize dp array with 0s\n    dp = [0] * (m + 1)\n    dp[0] = 1  # The frog can reach position 0\n\n    # Initialize sum_dp array with 0s\n    sum_dp = [0] * (m + 1)\n    sum_dp[0] = 1  # The sum of f(i) for i from 0 to 0 is 1\n\n    # Iterate from 1 to m\n    for i in range(1, m + 1):\n        # The frog can reach position i by jumping from i-a or i+b\n        if i >= a:\n            dp[i] += dp[i - a]\n        if i >= b:\n            dp[i] += sum_dp[i - b] - sum_dp[max(0, i - b - a + 1)]\n\n        # Update sum_dp[i]\n        sum_dp[i] = sum_dp[i - 1] + dp[i]\n\n    # Return the sum of all f(i) for i from 0 to m\n    return sum_dp[m]\n\n# Read input\nm, a, b = map(int, input().split())\n\n# Print output\nprint(frog_jumps(m, a, b))"}
{"solution": "# Read the length of the sequence\nn = int(input())\n\n# Read the elements of the sequence\nsequence = list(map(int, input().split()))\n\n# Check if the first and last elements are odd\nif sequence[0] % 2 == 0 or sequence[-1] % 2 == 0:\n    print(\"No\")\nelse:\n    # Count the number of odd elements in the sequence\n    odd_count = sum(1 for num in sequence if num % 2 == 1)\n\n    # Check if the length of the sequence and the number of odd elements are odd\n    if n % 2 == 1 and odd_count % 2 == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")"}
{"solution": "def find_coordinates(x1, y1, x2, y2):\n    if abs(x1 - x2) == abs(y1 - y2):\n        return [x1, y2, x2, y1] if x1 != x2 else [x2, y1, x1, y2]\n    elif x1 == x2:\n        diff = abs(y1 - y2)\n        return [x1 + diff, y1, x2 + diff, y2]\n    elif y1 == y2:\n        diff = abs(x1 - x2)\n        return [x1, y1 + diff, x2, y2 + diff]\n    else:\n        return [-1]\n\nx1, y1, x2, y2 = map(int, input().split())\nresult = find_coordinates(x1, y1, x2, y2)\nprint(*result)"}
{"solution": "MOD = 10**9 + 7\n\ndef matrix_multiply(a, b):\n    result = [[0, 0], [0, 0]]\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                result[i][j] = (result[i][j] + a[i][k] * b[k][j]) % MOD\n    return result\n\ndef matrix_power(matrix, n):\n    result = [[1, 0], [0, 1]]\n    while n > 0:\n        if n % 2 == 1:\n            result = matrix_multiply(result, matrix)\n        matrix = matrix_multiply(matrix, matrix)\n        n //= 2\n    return result\n\ndef calculate_fn(x, y, n):\n    if n == 1:\n        return x\n    if n == 2:\n        return y\n    matrix = [[1, 1], [1, 0]]\n    powered_matrix = matrix_power(matrix, n - 2)\n    return (powered_matrix[0][0] * y + powered_matrix[0][1] * x) % MOD\n\nx, y = map(int, input().split())\nn = int(input())\nresult = calculate_fn(x, y, n)\nprint(result)"}
{"solution": "def solve_array_split(n, arr):\n    # Initialize an empty list to store the subarrays\n    subarrays = []\n    # Initialize a variable to store the start index of the current subarray\n    start = 0\n\n    # Iterate through the array\n    for i in range(n):\n        # If the sum of the current subarray is zero and it's not empty\n        if start < i and sum(arr[start:i]) == 0:\n            # Add the current subarray to the list of subarrays\n            subarrays.append((start, i))\n            # Update the start index of the current subarray\n            start = i\n\n    # If the sum of the last subarray is not zero\n    if sum(arr[start:]) != 0:\n        # Add the last subarray to the list of subarrays\n        subarrays.append((start, n))\n\n    # If the list of subarrays is empty\n    if not subarrays:\n        # It's not possible to split the array\n        print(\"NO\")\n    else:\n        # It's possible to split the array\n        print(\"YES\")\n        # Print the number of subarrays\n        print(len(subarrays))\n        # Print the subarrays\n        for subarray in subarrays:\n            print(*subarray)\n\n# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Solve the problem\nsolve_array_split(n, arr)"}
{"solution": "def min_score(n, m, k):\n    MOD = 1000000009\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] + (1 << (i - 1) % (k - 1))\n        if i >= k:\n            dp[i] = min(dp[i], dp[i - k] * 2 + 1)\n    return (dp[n] - m) % MOD\n\nn, m, k = map(int, input().split())\nprint(min_score(n, m, k))"}
{"solution": "def find_divisible_by_eight(n):\n    # Convert the number to a string for easier manipulation\n    n = str(n)\n\n    # Check each possible subset of digits\n    for i in range(len(n)):\n        for j in range(i, len(n)):\n            # Extract the subset of digits\n            subset = n[i:j+1]\n\n            # Check if the subset is divisible by 8\n            if int(subset) % 8 == 0:\n                return subset\n\n    # If no subset is divisible by 8, return None\n    return None\n\n# Get the input number\nn = int(input())\n\n# Find a subset that is divisible by 8\nresult = find_divisible_by_eight(n)\n\n# Print the result\nif result is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(result)"}
{"solution": "def find_floor(n, m, memory):\n    # Sort the memory by flat number\n    memory.sort(key=lambda x: x[0])\n\n    # Initialize the floor size and previous floor\n    floor_size = memory[0][0]\n    prev_floor = memory[0][1]\n\n    # Iterate through the memory\n    for flat, floor in memory[1:]:\n        # Check if the floor size is consistent\n        if (flat - 1) // floor_size != (prev_floor - 1) // floor_size:\n            return -1\n        # Update the previous floor\n        prev_floor = floor\n\n    # Calculate the floor for the n-th flat\n    return (n - 1) // floor_size + 1\n\n# Read the input\nn, m = map(int, input().split())\nmemory = [list(map(int, input().split())) for _ in range(m)]\n\n# Print the output\nprint(find_floor(n, m, memory))"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    board = [[board1[i], board2[i]] for i in range(n)]\n\n    bishwock_shapes = [\n        [(0, 0), (0, 1), (1, 0)],\n        [(0, 0), (0, 1), (1, 1)],\n        [(0, 1), (1, 0), (1, 1)],\n        [(0, 0), (1, 0), (1, 1)]\n    ]\n\n    def can_place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            if nx >= 2 or ny >= n or board[ny][nx] == 'X':\n                return False\n        return True\n\n    def place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            board[ny][nx] = 'X'\n\n    count = 0\n    for y in range(n):\n        for x in range(2):\n            for shape in bishwock_shapes:\n                if can_place_bishwock(x, y, shape):\n                    place_bishwock(x, y, shape)\n                    count += 1\n                    break\n\n    return count\n\n# Test the function with the provided example\nboard1 = \"00X00X0XXX0\"\nboard2 = \"0XXX0X00X00\"\nprint(max_bishwocks(board1, board2))  # Output: 4"}
{"solution": "def max_pretty_set_length(n, s):\n    max_length = 0\n    current_set = set()\n\n    for char in s:\n        if char.islower():\n            current_set.add(char)\n        else:\n            max_length = max(max_length, len(current_set))\n            current_set.clear()\n\n    # Check the last segment\n    max_length = max(max_length, len(current_set))\n\n    return max_length\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult = max_pretty_set_length(n, s)\n\n# Print the result\nprint(result)"}
{"solution": "# Read the number of elements in the sequence\nn = int(input())\n\n# Read the elements of the sequence\na = list(map(int, input().split()))\n\n# Initialize the sum of elements in sequence b and c\nB = 0\nC = 0\n\n# Sort the sequence in descending order\na.sort(reverse=True)\n\n# Iterate through the sorted sequence\nfor i in range(n):\n    # If the current element is positive, add it to sequence b\n    if a[i] > 0:\n        B += a[i]\n    # If the current element is negative or zero, add it to sequence c\n    else:\n        C += a[i]\n\n# Print the maximum possible value of B - C\nprint(B - C)"}
{"solution": "def min_refuels(a, b, f, k):\n    # Calculate the distance covered in one full journey\n    full_journey = 2 * a\n\n    # Calculate the distance covered before reaching the gas station\n    distance_to_gas_station = min(f, a - f)\n\n    # Calculate the number of full journeys that can be made without refueling\n    full_journeys_without_refuel = b // full_journey\n\n    # Check if it's possible to make k journeys\n    if full_journeys_without_refuel < k:\n        # Calculate the remaining distance after full journeys without refueling\n        remaining_distance = k * full_journey - full_journeys_without_refuel * b\n\n        # Check if it's possible to make the remaining distance with refueling\n        if remaining_distance > 2 * f:\n            return -1\n        else:\n            # Calculate the number of refuels needed\n            refuels_needed = (remaining_distance - full_journeys_without_refuel * distance_to_gas_station) // (2 * f)\n            return full_journeys_without_refuel + refuels_needed\n    else:\n        return 0\n\n# Read input\na, b, f, k = map(int, input().split())\n\n# Print output\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    for i in range(n // p):\n        if (n - p * i) % q == 0:\n            return [s[j:j+p] for j in range(0, p*i, p)] + [s[p*i:]]\n    return -1\n\nn, p, q = map(int, input().split())\ns = input()\nresult = split_string(n, p, q, s)\n\nif result != -1:\n    print(len(result))\n    for part in result:\n        print(part)\nelse:\n    print(-1)"}
{"solution": "def can_reach_finish(n, m, s, d, obstacles):\n    obstacles.sort()\n    current_position = 0\n    for obstacle in obstacles:\n        if obstacle - current_position < s:\n            return \"IMPOSSIBLE\"\n        jump_distance = obstacle - current_position - s\n        if jump_distance > d:\n            return \"IMPOSSIBLE\"\n        current_position = obstacle + jump_distance\n    if m - current_position < s:\n        return \"IMPOSSIBLE\"\n    return f\"RUN {s}\\nJUMP {m - current_position - s}\"\n\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\nprint(can_reach_finish(n, m, s, d, obstacles))"}
{"solution": "def count_pairs(s, x):\n    # Calculate b\n    b = (s - x) // 2\n\n    # Check if b is a valid solution\n    if b <= 0 or b * 2 + x != s:\n        return 0\n\n    # Calculate a\n    a = s - b\n\n    # Check if a is a valid solution\n    if a <= 0:\n        return 0\n\n    # If both a and b are valid, return 2 (for each valid pair, considering both (a, b) and (b, a))\n    return 2\n\n# Read input\ns, x = map(int, input().split())\n\n# Print the number of solutions\nprint(count_pairs(s, x))"}
{"solution": "# Read the input\nn, k = map(int, input().split())\n\n# Calculate the minimum number of actions needed\nl = (n + 2 * k) // (2 * k + 1)\n\n# Print the minimum number of actions needed\nprint(l)\n\n# Print the number of the skewer that is to be turned over at the corresponding step\nfor i in range(1, l + 1):\n    print((i - 1) * (2 * k + 1) + k + 1)"}
{"solution": "def min_operations_to_square(n):\n    import math\n\n    n_str = str(n)\n    n_len = len(n_str)\n\n    # Generate all possible squares up to the maximum possible value\n    max_square_root = int(math.sqrt(2 * 10**9)) + 1\n    squares = [str(i * i) for i in range(1, max_square_root + 1)]\n\n    def is_subsequence(small, large):\n        it = iter(large)\n        return all(char in it for char in small)\n\n    min_deletions = float('inf')\n\n    for square in squares:\n        if is_subsequence(square, n_str):\n            deletions = n_len - len(square)\n            min_deletions = min(min_deletions, deletions)\n\n    return min_deletions if min_deletions != float('inf') else -1\n\n# Read input\nn = int(input())\n\n# Print output\nprint(min_operations_to_square(n))"}
{"solution": "def count_permutations(n):\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    max_f = 1\n    count = 1\n\n    for i in range(2, n + 1):\n        new_dp = [0] * (i + 1)\n        new_max_f = 0\n        new_count = 0\n\n        for j in range(1, i + 1):\n            gcd = j\n            for k in range(1, j):\n                gcd = math.gcd(gcd, k)\n\n            if gcd > new_max_f:\n                new_max_f = gcd\n                new_count = dp[j - 1]\n            elif gcd == new_max_f:\n                new_count = (new_count + dp[j - 1]) % MOD\n\n            new_dp[j] = new_count\n\n        dp = new_dp\n        max_f = new_max_f\n        count = new_count\n\n    return count\n\nn = int(input())\nresult = count_permutations(n)\nprint(result)"}
{"solution": "def minimum_jump_ability(s):\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    positions = [-1]  # Start position before the first character\n\n    # Collect positions of all vowels\n    for i, char in enumerate(s):\n        if char in vowels:\n            positions.append(i)\n\n    positions.append(len(s))  # End position after the last character\n\n    # Calculate maximum distance between consecutive positions\n    max_distance = 0\n    for i in range(1, len(positions)):\n        max_distance = max(max_distance, positions[i] - positions[i - 1])\n\n    return max_distance\n\n# Read input string\ns = input()\n\n# Print the minimum jump ability\nprint(minimum_jump_ability(s))"}
{"solution": "# Get the input\na1, a2, a3, a4 = map(int, input().split())\n\n# Calculate the total sum of candies\ntotal_sum = a1 + a2 + a3 + a4\n\n# Check if the total sum is odd or if any bag contains more than half of the total sum\nif total_sum % 2 != 0 or max(a1, a2, a3, a4) > total_sum / 2:\n    print(\"NO\")\nelse:\n    # Check if it's possible to distribute the candies equally\n    if a1 + a2 == total_sum / 2 or a1 + a3 == total_sum / 2 or a1 + a4 == total_sum / 2:\n        print(\"YES\")\n    elif a2 + a3 == total_sum / 2 or a2 + a4 == total_sum / 2:\n        print(\"YES\")\n    elif a3 + a4 == total_sum / 2:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "def pie_distribution(n, slices):\n    # Create a 2D DP table to store the maximum amount of pie each participant can get\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    # Fill the DP table using bottom-up approach\n    for gap in range(1, n + 1):\n        for i in range(n - gap + 1):\n            j = i + gap\n            # If Alice takes the ith slice\n            dp[i][j] = max(slices[i] + min(dp[i + 2][j], dp[i + 1][j - 1]),\n                           # If Alice takes the jth slice\n                           slices[j - 1] + min(dp[i][j - 2], dp[i + 1][j - 1]))\n\n    # The total amount of pie is the sum of all slices\n    total_pie = sum(slices)\n\n    # The maximum amount of pie Alice can get is stored in dp[0][n]\n    alice_pie = dp[0][n]\n\n    # The maximum amount of pie Bob can get is the total amount of pie minus the amount Alice gets\n    bob_pie = total_pie - alice_pie\n\n    return alice_pie, bob_pie\n\n# Read the input\nn = int(input())\nslices = list(map(int, input().split()))\n\n# Calculate the distribution of pie\nalice_pie, bob_pie = pie_distribution(n, slices)\n\n# Print the output\nprint(alice_pie, bob_pie)"}
{"solution": "def find_min_variables(n, a):\n    # Create a dictionary to store the count of each number in the sequence\n    count = {}\n    for num in a:\n        count[num] = 0\n\n    # Iterate through the sequence\n    for num in a:\n        # If the count of the current number is greater than 1, we need additional variables\n        if count[num] > 1:\n            # Create a new variable for the current number\n            count[num] = 1\n            # Update the count of the numbers used in the previous operations\n            for key in count:\n                if key != num and count[key] > 0:\n                    count[key] += 1\n        # If the count of the current number is 0, assign it to a new variable\n        elif count[num] == 0:\n            count[num] = 1\n\n    # Return the minimum number of variables needed\n    return sum(count.values())\n\n# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the output\nprint(find_min_variables(n, a))"}
{"solution": "def determine_winner(n, piles):\n    odd_count = sum(1 for pile in piles if pile % 2 != 0)\n    if odd_count % 2 == 0:\n        return \"Alice\"\n    else:\n        return \"Bob\"\n\n# Read input\nn = int(input())\npiles = list(map(int, input().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, piles))"}
{"solution": "def can_make_equal(n, arr):\n    arr.sort()\n    diff = [arr[i] - arr[i-1] for i in range(1, n)]\n    gcd_diff = diff[0]\n    for i in range(1, n-1):\n        gcd_diff = gcd(gcd_diff, diff[i])\n    if gcd_diff == 0:\n        return arr[0] == arr[-1]\n    return (arr[-1] - arr[0]) % gcd_diff == 0\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\nn = int(input())\narr = list(map(int, input().split()))\nif can_make_equal(n, arr):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def longest_repeated_substring(n, s):\n    max_len = 0\n    for length in range(n // 2, 0, -1):\n        for i in range(n - 2 * length + 1):\n            substring = s[i:i+length]\n            if substring in s[i+length:]:\n                return length\n    return 0\n\nn = int(input())\ns = input()\nprint(longest_repeated_substring(n, s))"}
{"solution": "def minimum_time_to_house(n, a):\n    if a % 2 == 1:\n        # a is odd\n        return (a + 1) // 2\n    else:\n        # a is even\n        return (n - a + 2) // 2\n\n# Read input\nn, a = map(int, input().split())\n\n# Calculate and print the result\nprint(minimum_time_to_house(n, a))"}
{"solution": "def find_subarray(n, m, colors, desired_counts):\n    window_counts = [0] * m\n    left = 0\n    for right in range(n):\n        window_counts[colors[right] - 1] += 1\n        if right - left + 1 == sum(desired_counts):\n            if window_counts == desired_counts:\n                return \"YES\"\n            window_counts[colors[left] - 1] -= 1\n            left += 1\n    return \"NO\"\n\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\ndesired_counts = list(map(int, input().split()))\n\nprint(find_subarray(n, m, colors, desired_counts))"}
{"solution": "def determine_winner(n, rounds):\n    mishka_wins = 0\n    chris_wins = 0\n\n    for round in rounds:\n        m, c = round\n        if m > c:\n            mishka_wins += 1\n        elif c > m:\n            chris_wins += 1\n\n    if mishka_wins > chris_wins:\n        return \"Mishka\"\n    elif chris_wins > mishka_wins:\n        return \"Chris\"\n    else:\n        return \"Friendship is magic!^^\"\n\nn = int(input())\nrounds = []\nfor _ in range(n):\n    m, c = map(int, input().split())\n    rounds.append((m, c))\n\nprint(determine_winner(n, rounds))"}
{"solution": "def is_valid(field, n, m):\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                continue\n            elif field[i][j] == '.':\n                if not is_safe(field, i, j, n, m):\n                    return False\n            else:\n                if not is_valid_digit(field, i, j, n, m):\n                    return False\n    return True\n\ndef is_safe(field, i, j, n, m):\n    for x in range(max(0, i-1), min(n, i+2)):\n        for y in range(max(0, j-1), min(m, j+2)):\n            if field[x][y] == '*':\n                return False\n    return True\n\ndef is_valid_digit(field, i, j, n, m):\n    count = 0\n    for x in range(max(0, i-1), min(n, i+2)):\n        for y in range(max(0, j-1), min(m, j+2)):\n            if field[x][y] == '*':\n                count += 1\n    return count == int(field[i][j])\n\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\nprint(\"YES\" if is_valid(field, n, m) else \"NO\")"}
{"solution": "def can_vasya_eat_half(n, k):\n    total_candies = n\n    vasya_eaten = 0\n\n    while total_candies > 0:\n        # Vasya eats k candies\n        vasya_eaten += min(k, total_candies)\n        total_candies -= min(k, total_candies)\n\n        # Petya eats 10% of the remaining candies\n        petya_eaten = total_candies // 10\n        total_candies -= petya_eaten\n\n    return vasya_eaten >= (n + 1) // 2\n\ndef find_min_k(n):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Read input\nn = int(input().strip())\n\n# Find and print the minimal k\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace(s):\n    p = s.count('o')\n    l = s.count('-')\n\n    if p == 0 or p == 1:\n        return \"YES\"\n    if l % p == 0:\n        return \"YES\"\n    return \"NO\"\n\n# Get input from the user\ns = input()\n\n# Print the result\nprint(can_rearrange_necklace(s))"}
{"solution": "def max_pillows(n, m, k):\n    # Each hobbit needs at least one pillow\n    m -= n\n    k -= 1\n\n    # Calculate the number of pillows Frodo can have\n    # Frodo can have the minimum of pillows he can take from the left and right sides\n    frodo_pillows = min(k, m - k)\n\n    # Calculate the number of pillows left for other hobbits\n    remaining_pillows = m - frodo_pillows\n\n    # Each hobbit should have at least one pillow\n    # So, the number of pillows Frodo can have is the minimum of the pillows he can take\n    # and the number of pillows that can be distributed equally among the other hobbits\n    frodo_pillows = min(frodo_pillows, remaining_pillows // (n - 1))\n\n    return frodo_pillows\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Print output\nprint(max_pillows(n, m, k))"}
{"solution": "import sys\nfrom math import ceil\n\ndef max_subarray_cost(n, m, k, a):\n    prefix_sum = [0] * (n + 1)\n    dp = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + a[i - 1]\n\n    for i in range(1, n + 1):\n        dp[i] = max(dp[i - 1], prefix_sum[i] - k * ceil(i / m))\n        for j in range(i - 1, 0, -1):\n            dp[i] = max(dp[i], (prefix_sum[i] - prefix_sum[j - 1]) - k * ceil((i - j + 1) / m))\n\n    return max(dp)\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    print(max_subarray_cost(n, m, k, a))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\n# Get the dimensions of the grid\nn, m = map(int, input().split())\n\n# Calculate the distance between the two diagonal points\ndiagonal_distance = math.sqrt(n**2 + m**2)\n\n# If the grid is square or wider than it is tall\nif n >= m:\n    # Calculate the distance between the two vertical points\n    vertical_distance = m\n    # Calculate the distance between the two horizontal points\n    horizontal_distance = n - (diagonal_distance - vertical_distance) / 2\n    # Print the coordinates of the points\n    print(f\"0 0\\n{n} 0\\n{n} {int(horizontal_distance)}\\n0 {m}\")\n# If the grid is taller than it is wide\nelse:\n    # Calculate the distance between the two horizontal points\n    horizontal_distance = n\n    # Calculate the distance between the two vertical points\n    vertical_distance = m - (diagonal_distance - horizontal_distance) / 2\n    # Print the coordinates of the points\n    print(f\"0 0\\n{horizontal_distance} 0\\n{n} {m}\\n0 {int(vertical_distance)}\")"}
{"solution": "def find_smallest_number(shuffled_string, substring):\n    # Count the frequency of each digit in the shuffled string and substring\n    shuffled_count = [0] * 10\n    substring_count = [0] * 10\n    for digit in shuffled_string:\n        shuffled_count[int(digit)] += 1\n    for digit in substring:\n        substring_count[int(digit)] += 1\n\n    # Calculate the excess count of each digit in the shuffled string\n    excess_count = [shuffled_count[i] - substring_count[i] for i in range(10)]\n\n    # Initialize the result string with the substring\n    result = substring\n\n    # Iterate through the shuffled string and append excess digits to the result\n    for digit in shuffled_string:\n        if excess_count[int(digit)] > 0:\n            result += digit\n            excess_count[int(digit)] -= 1\n\n    # Find the first non-zero digit in the result string\n    first_non_zero = 0\n    while first_non_zero < len(result) and result[first_non_zero] == '0':\n        first_non_zero += 1\n\n    # If the result string is empty, return '0'\n    if first_non_zero == len(result):\n        return '0'\n\n    # Swap the first non-zero digit with the first digit of the result string\n    result = result[first_non_zero] + result[:first_non_zero] + result[first_non_zero + 1:]\n\n    return result\n\n# Read the input\nshuffled_string = input()\nsubstring = input()\n\n# Find the smallest possible initial integer n\nresult = find_smallest_number(shuffled_string, substring)\n\n# Print the result\nprint(result)"}
{"solution": "# Read input\nn, m, min_temp, max_temp = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\n# Check if the recorded temperatures are within the minimum and maximum constraints\nif min(temperatures) < min_temp or max(temperatures) > max_temp:\n    print('Incorrect')\nelse:\n    # Check if it's possible to add n - m temperatures while maintaining the constraints\n    min_count = sum(1 for temp in temperatures if temp == min_temp)\n    max_count = sum(1 for temp in temperatures if temp == max_temp)\n\n    if min_count + (n - m) >= m and max_count + (n - m) >= m:\n        print('Correct')\n    else:\n        print('Incorrect')"}
{"solution": "def find_factorial_trailing_zeroes(m):\n    # Initialize variables\n    count = 0\n    n = 5\n    result = []\n\n    # Count how many multiples of 5 are less than or equal to m\n    while m // n > 0:\n        count += m // n\n        n *= 5\n\n    # If count is 0, return 0 as there are no such numbers\n    if count == 0:\n        return 0, []\n\n    # Find the numbers whose factorial ends with m zeroes\n    for i in range(1, count + 1):\n        # Binary search to find the number\n        left, right = 0, 10**10\n        while left < right:\n            mid = (left + right) // 2\n            if sum(mid // 5**j for j in range(1, 100)) >= i:\n                right = mid\n            else:\n                left = mid + 1\n        result.append(left)\n\n    return count, result\n\n# Read input\nm = int(input())\n\n# Find the number of integers and the integers themselves\nk, result = find_factorial_trailing_zeroes(m)\n\n# Print output\nprint(k)\nprint(*result)"}
{"solution": "import heapq\n\ndef dijkstra(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n\n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node].items():\n            distance = max(current_distance, weight)\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n\n    return distances\n\ndef find_farthest_special_vertex(graph, special_vertices):\n    farthest_distances = []\n\n    for vertex in special_vertices:\n        distances = dijkstra(graph, vertex)\n        max_distance = 0\n\n        for special_vertex in special_vertices:\n            max_distance = max(max_distance, distances[special_vertex])\n\n        farthest_distances.append(max_distance)\n\n    return farthest_distances\n\ndef main():\n    n, m, k = map(int, input().split())\n    special_vertices = list(map(int, input().split()))\n    graph = {i: {} for i in range(1, n+1)}\n\n    for _ in range(m):\n        u, v, w = map(int, input().split())\n        graph[u][v] = w\n        graph[v][u] = w\n\n    farthest_distances = find_farthest_special_vertex(graph, special_vertices)\n    print(*farthest_distances)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "# Read the input\nn = int(input())\nx = int(input())\n\n# Calculate the initial position of the ball\ninitial_position = x\nif n % 2 == 1:\n    if initial_position == 0:\n        initial_position = 1\n    elif initial_position == 1:\n        initial_position = 0\nelse:\n    if initial_position == 1:\n        initial_position = 2\n    elif initial_position == 2:\n        initial_position = 1\n\n# Print the initial position of the ball\nprint(initial_position)"}
{"solution": "def is_square(rectangles):\n    # Identify the Bounding Box\n    min_x = min(x1 for x1, _, _, _ in rectangles)\n    max_x = max(x2 for _, x2, _, _ in rectangles)\n    min_y = min(y1 for _, _, y1, _ in rectangles)\n    max_y = max(y2 for _, _, _, y2 in rectangles)\n\n    # Check for Square Dimensions\n    if max_x - min_x != max_y - min_y:\n        return False\n\n    # Verify Coverage\n    area = (max_x - min_x) * (max_y - min_y)\n    total_rectangle_area = sum((x2 - x1) * (y2 - y1) for x1, x2, y1, y2 in rectangles)\n    return area == total_rectangle_area\n\n# Read input\nn = int(input())\nrectangles = [list(map(int, input().split())) for _ in range(n)]\n\n# Print output\nprint(\"YES\" if is_square(rectangles) else \"NO\")"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef count_really_big_numbers(n, s):\n    count = 0\n    for i in range(1, n + 1):\n        if i - sum_of_digits(i) >= s:\n            count += 1\n    return count\n\nn, s = map(int, input().split())\nprint(count_really_big_numbers(n, s))"}
{"solution": "from collections import defaultdict\n\ndef can_cover_points(points):\n    x_dict = defaultdict(int)\n    y_dict = defaultdict(int)\n    xy_dict = defaultdict(int)\n    yx_dict = defaultdict(int)\n\n    for x, y in points:\n        x_dict[x] += 1\n        y_dict[y] += 1\n        xy_dict[x + y] += 1\n        yx_dict[y - x] += 1\n\n    max_x = max(x_dict.values())\n    max_y = max(y_dict.values())\n    max_xy = max(xy_dict.values())\n    max_yx = max(yx_dict.values())\n\n    if max_x * 2 >= len(points) or max_y * 2 >= len(points) or max_xy * 2 >= len(points) or max_yx * 2 >= len(points):\n        return True\n    return False\n\ndef main():\n    n = int(input())\n    points = [list(map(int, input().split())) for _ in range(n)]\n\n    if can_cover_points(points):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(a, b, k, t):\n    dp = [[0] * (2 * k + 1) for _ in range(t + 1)]\n    dp[0][a - b + k] = 1\n\n    for i in range(1, t + 1):\n        for j in range(2 * k + 1):\n            for x in range(-k, k + 1):\n                if 0 <= j + x < 2 * k + 1:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j + x]) % MOD\n\n    return sum(dp[t][k + 1:]) % MOD\n\na, b, k, t = map(int, input().split())\nprint(solve(a, b, k, t))"}
{"solution": "def min_marks(n, l, x, y, marks):\n    marks_set = set(marks)\n    add_marks = []\n\n    if x not in marks_set:\n        add_marks.append(x)\n    if y not in marks_set:\n        add_marks.append(y)\n\n    for mark in marks:\n        if mark + x not in marks_set and mark + x <= l:\n            add_marks.append(mark + x)\n        if mark + y not in marks_set and mark + y <= l:\n            add_marks.append(y - mark)\n\n    return add_marks\n\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\nadd_marks = min_marks(n, l, x, y, marks)\n\nprint(len(add_marks))\nprint(' '.join(map(str, add_marks)))"}
{"solution": "import math\n\n# Read the number of cakes\nn = int(input())\n\n# Read the dimensions of each cake and calculate its volume\ncakes = []\nfor i in range(n):\n    r, h = map(int, input().split())\n    volume = math.pi * r**2 * h\n    cakes.append(volume)\n\n# Sort the cakes in ascending order of volume\ncakes.sort()\n\n# Initialize the maximum possible volume of the birthday cake\nmax_volume = 0\n\n# Initialize the volume of the current cake stack\nstack_volume = 0\n\n# Iterate through the sorted cakes\nfor i in range(n):\n    # If the current cake can be placed on top of the stack, add its volume to the stack volume\n    if i == 0 or cakes[i] > cakes[i-1]:\n        stack_volume += cakes[i]\n        # Update the maximum possible volume of the birthday cake\n        max_volume = max(max_volume, stack_volume)\n    # If the current cake cannot be placed on top of the stack, reset the stack volume to the volume of the current cake\n    else:\n        stack_volume = cakes[i]\n\n# Print the maximum possible volume of the birthday cake\nprint(max_volume)"}
{"solution": "def min_slices(n, k, towers):\n    towers.sort()\n    slices = 0\n    while towers[-1] != towers[0]:\n        max_height = towers[-1]\n        cost = sum(max_height - h for h in towers)\n        if cost <= k:\n            k -= cost\n            towers = [max_height] * n\n        else:\n            height_diff = cost // n\n            if cost % n != 0:\n                height_diff += 1\n            towers = [max(h - height_diff, towers[0]) for h in towers]\n        slices += 1\n    return slices\n\nn, k = map(int, input().split())\ntowers = list(map(int, input().split()))\nprint(min_slices(n, k, towers))"}
{"solution": "def max_score(n, a):\n    # Calculate prefix sums\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    max_score = float('-inf')\n\n    # Iterate over all possible segments [l, r]\n    for l in range(n):\n        max_in_segment = float('-inf')\n        for r in range(l, n):\n            # Update the maximum value in the current segment\n            max_in_segment = max(max_in_segment, a[r])\n            # Calculate the sum of the current segment\n            segment_sum = prefix_sum[r + 1] - prefix_sum[l]\n            # Calculate the score after Bob removes the max value\n            score = segment_sum - max_in_segment\n            # Update the maximum score\n            max_score = max(max_score, score)\n\n    return max_score\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print output\nprint(max_score(n, a))"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef solve(k1, k2, k3):\n    lcm_1_2 = k1 * k2 // gcd(k1, k2)\n    lcm_1_3 = k1 * k3 // gcd(k1, k3)\n    lcm_2_3 = k2 * k3 // gcd(k2, k3)\n    lcm_1_2_3 = lcm_1_2 * k3 // gcd(lcm_1_2, k3)\n\n    if lcm_1_2_3 < max(k1, k2, k3):\n        return \"NO\"\n    else:\n        return \"YES\"\n\nk1, k2, k3 = map(int, input().split())\nprint(solve(k1, k2, k3))"}
{"solution": "def min_operations_to_delete_string(n, s):\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(n)]\n\n    # Base case: single character substrings\n    for i in range(n):\n        dp[i][i] = 1\n\n    # Fill the DP table for substrings of length greater than 1\n    for length in range(2, n + 1):  # length of the substring\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j-1]\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n\n    # The result for the entire string\n    return dp[0][n-1]\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Print output\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "# Read input\nn = int(input())\nboys = sorted(list(map(int, input().split())))\nm = int(input())\ngirls = sorted(list(map(int, input().split())))\n\n# Initialize pair count\npairs = 0\n\n# Iterate through boys and girls\ni = j = 0\nwhile i < n and j < m:\n    # If skill difference is at most 1, form a pair\n    if abs(boys[i] - girls[j]) <= 1:\n        pairs += 1\n        i += 1\n        j += 1\n    # If boy's skill is less, move to the next boy\n    elif boys[i] < girls[j]:\n        i += 1\n    # If girl's skill is less, move to the next girl\n    else:\n        j += 1\n\n# Print the maximum possible number of pairs\nprint(pairs)"}
{"solution": "# Read the input\nteam1_player1 = list(map(int, input().split()))\nteam1_player2 = list(map(int, input().split()))\nteam2_player1 = list(map(int, input().split()))\nteam2_player2 = list(map(int, input().split()))\n\n# Determine the optimal arrangement for each team\nteam1_defense = max(team1_player1[0], team1_player2[0])\nteam1_attack = max(team1_player1[1], team1_player2[1])\nteam2_defense = max(team2_player1[0], team2_player2[0])\nteam2_attack = max(team2_player1[1], team2_player2[1])\n\n# Check if either team can win\nif team1_defense > team2_attack and team1_attack > team2_defense:\n    print(\"Team 1\")\nelif team2_defense > team1_attack and team2_attack > team1_defense:\n    print(\"Team 2\")\nelse:\n    print(\"Draw\")"}
{"solution": "import math\nfrom itertools import combinations\n\ndef calculate_distance(x1, y1, x2, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef find_min_time(N, K, meat_data):\n    min_time = float('inf')\n    for combo in combinations(meat_data, K):\n        x_coords = [x for x, _, _ in combo]\n        y_coords = [y for _, y, _ in combo]\n        c_values = [c for _, _, c in combo]\n\n        x_min, x_max = min(x_coords), max(x_coords)\n        y_min, y_max = min(y_coords), max(y_coords)\n\n        for x in range(x_min, x_max + 1):\n            for y in range(y_min, y_max + 1):\n                max_time = max(c_values[i] * calculate_distance(x, y, x_coords[i], y_coords[i]) for i in range(K))\n                min_time = min(min_time, max_time)\n\n    return min_time\n\nN, K = map(int, input().split())\nmeat_data = [list(map(int, input().split())) for _ in range(N)]\n\nprint(find_min_time(N, K, meat_data))"}
{"solution": "n = int(input())\nticket = input()\n\n# Split the ticket into two halves\nfirst_half = ticket[:n//2]\nsecond_half = ticket[n//2:]\n\n# Count the number of '?' in each half\nfirst_half_unknowns = first_half.count('?')\nsecond_half_unknowns = second_half.count('?')\n\n# Calculate the sum of known digits in each half\nfirst_half_sum = sum(int(digit) for digit in first_half if digit != '?')\nsecond_half_sum = sum(int(digit) for digit in second_half if digit != '?')\n\n# If the number of '?' is equal in both halves, the winner is Bicarp\nif first_half_unknowns == second_half_unknowns:\n    # If the sum of known digits is already equal, Bicarp wins\n    if first_half_sum == second_half_sum:\n        print('Bicarp')\n    else:\n        # If the sum of known digits is not equal, Monocarp can make it equal\n        print('Monocarp')\nelse:\n    # If the number of '?' is not equal in both halves, Bicarp can always win\n    print('Bicarp')"}
{"solution": "def find_bus_route(n, t, bus_routes):\n    earliest_time = float('inf')\n    chosen_route = -1\n\n    for i in range(n):\n        s_i, d_i = bus_routes[i]\n\n        if s_i >= t:\n            next_bus_time = s_i\n        else:\n            # Calculate the next bus time after t\n            if (t - s_i) % d_i == 0:\n                next_bus_time = t\n            else:\n                next_bus_time = s_i + ((t - s_i) // d_i + 1) * d_i\n\n        if next_bus_time < earliest_time:\n            earliest_time = next_bus_time\n            chosen_route = i + 1\n\n    return chosen_route\n\n# Read input\nn, t = map(int, input().split())\nbus_routes = [list(map(int, input().split())) for _ in range(n)]\n\n# Print output\nprint(find_bus_route(n, t, bus_routes))"}
{"solution": "def count_numbers_with_k_ones(n, k):\n    count = 0\n    for i in range(n + 1, 2 * n + 1):\n        if bin(i).count('1') == k:\n            count += 1\n    return count\n\ndef find_n(m, k):\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if count_numbers_with_k_ones(mid, k) < m:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\nm, k = map(int, input().split())\nprint(find_n(m, k))"}
{"solution": "# Read the input\nn = int(input())\nlevel = input()\n\n# Find all platform positions\nplatforms = [i for i in range(n) if level[i] == '*']\n\n# Check for a sequence of four jumps of the same length\nfor i in range(len(platforms) - 4):\n    if platforms[i+1] - platforms[i] == platforms[i+2] - platforms[i+1] == platforms[i+3] - platforms[i+2] == platforms[i+4] - platforms[i+3]:\n        print('yes')\n        break\nelse:\n    print('no')"}
{"solution": "def find_missing_number(grid):\n    n = len(grid)\n    total_sum = sum(grid[0])\n    missing_row = missing_col = missing_value = None\n\n    # Find the missing number and its position\n    for i in range(n):\n        if sum(grid[i]) != total_sum:\n            missing_row = i\n            missing_col = grid[i].index(0)\n            break\n\n    # Calculate the sum of the first row\n    row_sum = sum(grid[0])\n\n    # Check rows\n    for i in range(1, n):\n        if sum(grid[i]) != row_sum:\n            return -1\n\n    # Check columns\n    for j in range(n):\n        col_sum = sum(grid[i][j] for i in range(n))\n        if col_sum != row_sum:\n            return -1\n\n    # Check diagonals\n    diag_sum = sum(grid[i][i] for i in range(n))\n    if diag_sum != row_sum:\n        return -1\n\n    diag_sum = sum(grid[i][n - i - 1] for i in range(n))\n    if diag_sum != row_sum:\n        return -1\n\n    # Calculate the missing value\n    missing_value = total_sum - sum(grid[missing_row])\n    if missing_value <= 0 or missing_value > 10**9:\n        return -1\n\n    return missing_value\n\n# Read input\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\n# Find the missing number\nresult = find_missing_number(grid)\n\n# Print the result\nprint(result)"}
{"solution": "# Get the number of benches\nn = int(input())\n\n# Get the number of additional people\nm = int(input())\n\n# Get the initial number of people on each bench\na = [int(input()) for _ in range(n)]\n\n# Calculate the maximum possible k\nmax_k = max(a) + m\n\n# Calculate the total number of people after adding m\ntotal_people = sum(a) + m\n\n# Calculate the minimum possible k\nmin_k = (total_people + n - 1) // n\n\n# Print the minimum and maximum possible k\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef power(base, exponent):\n    result = 1\n    base %= MOD\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef factorial(n):\n    fact = [1]\n    for i in range(1, n + 1):\n        fact.append((fact[-1] * i) % MOD)\n    return fact\n\ndef assign_tickets(n, m):\n    fact = factorial(n + m - 1)\n    inv_fact = [inverse(f) for f in fact]\n\n    ways = 0\n    for i in range(m, n + 1):\n        ways = (ways + (fact[n - 1] * inv_fact[i - 1] * inv_fact[n - i] * fact[i - 1] * fact[m - 1] * inv_fact[i - m]) % MOD)\n    return ways % MOD\n\nn, m = map(int, input().split())\nresult = assign_tickets(n, m)\nprint(result)"}
{"solution": "from itertools import combinations\n\ndef main():\n    n, m = map(int, input().split())\n    friends = [set(map(int, input().split()[1:])) for _ in range(n)]\n    pizzas = [(set(map(int, input().split()[2:])), int(input().split()[0])) for _ in range(m)]\n\n    max_pleased = 0\n    min_price = float('inf')\n    result = (-1, -1)\n\n    for p1, p2 in combinations(pizzas, 2):\n        pleased = sum(len(f & p1[0] | f & p2[0]) == len(f) for f in friends)\n        price = p1[1] + p2[1]\n\n        if pleased > max_pleased or (pleased == max_pleased and price < min_price):\n            max_pleased = pleased\n            min_price = price\n            result = (pizzas.index(p1) + 1, pizzas.index(p2) + 1)\n\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_numbers(m, s):\n    if s == 0 and m == 1:\n        return '0 0'\n    if s == 0 or s > m * 9:\n        return '-1 -1'\n\n    min_num = [0] * m\n    max_num = [0] * m\n\n    # Find the largest number\n    for i in range(m - 1, -1, -1):\n        if s >= 9:\n            max_num[i] = 9\n            s -= 9\n        else:\n            max_num[i] = s\n            s = 0\n\n    # Find the smallest number\n    s = s\n    for i in range(m - 1, -1, -1):\n        if s >= 9:\n            min_num[i] = 9\n            s -= 9\n        else:\n            min_num[i] = s\n            s = 0\n\n    # Remove leading zeros from the smallest number\n    while min_num[0] == 0 and len(min_num) > 1:\n        min_num = min_num[1:]\n\n    return ''.join(map(str, min_num)) + ' ' + ''.join(map(str, max_num))\n\nm, s = map(int, input().split())\nprint(find_numbers(m, s))"}
{"solution": "def count_numbers(n, k):\n    dp = [[0] * (1 << 10) for _ in range(20)]\n    dp[0] = [1] * (1 << 10)\n\n    for i in range(1, 20):\n        for mask in range(1 << 10):\n            for digit in range(10):\n                if (mask >> digit) & 1:\n                    dp[i][mask] += dp[i - 1][mask ^ (1 << digit)]\n\n    res = 0\n    for i in range(1, 20):\n        for mask in range(1 << 10):\n            if bin(mask).count('1') <= k:\n                res += dp[i][mask] * i * (10 ** (i - 1))\n\n    num = n\n    mask = 0\n    for i in range(19, -1, -1):\n        for digit in range(10 if i else 1, num // (10 ** i) - 1, -1):\n            if (mask >> digit) & 1:\n                res += dp[i][mask] * digit * (10 ** i)\n        if (num // (10 ** i)) == 0:\n            break\n        mask |= 1 << (num // (10 ** i))\n        num %= 10 ** i\n\n    return (res + n) % 998244353 if bin(mask).count('1') <= k else res % 998244353\n\nl, r, k = map(int, input().split())\nprint((count_numbers(r, k) - count_numbers(l - 1, k)) % 998244353)"}
{"solution": "def can_distribute_pencils(n, k, d, pencils):\n    pencils.sort()\n    i = 0\n    while i < n:\n        count = 0\n        prev = pencils[i]\n        while i < n and pencils[i] - prev <= d:\n            i += 1\n            count += 1\n            if count == k:\n                break\n        if count < k:\n            return False\n    return True\n\nn, k, d = map(int, input().split())\npencils = list(map(int, input().split()))\n\nif can_distribute_pencils(n, k, d, pencils):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_dead_bulbs(garland):\n    # Initialize the count of dead bulbs for each color\n    dead_bulbs = {'R': 0, 'B': 0, 'Y': 0, 'G': 0}\n\n    # Iterate over the garland\n    for i in range(len(garland)):\n        # If the current bulb is dead\n        if garland[i] == '!':\n            # Determine the possible colors of the bulb based on the previous and next bulbs\n            possible_colors = set('RBYG')\n            if i > 0:\n                possible_colors.discard(garland[i - 1])\n            if i < len(garland) - 1:\n                possible_colors.discard(garland[i + 1])\n            # Increment the count of dead bulbs for each possible color\n            for color in possible_colors:\n                dead_bulbs[color] += 1\n\n    # Return the count of dead bulbs for each color\n    return dead_bulbs['R'], dead_bulbs['B'], dead_bulbs['Y'], dead_bulbs['G']\n\n# Get the garland as input\ngarland = input()\n\n# Print the count of dead bulbs for each color\nprint(*count_dead_bulbs(garland))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    return sys.stdin.readline\n\ndef calculate_expected_passages():\n    n, m = map(int, read_input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        s, t = map(int, read_input().split())\n        graph[s].append(t)\n\n    dp = [0] * (n + 1)\n    dp[n] = 0\n    for i in range(n - 1, 0, -1):\n        total_passages = 0\n        for neighbor in graph[i]:\n            total_passages += dp[neighbor]\n        dp[i] = 1 + total_passages / len(graph[i])\n\n    min_expected_passages = dp[1]\n    for neighbor in graph[1]:\n        if neighbor == n:\n            continue\n        new_expected_passages = 1 + (total_passages - dp[neighbor]) / (len(graph[1]) - 1)\n        min_expected_passages = min(min_expected_passages, new_expected_passages)\n\n    return min_expected_passages\n\nprint(calculate_expected_passages())"}
{"solution": "# Get the input number\nn = int(input())\n\n# Check if the number already ends in 0\nif n % 10 == 0:\n    print(n)\nelse:\n    # Calculate the nearest lower multiple of 10\n    lower_multiple = n - n % 10\n\n    # Calculate the nearest higher multiple of 10\n    higher_multiple = lower_multiple + 10\n\n    # Determine the closest multiple\n    if n - lower_multiple < higher_multiple - n:\n        print(lower_multiple)\n    else:\n        print(higher_multiple)"}
{"solution": "def find_swaps(s, t):\n    if len(s) != len(t):\n        return -1\n\n    mismatches = {}\n\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if s[i] in mismatches and mismatches[s[i]] != t[i]:\n                return -1\n            if t[i] in mismatches and mismatches[t[i]] != s[i]:\n                return -1\n            mismatches[s[i]] = t[i]\n            mismatches[t[i]] = s[i]\n\n    visited = set()\n    swaps = []\n\n    for key in mismatches:\n        if key not in visited:\n            cycle = []\n            current = key\n            while current not in visited:\n                visited.add(current)\n                cycle.append(current)\n                current = mismatches[current]\n            if len(cycle) != 2:\n                return -1\n            swaps.append((cycle[0], cycle[1]))\n\n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0], swap[1])\n\n# Example usage:\ns = \"helloworld\"\nt = \"ehoolwlroz\"\nfind_swaps(s, t)"}
{"solution": "def earliest_login(first_name, last_name):\n    # Identify Prefixes\n    first_prefixes = [first_name[:i] for i in range(1, len(first_name) + 1)]\n    last_prefixes = [last_name[:i] for i in range(1, len(last_name) + 1)]\n\n    # Generate Combinations\n    combinations = [f + l for f in first_prefixes for l in last_prefixes]\n\n    # Compare Alphabetically and Select the Earliest\n    return min(combinations)\n\n# Get Input\nfirst_name, last_name = input().split()\n\n# Print Output\nprint(earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(sequence):\n    n = len(sequence)\n    height = n // 2\n    width = 2 * height - 1\n    grid = [[' '] * width for _ in range(height)]\n\n    def draw(start, end, row):\n        if start >= end:\n            return\n        grid[row][start] = '+'\n        grid[row][end] = '+'\n        for i in range(start + 1, end):\n            grid[row][i] = '-'\n        mid = (start + end) // 2\n        for i in range(row + 1, height):\n            grid[i][mid] = '|'\n        draw(start + 1, mid - 1, row + 1)\n        draw(mid + 1, end - 1, row + 1)\n\n    draw(0, width, 0)\n    return [''.join(row) for row in grid]\n\nn = int(input())\nsequence = input()\nprint('\\n'.join(draw_brackets(sequence)))"}
{"solution": "def normalize_golden_number(golden_number):\n    golden_number = list(map(int, golden_number))\n    n = len(golden_number)\n\n    for i in range(n - 1, 0, -1):\n        if golden_number[i] > 1:\n            golden_number[i] -= 2\n            golden_number[i - 1] += 1\n            if i - 2 >= 0:\n                golden_number[i - 2] += 1\n\n    while len(golden_number) > 1 and golden_number[0] == 0:\n        golden_number.pop(0)\n\n    return golden_number\n\ndef compare_golden_numbers(num1, num2):\n    norm_num1 = normalize_golden_number(num1)\n    norm_num2 = normalize_golden_number(num2)\n\n    if len(norm_num1) > len(norm_num2):\n        return \">\"\n    elif len(norm_num1) < len(norm_num2):\n        return \"<\"\n\n    for digit1, digit2 in zip(norm_num1, norm_num2):\n        if digit1 > digit2:\n            return \">\"\n        elif digit1 < digit2:\n            return \"<\"\n\n    return \"=\"\n\nnum1 = input().strip()\nnum2 = input().strip()\n\nresult = compare_golden_numbers(num1, num2)\nprint(result)"}
{"solution": "# Define the dictionary of Infinity Gems\ninfinity_gems = {\n    'purple': 'Power',\n    'green': 'Time',\n    'blue': 'Space',\n    'orange': 'Soul',\n    'red': 'Reality',\n    'yellow': 'Mind'\n}\n\n# Get the number of Gems in Infinity Gauntlet\nn = int(input())\n\n# Get the colors of Gems seen\nseen_gems = [input() for _ in range(n)]\n\n# Determine the absent Gems\nabsent_gems = [name for color, name in infinity_gems.items() if color not in seen_gems]\n\n# Print the number of absent Gems\nprint(len(absent_gems))\n\n# Print the names of absent Gems\nfor gem in absent_gems:\n    print(gem)"}
{"solution": "def find_round(n, a, b):\n    round = 1\n    while n > 1:\n        if a % 2 == 1 and a + 1 == b:\n            return round\n        if b % 2 == 1 and b + 1 == a:\n            return round\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n //= 2\n        round += 1\n    return \"Final!\"\n\nn, a, b = map(int, input().split())\nprint(find_round(n, a, b))"}
{"solution": "def min_changes(n, p, b):\n    # Create a list to store the visited positions for each skewer\n    visited = [set() for _ in range(n)]\n\n    # Simulate the movement of each skewer\n    for i in range(n):\n        pos = i\n        for _ in range(2 * n):\n            visited[i].add(pos)\n            pos = p[pos] - 1\n            if b[pos] == 1:\n                pos = n - 1 - pos\n\n    # Count the minimum number of changes required\n    changes = 0\n    for i in range(n):\n        if len(visited[i]) < 2 * n:\n            changes += 1\n\n    return changes\n\n# Read the input\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculate the minimum number of changes required\nresult = min_changes(n, p, b)\n\n# Print the result\nprint(result)"}
{"solution": "def max_path_length(v1, v2, t, d):\n    # Initialize the maximum possible length of the path section\n    max_length = 0\n\n    # Initialize the current speed\n    current_speed = v1\n\n    # Iterate through each second of the time\n    for _ in range(t):\n        # Add the current speed to the maximum possible length\n        max_length += current_speed\n\n        # Calculate the difference in speed between the current speed and the end speed\n        diff = v2 - current_speed\n\n        # If the difference is greater than the maximum speed change, increase the current speed by the maximum speed change\n        if diff > d:\n            current_speed += d\n        # If the difference is less than the negative of the maximum speed change, decrease the current speed by the maximum speed change\n        elif diff < -d:\n            current_speed -= d\n        # Otherwise, set the current speed to the end speed\n        else:\n            current_speed = v2\n\n    # Return the maximum possible length of the path section\n    return max_length\n\n# Get the input values\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Print the maximum possible length of the path section\nprint(max_path_length(v1, v2, t, d))"}
{"solution": "import sys\nfrom itertools import permutations\n\ndef can_cross_bridge(weights, lengths, capacities, order, distances):\n    camel_positions = [0] * len(weights)\n    for i in range(len(weights)):\n        if i > 0:\n            camel_positions[order[i]] = camel_positions[order[i - 1]] + distances[i - 1]\n        if weights[order[i]] > capacities[0]:\n            return False\n        current_weight = weights[order[i]]\n        j = 0\n        while j < len(lengths) and camel_positions[order[i]] >= lengths[j]:\n            if current_weight > capacities[j]:\n                return False\n            j += 1\n    return True\n\ndef find_min_distance(weights, lengths, capacities):\n    min_distance = float('inf')\n    for order in permutations(range(len(weights))):\n        left = 0\n        right = sum(lengths)\n        while left <= right:\n            mid = (left + right) // 2\n            distances = [mid] * (len(weights) - 1)\n            if can_cross_bridge(weights, lengths, capacities, order, distances):\n                min_distance = min(min_distance, mid)\n                right = mid - 1\n            else:\n                left = mid + 1\n    return min_distance if min_distance != float('inf') else -1\n\ndef main():\n    N, M = map(int, sys.stdin.readline().split())\n    weights = list(map(int, sys.stdin.readline().split()))\n    lengths = []\n    capacities = []\n    for _ in range(M):\n        l, v = map(int, sys.stdin.readline().split())\n        lengths.append(l)\n        capacities.append(v)\n    print(find_min_distance(weights, lengths, capacities))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def last_digit_factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    elif n == 2 or n == 3:\n        return n\n    elif n == 4:\n        return 6\n    else:\n        return 0\n\ndef last_digit_division(a, b):\n    if a == b:\n        return 1\n    elif a > b:\n        return 0\n    else:\n        return (last_digit_factorial(b) * pow(last_digit_factorial(a), -1, 10)) % 10\n\na, b = map(int, input().split())\nprint(last_digit_division(a, b))"}
{"solution": "from collections import deque\n\ndef min_jumps(n, d, lilies):\n    visited = [False] * n\n    queue = deque([(0, 0)])  # position, jumps\n    visited[0] = True\n\n    while queue:\n        pos, jumps = queue.popleft()\n\n        for i in range(1, d + 1):\n            next_pos = pos + i\n\n            if next_pos < n and lilies[next_pos] == '1' and not visited[next_pos]:\n                if next_pos == n - 1:\n                    return jumps + 1\n\n                visited[next_pos] = True\n                queue.append((next_pos, jumps + 1))\n\n    return -1\n\nn, d = map(int, input().split())\nlilies = input()\n\nprint(min_jumps(n, d, lilies))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_counterexample(n):\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\n# Read input\nn = int(input().strip())\n\n# Find and print the counterexample\nprint(find_counterexample(n))"}
{"solution": "def can_buy_items(n):\n    for a in range(n // 1234567 + 1):\n        for b in range((n - a * 1234567) // 123456 + 1):\n            c = (n - a * 1234567 - b * 123456) // 1234\n            if a * 1234567 + b * 123456 + c * 1234 == n:\n                return True\n    return False\n\nn = int(input())\nif can_buy_items(n):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def check_intersection(lines, x1, x2):\n    min_y = float('inf')\n    max_y = float('-inf')\n\n    for k, b in lines:\n        y1 = k * x1 + b\n        y2 = k * x2 + b\n\n        if y1 < y2:\n            min_y = min(min_y, y1)\n            max_y = max(max_y, y2)\n        else:\n            min_y = min(min_y, y2)\n            max_y = max(max_y, y1)\n\n    return min_y < max_y\n\nn = int(input())\nx1, x2 = map(int, input().split())\nlines = [list(map(int, input().split())) for _ in range(n)]\n\nif check_intersection(lines, x1, x2):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_weights(n):\n    # Initialize the partition function array\n    p = [0] * (n + 1)\n    p[0] = 1\n\n    # Calculate the partition function\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            p[j] += p[j - i]\n\n    # Initialize the count of weights\n    count = 0\n\n    # Iterate through all possible first parts\n    for i in range(1, n + 1):\n        # Count the number of partitions with length >= i\n        if p[n - i] >= i:\n            count += 1\n\n    return count\n\n# Read the input\nn = int(input())\n\n# Calculate and print the result\nresult = count_weights(n)\nprint(result)"}
{"solution": "def find_good_apartments(n, k):\n    if k == 0:\n        min_good = 0\n        max_good = 0\n    else:\n        min_good = 1\n        max_good = min(n - k, 2 * k)\n\n    return min_good, max_good\n\n# Get input\nn, k = map(int, input().split())\n\n# Find minimum and maximum good apartments\nmin_good, max_good = find_good_apartments(n, k)\n\n# Print output\nprint(min_good, max_good)"}
{"solution": "import math\n\n# Get the input\nn = int(input())\n\n# Calculate the maximum number of games the winner can play\nmax_games = math.floor(math.log2(n))\n\n# Print the result\nprint(max_games)"}
{"solution": "def max_vk_occurrences(s):\n    count = 0\n    i = 0\n    while i < len(s) - 1:\n        if s[i] == 'V' and s[i + 1] == 'K':\n            count += 1\n            i += 2\n        else:\n            i += 1\n    if count < len(s) - 1 and s.count('V') > 0 and s.count('K') > 0:\n        count += 1\n    return count\n\ns = input()\nprint(max_vk_occurrences(s))"}
{"solution": "import math\n\ndef min_segments(n):\n    a = int(math.sqrt(n))\n    b = (n + a - 1) // a\n    return a + b + 2\n\nn = int(input().strip())\nprint(min_segments(n))"}
{"solution": "# Get the input weights of Limak and Bob\na, b = map(int, input().split())\n\n# Initialize the number of years\nyears = 0\n\n# While Limak's weight is less than or equal to Bob's weight\nwhile a <= b:\n    # Triple Limak's weight and double Bob's weight\n    a *= 3\n    b *= 2\n    # Increment the number of years\n    years += 1\n\n# Print the number of years after which Limak becomes strictly larger than Bob\nprint(years)"}
{"solution": "def count_visited_nodes(h, n):\n    # Initialize variables\n    current_node = 1\n    visited_nodes = set()\n    skipped_commands = 0\n    command_index = 0\n    commands = \"LR\"\n\n    # Traverse the binary tree\n    while current_node != n:\n        # Get the next command\n        command = commands[command_index]\n\n        # Calculate the destination node\n        if command == \"L\":\n            destination_node = current_node * 2\n        else:\n            destination_node = current_node * 2 + 1\n\n        # Check if the destination node is valid and not visited\n        if destination_node <= 2 ** h and destination_node not in visited_nodes:\n            # Move to the destination node\n            visited_nodes.add(current_node)\n            current_node = destination_node\n            skipped_commands = 0\n        else:\n            # Skip the current command\n            skipped_commands += 1\n\n            # If two consecutive commands are skipped, go back to the parent node\n            if skipped_commands == 2:\n                current_node = current_node // 2\n                skipped_commands = 0\n\n        # Move to the next command\n        command_index = (command_index + 1) % 2\n\n    # Return the number of visited nodes (excluding the exit node)\n    return len(visited_nodes) - 1\n\n# Get the input\nh, n = map(int, input().split())\n\n# Print the output\nprint(count_visited_nodes(h, n))"}
{"solution": "def count_tables(x):\n    tables = []\n    for n in range(1, int(x**0.5) + 1):\n        if x % n == 0:\n            m = x // n\n            if n <= m:\n                tables.append((n, m))\n    return tables\n\ndef main():\n    x = int(input())\n    tables = count_tables(x)\n    print(len(tables))\n    for table in tables:\n        print(*table)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Read the number of integers in the sequence\nn = int(input())\n\n# Read the sequence of integers\nsequence = list(map(int, input().split()))\n\n# Define the valid month durations\nmonth_durations = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n# Initialize a variable to keep track of the current month index\ncurrent_month = 0\n\n# Iterate through the sequence of integers\nfor i in range(n):\n    # Check if the current integer matches the duration of the current month\n    if sequence[i] == month_durations[current_month]:\n        # Move to the next month\n        current_month = (current_month + 1) % 12\n    # Check if the current integer is 29 and the current month is February\n    elif sequence[i] == 29 and month_durations[current_month] == 28:\n        # Move to the next month\n        current_month = (current_month + 1) % 12\n    # If neither condition is met, the sequence is invalid\n    else:\n        print(\"NO\")\n        break\n# If all integers in the sequence are valid, output \"YES\"\nelse:\n    print(\"YES\")"}
{"solution": "def find_fractions(n):\n    # Find all divisors of n\n    divisors = [i for i in range(2, n) if n % i == 0]\n\n    # Initialize the sequence\n    sequence = []\n\n    # Iterate over divisors\n    for b in divisors:\n        # Find a such that 1 <= a < b and a/b + 1/n is an integer\n        a = int((1 - 1/n) * b)\n        if a > 0 and a < b:\n            sequence.append((a, b))\n            n -= b\n\n    # Check if the sequence sums to 1 - 1/n\n    if sum(a/b for a, b in sequence) == 1 - 1/n:\n        return \"YES\", sequence\n    else:\n        return \"NO\", []\n\n# Read input\nn = int(input())\n\n# Find the sequence\nresult, sequence = find_fractions(n)\n\n# Print the result\nprint(result)\nif result == \"YES\":\n    print(len(sequence))\n    for a, b in sequence:\n        print(a, b)"}
{"solution": "def min_unattractiveness(n, a, b, h):\n    # Initialize a 2D DP table where dp[i][j] represents the minimum unattractiveness\n    # value when the first i boards are painted and the last board is painted with color j\n    dp = [[float('inf')] * 2 for _ in range(n)]\n\n    # Base case: when there is only one board, the unattractiveness value is 0\n    dp[0][0] = dp[0][1] = 0\n\n    # Iterate through the boards\n    for i in range(1, n):\n        # If the current board is painted red\n        if h[i] <= a:\n            dp[i][0] = min(dp[i-1][0], dp[i-1][1] + h[i-1] if h[i-1] <= b else float('inf'))\n            a -= h[i]\n        # If the current board is painted green\n        if h[i] <= b:\n            dp[i][1] = min(dp[i-1][1], dp[i-1][0] + h[i-1] if h[i-1] <= a else float('inf'))\n            b -= h[i]\n\n    # Return the minimum unattractiveness value when all boards are painted\n    return min(dp[n-1]) if min(dp[n-1]) != float('inf') else -1\n\n# Read input\nn = int(input())\na, b = map(int, input().split())\nh = list(map(int, input().split()))\n\n# Print output\nprint(min_unattractiveness(n, a, b, h))"}
{"solution": "def find_triangle_points(n, m, k):\n    target_area = n * m / k\n\n    # Check if it's possible to form a triangle with the given area\n    if target_area > n * m / 2 or target_area < 0.5:\n        return \"NO\"\n\n    # Search for the points\n    for x1 in range(n + 1):\n        for y1 in range(m + 1):\n            for x2 in range(x1, n + 1):\n                for y2 in range(m + 1):\n                    # Calculate the area of the triangle formed by (x1, y1), (x2, y2), and (0, 0)\n                    triangle_area = abs(x1 * y2 - x2 * y1) / 2\n\n                    # If the area matches the target, calculate the third point\n                    if triangle_area == target_area:\n                        x3 = x2\n                        y3 = y1 + (n * m / k) / (x2 - x1)\n\n                        # Check if the third point is valid\n                        if 0 <= y3 <= m:\n                            return \"YES\\n{0} {1}\\n{2} {3}\\n{4} {5}\".format(x1, y1, x2, y2, x3, int(y3))\n\n    return \"NO\"\n\n# Read the input\nn, m, k = map(int, input().split())\n\n# Find the points and print the result\nprint(find_triangle_points(n, m, k))"}
{"solution": "# Get the input values\nn, k = map(int, input().split())\n\n# Calculate the number of moves Sasha can make\nsasha_moves = n // k\n\n# Calculate the number of moves Lena can make\nlena_moves = sasha_moves - 1\n\n# Check if Sasha wins\nif sasha_moves > lena_moves:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Read and parse input\nn = int(input())\nrepetitions = list(map(int, input().split()))\n\n# Initialize muscle groups\nchest = 0\nbiceps = 0\nback = 0\n\n# Identify the cyclic pattern and sum repetitions\nfor i in range(n):\n    if i % 3 == 0:\n        chest += repetitions[i]\n    elif i % 3 == 1:\n        biceps += repetitions[i]\n    else:\n        back += repetitions[i]\n\n# Compare totals and output the result\nif chest > biceps and chest > back:\n    print(\"chest\")\nelif biceps > chest and biceps > back:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "def min_redos_to_get_five(n, grades):\n    current_sum = sum(grades)\n    target_sum = n * 4.5\n\n    if current_sum >= target_sum:\n        return 0\n\n    grades.sort()\n    redos = 0\n\n    for grade in grades:\n        if current_sum >= target_sum:\n            break\n        current_sum += (5 - grade)\n        redos += 1\n\n    return redos\n\nn = int(input())\ngrades = list(map(int, input().split()))\nprint(min_redos_to_get_five(n, grades))"}
{"solution": "def find_array(u, v):\n    # If u and v are equal, the array is empty\n    if u == v:\n        return 0, []\n\n    # If u is greater than v, no solution exists\n    if u > v:\n        return -1, []\n\n    # Calculate the difference between u and v\n    diff = v - u\n\n    # If the difference is odd, no solution exists\n    if diff % 2 != 0:\n        return -1, []\n\n    # Calculate half of the difference\n    half_diff = diff // 2\n\n    # If u is less than half of the difference, no solution exists\n    if u < half_diff:\n        return -1, []\n\n    # Calculate the first element of the array\n    first_element = half_diff\n\n    # Calculate the second element of the array\n    second_element = u - half_diff\n\n    # Return the length of the array and the array itself\n    return 2, [first_element, second_element]\n\n# Read the input\nu, v = map(int, input().split())\n\n# Find the array\nn, array = find_array(u, v)\n\n# Print the output\nif n == -1:\n    print(-1)\nelse:\n    print(n)\n    print(*array)"}
{"solution": "def min_digits_sum(n):\n    # Initialize the count of digits '1'\n    count = 0\n\n    # While n is greater than 0\n    while n > 0:\n        # If n is odd, subtract the largest possible power of 10 that is less than or equal to n\n        if n % 2 != 0:\n            power = 1\n            while power * 10 <= n:\n                power *= 10\n            n -= power\n            count += power\n        # If n is even, divide it by 2\n        else:\n            n //= 2\n\n    # Return the count of digits '1'\n    return count\n\n# Read the input\nn = int(input())\n\n# Print the expected minimal number of digits '1'\nprint(min_digits_sum(n))"}
{"solution": "def can_reach_treasure(x1, y1, x2, y2, x, y):\n    # Check if the difference between the starting and ending coordinates can be expressed as a combination of the given moves\n    if (x2 - x1) % x == 0 and (y2 - y1) % y == 0:\n        return True\n    else:\n        return False\n\n# Get the input\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\n# Check if the treasure can be reached\nif can_reach_treasure(x1, y1, x2, y2, x, y):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "from itertools import permutations\n\ndef count_valid_bus_numbers(n):\n    # Convert the number to a string to extract digits\n    digits = list(str(n))\n\n    # Generate all unique permutations of the digits\n    all_permutations = set(permutations(digits))\n\n    # Filter out permutations that start with '0'\n    valid_permutations = set()\n    for perm in all_permutations:\n        if perm[0] != '0':\n            valid_permutations.add(perm)\n\n    # Return the count of valid permutations\n    return len(valid_permutations)\n\n# Read input\nn = int(input().strip())\n\n# Get the count of valid bus numbers\nresult = count_valid_bus_numbers(n)\n\n# Print the result\nprint(result)"}
{"solution": "# Read input\na = int(input())  # number of ties\nb = int(input())  # number of scarves\nc = int(input())  # number of vests\nd = int(input())  # number of jackets\ne = int(input())  # cost of one suit of the first type\nf = int(input())  # cost of one suit of the second type\n\n# Calculate the maximum number of suits of each type that can be made\nmax_suits_first_type = min(a, d)\nmax_suits_second_type = min(b, c, d)\n\n# Calculate the maximum total cost of suits\nmax_cost = max_suits_first_type * e + max_suits_second_type * f\n\n# Print the result\nprint(max_cost)"}
{"solution": "def solve(a, b, p, x):\n    count = 0\n    for n in range(1, x + 1):\n        if (n * pow(a, n, p)) % p == b:\n            count += 1\n    return count\n\na, b, p, x = map(int, input().split())\nresult = solve(a, b, p, x)\nprint(result)"}
{"solution": "def max_sum(k2, k3, k5, k6):\n    # Calculate the maximum number of 256 that can be formed\n    max_256 = min(k2, k5, k6)\n\n    # Calculate the remaining digits after forming 256\n    k2 -= max_256\n    k5 -= max_256\n    k6 -= max_256\n\n    # Calculate the maximum number of 32 that can be formed\n    max_32 = min(k2, k3)\n\n    # Calculate the maximum possible sum\n    max_sum = max_256 * 256 + max_32 * 32\n\n    return max_sum\n\n# Read the input\nk2, k3, k5, k6 = map(int, input().split())\n\n# Print the maximum possible sum\nprint(max_sum(k2, k3, k5, k6))"}
{"solution": "def calculate_cells(size, x, y, seconds):\n    if seconds == 0:\n        return 1\n    cells = 0\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nx, ny = x + dx * seconds, y + dy * seconds\n        if 1 <= nx <= size and 1 <= ny <= size:\n            cells += min(seconds, max(size - nx, size - ny, nx - 1, ny - 1))\n    return cells + 1\n\ndef find_seconds(size, x, y, target):\n    left, right = 0, size * 2\n    while left < right:\n        mid = (left + right) // 2\n        if calculate_cells(size, x, y, mid) >= target:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\nn, x, y, c = map(int, input().split())\nprint(find_seconds(n, x, y, c))"}
{"solution": "def max_xor(l, r):\n    # The maximum XOR value is achieved when both numbers are as close to the right boundary as possible\n    # and have different bits set at the most significant positions.\n    # To find this, we calculate the number of bits in the right boundary and shift 1 to the left by that amount minus 1.\n    # Then, we subtract the left boundary from this value to account for the range.\n    # Finally, we take the maximum of this value and 0, as the XOR of two equal numbers is 0.\n    return max(0, (1 << (len(bin(r)) - 2)) - l)\n\n# Read the input\nl, r = map(int, input().split())\n\n# Print the result\nprint(max_xor(l, r))"}
{"solution": "def minimum_height(n, k):\n    left, right = 1, k\n\n    while left < right:\n        mid = (left + right) // 2\n        if n * mid >= k:\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\nn, k = map(int, input().split())\nprint(minimum_height(n, k))"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    stairs_time = abs(x - y) * t1\n    elevator_to_masha_time = abs(z - x) * t2 + t3\n    elevator_to_egor_time = abs(x - y) * t2 + 2 * t3\n    elevator_time = elevator_to_masha_time + elevator_to_egor_time\n    if stairs_time < elevator_time:\n        return \"NO\"\n    else:\n        return \"YES\"\n\n# Get input from user\nx, y, z, t1, t2, t3 = map(int, input().split())\n\n# Print the result\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "# Read the input\nn, m = map(int, input().split())\n\n# Calculate the optimal value of a\nif m <= n // 2:\n    a = n\nelse:\n    a = 1\n\n# Print the output\nprint(a)"}
{"solution": "# Read the number of lessons\nn = int(input())\n\n# Read the schedule\nschedule = list(map(int, input().split()))\n\n# Initialize the count of pairs Alena stays at the university\ncount = 0\n\n# Initialize the flag to check if Alena is at the university\nat_university = False\n\n# Iterate over the schedule\nfor i in range(n):\n    # If Alena has a pair\n    if schedule[i] == 1:\n        # Increment the count\n        count += 1\n        # Set the flag to True\n        at_university = True\n    # If Alena doesn't have a pair\n    else:\n        # If Alena is at the university\n        if at_university:\n            # Increment the count\n            count += 1\n        # If Alena is not at the university\n        else:\n            # Check if the next pair is also a break\n            if i < n - 1 and schedule[i + 1] == 0:\n                # Continue to the next pair\n                continue\n            # If the next pair is not a break\n            else:\n                # Set the flag to True\n                at_university = True\n\n# Print the count\nprint(count)"}
{"solution": "# Read input\nn, k = map(int, input().split())\ncandies = list(map(int, input().split()))\n\n# Initialize variables\ndays = 0\ntotal_candies = 0\n\n# Iterate through the days\nfor i in range(n):\n    # Add the candies found on the current day\n    total_candies += candies[i]\n\n    # Give Bran at most 8 candies per day\n    if total_candies >= 8:\n        total_candies -= 8\n    else:\n        # If Arya doesn't have enough candies to give Bran 8, give her all she has\n        total_candies = 0\n\n    # Check if Bran has received enough candies\n    k -= min(8, total_candies)\n    if k <= 0:\n        days = i + 1\n        break\n\n# Print the result\nif days == 0:\n    print(-1)\nelse:\n    print(days)"}
{"solution": "def minimum_additional_walks(n, k, a):\n    b = a[:]\n    additional_walks = 0\n\n    for i in range(n - 1):\n        if b[i] + b[i + 1] < k:\n            needed_walks = k - (b[i] + b[i + 1])\n            b[i + 1] += needed_walks\n            additional_walks += needed_walks\n\n    return additional_walks, b\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nadditional_walks, b = minimum_additional_walks(n, k, a)\n\n# Print the result\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "# Read the input\nn = int(input())\n\n# Calculate the number of cells in the n-th order rhombus\n# The n-th order rhombus contains (2n - 1) cells in each row\n# Since the rhombus is symmetrical, the total number of cells is (2n - 1) * n\nnum_cells = (2 * n - 1) * n\n\n# Print the result\nprint(num_cells)"}
{"solution": "# Read the input\nn = int(input())\ns = input()\n\n# Convert the string to lowercase\ns = s.lower()\n\n# Create a set to store unique letters found in the string\nletters_found = set()\n\n# Iterate through the string and add each letter to the set\nfor char in s:\n    letters_found.add(char)\n\n# Check if the set contains all 26 letters of the alphabet\nif len(letters_found) == 26:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Read the current time and the number of minutes passed\ncurrent_time = input().split(':')\nminutes_passed = int(input())\n\n# Convert the current time to minutes\ncurrent_minutes = int(current_time[0]) * 60 + int(current_time[1])\n\n# Calculate the total minutes after the given number of minutes passed\ntotal_minutes = current_minutes + minutes_passed\n\n# Convert the total minutes back to the 24-hour format\nnew_hours = total_minutes // 60 % 24\nnew_minutes = total_minutes % 60\n\n# Print the new time with leading zeros if needed\nprint(f'{new_hours:02d}:{new_minutes:02d}')"}
{"solution": "def check_switches(n, m, switches):\n    # Create a list to store the lamps that are turned on by each switch\n    lamps_on = [set() for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if switches[i][j] == '1':\n                lamps_on[i].add(j)\n\n    # Check if there is a switch that can be ignored\n    for i in range(n):\n        # Create a set to store the lamps that are turned on by the other switches\n        other_lamps_on = set()\n        for j in range(n):\n            if i != j:\n                other_lamps_on |= lamps_on[j]\n        # If the set of lamps turned on by the other switches is equal to the set of all lamps, then the current switch can be ignored\n        if other_lamps_on == set(range(m)):\n            return True\n\n    # If no such switch is found, return False\n    return False\n\n# Read the input\nn, m = map(int, input().split())\nswitches = [input() for _ in range(n)]\n\n# Check if there is a switch that can be ignored\nif check_switches(n, m, switches):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_rotations(n, dominoes):\n    upper_sum = sum(x for x, _ in dominoes)\n    lower_sum = sum(y for _, y in dominoes)\n\n    if upper_sum % 2 == 0 and lower_sum % 2 == 0:\n        return 0\n    elif any(x % 2 != y % 2 for x, y in dominoes):\n        return 1\n    else:\n        return -1\n\nn = int(input())\ndominoes = [tuple(map(int, input().split())) for _ in range(n)]\nprint(min_rotations(n, dominoes))"}
{"solution": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef calculate_area(a, b):\n    return (a - b) * (a + b)\n\ndef solve_problem():\n    t = int(input())\n    for _ in range(t):\n        a, b = map(int, input().split())\n        area = calculate_area(a, b)\n        if is_prime(area):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nsolve_problem()"}
{"solution": "def can_remove_one_point(n, points):\n    positive_count = 0\n    negative_count = 0\n\n    for x, y in points:\n        if x > 0:\n            positive_count += 1\n        else:\n            negative_count += 1\n\n    if positive_count <= 1 or negative_count <= 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Reading input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_remove_one_point(n, points))"}
{"solution": "import math\n\n# Get the two numbers from the input\nA, B = map(int, input().split())\n\n# Calculate the factorials of the numbers\nfactorial_A = math.factorial(A)\nfactorial_B = math.factorial(B)\n\n# Calculate the GCD of the factorials\ngcd = math.gcd(factorial_A, factorial_B)\n\n# Print the result\nprint(gcd)"}
{"solution": "n = int(input())\n\nif n % 2 == 0:\n    a = n + 4\n    b = 4\nelse:\n    a = n + 9\n    b = 9\n\nprint(a, b)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef bellman_ford(graph, start, end, penalty):\n    distances = [float('inf')] * len(graph)\n    distances[start] = 0\n    coins = [0] * len(graph)\n\n    for _ in range(len(graph) - 1):\n        for node, edges in graph.items():\n            for neighbor, coin in edges:\n                if distances[node] + 1 < distances[neighbor]:\n                    distances[neighbor] = distances[node] + 1\n                    coins[neighbor] = coins[node] + coin\n                elif distances[node] + 1 == distances[neighbor]:\n                    coins[neighbor] = max(coins[neighbor], coins[node] + coin)\n\n    max_score = float('-inf')\n    for time in range(len(graph)):\n        score = coins[end] - max(0, time * penalty)\n        max_score = max(max_score, score)\n\n    return max_score\n\ndef main():\n    N, M, P = map(int, sys.stdin.readline().split())\n    graph = defaultdict(list)\n\n    for _ in range(M):\n        A, B, C = map(int, sys.stdin.readline().split())\n        graph[A - 1].append((B - 1, C))\n\n    max_score = bellman_ford(graph, 0, N - 1, P)\n    print(max_score)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef min_palindrome_cost():\n    n = int(sys.stdin.readline())\n    strings = [sys.stdin.readline().split() for _ in range(n)]\n\n    # Create a dictionary to store the cost of each string\n    string_cost = {s: int(c) for s, c in strings}\n\n    # Create a dictionary to store the minimum cost of making a palindrome from a substring\n    dp = defaultdict(lambda: float('inf'))\n\n    # Initialize the base cases\n    for s, c in strings:\n        dp[s] = min(dp[s], c)\n        dp[s[::-1]] = min(dp[s[::-1]], c)\n\n    # Iterate over all possible substring lengths\n    for length in range(1, 21):\n        for start in range(400 - length):\n            # Extract the current substring\n            substring = ''.join(s[start:start+length] for s in strings)\n\n            # Check if the substring is a palindrome\n            if substring == substring[::-1]:\n                # Calculate the cost of making a palindrome from the substring\n                cost = sum(string_cost[s] for s in strings if s in substring)\n                dp[substring] = min(dp[substring], cost)\n\n            # Check if the substring can be extended to a palindrome\n            for i in range(length // 2):\n                if substring[i] == substring[length-i-1]:\n                    # Calculate the cost of making a palindrome from the extended substring\n                    cost = dp[substring[i+1:length-i-1]]\n                    dp[substring] = min(dp[substring], cost)\n\n    # Return the minimum cost of making a palindrome from all strings\n    return min(dp.values()) if dp else -1\n\nprint(min_palindrome_cost())"}
{"solution": "def largest_xor_sum(n, k):\n    # Find the number of bits in n\n    num_bits = n.bit_length()\n    # The largest possible xor-sum\n    max_xor_sum = (1 << num_bits) - 1\n    return max_xor_sum\n\n# Get input\nn, k = map(int, input().split())\n# Print output\nprint(largest_xor_sum(n, k))"}
{"solution": "def min_triangle_side():\n    n = int(input())\n    points = sorted([tuple(map(int, input().split())) for _ in range(n)])\n\n    max_y = 0\n    min_side = float('inf')\n\n    for x, y in points:\n        max_y = max(max_y, y)\n        min_side = min(min_side, max(max_y - y, x))\n\n    print(min_side)\n\nmin_triangle_side()"}
{"solution": "def max_nineteens(s):\n    from collections import Counter\n\n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n\n    # Define the required frequency of each character in the word \"nineteen\"\n    required_counts = {'n': 3, 'i': 1, 'e': 3, 't': 1}\n\n    # Calculate the maximum number of \"nineteen\" words that can be formed\n    max_nineteens = float('inf')\n    for char, required in required_counts.items():\n        if char in char_count:\n            max_nineteens = min(max_nineteens, char_count[char] // required)\n        else:\n            return 0  # If any required character is missing, we can't form \"nineteen\"\n\n    return max_nineteens\n\n# Get the input string\ns = input()\n\n# Print the maximum number of \"nineteen\" words that can be formed\nprint(max_nineteens(s))"}
{"solution": "def find_highest_branch(p, y):\n    # Start from the highest branch\n    for branch in range(y, 1, -1):\n        # Check if the branch is a multiple of any grasshopper's branch\n        if all(branch % i != 0 for i in range(2, p + 1)):\n            return branch\n    # If no suitable branch is found\n    return -1\n\n# Read input\np, y = map(int, input().split())\n\n# Find and print the highest suitable branch\nprint(find_highest_branch(p, y))"}
{"solution": "# Read input\nn, m, k = map(int, input().split())\nhouses = list(map(int, input().split()))\n\n# Initialize minimum distance to a large number\nmin_distance = float('inf')\n\n# Iterate over all houses\nfor i in range(n):\n    # If the house is affordable\n    if houses[i] <= k:\n        # Calculate the distance from the girl's house\n        distance = abs(i - m + 1) * 10\n        # Update the minimum distance\n        min_distance = min(min_distance, distance)\n\n# Print the minimum distance\nprint(min_distance)"}
{"solution": "def is_possible_transformation(A, B):\n    n = len(A)\n    m = len(A[0])\n\n    # Check if the matrices have the same size\n    if len(B) != n or len(B[0]) != m:\n        return False\n\n    # Check if each element in A can be transformed into the corresponding element in B\n    for i in range(n):\n        for j in range(m):\n            # If the elements are already equal, no transformation is needed\n            if A[i][j] == B[i][j]:\n                continue\n\n            # Find a square submatrix that contains the current element\n            for k in range(min(n - i, m - j), 0, -1):\n                # Check if transposing the square submatrix will transform A[i][j] into B[i][j]\n                if A[i + k - 1][j + k - 1] == B[i][j]:\n                    # Transpose the square submatrix\n                    for x in range(i, i + k):\n                        for y in range(x + 1, i + k):\n                            A[x][y], A[y][x] = A[y][x], A[x][y]\n                    break\n\n            # If the element couldn't be transformed, return False\n            if A[i][j] != B[i][j]:\n                return False\n\n    # If all elements were transformed successfully, return True\n    return True\n\n# Read the input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nB = [list(map(int, input().split())) for _ in range(n)]\n\n# Check if it's possible to transform A into B\nif is_possible_transformation(A, B):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Get the input strings\na = input()\nb = input()\n\n# If the strings are equal, there's no uncommon subsequence\nif a == b:\n    print(-1)\n# Otherwise, the longest uncommon subsequence is the length of the longer string\nelse:\n    print(max(len(a), len(b)))"}
{"solution": "def find_intersection(a, b, c, d):\n    if a == c:\n        if b == d:\n            return b\n        else:\n            return -1\n    elif (b - d) % (c - a) == 0:\n        return max(b, d) + (max(0, (b - d) // (c - a)) * abs(c - a))\n    else:\n        return -1\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\nprint(find_intersection(a, b, c, d))"}
{"solution": "def split_number(n):\n    # Start with the smallest possible number that is not a multiple of 3\n    a = 1\n    b = 2\n    c = n - a - b\n\n    # Check if c is a multiple of 3\n    if c % 3 == 0:\n        # If c is a multiple of 3, increment a and decrement b until c is not a multiple of 3\n        while c % 3 == 0:\n            a += 1\n            b -= 1\n            c = n - a - b\n\n    return a, b, c\n\n# Get the input number\nn = int(input())\n\n# Split the number\na, b, c = split_number(n)\n\n# Print the result\nprint(a, b, c)"}
{"solution": "def find_distinct_squares(n, a, b, c, d):\n    # Calculate the sum of the top left 2x2 square\n    target_sum = a + b + c + d\n\n    # Initialize the count of distinct squares\n    count = 0\n\n    # Iterate through all possible values for the unknown cells\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            for k in range(1, n + 1):\n                # Calculate the value of the last cell in the top row\n                top_last = target_sum - a - i\n                # Check if the value is valid\n                if top_last < 1 or top_last > n or top_last == i:\n                    continue\n\n                # Calculate the value of the last cell in the middle row\n                middle_last = target_sum - b - j\n                # Check if the value is valid\n                if middle_last < 1 or middle_last > n or middle_last == j:\n                    continue\n\n                # Calculate the value of the last cell in the bottom row\n                bottom_last = target_sum - c - k\n                # Check if the value is valid\n                if bottom_last < 1 or bottom_last > n or bottom_last == k:\n                    continue\n\n                # Calculate the value of the middle cell in the bottom row\n                bottom_middle = target_sum - d - bottom_last\n                # Check if the value is valid\n                if bottom_middle < 1 or bottom_middle > n or bottom_middle == bottom_last:\n                    continue\n\n                # If all values are valid, increment the count of distinct squares\n                count += 1\n\n    # Return the count of distinct squares\n    return count\n\n# Read the input values\nn, a, b, c, d = map(int, input().split())\n\n# Print the number of distinct valid squares\nprint(find_distinct_squares(n, a, b, c, d))"}
{"solution": "# Get the initial weight and height of the snowball\nw, h = map(int, input().split())\n\n# Get the weight and height of the first stone\nu1, d1 = map(int, input().split())\n\n# Get the weight and height of the second stone\nu2, d2 = map(int, input().split())\n\n# Simulate the snowball's descent\nwhile h > 0:\n    # Increase the snowball's weight by its current height\n    w += h\n\n    # Check if the snowball hits a stone\n    if h == d1:\n        # Decrease the snowball's weight by the stone's weight\n        w = max(0, w - u1)\n    elif h == d2:\n        # Decrease the snowball's weight by the stone's weight\n        w = max(0, w - u2)\n\n    # Move the snowball one meter down\n    h -= 1\n\n# Print the final weight of the snowball\nprint(w)"}
{"solution": "# Read input\nm = int(input())\nscores = list(map(int, input().split()))\nx, y = map(int, input().split())\n\n# Initialize variables\nbeginners, intermediates = 0, sum(scores)\nk = m\n\n# Find the passing rate\nwhile k > 0:\n    if x <= beginners <= y and x <= intermediates <= y:\n        break\n    k -= 1\n    beginners += scores[k]\n    intermediates -= scores[k]\n\n# Print the result\nif k == 0:\n    print(0)\nelse:\n    print(k)"}
{"solution": "def min_coins(n, k, A, B):\n    coins = 0\n    while n != 1:\n        if n % k == 0:\n            if A < B:\n                n -= 1\n                coins += A\n            else:\n                n //= k\n                coins += B\n        else:\n            n -= 1\n            coins += A\n    return coins\n\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\nprint(min_coins(n, k, A, B))"}
{"solution": "import math\n\ndef min_operations(n):\n    operations = 0\n    while n > 1:\n        if n % 2 == 0:\n            n = math.isqrt(n)\n            operations += 1\n        else:\n            n *= 2\n            operations += 1\n    return n, operations\n\nn = int(input())\nmin_n, min_operations = min_operations(n)\nprint(min_n, min_operations)"}
{"solution": "# Read input\nn, k = map(int, input().split())\nr, s, p = map(int, input().split())\nt = input()\n\n# Initialize score and last used hands\nscore = 0\nlast_used = [-1] * 3\n\n# Iterate over each round\nfor i in range(n):\n    # Determine the machine's move\n    if t[i] == 'r':\n        machine_move = 0\n    elif t[i] == 'p':\n        machine_move = 1\n    else:\n        machine_move = 2\n\n    # Determine the best move for the player\n    if machine_move == 0:  # Rock\n        best_move = 1  # Paper\n    elif machine_move == 1:  # Paper\n        best_move = 2  # Scissors\n    else:  # Scissors\n        best_move = 0  # Rock\n\n    # Check if the best move was used K rounds ago\n    if i >= k and last_used[best_move] == i - k:\n        # If it was, skip this round\n        continue\n\n    # Update the score and the last used hands\n    if best_move == 0:\n        score += r\n    elif best_move == 1:\n        score += p\n    else:\n        score += s\n\n    last_used[best_move] = i\n\n# Print the maximum total score\nprint(score)"}
{"solution": "def longest_good_string(a, b, c):\n    # If the number of 'ab' strings is greater than or equal to the number of 'a' and 'b' strings,\n    # we can concatenate all 'ab' strings to form the longest good string.\n    if c >= a and c >= b:\n        return 2 * c\n\n    # If the number of 'ab' strings is less than the number of 'a' and 'b' strings,\n    # we can form the longest good string by alternating 'a' and 'b' strings.\n    # The length of the longest good string is the sum of the number of 'a' and 'b' strings,\n    # plus one extra character to separate the last 'a' or 'b' string from the first 'ab' string.\n    return a + b + 2 * c\n\n# Read input\na, b, c = map(int, input().split())\n\n# Print output\nprint(longest_good_string(a, b, c))"}
{"solution": "def solve_problem():\n    n, k, p, x, y = map(int, input().split())\n    marks = list(map(int, input().split()))\n\n    # Calculate the current sum and median of marks\n    current_sum = sum(marks)\n    marks.sort()\n    current_median = marks[k // 2]\n\n    # Calculate the required sum and median of marks\n    required_sum = x\n    required_median = y\n\n    # Calculate the remaining sum and number of marks needed to meet the requirements\n    remaining_sum = required_sum - current_sum\n    remaining_marks = n - k\n\n    # Check if it's possible to meet the requirements\n    if remaining_sum < remaining_marks or remaining_sum > remaining_marks * p:\n        print(-1)\n        return\n\n    # Calculate the number of marks needed to meet the median requirement\n    median_index = (n + 1) // 2\n    if current_median < required_median:\n        median_marks = median_index - k\n        remaining_sum -= median_marks * required_median\n        remaining_marks -= median_marks\n\n    # Distribute the remaining marks as evenly as possible\n    remaining_marks_per_test = remaining_sum // remaining_marks\n    remaining_marks_extra = remaining_sum % remaining_marks\n    result = [remaining_marks_per_test] * remaining_marks\n    for i in range(remaining_marks_extra):\n        result[i] += 1\n\n    print(' '.join(map(str, result)))\n\nsolve_problem()"}
{"solution": "def is_berlanese(word):\n    vowels = ['a', 'o', 'u', 'i', 'e']\n    prev_char = ''\n\n    for char in word:\n        if char not in vowels and prev_char != 'n' and prev_char not in vowels:\n            return False\n        prev_char = char\n\n    if prev_char not in vowels and prev_char != 'n':\n        return False\n\n    return True\n\nword = input()\nif is_berlanese(word):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "from collections import defaultdict\n\ndef is_bipartite(graph, node, visited, color):\n    visited[node] = color\n    for neighbor in graph[node]:\n        if visited[neighbor] == color:\n            return False\n        if visited[neighbor] == -1 and not is_bipartite(graph, neighbor, visited, 1 - color):\n            return False\n    return True\n\ndef max_dominoes(n, m, edges):\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [-1] * (n + 1)\n    for node in range(1, n + 1):\n        if visited[node] == -1 and not is_bipartite(graph, node, visited, 0):\n            return 0\n\n    return m\n\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nprint(max_dominoes(n, m, edges))"}
{"solution": "def max_points(n, m, a, b):\n    # Sort the questions in descending order of price\n    a.sort(reverse=True)\n\n    # Initialize the total points for R2\n    total_points = 0\n\n    # Initialize the current points for R2\n    current_points = 0\n\n    # Iterate through the questions\n    for i in range(n):\n        # If the question is an auction question\n        if i in b:\n            # If R2 can change the price of the question\n            if current_points > a[i]:\n                # Change the price to the current points of R2\n                total_points += current_points\n                current_points += current_points\n            else:\n                # R2 answers the question correctly\n                total_points += a[i]\n                current_points += a[i]\n        else:\n            # R2 answers the question correctly\n            total_points += a[i]\n            current_points += a[i]\n\n    return total_points\n\n# Read the input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Print the maximum points R2 can get\nprint(max_points(n, m, a, b))"}
{"solution": "# Get the input\nsubmission_times = list(map(int, input().split()))\nwrong_submissions = list(map(int, input().split()))\nsuccessful_hacks, unsuccessful_hacks = map(int, input().split())\n\n# Initialize the total score\ntotal_score = 0\n\n# Calculate the score for each problem\nproblem_scores = [0] * 5\nfor i in range(5):\n    m = submission_times[i]\n    w = wrong_submissions[i]\n    x = [500, 1000, 1500, 2000, 2500][i]\n    problem_scores[i] = max(0.3 * x, (1 - m / 250) * x - 50 * w)\n\n# Calculate the total score\ntotal_score = sum(problem_scores)\ntotal_score += successful_hacks * 100\ntotal_score -= unsuccessful_hacks * 50\n\n# Print the final score\nprint(int(total_score))"}
{"solution": "MOD = 998244353\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef find_grids(n, m, L, R):\n    total = (R - L + 1)\n    if n * m % 2 == 1:\n        return (total * power(2, total - 1, MOD)) % MOD\n    else:\n        return (total * power(2, total, MOD)) % MOD\n\nn, m, L, R = map(int, input().split())\nprint(find_grids(n, m, L, R))"}
{"solution": "def is_possible_to_make_increasing(n, m, matrix_a, matrix_b):\n    for i in range(n):\n        for j in range(m):\n            # Ensure that matrix_a[i][j] is the smaller or equal element\n            if matrix_a[i][j] > matrix_b[i][j]:\n                matrix_a[i][j], matrix_b[i][j] = matrix_b[i][j], matrix_a[i][j]\n\n    # Check rows for strictly increasing property\n    for i in range(n):\n        for j in range(1, m):\n            if matrix_a[i][j] <= matrix_a[i][j-1] or matrix_b[i][j] <= matrix_b[i][j-1]:\n                return \"Impossible\"\n\n    # Check columns for strictly increasing property\n    for j in range(m):\n        for i in range(1, n):\n            if matrix_a[i][j] <= matrix_a[i-1][j] or matrix_b[i][j] <= matrix_b[i-1][j]:\n                return \"Impossible\"\n\n    return \"Possible\"\n\n# Read input\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\nmatrix_b = [list(map(int, input().split())) for _ in range(n)]\n\n# Print output\nprint(is_possible_to_make_increasing(n, m, matrix_a, matrix_b))"}
{"solution": "# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Sort the list in descending order\na.sort(reverse=True)\n\n# Initialize the result\nresult = 0\n\n# Initialize the frequency of the current letter\nfreq = a[0]\n\n# Iterate over the sorted list\nfor i in range(n):\n    # If the frequency of the current letter is greater than 0\n    if freq > 0:\n        # Add the frequency to the result\n        result += freq\n        # Decrease the frequency by 1\n        freq -= 1\n    # If the frequency is 0, move to the next letter\n    else:\n        break\n    # If the next letter has the same frequency, decrease it by 1\n    if i < n - 1 and a[i] == a[i + 1]:\n        a[i + 1] -= 1\n\n# Print the result\nprint(result)"}
{"solution": "n, k = map(int, input().split())\nproblems = list(map(int, input().split()))\nproblems.sort()\n\nextra_problems = 0\nfor problem in problems:\n    if problem > k:\n        if k * 2 < problem:\n            extra_problems += 1\n            k = problem\n        else:\n            k = problem\n\nprint(extra_problems)"}
{"solution": "def distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3):\n    # Start with the maximum possible number of first-degree diplomas\n    first_degree = max(min_1, min(max_1, n - min_2 - min_3))\n    n -= first_degree\n\n    # Then, distribute the second-degree diplomas\n    second_degree = max(min_2, min(max_2, n - min_3))\n    n -= second_degree\n\n    # Finally, distribute the third-degree diplomas\n    third_degree = n\n\n    return first_degree, second_degree, third_degree\n\n# Read input\nn = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\n# Distribute diplomas\nfirst_degree, second_degree, third_degree = distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3)\n\n# Print output\nprint(first_degree, second_degree, third_degree)"}
{"solution": "# Get the number of days Vitya was watching the moon\nn = int(input())\n\n# Get Vitya's records\nrecords = list(map(int, input().split()))\n\n# Define the moon cycle\nmoon_cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n# Check if the records match the end of the moon cycle\nif records == moon_cycle[-n:]:\n    # If the records match the end of the moon cycle, the moon will be up next day\n    print(\"UP\")\n# Check if the records match the beginning of the moon cycle\nelif records == moon_cycle[:n]:\n    # If the records match the beginning of the moon cycle, the moon will be down next day\n    print(\"DOWN\")\nelse:\n    # If the records do not match the end or the beginning of the moon cycle, it's impossible to determine what will happen next\n    print(-1)"}
{"solution": "def can_transform(s, t):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n\n    # Check if lengths are the same\n    if len(s) != len(t):\n        return \"No\"\n\n    # Check each character\n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels) != (char_t in vowels):\n            return \"No\"\n\n    return \"Yes\"\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(can_transform(s, t))"}
{"solution": "def find_winner(board):\n    # Check if player A can win by moving a pawn to the first row\n    for i in range(8):\n        if 'W' in board[0][i]:\n            return 'A'\n\n    # Check if player B can win by moving a pawn to the last row\n    for i in range(8):\n        if 'B' in board[7][i]:\n            return 'B'\n\n    # Check if player A can block player B's pawn from reaching the last row\n    for i in range(8):\n        if 'W' in board[i]:\n            col = board[i].index('W')\n            if col > 0 and board[i][col - 1] == 'B':\n                return 'A'\n            if col < 7 and board[i][col + 1] == 'B':\n                return 'A'\n\n    # If none of the above conditions are met, player B will win\n    return 'B'\n\n# Read the input board\nboard = []\nfor _ in range(8):\n    row = input()\n    board.append(row)\n\n# Determine the winner\nwinner = find_winner(board)\nprint(winner)"}
{"solution": "def max_equal_length(n, A, m, B):\n    if sum(A) != sum(B):\n        return -1\n\n    i, j = 0, 0\n    sumA, sumB = 0, 0\n    count = 0\n\n    while i < n and j < m:\n        sumA += A[i]\n        sumB += B[j]\n\n        if sumA == sumB:\n            count += 1\n            sumA = 0\n            sumB = 0\n            i += 1\n            j += 1\n        elif sumA < sumB:\n            i += 1\n        else:\n            j += 1\n\n    return count\n\n# Read input\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\n# Print output\nprint(max_equal_length(n, A, m, B))"}
{"solution": "def is_contest_problem(problem_name):\n    friends_names = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    count = 0\n\n    for name in friends_names:\n        if name in problem_name:\n            count += problem_name.count(name)\n\n    return \"YES\" if count == 1 else \"NO\"\n\nproblem_name = input()\nprint(is_contest_problem(problem_name))"}
{"solution": "def sieve(n):\n    is_prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (is_prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n    is_prime[0], is_prime[1] = False, False  # 0 and 1 are not primes\n    return is_prime\n\ndef count_primes_in_range(is_prime, a, b):\n    prime_count = [0] * (b + 1)\n    for i in range(a, b + 1):\n        prime_count[i] = prime_count[i - 1] + (1 if is_prime[i] else 0)\n    return prime_count\n\ndef min_length_with_k_primes(a, b, k):\n    is_prime = sieve(b)\n    prime_count = count_primes_in_range(is_prime, a, b)\n\n    def has_k_primes_in_length(l):\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] >= k:\n                return True\n        return False\n\n    left, right = 1, b - a + 1\n    result = -1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if has_k_primes_in_length(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return result\n\n# Input\na, b, k = map(int, input().split())\n\n# Output\nprint(min_length_with_k_primes(a, b, k))"}
{"solution": "from math import gcd\n\ndef calculate_min_distance(a, h, w):\n    # Calculate the greatest common divisor of h and w\n    g = gcd(h, w)\n\n    # Check if it's possible to put at least one photo on the wall\n    if a > h or a > w or h % g != a % g or w % g != a % g:\n        return -1\n\n    # Calculate the maximum number of photos that can be placed along the height and width\n    max_photos_h = h // a\n    max_photos_w = w // a\n\n    # Calculate the minimum distance between photos\n    min_distance = min((h - a * max_photos_h) / (max_photos_h + 1), (w - a * max_photos_w) / (max_photos_w + 1))\n\n    return min_distance\n\n# Read the input\na, h, w = map(int, input().split())\n\n# Calculate and print the minimum distance\nresult = calculate_min_distance(a, h, w)\nprint(result)"}
{"solution": "# Read the number of chapters\nn = int(input())\n\n# Initialize an empty list to store the chapters\nchapters = []\n\n# Read the chapters and store them in the list\nfor _ in range(n):\n    l, r = map(int, input().split())\n    chapters.append((l, r))\n\n# Read the marked page\nk = int(input())\n\n# Initialize a counter for unread chapters\nunread_chapters = 0\n\n# Iterate over the chapters\nfor l, r in chapters:\n    # If the marked page is within the chapter or the chapter starts after the marked page,\n    # increment the counter\n    if l <= k <= r:\n        unread_chapters += 1\n    # If the chapter starts after the marked page, break the loop\n    elif l > k:\n        break\n\n# Print the number of unread chapters\nprint(unread_chapters)"}
{"solution": "def can_form_codeforces(word):\n    target = \"CODEFORCES\"\n    n = len(word)\n    m = len(target)\n\n    if n < m:\n        return \"NO\"\n\n    for i in range(m + 1):\n        if word[:i] == target[:i] and word[n - (m - i):] == target[i:]:\n            return \"YES\"\n\n    return \"NO\"\n\n# Read the input word\nword = input()\n\n# Call the function and print the result\nprint(can_form_codeforces(word))"}
{"solution": "n = int(input())\n\n# Initialize the minimum weight to a large number\nmin_weight = float('inf')\n\n# Iterate through all possible diagonals\nfor i in range(3, n + 1):\n    # Calculate the weight of the triangulation\n    weight = (i - 1) * i * (i + 1)\n    # Update the minimum weight if necessary\n    min_weight = min(min_weight, weight)\n\n# Print the minimum weight\nprint(min_weight)"}
{"solution": "# Input the number of books\nn = int(input())\n\n# Initialize the total number of digits\ntotal_digits = 0\n\n# Calculate the total number of digits needed\nfor i in range(1, n + 1):\n    total_digits += len(str(i))\n\n# Print the result\nprint(total_digits)"}
{"solution": "# Read input\nn, A = map(int, input().split())\ncars = list(map(int, input().split()))\n\n# Initialize counts\ncount_A = 0\ncount_B = 0\n\n# Initialize potential winning color\nB = -1\n\n# Iterate over cars\nfor i in range(n):\n    # Update counts\n    if cars[i] == A:\n        count_A += 1\n    else:\n        # If current car color can beat Alice's color, update Bob's count\n        if count_B < count_A:\n            count_B += 1\n            B = cars[i]\n\n# If Bob found a winning color, print it\nif count_B >= count_A:\n    print(B)\nelse:\n    print(-1)"}
{"solution": "def check_crossword(n, x, a):\n    # Calculate the total length of 1's in the encoding\n    total_length = sum(a)\n\n    # Check if the total length of 1's is equal to the length of the crossword\n    if total_length != x:\n        return \"NO\"\n\n    # Check if there are any two adjacent segments of 1's\n    for i in range(1, n):\n        if a[i-1] > 0 and a[i] > 0:\n            return \"NO\"\n\n    # If there are no two adjacent segments of 1's, then there is exactly one crossword\n    return \"YES\"\n\n# Read the input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the output\nprint(check_crossword(n, x, a))"}
{"solution": "def min_coins(n, S):\n    # Initialize result\n    res = 0\n\n    # While S is greater than 0\n    while S > 0:\n        # Find the largest possible coin value\n        coin = min(n, S)\n\n        # Subtract the coin value from S\n        S -= coin\n\n        # Increment the result\n        res += 1\n\n    # Return the result\n    return res\n\n# Read input\nn, S = map(int, input().split())\n\n# Print output\nprint(min_coins(n, S))"}
{"solution": "from collections import Counter\n\ndef min_changes_palindrome(s):\n    # Count the frequency of each character\n    counter = Counter(s)\n\n    # Find the character with the odd count\n    odd_char = [char for char, count in counter.items() if count % 2]\n\n    # If more than one character has an odd count, it's impossible to form a palindrome\n    if len(odd_char) > 1:\n        return \"Impossible\"\n\n    # Remove the odd character from the counter\n    if odd_char:\n        counter[odd_char[0]] -= 1\n\n    # Build the first half of the palindrome\n    first_half = []\n    for char in sorted(counter.keys()):\n        first_half.extend([char] * (counter[char] // 2))\n\n    # Build the second half of the palindrome (which is the reverse of the first half)\n    second_half = first_half[::-1]\n\n    # Add the odd character in the middle if it exists\n    if odd_char:\n        return \"\".join(first_half + [odd_char[0]] + second_half)\n    else:\n        return \"\".join(first_half + second_half)\n\n# Read the input string\ns = input()\n\n# Print the lexicographically smallest palindrome that can be obtained with the minimal number of changes\nprint(min_changes_palindrome(s))"}
{"solution": "def calculate_weight(board):\n    piece_weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n    }\n\n    white_weight = 0\n    black_weight = 0\n\n    for row in board:\n        for piece in row:\n            if piece in piece_weights:\n                if piece.isupper():\n                    white_weight += piece_weights[piece]\n                else:\n                    black_weight += piece_weights[piece]\n\n    if white_weight > black_weight:\n        return \"White\"\n    elif black_weight > white_weight:\n        return \"Black\"\n    else:\n        return \"Draw\"\n\n# Example usage:\nboard = [\n    \"...QK...\",\n    \"........\",\n    \"........\",\n    \"........\",\n    \"........\",\n    \"........\",\n    \"........\",\n    \"...rk...\"\n]\n\nprint(calculate_weight(board))  # Output: White"}
{"solution": "from collections import deque, defaultdict\n\ndef shortest_path(N, M, S):\n    # Create a graph\n    graph = defaultdict(list)\n    for i in range(N):\n        if S[i] == '0':\n            for j in range(1, M + 1):\n                if i + j <= N and S[i + j] == '0':\n                    graph[i].append(i + j)\n\n    # BFS\n    queue = deque([(0, [])])\n    while queue:\n        node, path = queue.popleft()\n        if node == N:\n            return path\n        for neighbor in sorted(graph[node]):\n            queue.append((neighbor, path + [neighbor - node]))\n\n    return [-1]\n\n# Read input\nN, M = map(int, input().split())\nS = input()\n\n# Find the shortest path\nresult = shortest_path(N, M, S)\n\n# Print the result\nprint(*result)"}
{"solution": "def manhattan_distance(x1, y1, x2, y2):\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef optimal_path(k, x, y):\n    path = []\n    current_x, current_y = 0, 0\n\n    while manhattan_distance(current_x, current_y, x, y) >= k:\n        if (current_x < x and current_y < y) or (current_x > x and current_y > y):\n            current_x += k if current_x < x else -k\n            current_y += k if current_y < y else -k\n        else:\n            current_x += k if current_x < x else -k\n\n        path.append((current_x, current_y))\n\n    if (current_x, current_y) != (x, y):\n        path.append((x, y))\n\n    return path\n\nk = int(input())\nx, y = map(int, input().split())\n\npath = optimal_path(k, x, y)\n\nif path:\n    print(len(path))\n    for point in path:\n        print(*point)\nelse:\n    print(-1)"}
{"solution": "def find_smallest_n(m):\n    # Binary search for the smallest possible value of n\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if count_ways(mid) >= m:\n            right = mid\n        else:\n            left = mid + 1\n\n    # Check if the found value of n is valid\n    if count_ways(left) == m:\n        return left\n    else:\n        return -1\n\ndef count_ways(n):\n    # Count the number of ways to steal chocolates for a given value of n\n    ways = 0\n    for k in range(2, n + 1):\n        # Check if the first thief can take 1 chocolate\n        if n % k < k - 1:\n            continue\n        # Calculate the number of ways for the remaining thieves\n        remaining = n - 1\n        for _ in range(3):\n            if remaining % k != 0:\n                break\n            remaining //= k\n        else:\n            ways += 1\n    return ways\n\n# Read the input\nm = int(input())\n\n# Find the smallest possible value of n\nn = find_smallest_n(m)\n\n# Print the output\nprint(n)"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\n    if d > r1 + r2:\n        return 0\n    elif d < abs(r1 - r2):\n        return min(math.pi * r1**2, math.pi * r2**2)\n    else:\n        a = (r1**2 - r2**2 + d**2) / (2 * d)\n        h = math.sqrt(r1**2 - a**2)\n        theta1 = 2 * math.asin(h / r1)\n        theta2 = 2 * math.asin(h / r2)\n        area1 = 0.5 * r1**2 * (theta1 - math.sin(theta1))\n        area2 = 0.5 * r2**2 * (theta2 - math.sin(theta2))\n        return area1 + area2\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\nprint(circle_intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "def minimize_n(v):\n    # If v is 1, return 1 as the minimum value\n    if v == 1:\n        return 1\n    # If v is even, return 1 as the minimum value\n    elif v % 2 == 0:\n        return 1\n    # If v is odd, return 2 as the minimum value\n    else:\n        return 2\n\n# Get the input value of v\nv = int(input())\n# Print the minimum value of n\nprint(minimize_n(v))"}
{"solution": "import sys\n\ndef dfs(node, parent, graph, citizens):\n    max_citizens = 0\n    for child in graph[node]:\n        if child != parent:\n            child_citizens = dfs(child, node, graph, citizens)\n            max_citizens = max(max_citizens, child_citizens)\n            citizens[node] += child_citizens\n    return max(citizens[node], max_citizens)\n\ndef main():\n    n = int(sys.stdin.readline())\n    parents = list(map(int, sys.stdin.readline().split()))\n    citizens = list(map(int, sys.stdin.readline().split()))\n\n    graph = [[] for _ in range(n + 1)]\n    for i in range(2, n + 1):\n        graph[parents[i - 1]].append(i)\n\n    result = dfs(1, 0, graph, citizens)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_typo_words(n, S, T):\n    count = 0\n    for i in range(n + 1):\n        # Construct W by inserting a character at position i in both S and T\n        if i == 0:\n            W1 = S[0] + S\n            W2 = T[0] + T\n        elif i == n:\n            W1 = S + S[-1]\n            W2 = T + T[-1]\n        else:\n            W1 = S[:i] + S[i] + S[i:]\n            W2 = T[:i] + T[i] + T[i:]\n\n        # Check if the constructed words are the same\n        if W1 == W2:\n            count += 1\n\n    return count\n\n# Read input\nn = int(input())\nS = input().strip()\nT = input().strip()\n\n# Print output\nprint(count_typo_words(n, S, T))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    n = int(sys.stdin.readline())\n    strengths = list(map(int, sys.stdin.readline().split()))\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    return n, strengths, graph\n\ndef dfs(node, parent, strengths, graph, visited):\n    visited[node] = True\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            strengths[neighbor] += 1\n            dfs(neighbor, node, strengths, graph, visited)\n\ndef find_min_strength(n, strengths, graph):\n    banks = sorted(range(n), key=lambda x: strengths[x])\n    visited = [False] * n\n    for bank in banks:\n        if not visited[bank]:\n            visited[bank] = True\n            for neighbor in graph[bank]:\n                strengths[neighbor] -= 1\n            if strengths[bank] <= 0:\n                return bank\n\ndef main():\n    n, strengths, graph = read_input()\n    min_strength = find_min_strength(n, strengths, graph)\n    print(strengths[min_strength])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_groups(n, m):\n    return min(m, n - m)\n\nn, m = map(int, input().split())\nprint(max_groups(n, m))"}
{"solution": "def min_shovels(k, r):\n    # Start with 1 shovel\n    shovels = 1\n    # Calculate the total cost\n    total_cost = k\n\n    # While the total cost is not divisible by 10 or the remainder is not equal to r\n    while total_cost % 10 != 0 and total_cost % 10 != r:\n        # Increase the number of shovels\n        shovels += 1\n        # Recalculate the total cost\n        total_cost = k * shovels\n\n    return shovels\n\n# Get the input\nk, r = map(int, input().split())\n# Print the result\nprint(min_shovels(k, r))"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n\n    # Dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n\n    # Extract the bounding box\n    piece = []\n    for i in range(min_row, max_row + 1):\n        piece.append(grid[i][min_col:max_col + 1])\n\n    # Check horizontal placement\n    if width * 2 == m:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j] != piece[i][j + width]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n\n    # Check vertical placement\n    if height * 2 == n:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j] != piece[i + height][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "# Read the coordinates of the three points\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\n# Check for collinearity on the same axis\nif x1 == x2 == x3 or y1 == y2 == y3:\n    print(1)\n# Check for two points sharing the same coordinate\nelif x1 == x2 or x1 == x3 or x2 == x3 or y1 == y2 or y1 == y3 or y2 == y3:\n    print(2)\n# General case\nelse:\n    print(3)"}
{"solution": "def create_graph(k):\n    if k % 2 != 0:\n        return \"NO\"\n\n    edges = []\n    n = 2 * k\n    for i in range(k):\n        edges.append((i, i + k))\n        for j in range(1, k // 2):\n            edges.append((i, i + j))\n            edges.append((i + k, (i + j + k) % n))\n\n    return \"YES\\n\" + str(n) + \" \" + str(len(edges)) + \"\\n\" + \"\\n\".join([\" \".join(map(str, edge)) for edge in edges])\n\nk = int(input())\nprint(create_graph(k))"}
{"solution": "import sys\nfrom typing import List\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef find_occurrences(s: str, t: str, queries: List[tuple]):\n    n, m = len(s), len(t)\n    prefix_sum = [[0] * (n + 1) for _ in range(26)]\n\n    for i in range(n):\n        for j in range(26):\n            prefix_sum[j][i + 1] = prefix_sum[j][i]\n        prefix_sum[ord(s[i]) - ord('a')][i + 1] += 1\n\n    results = []\n    for l, r in queries:\n        count = 0\n        for i in range(26):\n            count += (prefix_sum[i][r] - prefix_sum[i][l - 1]) * (t.count(chr(i + ord('a'))))\n        results.append(count // m)\n\n    return results\n\ndef main():\n    n, m, q = map(int, read_input().split())\n    s = read_input()\n    t = read_input()\n    queries = [tuple(map(int, read_input().split())) for _ in range(q)]\n\n    results = find_occurrences(s, t, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 1000000007\n\ndef solve(n, k, d):\n    dp = [[0] * (n + 1) for _ in range(k + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, k + 1):\n        for j in range(n + 1):\n            for l in range(1, min(i, j) + 1):\n                if l >= d:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD\n\n    return sum(dp[k][n - d + 1:]) % MOD\n\nn, k, d = map(int, input().split())\nprint(solve(n, k, d))"}
{"solution": "def encrypt_japanese_crossword(n, row):\n    groups = []\n    count = 0\n\n    for char in row:\n        if char == 'B':\n            count += 1\n        else:\n            if count > 0:\n                groups.append(count)\n                count = 0\n\n    if count > 0:\n        groups.append(count)\n\n    print(len(groups))\n    if groups:\n        print(\" \".join(map(str, groups)))\n\nn = int(input())\nrow = input().strip()\nencrypt_japanese_crossword(n, row)"}
{"solution": "def process_operations(n, m, p, sequence, operations):\n    stack = []\n    cursor = p - 1\n\n    for i in range(n):\n        if sequence[i] == '(':\n            stack.append(i)\n        else:\n            start = stack.pop()\n            if start < cursor < i:\n                cursor -= 1\n\n    for op in operations:\n        if op == 'L':\n            cursor -= 1\n        elif op == 'R':\n            cursor += 1\n        elif op == 'D':\n            start = stack[stack.index(cursor)]\n            end = cursor\n            while stack[stack.index(start)] != stack[stack.index(end)]:\n                end = stack[stack.index(end) + 1]\n            del sequence[start:end + 1]\n            del stack[stack.index(start):stack.index(end) + 1]\n            if start <= cursor <= end:\n                cursor = start if start < cursor else start - 1\n\n    return ''.join(sequence)\n\nn, m, p = map(int, input().split())\nsequence = list(input())\noperations = input()\n\nprint(process_operations(n, m, p, sequence, operations))"}
{"solution": "def find_number(n, queries):\n    lower_bound = -2 * 10 ** 9\n    upper_bound = 2 * 10 ** 9\n\n    for query in queries:\n        sign, x, answer = query\n        x = int(x)\n\n        if answer == 'Y':\n            if sign == '>':\n                lower_bound = max(lower_bound, x + 1)\n            elif sign == '<':\n                upper_bound = min(upper_bound, x - 1)\n            elif sign == '>=':\n                lower_bound = max(lower_bound, x)\n            elif sign == '<=':\n                upper_bound = min(upper_bound, x)\n        else:\n            if sign == '>':\n                upper_bound = min(upper_bound, x)\n            elif sign == '<':\n                lower_bound = max(lower_bound, x)\n            elif sign == '>=':\n                upper_bound = min(upper_bound, x - 1)\n            elif sign == '<=':\n                lower_bound = max(lower_bound, x + 1)\n\n    if lower_bound <= upper_bound:\n        return lower_bound\n    else:\n        return \"Impossible\"\n\nn = int(input())\nqueries = [input().split() for _ in range(n)]\nprint(find_number(n, queries))"}
{"solution": "import math\n\ndef count_periods(a, b):\n    total_length = a + b\n    periods = set()\n\n    # Check for periods that divide the total length\n    for i in range(1, int(math.sqrt(total_length)) + 1):\n        if total_length % i == 0:\n            periods.add(i)\n            periods.add(total_length // i)\n\n    # Check for periods that don't divide the total length\n    if a == b:\n        periods.add(total_length // 2)\n\n    return len(periods)\n\na, b = map(int, input().split())\nprint(count_periods(a, b))"}
{"solution": "def generate_names(n, k, conditions):\n    # Predefined list of unique names\n    names = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\n\n    # Initialize the result list with the first k names\n    result = names[:k]\n\n    for i in range(1, n - k + 1):\n        if conditions[i - 1] == \"YES\":\n            # If the group should be effective, add a new unique name\n            result.append(names[k + i - 1])\n        else:\n            # If the group should not be effective, repeat the last name\n            result.append(result[-1])\n\n    return result\n\n# Read input\nn, k = map(int, input().split())\nconditions = input().split()\n\n# Generate and print the names\nnames = generate_names(n, k, conditions)\nprint(\" \".join(names))"}
{"solution": "def min_operations_to_equal(a, b):\n    def count_factors(n, factor):\n        count = 0\n        while n % factor == 0:\n            n //= factor\n            count += 1\n        return count, n\n\n    # Count the number of times we can divide by 2, 3, and 5\n    a2, a = count_factors(a, 2)\n    a3, a = count_factors(a, 3)\n    a5, a = count_factors(a, 5)\n\n    b2, b = count_factors(b, 2)\n    b3, b = count_factors(b, 3)\n    b5, b = count_factors(b, 5)\n\n    # If the remaining parts are not equal, return -1\n    if a != b:\n        return -1\n\n    # Calculate the total number of operations needed\n    operations = abs(a2 - b2) + abs(a3 - b3) + abs(a5 - b5)\n\n    return operations\n\n# Get input from the user\na, b = map(int, input().split())\n\n# Print the minimum number of operations required to make the two pieces of cheese equal\nprint(min_operations_to_equal(a, b))"}
{"solution": "def min_cost(n, a, b, suits):\n    cost = 0\n    for i in range(n // 2):\n        if suits[i] == suits[n - i - 1]:\n            continue\n        elif suits[i] == 2:\n            suits[i] = suits[n - i - 1]\n            cost += a if suits[i] == 0 else b\n        elif suits[n - i - 1] == 2:\n            suits[n - i - 1] = suits[i]\n            cost += a if suits[n - i - 1] == 0 else b\n        else:\n            return -1\n    if n % 2 == 1 and suits[n // 2] == 2:\n        cost += min(a, b)\n    return cost\n\nn, a, b = map(int, input().split())\nsuits = list(map(int, input().split()))\nprint(min_cost(n, a, b, suits))"}
{"solution": "def print_cube(k):\n    if k % 2 != 0:\n        print(-1)\n        return\n\n    for i in range(k):\n        for j in range(k):\n            if (i + j) % 2 == 0:\n                print(\"w\", end=\"\")\n            else:\n                print(\"b\", end=\"\")\n        print()\n\nk = int(input())\nprint_cube(k)"}
{"solution": "def largest_lovely_number(n):\n    import math\n    from collections import Counter\n\n    def prime_factors(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            while (n % i) == 0:\n                factors.append(i)\n                n //= i\n            i += 1\n        if n > 1:\n            factors.append(n)\n        return factors\n\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n\n    lovely_number = 1\n    for prime, count in factor_counts.items():\n        lovely_number *= prime\n\n    return lovely_number\n\nn = int(input())\nprint(largest_lovely_number(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    # Check for adjacent occupied seats\n    for i in range(n - 1):\n        if seating[i] == '1' and seating[i + 1] == '1':\n            return \"No\"\n\n    # Check for possible additional seating\n    for i in range(n):\n        if seating[i] == '0':\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                return \"No\"\n\n    return \"Yes\"\n\n# Get input\nn = int(input())\nseating = input().strip()\n\n# Print output\nprint(is_maximal_seating(n, seating))"}
{"solution": "def find_possible_lengths(n, a):\n    possible_lengths = []\n    for k in range(1, n + 1):\n        x = [0] * k\n        x[0] = a[1]\n        for i in range(2, n + 1):\n            x[i % k] = a[i] - a[i - 1]\n        if all(x[i % k] == x[0] for i in range(1, k)):\n            possible_lengths.append(k)\n    return possible_lengths\n\nn = int(input())\na = [0] + list(map(int, input().split()))\npossible_lengths = find_possible_lengths(n, a)\nprint(len(possible_lengths))\nprint(' '.join(map(str, possible_lengths)))"}
{"solution": "# Get the input scores\nscores = list(map(int, input().split()))\n\n# Calculate the total sum of scores\ntotal_sum = sum(scores)\n\n# Check if the total sum is odd, if so, it's impossible to form two teams with equal scores\nif total_sum % 2 != 0:\n    print(\"NO\")\nelse:\n    # Calculate the target score for each team\n    target_score = total_sum // 2\n\n    # Sort the scores in descending order\n    scores.sort(reverse=True)\n\n    # Initialize a variable to store the current score\n    current_score = 0\n\n    # Iterate over the scores\n    for score in scores:\n        # Add the score to the current score\n        current_score += score\n\n        # If the current score is equal to the target score, it's possible to form two teams with equal scores\n        if current_score == target_score:\n            print(\"YES\")\n            break\n\n        # If the current score is greater than the target score, it's impossible to form two teams with equal scores\n        elif current_score > target_score:\n            print(\"NO\")\n            break"}
{"solution": "from bisect import bisect_right\n\n# Precompute the list of 2-3 integers\nMAX_VALUE = 2 * 10 ** 9\npowers_of_two = [2 ** i for i in range(34)]\npowers_of_three = [3 ** i for i in range(21)]\ntwo_three_integers = set()\n\nfor i in powers_of_two:\n    for j in powers_of_three:\n        if i * j <= MAX_VALUE:\n            two_three_integers.add(i * j)\n        else:\n            break\n\ntwo_three_integers = sorted(list(two_three_integers))\n\n# Function to count 2-3 integers in the given range\ndef count_two_three_integers(l, r):\n    return bisect_right(two_three_integers, r) - bisect_right(two_three_integers, l - 1)\n\n# Read input\nl, r = map(int, input().split())\n\n# Print output\nprint(count_two_three_integers(l, r))"}
{"solution": "def calculate_candies_eaten(n, k):\n    # Initialize the number of candies eaten to 0\n    candies_eaten = 0\n\n    # Initialize the number of candies in the box to 0\n    candies_in_box = 0\n\n    # Perform each action\n    for i in range(1, n + 1):\n        # If the box is empty, put i candies into the box\n        if candies_in_box == 0:\n            candies_in_box += i\n        # If the box contains at least one candy, take one candy out and eat it\n        else:\n            candies_in_box -= 1\n            candies_eaten += 1\n\n    # Calculate the excess candies in the box\n    excess_candies = candies_in_box - k\n\n    # Add the excess candies to the number of candies eaten\n    candies_eaten += excess_candies\n\n    return candies_eaten\n\n# Read the input\nn, k = map(int, input().split())\n\n# Calculate the number of candies eaten\ncandies_eaten = calculate_candies_eaten(n, k)\n\n# Print the result\nprint(candies_eaten)"}
{"solution": "# Read the number of line segments\nn = int(input())\n\n# Read the lengths of line segments\nsegments = list(map(int, input().split()))\n\n# Sort the lengths of line segments\nsegments.sort()\n\n# Check if there are three line segments that can form a non-degenerate triangle\nfor i in range(n - 2):\n    if segments[i] + segments[i + 1] > segments[i + 2]:\n        print(\"YES\")\n        exit()\n\n# If no three line segments can form a non-degenerate triangle\nprint(\"NO\")"}
{"solution": "def can_achieve_toys(x, y):\n    # If there are no original toys, it's impossible to achieve the desired configuration\n    if y == 0:\n        return False\n\n    # If the number of copies is greater than the number of original toys, it's impossible to achieve the desired configuration\n    if x > y:\n        return False\n\n    # If the number of copies is odd, it's impossible to achieve the desired configuration\n    if x % 2 != 0:\n        return False\n\n    # Calculate the number of times the machine needs to be applied to original toys\n    original_applications = y - 1\n\n    # Calculate the number of copies that can be obtained from original toys\n    copies_from_originals = original_applications\n\n    # If the number of copies that can be obtained from original toys is less than the desired number of copies, it's impossible to achieve the desired configuration\n    if copies_from_originals < x:\n        return False\n\n    # Calculate the number of times the machine needs to be applied to copies\n    copy_applications = (x - original_applications) // 2\n\n    # Calculate the number of original toys that can be obtained from copies\n    originals_from_copies = copy_applications\n\n    # Calculate the total number of original toys\n    total_originals = original_applications + originals_from_copies\n\n    # If the total number of original toys is equal to the desired number of original toys, it's possible to achieve the desired configuration\n    return total_originals == y\n\n# Read the input\nx, y = map(int, input().split())\n\n# Print the output\nprint(\"Yes\" if can_achieve_toys(x, y) else \"No\")"}
{"solution": "# Read input\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Calculate initial total rating\ninitial_rating = sum(skill // 10 for skill in skills)\n\n# Calculate units needed to increase each skill to the next multiple of 10\nunits_needed = sorted((10 - skill % 10) for skill in skills if skill < 100)\n\n# Allocate units to increase skills\nfor i in range(len(units_needed)):\n    if k >= units_needed[i]:\n        k -= units_needed[i]\n        skills[skills.index(min(skill for skill in skills if skill < 100))] += units_needed[i]\n    else:\n        break\n\n# Recalculate total rating\nmax_rating = sum(skill // 10 for skill in skills)\n\n# Print output\nprint(max_rating)"}
{"solution": "def find_smallest_pretty_integer(n, m, list1, list2):\n    # Convert lists to sets for faster lookup\n    set1 = set(list1)\n    set2 = set(list2)\n\n    # Check for common digits\n    common_digits = set1.intersection(set2)\n    if common_digits:\n        return min(common_digits)\n\n    # If no common digits, find the smallest combination\n    min1 = min(list1)\n    min2 = min(list2)\n\n    # Form the smallest two-digit number\n    smallest_pretty = min(int(str(min1) + str(min2)), int(str(min2) + str(min1)))\n    return smallest_pretty\n\n# Read input\nn, m = map(int, input().split())\nlist1 = list(map(int, input().split()))\nlist2 = list(map(int, input().split()))\n\n# Find and print the smallest pretty integer\nprint(find_smallest_pretty_integer(n, m, list1, list2))"}
{"solution": "# Get the input\nn, k = map(int, input().split())\n\n# Calculate the total time available for solving problems\ntotal_time = 240 - k\n\n# Initialize the time needed to solve problems and the number of problems solved\ntime_needed = 0\nproblems_solved = 0\n\n# Iterate over the problems\nfor i in range(1, n + 1):\n    # Calculate the time needed to solve the current problem\n    time_needed += 5 * i\n\n    # If Limak has enough time to solve the current problem, increment the number of problems solved\n    if time_needed <= total_time:\n        problems_solved += 1\n    else:\n        break\n\n# Print the maximum possible number of problems Limak can solve\nprint(problems_solved)"}
{"solution": "def max_teams(n, x, y, a):\n    a.sort()\n    double_sided = x\n    single_sided = y\n    count = 0\n\n    for pages in a:\n        double_needed = pages // 2\n        single_needed = pages % 2\n\n        if double_needed <= double_sided:\n            double_sided -= double_needed\n            if single_needed <= single_sided:\n                single_sided -= single_needed\n                count += 1\n            else:\n                double_sided += double_needed\n                break\n        else:\n            remaining_pages = pages - 2 * double_sided\n            if remaining_pages <= single_sided:\n                single_sided -= remaining_pages\n                double_sided = 0\n                count += 1\n            else:\n                break\n\n    return count\n\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\nprint(max_teams(n, x, y, a))"}
{"solution": "def count_divisors(n):\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return len(divisors)\n\n# Read input\nb = int(input().strip())\n\n# Calculate the number of distinct values\nresult = count_divisors(b)\n\n# Print the result\nprint(result)"}
{"solution": "# Read the input\nn = int(input())\nbumpers = input()\n\n# Initialize the count of positions from which the ball will fall\ncount = 0\n\n# Iterate over all positions\nfor i in range(n):\n    # Simulate the ball's movement\n    pos = i\n    while 0 < pos < n:\n        if bumpers[pos] == '<':\n            pos -= 1\n        else:\n            pos += 1\n        # If the ball falls off the field, break the loop\n        if pos <= 0 or pos >= n:\n            break\n    # If the ball falls off the field, increment the count\n    if pos <= 0 or pos >= n:\n        count += 1\n\n# Print the result\nprint(count)"}
{"solution": "from collections import Counter\n\ndef max_rectangle_area(n, sticks):\n    # Count the frequency of each stick length\n    freq = Counter(sticks)\n\n    # Initialize the maximum area\n    max_area = 0\n\n    # Iterate over the stick lengths\n    for length in freq:\n        # Check if there are at least two sticks of this length\n        if freq[length] >= 2:\n            # Check if there are two sticks of this length and one stick of this length - 1\n            if freq[length - 1] >= 1:\n                # Calculate the number of rectangles that can be made\n                num_rectangles = min(freq[length] // 2, freq[length - 1])\n                # Add the area of these rectangles to the maximum area\n                max_area += num_rectangles * length * (length - 1)\n                # Decrease the frequency of these sticks\n                freq[length] -= num_rectangles * 2\n                freq[length - 1] -= num_rectangles\n\n    # Return the maximum area\n    return max_area\n\n# Read the input\nn = int(input())\nsticks = list(map(int, input().split()))\n\n# Print the maximum area\nprint(max_rectangle_area(n, sticks))"}
{"solution": "from collections import Counter\n\ndef restore_numbers(n, numbers):\n    # Create a dictionary to map letters to digits\n    letter_to_digit = {}\n\n    # Create a counter to store the frequency of each letter\n    letter_freq = Counter()\n\n    # Count the frequency of each letter\n    for number in numbers:\n        for letter in number:\n            letter_freq[letter] += 1\n\n    # Sort the letters by their frequency in descending order\n    sorted_letters = sorted(letter_freq.keys(), key=lambda x: letter_freq[x], reverse=True)\n\n    # Assign digits to letters based on their frequency\n    for i, letter in enumerate(sorted_letters):\n        letter_to_digit[letter] = str(i)\n\n    # Restore the numbers\n    restored_numbers = []\n    for number in numbers:\n        restored_number = ''\n        for letter in number:\n            restored_number += letter_to_digit[letter]\n        restored_numbers.append(int(restored_number))\n\n    # Return the minimum possible sum of all restored numbers\n    return sum(restored_numbers)\n\n# Read the input\nn = int(input())\nnumbers = []\nfor _ in range(n):\n    numbers.append(input())\n\n# Print the output\nprint(restore_numbers(n, numbers))"}
{"solution": "def max_teams(n, m):\n    # Binary search to find the maximum number of teams\n    low, high = 0, min(n, m, (n + m) // 3)\n\n    while low < high:\n        mid = (low + high + 1) // 2\n        if mid <= n and mid <= m and 2 * mid <= n + m:\n            low = mid\n        else:\n            high = mid - 1\n\n    return low\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    n = len(s)\n\n    # Check for \"AB\" followed by \"BA\"\n    found_AB = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"AB\":\n            found_AB = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"BA\":\n                    print(\"YES\")\n                    return\n            break\n\n    # Check for \"BA\" followed by \"AB\"\n    found_BA = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"BA\":\n            found_BA = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"AB\":\n                    print(\"YES\")\n                    return\n            break\n\n    # If neither condition is met\n    print(\"NO\")\n\n# Get user input\ns = input().strip()\ncheck_substrings(s)"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    k = int(input())\n    b = list(map(int, input().split()))\n\n    # Simulate the eating process\n    actions = []\n    while a != b:\n        for i in range(len(a)):\n            # Check if the monster can eat the monster to its left\n            if i > 0 and a[i] > a[i-1]:\n                a[i] += a[i-1]\n                actions.append(f\"{i+1} L\")\n                del a[i-1]\n                break\n            # Check if the monster can eat the monster to its right\n            elif i < len(a) - 1 and a[i] > a[i+1]:\n                a[i] += a[i+1]\n                actions.append(f\"{i+1} R\")\n                del a[i+1]\n                break\n        else:\n            # No valid action found\n            print(\"NO\")\n            return\n\n    # Print the result\n    print(\"YES\")\n    for action in actions:\n        print(action)\n\nsolve()"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    return sys.stdin.readline\n\ndef write_output(x):\n    return sys.stdout.write(x)\n\ndef hopcroft_karp(graph):\n    pair_u = [-1] * len(graph)\n    pair_v = [-1] * len(graph[0])\n\n    def bfs():\n        queue = [u for u in range(len(graph)) if pair_u[u] == -1]\n        dist = [-1] * len(graph)\n        for u in queue:\n            dist[u] = 0\n        i = 0\n        while i < len(queue):\n            u = queue[i]\n            for v in graph[u]:\n                if pair_v[v] == -1:\n                    return True, u, v\n                if dist[pair_v[v]] == dist[u] + 1:\n                    queue.append(pair_v[v])\n                    dist[pair_v[v]] = dist[u] + 1\n            i += 1\n        return False,\n\n    def dfs(u):\n        for v in graph[u]:\n            if pair_v[v] == -1 or dfs(pair_v[v]):\n                pair_v[v] = u\n                pair_u[u] = v\n                return True\n        return False\n\n    while True:\n        bfs_result = bfs()\n        if len(bfs_result) == 1:\n            break\n        _, u, v = bfs_result\n        if dfs(u):\n            pair_u[u] = v\n            pair_v[v] = u\n    return sum(u != -1 for u in pair_u)\n\ndef on_segment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n            q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0\n    elif val > 0:\n        return 1\n    else:\n        return 2\n\ndef do_intersect(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False\n\ndef main():\n    read_line = read_input()\n    write_line = write_output\n\n    num_rebel_ships, num_bases = map(int, read_line().split())\n    rebel_ships = [tuple(map(int, read_line().split())) for _ in range(num_rebel_ships)]\n    bases = [tuple(map(int, read_line().split())) for _ in range(num_bases)]\n\n    graph = [[] for _ in range(num_rebel_ships)]\n    for i in range(num_rebel_ships):\n        for j in range(num_bases):\n            if not any(do_intersect(rebel_ships[i], bases[j], rebel_ships[k], bases[l])\n                       for k in range(num_rebel_ships) for l in range(num_bases)\n                       if (k, l) != (i, j)):\n                graph[i].append(j)\n\n    if hopcroft_karp(graph) == num_rebel_ships:\n        write_line(\"Yes\\n\")\n    else:\n        write_line(\"No\\n\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Read the input\nn = int(input())\nnumbers = list(map(int, input().split()))\n\n# Initialize the maximum power of 2 and the count of numbers divisible by this power\nmax_power = 0\ncount = 0\n\n# Iterate over the numbers\nfor num in numbers:\n    # Calculate the power of 2 for the current number\n    power = 0\n    while num % 2 == 0:\n        num //= 2\n        power += 1\n    # Update the maximum power and the count\n    if power > max_power:\n        max_power = power\n        count = 1\n    elif power == max_power:\n        count += 1\n\n# Print the result\nprint(2 ** max_power, count)"}
{"solution": "# Get the input numbers\nn, m = map(int, input().split())\n\n# Initialize the number of clicks\nclicks = 0\n\n# While n is less than m\nwhile n < m:\n    # If m is odd, subtract 1 from m\n    if m % 2 != 0:\n        m -= 1\n        clicks += 1\n    # Divide m by 2\n    m //= 2\n    clicks += 1\n\n# Add the difference between n and m to the number of clicks\nclicks += n - m\n\n# Print the result\nprint(clicks)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n = int(read_input())\n    segments = [list(map(int, read_input().split())) for _ in range(n)]\n    segments.sort(key=lambda x: x[0])\n\n    graph = defaultdict(list)\n    for i, (l1, r1) in enumerate(segments):\n        for j, (l2, r2) in enumerate(segments[:i]):\n            if l2 < r1 < r2 or l1 < r2 < r1:\n                graph[i].append(j)\n                graph[j].append(i)\n\n    visited = [False] * n\n    parent = [-1] * n\n\n    def dfs(node, parent_node):\n        visited[node] = True\n        parent[node] = parent_node\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if not dfs(neighbor, node):\n                    return False\n            elif neighbor != parent_node:\n                return False\n        return True\n\n    if not dfs(0, -1):\n        print(\"NO\")\n        return\n\n    if any(not visited[i] for i in range(n)):\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_ddos_attack_duration(n, requests):\n    max_duration = 0\n    current_duration = 0\n    current_sum = 0\n\n    for i in range(n):\n        current_sum += requests[i]\n        current_duration += 1\n\n        if current_sum > 100 * current_duration:\n            max_duration = max(max_duration, current_duration)\n        else:\n            current_sum = 0\n            current_duration = 0\n\n    return max_duration\n\nn = int(input())\nrequests = list(map(int, input().split()))\n\nresult = find_ddos_attack_duration(n, requests)\nprint(result)"}
{"solution": "def check_dissatisfaction(n, k, sequence):\n    # Break down the problem into smaller parts\n    # Identify all the segments of consecutive 'N's in the sequence\n    segments = []\n    current_segment = 0\n    for i in range(n):\n        if sequence[i] == 'N':\n            current_segment += 1\n        else:\n            if current_segment > 0:\n                segments.append(current_segment)\n                current_segment = 0\n    if current_segment > 0:\n        segments.append(current_segment)\n\n    # Handle uncertainty by considering '?' symbols\n    # Evaluate different possibilities and how these affect the maximum number of consecutive 'N's\n    max_consecutive_n = 0\n    for i in range(len(segments) + 1):\n        for j in range(i + 1, len(segments) + 2):\n            max_consecutive_n = max(max_consecutive_n, j - i - 1 + sum(segments[i:j]))\n\n    # Logical analysis to determine if there is any configuration of the sequence that results in exactly k consecutive 'N's\n    if max_consecutive_n == k:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Understanding the problem\nn, k = map(int, input().split())\nsequence = input()\n\n# Verification\nprint(check_dissatisfaction(n, k, sequence))"}
{"solution": "# Read input\nN, X, D = map(int, input().split())\n\n# Calculate the sequence\nsequence = [X + i * D for i in range(N)]\n\n# Initialize variables\npossible_values = set()\n\n# Iterate through all possible subsets of the sequence\nfor i in range(1 << N):\n    takahashi_sum = 0\n    aoki_sum = 0\n    # Iterate through each element in the sequence\n    for j in range(N):\n        # Check if the j-th element is included in the subset\n        if i & (1 << j):\n            takahashi_sum += sequence[j]\n        else:\n            aoki_sum += sequence[j]\n    # Add the difference between Takahashi's sum and Aoki's sum to the set of possible values\n    possible_values.add(takahashi_sum - aoki_sum)\n\n# Print the number of possible values\nprint(len(possible_values))"}
{"solution": "def did_anton_perform_good(n, participants):\n    for participant in participants:\n        handle, before, after = participant\n        if before >= 2400 and after > before:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\nparticipants = [input().split() for _ in range(n)]\nparticipants = [(handle, int(before), int(after)) for handle, before, after in participants]\n\n# Print output\nprint(did_anton_perform_good(n, participants))"}
{"solution": "# Get the binary input from the user\nbinary_input = input()\n\n# Convert the binary input to an integer\ns = int(binary_input, 2)\n\n# Initialize the count of missed trains\nmissed_trains = 0\n\n# Initialize the train departure time\ntrain_time = 1\n\n# Loop until the train departure time is less than or equal to s\nwhile train_time <= s:\n    # Increment the missed trains count\n    missed_trains += 1\n\n    # Calculate the next train departure time\n    train_time *= 4\n\n# Print the number of missed trains\nprint(missed_trains)"}
{"solution": "def min_rows(matrix):\n    n, m = len(matrix), len(matrix[0])\n    for i in range(1, n // 2 + 1):\n        if n % i == 0 and matrix[:i] == matrix[i:2*i]:\n            return i\n    return n\n\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\nprint(min_rows(matrix))"}
{"solution": "# Read the number of orders\nn = int(input())\n\n# Create a list to store the orders\norders = []\n\n# Read the orders and store them in the list\nfor _ in range(n):\n    l, r = map(int, input().split())\n    orders.append((l, r))\n\n# Sort the orders by their end times\norders.sort(key=lambda x: x[1])\n\n# Initialize the count of accepted orders and the end time of the last accepted order\ncount = 1\nlast_end = orders[0][1]\n\n# Iterate through the orders\nfor i in range(1, n):\n    # If the current order does not intersect with the last accepted order, accept it\n    if orders[i][0] >= last_end:\n        count += 1\n        last_end = orders[i][1]\n\n# Print the maximal number of orders that can be accepted\nprint(count)"}
{"solution": "def can_rearrange(n, k, x, y):\n    max_tables = max_formulas = 0\n    for i in range(n):\n        max_tables = max(max_tables - x[i], 0) + x[i]\n        max_formulas = max(max_formulas - y[i], 0) + y[i]\n        if max_tables > k or max_formulas > k:\n            return False\n    return True\n\nn, k = map(int, input().split())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\nif can_rearrange(n, k, x, y):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def can_guarantee_victory(n, k, coefficients):\n    # Check if the game is already over\n    if coefficients[0] == k:\n        return False\n\n    # Check if the human can set the coefficient a_n to guarantee victory\n    if coefficients[n] == '?':\n        return True\n\n    # Calculate the remainder of the polynomial division by x - k\n    remainder = coefficients[n]\n    for i in range(n - 1, -1, -1):\n        remainder = remainder * k + coefficients[i]\n        remainder %= k\n\n    # Check if the human can set a coefficient to make the remainder zero\n    for i in range(n, -1, -1):\n        if coefficients[i] == '?':\n            if (remainder - coefficients[i - 1]) % k == 0:\n                return True\n            remainder = (remainder - coefficients[i - 1]) % k\n\n    return False\n\n# Read the input\nn, k = map(int, input().split())\ncoefficients = []\nfor _ in range(n + 1):\n    coefficient = input()\n    if coefficient == '?':\n        coefficients.append('?')\n    else:\n        coefficients.append(int(coefficient))\n\n# Determine if the human can guarantee victory\nif can_guarantee_victory(n, k, coefficients):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def smallest_starting_number(X_2):\n    # Generate a list of prime numbers up to X_2\n    primes = [True] * (X_2 + 1)\n    p = 2\n    while p * p <= X_2:\n        if primes[p] == True:\n            for i in range(p * p, X_2 + 1, p):\n                primes[i] = False\n        p += 1\n\n    # Find the smallest possible starting number X_0\n    for X_0 in range(3, X_2 + 1):\n        # Check if X_0 is not divisible by any prime number less than X_0\n        if all(X_0 % p != 0 for p in range(2, X_0) if primes[p]):\n            # Check if there exists a prime number p such that p divides X_2\n            if any(X_2 % p == 0 for p in range(2, X_0) if primes[p]):\n                return X_0\n\n# Read the input\nX_2 = int(input())\n\n# Print the output\nprint(smallest_starting_number(X_2))"}
{"solution": "def solve(n, p):\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    for i in range(n + 1):\n        j = 0\n        while i + (1 << j) - p <= n:\n            dp[i + (1 << j) - p] = min(dp[i + (1 << j) - p], dp[i] + 1)\n            j += 1\n\n    return dp[n] if dp[n] != float('inf') else -1\n\nn, p = map(int, input().split())\nprint(solve(n, p))"}
{"solution": "n, k = map(int, input().split())\nS = list(input())\n\n# Change the first digit to 1 if n > 1, otherwise 0\nif n > 1:\n    S[0] = '1'\n    k -= 1\n\n# Change subsequent digits to 0 until k changes are exhausted or all digits are minimized\nfor i in range(1, n):\n    if k > 0 and S[i] != '0':\n        S[i] = '0'\n        k -= 1\n\n# Ensure the resulting number has no leading zeroes\nif S[0] == '0' and n > 1:\n    S[0] = '1'\n    S[1] = '0'\n\nprint(''.join(S))"}
{"solution": "def sieve_of_eratosthenes(n):\n    primes = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (primes[p] == True):\n            for i in range(p * p, n+1, p):\n                primes[i] = False\n        p += 1\n    return primes\n\ndef count_numbers(cnt_1, cnt_2, x, y):\n    primes = sieve_of_eratosthenes(30000)\n    v = 1\n    while True:\n        if (v - v//x - v//y) >= cnt_1 and (v - (v-cnt_1)//y) >= cnt_2:\n            return v\n        v += 1\n\ncnt_1, cnt_2, x, y = map(int, input().split())\nprint(count_numbers(cnt_1, cnt_2, x, y))"}
{"solution": "def main():\n    n, sx, sy, dx, dy, t = map(int, input().split())\n\n    # Calculate the number of raspberry bushes eaten by the bear\n    raspberries_eaten = (sx + sy + dx + dy - 2) * t // 2\n\n    # Calculate the new speed of the bear\n    new_dx = dx + raspberries_eaten\n    new_dy = dy + raspberries_eaten\n\n    # Calculate the new position of the bear\n    new_x = ((sx + new_dx - 1 + t) % n) + 1\n    new_y = ((sy + new_dy - 1 + t) % n) + 1\n\n    print(new_x, new_y)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve_nice_word(word):\n    # Initialize a set to store the required letters\n    required_letters = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n\n    # Initialize a list to store the result\n    result = list(word)\n\n    # Initialize a variable to store the start index of the substring\n    start = 0\n\n    # Iterate over the word\n    for i in range(len(word)):\n        # If the current character is a letter, remove it from the required letters\n        if word[i] != '?':\n            required_letters.discard(word[i])\n\n        # If the current character is a question mark, try to replace it with a required letter\n        else:\n            # If there are no required letters, return -1\n            if not required_letters:\n                return -1\n\n            # If there are required letters, replace the question mark with the first required letter\n            result[i] = required_letters.pop()\n\n        # If the substring length is 26, remove the first character from the required letters\n        if i - start + 1 == 26:\n            if word[start] != '?':\n                required_letters.add(word[start])\n            start += 1\n\n    # If there are still required letters, return -1\n    if required_letters:\n        return -1\n\n    # If there are no required letters, return the result\n    return ''.join(result)\n\n# Read the input\nword = input()\n\n# Print the output\nprint(solve_nice_word(word))"}
{"solution": "def divide_apples(n, weights):\n    # Count the number of 100g and 200g apples\n    count_100 = weights.count(100)\n    count_200 = weights.count(200)\n\n    # If the total weight is odd, it's impossible to divide them equally\n    if sum(weights) % 200 != 0:\n        return \"NO\"\n\n    # If there are no 200g apples, it's impossible to divide them equally\n    if count_200 == 0:\n        return \"NO\"\n\n    # If the number of 100g apples is more than twice the number of 200g apples,\n    # it's impossible to divide them equally\n    if count_100 > 2 * count_200:\n        return \"NO\"\n\n    # If the number of 100g apples is less than twice the number of 200g apples,\n    # it's impossible to divide them equally\n    if count_100 < 2 * count_200:\n        return \"NO\"\n\n    # If none of the above conditions are met, it's possible to divide them equally\n    return \"YES\"\n\n# Read the input\nn = int(input())\nweights = list(map(int, input().split()))\n\n# Print the output\nprint(divide_apples(n, weights))"}
{"solution": "def min_time(building):\n    n, m = len(building), len(building[0])\n    dp = [[float('inf')] * m for _ in range(n)]\n\n    # Initialize the ground floor\n    for i in range(m):\n        if building[n - 1][i] == '1':\n            dp[n - 1][i] = i\n\n    # Fill the dp table\n    for i in range(n - 2, -1, -1):\n        left, right = m - 1, m - 1\n        while left >= 0:\n            if building[i][left] == '1':\n                dp[i][left] = min(dp[i][left], dp[i + 1][left] + 2 * (m - 1 - left))\n            else:\n                dp[i][left] = dp[i + 1][left]\n            left -= 1\n\n        while right >= 0:\n            if building[i][right] == '1':\n                dp[i][right] = min(dp[i][right], dp[i + 1][right] + 2 * (right - 1))\n            else:\n                dp[i][right] = dp[i + 1][right]\n            right -= 1\n\n    return min(dp[0])\n\nn, m = map(int, input().split())\nbuilding = [input() for _ in range(n)]\nprint(min_time(building))"}
{"solution": "def find_min_trap_cost(n, costs, transitions):\n    visited = [False] * n\n    in_stack = [False] * n\n    min_cost = 0\n\n    def dfs(node):\n        stack = []\n        while True:\n            if visited[node]:\n                if in_stack[node]:\n                    # Found a cycle, calculate the minimum cost in this cycle\n                    cycle_min_cost = float('inf')\n                    while stack:\n                        cycle_node = stack.pop()\n                        in_stack[cycle_node] = False\n                        cycle_min_cost = min(cycle_min_cost, costs[cycle_node])\n                        if cycle_node == node:\n                            break\n                    return cycle_min_cost\n                else:\n                    return 0\n            visited[node] = True\n            in_stack[node] = True\n            stack.append(node)\n            node = transitions[node] - 1\n\n    for i in range(n):\n        if not visited[i]:\n            min_cost += dfs(i)\n\n    return min_cost\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(find_min_trap_cost(n, costs, transitions))"}
{"solution": "# Get the input\nn, a, b = map(int, input().split())\n\n# Calculate the final position\nfinal_position = (a + b) % n\n\n# If the final position is 0, it means Vasya stayed at his entrance\nif final_position == 0:\n    final_position = n\n\n# Print the result\nprint(final_position)"}
{"solution": "def min_arithmetic_progressions(seq):\n    n = len(seq)\n    dp = [0] * n\n    prev = [-1] * n\n\n    for i in range(1, n):\n        dp[i] = dp[i-1] + 1\n        for j in range(i-1, -1, -1):\n            if seq[j] != -1 and seq[i] != -1 and (seq[i] - seq[j]) % (i - j) == 0:\n                diff = (seq[i] - seq[j]) // (i - j)\n                if j == 0 or prev[j-1] == -1 or seq[j-1] == -1 or seq[j-1] + diff == seq[j]:\n                    if dp[i] > dp[j] + 1:\n                        dp[i] = dp[j] + 1\n                        prev[i] = j\n\n    return n - dp[-1]\n\nn = int(input())\nseq = list(map(int, input().split()))\nprint(min_arithmetic_progressions(seq))"}
{"solution": "def max_beauty(n, k, s):\n    # Initialize variables\n    max_len = 0\n    curr_len = 1\n    prev_char = s[0]\n    changes = 0\n\n    # Iterate over the string\n    for i in range(1, n):\n        # If the current character is the same as the previous one\n        if s[i] == prev_char:\n            curr_len += 1\n        # If the current character is different from the previous one\n        else:\n            # If we can make a change\n            if changes < k:\n                changes += 1\n                curr_len += 1\n            # If we can't make a change\n            else:\n                # Update the maximum length\n                max_len = max(max_len, curr_len)\n                # Reset the current length\n                curr_len = 1\n            # Update the previous character\n            prev_char = s[i]\n\n    # Update the maximum length\n    max_len = max(max_len, curr_len)\n\n    # If we still have changes left\n    if changes < k:\n        # Update the maximum length\n        max_len = max(max_len, min(n, k - changes + 1))\n\n    return max_len\n\n# Read the input\nn, k = map(int, input().split())\ns = input()\n\n# Print the output\nprint(max_beauty(n, k, s))"}
{"solution": "# Read input\nn = int(input())\nseats = list(map(int, input().split()))\n\n# Initialize total seats and coalition list\ntotal_seats = seats[0]\ncoalition = [1]\n\n# Sort the parties by seats in descending order\nparties = sorted(range(1, n + 1), key=lambda i: seats[i], reverse=True)\n\n# Iterate through the parties\nfor party in parties:\n    # If Alice's party has at least twice the seats of the current party\n    if seats[0] >= 2 * seats[party - 1]:\n        # Add the party to the coalition\n        coalition.append(party)\n        total_seats += seats[party - 1]\n        # If the coalition has a strict majority, break the loop\n        if total_seats > sum(seats) / 2:\n            break\n\n# Print the result\nif total_seats > sum(seats) / 2:\n    print(len(coalition))\n    print(' '.join(map(str, coalition)))\nelse:\n    print(0)"}
{"solution": "def max_reward(n):\n    harmonic_sum = 0.0\n    for i in range(1, n + 1):\n        harmonic_sum += 1.0 / i\n    return harmonic_sum\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the maximum reward\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "def max_children(n):\n    k = 0\n    while (k * (k + 1)) // 2 <= n:\n        k += 1\n    k -= 1\n    remaining_candies = n - (k * (k + 1)) // 2\n    distribution = list(range(1, k + 1))\n    distribution[-1] += remaining_candies\n    return k, distribution\n\nn = int(input())\nk, distribution = max_children(n)\nprint(k)\nprint(' '.join(map(str, distribution)))"}
{"solution": "def calculate_modulo(n, m):\n    # If n is greater than or equal to the number of bits in m,\n    # then m mod 2^n is equal to m itself\n    if n >= m.bit_length():\n        return m\n    else:\n        # If the least significant n bits of m are all zeros,\n        # then m mod 2^n is equal to m itself\n        if m & ((1 << n) - 1) == 0:\n            return m\n        else:\n            # Otherwise, m mod 2^n is equal to the least significant n bits of m\n            return m & ((1 << n) - 1)\n\n# Read the input\nn = int(input())\nm = int(input())\n\n# Calculate and print the result\nresult = calculate_modulo(n, m)\nprint(result)"}
{"solution": "def correct_word(word):\n    vowels = 'aeiouy'\n    corrected_word = ''\n    i = 0\n\n    while i < len(word):\n        if i < len(word) - 1 and word[i] in vowels and word[i + 1] in vowels:\n            i += 1\n        else:\n            corrected_word += word[i]\n        i += 1\n\n    return corrected_word\n\nn = int(input())\ns = input()\n\ncorrected_s = correct_word(s)\nprint(corrected_s)"}
{"solution": "def max_students(n, a, b, seats):\n    segments = []\n    i = 0\n\n    # Identify segments of empty seats\n    while i < n:\n        if seats[i] == '.':\n            start = i\n            while i < n and seats[i] == '.':\n                i += 1\n            segments.append(i - start)\n        else:\n            i += 1\n\n    total_students = 0\n\n    # Place students in each segment\n    for length in segments:\n        # Calculate the number of students that can be placed in this segment\n        # We will place students in an alternating fashion\n        if a > b:\n            # Start with a student-programmer if more student-programmers are available\n            programmers = (length + 1) // 2\n            athletes = length // 2\n        else:\n            # Start with a student-athlete if more student-athletes are available\n            athletes = (length + 1) // 2\n            programmers = length // 2\n\n        # Place the students\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n\n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n\n    return total_students\n\n# Read input\nn, a, b = map(int, input().split())\nseats = input()\n\n# Print output\nprint(max_students(n, a, b, seats))"}
{"solution": "def find_pair(r):\n    # Iterate through possible values of x\n    for x in range(1, int(r**0.5) + 1):\n        # Calculate the discriminant of the quadratic equation\n        discriminant = 4 * (r - x**2 - x - 1)\n        # Check if the discriminant is positive and a perfect square\n        if discriminant > 0 and int(discriminant**0.5)**2 == discriminant:\n            # Calculate the value of y\n            y = (discriminant**0.5 - 2 * x) / 2\n            # Check if y is a positive integer\n            if y.is_integer() and y > 0:\n                return x, int(y)\n    # If no pair is found, return \"NO\"\n    return \"NO\"\n\n# Read the input value of r\nr = int(input())\n# Find the pair (x, y) that satisfies the condition\nresult = find_pair(r)\n# Print the result\nprint(result if isinstance(result, str) else \"{} {}\".format(*result))"}
{"solution": "# Read input\nn = int(input())\nballoons = list(map(int, input().split()))\n\n# Check if it's possible to divide the balloons\nif n < 2 or sum(balloons) % 2 == 0:\n    print(-1)\nelse:\n    # Sort the balloons in descending order\n    balloons.sort(reverse=True)\n\n    # Initialize variables\n    grigory_balloons = 0\n    grigory_packets = []\n\n    # Divide the balloons\n    for i in range(n):\n        if grigory_balloons <= sum(balloons) // 2:\n            grigory_balloons += balloons[i]\n            grigory_packets.append(i + 1)\n\n    # Print the result\n    print(len(grigory_packets))\n    print(' '.join(map(str, grigory_packets)))"}
{"solution": "def min_digits(n):\n    # Start with the largest possible digit (9)\n    digit = 9\n    digits = []\n\n    # While the number is greater than 0\n    while n > 0:\n        # If the digit is greater than the number, decrease the digit\n        if digit > n:\n            digit -= 1\n        # Else, subtract the digit from the number and add it to the list\n        else:\n            n -= digit\n            digits.append(digit)\n\n    # Return the number of digits and the digits themselves\n    return len(digits), digits\n\n# Get the input\nn = int(input())\n\n# Get the result\nk, digits = min_digits(n)\n\n# Print the result\nprint(k)\nprint(' '.join(map(str, digits)))"}
{"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef max_simple_subset(arr):\n    n = len(arr)\n    max_size = 0\n    max_subset = []\n    for i in range(1, 1 << n):\n        subset = [arr[j] for j in range(n) if (i & (1 << j))]\n        if all(is_prime(x + y) for x in subset for y in subset if x != y):\n            if len(subset) > max_size:\n                max_size = len(subset)\n                max_subset = subset\n    return max_size, max_subset\n\nn = int(input())\narr = list(map(int, input().split()))\nmax_size, max_subset = max_simple_subset(arr)\nprint(max_size)\nprint(*max_subset)"}
{"solution": "def greatest_beautiful_divisor(n):\n    # Iterate through possible values of k\n    k = 1\n    while (2 ** k - 1) * (2 ** (k - 1)) <= n:\n        k += 1\n\n    # Calculate the greatest beautiful divisor\n    greatest_divisor = (2 ** (k - 1) - 1) * (2 ** (k - 1))\n\n    return greatest_divisor\n\n# Read the input number\nn = int(input())\n\n# Find the greatest beautiful divisor\nresult = greatest_beautiful_divisor(n)\n\n# Print the result\nprint(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef count_d_magic_numbers(m, d, a, b):\n    # Convert the numbers to strings for easier digit manipulation\n    a = str(a)\n    b = str(b)\n\n    # Initialize the dynamic programming table\n    dp = [[0] * 2 for _ in range(len(a) + 1)]\n    dp[0][0] = 1  # Base case: empty string is a valid number\n\n    # Iterate through the digits of the numbers\n    for i in range(1, len(a) + 1):\n        # Iterate through the possible digits for the current position\n        for digit in range(10):\n            # Check if the digit is valid for the current position\n            if (i % 2 == 0 and digit == d) or (i % 2 != 0 and digit != d):\n                # Update the dynamic programming table\n                dp[i][0] = (dp[i][0] + dp[i - 1][0]) % MOD\n                if digit < int(a[i - 1]):\n                    dp[i][1] = (dp[i][1] + dp[i - 1][0]) % MOD\n                elif digit == int(a[i - 1]):\n                    dp[i][1] = (dp[i][1] + dp[i - 1][1]) % MOD\n\n    # Calculate the number of d-magic numbers in the range [a, b] that are multiples of m\n    count = dp[len(a)][1]\n    if int(a) % m == 0:\n        count = (count + 1) % MOD\n    count = (count - dp[len(b)][1]) % MOD\n    if int(b) % m == 0:\n        count = (count + 1) % MOD\n    count = (count + MOD) % MOD\n\n    return count\n\n# Read the input\nm, d = map(int, input().split())\na = int(input())\nb = int(input())\n\n# Calculate the number of d-magic numbers\nresult = count_d_magic_numbers(m, d, a, b)\n\n# Print the result\nprint(result)"}
{"solution": "from collections import deque\n\n# Get the input\nn, m = map(int, input().split())\ncandies = list(map(int, input().split()))\n\n# Create a queue and a list to store the children who have gone home\nqueue = deque(range(1, n + 1))\ngone_home = []\n\n# Distribute candies\nwhile queue:\n    child = queue.popleft()\n    candies[child - 1] -= m\n    if candies[child - 1] <= 0:\n        gone_home.append(child)\n    else:\n        queue.append(child)\n\n# Print the last child who has gone home\nprint(gone_home[-1])"}
{"solution": "def min_bills(n):\n    bills = [100, 20, 10, 5, 1]\n    count = 0\n    for bill in bills:\n        count += n // bill\n        n %= bill\n    return count\n\nn = int(input())\nprint(min_bills(n))"}
{"solution": "MOD = 1000000007\n\ndef count_permutations(n, k):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(min(i, k) + 1):\n            dp[i][j] = (dp[i - 1][j] + (i - j) * dp[i - 1][j - 1]) % MOD\n\n    return dp[n][k]\n\nn, k = map(int, input().split())\nprint(count_permutations(n, k))"}
{"solution": "def max_beauty(n, k, b, c):\n    # Separate roses by color\n    white_roses = sorted([b[i] for i in range(n) if c[i] == 'W'], reverse=True)\n    orange_roses = sorted([b[i] for i in range(n) if c[i] == 'O'], reverse=True)\n    red_roses = sorted([b[i] for i in range(n) if c[i] == 'R'], reverse=True)\n\n    # Check if it's possible to make a bouquet\n    if len(white_roses) + len(orange_roses) < k or len(red_roses) < k:\n        return -1\n\n    # Calculate the maximum possible total beauty\n    max_beauty = 0\n    for i in range(min(k, len(red_roses))):\n        for j in range(max(0, k - i - 1), min(k - i, len(white_roses) + len(orange_roses)) + 1):\n            if j <= len(white_roses):\n                max_beauty = max(max_beauty, sum(red_roses[:i]) + sum(white_roses[:j]))\n            if j <= len(orange_roses):\n                max_beauty = max(max_beauty, sum(red_roses[:i]) + sum(orange_roses[:j]))\n\n    return max_beauty\n\n# Read input\nn, k = map(int, input().split())\nb = list(map(int, input().split()))\nc = input()\n\n# Print output\nprint(max_beauty(n, k, b, c))"}
{"solution": "def compare_fractions(p, q, n, a):\n    # Convert the continued fraction to a fraction\n    num, den = a[-1], 1\n    for i in range(n - 2, -1, -1):\n        num, den = a[i] * num + den, num\n\n    # Check if the two fractions are equal\n    return p == num and q == den\n\n# Read the input\np, q = map(int, input().split())\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the result\nprint(\"YES\" if compare_fractions(p, q, n, a) else \"NO\")"}
{"solution": "def solve_expression(expression):\n    # Split the expression into A, B, and C parts\n    a, b, c = expression.split('+')[0], expression.split('+')[1].split('=')[0], expression.split('=')[1]\n\n    # Count the sticks in each part\n    a_count = a.count('|')\n    b_count = b.count('|')\n    c_count = c.count('|')\n\n    # Check if a single stick can be moved to make the expression correct\n    if a_count + b_count == c_count + 1:\n        return expression.replace('=', '=|', 1)\n    elif a_count + b_count == c_count - 1:\n        return expression.replace('=', '=|', 1).replace('|', '', 1)\n    elif a_count + 1 == c_count - b_count:\n        return expression.replace('+', '|+', 1)\n    elif a_count - 1 == c_count - b_count:\n        return expression.replace('+', '|+', 1).replace('|', '', 1)\n    else:\n        return \"Impossible\"\n\n# Get the input expression\nexpression = input()\n\n# Print the result\nprint(solve_expression(expression))"}
{"solution": "def solve(n, k):\n    MOD = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i * i, k + 1):\n            for l in range(i):\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - l * l]) % MOD\n\n    return dp[n][k]\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "def solve(points, index, current_pos, path):\n    if index == len(points):\n        return path\n\n    x, y = points[index]\n    dx, dy = x - current_pos[0], y - current_pos[1]\n\n    if dx != 0 and dy != 0 and abs(dx) != abs(dy):\n        return None\n\n    if dx > 0:\n        direction = 'R'\n        new_pos = (current_pos[0] + dx, current_pos[1])\n    elif dx < 0:\n        direction = 'L'\n        new_pos = (current_pos[0] - dx, current_pos[1])\n    elif dy > 0:\n        direction = 'U'\n        new_pos = (current_pos[0], current_pos[1] + dy)\n    elif dy < 0:\n        direction = 'D'\n        new_pos = (current_pos[0], current_pos[1] - dy)\n    else:\n        return None\n\n    for i in range(1, abs(dx or dy) + 1):\n        new_path = solve(points, index + 1, new_pos, path + direction)\n        if new_path:\n            return new_path\n        current_pos = new_pos\n        new_pos = (current_pos[0] + (dx > 0) - (dx < 0), current_pos[1] + (dy > 0) - (dy < 0))\n\n    return None\n\ndef main():\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n\n    for m in range(1, 41):\n        path = solve(points, 0, (0, 0), '')\n        if path:\n            print(m)\n            print(' '.join(str(abs(path[i] - path[i - 1])) for i in range(1, m)))\n            print('\\n'.join(path[i:i + m] for i in range(0, len(path), m)))\n            break\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "# Get the length of the interview\nn = int(input())\n\n# Get the interview string\ns = input()\n\n# Initialize the result string\nresult = \"\"\n\n# Initialize the filler word\nfiller = \"ogo\"\n\n# Loop through the string\ni = 0\nwhile i < n:\n    # If the current substring starts with the filler word\n    if s[i:i+len(filler)] == filler:\n        # Add three asterisks to the result\n        result += \"***\"\n        # Move the index to the end of the filler word\n        i += len(filler)\n        # Skip any additional 'go' at the end of the filler word\n        while i < n and s[i:i+2] == \"go\":\n            i += 2\n    else:\n        # Add the current character to the result\n        result += s[i]\n        # Move to the next character\n        i += 1\n\n# Print the result\nprint(result)"}
{"solution": "import math\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef g(x, p):\n    k = 0\n    while x % p == 0:\n        x //= p\n        k += 1\n    return p ** k\n\ndef f(x, y):\n    factors = prime_factors(x)\n    result = 1\n    for p in factors:\n        result *= g(y, p)\n    return result\n\ndef calculate_product(x, n):\n    mod = 10 ** 9 + 7\n    result = 1\n    for y in range(1, n + 1):\n        result = (result * f(x, y)) % mod\n    return result\n\nx, n = map(int, input().split())\nprint(calculate_product(x, n))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for s in range(1, 82):  # s(x) can be at most 81\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and sum_of_digits(x) == s:\n            solutions.append(x)\n    solutions.sort()\n    return solutions\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find solutions\nsolutions = find_solutions(a, b, c)\n\n# Print results\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "def solve_rubiks_cube(cube):\n    # Define the adjacency list for the Rubik's cube\n    adj_list = [\n        [1, 3, 5, 7], [0, 2, 4, 6], [1, 3, 8, 10], [0, 2, 9, 11],\n        [1, 5, 8, 10], [0, 4, 9, 11], [3, 7, 9, 11], [2, 6, 8, 10],\n        [5, 7, 13, 15], [4, 6, 12, 14], [7, 9, 15, 17], [6, 8, 12, 16],\n        [13, 15, 19, 21], [12, 14, 18, 20], [15, 17, 19, 21], [14, 16, 18, 20],\n        [11, 13, 22, 23], [10, 12, 22, 23], [17, 19, 22, 23], [16, 18, 22, 23],\n        [19, 21, 23, 23], [18, 20, 23, 23], [21, 23, 23, 23], [20, 23, 23, 23]\n    ]\n\n    # Check if it's possible to solve the cube using one rotation\n    for i in range(0, 24, 4):\n        if len(set(cube[i:i+4])) == 1:\n            colors = set(cube[i:i+4])\n            for j in adj_list[i]:\n                if cube[j] not in colors:\n                    break\n            else:\n                return True\n    return False\n\n# Read the input\ncube = list(map(int, input().split()))\n\n# Print the output\nprint(\"YES\" if solve_rubiks_cube(cube) else \"NO\")"}
{"solution": "def solve(p, x, y):\n    s = y\n    i = (s // 50) % 475\n    t_shirts = set()\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        t_shirts.add(26 + i)\n\n    successful_hacks = 0\n    while p not in t_shirts or x < y:\n        if x + 100 >= y:\n            x += 100\n        else:\n            x -= 50\n        s = x\n        i = (s // 50) % 475\n        t_shirts = set()\n        for _ in range(25):\n            i = (i * 96 + 42) % 475\n            t_shirts.add(26 + i)\n        successful_hacks += 1\n\n    return successful_hacks\n\np, x, y = map(int, input().split())\nprint(solve(p, x, y))"}
{"solution": "# Get the input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# If Winnie-the-Pooh only needs to have a meal once, he doesn't need to travel\nif n == 1:\n    print(0)\nelse:\n    # Calculate the minimum distance Winnie-the-Pooh needs to travel\n    # He will always alternate between the two houses that are closest to Rabbit's house\n    # This is because he will always leave a house when the honey is about to end,\n    # and he wants to minimize his travel distance\n    min_distance = min(a, b) * (n - 1)\n\n    # If Winnie-the-Pooh needs to visit the third house,\n    # he will need to travel the distance between the two closest houses once more\n    if n > 2:\n        min_distance += min(a, b)\n\n    print(min_distance)"}
{"solution": "# Get the input and convert to integers\nx1, x2, x3 = map(int, input().split())\n\n# Sort the coordinates\ncoordinates = sorted([x1, x2, x3])\n\n# Calculate the minimum total distance\nmin_distance = (coordinates[1] - coordinates[0]) + (coordinates[2] - coordinates[1])\n\n# Print the result\nprint(min_distance)"}
{"solution": "def min_operations(n, x, arr):\n    # Create a set to store unique elements after bitwise AND operation\n    unique_elements = set()\n\n    # Initialize the number of operations\n    operations = 0\n\n    # Iterate through the array\n    for i in range(n):\n        # Perform bitwise AND operation with x\n        arr[i] &= x\n\n        # If the element is already in the set, return the number of operations\n        if arr[i] in unique_elements:\n            return operations\n\n        # Add the element to the set\n        unique_elements.add(arr[i])\n\n        # Increment the number of operations\n        operations += 1\n\n    # If no two elements are equal, return -1\n    return -1\n\n# Read input\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Print the minimal number of operations\nprint(min_operations(n, x, arr))"}
{"solution": "def is_plus_shape(grid):\n    h = len(grid)\n    w = len(grid[0])\n    center = None\n\n    # Scanning the Grid\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*':\n                if center is None:\n                    center = (i, j)\n                else:\n                    return False  # More than one center\n\n    if center is None:\n        return False  # No center\n\n    # Checking Conditions\n    i, j = center\n    left = right = up = down = 0\n    for k in range(j-1, -1, -1):\n        if grid[i][k] == '*':\n            left += 1\n        else:\n            break\n    for k in range(j+1, w):\n        if grid[i][k] == '*':\n            right += 1\n        else:\n            break\n    for k in range(i-1, -1, -1):\n        if grid[k][j] == '*':\n            up += 1\n        else:\n            break\n    for k in range(i+1, h):\n        if grid[k][j] == '*':\n            down += 1\n        else:\n            break\n\n    if left == 0 or right == 0 or up == 0 or down == 0:\n        return False  # Not all directions have consecutive non-empty cells\n\n    # Ensuring Uniqueness\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*' and (i, j) != center and (i != center[0] or j != center[1] + left or j != center[1] - right) and (j != center[1] or i != center[0] + up or i != center[0] - down):\n                return False  # Other non-empty cells outside the \"+\" shape\n\n    return True\n\n# Read input\nh, w = map(int, input().split())\ngrid = [input() for _ in range(h)]\n\n# Print output\nprint('YES' if is_plus_shape(grid) else 'NO')"}
{"solution": "def create_matrix(n, a, b):\n    # Check if it's possible to create such a matrix\n    if a + b > n + 1 or a * b < n - a - b + 2:\n        return \"NO\"\n\n    matrix = [[0] * n for _ in range(n)]\n\n    # Create a graph with 'a' components\n    for i in range(1, a):\n        matrix[i][i - 1] = matrix[i - 1][i] = 1\n\n    # Create a graph with 'b' components in its complement\n    for i in range(a, a + b - 1):\n        matrix[i][i + 1] = matrix[i + 1][i] = 1\n\n    # Connect the last component of the first graph with the first component of the second graph\n    if a > 1 and b > 1:\n        matrix[0][a] = matrix[a][0] = 1\n\n    # Fill the remaining cells\n    for i in range(a + b, n):\n        matrix[i][i - 1] = matrix[i - 1][i] = 1\n\n    return [\"YES\"] + [\"\".join(map(str, row)) for row in matrix]\n\nn, a, b = map(int, input().split())\nprint(\"\\n\".join(create_matrix(n, a, b)))"}
{"solution": "# Get the input\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\n# Calculate the number of main rounds needed\nmain_rounds = max(0, n * m - k) // n\n\n# Calculate the number of additional rounds needed\nadditional_rounds = max(0, n * m - k - main_rounds * n)\n\n# Calculate the total number of problems needed\ntotal_problems = main_rounds * c + additional_rounds * d\n\n# Print the result\nprint(total_problems)"}
{"solution": "def create_grid(s):\n    grid = [[' ' for _ in range(13)] for _ in range(2)]\n    used = [False] * 26\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x < 2 and 0 <= y < 13\n\n    def is_adjacent(a, b):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]:\n            if is_valid(a[0] + dx, a[1] + dy) and grid[a[0] + dx][a[1] + dy] == b:\n                return True\n        return False\n\n    def dfs(i, x, y):\n        if i == 27:\n            return True\n        if used[ord(s[i]) - ord('A')]:\n            if is_adjacent((x, y), s[i]):\n                path.append(s[i])\n                return dfs(i + 1, x, y)\n            else:\n                return False\n        else:\n            used[ord(s[i]) - ord('A')] = True\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny) and grid[nx][ny] == ' ':\n                    grid[nx][ny] = s[i]\n                    path.append(s[i])\n                    if dfs(i + 1, nx, ny):\n                        return True\n                    path.pop()\n                    grid[nx][ny] = ' '\n            used[ord(s[i]) - ord('A')] = False\n        return False\n\n    for i in range(2):\n        for j in range(13):\n            if dfs(0, i, j):\n                return grid\n    return \"Impossible\"\n\ns = input()\ngrid = create_grid(s)\nif grid == \"Impossible\":\n    print(grid)\nelse:\n    for row in grid:\n        print(''.join(row))"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<' if y > 1 else '='\n    elif y == 1:\n        return '>' if x > 1 else '='\n    else:\n        # Compute y * log(x) and x * log(y)\n        lhs = y * math.log(x)\n        rhs = x * math.log(y)\n\n        if lhs < rhs:\n            return '<'\n        elif lhs > rhs:\n            return '>'\n        else:\n            return '='\n\n# Read input\nx, y = map(int, input().split())\n\n# Output the result of the comparison\nprint(compare_powers(x, y))"}
{"solution": "import math\n\n# Get the input values for radius and height\nr, h = map(int, input().split())\n\n# Calculate the maximum number of balloons that can fit in the semicircular part\nsemicircle_balloons = math.floor(2 * r / r) * math.floor((h + r) / r)\n\n# Calculate the maximum number of balloons that can fit in the rectangular part\nrectangle_balloons = math.floor(r / r) * math.floor(h / r)\n\n# Calculate the total number of balloons\ntotal_balloons = semicircle_balloons + rectangle_balloons\n\n# Print the result\nprint(total_balloons)"}
{"solution": "from collections import Counter\n\n# Get the input numbers\nnumbers = list(map(int, input().split()))\n\n# Count the occurrences of each number\ncounts = Counter(numbers)\n\n# Initialize the minimum sum as the sum of all numbers\nmin_sum = sum(numbers)\n\n# Check each number to see if discarding two or three of them results in a smaller sum\nfor num, count in counts.items():\n    if count >= 2:\n        min_sum = min(min_sum, sum(numbers) - 2 * num)\n    if count >= 3:\n        min_sum = min(min_sum, sum(numbers) - 3 * num)\n\n# Print the minimum sum\nprint(min_sum)"}
{"solution": "def min_distance(n, a, checkpoints):\n    checkpoints.sort()\n    left_dist = [0] * n\n    right_dist = [0] * n\n\n    left_dist[0] = abs(checkpoints[0] - a)\n    for i in range(1, n):\n        left_dist[i] = left_dist[i-1] + abs(checkpoints[i] - checkpoints[i-1])\n\n    right_dist[n-1] = abs(checkpoints[n-1] - a)\n    for i in range(n-2, -1, -1):\n        right_dist[i] = right_dist[i+1] + abs(checkpoints[i+1] - checkpoints[i])\n\n    min_total_dist = min(left_dist[n-2], right_dist[1])\n    for i in range(1, n-1):\n        min_total_dist = min(min_total_dist, left_dist[i-1] + right_dist[i+1])\n\n    return min_total_dist\n\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\nprint(min_distance(n, a, checkpoints))"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef find_root(n):\n    x = 1\n    while True:\n        if x**2 + sum_of_digits(x)*x - n == 0:\n            return x\n        elif x**2 + sum_of_digits(x)*x > n:\n            return -1\n        x += 1\n\nn = int(input())\nprint(find_root(n))"}
{"solution": "from datetime import datetime, timedelta\n\n# Get the current time and sleep duration from the user\ncurrent_time = input()\nsleep_duration = input()\n\n# Convert the time strings to datetime objects\ncurrent_time = datetime.strptime(current_time, \"%H:%M\")\nsleep_duration = datetime.strptime(sleep_duration, \"%H:%M\")\n\n# Calculate the bedtime by subtracting the sleep duration from the current time\nbedtime = current_time - timedelta(hours=sleep_duration.hour, minutes=sleep_duration.minute)\n\n# Format the bedtime as a string in the required format\nbedtime = bedtime.strftime(\"%H:%M\")\n\n# Print the bedtime\nprint(bedtime)"}
{"solution": "def longest_subsegment(n, arr):\n    max_mean = float('-inf')\n    max_length = 0\n    current_sum = 0\n    current_length = 0\n    start = 0\n\n    for end in range(n):\n        current_sum += arr[end]\n        current_length += 1\n\n        current_mean = current_sum / current_length\n\n        if current_mean > max_mean:\n            max_mean = current_mean\n            max_length = current_length\n            start = end - current_length + 1\n        elif current_mean == max_mean and current_length > max_length:\n            max_length = current_length\n            start = end - current_length + 1\n\n        while current_sum <= 0 and start < end:\n            current_sum -= arr[start]\n            current_length -= 1\n            start += 1\n\n    return max_length\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(longest_subsegment(n, arr))"}
{"solution": "MOD = 998244353\n\ndef count_ways(n, m, k):\n    dp = [[0] * (k + 1) for _ in range(n)]\n    dp[0][0] = m\n\n    for i in range(1, n):\n        for j in range(k + 1):\n            dp[i][j] = dp[i - 1][j] * (m - 1) % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n\n    return sum(dp[n - 1]) % MOD\n\nn, m, k = map(int, input().split())\nprint(count_ways(n, m, k))"}
{"solution": "import re\n\ndef is_magic_number(n):\n    # Define the regular expression pattern for magic numbers\n    pattern = re.compile(r'^(1|14|144)+$')\n\n    # Check if the entire number matches the pattern\n    if pattern.match(str(n)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Example usage\nn = int(input())\nprint(is_magic_number(n))"}
{"solution": "from collections import deque\n\ndef min_moves(n, m, i, j, a, b):\n    # Define possible moves\n    moves = [(a, b), (-a, b), (a, -b), (-a, -b)]\n\n    # Initialize queue for BFS and visited set\n    queue = deque([(i, j, 0)])\n    visited = set([(i, j)])\n\n    # BFS\n    while queue:\n        x, y, d = queue.popleft()\n\n        # Check if current position is a corner\n        if (x == 1 and y == m) or (x == n and y == 1) or (x == n and y == m) or (x == 1 and y == 1):\n            return d\n\n        # Explore possible moves\n        for dx, dy in moves:\n            nx, ny = x + dx, y + dy\n\n            # Check if new position is within chessboard and not visited\n            if 1 <= nx <= n and 1 <= ny <= m and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, d + 1))\n\n    # If no path is found\n    return \"Poor Inna and pony!\"\n\n# Read input\nn, m, i, j, a, b = map(int, input().split())\n\n# Print output\nprint(min_moves(n, m, i, j, a, b))"}
{"solution": "def max_characters_removal(s):\n    # Create a list from the input string\n    s = list(s)\n    # Initialize the count of removable characters\n    count = 0\n    # Iterate over the string\n    i = 1\n    while i < len(s) - 1:\n        # If the current character is one more than its adjacent characters\n        if ord(s[i]) - 1 == ord(s[i - 1]) or ord(s[i]) - 1 == ord(s[i + 1]):\n            # Remove the current character\n            s.pop(i)\n            # Increment the count of removable characters\n            count += 1\n        else:\n            # Move to the next character\n            i += 1\n    # Check for the first and last characters\n    if len(s) > 1:\n        if ord(s[0]) - 1 == ord(s[1]):\n            count += 1\n        if ord(s[-1]) - 1 == ord(s[-2]):\n            count += 1\n    return count\n\n# Read the input\nn = int(input())\ns = input()\n# Print the result\nprint(max_characters_removal(s))"}
{"solution": "from collections import defaultdict\n\ndef min_coins(denominations, target, max_coins):\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n    for coin in denominations:\n        for i in range(coin, target + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[-1] if dp[-1] <= max_coins else -1\n\ndef main():\n    n, k = map(int, input().split())\n    denominations = list(map(int, input().split()))\n    q = int(input())\n    for _ in range(q):\n        target = int(input())\n        print(min_coins(denominations, target, k))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_min_time(s, x1, x2, t1, t2, p, d):\n    # Calculate the time Igor needs to walk to the tram's position\n    walk_time = abs(x1 - p) / t2\n\n    # Calculate the time the tram needs to reach Igor's destination\n    if d == 1:\n        tram_time = (s - x2) / t1\n    else:\n        tram_time = x2 / t1\n\n    # Calculate the time Igor needs to walk from the tram's position to his destination\n    walk_time_to_dest = abs(x2 - p) / t2\n\n    # Calculate the minimum time Igor needs to get to his destination\n    min_time = min(walk_time + walk_time_to_dest, walk_time + tram_time)\n\n    return min_time\n\n# Read the input\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Calculate the minimum time\nmin_time = calculate_min_time(s, x1, x2, t1, t2, p, d)\n\n# Print the result\nprint(min_time)"}
{"solution": "# Read the input\nn, x = map(int, input().split())\n\n# Initialize the count\ncount = 0\n\n# Iterate over the rows\nfor i in range(1, n + 1):\n    # If x is divisible by i, then x can be in the i-th row\n    if x % i == 0:\n        # Calculate the column number\n        j = x // i\n        # If j is less than or equal to n, then x is in the table\n        if j <= n:\n            count += 1\n\n# Print the result\nprint(count)"}
{"solution": "n, k = map(int, input().split())\n\npassword = []\n\n# Add distinct symbols to the password\nfor i in range(k):\n    password.append(chr(ord('a') + i))\n\n# Fill the remaining length of the password\nfor i in range(k, n):\n    # If the last symbol is 'a', add 'b' to avoid consecutive identical symbols\n    if password[-1] == 'a':\n        password.append('b')\n    else:\n        password.append('a')\n\nprint(''.join(password))"}
{"solution": "def first_collision_time(n, directions, positions):\n    min_time = float('inf')\n    collision_found = False\n\n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            collision_time = (positions[i + 1] - positions[i]) // 2\n            min_time = min(min_time, collision_time)\n            collision_found = True\n\n    if collision_found:\n        return min_time\n    else:\n        return -1\n\nn = int(input())\ndirections = input()\npositions = list(map(int, input().split()))\n\nprint(first_collision_time(n, directions, positions))"}
{"solution": "def max_area(n, a, b, seals):\n    # Sort seals by their area in descending order\n    seals.sort(key=lambda x: x[0]*x[1], reverse=True)\n\n    # Initialize maximum area\n    max_area = 0\n\n    # Iterate over all pairs of seals\n    for i in range(n):\n        for j in range(i+1, n):\n            # Get dimensions of the current pair of seals\n            x1, y1 = seals[i]\n            x2, y2 = seals[j]\n\n            # Check if seals can be placed without overlapping\n            if (x1 <= a and x2 <= a and y1 <= b and y2 <= b) or \\\n               (x1 <= b and x2 <= b and y1 <= a and y2 <= a):\n                # Update maximum area\n                max_area = max(max_area, x1*y1 + x2*y2)\n\n    # Return maximum area\n    return max_area\n\n# Read input\nn, a, b = map(int, input().split())\nseals = [list(map(int, input().split())) for _ in range(n)]\n\n# Print output\nprint(max_area(n, a, b, seals))"}
{"solution": "def find_point():\n    n = int(input())\n    points = [list(map(int, input().split())) for _ in range(4*n + 1)]\n\n    x_coords = sorted(set(point[0] for point in points))\n    y_coords = sorted(set(point[1] for point in points))\n\n    min_x, max_x = x_coords[0], x_coords[-1]\n    min_y, max_y = y_coords[0], y_coords[-1]\n\n    for point in points:\n        x, y = point\n        if not (x == min_x or x == max_x or y == min_y or y == max_y):\n            return point\n\nresult = find_point()\nprint(result[0], result[1])"}
{"solution": "def max_product(n):\n    if n < 10:\n        return n\n\n    product = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    for i in range(10, n + 1):\n        num = i\n        j = 9\n        while num > 0:\n            digit = num % 10\n            product[j] = max(product[j], product[j - 1] * digit)\n            num //= 10\n            j -= 1\n\n    return product[9]\n\nn = int(input())\nprint(max_product(n))"}
{"solution": "# Get the number of students\nn = int(input())\n\n# Get the list of votes for Elodreip\nvotes = list(map(int, input().split()))\n\n# Calculate the total votes for Elodreip\ntotal_elodreip_votes = sum(votes)\n\n# Initialize k as the maximum value in the list of votes\nk = max(votes)\n\n# Initialize Awruk's total votes\ntotal_awruk_votes = n * k - total_elodreip_votes\n\n# Increment k until Awruk's votes exceed Elodreip's votes\nwhile total_awruk_votes <= total_elodreip_votes:\n    k += 1\n    total_awruk_votes = n * k - total_elodreip_votes\n\n# Print the smallest winning number k\nprint(k)"}
{"solution": "def count_operations(colors):\n    stack = []\n    operations = 0\n\n    for color in colors:\n        if stack and stack[-1] != color:\n            stack.pop()\n            if not stack or stack[-1] != color:\n                operations += 1\n        else:\n            stack.append(color)\n\n    return operations\n\ncolors = input()\nprint(count_operations(colors))"}
{"solution": "# Read the number of elements\nn = int(input())\n\n# Read the elements of the array\na = list(map(int, input().split()))\n\n# Sort the array\na.sort()\n\n# Initialize the count of triples\ncount = 0\n\n# Iterate over the first element of the triple\nfor i in range(n - 2):\n    # Iterate over the second element of the triple\n    for j in range(i + 1, n - 1):\n        # Iterate over the third element of the triple\n        for k in range(j + 1, n):\n            # If the product of the current triple is equal to the product of the first three elements\n            if a[i] * a[j] * a[k] == a[0] * a[1] * a[2]:\n                # Increment the count of triples\n                count += 1\n            else:\n                # Break the inner loop since the product can't be minimum anymore\n                break\n\n# Print the count of triples\nprint(count)"}
{"solution": "# Get the number of friends\nn = int(input())\n\n# Calculate the number of cuts needed\ncuts_needed = n\n\n# Print the result\nprint(cuts_needed)"}
{"solution": "def max_bank_account(n):\n    # Convert the number to a list of digits\n    digits = list(str(abs(n)))\n\n    # If the number is positive, remove the last digit if it's smaller than the second last digit\n    if n > 0:\n        if len(digits) > 1 and digits[-1] < digits[-2]:\n            digits.pop(-1)\n    # If the number is negative, remove the last digit if it's larger than the second last digit\n    elif n < 0:\n        if len(digits) > 1 and digits[-1] > digits[-2]:\n            digits.pop(-1)\n\n    # Convert the list of digits back to an integer\n    result = int(''.join(digits))\n\n    # If the original number was negative, make the result negative as well\n    if n < 0:\n        result = -result\n\n    return result\n\n# Get the input\nn = int(input())\n\n# Print the output\nprint(max_bank_account(n))"}
{"solution": "# Define the spinner positions\npositions = ['v', '<', '^', '>']\n\n# Get the input\nstart, end = input().split()\nn = int(input())\n\n# Find the index of the start and end positions\nstart_index = positions.index(start)\nend_index = positions.index(end)\n\n# Calculate the difference in positions\ndiff = (end_index - start_index) % 4\n\n# Determine the direction of the spin\nif diff == 1:\n    direction = 'cw' if n % 4 == 1 else 'undefined'\nelif diff == 3:\n    direction = 'ccw' if n % 4 == 1 else 'undefined'\nelse:\n    direction = 'undefined'\n\n# Print the result\nprint(direction)"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize the state of each domino based on the input string\ndominoes = ['.' if c == '.' else c for c in s]\n\n# Simulate the process of the dominoes falling\nwhile True:\n    changed = False\n    for i in range(n):\n        if dominoes[i] == 'L':\n            if i > 0 and dominoes[i - 1] == '.':\n                dominoes[i - 1] = 'L'\n                changed = True\n        elif dominoes[i] == 'R':\n            if i < n - 1 and dominoes[i + 1] == '.':\n                dominoes[i + 1] = 'R'\n                changed = True\n    if not changed:\n        break\n\n# Count the number of dominoes that remain vertical\ncount = 0\nfor domino in dominoes:\n    if domino == '.':\n        count += 1\n\nprint(count)"}
{"solution": "def find_permutation(n, m, leaders):\n    # Initialize the permutation with all zeros\n    permutation = [0] * n\n\n    # Iterate over the leaders in reverse order\n    for i in range(m - 1, 0, -1):\n        # Calculate the difference between the current and previous leader\n        diff = (leaders[i] - leaders[i - 1]) % n\n\n        # If the difference is zero, it means that there is no solution\n        if diff == 0:\n            return [-1]\n\n        # Assign the difference to the previous leader's position in the permutation\n        permutation[leaders[i - 1] - 1] = diff\n\n    # Calculate the difference between the first leader and the last position in the permutation\n    diff = (leaders[0] - permutation[-1]) % n\n\n    # If the difference is zero, it means that there is no solution\n    if diff == 0:\n        return [-1]\n\n    # Assign the difference to the last position in the permutation\n    permutation[-1] = diff\n\n    # Return the permutation\n    return permutation\n\n# Read the input\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\n# Find the permutation\npermutation = find_permutation(n, m, leaders)\n\n# Print the output\nprint(*permutation)"}
{"solution": "def max_number(a, k):\n    # Convert the number to a list of digits\n    digits = list(str(a))\n\n    # Iterate through the digits\n    for i in range(len(digits)):\n        # If no more swaps are allowed, break the loop\n        if k == 0:\n            break\n\n        # Find the best possible digit to swap with\n        max_digit = max(digits[i:])\n        max_index = digits[i:].index(max_digit) + i\n\n        # If the best possible digit is not the current digit and swapping is beneficial\n        if max_index != i and digits[max_index] > digits[i]:\n            # Perform the swap\n            digits[i], digits[max_index] = digits[max_index], digits[i]\n            k -= 1\n\n    # Convert the list of digits back to a number\n    return int(''.join(digits))\n\n# Get the input\na, k = map(int, input().split())\n\n# Print the maximum number that Pasha can get\nprint(max_number(a, k))"}
{"solution": "def find_next_number(sequence):\n    # Check if the sequence is an arithmetic progression\n    if sequence[1] - sequence[0] == sequence[2] - sequence[1] == sequence[3] - sequence[2]:\n        return sequence[-1] + (sequence[1] - sequence[0])\n    # Check if the sequence is a geometric progression\n    elif sequence[1] / sequence[0] == sequence[2] / sequence[1] == sequence[3] / sequence[2]:\n        return sequence[-1] * (sequence[1] / sequence[0])\n    # If the sequence is neither arithmetic nor geometric\n    else:\n        return 42\n\n# Get the input sequence\nsequence = list(map(int, input().split()))\n\n# Print the next number in the sequence\nprint(find_next_number(sequence))"}
{"solution": "def max_distance(n, colors):\n    # Find the first and last occurrence of each color\n    first_occurrence = {}\n    last_occurrence = {}\n\n    for i in range(n):\n        color = colors[i]\n        if color not in first_occurrence:\n            first_occurrence[color] = i\n        last_occurrence[color] = i\n\n    # Get the list of unique colors\n    unique_colors = list(first_occurrence.keys())\n\n    # Calculate the maximum distance\n    max_dist = 0\n\n    # Compare distances from the first house to the last house of a different color\n    for color in unique_colors:\n        if colors[0] != color:\n            max_dist = max(max_dist, last_occurrence[color])\n        if colors[-1] != color:\n            max_dist = max(max_dist, n - 1 - first_occurrence[color])\n\n    return max_dist\n\n# Read the input\nn = int(input())\ncolors = list(map(int, input().split()))\n\n# Print the maximum possible distance\nprint(max_distance(n, colors))"}
{"solution": "# Read the input\nn, m, k = map(int, input().split())\n\n# Calculate the lane\nlane = (k - 1) // (2 * m) + 1\n\n# Calculate the desk\ndesk = ((k - 1) % (2 * m)) // 2 + 1\n\n# Calculate the side\nside = 'L' if k % 2 == 1 else 'R'\n\n# Print the output\nprint(lane, desk, side)"}
{"solution": "# Get the input\nn = int(input())\ns = input()\n\n# Count the number of each color\nb = s.count('B')\ng = s.count('G')\nr = s.count('R')\n\n# Determine the parity of each count\nb_parity = b % 2\ng_parity = g % 2\nr_parity = r % 2\n\n# Determine the possible final colors\nif b_parity == 0 and g_parity == 0 and r_parity == 0:\n    print(\"BGR\")\nelif b_parity == 1 and g_parity == 0 and r_parity == 0:\n    print(\"B\")\nelif b_parity == 0 and g_parity == 1 and r_parity == 0:\n    print(\"G\")\nelif b_parity == 0 and g_parity == 0 and r_parity == 1:\n    print(\"R\")\nelif b_parity == 1 and g_parity == 1 and r_parity == 0:\n    print(\"BG\")\nelif b_parity == 1 and g_parity == 0 and r_parity == 1:\n    print(\"BR\")\nelif b_parity == 0 and g_parity == 1 and r_parity == 1:\n    print(\"GR\")\nelse:\n    print(\"BGR\")"}
