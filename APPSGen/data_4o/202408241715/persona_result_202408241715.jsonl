{"solution": "def find_max_accordion_length(s):\n    n = len(s)\n    \n    # Find the first '['\n    first_open_bracket = -1\n    for i in range(n):\n        if s[i] == '[':\n            first_open_bracket = i\n            break\n    \n    # If no opening bracket is found, return -1\n    if first_open_bracket == -1:\n        return -1\n    \n    # Find the first ':' after the first '['\n    first_colon_after_open = -1\n    for i in range(first_open_bracket + 1, n):\n        if s[i] == ':':\n            first_colon_after_open = i\n            break\n    \n    # If no colon is found after the opening bracket, return -1\n    if first_colon_after_open == -1:\n        return -1\n    \n    # Find the last ']'\n    last_close_bracket = -1\n    for i in range(n - 1, -1, -1):\n        if s[i] == ']':\n            last_close_bracket = i\n            break\n    \n    # If no closing bracket is found, return -1\n    if last_close_bracket == -1:\n        return -1\n    \n    # Find the last ':' before the last ']'\n    last_colon_before_close = -1\n    for i in range(last_close_bracket - 1, first_colon_after_open, -1):\n        if s[i] == ':':\n            last_colon_before_close = i\n            break\n    \n    # If no colon is found before the closing bracket, return -1\n    if last_colon_before_close == -1:\n        return -1\n    \n    # Count the number of '|' between the two colons\n    pipe_count = 0\n    for i in range(first_colon_after_open + 1, last_colon_before_close):\n        if s[i] == '|':\n            pipe_count += 1\n    \n    # The length of the accordion is 4 (for the brackets and colons) plus the number of '|'\n    return 4 + pipe_count\n\n# Read input\ns = input().strip()\n\n# Find and print the maximum possible length of the accordion\nresult = find_max_accordion_length(s)\nprint(result)"}
{"solution": "def max_digit_sum(x):\n    # Convert x to a string to manipulate individual digits\n    x_str = str(x)\n    n = len(x_str)\n    \n    # Initialize the best number as x itself\n    best_number = x\n    best_sum = sum(int(digit) for digit in x_str)\n    \n    # Try to form numbers by reducing some digit and setting all following digits to 9\n    for i in range(n):\n        if x_str[i] == '0':\n            continue\n        \n        # Form a candidate number by reducing the current digit by 1 and setting all following digits to 9\n        candidate = x_str[:i] + str(int(x_str[i]) - 1) + '9' * (n - i - 1)\n        \n        # Convert candidate to integer and check if it's within the limit\n        candidate_int = int(candidate)\n        if candidate_int <= x:\n            candidate_sum = sum(int(digit) for digit in candidate)\n            if candidate_sum > best_sum or (candidate_sum == best_sum and candidate_int > best_number):\n                best_number = candidate_int\n                best_sum = candidate_sum\n    \n    return best_number\n\n# Read input\nx = int(input().strip())\n\n# Find and print the result\nprint(max_digit_sum(x))"}
{"solution": "def is_lucky_year(year):\n    # Convert the year to a string and count non-zero digits\n    non_zero_digits = sum(1 for digit in str(year) if digit != '0')\n    return non_zero_digits <= 1\n\ndef next_lucky_year(current_year):\n    year = current_year + 1\n    while not is_lucky_year(year):\n        year += 1\n    return year\n\ndef years_until_next_lucky(current_year):\n    next_year = next_lucky_year(current_year)\n    return next_year - current_year\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the result\nprint(years_until_next_lucky(n))"}
{"solution": "def max_painted_sections(n, q, painters):\n    # Function to calculate the number of painted sections with a given set of painters\n    def calculate_painted(painters_set):\n        painted = [0] * (n + 1)\n        for l, r in painters_set:\n            for i in range(l, r + 1):\n                painted[i] = 1\n        return sum(painted)\n\n    max_painted = 0\n\n    # Iterate over all combinations of q-2 painters\n    from itertools import combinations\n    for comb in combinations(painters, q - 2):\n        max_painted = max(max_painted, calculate_painted(comb))\n\n    return max_painted\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\npainters = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(q)]\n\n# Calculate and print the result\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def contains_seven(h, m):\n    return '7' in str(h) or '7' in str(m)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    x = int(data[0])\n    hh = int(data[1])\n    mm = int(data[2])\n    \n    presses = 0\n    \n    while not contains_seven(hh, mm):\n        presses += 1\n        mm -= x\n        if mm < 0:\n            mm += 60\n            hh -= 1\n            if hh < 0:\n                hh += 24\n    \n    print(presses)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0\n    elif l == 1:\n        return abs(pos - r) + 1\n    elif r == n:\n        return abs(pos - l) + 1\n    else:\n        return min(abs(pos - l), abs(pos - r)) + (r - l) + 2\n\n# Read input\nn, pos, l, r = map(int, input().split())\n\n# Print the result\nprint(min_seconds_to_close_tabs(n, pos, l, r))"}
{"solution": "def min_blows_to_defeat(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x, blows = query\n        max_d = 0\n        max_d_minus_h = 0\n        \n        for d, h in blows:\n            max_d = max(max_d, d)\n            max_d_minus_h = max(max_d_minus_h, d - h)\n        \n        if max_d >= x:\n            results.append(1)\n            continue\n        \n        if max_d_minus_h <= 0:\n            results.append(-1)\n            continue\n        \n        remaining_heads = x - max_d\n        blows_needed = (remaining_heads + max_d_minus_h - 1) // max_d_minus_h + 1\n        results.append(blows_needed)\n    \n    return results\n\n# Read input\nt = int(input().strip())\nqueries = []\n\nfor _ in range(t):\n    n, x = map(int, input().strip().split())\n    blows = [tuple(map(int, input().strip().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Get results\nresults = min_blows_to_defeat(t, queries)\n\n# Print results\nfor result in results:\n    print(result)"}
{"solution": "def find_empty_day(n, m):\n    day = 0\n    grains = n\n    \n    while grains > 0:\n        day += 1\n        grains += m\n        if grains > n:\n            grains = n\n        grains -= day\n    \n    return day\n\n# Read input\nn, m = map(int, input().split())\n\n# Find the day when the barn becomes empty\nresult = find_empty_day(n, m)\n\n# Print the result\nprint(result)"}
{"solution": "def min_draws_to_win(tiles):\n    # Parse the input tiles\n    tile1, tile2, tile3 = tiles.split()\n    \n    # Extract numbers and suits\n    num1, suit1 = int(tile1[0]), tile1[1]\n    num2, suit2 = int(tile2[0]), tile2[1]\n    num3, suit3 = int(tile3[0]), tile3[1]\n    \n    # Check for koutsu (triplet)\n    if tile1 == tile2 == tile3:\n        return 0\n    \n    # Check for shuntsu (sequence)\n    def is_shuntsu(n1, n2, n3):\n        return sorted([n1, n2, n3]) in [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9]]\n    \n    if suit1 == suit2 == suit3 and is_shuntsu(num1, num2, num3):\n        return 0\n    \n    # Check for possible koutsu with one more draw\n    if tile1 == tile2 or tile1 == tile3 or tile2 == tile3:\n        return 1\n    \n    # Check for possible shuntsu with one more draw\n    def needs_one_for_shuntsu(n1, n2):\n        return abs(n1 - n2) == 1 or abs(n1 - n2) == 2\n    \n    if suit1 == suit2 and needs_one_for_shuntsu(num1, num2):\n        return 1\n    if suit1 == suit3 and needs_one_for_shuntsu(num1, num3):\n        return 1\n    if suit2 == suit3 and needs_one_for_shuntsu(num2, num3):\n        return 1\n    \n    # If no koutsu or shuntsu can be formed with one more draw, return 2\n    return 2\n\n# Example usage\nif __name__ == \"__main__\":\n    import sys\n    input_tiles = sys.stdin.read().strip()\n    print(min_draws_to_win(input_tiles))"}
{"solution": "def find_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b):\n    left_count = [0] * d\n    right_count = [0] * d\n    top_count = [0] * d\n    bottom_count = [0] * d\n\n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        for j in range(d):\n            if i == j:\n                continue\n            x1_j, y1_j, x2_j, y2_j = sofas[j]\n            if x1 < x1_j and x2 < x1_j:\n                right_count[i] += 1\n            if x1 > x1_j and x2 > x1_j:\n                left_count[i] += 1\n            if y1 < y1_j and y2 < y1_j:\n                bottom_count[i] += 1\n            if y1 > y1_j and y2 > y1_j:\n                top_count[i] += 1\n\n    for i in range(d):\n        if (left_count[i] == cnt_l and right_count[i] == cnt_r and\n                top_count[i] == cnt_t and bottom_count[i] == cnt_b):\n            return i + 1\n\n    return -1\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nd = int(data[0])\nn = int(data[1])\nm = int(data[2])\n\nsofas = []\nindex = 3\nfor _ in range(d):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    sofas.append((x1, y1, x2, y2))\n    index += 4\n\ncnt_l = int(data[index])\ncnt_r = int(data[index + 1])\ncnt_t = int(data[index + 2])\ncnt_b = int(data[index + 3])\n\n# Find and print the result\nresult = find_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b)\nprint(result)"}
{"solution": "def mars_days_off(n):\n    full_weeks = n // 7\n    remaining_days = n % 7\n    \n    min_days_off = full_weeks * 2\n    max_days_off = full_weeks * 2 + min(remaining_days, 2)\n    \n    return min_days_off, max_days_off\n\n# Read input\nn = int(input())\n\n# Calculate and print the result\nmin_days_off, max_days_off = mars_days_off(n)\nprint(min_days_off, max_days_off)"}
{"solution": "def max_chocolates(n, a, b, p, q):\n    # Calculate the number of multiples of a, b, and both a and b (lcm of a and b)\n    from math import gcd\n\n    def lcm(x, y):\n        return x * y // gcd(x, y)\n\n    count_a = n // a\n    count_b = n // b\n    count_ab = n // lcm(a, b)\n\n    # Calculate the maximum chocolates\n    if p > q:\n        max_chocolates = count_a * p + (count_b - count_ab) * q\n    else:\n        max_chocolates = count_b * q + (count_a - count_ab) * p\n\n    return max_chocolates\n\n# Read input\nn, a, b, p, q = map(int, input().split())\n\n# Calculate and print the result\nprint(max_chocolates(n, a, b, p, q))"}
{"solution": "def max_beauty(n, trophies):\n    # Find all segments of golden trophies\n    segments = []\n    current_length = 0\n    for i in range(n):\n        if trophies[i] == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n    if current_length > 0:\n        segments.append(current_length)\n    \n    # If there are no golden trophies\n    if not segments:\n        return 0\n    \n    # If there is only one segment of golden trophies\n    if len(segments) == 1:\n        return segments[0] + (1 if 'S' in trophies else 0)\n    \n    # Calculate the maximum beauty with at most one swap\n    max_beauty = max(segments)\n    for i in range(len(segments) - 1):\n        # Check if we can merge two segments by swapping one 'S'\n        if segments[i] + segments[i + 1] + 1 > max_beauty:\n            max_beauty = segments[i] + segments[i + 1] + 1\n    \n    # Check if we can increase the length of any segment by swapping one 'S'\n    if sum(segments) < n:\n        max_beauty = max(max_beauty, max(segments) + 1)\n    \n    return max_beauty\n\n# Read input\nn = int(input())\ntrophies = input().strip()\n\n# Calculate and print the result\nprint(max_beauty(n, trophies))"}
{"solution": "from collections import deque, defaultdict\n\ndef find_course_order(n, k, main_courses, dependencies):\n    # Initialize graph and in-degree count\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    \n    # Build the graph and in-degree count\n    for i in range(1, n + 1):\n        for dep in dependencies[i - 1]:\n            graph[dep].append(i)\n            in_degree[i] += 1\n    \n    # Topological sort using Kahn's algorithm\n    queue = deque()\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    topo_order = []\n    while queue:\n        course = queue.popleft()\n        topo_order.append(course)\n        for neighbor in graph[course]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check if topological sort is possible\n    if len(topo_order) != n:\n        return -1, []\n    \n    # Determine the minimum courses to take\n    required_courses = set(main_courses)\n    course_set = set()\n    result = []\n    \n    for course in topo_order:\n        if course in required_courses:\n            required_courses.remove(course)\n        if course in course_set or course in main_courses:\n            result.append(course)\n            course_set.add(course)\n            for neighbor in graph[course]:\n                course_set.add(neighbor)\n    \n    if required_courses:\n        return -1, []\n    \n    return len(result), result\n\n# Read input\nn, k = map(int, input().split())\nmain_courses = list(map(int, input().split()))\ndependencies = []\n\nfor _ in range(n):\n    line = list(map(int, input().split()))\n    dependencies.append(line[1:])\n\n# Find the course order\nm, order = find_course_order(n, k, main_courses, dependencies)\n\n# Print the result\nif m == -1:\n    print(-1)\nelse:\n    print(m)\n    print(\" \".join(map(str, order)))"}
{"solution": "def is_stack_sortable(a):\n    s = []\n    b = []\n    for num in a:\n        s.append(num)\n        while s and (not b or s[-1] == b[-1] + 1):\n            b.append(s.pop())\n    return len(b) == len(a)\n\ndef restore_permutation(n, k, p):\n    remaining = set(range(1, n + 1)) - set(p)\n    remaining = sorted(remaining, reverse=True)\n    \n    for i in range(len(remaining)):\n        candidate = p + remaining[:i+1]\n        if is_stack_sortable(candidate):\n            return candidate + remaining[i+1:]\n    \n    return -1\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\np = list(map(int, data[2:2+k]))\n\n# Restore permutation\nresult = restore_permutation(n, k, p)\n\n# Print result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "def does_b_appear_in_sequence(a, b, c):\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n# Read input\na, b, c = map(int, input().split())\nprint(does_b_appear_in_sequence(a, b, c))"}
{"solution": "def can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    if cnt_1 == cnt_4:\n        return 1\n    else:\n        return 0\n\n# Example usage:\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\nprint(can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4))"}
{"solution": "def standing_spectators(n, k, t):\n    if t <= k:\n        return t\n    elif t <= n:\n        return k\n    else:\n        return n + k - t\n\n# Read input\nn, k, t = map(int, input().strip().split())\n\n# Calculate and print the number of standing spectators at time t\nprint(standing_spectators(n, k, t))"}
{"solution": "def lexicographically_minimal_string(s):\n    t = []\n    u = []\n    min_char = min(s)\n    s = list(s)\n    \n    while s or t:\n        if t and (not s or t[-1] <= min_char):\n            u.append(t.pop())\n        else:\n            char = s.pop(0)\n            t.append(char)\n            if s:\n                min_char = min(s)\n    \n    return ''.join(u)\n\n# Read input\ns = input().strip()\n# Print the resulting string u\nprint(lexicographically_minimal_string(s))"}
{"solution": "def is_valid_sequence(n, stats):\n    for i in range(1, n):\n        p_prev, c_prev = stats[i-1]\n        p_curr, c_curr = stats[i]\n        \n        # Check if plays and clears are non-decreasing\n        if p_curr < p_prev or c_curr < c_prev:\n            return False\n        \n        # Check if clears do not exceed plays\n        if c_curr > p_curr:\n            return False\n        \n        # Check if the increase in clears does not exceed the increase in plays\n        if (c_curr - c_prev) > (p_curr - p_prev):\n            return False\n    \n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        n = int(data[index])\n        index += 1\n        stats = []\n        \n        for _ in range(n):\n            p = int(data[index])\n            c = int(data[index + 1])\n            stats.append((p, c))\n            index += 2\n        \n        if is_valid_sequence(n, stats):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_palindrome(time_str):\n    return time_str == time_str[::-1]\n\ndef increment_time(hh, mm):\n    mm += 1\n    if mm == 60:\n        mm = 0\n        hh += 1\n        if hh == 24:\n            hh = 0\n    return hh, mm\n\ndef format_time(hh, mm):\n    return f\"{hh:02}:{mm:02}\"\n\ndef minutes_to_next_palindrome(hh, mm):\n    minutes = 0\n    while True:\n        time_str = format_time(hh, mm)\n        if is_palindrome(time_str):\n            return minutes\n        hh, mm = increment_time(hh, mm)\n        minutes += 1\n\nif __name__ == \"__main__\":\n    current_time = input().strip()\n    hh, mm = map(int, current_time.split(':'))\n    print(minutes_to_next_palindrome(hh, mm))"}
{"solution": "def max_distance_after_swap(n, a):\n    # Find the positions of the minimum (1) and maximum (n) elements\n    min_pos = a.index(1)\n    max_pos = a.index(n)\n    \n    # Calculate the initial distance\n    initial_distance = abs(min_pos - max_pos)\n    \n    # Possible new positions after one swap\n    possible_positions = [0, n-1]\n    \n    # Calculate the maximum possible distance after one swap\n    max_distance = initial_distance\n    for pos in possible_positions:\n        max_distance = max(max_distance, abs(pos - min_pos), abs(pos - max_pos))\n    \n    return max_distance\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = max_distance_after_swap(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    mid = n // 2\n    if n % 2 == 0:\n        first_half = s[:mid]\n        second_half = s[mid:]\n    else:\n        first_half = s[:mid]\n        second_half = s[mid+1:]\n    \n    if first_half == second_half[::-1]:\n        print(\"TAK\")\n    else:\n        print(\"NIE\")\n\n# Example usage:\ns = input().strip()\nis_s_palindrome(s)"}
{"solution": "def find_max_permutation(a, b):\n    from itertools import permutations\n\n    a_str = str(a)\n    b_str = str(b)\n    max_num = -1\n\n    for perm in permutations(a_str):\n        perm_str = ''.join(perm)\n        if perm_str[0] != '0' and int(perm_str) <= b:\n            max_num = max(max_num, int(perm_str))\n\n    return max_num\n\n# Read input\na = int(input().strip())\nb = int(input().strip())\n\n# Find and print the result\nresult = find_max_permutation(a, b)\nprint(result)"}
{"solution": "def check_win(board, x, y):\n    directions = [\n        (1, 0), (0, 1), (1, 1), (1, -1)\n    ]\n    \n    for dx, dy in directions:\n        count = 1\n        for i in range(1, 5):\n            nx, ny = x + i * dx, y + i * dy\n            if 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n            else:\n                break\n        for i in range(1, 5):\n            nx, ny = x - i * dx, y - i * dy\n            if 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n            else:\n                break\n        if count >= 5:\n            return True\n    return False\n\ndef can_alice_win(board):\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i][j] = 'X'\n                if check_win(board, i, j):\n                    return \"YES\"\n                board[i][j] = '.'\n    return \"NO\"\n\n# Read input\nboard = [list(input().strip()) for _ in range(10)]\n\n# Determine if Alice can win in one move\nresult = can_alice_win(board)\nprint(result)"}
{"solution": "def generate_matrix(n, k):\n    if k > n * n:\n        return -1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k == 0:\n            break\n        if k >= 2:\n            matrix[i][i] = 1\n            k -= 1\n            for j in range(i + 1, n):\n                if k >= 2:\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n                else:\n                    break\n        elif k == 1:\n            matrix[i][i] = 1\n            k -= 1\n    \n    if k > 0:\n        return -1\n    \n    return matrix\n\ndef print_matrix(matrix):\n    if matrix == -1:\n        print(-1)\n    else:\n        for row in matrix:\n            print(\" \".join(map(str, row)))\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    n = int(data[0])\n    k = int(data[1])\n    \n    result = generate_matrix(n, k)\n    print_matrix(result)"}
{"solution": "import math\n\ndef calculate_expression_values(x, y, z):\n    expressions = [\n        (x ** (y ** z), \"x^y^z\"),\n        (x ** (z ** y), \"x^z^y\"),\n        ((x ** y) ** z, \"(x^y)^z\"),\n        ((x ** z) ** y, \"(x^z)^y\"),\n        (y ** (x ** z), \"y^x^z\"),\n        (y ** (z ** x), \"y^z^x\"),\n        ((y ** x) ** z, \"(y^x)^z\"),\n        ((y ** z) ** x, \"(y^z)^x\"),\n        (z ** (x ** y), \"z^x^y\"),\n        (z ** (y ** x), \"z^y^x\"),\n        ((z ** x) ** y, \"(z^x)^y\"),\n        ((z ** y) ** x, \"(z^y)^x\")\n    ]\n    return expressions\n\ndef find_max_expression(x, y, z):\n    expressions = calculate_expression_values(x, y, z)\n    max_value, max_expression = max(expressions, key=lambda item: item[0])\n    return max_expression\n\nif __name__ == \"__main__\":\n    x, y, z = map(float, input().split())\n    result = find_max_expression(x, y, z)\n    print(result)"}
{"solution": "def min_operations_to_type_string(n, s):\n    # Function to find the minimum number of operations to type the string\n    def min_operations(s):\n        length = len(s)\n        for i in range(1, length // 2 + 1):\n            if s[:i] == s[i:2*i]:\n                return i + 1 + (length - 2 * i)\n        return length\n\n    print(min_operations(s))\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Calculate and print the minimum number of operations\nmin_operations_to_type_string(n, s)"}
{"solution": "def rename_files(n, files):\n    examples = []\n    regulars = []\n    for name, type_ in files:\n        if type_ == '1':\n            examples.append(name)\n        else:\n            regulars.append(name)\n    \n    moves = []\n    temp_name = 'temp'\n    used_temp = False\n    \n    # Renaming examples\n    for i in range(1, len(examples) + 1):\n        if examples[i - 1] != str(i):\n            if str(i) in examples or str(i) in regulars:\n                moves.append(f\"move {str(i)} {temp_name}\")\n                used_temp = True\n            moves.append(f\"move {examples[i - 1]} {str(i)}\")\n    \n    # Renaming regulars\n    for i in range(len(examples) + 1, n + 1):\n        if regulars[i - len(examples) - 1] != str(i):\n            if str(i) in examples or str(i) in regulars:\n                moves.append(f\"move {str(i)} {temp_name}\")\n                used_temp = True\n            moves.append(f\"move {regulars[i - len(examples) - 1]} {str(i)}\")\n    \n    if used_temp:\n        moves.append(f\"move {temp_name} {str(i + 1)}\")\n    \n    return moves\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn = int(data[0])\nfiles = [line.split() for line in data[1:]]\n\n# Generating the moves\nmoves = rename_files(n, files)\n\n# Printing the result\nprint(len(moves))\nfor move in moves:\n    print(move)"}
{"solution": "def min_changes_to_lucky_ticket(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first_half = sum(first_half)\n    sum_second_half = sum(second_half)\n    \n    if sum_first_half == sum_second_half:\n        return 0\n    \n    diff = abs(sum_first_half - sum_second_half)\n    \n    changes = []\n    \n    if sum_first_half > sum_second_half:\n        changes = sorted(first_half, reverse=True)\n    else:\n        changes = sorted(second_half, reverse=True)\n    \n    for i in range(3):\n        changes[i] = 9 - changes[i]\n    \n    changes.sort(reverse=True)\n    \n    count = 0\n    for change in changes:\n        diff -= change\n        count += 1\n        if diff <= 0:\n            return count\n    \n    return count\n\nticket = input().strip()\nprint(min_changes_to_lucky_ticket(ticket))"}
{"solution": "def minimum_traps(m, x):\n    return m - 1\n\n# Read input\nm, x = map(int, input().split())\n\n# Calculate and print the minimum number of traps needed\nprint(minimum_traps(m, x))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef birthday_paradox(n, k):\n    MOD = 10**6 + 3\n    days = 2**n\n\n    if k > days:\n        print(1, 1)\n        return\n\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator = (numerator * (days - i)) % MOD\n        denominator = (denominator * days) % MOD\n\n    prob_no_shared_birthday = numerator * mod_inverse(denominator, MOD) % MOD\n    prob_shared_birthday = (1 - prob_no_shared_birthday + MOD) % MOD\n\n    A = prob_shared_birthday\n    B = 1\n\n    g = gcd(A, B)\n    A //= g\n    B //= g\n\n    print(A, B)\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    n, k = map(int, input().strip().split())\n    birthday_paradox(n, k)"}
{"solution": "def is_valid_journey(n, journey):\n    position = 0  # Start at the North Pole (0 km from the North Pole)\n\n    for t, dir in journey:\n        if position == 0 and dir != \"South\":\n            return \"NO\"\n        if position == 20000 and dir != \"North\":\n            return \"NO\"\n        \n        if dir == \"North\":\n            position -= t\n        elif dir == \"South\":\n            position += t\n        \n        if position < 0 or position > 20000:\n            return \"NO\"\n    \n    if position == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input().strip())\njourney = []\nfor _ in range(n):\n    t, dir = input().strip().split()\n    t = int(t)\n    journey.append((t, dir))\n\n# Check if the journey is valid\nresult = is_valid_journey(n, journey)\nprint(result)"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef find_common_elements(a1, b1, a2, b2, L, R):\n    # Calculate the gcd of a1 and a2\n    g = gcd(a1, a2)\n    \n    # Calculate the difference between b1 and b2\n    diff = b2 - b1\n    \n    # If the difference is not divisible by the gcd, there are no common elements\n    if diff % g != 0:\n        return 0\n    \n    # Calculate the first common element\n    k = (diff // g) % (a2 // g)\n    first_common = a1 * k + b1\n    \n    # If the first common element is out of range, return 0\n    if first_common < L:\n        first_common += ((L - first_common + a1 * (a2 // g) - 1) // (a1 * (a2 // g))) * (a1 * (a2 // g))\n    elif first_common > R:\n        return 0\n    \n    # Calculate the step size for common elements\n    step = a1 * (a2 // g)\n    \n    # Calculate the number of common elements in the range [L, R]\n    if first_common > R:\n        return 0\n    else:\n        return (R - first_common) // step + 1\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Find and print the number of common elements\nprint(find_common_elements(a1, b1, a2, b2, L, R))"}
{"solution": "def max_min_pieces(n, a, b):\n    # Binary search for the maximum possible x\n    left, right = 1, min(a, b)\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # Check if it's possible to distribute at least mid pieces on each plate\n        if (a // mid) + (b // mid) >= n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return right\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(max_min_pieces(n, a, b))"}
{"solution": "def is_valid_flag(n, m, field):\n    def check_stripes(lines):\n        if len(lines) % 3 != 0:\n            return False\n        stripe_height = len(lines) // 3\n        colors = set()\n        for i in range(3):\n            stripe = lines[i * stripe_height:(i + 1) * stripe_height]\n            color = stripe[0][0]\n            if any(row != color * m for row in stripe):\n                return False\n            colors.add(color)\n        return len(colors) == 3\n\n    if check_stripes(field):\n        return \"YES\"\n    \n    transposed_field = [''.join(row) for row in zip(*field)]\n    if check_stripes(transposed_field):\n        return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Check if the field is a valid flag\nprint(is_valid_flag(n, m, field))"}
{"solution": "def find_coordinates(n):\n    if n == 0:\n        return (0, 0)\n    \n    # Directions in the order of the spiral\n    directions = [(1, 0), (0, 1), (-1, 1), (-1, 0), (0, -1), (1, -1)]\n    \n    # Initialize the starting point\n    x, y = 0, 0\n    step = 1\n    move_count = 0\n    \n    while move_count < n:\n        for direction in directions:\n            for _ in range(step):\n                if move_count == n:\n                    return (x, y)\n                x += direction[0]\n                y += direction[1]\n                move_count += 1\n            if move_count == n:\n                return (x, y)\n        step += 1\n\n    return (x, y)\n\n# Read input\nn = int(input().strip())\n\n# Find and print the coordinates\nx, y = find_coordinates(n)\nprint(x, y)"}
{"solution": "import math\n\ndef can_break_shield(a, b, c):\n    # Calculate the greatest common divisor of a and b\n    gcd_ab = math.gcd(a, b)\n    \n    # Check if c is divisible by the gcd of a and b\n    if c % gcd_ab == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input values\na, b, c = map(int, input().split())\n\n# Output the result\nprint(can_break_shield(a, b, c))"}
{"solution": "def can_tracks_coincide(n, L, kefa_barriers, sasha_barriers):\n    # Calculate distances between consecutive barriers for Kefa\n    kefa_distances = [(kefa_barriers[(i + 1) % n] - kefa_barriers[i]) % L for i in range(n)]\n    # Calculate distances between consecutive barriers for Sasha\n    sasha_distances = [(sasha_barriers[(i + 1) % n] - sasha_barriers[i]) % L for i in range(n)]\n    \n    # Double the kefa_distances to handle circular rotation\n    doubled_kefa_distances = kefa_distances + kefa_distances\n    \n    # Check if sasha_distances is a sublist of doubled_kefa_distances\n    for i in range(n):\n        if doubled_kefa_distances[i:i + n] == sasha_distances:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_barriers, sasha_barriers))"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindromic_substring_length(s):\n    n = len(s)\n    \n    # If the entire string is not a palindrome, return its length\n    if not is_palindrome(s):\n        return n\n    \n    # Check if all characters are the same\n    if all(c == s[0] for c in s):\n        return 0\n    \n    # Otherwise, the longest non-palindromic substring will be either\n    # the string without the first character or the string without the last character\n    return n - 1\n\n# Read input\ns = input().strip()\n\n# Get the result\nresult = longest_non_palindromic_substring_length(s)\n\n# Print the result\nprint(result)"}
{"solution": "def determine_round_status(n, ratings):\n    rated = False\n    unrated = False\n    \n    for i in range(n):\n        if ratings[i][0] != ratings[i][1]:\n            rated = True\n            break\n    \n    if not rated:\n        for i in range(1, n):\n            if ratings[i-1][0] < ratings[i][0]:\n                unrated = True\n                break\n    \n    if rated:\n        print(\"rated\")\n    elif unrated:\n        print(\"unrated\")\n    else:\n        print(\"maybe\")\n\n# Read input\nn = int(input().strip())\nratings = [tuple(map(int, input().strip().split())) for _ in range(n)]\n\n# Determine and print the round status\ndetermine_round_status(n, ratings)"}
{"solution": "def find_nearest_zero_distances(n, arr):\n    distances = [float('inf')] * n\n    last_zero_index = -1\n\n    # Forward pass to find nearest zero on the left\n    for i in range(n):\n        if arr[i] == 0:\n            last_zero_index = i\n        if last_zero_index != -1:\n            distances[i] = i - last_zero_index\n\n    last_zero_index = -1\n\n    # Backward pass to find nearest zero on the right\n    for i in range(n-1, -1, -1):\n        if arr[i] == 0:\n            last_zero_index = i\n        if last_zero_index != -1:\n            distances[i] = min(distances[i], last_zero_index - i)\n\n    return distances\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Find distances to nearest zero\ndistances = find_nearest_zero_distances(n, arr)\n\n# Print the result\nprint(\" \".join(map(str, distances)))"}
{"solution": "def count_distinct_cyclical_strings(n, s):\n    from itertools import product\n    \n    def is_substring_in_cyclical_shifts(t, s):\n        t_extended = t + t\n        return any(s in t_extended[i:i+len(t)] for i in range(len(t)))\n    \n    distinct_cyclical_strings = set()\n    \n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if is_substring_in_cyclical_shifts(t, s):\n            distinct_cyclical_strings.add(t)\n    \n    return len(distinct_cyclical_strings)\n\n# Example usage\nn = int(input())\ns = input().strip()\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import math\n\ndef angle_between(v1, v2):\n    dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n    magnitude_v1 = math.sqrt(v1[0]**2 + v1[1]**2)\n    magnitude_v2 = math.sqrt(v2[0]**2 + v2[1]**2)\n    cos_theta = dot_product / (magnitude_v1 * magnitude_v2)\n    return math.acos(cos_theta)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    vectors = []\n    for i in range(n):\n        x = int(data[2 * i + 1])\n        y = int(data[2 * i + 2])\n        vectors.append((x, y, i + 1))\n    \n    vectors.sort(key=lambda v: math.atan2(v[1], v[0]))\n    \n    min_angle = float('inf')\n    min_pair = (0, 0)\n    \n    for i in range(n):\n        v1 = vectors[i]\n        v2 = vectors[(i + 1) % n]\n        angle = angle_between(v1, v2)\n        if angle < min_angle:\n            min_angle = angle\n            min_pair = (v1[2], v2[2])\n    \n    print(min_pair[0], min_pair[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def minimal_time(d, k, a, b, t):\n    if d <= k:\n        return d * a\n    \n    # Full segments\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Time for full segments\n    time_for_full_segments = full_segments * k * a + (full_segments - 1) * t\n    \n    # Time for remaining distance\n    if remaining_distance == 0:\n        return time_for_full_segments\n    else:\n        # Option 1: Drive the remaining distance\n        time_drive_remaining = remaining_distance * a + t\n        # Option 2: Walk the remaining distance\n        time_walk_remaining = remaining_distance * b\n        \n        return time_for_full_segments + min(time_drive_remaining, time_walk_remaining)\n\n# Read input\nd, k, a, b, t = map(int, input().split())\n\n# Print the result\nprint(minimal_time(d, k, a, b, t))"}
{"solution": "def find_sequence(n, k):\n    # Check if it's possible to create a sequence\n    if k * (k + 1) // 2 > n:\n        return -1\n    \n    # Initialize the sequence with the first k natural numbers\n    sequence = list(range(1, k + 1))\n    \n    # Calculate the remaining sum to be distributed\n    remaining_sum = n - sum(sequence)\n    \n    # Distribute the remaining sum to maximize the GCD\n    for i in range(k - 1, -1, -1):\n        add = min(remaining_sum, sequence[i])\n        sequence[i] += add\n        remaining_sum -= add\n        if remaining_sum == 0:\n            break\n    \n    return sequence\n\n# Read input\nn, k = map(int, input().split())\n\n# Find the sequence\nresult = find_sequence(n, k)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def count_pairs(n, m):\n    # Count how many numbers in range 1 to n have each remainder when divided by 5\n    count_n = [0] * 5\n    for i in range(1, n + 1):\n        count_n[i % 5] += 1\n\n    # Count how many numbers in range 1 to m have each remainder when divided by 5\n    count_m = [0] * 5\n    for i in range(1, m + 1):\n        count_m[i % 5] += 1\n\n    # Calculate the number of valid pairs\n    result = 0\n    for i in range(5):\n        result += count_n[i] * count_m[(5 - i) % 5]\n\n    return result\n\n# Read input\nn, m = map(int, input().split())\n\n# Print the result\nprint(count_pairs(n, m))"}
{"solution": "def max_beauty(n, x, a):\n    # Initialize variables to store the maximum subarray sums\n    max_ending_here = 0\n    max_so_far = 0\n    max_ending_here_with_x = 0\n    max_so_far_with_x = 0\n    max_ending_here_after_x = 0\n    max_so_far_after_x = 0\n\n    for i in range(n):\n        # Calculate the maximum subarray sum without any multiplication\n        max_ending_here = max(0, max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n\n        # Calculate the maximum subarray sum with multiplication by x\n        max_ending_here_with_x = max(max_ending_here_with_x + a[i] * x, max_ending_here + a[i] * x, a[i] * x)\n        max_so_far_with_x = max(max_so_far_with_x, max_ending_here_with_x)\n\n        # Calculate the maximum subarray sum after the multiplication by x\n        max_ending_here_after_x = max(max_ending_here_after_x + a[i], max_ending_here_with_x + a[i])\n        max_so_far_after_x = max(max_so_far_after_x, max_ending_here_after_x)\n\n    # The result is the maximum of the three scenarios\n    return max(max_so_far, max_so_far_with_x, max_so_far_after_x)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nprint(max_beauty(n, x, a))"}
{"solution": "def find_kth_largest(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(m, x // i)\n        return count\n\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_less_equal(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\n# Read input\nimport sys\ninput = sys.stdin.read\nn, m, k = map(int, input().split())\n\n# Print the k-th largest number\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    # Initialize variables to keep track of the current length of the sequence\n    length = 0\n    digit_length = 1\n    count = 9\n\n    # Determine the range in which the k-th digit falls\n    while k > length + digit_length * count:\n        length += digit_length * count\n        digit_length += 1\n        count *= 10\n\n    # Calculate the actual number and the specific digit within that number\n    k -= length\n    start = 10**(digit_length - 1)\n    number = start + (k - 1) // digit_length\n    digit_index = (k - 1) % digit_length\n\n    # Convert the number to string and get the k-th digit\n    return str(number)[digit_index]\n\n# Read input\nk = int(input().strip())\n\n# Print the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "# Read input values\nn, m, r = map(int, input().split())\nbuy_prices = list(map(int, input().split()))\nsell_prices = list(map(int, input().split()))\n\n# Find the minimum buy price and maximum sell price\nmin_buy_price = min(buy_prices)\nmax_sell_price = max(sell_prices)\n\n# If the maximum sell price is less than or equal to the minimum buy price, no profit can be made\nif max_sell_price <= min_buy_price:\n    print(r)\nelse:\n    # Calculate the maximum number of shares that can be bought\n    shares_bought = r // min_buy_price\n    remaining_bourles = r % min_buy_price\n    \n    # Calculate the total bourles after selling the shares\n    total_bourles = shares_bought * max_sell_price + remaining_bourles\n    print(total_bourles)"}
{"solution": "def find_original_message(t):\n    n = len(t)\n    \n    # \u041f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u0432\u0441\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0434\u043b\u0438\u043d\u044b \u043d\u0430\u043b\u043e\u0436\u0435\u043d\u0438\u044f\n    for overlap in range(1, n // 2 + 1):\n        # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u043c\u043e\u0436\u043d\u043e \u043b\u0438 \u0440\u0430\u0437\u0434\u0435\u043b\u0438\u0442\u044c \u0441\u0442\u0440\u043e\u043a\u0443 t \u043d\u0430 \u0434\u0432\u0435 \u0447\u0430\u0441\u0442\u0438 \u0441 \u043d\u0430\u043b\u043e\u0436\u0435\u043d\u0438\u0435\u043c \u0434\u043b\u0438\u043d\u044b overlap\n        if t[:overlap] == t[-overlap:]:\n            s = t[:-overlap]\n            if s + t[-overlap:] == t:\n                return \"YES\", s\n    \n    return \"NO\", None\n\n# \u0427\u0442\u0435\u043d\u0438\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\nt = input().strip()\n\n# \u041f\u043e\u0438\u0441\u043a \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0433\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f s\nresult, s = find_original_message(t)\n\n# \u0412\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\nprint(result)\nif result == \"YES\":\n    print(s)"}
{"solution": "def find_teams_for_games(n):\n    results = []\n\n    # Check for each possible number of teams\n    for initial_teams in range(1, 2 * n + 1):\n        games_played = 0\n        teams = initial_teams\n\n        # Simulate the elimination stages\n        while teams % 2 == 0:\n            games_played += teams // 2\n            teams //= 2\n\n        # If there are more than one team left, simulate the round robin stage\n        if teams > 1:\n            games_played += teams * (teams - 1) // 2\n\n        # Check if the total games played matches the required number of games\n        if games_played == n:\n            results.append(initial_teams)\n\n    # Print the results\n    if results:\n        for result in results:\n            print(result)\n    else:\n        print(-1)\n\n# Read input\nn = int(input().strip())\n\n# Find and print the possible number of teams\nfind_teams_for_games(n)"}
{"solution": "def max_beauty(n, s, b):\n    from collections import Counter\n    import itertools\n\n    # Count the frequency of each character in the string\n    freq = Counter(s)\n    \n    # Create a list of characters sorted by their frequency in descending order\n    sorted_chars = sorted(freq.keys(), key=lambda x: -freq[x])\n    \n    # Create a list of indices sorted by their beauty in descending order\n    sorted_indices = sorted(range(n), key=lambda x: -b[x])\n    \n    # Initialize the result string with placeholders\n    t = [''] * n\n    \n    # Fill the result string with characters ensuring antipalindromic property\n    for i in range(n // 2):\n        char = sorted_chars[i % len(sorted_chars)]\n        t[sorted_indices[i]] = char\n        t[sorted_indices[n - i - 1]] = char\n    \n    # Calculate the maximum possible beauty\n    max_beauty = sum(b[i] for i in range(n) if s[i] == t[i])\n    \n    return max_beauty\n\n# Read input\nn = int(input())\ns = input().strip()\nb = list(map(int, input().split()))\n\n# Calculate and print the maximum possible beauty\nprint(max_beauty(n, s, b))"}
{"solution": "def can_weigh(w, m):\n    while m > 0:\n        if m % w == 0:\n            m //= w\n        elif (m + 1) % w == 0:\n            m = (m + 1) // w\n        elif (m - 1) % w == 0:\n            m = (m - 1) // w\n        else:\n            return \"NO\"\n    return \"YES\"\n\n# Read input\nw, m = map(int, input().split())\n\n# Determine if the item can be weighed\nresult = can_weigh(w, m)\n\n# Print the result\nprint(result)"}
{"solution": "def solve(n, k):\n    # Check if it's possible to represent n as the sum of k powers of 2\n    if n < k or n > (1 << k) - 1:\n        print(\"No\")\n        return\n    \n    # Initialize the result array with k elements, all set to 0\n    result = [0] * k\n    \n    # Start with the largest power of 2 that is less than or equal to n\n    power = 0\n    while (1 << (power + 1)) <= n:\n        power += 1\n    \n    # Fill the result array with the largest power of 2\n    for i in range(k):\n        result[i] = power\n        n -= (1 << power)\n    \n    # Adjust the result array to make the sum exactly n\n    for i in range(k):\n        while n < (1 << result[i]):\n            result[i] -= 1\n            n += (1 << (result[i] + 1))\n    \n    # Sort the result array in descending order to get the lexicographically largest sequence\n    result.sort(reverse=True)\n    \n    print(\"Yes\")\n    print(\" \".join(map(str, result)))\n\n# Read input\nn, k = map(int, input().split())\nsolve(n, k)"}
{"solution": "def count_full_glasses(n, t):\n    # Initialize a 2D list to represent the pyramid of glasses\n    glasses = [[0] * (i + 1) for i in range(n)]\n    \n    # Pour champagne into the top glass for t seconds\n    for _ in range(t):\n        glasses[0][0] += 1\n        for i in range(n):\n            for j in range(i + 1):\n                if glasses[i][j] > 1:\n                    overflow = glasses[i][j] - 1\n                    glasses[i][j] = 1\n                    if i + 1 < n:\n                        glasses[i + 1][j] += overflow / 2\n                        glasses[i + 1][j + 1] += overflow / 2\n    \n    # Count the number of completely full glasses\n    full_glasses = sum(1 for i in range(n) for j in range(i + 1) if glasses[i][j] == 1)\n    \n    return full_glasses\n\n# Read input\nn, t = map(int, input().split())\n\n# Calculate and print the number of full glasses\nprint(count_full_glasses(n, t))"}
{"solution": "def calculate_area(n, vertices):\n    if n == 1:\n        return -1\n    elif n == 2:\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        if x1 != x2 and y1 != y2:\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 3:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 4:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n\n# Read input\nn = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the area\nprint(calculate_area(n, vertices))"}
{"solution": "def minimal_wooden_bars(n, a, b):\n    # Total length needed for one door frame\n    total_length_one_door = 2 * a + b\n    # Total length needed for two door frames\n    total_length_two_doors = 2 * total_length_one_door\n    \n    # Calculate the minimal number of wooden bars needed\n    minimal_bars = (total_length_two_doors + n - 1) // n\n    \n    return minimal_bars\n\n# Read input values\nn = int(input())\na = int(input())\nb = int(input())\n\n# Calculate and print the result\nprint(minimal_wooden_bars(n, a, b))"}
{"solution": "def can_sort_array(n, a, s):\n    segments = []\n    start = 0\n\n    # Identify segments where swaps are allowed\n    for i in range(n - 1):\n        if s[i] == '0':\n            segments.append((start, i))\n            start = i + 1\n    segments.append((start, n - 1))\n\n    # Check if each segment can be sorted independently\n    for start, end in segments:\n        if sorted(a[start:end + 1]) != a[start:end + 1]:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\ns = input().strip()\n\n# Determine if the array can be sorted\nresult = can_sort_array(n, a, s)\nprint(result)"}
{"solution": "def time_to_get_lunch(seat):\n    # Parse the input\n    row = int(seat[:-1])\n    seat_letter = seat[-1]\n    \n    # Determine the seat position\n    seat_positions = {'a': 5, 'b': 4, 'c': 3, 'd': 3, 'e': 4, 'f': 5}\n    seat_time = seat_positions[seat_letter]\n    \n    # Determine the initial row of the attendant serving the given row\n    if row % 4 == 1 or row % 4 == 2:\n        initial_row = 1\n    else:\n        initial_row = 3\n    \n    # Calculate the time taken to reach the given row\n    full_cycles = (row - initial_row) // 4\n    remaining_rows = (row - initial_row) % 4\n    \n    time = full_cycles * 12  # Each full cycle takes 12 seconds (6 seconds serving + 6 seconds moving)\n    \n    if remaining_rows == 1:\n        time += 0  # No additional time needed\n    elif remaining_rows == 2:\n        time += 7  # 6 seconds serving + 1 second moving\n    elif remaining_rows == 3:\n        time += 8  # 6 seconds serving + 1 second moving + 1 second moving\n    \n    # Add the time to serve the specific seat\n    time += seat_time\n    \n    return time\n\n# Read input\nseat = input().strip()\n\n# Calculate and print the result\nprint(time_to_get_lunch(seat))"}
{"solution": "def convert_to_decimal(digits, base):\n    decimal_value = 0\n    for digit in digits:\n        decimal_value = decimal_value * base + digit\n    return decimal_value\n\n# Read input\nn, b_x = map(int, input().split())\nx_digits = list(map(int, input().split()))\nm, b_y = map(int, input().split())\ny_digits = list(map(int, input().split()))\n\n# Convert both numbers to decimal\nX = convert_to_decimal(x_digits, b_x)\nY = convert_to_decimal(y_digits, b_y)\n\n# Compare the two numbers\nif X < Y:\n    print('<')\nelif X > Y:\n    print('>')\nelse:\n    print('=')"}
{"solution": "def determine_winner(n, a):\n    if n == 1:\n        # If there's only one number, BitLGM can always win by reducing it to 0\n        return \"BitLGM\"\n    elif n == 2:\n        # If there are two numbers, the game is similar to Nim game with two piles\n        if a[0] == a[1]:\n            return \"BitLGM\"\n        else:\n            return \"BitAryo\"\n    else:\n        # If there are three numbers, we need to check the Nim-sum\n        nim_sum = a[0] ^ a[1] ^ a[2]\n        if nim_sum == 0:\n            return \"BitAryo\"\n        else:\n            return \"BitLGM\"\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Determine the winner\nwinner = determine_winner(n, a)\n\n# Print the result\nprint(winner)"}
{"solution": "def count_valid_decks(n, k, cards):\n    from math import gcd\n    from functools import reduce\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def product_divisible_by_k(product, k):\n        return product % k == 0\n\n    # Precompute prefix and suffix products\n    prefix_products = [1] * (n + 1)\n    suffix_products = [1] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_products[i] = prefix_products[i - 1] * cards[i - 1]\n    \n    for i in range(n - 1, -1, -1):\n        suffix_products[i] = suffix_products[i + 1] * cards[i]\n\n    valid_count = 0\n\n    # Check all possible (x, y) pairs\n    for x in range(n):\n        for y in range(n - x):\n            if x + y < n:\n                product = prefix_products[x] * suffix_products[n - y]\n                if product_divisible_by_k(product, k):\n                    valid_count += 1\n\n    return valid_count\n\n# Read input\nn, k = map(int, input().split())\ncards = list(map(int, input().split()))\n\n# Calculate and print the number of valid decks\nprint(count_valid_decks(n, k, cards))"}
{"solution": "def can_distribute_balloons(n, k, s):\n    from collections import Counter\n    \n    # Count the frequency of each balloon color\n    color_count = Counter(s)\n    \n    # Check if any color appears more times than there are friends\n    for count in color_count.values():\n        if count > k:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Determine if Kefa can distribute the balloons without upsetting any friends\nresult = can_distribute_balloons(n, k, s)\nprint(result)"}
{"solution": "# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Find the minimum value in the array\nmin_value = min(a)\n\n# Initialize variables to track the minimum distance\nmin_distance = float('inf')\nlast_min_index = -1\n\n# Iterate through the array to find the minimum distance between two closest minimums\nfor i in range(n):\n    if a[i] == min_value:\n        if last_min_index != -1:\n            min_distance = min(min_distance, i - last_min_index)\n        last_min_index = i\n\n# Print the result\nprint(min_distance)"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(t, w, b):\n    if w > b:\n        w, b = b, w\n\n    lcm_wb = (w * b) // gcd(w, b)\n    \n    # Calculate the number of tie cases\n    tie_cases = (t // lcm_wb) * w + min(w, t % lcm_wb + 1) - 1\n    \n    # Total possible cases\n    total_cases = t\n    \n    # Reduce the fraction\n    common_divisor = gcd(tie_cases, total_cases)\n    p = tie_cases // common_divisor\n    q = total_cases // common_divisor\n    \n    print(f\"{p}/{q}\")\n\n# Read input\nt, w, b = map(int, input().split())\n\n# Solve the problem\nsolve(t, w, b)"}
{"solution": "def determine_vote_result(x, y, z):\n    if x > y + z:\n        return \"+\"\n    elif y > x + z:\n        return \"-\"\n    elif x == y and z == 0:\n        return \"0\"\n    else:\n        return \"?\"\n\n# Read input\nx, y, z = map(int, input().split())\n\n# Determine and print the result\nprint(determine_vote_result(x, y, z))"}
{"solution": "def min_length_to_target(n, operations, x, y):\n    # Calculate the final position after performing the given operations\n    final_x, final_y = 0, 0\n    for op in operations:\n        if op == 'U':\n            final_y += 1\n        elif op == 'D':\n            final_y -= 1\n        elif op == 'L':\n            final_x -= 1\n        elif op == 'R':\n            final_x += 1\n\n    # If the final position is already the target, no changes are needed\n    if final_x == x and final_y == y:\n        return 0\n\n    # Calculate the difference between the final position and the target\n    dx, dy = x - final_x, y - final_y\n\n    # If the difference is greater than the number of operations, it's impossible\n    if abs(dx) + abs(dy) > n:\n        return -1\n\n    # Use a sliding window to find the minimum length of the subsegment to change\n    min_length = float('inf')\n    current_x, current_y = 0, 0\n    left = 0\n\n    for right in range(n):\n        if operations[right] == 'U':\n            current_y += 1\n        elif operations[right] == 'D':\n            current_y -= 1\n        elif operations[right] == 'L':\n            current_x -= 1\n        elif operations[right] == 'R':\n            current_x += 1\n\n        while current_x + dx == 0 and current_y + dy == 0:\n            min_length = min(min_length, right - left + 1)\n            if operations[left] == 'U':\n                current_y -= 1\n            elif operations[left] == 'D':\n                current_y += 1\n            elif operations[left] == 'L':\n                current_x += 1\n            elif operations[left] == 'R':\n                current_x -= 1\n            left += 1\n\n    return min_length if min_length != float('inf') else -1\n\n# Read input\nn = int(input().strip())\noperations = input().strip()\nx, y = map(int, input().strip().split())\n\n# Get the result and print it\nresult = min_length_to_target(n, operations, x, y)\nprint(result)"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    \n    results = []\n    \n    for _ in range(T):\n        n = int(data[index])\n        x = int(data[index + 1])\n        s = data[index + 2]\n        index += 3\n        \n        balance_s = s.count('0') - s.count('1')\n        prefix_balances = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix_balances[i + 1] = prefix_balances[i] + (1 if s[i] == '0' else -1)\n        \n        if balance_s == 0:\n            if x in prefix_balances:\n                results.append(-1)\n            else:\n                results.append(0)\n        else:\n            count = 0\n            for b in prefix_balances:\n                if (x - b) % balance_s == 0 and (x - b) // balance_s >= 0:\n                    count += 1\n            results.append(count)\n    \n    for result in results:\n        print(result)"}
{"solution": "def min_deletions_to_make_divisible(n, k):\n    n_str = str(n)\n    target_zeros = '0' * k\n    count = 0\n    zeros_found = 0\n\n    # Traverse the number from the end to the beginning\n    for digit in reversed(n_str):\n        if digit == '0':\n            zeros_found += 1\n            if zeros_found == k:\n                break\n        else:\n            count += 1\n\n    # If we have not found enough zeros, we need to delete more digits\n    if zeros_found < k:\n        count += (k - zeros_found)\n\n    return count\n\n# Read input\nn, k = map(int, input().split())\n\n# Get the result\nresult = min_deletions_to_make_divisible(n, k)\n\n# Print the result\nprint(result)"}
{"solution": "def solve(n, m, k, x, y):\n    if n == 1:\n        # Special case when there is only one row\n        max_questions = (k + m - 1) // m\n        min_questions = k // m\n        sergei_questions = (k + y - 1) // m\n    else:\n        # Calculate the number of full cycles\n        full_cycle_length = 2 * n * m - n * m\n        full_cycles = k // full_cycle_length\n        remaining_questions = k % full_cycle_length\n\n        # Calculate the base number of questions for each pupil\n        base_questions = full_cycles * 2\n        if remaining_questions > 0:\n            base_questions += 1\n\n        # Calculate the number of questions for each row\n        row_questions = [base_questions] * n\n        if remaining_questions > n * m:\n            for i in range(n):\n                row_questions[i] += 1\n            remaining_questions -= n * m\n            for i in range(n - 1, -1, -1):\n                if remaining_questions > 0:\n                    row_questions[i] += 1\n                    remaining_questions -= m\n        else:\n            for i in range(n):\n                if remaining_questions > 0:\n                    row_questions[i] += 1\n                    remaining_questions -= m\n\n        # Calculate the maximum and minimum number of questions\n        max_questions = max(row_questions)\n        min_questions = min(row_questions)\n\n        # Calculate the number of questions for Sergei\n        sergei_questions = base_questions\n        if x <= remaining_questions // m:\n            sergei_questions += 1\n        elif x == n and remaining_questions % m >= y:\n            sergei_questions += 1\n\n    print(max_questions, min_questions, sergei_questions)\n\n# Example usage\nn, m, k, x, y = map(int, input().split())\nsolve(n, m, k, x, y)"}
{"solution": "def calculate_beauty(ribbon, n):\n    from collections import Counter\n    \n    length = len(ribbon)\n    counter = Counter(ribbon)\n    max_freq = max(counter.values())\n    \n    if max_freq == length and n == 1:\n        return length - 1\n    return min(length, max_freq + n)\n\ndef determine_winner(n, kuro, shiro, katie):\n    kuro_beauty = calculate_beauty(kuro, n)\n    shiro_beauty = calculate_beauty(shiro, n)\n    katie_beauty = calculate_beauty(katie, n)\n    \n    max_beauty = max(kuro_beauty, shiro_beauty, katie_beauty)\n    \n    winners = []\n    if kuro_beauty == max_beauty:\n        winners.append(\"Kuro\")\n    if shiro_beauty == max_beauty:\n        winners.append(\"Shiro\")\n    if katie_beauty == max_beauty:\n        winners.append(\"Katie\")\n    \n    if len(winners) > 1:\n        return \"Draw\"\n    return winners[0]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nkuro = data[1]\nshiro = data[2]\nkatie = data[3]\n\n# Determine the winner\nwinner = determine_winner(n, kuro, shiro, katie)\nprint(winner)"}
{"solution": "def calculate_days_to_finish_book(c, v_0, v_1, a, l):\n    days = 0\n    pages_read = 0\n    current_speed = v_0\n\n    while pages_read < c:\n        days += 1\n        if days == 1:\n            pages_read += current_speed\n        else:\n            pages_read += current_speed - l\n        \n        if pages_read >= c:\n            break\n        \n        current_speed = min(current_speed + a, v_1)\n    \n    return days\n\n# Read input\nc, v_0, v_1, a, l = map(int, input().split())\n\n# Calculate and print the number of days needed to finish the book\nprint(calculate_days_to_finish_book(c, v_0, v_1, a, l))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_primes(n):\n    if is_prime(n):\n        return [n]\n    for i in range(2, n):\n        if is_prime(i) and is_prime(n - i):\n            return [i, n - i]\n    for i in range(2, n):\n        if is_prime(i):\n            for j in range(2, n - i):\n                if is_prime(j) and is_prime(n - i - j):\n                    return [i, j, n - i - j]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    n = int(input().strip())\n    \n    primes = find_primes(n)\n    print(len(primes))\n    print(\" \".join(map(str, primes)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    grid = []\n    index = 2\n    for i in range(n):\n        grid.append(data[index])\n        index += 1\n    \n    row_walls = [0] * n\n    col_walls = [0] * m\n    total_walls = 0\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*':\n                row_walls[i] += 1\n                col_walls[j] += 1\n                total_walls += 1\n    \n    for i in range(n):\n        for j in range(m):\n            if row_walls[i] + col_walls[j] - (1 if grid[i][j] == '*' else 0) == total_walls:\n                print(\"YES\")\n                print(i + 1, j + 1)\n                return\n    \n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def minimal_burles(n, m, a, b):\n    remainder = n % m\n    if remainder == 0:\n        return 0\n    \n    # Cost to build boxes to make n divisible by m\n    build_cost = (m - remainder) * a\n    \n    # Cost to demolish boxes to make n divisible by m\n    demolish_cost = remainder * b\n    \n    return min(build_cost, demolish_cost)\n\n# Read input\nn, m, a, b = map(int, input().split())\n\n# Calculate and print the minimal amount of burles\nprint(minimal_burles(n, m, a, b))"}
{"solution": "def max_odd_sum_subsequence(n, a):\n    total_sum = sum(a)\n    \n    if total_sum % 2 != 0:\n        return total_sum\n    \n    min_odd = float('inf')\n    \n    for num in a:\n        if num % 2 != 0:\n            min_odd = min(min_odd, abs(num))\n    \n    return total_sum - min_odd\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find and print the result\nprint(max_odd_sum_subsequence(n, a))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_playlists(n, T, songs):\n    from functools import lru_cache\n\n    @lru_cache(None)\n    def dp(time_left, last_genre, used_mask):\n        if time_left == 0:\n            return 1\n        if time_left < 0:\n            return 0\n        \n        count = 0\n        for i in range(n):\n            if not (used_mask & (1 << i)) and songs[i][1] != last_genre:\n                count += dp(time_left - songs[i][0], songs[i][1], used_mask | (1 << i))\n                count %= MOD\n        return count\n\n    return dp(T, 0, 0)\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    T = int(data[1])\n    songs = []\n    for i in range(n):\n        t_i = int(data[2 + 2 * i])\n        g_i = int(data[3 + 2 * i])\n        songs.append((t_i, g_i))\n    \n    result = count_playlists(n, T, songs)\n    print(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_inverse(x, mod):\n    return pow(x, mod - 2, mod)\n\ndef expected_length(m):\n    phi = list(range(m + 1))\n    for i in range(2, m + 1):\n        if phi[i] == i:\n            for j in range(i, m + 1, i):\n                phi[j] *= (i - 1)\n                phi[j] //= i\n\n    P = sum(phi[1:])\n    Q = m\n\n    Q_inv = mod_inverse(Q, MOD)\n    result = (P * Q_inv) % MOD\n    return result\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    m = int(input().strip())\n    print(expected_length(m))"}
{"solution": "import math\n\ndef count_good_pairs(l, r, x, y):\n    if y % x != 0:\n        return 0\n    \n    count = 0\n    product = y // x\n    \n    for a in range(1, int(math.sqrt(product)) + 1):\n        if product % a == 0:\n            b = product // a\n            a *= x\n            b *= x\n            if l <= a <= r and l <= b <= r and math.gcd(a, b) == x and (a * b) // math.gcd(a, b) == y:\n                if a != b:\n                    count += 2\n                else:\n                    count += 1\n    \n    return count\n\n# Read input\nl, r, x, y = map(int, input().split())\n\n# Calculate and print the result\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "import math\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef find_min_k(a, b):\n    if a == b:\n        return 0\n    \n    diff = abs(a - b)\n    min_lcm = float('inf')\n    best_k = 0\n    \n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            for k in [i, diff // i]:\n                k_mod = (k - a % k) % k\n                current_lcm = lcm(a + k_mod, b + k_mod)\n                if current_lcm < min_lcm or (current_lcm == min_lcm and k_mod < best_k):\n                    min_lcm = current_lcm\n                    best_k = k_mod\n    \n    return best_k\n\n# Read input\na, b = map(int, input().split())\n\n# Find and print the result\nprint(find_min_k(a, b))"}
{"solution": "def minimal_additional_marks(n, k, marks):\n    current_sum = sum(marks)\n    current_count = n\n    \n    # Calculate the current average and the required sum to achieve average k\n    while True:\n        current_average = (current_sum + k) / (current_count + 1)\n        if round(current_average) >= k:\n            break\n        current_sum += k\n        current_count += 1\n    \n    return current_count - n\n\n# Read input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(minimal_additional_marks(n, k, marks))"}
{"solution": "import math\n\ndef find_valid_d(n, arr):\n    required_positive_count = math.ceil(n / 2)\n    \n    for d in range(-1000, 1001):\n        if d == 0:\n            continue\n        positive_count = sum(1 for x in arr if x / d > 0)\n        if positive_count >= required_positive_count:\n            return d\n    \n    return 0\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Find and print the valid d\nprint(find_valid_d(n, arr))"}
{"solution": "def count_pairs_with_max_nines(n):\n    max_nines = 0\n    count = 0\n\n    for i in range(1, n // 2 + 1):\n        j = n - i\n        total_cost = i + j\n        nines = 0\n\n        while total_cost % 10 == 9:\n            nines += 1\n            total_cost //= 10\n\n        if nines > max_nines:\n            max_nines = nines\n            count = 1\n        elif nines == max_nines:\n            count += 1\n\n    print(count)\n\n# Read input\nn = int(input().strip())\ncount_pairs_with_max_nines(n)"}
{"solution": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef can_be_divided(n):\n    while n % 2 == 0:\n        n //= 2\n    while n % 3 == 0:\n        n //= 3\n    return n == 1\n\ndef min_minutes(a1, b1, a2, b2):\n    area1 = a1 * b1\n    area2 = a2 * b2\n\n    if area1 == area2:\n        return 0, (a1, b1), (a2, b2)\n\n    gcd1 = gcd(a1, b1)\n    gcd2 = gcd(a2, b2)\n\n    if not (can_be_divided(a1 // gcd1) and can_be_divided(b1 // gcd1) and can_be_divided(a2 // gcd2) and can_be_divided(b2 // gcd2)):\n        return -1, None, None\n\n    def count_steps(n):\n        steps = 0\n        while n % 2 == 0:\n            n //= 2\n            steps += 1\n        while n % 3 == 0:\n            n //= 3\n            steps += 1\n        return steps\n\n    steps1 = count_steps(a1 // gcd1) + count_steps(b1 // gcd1)\n    steps2 = count_steps(a2 // gcd2) + count_steps(b2 // gcd2)\n\n    if area1 > area2:\n        factor = area1 // area2\n        steps = count_steps(factor)\n        return steps, (a1 // (2 ** (steps1 - steps)), b1 // (3 ** (steps1 - steps))), (a2, b2)\n    else:\n        factor = area2 // area1\n        steps = count_steps(factor)\n        return steps, (a1, b1), (a2 // (2 ** (steps2 - steps)), b2 // (3 ** (steps2 - steps)))\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\nminutes, bar1, bar2 = min_minutes(a1, b1, a2, b2)\n\nif minutes == -1:\n    print(-1)\nelse:\n    print(minutes)\n    print(bar1[0], bar1[1])\n    print(bar2[0], bar2[1])"}
{"solution": "def determine_winner(xp, yp, xv, yv):\n    # Calculate the number of moves required for each player to reach (0, 0)\n    polycarp_moves = xp + yp\n    vasiliy_moves = max(xv, yv)\n    \n    # Determine the winner based on the number of moves\n    if polycarp_moves <= vasiliy_moves:\n        return \"Polycarp\"\n    else:\n        return \"Vasiliy\"\n\n# Read input\nxp, yp, xv, yv = map(int, input().split())\n\n# Determine and print the winner\nprint(determine_winner(xp, yp, xv, yv))"}
{"solution": "def calculate_columns(m, d):\n    # Days in each month for a non-leap year\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    # Get the number of days in the given month\n    days = days_in_month[m - 1]\n    \n    # Calculate the number of days in the first week\n    first_week_days = 8 - d\n    \n    # Calculate the remaining days after the first week\n    remaining_days = days - first_week_days\n    \n    # Calculate the number of full weeks in the remaining days\n    full_weeks = remaining_days // 7\n    \n    # Check if there are any extra days that don't fit into a full week\n    extra_days = remaining_days % 7\n    \n    # Total columns needed: 1 for the first week, plus the number of full weeks,\n    # plus one more if there are extra days\n    columns = 1 + full_weeks + (1 if extra_days > 0 else 0)\n    \n    return columns\n\n# Read input\nm, d = map(int, input().split())\n\n# Calculate and print the number of columns\nprint(calculate_columns(m, d))"}
{"solution": "def count_years_with_one_zero(a, b):\n    def has_exactly_one_zero_in_binary(n):\n        binary_representation = bin(n)[2:]\n        return binary_representation.count('0') == 1\n\n    count = 0\n    for year in range(a, b + 1):\n        if has_exactly_one_zero_in_binary(year):\n            count += 1\n\n    return count\n\n# Read input\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(count_years_with_one_zero(a, b))"}
{"solution": "def minimal_layers(N):\n    return (N * (N + 1)) // 2\n\n# Read input\nN = int(input())\n\n# Print the minimal number of layers required\nprint(minimal_layers(N))"}
{"solution": "from itertools import combinations\nfrom math import factorial\n\ndef count_ways(n, k, S, a):\n    # Precompute factorials for all numbers in a\n    factorials = {x: factorial(x) for x in a}\n    \n    # Function to calculate the number of ways to achieve the sum S\n    def calculate_ways(index, remaining_k, current_sum):\n        if current_sum == S:\n            return 1\n        if index == n or current_sum > S:\n            return 0\n        \n        # Option 1: Do not choose the current cube\n        ways = calculate_ways(index + 1, remaining_k, current_sum)\n        \n        # Option 2: Choose the current cube without a sticker\n        ways += calculate_ways(index + 1, remaining_k, current_sum + a[index])\n        \n        # Option 3: Choose the current cube with a sticker (if we have stickers left)\n        if remaining_k > 0:\n            ways += calculate_ways(index + 1, remaining_k - 1, current_sum + factorials[a[index]])\n        \n        return ways\n    \n    return calculate_ways(0, k, 0)\n\n# Read input\nn, k, S = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_ways(n, k, S, a))"}
{"solution": "def can_transform(n, k, a):\n    # Convert each element of a to its k-based representation\n    max_power = 0\n    for num in a:\n        power = 0\n        while k ** power <= num:\n            power += 1\n        max_power = max(max_power, power)\n    \n    # Create a list to count the usage of each power of k\n    power_count = [0] * (max_power + 1)\n    \n    for num in a:\n        current = num\n        for power in range(max_power, -1, -1):\n            k_power = k ** power\n            if current >= k_power:\n                count = current // k_power\n                power_count[power] += count\n                current -= count * k_power\n    \n    # Check if any power is used more than once\n    for count in power_count:\n        if count > 1:\n            return \"NO\"\n    \n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        n = int(data[index])\n        k = int(data[index + 1])\n        a = list(map(int, data[index + 2:index + 2 + n]))\n        index += 2 + n\n        \n        result = can_transform(n, k, a)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 1073741824\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    a, b, c = int(data[0]), int(data[1]), int(data[2])\n    \n    total_sum = 0\n    \n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                product = i * j * k\n                total_sum += count_divisors(product)\n                total_sum %= MOD\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    neighbors = []\n    idx = state.index('X')\n    if idx == 0:\n        neighbors.append(swap(state, 0, 1))\n        neighbors.append(swap(state, 0, 2))\n    elif idx == 1:\n        neighbors.append(swap(state, 1, 0))\n        neighbors.append(swap(state, 1, 3))\n    elif idx == 2:\n        neighbors.append(swap(state, 2, 0))\n        neighbors.append(swap(state, 2, 3))\n    elif idx == 3:\n        neighbors.append(swap(state, 3, 1))\n        neighbors.append(swap(state, 3, 2))\n    return neighbors\n\ndef swap(state, i, j):\n    state = list(state)\n    state[i], state[j] = state[j], state[i]\n    return ''.join(state)\n\ndef bfs(start):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        current = queue.popleft()\n        for neighbor in get_neighbors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return visited\n\ndef can_be_same_configuration(bessie, elsie):\n    bessie_start = ''.join(bessie)\n    elsie_start = ''.join(elsie)\n    \n    bessie_reachable = bfs(bessie_start)\n    elsie_reachable = bfs(elsie_start)\n    \n    return not bessie_reachable.isdisjoint(elsie_reachable)\n\n# Input reading\nbessie = [input().strip() for _ in range(2)]\nelsie = [input().strip() for _ in range(2)]\n\nif can_be_same_configuration(bessie, elsie):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def convert_to_decimal(base, number):\n    decimal_value = 0\n    power = 0\n    while number > 0:\n        digit = number % 10\n        decimal_value += digit * (base ** power)\n        number //= 10\n        power += 1\n    return decimal_value\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    \n    result = convert_to_decimal(n, k)\n    print(result)"}
{"solution": "def is_unimodal(arr):\n    n = len(arr)\n    if n == 1:\n        return True\n\n    i = 0\n\n    # Check for strictly increasing part\n    while i < n - 1 and arr[i] < arr[i + 1]:\n        i += 1\n\n    # Check for constant part\n    while i < n - 1 and arr[i] == arr[i + 1]:\n        i += 1\n\n    # Check for strictly decreasing part\n    while i < n - 1 and arr[i] > arr[i + 1]:\n        i += 1\n\n    # If we have traversed the entire array, it is unimodal\n    return i == n - 1\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Check if the array is unimodal and print the result\nif is_unimodal(arr):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def max_value_in_k_paths(n, k):\n    def count_paths(y):\n        count = 0\n        for i in range(y, n + 1, y):\n            count += 1\n            if count >= k:\n                return count\n        return count\n\n    left, right = 1, n\n    result = 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if count_paths(mid) >= k:\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\n# Read input\nn, k = map(int, input().split())\n\n# Find and print the result\nprint(max_value_in_k_paths(n, k))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef find_pocket(n, m, x, y, vx, vy):\n    if vx == 0:\n        if vy == 1:\n            return (0, m) if x == 0 else (n, m)\n        else:\n            return (0, 0) if x == 0 else (n, 0)\n    if vy == 0:\n        if vx == 1:\n            return (n, 0) if y == 0 else (n, m)\n        else:\n            return (0, 0) if y == 0 else (0, m)\n    \n    lcm_nm = lcm(n, m)\n    if (x + vx * lcm_nm) % (2 * n) == 0:\n        final_x = 0\n    elif (x + vx * lcm_nm) % (2 * n) == n:\n        final_x = n\n    else:\n        return -1\n    \n    if (y + vy * lcm_nm) % (2 * m) == 0:\n        final_y = 0\n    elif (y + vy * lcm_nm) % (2 * m) == m:\n        final_y = m\n    else:\n        return -1\n    \n    return final_x, final_y\n\n# Read input\nn, m, x, y, vx, vy = map(int, input().split())\n\n# Find the pocket\nresult = find_pocket(n, m, x, y, vx, vy)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(result[0], result[1])"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    # Check if two rectangles (a2, b2) and (a3, b3) can fit in (a1, b1)\n    def fits(w1, h1, w2, h2, W, H):\n        return (w1 + w2 <= W and max(h1, h2) <= H) or (h1 + h2 <= H and max(w1, w2) <= W)\n    \n    # Check all combinations of orientations\n    if (fits(a2, b2, a3, b3, a1, b1) or fits(b2, a2, a3, b3, a1, b1) or\n        fits(a2, b2, b3, a3, a1, b1) or fits(b2, a2, b3, a3, a1, b1) or\n        fits(a3, b3, a2, b2, a1, b1) or fits(b3, a3, a2, b2, a1, b1) or\n        fits(a3, b3, b2, a2, a1, b1) or fits(b3, a3, b2, a2, a1, b1)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\n# Print the result\nprint(can_place_paintings(a1, b1, a2, b2, a3, b3))"}
{"solution": "def count_written_terms(b1, q, l, m, bad_integers):\n    bad_set = set(bad_integers)\n    count = 0\n    current_term = b1\n\n    if abs(b1) > l:\n        return 0\n\n    if b1 == 0:\n        if 0 in bad_set:\n            return 0\n        else:\n            return \"inf\"\n\n    if q == 0:\n        if 0 in bad_set:\n            if b1 in bad_set:\n                return 0\n            else:\n                return 1\n        else:\n            if b1 in bad_set:\n                return \"inf\"\n            else:\n                return \"inf\"\n\n    if q == 1:\n        if b1 in bad_set:\n            return 0\n        else:\n            return \"inf\"\n\n    if q == -1:\n        if b1 in bad_set and -b1 in bad_set:\n            return 0\n        else:\n            return \"inf\"\n\n    while abs(current_term) <= l:\n        if current_term not in bad_set:\n            count += 1\n        current_term *= q\n\n    return count\n\n# Read input\nb1, q, l, m = map(int, input().split())\nbad_integers = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = count_written_terms(b1, q, l, m, bad_integers)\nprint(result)"}
{"solution": "def find_frame(n, m, screen):\n    # Find the bounding box of all white pixels\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if screen[i][j] == 'w':\n                if i < min_row:\n                    min_row = i\n                if i > max_row:\n                    max_row = i\n                if j < min_col:\n                    min_col = j\n                if j > max_col:\n                    max_col = j\n    \n    # Calculate the size of the frame\n    frame_size = max(max_row - min_row, max_col - min_col) + 1\n    \n    # Check if the frame can fit within the screen\n    if min_row + frame_size > n or min_col + frame_size > m:\n        return -1\n    \n    # Create a new screen with the frame\n    new_screen = [list(row) for row in screen]\n    \n    for i in range(frame_size):\n        if new_screen[min_row][min_col + i] == '.':\n            new_screen[min_row][min_col + i] = '+'\n        if new_screen[min_row + frame_size - 1][min_col + i] == '.':\n            new_screen[min_row + frame_size - 1][min_col + i] = '+'\n        if new_screen[min_row + i][min_col] == '.':\n            new_screen[min_row + i][min_col] = '+'\n        if new_screen[min_row + i][min_col + frame_size - 1] == '.':\n            new_screen[min_row + i][min_col + frame_size - 1] = '+'\n    \n    return new_screen\n\n# Read input\nn, m = map(int, input().split())\nscreen = [input().strip() for _ in range(n)]\n\n# Find the frame\nresult = find_frame(n, m, screen)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(''.join(row))"}
{"solution": "def can_spend_exactly(n, a, b):\n    for x in range(n // a + 1):\n        if (n - x * a) % b == 0:\n            y = (n - x * a) // b\n            return \"YES\", x, y\n    return \"NO\",\n\n# Read input\nn = int(input().strip())\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result\nresult = can_spend_exactly(n, a, b)\n\n# Print the result\nif result[0] == \"NO\":\n    print(result[0])\nelse:\n    print(result[0])\n    print(result[1], result[2])"}
{"solution": "def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\ns = int(input())\nprint(number_to_words(s))"}
{"solution": "def max_erase_length(n, arr):\n    max_erase = 0\n    for i in range(n):\n        for j in range(i, n):\n            if i == 0 or j == n - 1 or arr[j + 1] - arr[i - 1] > j - i + 1:\n                max_erase = max(max_erase, j - i + 1)\n    return max_erase\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_erase_length(n, arr))"}
{"solution": "def find_equator_day(n, problems):\n    total_problems = sum(problems)\n    half_problems = (total_problems + 1) // 2  # To ensure we get at least half\n    cumulative_sum = 0\n\n    for i in range(n):\n        cumulative_sum += problems[i]\n        if cumulative_sum >= half_problems:\n            return i + 1\n\n# Read input\nn = int(input())\nproblems = list(map(int, input().split()))\n\n# Find and print the day Polycarp will celebrate the equator\nprint(find_equator_day(n, problems))"}
{"solution": "from collections import deque, defaultdict\n\n# Define the moves for each piece\nknight_moves = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)]\nbishop_moves = [(i, i) for i in range(1, 10)] + [(i, -i) for i in range(1, 10)] + [(-i, i) for i in range(1, 10)] + [(-i, -i) for i in range(1, 10)]\nrook_moves = [(i, 0) for i in range(1, 10)] + [(0, i) for i in range(1, 10)] + [(-i, 0) for i in range(1, 10)] + [(0, -i) for i in range(1, 10)]\n\n# Function to check if a move is within the board\ndef is_valid(x, y, N):\n    return 0 <= x < N and 0 <= y < N\n\n# BFS function to find the shortest path\ndef bfs(start, end, N, board, piece_moves):\n    queue = deque([(start[0], start[1], 0)])  # (x, y, steps)\n    visited = set()\n    visited.add((start[0], start[1]))\n    \n    while queue:\n        x, y, steps = queue.popleft()\n        if (x, y) == end:\n            return steps\n        \n        for dx, dy in piece_moves:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny, N) and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, steps + 1))\n    \n    return float('inf')\n\n# Main function to solve the problem\ndef solve_chess_puzzle(N, board):\n    positions = {}\n    for i in range(N):\n        for j in range(N):\n            positions[board[i][j]] = (i, j)\n    \n    total_steps = 0\n    total_replacements = 0\n    current_piece = 'knight'\n    \n    for num in range(1, N * N):\n        start = positions[num]\n        end = positions[num + 1]\n        \n        knight_steps = bfs(start, end, N, board, knight_moves)\n        bishop_steps = bfs(start, end, N, board, bishop_moves)\n        rook_steps = bfs(start, end, N, board, rook_moves)\n        \n        if current_piece == 'knight':\n            if knight_steps <= bishop_steps and knight_steps <= rook_steps:\n                total_steps += knight_steps\n            else:\n                total_replacements += 1\n                if bishop_steps <= rook_steps:\n                    total_steps += bishop_steps\n                    current_piece = 'bishop'\n                else:\n                    total_steps += rook_steps\n                    current_piece = 'rook'\n        elif current_piece == 'bishop':\n            if bishop_steps <= knight_steps and bishop_steps <= rook_steps:\n                total_steps += bishop_steps\n            else:\n                total_replacements += 1\n                if knight_steps <= rook_steps:\n                    total_steps += knight_steps\n                    current_piece = 'knight'\n                else:\n                    total_steps += rook_steps\n                    current_piece = 'rook'\n        elif current_piece == 'rook':\n            if rook_steps <= knight_steps and rook_steps <= bishop_steps:\n                total_steps += rook_steps\n            else:\n                total_replacements += 1\n                if knight_steps <= bishop_steps:\n                    total_steps += knight_steps\n                    current_piece = 'knight'\n                else:\n                    total_steps += bishop_steps\n                    current_piece = 'bishop'\n    \n    print(total_steps, total_replacements)\n\n# Read input\nN = int(input())\nboard = [list(map(int, input().split())) for _ in range(N)]\n\n# Solve the puzzle\nsolve_chess_puzzle(N, board)"}
{"solution": "def min_time_to_reach(n, m, k, a, b):\n    # Function to calculate the entrance, floor, and position within the floor\n    def get_position(x):\n        entrance = (x - 1) // (m * k) + 1\n        floor = ((x - 1) % (m * k)) // k + 1\n        return entrance, floor\n\n    # Get positions of Edward and Natasha\n    entrance_a, floor_a = get_position(a)\n    entrance_b, floor_b = get_position(b)\n\n    # Calculate the minimum distance between entrances\n    direct_distance = abs(entrance_a - entrance_b)\n    circular_distance = min(direct_distance, n - direct_distance)\n    entrance_travel_time = circular_distance * 15\n\n    # Calculate the time to move between floors\n    if floor_a == floor_b:\n        floor_travel_time = 0\n    else:\n        # Time to use the lift\n        lift_time = 10 + abs(floor_a - 1) + abs(floor_b - 1)\n        # Time to use the stairs\n        stairs_time = abs(floor_a - floor_b) * 5\n        floor_travel_time = min(lift_time, stairs_time)\n\n    # Total time\n    total_time = entrance_travel_time + floor_travel_time\n    return total_time\n\n# Read input\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(min_time_to_reach(n, m, k, a, b))"}
{"solution": "def is_divisible_by_64(s):\n    # To be divisible by 64, the binary number must end with at least six '0's and have a '1' before them.\n    # We need to find if there is a '1' followed by at least six '0's in the string.\n    \n    # Reverse the string to make it easier to check for trailing zeros\n    s = s[::-1]\n    \n    # Find the first '1' in the reversed string\n    one_index = s.find('1')\n    \n    if one_index == -1:\n        # If there is no '1' in the string, it's impossible to form a number divisible by 64\n        return \"no\"\n    \n    # Check if there are at least six '0's after the first '1'\n    if s[one_index+1:one_index+7] == '000000':\n        return \"yes\"\n    \n    return \"no\"\n\n# Read input\ns = input().strip()\n\n# Print the result\nprint(is_divisible_by_64(s))"}
{"solution": "def transform_to_alphabet_subsequence(s):\n    target = \"abcdefghijklmnopqrstuvwxyz\"\n    target_index = 0\n    s = list(s)\n    \n    for i in range(len(s)):\n        if target_index < len(target) and s[i] <= target[target_index]:\n            s[i] = target[target_index]\n            target_index += 1\n        if target_index == len(target):\n            break\n    \n    if target_index == len(target):\n        print(\"\".join(s))\n    else:\n        print(\"-1\")\n\n# Read input\nimport sys\ninput = sys.stdin.read().strip()\ntransform_to_alphabet_subsequence(input)"}
{"solution": "def max_expected_fishes(n, m, r, k):\n    def count_positions(x, y):\n        return (min(x, n - r + 1) - max(1, x - r + 1) + 1) * (min(y, m - r + 1) - max(1, y - r + 1) + 1)\n\n    total_positions = (n - r + 1) * (m - r + 1)\n    fish_positions = []\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            fish_positions.append((count_positions(i, j), i, j))\n\n    fish_positions.sort(reverse=True, key=lambda x: x[0])\n\n    max_fishes = sum(pos[0] for pos in fish_positions[:k])\n    expected_value = max_fishes / total_positions\n\n    return expected_value\n\n# Read input\nn, m, r, k = map(int, input().split())\n\n# Calculate and print the result\nresult = max_expected_fishes(n, m, r, k)\nprint(f\"{result:.10f}\")"}
{"solution": "def maximize_product(n, a):\n    # Apply the operation to all non-negative numbers\n    for i in range(n):\n        if a[i] >= 0:\n            a[i] = -a[i] - 1\n    \n    # If the number of elements is odd, we need to flip one element back\n    if n % 2 != 0:\n        # Find the element with the smallest absolute value\n        min_index = 0\n        for i in range(1, n):\n            if abs(a[i]) < abs(a[min_index]):\n                min_index = i\n        # Flip it back\n        a[min_index] = -a[min_index] - 1\n    \n    return a\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = maximize_product(n, a)\n\n# Print the result\nprint(' '.join(map(str, result)))"}
{"solution": "def find_kth_smallest_divisor(n, k):\n    divisors = []\n    \n    # Find all divisors up to sqrt(n)\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    \n    # Sort the divisors\n    divisors.sort()\n    \n    # Check if there are at least k divisors\n    if len(divisors) < k:\n        return -1\n    else:\n        return divisors[k-1]\n\n# Read input\nn, k = map(int, input().split())\n\n# Find and print the k-th smallest divisor\nprint(find_kth_smallest_divisor(n, k))"}
{"solution": "def can_form_number(cubes, number):\n    str_num = str(number)\n    used_cubes = [False] * len(cubes)\n    \n    for digit in str_num:\n        found = False\n        for i in range(len(cubes)):\n            if not used_cubes[i] and int(digit) in cubes[i]:\n                used_cubes[i] = True\n                found = True\n                break\n        if not found:\n            return False\n    return True\n\ndef max_consecutive_number(cubes):\n    x = 1\n    while True:\n        if not can_form_number(cubes, x):\n            return x - 1\n        x += 1\n\n# Input reading\nn = int(input())\ncubes = []\nfor _ in range(n):\n    cubes.append(list(map(int, input().split())))\n\n# Calculate and print the result\nprint(max_consecutive_number(cubes))"}
{"solution": "def k_rounding(n, k):\n    # Calculate the factor to make the number end with k zeros\n    factor = 10 ** k\n    \n    # Find the smallest multiple of n that ends with k zeros\n    x = (n + factor - 1) // factor * factor\n    \n    print(x)\n\n# Read input\nn, k = map(int, input().split())\n\n# Perform k-rounding\nk_rounding(n, k)"}
{"solution": "def transform_matrix(n, m, A):\n    operations = []\n    B = [[0] * m for _ in range(n)]\n    \n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                operations.append((i + 1, j + 1))\n                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1\n    \n    for i in range(n):\n        for j in range(m):\n            if A[i][j] != B[i][j]:\n                return -1\n    \n    return operations\n\n# Input reading\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\n# Process the transformation\nresult = transform_matrix(n, m, A)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for x, y in result:\n        print(x, y)"}
{"solution": "def bad_luck_island(r, s, p):\n    # Initialize a 3D array to store the probabilities\n    dp = [[[0.0 for _ in range(p + 1)] for _ in range(s + 1)] for _ in range(r + 1)]\n    \n    # Base cases\n    for i in range(1, r + 1):\n        dp[i][0][0] = 1.0\n    for j in range(1, s + 1):\n        dp[0][j][0] = 1.0\n    for k in range(1, p + 1):\n        dp[0][0][k] = 1.0\n    \n    # Fill the dp table\n    for i in range(r + 1):\n        for j in range(s + 1):\n            for k in range(p + 1):\n                total_pairs = i * j + j * k + k * i\n                if total_pairs == 0:\n                    continue\n                if i > 0 and j > 0:\n                    dp[i][j][k] += dp[i][j - 1][k] * (i * j / total_pairs)\n                if j > 0 and k > 0:\n                    dp[i][j][k] += dp[i][j][k - 1] * (j * k / total_pairs)\n                if k > 0 and i > 0:\n                    dp[i][j][k] += dp[i - 1][j][k] * (k * i / total_pairs)\n    \n    # Calculate the probabilities\n    prob_r = sum(dp[i][0][0] for i in range(1, r + 1))\n    prob_s = sum(dp[0][j][0] for j in range(1, s + 1))\n    prob_p = sum(dp[0][0][k] for k in range(1, p + 1))\n    \n    return prob_r, prob_s, prob_p\n\n# Read input\nr, s, p = map(int, input().split())\n\n# Get the probabilities\nprob_r, prob_s, prob_p = bad_luck_island(r, s, p)\n\n# Print the results\nprint(f\"{prob_r:.12f} {prob_s:.12f} {prob_p:.12f}\")"}
{"solution": "# Read input values\nl_1, r_1, l_2, r_2, k = map(int, input().split())\n\n# Calculate the overlapping interval\nstart = max(l_1, l_2)\nend = min(r_1, r_2)\n\n# Calculate the number of overlapping minutes\nif start > end:\n    print(0)\nelse:\n    overlap = end - start + 1\n    # If the prinking minute is within the overlapping interval, subtract one minute\n    if start <= k <= end:\n        overlap -= 1\n    print(overlap)"}
{"solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    north_south_lines = []\n    east_west_lines = []\n    \n    index = 2\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        C = int(data[index + 2])\n        north_south_lines.append((A, B, C))\n        index += 3\n    \n    for _ in range(M):\n        D = int(data[index])\n        E = int(data[index + 1])\n        F = int(data[index + 2])\n        east_west_lines.append((D, E, F))\n        index += 3\n    \n    # Determine the boundaries\n    min_x = -float('inf')\n    max_x = float('inf')\n    min_y = -float('inf')\n    max_y = float('inf')\n    \n    for A, B, C in north_south_lines:\n        if C == 0:\n            min_x = max(min_x, B)\n        elif C == 1:\n            max_x = min(max_x, A)\n    \n    for D, E, F in east_west_lines:\n        if D == 0:\n            min_y = max(min_y, F)\n        elif D == 1:\n            max_y = min(max_y, E)\n    \n    if min_x == -float('inf') or max_x == float('inf') or min_y == -float('inf') or max_y == float('inf'):\n        print(\"INF\")\n    else:\n        width = max_x - min_x\n        height = max_y - min_y\n        if width < 0 or height < 0:\n            print(\"0\")\n        else:\n            print(width * height)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Read input values\nt, s, x = map(int, input().split())\n\n# Check if x is the first bark time\nif x == t:\n    print(\"YES\")\n# Check if x is one of the subsequent bark times\nelif x > t and ((x - t) % s == 0 or (x - t - 1) % s == 0 and x != t + 1):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def find_nested_segments(n, segments):\n    # Add index to each segment for easy reference\n    indexed_segments = [(segments[i][0], segments[i][1], i + 1) for i in range(n)]\n    \n    # Sort segments by starting point, and by ending point in descending order if starting points are equal\n    indexed_segments.sort(key=lambda x: (x[0], -x[1]))\n    \n    # Initialize the rightmost end seen so far\n    max_r = -1\n    max_r_index = -1\n    \n    for l, r, index in indexed_segments:\n        if r <= max_r:\n            # Found a segment that lies within another\n            return index, max_r_index\n        if r > max_r:\n            max_r = r\n            max_r_index = index\n    \n    return -1, -1\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nsegments = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n)]\n\n# Find and print the result\ni, j = find_nested_segments(n, segments)\nprint(i, j)"}
{"solution": "def decode_genome(n, s):\n    if n % 4 != 0:\n        return \"===\"\n\n    count = {'A': 0, 'C': 0, 'G': 0, 'T': 0, '?': 0}\n    for char in s:\n        count[char] += 1\n\n    required_each = n // 4\n    for nucleotide in 'ACGT':\n        if count[nucleotide] > required_each:\n            return \"===\"\n\n    for nucleotide in 'ACGT':\n        count['?'] -= (required_each - count[nucleotide])\n        count[nucleotide] = required_each\n\n    if count['?'] != 0:\n        return \"===\"\n\n    result = []\n    for char in s:\n        if char == '?':\n            for nucleotide in 'ACGT':\n                if count[nucleotide] > 0:\n                    result.append(nucleotide)\n                    count[nucleotide] -= 1\n                    break\n        else:\n            result.append(char)\n\n    return ''.join(result)\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Decode genome and print result\nprint(decode_genome(n, s))"}
{"solution": "def can_win(board):\n    # Check rows and columns\n    for i in range(4):\n        for j in range(2):\n            if board[i][j:j+3].count('x') == 2 and board[i][j:j+3].count('.') == 1:\n                return True\n            if [board[j+k][i] for k in range(3)].count('x') == 2 and [board[j+k][i] for k in range(3)].count('.') == 1:\n                return True\n\n    # Check diagonals\n    for i in range(2):\n        for j in range(2):\n            if [board[i+k][j+k] for k in range(3)].count('x') == 2 and [board[i+k][j+k] for k in range(3)].count('.') == 1:\n                return True\n            if [board[i+k][j+2-k] for k in range(3)].count('x') == 2 and [board[i+k][j+2-k] for k in range(3)].count('.') == 1:\n                return True\n\n    return False\n\n# Read the board\nboard = [input().strip() for _ in range(4)]\n\n# Determine if Ilya can win\nif can_win(board):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def can_divide_after_moving(n, a):\n    total_sum = sum(a)\n    \n    # If the total sum is odd, it's impossible to split into two equal parts\n    if total_sum % 2 != 0:\n        return \"NO\"\n    \n    target_sum = total_sum // 2\n    \n    # Check if we can find a prefix sum that equals target_sum\n    prefix_sum = 0\n    for i in range(n):\n        prefix_sum += a[i]\n        if prefix_sum == target_sum:\n            return \"YES\"\n    \n    # Check if moving an element can help\n    for i in range(n):\n        current_sum = total_sum - a[i]\n        if current_sum % 2 != 0:\n            continue\n        half_sum = current_sum // 2\n        \n        prefix_sum = 0\n        for j in range(n):\n            if j == i:\n                continue\n            prefix_sum += a[j]\n            if prefix_sum == half_sum:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the result\nprint(can_divide_after_moving(n, a))"}
{"solution": "def can_be_non_increasing(n, k, a, b):\n    # Sort b in descending order to try to make the sequence non-increasing\n    b.sort(reverse=True)\n    \n    # Replace zeros in a with elements from b\n    b_index = 0\n    for i in range(n):\n        if a[i] == 0:\n            a[i] = b[b_index]\n            b_index += 1\n    \n    # Check if the resulting sequence is non-increasing\n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            return \"Yes\"\n    \n    return \"No\"\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Determine if it's possible to make the sequence non-increasing\nresult = can_be_non_increasing(n, k, a, b)\nprint(result)"}
{"solution": "def can_distribute_grapes(x, y, z, a, b, c):\n    # Andrew takes x green grapes\n    if a < x:\n        return \"NO\"\n    a -= x\n    \n    # Dmitry takes y grapes, but only green and purple\n    if a + b < y:\n        return \"NO\"\n    remaining_grapes = a + b - y\n    \n    # Michal takes z grapes from any remaining grapes\n    if remaining_grapes + c < z:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Determine if the distribution is possible\nresult = can_distribute_grapes(x, y, z, a, b, c)\nprint(result)"}
{"solution": "def is_accident_possible(lights):\n    for i in range(4):\n        l, s, r, p = lights[i]\n        if p == 1:\n            if l == 1 or s == 1 or r == 1:\n                return \"YES\"\n            if lights[(i + 1) % 4][2] == 1 or lights[(i + 2) % 4][1] == 1 or lights[(i + 3) % 4][0] == 1:\n                return \"YES\"\n    return \"NO\"\n\n# Read input\nlights = []\nfor _ in range(4):\n    lights.append(list(map(int, input().split())))\n\n# Determine if an accident is possible\nresult = is_accident_possible(lights)\nprint(result)"}
{"solution": "def get_coordinates(digit):\n    keypad = {\n        '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2),\n        '0': (3, 1)\n    }\n    return keypad[digit]\n\ndef get_vectors(number):\n    vectors = []\n    for i in range(len(number) - 1):\n        x1, y1 = get_coordinates(number[i])\n        x2, y2 = get_coordinates(number[i + 1])\n        vectors.append((x2 - x1, y2 - y1))\n    return vectors\n\ndef is_unique_finger_movement(n, number):\n    original_vectors = get_vectors(number)\n    for i in range(10**(n-1), 10**n):\n        candidate = str(i).zfill(n)\n        if candidate != number:\n            if get_vectors(candidate) == original_vectors:\n                return \"NO\"\n    return \"YES\"\n\n# Input reading\nn = int(input())\nnumber = input().strip()\n\n# Output the result\nprint(is_unique_finger_movement(n, number))"}
{"solution": "def max_sold_products(n, f, days):\n    # Calculate the initial number of products sold without any sell-out days\n    initial_sales = [min(k, l) for k, l in days]\n    \n    # Calculate the potential additional sales if a sell-out day is chosen\n    additional_sales = [min(2 * k, l) - min(k, l) for k, l in days]\n    \n    # Sort the additional sales in descending order to maximize the benefit of sell-out days\n    additional_sales.sort(reverse=True)\n    \n    # Sum the initial sales and the top f additional sales\n    max_sales = sum(initial_sales) + sum(additional_sales[:f])\n    \n    return max_sales\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nf = int(data[1])\ndays = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(n)]\n\n# Calculate and print the result\nprint(max_sold_products(n, f, days))"}
{"solution": "def max_messiness(n, k):\n    # The maximum number of inversions in an array of size n is n * (n - 1) / 2\n    max_inversions = n * (n - 1) // 2\n    \n    # If k is large enough to reverse the entire array, we can achieve the maximum inversions\n    if k >= n // 2:\n        return max_inversions\n    \n    # Otherwise, we need to calculate the maximum inversions we can achieve with k swaps\n    # Each swap can increase the number of inversions by at most 2\n    return min(max_inversions, k * 2 * (n - 1 - k + 1) // 2)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split()\nn = int(data[0])\nk = int(data[1])\n\n# Calculate and print the result\nprint(max_messiness(n, k))"}
{"solution": "def min_coins_per_friend(N, M, K, L):\n    # Total number of coins needed to be gifted\n    total_needed = M * ((L + M - 1) // M)\n    \n    # If the total number of coins needed is more than the available coins, it's impossible\n    if total_needed > N:\n        return -1\n    \n    # Calculate the minimum number of coins each friend must gift\n    min_coins = (total_needed + M - 1) // M\n    \n    # If the minimum number of coins each friend must gift is more than the available coins, it's impossible\n    if min_coins > N:\n        return -1\n    \n    return min_coins\n\n# Read input\nN, M, K, L = map(int, input().split())\n\n# Get the result\nresult = min_coins_per_friend(N, M, K, L)\n\n# Print the result\nprint(result)"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    # Find the bounds of the black cells\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # If no black cells are found\n    if min_row == n:\n        return 1\n    \n    # Calculate the side length of the square\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    \n    # Check if the square can fit within the grid\n    if side_length > n or side_length > m:\n        return -1\n    \n    # Count the number of white cells within the square\n    min_paint = float('inf')\n    for i in range(n - side_length + 1):\n        for j in range(m - side_length + 1):\n            paint_count = 0\n            for x in range(i, i + side_length):\n                for y in range(j, j + side_length):\n                    if grid[x][y] == 'W':\n                        paint_count += 1\n            min_paint = min(min_paint, paint_count)\n    \n    return min_paint\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ngrid = data[2:]\n\n# Print the result\nprint(min_cells_to_paint(n, m, grid))"}
{"solution": "def can_transform(n, x, y):\n    # Calculate the total number of stones in both sequences\n    total_x = sum(x)\n    total_y = sum(y)\n    \n    # If the total number of stones is different, it's impossible to transform\n    if total_x != total_y:\n        return \"No\"\n    \n    # Calculate the difference in stones for each pile\n    diff = [y[i] - x[i] for i in range(n)]\n    \n    # Check if the differences can be balanced\n    positive_diff = sum(d for d in diff if d > 0)\n    negative_diff = -sum(d for d in diff if d < 0)\n    \n    # If the positive and negative differences are equal, transformation is possible\n    if positive_diff == negative_diff:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input\nn = int(input().strip())\nx = list(map(int, input().strip().split()))\ny = list(map(int, input().strip().split()))\n\n# Determine if the transformation is possible and print the result\nprint(can_transform(n, x, y))"}
{"solution": "def minimal_difference(n, angles):\n    total_sum = sum(angles)\n    min_diff = float('inf')\n    \n    # Iterate through all possible starting points\n    for start in range(n):\n        current_sum = 0\n        # Iterate through all possible lengths of the sector\n        for length in range(n):\n            current_sum += angles[(start + length) % n]\n            other_sum = total_sum - current_sum\n            min_diff = min(min_diff, abs(current_sum - other_sum))\n    \n    return min_diff\n\n# Read input\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Calculate and print the minimal difference\nprint(minimal_difference(n, angles))"}
{"solution": "MOD = 10**9 + 7\n\ndef power_mod(base, exp, mod):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return result\n\ndef count_ways(n, m):\n    # Calculate (m + 1)^n % MOD\n    total_ways = power_mod(m + 1, n, MOD)\n    # Subtract the case where no present is packed in any box\n    total_ways = (total_ways - 1 + MOD) % MOD\n    return total_ways\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(count_ways(n, m))"}
{"solution": "def find_pythagorean_triple(n):\n    if n == 1:\n        print(-1)\n        return\n    \n    if n % 2 == 0:\n        m = (n // 2) ** 2 - 1\n        k = (n // 2) ** 2 + 1\n    else:\n        m = (n ** 2 - 1) // 2\n        k = (n ** 2 + 1) // 2\n    \n    print(m, k)\n\n# Read input\nn = int(input().strip())\nfind_pythagorean_triple(n)"}
{"solution": "def are_remainders_distinct(n, k):\n    remainders = set()\n    for i in range(1, k + 1):\n        remainder = n % i\n        if remainder in remainders:\n            return \"No\"\n        remainders.add(remainder)\n    return \"Yes\"\n\n# Read input\nn, k = map(int, input().split())\n\n# Check if all remainders are distinct\nresult = are_remainders_distinct(n, k)\n\n# Print the result\nprint(result)"}
{"solution": "import sys\n\ndef compare_large_integers():\n    input = sys.stdin.read\n    data = input().split()\n    \n    a = data[0].lstrip('0')\n    b = data[1].lstrip('0')\n    \n    if len(a) < len(b):\n        print(\"<\")\n    elif len(a) > len(b):\n        print(\">\")\n    else:\n        if a < b:\n            print(\"<\")\n        elif a > b:\n            print(\">\")\n        else:\n            print(\"=\")\n\ncompare_large_integers()"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, p, colors):\n    # Count the number of uncolored pieces\n    uncolored_count = colors.count(-1)\n    \n    # If there are no uncolored pieces, we need to check the parity directly\n    if uncolored_count == 0:\n        score = sum(1 for i in range(n) if colors[i] == 1)\n        return 1 if score % 2 == p else 0\n    \n    # Calculate the number of ways to color the uncolored pieces\n    # There are 2^uncolored_count ways to color the uncolored pieces\n    total_ways = pow(2, uncolored_count, MOD)\n    \n    # Calculate the number of ways to achieve the desired parity\n    # Half of the ways will have even parity and half will have odd parity\n    if p == 0:\n        return total_ways // 2\n    else:\n        return (total_ways + 1) // 2\n\n# Read input\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = count_ways(n, p, colors)\nprint(result)"}
{"solution": "def minimum_rubles(n, a, b, c):\n    remainder = n % 4\n    if remainder == 0:\n        return 0\n    elif remainder == 1:\n        return min(3 * a, a + b, c)\n    elif remainder == 2:\n        return min(2 * a, b, 2 * c)\n    elif remainder == 3:\n        return min(a, b + c, 3 * c)\n\n# Read input\nn, a, b, c = map(int, input().split())\n\n# Calculate and print the minimum amount of rubles\nprint(minimum_rubles(n, a, b, c))"}
{"solution": "def dfs(graph, v, visited, rec_stack):\n    visited[v] = True\n    rec_stack[v] = True\n\n    for neighbor in graph[v]:\n        if not visited[neighbor]:\n            if dfs(graph, neighbor, visited, rec_stack):\n                return True\n        elif rec_stack[neighbor]:\n            return True\n\n    rec_stack[v] = False\n    return False\n\ndef has_cycle(graph, n):\n    visited = [False] * n\n    rec_stack = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if dfs(graph, node, visited, rec_stack):\n                return True\n    return False\n\ndef can_be_acyclic(n, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n\n    if not has_cycle(graph, n):\n        return \"YES\"\n\n    for u, v in edges:\n        graph[u - 1].remove(v - 1)\n        if not has_cycle(graph, n):\n            return \"YES\"\n        graph[u - 1].append(v - 1)\n\n    return \"NO\"\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n\n    print(can_be_acyclic(n, edges))"}
{"solution": "def min_coins_to_cover(n, m, antennas):\n    # Sort antennas by their position\n    antennas.sort()\n    \n    # Initialize the dp array with infinity\n    dp = [float('inf')] * (m + 1)\n    dp[0] = 0  # No cost to cover position 0 (base case)\n    \n    for i in range(1, m + 1):\n        for x, s in antennas:\n            if x - s <= i <= x + s:\n                dp[i] = min(dp[i], dp[max(0, x - s - 1)])\n            elif i < x - s:\n                dp[i] = min(dp[i], dp[max(0, x - s - 1)] + (x - s - i))\n    \n    return dp[m]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nantennas = []\n\nfor i in range(n):\n    x = int(data[2 + 2 * i])\n    s = int(data[3 + 2 * i])\n    antennas.append((x, s))\n\n# Calculate and print the result\nprint(min_coins_to_cover(n, m, antennas))"}
{"solution": "def max_good_subset_weight(W, cnt):\n    max_weight = 0\n    for weight in range(1, 9):\n        if W >= weight:\n            max_items = min(cnt[weight - 1], W // weight)\n            max_weight += max_items * weight\n            W -= max_items * weight\n    return max_weight\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    W = int(data[0])\n    cnt = list(map(int, data[1:9]))\n    \n    result = max_good_subset_weight(W, cnt)\n    print(result)"}
{"solution": "def min_cost(n, L, costs):\n    # Initialize the minimum cost array\n    min_costs = [float('inf')] * n\n    min_costs[0] = costs[0]\n    \n    # Calculate the minimum cost for each bottle type\n    for i in range(1, n):\n        min_costs[i] = min(costs[i], 2 * min_costs[i - 1])\n    \n    total_cost = 0\n    remaining_liters = L\n    \n    # Traverse from the largest bottle to the smallest\n    for i in range(n - 1, -1, -1):\n        bottle_volume = (1 << i)  # 2^i\n        if remaining_liters >= bottle_volume:\n            num_bottles = remaining_liters // bottle_volume\n            total_cost += num_bottles * min_costs[i]\n            remaining_liters -= num_bottles * bottle_volume\n    \n    # Check if we need to buy an additional bottle to cover the remaining liters\n    for i in range(n):\n        bottle_volume = (1 << i)  # 2^i\n        if remaining_liters > 0:\n            total_cost = min(total_cost, min_costs[i] + total_cost - (remaining_liters // bottle_volume) * min_costs[i])\n    \n    return total_cost\n\n# Read input\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Calculate and print the minimum cost\nprint(min_cost(n, L, costs))"}
{"solution": "def max_mex(n, a):\n    a.sort()\n    mex = 1\n    for num in a:\n        if num >= mex:\n            mex += 1\n    return mex\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = max_mex(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(int(digit) for digit in digits)\n    \n    # Try every possible segment sum from 1 to total_sum\n    for segment_sum in range(1, total_sum + 1):\n        if total_sum % segment_sum == 0:\n            current_sum = 0\n            valid_partition = True\n            for digit in digits:\n                current_sum += int(digit)\n                if current_sum > segment_sum:\n                    valid_partition = False\n                    break\n                elif current_sum == segment_sum:\n                    current_sum = 0\n            if valid_partition and current_sum == 0:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\ndigits = input().strip()\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        print(\"CHAT WITH HER!\")\n    else:\n        print(\"IGNORE HIM!\")\n\n# Read input\nusername = input().strip()\ndetermine_gender(username)"}
{"solution": "def max_abs_difference(n, k, tabs):\n    max_diff = 0\n    \n    for b in range(1, k + 1):\n        remaining_tabs = tabs[:]\n        \n        for i in range(b - 1, n, k):\n            remaining_tabs[i] = 0\n        \n        e = remaining_tabs.count(1)\n        s = remaining_tabs.count(-1)\n        \n        max_diff = max(max_diff, abs(e - s))\n    \n    return max_diff\n\n# Read input\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_abs_difference(n, k, tabs))"}
{"solution": "def minimum_cost(n, c0, c1):\n    # Calculate the number of bits needed to represent n letters uniquely\n    import math\n    bits_needed = math.ceil(math.log2(n))\n    \n    # Calculate the number of letters that can be represented with the given bits\n    num_letters = 2 ** bits_needed\n    \n    # Calculate the number of 0s and 1s in the optimal encoding\n    num_zeros = num_letters // 2\n    num_ones = num_letters // 2\n    \n    # Calculate the total cost\n    total_cost = num_zeros * bits_needed * c0 + num_ones * bits_needed * c1\n    \n    return total_cost\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().strip().split()\nn = int(data[0])\nc0 = int(data[1])\nc1 = int(data[2])\n\n# Calculate and print the minimum possible total cost\nprint(minimum_cost(n, c0, c1))"}
{"solution": "def will_meet(n, a, x, b, y):\n    while a != x and b != y:\n        if a == b:\n            return \"YES\"\n        a = a + 1 if a < n else 1\n        b = b - 1 if b > 1 else n\n    return \"YES\" if a == b else \"NO\"\n\n# Read input\nn, a, x, b, y = map(int, input().split())\n\n# Print the result\nprint(will_meet(n, a, x, b, y))"}
{"solution": "def find_unlucky_years(x, y, l, r):\n    unlucky_years = set()\n    a = 0\n    while x ** a <= r:\n        b = 0\n        while x ** a + y ** b <= r:\n            year = x ** a + y ** b\n            if l <= year <= r:\n                unlucky_years.add(year)\n            b += 1\n            if y ** b > r:\n                break\n        a += 1\n        if x ** a > r:\n            break\n    return unlucky_years\n\ndef max_golden_age_length(x, y, l, r):\n    unlucky_years = find_unlucky_years(x, y, l, r)\n    unlucky_years = sorted(unlucky_years)\n    \n    max_length = 0\n    current_start = l\n    \n    for year in unlucky_years:\n        if year > r:\n            break\n        if year >= current_start:\n            max_length = max(max_length, year - current_start)\n            current_start = year + 1\n    \n    max_length = max(max_length, r - current_start + 1)\n    \n    return max_length\n\n# Read input\nx, y, l, r = map(int, input().split())\n\n# Calculate and print the result\nprint(max_golden_age_length(x, y, l, r))"}
{"solution": "def min_tax(n):\n    if n % 2 == 0:\n        return n // 2\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return n // i\n    return 1\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the minimum tax\nprint(min_tax(n))"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    n = len(word)\n    result = []\n    i = 0\n    \n    while i < n:\n        result.append(word[i])\n        if word[i] not in vowels:\n            start = i\n            while i < n and word[i] not in vowels:\n                i += 1\n            if i - start >= 3:\n                block = word[start:i]\n                if len(set(block)) > 1:\n                    result.append(' ')\n        i += 1\n    \n    print(''.join(result))\n\n# Read input\nword = input().strip()\nfix_typos(word)"}
{"solution": "def min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d):\n    # Initialize the minimum time with the time taken without any spells\n    min_time = n * x\n\n    # Check all spells of the first type\n    for i in range(m):\n        if b[i] <= s:\n            min_time = min(min_time, n * a[i])\n\n    # Check all spells of the second type\n    for i in range(k):\n        if d[i] <= s:\n            min_time = min(min_time, (n - c[i]) * x)\n\n    # Check combinations of both types of spells\n    for i in range(m):\n        if b[i] <= s:\n            remaining_manapoints = s - b[i]\n            # Binary search to find the best second type spell within remaining manapoints\n            low, high = 0, k - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if d[mid] <= remaining_manapoints:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            if high >= 0:\n                min_time = min(min_time, (n - c[high]) * a[i])\n\n    return min_time\n\n# Read input\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\n# Calculate and print the minimum time\nprint(min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d))"}
{"solution": "def max_points(n, k, M, t):\n    # Sort the times required for subtasks in ascending order\n    t.sort()\n    \n    # Calculate the total time required to complete all subtasks of a task\n    total_time_per_task = sum(t)\n    \n    # Initialize the maximum points to 0\n    max_points = 0\n    \n    # Try to complete as many full tasks as possible\n    for full_tasks in range(n + 1):\n        time_spent = full_tasks * total_time_per_task\n        if time_spent > M:\n            break\n        \n        remaining_time = M - time_spent\n        points = full_tasks * (k + 1)\n        \n        # Calculate the maximum points from remaining time\n        for i in range(n - full_tasks):\n            for j in range(k):\n                if remaining_time >= t[j]:\n                    remaining_time -= t[j]\n                    points += 1\n                else:\n                    break\n        \n        max_points = max(max_points, points)\n    \n    return max_points\n\n# Read input\nn, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Calculate and print the maximum points\nprint(max_points(n, k, M, t))"}
{"solution": "MOD = 998244353\n\ndef count_balanced_striped_bsts(n):\n    if n % 2 == 1:\n        return 0\n    \n    # Initialize dp array\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case: one way to have an empty tree\n    \n    # Fill dp array\n    for i in range(2, n + 1, 2):\n        for j in range(0, i, 2):\n            dp[i] = (dp[i] + dp[j] * dp[i - 2 - j]) % MOD\n    \n    return dp[n]\n\n# Read input\nn = int(input().strip())\n\n# Compute and print the result\nprint(count_balanced_striped_bsts(n))"}
{"solution": "def find_position(n, m, k):\n    if k < n:\n        # If k is less than n, Lara is still in the first column\n        print(k + 1, 1)\n    else:\n        # Calculate the remaining steps after reaching the bottom of the first column\n        k -= n\n        # Determine the number of complete snake rows Lara has traversed\n        full_snake_rows = k // (m - 1)\n        # Determine the remaining steps after the complete snake rows\n        remaining_steps = k % (m - 1)\n        \n        if full_snake_rows % 2 == 0:\n            # If the number of full snake rows is even, Lara is moving to the right\n            print(n - full_snake_rows, 2 + remaining_steps)\n        else:\n            # If the number of full snake rows is odd, Lara is moving to the left\n            print(n - full_snake_rows, m - remaining_steps)\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Find and print the position\nfind_position(n, m, k)"}
{"solution": "import math\n\ndef find_min_max_lcm_pair(X):\n    # Initialize the minimum possible value of max(a, b) to X\n    min_max_value = X\n    a, b = 1, X\n    \n    # Iterate through all possible factors of X\n    for i in range(1, int(math.sqrt(X)) + 1):\n        if X % i == 0:\n            j = X // i\n            # Check if the LCM of (i, j) is X\n            if math.lcm(i, j) == X:\n                # Update the pair (a, b) if the current max(i, j) is smaller\n                if max(i, j) < min_max_value:\n                    min_max_value = max(i, j)\n                    a, b = i, j\n    \n    return a, b\n\n# Read input\nX = int(input().strip())\n\n# Find the pair (a, b)\na, b = find_min_max_lcm_pair(X)\n\n# Print the result\nprint(a, b)"}
{"solution": "def max_fruits_for_compote(a, b, c):\n    # Calculate the maximum number of complete sets for each fruit type\n    max_sets_lemons = a // 1\n    max_sets_apples = b // 2\n    max_sets_pears = c // 4\n    \n    # Find the limiting factor (minimum number of complete sets)\n    max_complete_sets = min(max_sets_lemons, max_sets_apples, max_sets_pears)\n    \n    # Calculate the total number of fruits used in the compote\n    total_fruits = max_complete_sets * (1 + 2 + 4)\n    \n    return total_fruits\n\n# Example usage:\na = int(input())\nb = int(input())\nc = int(input())\n\nprint(max_fruits_for_compote(a, b, c))"}
{"solution": "def can_divide_teams(n, ratings):\n    ratings.sort()\n    for i in range(n):\n        if ratings[i] >= ratings[i + n]:\n            return \"NO\"\n    return \"YES\"\n\n# Reading input\nn = int(input())\nratings = list(map(int, input().split()))\n\n# Printing output\nprint(can_divide_teams(n, ratings))"}
{"solution": "import math\n\ndef is_coprime(x, y):\n    return math.gcd(x, y) == 1\n\ndef make_coprime_array(arr):\n    n = len(arr)\n    result = []\n    insertions = 0\n    \n    for i in range(n - 1):\n        result.append(arr[i])\n        if not is_coprime(arr[i], arr[i + 1]):\n            # Find a number to insert between arr[i] and arr[i + 1]\n            for num in range(1, 10**9 + 1):\n                if is_coprime(arr[i], num) and is_coprime(num, arr[i + 1]):\n                    result.append(num)\n                    insertions += 1\n                    break\n    result.append(arr[-1])\n    \n    return insertions, result\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Process the array to make it co-prime\ninsertions, result = make_coprime_array(arr)\n\n# Print the result\nprint(insertions)\nprint(\" \".join(map(str, result)))"}
{"solution": "import math\nfrom functools import reduce\nfrom math import gcd\n\ndef compute_gcd_of_list(lst):\n    return reduce(gcd, lst)\n\ndef max_divisor_after_operations(N, K, A):\n    if N == 1:\n        return A[0]\n    \n    # Compute the GCD of the differences between all pairs\n    diffs = [abs(A[i] - A[j]) for i in range(N) for j in range(i + 1, N)]\n    initial_gcd = compute_gcd_of_list(diffs)\n    \n    # Check all divisors of the initial GCD\n    max_divisor = 1\n    for d in range(1, initial_gcd + 1):\n        if initial_gcd % d == 0:\n            # Check if we can make all elements divisible by d\n            if all((a % d) <= K for a in A):\n                max_divisor = d\n    \n    return max_divisor\n\n# Read input\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Compute and print the result\nprint(max_divisor_after_operations(N, K, A))"}
{"solution": "def cat_furrier_transform(x):\n    operations = []\n    count = 0\n\n    while (x & (x + 1)) != 0:\n        if count % 2 == 0:\n            # Find the highest bit that is 0\n            n = 0\n            while (1 << n) <= x:\n                n += 1\n            operations.append(n)\n            x ^= (1 << n) - 1\n        else:\n            x += 1\n        count += 1\n        if count >= 40:\n            break\n\n    print(count)\n    for i in range(0, len(operations), 2):\n        print(operations[i], end=' ')\n    if operations:\n        print()\n\n# Read input\nx = int(input().strip())\ncat_furrier_transform(x)"}
{"solution": "# Read input values\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize the minimum hours to a large number\nmin_hours = float('inf')\n\n# Iterate through each bucket length\nfor length in a:\n    if k % length == 0:\n        hours = k // length\n        if hours < min_hours:\n            min_hours = hours\n\n# Print the minimum number of hours required\nprint(min_hours)"}
{"solution": "def can_grasshopper_reach_insect(n, k, line):\n    g_pos = line.index('G')\n    t_pos = line.index('T')\n    \n    # Ensure g_pos is less than t_pos for simplicity\n    if g_pos > t_pos:\n        g_pos, t_pos = t_pos, g_pos\n    \n    # Check if grasshopper can reach the insect\n    for i in range(g_pos, t_pos + 1, k):\n        if line[i] == '#':\n            return \"NO\"\n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\nline = input().strip()\n\n# Determine if the grasshopper can reach the insect\nresult = can_grasshopper_reach_insect(n, k, line)\nprint(result)"}
{"solution": "def find_aiming_point(y1, y2, yw, xb, yb, r):\n    # Check if the ball can bounce off the wall and go into the goal\n    if yb + r >= yw or yb - r <= 0:\n        return -1\n\n    # Calculate the y-coordinate of the ball after it bounces off the wall\n    y_goal = (2 * yw - yb)\n\n    # Check if the ball can go into the goal after bouncing\n    if y_goal - r > y2 or y_goal + r < y1:\n        return -1\n\n    # Calculate the x-coordinate of the point on the wall to aim at\n    xw = xb * (yw - yb) / (yw + yb)\n\n    return xw\n\n# Read input\ny1, y2, yw, xb, yb, r = map(int, input().split())\n\n# Find the aiming point\nresult = find_aiming_point(y1, y2, yw, xb, yb, r)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    print(f\"{result:.10f}\")"}
{"solution": "def min_missed_meals(b, d, s):\n    # Find the maximum number of meals of any type\n    max_meals = max(b, d, s)\n    \n    # Calculate the total number of meals that should have been had if no meals were missed\n    total_meals = 3 * (max_meals - 1)\n    \n    # Calculate the actual number of meals had\n    actual_meals = b + d + s\n    \n    # The minimum number of missed meals is the difference between the total meals and the actual meals\n    missed_meals = max(0, total_meals - actual_meals)\n    \n    return missed_meals\n\n# Read input\nb, d, s = map(int, input().split())\n\n# Calculate and print the result\nprint(min_missed_meals(b, d, s))"}
{"solution": "def find_matrix_dimensions(n, path):\n    from math import gcd\n    from functools import reduce\n\n    def possible_dimensions(a, b):\n        diff = abs(a - b)\n        factors = set()\n        for i in range(1, int(diff**0.5) + 1):\n            if diff % i == 0:\n                factors.add(i)\n                factors.add(diff // i)\n        return factors\n\n    if n == 1:\n        print(\"YES\")\n        print(1, path[0])\n        return\n\n    common_factors = possible_dimensions(path[0], path[1])\n    for i in range(1, n - 1):\n        common_factors &= possible_dimensions(path[i], path[i + 1])\n        if not common_factors:\n            print(\"NO\")\n            return\n\n    for y in common_factors:\n        x_set = set()\n        valid = True\n        for num in path:\n            if (num - 1) % y == 0:\n                x_set.add((num - 1) // y + 1)\n            else:\n                valid = False\n                break\n        if valid and len(x_set) == 1:\n            x = x_set.pop()\n            if 1 <= x <= 10**9 and 1 <= y <= 10**9:\n                print(\"YES\")\n                print(x, y)\n                return\n\n    print(\"NO\")\n\n# Read input\nn = int(input().strip())\npath = list(map(int, input().strip().split()))\n\n# Find and print the matrix dimensions\nfind_matrix_dimensions(n, path)"}
{"solution": "def min_removals_to_subsequence(a, b):\n    n, m = len(a), len(b)\n    \n    # dp[i][j] will be True if b[0..i-1] is a subsequence of a[0..j-1]\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    \n    # An empty string is a subsequence of any string\n    for j in range(n + 1):\n        dp[0][j] = True\n    \n    # Fill the dp table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if b[i - 1] == a[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] or dp[i][j - 1]\n            else:\n                dp[i][j] = dp[i][j - 1]\n    \n    # Find the minimum number of consecutive characters to remove\n    for i in range(m, 0, -1):\n        if dp[i][n]:\n            return b[:i]\n    \n    return \"-\"\n\n# Read input\na = input().strip()\nb = input().strip()\n\n# Get the result\nresult = min_removals_to_subsequence(a, b)\n\n# Print the result\nprint(result)"}
{"solution": "def minimal_stones(n, s):\n    current_stones = 0\n    min_stones = 0\n    \n    for char in s:\n        if char == '+':\n            current_stones += 1\n        elif char == '-':\n            current_stones -= 1\n        min_stones = min(min_stones, current_stones)\n    \n    return max(0, -min_stones)\n\n# Input handling\nn = int(input())\ns = input().strip()\nprint(minimal_stones(n, s))"}
{"solution": "def max_kefir(n, a, b, c):\n    # If plastic bottle is cheaper or equal to glass bottle after return\n    if a <= b - c:\n        return n // a\n    else:\n        # Calculate maximum kefir with glass bottles and returns\n        max_kefir = 0\n        # Try to buy as many glass bottles as possible\n        while n >= b:\n            bottles = n // b\n            max_kefir += bottles\n            n = n % b + bottles * c\n        # After that, buy plastic bottles with the remaining money\n        max_kefir += n // a\n        return max_kefir\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate and print the result\nprint(max_kefir(n, a, b, c))"}
{"solution": "def card_war(n, k1, cards1, k2, cards2):\n    from collections import deque\n\n    # Initialize the decks\n    deck1 = deque(cards1)\n    deck2 = deque(cards2)\n\n    # To detect infinite loops, we use a set to store seen configurations\n    seen_configurations = set()\n    fight_count = 0\n\n    while deck1 and deck2:\n        # Create a tuple of the current configuration\n        current_configuration = (tuple(deck1), tuple(deck2))\n        \n        # Check if this configuration has been seen before\n        if current_configuration in seen_configurations:\n            return -1  # Infinite loop detected\n        \n        # Add the current configuration to the set\n        seen_configurations.add(current_configuration)\n        \n        # Draw the top cards\n        card1 = deck1.popleft()\n        card2 = deck2.popleft()\n        \n        # Determine the winner of this fight\n        if card1 > card2:\n            deck1.append(card2)\n            deck1.append(card1)\n        else:\n            deck2.append(card1)\n            deck2.append(card2)\n        \n        fight_count += 1\n\n    # Determine the winner\n    if deck1:\n        return fight_count, 1\n    else:\n        return fight_count, 2\n\n# Read input\nn = int(input())\nk1, *cards1 = map(int, input().split())\nk2, *cards2 = map(int, input().split())\n\n# Get the result\nresult = card_war(n, k1, cards1, k2, cards2)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    \n    has_upper = False\n    has_lower = False\n    has_digit = False\n    \n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n    \n    if has_upper and has_lower and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\"\n\n# Read input\npassword = input().strip()\n# Print the result of the complexity check\nprint(check_password_complexity(password))"}
{"solution": "def min_exchanges(n, group_a, group_b):\n    from collections import Counter\n\n    # Count the occurrences of each academic performance in both groups\n    count_a = Counter(group_a)\n    count_b = Counter(group_b)\n\n    # Calculate the difference in counts for each academic performance\n    diff = {i: count_a[i] - count_b[i] for i in range(1, 6)}\n\n    # Check if the total difference for each performance is even\n    for value in diff.values():\n        if value % 2 != 0:\n            return -1\n\n    # Calculate the number of exchanges needed\n    exchanges = 0\n    for value in diff.values():\n        if value > 0:\n            exchanges += value // 2\n\n    return exchanges\n\n# Read input\nn = int(input())\ngroup_a = list(map(int, input().split()))\ngroup_b = list(map(int, input().split()))\n\n# Get the result and print it\nresult = min_exchanges(n, group_a, group_b)\nprint(result)"}
{"solution": "def is_reachable(n, m, horizontal, vertical):\n    # Check if all horizontal streets are in the same direction\n    if all(c == '>' for c in horizontal) or all(c == '<' for c in horizontal):\n        # Check if all vertical streets are in the same direction\n        if all(c == 'v' for c in vertical) or all(c == '^' for c in vertical):\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nhorizontal = input().strip()\nvertical = input().strip()\n\n# Determine if the pattern meets the criteria\nresult = is_reachable(n, m, horizontal, vertical)\nprint(result)"}
{"solution": "def find_bracket_placement(n, arguments):\n    # If there's only one argument, the result is the argument itself\n    if n == 1:\n        return \"YES\", arguments[0]\n    \n    # Check if there's at least one '1' followed by a '0'\n    for i in range(n - 1):\n        if arguments[i] == '1' and arguments[i + 1] == '0':\n            # We can place brackets to make the expression false\n            result = arguments[0]\n            for j in range(1, n):\n                if j == i + 1:\n                    result = f\"({result}->{arguments[j]})\"\n                else:\n                    result = f\"{result}->{arguments[j]}\"\n            return \"YES\", result\n    \n    # If no such pair is found, it's impossible to make the expression false\n    return \"NO\", None\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\narguments = data[1:]\n\n# Find the bracket placement\nresult, expression = find_bracket_placement(n, arguments)\n\n# Print the result\nprint(result)\nif expression:\n    print(expression)"}
{"solution": "def process_values(n, m):\n    while n != 0 and m != 0:\n        if n >= 2 * m:\n            n = n % (2 * m)\n        elif m >= 2 * n:\n            m = m % (2 * n)\n        else:\n            break\n    return n, m\n\n# Read input\nn, m = map(int, input().strip().split())\n\n# Process the values\nresult_n, result_m = process_values(n, m)\n\n# Print the result\nprint(result_n, result_m)"}
{"solution": "def count_k_divisible(k, a, b):\n    # Calculate the first k-divisible number greater than or equal to a\n    if a % k == 0:\n        first_divisible = a\n    else:\n        first_divisible = a + (k - a % k)\n    \n    # Calculate the last k-divisible number less than or equal to b\n    if b % k == 0:\n        last_divisible = b\n    else:\n        last_divisible = b - (b % k)\n    \n    # If the first divisible number is greater than the last, there are no k-divisible numbers in the range\n    if first_divisible > last_divisible:\n        return 0\n    \n    # Calculate the number of k-divisible numbers in the range\n    return (last_divisible - first_divisible) // k + 1\n\n# Read input\nk, a, b = map(int, input().split())\n\n# Print the result\nprint(count_k_divisible(k, a, b))"}
{"solution": "def find_kth_digit(k):\n    length = 0\n    digit_length = 1\n    count = 9\n    \n    while k > length + digit_length * count:\n        length += digit_length * count\n        digit_length += 1\n        count *= 10\n    \n    number = 10**(digit_length - 1) + (k - length - 1) // digit_length\n    digit_index = (k - length - 1) % digit_length\n    \n    return str(number)[digit_index]\n\n# Read input\nk = int(input().strip())\n\n# Find and print the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "def can_vasya_win(n, s):\n    # Calculate the number of moves each player will make\n    moves_each = (n - 11) // 2\n    \n    # Count the number of '8's in the first n - 10 characters\n    count_8s = s[:n - 10].count('8')\n    \n    # Vasya wins if there are more '8's than the number of moves Petya can make\n    if count_8s > moves_each:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Determine if Vasya has a winning strategy\nresult = can_vasya_win(n, s)\nprint(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial(n):\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef count_valid_permutations(n, x, pos):\n    less_than_x = x - 1\n    greater_than_x = n - x\n    \n    left = 0\n    right = n\n    less_count = 0\n    greater_count = 0\n    \n    while left < right:\n        middle = (left + right) // 2\n        if middle <= pos:\n            if middle != pos:\n                less_count += 1\n            left = middle + 1\n        else:\n            greater_count += 1\n            right = middle\n    \n    if less_count > less_than_x or greater_count > greater_than_x:\n        return 0\n    \n    less_permutations = factorial(less_than_x) // factorial(less_than_x - less_count)\n    greater_permutations = factorial(greater_than_x) // factorial(greater_than_x - greater_count)\n    remaining_permutations = factorial(n - 1 - less_count - greater_count)\n    \n    result = (less_permutations * greater_permutations) % MOD\n    result = (result * remaining_permutations) % MOD\n    \n    return result\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Calculate and print the result\nprint(count_valid_permutations(n, x, pos))"}
{"solution": "def decode_message(encoded_str, k):\n    # Initialize variables\n    n = len(encoded_str)\n    result = []\n    i = 0\n\n    # Iterate through the encoded string\n    while i < n:\n        if encoded_str[i].isalpha():\n            result.append(encoded_str[i])\n            i += 1\n        elif encoded_str[i] == '?':\n            if len(result) > 0:\n                result.pop()\n            i += 1\n        elif encoded_str[i] == '*':\n            if len(result) > 0:\n                result.append(result[-1])\n            i += 1\n\n    # Check if the result length matches k\n    if len(result) == k:\n        return ''.join(result)\n    else:\n        return \"Impossible\"\n\n# Read input\nencoded_str = input().strip()\nk = int(input().strip())\n\n# Get the decoded message\ndecoded_message = decode_message(encoded_str, k)\n\n# Print the result\nprint(decoded_message)"}
{"solution": "def minimum_clockwise_turns(x):\n    # Normalize the angle to be within the range [0, 360)\n    x = x % 360\n    if x < 0:\n        x += 360\n\n    # Calculate the deviation from vertical for each possible number of 90-degree turns\n    deviations = [(x + 90 * i) % 360 for i in range(4)]\n    deviations = [min(deviation, 360 - deviation) for deviation in deviations]\n\n    # Find the minimum deviation and its corresponding number of turns\n    min_deviation = min(deviations)\n    min_turns = deviations.index(min_deviation)\n\n    return min_turns\n\n# Read input\nx = int(input().strip())\n\n# Calculate and print the minimum number of 90-degree clockwise turns\nprint(minimum_clockwise_turns(x))"}
{"solution": "def can_transform(a, b, c, x, y, z):\n    # Calculate the surplus or deficit of each color\n    surplus_blue = a - x\n    surplus_violet = b - y\n    surplus_orange = c - z\n\n    # If all surpluses are non-negative, we already have enough spheres\n    if surplus_blue >= 0 and surplus_violet >= 0 and surplus_orange >= 0:\n        return \"Yes\"\n\n    # Calculate the total surplus and total deficit\n    total_surplus = max(0, surplus_blue) // 2 + max(0, surplus_violet) // 2 + max(0, surplus_orange) // 2\n    total_deficit = max(0, -surplus_blue) + max(0, -surplus_violet) + max(0, -surplus_orange)\n\n    # If the total surplus is at least the total deficit, transformation is possible\n    if total_surplus >= total_deficit:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Print the result\nprint(can_transform(a, b, c, x, y, z))"}
{"solution": "def count_valid_numbers(n, k, m):\n    # Initialize a list to store the number of valid numbers with exactly i digits\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case: there's one way to have a number with 0 digits (the empty number)\n\n    # Iterate over the number of digits from 1 to n\n    for i in range(1, n + 1):\n        # Iterate over all possible last digits (0 to 9)\n        for last_digit in range(10):\n            # If the number has exactly i digits and ends with last_digit\n            # We need to check if the number formed by the last k digits is divisible by k\n            if i >= len(str(k)):\n                # Form the number by taking the last k digits\n                suffix = int(str(last_digit) + '0' * (len(str(k)) - 1))\n                if suffix % k == 0:\n                    dp[i] = (dp[i] + dp[i - 1]) % m\n            else:\n                dp[i] = (dp[i] + dp[i - 1]) % m\n\n    # The answer is the number of valid numbers with exactly n digits\n    return dp[n]\n\n# Read input\nn, k, m = map(int, input().split())\n\n# Compute the result\nresult = count_valid_numbers(n, k, m)\n\n# Print the result\nprint(result)"}
{"solution": "def max_team_size(l, r, a):\n    if l > r:\n        l, r = r, l  # Ensure l is always the smaller or equal group\n    \n    # Use ambidexters to balance the difference\n    d = r - l\n    if a >= d:\n        l += d\n        a -= d\n        # Now l == r, distribute remaining ambidexters equally\n        l += a // 2\n        r += a // 2\n    else:\n        l += a\n        # Not enough ambidexters to balance completely, r remains larger\n    \n    # The maximum team size is twice the smaller group\n    return 2 * min(l, r)\n\n# Read input\nl, r, a = map(int, input().split())\n\n# Print the result\nprint(max_team_size(l, r, a))"}
{"solution": "def min_moves_to_collect_coins(n, k):\n    # Calculate the minimum moves required to collect all coins\n    # Initial position is k-1 (0-based index)\n    k -= 1\n    \n    # Calculate the minimum distance to the nearest end\n    min_distance_to_end = min(k, n - k - 1)\n    \n    # Total moves to throw all stones and collect all coins\n    total_moves = 3 * (n - 1) + n + min_distance_to_end\n    \n    return total_moves\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(min_moves_to_collect_coins(n, k))"}
{"solution": "def min_tallest_tower(n, m):\n    # Calculate the maximum height for towers made of 2-block pieces\n    max_height_2 = 2 * n if n > 0 else 0\n    \n    # Calculate the maximum height for towers made of 3-block pieces\n    max_height_3 = 3 * m if m > 0 else 0\n    \n    # The minimum height necessary for the tallest tower is the maximum of these two heights\n    return max(max_height_2, max_height_3)\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(min_tallest_tower(n, m))"}
{"solution": "def fair_game(n, cards):\n    from collections import Counter\n    \n    # Count the frequency of each number on the cards\n    count = Counter(cards)\n    \n    # If there are exactly two distinct numbers and each appears n/2 times, it's a fair game\n    if len(count) == 2:\n        values = list(count.values())\n        if values[0] == values[1] == n // 2:\n            keys = list(count.keys())\n            print(\"YES\")\n            print(keys[0], keys[1])\n            return\n    \n    print(\"NO\")\n\n# Read input\nn = int(input().strip())\ncards = [int(input().strip()) for _ in range(n)]\n\n# Determine if the game can be fair\nfair_game(n, cards)"}
{"solution": "def can_place_soldiers(n, k, groups):\n    # Each row has 4 pairs of neighboring seats\n    pairs_per_row = 4\n    total_pairs = n * pairs_per_row\n\n    # Count the number of groups that need more than 2 seats\n    more_than_two = sum(1 for group in groups if group > 2)\n\n    # Calculate the total number of pairs needed\n    pairs_needed = sum((group + 1) // 2 for group in groups)\n\n    # Check if we have enough pairs to place all groups\n    if pairs_needed <= total_pairs and more_than_two <= n:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\ngroups = list(map(int, data[2:]))\n\n# Output the result\nprint(can_place_soldiers(n, k, groups))"}
{"solution": "def find_min_cost_and_t(n, sticks):\n    min_cost = float('inf')\n    best_t = -1\n    \n    for t in range(1, 101):\n        current_cost = 0\n        for stick in sticks:\n            if abs(stick - t) > 1:\n                current_cost += abs(stick - t) - 1\n        if current_cost < min_cost:\n            min_cost = current_cost\n            best_t = t\n    \n    return best_t, min_cost\n\n# Read input\nn = int(input())\nsticks = list(map(int, input().split()))\n\n# Find the best t and the minimum cost\nbest_t, min_cost = find_min_cost_and_t(n, sticks)\n\n# Print the result\nprint(best_t, min_cost)"}
{"solution": "# Read input values\nn, m = map(int, input().split())\nsky_map = [input().strip() for _ in range(n)]\n\n# Initialize variables to find the bounding box of stars\nmin_x, max_x = n, 0\nmin_y, max_y = m, 0\n\n# Find the bounding box of all stars\nfor i in range(n):\n    for j in range(m):\n        if sky_map[i][j] == '*':\n            if i < min_x:\n                min_x = i\n            if i > max_x:\n                max_x = i\n            if j < min_y:\n                min_y = j\n            if j > max_y:\n                max_y = j\n\n# Calculate the side length of the smallest square that can cover all stars\nside_length = max(max_x - min_x + 1, max_y - min_y + 1)\n\n# Print the result\nprint(side_length)"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_inv(x, mod):\n    return pow(x, mod - 2, mod)\n\ndef solve(n, k, a):\n    ones = sum(a)\n    zeros = n - ones\n    \n    if ones == 0 or zeros == 0:\n        print(1)\n        return\n    \n    total_pairs = n * (n - 1) // 2\n    sorted_pairs = ones * zeros\n    \n    if k == 1:\n        if sorted_pairs == 0:\n            print(1)\n        else:\n            print(0)\n        return\n    \n    P = sorted_pairs\n    Q = total_pairs\n    \n    P = (P * mod_inv(Q, MOD)) % MOD\n    \n    print(P)\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    solve(n, k, a)"}
{"solution": "def min_seconds_to_devolve(x, y):\n    # The minimum number of seconds required is simply the difference between x and y\n    return x - y\n\n# Read input\nx, y = map(int, input().split())\n\n# Calculate and print the result\nprint(min_seconds_to_devolve(x, y))"}
{"solution": "def min_norm_degenerate_matrix(a, b, c, d):\n    # Calculate the determinant of the matrix A\n    det_A = a * d - b * c\n    \n    # If the determinant is already zero, the matrix is already degenerate\n    if det_A == 0:\n        return 0.0\n    \n    # Calculate the minimum possible value of ||A - B||\n    # We need to find the minimum value of |ad - bc| / sqrt(a^2 + c^2 + b^2 + d^2)\n    norm_A = max(abs(a), abs(b), abs(c), abs(d))\n    \n    # Calculate the minimum possible value of ||A - B||\n    min_norm = abs(det_A) / (abs(a) + abs(c) + abs(b) + abs(d))\n    \n    return min_norm\n\n# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate and print the result\nresult = min_norm_degenerate_matrix(a, b, c, d)\nprint(f\"{result:.10f}\")"}
{"solution": "# Read input values\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = int(data[1])\nb = int(data[2])\ngroups = list(map(int, data[3:]))\n\n# Initialize counters\ndenied_service = 0\none_seater_tables = a\ntwo_seater_tables = b\none_person_in_two_seater = 0\n\n# Process each group\nfor group in groups:\n    if group == 1:\n        if one_seater_tables > 0:\n            one_seater_tables -= 1\n        elif two_seater_tables > 0:\n            two_seater_tables -= 1\n            one_person_in_two_seater += 1\n        elif one_person_in_two_seater > 0:\n            one_person_in_two_seater -= 1\n        else:\n            denied_service += 1\n    elif group == 2:\n        if two_seater_tables > 0:\n            two_seater_tables -= 1\n        else:\n            denied_service += 2\n\n# Print the result\nprint(denied_service)"}
{"solution": "def calculate_students_not_passed(A, B, C, N):\n    # Check for invalid conditions\n    if C > A or C > B or A + B - C >= N:\n        return -1\n    \n    # Calculate the number of students who didn't pass\n    students_passed = A + B - C\n    students_not_passed = N - students_passed\n    \n    # Check if at least one student didn't pass\n    if students_not_passed < 1:\n        return -1\n    \n    return students_not_passed\n\n# Read input values\nA, B, C, N = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_students_not_passed(A, B, C, N)\nprint(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_exp(base, exp, mod):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return result\n\ndef expected_dresses(x, k):\n    if x == 0:\n        return 0\n    # Calculate 2^(k+1) % MOD\n    power = mod_exp(2, k + 1, MOD)\n    # Calculate (x * power - 1) % MOD\n    result = (x * power - 1) % MOD\n    return result\n\n# Read input\nx, k = map(int, input().split())\n\n# Calculate and print the result\nprint(expected_dresses(x, k))"}
{"solution": "MOD = 998244353\n\ndef mod_inv(a, p):\n    return pow(a, p - 2, p)\n\ndef calculate_probability(n, ranges):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        l_i, r_i = ranges[i - 1]\n        for j in range(i + 1):\n            dp[i][j] = dp[i - 1][j] * (r_i - l_i + 1) % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * (r_i - l_i + 1) % MOD) % MOD\n\n    total_ways = 1\n    for l_i, r_i in ranges:\n        total_ways = total_ways * (r_i - l_i + 1) % MOD\n\n    no_inversion_ways = sum(dp[n][i] for i in range(n + 1)) % MOD\n    probability = no_inversion_ways * mod_inv(total_ways, MOD) % MOD\n\n    return probability\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    ranges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n)]\n    \n    result = calculate_probability(n, ranges)\n    print(result)"}
{"solution": "def count_ways(n):\n    count = 0\n    for a in range(1, n // 4 + 1):\n        for b in range(a, (n - 2 * a) // 2 + 1):\n            c = b\n            d = n - a - b - c\n            if d >= c and a + b + c + d == n and a != b:\n                count += 1\n    return count\n\nn = int(input())\nprint(count_ways(n))"}
{"solution": "def fair_nut_kvass(n, s, volumes):\n    total_volume = sum(volumes)\n    \n    if total_volume < s:\n        return -1\n    \n    left, right = 0, min(volumes)\n    \n    while left < right:\n        mid = (left + right + 1) // 2\n        if sum(max(0, v - mid) for v in volumes) >= s:\n            left = mid\n        else:\n            right = mid - 1\n    \n    return left\n\n# Read input\nn, s = map(int, input().split())\nvolumes = list(map(int, input().split()))\n\n# Get the result\nresult = fair_nut_kvass(n, s, volumes)\n\n# Print the result\nprint(result)"}
{"solution": "def days_to_reach_apple(h1, h2, a, b):\n    # Initial height difference\n    height_diff = h2 - h1\n    \n    # Initial climb from 2 pm to 10 pm (8 hours)\n    initial_climb = 8 * a\n    \n    # If the initial climb is enough to reach the apple\n    if initial_climb >= height_diff:\n        return 0\n    \n    # Net gain per day (12 hours climb - 12 hours slip)\n    net_gain_per_day = 12 * (a - b)\n    \n    # If the caterpillar slips more than it climbs in a full day\n    if net_gain_per_day <= 0:\n        return -1\n    \n    # Remaining height to climb after the first day\n    remaining_height = height_diff - initial_climb\n    \n    # Calculate the number of full days needed\n    full_days_needed = (remaining_height + net_gain_per_day - 1) // net_gain_per_day\n    \n    return full_days_needed + 1\n\n# Read input\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(days_to_reach_apple(h1, h2, a, b))"}
{"solution": "def max_joy_units(C, Hr, Hb, Wr, Wb):\n    # If the weight of red candies is greater than the weight of blue candies, swap them\n    if Wr > Wb:\n        Hr, Hb = Hb, Hr\n        Wr, Wb = Wb, Wr\n\n    max_joy = 0\n\n    # Try all possible counts of blue candies\n    for blue_candies in range(0, C // Wb + 1):\n        remaining_weight = C - blue_candies * Wb\n        red_candies = remaining_weight // Wr\n        joy_units = blue_candies * Hb + red_candies * Hr\n        max_joy = max(max_joy, joy_units)\n\n    return max_joy\n\n# Read input\nC, Hr, Hb, Wr, Wb = map(int, input().split())\n\n# Calculate and print the maximum joy units\nprint(max_joy_units(C, Hr, Hb, Wr, Wb))"}
{"solution": "# Read input values\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\n# Calculate the minimal number of steps\nd = max(abs(x2 - x1), abs(y2 - y1))\n\n# Print the result\nprint(d)"}
{"solution": "def predict_vote_outcome(n, employees):\n    from collections import deque\n\n    depublicans = deque()\n    remocrats = deque()\n\n    for i in range(n):\n        if employees[i] == 'D':\n            depublicans.append(i)\n        else:\n            remocrats.append(i)\n\n    while depublicans and remocrats:\n        d = depublicans.popleft()\n        r = remocrats.popleft()\n        if d < r:\n            depublicans.append(d + n)\n        else:\n            remocrats.append(r + n)\n\n    if depublicans:\n        return 'D'\n    else:\n        return 'R'\n\n# Read input\nn = int(input().strip())\nemployees = input().strip()\n\n# Predict and print the outcome\nprint(predict_vote_outcome(n, employees))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_tv_sets(a, b, x, y):\n    # Reduce the aspect ratio x/y to its simplest form\n    g = gcd(x, y)\n    x //= g\n    y //= g\n    \n    # Find the maximum k such that k*x <= a and k*y <= b\n    k = min(a // x, b // y)\n    \n    return k\n\n# Read input\na, b, x, y = map(int, input().split())\n\n# Calculate and print the result\nprint(count_tv_sets(a, b, x, y))"}
{"solution": "def prime_factors(n):\n    i = 2\n    factors = {}\n    while i * i <= n:\n        while (n % i) == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n //= i\n        i += 1\n    if n > 1:\n        factors[n] = 1\n    return factors\n\ndef count_factors_in_factorial(n, p):\n    count = 0\n    power = p\n    while power <= n:\n        count += n // power\n        power *= p\n    return count\n\ndef trailing_zeros_in_base(n, b):\n    b_factors = prime_factors(b)\n    min_trailing_zeros = float('inf')\n    \n    for p in b_factors:\n        count_p_in_factorial = count_factors_in_factorial(n, p)\n        max_trailing_zeros_for_p = count_p_in_factorial // b_factors[p]\n        min_trailing_zeros = min(min_trailing_zeros, max_trailing_zeros_for_p)\n    \n    return min_trailing_zeros\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    n, b = map(int, input().strip().split())\n    print(trailing_zeros_in_base(n, b))"}
{"solution": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef sum_f(m, a, b):\n    g = gcd(a, b)\n    lcm_ab = (a // g) * b\n\n    sum_f = 0\n    for i in range(lcm_ab):\n        if i <= m:\n            sum_f += (m - i) // lcm_ab + 1\n        else:\n            break\n\n    return sum_f\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    m = int(data[0])\n    a = int(data[1])\n    b = int(data[2])\n    \n    result = sum_f(m, a, b)\n    print(result)"}
{"solution": "def can_divide_into_odd_subsegments(n, sequence):\n    # Check if the sequence length is odd\n    if n % 2 == 0:\n        return \"No\"\n    \n    # Check if the first and last elements are odd\n    if sequence[0] % 2 == 1 and sequence[-1] % 2 == 1:\n        return \"Yes\"\n    \n    return \"No\"\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Determine if it's possible to divide the sequence as required\nresult = can_divide_into_odd_subsegments(n, sequence)\nprint(result)"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    # Check if the given points can form a square\n    if x1 == x2:\n        # Vertical line, the other two points must be horizontal\n        side_length = abs(y2 - y1)\n        x3, y3 = x1 + side_length, y1\n        x4, y4 = x2 + side_length, y2\n    elif y1 == y2:\n        # Horizontal line, the other two points must be vertical\n        side_length = abs(x2 - x1)\n        x3, y3 = x1, y1 + side_length\n        x4, y4 = x2, y2 + side_length\n    elif abs(x2 - x1) == abs(y2 - y1):\n        # Diagonal line, the other two points must form the other diagonal\n        x3, y3 = x1, y2\n        x4, y4 = x2, y1\n    else:\n        # The given points cannot form a square\n        return -1\n\n    return x3, y3, x4, y4\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\n\n# Find the remaining trees\nresult = find_remaining_trees(x1, y1, x2, y2)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    print(result[0], result[1], result[2], result[3])"}
{"solution": "def calculate_fn(x, y, n):\n    MOD = 1000000007\n    \n    # The sequence repeats every 6 terms\n    sequence = [x, y, y - x, -x, -y, x - y]\n    \n    # Adjust n to be within the range of 1 to 6\n    n = (n - 1) % 6\n    \n    # Return the nth term modulo 1000000007\n    return sequence[n] % MOD\n\n# Read input\nx, y = map(int, input().split())\nn = int(input())\n\n# Calculate and print the result\nprint(calculate_fn(x, y, n))"}
{"solution": "def split_array(n, A):\n    total_sum = sum(A)\n    \n    if total_sum != 0:\n        print(\"YES\")\n        print(1)\n        print(1, n)\n        return\n    \n    for i in range(n):\n        if A[i] != 0:\n            print(\"YES\")\n            print(2)\n            print(1, i + 1)\n            print(i + 2, n)\n            return\n    \n    print(\"NO\")\n\n# Read input\nn = int(input())\nA = list(map(int, input().split()))\n\n# Call the function\nsplit_array(n, A)"}
{"solution": "MOD = 1000000009\n\ndef min_score(n, m, k):\n    if m < k:\n        return m % MOD\n    \n    full_sets = m // k\n    remaining_correct = m % k\n    \n    if full_sets * (k - 1) + remaining_correct >= n:\n        return (2 * (m - n) + n) % MOD\n    \n    return (2 * full_sets + remaining_correct) % MOD\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Calculate and print the result\nprint(min_score(n, m, k))"}
{"solution": "def is_divisible_by_8(n):\n    length = len(n)\n    \n    # Check all single digit numbers\n    for i in range(length):\n        if int(n[i]) % 8 == 0:\n            return \"YES\", n[i]\n    \n    # Check all two digit numbers\n    for i in range(length):\n        for j in range(i + 1, length):\n            if int(n[i] + n[j]) % 8 == 0:\n                return \"YES\", n[i] + n[j]\n    \n    # Check all three digit numbers\n    for i in range(length):\n        for j in range(i + 1, length):\n            for k in range(j + 1, length):\n                if int(n[i] + n[j] + n[k]) % 8 == 0:\n                    return \"YES\", n[i] + n[j] + n[k]\n    \n    return \"NO\", \"\"\n\n# Read input\nn = input().strip()\n\n# Determine if there is a valid number divisible by 8\nresult, number = is_divisible_by_8(n)\n\n# Print the result\nprint(result)\nif result == \"YES\":\n    print(number)"}
{"solution": "def find_floor(n, m, memories):\n    possible_floors = set()\n    \n    for flats_per_floor in range(1, 101):\n        consistent = True\n        for k, f in memories:\n            if (k - 1) // flats_per_floor + 1 != f:\n                consistent = False\n                break\n        if consistent:\n            possible_floors.add((n - 1) // flats_per_floor + 1)\n    \n    if len(possible_floors) == 1:\n        return possible_floors.pop()\n    else:\n        return -1\n\n# Read input\nn, m = map(int, input().split())\nmemories = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Find and print the floor\nprint(find_floor(n, m, memories))"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    board = [[board1[i], board2[i]] for i in range(n)]\n    \n    # Define the four possible shapes of the bishwock\n    bishwock_shapes = [\n        [(0, 0), (0, 1), (1, 0)],  # Original L shape\n        [(0, 0), (0, 1), (1, 1)],  # Rotated 90 degrees\n        [(0, 1), (1, 0), (1, 1)],  # Rotated 180 degrees\n        [(0, 0), (1, 0), (1, 1)]   # Rotated 270 degrees\n    ]\n    \n    def can_place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            if nx >= 2 or ny >= n or board[ny][nx] == 'X':\n                return False\n        return True\n    \n    def place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            board[ny][nx] = 'X'\n    \n    count = 0\n    for y in range(n):\n        for x in range(2):\n            for shape in bishwock_shapes:\n                if can_place_bishwock(x, y, shape):\n                    place_bishwock(x, y, shape)\n                    count += 1\n                    break\n    \n    return count\n\n# Read input\nboard1 = input().strip()\nboard2 = input().strip()\n\n# Calculate and print the result\nprint(max_bishwocks(board1, board2))"}
{"solution": "def max_pretty_set_length(n, s):\n    max_length = 0\n    current_set = set()\n    \n    for char in s:\n        if char.islower():\n            current_set.add(char)\n        else:\n            max_length = max(max_length, len(current_set))\n            current_set.clear()\n    \n    # Check the last segment\n    max_length = max(max_length, len(current_set))\n    \n    return max_length\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult = max_pretty_set_length(n, s)\n\n# Print the result\nprint(result)"}
{"solution": "def max_B_minus_C(n, a):\n    # Calculate the total sum of the array\n    total_sum = sum(a)\n    \n    # Calculate the maximum possible value of B - C\n    max_value = total_sum - 2 * min(0, sum(x for x in a if x < 0))\n    \n    return max_value\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = max_B_minus_C(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def min_refuels(a, b, f, k):\n    # If the tank capacity is less than the distance to the gas station or the distance from the gas station to the end point, it's impossible\n    if b < f or b < (a - f):\n        return -1\n\n    refuels = 0\n    current_fuel = b\n\n    for i in range(1, k + 1):\n        if i % 2 == 1:  # Odd journey: 0 -> a\n            if current_fuel < f:\n                return -1\n            current_fuel -= f\n            if current_fuel < (a - f):\n                refuels += 1\n                current_fuel = b\n            current_fuel -= (a - f)\n        else:  # Even journey: a -> 0\n            if current_fuel < (a - f):\n                return -1\n            current_fuel -= (a - f)\n            if current_fuel < f:\n                refuels += 1\n                current_fuel = b\n            current_fuel -= f\n\n    return refuels\n\n# Read input\na, b, f, k = map(int, input().split())\n\n# Calculate and print the result\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    for i in range(n // p + 1):\n        if (n - i * p) % q == 0:\n            j = (n - i * p) // q\n            result = []\n            index = 0\n            for _ in range(i):\n                result.append(s[index:index + p])\n                index += p\n            for _ in range(j):\n                result.append(s[index:index + q])\n                index += q\n            print(len(result))\n            for part in result:\n                print(part)\n            return\n    print(-1)\n\n# Read input\nn, p, q = map(int, input().split())\ns = input().strip()\n\n# Call the function\nsplit_string(n, p, q, s)"}
{"solution": "def solve(n, m, s, d, obstacles):\n    obstacles.sort()\n    current_position = 0\n    commands = []\n\n    for i in range(n):\n        if obstacles[i] - current_position - 1 >= s:\n            run_length = obstacles[i] - current_position - 1\n            commands.append(f\"RUN {run_length}\")\n            current_position += run_length\n\n            if i < n - 1 and obstacles[i + 1] - obstacles[i] - 1 < s:\n                if obstacles[i + 1] - current_position - 1 > d:\n                    print(\"IMPOSSIBLE\")\n                    return\n                jump_length = obstacles[i + 1] - current_position\n                commands.append(f\"JUMP {jump_length}\")\n                current_position += jump_length\n            else:\n                jump_length = min(d, m - current_position)\n                commands.append(f\"JUMP {jump_length}\")\n                current_position += jump_length\n        else:\n            print(\"IMPOSSIBLE\")\n            return\n\n    if current_position < m:\n        run_length = m - current_position\n        commands.append(f\"RUN {run_length}\")\n\n    for command in commands:\n        print(command)\n\n# Read input\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\n# Solve the problem\nsolve(n, m, s, d, obstacles)"}
{"solution": "def count_valid_pairs(s, x):\n    # Check if s - x is even\n    if (s - x) % 2 != 0:\n        return 0\n    \n    # Calculate b\n    b = (s - x) // 2\n    \n    # Check if b is positive\n    if b <= 0:\n        return 0\n    \n    # Calculate a\n    a = s - b\n    \n    # Check if a is positive\n    if a <= 0:\n        return 0\n    \n    # Check if a and b satisfy the XOR condition\n    if a ^ b != x:\n        return 0\n    \n    # If all conditions are met, return 2 (for (a, b) and (b, a))\n    return 2 if a != b else 1\n\n# Read input\ns, x = map(int, input().split())\n\n# Calculate the number of valid pairs\nresult = count_valid_pairs(s, x)\n\n# Print the result\nprint(result)"}
{"solution": "def turn_skewers(n, k):\n    # Calculate the step size\n    step = 2 * k + 1\n    \n    # Initialize the list of actions\n    actions = []\n    \n    # Start from the first skewer and move in steps of 'step'\n    i = 1\n    while i <= n:\n        actions.append(i)\n        i += step\n    \n    # If the last skewer is not covered, adjust the last action\n    if actions[-1] + k < n:\n        actions[-1] = n - k\n    \n    return actions\n\n# Read input\nn, k = map(int, input().split())\n\n# Get the actions\nactions = turn_skewers(n, k)\n\n# Print the results\nprint(len(actions))\nprint(' '.join(map(str, actions)))"}
{"solution": "def min_operations_to_square(n):\n    import math\n    \n    n_str = str(n)\n    n_len = len(n_str)\n    \n    # Generate all possible squares up to the maximum possible value\n    max_square_root = int(math.sqrt(2 * 10**9)) + 1\n    squares = [str(i * i) for i in range(1, max_square_root + 1)]\n    \n    def is_subsequence(small, large):\n        it = iter(large)\n        return all(char in it for char in small)\n    \n    min_deletions = float('inf')\n    \n    for square in squares:\n        if is_subsequence(square, n_str):\n            deletions = n_len - len(square)\n            min_deletions = min(min_deletions, deletions)\n    \n    return min_deletions if min_deletions != float('inf') else -1\n\n# Read input\nn = int(input().strip())\n\n# Print output\nprint(min_operations_to_square(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef solve(n):\n    if n == 2:\n        print(1)\n        return\n    \n    # For n >= 3, the number of permutations where f(p) = f_max(n) is (n-1)!\n    result = factorial(n - 1)\n    print(result)\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    n = int(input().strip())\n    solve(n)"}
{"solution": "def minimum_jump_ability(s):\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    positions = [-1]  # Start position before the first character\n    \n    # Collect positions of all vowels\n    for i, char in enumerate(s):\n        if char in vowels:\n            positions.append(i)\n    \n    positions.append(len(s))  # End position after the last character\n    \n    # Calculate maximum distance between consecutive positions\n    max_distance = 0\n    for i in range(1, len(positions)):\n        max_distance = max(max_distance, positions[i] - positions[i - 1])\n    \n    print(max_distance)\n\n# Read input\ns = input().strip()\nminimum_jump_ability(s)"}
{"solution": "def can_distribute_equally(a1, a2, a3, a4):\n    candies = [a1, a2, a3, a4]\n    total = sum(candies)\n    \n    # If the total number of candies is odd, it's impossible to split them equally\n    if total % 2 != 0:\n        return \"NO\"\n    \n    half = total // 2\n    \n    # Check all possible combinations of distributing the bags\n    for i in range(4):\n        for j in range(i + 1, 4):\n            if candies[i] + candies[j] == half:\n                return \"YES\"\n    \n    # Check if any single bag equals half of the total candies\n    if any(candy == half for candy in candies):\n        return \"YES\"\n    \n    # Check if the sum of any three bags equals half of the total candies\n    for i in range(4):\n        if total - candies[i] == half:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\na1, a2, a3, a4 = map(int, input().split())\n\n# Print the result\nprint(can_distribute_equally(a1, a2, a3, a4))"}
{"solution": "def optimal_pie_distribution(N, slices):\n    # Initialize sums for Alice and Bob\n    alice_sum = 0\n    bob_sum = 0\n    \n    # Initialize the decider token holder (0 for Bob, 1 for Alice)\n    decider = 0\n    \n    # Iterate through the slices\n    for i in range(N):\n        if decider == 0:  # Bob is the decider\n            if i % 2 == 0:\n                bob_sum += slices[i]\n                decider = 1  # Pass the decider token to Alice\n            else:\n                alice_sum += slices[i]\n                decider = 1  # Pass the decider token to Alice\n        else:  # Alice is the decider\n            if i % 2 == 0:\n                alice_sum += slices[i]\n                decider = 0  # Pass the decider token to Bob\n            else:\n                bob_sum += slices[i]\n                decider = 0  # Pass the decider token to Bob\n    \n    return alice_sum, bob_sum\n\n# Read input\nN = int(input())\nslices = list(map(int, input().split()))\n\n# Get the optimal distribution\nalice_sum, bob_sum = optimal_pie_distribution(N, slices)\n\n# Print the result\nprint(alice_sum, bob_sum)"}
{"solution": "def min_variables(n, a):\n    from itertools import combinations\n\n    # Function to check if we can generate the sequence with m variables\n    def can_generate_with_m(m):\n        # Initialize variables\n        b = [0] * m\n        b[0] = a[0]\n        used = {a[0]}\n        \n        for k in range(1, n):\n            found = False\n            for i, j in combinations(range(m), 2):\n                if b[i] + b[j] == a[k] or b[j] + b[i] == a[k]:\n                    b[k % m] = a[k]\n                    used.add(a[k])\n                    found = True\n                    break\n            if not found:\n                return False\n        return True\n\n    # Try to find the minimum m\n    for m in range(1, n + 1):\n        if can_generate_with_m(m):\n            return m\n    return -1\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find and print the minimum number of variables\nprint(min_variables(n, a))"}
{"solution": "def determine_winner(n, piles):\n    odd_count = sum(1 for pile in piles if pile % 2 != 0)\n    if odd_count % 2 == 0:\n        return \"Alice\"\n    else:\n        return \"Bob\"\n\n# Read input\nn = int(input())\npiles = list(map(int, input().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, piles))"}
{"solution": "def can_make_elements_equal(n, arr):\n    # Convert the array to a set to get unique elements\n    unique_elements = set(arr)\n    \n    # If there are 1 or 2 unique elements, we can always make them equal\n    if len(unique_elements) <= 2:\n        return \"YES\"\n    \n    # If there are more than 3 unique elements, it's impossible\n    if len(unique_elements) > 3:\n        return \"NO\"\n    \n    # If there are exactly 3 unique elements, check the condition\n    unique_elements = sorted(unique_elements)\n    if unique_elements[2] - unique_elements[1] == unique_elements[1] - unique_elements[0]:\n        return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Print the result\nprint(can_make_elements_equal(n, arr))"}
{"solution": "def find_max_non_overlapping_substring_length(N, S):\n    def has_repeated_substring_of_length(length):\n        seen = set()\n        for i in range(N - length + 1):\n            substring = S[i:i + length]\n            if substring in seen:\n                return True\n            seen.add(substring)\n        return False\n\n    left, right = 1, N\n    max_len = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if has_repeated_substring_of_length(mid):\n            max_len = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return max_len\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nS = data[1]\n\n# Find and print the result\nresult = find_max_non_overlapping_substring_length(N, S)\nprint(result)"}
{"solution": "def minimum_time_to_house(n, a):\n    if a % 2 == 1:\n        # a is odd\n        return (a + 1) // 2\n    else:\n        # a is even\n        return (n - a + 2) // 2\n\n# Read input\nn, a = map(int, input().split())\n\n# Calculate and print the result\nprint(minimum_time_to_house(n, a))"}
{"solution": "def find_jedi_interval(n, m, colors, required_counts):\n    # Initialize the current counts of each color in the window\n    current_counts = [0] * m\n    left = 0\n\n    # Function to check if current window matches the required counts\n    def matches_required_counts():\n        for i in range(m):\n            if current_counts[i] != required_counts[i]:\n                return False\n        return True\n\n    # Sliding window approach\n    for right in range(n):\n        # Add the current color to the window\n        current_counts[colors[right] - 1] += 1\n\n        # Check if the window is valid\n        while matches_required_counts():\n            return \"YES\"\n        \n        # If the window is too large, move the left pointer\n        if right - left + 1 > sum(required_counts):\n            current_counts[colors[left] - 1] -= 1\n            left += 1\n\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\nrequired_counts = list(map(int, input().split()))\n\n# Find and print the result\nprint(find_jedi_interval(n, m, colors, required_counts))"}
{"solution": "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    mishka_wins = 0\n    chris_wins = 0\n    \n    index = 1\n    for _ in range(n):\n        m = int(data[index])\n        c = int(data[index + 1])\n        if m > c:\n            mishka_wins += 1\n        elif c > m:\n            chris_wins += 1\n        index += 2\n    \n    if mishka_wins > chris_wins:\n        print(\"Mishka\")\n    elif chris_wins > mishka_wins:\n        print(\"Chris\")\n    else:\n        print(\"Friendship is magic!^^\")\n\ndetermine_winner()"}
{"solution": "def is_valid_minesweeper_field(n, m, field):\n    # Directions for the 8 neighboring cells\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    \n    def count_bombs_around(x, y):\n        count = 0\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and field[nx][ny] == '*':\n                count += 1\n        return count\n    \n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '.':\n                if count_bombs_around(i, j) != 0:\n                    return \"NO\"\n            elif field[i][j].isdigit():\n                if count_bombs_around(i, j) != int(field[i][j]):\n                    return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Validate the field\nresult = is_valid_minesweeper_field(n, m, field)\nprint(result)"}
{"solution": "def can_vasya_eat_half(n, k):\n    total_candies = n\n    vasya_eaten = 0\n    \n    while total_candies > 0:\n        # Vasya eats k candies\n        vasya_eaten += min(k, total_candies)\n        total_candies -= min(k, total_candies)\n        \n        # Petya eats 10% of the remaining candies\n        petya_eaten = total_candies // 10\n        total_candies -= petya_eaten\n    \n    return vasya_eaten >= (n + 1) // 2\n\ndef find_min_k(n):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Read input\nn = int(input().strip())\n\n# Find and print the minimal k\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace(s):\n    p = s.count('o')\n    l = s.count('-')\n    \n    if p == 0 or p == 1:\n        print(\"YES\")\n    elif l % p == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n# Example usage:\ns = input().strip()\ncan_rearrange_necklace(s)"}
{"solution": "def max_pillows(n, m, k):\n    def can_distribute(x):\n        left = k - 1\n        right = n - k\n        total = x\n        \n        if left > 0:\n            if x > left:\n                total += (x - 1) * left - (left * (left - 1)) // 2\n            else:\n                total += (x * (x - 1)) // 2 + (left - x + 1)\n        \n        if right > 0:\n            if x > right:\n                total += (x - 1) * right - (right * (right - 1)) // 2\n            else:\n                total += (x * (x - 1)) // 2 + (right - x + 1)\n        \n        return total <= m\n\n    low, high = 1, m\n    while low < high:\n        mid = (low + high + 1) // 2\n        if can_distribute(mid):\n            low = mid\n        else:\n            high = mid - 1\n    \n    return low\n\n# Read input\nn, m, k = map(int, input().strip().split())\n\n# Print the result\nprint(max_pillows(n, m, k))"}
{"solution": "import sys\nimport math\n\ndef max_subarray_cost(n, m, k, a):\n    max_cost = 0\n    current_sum = 0\n    min_prefix_sum = 0\n    \n    for i in range(n):\n        current_sum += a[i]\n        for j in range(1, m + 1):\n            if i - j + 1 >= 0:\n                subarray_length = j\n                subarray_cost = current_sum - min_prefix_sum - k * math.ceil(subarray_length / m)\n                max_cost = max(max_cost, subarray_cost)\n        min_prefix_sum = min(min_prefix_sum, current_sum)\n    \n    return max_cost\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2])\n    a = list(map(int, data[3:]))\n    \n    result = max_subarray_cost(n, m, k, a)\n    print(result)"}
{"solution": "import math\n\ndef longest_polyline(n, m):\n    if n == 0:\n        return [(0, 1), (0, m), (0, 0), (0, m-1)]\n    elif m == 0:\n        return [(1, 0), (n, 0), (0, 0), (n-1, 0)]\n    else:\n        if n > m:\n            return [(0, 0), (n, m), (0, m), (n, 0)]\n        else:\n            return [(0, 0), (n, m), (n, 0), (0, m)]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    n, m = map(int, input().strip().split())\n    points = longest_polyline(n, m)\n    for point in points:\n        print(point[0], point[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_smallest_n(shuffled_string, remembered_substring):\n    from collections import Counter\n\n    # Count the frequency of each digit in the shuffled string\n    shuffled_count = Counter(shuffled_string)\n    remembered_count = Counter(remembered_substring)\n\n    # Subtract the count of remembered substring from the shuffled string count\n    for digit in remembered_count:\n        shuffled_count[digit] -= remembered_count[digit]\n\n    # Convert the remaining counts back to a list of digits\n    remaining_digits = []\n    for digit in '0123456789':\n        remaining_digits.extend([digit] * shuffled_count[digit])\n\n    # The length of the original number n\n    length_of_n = len(shuffled_string) - len(remembered_substring)\n\n    # Try to construct the smallest possible number n\n    for i in range(len(remaining_digits) + 1):\n        candidate = remaining_digits[:i] + list(remembered_substring) + remaining_digits[i:]\n        candidate_str = ''.join(candidate)\n        if len(candidate_str) == length_of_n and candidate_str[0] != '0':\n            return candidate_str\n\n    # If no valid number found, return the smallest possible number with leading zeroes\n    return '0' * (length_of_n - len(remembered_substring)) + remembered_substring\n\n# Read input\nshuffled_string = input().strip()\nremembered_substring = input().strip()\n\n# Find and print the smallest possible n\nprint(find_smallest_n(shuffled_string, remembered_substring))"}
{"solution": "# Read input values\nn, m, min_temp, max_temp = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\n# Check if the current temperatures already contain the required min and max\ncurrent_min = min(temperatures)\ncurrent_max = max(temperatures)\n\n# Determine if we can add temperatures to meet the requirements\nif current_min <= min_temp and current_max >= max_temp:\n    print(\"Correct\")\nelif current_min > min_temp and current_max < max_temp:\n    if n - m >= 2:\n        print(\"Correct\")\n    else:\n        print(\"Incorrect\")\nelif current_min > min_temp:\n    if n - m >= 1:\n        print(\"Correct\")\n    else:\n        print(\"Incorrect\")\nelif current_max < max_temp:\n    if n - m >= 1:\n        print(\"Correct\")\n    else:\n        print(\"Incorrect\")\nelse:\n    print(\"Incorrect\")"}
{"solution": "def count_trailing_zeroes(n):\n    count = 0\n    power_of_5 = 5\n    while n >= power_of_5:\n        count += n // power_of_5\n        power_of_5 *= 5\n    return count\n\ndef find_numbers_with_m_trailing_zeroes(m):\n    low, high = 0, 5 * (m + 1)\n    result = []\n\n    while low <= high:\n        mid = (low + high) // 2\n        zeroes = count_trailing_zeroes(mid)\n        \n        if zeroes < m:\n            low = mid + 1\n        elif zeroes > m:\n            high = mid - 1\n        else:\n            result = [i for i in range(mid - mid % 5, mid - mid % 5 + 5) if count_trailing_zeroes(i) == m]\n            break\n\n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    m = int(input().strip())\n    \n    result = find_numbers_with_m_trailing_zeroes(m)\n    print(len(result))\n    if result:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import heapq\nfrom collections import defaultdict\n\ndef dijkstra(graph, start, n):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for weight, v in graph[u]:\n            max_weight = max(current_dist, weight)\n            if max_weight < dist[v]:\n                dist[v] = max_weight\n                heapq.heappush(pq, (max_weight, v))\n    return dist\n\ndef solve(n, m, k, special_vertices, edges):\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((w, v))\n        graph[v].append((w, u))\n    \n    max_distances = [0] * k\n    for i, sv in enumerate(special_vertices):\n        dist = dijkstra(graph, sv, n)\n        max_dist = 0\n        for j, sv2 in enumerate(special_vertices):\n            if i != j:\n                max_dist = max(max_dist, dist[sv2])\n        max_distances[i] = max_dist\n    \n    print(\" \".join(map(str, max_distances)))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\nspecial_vertices = list(map(int, data[3:3+k]))\nedges = []\nindex = 3 + k\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index+1])\n    w = int(data[index+2])\n    edges.append((u, v, w))\n    index += 3\n\nsolve(n, m, k, special_vertices, edges)"}
{"solution": "def find_initial_position(n, x):\n    # We will reverse the moves to find the initial position\n    for i in range(n, 0, -1):\n        if i % 2 == 1:\n            # Odd move: swap left (0) and middle (1)\n            if x == 0:\n                x = 1\n            elif x == 1:\n                x = 0\n        else:\n            # Even move: swap middle (1) and right (2)\n            if x == 1:\n                x = 2\n            elif x == 2:\n                x = 1\n    return x\n\n# Read input\nn = int(input())\nx = int(input())\n\n# Find and print the initial position\nprint(find_initial_position(n, x))"}
{"solution": "def is_square(rectangles):\n    min_x = min(rect[0] for rect in rectangles)\n    max_x = max(rect[2] for rect in rectangles)\n    min_y = min(rect[1] for rect in rectangles)\n    max_y = max(rect[3] for rect in rectangles)\n    \n    width = max_x - min_x\n    height = max_y - min_y\n    \n    if width != height:\n        return \"NO\"\n    \n    area = width * height\n    total_area = sum((rect[2] - rect[0]) * (rect[3] - rect[1]) for rect in rectangles)\n    \n    if area != total_area:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn = int(input().strip())\nrectangles = [tuple(map(int, input().strip().split())) for _ in range(n)]\n\n# Determine if the rectangles form a square\nresult = is_square(rectangles)\nprint(result)"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef count_really_big_numbers(n, s):\n    count = 0\n    for x in range(s, n + 1):\n        if x - sum_of_digits(x) >= s:\n            count += 1\n    return count\n\n# Read input\nn, s = map(int, input().split())\n\n# Calculate and print the result\nprint(count_really_big_numbers(n, s))"}
{"solution": "def can_be_covered_by_two_lines(points):\n    def collinear(p1, p2, p3):\n        return (p2[1] - p1[1]) * (p3[0] - p1[0]) == (p3[1] - p1[1]) * (p2[0] - p1[0])\n\n    n = len(points)\n    if n <= 2:\n        return True\n\n    for i in range(3):\n        for j in range(i + 1, 3):\n            line1 = []\n            line2 = []\n            for k in range(n):\n                if collinear(points[i], points[j], points[k]):\n                    line1.append(points[k])\n                else:\n                    line2.append(points[k])\n            if len(line2) <= 2:\n                return True\n            for l in range(1, len(line2)):\n                if not collinear(line2[0], line2[1], line2[l]):\n                    break\n            else:\n                return True\n    return False\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\nif can_be_covered_by_two_lines(points):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(a, b, k, t):\n    max_score = 2 * k * t + max(a, b)\n    dp = [[0] * (max_score + 1) for _ in range(2)]\n    dp[0][a] = 1\n\n    for turn in range(1, t + 1):\n        current = turn % 2\n        previous = 1 - current\n        prefix_sum = [0] * (max_score + 2)\n        \n        for i in range(max_score + 1):\n            prefix_sum[i + 1] = (prefix_sum[i] + dp[previous][i]) % MOD\n        \n        for i in range(max_score + 1):\n            left = max(0, i - k)\n            right = min(max_score, i + k)\n            dp[current][i] = (prefix_sum[right + 1] - prefix_sum[left] + MOD) % MOD\n\n    result = 0\n    for i in range(max_score + 1):\n        for j in range(i):\n            result = (result + dp[t % 2][i] * dp[t % 2][j]) % MOD\n\n    print(result)\n\n# Example usage\na, b, k, t = map(int, input().split())\nsolve(a, b, k, t)"}
{"solution": "def find_minimum_marks(n, l, x, y, marks):\n    marks_set = set(marks)\n    can_measure_x = False\n    can_measure_y = False\n\n    for mark in marks:\n        if (mark + x) in marks_set or (mark - x) in marks_set:\n            can_measure_x = True\n        if (mark + y) in marks_set or (mark - y) in marks_set:\n            can_measure_y = True\n\n    if can_measure_x and can_measure_y:\n        return 0, []\n\n    if can_measure_x:\n        for mark in marks:\n            if (mark + y) <= l and (mark + y) not in marks_set:\n                return 1, [mark + y]\n            if (mark - y) >= 0 and (mark - y) not in marks_set:\n                return 1, [mark - y]\n        return 1, [y]\n\n    if can_measure_y:\n        for mark in marks:\n            if (mark + x) <= l and (mark + x) not in marks_set:\n                return 1, [mark + x]\n            if (mark - x) >= 0 and (mark - x) not in marks_set:\n                return 1, [mark - x]\n        return 1, [x]\n\n    for mark in marks:\n        if (mark + x) <= l and (mark + x + y) <= l and (mark + x) not in marks_set and (mark + x + y) in marks_set:\n            return 1, [mark + x]\n        if (mark - x) >= 0 and (mark - x + y) <= l and (mark - x) not in marks_set and (mark - x + y) in marks_set:\n            return 1, [mark - x]\n        if (mark + y) <= l and (mark + y + x) <= l and (mark + y) not in marks_set and (mark + y + x) in marks_set:\n            return 1, [mark + y]\n        if (mark - y) >= 0 and (mark - y + x) <= l and (mark - y) not in marks_set and (mark - y + x) in marks_set:\n            return 1, [mark - y]\n\n    return 2, [x, y]\n\n# Read input\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Find the minimum number of marks to add\nv, new_marks = find_minimum_marks(n, l, x, y, marks)\n\n# Print the result\nprint(v)\nif v > 0:\n    print(\" \".join(map(str, new_marks)))"}
{"solution": "import math\nimport sys\ninput = sys.stdin.read\n\ndef max_cake_volume(n, cakes):\n    # Calculate the volume of each cake\n    volumes = [(math.pi * r * r * h, i) for i, (r, h) in enumerate(cakes)]\n    # Sort cakes by volume\n    volumes.sort()\n    \n    # Initialize dp array to store the maximum volume ending at each cake\n    dp = [0] * n\n    \n    for i in range(n):\n        dp[i] = volumes[i][0]  # Base case: the volume of the cake itself\n        for j in range(i):\n            if volumes[j][0] < volumes[i][0]:\n                dp[i] = max(dp[i], dp[j] + volumes[i][0])\n    \n    # The answer is the maximum value in dp array\n    return max(dp)\n\ndef main():\n    data = input().split()\n    n = int(data[0])\n    cakes = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n)]\n    result = max_cake_volume(n, cakes)\n    print(f\"{result:.9f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_good_slices(n, k, heights):\n    heights.sort(reverse=True)\n    slices = 0\n    current_height = heights[0]\n    total_removed = 0\n\n    for i in range(1, n):\n        if heights[i] < current_height:\n            cost = (current_height - heights[i]) * i\n            if total_removed + cost > k:\n                slices += 1\n                total_removed = 0\n            total_removed += cost\n            current_height = heights[i]\n\n    if total_removed > 0:\n        slices += 1\n\n    return slices\n\n# Read input\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_good_slices(n, k, heights))"}
{"solution": "def max_score(n, a):\n    # Calculate prefix sums\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n    \n    max_score = float('-inf')\n    \n    # Iterate over all possible segments [l, r]\n    for l in range(n):\n        max_in_segment = float('-inf')\n        for r in range(l, n):\n            # Update the maximum value in the current segment\n            max_in_segment = max(max_in_segment, a[r])\n            # Calculate the sum of the current segment\n            segment_sum = prefix_sum[r + 1] - prefix_sum[l]\n            # Calculate the score after Bob removes the max value\n            score = segment_sum - max_in_segment\n            # Update the maximum score\n            max_score = max(max_score, score)\n    \n    return max_score\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Print the output\nprint(max_score(n, a))"}
{"solution": "def can_cover_all_seconds(k1, k2, k3):\n    # Function to find the greatest common divisor\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    # Function to find the least common multiple\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    # Calculate the least common multiple of the three intervals\n    lcm12 = lcm(k1, k2)\n    lcm123 = lcm(lcm12, k3)\n\n    # If the least common multiple of the three intervals is less than or equal to the sum of the intervals,\n    # then it is possible to cover all seconds\n    if lcm123 <= k1 + k2 + k3:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nk1, k2, k3 = map(int, input().split())\n\n# Print the result\nprint(can_cover_all_seconds(k1, k2, k3))"}
{"solution": "def min_operations_to_delete_string(n, s):\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(n)]\n    \n    # Base case: single character substrings\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the DP table for substrings of length greater than 1\n    for length in range(2, n + 1):  # length of the substring\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j-1]\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n    \n    # The result for the entire string\n    return dp[0][n-1]\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Print the result\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "def max_pairs(n, boys, m, girls):\n    boys.sort()\n    girls.sort()\n    \n    i, j = 0, 0\n    pairs = 0\n    \n    while i < n and j < m:\n        if abs(boys[i] - girls[j]) <= 1:\n            pairs += 1\n            i += 1\n            j += 1\n        elif boys[i] < girls[j]:\n            i += 1\n        else:\n            j += 1\n    \n    return pairs\n\n# Read input\nn = int(input())\nboys = list(map(int, input().split()))\nm = int(input())\ngirls = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_pairs(n, boys, m, girls))"}
{"solution": "def determine_winner(skills):\n    # Extract skills for each player\n    a1, b1 = skills[0]\n    a2, b2 = skills[1]\n    a3, b3 = skills[2]\n    a4, b4 = skills[3]\n\n    # First team configurations\n    team1_configs = [(a1, b2), (a2, b1)]\n\n    # Second team configurations\n    team2_configs = [(a3, b4), (a4, b3)]\n\n    # Check if team 1 can guarantee a win\n    team1_wins = False\n    for d1, a1 in team1_configs:\n        team1_guaranteed = True\n        for d2, a2 in team2_configs:\n            if not (d1 > a2 and a1 > d2):\n                team1_guaranteed = False\n                break\n        if team1_guaranteed:\n            team1_wins = True\n            break\n\n    # Check if team 2 can guarantee a win\n    team2_wins = False\n    for d2, a2 in team2_configs:\n        team2_guaranteed = True\n        for d1, a1 in team1_configs:\n            if not (d2 > a1 and a2 > d1):\n                team2_guaranteed = False\n                break\n        if team2_guaranteed:\n            team2_wins = True\n            break\n\n    if team1_wins:\n        print(\"Team 1\")\n    elif team2_wins:\n        print(\"Team 2\")\n    else:\n        print(\"Draw\")\n\n# Read input\nskills = [tuple(map(int, input().split())) for _ in range(4)]\n\n# Determine the winner\ndetermine_winner(skills)"}
{"solution": "import sys\nimport math\nfrom scipy.optimize import minimize\n\ndef time_to_grill(XY, meats, K):\n    X, Y = XY\n    times = []\n    for x, y, c in meats:\n        time = c * math.sqrt((X - x) ** 2 + (Y - y) ** 2)\n        times.append(time)\n    times.sort()\n    return times[K-1]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    meats = []\n    index = 2\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        c = int(data[index + 2])\n        meats.append((x, y, c))\n        index += 3\n    \n    initial_guess = [0, 0]\n    result = minimize(time_to_grill, initial_guess, args=(meats, K), method='Nelder-Mead')\n    \n    print(f\"{result.fun:.6f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def determine_winner(n, ticket):\n    half = n // 2\n    left_sum = 0\n    right_sum = 0\n    left_question_marks = 0\n    right_question_marks = 0\n\n    for i in range(half):\n        if ticket[i] == '?':\n            left_question_marks += 1\n        else:\n            left_sum += int(ticket[i])\n\n    for i in range(half, n):\n        if ticket[i] == '?':\n            right_question_marks += 1\n        else:\n            right_sum += int(ticket[i])\n\n    # Calculate the difference in sums and question marks\n    sum_diff = left_sum - right_sum\n    question_diff = left_question_marks - right_question_marks\n\n    # Each question mark can be any digit from 0 to 9\n    # The maximum difference a question mark can make is 9\n    max_diff = (question_diff // 2) * 9\n\n    if abs(sum_diff) > max_diff:\n        print(\"Monocarp\")\n    else:\n        print(\"Bicarp\")\n\n# Read input\nn = int(input().strip())\nticket = input().strip()\n\n# Determine the winner\ndetermine_winner(n, ticket)"}
{"solution": "def find_bus_route(n, t, bus_routes):\n    earliest_time = float('inf')\n    chosen_route = -1\n    \n    for i in range(n):\n        s_i, d_i = bus_routes[i]\n        \n        if s_i >= t:\n            next_bus_time = s_i\n        else:\n            # Calculate the next bus time after t\n            if (t - s_i) % d_i == 0:\n                next_bus_time = t\n            else:\n                next_bus_time = s_i + ((t - s_i) // d_i + 1) * d_i\n        \n        if next_bus_time < earliest_time:\n            earliest_time = next_bus_time\n            chosen_route = i + 1\n    \n    return chosen_route\n\n# Input reading\nn, t = map(int, input().split())\nbus_routes = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Find and print the bus route Serval will use\nprint(find_bus_route(n, t, bus_routes))"}
{"solution": "def count_ones_in_binary(x):\n    return bin(x).count('1')\n\ndef find_n(m, k):\n    for n in range(1, 10**18 + 1):\n        count = 0\n        for i in range(n + 1, 2 * n + 1):\n            if count_ones_in_binary(i) == k:\n                count += 1\n            if count > m:\n                break\n        if count == m:\n            return n\n    return -1\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    m = int(data[0])\n    k = int(data[1])\n    result = find_n(m, k)\n    print(result)"}
{"solution": "def is_good_level(n, level):\n    platforms = [i for i in range(n) if level[i] == '*']\n    \n    for i in range(len(platforms)):\n        for j in range(i + 1, len(platforms)):\n            d = platforms[j] - platforms[i]\n            count = 1\n            current = platforms[j]\n            while current + d < n and level[current + d] == '*':\n                current += d\n                count += 1\n                if count == 4:\n                    return \"yes\"\n    return \"no\"\n\n# Read input\nn = int(input())\nlevel = input().strip()\n\n# Determine if the level is good\nresult = is_good_level(n, level)\nprint(result)"}
{"solution": "def find_missing_value(n, grid):\n    # Find the position of the missing cell\n    missing_row, missing_col = -1, -1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                missing_row, missing_col = i, j\n                break\n        if missing_row != -1:\n            break\n\n    # Calculate the target sum using a row that doesn't contain the missing cell\n    target_sum = -1\n    for i in range(n):\n        if i != missing_row:\n            target_sum = sum(grid[i])\n            break\n\n    # Calculate the sum of the row and column containing the missing cell\n    row_sum = sum(grid[missing_row])\n    col_sum = sum(grid[i][missing_col] for i in range(n))\n\n    # Calculate the required value to make the row and column sums equal to the target sum\n    missing_value = target_sum - row_sum\n\n    # Check if the calculated value is valid\n    if missing_value <= 0 or missing_value != target_sum - col_sum:\n        return -1\n\n    # Temporarily fill in the missing value\n    grid[missing_row][missing_col] = missing_value\n\n    # Check all rows, columns, and diagonals\n    for i in range(n):\n        if sum(grid[i]) != target_sum or sum(grid[j][i] for j in range(n)) != target_sum:\n            return -1\n\n    if sum(grid[i][i] for i in range(n)) != target_sum or sum(grid[i][n - i - 1] for i in range(n)) != target_sum:\n        return -1\n\n    return missing_value\n\n# Read input\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\n# Find and print the missing value\nprint(find_missing_value(n, grid))"}
{"solution": "import math\n\n# Read input values\nn = int(input())\nm = int(input())\na = [int(input()) for _ in range(n)]\n\n# Calculate the maximum possible k\nmax_k = max(a) + m\n\n# Calculate the total number of people after adding m people\ntotal_people = sum(a) + m\n\n# Calculate the minimum possible k\nmin_k = math.ceil(total_people / n)\n\n# Print the results\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, m):\n    # Initialize dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(0, m + 1):\n            dp[i][j] = dp[i - 1][j] * (j + 1) % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * (m - j + 1) % MOD) % MOD\n\n    return dp[n][m]\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(count_ways(n, m))"}
{"solution": "def main():\n    import sys\n    input = sys.stdin.read\n    from itertools import combinations\n    from collections import defaultdict\n\n    data = input().split()\n    idx = 0\n\n    n = int(data[idx])\n    m = int(data[idx + 1])\n    idx += 2\n\n    friends = []\n    for _ in range(n):\n        f_i = int(data[idx])\n        ingredients = set(map(int, data[idx + 1: idx + 1 + f_i]))\n        friends.append(ingredients)\n        idx += 1 + f_i\n\n    pizzas = []\n    for j in range(m):\n        c_j = int(data[idx])\n        r_j = int(data[idx + 1])\n        ingredients = set(map(int, data[idx + 2: idx + 2 + r_j]))\n        pizzas.append((c_j, ingredients, j + 1))\n        idx += 2 + r_j\n\n    max_friends_pleased = 0\n    min_cost = float('inf')\n    best_pair = None\n\n    for (c1, ing1, idx1), (c2, ing2, idx2) in combinations(pizzas, 2):\n        combined_ingredients = ing1 | ing2\n        friends_pleased = sum(1 for friend in friends if friend <= combined_ingredients)\n        total_cost = c1 + c2\n\n        if (friends_pleased > max_friends_pleased) or (friends_pleased == max_friends_pleased and total_cost < min_cost):\n            max_friends_pleased = friends_pleased\n            min_cost = total_cost\n            best_pair = (idx1, idx2)\n\n    print(best_pair[0], best_pair[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_min_max(m, s):\n    if s == 0:\n        if m == 1:\n            print(\"0 0\")\n        else:\n            print(\"-1 -1\")\n        return\n\n    if s > 9 * m:\n        print(\"-1 -1\")\n        return\n\n    # Find the smallest number\n    min_num = [0] * m\n    sum_digits = s\n\n    for i in range(m - 1, -1, -1):\n        if sum_digits > 9:\n            min_num[i] = 9\n            sum_digits -= 9\n        else:\n            min_num[i] = sum_digits\n            sum_digits = 0\n\n    if min_num[0] == 0:\n        for i in range(1, m):\n            if min_num[i] > 0:\n                min_num[i] -= 1\n                min_num[0] = 1\n                break\n\n    # Find the largest number\n    max_num = [0] * m\n    sum_digits = s\n\n    for i in range(m):\n        if sum_digits > 9:\n            max_num[i] = 9\n            sum_digits -= 9\n        else:\n            max_num[i] = sum_digits\n            sum_digits = 0\n\n    min_num_str = ''.join(map(str, min_num))\n    max_num_str = ''.join(map(str, max_num))\n\n    print(f\"{min_num_str} {max_num_str}\")\n\n# Read input\nm, s = map(int, input().split())\nfind_min_max(m, s)"}
{"solution": "MOD = 998244353\n\ndef count_unique_digits(n):\n    return len(set(str(n)))\n\ndef sum_of_numbers_with_k_digits(l, r, k):\n    total_sum = 0\n    for num in range(l, r + 1):\n        if count_unique_digits(num) <= k:\n            total_sum = (total_sum + num) % MOD\n    return total_sum\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    l, r, k = map(int, input().strip().split())\n    result = sum_of_numbers_with_k_digits(l, r, k)\n    print(result)"}
{"solution": "def can_distribute_pencils(n, k, d, saturations):\n    saturations.sort()\n    \n    # dp[i] will be True if we can partition the first i pencils\n    dp = [False] * (n + 1)\n    dp[0] = True\n    \n    # min_index[i] will store the minimum index j such that dp[j] is True and\n    # saturations[i] - saturations[j] <= d\n    min_index = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        if i >= k and dp[i - k]:\n            min_index[i] = i - k\n        else:\n            min_index[i] = min_index[i - 1]\n        \n        if min_index[i] < i and saturations[i - 1] - saturations[min_index[i]] <= d:\n            dp[i] = True\n    \n    return \"YES\" if dp[n] else \"NO\"\n\n# Read input\nn, k, d = map(int, input().split())\nsaturations = list(map(int, input().split()))\n\n# Determine if it's possible to distribute the pencils\nresult = can_distribute_pencils(n, k, d, saturations)\nprint(result)"}
{"solution": "def count_dead_bulbs(s):\n    n = len(s)\n    color_positions = {'R': -1, 'B': -1, 'Y': -1, 'G': -1}\n    dead_counts = {'R': 0, 'B': 0, 'Y': 0, 'G': 0}\n\n    # Determine the positions of each color in the first four bulbs\n    for i in range(4):\n        if s[i] in color_positions:\n            color_positions[s[i]] = i\n\n    # Iterate through the garland and count dead bulbs\n    for i in range(n):\n        if s[i] == '!':\n            # Determine the color of the dead bulb based on its position\n            pos = i % 4\n            for color, position in color_positions.items():\n                if position == pos:\n                    dead_counts[color] += 1\n                    break\n\n    print(dead_counts['R'], dead_counts['B'], dead_counts['Y'], dead_counts['G'])\n\n# Read input\ns = input().strip()\ncount_dead_bulbs(s)"}
{"solution": "import sys\nimport heapq\n\ndef dijkstra(graph, start, N):\n    distances = [float('inf')] * (N + 1)\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances\n\ndef calculate_expected_passages(N, M, passages):\n    graph = [[] for _ in range(N + 1)]\n    for s, t in passages:\n        graph[s].append((t, 1))\n    \n    expected_passages = dijkstra(graph, 1, N)\n    \n    min_expected_passages = expected_passages[N]\n    \n    for s, t in passages:\n        if s == 1:\n            graph[s].remove((t, 1))\n            new_expected_passages = dijkstra(graph, 1, N)\n            min_expected_passages = min(min_expected_passages, new_expected_passages[N])\n            graph[s].append((t, 1))\n    \n    return min_expected_passages\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    passages = []\n    index = 2\n    for _ in range(M):\n        s = int(data[index])\n        t = int(data[index + 1])\n        passages.append((s, t))\n        index += 2\n    \n    result = calculate_expected_passages(N, M, passages)\n    print(f\"{result:.10f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def round_to_nearest_10(n):\n    # If n already ends with 0, return n\n    if n % 10 == 0:\n        return n\n    \n    # Calculate the nearest lower and higher multiples of 10\n    lower_multiple = (n // 10) * 10\n    higher_multiple = lower_multiple + 10\n    \n    # Determine which multiple is closer\n    if n - lower_multiple < higher_multiple - n:\n        return lower_multiple\n    else:\n        return higher_multiple\n\n# Read input\nn = int(input().strip())\n\n# Print the result of rounding n\nprint(round_to_nearest_10(n))"}
{"solution": "def find_swaps(s, t):\n    if len(s) != len(t):\n        print(-1)\n        return\n    \n    mismatches = {}\n    \n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if s[i] in mismatches and mismatches[s[i]] != t[i]:\n                print(-1)\n                return\n            if t[i] in mismatches and mismatches[t[i]] != s[i]:\n                print(-1)\n                return\n            mismatches[s[i]] = t[i]\n            mismatches[t[i]] = s[i]\n    \n    visited = set()\n    swaps = []\n    \n    for key in mismatches:\n        if key not in visited:\n            cycle = []\n            current = key\n            while current not in visited:\n                visited.add(current)\n                cycle.append(current)\n                current = mismatches[current]\n            if len(cycle) != 2:\n                print(-1)\n                return\n            swaps.append((cycle[0], cycle[1]))\n    \n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0], swap[1])\n\n# Example usage:\ns = input().strip()\nt = input().strip()\nfind_swaps(s, t)"}
{"solution": "def earliest_login(first_name, last_name):\n    earliest = first_name[0] + last_name[0]\n    for i in range(1, len(first_name) + 1):\n        for j in range(1, len(last_name) + 1):\n            login = first_name[:i] + last_name[:j]\n            if login < earliest:\n                earliest = login\n    return earliest\n\n# Read input\nfirst_name, last_name = input().split()\n\n# Get the alphabetically earliest login\nresult = earliest_login(first_name, last_name)\n\n# Print the result\nprint(result)"}
{"solution": "def draw_brackets(n, sequence):\n    # Determine the maximum depth of the nested brackets\n    max_depth = 0\n    current_depth = 0\n    for char in sequence:\n        if char == '[':\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        else:\n            current_depth -= 1\n\n    # Initialize the drawing grid\n    height = 2 * max_depth + 1\n    width = n + (n // 2) * 2\n    grid = [[' ' for _ in range(width)] for _ in range(height)]\n\n    # Function to draw a single bracket pair\n    def draw_bracket(x, y, depth):\n        grid[y][x] = '+'\n        grid[y][x + 1] = '-'\n        grid[y][x + 2] = '-'\n        grid[y][x + 3] = '+'\n        for i in range(1, 2 * depth):\n            grid[y + i][x] = '|'\n            grid[y + i][x + 3] = '|'\n        grid[y + 2 * depth][x] = '+'\n        grid[y + 2 * depth][x + 1] = '-'\n        grid[y + 2 * depth][x + 2] = '-'\n        grid[y + 2 * depth][x + 3] = '+'\n\n    # Draw the brackets\n    x = 0\n    y = 0\n    stack = []\n    for char in sequence:\n        if char == '[':\n            stack.append((x, y, current_depth))\n            current_depth += 1\n            x += 2\n        else:\n            current_depth -= 1\n            x, y, depth = stack.pop()\n            draw_bracket(x, y, depth)\n            x += 4\n            if stack:\n                x += 1\n\n    # Print the grid\n    for row in grid:\n        print(''.join(row))\n\n# Read input\nn = int(input().strip())\nsequence = input().strip()\n\n# Draw the brackets\ndraw_brackets(n, sequence)"}
{"solution": "def normalize_golden_number(golden_number):\n    # Convert the golden number string to a list of integers for easier manipulation\n    golden_number = list(map(int, golden_number))\n    n = len(golden_number)\n    \n    # Normalize the number using the property q^2 = q + 1\n    for i in range(n - 1, 0, -1):\n        if golden_number[i] > 1:\n            golden_number[i] -= 2\n            golden_number[i - 1] += 1\n            if i - 2 >= 0:\n                golden_number[i - 2] += 1\n    \n    # Remove leading zeros\n    while len(golden_number) > 1 and golden_number[0] == 0:\n        golden_number.pop(0)\n    \n    return golden_number\n\ndef compare_golden_numbers(num1, num2):\n    # Normalize both numbers\n    norm_num1 = normalize_golden_number(num1)\n    norm_num2 = normalize_golden_number(num2)\n    \n    # Compare lengths first\n    if len(norm_num1) > len(norm_num2):\n        return \">\"\n    elif len(norm_num1) < len(norm_num2):\n        return \"<\"\n    \n    # If lengths are equal, compare digit by digit\n    for digit1, digit2 in zip(norm_num1, norm_num2):\n        if digit1 > digit2:\n            return \">\"\n        elif digit1 < digit2:\n            return \"<\"\n    \n    # If all digits are equal\n    return \"=\"\n\n# Read input\nnum1 = input().strip()\nnum2 = input().strip()\n\n# Compare the numbers and print the result\nresult = compare_golden_numbers(num1, num2)\nprint(result)"}
{"solution": "# Define the mapping of colors to gem names\ngem_map = {\n    \"purple\": \"Power\",\n    \"green\": \"Time\",\n    \"blue\": \"Space\",\n    \"orange\": \"Soul\",\n    \"red\": \"Reality\",\n    \"yellow\": \"Mind\"\n}\n\n# Read the number of gems in the gauntlet\nn = int(input().strip())\n\n# Read the colors of the gems in the gauntlet\npresent_gems = set()\nfor _ in range(n):\n    color = input().strip()\n    present_gems.add(color)\n\n# Determine the absent gems\nabsent_gems = []\nfor color, name in gem_map.items():\n    if color not in present_gems:\n        absent_gems.append(name)\n\n# Output the number of absent gems\nprint(len(absent_gems))\n\n# Output the names of the absent gems\nfor gem in absent_gems:\n    print(gem)"}
{"solution": "def find_meeting_round(n, a, b):\n    round_num = 1\n    while n > 1:\n        # Determine the next round positions for a and b\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        \n        # Check if they meet in this round\n        if a == b:\n            return round_num\n        \n        # Move to the next round\n        n //= 2\n        round_num += 1\n    \n    return \"Final!\"\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Determine the round in which teams a and b will meet\nresult = find_meeting_round(n, a, b)\n\n# Print the result\nprint(result)"}
{"solution": "def min_changes_to_visit_all_positions(n, p, b):\n    # Function to find the minimum number of changes required\n    def find_cycles(p):\n        visited = [False] * n\n        cycles = []\n        for i in range(n):\n            if not visited[i]:\n                cycle = []\n                x = i\n                while not visited[x]:\n                    visited[x] = True\n                    cycle.append(x)\n                    x = p[x] - 1\n                cycles.append(cycle)\n        return cycles\n\n    cycles = find_cycles(p)\n    changes = 0\n\n    for cycle in cycles:\n        count_ones = sum(b[i] for i in cycle)\n        count_zeros = len(cycle) - count_ones\n        changes += min(count_ones, count_zeros)\n\n    return changes\n\n# Input reading\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\np = list(map(int, data[1:n+1]))\nb = list(map(int, data[n+1:2*n+1]))\n\n# Calculate and print the result\nprint(min_changes_to_visit_all_positions(n, p, b))"}
{"solution": "def max_path_length(v1, v2, t, d):\n    speeds = [v1]\n    \n    for i in range(1, t - 1):\n        next_speed = min(speeds[-1] + d, v2 + (t - 1 - i) * d)\n        speeds.append(next_speed)\n    \n    speeds.append(v2)\n    \n    return sum(speeds)\n\n# Read input\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Calculate and print the maximum path length\nprint(max_path_length(v1, v2, t, d))"}
{"solution": "from itertools import permutations\n\ndef can_cross(perm, weights, lengths, capacities):\n    N = len(weights)\n    M = len(lengths)\n    \n    for i in range(M):\n        l_i = lengths[i]\n        v_i = capacities[i]\n        \n        for j in range(N):\n            total_weight = 0\n            for k in range(j + 1, N):\n                total_weight += weights[perm[k]]\n                if total_weight > v_i:\n                    break\n                if k - j > l_i:\n                    break\n            if total_weight > v_i:\n                return False\n    return True\n\ndef min_distance(N, M, weights, lengths, capacities):\n    min_dist = float('inf')\n    found = False\n    \n    for perm in permutations(range(N)):\n        if can_cross(perm, weights, lengths, capacities):\n            found = True\n            dist = sum(lengths)\n            min_dist = min(min_dist, dist)\n    \n    if not found:\n        return -1\n    return min_dist\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    weights = list(map(int, data[2:N+2]))\n    lengths = []\n    capacities = []\n    \n    index = N + 2\n    for _ in range(M):\n        l_i = int(data[index])\n        v_i = int(data[index + 1])\n        lengths.append(l_i)\n        capacities.append(v_i)\n        index += 2\n    \n    result = min_distance(N, M, weights, lengths, capacities)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def last_digit_of_reincarnations(a, b):\n    if a == 0:\n        print(0)\n        return\n    \n    if b >= a:\n        print(0)\n        return\n    \n    # Calculate the last digit of b! / a!\n    result = 1\n    for i in range(a + 1, b + 1):\n        result *= i\n        result %= 10\n    \n    print(result)\n\n# Read input\na, b = map(int, input().split())\n\n# Calculate and print the result\nlast_digit_of_reincarnations(a, b)"}
{"solution": "from collections import deque\n\ndef minimal_jumps(n, d, s):\n    # Initialize the queue with the starting point (index 0) and 0 jumps\n    queue = deque([(0, 0)])\n    visited = [False] * n\n    visited[0] = True\n\n    while queue:\n        current, jumps = queue.popleft()\n\n        # Try all possible jumps from 1 to d\n        for i in range(1, d + 1):\n            next_pos = current + i\n            if next_pos >= n:\n                break\n            if s[next_pos] == '1' and not visited[next_pos]:\n                if next_pos == n - 1:\n                    return jumps + 1\n                queue.append((next_pos, jumps + 1))\n                visited[next_pos] = True\n\n    return -1\n\n# Read input\nn, d = map(int, input().split())\ns = input().strip()\n\n# Get the result and print it\nresult = minimal_jumps(n, d, s)\nprint(result)"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_counterexample(n):\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\n# Read input\nn = int(input().strip())\n\n# Find and print the counterexample\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all_coins(n):\n    house_cost = 1234567\n    car_cost = 123456\n    computer_cost = 1234\n\n    # Iterate over possible number of houses\n    for a in range(n // house_cost + 1):\n        remaining_after_houses = n - a * house_cost\n        # Iterate over possible number of cars\n        for b in range(remaining_after_houses // car_cost + 1):\n            remaining_after_cars = remaining_after_houses - b * car_cost\n            # Check if the remaining can be exactly spent on computers\n            if remaining_after_cars % computer_cost == 0:\n                return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input().strip())\n\n# Print the result\nprint(can_spend_all_coins(n))"}
{"solution": "def check_intersection(n, x1, x2, lines):\n    # Calculate the y-values of each line at x1 and x2\n    y_values_at_x1 = [(k * x1 + b, i) for i, (k, b) in enumerate(lines)]\n    y_values_at_x2 = [(k * x2 + b, i) for i, (k, b) in enumerate(lines)]\n    \n    # Sort the y-values at x1 and x2\n    y_values_at_x1.sort()\n    y_values_at_x2.sort()\n    \n    # Check if the order of lines changes between x1 and x2\n    for i in range(n):\n        if y_values_at_x1[i][1] != y_values_at_x2[i][1]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx1 = int(data[1])\nx2 = int(data[2])\nlines = [(int(data[3 + 2 * i]), int(data[4 + 2 * i])) for i in range(n)]\n\n# Check for intersection\nresult = check_intersection(n, x1, x2, lines)\nprint(result)"}
{"solution": "def count_different_weights(n):\n    # Initialize a set to store unique weights\n    weights = set()\n    \n    # Iterate over possible first elements of the split\n    for i in range(1, n + 1):\n        # Calculate the weight for the current first element\n        weight = n // i\n        # Add the weight to the set\n        weights.add(weight)\n    \n    # The number of different weights is the size of the set\n    return len(weights)\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the number of different weights\nprint(count_different_weights(n))"}
{"solution": "def find_good_apartments(n, k):\n    if k == 0:\n        min_good = 0\n        max_good = 0\n    else:\n        min_good = 1\n        max_good = min(n - k, 2 * k)\n    \n    return min_good, max_good\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate the minimum and maximum number of good apartments\nmin_good, max_good = find_good_apartments(n, k)\n\n# Print the results\nprint(min_good, max_good)"}
{"solution": "import math\n\ndef max_games(n):\n    return math.floor(math.log2(n))\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the result\nprint(max_games(n))"}
{"solution": "def max_vk_occurrences(s):\n    # Initial count of \"VK\" in the original string\n    initial_count = s.count(\"VK\")\n    \n    max_count = initial_count\n    \n    # Try changing each character and see if it increases the count of \"VK\"\n    for i in range(len(s)):\n        if s[i] == 'V':\n            # Change 'V' to 'K' and count \"VK\"\n            new_s = s[:i] + 'K' + s[i+1:]\n        else:\n            # Change 'K' to 'V' and count \"VK\"\n            new_s = s[:i] + 'V' + s[i+1:]\n        \n        new_count = new_s.count(\"VK\")\n        if new_count > max_count:\n            max_count = new_count\n    \n    return max_count\n\n# Read input\ns = input().strip()\n\n# Compute and print the result\nprint(max_vk_occurrences(s))"}
{"solution": "import math\n\ndef min_segments(n):\n    a = int(math.sqrt(n))\n    b = (n + a - 1) // a  # This is equivalent to math.ceil(n / a)\n    return a + b + 2\n\n# Read input\nn = int(input().strip())\nprint(min_segments(n))"}
{"solution": "def years_to_surpass(a, b):\n    years = 0\n    while a <= b:\n        a *= 3\n        b *= 2\n        years += 1\n    return years\n\n# Read input\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(years_to_surpass(a, b))"}
{"solution": "def count_visited_nodes(h, n):\n    # Calculate the total number of nodes in the tree\n    total_nodes = (1 << (h + 1)) - 1\n    \n    # Calculate the path to the exit node in binary\n    path_to_exit = bin(n - 1)[2:].zfill(h)\n    \n    # Initialize the current node and visited nodes count\n    current_node = 1\n    visited_nodes = 0\n    visited = set()\n    skipped = 0\n    \n    # Infinite command string \"LRLRLRLRL...\"\n    commands = \"LR\" * (total_nodes // 2)\n    \n    for command in commands:\n        if current_node in visited:\n            skipped += 1\n            if skipped == 2:\n                current_node //= 2\n                skipped = 0\n            continue\n        \n        visited.add(current_node)\n        visited_nodes += 1\n        skipped = 0\n        \n        if current_node > (1 << h):\n            current_node //= 2\n            continue\n        \n        if command == 'L':\n            current_node = current_node * 2\n        else:\n            current_node = current_node * 2 + 1\n        \n        if current_node == (1 << h) + n - 1:\n            break\n    \n    return visited_nodes\n\n# Read input\nh, n = map(int, input().split())\n\n# Calculate and print the result\nprint(count_visited_nodes(h, n))"}
{"solution": "def count_squares(n, m):\n    total_squares = 0\n    for k in range(1, min(n, m) + 1):\n        total_squares += (n - k + 1) * (m - k + 1)\n    return total_squares\n\ndef find_tables_with_x_squares(x):\n    results = []\n    for n in range(1, int(x**0.5) + 2):\n        for m in range(1, int(x**0.5) + 2):\n            if count_squares(n, m) == x:\n                results.append((n, m))\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    x = int(input().strip())\n    \n    tables = find_tables_with_x_squares(x)\n    tables.sort()\n    \n    print(len(tables))\n    for n, m in tables:\n        print(n, m)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_leap_year(year):\n    if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n        return True\n    return False\n\ndef check_consecutive_months(n, days):\n    # Days in each month for non-leap and leap years\n    non_leap_year = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    leap_year = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    # Create a list of months for 2 consecutive years to handle wrap-around\n    months = non_leap_year + non_leap_year + leap_year + leap_year\n    \n    # Check if the sequence exists in the months list\n    for i in range(len(months) - n + 1):\n        if months[i:i+n] == days:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\ndays = list(map(int, input().split()))\n\n# Check and print the result\nprint(check_consecutive_months(n, days))"}
{"solution": "def find_fractions(n):\n    if n == 2:\n        print(\"NO\")\n        return\n\n    fractions = []\n    sum_fractions = 0\n    for b in range(2, n):\n        if n % b == 0:\n            a = 1\n            fractions.append((a, b))\n            sum_fractions += a / b\n            if sum_fractions >= 1 - 1 / n:\n                break\n\n    if sum_fractions == 1 - 1 / n:\n        print(\"YES\")\n        print(len(fractions))\n        for a, b in fractions:\n            print(a, b)\n    else:\n        print(\"NO\")\n\n# Read input\nn = int(input().strip())\nfind_fractions(n)"}
{"solution": "def min_unattractiveness(n, a, b, heights):\n    # Initialize DP table with infinity\n    dp = [[float('inf')] * (b + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    # Iterate over each board\n    for i in range(1, n + 1):\n        for green_area in range(b + 1):\n            red_area = sum(heights[:i]) - green_area\n            if red_area < 0 or red_area > a:\n                continue\n            if green_area >= heights[i - 1]:\n                dp[i][green_area] = min(dp[i][green_area], dp[i - 1][green_area - heights[i - 1]])\n            if red_area >= heights[i - 1]:\n                dp[i][green_area] = min(dp[i][green_area], dp[i - 1][green_area] + (heights[i - 1] if i > 1 and dp[i - 1][green_area] != float('inf') else 0))\n\n    # Find the minimum unattractiveness value\n    min_unattractiveness_value = min(dp[n])\n    return min_unattractiveness_value if min_unattractiveness_value != float('inf') else -1\n\n# Read input\nn = int(input())\na, b = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_unattractiveness(n, a, b, heights))"}
{"solution": "def find_triangle(n, m, k):\n    # Calculate the required area\n    required_area = n * m / k\n    \n    # Check if the required area is an integer\n    if required_area != int(required_area):\n        print(\"NO\")\n        return\n    \n    required_area = int(required_area)\n    \n    # Try to find the points\n    for x1 in range(n + 1):\n        for y1 in range(m + 1):\n            for x2 in range(n + 1):\n                for y2 in range(m + 1):\n                    if x1 == x2 and y1 == y2:\n                        continue\n                    for x3 in range(n + 1):\n                        for y3 in range(m + 1):\n                            if (x3 == x1 and y3 == y1) or (x3 == x2 and y3 == y2):\n                                continue\n                            # Calculate the area of the triangle\n                            area = abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2\n                            if area == required_area:\n                                print(\"YES\")\n                                print(x1, y1)\n                                print(x2, y2)\n                                print(x3, y3)\n                                return\n    \n    print(\"NO\")\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Find the triangle\nfind_triangle(n, m, k)"}
{"solution": "def sasha_wins(n, k):\n    # Calculate the total number of moves possible\n    total_moves = n // k\n    \n    # Sasha wins if the total number of moves is odd\n    if total_moves % 2 == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\n\n# Determine if Sasha wins and print the result\nprint(sasha_wins(n, k))"}
{"solution": "# Read input values\nn = int(input())\nexercises = list(map(int, input().split()))\n\n# Initialize counters for each muscle group\nchest = 0\nbiceps = 0\nback = 0\n\n# Iterate through the exercises and sum repetitions for each muscle group\nfor i in range(n):\n    if i % 3 == 0:\n        chest += exercises[i]\n    elif i % 3 == 1:\n        biceps += exercises[i]\n    else:\n        back += exercises[i]\n\n# Determine which muscle group got the most exercise\nif chest > biceps and chest > back:\n    print(\"chest\")\nelif biceps > chest and biceps > back:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "def min_redos_to_get_five(n, grades):\n    current_sum = sum(grades)\n    target_sum = n * 4.5\n    \n    if current_sum >= target_sum:\n        return 0\n    \n    grades.sort()\n    redos = 0\n    \n    for grade in grades:\n        if current_sum >= target_sum:\n            break\n        current_sum += (5 - grade)\n        redos += 1\n    \n    return redos\n\n# Input reading\nn = int(input())\ngrades = list(map(int, input().split()))\n\n# Output the result\nprint(min_redos_to_get_five(n, grades))"}
{"solution": "def find_shortest_array(u, v):\n    if u > v or (u % 2 != v % 2):\n        print(-1)\n        return\n    \n    if u == v:\n        if u == 0:\n            print(0)\n        else:\n            print(1)\n            print(u)\n        return\n    \n    x = (v - u) // 2\n    if (u & x) == 0:\n        print(2)\n        print(u + x, x)\n    else:\n        print(3)\n        print(u, (v - u) // 2, (v - u) // 2)\n\n# Read input\nu, v = map(int, input().split())\n\n# Find and print the shortest array\nfind_shortest_array(u, v)"}
{"solution": "def min_digits_of_1(n):\n    # Convert the number to a string to work with each digit\n    n_str = str(n)\n    # Initialize the count of '1's\n    count_ones = 0\n    \n    # Iterate through each digit in the number\n    for digit in n_str:\n        # Convert the digit to an integer\n        digit_int = int(digit)\n        # Add the digit to the count of '1's\n        count_ones += digit_int\n    \n    return count_ones\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the minimal number of digits '1'\nprint(min_digits_of_1(n))"}
{"solution": "def can_reach_treasure(x1, y1, x2, y2, x, y):\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    \n    if dx % x == 0 and dy % y == 0:\n        if (dx // x) % 2 == (dy // y) % 2:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\n# Determine if the treasure can be reached\nresult = can_reach_treasure(x1, y1, x2, y2, x, y)\nprint(result)"}
{"solution": "from itertools import permutations\n\ndef count_valid_bus_numbers(n):\n    # Convert the number to a string to extract digits\n    digits = list(str(n))\n    \n    # Generate all unique permutations of the digits\n    all_permutations = set(permutations(digits))\n    \n    # Filter out permutations that start with '0'\n    valid_permutations = set()\n    for perm in all_permutations:\n        if perm[0] != '0':\n            valid_permutations.add(perm)\n    \n    # Return the count of valid permutations\n    return len(valid_permutations)\n\n# Read input\nn = int(input().strip())\n\n# Get the count of valid bus numbers\nresult = count_valid_bus_numbers(n)\n\n# Print the result\nprint(result)"}
{"solution": "# Read input values\na = int(input().strip())  # number of ties\nb = int(input().strip())  # number of scarves\nc = int(input().strip())  # number of vests\nd = int(input().strip())  # number of jackets\ne = int(input().strip())  # cost of one suit of the first type\nf = int(input().strip())  # cost of one suit of the second type\n\n# Calculate the maximum possible cost\nmax_cost = 0\n\n# Case 1: Prioritize making suits of the first type\nsuits_first_type = min(a, d)\nremaining_jackets = d - suits_first_type\nsuits_second_type = min(b, c, remaining_jackets)\ncost_case1 = suits_first_type * e + suits_second_type * f\n\n# Case 2: Prioritize making suits of the second type\nsuits_second_type = min(b, c, d)\nremaining_jackets = d - suits_second_type\nsuits_first_type = min(a, remaining_jackets)\ncost_case2 = suits_second_type * f + suits_first_type * e\n\n# The maximum cost is the best of the two cases\nmax_cost = max(cost_case1, cost_case2)\n\n# Print the result\nprint(max_cost)"}
{"solution": "def mod_exp(base, exp, mod):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return result\n\ndef count_solutions(a, b, p, x):\n    count = 0\n    for n in range(1, p):\n        if (n * mod_exp(a, n, p)) % p == b:\n            max_n = (x - n) // p\n            count += max_n + 1\n    return count\n\n# Read input\na, b, p, x = map(int, input().split())\n\n# Calculate and print the result\nprint(count_solutions(a, b, p, x))"}
{"solution": "def max_sum_of_favorite_integers(k_2, k_3, k_5, k_6):\n    # Calculate the number of 256 we can form\n    num_256 = min(k_2, k_5, k_6)\n    \n    # Update the count of 2s after forming 256\n    k_2 -= num_256\n    \n    # Calculate the number of 32 we can form\n    num_32 = min(k_2, k_3)\n    \n    # Calculate the total sum\n    total_sum = num_256 * 256 + num_32 * 32\n    \n    return total_sum\n\n# Read input\nk_2, k_3, k_5, k_6 = map(int, input().split())\n\n# Get the result\nresult = max_sum_of_favorite_integers(k_2, k_3, k_5, k_6)\n\n# Print the result\nprint(result)"}
{"solution": "def calculate_seconds(n, x, y, c):\n    def cells_covered_in_time(t):\n        # Calculate the number of cells covered in t seconds\n        total = 0\n        for dx in range(-t, t + 1):\n            for dy in range(-t, t + 1):\n                if abs(dx) + abs(dy) <= t:\n                    if 1 <= x + dx <= n and 1 <= y + dy <= n:\n                        total += 1\n        return total\n\n    # Binary search to find the minimum time required\n    left, right = 0, 2 * n\n    while left < right:\n        mid = (left + right) // 2\n        if cells_covered_in_time(mid) >= c:\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n# Read input\nn, x, y, c = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_seconds(n, x, y, c))"}
{"solution": "def max_xor(l, r):\n    # Find the most significant bit position where l and r differ\n    xor = l ^ r\n    significant_bit = 1\n    while xor > 0:\n        significant_bit <<= 1\n        xor >>= 1\n    # The maximum XOR value will be when all bits up to the most significant differing bit are set to 1\n    return significant_bit - 1\n\n# Read input\nl, r = map(int, input().split())\n\n# Calculate and print the result\nprint(max_xor(l, r))"}
{"solution": "def minimum_height(n, k):\n    left, right = 1, k  # The height cannot be more than k because the area is k\n    \n    while left < right:\n        mid = (left + right) // 2\n        if n * mid >= k:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the result\nprint(minimum_height(n, k))"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    stairs_time = abs(x - y) * t1\n    \n    elevator_to_masha_time = abs(z - x) * t2 + t3\n    elevator_to_egor_time = abs(x - y) * t2 + 2 * t3\n    elevator_time = elevator_to_masha_time + elevator_to_egor_time\n    \n    if stairs_time < elevator_time:\n        return \"NO\"\n    else:\n        return \"YES\"\n\n# Example usage:\nx, y, z, t1, t2, t3 = map(int, input().split())\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "def find_best_a(n, m):\n    if m <= n // 2:\n        return m + 1\n    else:\n        return m - 1\n\n# Read input\nn, m = map(int, input().split())\n\n# Find and print the best value of a\nprint(find_best_a(n, m))"}
{"solution": "def count_pairs_at_university(n, schedule):\n    # Find the first and last pair with a class\n    first_class = -1\n    last_class = -1\n    for i in range(n):\n        if schedule[i] == 1:\n            if first_class == -1:\n                first_class = i\n            last_class = i\n    \n    # If there are no classes at all\n    if first_class == -1:\n        return 0\n    \n    # Count the number of pairs Alena stays at the university\n    pairs_at_university = 0\n    i = first_class\n    while i <= last_class:\n        if schedule[i] == 1:\n            pairs_at_university += 1\n            i += 1\n        else:\n            # Check if there is a break of at least two pairs\n            if i + 1 <= last_class and schedule[i + 1] == 0:\n                i += 2\n            else:\n                pairs_at_university += 1\n                i += 1\n    \n    return pairs_at_university\n\n# Read input\nn = int(input())\nschedule = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_pairs_at_university(n, schedule))"}
{"solution": "def min_days_to_give_candies(n, k, candies):\n    total_given = 0\n    saved_candies = 0\n\n    for day in range(n):\n        saved_candies += candies[day]\n        give_today = min(saved_candies, 8)\n        total_given += give_today\n        saved_candies -= give_today\n\n        if total_given >= k:\n            return day + 1\n\n    return -1\n\n# Read input\nn, k = map(int, input().split())\ncandies = list(map(int, input().split()))\n\n# Get the result\nresult = min_days_to_give_candies(n, k, candies)\n\n# Print the result\nprint(result)"}
{"solution": "def minimum_additional_walks(n, k, a):\n    b = a[:]\n    additional_walks = 0\n    \n    for i in range(n - 1):\n        if b[i] + b[i + 1] < k:\n            needed_walks = k - (b[i] + b[i + 1])\n            b[i + 1] += needed_walks\n            additional_walks += needed_walks\n    \n    return additional_walks, b\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nadditional_walks, b = minimum_additional_walks(n, k, a)\n\n# Print the result\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "def number_of_cells_in_rhombus(n):\n    if n == 1:\n        return 1\n    return 2 * n * (n - 1) + 1\n\n# Read input\nn = int(input().strip())\n\n# Compute and print the number of cells in the n-th order rhombus\nprint(number_of_cells_in_rhombus(n))"}
{"solution": "def is_pangram(n, s):\n    # Convert the string to lowercase to handle case insensitivity\n    s = s.lower()\n    \n    # Create a set of all letters in the alphabet\n    alphabet_set = set('abcdefghijklmnopqrstuvwxyz')\n    \n    # Create a set of all unique letters in the string\n    string_set = set(s)\n    \n    # Check if all letters in the alphabet are in the string set\n    if alphabet_set.issubset(string_set):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input()\n\n# Check if the string is a pangram and print the result\nprint(is_pangram(n, s))"}
{"solution": "# Read the input\ncurrent_time = input().strip()\na = int(input().strip())\n\n# Split the current time into hours and minutes\nhh, mm = map(int, current_time.split(':'))\n\n# Calculate the total minutes from the start of the day\ntotal_minutes = hh * 60 + mm\n\n# Add the given minutes\ntotal_minutes += a\n\n# Calculate the new hours and minutes\nnew_hh = (total_minutes // 60) % 24\nnew_mm = total_minutes % 60\n\n# Print the result in the required format\nprint(f\"{new_hh:02}:{new_mm:02}\")"}
{"solution": "def can_ignore_switch(n, m, matrix):\n    # Create an array to count how many switches can turn on each lamp\n    lamp_count = [0] * m\n    \n    # Count the number of switches that can turn on each lamp\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == '1':\n                lamp_count[j] += 1\n    \n    # Check if there is a switch that can be ignored\n    for i in range(n):\n        can_ignore = True\n        for j in range(m):\n            if matrix[i][j] == '1' and lamp_count[j] == 1:\n                can_ignore = False\n                break\n        if can_ignore:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nmatrix = [data[i + 2] for i in range(n)]\n\n# Determine if there is a switch that can be ignored\nresult = can_ignore_switch(n, m, matrix)\nprint(result)"}
{"solution": "def min_rotations_to_even_sums(n, dominoes):\n    upper_sum = sum(x for x, y in dominoes)\n    lower_sum = sum(y for x, y in dominoes)\n    \n    if upper_sum % 2 == 0 and lower_sum % 2 == 0:\n        return 0\n    \n    for x, y in dominoes:\n        if (upper_sum % 2 != lower_sum % 2) and ((x % 2) != (y % 2)):\n            return 1\n    \n    return -1\n\n# Read input\nn = int(input())\ndominoes = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(min_rotations_to_even_sums(n, dominoes))"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        \n        area = (a - b) * (a + b)\n        \n        if is_prime(area):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_remove_one_point(n, points):\n    positive_count = 0\n    negative_count = 0\n    \n    for x, y in points:\n        if x > 0:\n            positive_count += 1\n        else:\n            negative_count += 1\n    \n    if positive_count <= 1 or negative_count <= 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Reading input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_remove_one_point(n, points))"}
{"solution": "import math\n\ndef gcd_of_factorials(A, B):\n    # The GCD of A! and B! is the factorial of the minimum of A and B\n    min_val = min(A, B)\n    return math.factorial(min_val)\n\n# Read input\nA, B = map(int, input().split())\n\n# Calculate and print the result\nprint(gcd_of_factorials(A, B))"}
{"solution": "def is_composite(x):\n    if x <= 3:\n        return False\n    for i in range(2, int(x**0.5) + 1):\n        if x % i == 0:\n            return True\n    return False\n\ndef find_composite_pair(n):\n    # Start with a known composite number\n    a = 4 + n\n    b = 4\n    while not (is_composite(a) and is_composite(b)):\n        a += 1\n        b += 1\n    return a, b\n\n# Read input\nn = int(input().strip())\n\n# Find the composite pair\na, b = find_composite_pair(n)\n\n# Print the result\nprint(a, b)"}
{"solution": "import sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    P = int(data[2])\n    \n    edges = []\n    index = 3\n    for _ in range(M):\n        A = int(data[index]) - 1\n        B = int(data[index + 1]) - 1\n        C = int(data[index + 2])\n        edges.append((A, B, C))\n        index += 3\n    \n    # Bellman-Ford algorithm to find the maximum coins we can collect\n    dist = [-float('inf')] * N\n    dist[0] = 0\n    \n    for _ in range(N - 1):\n        for u, v, c in edges:\n            if dist[u] != -float('inf') and dist[u] + c > dist[v]:\n                dist[v] = dist[u] + c\n    \n    # Check for positive cycles reachable from vertex 1\n    reachable = [False] * N\n    reachable[0] = True\n    for _ in range(N):\n        for u, v, c in edges:\n            if reachable[u]:\n                reachable[v] = True\n    \n    for _ in range(N):\n        for u, v, c in edges:\n            if dist[u] != -float('inf') and dist[u] + c > dist[v]:\n                if reachable[v]:\n                    print(-1)\n                    return\n    \n    max_coins = dist[N - 1]\n    if max_coins == -float('inf'):\n        print(-1)\n    else:\n        max_score = max_coins - (N - 1) * P\n        print(max_score)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef min_cost_to_make_palindrome(N, strings, costs):\n    from itertools import combinations_with_replacement\n\n    min_cost = float('inf')\n    found_palindrome = False\n\n    for r in range(1, N + 1):\n        for combo in combinations_with_replacement(range(N), r):\n            combined_string = ''.join(strings[i] for i in combo)\n            if is_palindrome(combined_string):\n                found_palindrome = True\n                cost = sum(costs[i] for i in combo)\n                min_cost = min(min_cost, cost)\n\n    return min_cost if found_palindrome else -1\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN = int(data[0])\nstrings = []\ncosts = []\n\nfor i in range(1, N + 1):\n    s, c = data[i].split()\n    strings.append(s)\n    costs.append(int(c))\n\n# Calculate and print the result\nresult = min_cost_to_make_palindrome(N, strings, costs)\nprint(result)"}
{"solution": "def largest_xor_sum(n, k):\n    # Find the number of bits in n\n    num_bits = n.bit_length()\n    # The largest possible xor-sum\n    max_xor_sum = (1 << num_bits) - 1\n    return max_xor_sum\n\n# Read input\nn, k = map(int, input().split())\n# Print the result\nprint(largest_xor_sum(n, k))"}
{"solution": "def min_shorter_side_length(n, points):\n    max_x = max(point[0] for point in points)\n    max_y = max(point[1] for point in points)\n    return max(max_x, max_y) + 1\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    points = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(n)]\n    \n    result = min_shorter_side_length(n, points)\n    print(result)"}
{"solution": "def max_nineteens(s):\n    from collections import Counter\n    \n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # Define the required frequency of each character in the word \"nineteen\"\n    required_counts = {'n': 3, 'i': 1, 'e': 3, 't': 1}\n    \n    # Calculate the maximum number of \"nineteen\" words that can be formed\n    max_nineteens = float('inf')\n    for char, required in required_counts.items():\n        if char in char_count:\n            max_nineteens = min(max_nineteens, char_count[char] // required)\n        else:\n            return 0  # If any required character is missing, we can't form \"nineteen\"\n    \n    return max_nineteens\n\n# Read input\ns = input().strip()\n\n# Print the output\nprint(max_nineteens(s))"}
{"solution": "def highest_suitable_branch(p, y):\n    def is_reachable_by_grasshopper(branch, p):\n        for x in range(2, min(p + 1, int(branch**0.5) + 1)):\n            if branch % x == 0:\n                return True\n        return False\n\n    for branch in range(y, p, -1):\n        if not is_reachable_by_grasshopper(branch, p):\n            return branch\n    return -1\n\n# Read input\np, y = map(int, input().split())\n\n# Find and print the highest suitable branch\nprint(highest_suitable_branch(p, y))"}
{"solution": "def find_minimum_distance(n, m, k, prices):\n    min_distance = float('inf')\n    \n    for i in range(n):\n        if prices[i] != 0 and prices[i] <= k:\n            distance = abs(i + 1 - m) * 10\n            if distance < min_distance:\n                min_distance = distance\n    \n    return min_distance\n\n# Read input\nn, m, k = map(int, input().split())\nprices = list(map(int, input().split()))\n\n# Find and print the minimum distance\nprint(find_minimum_distance(n, m, k, prices))"}
{"solution": "def can_transform(A, B, n, m):\n    # Check if the sorted rows and columns of A match those of B\n    for i in range(n):\n        if sorted(A[i]) != sorted(B[i]):\n            return False\n\n    for j in range(m):\n        if sorted([A[i][j] for i in range(n)]) != sorted([B[i][j] for i in range(n)]):\n            return False\n\n    return True\n\n# Read input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nB = [list(map(int, input().split())) for _ in range(n)]\n\n# Check if transformation is possible\nif can_transform(A, B, n, m):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def longest_uncommon_subsequence(a, b):\n    if a == b:\n        return -1\n    else:\n        return max(len(a), len(b))\n\n# Read input\na = input().strip()\nb = input().strip()\n\n# Compute and print the result\nprint(longest_uncommon_subsequence(a, b))"}
{"solution": "def find_first_common_scream(a, b, c, d):\n    # Initialize the times for Rick and Morty\n    rick_time = b\n    morty_time = d\n    \n    # Use a set to keep track of Rick's scream times\n    rick_screams = set()\n    \n    # Generate Rick's scream times up to a reasonable limit\n    while rick_time <= 10000:  # Arbitrary large limit to avoid infinite loop\n        rick_screams.add(rick_time)\n        rick_time += a\n    \n    # Check Morty's scream times against Rick's scream times\n    while morty_time <= 10000:  # Same arbitrary large limit\n        if morty_time in rick_screams:\n            return morty_time\n        morty_time += c\n    \n    # If no common scream time is found\n    return -1\n\n# Read input values\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Find and print the first common scream time\nprint(find_first_common_scream(a, b, c, d))"}
{"solution": "def split_number(n):\n    # Start with a base case where a, b, and c are all 1\n    a, b, c = 1, 1, n - 2\n    \n    # Adjust c if it is a multiple of 3\n    if c % 3 == 0:\n        c -= 1\n        b += 1\n    \n    # Print the result\n    print(a, b, c)\n\n# Read input\nn = int(input().strip())\n\n# Call the function to split the number\nsplit_number(n)"}
{"solution": "def count_valid_squares(n, a, b, c, d):\n    count = 0\n    for x in range(1, n + 1):\n        for y in range(1, n + 1):\n            if a + b + x + y == a + c + x + d == b + d + y + c:\n                count += 1\n    return count\n\n# Read input\nn, a, b, c, d = map(int, input().split())\n\n# Calculate and print the number of distinct valid squares\nprint(count_valid_squares(n, a, b, c, d))"}
{"solution": "# Read input values\nw, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\n# Simulate the snowball's descent\nfor current_height in range(h, 0, -1):\n    # Increase the snowball's weight by the current height\n    w += current_height\n    \n    # Check if the snowball hits a stone\n    if current_height == d1:\n        w -= u1\n    elif current_height == d2:\n        w -= u2\n    \n    # Ensure the weight does not go below zero\n    if w < 0:\n        w = 0\n\n# Print the final weight of the snowball\nprint(w)"}
{"solution": "def find_passing_rate(m, scores, x, y):\n    # Calculate prefix sums to get the number of students with scores less than k\n    prefix_sums = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + scores[i - 1]\n\n    # Iterate over possible passing rates\n    for k in range(1, m + 1):\n        beginners = prefix_sums[k - 1]\n        intermediates = prefix_sums[m] - prefix_sums[k - 1]\n        \n        if x <= beginners <= y and x <= intermediates <= y:\n            return k\n\n    return 0\n\n# Read input\nm = int(input())\nscores = list(map(int, input().split()))\nx, y = map(int, input().split())\n\n# Find and print the passing rate\nresult = find_passing_rate(m, scores, x, y)\nprint(result)"}
{"solution": "def min_coins_to_one(n, k, A, B):\n    coins = 0\n    while n > 1:\n        if k == 1:\n            # If k is 1, we can only subtract 1 each time\n            coins += (n - 1) * A\n            break\n        if n % k == 0:\n            # If n is divisible by k, we have a choice\n            cost_divide = B\n            cost_subtract = (n - n // k) * A\n            if cost_divide < cost_subtract:\n                coins += cost_divide\n                n //= k\n            else:\n                coins += cost_subtract\n                n = n // k\n        else:\n            # If n is not divisible by k, we need to subtract to make it divisible\n            remainder = n % k\n            if remainder > 0:\n                coins += remainder * A\n                n -= remainder\n    return coins\n\n# Read input\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\n# Calculate and print the result\nprint(min_coins_to_one(n, k, A, B))"}
{"solution": "import math\nfrom collections import deque\n\ndef min_operations(n):\n    # Queue for BFS\n    queue = deque([(n, 0)])\n    visited = set([n])\n    \n    while queue:\n        current, steps = queue.popleft()\n        \n        # If current is 1, we found the minimum value\n        if current == 1:\n            return (1, steps)\n        \n        # Try the sqrt operation if possible\n        sqrt_val = int(math.isqrt(current))\n        if sqrt_val * sqrt_val == current and sqrt_val not in visited:\n            visited.add(sqrt_val)\n            queue.append((sqrt_val, steps + 1))\n        \n        # Try the mul operation with arbitrary positive integers\n        for x in range(2, int(math.sqrt(current)) + 1):\n            mul_val = current * x\n            if mul_val not in visited:\n                visited.add(mul_val)\n                queue.append((mul_val, steps + 1))\n    \n    return (n, 0)\n\n# Read input\nn = int(input().strip())\n\n# Get the result\nresult = min_operations(n)\n\n# Print the result\nprint(result[0], result[1])"}
{"solution": "def max_score(N, K, R, S, P, T):\n    # Initialize the score\n    score = 0\n    \n    # Initialize the list to keep track of the hand used in each round\n    hand_used = [None] * N\n    \n    # Iterate through each round\n    for i in range(N):\n        if T[i] == 'r':\n            if i >= K and hand_used[i - K] == 'p':\n                hand_used[i] = None\n            else:\n                hand_used[i] = 'p'\n                score += P\n        elif T[i] == 'p':\n            if i >= K and hand_used[i - K] == 's':\n                hand_used[i] = None\n            else:\n                hand_used[i] = 's'\n                score += S\n        elif T[i] == 's':\n            if i >= K and hand_used[i - K] == 'r':\n                hand_used[i] = None\n            else:\n                hand_used[i] = 'r'\n                score += R\n    \n    return score\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nR = int(data[2])\nS = int(data[3])\nP = int(data[4])\nT = data[5]\n\n# Calculate and print the maximum score\nprint(max_score(N, K, R, S, P, T))"}
{"solution": "def longest_good_string(a, b, c):\n    # The maximum length of the good string can be obtained by using all \"ab\" strings first\n    # and then using the remaining \"a\" and \"b\" strings in an alternating manner.\n    \n    # Each \"ab\" string contributes 2 to the length of the good string.\n    length = 2 * c\n    \n    # After using all \"ab\" strings, we need to use the remaining \"a\" and \"b\" strings.\n    # The number of remaining \"a\" strings is a - c and the number of remaining \"b\" strings is b - c.\n    # We need to ensure that we do not use more \"a\" or \"b\" strings than available.\n    remaining_a = a - c\n    remaining_b = b - c\n    \n    # We can use the minimum of the remaining \"a\" and \"b\" strings in an alternating manner.\n    # Each pair of \"a\" and \"b\" contributes 2 to the length of the good string.\n    length += 2 * min(remaining_a, remaining_b)\n    \n    # If there is one more \"a\" or \"b\" string left, we can add one more to the length.\n    if remaining_a > remaining_b:\n        length += 1\n    elif remaining_b > remaining_a:\n        length += 1\n    \n    return length\n\n# Read input\na, b, c = map(int, input().split())\n\n# Calculate and print the result\nprint(longest_good_string(a, b, c))"}
{"solution": "def solve_vova_problem(n, k, p, x, y, marks):\n    remaining_tests = n - k\n    current_sum = sum(marks)\n    marks_needed = []\n\n    # Calculate how many marks >= y are needed to ensure the median is at least y\n    marks_ge_y_needed = (n + 1) // 2 - sum(1 for mark in marks if mark >= y)\n    marks_ge_y_needed = max(0, marks_ge_y_needed)\n\n    # If we need more marks >= y than the remaining tests, it's impossible\n    if marks_ge_y_needed > remaining_tests:\n        return -1\n\n    # Add the necessary marks >= y\n    marks_needed.extend([y] * marks_ge_y_needed)\n    remaining_tests -= marks_ge_y_needed\n\n    # Add the remaining marks as 1 to minimize the sum\n    marks_needed.extend([1] * remaining_tests)\n\n    # Check if the total sum exceeds x\n    if current_sum + sum(marks_needed) > x:\n        return -1\n\n    return marks_needed\n\n# Read input\nn, k, p, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Solve the problem\nresult = solve_vova_problem(n, k, p, x, y, marks)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def is_berlanese(s):\n    vowels = {'a', 'o', 'u', 'i', 'e'}\n    n = len(s)\n    \n    for i in range(n):\n        if s[i] not in vowels and s[i] != 'n':\n            if i == n - 1 or s[i + 1] not in vowels:\n                return \"NO\"\n    return \"YES\"\n\n# Read input\ns = input().strip()\n\n# Determine if the word is Berlanese\nresult = is_berlanese(s)\n\n# Print the result\nprint(result)"}
{"solution": "def max_dominoes(n, m, edges):\n    from collections import defaultdict\n    from itertools import combinations\n\n    # Create adjacency list for the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Function to check if a given assignment of dots to vertices is valid\n    def is_valid_assignment(assignment):\n        for u in range(1, n + 1):\n            for v in graph[u]:\n                if assignment[u] != assignment[v]:\n                    return False\n        return True\n\n    # Try all possible assignments of dots to vertices\n    max_dominoes_count = 0\n    for dots in combinations(range(1, 7), n):\n        assignment = {i + 1: dots[i] for i in range(n)}\n        if is_valid_assignment(assignment):\n            max_dominoes_count = max(max_dominoes_count, m)\n\n    return max_dominoes_count\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Calculate and print the result\nprint(max_dominoes(n, m, edges))"}
{"solution": "def max_points(n, m, prices, auction_indices):\n    # Convert auction_indices to zero-based\n    auction_indices = [x - 1 for x in auction_indices]\n    \n    # Separate auction and regular questions\n    auction_prices = [prices[i] for i in auction_indices]\n    regular_prices = [prices[i] for i in range(n) if i not in auction_indices]\n    \n    # Sort auction prices in descending order\n    auction_prices.sort(reverse=True)\n    # Sort regular prices in descending order\n    regular_prices.sort(reverse=True)\n    \n    # Initialize total points\n    total_points = 0\n    current_points = 0\n    \n    # First, answer all auction questions optimally\n    for price in auction_prices:\n        if current_points > price:\n            total_points += current_points\n        else:\n            total_points += price\n        current_points = total_points\n    \n    # Then, answer all regular questions\n    for price in regular_prices:\n        total_points += price\n        current_points = total_points\n    \n    return total_points\n\n# Read input\nn, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauction_indices = list(map(int, input().split()))\n\n# Calculate and print the maximum points\nprint(max_points(n, m, prices, auction_indices))"}
{"solution": "def calculate_score(submission_times, wrong_submissions, successful_hacks, unsuccessful_hacks):\n    max_points = [500, 1000, 1500, 2000, 2500]\n    total_score = 0\n    \n    for i in range(5):\n        m = submission_times[i]\n        w = wrong_submissions[i]\n        x = max_points[i]\n        \n        score = max(0.3 * x, (1 - m / 250) * x - 50 * w)\n        total_score += score\n    \n    total_score += 100 * successful_hacks\n    total_score -= 50 * unsuccessful_hacks\n    \n    return int(total_score)\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    submission_times = list(map(int, data[0:5]))\n    wrong_submissions = list(map(int, data[5:10]))\n    successful_hacks = int(data[10])\n    unsuccessful_hacks = int(data[11])\n    \n    final_score = calculate_score(submission_times, wrong_submissions, successful_hacks, unsuccessful_hacks)\n    print(final_score)"}
{"solution": "MOD = 998244353\n\ndef count_valid_grids(n, m, L, R):\n    # Calculate the total number of cells\n    total_cells = n * m\n    \n    # Calculate the number of valid grids\n    valid_grids = (R - L + 1) % MOD\n    \n    # Raise the number of valid grids to the power of total_cells\n    result = pow(valid_grids, total_cells, MOD)\n    \n    return result\n\n# Read input\nn, m, L, R = map(int, input().strip().split())\n\n# Calculate and print the result\nprint(count_valid_grids(n, m, L, R))"}
{"solution": "def is_possible_to_make_increasing(n, m, matrix_a, matrix_b):\n    for i in range(n):\n        for j in range(m):\n            # Ensure that matrix_a[i][j] is the smaller or equal element\n            if matrix_a[i][j] > matrix_b[i][j]:\n                matrix_a[i][j], matrix_b[i][j] = matrix_b[i][j], matrix_a[i][j]\n    \n    # Check rows for strictly increasing property\n    for i in range(n):\n        for j in range(1, m):\n            if matrix_a[i][j] <= matrix_a[i][j-1] or matrix_b[i][j] <= matrix_b[i][j-1]:\n                return \"Impossible\"\n    \n    # Check columns for strictly increasing property\n    for j in range(m):\n        for i in range(1, n):\n            if matrix_a[i][j] <= matrix_a[i-1][j] or matrix_b[i][j] <= matrix_b[i-1][j]:\n                return \"Impossible\"\n    \n    return \"Possible\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nmatrix_a = []\nmatrix_b = []\n\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    matrix_a.append(row)\n    index += m\n\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    matrix_b.append(row)\n    index += m\n\n# Determine if it is possible to make both matrices strictly increasing\nresult = is_possible_to_make_increasing(n, m, matrix_a, matrix_b)\nprint(result)"}
{"solution": "def max_length_string(n, a):\n    # Sort the list of maximum occurrences in descending order\n    a.sort(reverse=True)\n    \n    # Initialize the maximum length of the string\n    max_length = 0\n    \n    # Initialize the current maximum allowed occurrences\n    current_max = float('inf')\n    \n    for count in a:\n        # The number of occurrences of the current letter should be the minimum of\n        # the current count and the current maximum allowed occurrences minus one\n        if current_max > 0:\n            current_max = min(current_max - 1, count)\n            max_length += current_max\n        else:\n            break\n    \n    return max_length\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the maximum length of the string\nprint(max_length_string(n, a))"}
{"solution": "def min_problems_to_solve(n, k, difficulties):\n    difficulties.sort()\n    current_max = k\n    additional_problems = 0\n\n    for difficulty in difficulties:\n        while current_max < (difficulty + 1) // 2:\n            current_max *= 2\n            additional_problems += 1\n        current_max = max(current_max, difficulty)\n\n    return additional_problems\n\n# Read input\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_problems_to_solve(n, k, difficulties))"}
{"solution": "def distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3):\n    # Start with the minimum required diplomas\n    first_degree = min_1\n    second_degree = min_2\n    third_degree = min_3\n\n    # Calculate the remaining participants after assigning the minimum required diplomas\n    remaining = n - (first_degree + second_degree + third_degree)\n\n    # Try to maximize the first degree diplomas\n    additional_first = min(remaining, max_1 - first_degree)\n    first_degree += additional_first\n    remaining -= additional_first\n\n    # Try to maximize the second degree diplomas\n    additional_second = min(remaining, max_2 - second_degree)\n    second_degree += additional_second\n    remaining -= additional_second\n\n    # The rest will go to the third degree diplomas\n    third_degree += remaining\n\n    return first_degree, second_degree, third_degree\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nmin_1, max_1 = int(data[1]), int(data[2])\nmin_2, max_2 = int(data[3]), int(data[4])\nmin_3, max_3 = int(data[5]), int(data[6])\n\n# Get the optimal distribution of diplomas\nresult = distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3)\n\n# Print the result\nprint(result[0], result[1], result[2])"}
{"solution": "def determine_moon_phase(n, records):\n    moon_cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, \n                  14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    \n    last_size = records[-1]\n    \n    if n == 1:\n        if last_size == 0:\n            return \"UP\"\n        elif last_size == 15:\n            return \"DOWN\"\n        else:\n            return -1\n    \n    second_last_size = records[-2]\n    \n    if last_size == 0:\n        return \"UP\"\n    elif last_size == 15:\n        return \"DOWN\"\n    elif last_size > second_last_size:\n        return \"UP\"\n    else:\n        return \"DOWN\"\n\n# Read input\nn = int(input())\nrecords = list(map(int, input().split()))\n\n# Determine and print the result\nprint(determine_moon_phase(n, records))"}
{"solution": "def can_transform(s, t):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    # Check if lengths are the same\n    if len(s) != len(t):\n        return \"No\"\n    \n    # Check each character\n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels) != (char_t in vowels):\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(can_transform(s, t))"}
{"solution": "def determine_winner(board):\n    min_white_steps = float('inf')\n    min_black_steps = float('inf')\n\n    for col in range(8):\n        for row in range(8):\n            if board[row][col] == 'W':\n                steps = row\n                if steps < min_white_steps:\n                    min_white_steps = steps\n            elif board[row][col] == 'B':\n                steps = 7 - row\n                if steps < min_black_steps:\n                    min_black_steps = steps\n\n    if min_white_steps <= min_black_steps:\n        return 'A'\n    else:\n        return 'B'\n\n# Read the board input\nboard = [input().strip() for _ in range(8)]\n\n# Determine the winner\nwinner = determine_winner(board)\n\n# Print the result\nprint(winner)"}
{"solution": "def max_equal_length(n, A, m, B):\n    if sum(A) != sum(B):\n        return -1\n    \n    i, j = 0, 0\n    sumA, sumB = 0, 0\n    count = 0\n    \n    while i < n and j < m:\n        sumA += A[i]\n        sumB += B[j]\n        \n        if sumA == sumB:\n            count += 1\n            sumA = 0\n            sumB = 0\n            i += 1\n            j += 1\n        elif sumA < sumB:\n            i += 1\n        else:\n            j += 1\n    \n    return count\n\n# Example usage:\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\nprint(max_equal_length(n, A, m, B))"}
{"solution": "def is_contest_problem(problem_name):\n    friends_names = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    count = 0\n    \n    for name in friends_names:\n        count += problem_name.count(name)\n    \n    if count == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nproblem_name = input().strip()\n\n# Determine if the problem is from the contest\nresult = is_contest_problem(problem_name)\n\n# Print the result\nprint(result)"}
{"solution": "def sieve(n):\n    is_prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (is_prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n    is_prime[0], is_prime[1] = False, False  # 0 and 1 are not primes\n    return is_prime\n\ndef count_primes_in_range(is_prime, a, b):\n    prime_count = [0] * (b + 1)\n    for i in range(a, b + 1):\n        prime_count[i] = prime_count[i - 1] + (1 if is_prime[i] else 0)\n    return prime_count\n\ndef min_length_with_k_primes(a, b, k):\n    is_prime = sieve(b)\n    prime_count = count_primes_in_range(is_prime, a, b)\n    \n    def has_k_primes_in_length(l):\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] >= k:\n                return True\n        return False\n    \n    left, right = 1, b - a + 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if has_k_primes_in_length(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\n# Input\na, b, k = map(int, input().split())\n\n# Output\nprint(min_length_with_k_primes(a, b, k))"}
{"solution": "def min_x(a, h, w):\n    def check(n, m):\n        return (h - n * a) / (n + 1) >= 0 and (w - m * a) / (m + 1) >= 0\n\n    min_x = float('inf')\n    found = False\n\n    for n in range(1, h // a + 1 + 1):\n        for m in range(1, w // a + 1 + 1):\n            if check(n, m):\n                x1 = (h - n * a) / (n + 1)\n                x2 = (w - m * a) / (m + 1)\n                x = max(x1, x2)\n                min_x = min(min_x, x)\n                found = True\n\n    if found:\n        return min_x\n    else:\n        return -1\n\n# Read input\na, h, w = map(int, input().split())\n\n# Calculate and print the result\nresult = min_x(a, h, w)\nprint(f\"{result:.6f}\" if result != -1 else -1)"}
{"solution": "# Read the number of chapters\nn = int(input())\n\n# Read the chapters' page ranges\nchapters = []\nfor _ in range(n):\n    l, r = map(int, input().split())\n    chapters.append((l, r))\n\n# Read the marked page number\nk = int(input())\n\n# Count the number of chapters not completely read\nunread_chapters = 0\nfor l, r in chapters:\n    if k <= r:\n        unread_chapters += 1\n\n# Print the result\nprint(unread_chapters)"}
{"solution": "def can_form_codeforces(word):\n    target = \"CODEFORCES\"\n    n = len(word)\n    m = len(target)\n    \n    if n < m:\n        print(\"NO\")\n        return\n    \n    for i in range(m + 1):\n        if word[:i] == target[:i] and word[n - (m - i):] == target[i:]:\n            print(\"YES\")\n            return\n    \n    print(\"NO\")\n\n# Example usage:\nword = input().strip()\ncan_form_codeforces(word)"}
{"solution": "def min_weight_triangulation(n):\n    # Initialize the dp table\n    dp = [[0] * n for _ in range(n)]\n    \n    # Fill the dp table\n    for length in range(2, n):  # length is the distance between i and j\n        for i in range(n - length):\n            j = i + length\n            dp[i][j] = float('inf')\n            for k in range(i + 1, j):\n                weight = (i + 1) * (k + 1) * (j + 1)\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + weight)\n    \n    return dp[0][n - 1]\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the minimum weight\nprint(min_weight_triangulation(n))"}
{"solution": "def count_digits(n):\n    digits = 0\n    length = 1\n    start = 1\n    while start <= n:\n        end = min(n, start * 10 - 1)\n        digits += (end - start + 1) * length\n        length += 1\n        start *= 10\n    return digits\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the number of digits\nprint(count_digits(n))"}
{"solution": "def find_winning_color(n, A, car_colors):\n    from collections import defaultdict\n\n    # Count occurrences of each color\n    color_count = defaultdict(int)\n    for color in car_colors:\n        color_count[color] += 1\n\n    # Initialize counters for Alice's color and other colors\n    cnt_A = 0\n    cnt_B = defaultdict(int)\n\n    # Iterate through the car colors\n    for color in car_colors:\n        if color == A:\n            cnt_A += 1\n        else:\n            cnt_B[color] += 1\n\n        # Check if any color B has cnt_B >= cnt_A at all times\n        for color, count in cnt_B.items():\n            if count >= cnt_A:\n                return color\n\n    return -1\n\n# Read input\nn, A = map(int, input().split())\ncar_colors = list(map(int, input().split()))\n\n# Find and print the winning color for Bob\nprint(find_winning_color(n, A, car_colors))"}
{"solution": "def can_form_unique_crossword(n, x, a):\n    # Calculate the minimum length required to fit the segments with at least one '0' between them\n    min_length_required = sum(a) + (n - 1)\n    \n    # Check if the minimum length required matches the given length x\n    if min_length_required == x:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Output the result\nprint(can_form_unique_crossword(n, x, a))"}
{"solution": "def min_coins(n, S):\n    # The largest coin value we can use is n\n    max_coin = n\n    \n    # The minimum number of coins required to get sum S\n    min_coins_required = S // max_coin\n    \n    # If there is a remainder, we need one more coin\n    if S % max_coin != 0:\n        min_coins_required += 1\n    \n    return min_coins_required\n\n# Read input\nn, S = map(int, input().split())\n\n# Calculate and print the result\nprint(min_coins(n, S))"}
{"solution": "def smallest_palindrome(s):\n    from collections import Counter\n\n    n = len(s)\n    freq = Counter(s)\n    odd_count = sum(1 for count in freq.values() if count % 2 != 0)\n    \n    if odd_count > 1:\n        return \"Not possible to form a palindrome\"\n    \n    half = []\n    middle = []\n    \n    for char in sorted(freq.keys()):\n        if freq[char] % 2 != 0:\n            middle.append(char)\n        half.extend([char] * (freq[char] // 2))\n    \n    left_half = ''.join(half)\n    right_half = left_half[::-1]\n    middle_part = ''.join(middle)\n    \n    return left_half + middle_part + right_half\n\n# Read input\ns = input().strip()\n\n# Get the smallest palindrome\nresult = smallest_palindrome(s)\n\n# Print the result\nprint(result)"}
{"solution": "def calculate_weight(board):\n    piece_weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n    }\n    \n    white_weight = 0\n    black_weight = 0\n    \n    for row in board:\n        for piece in row:\n            if piece in piece_weights:\n                if piece.isupper():\n                    white_weight += piece_weights[piece]\n                else:\n                    black_weight += piece_weights[piece]\n    \n    if white_weight > black_weight:\n        print(\"White\")\n    elif black_weight > white_weight:\n        print(\"Black\")\n    else:\n        print(\"Draw\")\n\n# Reading input\nboard = [input().strip() for _ in range(8)]\n\n# Calculate and print the result\ncalculate_weight(board)"}
{"solution": "import heapq\nfrom collections import deque\n\ndef solve_sugoroku(N, M, S):\n    # Initialize the queue for BFS and the priority queue for lexicographical order\n    queue = deque([(0, [])])\n    visited = [False] * (N + 1)\n    visited[0] = True\n    \n    while queue:\n        current_square, path = queue.popleft()\n        \n        # Try all possible moves from the current square\n        for move in range(1, M + 1):\n            next_square = current_square + move\n            \n            # Check if the move is valid\n            if next_square > N or S[next_square] == '1' or visited[next_square]:\n                continue\n            \n            # If we reach the final square, return the path\n            if next_square == N:\n                print(' '.join(map(str, path + [move])))\n                return\n            \n            # Mark the square as visited and add to the queue\n            visited[next_square] = True\n            queue.append((next_square, path + [move]))\n    \n    # If we exhaust the queue without finding a path, return -1\n    print(-1)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nS = data[2]\n\n# Solve the problem\nsolve_sugoroku(N, M, S)"}
{"solution": "def solve_golf(K, X, Y):\n    # Check if the game can be finished\n    if (X + Y) % K != 0:\n        print(-1)\n        return\n\n    # Calculate the number of strokes needed\n    s = (abs(X) + abs(Y) + K - 1) // K\n\n    # Initialize the current position\n    current_x, current_y = 0, 0\n\n    # List to store the positions after each stroke\n    positions = []\n\n    for _ in range(s - 1):\n        # Calculate the next position\n        if abs(X - current_x) >= K:\n            if X > current_x:\n                next_x = current_x + K\n            else:\n                next_x = current_x - K\n            next_y = current_y\n        else:\n            next_x = X\n            next_y = current_y + (K - abs(X - current_x)) if Y > current_y else current_y - (K - abs(X - current_x))\n\n        positions.append((next_x, next_y))\n        current_x, current_y = next_x, next_y\n\n    # Add the final position\n    positions.append((X, Y))\n\n    # Print the result\n    print(s)\n    for pos in positions:\n        print(pos[0], pos[1])\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nK = int(data[0])\nX = int(data[1])\nY = int(data[2])\n\n# Solve the problem\nsolve_golf(K, X, Y)"}
{"solution": "def count_ways(n):\n    count = 0\n    for a in range(1, n + 1):\n        for k in range(2, n + 1):\n            b = a * k\n            c = b * k\n            d = c * k\n            if d > n:\n                break\n            if d <= n:\n                count += 1\n    return count\n\ndef find_min_n(m):\n    left, right = 1, 10**18\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        ways = count_ways(mid)\n        if ways == m:\n            result = mid\n            right = mid - 1\n        elif ways < m:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result\n\nm = int(input().strip())\nprint(find_min_n(m))"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    # Calculate the distance between the centers of the circles\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    \n    # If the circles do not overlap\n    if d >= r1 + r2:\n        return 0.0\n    \n    # If one circle is completely inside the other\n    if d <= abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n    \n    # Calculate the area of intersection\n    r1_sq = r1 ** 2\n    r2_sq = r2 ** 2\n    \n    part1 = r1_sq * math.acos((d ** 2 + r1_sq - r2_sq) / (2 * d * r1))\n    part2 = r2_sq * math.acos((d ** 2 + r2_sq - r1_sq) / (2 * d * r2))\n    part3 = 0.5 * math.sqrt((-d + r1 + r2) * (d + r1 - r2) * (d - r1 + r2) * (d + r1 + r2))\n    \n    return part1 + part2 - part3\n\n# Read input\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\n# Calculate the area of intersection\narea = circle_intersection_area(x1, y1, r1, x2, y2, r2)\n\n# Print the result with sufficient precision\nprint(f\"{area:.20f}\")"}
{"solution": "def minimize_n(v):\n    if v == 1:\n        return 1\n    \n    # Find the smallest non-trivial divisor of v\n    for i in range(2, int(v**0.5) + 1):\n        if v % i == 0:\n            return v - (v // i)\n    \n    # If no divisors found, v is prime\n    return 1\n\n# Read input\nv = int(input().strip())\n\n# Output the result\nprint(minimize_n(v))"}
{"solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    p = list(map(int, data[1:n]))\n    a = list(map(int, data[n:2*n]))\n    \n    from collections import defaultdict, deque\n    \n    # Create adjacency list for the tree\n    tree = defaultdict(list)\n    for i in range(2, n+1):\n        tree[p[i-2]].append(i)\n    \n    # Calculate the number of citizens in each subtree\n    subtree_citizens = [0] * (n + 1)\n    def dfs(node):\n        subtree_citizens[node] = a[node-1]\n        for child in tree[node]:\n            dfs(child)\n            subtree_citizens[node] += subtree_citizens[child]\n    \n    dfs(1)\n    \n    # Find the maximum number of citizens the bandit can catch\n    max_citizens = 0\n    def find_max_citizens(node):\n        nonlocal max_citizens\n        if not tree[node]:  # If it's a leaf node\n            max_citizens = max(max_citizens, subtree_citizens[node])\n        for child in tree[node]:\n            find_max_citizens(child)\n    \n    find_max_citizens(1)\n    \n    print(max_citizens)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_typo_words(n, S, T):\n    count = 0\n    for i in range(n + 1):\n        # Construct W by inserting a character at position i in both S and T\n        if i == 0:\n            W1 = S[0] + S\n            W2 = T[0] + T\n        elif i == n:\n            W1 = S + S[-1]\n            W2 = T + T[-1]\n        else:\n            W1 = S[:i] + S[i] + S[i:]\n            W2 = T[:i] + T[i] + T[i:]\n        \n        # Check if the constructed words are the same\n        if W1 == W2:\n            count += 1\n    \n    return count\n\n# Example usage:\nn = int(input())\nS = input().strip()\nT = input().strip()\nprint(count_typo_words(n, S, T))"}
{"solution": "import sys\nimport collections\n\ndef min_computer_strength(n, strengths, connections):\n    # Create adjacency list for the graph\n    graph = collections.defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Function to perform BFS and determine the minimum strength required\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = collections.deque([start])\n        visited[start] = True\n        max_strength = strengths[start - 1]\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    max_strength = max(max_strength, strengths[neighbor - 1])\n        \n        return max_strength\n    \n    # Find the minimum strength required by trying to start from each bank\n    min_strength = float('inf')\n    for i in range(1, n + 1):\n        min_strength = min(min_strength, bfs(i))\n    \n    return min_strength\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nstrengths = list(map(int, data[1:n+1]))\nconnections = []\nindex = n + 1\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    connections.append((u, v))\n    index += 2\n\n# Calculate and print the result\nprint(min_computer_strength(n, strengths, connections))"}
{"solution": "def max_groups(n, m):\n    if m == 0:\n        return 1\n    return min(m, n - m)\n\n# Read input values\nn, m = map(int, input().split())\n\n# Print the maximum number of groups\nprint(max_groups(n, m))"}
{"solution": "def minimum_shovels(k, r):\n    for i in range(1, 11):\n        total_cost = k * i\n        if total_cost % 10 == 0 or total_cost % 10 == r:\n            return i\n\n# Read input\nk, r = map(int, input().split())\n\n# Calculate and print the result\nprint(minimum_shovels(k, r))"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # Dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Extract the bounding box\n    piece = []\n    for i in range(min_row, max_row + 1):\n        piece.append(grid[i][min_col:max_col + 1])\n    \n    # Check horizontal placement\n    if width * 2 == m:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j] != piece[i][j + width]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    # Check vertical placement\n    if height * 2 == n:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j] != piece[i + height][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "# Function to determine the minimum number of segments required\ndef min_segments(points):\n    # Unpack the points\n    (x1, y1), (x2, y2), (x3, y3) = points\n    \n    # Check if all three points share the same x-coordinate or y-coordinate\n    if (x1 == x2 == x3) or (y1 == y2 == y3):\n        return 1\n    \n    # Check if any two points share the same x-coordinate or y-coordinate\n    if (x1 == x2) or (x1 == x3) or (x2 == x3) or (y1 == y2) or (y1 == y3) or (y2 == y3):\n        return 2\n    \n    # General case where no two points share the same x-coordinate or y-coordinate\n    return 3\n\n# Read input points\npoints = [tuple(map(int, input().split())) for _ in range(3)]\n\n# Determine and print the minimum number of segments\nprint(min_segments(points))"}
{"solution": "def construct_k_regular_graph(k):\n    if k == 1:\n        print(\"YES\")\n        print(\"2 1\")\n        print(\"1 2\")\n        return\n    \n    if k % 2 != 0:\n        print(\"NO\")\n        return\n    \n    n = k + 2\n    m = (k * n) // 2\n    \n    print(\"YES\")\n    print(f\"{n} {m}\")\n    \n    edges = []\n    for i in range(1, n - 1):\n        for j in range(i + 1, n - 1):\n            if len(edges) < m:\n                edges.append((i, j))\n    \n    for i in range(1, k // 2 + 1):\n        edges.append((n - 1, i))\n        edges.append((n, i + k // 2))\n    \n    for edge in edges:\n        print(f\"{edge[0]} {edge[1]}\")\n\nk = int(input().strip())\nconstruct_k_regular_graph(k)"}
{"solution": "def preprocess_occurrences(s, t):\n    n = len(s)\n    m = len(t)\n    occurrences = [0] * (n + 1)\n    \n    for i in range(n - m + 1):\n        if s[i:i + m] == t:\n            occurrences[i + 1] = 1\n    \n    for i in range(1, n + 1):\n        occurrences[i] += occurrences[i - 1]\n    \n    return occurrences\n\ndef count_occurrences(occurrences, l, r, m):\n    if r - l + 1 < m:\n        return 0\n    return occurrences[r - m + 1] - occurrences[l - 1]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    q = int(data[2])\n    \n    s = data[3]\n    t = data[4]\n    \n    queries = []\n    for i in range(5, len(data), 2):\n        l = int(data[i])\n        r = int(data[i + 1])\n        queries.append((l, r))\n    \n    occurrences = preprocess_occurrences(s, t)\n    \n    results = []\n    for l, r in queries:\n        results.append(count_occurrences(occurrences, l, r, m))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 1000000007\n\ndef count_paths(n, k, d):\n    # dp[i] will store the number of ways to get a sum of i using edges with weights from 1 to k\n    dp = [0] * (n + 1)\n    # dp_d[i] will store the number of ways to get a sum of i using at least one edge with weight >= d\n    dp_d = [0] * (n + 1)\n    \n    dp[0] = 1  # There's one way to get a sum of 0: using no edges\n    \n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if i >= j:\n                dp[i] = (dp[i] + dp[i - j]) % MOD\n                if j >= d:\n                    dp_d[i] = (dp_d[i] + dp[i - j]) % MOD\n                else:\n                    dp_d[i] = (dp_d[i] + dp_d[i - j]) % MOD\n    \n    return dp_d[n]\n\n# Read input\nn, k, d = map(int, input().split())\n\n# Calculate and print the result\nprint(count_paths(n, k, d))"}
{"solution": "def encrypt_japanese_crossword(n, row):\n    groups = []\n    count = 0\n    \n    for char in row:\n        if char == 'B':\n            count += 1\n        else:\n            if count > 0:\n                groups.append(count)\n                count = 0\n    \n    if count > 0:\n        groups.append(count)\n    \n    print(len(groups))\n    if groups:\n        print(\" \".join(map(str, groups)))\n\nn = int(input())\nrow = input().strip()\nencrypt_japanese_crossword(n, row)"}
{"solution": "def process_editor_operations(n, m, p, brackets, operations):\n    # Initialize the stack to find pairs of brackets\n    stack = []\n    pair = [-1] * n\n    for i in range(n):\n        if brackets[i] == '(':\n            stack.append(i)\n        else:\n            j = stack.pop()\n            pair[i] = j\n            pair[j] = i\n\n    # Convert the string to a list for easier manipulation\n    brackets = list(brackets)\n    cursor = p - 1\n\n    for op in operations:\n        if op == 'L':\n            cursor -= 1\n        elif op == 'R':\n            cursor += 1\n        elif op == 'D':\n            left = min(cursor, pair[cursor])\n            right = max(cursor, pair[cursor])\n            for i in range(left, right + 1):\n                brackets[i] = ''\n            # Move cursor to the nearest non-deleted bracket\n            if right + 1 < n and brackets[right + 1] != '':\n                cursor = right + 1\n            else:\n                cursor = left - 1\n                while cursor >= 0 and brackets[cursor] == '':\n                    cursor -= 1\n\n    # Join the list to form the final string\n    result = ''.join(brackets)\n    print(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = int(data[2])\nbrackets = data[3]\noperations = data[4]\n\n# Process the operations\nprocess_editor_operations(n, m, p, brackets, operations)"}
{"solution": "def find_valid_y(n, queries):\n    lower_bound = -2 * 10**9\n    upper_bound = 2 * 10**9\n\n    for query in queries:\n        sign, x, answer = query.split()\n        x = int(x)\n        if sign == \">\":\n            if answer == \"Y\":\n                lower_bound = max(lower_bound, x + 1)\n            else:\n                upper_bound = min(upper_bound, x)\n        elif sign == \"<\":\n            if answer == \"Y\":\n                upper_bound = min(upper_bound, x - 1)\n            else:\n                lower_bound = max(lower_bound, x)\n        elif sign == \">=\":\n            if answer == \"Y\":\n                lower_bound = max(lower_bound, x)\n            else:\n                upper_bound = min(upper_bound, x - 1)\n        elif sign == \"<=\":\n            if answer == \"Y\":\n                upper_bound = min(upper_bound, x)\n            else:\n                lower_bound = max(lower_bound, x + 1)\n\n    if lower_bound <= upper_bound:\n        print(lower_bound)\n    else:\n        print(\"Impossible\")\n\n# Read input\nn = int(input().strip())\nqueries = [input().strip() for _ in range(n)]\n\n# Find and print the valid y\nfind_valid_y(n, queries)"}
{"solution": "def count_different_periods(a, b):\n    from math import gcd\n\n    # The total length of the string\n    n = a + b\n\n    # Function to count the number of divisors of a number\n    def count_divisors(x):\n        count = 0\n        for i in range(1, int(x**0.5) + 1):\n            if x % i == 0:\n                count += 1\n                if i != x // i:\n                    count += 1\n        return count\n\n    # The number of different periods is the number of divisors of gcd(a, b)\n    return count_divisors(gcd(a, b))\n\n# Read input\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(count_different_periods(a, b))"}
{"solution": "def generate_names(n, k, conditions):\n    # Predefined list of unique names\n    names = [\"Adam\", \"Bob\", \"Charlie\", \"David\", \"Edward\", \"Frank\", \"George\", \"Henry\", \"Isaac\", \"Jack\",\n             \"Kevin\", \"Larry\", \"Michael\", \"Nathan\", \"Oscar\", \"Paul\", \"Quincy\", \"Robert\", \"Steve\", \"Tom\",\n             \"Ulysses\", \"Victor\", \"Walter\", \"Xander\", \"Yale\", \"Zach\"]\n    \n    # Initialize the result list with the first k names\n    result = names[:k]\n    \n    for i in range(1, n - k + 1):\n        if conditions[i - 1] == \"YES\":\n            # If the group should be effective, add a new unique name\n            result.append(names[k + i - 1])\n        else:\n            # If the group should not be effective, repeat the last name\n            result.append(result[-k + 1])\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\nconditions = input().split()\n\n# Generate and print the names\nnames = generate_names(n, k, conditions)\nprint(\" \".join(names))"}
{"solution": "def min_operations_to_equal(a, b):\n    def count_factors(n, factor):\n        count = 0\n        while n % factor == 0:\n            n //= factor\n            count += 1\n        return count, n\n\n    # Count the number of times we can divide by 2, 3, and 5\n    a2, a = count_factors(a, 2)\n    a3, a = count_factors(a, 3)\n    a5, a = count_factors(a, 5)\n    \n    b2, b = count_factors(b, 2)\n    b3, b = count_factors(b, 3)\n    b5, b = count_factors(b, 5)\n    \n    # If the remaining parts are not equal, return -1\n    if a != b:\n        return -1\n    \n    # Calculate the total number of operations needed\n    operations = abs(a2 - b2) + abs(a3 - b3) + abs(a5 - b5)\n    \n    return operations\n\n# Read input\na, b = map(int, input().split())\n\n# Print the result\nprint(min_operations_to_equal(a, b))"}
{"solution": "def min_cost_to_palindrome(n, a, b, suits):\n    cost = 0\n    for i in range(n // 2):\n        left = suits[i]\n        right = suits[n - i - 1]\n        \n        if left == 2 and right == 2:\n            cost += 2 * min(a, b)\n        elif left == 2:\n            cost += a if right == 0 else b\n        elif right == 2:\n            cost += a if left == 0 else b\n        elif left != right:\n            return -1\n    \n    return cost\n\n# Read input\nn, a, b = map(int, input().split())\nsuits = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = min_cost_to_palindrome(n, a, b, suits)\nprint(result)"}
{"solution": "def paint_cube(k):\n    if k == 1:\n        print(-1)\n        return\n\n    # Initialize the cube with alternating pattern\n    cube = [[['w' if (i + j + l) % 2 == 0 else 'b' for l in range(k)] for j in range(k)] for i in range(k)]\n\n    # Print the cube layer by layer\n    for layer in cube:\n        for row in layer:\n            print(''.join(row))\n        print()\n\n# Read input\nk = int(input().strip())\n\n# Paint the cube\npaint_cube(k)"}
{"solution": "def largest_lovely_number(n):\n    import math\n    from collections import Counter\n\n    def prime_factors(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            while (n % i) == 0:\n                factors.append(i)\n                n //= i\n            i += 1\n        if n > 1:\n            factors.append(n)\n        return factors\n\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n    \n    lovely_number = 1\n    for prime, count in factor_counts.items():\n        lovely_number *= prime\n    \n    return lovely_number\n\n# Read input\nn = int(input())\n# Print the largest lovely number\nprint(largest_lovely_number(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    # Check for adjacent occupied seats\n    for i in range(n - 1):\n        if seating[i] == '1' and seating[i + 1] == '1':\n            return \"No\"\n    \n    # Check for possible additional seating\n    for i in range(n):\n        if seating[i] == '0':\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nn = int(input())\nseating = input().strip()\n\n# Print the result\nprint(is_maximal_seating(n, seating))"}
{"solution": "def find_possible_lengths(n, a):\n    possible_lengths = []\n    \n    for k in range(1, n + 1):\n        valid = True\n        for i in range(k, n):\n            if a[i] - a[i - k] != a[i % k]:\n                valid = False\n                break\n        if valid:\n            possible_lengths.append(k)\n    \n    return possible_lengths\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find possible lengths\npossible_lengths = find_possible_lengths(n, a)\n\n# Print the results\nprint(len(possible_lengths))\nprint(\" \".join(map(str, possible_lengths)))"}
{"solution": "def can_form_equal_teams(scores):\n    from itertools import combinations\n\n    # Generate all possible combinations of 3 participants out of 6\n    for team1 in combinations(scores, 3):\n        team1_score = sum(team1)\n        # The remaining participants form the second team\n        team2 = [score for score in scores if score not in team1 or team1.count(score) > scores.count(score)]\n        if sum(team2) == team1_score:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nscores = list(map(int, input().split()))\n\n# Check if it's possible to form two teams with equal scores\nresult = can_form_equal_teams(scores)\nprint(result)"}
{"solution": "def count_2_3_integers(l, r):\n    count = 0\n    x = 1\n    while x <= r:\n        y = x\n        while y <= r:\n            if y >= l:\n                count += 1\n            y *= 3\n        x *= 2\n    return count\n\n# Read input\nl, r = map(int, input().split())\n\n# Calculate and print the result\nprint(count_2_3_integers(l, r))"}
{"solution": "def find_candies_eaten(n, k):\n    # The total number of candies added to the box follows the series:\n    # 1 + 2 + 3 + ... + m = m * (m + 1) / 2\n    # where m is the number of times candies were added.\n    \n    # We need to find the maximum m such that the sum of the series is less than or equal to n.\n    # This can be found by solving the quadratic equation: m * (m + 1) / 2 <= n\n    # m^2 + m - 2n <= 0\n    # Using the quadratic formula: m = (-1 + sqrt(1 + 8n)) / 2\n    \n    import math\n    \n    m = int((-1 + math.sqrt(1 + 8 * n)) // 2)\n    \n    # Calculate the total number of candies added\n    total_added = m * (m + 1) // 2\n    \n    # Calculate the number of candies eaten\n    candies_eaten = n - (total_added - k)\n    \n    return candies_eaten\n\n# Read input\nn, k = map(int, input().split())\n\n# Find and print the number of candies eaten\nprint(find_candies_eaten(n, k))"}
{"solution": "def can_form_triangle(n, segments):\n    segments.sort()\n    for i in range(n - 2):\n        if segments[i] + segments[i + 1] > segments[i + 2]:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\nsegments = list(map(int, input().split()))\n\n# Check if we can form a non-degenerate triangle\nresult = can_form_triangle(n, segments)\nprint(result)"}
{"solution": "def can_get_toys(x, y):\n    # Check if the number of original toys is at least 1 (since we start with 1 original toy)\n    if y < 1:\n        return \"No\"\n    \n    # Calculate the number of operations needed to get the desired number of original toys\n    original_operations = y - 1\n    \n    # Calculate the number of copies generated from these operations\n    generated_copies = original_operations\n    \n    # Calculate the remaining copies needed\n    remaining_copies = x - generated_copies\n    \n    # Check if the remaining copies can be generated by applying the machine to copies\n    if remaining_copies >= 0 and remaining_copies % 2 == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input\nx, y = map(int, input().split())\n\n# Print the result\nprint(can_get_toys(x, y))"}
{"solution": "def maximize_rating(n, k, skills):\n    # Calculate initial total rating\n    total_rating = sum(skill // 10 for skill in skills)\n    \n    # Calculate units needed to increase each skill to the next multiple of 10\n    units_needed = []\n    for skill in skills:\n        next_multiple_of_10 = ((skill // 10) + 1) * 10\n        if next_multiple_of_10 <= 100:\n            units_needed.append((next_multiple_of_10 - skill, skill))\n    \n    # Sort the units needed in ascending order\n    units_needed.sort()\n    \n    # Use improvement units to maximize the rating\n    for units, skill in units_needed:\n        if k >= units:\n            k -= units\n            total_rating += 1\n        else:\n            break\n    \n    # If there are remaining units, try to use them to increase the skills further\n    for i in range(n):\n        if k > 0 and skills[i] < 100:\n            increase = min(k, 100 - skills[i])\n            k -= increase\n            skills[i] += increase\n    \n    # Recalculate the total rating after using the remaining units\n    total_rating = sum(skill // 10 for skill in skills)\n    \n    return total_rating\n\n# Read input\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Get the maximum total rating\nmax_rating = maximize_rating(n, k, skills)\n\n# Print the result\nprint(max_rating)"}
{"solution": "def find_smallest_pretty_integer(n, m, list1, list2):\n    # Convert lists to sets for faster lookup\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check for common digits\n    common_digits = set1.intersection(set2)\n    if common_digits:\n        return min(common_digits)\n    \n    # If no common digits, find the smallest combination\n    min1 = min(list1)\n    min2 = min(list2)\n    \n    # Form the smallest two-digit number\n    smallest_pretty = min(int(str(min1) + str(min2)), int(str(min2) + str(min1)))\n    return smallest_pretty\n\n# Read input\nn, m = map(int, input().split())\nlist1 = list(map(int, input().split()))\nlist2 = list(map(int, input().split()))\n\n# Find and print the smallest pretty integer\nprint(find_smallest_pretty_integer(n, m, list1, list2))"}
{"solution": "def max_problems_solved(n, k):\n    total_contest_time = 240  # 4 hours in minutes\n    time_available = total_contest_time - k\n    time_spent = 0\n    problems_solved = 0\n\n    for i in range(1, n + 1):\n        time_needed = 5 * i\n        if time_spent + time_needed <= time_available:\n            time_spent += time_needed\n            problems_solved += 1\n        else:\n            break\n\n    return problems_solved\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(max_problems_solved(n, k))"}
{"solution": "def max_teams(n, x, y, a):\n    # \u0421\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u043c\u0430\u0441\u0441\u0438\u0432 a \u0432 \u043f\u043e\u0440\u044f\u0434\u043a\u0435 \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044f\n    a.sort()\n    \n    # \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u0443\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u0434\u043b\u044f \u043e\u0442\u0441\u043b\u0435\u0436\u0438\u0432\u0430\u043d\u0438\u044f \u043e\u0441\u0442\u0430\u0432\u0448\u0438\u0445\u0441\u044f \u043b\u0438\u0441\u0442\u043e\u0432\n    double_sided = x\n    single_sided = y\n    count = 0\n    \n    for pages in a:\n        # \u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c \u043b\u0438\u0441\u0442\u044b \u0441 \u0434\u0432\u0443\u043c\u044f \u0447\u0438\u0441\u0442\u044b\u043c\u0438 \u0441\u0442\u043e\u0440\u043e\u043d\u0430\u043c\u0438\n        double_needed = pages // 2\n        single_needed = pages % 2\n        \n        if double_needed <= double_sided:\n            double_sided -= double_needed\n            if single_needed <= single_sided:\n                single_sided -= single_needed\n                count += 1\n            else:\n                # \u0415\u0441\u043b\u0438 \u043d\u0435 \u0445\u0432\u0430\u0442\u0430\u0435\u0442 \u043b\u0438\u0441\u0442\u043e\u0432 \u0441 \u043e\u0434\u043d\u043e\u0439 \u0447\u0438\u0441\u0442\u043e\u0439 \u0441\u0442\u043e\u0440\u043e\u043d\u043e\u0439\n                double_sided += double_needed  # \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u043b\u0438\u0441\u0442\u044b\n                break\n        else:\n            # \u0415\u0441\u043b\u0438 \u043d\u0435 \u0445\u0432\u0430\u0442\u0430\u0435\u0442 \u043b\u0438\u0441\u0442\u043e\u0432 \u0441 \u0434\u0432\u0443\u043c\u044f \u0447\u0438\u0441\u0442\u044b\u043c\u0438 \u0441\u0442\u043e\u0440\u043e\u043d\u0430\u043c\u0438\n            remaining_pages = pages - 2 * double_sided\n            if remaining_pages <= single_sided:\n                single_sided -= remaining_pages\n                double_sided = 0\n                count += 1\n            else:\n                break\n    \n    return count\n\n# \u0427\u0442\u0435\u043d\u0438\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\ny = int(data[2])\na = list(map(int, data[3:]))\n\n# \u0412\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\nprint(max_teams(n, x, y, a))"}
{"solution": "def count_divisors(n):\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return len(divisors)\n\n# Read input\nb = int(input().strip())\n\n# Calculate the number of distinct values\nresult = count_divisors(b)\n\n# Print the result\nprint(result)"}
{"solution": "def count_fall_positions(n, bumpers):\n    # Initialize counters for positions where the ball will fall off the field\n    fall_left = 0\n    fall_right = 0\n\n    # Check from the left side\n    for i in range(n):\n        if bumpers[i] == '>':\n            break\n        fall_left += 1\n\n    # Check from the right side\n    for i in range(n-1, -1, -1):\n        if bumpers[i] == '<':\n            break\n        fall_right += 1\n\n    # The total number of positions where the ball will fall off the field\n    total_fall_positions = fall_left + fall_right\n    return total_fall_positions\n\n# Read input\nn = int(input())\nbumpers = input().strip()\n\n# Calculate and print the result\nprint(count_fall_positions(n, bumpers))"}
{"solution": "def max_total_area(n, lengths):\n    from collections import Counter\n\n    # Count the frequency of each stick length\n    count = Counter(lengths)\n    \n    # Create a list to store potential sides of rectangles\n    sides = []\n    \n    # Iterate over each length and its count\n    for length, cnt in count.items():\n        # If there are at least 2 sticks of this length, add it to sides\n        if cnt >= 2:\n            sides.append(length)\n        # If there are at least 4 sticks of this length, add it twice to sides\n        if cnt >= 4:\n            sides.append(length)\n    \n    # Sort the sides in descending order\n    sides.sort(reverse=True)\n    \n    # Initialize the total area\n    total_area = 0\n    \n    # Iterate over the sides in pairs to form rectangles\n    i = 0\n    while i < len(sides) - 1:\n        # Form a rectangle with the current and next side\n        total_area += sides[i] * sides[i + 1]\n        # Move to the next pair of sides\n        i += 2\n    \n    return total_area\n\n# Read input\nn = int(input())\nlengths = list(map(int, input().split()))\n\n# Calculate and print the maximum total area\nprint(max_total_area(n, lengths))"}
{"solution": "def restore_numbers(n, encoded_numbers):\n    from collections import defaultdict\n    import heapq\n\n    # Frequency and position importance of each letter\n    freq = defaultdict(int)\n    position_importance = defaultdict(int)\n\n    for number in encoded_numbers:\n        length = len(number)\n        for i, char in enumerate(number):\n            freq[char] += 1\n            position_importance[char] += 10 ** (length - i - 1)\n\n    # Sort letters by their importance (position importance first, then frequency)\n    letters = list(position_importance.keys())\n    letters.sort(key=lambda x: (-position_importance[x], -freq[x]))\n\n    # Assign digits to letters\n    digit_assignment = {}\n    used_digits = set()\n\n    # Ensure no leading zero\n    leading_chars = set(number[0] for number in encoded_numbers)\n    for char in letters:\n        if char in leading_chars:\n            for digit in range(1, 10):\n                if digit not in used_digits:\n                    digit_assignment[char] = digit\n                    used_digits.add(digit)\n                    break\n\n    # Assign remaining digits\n    for char in letters:\n        if char not in digit_assignment:\n            for digit in range(10):\n                if digit not in used_digits:\n                    digit_assignment[char] = digit\n                    used_digits.add(digit)\n                    break\n\n    # Calculate the minimum sum\n    min_sum = 0\n    for number in encoded_numbers:\n        restored_number = int(''.join(str(digit_assignment[char]) for char in number))\n        min_sum += restored_number\n\n    return min_sum\n\n# Read input\nn = int(input().strip())\nencoded_numbers = [input().strip() for _ in range(n)]\n\n# Calculate and print the result\nresult = restore_numbers(n, encoded_numbers)\nprint(result)"}
{"solution": "def max_teams(n, m):\n    # Binary search to find the maximum number of teams\n    low, high = 0, min(n, m, (n + m) // 3)\n    \n    while low < high:\n        mid = (low + high + 1) // 2\n        if mid <= n and mid <= m and 2 * mid <= n + m:\n            low = mid\n        else:\n            high = mid - 1\n    \n    return low\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    n = len(s)\n    \n    # Check for \"AB\" followed by \"BA\"\n    for i in range(n - 1):\n        if s[i:i+2] == \"AB\":\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"BA\":\n                    print(\"YES\")\n                    return\n    \n    # Check for \"BA\" followed by \"AB\"\n    for i in range(n - 1):\n        if s[i:i+2] == \"BA\":\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"AB\":\n                    print(\"YES\")\n                    return\n    \n    # If neither condition is met\n    print(\"NO\")\n\n# Example usage\ns = input().strip()\ncheck_substrings(s)"}
{"solution": "def solve_monsters(n, a, k, b):\n    # Check if the sum of the initial weights matches the sum of the final weights\n    if sum(a) != sum(b):\n        print(\"NO\")\n        return\n\n    # Initialize pointers for the initial and final queues\n    i, j = 0, 0\n    actions = []\n\n    while i < n and j < k:\n        current_sum = 0\n        start = i\n\n        # Try to match the current segment of the initial queue to the current final weight\n        while i < n and current_sum < b[j]:\n            current_sum += a[i]\n            i += 1\n\n        # If the current segment sum does not match the current final weight, it's impossible\n        if current_sum != b[j]:\n            print(\"NO\")\n            return\n\n        # Record the actions for this segment\n        for x in range(start, i - 1):\n            if a[x] < a[x + 1]:\n                actions.append((x + 1, 'R'))\n            else:\n                actions.append((x + 2, 'L'))\n\n        j += 1\n\n    # If we have processed all final weights and initial weights, it's possible\n    if j == k and i == n:\n        print(\"YES\")\n        for action in actions:\n            print(action[0], action[1])\n    else:\n        print(\"NO\")\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\nk = int(input().strip())\nb = list(map(int, input().strip().split()))\n\n# Solve the problem\nsolve_monsters(n, a, k, b)"}
{"solution": "from itertools import permutations\n\ndef ccw(A, B, C):\n    return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])\n\ndef intersect(A, B, C, D):\n    return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D)\n\ndef is_valid_assignment(rebels, bases, assignment):\n    for i in range(len(assignment)):\n        for j in range(i + 1, len(assignment)):\n            if intersect(rebels[i], bases[assignment[i]], rebels[j], bases[assignment[j]]):\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    R = int(data[0])\n    B = int(data[1])\n    \n    rebels = []\n    bases = []\n    \n    index = 2\n    for _ in range(R):\n        x = int(data[index])\n        y = int(data[index + 1])\n        rebels.append((x, y))\n        index += 2\n    \n    for _ in range(B):\n        x = int(data[index])\n        y = int(data[index + 1])\n        bases.append((x, y))\n        index += 2\n    \n    if R != B:\n        print(\"No\")\n        return\n    \n    for perm in permutations(range(B)):\n        if is_valid_assignment(rebels, bases, perm):\n            print(\"Yes\")\n            return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_power_of_two_and_count(n, sequence):\n    def max_power_of_two(x):\n        power = 1\n        while x % 2 == 0:\n            x //= 2\n            power *= 2\n        return power\n\n    max_power = 1\n    for num in sequence:\n        max_power = max(max_power, max_power_of_two(num))\n\n    count = sum(1 for num in sequence if num % max_power == 0)\n    \n    return max_power, count\n\n# Input reading\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Get the result\nresult = max_power_of_two_and_count(n, sequence)\n\n# Print the result\nprint(result[0], result[1])"}
{"solution": "from collections import deque\n\ndef min_clicks(n, m):\n    if n >= m:\n        return n - m\n    \n    visited = [False] * (2 * m + 1)\n    queue = deque([(n, 0)])\n    \n    while queue:\n        current, clicks = queue.popleft()\n        \n        if current == m:\n            return clicks\n        \n        if current * 2 <= 2 * m and not visited[current * 2]:\n            visited[current * 2] = True\n            queue.append((current * 2, clicks + 1))\n        \n        if current - 1 > 0 and not visited[current - 1]:\n            visited[current - 1] = True\n            queue.append((current - 1, clicks + 1))\n\n# Read input\nn, m = map(int, input().split())\n\n# Print the result\nprint(min_clicks(n, m))"}
{"solution": "def find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\ndef is_tree(n, segments):\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            l1, r1 = segments[i]\n            l2, r2 = segments[j]\n            if (l1 < l2 < r1 < r2) or (l2 < l1 < r2 < r1):\n                continue\n            if (l1 < r2 and l2 < r1):\n                edges.append((i, j))\n    \n    if len(edges) != n - 1:\n        return \"NO\"\n    \n    parent = list(range(n))\n    rank = [0] * n\n    \n    for u, v in edges:\n        if find(parent, u) == find(parent, v):\n            return \"NO\"\n        union(parent, rank, u, v)\n    \n    return \"YES\"\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nsegments = []\nindex = 1\nfor i in range(n):\n    l = int(data[index])\n    r = int(data[index + 1])\n    segments.append((l, r))\n    index += 2\n\nprint(is_tree(n, segments))"}
{"solution": "def longest_ddos_period(n, requests):\n    max_length = 0\n    for start in range(n):\n        total_requests = 0\n        for end in range(start, n):\n            total_requests += requests[end]\n            time_period = end - start + 1\n            if total_requests > 100 * time_period:\n                max_length = max(max_length, time_period)\n    return max_length\n\n# Read input\nn = int(input())\nrequests = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(longest_ddos_period(n, requests))"}
{"solution": "def can_dissatisfaction_be_k(n, k, sequence):\n    # Function to check if dissatisfaction can be exactly k\n    def check_dissatisfaction(seq, k):\n        max_dissatisfaction = 0\n        current_dissatisfaction = 0\n        for char in seq:\n            if char == 'N':\n                current_dissatisfaction += 1\n                if current_dissatisfaction > max_dissatisfaction:\n                    max_dissatisfaction = current_dissatisfaction\n            else:\n                current_dissatisfaction = 0\n        return max_dissatisfaction == k\n\n    # Check all possible sequences by replacing '?' with 'Y' or 'N'\n    from itertools import product\n\n    # Generate all possible sequences by replacing '?' with 'Y' or 'N'\n    possible_sequences = []\n    question_marks_indices = [i for i, char in enumerate(sequence) if char == '?']\n    for replacements in product('YN', repeat=len(question_marks_indices)):\n        new_sequence = list(sequence)\n        for index, replacement in zip(question_marks_indices, replacements):\n            new_sequence[index] = replacement\n        possible_sequences.append(''.join(new_sequence))\n\n    # Check each possible sequence\n    for seq in possible_sequences:\n        if check_dissatisfaction(seq, k):\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\nsequence = input().strip()\n\n# Determine if dissatisfaction can be exactly k\nresult = can_dissatisfaction_be_k(n, k, sequence)\nprint(result)"}
{"solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    N = int(data[0])\n    X = int(data[1])\n    D = int(data[2])\n    \n    if D == 0:\n        if X == 0:\n            print(1)\n        else:\n            print(N + 1)\n        return\n    \n    values = set()\n    \n    for k in range(N + 1):\n        S_minus_T = k * (2 * X + (k - 1) * D) - (N - k) * (2 * X + (N - k - 1) * D)\n        values.add(S_minus_T)\n    \n    print(len(values))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def did_anton_perform_good(n, participants):\n    for participant in participants:\n        handle, before, after = participant\n        if before >= 2400 and after > before:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\nparticipants = [input().split() for _ in range(n)]\nparticipants = [(handle, int(before), int(after)) for handle, before, after in participants]\n\n# Determine if Anton performed good\nprint(did_anton_perform_good(n, participants))"}
{"solution": "# Read the input binary number as a string\ns = input().strip()\n\n# Convert the binary string to an integer\ns_decimal = int(s, 2)\n\n# Initialize the count of missed trains\nmissed_trains = 0\n\n# Initialize the departure time of the first train\ndeparture_time = 1\n\n# Count the number of trains that have departed strictly before time s\nwhile departure_time < s_decimal:\n    missed_trains += 1\n    departure_time *= 4\n\n# Print the result\nprint(missed_trains)"}
{"solution": "def min_rows_for_mirroring(n, m, matrix):\n    for x in range(1, n + 1):\n        valid = True\n        for i in range(x):\n            for j in range(m):\n                if matrix[i][j] != matrix[2 * x - i - 1][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return x\n    return n\n\n# Read input\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Find and print the minimum number of rows for matrix b\nprint(min_rows_for_mirroring(n, m, matrix))"}
{"solution": "def max_accepted_orders(n, orders):\n    # Sort orders by their end times\n    orders.sort(key=lambda x: x[1])\n    \n    count = 0\n    last_end_time = 0\n    \n    for start, end in orders:\n        if start > last_end_time:\n            count += 1\n            last_end_time = end\n    \n    return count\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\norders = [(int(data[i]), int(data[i+1])) for i in range(1, len(data), 2)]\n\n# Get the result\nresult = max_accepted_orders(n, orders)\n\n# Print the result\nprint(result)"}
{"solution": "def can_rearrange(n, k, tables, formulas):\n    # Initialize the current streaks of tables and formulas\n    current_tables_streak = 0\n    current_formulas_streak = 0\n\n    for i in range(n):\n        # Check if we can place tables and formulas on the current page without exceeding k\n        if tables[i] > k and formulas[i] > k:\n            return \"NO\"\n        \n        # Update the current streaks\n        if tables[i] > k:\n            current_tables_streak = tables[i]\n            current_formulas_streak = 0\n        elif formulas[i] > k:\n            current_formulas_streak = formulas[i]\n            current_tables_streak = 0\n        else:\n            # If both are less than or equal to k, we need to check the combined streaks\n            if current_tables_streak + tables[i] > k and current_formulas_streak + formulas[i] > k:\n                return \"NO\"\n            # Update the streaks\n            current_tables_streak = min(current_tables_streak + tables[i], tables[i])\n            current_formulas_streak = min(current_formulas_streak + formulas[i], formulas[i])\n    \n    return \"YES\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\ntables = list(map(int, data[2:n+2]))\nformulas = list(map(int, data[n+2:2*n+2]))\n\n# Determine if Vova can rearrange the tables and formulas\nresult = can_rearrange(n, k, tables, formulas)\nprint(result)"}
{"solution": "def can_human_win(n, k, coefficients):\n    # Check if the polynomial is already fully defined\n    fully_defined = all(c != '?' for c in coefficients)\n    \n    if fully_defined:\n        # Evaluate P(k) to check if P(x) is divisible by Q(x) = x - k\n        P_k = sum(int(coefficients[i]) * (k ** i) for i in range(n + 1))\n        return P_k == 0\n    \n    # If there are undefined coefficients, human can always set them to make P(k) = 0\n    return True\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\ncoefficients = data[2:]\n\n# Determine if human can guarantee a win\nif can_human_win(n, k, coefficients):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def smallest_starting_number(X_2):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def get_primes_less_than(n):\n        primes = []\n        for i in range(2, n):\n            if is_prime(i):\n                primes.append(i)\n        return primes\n\n    primes = get_primes_less_than(X_2)\n    min_X0 = float('inf')\n\n    for p1 in primes:\n        X1 = (X_2 // p1) * p1\n        if X1 < X_2:\n            X1 += p1\n        for p2 in primes:\n            if p2 >= X1:\n                break\n            X0 = (X1 // p2) * p2\n            if X0 < X1:\n                X0 += p2\n            if X0 >= 3:\n                min_X0 = min(min_X0, X0)\n\n    return min_X0\n\n# Read input\nX_2 = int(input().strip())\n\n# Compute and print the result\nprint(smallest_starting_number(X_2))"}
{"solution": "def min_p_binary_summands(n, p):\n    for k in range(1, 1001):\n        remaining = n - k * p\n        if remaining < 0:\n            continue\n        if bin(remaining).count('1') <= k and k <= remaining:\n            return k\n    return -1\n\n# Read input\nn, p = map(int, input().split())\n\n# Get the result\nresult = min_p_binary_summands(n, p)\n\n# Print the result\nprint(result)"}
{"solution": "def minimize_integer(n, k, S):\n    # Convert the string S to a list of characters for easy manipulation\n    S = list(S)\n    \n    # Initialize the number of changes made\n    changes = 0\n    \n    # Iterate through each digit of S\n    for i in range(n):\n        if changes >= k:\n            break\n        if i == 0:\n            # The first digit should be 1 if n > 1, otherwise it can be 0\n            if S[i] != '1':\n                S[i] = '1'\n                changes += 1\n        else:\n            # Other digits should be 0\n            if S[i] != '0':\n                S[i] = '0'\n                changes += 1\n    \n    # Join the list back into a string and return\n    return ''.join(S)\n\n# Read input\nn, k = map(int, input().split())\nS = input().strip()\n\n# Get the minimal possible value of S\nresult = minimize_integer(n, k, S)\n\n# Print the result\nprint(result)"}
{"solution": "def find_min_v(cnt_1, cnt_2, x, y):\n    def count_valid_numbers(v, prime):\n        return v // prime\n\n    def count_valid_numbers_both(v, prime1, prime2):\n        return v // (prime1 * prime2)\n\n    left, right = 1, 2 * (cnt_1 + cnt_2)\n    while left < right:\n        mid = (left + right) // 2\n        total_x = count_valid_numbers(mid, x)\n        total_y = count_valid_numbers(mid, y)\n        total_xy = count_valid_numbers_both(mid, x, y)\n        \n        valid_for_first = mid - total_x\n        valid_for_second = mid - total_y\n        valid_for_both = mid - total_x - total_y + total_xy\n        \n        if valid_for_first >= cnt_1 and valid_for_second >= cnt_2 and valid_for_both >= cnt_1 + cnt_2:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Read input\ncnt_1, cnt_2, x, y = map(int, input().strip().split())\n\n# Find and print the result\nprint(find_min_v(cnt_1, cnt_2, x, y))"}
{"solution": "def bear_walk(n, sx, sy, dx, dy, t):\n    x, y = sx, sy\n    for _ in range(t):\n        k = x + y\n        dx += k\n        dy += k\n        x = ((x + dx - 1) % n) + 1\n        y = ((y + dy - 1) % n) + 1\n    return x, y\n\n# Read input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Get the final position\nfinal_x, final_y = bear_walk(n, sx, sy, dx, dy, t)\n\n# Print the result\nprint(final_x, final_y)"}
{"solution": "def find_nice_word(s):\n    n = len(s)\n    if n < 26:\n        print(-1)\n        return\n\n    alphabet = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    \n    for i in range(n - 25):\n        substring = s[i:i+26]\n        missing_letters = alphabet.copy()\n        question_marks = 0\n        \n        for char in substring:\n            if char == '?':\n                question_marks += 1\n            else:\n                missing_letters.discard(char)\n        \n        if len(missing_letters) == question_marks:\n            result = list(s)\n            missing_letters = list(missing_letters)\n            for j in range(26):\n                if result[i + j] == '?':\n                    result[i + j] = missing_letters.pop()\n            for k in range(n):\n                if result[k] == '?':\n                    result[k] = 'A'\n            print(''.join(result))\n            return\n    \n    print(-1)\n\n# Read input\ns = input().strip()\nfind_nice_word(s)"}
{"solution": "def can_divide_apples(n, weights):\n    count_100 = weights.count(100)\n    count_200 = weights.count(200)\n    \n    # Check if the total weight is even\n    total_weight = count_100 * 100 + count_200 * 200\n    if total_weight % 2 != 0:\n        return \"NO\"\n    \n    # We need to check if we can split the apples into two groups with equal weight\n    half_weight = total_weight // 2\n    \n    # Try to use as many 200g apples as possible to reach half_weight\n    if half_weight % 200 <= count_100 * 100 and half_weight // 200 <= count_200:\n        return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\nweights = list(map(int, input().split()))\n\n# Print the result\nprint(can_divide_apples(n, weights))"}
{"solution": "def min_time_to_turn_off_lights(n, m, building):\n    # Initialize the total time\n    total_time = 0\n    \n    # Current position of Sagheer (starting at the left stairs of the ground floor)\n    current_floor = n - 1\n    current_position = 0\n    \n    # Process each floor from the ground floor to the top floor\n    for floor in range(n):\n        # Get the current floor's light status\n        lights = building[current_floor]\n        \n        # Find the leftmost and rightmost lights that are on\n        leftmost = lights.find('1')\n        rightmost = lights.rfind('1')\n        \n        if leftmost == -1:\n            # If no lights are on this floor, just move to the next floor\n            total_time += 1\n        else:\n            # Calculate the time to turn off all lights on this floor\n            if current_position == 0:\n                # If Sagheer is at the left stairs\n                total_time += rightmost\n                total_time += rightmost - leftmost\n                current_position = rightmost\n            else:\n                # If Sagheer is at the right stairs\n                total_time += m + 1 - leftmost\n                total_time += rightmost - leftmost\n                current_position = leftmost\n            \n            # Move to the next floor\n            total_time += 1\n        \n        # Move to the next floor\n        current_floor -= 1\n    \n    # Return the total time\n    return total_time\n\n# Read input\nn, m = map(int, input().split())\nbuilding = [input().strip() for _ in range(n)]\n\n# Calculate and print the minimum total time\nprint(min_time_to_turn_off_lights(n, m, building))"}
{"solution": "def find_min_trap_cost(n, costs, transitions):\n    visited = [False] * n\n    in_stack = [False] * n\n    min_cost = 0\n\n    def dfs(node):\n        stack = []\n        while True:\n            if visited[node]:\n                if in_stack[node]:\n                    # Found a cycle, calculate the minimum cost in this cycle\n                    cycle_min_cost = float('inf')\n                    while stack:\n                        cycle_node = stack.pop()\n                        in_stack[cycle_node] = False\n                        cycle_min_cost = min(cycle_min_cost, costs[cycle_node])\n                        if cycle_node == node:\n                            break\n                    return cycle_min_cost\n                else:\n                    return 0\n            visited[node] = True\n            in_stack[node] = True\n            stack.append(node)\n            node = transitions[node] - 1\n\n    for i in range(n):\n        if not visited[i]:\n            min_cost += dfs(i)\n\n    return min_cost\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(find_min_trap_cost(n, costs, transitions))"}
{"solution": "def find_entrance(n, a, b):\n    # Calculate the final position using modular arithmetic\n    final_position = (a + b - 1) % n + 1\n    return final_position\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Find and print the entrance number\nprint(find_entrance(n, a, b))"}
{"solution": "def min_arithmetic_progressions(n, a):\n    # Helper function to determine if a segment is an arithmetic progression\n    def is_arithmetic_progression(segment):\n        if len(segment) <= 1:\n            return True\n        diff = None\n        for i in range(1, len(segment)):\n            if segment[i] == -1 or segment[i-1] == -1:\n                continue\n            current_diff = segment[i] - segment[i-1]\n            if diff is None:\n                diff = current_diff\n            elif diff != current_diff:\n                return False\n        return True\n\n    # Initialize the count of arithmetic progressions\n    count = 0\n    i = 0\n\n    while i < n:\n        # Find the start of the next arithmetic progression\n        while i < n and a[i] == -1:\n            i += 1\n        if i == n:\n            count += 1\n            break\n\n        # Determine the end of the current arithmetic progression\n        j = i + 1\n        while j < n and (a[j] == -1 or is_arithmetic_progression(a[i:j+1])):\n            j += 1\n\n        # Increment the count of arithmetic progressions\n        count += 1\n        i = j\n\n    return count\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = min_arithmetic_progressions(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def max_beauty(n, k, s):\n    def max_length_with_char(char):\n        max_len = 0\n        left = 0\n        count = 0\n\n        for right in range(n):\n            if s[right] != char:\n                count += 1\n\n            while count > k:\n                if s[left] != char:\n                    count -= 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n\n        return max_len\n\n    return max(max_length_with_char('a'), max_length_with_char('b'))\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Calculate and print the result\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, seats):\n    alice_seats = seats[0]\n    total_seats = sum(seats)\n    majority_seats = total_seats // 2 + 1\n\n    coalition = [1]\n    coalition_seats = alice_seats\n\n    for i in range(1, n):\n        if alice_seats >= 2 * seats[i]:\n            coalition.append(i + 1)\n            coalition_seats += seats[i]\n\n    if coalition_seats >= majority_seats:\n        print(len(coalition))\n        print(\" \".join(map(str, coalition)))\n    else:\n        print(0)\n\n# Read input\nn = int(input())\nseats = list(map(int, input().split()))\n\n# Find and print the coalition\nfind_coalition(n, seats)"}
{"solution": "def max_reward(n):\n    harmonic_sum = 0.0\n    for i in range(1, n + 1):\n        harmonic_sum += 1.0 / i\n    return harmonic_sum\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the maximum reward\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "def distribute_candies(n):\n    k = 0\n    total = 0\n    while total + (k + 1) <= n:\n        k += 1\n        total += k\n\n    candies = list(range(1, k + 1))\n    remaining = n - total\n\n    if remaining > 0:\n        candies[-1] += remaining\n\n    print(k)\n    print(\" \".join(map(str, candies)))\n\n# Read input\nn = int(input().strip())\ndistribute_candies(n)"}
{"solution": "# Read input values\nn = int(input())\nm = int(input())\n\n# Calculate 2^n\npower_of_two = 1 << n\n\n# Calculate m % 2^n\nresult = m % power_of_two\n\n# Print the result\nprint(result)"}
{"solution": "def correct_word(n, s):\n    vowels = set('aeiouy')\n    result = []\n    \n    i = 0\n    while i < n:\n        if i < n - 1 and s[i] in vowels and s[i + 1] in vowels:\n            i += 1\n        else:\n            result.append(s[i])\n        i += 1\n    \n    return ''.join(result)\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the corrected word\ncorrected_word = correct_word(n, s)\n\n# Print the result\nprint(corrected_word)"}
{"solution": "def max_students(n, a, b, seats):\n    segments = []\n    i = 0\n    \n    # Identify segments of empty seats\n    while i < n:\n        if seats[i] == '.':\n            start = i\n            while i < n and seats[i] == '.':\n                i += 1\n            segments.append(i - start)\n        else:\n            i += 1\n    \n    total_students = 0\n    \n    # Place students in each segment\n    for length in segments:\n        # Calculate the number of students that can be placed in this segment\n        # We will place students in an alternating fashion\n        if a > b:\n            # Start with a student-programmer if more student-programmers are available\n            programmers = (length + 1) // 2\n            athletes = length // 2\n        else:\n            # Start with a student-athlete if more student-athletes are available\n            athletes = (length + 1) // 2\n            programmers = length // 2\n        \n        # Place the students\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n        \n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n    \n    return total_students\n\n# Read input\nn, a, b = map(int, input().split())\nseats = input().strip()\n\n# Calculate and print the result\nprint(max_students(n, a, b, seats))"}
{"solution": "def find_xy(r):\n    for x in range(1, int(r**0.5) + 1):\n        # Calculate the value of H(x, y) for given x and solve for y\n        # H(x, y) = x^2 + 2xy + x + 1\n        # Rearrange to find y: 2xy + x = r - x^2 - x - 1\n        # 2xy = r - x^2 - x - 1\n        # y = (r - x^2 - x - 1) / (2x)\n        remaining = r - x**2 - x - 1\n        if remaining > 0 and remaining % (2 * x) == 0:\n            y = remaining // (2 * x)\n            if y > 0:\n                return x, y\n    return \"NO\"\n\n# Read input\nr = int(input().strip())\n\n# Find and print the result\nresult = find_xy(r)\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "from itertools import combinations\n\ndef divide_balloons(n, a):\n    total_sum = sum(a)\n    \n    # If there's only one packet, it's impossible to divide\n    if n == 1:\n        return -1\n    \n    # Try all possible ways to divide the packets\n    for i in range(1, n):\n        for comb in combinations(range(n), i):\n            sum_grigory = sum(a[j] for j in comb)\n            sum_andrew = total_sum - sum_grigory\n            \n            # Ensure both get at least one packet and the sums are not equal\n            if sum_grigory != sum_andrew:\n                return (len(comb), [j + 1 for j in comb])\n    \n    return -1\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = divide_balloons(n, a)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    print(result[0])\n    print(\" \".join(map(str, result[1])))"}
{"solution": "def split_number(n):\n    # The optimal way to minimize the number of different digits is to use the largest digit possible, which is 9.\n    # We will use as many 9s as possible and then handle the remainder.\n    \n    # Calculate the number of 9s we can use\n    num_nines = n // 9\n    remainder = n % 9\n    \n    # If there is a remainder, we need to include it as an additional digit\n    if remainder > 0:\n        result = [9] * num_nines + [remainder]\n    else:\n        result = [9] * num_nines\n    \n    # Output the result\n    print(len(result))\n    print(\" \".join(map(str, result)))\n\n# Read input\nn = int(input().strip())\n\n# Call the function to split the number\nsplit_number(n)"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_max_simple_subset(arr):\n    n = len(arr)\n    arr.sort()\n    max_subset = []\n    \n    for i in range(n):\n        current_subset = [arr[i]]\n        for j in range(i + 1, n):\n            valid = True\n            for k in current_subset:\n                if not is_prime(k + arr[j]):\n                    valid = False\n                    break\n            if valid:\n                current_subset.append(arr[j])\n        if len(current_subset) > len(max_subset):\n            max_subset = current_subset\n    \n    return max_subset\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum size simple subset\nresult = find_max_simple_subset(a)\n\n# Print the result\nprint(len(result))\nprint(' '.join(map(str, result)))"}
{"solution": "def greatest_beautiful_divisor(n):\n    def is_beautiful(num):\n        k = 1\n        while True:\n            beautiful_num = (2**k - 1) * (2**(k-1))\n            if beautiful_num > num:\n                break\n            if num % beautiful_num == 0:\n                return beautiful_num\n            k += 1\n        return 1\n\n    return is_beautiful(n)\n\n# Read input\nn = int(input().strip())\n\n# Find and print the greatest beautiful divisor\nprint(greatest_beautiful_divisor(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef is_d_magic(number, d):\n    number_str = str(number)\n    for i in range(len(number_str)):\n        if i % 2 == 1 and number_str[i] != str(d):\n            return False\n        if i % 2 == 0 and number_str[i] == str(d):\n            return False\n    return True\n\ndef count_d_magic_numbers(m, d, a, b):\n    count = 0\n    for number in range(int(a), int(b) + 1):\n        if number % m == 0 and is_d_magic(number, d):\n            count = (count + 1) % MOD\n    return count\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    m = int(data[0])\n    d = int(data[1])\n    a = data[2]\n    b = data[3]\n    \n    result = count_d_magic_numbers(m, d, a, b)\n    print(result)"}
{"solution": "def find_last_child(n, m, candies):\n    from collections import deque\n\n    queue = deque([(i + 1, candies[i]) for i in range(n)])\n    \n    while len(queue) > 1:\n        child, required_candies = queue.popleft()\n        required_candies -= m\n        if required_candies > 0:\n            queue.append((child, required_candies))\n    \n    return queue[0][0]\n\n# Read input\nn, m = map(int, input().split())\ncandies = list(map(int, input().split()))\n\n# Find and print the last child\nprint(find_last_child(n, m, candies))"}
{"solution": "def minimum_bills(n):\n    denominations = [100, 20, 10, 5, 1]\n    count = 0\n    \n    for denom in denominations:\n        count += n // denom\n        n %= denom\n    \n    return count\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the minimum number of bills\nprint(minimum_bills(n))"}
{"solution": "MOD = 1000000007\n\ndef count_permutations_with_k_good_positions(n, k):\n    # Initialize dp array\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            dp[i][j] = dp[i - 1][j]  # Case when i-th position is not good\n            if j > 0 and i > 1:\n                dp[i][j] = (dp[i][j] + dp[i - 2][j - 1] * (i - 1)) % MOD  # Case when i-th position is good\n    \n    return dp[n][k]\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(count_permutations_with_k_good_positions(n, k))"}
{"solution": "def max_beauty(n, k, beauties, colors):\n    white_roses = []\n    orange_roses = []\n    red_roses = []\n\n    for i in range(n):\n        if colors[i] == 'W':\n            white_roses.append(beauties[i])\n        elif colors[i] == 'O':\n            orange_roses.append(beauties[i])\n        elif colors[i] == 'R':\n            red_roses.append(beauties[i])\n\n    white_roses.sort(reverse=True)\n    orange_roses.sort(reverse=True)\n    red_roses.sort(reverse=True)\n\n    max_beauty = -1\n\n    for w in range(min(k, len(white_roses)) + 1):\n        for r in range(min(k - w, len(red_roses)) + 1):\n            o = k - w - r\n            if o > len(orange_roses):\n                continue\n            if (w > 0 and r > 0) or (w == 0 and r == 0):\n                continue\n            current_beauty = sum(white_roses[:w]) + sum(orange_roses[:o]) + sum(red_roses[:r])\n            max_beauty = max(max_beauty, current_beauty)\n\n    return max_beauty\n\n# Read input\nn, k = map(int, input().split())\nbeauties = list(map(int, input().split()))\ncolors = input().strip()\n\n# Compute and print the result\nresult = max_beauty(n, k, beauties, colors)\nprint(result)"}
{"solution": "def compare_fractions(p, q, n, a):\n    # Function to convert continued fraction to a simple fraction\n    def continued_fraction_to_fraction(a):\n        num, denom = 1, a[-1]\n        for i in range(n-2, -1, -1):\n            num, denom = denom, a[i] * denom + num\n        return denom, num\n\n    # Convert the continued fraction to a simple fraction\n    cf_num, cf_denom = continued_fraction_to_fraction(a)\n\n    # Compare the two fractions\n    if p * cf_denom == q * cf_num:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\np, q = map(int, input().split())\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the result of the comparison\nprint(compare_fractions(p, q, n, a))"}
{"solution": "def solve_expression(expression):\n    parts = expression.split('+')\n    A = len(parts[0])\n    B, C = map(len, parts[1].split('='))\n    \n    if A + B == C:\n        print(expression)\n        return\n    \n    # Try to shift one stick from A to B or C\n    if A > 1:\n        if A - 1 + B == C + 1:\n            print('|' * (A - 1) + '+' + '|' * B + '=' + '|' * (C + 1))\n            return\n        if A - 1 + B + 1 == C:\n            print('|' * (A - 1) + '+' + '|' * (B + 1) + '=' + '|' * C)\n            return\n    \n    # Try to shift one stick from B to A or C\n    if B > 1:\n        if A + B - 1 == C + 1:\n            print('|' * A + '+' + '|' * (B - 1) + '=' + '|' * (C + 1))\n            return\n        if A + B - 1 + 1 == C:\n            print('|' * (A + 1) + '+' + '|' * (B - 1) + '=' + '|' * C)\n            return\n    \n    # Try to shift one stick from C to A or B\n    if C > 1:\n        if A + B == C - 1 + 1:\n            print('|' * A + '+' + '|' * (B + 1) + '=' + '|' * (C - 1))\n            return\n        if A + B + 1 == C - 1:\n            print('|' * (A + 1) + '+' + '|' * B + '=' + '|' * (C - 1))\n            return\n    \n    print(\"Impossible\")\n\n# Read input\nexpression = input().strip()\nsolve_expression(expression)"}
{"solution": "MOD = 10**9 + 7\n\ndef count_permutations_with_oddness(n, k):\n    # Initialize DP table\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    # Fill DP table\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            for m in range(i):\n                if j >= abs(i - (m + 1)):\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - abs(i - (m + 1))]) % MOD\n\n    return dp[n][k]\n\n# Read input\nimport sys\ninput = sys.stdin.read\nn, k = map(int, input().split())\n\n# Calculate and print the result\nresult = count_permutations_with_oddness(n, k)\nprint(result)"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    points = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N)]\n    \n    # Check if all points have the same parity\n    parity = (points[0][0] + points[0][1]) % 2\n    for x, y in points:\n        if (x + y) % 2 != parity:\n            print(-1)\n            return\n    \n    # Determine the number of sections and their lengths\n    m = 40\n    d = [1 << i for i in range(m)]\n    \n    # Generate the directions for each point\n    directions = []\n    for x, y in points:\n        w = []\n        for length in reversed(d):\n            if abs(x) > abs(y):\n                if x > 0:\n                    w.append('R')\n                    x -= length\n                else:\n                    w.append('L')\n                    x += length\n            else:\n                if y > 0:\n                    w.append('U')\n                    y -= length\n                else:\n                    w.append('D')\n                    y += length\n        directions.append(''.join(reversed(w)))\n    \n    # Output the result\n    print(m)\n    print(' '.join(map(str, d)))\n    for direction in directions:\n        print(direction)\n\n# Call the solve function\nsolve()"}
{"solution": "def replace_fillers(n, s):\n    result = []\n    i = 0\n    while i < n:\n        if s[i:i+3] == 'ogo':\n            result.append('***')\n            i += 3\n            while i + 1 < n and s[i:i+2] == 'go':\n                i += 2\n        else:\n            result.append(s[i])\n            i += 1\n    print(''.join(result))\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Replace fillers and print the result\nreplace_fillers(n, s)"}
{"solution": "MOD = 10**9 + 7\n\ndef prime_factors(x):\n    factors = set()\n    d = 2\n    while d * d <= x:\n        while (x % d) == 0:\n            factors.add(d)\n            x //= d\n        d += 1\n    if x > 1:\n        factors.add(x)\n    return factors\n\ndef g(y, p):\n    power = 1\n    while y % (p ** power) == 0:\n        power += 1\n    return p ** (power - 1)\n\ndef f(x, y):\n    primes = prime_factors(x)\n    result = 1\n    for p in primes:\n        result *= g(y, p)\n        result %= MOD\n    return result\n\ndef calculate_product(x, n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= f(x, i)\n        result %= MOD\n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    x, n = map(int, input().strip().split())\n    print(calculate_product(x, n))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for s in range(1, 82):  # s(x) can be at most 81\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and sum_of_digits(x) == s:\n            solutions.append(x)\n    solutions.sort()\n    return solutions\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find solutions\nsolutions = find_solutions(a, b, c)\n\n# Print results\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "def is_solved(cube):\n    for i in range(0, 24, 4):\n        if len(set(cube[i:i+4])) != 1:\n            return False\n    return True\n\ndef rotate(cube, face):\n    new_cube = cube[:]\n    if face == 0:  # Front face\n        new_cube[0], new_cube[1], new_cube[2], new_cube[3] = cube[2], cube[0], cube[3], cube[1]\n        new_cube[8], new_cube[9], new_cube[20], new_cube[21] = cube[20], cube[21], cube[9], cube[8]\n        new_cube[10], new_cube[11], new_cube[22], new_cube[23] = cube[22], cube[23], cube[11], cube[10]\n    elif face == 1:  # Back face\n        new_cube[4], new_cube[5], new_cube[6], new_cube[7] = cube[6], cube[4], cube[7], cube[5]\n        new_cube[12], new_cube[13], new_cube[16], new_cube[17] = cube[16], cube[17], cube[13], cube[12]\n        new_cube[14], new_cube[15], new_cube[18], new_cube[19] = cube[18], cube[19], cube[15], cube[14]\n    elif face == 2:  # Left face\n        new_cube[8], new_cube[9], new_cube[10], new_cube[11] = cube[10], cube[8], cube[11], cube[9]\n        new_cube[0], new_cube[2], new_cube[16], new_cube[18] = cube[16], cube[18], cube[2], cube[0]\n        new_cube[4], new_cube[6], new_cube[20], new_cube[22] = cube[20], cube[22], cube[6], cube[4]\n    elif face == 3:  # Right face\n        new_cube[12], new_cube[13], new_cube[14], new_cube[15] = cube[14], cube[12], cube[15], cube[13]\n        new_cube[1], new_cube[3], new_cube[17], new_cube[19] = cube[17], cube[19], cube[3], cube[1]\n        new_cube[5], new_cube[7], new_cube[21], new_cube[23] = cube[21], cube[23], cube[7], cube[5]\n    elif face == 4:  # Top face\n        new_cube[16], new_cube[17], new_cube[18], new_cube[19] = cube[18], cube[16], cube[19], cube[17]\n        new_cube[0], new_cube[1], new_cube[12], new_cube[13] = cube[12], cube[13], cube[1], cube[0]\n        new_cube[4], new_cube[5], new_cube[8], new_cube[9] = cube[8], cube[9], cube[5], cube[4]\n    elif face == 5:  # Bottom face\n        new_cube[20], new_cube[21], new_cube[22], new_cube[23] = cube[22], cube[20], cube[23], cube[21]\n        new_cube[2], new_cube[3], new_cube[14], new_cube[15] = cube[14], cube[15], cube[3], cube[2]\n        new_cube[6], new_cube[7], new_cube[10], new_cube[11] = cube[10], cube[11], cube[7], cube[6]\n    return new_cube\n\ndef can_be_solved_with_one_rotation(cube):\n    for face in range(6):\n        rotated_cube = rotate(cube, face)\n        if is_solved(rotated_cube):\n            return True\n    return False\n\n# Read input\ncube = list(map(int, input().split()))\n\n# Check if the cube can be solved with one rotation\nif can_be_solved_with_one_rotation(cube):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def will_get_tshirt(p, s):\n    i = (s // 50) % 475\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        if 26 + i == p:\n            return True\n    return False\n\ndef min_successful_hacks(p, x, y):\n    for k in range(0, 1000):\n        for m in range(0, k + 1):\n            new_score = x + 100 * m - 50 * (k - m)\n            if new_score >= y and will_get_tshirt(p, new_score):\n                return m\n    return -1\n\n# Read input\np, x, y = map(int, input().split())\n\n# Calculate and print the result\nprint(min_successful_hacks(p, x, y))"}
{"solution": "def min_distance(n, a, b, c):\n    if n == 1:\n        return 0\n    # Calculate the minimum distance for the first move\n    min_first_move = min(a, b)\n    # Calculate the minimum distance for the remaining moves\n    min_remaining_moves = (n - 2) * min(a, b, c)\n    return min_first_move + min_remaining_moves\n\n# Read input values\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate and print the minimum distance\nprint(min_distance(n, a, b, c))"}
{"solution": "# Read input\nx1, x2, x3 = map(int, input().split())\n\n# Sort the coordinates\ncoordinates = sorted([x1, x2, x3])\n\n# The optimal meeting point is the median of the three points\nmeeting_point = coordinates[1]\n\n# Calculate the total distance\ntotal_distance = abs(x1 - meeting_point) + abs(x2 - meeting_point) + abs(x3 - meeting_point)\n\n# Print the result\nprint(total_distance)"}
{"solution": "def minimal_operations(n, x, arr):\n    from collections import defaultdict\n\n    # Dictionary to count occurrences of each element\n    count = defaultdict(int)\n    for num in arr:\n        count[num] += 1\n\n    # If any element appears at least twice, no operation is needed\n    for num in count:\n        if count[num] > 1:\n            return 0\n\n    # Dictionary to count occurrences of each element after AND operation\n    and_count = defaultdict(int)\n    for num in arr:\n        and_count[num & x] += 1\n\n    # Check if any element after AND operation appears at least twice\n    for num in and_count:\n        if and_count[num] > 1:\n            return 1\n\n    # Check if any element after AND operation matches any original element\n    for num in arr:\n        if and_count[num] > 0:\n            return 1\n\n    # If no solution found, return -1\n    return -1\n\n# Read input\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Get the result and print it\nresult = minimal_operations(n, x, arr)\nprint(result)"}
{"solution": "def is_single_plus(h, w, grid):\n    def is_valid_center(x, y):\n        if grid[x][y] != '*':\n            return False\n        # Check for rays in all four directions\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if not (0 <= nx < h and 0 <= ny < w and grid[nx][ny] == '*'):\n                return False\n        return True\n\n    def mark_plus(x, y):\n        # Mark the center\n        grid[x][y] = '.'\n        # Mark the rays\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            while 0 <= nx < h and 0 <= ny < w and grid[nx][ny] == '*':\n                grid[nx][ny] = '.'\n                nx += dx\n                ny += dy\n\n    # Find the center of the plus\n    center_found = False\n    for i in range(h):\n        for j in range(w):\n            if is_valid_center(i, j):\n                if center_found:\n                    return \"NO\"\n                center_found = True\n                mark_plus(i, j)\n\n    # Check if there are any remaining non-empty cells\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*':\n                return \"NO\"\n\n    return \"YES\" if center_found else \"NO\"\n\n# Read input\nh, w = map(int, input().split())\ngrid = [list(input().strip()) for _ in range(h)]\n\n# Determine if the picture has a single \"+\" shape\nresult = is_single_plus(h, w, grid)\nprint(result)"}
{"solution": "def solve(n, a, b):\n    if a + b > n + 1:\n        print(\"NO\")\n        return\n    if a == 1 and b == 1:\n        if n == 1:\n            print(\"YES\")\n            print(\"0\")\n        else:\n            print(\"NO\")\n        return\n    if a == 1 or b == 1:\n        print(\"YES\")\n        matrix = [[0] * n for _ in range(n)]\n        if a == 1:\n            for i in range(1, n):\n                matrix[i][i-1] = matrix[i-1][i] = 1\n        else:\n            for i in range(n-1):\n                matrix[i][i+1] = matrix[i+1][i] = 1\n        for row in matrix:\n            print(\"\".join(map(str, row)))\n        return\n    if a > 1 and b > 1:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    matrix = [[0] * n for _ in range(n)]\n    if a == 1:\n        for i in range(1, n):\n            matrix[i][i-1] = matrix[i-1][i] = 1\n        for i in range(n - b + 1, n):\n            matrix[i][i-1] = matrix[i-1][i] = 0\n    else:\n        for i in range(n-1):\n            matrix[i][i+1] = matrix[i+1][i] = 1\n        for i in range(b - 1):\n            matrix[i][i+1] = matrix[i+1][i] = 0\n    for row in matrix:\n        print(\"\".join(map(str, row)))\n\n# Read input\nn, a, b = map(int, input().split())\nsolve(n, a, b)"}
{"solution": "def minimum_problems(c, d, n, m, k):\n    required_finalists = n * m\n    remaining_finalists = required_finalists - k\n\n    if remaining_finalists <= 0:\n        return 0\n\n    min_problems = float('inf')\n\n    for main_rounds in range(remaining_finalists // n + 2):\n        additional_finalists_needed = remaining_finalists - main_rounds * n\n        if additional_finalists_needed <= 0:\n            additional_rounds = 0\n        else:\n            additional_rounds = (additional_finalists_needed + 1) // 1\n\n        total_problems = main_rounds * c + additional_rounds * d\n        min_problems = min(min_problems, total_problems)\n\n    return min_problems\n\nif __name__ == \"__main__\":\n    c, d = map(int, input().split())\n    n, m = map(int, input().split())\n    k = int(input())\n    print(minimum_problems(c, d, n, m, k))"}
{"solution": "def find_grid(s):\n    if len(s) != 27:\n        return \"Impossible\"\n\n    # Create a 2x13 grid initialized with empty strings\n    grid = [['' for _ in range(13)] for _ in range(2)]\n    \n    # Try to place the first 13 characters in the first row\n    for i in range(13):\n        grid[0][i] = s[i]\n    \n    # Try to place the next 13 characters in the second row\n    for i in range(13):\n        grid[1][i] = s[13 + i]\n    \n    # The last character should be placed in the first row at the end\n    grid[0].append(s[26])\n    \n    # Check if the path exists\n    def is_adjacent(x1, y1, x2, y2):\n        return abs(x1 - x2) <= 1 and abs(y1 - y2) <= 1 and not (x1 == x2 and y1 == y2)\n    \n    def find_path(s, grid):\n        positions = {}\n        for i in range(2):\n            for j in range(13):\n                positions[grid[i][j]] = (i, j)\n        \n        for i in range(len(s) - 1):\n            x1, y1 = positions[s[i]]\n            x2, y2 = positions[s[i + 1]]\n            if not is_adjacent(x1, y1, x2, y2):\n                return False\n        return True\n    \n    if find_path(s, grid):\n        return ''.join(grid[0]) + '\\n' + ''.join(grid[1])\n    else:\n        return \"Impossible\"\n\n# Read input\ns = input().strip()\n\n# Find and print the grid\nresult = find_grid(s)\nprint(result)"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<' if y > 1 else '='\n    elif y == 1:\n        return '>' if x > 1 else '='\n    else:\n        # Compute y * log(x) and x * log(y)\n        lhs = y * math.log(x)\n        rhs = x * math.log(y)\n        \n        if lhs < rhs:\n            return '<'\n        elif lhs > rhs:\n            return '>'\n        else:\n            return '='\n\n# Read input\nx, y = map(int, input().split())\n\n# Output the result of the comparison\nprint(compare_powers(x, y))"}
{"solution": "import math\n\ndef max_balloons(r, h):\n    # Radius of each balloon\n    balloon_radius = r / 2\n    \n    # Calculate the number of balloons that can fit in the semicircular top part\n    # The diameter of each balloon is r, so we can fit at most 1 balloon in the semicircle\n    balloons_in_semi_circle = 1\n    \n    # Calculate the number of balloons that can fit in the rectangular part\n    # The height of the rectangular part is h, and the depth is r\n    # We can fit balloons in a grid pattern\n    balloons_in_height = h // r\n    balloons_in_depth = 1\n    \n    # Total balloons in the rectangular part\n    balloons_in_rectangle = balloons_in_height * balloons_in_depth\n    \n    # Total balloons in the cupboard\n    total_balloons = balloons_in_semi_circle + balloons_in_rectangle\n    \n    return total_balloons\n\n# Read input\nr, h = map(int, input().split())\n\n# Calculate and print the result\nprint(max_balloons(r, h))"}
{"solution": "def min_sum_after_discard(cards):\n    from collections import Counter\n    \n    # Count the frequency of each card\n    card_count = Counter(cards)\n    \n    # Calculate the initial sum of all cards\n    total_sum = sum(cards)\n    \n    # Initialize the minimum sum as the total sum\n    min_sum = total_sum\n    \n    # Check for each card value if we can discard 2 or 3 cards\n    for card, count in card_count.items():\n        if count >= 2:\n            # If we can discard 2 cards\n            min_sum = min(min_sum, total_sum - 2 * card)\n        if count >= 3:\n            # If we can discard 3 cards\n            min_sum = min(min_sum, total_sum - 3 * card)\n    \n    return min_sum\n\n# Read input\ncards = list(map(int, input().split()))\n\n# Get the minimum sum after discarding\nresult = min_sum_after_discard(cards)\n\n# Print the result\nprint(result)"}
{"solution": "def min_distance_to_visit_checkpoints(n, a, checkpoints):\n    checkpoints.sort()\n    \n    # If there's only one checkpoint, Vasya doesn't need to travel at all\n    if n == 1:\n        return 0\n    \n    # Calculate the distance if we skip the first checkpoint\n    skip_first = abs(a - checkpoints[1]) + abs(checkpoints[1] - checkpoints[-1])\n    \n    # Calculate the distance if we skip the last checkpoint\n    skip_last = abs(a - checkpoints[-2]) + abs(checkpoints[-2] - checkpoints[0])\n    \n    # The minimum distance will be the lesser of the two calculated distances\n    return min(skip_first, skip_last)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = int(data[1])\ncheckpoints = list(map(int, data[2:]))\n\n# Calculate and print the result\nprint(min_distance_to_visit_checkpoints(n, a, checkpoints))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_smallest_root(n):\n    for x in range(1, int(n**0.5) + 1):\n        if x**2 + sum_of_digits(x) * x == n:\n            return x\n    return -1\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    result = find_smallest_root(n)\n    print(result)"}
{"solution": "def calculate_bed_time(current_time, sleep_duration):\n    # Parse the current time\n    current_hours, current_minutes = map(int, current_time.split(':'))\n    \n    # Parse the sleep duration\n    sleep_hours, sleep_minutes = map(int, sleep_duration.split(':'))\n    \n    # Calculate the total minutes for current time and sleep duration\n    current_total_minutes = current_hours * 60 + current_minutes\n    sleep_total_minutes = sleep_hours * 60 + sleep_minutes\n    \n    # Calculate the time George went to bed\n    bed_total_minutes = current_total_minutes - sleep_total_minutes\n    \n    # If the bed time is negative, it means George went to bed the previous day\n    if bed_total_minutes < 0:\n        bed_total_minutes += 24 * 60\n    \n    # Convert the total minutes back to hours and minutes\n    bed_hours = bed_total_minutes // 60\n    bed_minutes = bed_total_minutes % 60\n    \n    # Format the result to \"hh:mm\"\n    bed_time = f\"{bed_hours:02}:{bed_minutes:02}\"\n    \n    return bed_time\n\n# Read input\ncurrent_time = input().strip()\nsleep_duration = input().strip()\n\n# Calculate and print the bed time\nprint(calculate_bed_time(current_time, sleep_duration))"}
{"solution": "def find_longest_subsegment_with_max_mean(n, a):\n    max_value = max(a)\n    max_length = 0\n    current_length = 0\n\n    for value in a:\n        if value == max_value:\n            current_length += 1\n            if current_length > max_length:\n                max_length = current_length\n        else:\n            current_length = 0\n\n    return max_length\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find and print the length of the longest subsegment with maximum mean\nprint(find_longest_subsegment_with_max_mean(n, a))"}
{"solution": "MOD = 998244353\n\ndef count_ways(n, m, k):\n    # Initialize a 2D dp array with zeros\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    # Base case: 1 way to paint 1 brick with any of the m colors\n    for i in range(1, n + 1):\n        dp[i][0] = m\n    \n    # Fill the dp table\n    for i in range(2, n + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i - 1][j] * m + dp[i - 1][j - 1] * (m - 1)) % MOD\n    \n    return dp[n][k]\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Calculate and print the result\nprint(count_ways(n, m, k))"}
{"solution": "import re\n\ndef is_magic_number(n):\n    # Define the regular expression pattern for magic numbers\n    pattern = re.compile(r'^(1|14|144)+$')\n    \n    # Check if the entire number matches the pattern\n    if pattern.match(str(n)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = input().strip()\nprint(is_magic_number(n))"}
{"solution": "from collections import deque\n\ndef min_moves_to_corner(n, m, i, j, a, b):\n    corners = [(1, 1), (1, m), (n, 1), (n, m)]\n    directions = [(-a, -b), (a, -b), (-a, b), (a, b)]\n    \n    def is_within_bounds(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n    \n    def bfs(start):\n        queue = deque([(start, 0)])\n        visited = set()\n        visited.add(start)\n        \n        while queue:\n            (x, y), moves = queue.popleft()\n            if (x, y) in corners:\n                return moves\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if is_within_bounds(nx, ny) and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append(((nx, ny), moves + 1))\n        return float('inf')\n    \n    min_moves = bfs((i, j))\n    if min_moves == float('inf'):\n        return \"Poor Inna and pony!\"\n    else:\n        return min_moves\n\n# Read input\nn, m, i, j, a, b = map(int, input().split())\n\n# Print output\nprint(min_moves_to_corner(n, m, i, j, a, b))"}
{"solution": "def max_removals(s):\n    def can_remove(s, i):\n        if i > 0 and ord(s[i]) - ord(s[i-1]) == 1:\n            return True\n        if i < len(s) - 1 and ord(s[i]) - ord(s[i+1]) == 1:\n            return True\n        return False\n\n    s = list(s)\n    total_removed = 0\n\n    while True:\n        to_remove = []\n        for i in range(len(s)):\n            if can_remove(s, i):\n                to_remove.append(i)\n        \n        if not to_remove:\n            break\n        \n        for i in reversed(to_remove):\n            s.pop(i)\n            total_removed += 1\n\n    return total_removed\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Calculate and print the result\nprint(max_removals(s))"}
{"solution": "def min_bills(n, k, denominations, q, requests):\n    results = []\n    \n    for x in requests:\n        min_bills_needed = float('inf')\n        found = False\n        \n        for i in range(n):\n            for j in range(i, n):\n                d1, d2 = denominations[i], denominations[j]\n                for c1 in range(k + 1):\n                    if c1 * d1 > x:\n                        break\n                    if (x - c1 * d1) % d2 == 0:\n                        c2 = (x - c1 * d1) // d2\n                        if c1 + c2 <= k:\n                            min_bills_needed = min(min_bills_needed, c1 + c2)\n                            found = True\n        \n        if found:\n            results.append(min_bills_needed)\n        else:\n            results.append(-1)\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\ndenominations = list(map(int, data[2:n+2]))\nq = int(data[n+2])\nrequests = list(map(int, data[n+3:n+3+q]))\n\n# Get results\nresults = min_bills(n, k, denominations, q, requests)\n\n# Print results\nfor result in results:\n    print(result)"}
{"solution": "def minimum_time(s, x1, x2, t1, t2, p, d):\n    # Calculate the time if Igor walks the entire distance\n    walk_time = abs(x2 - x1) * t2\n\n    # Calculate the time if Igor uses the tram\n    tram_time = float('inf')\n    \n    if t1 >= t2:\n        # If walking is faster or equal to tram, just walk\n        return walk_time\n\n    # Calculate the time for the tram to reach x1 from p\n    if d == 1:\n        if p <= x1:\n            tram_to_x1 = (x1 - p) * t1\n        else:\n            tram_to_x1 = (s - p + s + x1) * t1\n    else:\n        if p >= x1:\n            tram_to_x1 = (p - x1) * t1\n        else:\n            tram_to_x1 = (p + s + (s - x1)) * t1\n\n    # Calculate the time for the tram to reach x2 from x1\n    if x1 <= x2:\n        tram_to_x2 = (x2 - x1) * t1\n    else:\n        tram_to_x2 = (s - x1 + s + x2) * t1\n\n    tram_time = tram_to_x1 + tram_to_x2\n\n    return min(walk_time, tram_time)\n\n# Read input\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Calculate and print the minimum time\nprint(minimum_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "def count_occurrences(n, x):\n    count = 0\n    for i in range(1, n + 1):\n        if x % i == 0:\n            j = x // i\n            if j <= n:\n                count += 1\n    return count\n\n# Read input\nn, x = map(int, input().split())\n\n# Calculate and print the result\nprint(count_occurrences(n, x))"}
{"solution": "def generate_password(n, k):\n    # Create a list of the first k distinct lowercase Latin letters\n    distinct_letters = [chr(ord('a') + i) for i in range(k)]\n    \n    # Initialize the password list\n    password = []\n    \n    # Generate the password by cycling through the distinct letters\n    for i in range(n):\n        password.append(distinct_letters[i % k])\n    \n    # Join the list into a string and return\n    return ''.join(password)\n\n# Read input values\nn, k = map(int, input().split())\n\n# Generate and print the password\nprint(generate_password(n, k))"}
{"solution": "def first_collision_time(n, directions, positions):\n    min_time = float('inf')\n    collision_found = False\n    \n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            collision_time = (positions[i + 1] - positions[i]) // 2\n            min_time = min(min_time, collision_time)\n            collision_found = True\n    \n    if collision_found:\n        return min_time\n    else:\n        return -1\n\n# Read input\nn = int(input().strip())\ndirections = input().strip()\npositions = list(map(int, input().strip().split()))\n\n# Print the result\nprint(first_collision_time(n, directions, positions))"}
{"solution": "def can_fit(a, b, x1, y1, x2, y2):\n    # Check if two seals can fit in the given dimensions without overlapping\n    return (x1 + x2 <= a and max(y1, y2) <= b) or (y1 + y2 <= b and max(x1, x2) <= a) or \\\n           (x1 + y2 <= a and max(y1, x2) <= b) or (y1 + x2 <= b and max(x1, y2) <= a) or \\\n           (y1 + y2 <= a and max(x1, x2) <= b) or (x1 + x2 <= b and max(y1, y2) <= a) or \\\n           (y1 + x2 <= a and max(x1, y2) <= b) or (x1 + y2 <= b and max(y1, x2) <= a)\n\ndef max_seal_area(n, a, b, seals):\n    max_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = seals[i]\n            x2, y2 = seals[j]\n            if can_fit(a, b, x1, y1, x2, y2):\n                max_area = max(max_area, x1 * y1 + x2 * y2)\n    return max_area\n\n# Read input\nn, a, b = map(int, input().split())\nseals = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(max_seal_area(n, a, b, seals))"}
{"solution": "def find_outlier_point(points):\n    # Determine the min and max x and y values to find the boundaries of the square\n    min_x = min(point[0] for point in points)\n    max_x = max(point[0] for point in points)\n    min_y = min(point[1] for point in points)\n    max_y = max(point[1] for point in points)\n    \n    # Check each point to see if it lies on the boundary of the square\n    for point in points:\n        x, y = point\n        if not (x == min_x or x == max_x or y == min_y or y == max_y):\n            return point\n\n# Read input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(4 * n + 1)]\n\n# Find and print the outlier point\noutlier_point = find_outlier_point(points)\nprint(outlier_point[0], outlier_point[1])"}
{"solution": "def digit_product(x):\n    product = 1\n    while x > 0:\n        product *= x % 10\n        x //= 10\n    return product\n\ndef max_digit_product(n):\n    max_product = 0\n    str_n = str(n)\n    length = len(str_n)\n    \n    for i in range(length):\n        if str_n[i] == '0':\n            continue\n        \n        # Create a number by reducing the current digit by 1 and setting all following digits to 9\n        candidate = int(str_n[:i] + str(int(str_n[i]) - 1) + '9' * (length - i - 1))\n        if candidate > 0:\n            max_product = max(max_product, digit_product(candidate))\n    \n    # Also consider the number itself\n    max_product = max(max_product, digit_product(n))\n    \n    return max_product\n\n# Read input\nn = int(input().strip())\n\n# Print the result\nprint(max_digit_product(n))"}
{"solution": "def find_min_k(n, votes):\n    total_votes_elodreip = sum(votes)\n    max_vote = max(votes)\n    \n    k = max_vote\n    while True:\n        total_votes_awruk = n * k - total_votes_elodreip\n        if total_votes_awruk > total_votes_elodreip:\n            return k\n        k += 1\n\n# Read input\nn = int(input())\nvotes = list(map(int, input().split()))\n\n# Find and print the minimum k\nprint(find_min_k(n, votes))"}
{"solution": "def count_operations(points):\n    operations = 0\n    while True:\n        to_delete = set()\n        n = len(points)\n        \n        # Determine which points need to be deleted\n        for i in range(n):\n            if (i > 0 and points[i] != points[i - 1]) or (i < n - 1 and points[i] != points[i + 1]):\n                to_delete.add(i)\n        \n        # If no points to delete, break the loop\n        if not to_delete:\n            break\n        \n        # Create a new list of points excluding the ones to be deleted\n        points = [points[i] for i in range(n) if i not in to_delete]\n        operations += 1\n    \n    return operations\n\n# Read input\npoints = input().strip()\n\n# Calculate and print the number of operations\nprint(count_operations(points))"}
{"solution": "def count_minimum_product_triples(n, a):\n    from collections import Counter\n    from itertools import combinations\n    import math\n\n    # Count the frequency of each element in the array\n    freq = Counter(a)\n    \n    # Get the three smallest unique elements\n    smallest_elements = sorted(freq.keys())[:3]\n    \n    # If there are less than 3 unique elements, we need to handle it separately\n    if len(smallest_elements) < 3:\n        if len(smallest_elements) == 2:\n            # If there are exactly 2 unique elements, we need at least one of them to appear at least 2 times\n            if freq[smallest_elements[0]] >= 2:\n                return math.comb(freq[smallest_elements[0]], 2) * freq[smallest_elements[1]]\n            elif freq[smallest_elements[1]] >= 2:\n                return math.comb(freq[smallest_elements[1]], 2) * freq[smallest_elements[0]]\n            else:\n                return 0\n        elif len(smallest_elements) == 1:\n            # If there is only 1 unique element, we need it to appear at least 3 times\n            if freq[smallest_elements[0]] >= 3:\n                return math.comb(freq[smallest_elements[0]], 3)\n            else:\n                return 0\n        else:\n            return 0\n    \n    # Calculate the number of valid triples\n    result = 1\n    for elem in smallest_elements:\n        result *= freq[elem]\n    \n    return result\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_minimum_product_triples(n, a))"}
{"solution": "def min_cuts(n):\n    if n == 0:\n        return 0\n    elif (n + 1) % 2 == 0:\n        return (n + 1) // 2\n    else:\n        return n + 1\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the result\nprint(min_cuts(n))"}
{"solution": "def maximize_bank_account(n):\n    n_str = str(n)\n    \n    if n >= 0:\n        return n\n    \n    # Remove the last digit\n    option1 = int(n_str[:-1])\n    \n    # Remove the second last digit\n    option2 = int(n_str[:-2] + n_str[-1])\n    \n    # Return the maximum of the original number, option1, and option2\n    return max(n, option1, option2)\n\n# Read input\nn = int(input().strip())\n\n# Print the result\nprint(maximize_bank_account(n))"}
{"solution": "# Define the positions in order\npositions = ['v', '<', '^', '>']\n\n# Read input\nstart, end = input().split()\nn = int(input())\n\n# Find the indices of the start and end positions\nstart_index = positions.index(start)\nend_index = positions.index(end)\n\n# Calculate the positions after n seconds for both directions\ncw_index = (start_index + n) % 4\nccw_index = (start_index - n) % 4\n\n# Determine the direction\nif positions[cw_index] == end and positions[ccw_index] == end:\n    print(\"undefined\")\nelif positions[cw_index] == end:\n    print(\"cw\")\nelif positions[ccw_index] == end:\n    print(\"ccw\")\nelse:\n    print(\"undefined\")"}
{"solution": "def count_standing_dominoes(n, s):\n    standing_count = 0\n    i = 0\n\n    while i < n:\n        if s[i] == '.':\n            standing_count += 1\n            i += 1\n        elif s[i] == 'L':\n            i += 1\n        elif s[i] == 'R':\n            j = i + 1\n            while j < n and s[j] == '.':\n                j += 1\n            if j < n and s[j] == 'L':\n                distance = j - i - 1\n                if distance % 2 == 0:\n                    standing_count += 1\n            i = j\n\n    return standing_count\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Calculate and print the result\nprint(count_standing_dominoes(n, s))"}
{"solution": "def find_permutation(n, m, leaders):\n    # Initialize the permutation array with -1\n    permutation = [-1] * n\n    used = [False] * (n + 1)\n    \n    # Set the first leader\n    current_leader = leaders[0] - 1\n    \n    for i in range(m - 1):\n        next_leader = leaders[i + 1] - 1\n        steps = (next_leader - current_leader) % n\n        if steps == 0:\n            steps = n\n        \n        if permutation[current_leader] == -1:\n            if used[steps]:\n                return -1\n            permutation[current_leader] = steps\n            used[steps] = True\n        elif permutation[current_leader] != steps:\n            return -1\n        \n        current_leader = next_leader\n    \n    # Fill in the remaining values in the permutation\n    available_numbers = [i for i in range(1, n + 1) if not used[i]]\n    for i in range(n):\n        if permutation[i] == -1:\n            permutation[i] = available_numbers.pop(0)\n    \n    return permutation\n\n# Read input\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\n# Find the permutation\nresult = find_permutation(n, m, leaders)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def maximize_number(a, k):\n    # Convert the number to a list of digits for easy manipulation\n    digits = list(str(a))\n    n = len(digits)\n    \n    # Perform at most k swaps\n    for i in range(n):\n        if k == 0:\n            break\n        \n        # Find the maximum digit in the range [i, min(n, i + k + 1)]\n        max_digit = max(digits[i:min(n, i + k + 1)])\n        \n        # If the current digit is already the maximum, continue\n        if digits[i] == max_digit:\n            continue\n        \n        # Find the position of the maximum digit\n        max_pos = i + digits[i:min(n, i + k + 1)].index(max_digit)\n        \n        # Perform swaps to bring the maximum digit to position i\n        for j in range(max_pos, i, -1):\n            digits[j], digits[j - 1] = digits[j - 1], digits[j]\n            k -= 1\n            if k == 0:\n                break\n    \n    # Convert the list of digits back to a string and print the result\n    print(''.join(digits))\n\n# Read input\na, k = map(int, input().split())\n\n# Call the function to maximize the number\nmaximize_number(a, k)"}
{"solution": "def find_next_number(sequence):\n    a1, a2, a3, a4 = sequence\n\n    # Check for arithmetic progression\n    if (a2 - a1 == a3 - a2 == a4 - a3):\n        d = a2 - a1\n        next_number = a4 + d\n        print(next_number)\n        return\n\n    # Check for geometric progression\n    if (a2 / a1 == a3 / a2 == a4 / a3):\n        q = a2 / a1\n        next_number = a4 * q\n        if next_number.is_integer():\n            print(int(next_number))\n            return\n\n    # If neither, print 42\n    print(42)\n\n# Read input\nsequence = list(map(int, input().split()))\n\n# Find and print the next number in the sequence\nfind_next_number(sequence)"}
{"solution": "def max_distance(n, colors):\n    # Find the first and last occurrence of each color\n    first_occurrence = {}\n    last_occurrence = {}\n    \n    for i in range(n):\n        color = colors[i]\n        if color not in first_occurrence:\n            first_occurrence[color] = i\n        last_occurrence[color] = i\n    \n    # Get the list of unique colors\n    unique_colors = list(first_occurrence.keys())\n    \n    # Calculate the maximum distance\n    max_dist = 0\n    \n    # Compare distances from the first house to the last house of a different color\n    for color in unique_colors:\n        if colors[0] != color:\n            max_dist = max(max_dist, last_occurrence[color])\n        if colors[-1] != color:\n            max_dist = max(max_dist, n - 1 - first_occurrence[color])\n    \n    return max_dist\n\n# Example usage:\nn = int(input())\ncolors = list(map(int, input().split()))\nprint(max_distance(n, colors))"}
{"solution": "def find_santa_place(n, m, k):\n    # Determine the lane number\n    lane = (k - 1) // (2 * m) + 1\n    \n    # Determine the desk number within the lane\n    desk = ((k - 1) % (2 * m)) // 2 + 1\n    \n    # Determine the side of the desk\n    side = \"L\" if k % 2 != 0 else \"R\"\n    \n    return lane, desk, side\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Find Santa's place\nlane, desk, side = find_santa_place(n, m, k)\n\n# Print the result\nprint(lane, desk, side)"}
{"solution": "def possible_final_colors(n, s):\n    # Count the number of each color\n    count_B = s.count('B')\n    count_G = s.count('G')\n    count_R = s.count('R')\n    \n    # Determine the parity of each count\n    odd_B = count_B % 2\n    odd_G = count_G % 2\n    odd_R = count_R % 2\n    \n    # Determine the possible final colors\n    possible_colors = set()\n    \n    if odd_B:\n        possible_colors.add('B')\n    if odd_G:\n        possible_colors.add('G')\n    if odd_R:\n        possible_colors.add('R')\n    \n    # If the number of odd counts is even, all colors are possible\n    if (odd_B + odd_G + odd_R) % 2 == 0:\n        possible_colors.update(['B', 'G', 'R'])\n    \n    # Return the possible colors in alphabetical order\n    return ''.join(sorted(possible_colors))\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the possible final colors\nresult = possible_final_colors(n, s)\n\n# Print the result\nprint(result)"}
