{"solution": "def max_accordion_length(s):\n    n = len(s)\n    left_bracket = s.find('[')\n    right_bracket = s.rfind(']')\n    \n    if left_bracket == -1 or right_bracket == -1 or left_bracket >= right_bracket:\n        return -1\n    \n    left_colon = s.find(':', left_bracket + 1, right_bracket)\n    right_colon = s.rfind(':', left_bracket + 1, right_bracket)\n    \n    if left_colon == -1 or right_colon == -1 or left_colon >= right_colon:\n        return -1\n    \n    vertical_bars = s[left_colon + 1:right_colon].count('|')\n    \n    return 4 + vertical_bars\n\n# Read input\ns = input().strip()\n\n# Print output\nprint(max_accordion_length(s))"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef find_max_sum_of_digits(x):\n    str_x = str(x)\n    length = len(str_x)\n    \n    # Start with the number itself\n    max_sum = sum_of_digits(x)\n    result = x\n    \n    # Try to form the largest number with maximum sum of digits\n    for i in range(length):\n        if str_x[i] == '0':\n            continue\n        \n        # Form a new number by reducing the current digit by 1 and setting all following digits to 9\n        new_number = int(str_x[:i] + str(int(str_x[i]) - 1) + '9' * (length - i - 1))\n        \n        if new_number <= x:\n            current_sum = sum_of_digits(new_number)\n            if current_sum > max_sum or (current_sum == max_sum and new_number > result):\n                max_sum = current_sum\n                result = new_number\n    \n    return result\n\n# Read input\nx = int(input().strip())\n\n# Find and print the result\nprint(find_max_sum_of_digits(x))"}
{"solution": "def is_lucky(year):\n    non_zero_digits = sum(1 for digit in str(year) if digit != '0')\n    return non_zero_digits <= 1\n\ndef next_lucky_year(current_year):\n    year = current_year + 1\n    while not is_lucky(year):\n        year += 1\n    return year - current_year\n\nn = int(input())\nprint(next_lucky_year(n))"}
{"solution": "def max_painted_sections(n, q, painters):\n    # Initialize the coverage array\n    coverage = [0] * (n + 1)\n    \n    # Calculate the initial coverage by all painters\n    for l, r in painters:\n        for i in range(l, r + 1):\n            coverage[i] += 1\n    \n    # Calculate the total number of painted sections with all painters\n    total_painted = sum(1 for i in range(1, n + 1) if coverage[i] > 0)\n    \n    # Calculate the impact of removing each painter\n    impact = []\n    for l, r in painters:\n        impact.append(sum(1 for i in range(l, r + 1) if coverage[i] == 1))\n    \n    # Find the two painters whose removal has the least impact\n    min_impact = float('inf')\n    for i in range(q):\n        for j in range(i + 1, q):\n            min_impact = min(min_impact, impact[i] + impact[j])\n    \n    # The maximum number of painted sections after removing two painters\n    return total_painted - min_impact\n\n# Read input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Calculate and print the result\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def contains_seven(h, m):\n    return '7' in str(h) or '7' in str(m)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    x = int(data[0])\n    hh = int(data[1])\n    mm = int(data[2])\n    \n    presses = 0\n    \n    while not contains_seven(hh, mm):\n        presses += 1\n        mm -= x\n        if mm < 0:\n            mm += 60\n            hh -= 1\n            if hh < 0:\n                hh += 24\n    \n    print(presses)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0\n    elif l == 1:\n        return abs(pos - r) + 1\n    elif r == n:\n        return abs(pos - l) + 1\n    else:\n        return min(abs(pos - l), abs(pos - r)) + (r - l) + 2\n\n# Read input\nn, pos, l, r = map(int, input().split())\n\n# Calculate and print the result\nprint(min_seconds_to_close_tabs(n, pos, l, r))"}
{"solution": "def min_blows_to_defeat(t, queries):\n    results = []\n    for query in queries:\n        n, x, blows = query\n        max_d = 0\n        max_d_minus_h = 0\n        for d, h in blows:\n            max_d = max(max_d, d)\n            max_d_minus_h = max(max_d_minus_h, d - h)\n        \n        if max_d >= x:\n            results.append(1)\n        elif max_d_minus_h <= 0:\n            results.append(-1)\n        else:\n            remaining_heads = x - max_d\n            blows_needed = (remaining_heads + max_d_minus_h - 1) // max_d_minus_h\n            results.append(blows_needed + 1)\n    \n    return results\n\n# Read input\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Get results\nresults = min_blows_to_defeat(t, queries)\n\n# Print results\nfor result in results:\n    print(result)"}
{"solution": "def find_empty_day(n, m):\n    day = 0\n    while n > 0:\n        day += 1\n        n += m\n        n -= day\n        if n < 0:\n            n = 0\n    return day\n\n# Read input\nn, m = map(int, input().split())\n\n# Find and print the day when the barn becomes empty\nprint(find_empty_day(n, m))"}
{"solution": "def min_tiles_to_draw(tiles):\n    # Parse the input tiles\n    tile_counts = {}\n    for tile in tiles:\n        if tile in tile_counts:\n            tile_counts[tile] += 1\n        else:\n            tile_counts[tile] = 1\n\n    # Check for koutsu (triplet)\n    for tile, count in tile_counts.items():\n        if count == 3:\n            return 0\n\n    # Check for shuntsu (sequence)\n    suits = {'m': [], 'p': [], 's': []}\n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(number)\n\n    for suit in suits:\n        suits[suit].sort()\n        numbers = suits[suit]\n        if len(numbers) == 3:\n            if numbers[1] == numbers[0] + 1 and numbers[2] == numbers[1] + 1:\n                return 0\n\n    # Check for possible koutsu or shuntsu with one more tile\n    for tile, count in tile_counts.items():\n        if count == 2:\n            return 1\n\n    for suit in suits:\n        numbers = suits[suit]\n        if len(numbers) == 2:\n            if numbers[1] == numbers[0] + 1 or numbers[1] == numbers[0] + 2:\n                return 1\n\n    return 2\n\n# Read input\ntiles = input().split()\nprint(min_tiles_to_draw(tiles))"}
{"solution": "def find_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b):\n    left_count = [0] * d\n    right_count = [0] * d\n    top_count = [0] * d\n    bottom_count = [0] * d\n\n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        for j in range(d):\n            if i == j:\n                continue\n            x1_j, y1_j, x2_j, y2_j = sofas[j]\n            if x1 < x1_j and x2 < x1_j:\n                right_count[i] += 1\n            if x1 > x2_j and x2 > x2_j:\n                left_count[i] += 1\n            if y1 < y1_j and y2 < y1_j:\n                bottom_count[i] += 1\n            if y1 > y2_j and y2 > y2_j:\n                top_count[i] += 1\n\n    for i in range(d):\n        if (left_count[i] == cnt_l and right_count[i] == cnt_r and\n                top_count[i] == cnt_t and bottom_count[i] == cnt_b):\n            return i + 1\n\n    return -1\n\n# Read input\nd = int(input())\nn, m = map(int, input().split())\nsofas = [tuple(map(int, input().split())) for _ in range(d)]\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\n# Find and print the result\nresult = find_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b)\nprint(result)"}
{"solution": "def mars_days_off(n):\n    # Calculate the number of complete weeks and remaining days\n    complete_weeks = n // 7\n    remaining_days = n % 7\n    \n    # Minimum days off: all remaining days are work days\n    min_days_off = complete_weeks * 2\n    \n    # Maximum days off: all remaining days are days off, but not more than 2\n    max_days_off = min_days_off + min(remaining_days, 2)\n    \n    print(min_days_off, max_days_off)\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the result\nmars_days_off(n)"}
{"solution": "def max_chocolates(n, a, b, p, q):\n    from math import gcd\n\n    lcm_ab = (a * b) // gcd(a, b)\n    \n    red_tiles = n // a\n    blue_tiles = n // b\n    both_tiles = n // lcm_ab\n    \n    max_chocolates = red_tiles * p + blue_tiles * q - both_tiles * min(p, q)\n    \n    return max_chocolates\n\n# Read input\nn, a, b, p, q = map(int, input().strip().split())\n\n# Calculate and print the result\nprint(max_chocolates(n, a, b, p, q))"}
{"solution": "def max_beauty(n, trophies):\n    if 'G' not in trophies:\n        return 0\n    if 'S' not in trophies:\n        return n\n\n    segments = []\n    count = 0\n    for i in range(n):\n        if trophies[i] == 'G':\n            count += 1\n        else:\n            if count > 0:\n                segments.append(count)\n            count = 0\n    if count > 0:\n        segments.append(count)\n\n    max_length = max(segments)\n    if len(segments) == 1:\n        return max_length\n\n    for i in range(len(segments) - 1):\n        if segments[i] + segments[i + 1] + 1 > max_length:\n            max_length = segments[i] + segments[i + 1] + 1\n\n    if trophies.count('G') > max_length:\n        max_length += 1\n\n    return max_length\n\nn = int(input())\ntrophies = input().strip()\nprint(max_beauty(n, trophies))"}
{"solution": "from collections import deque, defaultdict\n\ndef find_course_order(n, k, main_courses, dependencies):\n    # Create a graph and in-degree array\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        for dep in dependencies[i - 1]:\n            graph[dep].append(i)\n            in_degree[i] += 1\n    \n    # Topological sort using Kahn's algorithm\n    queue = deque()\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    topo_order = []\n    while queue:\n        course = queue.popleft()\n        topo_order.append(course)\n        for neighbor in graph[course]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check if topological sort is possible\n    if len(topo_order) != n:\n        return -1, []\n    \n    # Find the minimum courses to take\n    required_courses = set(main_courses)\n    result = []\n    visited = set()\n    \n    def dfs(course):\n        if course in visited:\n            return\n        visited.add(course)\n        for dep in dependencies[course - 1]:\n            dfs(dep)\n        result.append(course)\n    \n    for course in main_courses:\n        dfs(course)\n    \n    result = list(reversed(result))\n    return len(result), result\n\n# Read input\nn, k = map(int, input().split())\nmain_courses = list(map(int, input().split()))\ndependencies = []\nfor _ in range(n):\n    line = list(map(int, input().split()))\n    dependencies.append(line[1:])\n\n# Find the course order\nm, order = find_course_order(n, k, main_courses, dependencies)\n\n# Print the result\nif m == -1:\n    print(-1)\nelse:\n    print(m)\n    print(\" \".join(map(str, order)))"}
{"solution": "def is_stack_sortable(a):\n    s = []\n    b = []\n    for x in a:\n        s.append(x)\n        while s and (not b or s[-1] == b[-1] + 1):\n            b.append(s.pop())\n    return len(b) == len(a)\n\ndef solve(n, k, p):\n    remaining = set(range(1, n + 1)) - set(p)\n    remaining = sorted(remaining, reverse=True)\n    \n    for i in range(k, n):\n        p.append(remaining.pop(0))\n        if not is_stack_sortable(p):\n            return -1\n    \n    return p\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\np = list(map(int, data[2:2+k]))\n\n# Solve the problem\nresult = solve(n, k, p)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def does_b_appear_in_sequence(a, b, c):\n    if c == 0:\n        if a == b:\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n# Read input\na, b, c = map(int, input().split())\n\n# Determine if b appears in the sequence\nresult = does_b_appear_in_sequence(a, b, c)\n\n# Print the result\nprint(result)"}
{"solution": "cnt1 = int(input())\ncnt2 = int(input())\ncnt3 = int(input())\ncnt4 = int(input())\n\n# To form a regular bracket sequence, the number of opening brackets must equal the number of closing brackets.\n# Also, at any point in the sequence, the number of closing brackets should not exceed the number of opening brackets.\n\n# Total number of opening brackets\ntotal_open = cnt1 * 2 + cnt2\n\n# Total number of closing brackets\ntotal_close = cnt4 * 2 + cnt2\n\n# Check if the total number of opening and closing brackets are equal\nif total_open != total_close:\n    print(0)\nelse:\n    # Check if we can balance the brackets\n    if cnt3 <= cnt2 + 1 and cnt1 <= cnt4 + 1:\n        print(1)\n    else:\n        print(0)"}
{"solution": "def mexican_wave(n, k, t):\n    if t <= k:\n        return t\n    elif t <= n:\n        return k\n    else:\n        return n + k - t\n\n# Read input\nn, k, t = map(int, input().strip().split())\n\n# Calculate and print the result\nprint(mexican_wave(n, k, t))"}
{"solution": "def petya_game(s):\n    t = []\n    u = []\n    s = list(s)\n    \n    while s or t:\n        if not t:\n            t.append(s.pop(0))\n        elif not s:\n            u.append(t.pop())\n        else:\n            if s[0] <= t[-1]:\n                t.append(s.pop(0))\n            else:\n                u.append(t.pop())\n    \n    return ''.join(u)\n\n# Read input\ns = input().strip()\n\n# Get the result\nresult = petya_game(s)\n\n# Print the result\nprint(result)"}
{"solution": "def is_valid_sequence(n, stats):\n    for i in range(1, n):\n        p1, c1 = stats[i-1]\n        p2, c2 = stats[i]\n        if p2 < p1 or c2 < c1 or c2 > p2 or (p2 - p1) < (c2 - c1):\n            return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        n = int(data[index])\n        index += 1\n        stats = []\n        for _ in range(n):\n            p = int(data[index])\n            c = int(data[index + 1])\n            stats.append((p, c))\n            index += 2\n        if is_valid_sequence(n, stats):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_palindrome(time):\n    return time == time[::-1]\n\ndef increment_time(hh, mm):\n    mm += 1\n    if mm == 60:\n        mm = 0\n        hh += 1\n        if hh == 24:\n            hh = 0\n    return hh, mm\n\ndef format_time(hh, mm):\n    return f\"{hh:02}:{mm:02}\"\n\ndef min_minutes_to_palindrome(time):\n    hh, mm = map(int, time.split(':'))\n    minutes = 0\n    while True:\n        formatted_time = format_time(hh, mm)\n        if is_palindrome(formatted_time.replace(':', '')):\n            return minutes\n        hh, mm = increment_time(hh, mm)\n        minutes += 1\n\n# Read input\ntime = input().strip()\n\n# Calculate and print the result\nprint(min_minutes_to_palindrome(time))"}
{"solution": "def max_distance_after_swap(n, a):\n    min_index = a.index(1)\n    max_index = a.index(n)\n    \n    # Calculate possible distances after swapping\n    dist1 = abs(min_index - 0) + abs(max_index - (n - 1))\n    dist2 = abs(min_index - (n - 1)) + abs(max_index - 0)\n    \n    return max(dist1, dist2)\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_distance_after_swap(n, a))"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            return \"NIE\"\n    return \"TAK\"\n\ns = input().strip()\nprint(is_s_palindrome(s))"}
{"solution": "from itertools import permutations\n\ndef max_permutation(a, b):\n    a_str = str(a)\n    b_str = str(b)\n    a_len = len(a_str)\n    \n    # Generate all permutations of a\n    perm = sorted(set(permutations(a_str)), reverse=True)\n    \n    # Find the maximum permutation that is less than or equal to b\n    for p in perm:\n        p_str = ''.join(p)\n        if p_str[0] != '0' and int(p_str) <= b:\n            return p_str\n\n# Read input\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result\nresult = max_permutation(a, b)\n\n# Print the result\nprint(result)"}
{"solution": "def check_win(board, x, y):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]\n    for dx, dy in directions:\n        count = 1\n        for i in range(1, 5):\n            nx, ny = x + i * dx, y + i * dy\n            if 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n            else:\n                break\n        for i in range(1, 5):\n            nx, ny = x - i * dx, y - i * dy\n            if 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n            else:\n                break\n        if count >= 5:\n            return True\n    return False\n\ndef can_alice_win(board):\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i][j] = 'X'\n                if check_win(board, i, j):\n                    return \"YES\"\n                board[i][j] = '.'\n    return \"NO\"\n\nboard = [input().strip() for _ in range(10)]\nprint(can_alice_win(board))"}
{"solution": "def generate_matrix(n, k):\n    if k > n * n:\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        if k >= 2 and i != n - 1:\n            matrix[i][i] = 1\n            matrix[i][i + 1] = 1\n            matrix[i + 1][i] = 1\n            k -= 2\n        elif k == 1:\n            matrix[i][i] = 1\n            k -= 1\n        else:\n            matrix[i][i] = 1\n            k -= 1\n            if k > 0:\n                matrix[i][i + 1] = 1\n                matrix[i + 1][i] = 1\n                k -= 2\n\n    if k > 0:\n        return -1\n\n    return matrix\n\ndef print_matrix(matrix):\n    if matrix == -1:\n        print(-1)\n    else:\n        for row in matrix:\n            print(\" \".join(map(str, row)))\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    result = generate_matrix(n, k)\n    print_matrix(result)"}
{"solution": "import math\n\ndef calculate_expressions(x, y, z):\n    expressions = [\n        (x ** (y ** z), \"x^y^z\"),\n        (x ** (z ** y), \"x^z^y\"),\n        ((x ** y) ** z, \"(x^y)^z\"),\n        ((x ** z) ** y, \"(x^z)^y\"),\n        (y ** (x ** z), \"y^x^z\"),\n        (y ** (z ** x), \"y^z^x\"),\n        ((y ** x) ** z, \"(y^x)^z\"),\n        ((y ** z) ** x, \"(y^z)^x\"),\n        (z ** (x ** y), \"z^x^y\"),\n        (z ** (y ** x), \"z^y^x\"),\n        ((z ** x) ** y, \"(z^x)^y\"),\n        ((z ** y) ** x, \"(z^y)^x\")\n    ]\n    return expressions\n\ndef find_max_expression(x, y, z):\n    expressions = calculate_expressions(x, y, z)\n    max_value, max_expr = max(expressions, key=lambda item: item[0])\n    return max_expr\n\nif __name__ == \"__main__\":\n    x, y, z = map(float, input().split())\n    result = find_max_expression(x, y, z)\n    print(result)"}
{"solution": "def min_operations_to_type_string(n, s):\n    min_operations = n  # Start with the worst case: typing all characters one by one\n\n    for i in range(1, n // 2 + 1):\n        if s[:i] == s[i:2*i]:\n            min_operations = min(min_operations, i + 1 + (n - 2 * i))\n\n    return min_operations\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Calculate and print the minimum number of operations\nprint(min_operations_to_type_string(n, s))"}
{"solution": "n = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = []\nregulars = []\n\nfor name, type_ in files:\n    if type_ == '1':\n        examples.append(name)\n    else:\n        regulars.append(name)\n\nmoves = []\ntemp_name = 'temp'\n\n# Move examples to the beginning\nfor i in range(len(examples)):\n    if examples[i] != str(i + 1):\n        if str(i + 1) in examples or str(i + 1) in regulars:\n            moves.append(f\"move {i + 1} {temp_name}\")\n        moves.append(f\"move {examples[i]} {i + 1}\")\n        if str(i + 1) in examples or str(i + 1) in regulars:\n            moves.append(f\"move {temp_name} {examples[i]}\")\n\n# Move regulars to the correct positions\nfor i in range(len(regulars)):\n    if regulars[i] != str(len(examples) + i + 1):\n        if str(len(examples) + i + 1) in examples or str(len(examples) + i + 1) in regulars:\n            moves.append(f\"move {len(examples) + i + 1} {temp_name}\")\n        moves.append(f\"move {regulars[i]} {len(examples) + i + 1}\")\n        if str(len(examples) + i + 1) in examples or str(len(examples) + i + 1) in regulars:\n            moves.append(f\"move {temp_name} {regulars[i]}\")\n\nprint(len(moves))\nfor move in moves:\n    print(move)"}
{"solution": "def min_replacements_to_lucky(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n\n    sum_first_half = sum(first_half)\n    sum_second_half = sum(second_half)\n\n    if sum_first_half == sum_second_half:\n        return 0\n\n    diff = abs(sum_first_half - sum_second_half)\n\n    if sum_first_half > sum_second_half:\n        first_half, second_half = second_half, first_half\n\n    changes = []\n    for digit in first_half:\n        changes.append(9 - digit)\n    for digit in second_half:\n        changes.append(digit)\n\n    changes.sort(reverse=True)\n\n    replacements = 0\n    for change in changes:\n        diff -= change\n        replacements += 1\n        if diff <= 0:\n            return replacements\n\n    return replacements\n\nticket = input().strip()\nprint(min_replacements_to_lucky(ticket))"}
{"solution": "def min_traps(m, x):\n    # Since GCD(x, m) = 1, x is a generator of the multiplicative group of integers modulo m\n    # This means that x will visit all rooms 0 to m-1 exactly once before repeating\n    # Therefore, the minimum number of traps needed is m - 1\n    return m - 1\n\n# Read input\nm, x = map(int, input().split())\n\n# Print the result\nprint(min_traps(m, x))"}
{"solution": "import math\n\nMOD = 10**6 + 3\n\ndef modinv(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef solve(n, k):\n    if k > 2**n:\n        print(1, 1)\n        return\n    \n    total_days = 2**n\n    numerator = 1\n    denominator = 1\n    \n    for i in range(k):\n        numerator = (numerator * (total_days - i)) % MOD\n        denominator = (denominator * total_days) % MOD\n    \n    A = (denominator - numerator) % MOD\n    B = denominator\n    \n    gcd = math.gcd(A, B)\n    A //= gcd\n    B //= gcd\n    \n    A = A % MOD\n    B = B % MOD\n    \n    print(A, B)\n\nn, k = map(int, input().split())\nsolve(n, k)"}
{"solution": "def is_valid_journey(n, journey):\n    position = 0  # Start at the North Pole\n\n    for t, dir in journey:\n        if position == 0 and dir != \"South\":\n            return \"NO\"\n        if position == 20000 and dir != \"North\":\n            return \"NO\"\n        \n        if dir == \"North\":\n            position -= t\n        elif dir == \"South\":\n            position += t\n        \n        if position < 0 or position > 20000:\n            return \"NO\"\n    \n    if position == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input().strip())\njourney = []\nfor _ in range(n):\n    t, dir = input().strip().split()\n    journey.append((int(t), dir))\n\n# Check if the journey is valid\nprint(is_valid_journey(n, journey))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef find_common_elements(a1, b1, a2, b2, L, R):\n    g = gcd(a1, a2)\n    if (b2 - b1) % g != 0:\n        return 0\n\n    lcm = (a1 // g) * a2\n    start = max(L, min(b1, b2))\n    end = min(R, max(b1, b2) + lcm - 1)\n\n    if start > end:\n        return 0\n\n    count = (end - start) // lcm - (start - 1 - start) // lcm\n    return count\n\na1, b1, a2, b2, L, R = map(int, input().split())\nprint(find_common_elements(a1, b1, a2, b2, L, R))"}
{"solution": "def max_pieces_per_plate(n, a, b):\n    left, right = 1, min(a, b)\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if (a // mid) + (b // mid) >= n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return right\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(max_pieces_per_plate(n, a, b))"}
{"solution": "def is_valid_flag(n, m, field):\n    def check_stripes(lines):\n        if len(lines) % 3 != 0:\n            return False\n        stripe_height = len(lines) // 3\n        colors = set()\n        for i in range(3):\n            stripe = lines[i * stripe_height:(i + 1) * stripe_height]\n            color = stripe[0]\n            if any(row != color for row in stripe):\n                return False\n            colors.add(color)\n        return len(colors) == 3\n\n    # Check horizontal stripes\n    if check_stripes(field):\n        return \"YES\"\n\n    # Check vertical stripes\n    transposed_field = [''.join(row[i] for row in field) for i in range(m)]\n    if check_stripes(transposed_field):\n        return \"YES\"\n\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Output result\nprint(is_valid_flag(n, m, field))"}
{"solution": "def find_coordinates(n):\n    if n == 0:\n        return (0, 0)\n    \n    # Directions in the order of the spiral\n    directions = [(1, 0), (0, 1), (-1, 1), (-1, 0), (0, -1), (1, -1)]\n    \n    x, y = 0, 0\n    step = 1\n    while n > 0:\n        for direction in directions:\n            move = min(step, n)\n            x += direction[0] * move\n            y += direction[1] * move\n            n -= move\n            if n == 0:\n                break\n        step += 1\n    \n    return (x, y)\n\n# Read input\nn = int(input().strip())\n\n# Find coordinates\nx, y = find_coordinates(n)\n\n# Print result\nprint(x, y)"}
{"solution": "def can_break_shield(a, b, c):\n    for i in range(c // a + 1):\n        if (c - i * a) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Read input\na, b, c = map(int, input().split())\n\n# Print the result\nprint(can_break_shield(a, b, c))"}
{"solution": "def check_tracks(n, L, kefa, sasha):\n    def get_diffs(arr):\n        return [(arr[i] - arr[i-1]) % L for i in range(1, n)] + [(arr[0] - arr[-1]) % L]\n\n    kefa_diffs = get_diffs(kefa)\n    sasha_diffs = get_diffs(sasha)\n\n    for i in range(n):\n        if kefa_diffs == sasha_diffs[i:] + sasha_diffs[:i]:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa = list(map(int, input().split()))\nsasha = list(map(int, input().split()))\n\n# Check if tracks coincide\nresult = check_tracks(n, L, kefa, sasha)\nprint(result)"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring_length(s):\n    n = len(s)\n    if not is_palindrome(s):\n        return n\n    for length in range(n-1, 0, -1):\n        for start in range(n - length + 1):\n            substring = s[start:start + length]\n            if not is_palindrome(substring):\n                return length\n    return 0\n\ns = input().strip()\nprint(longest_non_palindrome_substring_length(s))"}
{"solution": "n = int(input())\nparticipants = [tuple(map(int, input().split())) for _ in range(n)]\n\nrated = False\nunrated = False\n\nfor a, b in participants:\n    if a != b:\n        rated = True\n        break\n\nif not rated:\n    for i in range(n - 1):\n        if participants[i][0] < participants[i + 1][0]:\n            unrated = True\n            break\n\nif rated:\n    print(\"rated\")\nelif unrated:\n    print(\"unrated\")\nelse:\n    print(\"maybe\")"}
{"solution": "def nearest_zero_distances(n, arr):\n    distances = [float('inf')] * n\n    last_zero = -1\n\n    # Forward pass to find nearest zero on the left\n    for i in range(n):\n        if arr[i] == 0:\n            last_zero = i\n        if last_zero != -1:\n            distances[i] = i - last_zero\n\n    # Backward pass to find nearest zero on the right\n    last_zero = -1\n    for i in range(n-1, -1, -1):\n        if arr[i] == 0:\n            last_zero = i\n        if last_zero != -1:\n            distances[i] = min(distances[i], last_zero - i)\n\n    return distances\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Get the distances\ndistances = nearest_zero_distances(n, arr)\n\n# Print the result\nprint(\" \".join(map(str, distances)))"}
{"solution": "def count_distinct_cyclical_strings(n, s):\n    from itertools import product\n\n    def is_cyclical_substring(t, s):\n        t = t + t\n        return s in t\n\n    count = 0\n    for t in product('01', repeat=n):\n        t = ''.join(t)\n        if is_cyclical_substring(t, s):\n            count += 1\n\n    return count\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Calculate and print the result\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import math\n\ndef angle_between(v1, v2):\n    dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n    magnitude_v1 = math.sqrt(v1[0]**2 + v1[1]**2)\n    magnitude_v2 = math.sqrt(v2[0]**2 + v2[1]**2)\n    cos_theta = dot_product / (magnitude_v1 * magnitude_v2)\n    cos_theta = max(-1, min(1, cos_theta))  # Clamp value to avoid precision errors\n    return math.acos(cos_theta)\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    angles = []\n    \n    for i in range(n):\n        angle = math.atan2(vectors[i][1], vectors[i][0])\n        angles.append((angle, i + 1))\n    \n    angles.sort()\n    \n    min_angle = float('inf')\n    min_pair = (0, 0)\n    \n    for i in range(n):\n        angle1, idx1 = angles[i]\n        angle2, idx2 = angles[(i + 1) % n]\n        v1 = vectors[idx1 - 1]\n        v2 = vectors[idx2 - 1]\n        current_angle = angle_between(v1, v2)\n        \n        if current_angle < min_angle:\n            min_angle = current_angle\n            min_pair = (idx1, idx2)\n    \n    return min_pair\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    vectors = []\n    \n    for i in range(n):\n        x = int(data[2 * i + 1])\n        y = int(data[2 * i + 2])\n        vectors.append((x, y))\n    \n    result = find_min_angle_pair(vectors)\n    print(result[0], result[1])"}
{"solution": "def minimal_time(d, k, a, b, t):\n    if d <= k:\n        return d * a\n\n    # Time to drive the first k kilometers\n    time = k * a\n    d -= k\n\n    # Full cycles of k kilometers\n    full_cycles = d // k\n    remaining_distance = d % k\n\n    # Time for full cycles\n    time += full_cycles * min(k * a + t, k * b)\n\n    # Time for remaining distance\n    if remaining_distance > 0:\n        time += min(remaining_distance * a + t, remaining_distance * b)\n\n    return time\n\n# Read input\nd, k, a, b, t = map(int, input().split())\n\n# Calculate and print the minimal time\nprint(minimal_time(d, k, a, b, t))"}
{"solution": "def find_sequence(n, k):\n    if k * (k + 1) // 2 > n:\n        return -1\n    \n    base = n // k\n    remainder = n % k\n    \n    sequence = [base + i for i in range(1, k + 1)]\n    \n    for i in range(remainder):\n        sequence[k - 1 - i] += 1\n    \n    return sequence\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    n = int(data[0])\n    k = int(data[1])\n    \n    result = find_sequence(n, k)\n    if result == -1:\n        print(-1)\n    else:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_pairs(n, m):\n    count = 0\n    for i in range(5):\n        for j in range(5):\n            if (i + j) % 5 == 0:\n                count += ((n - i + 4) // 5) * ((m - j + 4) // 5)\n    return count\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(count_pairs(n, m))"}
{"solution": "def max_beauty(n, x, a):\n    max_ending_here = 0\n    max_so_far = 0\n    max_ending_here_with_x = 0\n    max_so_far_with_x = 0\n    max_ending_here_after_x = 0\n    max_so_far_after_x = 0\n\n    for i in range(n):\n        max_ending_here = max(0, max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n\n        max_ending_here_with_x = max(max_ending_here_with_x + a[i], max_ending_here + a[i] * x, a[i] * x)\n        max_so_far_with_x = max(max_so_far_with_x, max_ending_here_with_x)\n\n        max_ending_here_after_x = max(max_ending_here_after_x + a[i], max_ending_here_with_x + a[i])\n        max_so_far_after_x = max(max_so_far_after_x, max_ending_here_after_x)\n\n    return max(max_so_far, max_so_far_with_x, max_so_far_after_x)\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_beauty(n, x, a))"}
{"solution": "def find_kth_largest(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(x // i, m)\n        return count\n\n    left, right = 1, n * m\n    while left < right:\n        mid = (left + right) // 2\n        if count_less_equal(mid) < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Read input\nn, m, k = map(int, input().strip().split())\n\n# Find and print the k-th largest number\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    start += (k - 1) // length\n    s = str(start)\n    return s[(k - 1) % length]\n\nk = int(input().strip())\nprint(find_kth_digit(k))"}
{"solution": "def max_bourles(n, m, r, s, b):\n    min_buy_price = min(s)\n    max_sell_price = max(b)\n    \n    if min_buy_price >= max_sell_price:\n        return r\n    \n    shares_to_buy = r // min_buy_price\n    remaining_bourles = r % min_buy_price\n    total_bourles = shares_to_buy * max_sell_price + remaining_bourles\n    \n    return total_bourles\n\n# Read input\nn, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_bourles(n, m, r, s, b))"}
{"solution": "def find_original_message(t):\n    n = len(t)\n    for i in range(1, n):\n        if t[:i] == t[-i:]:\n            s = t[:-i]\n            if s + t[:i] == t:\n                return \"YES\\n\" + s\n    return \"NO\"\n\n# Read input\nt = input().strip()\n\n# Find and print the result\nprint(find_original_message(t))"}
{"solution": "def find_teams(n):\n    results = []\n    \n    # Check for the case where the number of games is exactly n\n    for initial_teams in range(1, n + 1):\n        games_played = 0\n        teams = initial_teams\n        \n        # Simulate the elimination stages\n        while teams % 2 == 0:\n            games_played += teams // 2\n            teams //= 2\n        \n        # If we have an odd number of teams left, simulate the round robin stage\n        if teams > 1:\n            games_played += teams * (teams - 1) // 2\n        \n        # Check if the total number of games played matches n\n        if games_played == n:\n            results.append(initial_teams)\n    \n    # Print the results\n    if results:\n        for result in results:\n            print(result)\n    else:\n        print(-1)\n\n# Read input\nn = int(input().strip())\n\n# Find and print the possible number of teams\nfind_teams(n)"}
{"solution": "def max_beauty(n, s, b):\n    from collections import Counter\n\n    # Count the frequency of each character in the string\n    freq = Counter(s)\n    \n    # Sort the beauty values in descending order\n    sorted_beauty = sorted(b, reverse=True)\n    \n    # Create a list of characters sorted by their frequency in descending order\n    sorted_chars = sorted(freq.keys(), key=lambda x: -freq[x])\n    \n    # Create the antipalindromic string\n    t = [''] * n\n    idx = 0\n    for char in sorted_chars:\n        for _ in range(freq[char]):\n            t[idx] = char\n            idx += 1\n    \n    # Calculate the maximum possible beauty\n    max_beauty = 0\n    for i in range(n):\n        if t[i] == s[i]:\n            max_beauty += sorted_beauty[i]\n    \n    return max_beauty\n\n# Read input\nn = int(input())\ns = input().strip()\nb = list(map(int, input().split()))\n\n# Get the result and print it\nresult = max_beauty(n, s, b)\nprint(result)"}
{"solution": "def can_weigh(w, m):\n    while m > 0:\n        if m % w == 0 or m % w == 1:\n            m //= w\n        elif m % w == w - 1:\n            m = m // w + 1\n        else:\n            return \"NO\"\n    return \"YES\"\n\n# Read input\nw, m = map(int, input().split())\n\n# Print the result\nprint(can_weigh(w, m))"}
{"solution": "def solve(n, k):\n    if k > n:\n        print(\"No\")\n        return\n\n    powers = []\n    for i in range(60, -61, -1):\n        if n >= (1 << i):\n            powers.append(i)\n            n -= (1 << i)\n\n    if len(powers) > k:\n        print(\"No\")\n        return\n\n    while len(powers) < k:\n        smallest = powers.pop()\n        powers.append(smallest - 1)\n        powers.append(smallest - 1)\n\n    powers.sort(reverse=True)\n    print(\"Yes\")\n    print(\" \".join(map(str, powers)))\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    solve(n, k)"}
{"solution": "def count_full_glasses(n, t):\n    # Initialize a 2D list to store the amount of champagne in each glass\n    glasses = [[0] * (i + 1) for i in range(n)]\n    \n    # Pour champagne into the top glass\n    glasses[0][0] = t\n    \n    # Distribute the champagne\n    for i in range(n):\n        for j in range(i + 1):\n            if glasses[i][j] > 1:\n                overflow = glasses[i][j] - 1\n                glasses[i][j] = 1\n                if i + 1 < n:\n                    glasses[i + 1][j] += overflow / 2\n                    glasses[i + 1][j + 1] += overflow / 2\n    \n    # Count the number of full glasses\n    full_glasses = sum(1 for i in range(n) for j in range(i + 1) if glasses[i][j] == 1)\n    \n    return full_glasses\n\n# Read input\nn, t = map(int, input().split())\n\n# Print the result\nprint(count_full_glasses(n, t))"}
{"solution": "def calculate_area(vertices):\n    if len(vertices) == 1:\n        return -1\n    elif len(vertices) == 2:\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        return abs(x2 - x1) * abs(y2 - y1)\n    elif len(vertices) == 3:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x2 - x1) * abs(y2 - y1)\n        else:\n            return -1\n    elif len(vertices) == 4:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x2 - x1) * abs(y2 - y1)\n        else:\n            return -1\n\nn = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\nprint(calculate_area(vertices))"}
{"solution": "def minimal_wooden_bars(n, a, b):\n    total_length_needed = 4 * a + 2 * b\n    bars_needed = (total_length_needed + n - 1) // n\n    return bars_needed\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = int(input())\n    b = int(input())\n    print(minimal_wooden_bars(n, a, b))"}
{"solution": "def can_sort_array(n, a, s):\n    segments = []\n    start = 0\n\n    for i in range(n - 1):\n        if s[i] == '0':\n            segments.append((start, i))\n            start = i + 1\n    segments.append((start, n - 1))\n\n    for start, end in segments:\n        segment = a[start:end + 1]\n        if segment != sorted(segment):\n            return \"NO\"\n    return \"YES\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\ns = input().strip()\n\n# Output result\nprint(can_sort_array(n, a, s))"}
{"solution": "def time_to_get_lunch(seat):\n    row = int(seat[:-1])\n    seat_letter = seat[-1]\n    \n    # Time to serve one row\n    time_per_row = 6\n    \n    # Determine the base time for the row\n    if row % 4 == 1 or row % 4 == 2:\n        base_time = (row - 1) // 2 * (time_per_row + 1)\n    else:\n        base_time = ((row - 1) // 2 + 1) * (time_per_row + 1) - 1\n    \n    # Determine the additional time based on the seat letter\n    seat_time = {\n        'a': 5,\n        'b': 4,\n        'c': 3,\n        'd': 3,\n        'e': 2,\n        'f': 1\n    }\n    \n    return base_time + seat_time[seat_letter]\n\n# Read input\nseat = input().strip()\n\n# Calculate and print the result\nprint(time_to_get_lunch(seat))"}
{"solution": "def convert_to_decimal(digits, base):\n    decimal_value = 0\n    for digit in digits:\n        decimal_value = decimal_value * base + digit\n    return decimal_value\n\n# Read input\nn, b_x = map(int, input().split())\nx_digits = list(map(int, input().split()))\nm, b_y = map(int, input().split())\ny_digits = list(map(int, input().split()))\n\n# Convert both numbers to decimal\nX = convert_to_decimal(x_digits, b_x)\nY = convert_to_decimal(y_digits, b_y)\n\n# Compare and print the result\nif X < Y:\n    print('<')\nelif X > Y:\n    print('>')\nelse:\n    print('=')"}
{"solution": "def determine_winner(n, a):\n    if n == 1:\n        return \"BitLGM\" if a[0] > 0 else \"BitAryo\"\n    elif n == 2:\n        return \"BitLGM\" if a[0] != a[1] else \"BitAryo\"\n    else:\n        xor_sum = a[0] ^ a[1] ^ a[2]\n        return \"BitLGM\" if xor_sum != 0 else \"BitAryo\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, a))"}
{"solution": "def count_valid_decks(n, k, cards):\n    from math import gcd\n    from functools import reduce\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def product_mod_k(arr, k):\n        result = 1\n        for num in arr:\n            result = (result * num) % k\n            if result == 0:\n                return 0\n        return result\n\n    total_ways = 0\n\n    for x in range(n):\n        for y in range(n - x):\n            if x + y < n:\n                sub_deck = cards[x:n-y]\n                if product_mod_k(sub_deck, k) == 0:\n                    total_ways += 1\n\n    return total_ways\n\n# Read input\nn, k = map(int, input().split())\ncards = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_valid_decks(n, k, cards))"}
{"solution": "def can_distribute_balloons(n, k, s):\n    from collections import Counter\n    \n    balloon_counts = Counter(s)\n    \n    for count in balloon_counts.values():\n        if count > k:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Print the result\nprint(can_distribute_balloons(n, k, s))"}
{"solution": "n = int(input())\narr = list(map(int, input().split()))\n\nmin_val = min(arr)\nmin_indices = [i for i, x in enumerate(arr) if x == min_val]\n\nmin_distance = float('inf')\nfor i in range(1, len(min_indices)):\n    min_distance = min(min_distance, min_indices[i] - min_indices[i - 1])\n\nprint(min_distance)"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(t, w, b):\n    if w > b:\n        w, b = b, w\n\n    l = lcm(w, b)\n    full_cycles = t // l\n    remainder = t % l\n\n    tie_count = full_cycles * w + min(w - 1, remainder)\n    tie_count += min(w - 1, t)\n\n    p = tie_count\n    q = t\n\n    g = gcd(p, q)\n    p //= g\n    q //= g\n\n    print(f\"{p}/{q}\")\n\n# Read input\nt, w, b = map(int, input().split())\n\n# Solve the problem\nsolve(t, w, b)"}
{"solution": "def determine_result(x, y, z):\n    if x > y + z:\n        return \"+\"\n    elif y > x + z:\n        return \"-\"\n    elif x == y and z == 0:\n        return \"0\"\n    else:\n        return \"?\"\n\n# Read input\nx, y, z = map(int, input().split())\n\n# Determine and print the result\nprint(determine_result(x, y, z))"}
{"solution": "def min_length_to_reach_target(n, operations, x, y):\n    # Calculate the final position after all operations\n    final_x, final_y = 0, 0\n    for op in operations:\n        if op == 'U':\n            final_y += 1\n        elif op == 'D':\n            final_y -= 1\n        elif op == 'L':\n            final_x -= 1\n        elif op == 'R':\n            final_x += 1\n\n    # Calculate the difference between the final position and the target position\n    dx, dy = final_x - x, final_y - y\n\n    # If the difference is zero, no changes are needed\n    if dx == 0 and dy == 0:\n        return 0\n\n    # Use a sliding window to find the minimum length subsegment to change\n    min_length = float('inf')\n    current_dx, current_dy = 0, 0\n    left = 0\n\n    for right in range(n):\n        if operations[right] == 'U':\n            current_dy += 1\n        elif operations[right] == 'D':\n            current_dy -= 1\n        elif operations[right] == 'L':\n            current_dx -= 1\n        elif operations[right] == 'R':\n            current_dx += 1\n\n        while current_dx == dx and current_dy == dy:\n            min_length = min(min_length, right - left + 1)\n            if operations[left] == 'U':\n                current_dy -= 1\n            elif operations[left] == 'D':\n                current_dy += 1\n            elif operations[left] == 'L':\n                current_dx += 1\n            elif operations[left] == 'R':\n                current_dx -= 1\n            left += 1\n\n    return min_length if min_length != float('inf') else -1\n\n# Read input\nn = int(input())\noperations = input().strip()\nx, y = map(int, input().split())\n\n# Get the result and print it\nresult = min_length_to_reach_target(n, operations, x, y)\nprint(result)"}
{"solution": "def count_prefixes_with_balance(n, x, s):\n    balance = 0\n    balance_counts = {0: 1}\n    for char in s:\n        if char == '0':\n            balance += 1\n        else:\n            balance -= 1\n        if balance in balance_counts:\n            balance_counts[balance] += 1\n        else:\n            balance_counts[balance] = 1\n\n    total_balance = balance\n    if total_balance == 0:\n        if x in balance_counts:\n            return -1\n        else:\n            return 0\n\n    count = 0\n    current_balance = 0\n    for i in range(n):\n        if current_balance == x:\n            count += 1\n        if total_balance != 0 and (x - current_balance) % total_balance == 0 and (x - current_balance) // total_balance >= 0:\n            count += 1\n        if s[i] == '0':\n            current_balance += 1\n        else:\n            current_balance -= 1\n\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        n = int(data[index])\n        x = int(data[index + 1])\n        s = data[index + 2]\n        index += 3\n        results.append(count_prefixes_with_balance(n, x, s))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_digits_to_remove(n, k):\n    n_str = str(n)\n    count_zeros_needed = k\n    count_zeros_found = 0\n    digits_to_remove = 0\n\n    for digit in reversed(n_str):\n        if digit == '0':\n            count_zeros_found += 1\n            if count_zeros_found == count_zeros_needed:\n                break\n        else:\n            digits_to_remove += 1\n\n    if count_zeros_found < count_zeros_needed:\n        digits_to_remove += count_zeros_needed - count_zeros_found\n\n    return digits_to_remove\n\n# Read input\nn, k = map(int, input().split())\n\n# Get the result\nresult = min_digits_to_remove(n, k)\n\n# Print the result\nprint(result)"}
{"solution": "def literature_lesson(n, m, k, x, y):\n    if n == 1:\n        max_questions = (k + m - 1) // m\n        min_questions = k // m\n        sergei_questions = (k + y - 1) // m\n    else:\n        full_cycle = 2 * n - 2\n        full_cycle_questions = full_cycle * m\n        full_cycles_completed = k // full_cycle_questions\n        remaining_questions = k % full_cycle_questions\n\n        max_questions = full_cycles_completed * 2\n        min_questions = full_cycles_completed\n\n        if remaining_questions > 0:\n            max_questions += 1\n        if remaining_questions > n * m:\n            max_questions += 1\n\n        sergei_questions = full_cycles_completed\n        if x == 1 or x == n:\n            sergei_questions *= 2\n        else:\n            sergei_questions *= 2\n\n        if remaining_questions > 0:\n            if x == 1:\n                if remaining_questions >= (x - 1) * m + y:\n                    sergei_questions += 1\n            elif x == n:\n                if remaining_questions >= (n - 1) * m + y:\n                    sergei_questions += 1\n            else:\n                if remaining_questions >= (x - 1) * m + y:\n                    sergei_questions += 1\n                if remaining_questions >= (full_cycle - x + 1) * m + y:\n                    sergei_questions += 1\n\n    print(max_questions, min_questions, sergei_questions)\n\n# Example usage\nn, m, k, x, y = map(int, input().split())\nliterature_lesson(n, m, k, x, y)"}
{"solution": "def max_beauty_after_n_turns(ribbon, n):\n    from collections import Counter\n    length = len(ribbon)\n    counter = Counter(ribbon)\n    max_freq = max(counter.values())\n    \n    if max_freq == length and n == 1:\n        return length - 1\n    return min(length, max_freq + n)\n\ndef find_winner(n, ribbons):\n    beauties = [max_beauty_after_n_turns(ribbon, n) for ribbon in ribbons]\n    max_beauty = max(beauties)\n    if beauties.count(max_beauty) > 1:\n        return \"Draw\"\n    if beauties[0] == max_beauty:\n        return \"Kuro\"\n    if beauties[1] == max_beauty:\n        return \"Shiro\"\n    return \"Katie\"\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    ribbons = data[1:4]\n    \n    print(find_winner(n, ribbons))"}
{"solution": "def days_to_finish_book(c, v_0, v_1, a, l):\n    days = 0\n    pages_read = 0\n    current_speed = v_0\n\n    while pages_read < c:\n        days += 1\n        pages_read += current_speed\n        if pages_read >= c:\n            break\n        pages_read -= l\n        current_speed = min(current_speed + a, v_1)\n\n    return days\n\n# Read input\nc, v_0, v_1, a, l = map(int, input().split())\n\n# Calculate and print the number of days needed to finish the book\nprint(days_to_finish_book(c, v_0, v_1, a, l))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_primes(n):\n    if is_prime(n):\n        return [n]\n    for i in range(2, n):\n        if is_prime(i) and is_prime(n - i):\n            return [i, n - i]\n    for i in range(2, n):\n        if is_prime(i):\n            for j in range(2, n - i):\n                if is_prime(j) and is_prime(n - i - j):\n                    return [i, j, n - i - j]\n\nn = int(input().strip())\nresult = find_primes(n)\nprint(len(result))\nprint(\" \".join(map(str, result)))"}
{"solution": "def can_wipe_out_all_walls(n, m, field):\n    row_walls = [0] * n\n    col_walls = [0] * m\n    total_walls = 0\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                row_walls[i] += 1\n                col_walls[j] += 1\n                total_walls += 1\n\n    for i in range(n):\n        for j in range(m):\n            if row_walls[i] + col_walls[j] - (1 if field[i][j] == '*' else 0) == total_walls:\n                print(\"YES\")\n                print(i + 1, j + 1)\n                return\n\n    print(\"NO\")\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Determine if it's possible to wipe out all walls\ncan_wipe_out_all_walls(n, m, field)"}
{"solution": "def minimal_burles(n, m, a, b):\n    remainder = n % m\n    if remainder == 0:\n        return 0\n    build_cost = (m - remainder) * a\n    demolish_cost = remainder * b\n    return min(build_cost, demolish_cost)\n\n# Read input\nn, m, a, b = map(int, input().split())\n\n# Calculate and print the minimal amount of burles\nprint(minimal_burles(n, m, a, b))"}
{"solution": "def max_odd_sum_subsequence(n, a):\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return total_sum\n    \n    min_odd = float('inf')\n    for num in a:\n        if num % 2 != 0:\n            min_odd = min(min_odd, num)\n    \n    return total_sum - min_odd\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = max_odd_sum_subsequence(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef count_playlists(n, T, songs):\n    dp = [[[[0] * 4 for _ in range(T + 1)] for _ in range(1 << n)] for _ in range(n + 1)]\n    dp[0][0][0][0] = 1\n\n    for i in range(n):\n        for mask in range(1 << n):\n            for t in range(T + 1):\n                for last_genre in range(4):\n                    if dp[i][mask][t][last_genre] == 0:\n                        continue\n                    for j in range(n):\n                        if mask & (1 << j):\n                            continue\n                        song_time, song_genre = songs[j]\n                        if t + song_time > T or song_genre == last_genre:\n                            continue\n                        new_mask = mask | (1 << j)\n                        dp[i + 1][new_mask][t + song_time][song_genre] += dp[i][mask][t][last_genre]\n                        dp[i + 1][new_mask][t + song_time][song_genre] %= MOD\n\n    result = 0\n    for i in range(1, n + 1):\n        for last_genre in range(1, 4):\n            result = (result + dp[i][(1 << n) - 1][T][last_genre]) % MOD\n\n    return result\n\nif __name__ == \"__main__\":\n    n, T = map(int, input().split())\n    songs = [tuple(map(int, input().split())) for _ in range(n)]\n    print(count_playlists(n, T, songs))"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_inverse(x, mod):\n    return pow(x, mod - 2, mod)\n\ndef expected_length(m):\n    phi = list(range(m + 1))\n    for i in range(2, m + 1):\n        if phi[i] == i:\n            for j in range(i, m + 1, i):\n                phi[j] *= (i - 1)\n                phi[j] //= i\n\n    P = sum(phi[1:])\n    Q = m\n\n    Q_inv = mod_inverse(Q, MOD)\n    result = (P * Q_inv) % MOD\n    return result\n\nm = int(input())\nprint(expected_length(m))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_good_pairs(l, r, x, y):\n    if y % x != 0:\n        return 0\n    \n    count = 0\n    z = y // x\n    \n    for i in range(1, int(z**0.5) + 1):\n        if z % i == 0:\n            a = i * x\n            b = (z // i) * x\n            if l <= a <= r and l <= b <= r and gcd(a, b) == x and lcm(a, b) == y:\n                if a == b:\n                    count += 1\n                else:\n                    count += 2\n    \n    return count\n\n# Read input\nl, r, x, y = map(int, input().split())\n\n# Print the result\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "import math\n\ndef lcm(x, y):\n    return x * y // math.gcd(x, y)\n\ndef find_min_k(a, b):\n    if a == b:\n        return 0\n    \n    diff = abs(a - b)\n    min_lcm = float('inf')\n    best_k = 0\n    \n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            for d in [i, diff // i]:\n                k = (d - a % d) % d\n                current_lcm = lcm(a + k, b + k)\n                if current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n                    min_lcm = current_lcm\n                    best_k = k\n    \n    return best_k\n\na, b = map(int, input().split())\nprint(find_min_k(a, b))"}
{"solution": "import math\n\ndef minimal_additional_marks(n, k, marks):\n    current_sum = sum(marks)\n    current_count = n\n    \n    while True:\n        average = current_sum / current_count\n        if round(average) == k:\n            return current_count - n\n        current_sum += k\n        current_count += 1\n\n# Read input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(minimal_additional_marks(n, k, marks))"}
{"solution": "import math\n\ndef find_d(n, arr):\n    required_positive_count = math.ceil(n / 2)\n    \n    for d in range(1, 1001):\n        positive_count = sum(1 for x in arr if x / d > 0)\n        if positive_count >= required_positive_count:\n            return d\n    \n    for d in range(-1, -1001, -1):\n        positive_count = sum(1 for x in arr if x / d > 0)\n        if positive_count >= required_positive_count:\n            return d\n    \n    return 0\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Find and print the result\nprint(find_d(n, arr))"}
{"solution": "def count_pairs_with_max_nines(n):\n    max_nines = 0\n    count = 0\n\n    for i in range(1, n // 2 + 1):\n        j = n - i\n        total_cost = i + j\n        nines = 0\n        while total_cost % 10 == 9:\n            nines += 1\n            total_cost //= 10\n\n        if nines > max_nines:\n            max_nines = nines\n            count = 1\n        elif nines == max_nines:\n            count += 1\n\n    return count\n\nn = int(input())\nprint(count_pairs_with_max_nines(n))"}
{"solution": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef can_be_equal(a1, b1, a2, b2):\n    area1 = a1 * b1\n    area2 = a2 * b2\n    if area1 == area2:\n        return 0, (a1, b1), (a2, b2)\n    \n    g1 = gcd(a1, b1)\n    g2 = gcd(a2, b2)\n    \n    a1 //= g1\n    b1 //= g1\n    a2 //= g2\n    b2 //= g2\n    \n    if a1 * b1 != a2 * b2:\n        return -1, None, None\n    \n    return 1, (a1 * g1, b1 * g1), (a2 * g2, b2 * g2)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    a1, b1 = int(data[0]), int(data[1])\n    a2, b2 = int(data[2]), int(data[3])\n    \n    minutes, (new_a1, new_b1), (new_a2, new_b2) = can_be_equal(a1, b1, a2, b2)\n    \n    if minutes == -1:\n        print(-1)\n    else:\n        print(minutes)\n        print(new_a1, new_b1)\n        print(new_a2, new_b2)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def determine_winner(xp, yp, xv, yv):\n    if max(xp, yp) <= max(xv, yv):\n        return \"Polycarp\"\n    else:\n        return \"Vasiliy\"\n\n# Read input\nxp, yp, xv, yv = map(int, input().split())\n\n# Determine and print the winner\nprint(determine_winner(xp, yp, xv, yv))"}
{"solution": "def number_of_columns(m, d):\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    days = days_in_month[m - 1]\n    first_week_days = 8 - d\n    remaining_days = days - first_week_days\n    full_weeks = (remaining_days + 6) // 7\n    total_columns = 1 + full_weeks\n    return total_columns\n\n# Read input\nm, d = map(int, input().split())\n\n# Calculate and print the number of columns\nprint(number_of_columns(m, d))"}
{"solution": "def count_years_with_one_zero(a, b):\n    def has_exactly_one_zero_in_binary(n):\n        binary_representation = bin(n)[2:]\n        return binary_representation.count('0') == 1\n\n    count = 0\n    for year in range(a, b + 1):\n        if has_exactly_one_zero_in_binary(year):\n            count += 1\n\n    return count\n\n# Read input\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(count_years_with_one_zero(a, b))"}
{"solution": "def minimal_layers(N):\n    return (N * (N + 1)) // 2\n\n# Read input\nN = int(input().strip())\n\n# Calculate and print the minimal number of layers\nprint(minimal_layers(N))"}
{"solution": "from itertools import combinations\nfrom math import factorial\n\ndef count_ways(n, k, S, a):\n    # Precompute factorials for all numbers in a\n    factorials = {x: factorial(x) for x in set(a)}\n    \n    # Function to calculate the number of ways to achieve the sum S\n    def calculate_ways(index, remaining_k, current_sum):\n        if current_sum == S:\n            return 1\n        if index == n or current_sum > S:\n            return 0\n        \n        ways = 0\n        # Option 1: Do not choose the current cube\n        ways += calculate_ways(index + 1, remaining_k, current_sum)\n        \n        # Option 2: Choose the current cube without sticking a sticker\n        ways += calculate_ways(index + 1, remaining_k, current_sum + a[index])\n        \n        # Option 3: Choose the current cube and stick a sticker (if we have stickers left)\n        if remaining_k > 0:\n            ways += calculate_ways(index + 1, remaining_k - 1, current_sum + factorials[a[index]])\n        \n        return ways\n    \n    return calculate_ways(0, k, 0)\n\n# Read input\nn, k, S = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_ways(n, k, S, a))"}
{"solution": "def can_achieve_array(n, k, a):\n    max_power = 0\n    while k ** max_power <= 10**16:\n        max_power += 1\n\n    powers = [0] * max_power\n    for num in a:\n        for i in range(max_power - 1, -1, -1):\n            if num >= k ** i:\n                num -= k ** i\n                powers[i] += 1\n                if powers[i] > 1:\n                    return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        a = list(map(int, data[index:index + n]))\n        index += n\n        results.append(can_achieve_array(n, k, a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 1073741824\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    a, b, c = map(int, data)\n    \n    total_sum = 0\n    \n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                product = i * j * k\n                total_sum += count_divisors(product)\n                total_sum %= MOD\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import deque\n\ndef puzzle_to_tuple(puzzle):\n    return tuple(puzzle[0] + puzzle[1])\n\ndef get_neighbors(puzzle):\n    neighbors = []\n    x, y = [(i, j) for i in range(2) for j in range(2) if puzzle[i][j] == 'X'][0]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    for dx, dy in directions:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < 2 and 0 <= ny < 2:\n            new_puzzle = [list(row) for row in puzzle]\n            new_puzzle[x][y], new_puzzle[nx][ny] = new_puzzle[nx][ny], new_puzzle[x][y]\n            neighbors.append(puzzle_to_tuple(new_puzzle))\n    return neighbors\n\ndef bfs(start, target):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        current = queue.popleft()\n        if current == target:\n            return True\n        for neighbor in get_neighbors([list(current[:2]), list(current[2:])]):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return False\n\nbessie_puzzle = [input().strip() for _ in range(2)]\nelsie_puzzle = [input().strip() for _ in range(2)]\n\nbessie_start = puzzle_to_tuple(bessie_puzzle)\nelsie_start = puzzle_to_tuple(elsie_puzzle)\n\nif bfs(bessie_start, elsie_start):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def convert_to_decimal(n, k):\n    k = str(k)\n    decimal_value = 0\n    power = 0\n    \n    for digit in reversed(k):\n        decimal_value += int(digit) * (n ** power)\n        power += 1\n    \n    return decimal_value\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    k = input().strip()\n    result = convert_to_decimal(n, k)\n    print(result)"}
{"solution": "def is_unimodal(arr):\n    n = len(arr)\n    if n == 1:\n        return True\n    \n    i = 0\n    \n    # Check for strictly increasing part\n    while i < n - 1 and arr[i] < arr[i + 1]:\n        i += 1\n    \n    # Check for constant part\n    while i < n - 1 and arr[i] == arr[i + 1]:\n        i += 1\n    \n    # Check for strictly decreasing part\n    while i < n - 1 and arr[i] > arr[i + 1]:\n        i += 1\n    \n    # If we have traversed the entire array, it is unimodal\n    return i == n - 1\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Check if the array is unimodal\nif is_unimodal(arr):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def max_value_in_k_paths(n, k):\n    def count_occurrences(y):\n        count = 0\n        for i in range(1, n + 1):\n            x = i\n            while x >= y:\n                if x == y:\n                    count += 1\n                    break\n                if x % 2 == 0:\n                    x //= 2\n                else:\n                    x -= 1\n        return count\n\n    left, right = 1, n\n    result = 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if count_occurrences(mid) >= k:\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the result\nprint(max_value_in_k_paths(n, k))"}
{"solution": "def find_pocket(n, m, x, y, vx, vy):\n    if vx == 0:\n        if vy == 1:\n            if y == m:\n                return -1\n            else:\n                return (x, m)\n        elif vy == -1:\n            if y == 0:\n                return -1\n            else:\n                return (x, 0)\n    elif vy == 0:\n        if vx == 1:\n            if x == n:\n                return -1\n            else:\n                return (n, y)\n        elif vx == -1:\n            if x == 0:\n                return -1\n            else:\n                return (0, y)\n    else:\n        if vx == 1 and vy == 1:\n            t1 = (n - x) // vx\n            t2 = (m - y) // vy\n            t = min(t1, t2)\n            if t1 == t2:\n                return (n, m)\n            elif t1 < t2:\n                return (n, y + t * vy)\n            else:\n                return (x + t * vx, m)\n        elif vx == 1 and vy == -1:\n            t1 = (n - x) // vx\n            t2 = y // -vy\n            t = min(t1, t2)\n            if t1 == t2:\n                return (n, 0)\n            elif t1 < t2:\n                return (n, y + t * vy)\n            else:\n                return (x + t * vx, 0)\n        elif vx == -1 and vy == 1:\n            t1 = x // -vx\n            t2 = (m - y) // vy\n            t = min(t1, t2)\n            if t1 == t2:\n                return (0, m)\n            elif t1 < t2:\n                return (0, y + t * vy)\n            else:\n                return (x + t * vx, m)\n        elif vx == -1 and vy == -1:\n            t1 = x // -vx\n            t2 = y // -vy\n            t = min(t1, t2)\n            if t1 == t2:\n                return (0, 0)\n            elif t1 < t2:\n                return (0, y + t * vy)\n            else:\n                return (x + t * vx, 0)\n    return -1\n\n# Read input\nn, m, x, y, vx, vy = map(int, input().split())\n\n# Find the pocket\nresult = find_pocket(n, m, x, y, vx, vy)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(result[0], result[1])"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    # Check all possible orientations of the paintings\n    orientations = [\n        (a2, b2, a3, b3),\n        (a2, b2, b3, a3),\n        (b2, a2, a3, b3),\n        (b2, a2, b3, a3)\n    ]\n    \n    for w2, h2, w3, h3 in orientations:\n        if (w2 + w3 <= a1 and max(h2, h3) <= b1) or (w2 + w3 <= b1 and max(h2, h3) <= a1):\n            return \"YES\"\n        if (h2 + h3 <= b1 and max(w2, w3) <= a1) or (h2 + h3 <= a1 and max(w2, w3) <= b1):\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\n# Print the result\nprint(can_place_paintings(a1, b1, a2, b2, a3, b3))"}
{"solution": "def count_written_terms(b1, q, l, m, bad_integers):\n    bad_set = set(bad_integers)\n    count = 0\n\n    if abs(b1) > l:\n        return 0\n\n    if b1 == 0:\n        if 0 in bad_set:\n            return 0\n        else:\n            return \"inf\"\n\n    if q == 0:\n        if 0 in bad_set:\n            if b1 in bad_set:\n                return 0\n            else:\n                return 1\n        else:\n            if b1 in bad_set:\n                return \"inf\"\n            else:\n                return \"inf\"\n\n    if q == 1:\n        if b1 in bad_set:\n            return 0\n        else:\n            return \"inf\"\n\n    if q == -1:\n        if b1 in bad_set and -b1 in bad_set:\n            return 0\n        else:\n            return \"inf\"\n\n    current_term = b1\n    while abs(current_term) <= l:\n        if current_term not in bad_set:\n            count += 1\n        current_term *= q\n\n    return count\n\n# Read input\nb1, q, l, m = map(int, input().split())\nbad_integers = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_written_terms(b1, q, l, m, bad_integers))"}
{"solution": "def find_frame(n, m, screen):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n\n    # Find the bounding box of all white pixels\n    for i in range(n):\n        for j in range(m):\n            if screen[i][j] == 'w':\n                if i < min_row:\n                    min_row = i\n                if i > max_row:\n                    max_row = i\n                if j < min_col:\n                    min_col = j\n                if j > max_col:\n                    max_col = j\n\n    # Calculate the size of the frame\n    frame_size = max(max_row - min_row + 1, max_col - min_col + 1)\n\n    # Check if the frame fits within the screen\n    if min_row + frame_size > n or min_col + frame_size > m:\n        return -1\n\n    # Create a new screen with the frame\n    new_screen = [list(row) for row in screen]\n    for i in range(frame_size):\n        for j in range(frame_size):\n            if i == 0 or i == frame_size - 1 or j == 0 or j == frame_size - 1:\n                if new_screen[min_row + i][min_col + j] == '.':\n                    new_screen[min_row + i][min_col + j] = '+'\n\n    return new_screen\n\n# Read input\nn, m = map(int, input().split())\nscreen = [input().strip() for _ in range(n)]\n\n# Find the frame\nresult = find_frame(n, m, screen)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(''.join(row))"}
{"solution": "def find_combination(n, a, b):\n    for x in range(n // a + 1):\n        if (n - x * a) % b == 0:\n            y = (n - x * a) // b\n            print(\"YES\")\n            print(x, y)\n            return\n    print(\"NO\")\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\n\n# Find and print the combination\nfind_combination(n, a, b)"}
{"solution": "def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\ns = int(input())\nprint(number_to_words(s))"}
{"solution": "def max_erase_length(n, arr):\n    max_erase = 0\n    for i in range(n):\n        for j in range(i, n):\n            if i == 0 or j == n - 1 or arr[j + 1] - arr[i - 1] == j - i + 2:\n                max_erase = max(max_erase, j - i + 1)\n    return max_erase\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_erase_length(n, arr))"}
{"solution": "def find_equator_day(n, problems):\n    total_problems = sum(problems)\n    half_problems = (total_problems + 1) // 2\n    \n    current_sum = 0\n    for i in range(n):\n        current_sum += problems[i]\n        if current_sum >= half_problems:\n            return i + 1\n\n# Read input\nn = int(input())\nproblems = list(map(int, input().split()))\n\n# Find and print the equator day\nprint(find_equator_day(n, problems))"}
{"solution": "from collections import deque\n\n# Define the moves for each piece\nknight_moves = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)]\nbishop_moves = [(i, i) for i in range(1, 10)] + [(i, -i) for i in range(1, 10)] + [(-i, i) for i in range(1, 10)] + [(-i, -i) for i in range(1, 10)]\nrook_moves = [(i, 0) for i in range(1, 10)] + [(-i, 0) for i in range(1, 10)] + [(0, i) for i in range(1, 10)] + [(0, -i) for i in range(1, 10)]\n\n# Read input\nN = int(input())\nboard = []\npositions = {}\nfor i in range(N):\n    row = list(map(int, input().split()))\n    board.append(row)\n    for j in range(N):\n        positions[row[j]] = (i, j)\n\n# BFS to find the shortest path\ndef bfs(start, end, piece):\n    queue = deque([(start[0], start[1], 0)])  # (x, y, steps)\n    visited = set()\n    visited.add((start[0], start[1]))\n    moves = knight_moves if piece == 'knight' else bishop_moves if piece == 'bishop' else rook_moves\n    \n    while queue:\n        x, y, steps = queue.popleft()\n        if (x, y) == end:\n            return steps\n        for dx, dy in moves:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, steps + 1))\n    return float('inf')\n\n# Find the minimum steps and replacements\nmin_steps = float('inf')\nmin_replacements = float('inf')\n\nfor start_piece in ['knight', 'bishop', 'rook']:\n    steps = 0\n    replacements = 0\n    current_piece = start_piece\n    for num in range(1, N * N):\n        start = positions[num]\n        end = positions[num + 1]\n        step_count = bfs(start, end, current_piece)\n        if step_count == float('inf'):\n            break\n        steps += step_count\n        if current_piece != 'knight':\n            current_piece = 'knight'\n            replacements += 1\n        elif current_piece != 'bishop':\n            current_piece = 'bishop'\n            replacements += 1\n        elif current_piece != 'rook':\n            current_piece = 'rook'\n            replacements += 1\n    else:\n        if steps < min_steps or (steps == min_steps and replacements < min_replacements):\n            min_steps = steps\n            min_replacements = replacements\n\nprint(min_steps, min_replacements)"}
{"solution": "def min_time_to_reach(n, m, k, a, b):\n    def get_entrance_and_floor(apartment):\n        entrance = (apartment - 1) // (m * k) + 1\n        floor = ((apartment - 1) % (m * k)) // k + 1\n        return entrance, floor\n\n    a_entrance, a_floor = get_entrance_and_floor(a)\n    b_entrance, b_floor = get_entrance_and_floor(b)\n\n    # Time to get from a's floor to the ground floor using the elevator\n    if a_floor == 1:\n        time_to_ground = 0\n    else:\n        time_to_ground = 10 + (a_floor - 1)\n\n    # Time to walk to b's entrance\n    clockwise_distance = (b_entrance - a_entrance) % n\n    counterclockwise_distance = (a_entrance - b_entrance) % n\n    walk_time = min(clockwise_distance, counterclockwise_distance) * 15\n\n    # Time to climb to b's floor using stairs\n    climb_time = (b_floor - 1) * 5\n\n    return time_to_ground + walk_time + climb_time\n\n# Read input\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(min_time_to_reach(n, m, k, a, b))"}
{"solution": "def is_divisible_by_64(s):\n    # We need at least one '1' followed by six '0's to form a number divisible by 64\n    if '1' in s:\n        index_of_first_one = s.index('1')\n        if s[index_of_first_one:].count('0') >= 6:\n            return \"yes\"\n    return \"no\"\n\n# Read input\ns = input().strip()\n\n# Print the result\nprint(is_divisible_by_64(s))"}
{"solution": "def get_alphabet_subsequence(s):\n    target = \"abcdefghijklmnopqrstuvwxyz\"\n    target_index = 0\n    s = list(s)\n    \n    for i in range(len(s)):\n        if target_index < len(target) and s[i] <= target[target_index]:\n            s[i] = target[target_index]\n            target_index += 1\n        if target_index == len(target):\n            return ''.join(s)\n    \n    return \"-1\"\n\n# Read input\ns = input().strip()\n# Print the result\nprint(get_alphabet_subsequence(s))"}
{"solution": "def max_expected_fishes(n, m, r, k):\n    def count_positions(x, y):\n        return (min(x, n - r + 1) - max(1, x - r + 1) + 1) * (min(y, m - r + 1) - max(1, y - r + 1) + 1)\n\n    total_positions = (n - r + 1) * (m - r + 1)\n    fish_positions = []\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            fish_positions.append((count_positions(i, j), i, j))\n\n    fish_positions.sort(reverse=True, key=lambda x: x[0])\n\n    max_fishes = 0\n    for i in range(k):\n        max_fishes += fish_positions[i][0]\n\n    return max_fishes / total_positions\n\n# Read input\nn, m, r, k = map(int, input().split())\n\n# Calculate and print the result\nresult = max_expected_fishes(n, m, r, k)\nprint(f\"{result:.10f}\")"}
{"solution": "def maximize_product(n, a):\n    # Apply the operation to all non-negative numbers\n    for i in range(n):\n        if a[i] >= 0:\n            a[i] = -a[i] - 1\n    \n    # If the number of elements is odd, we need to flip one element back\n    if n % 2 != 0:\n        # Find the element with the smallest absolute value\n        min_index = 0\n        for i in range(1, n):\n            if abs(a[i]) < abs(a[min_index]):\n                min_index = i\n        # Flip it back\n        a[min_index] = -a[min_index] - 1\n    \n    return a\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = maximize_product(n, a)\n\n# Print the result\nprint(' '.join(map(str, result)))"}
{"solution": "def kth_smallest_divisor(n, k):\n    divisors = []\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.sort()\n    \n    if k > len(divisors):\n        return -1\n    else:\n        return divisors[k-1]\n\n# Read input\nn, k = map(int, input().split())\n\n# Find and print the k-th smallest divisor\nprint(kth_smallest_divisor(n, k))"}
{"solution": "def can_form_number(cubes, number):\n    str_num = str(number)\n    for digit in str_num:\n        found = False\n        for cube in cubes:\n            if int(digit) in cube:\n                found = True\n                break\n        if not found:\n            return False\n    return True\n\ndef max_number(cubes):\n    x = 1\n    while True:\n        if not can_form_number(cubes, x):\n            return x - 1\n        x += 1\n\nn = int(input())\ncubes = []\nfor _ in range(n):\n    cubes.append(list(map(int, input().split())))\n\nprint(max_number(cubes))"}
{"solution": "def k_rounding(n, k):\n    multiplier = 10 ** k\n    x = (n + multiplier - 1) // multiplier * multiplier\n    print(x)\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    n = int(data[0])\n    k = int(data[1])\n    k_rounding(n, k)"}
{"solution": "def solve(n, m, A):\n    B = [[0] * m for _ in range(n)]\n    operations = []\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1\n                operations.append((i + 1, j + 1))\n\n    if B == A:\n        print(len(operations))\n        for op in operations:\n            print(op[0], op[1])\n    else:\n        print(-1)\n\n# Read input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nsolve(n, m, A)"}
{"solution": "def bad_luck_island(r, s, p):\n    dp = [[[0.0 for _ in range(p+1)] for _ in range(s+1)] for _ in range(r+1)]\n    dp[r][s][p] = 1.0\n\n    for i in range(r, -1, -1):\n        for j in range(s, -1, -1):\n            for k in range(p, -1, -1):\n                total_pairs = i * j + j * k + k * i\n                if total_pairs == 0:\n                    continue\n                if i > 0 and j > 0:\n                    dp[i][j-1][k] += dp[i][j][k] * (i * j) / total_pairs\n                if j > 0 and k > 0:\n                    dp[i][j][k-1] += dp[i][j][k] * (j * k) / total_pairs\n                if k > 0 and i > 0:\n                    dp[i-1][j][k] += dp[i][j][k] * (k * i) / total_pairs\n\n    pr = sum(dp[i][0][0] for i in range(r+1))\n    ps = sum(dp[0][j][0] for j in range(s+1))\n    pp = sum(dp[0][0][k] for k in range(p+1))\n\n    return pr, ps, pp\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    r, s, p = map(int, input().strip().split())\n    pr, ps, pp = bad_luck_island(r, s, p)\n    print(f\"{pr:.12f} {ps:.12f} {pp:.12f}\")"}
{"solution": "def calculate_time_together(l1, r1, l2, r2, k):\n    start = max(l1, l2)\n    end = min(r1, r2)\n    \n    if start > end:\n        return 0\n    \n    total_time = end - start + 1\n    \n    if start <= k <= end:\n        total_time -= 1\n    \n    return total_time\n\n# Read input\nl1, r1, l2, r2, k = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_time_together(l1, r1, l2, r2, k))"}
{"solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    north_south_lines = []\n    east_west_lines = []\n    \n    index = 2\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        C = int(data[index + 2])\n        north_south_lines.append((A, B, C))\n        index += 3\n    \n    for _ in range(M):\n        D = int(data[index])\n        E = int(data[index + 1])\n        F = int(data[index + 2])\n        east_west_lines.append((D, E, F))\n        index += 3\n    \n    min_x = -float('inf')\n    max_x = float('inf')\n    min_y = -float('inf')\n    max_y = float('inf')\n    \n    for A, B, C in north_south_lines:\n        if C == 0:\n            min_x = max(min_x, B)\n        elif C == 1:\n            max_x = min(max_x, A)\n    \n    for D, E, F in east_west_lines:\n        if D == 0:\n            min_y = max(min_y, F)\n        elif D == 1:\n            max_y = min(max_y, E)\n    \n    if min_x == -float('inf') or max_x == float('inf') or min_y == -float('inf') or max_y == float('inf'):\n        print(\"INF\")\n    else:\n        width = max_x - min_x\n        height = max_y - min_y\n        if width < 0 or height < 0:\n            print(\"0\")\n        else:\n            print(width * height)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "t, s, x = map(int, input().split())\n\nif x == t:\n    print(\"YES\")\nelif x > t and ((x - t) % s == 0 or (x - t - 1) % s == 0 and x != t + 1):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\nsegments = []\n\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r, i + 1))\n\nsegments.sort()\n\nmin_r = float('inf')\nmin_r_index = -1\n\nfor l, r, index in segments:\n    if r <= min_r:\n        min_r = r\n        min_r_index = index\n    else:\n        print(min_r_index, index)\n        exit()\n\nprint(-1, -1)"}
{"solution": "def decode_genome(n, s):\n    if n % 4 != 0:\n        return \"===\"\n\n    count = {'A': 0, 'C': 0, 'G': 0, 'T': 0, '?': 0}\n    for char in s:\n        count[char] += 1\n\n    required_each = n // 4\n    for nucleotide in 'ACGT':\n        if count[nucleotide] > required_each:\n            return \"===\"\n\n    for nucleotide in 'ACGT':\n        count['?'] -= (required_each - count[nucleotide])\n        count[nucleotide] = required_each\n\n    if count['?'] != 0:\n        return \"===\"\n\n    result = []\n    for char in s:\n        if char == '?':\n            for nucleotide in 'ACGT':\n                if count[nucleotide] > 0:\n                    result.append(nucleotide)\n                    count[nucleotide] -= 1\n                    break\n        else:\n            result.append(char)\n\n    return ''.join(result)\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Decode genome and print result\nprint(decode_genome(n, s))"}
{"solution": "def check_win(board, x, y):\n    # Check horizontal\n    if y <= 1 and board[x][y] == 'x' and board[x][y+1] == 'x' and board[x][y+2] == 'x':\n        return True\n    if y >= 1 and y <= 2 and board[x][y-1] == 'x' and board[x][y] == 'x' and board[x][y+1] == 'x':\n        return True\n    if y >= 2 and board[x][y-2] == 'x' and board[x][y-1] == 'x' and board[x][y] == 'x':\n        return True\n\n    # Check vertical\n    if x <= 1 and board[x][y] == 'x' and board[x+1][y] == 'x' and board[x+2][y] == 'x':\n        return True\n    if x >= 1 and x <= 2 and board[x-1][y] == 'x' and board[x][y] == 'x' and board[x+1][y] == 'x':\n        return True\n    if x >= 2 and board[x-2][y] == 'x' and board[x-1][y] == 'x' and board[x][y] == 'x':\n        return True\n\n    # Check diagonal\n    if x <= 1 and y <= 1 and board[x][y] == 'x' and board[x+1][y+1] == 'x' and board[x+2][y+2] == 'x':\n        return True\n    if x >= 1 and x <= 2 and y >= 1 and y <= 2 and board[x-1][y-1] == 'x' and board[x][y] == 'x' and board[x+1][y+1] == 'x':\n        return True\n    if x >= 2 and y >= 2 and board[x-2][y-2] == 'x' and board[x-1][y-1] == 'x' and board[x][y] == 'x':\n        return True\n\n    if x <= 1 and y >= 2 and board[x][y] == 'x' and board[x+1][y-1] == 'x' and board[x+2][y-2] == 'x':\n        return True\n    if x >= 1 and x <= 2 and y >= 1 and y <= 2 and board[x-1][y+1] == 'x' and board[x][y] == 'x' and board[x+1][y-1] == 'x':\n        return True\n    if x >= 2 and y <= 1 and board[x-2][y+2] == 'x' and board[x-1][y+1] == 'x' and board[x][y] == 'x':\n        return True\n\n    return False\n\ndef can_win(board):\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                board[i][j] = 'x'\n                if check_win(board, i, j):\n                    return True\n                board[i][j] = '.'\n    return False\n\nboard = [input().strip() for _ in range(4)]\nboard = [list(row) for row in board]\n\nif can_win(board):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def can_divide_after_move(n, a):\n    total_sum = sum(a)\n    \n    if total_sum % 2 != 0:\n        return \"NO\"\n    \n    target = total_sum // 2\n    \n    prefix_sum = 0\n    suffix_sum = total_sum\n    \n    for i in range(n):\n        suffix_sum -= a[i]\n        if prefix_sum == target or suffix_sum == target:\n            return \"YES\"\n        prefix_sum += a[i]\n    \n    prefix_sum = 0\n    suffix_sum = total_sum\n    \n    for i in range(n):\n        suffix_sum -= a[i]\n        if prefix_sum + a[i] == target or suffix_sum + a[i] == target:\n            return \"YES\"\n        prefix_sum += a[i]\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print output\nprint(can_divide_after_move(n, a))"}
{"solution": "def is_possible_to_recover(n, k, a, b):\n    b.sort(reverse=True)\n    j = 0\n    for i in range(n):\n        if a[i] == 0:\n            a[i] = b[j]\n            j += 1\n\n    for i in range(1, n):\n        if a[i] <= a[i - 1]:\n            return \"Yes\"\n    return \"No\"\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Determine if it's possible to recover\nresult = is_possible_to_recover(n, k, a, b)\nprint(result)"}
{"solution": "def can_distribute_grapes(x, y, z, a, b, c):\n    # Andrew takes x green grapes\n    if a < x:\n        return \"NO\"\n    a -= x\n    \n    # Dmitry takes y grapes from remaining green and purple grapes\n    if a + b < y:\n        return \"NO\"\n    remaining_grapes = a + b - y\n    \n    # Michal takes z grapes from remaining grapes\n    if remaining_grapes + c < z:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Print the result\nprint(can_distribute_grapes(x, y, z, a, b, c))"}
{"solution": "def is_accident_possible(lights):\n    for i in range(4):\n        l, s, r, p = lights[i]\n        if p == 1:\n            if l == 1 or s == 1 or r == 1:\n                return \"YES\"\n            if lights[(i + 1) % 4][0] == 1 or lights[(i + 2) % 4][1] == 1 or lights[(i + 3) % 4][2] == 1:\n                return \"YES\"\n    return \"NO\"\n\nlights = [list(map(int, input().split())) for _ in range(4)]\nprint(is_accident_possible(lights))"}
{"solution": "def get_vector(a, b):\n    keypad = {\n        '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2),\n        '0': (3, 1)\n    }\n    return (keypad[b][0] - keypad[a][0], keypad[b][1] - keypad[a][1])\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    number = data[1]\n    \n    if n == 1:\n        print(\"YES\")\n        return\n    \n    movements = []\n    for i in range(n - 1):\n        movements.append(get_vector(number[i], number[i + 1]))\n    \n    unique_movements = set(movements)\n    \n    if len(unique_movements) == len(movements):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_sold_products(n, f, days):\n    # Calculate the initial sales without any sell-out days\n    initial_sales = [min(k, l) for k, l in days]\n    # Calculate the potential increase in sales if a sell-out day is chosen\n    potential_increase = [min(2 * k, l) - min(k, l) for k, l in days]\n    \n    # Sort the potential increases in descending order\n    potential_increase.sort(reverse=True)\n    \n    # Sum the initial sales\n    total_sales = sum(initial_sales)\n    \n    # Add the top f potential increases to the total sales\n    total_sales += sum(potential_increase[:f])\n    \n    return total_sales\n\n# Read input\nn, f = map(int, input().split())\ndays = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(max_sold_products(n, f, days))"}
{"solution": "def max_messiness(n, k):\n    # The maximum number of inversions in an array of size n is n * (n - 1) / 2\n    max_inversions = n * (n - 1) // 2\n    \n    # If k is large enough to reverse the entire array, we can achieve the maximum number of inversions\n    if k >= n // 2:\n        return max_inversions\n    \n    # Otherwise, we can achieve at most k * (2 * n - 2 * k - 1) inversions\n    return k * (2 * n - 2 * k - 1)\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the maximum messiness\nprint(max_messiness(n, k))"}
{"solution": "def min_coins_per_friend(N, M, K, L):\n    # Check if it's possible to satisfy the conditions\n    if M > N:\n        return -1\n    \n    # Calculate the minimum number of new coins needed\n    min_new_coins_needed = L\n    \n    # Calculate the total number of coins needed\n    total_coins_needed = K + min_new_coins_needed\n    \n    # Check if it's possible to have at least L new coins\n    if total_coins_needed > N:\n        return -1\n    \n    # Calculate the minimum number of coins each friend should gift\n    min_coins_per_friend = (total_coins_needed + M - 1) // M\n    \n    # Check if the total number of coins gifted by all friends is within the limit\n    if min_coins_per_friend * M > N:\n        return -1\n    \n    return min_coins_per_friend\n\n# Read input\nN, M, K, L = map(int, input().split())\n\n# Get the result\nresult = min_coins_per_friend(N, M, K, L)\n\n# Print the result\nprint(result)"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    # Find the bounds of the black cells\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # If there are no black cells\n    if min_row == n:\n        return 1\n    \n    # Calculate the side length of the square\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    \n    # If the square doesn't fit in the grid\n    if side_length > n or side_length > m:\n        return -1\n    \n    # Calculate the number of cells to paint\n    cells_to_paint = 0\n    for i in range(min_row, min_row + side_length):\n        for j in range(min_col, min_col + side_length):\n            if i >= n or j >= m or grid[i][j] == 'W':\n                cells_to_paint += 1\n    \n    return cells_to_paint\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Get the result and print it\nresult = min_cells_to_paint(n, m, grid)\nprint(result)"}
{"solution": "def can_be_consistent(n, x, y):\n    if sum(x) < sum(y):\n        return \"No\"\n    return \"Yes\"\n\n# Read input\nn = int(input().strip())\nx = list(map(int, input().strip().split()))\ny = list(map(int, input().strip().split()))\n\n# Check if the records can be consistent\nresult = can_be_consistent(n, x, y)\nprint(result)"}
{"solution": "def minimal_difference(n, angles):\n    total_sum = sum(angles)\n    min_diff = float('inf')\n    \n    for i in range(1 << n):\n        subset_sum = 0\n        for j in range(n):\n            if i & (1 << j):\n                subset_sum += angles[j]\n        other_sum = total_sum - subset_sum\n        min_diff = min(min_diff, abs(subset_sum - other_sum))\n    \n    return min_diff\n\n# Read input\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Calculate and print the minimal difference\nprint(minimal_difference(n, angles))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, m):\n    return (pow(2, m, MOD) - 1) ** n % MOD\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    print(count_ways(n, m))"}
{"solution": "def find_pythagorean_triple(n):\n    if n == 1:\n        return -1\n    if n % 2 == 0:\n        m = (n // 2) ** 2 - 1\n        k = (n // 2) ** 2 + 1\n    else:\n        m = (n ** 2 - 1) // 2\n        k = (n ** 2 + 1) // 2\n    return m, k\n\nn = int(input().strip())\nresult = find_pythagorean_triple(n)\nif result == -1:\n    print(-1)\nelse:\n    print(result[0], result[1])"}
{"solution": "def are_remainders_distinct(n, k):\n    remainders = set()\n    for i in range(1, k + 1):\n        remainder = n % i\n        if remainder in remainders:\n            return \"No\"\n        remainders.add(remainder)\n    return \"Yes\"\n\n# Read input\nn, k = map(int, input().split())\n\n# Check if all remainders are distinct\nresult = are_remainders_distinct(n, k)\n\n# Print the result\nprint(result)"}
{"solution": "import sys\ninput = sys.stdin.read\n\ndef compare_large_numbers():\n    data = input().split()\n    a = data[0].lstrip('0') or '0'\n    b = data[1].lstrip('0') or '0'\n    \n    if len(a) < len(b):\n        print('<')\n    elif len(a) > len(b):\n        print('>')\n    else:\n        if a < b:\n            print('<')\n        elif a > b:\n            print('>')\n        else:\n            print('=')\n\ncompare_large_numbers()"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, p, colors):\n    # Count the number of uncolored pieces\n    uncolored_count = colors.count(-1)\n    \n    # If there are no uncolored pieces, we need to check the parity directly\n    if uncolored_count == 0:\n        score = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if colors[i] != colors[j]:\n                    score += 1\n        return 1 if score % 2 == p else 0\n    \n    # If there are uncolored pieces, we need to consider all possible colorings\n    total_ways = 0\n    for mask in range(1 << uncolored_count):\n        new_colors = colors[:]\n        idx = 0\n        for i in range(n):\n            if new_colors[i] == -1:\n                new_colors[i] = (mask >> idx) & 1\n                idx += 1\n        \n        score = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if new_colors[i] != new_colors[j]:\n                    score += 1\n        \n        if score % 2 == p:\n            total_ways += 1\n    \n    return total_ways % MOD\n\n# Read input\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_ways(n, p, colors))"}
{"solution": "def min_rubles_to_divisible_by_4(n, a, b, c):\n    remainder = n % 4\n    if remainder == 0:\n        return 0\n    elif remainder == 1:\n        return min(3 * a, a + b, c)\n    elif remainder == 2:\n        return min(2 * a, b, 2 * c)\n    elif remainder == 3:\n        return min(a, b + c, 3 * c)\n\n# Read input\nn, a, b, c = map(int, input().split())\n\n# Calculate and print the result\nprint(min_rubles_to_divisible_by_4(n, a, b, c))"}
{"solution": "def is_cyclic(graph, n):\n    visited = [False] * n\n    rec_stack = [False] * n\n\n    def cycle_util(v):\n        visited[v] = True\n        rec_stack[v] = True\n\n        for neighbor in graph[v]:\n            if not visited[neighbor]:\n                if cycle_util(neighbor):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[v] = False\n        return False\n\n    for node in range(n):\n        if not visited[node]:\n            if cycle_util(node):\n                return True\n    return False\n\ndef can_be_acyclic(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u-1].append(v-1)\n\n    if not is_cyclic(graph, n):\n        return \"YES\"\n\n    for u, v in edges:\n        graph[u-1].remove(v-1)\n        if not is_cyclic(graph, n):\n            return \"YES\"\n        graph[u-1].append(v-1)\n\n    return \"NO\"\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n\n    print(can_be_acyclic(n, m, edges))"}
{"solution": "def min_coins_to_cover_street(n, m, antennas):\n    # Initialize the dp array with infinity\n    dp = [float('inf')] * (m + 1)\n    dp[0] = 0  # No cost to cover position 0\n\n    # Sort antennas by their position\n    antennas.sort()\n\n    for i in range(1, m + 1):\n        for x, s in antennas:\n            if x + s >= i:\n                left = max(1, x - s)\n                dp[i] = min(dp[i], dp[left - 1] + max(0, i - (x + s)))\n\n    return dp[m]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nantennas = []\n\nfor i in range(n):\n    x = int(data[2 + 2 * i])\n    s = int(data[3 + 2 * i])\n    antennas.append((x, s))\n\n# Calculate and print the result\nprint(min_coins_to_cover_street(n, m, antennas))"}
{"solution": "def max_good_subset_weight(W, cnt):\n    max_weight = 0\n    for i in range(256):\n        current_weight = 0\n        for j in range(8):\n            if i & (1 << j):\n                current_weight += (j + 1) * cnt[j]\n        if current_weight <= W:\n            max_weight = max(max_weight, current_weight)\n    return max_weight\n\n# Read input\nW = int(input().strip())\ncnt = list(map(int, input().strip().split()))\n\n# Calculate and print the result\nprint(max_good_subset_weight(W, cnt))"}
{"solution": "def min_cost(n, L, costs):\n    # Initialize the minimum cost array\n    min_costs = [float('inf')] * n\n    min_costs[0] = costs[0]\n\n    # Calculate the minimum cost for each bottle type\n    for i in range(1, n):\n        min_costs[i] = min(costs[i], 2 * min_costs[i - 1])\n\n    total_cost = 0\n    remaining_liters = L\n\n    # Traverse from the largest bottle type to the smallest\n    for i in range(n - 1, -1, -1):\n        bottle_volume = (1 << i) - 1\n        if remaining_liters > bottle_volume:\n            num_bottles = remaining_liters // (1 << i)\n            total_cost += num_bottles * min_costs[i]\n            remaining_liters -= num_bottles * (1 << i)\n\n    # Check if we need to buy an additional bottle for the remaining liters\n    for i in range(n):\n        if remaining_liters > 0:\n            total_cost = min(total_cost, min_costs[i] + total_cost)\n\n    return total_cost\n\n# Read input\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Calculate and print the minimum cost\nprint(min_cost(n, L, costs))"}
{"solution": "def max_mex(n, arr):\n    arr.sort()\n    mex = 1\n    for num in arr:\n        if num >= mex:\n            mex += 1\n    return mex\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_mex(n, arr))"}
{"solution": "def is_lucky_ticket(n, ticket):\n    ticket = list(map(int, ticket))\n    total_sum = sum(ticket)\n    \n    for part_sum in range(1, total_sum):\n        current_sum = 0\n        for digit in ticket:\n            current_sum += digit\n            if current_sum == part_sum:\n                current_sum = 0\n        if current_sum == 0:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\nticket = input().strip()\n\n# Check if the ticket is lucky\nresult = is_lucky_ticket(n, ticket)\nprint(result)"}
{"solution": "# Read the input username\nusername = input().strip()\n\n# Determine the number of distinct characters in the username\ndistinct_characters = set(username)\n\n# Check if the number of distinct characters is odd or even\nif len(distinct_characters) % 2 == 0:\n    print(\"CHAT WITH HER!\")\nelse:\n    print(\"IGNORE HIM!\")"}
{"solution": "def max_abs_difference(n, k, tabs):\n    max_diff = 0\n    for b in range(1, k + 1):\n        remaining_tabs = tabs[:]\n        for i in range(b - 1, n, k):\n            remaining_tabs[i] = 0\n        e = remaining_tabs.count(1)\n        s = remaining_tabs.count(-1)\n        max_diff = max(max_diff, abs(e - s))\n    return max_diff\n\n# Read input\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_abs_difference(n, k, tabs))"}
{"solution": "def min_cost(n, c0, c1):\n    # Calculate the length of the binary representation needed\n    length = n.bit_length()\n    \n    # Calculate the number of bits needed\n    num_bits = length * n\n    \n    # Calculate the number of 0s and 1s\n    num_zeros = (1 << (length - 1)) * (length - 1)\n    num_ones = num_bits - num_zeros\n    \n    # Calculate the total cost\n    total_cost = num_zeros * c0 + num_ones * c1\n    \n    return total_cost\n\n# Read input\nn, c0, c1 = map(int, input().split())\n\n# Print the result\nprint(min_cost(n, c0, c1))"}
{"solution": "def will_meet(n, a, x, b, y):\n    while a != x and b != y:\n        if a == b:\n            return \"YES\"\n        a = a + 1 if a < n else 1\n        b = b - 1 if b > 1 else n\n    return \"YES\" if a == b else \"NO\"\n\n# Read input\nn, a, x, b, y = map(int, input().split())\n\n# Print the result\nprint(will_meet(n, a, x, b, y))"}
{"solution": "def find_unlucky_years(x, y, l, r):\n    unlucky_years = set()\n    a = 0\n    while x ** a <= r:\n        b = 0\n        while x ** a + y ** b <= r:\n            if l <= x ** a + y ** b <= r:\n                unlucky_years.add(x ** a + y ** b)\n            b += 1\n            if y == 1:\n                break\n        a += 1\n        if x == 1:\n            break\n    return unlucky_years\n\ndef max_golden_age_length(x, y, l, r):\n    unlucky_years = find_unlucky_years(x, y, l, r)\n    unlucky_years = sorted(unlucky_years)\n    \n    if not unlucky_years:\n        return r - l + 1\n    \n    max_length = 0\n    prev = l - 1\n    \n    for year in unlucky_years:\n        if year > r:\n            break\n        if year > prev + 1:\n            max_length = max(max_length, year - prev - 1)\n        prev = year\n    \n    if prev < r:\n        max_length = max(max_length, r - prev)\n    \n    return max_length\n\n# Read input\nx, y, l, r = map(int, input().split())\n\n# Calculate and print the result\nprint(max_golden_age_length(x, y, l, r))"}
{"solution": "def min_tax(n):\n    if n % 2 == 0:\n        return n // 2\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return n // i\n    return 1\n\nn = int(input())\nprint(min_tax(n))"}
{"solution": "def is_vowel(c):\n    return c in 'aeiou'\n\ndef process_word(word):\n    n = len(word)\n    result = []\n    i = 0\n    \n    while i < n:\n        j = i\n        while j < n and (is_vowel(word[j]) or word[j] == word[i]):\n            j += 1\n        \n        if j - i >= 3 and not is_vowel(word[i]):\n            result.append(word[i:j])\n            i = j\n        else:\n            k = j\n            while k < n and not is_vowel(word[k]):\n                k += 1\n            if k - j >= 2:\n                result.append(word[i:j])\n                i = j\n            else:\n                result.append(word[i:k])\n                i = k\n    \n    return ' '.join(result)\n\nword = input().strip()\nprint(process_word(word))"}
{"solution": "def min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d):\n    min_time = n * x\n\n    for i in range(m):\n        if b[i] <= s:\n            min_time = min(min_time, n * a[i])\n\n    for j in range(k):\n        if d[j] <= s:\n            potions_left = n - c[j]\n            if potions_left <= 0:\n                min_time = 0\n            else:\n                min_time = min(min_time, potions_left * x)\n\n    for i in range(m):\n        if b[i] <= s:\n            remaining_mana = s - b[i]\n            for j in range(k):\n                if d[j] <= remaining_mana:\n                    potions_left = n - c[j]\n                    if potions_left <= 0:\n                        min_time = 0\n                    else:\n                        min_time = min(min_time, potions_left * a[i])\n\n    return min_time\n\n# Read input\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\n# Calculate and print the minimum time\nprint(min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d))"}
{"solution": "def max_points(n, k, M, t):\n    t.sort()\n    max_points = 0\n\n    for full_tasks in range(n + 1):\n        time_spent = full_tasks * sum(t)\n        if time_spent > M:\n            break\n\n        remaining_time = M - time_spent\n        points = full_tasks * (k + 1)\n\n        for i in range(n - full_tasks):\n            for j in range(k):\n                if remaining_time >= t[j]:\n                    remaining_time -= t[j]\n                    points += 1\n                else:\n                    break\n\n        max_points = max(max_points, points)\n\n    return max_points\n\n# Read input\nn, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_points(n, k, M, t))"}
{"solution": "MOD = 998244353\n\ndef count_balanced_striped_bsts(n):\n    if n % 2 == 1:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[2] = 1\n    \n    for i in range(4, n + 1, 2):\n        dp[i] = (dp[i - 2] * (i - 1)) % MOD\n    \n    return dp[n]\n\nn = int(input().strip())\nprint(count_balanced_striped_bsts(n))"}
{"solution": "def find_position(n, m, k):\n    if k < n:\n        # Moving down the first column\n        print(k + 1, 1)\n    else:\n        k -= n\n        full_rows = k // (m - 1)\n        remaining_steps = k % (m - 1)\n        \n        if full_rows % 2 == 0:\n            # Moving right on an even row\n            print(n - full_rows, 2 + remaining_steps)\n        else:\n            # Moving left on an odd row\n            print(n - full_rows, m - remaining_steps)\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Find and print the position\nfind_position(n, m, k)"}
{"solution": "import math\n\ndef find_min_max_pair(X):\n    a, b = 1, X\n    for i in range(1, int(math.sqrt(X)) + 1):\n        if X % i == 0:\n            j = X // i\n            if max(i, j) < max(a, b):\n                a, b = i, j\n    return a, b\n\nX = int(input())\na, b = find_min_max_pair(X)\nprint(a, b)"}
{"solution": "a = int(input())\nb = int(input())\nc = int(input())\n\n# Find the maximum number of sets of (1 lemon, 2 apples, 4 pears) that can be made\nmax_sets = min(a, b // 2, c // 4)\n\n# Calculate the total number of fruits used\ntotal_fruits = max_sets * 7\n\nprint(total_fruits)"}
{"solution": "n = int(input())\nratings = list(map(int, input().split()))\n\nratings.sort()\n\nteam1 = ratings[:n]\nteam2 = ratings[n:]\n\nif all(team1[i] < team2[i] for i in range(n)):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\ndef is_coprime(a, b):\n    return math.gcd(a, b) == 1\n\ndef make_coprime_array(n, arr):\n    result = []\n    additions = 0\n    \n    for i in range(n - 1):\n        result.append(arr[i])\n        if not is_coprime(arr[i], arr[i + 1]):\n            for j in range(1, 10**9 + 1):\n                if is_coprime(arr[i], j) and is_coprime(j, arr[i + 1]):\n                    result.append(j)\n                    additions += 1\n                    break\n    result.append(arr[-1])\n    \n    return additions, result\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Process the array to make it co-prime\nadditions, result = make_coprime_array(n, arr)\n\n# Print the result\nprint(additions)\nprint(\" \".join(map(str, result)))"}
{"solution": "import math\nfrom functools import reduce\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef gcd_list(lst):\n    return reduce(gcd, lst)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n    \n    total_sum = sum(A)\n    max_gcd = gcd_list(A)\n    \n    if K >= total_sum:\n        print(total_sum)\n        return\n    \n    for i in range(1, int(math.sqrt(total_sum)) + 1):\n        if total_sum % i == 0:\n            if i <= K:\n                max_gcd = max(max_gcd, i)\n            if total_sum // i <= K:\n                max_gcd = max(max_gcd, total_sum // i)\n    \n    print(max_gcd)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def cat_furrier_transform(x):\n    operations = []\n    count = 0\n\n    while (x & (x + 1)) != 0:\n        if count % 2 == 0:\n            n = 0\n            while (1 << (n + 1)) - 1 <= x:\n                n += 1\n            operations.append(n)\n            x ^= (1 << n) - 1\n        else:\n            x += 1\n        count += 1\n\n    print(count)\n    for i in range(0, len(operations), 2):\n        print(operations[i], end=' ')\n    if operations:\n        print()\n\n# Read input\nx = int(input().strip())\ncat_furrier_transform(x)"}
{"solution": "# Read input values\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize the minimum hours to a large number\nmin_hours = float('inf')\n\n# Iterate through each bucket\nfor length in a:\n    # Check if the bucket can water the garden in an integer number of hours\n    if k % length == 0:\n        # Calculate the number of hours required\n        hours = k // length\n        # Update the minimum hours if the current bucket is better\n        if hours < min_hours:\n            min_hours = hours\n\n# Print the minimum number of hours required\nprint(min_hours)"}
{"solution": "def can_grasshopper_reach_insect(n, k, line):\n    g_pos = line.index('G')\n    t_pos = line.index('T')\n    \n    if g_pos > t_pos:\n        g_pos, t_pos = t_pos, g_pos\n    \n    for i in range(g_pos, t_pos + 1, k):\n        if line[i] == '#':\n            return \"NO\"\n    \n    if (t_pos - g_pos) % k == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\nline = input().strip()\n\n# Determine if the grasshopper can reach the insect\nresult = can_grasshopper_reach_insect(n, k, line)\nprint(result)"}
{"solution": "def find_aiming_point(y1, y2, yw, xb, yb, r):\n    # Check if the ball can be aimed to the wall and bounce into the goal\n    if yb + r >= yw or yb - r <= 0 or y1 + r >= y2 - r:\n        return -1\n\n    # Calculate the x-coordinate of the aiming point\n    xw = xb * (yw - yb) / (yb - (y1 + y2) / 2)\n    \n    # Check if the ball will bounce into the goal\n    if xw <= 0:\n        return -1\n\n    return xw\n\n# Read input\ny1, y2, yw, xb, yb, r = map(int, input().split())\n\n# Find the aiming point\nresult = find_aiming_point(y1, y2, yw, xb, yb, r)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    print(f\"{result:.10f}\")"}
{"solution": "def min_missed_meals(b, d, s):\n    max_meals = max(b, d, s)\n    missed_meals = max(0, (max_meals - 1) - b) + max(0, (max_meals - 1) - d) + max(0, (max_meals - 1) - s)\n    return missed_meals\n\n# Read input\nb, d, s = map(int, input().split())\n\n# Calculate and print the result\nprint(min_missed_meals(b, d, s))"}
{"solution": "def find_matrix_dimensions(n, path):\n    from math import gcd\n    from functools import reduce\n\n    def get_coordinates(a, y):\n        i = (a - 1) // y + 1\n        j = (a - 1) % y + 1\n        return i, j\n\n    def valid_dimensions(x, y):\n        for k in range(1, n):\n            i1, j1 = get_coordinates(path[k-1], y)\n            i2, j2 = get_coordinates(path[k], y)\n            if abs(i1 - i2) + abs(j1 - j2) != 1:\n                return False\n        return True\n\n    diffs = [abs(path[i] - path[i-1]) for i in range(1, n)]\n    common_diff = reduce(gcd, diffs)\n\n    for y in range(1, int(common_diff**0.5) + 1):\n        if common_diff % y == 0:\n            x = common_diff // y\n            if x <= 10**9 and y <= 10**9:\n                if valid_dimensions(x, y):\n                    return \"YES\\n{} {}\".format(x, y)\n                if valid_dimensions(y, x):\n                    return \"YES\\n{} {}\".format(y, x)\n    \n    return \"NO\"\n\n# Read input\nn = int(input().strip())\npath = list(map(int, input().strip().split()))\n\n# Find and print the result\nprint(find_matrix_dimensions(n, path))"}
{"solution": "def min_remove_to_subsequence(a, b):\n    n, m = len(a), len(b)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    i, j = n, m\n    subsequence = []\n\n    while i > 0 and j > 0:\n        if a[i - 1] == b[j - 1]:\n            subsequence.append(a[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] >= dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    subsequence.reverse()\n    result = ''.join(subsequence)\n    return result if result else '-'\n\na = input().strip()\nb = input().strip()\nprint(min_remove_to_subsequence(a, b))"}
{"solution": "n = int(input())\ns = input()\n\nmin_stones = 0\ncurrent_stones = 0\n\nfor operation in s:\n    if operation == '+':\n        current_stones += 1\n    else:\n        if current_stones > 0:\n            current_stones -= 1\n        else:\n            min_stones += 1\n\nprint(current_stones)"}
{"solution": "def max_kefir(n, a, b, c):\n    if a <= b - c:\n        return n // a\n    else:\n        max_liters = 0\n        if n >= b:\n            max_liters += (n - b) // (b - c) + 1\n            n = (n - b) % (b - c) + c\n        max_liters += n // a\n        return max_liters\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate and print the result\nprint(max_kefir(n, a, b, c))"}
{"solution": "def card_war(n, k1, cards1, k2, cards2):\n    from collections import deque\n\n    deck1 = deque(cards1)\n    deck2 = deque(cards2)\n    seen_states = set()\n    fight_count = 0\n\n    while deck1 and deck2:\n        state = (tuple(deck1), tuple(deck2))\n        if state in seen_states:\n            return -1\n        seen_states.add(state)\n\n        card1 = deck1.popleft()\n        card2 = deck2.popleft()\n\n        if card1 > card2:\n            deck1.append(card2)\n            deck1.append(card1)\n        else:\n            deck2.append(card1)\n            deck2.append(card2)\n\n        fight_count += 1\n\n    if deck1:\n        return fight_count, 1\n    else:\n        return fight_count, 2\n\n# Read input\nn = int(input())\nk1, *cards1 = map(int, input().split())\nk2, *cards2 = map(int, input().split())\n\n# Get result\nresult = card_war(n, k1, cards1, k2, cards2)\n\n# Print result\nif result == -1:\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "import re\n\ndef check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    if not re.search(r'[A-Z]', password):\n        return \"Too weak\"\n    if not re.search(r'[a-z]', password):\n        return \"Too weak\"\n    if not re.search(r'\\d', password):\n        return \"Too weak\"\n    return \"Correct\"\n\npassword = input().strip()\nprint(check_password_complexity(password))"}
{"solution": "def min_exchanges(n, group_a, group_b):\n    from collections import Counter\n\n    count_a = Counter(group_a)\n    count_b = Counter(group_b)\n\n    total_count = Counter(group_a + group_b)\n\n    for key in total_count:\n        if total_count[key] % 2 != 0:\n            return -1\n\n    exchanges = 0\n    for i in range(1, 6):\n        if count_a[i] > count_b[i]:\n            exchanges += (count_a[i] - count_b[i]) // 2\n\n    return exchanges\n\n# Read input\nn = int(input())\ngroup_a = list(map(int, input().split()))\ngroup_b = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_exchanges(n, group_a, group_b))"}
{"solution": "def can_reach_all_junctions(n, m, horizontal, vertical):\n    # Check horizontal streets\n    if horizontal[0] == '<' or horizontal[-1] == '>':\n        return \"NO\"\n    \n    # Check vertical streets\n    if vertical[0] == '^' or vertical[-1] == 'v':\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nhorizontal = input().strip()\nvertical = input().strip()\n\n# Determine if all junctions are reachable\nresult = can_reach_all_junctions(n, m, horizontal, vertical)\nprint(result)"}
{"solution": "def implication(a, b):\n    return not a or b\n\ndef find_false_implication(n, arr):\n    if n == 1:\n        if arr[0] == 0:\n            return \"YES\\n0\"\n        else:\n            return \"NO\"\n    \n    # Check if there is any 1 followed by 0\n    for i in range(n - 1):\n        if arr[i] == 1 and arr[i + 1] == 0:\n            # We can make the expression false\n            result = []\n            for j in range(n):\n                if j == i:\n                    result.append('(')\n                result.append(str(arr[j]))\n                if j == i:\n                    result.append(\"->\")\n                elif j < n - 1:\n                    result.append(\"->\")\n                if j == i + 1:\n                    result.append(')')\n            return \"YES\\n\" + \"\".join(result)\n    \n    return \"NO\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\narr = list(map(int, data[1:]))\n\n# Find and print the result\nprint(find_false_implication(n, arr))"}
{"solution": "def process_values(a, b):\n    while a != 0 and b != 0:\n        if a >= 2 * b:\n            a = a % (2 * b)\n        elif b >= 2 * a:\n            b = b % (2 * a)\n        else:\n            break\n    return a, b\n\n# Read input\nn, m = map(int, input().split())\n\n# Process the values\nresult_a, result_b = process_values(n, m)\n\n# Print the result\nprint(result_a, result_b)"}
{"solution": "def count_k_divisible(k, a, b):\n    if a % k == 0:\n        start = a\n    else:\n        start = a + (k - a % k)\n    \n    if b % k == 0:\n        end = b\n    else:\n        end = b - (b % k)\n    \n    if start > end:\n        return 0\n    \n    return (end - start) // k + 1\n\n# Read input\nk, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(count_k_divisible(k, a, b))"}
{"solution": "def find_kth_digit(k):\n    current_length = 0\n    number = 1\n    \n    while True:\n        number_str = str(number)\n        if current_length + len(number_str) >= k:\n            return number_str[k - current_length - 1]\n        current_length += len(number_str)\n        number += 1\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "def can_vasya_win(n, s):\n    # Calculate the number of moves each player will make\n    moves = (n - 11) // 2\n    \n    # Count the number of '8's in the first (n-11) characters\n    count_8 = s[:n-11].count('8')\n    \n    # Vasya wins if there are more '8's than moves Petya can make\n    if count_8 > moves:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Determine if Vasya can win\nresult = can_vasya_win(n, s)\nprint(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial(n):\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef count_permutations(n, x, pos):\n    less_than_x = x - 1\n    greater_than_x = n - x\n    left = 0\n    right = n\n    less_count = 0\n    greater_count = 0\n\n    while left < right:\n        middle = (left + right) // 2\n        if middle <= pos:\n            if middle < pos:\n                less_count += 1\n            left = middle + 1\n        else:\n            greater_count += 1\n            right = middle\n\n    if less_count > less_than_x or greater_count > greater_than_x:\n        return 0\n\n    less_permutations = factorial(less_than_x) // factorial(less_than_x - less_count)\n    greater_permutations = factorial(greater_than_x) // factorial(greater_than_x - greater_count)\n    remaining_permutations = factorial(n - 1 - less_count - greater_count)\n\n    result = (less_permutations * greater_permutations) % MOD\n    result = (result * remaining_permutations) % MOD\n\n    return result\n\nn, x, pos = map(int, input().split())\nprint(count_permutations(n, x, pos))"}
{"solution": "def decode_message(encoded_str, k):\n    n = len(encoded_str)\n    dp = [[False] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(n):\n        for j in range(k + 1):\n            if not dp[i][j]:\n                continue\n            if encoded_str[i].isalpha():\n                if j + 1 <= k:\n                    dp[i + 1][j + 1] = True\n                if i + 1 < n and encoded_str[i + 1] == '?':\n                    dp[i + 2][j] = True\n                    if j + 1 <= k:\n                        dp[i + 2][j + 1] = True\n                elif i + 1 < n and encoded_str[i + 1] == '*':\n                    dp[i + 2][j] = True\n                    for l in range(1, k - j + 1):\n                        dp[i + 2][j + l] = True\n            elif encoded_str[i] in '?*':\n                dp[i + 1][j] = True\n\n    if not dp[n][k]:\n        return \"Impossible\"\n\n    result = []\n    i, j = n, k\n    while i > 0:\n        if encoded_str[i - 1].isalpha():\n            if j > 0 and dp[i - 1][j - 1]:\n                result.append(encoded_str[i - 1])\n                i -= 1\n                j -= 1\n            elif i > 1 and encoded_str[i - 2] == '?':\n                if dp[i - 2][j]:\n                    i -= 2\n                else:\n                    result.append(encoded_str[i - 2])\n                    i -= 2\n                    j -= 1\n            elif i > 1 and encoded_str[i - 2] == '*':\n                if dp[i - 2][j]:\n                    i -= 2\n                else:\n                    count = 0\n                    while j > 0 and dp[i - 2][j - 1]:\n                        result.append(encoded_str[i - 2])\n                        j -= 1\n                        count += 1\n                    i -= 2\n        else:\n            i -= 1\n\n    return ''.join(result[::-1])\n\n# Read input\nencoded_str = input().strip()\nk = int(input().strip())\n\n# Get the decoded message\nresult = decode_message(encoded_str, k)\n\n# Print the result\nprint(result)"}
{"solution": "x = int(input().strip())\n\n# Normalize the angle to be within the range [0, 360)\nx = x % 360\n\n# Calculate the number of 90 degree turns needed\nturns = (360 - x) // 90\n\n# Output the result\nprint(turns)"}
{"solution": "def can_transform(a, b, c, x, y, z):\n    # Calculate the surplus or deficit of each color\n    surplus_blue = a - x\n    surplus_violet = b - y\n    surplus_orange = c - z\n\n    # If all are non-negative, we already have enough spheres\n    if surplus_blue >= 0 and surplus_violet >= 0 and surplus_orange >= 0:\n        return \"Yes\"\n\n    # Calculate the total surplus and total deficit\n    total_surplus = max(0, surplus_blue) // 2 + max(0, surplus_violet) // 2 + max(0, surplus_orange) // 2\n    total_deficit = max(0, -surplus_blue) + max(0, -surplus_violet) + max(0, -surplus_orange)\n\n    # If the total surplus is enough to cover the total deficit, return \"Yes\"\n    if total_surplus >= total_deficit:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Print the result\nprint(can_transform(a, b, c, x, y, z))"}
{"solution": "def count_numbers(n, k, m):\n    # Initialize the dp array\n    dp = [[0] * k for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(10):\n            for r in range(k):\n                dp[i][(r * 10 + j) % k] = (dp[i][(r * 10 + j) % k] + dp[i - 1][r]) % m\n\n    # Calculate the result\n    result = 0\n    for i in range(1, 10):\n        result = (result + dp[n - 1][(k - i % k) % k]) % m\n\n    return result\n\n# Read input\nn, k, m = map(int, input().split())\n\n# Get the result\nresult = count_numbers(n, k, m)\n\n# Print the result\nprint(result)"}
{"solution": "def max_team_size(l, r, a):\n    # Balance the left and right handers using ambidexters\n    if l < r:\n        l, r = r, l\n    r += min(a, l - r)\n    a -= min(a, l - r)\n    \n    # Add remaining ambidexters equally to both sides\n    l += a // 2\n    r += a // 2\n    \n    # The maximum team size is twice the minimum of l and r\n    return 2 * min(l, r)\n\n# Read input\nl, r, a = map(int, input().split())\n\n# Print the result\nprint(max_team_size(l, r, a))"}
{"solution": "def min_moves_to_pick_all_coins(n, k):\n    # Calculate the minimum moves required\n    left_moves = (k - 1) * 3 + (n - 1)\n    right_moves = (n - k) * 3 + (n - 1)\n    return min(left_moves, right_moves) + n\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the result\nprint(min_moves_to_pick_all_coins(n, k))"}
{"solution": "def min_tallest_tower(n, m):\n    max_height = 0\n    used_heights = set()\n    \n    # Generate heights for students using 2-block pieces\n    for i in range(1, n + 1):\n        height = 2 * i\n        used_heights.add(height)\n        max_height = max(max_height, height)\n    \n    # Generate heights for students using 3-block pieces\n    for i in range(1, m + 1):\n        height = 3 * i\n        while height in used_heights:\n            height += 3\n        used_heights.add(height)\n        max_height = max(max_height, height)\n    \n    return max_height\n\n# Read input\nn, m = map(int, input().split())\n\n# Print the result\nprint(min_tallest_tower(n, m))"}
{"solution": "n = int(input())\ncards = [int(input()) for _ in range(n)]\n\nfrom collections import Counter\n\ncount = Counter(cards)\n\nif len(count) != 2:\n    print(\"NO\")\nelse:\n    values = list(count.values())\n    if values[0] == values[1]:\n        keys = list(count.keys())\n        print(\"YES\")\n        print(keys[0], keys[1])\n    else:\n        print(\"NO\")"}
{"solution": "def can_place_soldiers(n, k, groups):\n    # Each row has 4 pairs of neighboring seats\n    pairs_per_row = 4\n    total_pairs = n * pairs_per_row\n    \n    # Count the number of groups that need more than 2 seats\n    large_groups = sum((g + 1) // 2 for g in groups)\n    \n    # If the number of large groups is more than the available pairs, it's not possible\n    if large_groups > total_pairs:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Output the result\nprint(can_place_soldiers(n, k, groups))"}
{"solution": "def find_min_cost(n, sticks):\n    min_cost = float('inf')\n    best_t = -1\n\n    for t in range(1, 101):\n        current_cost = 0\n        for stick in sticks:\n            if abs(stick - t) > 1:\n                current_cost += abs(stick - t) - 1\n        if current_cost < min_cost:\n            min_cost = current_cost\n            best_t = t\n\n    return best_t, min_cost\n\n# Read input\nn = int(input())\nsticks = list(map(int, input().split()))\n\n# Find the best t and the minimum cost\nt, min_cost = find_min_cost(n, sticks)\n\n# Print the result\nprint(t, min_cost)"}
{"solution": "def find_min_square_side(n, m, sky_map):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n\n    for i in range(n):\n        for j in range(m):\n            if sky_map[i][j] == '*':\n                if i < min_row:\n                    min_row = i\n                if i > max_row:\n                    max_row = i\n                if j < min_col:\n                    min_col = j\n                if j > max_col:\n                    max_col = j\n\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    return side_length\n\n# Read input\nn, m = map(int, input().split())\nsky_map = [input().strip() for _ in range(n)]\n\n# Find and print the result\nprint(find_min_square_side(n, m, sky_map))"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_inv(x, mod):\n    return pow(x, mod - 2, mod)\n\ndef solve(n, k, a):\n    if sorted(a) == a:\n        print(1)\n        return\n    \n    ones = sum(a)\n    zeros = n - ones\n    \n    if ones == 0 or zeros == 0:\n        print(1)\n        return\n    \n    if k == 1:\n        print(0)\n        return\n    \n    P = ones * zeros\n    Q = n * (n - 1) // 2\n    \n    P = (P * mod_inv(Q, MOD)) % MOD\n    print(P)\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    solve(n, k, a)"}
{"solution": "def min_seconds_to_devolve_triangle(x, y):\n    # The minimum number of seconds required to devolve the triangle\n    return x - y\n\n# Read input\nx, y = map(int, input().split())\n\n# Print the result\nprint(min_seconds_to_devolve_triangle(x, y))"}
{"solution": "def min_norm(a, b, c, d):\n    det = a * d - b * c\n    if det == 0:\n        return 0.0\n\n    norm = abs(det) / ((a * a + c * c) ** 0.5 + (b * b + d * d) ** 0.5)\n    return norm\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    a, b = int(data[0]), int(data[1])\n    c, d = int(data[2]), int(data[3])\n    result = min_norm(a, b, c, d)\n    print(f\"{result:.10f}\")"}
{"solution": "def denied_service_count(n, a, b, groups):\n    denied = 0\n    one_seater = a\n    two_seater = b\n    one_seater_occupied = 0\n\n    for group in groups:\n        if group == 1:\n            if one_seater > 0:\n                one_seater -= 1\n            elif two_seater > 0:\n                two_seater -= 1\n                one_seater_occupied += 1\n            elif one_seater_occupied > 0:\n                one_seater_occupied -= 1\n            else:\n                denied += 1\n        elif group == 2:\n            if two_seater > 0:\n                two_seater -= 1\n            else:\n                denied += 2\n\n    return denied\n\n# Read input\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(denied_service_count(n, a, b, groups))"}
{"solution": "def calculate_students(A, B, C, N):\n    # Check for invalid conditions\n    if C > A or C > B or A + B - C >= N:\n        return -1\n    \n    # Calculate the number of students who didn't pass the exam\n    students_did_not_pass = N - (A + B - C)\n    \n    # Check if at least one student didn't pass the exam\n    if students_did_not_pass < 1:\n        return -1\n    \n    return students_did_not_pass\n\n# Read input values\nA, B, C, N = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_students(A, B, C, N))"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_exp(base, exp, mod):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return result\n\ndef expected_dresses(x, k):\n    if x == 0:\n        return 0\n    return (x * mod_exp(2, k + 1, MOD) - mod_exp(2, k, MOD) + 1) % MOD\n\nx, k = map(int, input().split())\nprint(expected_dresses(x, k))"}
{"solution": "MOD = 998244353\n\ndef mod_inv(a, p):\n    return pow(a, p - 2, p)\n\ndef calculate_probability(n, ranges):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        l_i, r_i = ranges[i - 1]\n        for j in range(i + 1):\n            dp[i][j] = dp[i - 1][j] * (r_i - l_i + 1) % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * (r_i - l_i + 1) % MOD) % MOD\n\n    total_ways = 1\n    for l_i, r_i in ranges:\n        total_ways = total_ways * (r_i - l_i + 1) % MOD\n\n    no_inversion_ways = sum(dp[n][i] for i in range(n + 1)) % MOD\n    probability = no_inversion_ways * mod_inv(total_ways, MOD) % MOD\n\n    return probability\n\nn = int(input().strip())\nranges = [tuple(map(int, input().strip().split())) for _ in range(n)]\nprint(calculate_probability(n, ranges))"}
{"solution": "def count_ways(n):\n    if n % 2 != 0 or n < 8:\n        return 0\n\n    count = 0\n    for a in range(1, n // 4 + 1):\n        b = a\n        c = (n - 2 * a) // 2\n        d = c\n        if a != c:\n            count += 1\n\n    return count\n\nn = int(input())\nprint(count_ways(n))"}
{"solution": "def fair_nut_kvass(n, s, volumes):\n    total_volume = sum(volumes)\n    if total_volume < s:\n        return -1\n    \n    min_volume = min(volumes)\n    remaining_s = s\n    \n    for i in range(n):\n        remaining_s -= (volumes[i] - min_volume)\n        if remaining_s <= 0:\n            return min_volume\n    \n    return min_volume - (remaining_s + n - 1) // n\n\n# Read input\nn, s = map(int, input().split())\nvolumes = list(map(int, input().split()))\n\n# Get the result\nresult = fair_nut_kvass(n, s, volumes)\n\n# Print the result\nprint(result)"}
{"solution": "def days_to_reach_apple(h1, h2, a, b):\n    # Initial height difference\n    height_diff = h2 - h1\n    \n    # Caterpillar's net gain in height per day\n    net_gain_per_day = (12 * a) - (12 * b)\n    \n    # If the caterpillar can reach the apple on the first day\n    if 8 * a >= height_diff:\n        return 0\n    \n    # If the caterpillar cannot make any progress\n    if net_gain_per_day <= 0:\n        return -1\n    \n    # Calculate the remaining height after the first day\n    remaining_height = height_diff - (8 * a)\n    \n    # Calculate the number of full days needed to reach the apple\n    full_days_needed = (remaining_height + net_gain_per_day - 1) // net_gain_per_day\n    \n    return full_days_needed + 1\n\n# Read input\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Print the result\nprint(days_to_reach_apple(h1, h2, a, b))"}
{"solution": "def max_joy(C, Hr, Hb, Wr, Wb):\n    max_joy_units = 0\n\n    if Wr > Wb:\n        Wr, Wb = Wb, Wr\n        Hr, Hb = Hb, Hr\n\n    for blue_candies in range(0, C // Wb + 1):\n        remaining_weight = C - blue_candies * Wb\n        red_candies = remaining_weight // Wr\n        joy_units = blue_candies * Hb + red_candies * Hr\n        max_joy_units = max(max_joy_units, joy_units)\n\n    return max_joy_units\n\n# Read input\nC, Hr, Hb, Wr, Wb = map(int, input().split())\n\n# Calculate and print the result\nprint(max_joy(C, Hr, Hb, Wr, Wb))"}
{"solution": "# Read input values\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\n# Calculate the minimal number of steps\nsteps = max(abs(x2 - x1), abs(y2 - y1))\n\n# Print the result\nprint(steps)"}
{"solution": "def predict_vote_outcome(n, employees):\n    from collections import deque\n\n    depublicans = deque()\n    remocrats = deque()\n\n    for i in range(n):\n        if employees[i] == 'D':\n            depublicans.append(i)\n        else:\n            remocrats.append(i)\n\n    while depublicans and remocrats:\n        d = depublicans.popleft()\n        r = remocrats.popleft()\n        if d < r:\n            depublicans.append(d + n)\n        else:\n            remocrats.append(r + n)\n\n    if depublicans:\n        return 'D'\n    else:\n        return 'R'\n\n# Read input\nn = int(input().strip())\nemployees = input().strip()\n\n# Predict and print the outcome\nprint(predict_vote_outcome(n, employees))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_tv_sets(a, b, x, y):\n    g = gcd(x, y)\n    x //= g\n    y //= g\n    \n    max_w = a // x\n    max_h = b // y\n    \n    return min(max_w, max_h)\n\n# Read input\na, b, x, y = map(int, input().split())\n\n# Calculate and print the result\nprint(count_tv_sets(a, b, x, y))"}
{"solution": "def prime_factors(b):\n    factors = {}\n    d = 2\n    while d * d <= b:\n        while (b % d) == 0:\n            if d in factors:\n                factors[d] += 1\n            else:\n                factors[d] = 1\n            b //= d\n        d += 1\n    if b > 1:\n        factors[b] = 1\n    return factors\n\ndef count_factors_in_factorial(n, p):\n    count = 0\n    power = p\n    while power <= n:\n        count += n // power\n        power *= p\n    return count\n\ndef trailing_zeros_in_base(n, b):\n    factors = prime_factors(b)\n    min_trailing_zeros = float('inf')\n    for p in factors:\n        count_p = count_factors_in_factorial(n, p)\n        min_trailing_zeros = min(min_trailing_zeros, count_p // factors[p])\n    return min_trailing_zeros\n\nn, b = map(int, input().split())\nprint(trailing_zeros_in_base(n, b))"}
{"solution": "def sum_f(m, a, b):\n    if a > b:\n        a, b = b, a\n\n    gcd_ab = gcd(a, b)\n    lcm_ab = (a // gcd_ab) * b\n\n    def f(x):\n        if x < a:\n            return x + 1\n        if x < b:\n            return x - (x - a) // gcd_ab\n        if x < lcm_ab:\n            return x - (x - a) // gcd_ab - (x - b) // gcd_ab + (x - lcm_ab) // gcd_ab\n        return x - (x - a) // gcd_ab - (x - b) // gcd_ab + (x - lcm_ab) // gcd_ab + 1\n\n    total_sum = 0\n    for i in range(m + 1):\n        total_sum += f(i)\n\n    return total_sum\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n# Read input\nm, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(sum_f(m, a, b))"}
{"solution": "def can_divide_into_odd_subsegments(n, sequence):\n    if n % 2 == 1 and sequence[0] % 2 == 1 and sequence[-1] % 2 == 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Output result\nprint(can_divide_into_odd_subsegments(n, sequence))"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    if x1 == x2:\n        side_length = abs(y2 - y1)\n        x3, y3 = x1 + side_length, y1\n        x4, y4 = x2 + side_length, y2\n    elif y1 == y2:\n        side_length = abs(x2 - x1)\n        x3, y3 = x1, y1 + side_length\n        x4, y4 = x2, y2 + side_length\n    elif abs(x2 - x1) == abs(y2 - y1):\n        x3, y3 = x1, y2\n        x4, y4 = x2, y1\n    else:\n        return -1\n    \n    return x3, y3, x4, y4\n\nx1, y1, x2, y2 = map(int, input().split())\nresult = find_remaining_trees(x1, y1, x2, y2)\nif result == -1:\n    print(result)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def calculate_fn(x, y, n):\n    MOD = 1000000007\n    sequence = [x, y, y - x, -x, -y, x - y]\n    return sequence[(n - 1) % 6] % MOD\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    x = int(data[0])\n    y = int(data[1])\n    n = int(data[2])\n    print(calculate_fn(x, y, n))"}
{"solution": "def split_array(n, A):\n    total_sum = sum(A)\n    \n    if total_sum != 0:\n        print(\"YES\")\n        print(1)\n        print(1, n)\n        return\n    \n    for i in range(n):\n        if A[i] != 0:\n            print(\"YES\")\n            print(2)\n            print(1, i + 1)\n            print(i + 2, n)\n            return\n    \n    print(\"NO\")\n\n# Read input\nn = int(input())\nA = list(map(int, input().split()))\n\n# Call the function\nsplit_array(n, A)"}
{"solution": "MOD = 1000000009\n\ndef min_score(n, m, k):\n    if m < k:\n        return m % MOD\n    \n    full_sets = m // k\n    remaining_correct = m % k\n    max_full_sets = (n - m) // (k - 1)\n    \n    if full_sets <= max_full_sets:\n        return m % MOD\n    \n    extra_sets = full_sets - max_full_sets\n    score = (max_full_sets * k + remaining_correct) % MOD\n    score = (score + (2 * k * (pow(2, extra_sets, MOD) - 1) % MOD) * pow(2, MOD-2, MOD)) % MOD\n    \n    return score\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Calculate and print the result\nprint(min_score(n, m, k))"}
{"solution": "def is_divisible_by_8(n):\n    length = len(n)\n    \n    # Check all single digit numbers\n    for i in range(length):\n        if int(n[i]) % 8 == 0:\n            return \"YES\", n[i]\n    \n    # Check all two digit numbers\n    for i in range(length):\n        for j in range(i + 1, length):\n            if int(n[i] + n[j]) % 8 == 0:\n                return \"YES\", n[i] + n[j]\n    \n    # Check all three digit numbers\n    for i in range(length):\n        for j in range(i + 1, length):\n            for k in range(j + 1, length):\n                if int(n[i] + n[j] + n[k]) % 8 == 0:\n                    return \"YES\", n[i] + n[j] + n[k]\n    \n    return \"NO\", \"\"\n\nn = input().strip()\nresult, number = is_divisible_by_8(n)\nprint(result)\nif result == \"YES\":\n    print(number)"}
{"solution": "def find_floor(n, m, memories):\n    possible_floors = set()\n    \n    for flats_per_floor in range(1, 101):\n        consistent = True\n        for k, f in memories:\n            if (k - 1) // flats_per_floor + 1 != f:\n                consistent = False\n                break\n        if consistent:\n            possible_floors.add((n - 1) // flats_per_floor + 1)\n    \n    if len(possible_floors) == 1:\n        return possible_floors.pop()\n    else:\n        return -1\n\n# Read input\nn, m = map(int, input().split())\nmemories = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Find and print the floor\nprint(find_floor(n, m, memories))"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    count = 0\n    i = 0\n\n    while i < n:\n        if i + 1 < n:\n            if board1[i] == '0' and board1[i + 1] == '0' and board2[i] == '0':\n                count += 1\n                i += 2\n                continue\n            if board1[i] == '0' and board1[i + 1] == '0' and board2[i + 1] == '0':\n                count += 1\n                i += 2\n                continue\n            if board2[i] == '0' and board2[i + 1] == '0' and board1[i] == '0':\n                count += 1\n                i += 2\n                continue\n            if board2[i] == '0' and board2[i + 1] == '0' and board1[i + 1] == '0':\n                count += 1\n                i += 2\n                continue\n\n        if i + 1 < n:\n            if board1[i] == '0' and board1[i + 1] == '0' and board2[i] == '0':\n                count += 1\n                i += 2\n                continue\n            if board1[i] == '0' and board1[i + 1] == '0' and board2[i + 1] == '0':\n                count += 1\n                i += 2\n                continue\n            if board2[i] == '0' and board2[i + 1] == '0' and board1[i] == '0':\n                count += 1\n                i += 2\n                continue\n            if board2[i] == '0' and board2[i + 1] == '0' and board1[i + 1] == '0':\n                count += 1\n                i += 2\n                continue\n\n        if board1[i] == '0' and board2[i] == '0' and i + 1 < n and board1[i + 1] == '0':\n            count += 1\n            i += 2\n            continue\n        if board1[i] == '0' and board2[i] == '0' and i + 1 < n and board2[i + 1] == '0':\n            count += 1\n            i += 2\n            continue\n\n        i += 1\n\n    return count\n\nboard1 = input().strip()\nboard2 = input().strip()\nprint(max_bishwocks(board1, board2))"}
{"solution": "def max_pretty_set_length(n, s):\n    max_length = 0\n    current_set = set()\n    current_length = 0\n\n    for char in s:\n        if char.islower():\n            if char not in current_set:\n                current_set.add(char)\n                current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_set.clear()\n            current_length = 0\n\n    max_length = max(max_length, current_length)\n    return max_length\n\n# Read input\nn = int(input())\ns = input()\n\n# Get the result\nresult = max_pretty_set_length(n, s)\n\n# Print the result\nprint(result)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nB = sum(x for x in a if x > 0)\nC = sum(x for x in a if x < 0)\n\nprint(B - C)"}
{"solution": "def min_refuels(a, b, f, k):\n    if b < f or b < (a - f):\n        return -1\n\n    refuels = 0\n    current_fuel = b\n    position = 0\n    direction = 1  # 1 means going to a, -1 means going to 0\n\n    for journey in range(k):\n        if direction == 1:\n            distance_to_next = a - position\n            distance_to_station = f - position\n        else:\n            distance_to_next = position\n            distance_to_station = position - f\n\n        if current_fuel < distance_to_next:\n            if current_fuel < distance_to_station:\n                return -1\n            current_fuel = b\n            refuels += 1\n\n        current_fuel -= distance_to_next\n        position = a if direction == 1 else 0\n        direction *= -1\n\n    return refuels\n\n# Read input\na, b, f, k = map(int, input().split())\n\n# Calculate and print the result\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    for i in range(n // p + 1):\n        if (n - i * p) % q == 0:\n            j = (n - i * p) // q\n            print(i + j)\n            for k in range(i):\n                print(s[k * p:(k + 1) * p])\n            for k in range(j):\n                print(s[i * p + k * q:i * p + (k + 1) * q])\n            return\n    print(-1)\n\n# Read input\nn, p, q = map(int, input().split())\ns = input().strip()\n\n# Call the function\nsplit_string(n, p, q, s)"}
{"solution": "def can_reach_finish(n, m, s, d, obstacles):\n    obstacles.sort()\n    current_position = 0\n    result = []\n\n    for i in range(n):\n        if obstacles[i] - current_position - 1 >= s:\n            run_distance = obstacles[i] - current_position - 1\n            if i < n - 1 and obstacles[i + 1] - obstacles[i] - 1 < s:\n                if obstacles[i + 1] - current_position - 1 > d:\n                    return \"IMPOSSIBLE\"\n                jump_distance = obstacles[i + 1] - current_position - 1\n                result.append(f\"RUN {run_distance}\")\n                result.append(f\"JUMP {jump_distance}\")\n                current_position = obstacles[i + 1]\n            else:\n                if obstacles[i] - current_position - 1 > d:\n                    return \"IMPOSSIBLE\"\n                jump_distance = obstacles[i] - current_position - 1\n                result.append(f\"RUN {run_distance}\")\n                result.append(f\"JUMP {jump_distance}\")\n                current_position = obstacles[i]\n        else:\n            return \"IMPOSSIBLE\"\n\n    if m - current_position - 1 >= s:\n        result.append(f\"RUN {m - current_position - 1}\")\n    else:\n        return \"IMPOSSIBLE\"\n\n    return \"\\n\".join(result)\n\n# Read input\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\n# Get the result\nresult = can_reach_finish(n, m, s, d, obstacles)\n\n# Print the result\nprint(result)"}
{"solution": "def count_pairs(s, x):\n    if (s - x) % 2 != 0 or s < x:\n        return 0\n\n    a_plus_b = s\n    a_xor_b = x\n    a_and_b = (a_plus_b - a_xor_b) // 2\n\n    if a_and_b < 0:\n        return 0\n\n    count = 0\n    for i in range(40):\n        if (a_xor_b & (1 << i)) and (a_and_b & (1 << i)):\n            return 0\n\n    for i in range(40):\n        if (a_xor_b & (1 << i)):\n            count += 1\n\n    return 1 << count\n\ns, x = map(int, input().split())\nprint(count_pairs(s, x))"}
{"solution": "def turn_skewers(n, k):\n    # Calculate the step size\n    step = 2 * k + 1\n    \n    # Calculate the number of actions needed\n    actions = (n + step - 1) // step\n    \n    # Calculate the positions to turn\n    positions = []\n    start = (n - (actions - 1) * step + 1) // 2\n    for i in range(actions):\n        positions.append(start + i * step)\n    \n    return actions, positions\n\n# Read input\nn, k = map(int, input().split())\n\n# Get the result\nactions, positions = turn_skewers(n, k)\n\n# Print the result\nprint(actions)\nprint(' '.join(map(str, positions)))"}
{"solution": "import math\n\ndef is_square(x):\n    root = int(math.isqrt(x))\n    return root * root == x\n\ndef min_operations_to_square(n):\n    n_str = str(n)\n    length = len(n_str)\n    min_operations = float('inf')\n    found = False\n    \n    for i in range(1, 1 << length):\n        candidate = []\n        for j in range(length):\n            if i & (1 << j):\n                candidate.append(n_str[j])\n        candidate_num = int(''.join(candidate))\n        if is_square(candidate_num):\n            found = True\n            min_operations = min(min_operations, length - len(candidate))\n    \n    if found:\n        return min_operations\n    else:\n        return -1\n\nn = int(input().strip())\nprint(min_operations_to_square(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef solve(n):\n    if n == 2:\n        print(1)\n        return\n    \n    # For n >= 3, the number of permutations such that f(p) = f_max(n) is (n-1)!\n    result = factorial(n - 1)\n    print(result)\n\n# Read input\nn = int(input().strip())\nsolve(n)"}
{"solution": "def min_jump_ability(s):\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    max_distance = 0\n    last_vowel_position = -1\n\n    for i, char in enumerate(s):\n        if char in vowels:\n            max_distance = max(max_distance, i - last_vowel_position)\n            last_vowel_position = i\n\n    max_distance = max(max_distance, len(s) - last_vowel_position)\n    return max_distance\n\n# Read input\ns = input().strip()\n\n# Calculate and print the result\nprint(min_jump_ability(s))"}
{"solution": "def can_distribute_equally(a1, a2, a3, a4):\n    candies = [a1, a2, a3, a4]\n    total = sum(candies)\n    \n    # If the total number of candies is odd, it's impossible to split them equally\n    if total % 2 != 0:\n        return \"NO\"\n    \n    half = total // 2\n    \n    # Check all possible combinations of distributing the bags\n    for i in range(1 << 4):\n        sum1 = 0\n        for j in range(4):\n            if i & (1 << j):\n                sum1 += candies[j]\n        if sum1 == half:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\na1, a2, a3, a4 = map(int, input().split())\n\n# Print the result\nprint(can_distribute_equally(a1, a2, a3, a4))"}
{"solution": "def optimal_pie_distribution(N, slices):\n    # Initialize sums for Alice and Bob\n    alice_sum = 0\n    bob_sum = 0\n    \n    # Initialize the decider token holder (0 for Alice, 1 for Bob)\n    decider = 1\n    \n    # Iterate through the slices\n    for i in range(N):\n        if decider == 1:  # Bob's turn to decide\n            if i < N - 1 and slices[i] < slices[i + 1]:\n                bob_sum += slices[i + 1]\n                alice_sum += slices[i]\n                decider = 0  # Alice gets the decider token\n                i += 1  # Skip the next slice as it is already taken\n            else:\n                bob_sum += slices[i]\n                decider = 0  # Alice gets the decider token\n        else:  # Alice's turn to decide\n            if i < N - 1 and slices[i] < slices[i + 1]:\n                alice_sum += slices[i + 1]\n                bob_sum += slices[i]\n                decider = 1  # Bob gets the decider token\n                i += 1  # Skip the next slice as it is already taken\n            else:\n                alice_sum += slices[i]\n                decider = 1  # Bob gets the decider token\n    \n    return alice_sum, bob_sum\n\n# Read input\nN = int(input())\nslices = list(map(int, input().split()))\n\n# Get the result\nalice_sum, bob_sum = optimal_pie_distribution(N, slices)\n\n# Print the result\nprint(alice_sum, bob_sum)"}
{"solution": "def min_variables(n, a):\n    a.sort()\n    if a[0] != 1:\n        return -1\n\n    variables = [0] * n\n    variables[0] = a[0]\n    used = 1\n\n    for i in range(1, n):\n        found = False\n        for j in range(used):\n            for k in range(j, used):\n                if variables[j] + variables[k] == a[i]:\n                    variables[used] = a[i]\n                    used += 1\n                    found = True\n                    break\n            if found:\n                break\n        if not found:\n            return -1\n\n    return used\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = min_variables(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def determine_winner(n, piles):\n    # If all piles have the same number of stones, Bob wins\n    if len(set(piles)) == 1:\n        return \"Bob\"\n    else:\n        return \"Alice\"\n\n# Read input\nn = int(input())\npiles = list(map(int, input().split()))\n\n# Determine the winner\nprint(determine_winner(n, piles))"}
{"solution": "def can_make_elements_equal(n, arr):\n    unique_elements = sorted(set(arr))\n    \n    if len(unique_elements) == 1:\n        return \"YES\"\n    elif len(unique_elements) == 2:\n        return \"YES\"\n    elif len(unique_elements) == 3:\n        if unique_elements[2] - unique_elements[1] == unique_elements[1] - unique_elements[0]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Print the result\nprint(can_make_elements_equal(n, arr))"}
{"solution": "def find_max_length(N, S):\n    def has_repeated_substring_of_length(length):\n        seen = set()\n        for i in range(N - length + 1):\n            substring = S[i:i + length]\n            if substring in seen:\n                return True\n            seen.add(substring)\n        return False\n\n    left, right = 1, N\n    max_len = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if has_repeated_substring_of_length(mid):\n            max_len = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return max_len\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    S = data[1]\n    print(find_max_length(N, S))"}
{"solution": "def min_time_to_reach_house(n, a):\n    if a % 2 == 1:\n        return (a + 1) // 2\n    else:\n        return (n - a + 2) // 2\n\n# Read input\nn, a = map(int, input().split())\n\n# Calculate and print the result\nprint(min_time_to_reach_house(n, a))"}
{"solution": "def find_jedi_interval(n, m, colors, k):\n    # Initialize the count of each color in the current window\n    current_count = [0] * m\n    \n    # Initialize the start of the window\n    start = 0\n    \n    # Iterate over the end of the window\n    for end in range(n):\n        # Increment the count of the current color\n        current_count[colors[end] - 1] += 1\n        \n        # Check if the current window is valid\n        while all(current_count[i] >= k[i] for i in range(m)):\n            # If the current window is valid, return YES\n            if all(current_count[i] == k[i] for i in range(m)):\n                return \"YES\"\n            # Move the start of the window to the right\n            current_count[colors[start] - 1] -= 1\n            start += 1\n    \n    # If no valid window is found, return NO\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\nk = list(map(int, input().split()))\n\n# Find and print the result\nprint(find_jedi_interval(n, m, colors, k))"}
{"solution": "n = int(input())\nmishka_wins = 0\nchris_wins = 0\n\nfor _ in range(n):\n    m_i, c_i = map(int, input().split())\n    if m_i > c_i:\n        mishka_wins += 1\n    elif c_i > m_i:\n        chris_wins += 1\n\nif mishka_wins > chris_wins:\n    print(\"Mishka\")\nelif chris_wins > mishka_wins:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")"}
{"solution": "def is_valid_minesweeper_field(n, m, field):\n    def count_bombs_around(x, y):\n        count = 0\n        for dx in range(-1, 2):\n            for dy in range(-1, 2):\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and field[nx][ny] == '*':\n                    count += 1\n        return count\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '.':\n                if count_bombs_around(i, j) != 0:\n                    return \"NO\"\n            elif field[i][j].isdigit():\n                if count_bombs_around(i, j) != int(field[i][j]):\n                    return \"NO\"\n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Check if the field is valid\nprint(is_valid_minesweeper_field(n, m, field))"}
{"solution": "def can_vasya_eat_half(n, k):\n    vasya_eaten = 0\n    total_candies = n\n    \n    while total_candies > 0:\n        vasya_eaten += min(k, total_candies)\n        total_candies -= min(k, total_candies)\n        petya_eaten = total_candies // 10\n        total_candies -= petya_eaten\n    \n    return vasya_eaten * 2 >= n\n\ndef find_min_k(n):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\nn = int(input())\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace(s):\n    pearls = s.count('o')\n    links = s.count('-')\n    \n    if pearls == 0:\n        print(\"YES\")\n        return\n    \n    if links % pearls == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n# Read input\ns = input().strip()\ncan_rearrange_necklace(s)"}
{"solution": "def max_pillows(n, m, k):\n    def can_distribute(p):\n        left = k - 1\n        right = n - k\n        total = p\n        if left > 0:\n            if p > left:\n                total += (p - 1) * left - (left * (left - 1)) // 2\n            else:\n                total += (p * (p - 1)) // 2 + (left - p + 1)\n        if right > 0:\n            if p > right:\n                total += (p - 1) * right - (right * (right - 1)) // 2\n            else:\n                total += (p * (p - 1)) // 2 + (right - p + 1)\n        return total <= m\n\n    low, high = 1, m\n    while low < high:\n        mid = (low + high + 1) // 2\n        if can_distribute(mid):\n            low = mid\n        else:\n            high = mid - 1\n    return low\n\n# Read input\nn, m, k = map(int, input().strip().split())\n\n# Print the result\nprint(max_pillows(n, m, k))"}
{"solution": "import sys\nimport math\n\ndef max_subarray_cost(n, m, k, a):\n    max_cost = 0\n    current_sum = 0\n    min_prefix_sum = 0\n    prefix_sums = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + a[i - 1]\n    \n    for r in range(1, n + 1):\n        for l in range(r):\n            subarray_sum = prefix_sums[r] - prefix_sums[l]\n            length = r - l\n            cost = subarray_sum - k * math.ceil(length / m)\n            max_cost = max(max_cost, cost)\n    \n    return max_cost\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2])\n    a = list(map(int, data[3:]))\n    \n    result = max_subarray_cost(n, m, k, a)\n    print(result)"}
{"solution": "def find_longest_polyline(n, m):\n    if n == 0:\n        return [(0, 1), (0, m), (0, 0), (0, m-1)]\n    elif m == 0:\n        return [(1, 0), (n, 0), (0, 0), (n-1, 0)]\n    else:\n        return [(0, 0), (n, m), (0, m), (n, 0)]\n\n# Read input\nn, m = map(int, input().split())\n\n# Find the longest polyline\npoints = find_longest_polyline(n, m)\n\n# Print the points\nfor point in points:\n    print(point[0], point[1])"}
{"solution": "def find_smallest_n(received, remembered):\n    k = len(received) - len(remembered)\n    possible_ns = []\n\n    for i in range(len(received) - k + 1):\n        candidate = received[:i] + received[i + k:]\n        if remembered in candidate:\n            possible_ns.append(candidate)\n\n    possible_ns = [int(n) for n in possible_ns]\n    return str(min(possible_ns))\n\n# Read input\nreceived = input().strip()\nremembered = input().strip()\n\n# Find and print the smallest possible n\nprint(find_smallest_n(received, remembered))"}
{"solution": "# Read input values\nn, m, min_temp, max_temp = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\n# Check if the given temperatures already contain min and max\ncontains_min = min_temp in temperatures\ncontains_max = max_temp in temperatures\n\n# Calculate how many more temperatures we need to add\nremaining_temps = n - m\n\n# Check if we can add the necessary min and max temperatures\nif contains_min and contains_max:\n    print(\"Correct\")\nelif contains_min and not contains_max:\n    if remaining_temps >= 1:\n        print(\"Correct\")\n    else:\n        print(\"Incorrect\")\nelif not contains_min and contains_max:\n    if remaining_temps >= 1:\n        print(\"Correct\")\n    else:\n        print(\"Incorrect\")\nelse:\n    if remaining_temps >= 2:\n        print(\"Correct\")\n    else:\n        print(\"Incorrect\")"}
{"solution": "def count_trailing_zeroes(n):\n    count = 0\n    power_of_5 = 5\n    while n >= power_of_5:\n        count += n // power_of_5\n        power_of_5 *= 5\n    return count\n\ndef find_numbers_with_m_zeroes(m):\n    low, high = 0, 5 * (m + 1)\n    result = []\n\n    while low <= high:\n        mid = (low + high) // 2\n        zeroes = count_trailing_zeroes(mid)\n        \n        if zeroes < m:\n            low = mid + 1\n        elif zeroes > m:\n            high = mid - 1\n        else:\n            result = [i for i in range(mid - mid % 5, mid - mid % 5 + 5) if count_trailing_zeroes(i) == m]\n            break\n\n    return result\n\nm = int(input().strip())\nresult = find_numbers_with_m_zeroes(m)\nprint(len(result))\nif result:\n    print(\" \".join(map(str, result)))"}
{"solution": "import heapq\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\nspecial_vertices = list(map(int, data[3:3+k]))\n\nedges = []\nindex = 3 + k\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index+1])\n    w = int(data[index+2])\n    edges.append((w, u, v))\n    index += 3\n\n# Kruskal's algorithm to find the Minimum Spanning Tree (MST)\nparent = list(range(n + 1))\nrank = [0] * (n + 1)\n\ndef find(u):\n    if parent[u] != u:\n        parent[u] = find(parent[u])\n    return parent[u]\n\ndef union(u, v):\n    root_u = find(u)\n    root_v = find(v)\n    if root_u != root_v:\n        if rank[root_u] > rank[root_v]:\n            parent[root_v] = root_u\n        elif rank[root_u] < rank[root_v]:\n            parent[root_u] = root_v\n        else:\n            parent[root_v] = root_u\n            rank[root_u] += 1\n\nedges.sort()\nmst = defaultdict(list)\nfor w, u, v in edges:\n    if find(u) != find(v):\n        union(u, v)\n        mst[u].append((v, w))\n        mst[v].append((u, w))\n\n# Dijkstra's algorithm to find the maximum edge weight in the shortest path\ndef dijkstra_max_edge(start):\n    max_edge = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    pq = [(0, start)]\n    while pq:\n        max_w, u = heapq.heappop(pq)\n        if visited[u]:\n            continue\n        visited[u] = True\n        for v, w in mst[u]:\n            if not visited[v]:\n                new_max_w = max(max_w, w)\n                if new_max_w < max_edge[v] or max_edge[v] == 0:\n                    max_edge[v] = new_max_w\n                    heapq.heappush(pq, (new_max_w, v))\n    return max_edge\n\nmax_distances = [0] * k\nfor i in range(k):\n    max_edge = dijkstra_max_edge(special_vertices[i])\n    max_distances[i] = max(max_edge[special_vertices[j]] for j in range(k) if i != j)\n\nprint(\" \".join(map(str, max_distances)))"}
{"solution": "def find_initial_position(n, x):\n    # We will reverse the moves to find the initial position\n    for i in range(n, 0, -1):\n        if i % 2 == 1:\n            # Odd move: swap left (0) and middle (1)\n            if x == 0:\n                x = 1\n            elif x == 1:\n                x = 0\n        else:\n            # Even move: swap middle (1) and right (2)\n            if x == 1:\n                x = 2\n            elif x == 2:\n                x = 1\n    return x\n\n# Read input\nn = int(input())\nx = int(input())\n\n# Find and print the initial position\nprint(find_initial_position(n, x))"}
{"solution": "def is_square(rectangles):\n    min_x = min(rect[0] for rect in rectangles)\n    max_x = max(rect[2] for rect in rectangles)\n    min_y = min(rect[1] for rect in rectangles)\n    max_y = max(rect[3] for rect in rectangles)\n\n    side_length = max_x - min_x\n    if side_length != max_y - min_y:\n        return \"NO\"\n\n    covered_area = 0\n    for rect in rectangles:\n        covered_area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n\n    if covered_area == side_length * side_length:\n        return \"YES\"\n    else:\n        return \"NO\"\n\nn = int(input())\nrectangles = [list(map(int, input().split())) for _ in range(n)]\nprint(is_square(rectangles))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef count_really_big_numbers(n, s):\n    count = 0\n    for x in range(s, n + 1):\n        if x - sum_of_digits(x) >= s:\n            count += 1\n    return count\n\n# Read input\nn, s = map(int, input().split())\n\n# Calculate and print the result\nprint(count_really_big_numbers(n, s))"}
{"solution": "def is_possible(n, points):\n    if n <= 2:\n        return \"YES\"\n    \n    def collinear(p1, p2, p3):\n        return (p2[1] - p1[1]) * (p3[0] - p1[0]) == (p3[1] - p1[1]) * (p2[0] - p1[0])\n    \n    def check_line(exclude):\n        remaining = [points[i] for i in range(n) if i not in exclude]\n        if len(remaining) <= 2:\n            return True\n        for i in range(2, len(remaining)):\n            if not collinear(remaining[0], remaining[1], remaining[i]):\n                return False\n        return True\n    \n    for i in range(2, n):\n        if collinear(points[0], points[1], points[i]):\n            continue\n        if check_line({0, 1}) or check_line({0, i}) or check_line({1, i}):\n            return \"YES\"\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(n)]\n\n# Print output\nprint(is_possible(n, points))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(a, b, k, t):\n    dp = [[0] * (2 * k * t + 1) for _ in range(2)]\n    offset = k * t\n    dp[0][a - b + offset] = 1\n\n    for turn in range(1, t + 1):\n        current = turn % 2\n        previous = 1 - current\n        for i in range(2 * k * t + 1):\n            dp[current][i] = 0\n\n        for i in range(2 * k * t + 1):\n            if dp[previous][i] == 0:\n                continue\n            for j in range(-k, k + 1):\n                for l in range(-k, k + 1):\n                    ni = i + j - l\n                    if 0 <= ni < 2 * k * t + 1:\n                        dp[current][ni] = (dp[current][ni] + dp[previous][i]) % MOD\n\n    result = 0\n    for i in range(offset + 1, 2 * k * t + 1):\n        result = (result + dp[t % 2][i]) % MOD\n\n    print(result)\n\n# Example usage\na, b, k, t = map(int, input().split())\nsolve(a, b, k, t)"}
{"solution": "def find_minimum_marks(n, l, x, y, marks):\n    marks_set = set(marks)\n    can_measure_x = any((mark + x) in marks_set or (mark - x) in marks_set for mark in marks)\n    can_measure_y = any((mark + y) in marks_set or (mark - y) in marks_set for mark in marks)\n\n    if can_measure_x and can_measure_y:\n        return 0, []\n\n    if can_measure_x:\n        for mark in marks:\n            if (mark + y <= l and (mark + y) not in marks_set) or (mark - y >= 0 and (mark - y) not in marks_set):\n                return 1, [mark + y] if mark + y <= l else [mark - y]\n        return 1, [y]\n\n    if can_measure_y:\n        for mark in marks:\n            if (mark + x <= l and (mark + x) not in marks_set) or (mark - x >= 0 and (mark - x) not in marks_set):\n                return 1, [mark + x] if mark + x <= l else [mark - x]\n        return 1, [x]\n\n    for mark in marks:\n        if (mark + x <= l and (mark + x + y) in marks_set) or (mark + x <= l and (mark + x - y) in marks_set):\n            return 1, [mark + x]\n        if (mark - x >= 0 and (mark - x + y) in marks_set) or (mark - x >= 0 and (mark - x - y) in marks_set):\n            return 1, [mark - x]\n        if (mark + y <= l and (mark + y + x) in marks_set) or (mark + y <= l and (mark + y - x) in marks_set):\n            return 1, [mark + y]\n        if (mark - y >= 0 and (mark - y + x) in marks_set) or (mark - y >= 0 and (mark - y - x) in marks_set):\n            return 1, [mark - y]\n\n    return 2, [x, y]\n\n# Read input\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Find the minimum number of marks to add\nv, new_marks = find_minimum_marks(n, l, x, y, marks)\n\n# Print the result\nprint(v)\nif v > 0:\n    print(\" \".join(map(str, new_marks)))"}
{"solution": "import math\nimport sys\ninput = sys.stdin.read\n\ndef max_cake_volume(n, cakes):\n    volumes = [(math.pi * r * r * h) for r, h in cakes]\n    dp = [0] * n\n    dp[0] = volumes[0]\n    \n    for i in range(1, n):\n        dp[i] = volumes[i]\n        for j in range(i):\n            if volumes[i] > volumes[j]:\n                dp[i] = max(dp[i], dp[j] + volumes[i])\n    \n    return max(dp)\n\nif __name__ == \"__main__\":\n    data = input().split()\n    n = int(data[0])\n    cakes = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(n)]\n    result = max_cake_volume(n, cakes)\n    print(f\"{result:.9f}\")"}
{"solution": "def min_good_slices(n, k, heights):\n    heights.sort(reverse=True)\n    slices = 0\n    current_height = heights[0]\n    total_removed = 0\n\n    for i in range(1, n):\n        if heights[i] < current_height:\n            cost = (current_height - heights[i]) * i\n            if total_removed + cost > k:\n                slices += 1\n                total_removed = 0\n            total_removed += cost\n            current_height = heights[i]\n\n    if total_removed > 0:\n        slices += 1\n\n    return slices\n\n# Read input\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_good_slices(n, k, heights))"}
{"solution": "def max_score(n, a):\n    max_score = float('-inf')\n    for l in range(n):\n        current_sum = 0\n        min_value_in_segment = float('inf')\n        for r in range(l, n):\n            current_sum += a[r]\n            min_value_in_segment = min(min_value_in_segment, a[r])\n            score = current_sum - min_value_in_segment\n            max_score = max(max_score, score)\n    return max_score\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_score(n, a))"}
{"solution": "def can_decorate_tree(k1, k2, k3):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    lcm12 = lcm(k1, k2)\n    lcm123 = lcm(lcm12, k3)\n\n    if lcm123 <= k1 + k2 + k3:\n        return \"YES\"\n    else:\n        return \"NO\"\n\nk1, k2, k3 = map(int, input().split())\nprint(can_decorate_tree(k1, k2, k3))"}
{"solution": "def min_operations_to_delete_string(n, s):\n    dp = [[0] * n for _ in range(n)]\n    \n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if length == 1:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i + 1][j] + 1\n                if s[i] == s[i + 1]:\n                    dp[i][j] = min(dp[i][j], dp[i + 1][j])\n                for k in range(i + 2, j + 1):\n                    if s[i] == s[k]:\n                        dp[i][j] = min(dp[i][j], dp[i + 1][k - 1] + dp[k + 1][j])\n    \n    return dp[0][n - 1]\n\nn = int(input())\ns = input().strip()\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "n = int(input())\nboys = list(map(int, input().split()))\nm = int(input())\ngirls = list(map(int, input().split()))\n\nboys.sort()\ngirls.sort()\n\ni, j = 0, 0\npairs = 0\n\nwhile i < n and j < m:\n    if abs(boys[i] - girls[j]) <= 1:\n        pairs += 1\n        i += 1\n        j += 1\n    elif boys[i] < girls[j]:\n        i += 1\n    else:\n        j += 1\n\nprint(pairs)"}
{"solution": "def can_team_win(a1, b1, a2, b2, a3, b3, a4, b4):\n    # First team configurations\n    team1_configs = [(a1, b2), (a2, b1)]\n    # Second team configurations\n    team2_configs = [(a3, b4), (a4, b3)]\n    \n    # Check if team 1 can win in any configuration\n    team1_wins = any(\n        all(\n            team1_def > team2_att and team1_att > team2_def\n            for team2_def, team2_att in team2_configs\n        )\n        for team1_def, team1_att in team1_configs\n    )\n    \n    # Check if team 2 can win in any configuration\n    team2_wins = any(\n        all(\n            team2_def > team1_att and team2_att > team1_def\n            for team1_def, team1_att in team1_configs\n        )\n        for team2_def, team2_att in team2_configs\n    )\n    \n    if team1_wins:\n        return \"Team 1\"\n    elif team2_wins:\n        return \"Team 2\"\n    else:\n        return \"Draw\"\n\n# Read input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\na4, b4 = map(int, input().split())\n\n# Determine the result\nresult = can_team_win(a1, b1, a2, b2, a3, b3, a4, b4)\nprint(result)"}
{"solution": "import sys\nimport math\nfrom scipy.optimize import minimize\n\ndef time_to_grill(XY, meats, K):\n    X, Y = XY\n    times = [c * math.sqrt((X - x) ** 2 + (Y - y) ** 2) for x, y, c in meats]\n    times.sort()\n    return times[K-1]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    meats = []\n    \n    for i in range(N):\n        x = int(data[2 + 3 * i])\n        y = int(data[3 + 3 * i])\n        c = int(data[4 + 3 * i])\n        meats.append((x, y, c))\n    \n    initial_guess = [0, 0]\n    result = minimize(time_to_grill, initial_guess, args=(meats, K), method='Nelder-Mead')\n    \n    print(f\"{result.fun:.6f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def determine_winner(n, ticket):\n    half = n // 2\n    left_sum = 0\n    right_sum = 0\n    left_question_marks = 0\n    right_question_marks = 0\n\n    for i in range(half):\n        if ticket[i] == '?':\n            left_question_marks += 1\n        else:\n            left_sum += int(ticket[i])\n\n    for i in range(half, n):\n        if ticket[i] == '?':\n            right_question_marks += 1\n        else:\n            right_sum += int(ticket[i])\n\n    if (left_question_marks + right_question_marks) % 2 != 0:\n        return \"Monocarp\"\n\n    diff = left_sum - right_sum\n    question_diff = (right_question_marks - left_question_marks) // 2\n\n    if diff + question_diff * 9 == 0:\n        return \"Bicarp\"\n    else:\n        return \"Monocarp\"\n\n# Read input\nn = int(input().strip())\nticket = input().strip()\n\n# Determine the winner\nprint(determine_winner(n, ticket))"}
{"solution": "n, t = map(int, input().split())\nbus_routes = []\n\nfor _ in range(n):\n    s, d = map(int, input().split())\n    bus_routes.append((s, d))\n\nmin_wait_time = float('inf')\nchosen_route = -1\n\nfor i, (s, d) in enumerate(bus_routes):\n    if s >= t:\n        wait_time = s - t\n    else:\n        wait_time = ((t - s + d - 1) // d) * d + s - t\n    \n    if wait_time < min_wait_time:\n        min_wait_time = wait_time\n        chosen_route = i + 1\n\nprint(chosen_route)"}
{"solution": "def count_ones_in_binary(x):\n    return bin(x).count('1')\n\ndef find_n(m, k):\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        count = sum(1 for i in range(mid + 1, 2 * mid + 1) if count_ones_in_binary(i) == k)\n        if count < m:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    m = int(data[0])\n    k = int(data[1])\n    print(find_n(m, k))"}
{"solution": "def is_good_level(n, level):\n    platforms = [i for i in range(n) if level[i] == '*']\n    for i in range(len(platforms) - 4):\n        for j in range(i + 1, len(platforms) - 3):\n            step = platforms[j] - platforms[i]\n            if all(platforms[i] + k * step in platforms for k in range(1, 5)):\n                return \"yes\"\n    return \"no\"\n\n# Read input\nn = int(input())\nlevel = input().strip()\n\n# Check if the level is good\nprint(is_good_level(n, level))"}
{"solution": "def find_magic_number(n, grid):\n    # Find the position of the empty cell\n    empty_row, empty_col = -1, -1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                empty_row, empty_col = i, j\n                break\n        if empty_row != -1:\n            break\n\n    # Calculate the target sum using a row that doesn't contain the empty cell\n    target_sum = -1\n    for i in range(n):\n        if i != empty_row:\n            target_sum = sum(grid[i])\n            break\n\n    # Calculate the sum of the row and column containing the empty cell\n    row_sum = sum(grid[empty_row])\n    col_sum = sum(grid[i][empty_col] for i in range(n))\n\n    # Calculate the required value to fill the empty cell\n    fill_value = target_sum - row_sum\n\n    # Check if the fill_value is positive\n    if fill_value <= 0:\n        return -1\n\n    # Temporarily fill the empty cell with the calculated value\n    grid[empty_row][empty_col] = fill_value\n\n    # Check if all rows, columns, and diagonals sum to the target sum\n    for i in range(n):\n        if sum(grid[i]) != target_sum:\n            return -1\n        if sum(grid[j][i] for j in range(n)) != target_sum:\n            return -1\n\n    if sum(grid[i][i] for i in range(n)) != target_sum:\n        return -1\n    if sum(grid[i][n - i - 1] for i in range(n)) != target_sum:\n        return -1\n\n    return fill_value\n\n# Read input\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\n# Find the magic number to fill the empty cell\nresult = find_magic_number(n, grid)\n\n# Print the result\nprint(result)"}
{"solution": "def calculate_min_max(n, m, a):\n    max_initial = max(a)\n    max_possible = max_initial + m\n    \n    total_people = sum(a) + m\n    min_possible = (total_people + n - 1) // n\n    \n    return min_possible, max_possible\n\n# Read input\nn = int(input())\nm = int(input())\na = [int(input()) for _ in range(n)]\n\n# Calculate and print the result\nmin_k, max_k = calculate_min_max(n, m, a)\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, m):\n    if m == 1:\n        return (2 * n) % MOD\n    \n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    inv_fact = [1] * (n + 1)\n    inv_fact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    def comb(x, y):\n        if y > x or y < 0:\n            return 0\n        return fact[x] * inv_fact[y] % MOD * inv_fact[x - y] % MOD\n    \n    result = 0\n    for k in range(m):\n        result = (result + comb(n - 1, k) * comb(n - 1, m - 1 - k)) % MOD\n    \n    return (result * pow(2, m, MOD)) % MOD\n\nn, m = map(int, input().split())\nprint(count_ways(n, m))"}
{"solution": "def main():\n    import sys\n    input = sys.stdin.read\n    from itertools import combinations\n\n    data = input().split()\n    idx = 0\n\n    n = int(data[idx])\n    m = int(data[idx + 1])\n    idx += 2\n\n    friends = []\n    for _ in range(n):\n        f_i = int(data[idx])\n        ingredients = set(map(int, data[idx + 1: idx + 1 + f_i]))\n        friends.append(ingredients)\n        idx += 1 + f_i\n\n    pizzas = []\n    for j in range(m):\n        c_j = int(data[idx])\n        r_j = int(data[idx + 1])\n        ingredients = set(map(int, data[idx + 2: idx + 2 + r_j]))\n        pizzas.append((c_j, ingredients, j + 1))\n        idx += 2 + r_j\n\n    max_satisfied = 0\n    min_cost = float('inf')\n    best_pair = (1, 2)\n\n    for (c1, ing1, idx1), (c2, ing2, idx2) in combinations(pizzas, 2):\n        combined_ingredients = ing1 | ing2\n        satisfied = sum(1 for friend in friends if friend <= combined_ingredients)\n        cost = c1 + c2\n\n        if satisfied > max_satisfied or (satisfied == max_satisfied and cost < min_cost):\n            max_satisfied = satisfied\n            min_cost = cost\n            best_pair = (idx1, idx2)\n\n    print(best_pair[0], best_pair[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_min_max(m, s):\n    if s == 0:\n        if m == 1:\n            return \"0 0\"\n        else:\n            return \"-1 -1\"\n    \n    if s > 9 * m:\n        return \"-1 -1\"\n    \n    min_num = [0] * m\n    max_num = [0] * m\n    \n    # Find the minimum number\n    sum_digits = s\n    for i in range(m - 1, -1, -1):\n        if sum_digits > 9:\n            min_num[i] = 9\n            sum_digits -= 9\n        else:\n            min_num[i] = sum_digits\n            sum_digits = 0\n    \n    if min_num[0] == 0:\n        for i in range(1, m):\n            if min_num[i] > 0:\n                min_num[i] -= 1\n                min_num[0] = 1\n                break\n    \n    # Find the maximum number\n    sum_digits = s\n    for i in range(m):\n        if sum_digits > 9:\n            max_num[i] = 9\n            sum_digits -= 9\n        else:\n            max_num[i] = sum_digits\n            sum_digits = 0\n    \n    min_num_str = ''.join(map(str, min_num))\n    max_num_str = ''.join(map(str, max_num))\n    \n    return f\"{min_num_str} {max_num_str}\"\n\n# Read input\nm, s = map(int, input().split())\n\n# Find and print the result\nprint(find_min_max(m, s))"}
{"solution": "MOD = 998244353\n\ndef count_unique_digits(n):\n    return len(set(str(n)))\n\ndef sum_of_numbers_with_k_digits(l, r, k):\n    total_sum = 0\n    for num in range(l, r + 1):\n        if count_unique_digits(num) <= k:\n            total_sum = (total_sum + num) % MOD\n    return total_sum\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    l = int(data[0])\n    r = int(data[1])\n    k = int(data[2])\n    result = sum_of_numbers_with_k_digits(l, r, k)\n    print(result)"}
{"solution": "def can_distribute_pencils(n, k, d, saturations):\n    saturations.sort()\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = [0] * (n + 1)\n    prefix_sum[0] = 1\n\n    for i in range(1, n + 1):\n        left = 0\n        right = i - k\n        if right >= 0:\n            while left < right and saturations[i - 1] - saturations[left] > d:\n                left += 1\n            if left <= right and prefix_sum[right + 1] - prefix_sum[left] > 0:\n                dp[i] = 1\n        prefix_sum[i] = prefix_sum[i - 1] + dp[i]\n\n    return \"YES\" if dp[n] else \"NO\"\n\n# Read input\nn, k, d = map(int, input().split())\nsaturations = list(map(int, input().split()))\n\n# Print the result\nprint(can_distribute_pencils(n, k, d, saturations))"}
{"solution": "def count_dead_bulbs(s):\n    n = len(s)\n    color_positions = {'R': -1, 'B': -1, 'Y': -1, 'G': -1}\n    dead_counts = {'R': 0, 'B': 0, 'Y': 0, 'G': 0}\n\n    # Determine the positions of each color in the first 4 characters\n    for i in range(4):\n        if s[i] != '!':\n            color_positions[s[i]] = i\n\n    # Iterate through the string in steps of 4 to count dead bulbs\n    for i in range(n):\n        if s[i] == '!':\n            pos = i % 4\n            for color, position in color_positions.items():\n                if position == pos:\n                    dead_counts[color] += 1\n\n    print(dead_counts['R'], dead_counts['B'], dead_counts['Y'], dead_counts['G'])\n\n# Example usage\ns = input().strip()\ncount_dead_bulbs(s)"}
{"solution": "import sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances\n\ndef minimize_expected_passages(n, m, passages):\n    graph = [[] for _ in range(n + 1)]\n    for s, t in passages:\n        graph[s].append((t, 1))\n    \n    original_distances = dijkstra(graph, 1, n)\n    min_expected_passages = original_distances[n]\n    \n    for s, t in passages:\n        graph[s].remove((t, 1))\n        new_distances = dijkstra(graph, 1, n)\n        if new_distances[n] < float('inf'):\n            min_expected_passages = min(min_expected_passages, new_distances[n])\n        graph[s].append((t, 1))\n    \n    return min_expected_passages\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    passages = []\n    index = 2\n    for _ in range(m):\n        s = int(data[index])\n        t = int(data[index + 1])\n        passages.append((s, t))\n        index += 2\n    \n    result = minimize_expected_passages(n, m, passages)\n    print(f\"{result:.10f}\")"}
{"solution": "n = int(input())\n\nif n % 10 == 0:\n    print(n)\nelse:\n    lower = (n // 10) * 10\n    upper = lower + 10\n    if n - lower < upper - n:\n        print(lower)\n    else:\n        print(upper)"}
{"solution": "def find_swaps(s, t):\n    if len(s) != len(t):\n        return -1\n\n    swaps = []\n    used = set()\n    swap_map = {}\n\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if s[i] in used or t[i] in used:\n                return -1\n            if s[i] in swap_map:\n                if swap_map[s[i]] != t[i]:\n                    return -1\n            else:\n                swap_map[s[i]] = t[i]\n                swap_map[t[i]] = s[i]\n                swaps.append((s[i], t[i]))\n                used.add(s[i])\n                used.add(t[i])\n\n    return swaps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    s = data[0]\n    t = data[1]\n\n    swaps = find_swaps(s, t)\n    if swaps == -1:\n        print(-1)\n    else:\n        print(len(swaps))\n        for swap in swaps:\n            print(swap[0], swap[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def earliest_login(first_name, last_name):\n    earliest = first_name[0] + last_name[0]\n    for i in range(1, len(first_name) + 1):\n        for j in range(1, len(last_name) + 1):\n            login = first_name[:i] + last_name[:j]\n            if login < earliest:\n                earliest = login\n    return earliest\n\n# Read input\nfirst_name, last_name = input().split()\n\n# Get the earliest login\nresult = earliest_login(first_name, last_name)\n\n# Print the result\nprint(result)"}
{"solution": "def draw_brackets(n, sequence):\n    # Determine the maximum depth of nested brackets\n    max_depth = 0\n    current_depth = 0\n    for char in sequence:\n        if char == '[':\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        else:\n            current_depth -= 1\n\n    # Initialize the drawing grid\n    height = 2 * max_depth + 1\n    width = n + (n // 2) * 2\n    grid = [[' ' for _ in range(width)] for _ in range(height)]\n\n    # Function to draw a single bracket pair\n    def draw_bracket(x, y, depth):\n        grid[y][x] = '+'\n        grid[y][x + 1] = '-'\n        grid[y][x + 2] = '-'\n        grid[y][x + 3] = '+'\n        for i in range(1, depth + 1):\n            grid[y + i][x] = '|'\n            grid[y + i][x + 3] = '|'\n        grid[y + depth + 1][x] = '+'\n        grid[y + depth + 1][x + 1] = '-'\n        grid[y + depth + 1][x + 2] = '-'\n        grid[y + depth + 1][x + 3] = '+'\n\n    # Draw the brackets\n    x = 0\n    y = 0\n    stack = []\n    for char in sequence:\n        if char == '[':\n            stack.append((x, y))\n            depth = len(stack) - 1\n            draw_bracket(x, y, depth)\n            x += 4\n        else:\n            x, y = stack.pop()\n            y += 1\n\n    # Print the grid\n    for row in grid:\n        print(''.join(row))\n\n# Read input\nn = int(input())\nsequence = input().strip()\n\n# Draw the brackets\ndraw_brackets(n, sequence)"}
{"solution": "def golden_compare(num1, num2):\n    # Function to convert golden system number to its decimal value\n    def golden_to_decimal(golden_num):\n        q = (5 ** 0.5 + 1) / 2\n        decimal_value = 0\n        length = len(golden_num)\n        for i in range(length):\n            if golden_num[i] == '1':\n                decimal_value += q ** (length - i - 1)\n        return decimal_value\n\n    # Convert both numbers to their decimal values\n    decimal_num1 = golden_to_decimal(num1)\n    decimal_num2 = golden_to_decimal(num2)\n\n    # Compare the decimal values\n    if decimal_num1 > decimal_num2:\n        return \">\"\n    elif decimal_num1 < decimal_num2:\n        return \"<\"\n    else:\n        return \"=\"\n\n# Read input\nnum1 = input().strip()\nnum2 = input().strip()\n\n# Print the result of comparison\nprint(golden_compare(num1, num2))"}
{"solution": "# Define the mapping of colors to gem names\ncolor_to_gem = {\n    \"purple\": \"Power\",\n    \"green\": \"Time\",\n    \"blue\": \"Space\",\n    \"orange\": \"Soul\",\n    \"red\": \"Reality\",\n    \"yellow\": \"Mind\"\n}\n\n# Read the number of gems present\nn = int(input().strip())\n\n# Read the colors of the present gems\npresent_colors = set()\nfor _ in range(n):\n    color = input().strip()\n    present_colors.add(color)\n\n# Determine the absent gems\nabsent_gems = []\nfor color, gem in color_to_gem.items():\n    if color not in present_colors:\n        absent_gems.append(gem)\n\n# Output the number of absent gems\nprint(len(absent_gems))\n\n# Output the names of the absent gems\nfor gem in absent_gems:\n    print(gem)"}
{"solution": "def find_round(n, a, b):\n    round_num = 1\n    while n > 1:\n        if (a + 1) // 2 == (b + 1) // 2:\n            return round_num\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n //= 2\n        round_num += 1\n    return \"Final!\"\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Ensure a is less than b for simplicity\nif a > b:\n    a, b = b, a\n\n# Find and print the round\nprint(find_round(n, a, b))"}
{"solution": "def min_changes_to_suit_pavel(n, p, b):\n    # Function to find the minimum number of changes required\n    def find_min_changes(n, p, b):\n        visited = [False] * n\n        cycles = []\n        \n        # Find all cycles in the permutation\n        for i in range(n):\n            if not visited[i]:\n                cycle = []\n                x = i\n                while not visited[x]:\n                    visited[x] = True\n                    cycle.append(x)\n                    x = p[x] - 1\n                cycles.append(cycle)\n        \n        # Count the number of cycles with odd length\n        odd_cycles = sum(1 for cycle in cycles if len(cycle) % 2 == 1)\n        \n        # Count the number of 1s in b\n        ones_in_b = sum(b)\n        \n        # Minimum changes required\n        min_changes = max(odd_cycles - ones_in_b, 0)\n        \n        return min_changes\n    \n    return find_min_changes(n, p, b)\n\n# Read input\nn = int(input().strip())\np = list(map(int, input().strip().split()))\nb = list(map(int, input().strip().split()))\n\n# Get the result\nresult = min_changes_to_suit_pavel(n, p, b)\n\n# Print the result\nprint(result)"}
{"solution": "def max_path_length(v1, v2, t, d):\n    speeds = [v1]\n    for i in range(1, t - 1):\n        next_speed = min(speeds[-1] + d, v2 + (t - 1 - i) * d)\n        speeds.append(next_speed)\n    speeds.append(v2)\n    return sum(speeds)\n\n# Read input\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Calculate and print the maximum possible length of the path segment\nprint(max_path_length(v1, v2, t, d))"}
{"solution": "from itertools import permutations\n\ndef can_cross(bridge_parts, camels, order):\n    for length, capacity in bridge_parts:\n        current_weight = 0\n        for i in range(len(order)):\n            if current_weight + camels[order[i]] > capacity:\n                return False\n            current_weight += camels[order[i]]\n            if i < len(order) - 1:\n                current_weight -= camels[order[i]]\n    return True\n\ndef min_distance(N, M, camels, bridge_parts):\n    min_dist = float('inf')\n    for order in permutations(range(N)):\n        if can_cross(bridge_parts, camels, order):\n            min_dist = min(min_dist, sum(bridge_parts[i][0] for i in range(M)))\n    return min_dist if min_dist != float('inf') else -1\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    camels = list(map(int, data[2:N+2]))\n    bridge_parts = [(int(data[i]), int(data[i+1])) for i in range(N+2, len(data), 2)]\n    \n    result = min_distance(N, M, camels, bridge_parts)\n    print(result)"}
{"solution": "def last_digit_of_reincarnations(a, b):\n    if a == b:\n        return 1\n    if b - a >= 5:\n        return 0\n    result = 1\n    for i in range(a + 1, b + 1):\n        result *= i\n        result %= 10\n    return result\n\n# Read input\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(last_digit_of_reincarnations(a, b))"}
{"solution": "def minimal_jumps(n, d, s):\n    jumps = 0\n    position = 0\n    \n    while position < n - 1:\n        next_position = position\n        for i in range(1, d + 1):\n            if position + i < n and s[position + i] == '1':\n                next_position = position + i\n        if next_position == position:\n            return -1\n        position = next_position\n        jumps += 1\n    \n    return jumps\n\n# Read input\nn, d = map(int, input().split())\ns = input().strip()\n\n# Calculate and print the result\nprint(minimal_jumps(n, d, s))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_counterexample(n):\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\nn = int(input())\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all_coins(n):\n    house_cost = 1234567\n    car_cost = 123456\n    computer_cost = 1234\n\n    for a in range(n // house_cost + 1):\n        for b in range((n - a * house_cost) // car_cost + 1):\n            remaining = n - a * house_cost - b * car_cost\n            if remaining % computer_cost == 0:\n                return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input().strip())\n\n# Print the result\nprint(can_spend_all_coins(n))"}
{"solution": "def check_intersection(n, x1, x2, lines):\n    # Calculate the y-values at x1 and x2 for each line\n    y_values_at_x1 = [(k * x1 + b, i) for i, (k, b) in enumerate(lines)]\n    y_values_at_x2 = [(k * x2 + b, i) for i, (k, b) in enumerate(lines)]\n    \n    # Sort the y-values at x1 and x2\n    y_values_at_x1.sort()\n    y_values_at_x2.sort()\n    \n    # Check if the order of lines changes between x1 and x2\n    for i in range(n - 1):\n        if y_values_at_x1[i][1] != y_values_at_x2[i][1]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx1 = int(data[1])\nx2 = int(data[2])\nlines = [(int(data[3 + 2 * i]), int(data[4 + 2 * i])) for i in range(n)]\n\n# Check for intersection\nresult = check_intersection(n, x1, x2, lines)\nprint(result)"}
{"solution": "def count_weights(n):\n    weights = set()\n    i = 1\n    while i * (i + 1) // 2 <= n:\n        if (n - i * (i + 1) // 2) % i == 0:\n            weights.add(i)\n        i += 1\n    return len(weights)\n\nn = int(input())\nprint(count_weights(n))"}
{"solution": "def find_good_apartments(n, k):\n    if k == 0:\n        min_good = 0\n        max_good = 0\n    elif k == n:\n        min_good = 0\n        max_good = 0\n    else:\n        min_good = 1\n        max_good = min(2 * k, n - k)\n    \n    print(min_good, max_good)\n\n# Read input\nn, k = map(int, input().split())\n\n# Find and print the result\nfind_good_apartments(n, k)"}
{"solution": "import math\n\ndef max_games(n):\n    return int(math.log2(n))\n\nn = int(input())\nprint(max_games(n))"}
{"solution": "def max_vk_occurrences(s):\n    def count_vk(s):\n        return sum(1 for i in range(len(s) - 1) if s[i:i+2] == \"VK\")\n    \n    max_count = count_vk(s)\n    \n    for i in range(len(s)):\n        if s[i] == 'V':\n            new_s = s[:i] + 'K' + s[i+1:]\n        else:\n            new_s = s[:i] + 'V' + s[i+1:]\n        \n        max_count = max(max_count, count_vk(new_s))\n    \n    return max_count\n\n# Read input\ns = input().strip()\n\n# Compute and print the result\nprint(max_vk_occurrences(s))"}
{"solution": "import math\n\ndef min_segments(n):\n    side_length = math.isqrt(n)\n    if side_length * side_length == n:\n        return 2 * side_length\n    elif side_length * (side_length + 1) >= n:\n        return 2 * side_length + 1\n    else:\n        return 2 * side_length + 2\n\nn = int(input())\nprint(min_segments(n))"}
{"solution": "a, b = map(int, input().split())\nyears = 0\n\nwhile a <= b:\n    a *= 3\n    b *= 2\n    years += 1\n\nprint(years)"}
{"solution": "def count_visited_nodes(h, n):\n    visited = set()\n    current_node = 1\n    command_index = 0\n    consecutive_skips = 0\n    nodes_visited = 0\n\n    def get_left_child(node):\n        return node * 2\n\n    def get_right_child(node):\n        return node * 2 + 1\n\n    def get_parent(node):\n        return node // 2\n\n    while True:\n        if current_node in visited:\n            consecutive_skips += 1\n            if consecutive_skips == 2:\n                current_node = get_parent(current_node)\n                consecutive_skips = 0\n            command_index += 1\n            continue\n\n        visited.add(current_node)\n        nodes_visited += 1\n\n        if current_node == n:\n            break\n\n        if command_index % 2 == 0:\n            next_node = get_left_child(current_node)\n        else:\n            next_node = get_right_child(current_node)\n\n        if next_node in visited:\n            consecutive_skips += 1\n            if consecutive_skips == 2:\n                current_node = get_parent(current_node)\n                consecutive_skips = 0\n        else:\n            current_node = next_node\n            consecutive_skips = 0\n\n        command_index += 1\n\n    return nodes_visited - 1\n\n# Read input\nh, n = map(int, input().split())\n\n# Calculate and print the result\nprint(count_visited_nodes(h, n))"}
{"solution": "def count_squares(n, m):\n    total_squares = 0\n    for k in range(1, min(n, m) + 1):\n        total_squares += (n - k + 1) * (m - k + 1)\n    return total_squares\n\ndef find_tables(x):\n    tables = []\n    for n in range(1, int(x**0.5) + 1):\n        for m in range(n, int(x**0.5) + 1):\n            if count_squares(n, m) == x:\n                tables.append((n, m))\n                if n != m:\n                    tables.append((m, n))\n    tables.sort()\n    return tables\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    x = int(input().strip())\n    tables = find_tables(x)\n    print(len(tables))\n    for n, m in tables:\n        print(n, m)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_leap_year(year):\n    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\ndef check_consecutive_months(n, days):\n    # Days in each month for a non-leap year\n    non_leap_year = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    # Days in each month for a leap year\n    leap_year = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    # Create a list of all possible month sequences (non-leap and leap years)\n    all_months = non_leap_year + non_leap_year + leap_year + leap_year\n    \n    # Check if the sequence exists in the combined list\n    for i in range(len(all_months) - n + 1):\n        if all_months[i:i+n] == days:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\ndays = list(map(int, input().split()))\n\n# Check and print the result\nprint(check_consecutive_months(n, days))"}
{"solution": "def find_sequence(n):\n    if n == 2:\n        return \"NO\"\n    \n    fractions = []\n    for b in range(2, n):\n        if n % b == 0:\n            a = 1\n            fractions.append((a, b))\n            if sum(a / b for a, b in fractions) >= 1 - 1 / n:\n                break\n    \n    if sum(a / b for a, b in fractions) == 1 - 1 / n:\n        result = [\"YES\", str(len(fractions))]\n        for a, b in fractions:\n            result.append(f\"{a} {b}\")\n        return \"\\n\".join(result)\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input().strip())\n\n# Find and print the sequence\nprint(find_sequence(n))"}
{"solution": "def min_unattractiveness(n, a, b, heights):\n    # Initialize DP table\n    dp = [[float('inf')] * (a + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    # Iterate over each board\n    for i in range(1, n + 1):\n        for red_area in range(a + 1):\n            green_area = sum(heights[:i]) - red_area\n            if green_area > b or green_area < 0:\n                continue\n\n            # Paint current board red\n            if red_area >= heights[i - 1]:\n                dp[i][red_area] = min(dp[i][red_area], dp[i - 1][red_area - heights[i - 1]])\n\n            # Paint current board green\n            if green_area >= heights[i - 1]:\n                dp[i][red_area] = min(dp[i][red_area], dp[i - 1][red_area] + heights[i - 1])\n\n    # Find the minimum unattractiveness value\n    result = min(dp[n])\n    return result if result != float('inf') else -1\n\n# Read input\nn = int(input())\na, b = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_unattractiveness(n, a, b, heights))"}
{"solution": "def find_triangle(n, m, k):\n    area = n * m\n    if area % k != 0:\n        print(\"NO\")\n        return\n    \n    target_area = area // k\n    \n    if k % 2 == 0:\n        x1, y1 = 0, 0\n        x2, y2 = n, 0\n        x3, y3 = 0, m\n        print(\"YES\")\n        print(x1, y1)\n        print(x2, y2)\n        print(x3, y3)\n    else:\n        if 2 * n <= n * m // k:\n            x1, y1 = 0, 0\n            x2, y2 = 2 * n, 0\n            x3, y3 = 0, m\n            print(\"YES\")\n            print(x1, y1)\n            print(x2, y2)\n            print(x3, y3)\n        elif 2 * m <= n * m // k:\n            x1, y1 = 0, 0\n            x2, y2 = n, 0\n            x3, y3 = 0, 2 * m\n            print(\"YES\")\n            print(x1, y1)\n            print(x2, y2)\n            print(x3, y3)\n        else:\n            print(\"NO\")\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Find and print the triangle\nfind_triangle(n, m, k)"}
{"solution": "def sasha_wins(n, k):\n    # Calculate the number of moves each player can make\n    sasha_moves = (n + k - 1) // k // 2\n    lena_moves = (n + k - 1) // k - sasha_moves\n    \n    # Sasha wins if he makes strictly more moves than Lena\n    if sasha_moves > lena_moves:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\n\n# Determine if Sasha wins and print the result\nprint(sasha_wins(n, k))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nchest = sum(a[i] for i in range(0, n, 3))\nbiceps = sum(a[i] for i in range(1, n, 3))\nback = sum(a[i] for i in range(2, n, 3))\n\nif chest > biceps and chest > back:\n    print(\"chest\")\nelif biceps > chest and biceps > back:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "n = int(input())\ngrades = list(map(int, input().split()))\n\ncurrent_sum = sum(grades)\ntarget_sum = 5 * n\ngrades.sort()\n\nredo_count = 0\nfor grade in grades:\n    if current_sum >= target_sum - 0.5:\n        break\n    current_sum += (5 - grade)\n    redo_count += 1\n\nprint(redo_count)"}
{"solution": "def find_array(u, v):\n    if u > v or (v - u) % 2 != 0:\n        print(-1)\n        return\n    \n    if u == v:\n        if u == 0:\n            print(0)\n        else:\n            print(1)\n            print(u)\n        return\n    \n    x = (v - u) // 2\n    if (u & x) == 0:\n        print(2)\n        print(u + x, x)\n    else:\n        print(3)\n        print(u, (v - u) // 2, (v - u) // 2)\n\n# Read input\nu, v = map(int, input().split())\n\n# Find and print the array\nfind_array(u, v)"}
{"solution": "def min_digits_of_1(n):\n    count = 0\n    while n > 0:\n        # Find the largest number consisting of only 1s that is less than or equal to n\n        num_of_1s = 0\n        current = 0\n        while current <= n:\n            num_of_1s += 1\n            current = int('1' * num_of_1s)\n        \n        # Subtract the largest number consisting of only 1s from n\n        n -= int('1' * (num_of_1s - 1))\n        count += num_of_1s - 1\n    \n    return count\n\n# Read input\nn = int(input().strip())\n\n# Print the result\nprint(min_digits_of_1(n))"}
{"solution": "def can_reach_treasure(x1, y1, x2, y2, x, y):\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    \n    if dx % x == 0 and dy % y == 0:\n        steps_x = dx // x\n        steps_y = dy // y\n        if (steps_x % 2) == (steps_y % 2):\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\n# Print the result\nprint(can_reach_treasure(x1, y1, x2, y2, x, y))"}
{"solution": "from itertools import permutations\n\ndef count_possible_bus_numbers(n):\n    n_str = str(n)\n    unique_numbers = set()\n    \n    for i in range(1, len(n_str) + 1):\n        for perm in permutations(n_str, i):\n            if perm[0] != '0':\n                unique_numbers.add(int(''.join(perm)))\n    \n    return len(unique_numbers)\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the result\nprint(count_possible_bus_numbers(n))"}
{"solution": "# Read input values\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\n# Calculate the maximum possible cost\nmax_cost = 0\n\n# Try to maximize the number of suits of the first type\nif e > f:\n    suits_first_type = min(a, d)\n    max_cost += suits_first_type * e\n    d -= suits_first_type\n    suits_second_type = min(b, c, d)\n    max_cost += suits_second_type * f\nelse:\n    suits_second_type = min(b, c, d)\n    max_cost += suits_second_type * f\n    d -= suits_second_type\n    suits_first_type = min(a, d)\n    max_cost += suits_first_type * e\n\n# Print the result\nprint(max_cost)"}
{"solution": "def mod_exp(base, exp, mod):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return result\n\ndef solve(a, b, p, x):\n    count = 0\n    inv_a = mod_exp(a, p-2, p)\n    for n in range(1, p):\n        an_mod_p = mod_exp(a, n, p)\n        if (n * an_mod_p) % p == b:\n            max_n = (x - n) // p\n            count += max_n + 1\n    print(count)\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    a = int(data[0])\n    b = int(data[1])\n    p = int(data[2])\n    x = int(data[3])\n    solve(a, b, p, x)"}
{"solution": "def max_sum_of_favorite_integers(k_2, k_3, k_5, k_6):\n    # Calculate the number of 256 we can form\n    count_256 = min(k_2, k_5, k_6)\n    \n    # Update the remaining count of 2s after forming 256\n    k_2 -= count_256\n    \n    # Calculate the number of 32 we can form with the remaining 2s\n    count_32 = min(k_2, k_3)\n    \n    # Calculate the total sum\n    total_sum = count_256 * 256 + count_32 * 32\n    \n    return total_sum\n\n# Read input\nk_2, k_3, k_5, k_6 = map(int, input().split())\n\n# Get the result\nresult = max_sum_of_favorite_integers(k_2, k_3, k_5, k_6)\n\n# Print the result\nprint(result)"}
{"solution": "def is_happy(n, x, y, c, t):\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if abs(i - x) + abs(j - y) <= t:\n                count += 1\n                if count >= c:\n                    return True\n    return count >= c\n\ndef min_seconds_to_happiness(n, x, y, c):\n    left, right = 0, 2 * n\n    while left < right:\n        mid = (left + right) // 2\n        if is_happy(n, x, y, c, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Read input\nn, x, y, c = map(int, input().strip().split())\n\n# Calculate and print the result\nprint(min_seconds_to_happiness(n, x, y, c))"}
{"solution": "def max_xor(l, r):\n    xor = l ^ r\n    significant_bit = 1\n    while xor > 0:\n        significant_bit <<= 1\n        xor >>= 1\n    return significant_bit - 1\n\n# Read input\nl, r = map(int, input().split())\n\n# Calculate and print the result\nprint(max_xor(l, r))"}
{"solution": "def min_height(n, k):\n    # The minimum height can be calculated by solving the equation:\n    # h * n >= k\n    # where h is the minimum height and n is the number of odd points.\n    # Rearranging, we get:\n    # h >= k / n\n    # Since h must be an integer, we take the ceiling of k / n.\n    \n    # Using integer arithmetic to avoid floating point precision issues\n    if k % n == 0:\n        return k // n\n    else:\n        return k // n + 1\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the minimum possible height\nprint(min_height(n, k))"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    stairs_time = abs(x - y) * t1\n    elevator_time = abs(z - x) * t2 + t3 + t3 + abs(x - y) * t2 + t3\n    if elevator_time <= stairs_time:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nx, y, z, t1, t2, t3 = map(int, input().split())\n\n# Determine whether to use the elevator or stairs\nresult = should_use_elevator(x, y, z, t1, t2, t3)\n\n# Print the result\nprint(result)"}
{"solution": "def find_best_a(n, m):\n    if m == 1:\n        return 2\n    elif m == n:\n        return n - 1\n    else:\n        return m - 1 if m - 1 >= n - m else m + 1\n\n# Read input\nn, m = map(int, input().split())\n\n# Find and print the best value for Andrew\nprint(find_best_a(n, m))"}
{"solution": "def count_pairs_at_university(n, pairs):\n    # Find the first and last pair with a class\n    first_class = -1\n    last_class = -1\n    for i in range(n):\n        if pairs[i] == 1:\n            if first_class == -1:\n                first_class = i\n            last_class = i\n\n    # If there are no classes at all\n    if first_class == -1:\n        return 0\n\n    # Count the number of pairs Alena stays at the university\n    stay_count = 0\n    i = first_class\n    while i <= last_class:\n        if pairs[i] == 1:\n            stay_count += 1\n            i += 1\n        else:\n            # Check for breaks of at least two free pairs in a row\n            j = i\n            while j <= last_class and pairs[j] == 0:\n                j += 1\n            if j - i >= 2:\n                i = j\n            else:\n                stay_count += (j - i)\n                i = j\n\n    return stay_count\n\n# Read input\nn = int(input())\npairs = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_pairs_at_university(n, pairs))"}
{"solution": "def min_days_to_give_candies(n, k, candies):\n    total_given = 0\n    saved_candies = 0\n\n    for day in range(n):\n        saved_candies += candies[day]\n        give_today = min(saved_candies, 8)\n        total_given += give_today\n        saved_candies -= give_today\n\n        if total_given >= k:\n            return day + 1\n\n    return -1\n\n# Read input\nn, k = map(int, input().split())\ncandies = list(map(int, input().split()))\n\n# Get the result\nresult = min_days_to_give_candies(n, k, candies)\n\n# Print the result\nprint(result)"}
{"solution": "def min_additional_walks(n, k, a):\n    b = a[:]\n    additional_walks = 0\n\n    for i in range(1, n):\n        if b[i - 1] + b[i] < k:\n            needed_walks = k - (b[i - 1] + b[i])\n            b[i] += needed_walks\n            additional_walks += needed_walks\n\n    return additional_walks, b\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nadditional_walks, b = min_additional_walks(n, k, a)\n\n# Print the result\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "def number_of_cells(n):\n    return 2 * n * (n - 1) + 1\n\nn = int(input())\nprint(number_of_cells(n))"}
{"solution": "def is_pangram(n, s):\n    alphabet_set = set('abcdefghijklmnopqrstuvwxyz')\n    s = s.lower()\n    s_set = set(s)\n    if alphabet_set.issubset(s_set):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input()\n\n# Check if the string is a pangram\nresult = is_pangram(n, s)\nprint(result)"}
{"solution": "from datetime import datetime, timedelta\n\n# Read input\ncurrent_time = input().strip()\nminutes_to_add = int(input().strip())\n\n# Parse the current time\ncurrent_time_obj = datetime.strptime(current_time, \"%H:%M\")\n\n# Add the minutes\nnew_time_obj = current_time_obj + timedelta(minutes=minutes_to_add)\n\n# Format the new time\nnew_time_str = new_time_obj.strftime(\"%H:%M\")\n\n# Print the result\nprint(new_time_str)"}
{"solution": "n, m = map(int, input().split())\na = [input().strip() for _ in range(n)]\n\n# Count how many switches turn on each lamp\nlamp_count = [0] * m\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == '1':\n            lamp_count[j] += 1\n\n# Check if there is a switch that can be ignored\nfor i in range(n):\n    can_ignore = True\n    for j in range(m):\n        if a[i][j] == '1' and lamp_count[j] == 1:\n            can_ignore = False\n            break\n    if can_ignore:\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\ndominoes = [tuple(map(int, input().split())) for _ in range(n)]\n\nupper_sum = sum(x for x, y in dominoes)\nlower_sum = sum(y for x, y in dominoes)\n\nif upper_sum % 2 == 0 and lower_sum % 2 == 0:\n    print(0)\nelif upper_sum % 2 == 1 and lower_sum % 2 == 1:\n    for x, y in dominoes:\n        if (x % 2) != (y % 2):\n            print(1)\n            break\n    else:\n        print(-1)\nelse:\n    print(-1)"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef remaining_cloth_prime(t, test_cases):\n    results = []\n    for a, b in test_cases:\n        area = a * a - b * b\n        if is_prime(area):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    return results\n\n# Read input\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = remaining_cloth_prime(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)"}
{"solution": "def can_remove_point(points):\n    left_count = sum(1 for x, y in points if x < 0)\n    right_count = len(points) - left_count\n    return left_count <= 1 or right_count <= 1\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\nif can_remove_point(points):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "import math\n\ndef gcd_of_factorials(A, B):\n    return math.factorial(min(A, B))\n\n# Read input\nA, B = map(int, input().split())\n\n# Calculate and print the result\nprint(gcd_of_factorials(A, B))"}
{"solution": "def is_composite(x):\n    if x <= 3:\n        return False\n    if x % 2 == 0 or x % 3 == 0:\n        return True\n    i = 5\n    while i * i <= x:\n        if x % i == 0 or x % (i + 2) == 0:\n            return True\n        i += 6\n    return False\n\ndef find_composites(n):\n    a = 4 + n\n    b = 4\n    while not (is_composite(a) and is_composite(b)):\n        a += 1\n        b += 1\n    return a, b\n\nn = int(input().strip())\na, b = find_composites(n)\nprint(a, b)"}
{"solution": "import sys\nimport heapq\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    P = int(data[2])\n    \n    edges = []\n    index = 3\n    for _ in range(M):\n        A = int(data[index]) - 1\n        B = int(data[index + 1]) - 1\n        C = int(data[index + 2])\n        edges.append((A, B, C))\n        index += 3\n    \n    # Bellman-Ford to find the maximum coins we can collect\n    dist = [-float('inf')] * N\n    dist[0] = 0\n    \n    for _ in range(N - 1):\n        for u, v, c in edges:\n            if dist[u] != -float('inf') and dist[u] + c > dist[v]:\n                dist[v] = dist[u] + c\n    \n    # Check for positive cycles reachable from vertex 1\n    reachable = [False] * N\n    reachable[0] = True\n    for _ in range(N):\n        for u, v, c in edges:\n            if reachable[u]:\n                reachable[v] = True\n    \n    for _ in range(N):\n        for u, v, c in edges:\n            if dist[u] != -float('inf') and dist[u] + c > dist[v]:\n                if reachable[v]:\n                    print(-1)\n                    return\n    \n    max_coins = dist[N - 1]\n    if max_coins == -float('inf'):\n        print(-1)\n    else:\n        max_score = max_coins - (N - 1) * P\n        print(max_score)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef min_cost_palindrome(N, strings, costs):\n    from itertools import combinations_with_replacement\n\n    min_cost = float('inf')\n    found_palindrome = False\n\n    for r in range(1, N + 1):\n        for combo in combinations_with_replacement(range(N), r):\n            combined_string = ''.join(strings[i] for i in combo)\n            if is_palindrome(combined_string):\n                found_palindrome = True\n                cost = sum(costs[i] for i in combo)\n                min_cost = min(min_cost, cost)\n\n    return min_cost if found_palindrome else -1\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN = int(data[0])\nstrings = []\ncosts = []\n\nfor i in range(1, N + 1):\n    s, c = data[i].split()\n    strings.append(s)\n    costs.append(int(c))\n\n# Find and print the minimum cost\nprint(min_cost_palindrome(N, strings, costs))"}
{"solution": "def largest_xor_sum(n, k):\n    # If k is equal to or greater than n, the largest xor-sum is the xor of all numbers from 1 to n\n    if k >= n:\n        # The largest number with all bits set that is less than or equal to n\n        highest_bit = 1\n        while highest_bit <= n:\n            highest_bit <<= 1\n        return highest_bit - 1\n    else:\n        # If k < n, the largest xor-sum is the xor of the first k numbers\n        highest_bit = 1\n        while highest_bit <= k:\n            highest_bit <<= 1\n        return highest_bit - 1\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(largest_xor_sum(n, k))"}
{"solution": "def min_shorter_side(n, points):\n    max_x = max(point[0] for point in points)\n    max_y = max(point[1] for point in points)\n    return max(max_x, max_y) * 2\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    points = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n    \n    result = min_shorter_side(n, points)\n    print(result)"}
{"solution": "def max_nineteens(s):\n    from collections import Counter\n    \n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # The word \"nineteen\" has the following character counts:\n    # n: 3, i: 1, e: 3, t: 1\n    # We need to find the limiting factor for the number of \"nineteen\"s we can form\n    n_count = char_count['n'] // 3\n    i_count = char_count['i'] // 1\n    e_count = char_count['e'] // 3\n    t_count = char_count['t'] // 1\n    \n    # The maximum number of \"nineteen\"s we can form is the minimum of these counts\n    return min(n_count, i_count, e_count, t_count)\n\n# Read input\ns = input().strip()\n\n# Print the result\nprint(max_nineteens(s))"}
{"solution": "def highest_suitable_branch(p, y):\n    def is_safe(branch):\n        for i in range(2, min(p + 1, int(branch**0.5) + 1)):\n            if branch % i == 0:\n                return False\n        return True\n\n    for branch in range(y, p, -1):\n        if is_safe(branch):\n            return branch\n    return -1\n\n# Read input\np, y = map(int, input().strip().split())\n\n# Find and print the highest suitable branch\nprint(highest_suitable_branch(p, y))"}
{"solution": "# Read input values\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize the minimum distance to a large number\nmin_distance = float('inf')\n\n# Check houses to the left of the girl's house\nfor i in range(m - 2, -1, -1):\n    if a[i] != 0 and a[i] <= k:\n        min_distance = min(min_distance, (m - 1 - i) * 10)\n        break\n\n# Check houses to the right of the girl's house\nfor i in range(m, n):\n    if a[i] != 0 and a[i] <= k:\n        min_distance = min(min_distance, (i - (m - 1)) * 10)\n        break\n\n# Print the minimum distance\nprint(min_distance)"}
{"solution": "def can_transform(A, B, n, m):\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] != B[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    A = []\n    B = []\n    \n    index = 2\n    for i in range(n):\n        A.append([int(data[index + j]) for j in range(m)])\n        index += m\n    \n    for i in range(n):\n        B.append([int(data[index + j]) for j in range(m)])\n        index += m\n    \n    print(can_transform(A, B, n, m))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def longest_uncommon_subsequence(a, b):\n    if a == b:\n        return -1\n    else:\n        return max(len(a), len(b))\n\n# Read input\na = input().strip()\nb = input().strip()\n\n# Get the result\nresult = longest_uncommon_subsequence(a, b)\n\n# Print the result\nprint(result)"}
{"solution": "def find_first_common_scream(a, b, c, d):\n    rick_screams = set()\n    time = b\n    while time <= 10000:  # Arbitrary large number to avoid infinite loop\n        rick_screams.add(time)\n        time += a\n\n    time = d\n    while time <= 10000:\n        if time in rick_screams:\n            return time\n        time += c\n\n    return -1\n\nif __name__ == \"__main__\":\n    a, b = map(int, input().split())\n    c, d = map(int, input().split())\n    result = find_first_common_scream(a, b, c, d)\n    print(result)"}
{"solution": "def split_into_three(n):\n    if n % 3 == 0:\n        return 1, 1, n - 2\n    elif n % 3 == 1:\n        return 1, 2, n - 3\n    else:\n        return 1, 1, n - 2\n\nn = int(input())\na, b, c = split_into_three(n)\nprint(a, b, c)"}
{"solution": "def count_valid_squares(n, a, b, c, d):\n    count = 0\n    for x in range(1, n + 1):\n        for y in range(1, n + 1):\n            if a + b + x + y == b + c + x + y == c + d + x + y == d + a + x + y:\n                count += 1\n    return count\n\n# Read input\nn, a, b, c, d = map(int, input().split())\n\n# Calculate and print the result\nprint(count_valid_squares(n, a, b, c, d))"}
{"solution": "# Read input values\nw, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\n# Simulate the snowball rolling down the mountain\nfor i in range(h, 0, -1):\n    w += i  # Snowball's weight increases by the current height\n    if i == d1:\n        w -= u1  # Snowball hits the first stone\n    elif i == d2:\n        w -= u2  # Snowball hits the second stone\n    if w < 0:\n        w = 0  # Snowball's weight cannot be negative\n\n# Output the final weight of the snowball\nprint(w)"}
{"solution": "def find_passing_rate(m, scores, x, y):\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + scores[i - 1]\n\n    for k in range(1, m + 1):\n        beginners = prefix_sum[k - 1]\n        intermediates = prefix_sum[m] - prefix_sum[k - 1]\n        if x <= beginners <= y and x <= intermediates <= y:\n            return k\n    return 0\n\n# Read input\nm = int(input())\nscores = list(map(int, input().split()))\nx, y = map(int, input().split())\n\n# Find and print the passing rate\nprint(find_passing_rate(m, scores, x, y))"}
{"solution": "def min_coins(n, k, A, B):\n    coins = 0\n    while n > 1:\n        if k == 1:\n            coins += (n - 1) * A\n            break\n        if n % k == 0:\n            cost_divide = B\n            cost_subtract = (n - n // k) * A\n            if cost_divide < cost_subtract:\n                coins += cost_divide\n                n //= k\n            else:\n                coins += cost_subtract\n                n -= (n - n // k)\n        else:\n            remainder = n % k\n            if remainder == 0:\n                remainder = k\n            if n - remainder > 0:\n                coins += remainder * A\n                n -= remainder\n            else:\n                coins += (n - 1) * A\n                n = 1\n    return coins\n\n# Read input\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\n# Calculate and print the result\nprint(min_coins(n, k, A, B))"}
{"solution": "import math\nfrom collections import deque\n\ndef min_operations(n):\n    visited = set()\n    queue = deque([(n, 0)])\n    \n    while queue:\n        current, steps = queue.popleft()\n        \n        if current == 1:\n            return (1, steps)\n        \n        if current not in visited:\n            visited.add(current)\n            \n            # Try sqrt operation if possible\n            sqrt_val = int(math.isqrt(current))\n            if sqrt_val * sqrt_val == current:\n                queue.append((sqrt_val, steps + 1))\n            \n            # Try multiplication operations\n            for x in range(2, int(math.sqrt(current)) + 1):\n                new_val = current * x\n                if new_val not in visited:\n                    queue.append((new_val, steps + 1))\n    \n    return (n, 0)\n\n# Read input\nn = int(input().strip())\n\n# Get the result\nresult = min_operations(n)\n\n# Print the result\nprint(result[0], result[1])"}
{"solution": "def max_score(N, K, R, S, P, T):\n    # Initialize the dp array to store the maximum score up to each round\n    dp = [[0] * 3 for _ in range(N)]\n    \n    # Mapping for the hands\n    hand_to_index = {'r': 0, 's': 1, 'p': 2}\n    index_to_hand = ['r', 's', 'p']\n    points = [P, R, S]  # Points for winning with Paper, Rock, Scissors respectively\n    \n    for i in range(N):\n        for j in range(3):\n            if i < K:\n                if index_to_hand[j] == 'r' and T[i] == 's':\n                    dp[i][j] = points[j]\n                elif index_to_hand[j] == 's' and T[i] == 'p':\n                    dp[i][j] = points[j]\n                elif index_to_hand[j] == 'p' and T[i] == 'r':\n                    dp[i][j] = points[j]\n            else:\n                max_prev = 0\n                for l in range(3):\n                    if l != j:\n                        max_prev = max(max_prev, dp[i-K][l])\n                if index_to_hand[j] == 'r' and T[i] == 's':\n                    dp[i][j] = max_prev + points[j]\n                elif index_to_hand[j] == 's' and T[i] == 'p':\n                    dp[i][j] = max_prev + points[j]\n                elif index_to_hand[j] == 'p' and T[i] == 'r':\n                    dp[i][j] = max_prev + points[j]\n                else:\n                    dp[i][j] = max_prev\n    \n    # The answer is the maximum score we can get after all rounds\n    print(max(dp[N-1]))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nR = int(data[2])\nS = int(data[3])\nP = int(data[4])\nT = data[5]\n\nmax_score(N, K, R, S, P, T)"}
{"solution": "def max_good_string_length(a, b, c):\n    # The maximum length of the good string is determined by the number of 'ab' pairs we can use\n    # and the remaining 'a' and 'b' characters we can add to the string.\n    return 2 * c + 2 * min(a, b) + (1 if a != b else 0)\n\n# Read input\na, b, c = map(int, input().strip().split())\n\n# Calculate and print the result\nprint(max_good_string_length(a, b, c))"}
{"solution": "def find_marks(n, k, p, x, y, marks):\n    remaining_tests = n - k\n    current_sum = sum(marks)\n    marks_needed = []\n\n    # Count how many marks are less than y\n    less_than_y = sum(1 for mark in marks if mark < y)\n    more_than_y = k - less_than_y\n\n    # We need at least (n // 2 + 1) marks to be >= y to have y as the median\n    required_more_than_y = (n // 2 + 1) - more_than_y\n\n    if required_more_than_y > remaining_tests:\n        return -1\n\n    # Add the required number of y marks\n    for _ in range(required_more_than_y):\n        marks_needed.append(y)\n        current_sum += y\n        remaining_tests -= 1\n\n    # Fill the rest with 1s to minimize the sum\n    for _ in range(remaining_tests):\n        marks_needed.append(1)\n        current_sum += 1\n\n    if current_sum > x:\n        return -1\n\n    return marks_needed\n\n# Read input\nn, k, p, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Find the marks needed\nresult = find_marks(n, k, p, x, y, marks)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def is_berlanese(s):\n    vowels = set(\"aouie\")\n    n = len(s)\n    \n    for i in range(n):\n        if s[i] not in vowels and s[i] != 'n':\n            if i == n - 1 or s[i + 1] not in vowels:\n                return \"NO\"\n    return \"YES\"\n\n# Read input\ns = input().strip()\n\n# Check if the word is Berlanese\nresult = is_berlanese(s)\n\n# Print the result\nprint(result)"}
{"solution": "def max_dominoes(n, m, edges):\n    from itertools import permutations\n\n    if m == 0:\n        return 0\n\n    def is_valid_assignment(assignment):\n        vertex_dots = {}\n        for (u, v), (a, b) in zip(edges, assignment):\n            if u not in vertex_dots:\n                vertex_dots[u] = a\n            elif vertex_dots[u] != a:\n                return False\n            if v not in vertex_dots:\n                vertex_dots[v] = b\n            elif vertex_dots[v] != b:\n                return False\n        return True\n\n    dominoes = [(a, b) for a in range(1, 7) for b in range(a, 7)]\n    max_dominoes_count = 0\n\n    for perm in permutations(dominoes, m):\n        if is_valid_assignment(perm):\n            max_dominoes_count = max(max_dominoes_count, m)\n\n    return max_dominoes_count\n\n# Input reading\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output the result\nprint(max_dominoes(n, m, edges))"}
{"solution": "def max_points(n, m, prices, auction_indices):\n    auction_prices = [prices[i - 1] for i in auction_indices]\n    regular_prices = [prices[i] for i in range(n) if i + 1 not in auction_indices]\n\n    auction_prices.sort(reverse=True)\n    regular_prices.sort(reverse=True)\n\n    total_points = 0\n    current_points = 0\n\n    for price in regular_prices:\n        total_points += price\n        current_points += price\n\n    for price in auction_prices:\n        if current_points > price:\n            total_points += current_points\n            current_points *= 2\n        else:\n            total_points += price\n            current_points += price\n\n    return total_points\n\n# Read input\nn, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauction_indices = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_points(n, m, prices, auction_indices))"}
{"solution": "def calculate_score(submission_times, wrong_submissions, successful_hacks, unsuccessful_hacks):\n    max_points = [500, 1000, 1500, 2000, 2500]\n    total_score = 0\n    \n    for i in range(5):\n        m = submission_times[i]\n        w = wrong_submissions[i]\n        x = max_points[i]\n        score = max(0.3 * x, (1 - m / 250) * x - 50 * w)\n        total_score += score\n    \n    total_score += 100 * successful_hacks\n    total_score -= 50 * unsuccessful_hacks\n    \n    return int(total_score)\n\n# Read input\nsubmission_times = list(map(int, input().split()))\nwrong_submissions = list(map(int, input().split()))\nsuccessful_hacks, unsuccessful_hacks = map(int, input().split())\n\n# Calculate and print the final score\nfinal_score = calculate_score(submission_times, wrong_submissions, successful_hacks, unsuccessful_hacks)\nprint(final_score)"}
{"solution": "MOD = 998244353\n\ndef count_valid_grids(n, m, L, R):\n    total_cells = n * m\n    if total_cells % 2 == 0:\n        total_grids = (R - L + 1) % MOD\n        total_grids = (total_grids * pow(R - L + 1, total_cells - 1, MOD)) % MOD\n    else:\n        total_grids = (R - L + 1) % MOD\n        total_grids = (total_grids * pow(R - L + 1, total_cells - 1, MOD)) % MOD\n    return total_grids\n\n# Read input\nn, m, L, R = map(int, input().split())\n\n# Calculate the result\nresult = count_valid_grids(n, m, L, R)\n\n# Print the result\nprint(result)"}
{"solution": "def is_increasing(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n    \n    # Check rows\n    for i in range(n):\n        for j in range(1, m):\n            if matrix[i][j] <= matrix[i][j-1]:\n                return False\n    \n    # Check columns\n    for j in range(m):\n        for i in range(1, n):\n            if matrix[i][j] <= matrix[i-1][j]:\n                return False\n    \n    return True\n\ndef solve(n, m, a, b):\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] > b[i][j]:\n                a[i][j], b[i][j] = b[i][j], a[i][j]\n    \n    if is_increasing(a) and is_increasing(b):\n        print(\"Possible\")\n    else:\n        print(\"Impossible\")\n\n# Read input\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nb = [list(map(int, input().split())) for _ in range(n)]\n\nsolve(n, m, a, b)"}
{"solution": "def max_length_string(n, a):\n    a.sort(reverse=True)\n    used = set()\n    max_length = 0\n\n    for count in a:\n        while count in used:\n            count -= 1\n        if count > 0:\n            used.add(count)\n            max_length += count\n\n    return max_length\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_length_string(n, a))"}
{"solution": "def min_problems_to_solve(n, k, difficulties):\n    difficulties.sort()\n    additional_problems = 0\n    current_max_difficulty = k\n\n    for difficulty in difficulties:\n        while current_max_difficulty < (difficulty + 1) // 2:\n            current_max_difficulty *= 2\n            additional_problems += 1\n        current_max_difficulty = max(current_max_difficulty, difficulty)\n\n    return additional_problems\n\n# Read input\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_problems_to_solve(n, k, difficulties))"}
{"solution": "def distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3):\n    # Start with the minimum required diplomas\n    first = min_1\n    second = min_2\n    third = min_3\n    \n    # Calculate the remaining diplomas to be distributed\n    remaining = n - (first + second + third)\n    \n    # Try to maximize the first degree diplomas\n    add_first = min(remaining, max_1 - first)\n    first += add_first\n    remaining -= add_first\n    \n    # Try to maximize the second degree diplomas\n    add_second = min(remaining, max_2 - second)\n    second += add_second\n    remaining -= add_second\n    \n    # The rest will go to the third degree diplomas\n    third += remaining\n    \n    return first, second, third\n\n# Read input\nn = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\n# Get the optimal distribution\nresult = distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3)\n\n# Print the result\nprint(result[0], result[1], result[2])"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    if a[0] == 0:\n        print(\"UP\")\n    elif a[0] == 15:\n        print(\"DOWN\")\n    else:\n        print(-1)\nelse:\n    if a[-1] == 0:\n        print(\"UP\")\n    elif a[-1] == 15:\n        print(\"DOWN\")\n    elif a[-1] > a[-2]:\n        print(\"UP\")\n    else:\n        print(\"DOWN\")"}
{"solution": "def can_transform(s, t):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    if len(s) != len(t):\n        return \"No\"\n    \n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels and char_t not in vowels) or (char_s not in vowels and char_t in vowels):\n            return \"No\"\n    \n    return \"Yes\"\n\ns = input().strip()\nt = input().strip()\n\nprint(can_transform(s, t))"}
{"solution": "def find_winner(board):\n    min_white_steps = float('inf')\n    min_black_steps = float('inf')\n\n    for col in range(8):\n        for row in range(8):\n            if board[row][col] == 'W':\n                steps = row\n                blocked = False\n                for r in range(row - 1, -1, -1):\n                    if board[r][col] != '.':\n                        blocked = True\n                        break\n                if not blocked:\n                    min_white_steps = min(min_white_steps, steps)\n            elif board[row][col] == 'B':\n                steps = 7 - row\n                blocked = False\n                for r in range(row + 1, 8):\n                    if board[r][col] != '.':\n                        blocked = True\n                        break\n                if not blocked:\n                    min_black_steps = min(min_black_steps, steps)\n\n    if min_white_steps <= min_black_steps:\n        return 'A'\n    else:\n        return 'B'\n\n# Read input\nboard = [input().strip() for _ in range(8)]\n\n# Determine the winner\nwinner = find_winner(board)\n\n# Print the result\nprint(winner)"}
{"solution": "def max_equal_length(n, a, m, b):\n    i, j = 0, 0\n    sum_a, sum_b = 0, 0\n    count = 0\n\n    while i < n and j < m:\n        if sum_a == sum_b:\n            count += 1\n            sum_a += a[i]\n            sum_b += b[j]\n            i += 1\n            j += 1\n        elif sum_a < sum_b:\n            sum_a += a[i]\n            i += 1\n        else:\n            sum_b += b[j]\n            j += 1\n\n    while i < n:\n        sum_a += a[i]\n        i += 1\n\n    while j < m:\n        sum_b += b[j]\n        j += 1\n\n    if sum_a == sum_b:\n        return count\n    else:\n        return -1\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nm = int(input())\nb = list(map(int, input().split()))\n\n# Get the result\nresult = max_equal_length(n, a, m, b)\n\n# Print the result\nprint(result)"}
{"solution": "def is_contest_problem(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    count = 0\n    for friend in friends:\n        count += problem_name.count(friend)\n    if count == 1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n# Read input\nproblem_name = input().strip()\nis_contest_problem(problem_name)"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef count_primes_in_range(a, b):\n    return sum(is_prime(i) for i in range(a, b + 1))\n\ndef find_min_l(a, b, k):\n    if k == 0:\n        return 1\n    primes = [0] * (b - a + 2)\n    for i in range(a, b + 1):\n        primes[i - a + 1] = primes[i - a] + (1 if is_prime(i) else 0)\n    \n    for l in range(1, b - a + 2):\n        for x in range(a, b - l + 2):\n            if primes[x - a + l] - primes[x - a] >= k:\n                return l\n    return -1\n\na, b, k = map(int, input().split())\nprint(find_min_l(a, b, k))"}
{"solution": "def min_x(a, h, w):\n    def check(n, m):\n        return (h - n * a) / (n + 1) >= 0 and (w - m * a) / (m + 1) >= 0\n\n    min_x = float('inf')\n    found = False\n\n    for n in range(1, h // a + 1):\n        for m in range(1, w // a + 1):\n            if check(n, m):\n                x1 = (h - n * a) / (n + 1)\n                x2 = (w - m * a) / (m + 1)\n                min_x = min(min_x, max(x1, x2))\n                found = True\n\n    if not found:\n        return -1\n    return min_x\n\na, h, w = map(int, input().split())\nresult = min_x(a, h, w)\nif result == -1:\n    print(result)\nelse:\n    print(f\"{result:.6f}\")"}
{"solution": "# Read the number of chapters\nn = int(input())\n\n# Read the chapters' page ranges\nchapters = []\nfor _ in range(n):\n    l, r = map(int, input().split())\n    chapters.append((l, r))\n\n# Read the marked page\nk = int(input())\n\n# Count the number of chapters not completely read\ncount = 0\nfor l, r in chapters:\n    if k <= r:\n        count += 1\n\n# Print the result\nprint(count)"}
{"solution": "def can_form_codeforces(banner):\n    target = \"CODEFORCES\"\n    n = len(banner)\n    m = len(target)\n    \n    if n < m:\n        return \"NO\"\n    \n    for i in range(m + 1):\n        if banner[:i] + banner[n - (m - i):] == target:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nbanner = input().strip()\n\n# Print output\nprint(can_form_codeforces(banner))"}
{"solution": "def min_triangulation_weight(n):\n    # Initialize the dp array\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    # Fill the dp array\n    for length in range(2, n):\n        for i in range(1, n - length + 1):\n            j = i + length\n            dp[i][j] = float('inf')\n            for k in range(i + 1, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + i * k * j)\n\n    return dp[1][n]\n\n# Read input\nn = int(input().strip())\n\n# Print the result\nprint(min_triangulation_weight(n))"}
{"solution": "def count_digits(n):\n    digits = 0\n    length = 1\n    start = 1\n    while start <= n:\n        end = min(n, start * 10 - 1)\n        digits += (end - start + 1) * length\n        length += 1\n        start *= 10\n    return digits\n\nn = int(input())\nprint(count_digits(n))"}
{"solution": "def find_winning_color(n, A, cars):\n    from collections import defaultdict\n\n    # Count occurrences of each color\n    color_count = defaultdict(int)\n    for color in cars:\n        color_count[color] += 1\n\n    # Initialize counters for Alice's color and other colors\n    cnt_A = 0\n    cnt_B = defaultdict(int)\n\n    # Iterate through the cars and update counts\n    for color in cars:\n        if color == A:\n            cnt_A += 1\n        else:\n            cnt_B[color] += 1\n\n        # Check if any color B has cnt_B >= cnt_A at every point\n        for color_B, count_B in cnt_B.items():\n            if count_B >= cnt_A:\n                return color_B\n\n    return -1\n\n# Read input\nn, A = map(int, input().split())\ncars = list(map(int, input().split()))\n\n# Find and print the winning color\nprint(find_winning_color(n, A, cars))"}
{"solution": "# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate the minimum length required\nmin_length = sum(a) + (n - 1)\n\n# Check if the minimum length matches the given length\nif min_length == x:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n, S = map(int, input().split())\n\n# The largest coin value we can use is n\nmax_coin_value = n\n\n# The minimum number of coins required to get sum S\nmin_coins = (S + max_coin_value - 1) // max_coin_value\n\nprint(min_coins)"}
{"solution": "def smallest_palindrome(s):\n    from collections import Counter\n\n    n = len(s)\n    count = Counter(s)\n    odd_count = sum(1 for v in count.values() if v % 2 != 0)\n\n    if odd_count > 1:\n        return \"Not possible to form a palindrome\"\n\n    half = []\n    middle = []\n    for char in sorted(count):\n        if count[char] % 2 != 0:\n            middle.append(char)\n        half.extend([char] * (count[char] // 2))\n\n    half_str = ''.join(half)\n    middle_str = ''.join(middle)\n    palindrome = half_str + middle_str + half_str[::-1]\n\n    return palindrome\n\ns = input().strip()\nprint(smallest_palindrome(s))"}
{"solution": "# Define the weights of the pieces\nweights = {\n    'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n    'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n}\n\n# Initialize the weights for white and black\nwhite_weight = 0\nblack_weight = 0\n\n# Read the board input\nboard = [input().strip() for _ in range(8)]\n\n# Calculate the weights\nfor row in board:\n    for piece in row:\n        if piece.isupper():\n            white_weight += weights.get(piece, 0)\n        elif piece.islower():\n            black_weight += weights.get(piece, 0)\n\n# Determine the result\nif white_weight > black_weight:\n    print(\"White\")\nelif black_weight > white_weight:\n    print(\"Black\")\nelse:\n    print(\"Draw\")"}
{"solution": "from collections import deque\n\ndef solve_sugoroku(N, M, S):\n    # Initialize the queue for BFS\n    queue = deque([(0, [])])\n    visited = [False] * (N + 1)\n    visited[0] = True\n    \n    while queue:\n        current_square, path = queue.popleft()\n        \n        # Try all possible moves from the current square\n        for move in range(1, M + 1):\n            next_square = current_square + move\n            \n            if next_square == N:\n                # If we reach the final square, return the path\n                return ' '.join(map(str, path + [move]))\n            \n            if next_square < N and not visited[next_square] and S[next_square] == '0':\n                visited[next_square] = True\n                queue.append((next_square, path + [move]))\n    \n    # If we exhaust the queue without finding a solution, return -1\n    return -1\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nS = data[2]\n\n# Solve the problem\nresult = solve_sugoroku(N, M, S)\nprint(result)"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    K = int(data[0])\n    X = int(data[1])\n    Y = int(data[2])\n    \n    if (X + Y) % 2 != K % 2:\n        print(-1)\n        return\n    \n    steps = []\n    current_x, current_y = 0, 0\n    \n    while abs(current_x - X) + abs(current_y - Y) > K:\n        if abs(X - current_x) > abs(Y - current_y):\n            if X > current_x:\n                current_x += K\n            else:\n                current_x -= K\n        else:\n            if Y > current_y:\n                current_y += K\n            else:\n                current_y -= K\n        steps.append((current_x, current_y))\n    \n    if current_x != X or current_y != Y:\n        dx = X - current_x\n        dy = Y - current_y\n        if abs(dx) + abs(dy) == K:\n            steps.append((X, Y))\n        else:\n            if abs(dx) > abs(dy):\n                if dx > 0:\n                    steps.append((current_x + K - abs(dy), current_y + dy))\n                else:\n                    steps.append((current_x - K + abs(dy), current_y + dy))\n            else:\n                if dy > 0:\n                    steps.append((current_x + dx, current_y + K - abs(dx)))\n                else:\n                    steps.append((current_x + dx, current_y - K + abs(dx)))\n            steps.append((X, Y))\n    \n    print(len(steps))\n    for step in steps:\n        print(step[0], step[1])\n\nsolve()"}
{"solution": "def find_min_n(m):\n    def count_ways(n):\n        count = 0\n        k = 2\n        while True:\n            a1 = 1\n            a2 = a1 * k\n            a3 = a2 * k\n            a4 = a3 * k\n            if a4 > n:\n                break\n            if a4 <= n:\n                count += 1\n            k += 1\n        return count\n\n    n = 1\n    while True:\n        if count_ways(n) == m:\n            return n\n        if count_ways(n) > m:\n            return -1\n        n += 1\n\nm = int(input().strip())\nprint(find_min_n(m))"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    \n    if d >= r1 + r2:\n        return 0.0\n    if d <= abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n    \n    r1_sq = r1 ** 2\n    r2_sq = r2 ** 2\n    \n    part1 = r1_sq * math.acos((d ** 2 + r1_sq - r2_sq) / (2 * d * r1))\n    part2 = r2_sq * math.acos((d ** 2 + r2_sq - r1_sq) / (2 * d * r2))\n    part3 = 0.5 * math.sqrt((-d + r1 + r2) * (d + r1 - r2) * (d - r1 + r2) * (d + r1 + r2))\n    \n    return part1 + part2 - part3\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\narea = circle_intersection_area(x1, y1, r1, x2, y2, r2)\nprint(f\"{area:.20f}\")"}
{"solution": "def minimize_n(v):\n    if v == 1:\n        return 1\n    for x in range(2, v):\n        if v % x != 0:\n            return 1\n    return v\n\nv = int(input())\nprint(minimize_n(v))"}
{"solution": "import sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\np = list(map(int, data[1:n]))\na = list(map(int, data[n:]))\n\n# Create adjacency list for the tree\nadj = defaultdict(list)\nfor i in range(2, n + 1):\n    adj[p[i - 2]].append(i)\n\n# Calculate the number of citizens in each subtree\nsubtree_citizens = [0] * (n + 1)\nfor i in range(1, n + 1):\n    subtree_citizens[i] = a[i - 1]\n\n# Post-order DFS to calculate subtree citizens\ndef dfs(node):\n    for child in adj[node]:\n        dfs(child)\n        subtree_citizens[node] += subtree_citizens[child]\n\ndfs(1)\n\n# Find the maximum citizens in any subtree\nmax_citizens = 0\nfor i in range(1, n + 1):\n    max_citizens = max(max_citizens, subtree_citizens[i])\n\nprint(max_citizens)"}
{"solution": "def count_possible_words(n, S, T):\n    count = 0\n    for i in range(n + 1):\n        for j in range(n + 1):\n            if i != j:\n                W1 = S[:i] + S[i:]\n                W2 = T[:j] + T[j:]\n                if W1 == W2:\n                    count += 1\n    return count\n\n# Read input\nn = int(input().strip())\nS = input().strip()\nT = input().strip()\n\n# Calculate and print the result\nprint(count_possible_words(n, S, T))"}
{"solution": "import sys\nfrom collections import deque, defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nstrengths = list(map(int, data[1:n+1]))\nedges = data[n+1:]\n\ngraph = defaultdict(list)\nfor i in range(0, len(edges), 2):\n    u = int(edges[i]) - 1\n    v = int(edges[i+1]) - 1\n    graph[u].append(v)\n    graph[v].append(u)\n\ndef bfs(start, max_strength):\n    queue = deque([start])\n    visited = [False] * n\n    visited[start] = True\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if not visited[neighbor] and strengths[neighbor] <= max_strength:\n                visited[neighbor] = True\n                queue.append(neighbor)\n    return all(visited)\n\nleft, right = min(strengths), max(strengths)\nanswer = right\n\nwhile left <= right:\n    mid = (left + right) // 2\n    if any(bfs(i, mid) for i in range(n) if strengths[i] <= mid):\n        answer = mid\n        right = mid - 1\n    else:\n        left = mid + 1\n\nprint(answer)"}
{"solution": "def max_groups(n, m):\n    if m == 0:\n        return 1\n    elif m == n:\n        return 0\n    else:\n        return min(m, n - m)\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(max_groups(n, m))"}
{"solution": "def minimum_shovels(k, r):\n    for i in range(1, 11):\n        if (k * i) % 10 == 0 or (k * i) % 10 == r:\n            return i\n\n# Read input\nk, r = map(int, input().split())\n\n# Get the result\nresult = minimum_shovels(k, r)\n\n# Print the result\nprint(result)"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                if i < min_row:\n                    min_row = i\n                if i > max_row:\n                    max_row = i\n                if j < min_col:\n                    min_col = j\n                if j > max_col:\n                    max_col = j\n    \n    # Check if the bounding box forms a solid rectangle\n    for i in range(min_row, max_row + 1):\n        for j in range(min_col, max_col + 1):\n            if grid[i][j] != 'X':\n                return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "def min_segments(points):\n    points.sort()\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n\n    if (x1 == x2 == x3) or (y1 == y2 == y3):\n        return 1\n    elif (x1 == x2 and y2 == y3) or (y1 == y2 and x2 == x3):\n        return 2\n    else:\n        return 3\n\npoints = [tuple(map(int, input().split())) for _ in range(3)]\nprint(min_segments(points))"}
{"solution": "def build_k_regular_graph(k):\n    if k == 1:\n        print(\"YES\")\n        print(\"2 1\")\n        print(\"1 2\")\n        return\n    \n    if k % 2 == 1:\n        print(\"NO\")\n        return\n    \n    n = k + 2\n    m = (k * n) // 2\n    print(\"YES\")\n    print(n, m)\n    \n    edges = []\n    for i in range(1, n - 1):\n        for j in range(i + 1, n - 1):\n            if len(edges) < m - 2:\n                edges.append((i, j))\n    \n    for i in range(1, k // 2 + 1):\n        edges.append((i, n - 1))\n        edges.append((i, n))\n    \n    for edge in edges:\n        print(edge[0], edge[1])\n\nk = int(input().strip())\nbuild_k_regular_graph(k)"}
{"solution": "def count_occurrences(s, t, l, r):\n    substring = s[l-1:r]\n    count = 0\n    t_len = len(t)\n    for i in range(len(substring) - t_len + 1):\n        if substring[i:i + t_len] == t:\n            count += 1\n    return count\n\n# Read input\nn, m, q = map(int, input().split())\ns = input().strip()\nt = input().strip()\n\n# Process each query\nfor _ in range(q):\n    l, r = map(int, input().split())\n    print(count_occurrences(s, t, l, r))"}
{"solution": "MOD = 1000000007\n\ndef count_paths(n, k, d):\n    dp = [[0 for _ in range(2)] for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if i - j >= 0:\n                if j < d:\n                    dp[i][0] = (dp[i][0] + dp[i - j][0]) % MOD\n                    dp[i][1] = (dp[i][1] + dp[i - j][1]) % MOD\n                else:\n                    dp[i][1] = (dp[i][1] + dp[i - j][0] + dp[i - j][1]) % MOD\n\n    return dp[n][1]\n\nn, k, d = map(int, input().split())\nprint(count_paths(n, k, d))"}
{"solution": "n = int(input())\nrow = input().strip()\n\ngroups = []\ncount = 0\n\nfor char in row:\n    if char == 'B':\n        count += 1\n    else:\n        if count > 0:\n            groups.append(count)\n            count = 0\n\nif count > 0:\n    groups.append(count)\n\nprint(len(groups))\nif groups:\n    print(' '.join(map(str, groups)))"}
{"solution": "def process_bracket_sequence(n, m, p, brackets, operations):\n    # Create a stack to find pairs of brackets\n    stack = []\n    pair = [-1] * n\n    for i in range(n):\n        if brackets[i] == '(':\n            stack.append(i)\n        else:\n            j = stack.pop()\n            pair[i] = j\n            pair[j] = i\n\n    # Convert to zero-based index\n    p -= 1\n\n    # Create a list to keep track of deleted positions\n    deleted = [False] * n\n\n    for op in operations:\n        if op == 'L':\n            p -= 1\n        elif op == 'R':\n            p += 1\n        elif op == 'D':\n            left = min(p, pair[p])\n            right = max(p, pair[p])\n            for i in range(left, right + 1):\n                deleted[i] = True\n            # Move cursor to the nearest non-deleted bracket\n            if right + 1 < n and not deleted[right + 1]:\n                p = right + 1\n            else:\n                p = left - 1\n                while p >= 0 and deleted[p]:\n                    p -= 1\n\n    # Build the resulting sequence\n    result = []\n    for i in range(n):\n        if not deleted[i]:\n            result.append(brackets[i])\n\n    return ''.join(result)\n\n# Read input\nn, m, p = map(int, input().split())\nbrackets = input().strip()\noperations = input().strip()\n\n# Process the bracket sequence\nresult = process_bracket_sequence(n, m, p, brackets, operations)\n\n# Print the result\nprint(result)"}
{"solution": "def find_possible_y(n, queries):\n    lower_bound = -2 * 10**9\n    upper_bound = 2 * 10**9\n\n    for query in queries:\n        sign, x, answer = query.split()\n        x = int(x)\n        if answer == 'Y':\n            if sign == '>':\n                lower_bound = max(lower_bound, x + 1)\n            elif sign == '>=':\n                lower_bound = max(lower_bound, x)\n            elif sign == '<':\n                upper_bound = min(upper_bound, x - 1)\n            elif sign == '<=':\n                upper_bound = min(upper_bound, x)\n        else:\n            if sign == '>':\n                upper_bound = min(upper_bound, x)\n            elif sign == '>=':\n                upper_bound = min(upper_bound, x - 1)\n            elif sign == '<':\n                lower_bound = max(lower_bound, x)\n            elif sign == '<=':\n                lower_bound = max(lower_bound, x + 1)\n\n    if lower_bound <= upper_bound:\n        print(lower_bound)\n    else:\n        print(\"Impossible\")\n\n# Read input\nn = int(input().strip())\nqueries = [input().strip() for _ in range(n)]\n\n# Find and print possible y\nfind_possible_y(n, queries)"}
{"solution": "import math\n\ndef count_periods(a, b):\n    n = a + b\n    count = 0\n    for k in range(1, n + 1):\n        if n % k == 0:\n            count += 1\n    return count\n\na, b = map(int, input().split())\nprint(count_periods(a, b))"}
{"solution": "def generate_names(n, k, notes):\n    names = []\n    for i in range(n):\n        names.append(chr(65 + i) + 'a')  # Generate unique names like Aa, Ba, Ca, etc.\n\n    for i in range(n - k + 1):\n        if notes[i] == \"NO\":\n            names[i + k - 1] = names[i]  # Make the last name in the group same as the first to ensure \"NO\"\n\n    return names\n\n# Read input\nn, k = map(int, input().split())\nnotes = input().split()\n\n# Generate and print names\nnames = generate_names(n, k, notes)\nprint(\" \".join(names))"}
{"solution": "def min_operations_to_equal(a, b):\n    def reduce(x):\n        count = 0\n        for factor in [2, 3, 5]:\n            while x % factor == 0:\n                x //= factor\n                count += 1\n        return x, count\n\n    reduced_a, count_a = reduce(a)\n    reduced_b, count_b = reduce(b)\n\n    if reduced_a != reduced_b:\n        return -1\n    else:\n        return count_a + count_b\n\n# Read input\na, b = map(int, input().split())\n\n# Get the result\nresult = min_operations_to_equal(a, b)\n\n# Print the result\nprint(result)"}
{"solution": "def min_cost_to_palindrome(n, a, b, c):\n    cost = 0\n    for i in range(n // 2):\n        left = c[i]\n        right = c[n - i - 1]\n        \n        if left == 2 and right == 2:\n            cost += 2 * min(a, b)\n        elif left == 2:\n            cost += a if right == 0 else b\n        elif right == 2:\n            cost += a if left == 0 else b\n        elif left != right:\n            return -1\n    \n    return cost\n\n# Read input\nn, a, b = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_cost_to_palindrome(n, a, b, c))"}
{"solution": "def paint_cube(k):\n    if k == 1:\n        print(-1)\n        return\n    \n    for z in range(k):\n        for y in range(k):\n            row = []\n            for x in range(k):\n                if (x + y + z) % 2 == 0:\n                    row.append('b')\n                else:\n                    row.append('w')\n            print(''.join(row))\n        if z != k - 1:\n            print()\n\n# Read input\nk = int(input().strip())\npaint_cube(k)"}
{"solution": "def largest_lovely_number(n):\n    def is_lovely(x):\n        a = 2\n        while a * a <= x:\n            if x % (a * a) == 0:\n                return False\n            a += 1\n        return True\n\n    for i in range(n, 0, -1):\n        if n % i == 0 and is_lovely(i):\n            return i\n\nn = int(input())\nprint(largest_lovely_number(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    # Check for adjacent occupied seats\n    for i in range(n - 1):\n        if seating[i] == '1' and seating[i + 1] == '1':\n            return \"No\"\n    \n    # Check for possible additional seating\n    for i in range(n):\n        if seating[i] == '0':\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nn = int(input())\nseating = input().strip()\n\n# Determine if the seating is maximal\nresult = is_maximal_seating(n, seating)\nprint(result)"}
{"solution": "def find_possible_lengths(n, a):\n    possible_lengths = []\n    \n    for k in range(1, n + 1):\n        valid = True\n        for i in range(k, n):\n            if a[i] - a[i - k] != a[k] - a[0]:\n                valid = False\n                break\n        if valid:\n            possible_lengths.append(k)\n    \n    return possible_lengths\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find possible lengths\npossible_lengths = find_possible_lengths(n, a)\n\n# Print output\nprint(len(possible_lengths))\nprint(\" \".join(map(str, possible_lengths)))"}
{"solution": "from itertools import combinations\n\ndef can_form_equal_teams(scores):\n    for comb in combinations(scores, 3):\n        if sum(comb) == sum(scores) - sum(comb):\n            return \"YES\"\n    return \"NO\"\n\nscores = list(map(int, input().split()))\nprint(can_form_equal_teams(scores))"}
{"solution": "def count_2_3_integers(l, r):\n    count = 0\n    x = 1\n    while x <= r:\n        y = x\n        while y <= r:\n            if y >= l:\n                count += 1\n            y *= 3\n        x *= 2\n    return count\n\n# Read input\nl, r = map(int, input().split())\n\n# Calculate and print the result\nprint(count_2_3_integers(l, r))"}
{"solution": "def find_candies_eaten(n, k):\n    # Initialize the number of candies put in the box\n    candies_put = 0\n    # Initialize the number of candies eaten\n    candies_eaten = 0\n    \n    # Iterate through the number of actions\n    for i in range(1, n + 1):\n        if candies_put - candies_eaten == k:\n            # If the current number of candies in the box equals k, break the loop\n            break\n        if candies_put - candies_eaten > k:\n            # If the current number of candies in the box is greater than k, eat a candy\n            candies_eaten += 1\n        else:\n            # Otherwise, put candies in the box\n            candies_put += i\n    \n    return candies_eaten\n\n# Read input\nn, k = map(int, input().split())\n\n# Find and print the number of candies eaten\nprint(find_candies_eaten(n, k))"}
{"solution": "def can_form_triangle(n, segments):\n    segments.sort()\n    for i in range(n - 2):\n        if segments[i] + segments[i + 1] > segments[i + 2]:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\nsegments = list(map(int, input().split()))\n\n# Check if a non-degenerate triangle can be formed\nresult = can_form_triangle(n, segments)\nprint(result)"}
{"solution": "def can_get_toys(x, y):\n    # Check if the number of original toys is at least 1\n    if y < 1:\n        return \"No\"\n    \n    # Check if the number of original toys is enough to produce the required copies\n    if x > 2 * (y - 1):\n        return \"No\"\n    \n    # Check if the number of copies is even\n    if x % 2 != 0:\n        return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nx, y = map(int, input().split())\n\n# Print the result\nprint(can_get_toys(x, y))"}
{"solution": "def max_total_rating(n, k, skills):\n    # Calculate initial rating\n    initial_rating = sum(skill // 10 for skill in skills)\n    \n    # Calculate the number of units needed to increase each skill to the next multiple of 10\n    units_needed = [(10 - (skill % 10)) % 10 for skill in skills]\n    \n    # Pair the units needed with the skills and sort by units needed\n    skills_with_units = sorted(zip(units_needed, skills))\n    \n    # Use the improvement units to maximize the rating\n    for units, skill in skills_with_units:\n        if k >= units:\n            k -= units\n            skill += units\n            initial_rating += 1\n    \n    # If there are remaining units, try to use them to increase the rating further\n    for i in range(n):\n        if k > 0:\n            max_increase = min(k, 100 - skills_with_units[i][1])\n            k -= max_increase\n            initial_rating += max_increase // 10\n    \n    return initial_rating\n\n# Read input\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Calculate and print the maximum total rating\nprint(max_total_rating(n, k, skills))"}
{"solution": "n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Find the smallest digit in both lists\nmin_a = min(a)\nmin_b = min(b)\n\n# Check if there is any common digit\ncommon_digits = set(a) & set(b)\nif common_digits:\n    print(min(common_digits))\nelse:\n    # If no common digit, form the smallest two-digit number\n    print(min(min_a * 10 + min_b, min_b * 10 + min_a))"}
{"solution": "def max_problems_solved(n, k):\n    total_time = 240 - k  # Total time available for solving problems\n    time_spent = 0\n    problems_solved = 0\n    \n    for i in range(1, n + 1):\n        time_needed = 5 * i\n        if time_spent + time_needed <= total_time:\n            time_spent += time_needed\n            problems_solved += 1\n        else:\n            break\n    \n    return problems_solved\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the result\nprint(max_problems_solved(n, k))"}
{"solution": "def max_teams(n, x, y, a):\n    a.sort()\n    count = 0\n    for pages in a:\n        if pages <= y:\n            y -= pages\n            count += 1\n        else:\n            pages -= y\n            y = 0\n            if pages <= 2 * x:\n                x -= (pages + 1) // 2\n                count += 1\n            else:\n                break\n    return count\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\ny = int(data[2])\na = list(map(int, data[3:]))\n\n# Calculate and print the result\nprint(max_teams(n, x, y, a))"}
{"solution": "import math\n\ndef count_distinct_numbers(b):\n    distinct_numbers = set()\n    for i in range(1, int(math.sqrt(b)) + 1):\n        if b % i == 0:\n            distinct_numbers.add(i)\n            distinct_numbers.add(b // i)\n    return len(distinct_numbers)\n\n# Read input\nb = int(input().strip())\n\n# Calculate and print the result\nprint(count_distinct_numbers(b))"}
{"solution": "def count_fall_positions(n, bumpers):\n    left_fall = 0\n    right_fall = 0\n\n    # Count positions where ball falls to the left\n    for i in range(n):\n        if bumpers[i] == '>':\n            break\n        left_fall += 1\n\n    # Count positions where ball falls to the right\n    for i in range(n-1, -1, -1):\n        if bumpers[i] == '<':\n            break\n        right_fall += 1\n\n    return left_fall + right_fall\n\n# Read input\nn = int(input())\nbumpers = input().strip()\n\n# Calculate and print the result\nprint(count_fall_positions(n, bumpers))"}
{"solution": "def max_total_area(n, lengths):\n    from collections import Counter\n\n    # Count the frequency of each length\n    count = Counter(lengths)\n    \n    # Create a list of possible lengths including reduced lengths\n    possible_lengths = []\n    for length in count:\n        possible_lengths.append(length)\n        if length - 1 >= 2:\n            possible_lengths.append(length - 1)\n    \n    # Count the frequency of each possible length\n    possible_count = Counter()\n    for length in possible_lengths:\n        possible_count[length] += count[length]\n    \n    # Sort the possible lengths in descending order\n    sorted_lengths = sorted(possible_count.keys(), reverse=True)\n    \n    # Find pairs of lengths to form rectangles\n    total_area = 0\n    i = 0\n    while i < len(sorted_lengths) - 1:\n        if possible_count[sorted_lengths[i]] >= 2:\n            if possible_count[sorted_lengths[i + 1]] >= 2:\n                total_area += sorted_lengths[i] * sorted_lengths[i + 1]\n                possible_count[sorted_lengths[i]] -= 2\n                possible_count[sorted_lengths[i + 1]] -= 2\n            else:\n                i += 1\n        else:\n            i += 1\n    \n    return total_area\n\n# Read input\nn = int(input())\nlengths = list(map(int, input().split()))\n\n# Calculate and print the maximum total area\nprint(max_total_area(n, lengths))"}
{"solution": "def min_sum_after_restoration(n, strings):\n    from collections import defaultdict\n    import heapq\n\n    # Frequency of each character in each position\n    freq = defaultdict(int)\n    leading = set()\n\n    for s in strings:\n        leading.add(s[0])\n        for i, char in enumerate(s[::-1]):\n            freq[char] += 10 ** i\n\n    # Min-heap to assign the smallest digits to the most significant characters\n    heap = []\n    for char, value in freq.items():\n        heapq.heappush(heap, (-value, char))\n\n    # Assign digits from 0 to 9\n    digit_map = {}\n    available_digits = list(range(10))\n    while heap:\n        value, char = heapq.heappop(heap)\n        if char in leading and 0 in available_digits:\n            available_digits.remove(0)\n        digit_map[char] = available_digits.pop(0)\n\n    # Calculate the minimum sum\n    min_sum = 0\n    for s in strings:\n        num = int(''.join(str(digit_map[char]) for char in s))\n        min_sum += num\n\n    return min_sum\n\n# Read input\nn = int(input().strip())\nstrings = [input().strip() for _ in range(n)]\n\n# Calculate and print the result\nprint(min_sum_after_restoration(n, strings))"}
{"solution": "def max_teams(n, m):\n    # Initialize the number of teams to 0\n    teams = 0\n    \n    # While there are enough participants to form at least one team\n    while n > 0 and m > 0:\n        if n > m:\n            # If there are more experienced participants, form a team of (XP, XP, NB)\n            n -= 2\n            m -= 1\n        else:\n            # If there are more or equal newbies, form a team of (XP, NB, NB)\n            n -= 1\n            m -= 2\n        \n        # Increment the number of teams formed\n        if n >= 0 and m >= 0:\n            teams += 1\n    \n    return teams\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    ab_index = s.find(\"AB\")\n    ba_index = s.find(\"BA\")\n    \n    if ab_index != -1 and ba_index != -1:\n        if abs(ab_index - ba_index) > 1:\n            return \"YES\"\n        if ab_index < ba_index:\n            if s.find(\"BA\", ab_index + 2) != -1:\n                return \"YES\"\n        else:\n            if s.find(\"AB\", ba_index + 2) != -1:\n                return \"YES\"\n    return \"NO\"\n\ns = input().strip()\nprint(check_substrings(s))"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:n+1]))\n    k = int(data[n+1])\n    b = list(map(int, data[n+2:n+2+k]))\n    \n    if sum(a) != sum(b):\n        print(\"NO\")\n        return\n    \n    actions = []\n    i, j = 0, 0\n    \n    while i < n and j < k:\n        current_sum = 0\n        start = i\n        while i < n and current_sum < b[j]:\n            current_sum += a[i]\n            i += 1\n        if current_sum != b[j]:\n            print(\"NO\")\n            return\n        if i - start > 1:\n            max_index = start\n            for x in range(start, i):\n                if a[x] > a[max_index]:\n                    max_index = x\n            for x in range(max_index - 1, start - 1, -1):\n                actions.append((x + 1, 'R'))\n            for x in range(max_index + 1, i):\n                actions.append((max_index + 1, 'L'))\n        j += 1\n    \n    if j != k:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for action in actions:\n            print(action[0], action[1])"}
{"solution": "def ccw(A, B, C):\n    return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])\n\ndef intersect(A, B, C, D):\n    return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D)\n\ndef is_possible_to_assign(R, B, rebels, bases):\n    from itertools import permutations\n\n    if R != B:\n        return False\n\n    for perm in permutations(bases):\n        valid = True\n        for i in range(R):\n            for j in range(i + 1, R):\n                if intersect(rebels[i], perm[i], rebels[j], perm[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return True\n    return False\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    R = int(data[0])\n    B = int(data[1])\n    \n    rebels = []\n    bases = []\n    \n    index = 2\n    for _ in range(R):\n        x = int(data[index])\n        y = int(data[index + 1])\n        rebels.append((x, y))\n        index += 2\n    \n    for _ in range(B):\n        x = int(data[index])\n        y = int(data[index + 1])\n        bases.append((x, y))\n        index += 2\n    \n    if is_possible_to_assign(R, B, rebels, bases):\n        print(\"Yes\")\n    else:\n        print(\"No\")"}
{"solution": "def max_power_of_two_divisor(n, sequence):\n    def max_power_of_two(x):\n        power = 1\n        while x % 2 == 0:\n            x //= 2\n            power *= 2\n        return power\n\n    max_power = 1\n    for num in sequence:\n        max_power = max(max_power, max_power_of_two(num))\n\n    count = sum(1 for num in sequence if num % max_power == 0)\n    \n    return max_power, count\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Get the result\nresult = max_power_of_two_divisor(n, sequence)\n\n# Print the result\nprint(result[0], result[1])"}
{"solution": "def min_clicks(n, m):\n    clicks = 0\n    while m > n:\n        if m % 2 == 0:\n            m //= 2\n        else:\n            m += 1\n        clicks += 1\n    clicks += n - m\n    return clicks\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    print(min_clicks(n, m))"}
{"solution": "def is_tree(n, segments):\n    from collections import defaultdict, deque\n\n    def intersect(s1, s2):\n        return not (s1[1] < s2[0] or s2[1] < s1[0]) and not (s1[0] > s2[0] and s1[1] < s2[1]) and not (s2[0] > s1[0] and s2[1] < s1[1])\n\n    graph = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if intersect(segments[i], segments[j]):\n                graph[i].append(j)\n                graph[j].append(i)\n\n    visited = [False] * n\n    parent = [-1] * n\n\n    def bfs(start):\n        queue = deque([start])\n        visited[start] = True\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n                elif parent[node] != neighbor:\n                    return False\n        return True\n\n    if not bfs(0):\n        return \"NO\"\n    if not all(visited):\n        return \"NO\"\n    return \"YES\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nsegments = []\nfor i in range(n):\n    l = int(data[2 * i + 1])\n    r = int(data[2 * i + 2])\n    segments.append((l, r))\n\n# Determine if the graph is a tree\nresult = is_tree(n, segments)\nprint(result)"}
{"solution": "def longest_ddos_period(n, requests):\n    max_length = 0\n    for start in range(n):\n        total_requests = 0\n        for end in range(start, n):\n            total_requests += requests[end]\n            time_period = end - start + 1\n            if total_requests > 100 * time_period:\n                max_length = max(max_length, time_period)\n    return max_length\n\n# Read input\nn = int(input())\nrequests = list(map(int, input().split()))\n\n# Find and print the length of the longest DDoS period\nprint(longest_ddos_period(n, requests))"}
{"solution": "def can_dissatisfaction_be_k(n, k, sequence):\n    max_dissatisfaction = 0\n    current_dissatisfaction = 0\n\n    for char in sequence:\n        if char == 'N' or char == '?':\n            current_dissatisfaction += 1\n        else:\n            max_dissatisfaction = max(max_dissatisfaction, current_dissatisfaction)\n            current_dissatisfaction = 0\n\n    max_dissatisfaction = max(max_dissatisfaction, current_dissatisfaction)\n\n    if max_dissatisfaction >= k:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\nsequence = input().strip()\n\n# Print output\nprint(can_dissatisfaction_be_k(n, k, sequence))"}
{"solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    N = int(data[0])\n    X = int(data[1])\n    D = int(data[2])\n    \n    if D == 0:\n        if X == 0:\n            print(1)\n        else:\n            print(2)\n        return\n    \n    values = set()\n    for k in range(N + 1):\n        S = k * X + D * k * (k - 1) // 2\n        values.add(S)\n    \n    print(len(values))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\nperformed_good = False\n\nfor _ in range(n):\n    handle, before, after = input().split()\n    before = int(before)\n    after = int(after)\n    \n    if before >= 2400 and after > before:\n        performed_good = True\n        break\n\nif performed_good:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_missed_trains(s):\n    # Convert binary string to integer\n    s_int = int(s, 2)\n    \n    # Initialize count of missed trains\n    count = 0\n    \n    # Initialize the departure time of the first train\n    departure_time = 1\n    \n    # Count the number of trains that have departed strictly before time s\n    while departure_time < s_int:\n        count += 1\n        departure_time *= 4\n    \n    return count\n\n# Read input\ns = input().strip()\n\n# Calculate and print the number of missed trains\nprint(count_missed_trains(s))"}
{"solution": "def min_rows_of_b(n, m, a):\n    for x in range(1, n + 1):\n        valid = True\n        for i in range(x):\n            for j in range(m):\n                if a[i][j] != a[2 * x - i - 1][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return x\n    return n\n\n# Read input\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\n# Find and print the minimum number of rows of matrix b\nprint(min_rows_of_b(n, m, a))"}
{"solution": "def max_orders(n, orders):\n    # Sort orders by their end time\n    orders.sort(key=lambda x: x[1])\n    \n    count = 0\n    last_end_time = 0\n    \n    for order in orders:\n        if order[0] > last_end_time:\n            count += 1\n            last_end_time = order[1]\n    \n    return count\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\norders = []\n\nfor i in range(n):\n    l = int(data[2 * i + 1])\n    r = int(data[2 * i + 2])\n    orders.append((l, r))\n\n# Get the result\nresult = max_orders(n, orders)\n\n# Print the result\nprint(result)"}
{"solution": "def can_rearrange(n, k, x, y):\n    # Initialize the current count of consecutive tables and formulas\n    current_tables = 0\n    current_formulas = 0\n\n    for i in range(n):\n        # Add the current page's tables and formulas to the running total\n        current_tables += x[i]\n        current_formulas += y[i]\n\n        # Check if the current count of consecutive tables or formulas exceeds k\n        if current_tables > k and current_formulas > k:\n            return \"NO\"\n\n        # If the current count of consecutive tables exceeds k, reset the count\n        if current_tables > k:\n            current_tables = x[i]\n            current_formulas = 0\n\n        # If the current count of consecutive formulas exceeds k, reset the count\n        if current_formulas > k:\n            current_formulas = y[i]\n            current_tables = 0\n\n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Print the result\nprint(can_rearrange(n, k, x, y))"}
{"solution": "def can_human_win(n, k, coefficients):\n    # Check if all coefficients are already defined\n    all_defined = all(c != '?' for c in coefficients)\n    \n    if all_defined:\n        # Evaluate P(k) to check if it's zero\n        P_k = sum(int(coefficients[i]) * (k ** i) for i in range(n + 1))\n        return P_k == 0\n    \n    # If there are undefined coefficients, human can always set them to make P(k) zero\n    return True\n\n# Read input\nn, k = map(int, input().split())\ncoefficients = [input().strip() for _ in range(n + 1)]\n\n# Determine if human can guarantee a win\nif can_human_win(n, k, coefficients):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def smallest_starting_number(X_2):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def primes_up_to(n):\n        sieve = [True] * (n + 1)\n        sieve[0] = sieve[1] = False\n        for start in range(2, int(n**0.5) + 1):\n            if sieve[start]:\n                for multiple in range(start*start, n + 1, start):\n                    sieve[multiple] = False\n        return [num for num, is_prime in enumerate(sieve) if is_prime]\n\n    primes = primes_up_to(X_2)\n    min_X0 = X_2 - 1\n\n    for p1 in primes:\n        for p2 in primes:\n            if p1 >= min_X0 or p2 >= min_X0:\n                break\n            X1 = ((X_2 - 1) // p2) * p2\n            if X1 < X_2 - 1:\n                X1 += p2\n            if X1 >= X_2:\n                continue\n            X0 = ((X1 - 1) // p1) * p1\n            if X0 < X1 - 1:\n                X0 += p1\n            if X0 < min_X0:\n                min_X0 = X0\n\n    return min_X0\n\nX_2 = int(input())\nprint(smallest_starting_number(X_2))"}
{"solution": "def min_p_binary_numbers(n, p):\n    for k in range(1, 1001):\n        m = n - k * p\n        if m < k:\n            break\n        if bin(m).count('1') <= k:\n            return k\n    return -1\n\n# Read input\nn, p = map(int, input().split())\n\n# Get the result\nresult = min_p_binary_numbers(n, p)\n\n# Print the result\nprint(result)"}
{"solution": "def minimal_possible_value(n, k, S):\n    S = list(S)\n    if n == 1:\n        if k > 0:\n            return '0'\n        else:\n            return S[0]\n    \n    if k > 0 and S[0] != '1':\n        S[0] = '1'\n        k -= 1\n    \n    for i in range(1, n):\n        if k == 0:\n            break\n        if S[i] != '0':\n            S[i] = '0'\n            k -= 1\n    \n    return ''.join(S)\n\n# Read input\nn, k = map(int, input().split())\nS = input().strip()\n\n# Get the minimal possible value\nresult = minimal_possible_value(n, k, S)\n\n# Print the result\nprint(result)"}
{"solution": "def find_min_v(cnt_1, cnt_2, x, y):\n    def count_valid_numbers(v, prime):\n        return v // prime\n\n    def count_valid_numbers_both(v, prime1, prime2):\n        return v // (prime1 * prime2)\n\n    left, right = 1, 2 * (cnt_1 + cnt_2)\n    while left < right:\n        mid = (left + right) // 2\n        count_x = count_valid_numbers(mid, x)\n        count_y = count_valid_numbers(mid, y)\n        count_xy = count_valid_numbers_both(mid, x, y)\n        \n        valid_for_first = mid - count_x\n        valid_for_second = mid - count_y\n        valid_for_both = mid - count_x - count_y + count_xy\n        \n        if valid_for_first >= cnt_1 and valid_for_second >= cnt_2 and valid_for_both >= cnt_1 + cnt_2:\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n# Read input\ncnt_1, cnt_2, x, y = map(int, input().split())\n\n# Find and print the result\nprint(find_min_v(cnt_1, cnt_2, x, y))"}
{"solution": "def bear_walk(n, sx, sy, dx, dy, t):\n    x, y = sx, sy\n    for _ in range(t):\n        k = x + y\n        dx += k\n        dy += k\n        x = ((x + dx - 1) % n) + 1\n        y = ((y + dy - 1) % n) + 1\n    return x, y\n\n# Read input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Get the final position\nfinal_x, final_y = bear_walk(n, sx, sy, dx, dy, t)\n\n# Print the result\nprint(final_x, final_y)"}
{"solution": "def find_nice_word(s):\n    n = len(s)\n    if n < 26:\n        return -1\n\n    alphabet = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    \n    for i in range(n - 25):\n        substring = s[i:i+26]\n        missing_letters = alphabet - set(substring.replace('?', ''))\n        if len(missing_letters) <= substring.count('?'):\n            result = list(s)\n            missing_letters = list(missing_letters)\n            for j in range(26):\n                if result[i + j] == '?':\n                    result[i + j] = missing_letters.pop()\n            return ''.join(result).replace('?', 'A')\n    \n    return -1\n\n# Read input\ns = input().strip()\n# Find and print the nice word\nprint(find_nice_word(s))"}
{"solution": "n = int(input())\nweights = list(map(int, input().split()))\n\ncount_100 = weights.count(100)\ncount_200 = weights.count(200)\n\ntotal_weight = count_100 * 100 + count_200 * 200\n\nif total_weight % 2 != 0:\n    print(\"NO\")\nelse:\n    half_weight = total_weight // 2\n    if half_weight % 200 <= count_100 * 100 and half_weight // 200 <= count_200:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "def min_time_to_turn_off_lights(n, m, building):\n    total_time = 0\n    current_position = 0  # Start at the left stairs of the ground floor\n\n    for floor in range(n):\n        lights = building[floor]\n        leftmost = lights.find('1')\n        rightmost = lights.rfind('1')\n\n        if leftmost == -1:\n            # No lights on this floor\n            continue\n\n        if floor == 0:\n            # On the ground floor, start from the left stairs\n            total_time += rightmost\n            current_position = rightmost\n        else:\n            if current_position <= leftmost:\n                # Move to the leftmost light\n                total_time += leftmost - current_position\n                total_time += rightmost - leftmost\n                current_position = rightmost\n            else:\n                # Move to the rightmost light\n                total_time += current_position - rightmost\n                total_time += rightmost - leftmost\n                current_position = leftmost\n\n        # Move to the next floor\n        total_time += 1\n\n    return total_time\n\n# Read input\nn, m = map(int, input().split())\nbuilding = [input().strip() for _ in range(n)]\n\n# Calculate and print the result\nprint(min_time_to_turn_off_lights(n, m, building))"}
{"solution": "def find_min_cost(n, c, a):\n    visited = [False] * n\n    in_cycle = [False] * n\n    min_cost = 0\n\n    def dfs(node):\n        stack = []\n        while not visited[node]:\n            visited[node] = True\n            stack.append(node)\n            node = a[node] - 1\n\n        if in_cycle[node]:\n            return\n\n        cycle_cost = float('inf')\n        while stack:\n            current = stack.pop()\n            in_cycle[current] = True\n            cycle_cost = min(cycle_cost, c[current])\n            if current == node:\n                break\n\n        nonlocal min_cost\n        min_cost += cycle_cost\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n\n    return min_cost\n\n# Input reading\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nc = list(map(int, data[1:n+1]))\na = list(map(int, data[n+1:2*n+1]))\n\n# Output the result\nprint(find_min_cost(n, c, a))"}
{"solution": "def find_entrance(n, a, b):\n    return (a + b - 1) % n + 1\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Find the entrance number\nresult = find_entrance(n, a, b)\n\n# Print the result\nprint(result)"}
{"solution": "def min_arithmetic_progressions(n, a):\n    def is_arithmetic_progression(seq):\n        if len(seq) <= 1:\n            return True\n        diff = seq[1] - seq[0]\n        for i in range(1, len(seq)):\n            if seq[i] - seq[i - 1] != diff:\n                return False\n        return True\n\n    count = 0\n    i = 0\n    while i < n:\n        if a[i] == -1:\n            j = i\n            while j < n and a[j] == -1:\n                j += 1\n            count += 1\n            i = j\n        else:\n            j = i + 1\n            while j < n and (a[j] == -1 or (a[j] != -1 and a[j] - a[j - 1] == a[i + 1] - a[i])):\n                j += 1\n            count += 1\n            i = j\n\n    return count\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = min_arithmetic_progressions(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def max_beauty(n, k, s):\n    def max_length_with_char(char):\n        left = 0\n        max_len = 0\n        count = 0\n\n        for right in range(n):\n            if s[right] != char:\n                count += 1\n\n            while count > k:\n                if s[left] != char:\n                    count -= 1\n                left += 1\n\n            max_len = max(max_len, right - left + 1)\n\n        return max_len\n\n    return max(max_length_with_char('a'), max_length_with_char('b'))\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Print the output\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, a):\n    total_seats = sum(a)\n    alice_seats = a[0]\n    coalition = [1]\n    coalition_seats = alice_seats\n\n    for i in range(1, n):\n        if alice_seats >= 2 * a[i]:\n            coalition.append(i + 1)\n            coalition_seats += a[i]\n\n    if coalition_seats > total_seats // 2:\n        print(len(coalition))\n        print(\" \".join(map(str, coalition)))\n    else:\n        print(0)\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find and print the coalition\nfind_coalition(n, a)"}
{"solution": "def max_reward(n):\n    reward = 0.0\n    for i in range(1, n + 1):\n        reward += 1.0 / i\n    return reward\n\nn = int(input())\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "def distribute_candies(n):\n    k = 0\n    total = 0\n    candies = []\n    \n    while total + (k + 1) <= n:\n        k += 1\n        total += k\n        candies.append(k)\n    \n    if total < n:\n        candies[-1] += n - total\n    \n    print(k)\n    print(\" \".join(map(str, candies)))\n\n# Read input\nn = int(input().strip())\ndistribute_candies(n)"}
{"solution": "n = int(input())\nm = int(input())\n\nresult = m % (2 ** n)\nprint(result)"}
{"solution": "def correct_word(n, s):\n    vowels = set('aeiouy')\n    result = []\n    i = 0\n    while i < n:\n        result.append(s[i])\n        if i < n - 1 and s[i] in vowels and s[i + 1] in vowels:\n            i += 1\n        i += 1\n    return ''.join(result)\n\n# Read input\nn = int(input())\ns = input()\n\n# Get the corrected word\ncorrected_word = correct_word(n, s)\n\n# Print the result\nprint(corrected_word)"}
{"solution": "def max_students(n, a, b, seats):\n    segments = seats.split('*')\n    total_students = 0\n\n    for segment in segments:\n        length = len(segment)\n        if length == 0:\n            continue\n\n        # Calculate the number of students that can be placed in this segment\n        programmers = (length + 1) // 2\n        athletes = length // 2\n\n        if a < b:\n            programmers, athletes = athletes, programmers\n\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n\n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n\n    return total_students\n\n# Read input\nn, a, b = map(int, input().split())\nseats = input().strip()\n\n# Calculate and print the result\nprint(max_students(n, a, b, seats))"}
{"solution": "def find_xy(r):\n    for x in range(1, int(r**0.5) + 1):\n        # Calculate the value of y using the rearranged formula\n        # H(x, y) = x^2 + 2xy + x + 1\n        # => 2xy + x + 1 = r - x^2\n        # => 2xy = r - x^2 - x - 1\n        # => y = (r - x^2 - x - 1) / (2x)\n        remainder = r - x**2 - x - 1\n        if remainder > 0 and remainder % (2 * x) == 0:\n            y = remainder // (2 * x)\n            if y > 0:\n                return x, y\n    return \"NO\"\n\n# Read input\nr = int(input().strip())\n\n# Find and print the result\nresult = find_xy(r)\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "def divide_balloons(n, a):\n    if n == 1:\n        return -1\n    \n    total_sum = sum(a)\n    \n    for i in range(1, 1 << n):\n        subset_sum = sum(a[j] for j in range(n) if (i & (1 << j)) > 0)\n        if subset_sum * 2 != total_sum:\n            subset_indices = [j + 1 for j in range(n) if (i & (1 << j)) > 0]\n            if 0 < len(subset_indices) < n:\n                return len(subset_indices), subset_indices\n    \n    return -1\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = divide_balloons(n, a)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    print(result[0])\n    print(\" \".join(map(str, result[1])))"}
{"solution": "def split_number(n):\n    # The best way to minimize the number of different digits is to use the largest digit possible, which is 9.\n    # We will use as many 9s as possible and then handle the remainder.\n    \n    # Number of 9s we can use\n    num_nines = n // 9\n    remainder = n % 9\n    \n    # If there is a remainder, we need to add it as an additional digit\n    if remainder > 0:\n        result = [9] * num_nines + [remainder]\n    else:\n        result = [9] * num_nines\n    \n    # Output the result\n    print(len(result))\n    print(\" \".join(map(str, result)))\n\n# Read input\nn = int(input().strip())\n\n# Call the function\nsplit_number(n)"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_max_simple_subset(arr):\n    n = len(arr)\n    arr.sort()\n    max_subset = []\n    \n    for i in range(n):\n        current_subset = [arr[i]]\n        for j in range(i + 1, n):\n            valid = True\n            for k in current_subset:\n                if not is_prime(k + arr[j]):\n                    valid = False\n                    break\n            if valid:\n                current_subset.append(arr[j])\n        if len(current_subset) > len(max_subset):\n            max_subset = current_subset\n    \n    return max_subset\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum simple subset\nresult = find_max_simple_subset(a)\n\n# Output the result\nprint(len(result))\nprint(\" \".join(map(str, result)))"}
{"solution": "def is_beautiful(num):\n    k = 1\n    while True:\n        beautiful_num = (2**(k+1) - 1) * (2**k - 1)\n        if beautiful_num > num:\n            break\n        if num % beautiful_num == 0:\n            return beautiful_num\n        k += 1\n    return 1\n\nn = int(input())\nprint(is_beautiful(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef is_d_magic(number, d):\n    number_str = str(number)\n    for i, char in enumerate(number_str):\n        if i % 2 == 1 and char != str(d):\n            return False\n        if i % 2 == 0 and char == str(d):\n            return False\n    return True\n\ndef count_d_magic_numbers(m, d, a, b):\n    a = int(a)\n    b = int(b)\n    count = 0\n    for num in range(a, b + 1):\n        if num % m == 0 and is_d_magic(num, d):\n            count += 1\n            count %= MOD\n    return count\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    m = int(data[0])\n    d = int(data[1])\n    a = data[2]\n    b = data[3]\n    \n    result = count_d_magic_numbers(m, d, a, b)\n    print(result)"}
{"solution": "def last_child(n, m, a):\n    from collections import deque\n\n    queue = deque([(i + 1, a[i])])  # (child index, candies needed)\n    for i in range(1, n):\n        queue.append((i + 1, a[i]))\n\n    last = -1\n    while queue:\n        child, candies_needed = queue.popleft()\n        candies_needed -= m\n        if candies_needed > 0:\n            queue.append((child, candies_needed))\n        else:\n            last = child\n\n    return last\n\n# Read input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nresult = last_child(n, m, a)\n\n# Print the result\nprint(result)"}
{"solution": "def min_bills(n):\n    denominations = [100, 20, 10, 5, 1]\n    count = 0\n    for denom in denominations:\n        count += n // denom\n        n %= denom\n    return count\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the result\nprint(min_bills(n))"}
{"solution": "MOD = 1000000007\n\ndef count_permutations(n, k):\n    # Initialize dp array\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j > 0:\n                dp[i][j] = (dp[i][j] + (i - 1) * dp[i - 2][j - 1]) % MOD\n\n    return dp[n][k]\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(count_permutations(n, k))"}
{"solution": "def max_beauty(n, k, beauties, colors):\n    white_roses = []\n    orange_roses = []\n    red_roses = []\n\n    for i in range(n):\n        if colors[i] == 'W':\n            white_roses.append(beauties[i])\n        elif colors[i] == 'O':\n            orange_roses.append(beauties[i])\n        elif colors[i] == 'R':\n            red_roses.append(beauties[i])\n\n    white_roses.sort(reverse=True)\n    orange_roses.sort(reverse=True)\n    red_roses.sort(reverse=True)\n\n    max_beauty = -1\n\n    for w in range(min(k, len(white_roses)) + 1):\n        for r in range(min(k - w, len(red_roses)) + 1):\n            o = k - w - r\n            if o <= len(orange_roses):\n                current_beauty = sum(white_roses[:w]) + sum(orange_roses[:o]) + sum(red_roses[:r])\n                max_beauty = max(max_beauty, current_beauty)\n\n    return max_beauty\n\n# Read input\nn, k = map(int, input().split())\nbeauties = list(map(int, input().split()))\ncolors = input().strip()\n\n# Compute and print the result\nresult = max_beauty(n, k, beauties, colors)\nprint(result)"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef continued_fraction_to_fraction(a):\n    n = len(a)\n    num = 1\n    den = a[-1]\n    for i in range(n - 2, -1, -1):\n        num, den = den, a[i] * den + num\n    return den, num\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    p = int(data[0])\n    q = int(data[1])\n    n = int(data[2])\n    a = list(map(int, data[3:3+n]))\n    \n    num1, den1 = p, q\n    num2, den2 = continued_fraction_to_fraction(a)\n    \n    gcd1 = gcd(num1, den1)\n    gcd2 = gcd(num2, den2)\n    \n    num1 //= gcd1\n    den1 //= gcd1\n    num2 //= gcd2\n    den2 //= gcd2\n    \n    if num1 == num2 and den1 == den2:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def check_expression(expression):\n    parts = expression.split('+')\n    A = len(parts[0])\n    B, C = parts[1].split('=')\n    B = len(B)\n    C = len(C)\n    \n    if A + B == C:\n        return expression\n    \n    # Try to shift one stick from A to B or C\n    if A > 1:\n        if A - 1 + B == C + 1:\n            return '|' * (A - 1) + '+' + '|' * B + '=' + '|' * (C + 1)\n        if A - 1 + B + 1 == C:\n            return '|' * (A - 1) + '+' + '|' * (B + 1) + '=' + '|' * C\n    \n    # Try to shift one stick from B to A or C\n    if B > 1:\n        if A + B - 1 == C + 1:\n            return '|' * A + '+' + '|' * (B - 1) + '=' + '|' * (C + 1)\n        if A + B - 1 + 1 == C:\n            return '|' * A + '+' + '|' * (B - 1) + '=' + '|' * C\n    \n    # Try to shift one stick from C to A or B\n    if C > 1:\n        if A + B == C - 1:\n            return '|' * A + '+' + '|' * B + '=' + '|' * (C - 1)\n        if A + B + 1 == C - 1:\n            return '|' * (A + 1) + '+' + '|' * B + '=' + '|' * (C - 1)\n        if A + B + 1 == C - 1:\n            return '|' * A + '+' + '|' * (B + 1) + '=' + '|' * (C - 1)\n    \n    return \"Impossible\"\n\nexpression = input().strip()\nprint(check_expression(expression))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_permutations_with_oddness(n, k):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            for l in range(i):\n                if j >= abs(i - (l + 1)):\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - abs(i - (l + 1))]) % MOD\n\n    return dp[n][k]\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    n, k = map(int, input().strip().split())\n    print(count_permutations_with_oddness(n, k))"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    points = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N)]\n    \n    # Check if all points have the same parity\n    parity = (points[0][0] + points[0][1]) % 2\n    for x, y in points:\n        if (x + y) % 2 != parity:\n            print(-1)\n            return\n    \n    # Determine the number of sections and their lengths\n    m = 40\n    d = [1 << i for i in range(m)]\n    \n    # Generate the directions for each point\n    directions = []\n    for x, y in points:\n        x -= (x + y) % 2\n        y -= (x + y) % 2\n        x //= 2\n        y //= 2\n        direction = []\n        for length in reversed(d):\n            if abs(x) > abs(y):\n                if x > 0:\n                    direction.append('R')\n                    x -= length\n                else:\n                    direction.append('L')\n                    x += length\n            else:\n                if y > 0:\n                    direction.append('U')\n                    y -= length\n                else:\n                    direction.append('D')\n                    y += length\n        directions.append(''.join(reversed(direction)))\n    \n    # Output the result\n    print(m)\n    print(' '.join(map(str, d)))\n    for direction in directions:\n        print(direction)\n\nsolve()"}
{"solution": "def replace_fillers(n, s):\n    i = 0\n    result = []\n    while i < n:\n        if s[i:i+3] == 'ogo':\n            result.append('***')\n            i += 3\n            while i + 1 < n and s[i:i+2] == 'go':\n                i += 2\n        else:\n            result.append(s[i])\n            i += 1\n    return ''.join(result)\n\n# Read input\nn = int(input())\ns = input()\n\n# Process and print the result\nprint(replace_fillers(n, s))"}
{"solution": "MOD = 10**9 + 7\n\ndef prime_factors(x):\n    factors = set()\n    d = 2\n    while d * d <= x:\n        while (x % d) == 0:\n            factors.add(d)\n            x //= d\n        d += 1\n    if x > 1:\n        factors.add(x)\n    return factors\n\ndef g(y, p):\n    result = 1\n    while y % p == 0:\n        y //= p\n        result *= p\n    return result\n\ndef f(x, y):\n    primes = prime_factors(x)\n    result = 1\n    for p in primes:\n        result *= g(y, p)\n    return result\n\ndef calculate(x, n):\n    primes = prime_factors(x)\n    result = 1\n    for p in primes:\n        power = p\n        while power <= n:\n            result = (result * pow(p, n // power, MOD)) % MOD\n            if power > n // p:\n                break\n            power *= p\n    return result\n\nx, n = map(int, input().split())\nprint(calculate(x, n))"}
{"solution": "def digit_sum(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for s in range(1, 82):  # s(x) can be at most 81 (for x = 999,999,999)\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and digit_sum(x) == s:\n            solutions.append(x)\n    return solutions\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    a = int(data[0])\n    b = int(data[1])\n    c = int(data[2])\n    \n    solutions = find_solutions(a, b, c)\n    solutions.sort()\n    \n    print(len(solutions))\n    if solutions:\n        print(\" \".join(map(str, solutions)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_solvable(cube):\n    # Define the 6 faces of the cube\n    faces = [\n        [0, 1, 2, 3],    # Front\n        [4, 5, 6, 7],    # Back\n        [8, 9, 10, 11],  # Top\n        [12, 13, 14, 15],# Bottom\n        [16, 17, 18, 19],# Left\n        [20, 21, 22, 23] # Right\n    ]\n    \n    # Check if a face is solved\n    def is_face_solved(face):\n        return len(set(cube[i] for i in face)) == 1\n    \n    # Check if the cube is solved\n    def is_cube_solved():\n        return all(is_face_solved(face) for face in faces)\n    \n    # Rotate a face 90 degrees clockwise\n    def rotate_face(face):\n        return [face[2], face[0], face[3], face[1]]\n    \n    # Rotate a face 90 degrees counterclockwise\n    def rotate_face_ccw(face):\n        return [face[1], face[3], face[0], face[2]]\n    \n    # Check all possible rotations\n    for face in faces:\n        original_face = face[:]\n        \n        # Rotate clockwise\n        face = rotate_face(face)\n        if is_cube_solved():\n            return \"YES\"\n        \n        # Rotate counterclockwise\n        face = rotate_face_ccw(face)\n        face = rotate_face_ccw(face)\n        if is_cube_solved():\n            return \"YES\"\n        \n        # Restore original face\n        face = original_face\n    \n    return \"NO\"\n\n# Read input\ncube = list(map(int, input().split()))\n\n# Check if the cube can be solved with one rotation\nprint(is_solvable(cube))"}
{"solution": "def will_get_tshirt(p, s):\n    i = (s // 50) % 475\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        if 26 + i == p:\n            return True\n    return False\n\ndef min_successful_hacks(p, x, y):\n    for hacks in range(1000):\n        for unsuccessful_hacks in range(hacks + 1):\n            score = x + 100 * (hacks - unsuccessful_hacks) - 50 * unsuccessful_hacks\n            if score >= y and will_get_tshirt(p, score):\n                return hacks\n    return -1\n\np, x, y = map(int, input().split())\nprint(min_successful_hacks(p, x, y))"}
{"solution": "def min_distance(n, a, b, c):\n    if n == 1:\n        return 0\n    elif n == 2:\n        return min(a, b)\n    else:\n        return min(a + c * (n - 2), b + c * (n - 2))\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate and print the result\nprint(min_distance(n, a, b, c))"}
{"solution": "# Read input\nx1, x2, x3 = map(int, input().split())\n\n# Sort the coordinates\ncoordinates = sorted([x1, x2, x3])\n\n# The optimal meeting point is the median of the three points\nmeeting_point = coordinates[1]\n\n# Calculate the total distance\ntotal_distance = abs(x1 - meeting_point) + abs(x2 - meeting_point) + abs(x3 - meeting_point)\n\n# Print the result\nprint(total_distance)"}
{"solution": "def minimal_operations(n, x, arr):\n    from collections import defaultdict\n\n    # Dictionary to count occurrences of each element\n    count = defaultdict(int)\n    for num in arr:\n        count[num] += 1\n\n    # If any element appears at least twice, no operation is needed\n    for num in count:\n        if count[num] > 1:\n            return 0\n\n    # Dictionary to count occurrences of each element after AND operation\n    and_count = defaultdict(int)\n    for num in arr:\n        and_num = num & x\n        and_count[and_num] += 1\n\n    # Check if any element after AND operation appears at least twice\n    for num in and_count:\n        if and_count[num] > 1:\n            return 1\n\n    # Check if any element after AND operation matches any original element\n    for num in arr:\n        and_num = num & x\n        if and_num in count:\n            return 1\n\n    # If no solution found, return -1\n    return -1\n\n# Read input\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Print the result\nprint(minimal_operations(n, x, arr))"}
{"solution": "def is_single_plus(h, w, picture):\n    def is_valid_center(x, y):\n        if picture[x][y] != '*':\n            return False\n        # Check up\n        if x == 0 or picture[x-1][y] != '*':\n            return False\n        # Check down\n        if x == h-1 or picture[x+1][y] != '*':\n            return False\n        # Check left\n        if y == 0 or picture[x][y-1] != '*':\n            return False\n        # Check right\n        if y == w-1 or picture[x][y+1] != '*':\n            return False\n        return True\n\n    def mark_visited(x, y):\n        # Mark the center\n        picture[x][y] = '.'\n        # Mark up\n        i = x - 1\n        while i >= 0 and picture[i][y] == '*':\n            picture[i][y] = '.'\n            i -= 1\n        # Mark down\n        i = x + 1\n        while i < h and picture[i][y] == '*':\n            picture[i][y] = '.'\n            i += 1\n        # Mark left\n        j = y - 1\n        while j >= 0 and picture[x][j] == '*':\n            picture[x][j] = '.'\n            j -= 1\n        # Mark right\n        j = y + 1\n        while j < w and picture[x][j] == '*':\n            picture[x][j] = '.'\n            j += 1\n\n    center_found = False\n    for i in range(h):\n        for j in range(w):\n            if is_valid_center(i, j):\n                if center_found:\n                    return \"NO\"\n                center_found = True\n                mark_visited(i, j)\n\n    for i in range(h):\n        for j in range(w):\n            if picture[i][j] == '*':\n                return \"NO\"\n\n    return \"YES\" if center_found else \"NO\"\n\n# Read input\nh, w = map(int, input().split())\npicture = [list(input().strip()) for _ in range(h)]\n\n# Determine if the picture has a single \"+\" shape\nresult = is_single_plus(h, w, picture)\nprint(result)"}
{"solution": "def solve(n, a, b):\n    if (a == 1 and b == 1 and n > 1) or (a > 1 and b > 1):\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    matrix = [[0] * n for _ in range(n)]\n\n    if a == 1:\n        for i in range(n - 1):\n            matrix[i][i + 1] = 1\n            matrix[i + 1][i] = 1\n    else:\n        for i in range(1, n):\n            matrix[0][i] = 1\n            matrix[i][0] = 1\n\n    for row in matrix:\n        print(\"\".join(map(str, row)))\n\n# Example usage:\nn, a, b = map(int, input().split())\nsolve(n, a, b)"}
{"solution": "c, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\nrequired_finalists = n * m\nremaining_finalists = required_finalists - k\n\nif remaining_finalists <= 0:\n    print(0)\nelse:\n    main_rounds_needed = remaining_finalists // n\n    additional_rounds_needed = remaining_finalists % n\n\n    if additional_rounds_needed > 0:\n        main_rounds_needed += 1\n\n    total_problems = main_rounds_needed * c + additional_rounds_needed * d\n    print(total_problems)"}
{"solution": "def find_grid(s):\n    if len(s) != 27:\n        return \"Impossible\"\n\n    # Create a dictionary to store the positions of each character in the string\n    pos = {}\n    for i, char in enumerate(s):\n        if char in pos:\n            pos[char].append(i)\n        else:\n            pos[char] = [i]\n\n    # Check if there is any character that appears more than twice\n    for key in pos:\n        if len(pos[key]) > 2:\n            return \"Impossible\"\n\n    # Try to find a valid grid\n    for i in range(27):\n        for j in range(i + 1, 27):\n            if s[i] == s[j]:\n                # Calculate the distance between the two positions\n                dist = j - i - 1\n                if dist % 2 == 0:\n                    mid = (i + j) // 2\n                    if mid % 13 != 0 and mid % 13 != 12:\n                        grid = [[''] * 13 for _ in range(2)]\n                        grid[0][mid % 13] = s[i]\n                        grid[1][mid % 13] = s[j]\n                        k = 0\n                        for l in range(27):\n                            if l != i and l != j:\n                                if k < mid % 13:\n                                    grid[0][k] = s[l]\n                                elif k > mid % 13:\n                                    grid[0][k] = s[l]\n                                else:\n                                    grid[1][k] = s[l]\n                                k += 1\n                        return ''.join(grid[0]) + '\\n' + ''.join(grid[1])\n    return \"Impossible\"\n\n# Read input\ns = input().strip()\n\n# Find and print the grid\nprint(find_grid(s))"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<'\n    elif y == 1:\n        return '>'\n    else:\n        log_x = math.log(x)\n        log_y = math.log(y)\n        if y * log_x < x * log_y:\n            return '<'\n        elif y * log_x > x * log_y:\n            return '>'\n        else:\n            return '='\n\nx, y = map(int, input().split())\nprint(compare_powers(x, y))"}
{"solution": "import math\n\ndef max_balloons(r, h):\n    # Calculate the number of balloons that can fit in the semicircle part\n    semicircle_balloons = (r // (r // 2)) * (r // (r // 2)) // 2\n    \n    # Calculate the number of balloons that can fit in the rectangular part\n    rectangle_balloons = (h // (r // 2)) * (r // (r // 2))\n    \n    # Total balloons is the sum of balloons in the semicircle and rectangle parts\n    total_balloons = semicircle_balloons + rectangle_balloons\n    \n    return total_balloons\n\n# Read input\nr, h = map(int, input().split())\n\n# Calculate and print the result\nprint(max_balloons(r, h))"}
{"solution": "def min_sum_after_discard(cards):\n    from collections import Counter\n    \n    card_counts = Counter(cards)\n    total_sum = sum(cards)\n    min_sum = total_sum\n    \n    for card, count in card_counts.items():\n        if count >= 2:\n            min_sum = min(min_sum, total_sum - card * min(count, 3))\n    \n    return min_sum\n\n# Read input\ncards = list(map(int, input().split()))\n\n# Calculate and print the minimum sum\nprint(min_sum_after_discard(cards))"}
{"solution": "def min_distance_to_visit_checkpoints(n, a, checkpoints):\n    checkpoints.sort()\n    \n    if n == 1:\n        return 0\n    \n    # Calculate the distance if we skip the first checkpoint\n    distance_skip_first = abs(a - checkpoints[1]) + abs(checkpoints[1] - checkpoints[-1])\n    \n    # Calculate the distance if we skip the last checkpoint\n    distance_skip_last = abs(a - checkpoints[-2]) + abs(checkpoints[-2] - checkpoints[0])\n    \n    return min(distance_skip_first, distance_skip_last)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = int(data[1])\ncheckpoints = list(map(int, data[2:]))\n\n# Calculate and print the result\nprint(min_distance_to_visit_checkpoints(n, a, checkpoints))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_smallest_root(n):\n    for x in range(1, int(n**0.5) + 1):\n        if x**2 + sum_of_digits(x) * x == n:\n            return x\n    return -1\n\nn = int(input().strip())\nprint(find_smallest_root(n))"}
{"solution": "def time_to_bed(current_time, sleep_duration):\n    current_hours, current_minutes = map(int, current_time.split(':'))\n    sleep_hours, sleep_minutes = map(int, sleep_duration.split(':'))\n\n    total_current_minutes = current_hours * 60 + current_minutes\n    total_sleep_minutes = sleep_hours * 60 + sleep_minutes\n\n    bed_time_minutes = total_current_minutes - total_sleep_minutes\n    if bed_time_minutes < 0:\n        bed_time_minutes += 24 * 60\n\n    bed_hours = bed_time_minutes // 60\n    bed_minutes = bed_time_minutes % 60\n\n    return f\"{bed_hours:02}:{bed_minutes:02}\"\n\n# Read input\ncurrent_time = input().strip()\nsleep_duration = input().strip()\n\n# Calculate and print the time George went to bed\nprint(time_to_bed(current_time, sleep_duration))"}
{"solution": "def find_longest_subsegment_with_max_mean(n, a):\n    max_value = max(a)\n    max_length = 0\n    current_length = 0\n\n    for value in a:\n        if value == max_value:\n            current_length += 1\n            if current_length > max_length:\n                max_length = current_length\n        else:\n            current_length = 0\n\n    return max_length\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find and print the length of the longest subsegment with maximum mean\nprint(find_longest_subsegment_with_max_mean(n, a))"}
{"solution": "MOD = 998244353\n\ndef count_ways(n, m, k):\n    # Initialize a 2D dp array with zeros\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    # Base case: 1 way to paint 1 brick with any color\n    for i in range(1, n + 1):\n        dp[i][0] = m\n    \n    # Fill the dp table\n    for i in range(2, n + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i - 1][j] * m + dp[i - 1][j - 1] * (m - 1)) % MOD\n    \n    return dp[n][k]\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Calculate and print the result\nprint(count_ways(n, m, k))"}
{"solution": "def is_magic_number(n):\n    s = str(n)\n    i = 0\n    while i < len(s):\n        if s[i:i+3] == '144':\n            i += 3\n        elif s[i:i+2] == '14':\n            i += 2\n        elif s[i:i+1] == '1':\n            i += 1\n        else:\n            return \"NO\"\n    return \"YES\"\n\n# Read input\nn = int(input().strip())\n\n# Determine if the number is a magic number\nresult = is_magic_number(n)\n\n# Print the result\nprint(result)"}
{"solution": "def min_moves_to_corner(n, m, i, j, a, b):\n    corners = [(1, 1), (1, m), (n, 1), (n, m)]\n    min_moves = float('inf')\n    \n    for (x, y) in corners:\n        if (abs(i - x) % a == 0) and (abs(j - y) % b == 0):\n            moves_x = abs(i - x) // a\n            moves_y = abs(j - y) // b\n            if (moves_x % 2) == (moves_y % 2):\n                moves = max(moves_x, moves_y)\n                if (i + a <= n or i - a >= 1) and (j + b <= m or j - b >= 1):\n                    min_moves = min(min_moves, moves)\n    \n    if min_moves == float('inf'):\n        return \"Poor Inna and pony!\"\n    else:\n        return min_moves\n\n# Read input\nn, m, i, j, a, b = map(int, input().split())\n\n# Get the result\nresult = min_moves_to_corner(n, m, i, j, a, b)\n\n# Print the result\nprint(result)"}
{"solution": "def max_removals(s):\n    n = len(s)\n    removed = 0\n    while True:\n        to_remove = set()\n        for i in range(n):\n            if i > 0 and ord(s[i]) == ord(s[i-1]) + 1:\n                to_remove.add(i)\n            if i < n-1 and ord(s[i]) == ord(s[i+1]) + 1:\n                to_remove.add(i)\n        if not to_remove:\n            break\n        s = ''.join(s[i] for i in range(n) if i not in to_remove)\n        n = len(s)\n        removed += len(to_remove)\n    return removed\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Calculate and print the result\nprint(max_removals(s))"}
{"solution": "def min_bills(n, k, denominations, q, requests):\n    results = []\n    for x in requests:\n        min_bills_needed = float('inf')\n        found = False\n        for i in range(n):\n            for j in range(i, n):\n                d1, d2 = denominations[i], denominations[j]\n                if d1 == d2:\n                    if x % d1 == 0 and x // d1 <= k:\n                        min_bills_needed = min(min_bills_needed, x // d1)\n                        found = True\n                else:\n                    for b1 in range(k + 1):\n                        if b1 * d1 > x:\n                            break\n                        if (x - b1 * d1) % d2 == 0:\n                            b2 = (x - b1 * d1) // d2\n                            if b1 + b2 <= k:\n                                min_bills_needed = min(min_bills_needed, b1 + b2)\n                                found = True\n        if found:\n            results.append(min_bills_needed)\n        else:\n            results.append(-1)\n    return results\n\n# Read input\nn, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\nrequests = [int(input()) for _ in range(q)]\n\n# Get results\nresults = min_bills(n, k, denominations, q, requests)\n\n# Print results\nfor result in results:\n    print(result)"}
{"solution": "def min_time_to_reach(s, x1, x2, t1, t2, p, d):\n    if t2 <= t1:\n        return abs(x2 - x1) * t2\n\n    if d == 1:\n        if p <= x1:\n            tram_time = (x1 - p) * t1\n        else:\n            tram_time = (s - p + s + x1) * t1\n    else:\n        if p >= x1:\n            tram_time = (p - x1) * t1\n        else:\n            tram_time = (p + s + (s - x1)) * t1\n\n    tram_time += abs(x2 - x1) * t1\n    walk_time = abs(x2 - x1) * t2\n\n    return min(tram_time, walk_time)\n\n# Read input\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Calculate and print the result\nprint(min_time_to_reach(s, x1, x2, t1, t2, p, d))"}
{"solution": "def count_occurrences(n, x):\n    count = 0\n    for i in range(1, n + 1):\n        if x % i == 0 and x // i <= n:\n            count += 1\n    return count\n\n# Read input\nn, x = map(int, input().split())\n\n# Get the result\nresult = count_occurrences(n, x)\n\n# Print the result\nprint(result)"}
{"solution": "def generate_password(n, k):\n    # Create a list of the first k lowercase Latin letters\n    letters = [chr(i) for i in range(ord('a'), ord('a') + k)]\n    \n    # Initialize the password list\n    password = []\n    \n    # Fill the password list ensuring no two consecutive characters are the same\n    for i in range(n):\n        password.append(letters[i % k])\n    \n    # Join the list into a string and return\n    return ''.join(password)\n\n# Read input\nn, k = map(int, input().split())\n\n# Generate and print the password\nprint(generate_password(n, k))"}
{"solution": "def first_collision_time(n, directions, positions):\n    min_time = float('inf')\n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            time = (positions[i + 1] - positions[i]) // 2\n            if time < min_time:\n                min_time = time\n    return min_time if min_time != float('inf') else -1\n\n# Read input\nn = int(input().strip())\ndirections = input().strip()\npositions = list(map(int, input().strip().split()))\n\n# Find and print the first collision time\nprint(first_collision_time(n, directions, positions))"}
{"solution": "def largest_area(n, a, b, seals):\n    max_area = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = seals[i]\n            x2, y2 = seals[j]\n\n            # Check all possible orientations and placements\n            for (w1, h1) in [(x1, y1), (y1, x1)]:\n                for (w2, h2) in [(x2, y2), (y2, x2)]:\n                    if (w1 + w2 <= a and max(h1, h2) <= b) or (w1 + w2 <= b and max(h1, h2) <= a):\n                        max_area = max(max_area, w1 * h1 + w2 * h2)\n                    if (h1 + h2 <= b and max(w1, w2) <= a) or (h1 + h2 <= a and max(w1, w2) <= b):\n                        max_area = max(max_area, w1 * h1 + w2 * h2)\n\n    return max_area\n\n# Read input\nn, a, b = map(int, input().split())\nseals = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(largest_area(n, a, b, seals))"}
{"solution": "def find_outlier_point(n, points):\n    x_count = {}\n    y_count = {}\n    \n    for x, y in points:\n        if x in x_count:\n            x_count[x] += 1\n        else:\n            x_count[x] = 1\n        \n        if y in y_count:\n            y_count[y] += 1\n        else:\n            y_count[y] = 1\n    \n    for x, y in points:\n        if x_count[x] <= n and y_count[y] <= n:\n            return x, y\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(4 * n + 1)]\noutlier = find_outlier_point(n, points)\nprint(outlier[0], outlier[1])"}
{"solution": "def digit_product(x):\n    product = 1\n    while x > 0:\n        product *= x % 10\n        x //= 10\n    return product\n\ndef max_digit_product(n):\n    max_product = digit_product(n)\n    str_n = str(n)\n    for i in range(len(str_n)):\n        if str_n[i] == '0':\n            continue\n        new_number = list(str_n)\n        new_number[i] = str(int(new_number[i]) - 1)\n        for j in range(i + 1, len(new_number)):\n            new_number[j] = '9'\n        new_number = int(''.join(new_number))\n        max_product = max(max_product, digit_product(new_number))\n    return max_product\n\nn = int(input())\nprint(max_digit_product(n))"}
{"solution": "def smallest_winning_k(n, votes):\n    max_a = max(votes)\n    total_votes_elodreip = sum(votes)\n    \n    # We need to find the smallest k such that Awruk's votes are strictly more than Elodreip's votes\n    k = max_a\n    while True:\n        total_votes_awruk = n * k - total_votes_elodreip\n        if total_votes_awruk > total_votes_elodreip:\n            return k\n        k += 1\n\n# Read input\nn = int(input())\nvotes = list(map(int, input().split()))\n\n# Find and print the smallest winning k\nprint(smallest_winning_k(n, votes))"}
{"solution": "def count_operations(points):\n    operations = 0\n    while True:\n        to_delete = set()\n        for i in range(1, len(points) - 1):\n            if points[i] != points[i - 1] or points[i] != points[i + 1]:\n                to_delete.add(i)\n        if points[0] != points[1]:\n            to_delete.add(0)\n        if points[-1] != points[-2]:\n            to_delete.add(len(points) - 1)\n        \n        if not to_delete:\n            break\n        \n        points = ''.join(points[i] for i in range(len(points)) if i not in to_delete)\n        operations += 1\n    \n    return operations\n\n# Read input\npoints = input().strip()\n\n# Calculate and print the number of operations\nprint(count_operations(points))"}
{"solution": "from collections import Counter\nfrom math import comb\n\ndef count_minimum_product_triples(n, a):\n    a.sort()\n    min1, min2, min3 = a[0], a[1], a[2]\n    \n    if min1 == min2 == min3:\n        count1 = a.count(min1)\n        return comb(count1, 3)\n    elif min1 == min2:\n        count1 = a.count(min1)\n        count3 = a.count(min3)\n        return comb(count1, 2) * count3\n    else:\n        count1 = a.count(min1)\n        count2 = a.count(min2)\n        count3 = a.count(min3)\n        return count1 * count2 * count3\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_minimum_product_triples(n, a))"}
{"solution": "n = int(input())\n\nif n == 0:\n    print(0)\nelif (n + 1) % 2 == 0:\n    print((n + 1) // 2)\nelse:\n    print(n + 1)"}
{"solution": "n = int(input())\n\nif n >= 0:\n    print(n)\nelse:\n    option1 = n // 10\n    option2 = (n // 100) * 10 + (n % 10)\n    print(max(option1, option2))"}
{"solution": "def determine_direction(start, end, n):\n    positions = ['v', '<', '^', '>']\n    start_index = positions.index(start)\n    end_index = positions.index(end)\n    \n    # Calculate the positions after n seconds in both directions\n    cw_index = (start_index + n) % 4\n    ccw_index = (start_index - n) % 4\n    \n    if positions[cw_index] == end and positions[ccw_index] == end:\n        return \"undefined\"\n    elif positions[cw_index] == end:\n        return \"cw\"\n    elif positions[ccw_index] == end:\n        return \"ccw\"\n    else:\n        return \"undefined\"\n\n# Read input\nstart, end = input().split()\nn = int(input())\n\n# Determine and print the direction\nprint(determine_direction(start, end, n))"}
{"solution": "def count_standing_dominoes(n, s):\n    standing_count = 0\n    i = 0\n\n    while i < n:\n        if s[i] == '.':\n            standing_count += 1\n            i += 1\n        elif s[i] == 'L':\n            i += 1\n        elif s[i] == 'R':\n            j = i + 1\n            while j < n and s[j] == '.':\n                j += 1\n            if j < n and s[j] == 'L':\n                distance = j - i - 1\n                if distance % 2 == 0:\n                    standing_count += 1\n            i = j\n\n    return standing_count\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Calculate and print the result\nprint(count_standing_dominoes(n, s))"}
{"solution": "def find_permutation(n, m, leaders):\n    a = [-1] * n\n    used = [False] * (n + 1)\n    \n    for i in range(m - 1):\n        current_leader = leaders[i] - 1\n        next_leader = leaders[i + 1] - 1\n        steps = (next_leader - current_leader) % n\n        if steps == 0:\n            steps = n\n        \n        if a[current_leader] == -1:\n            if used[steps]:\n                return -1\n            a[current_leader] = steps\n            used[steps] = True\n        elif a[current_leader] != steps:\n            return -1\n    \n    for i in range(n):\n        if a[i] == -1:\n            for j in range(1, n + 1):\n                if not used[j]:\n                    a[i] = j\n                    used[j] = True\n                    break\n    \n    return a\n\n# Read input\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\n# Find permutation\nresult = find_permutation(n, m, leaders)\n\n# Print result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def maximize_number(a, k):\n    a = list(str(a))\n    n = len(a)\n    \n    for i in range(n):\n        if k == 0:\n            break\n        \n        max_digit = a[i]\n        max_pos = i\n        \n        for j in range(i + 1, min(n, i + k + 1)):\n            if a[j] > max_digit:\n                max_digit = a[j]\n                max_pos = j\n        \n        if max_pos != i:\n            for j in range(max_pos, i, -1):\n                a[j], a[j - 1] = a[j - 1], a[j]\n            k -= (max_pos - i)\n    \n    return ''.join(a)\n\n# Read input\na, k = input().split()\nk = int(k)\n\n# Get the result\nresult = maximize_number(a, k)\n\n# Print the result\nprint(result)"}
{"solution": "def find_next_number(sequence):\n    a1, a2, a3, a4 = sequence\n\n    # Check for arithmetic progression\n    if a2 - a1 == a3 - a2 == a4 - a3:\n        d = a2 - a1\n        next_number = a4 + d\n        print(next_number)\n        return\n\n    # Check for geometric progression\n    if a1 != 0 and a2 % a1 == 0 and a3 % a2 == 0 and a4 % a3 == 0:\n        q = a2 // a1\n        if a2 == a1 * q and a3 == a2 * q and a4 == a3 * q:\n            next_number = a4 * q\n            print(next_number)\n            return\n\n    # If neither, print 42\n    print(42)\n\n# Read input\nsequence = list(map(int, input().split()))\nfind_next_number(sequence)"}
{"solution": "def max_distance(n, colors):\n    # Find the first and last occurrence of each color\n    first_occurrence = {}\n    last_occurrence = {}\n    \n    for i in range(n):\n        color = colors[i]\n        if color not in first_occurrence:\n            first_occurrence[color] = i\n        last_occurrence[color] = i\n    \n    # Get the first and last house colors\n    first_color = colors[0]\n    last_color = colors[-1]\n    \n    # Calculate the maximum distance\n    max_dist = 0\n    for color in first_occurrence:\n        if color != first_color:\n            max_dist = max(max_dist, first_occurrence[color])\n        if color != last_color:\n            max_dist = max(max_dist, n - 1 - first_occurrence[color])\n    \n    return max_dist\n\n# Read input\nn = int(input())\ncolors = list(map(int, input().split()))\n\n# Get the result and print it\nresult = max_distance(n, colors)\nprint(result)"}
{"solution": "def find_santa_place(n, m, k):\n    # Determine the lane number\n    lane = (k - 1) // (2 * m) + 1\n    \n    # Determine the desk number within the lane\n    desk = ((k - 1) % (2 * m)) // 2 + 1\n    \n    # Determine the side of the desk\n    side = \"L\" if (k - 1) % 2 == 0 else \"R\"\n    \n    return lane, desk, side\n\n# Read input\nn, m, k = map(int, input().strip().split())\n\n# Find Santa's place\nlane, desk, side = find_santa_place(n, m, k)\n\n# Print the result\nprint(lane, desk, side)"}
{"solution": "def possible_final_colors(n, s):\n    count_R = s.count('R')\n    count_G = s.count('G')\n    count_B = s.count('B')\n    \n    # If all cards are of the same color\n    if count_R == n or count_G == n or count_B == n:\n        return s[0]\n    \n    # If there are cards of all three colors\n    if count_R > 0 and count_G > 0 and count_B > 0:\n        return \"BGR\"\n    \n    # If there are cards of exactly two colors\n    if count_R > 0 and count_G > 0:\n        if (count_R % 2 == 0 and count_G % 2 == 0) or (count_R % 2 == 1 and count_G % 2 == 1):\n            return \"R\"\n        else:\n            return \"BRG\"\n    if count_R > 0 and count_B > 0:\n        if (count_R % 2 == 0 and count_B % 2 == 0) or (count_R % 2 == 1 and count_B % 2 == 1):\n            return \"R\"\n        else:\n            return \"BRG\"\n    if count_G > 0 and count_B > 0:\n        if (count_G % 2 == 0 and count_B % 2 == 0) or (count_G % 2 == 1 and count_B % 2 == 1):\n            return \"G\"\n        else:\n            return \"BRG\"\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the possible final colors\nresult = possible_final_colors(n, s)\n\n# Print the result\nprint(result)"}
