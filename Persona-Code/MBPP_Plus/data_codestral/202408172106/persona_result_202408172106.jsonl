{"task_id": "Mbpp/2", "solution": "def similar_elements(list1, list2):\n    # Convert the lists to sets\n    set1 = set(list1)\n    set2 = set(list2)\n\n    # Find the intersection of the two sets\n    intersection = set1 & set2\n\n    # Convert the intersection set back to a tuple\n    result = tuple(intersection)\n\n    return result"}
{"task_id": "Mbpp/3", "solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False"}
{"task_id": "Mbpp/4", "solution": "import heapq\n\ndef heap_queue_largest(numbers, n):\n    # Create a min heap with the first n elements of the list\n    min_heap = numbers[:n]\n    heapq.heapify(min_heap)\n\n    # Iterate over the remaining elements in the list\n    for num in numbers[n:]:\n        # If the current number is larger than the smallest number in the heap,\n        # replace the smallest number with the current number\n        if num > min_heap[0]:\n            heapq.heapreplace(min_heap, num)\n\n    # Sort the heap in descending order and return it\n    return sorted(min_heap, reverse=True)"}
{"task_id": "Mbpp/6", "solution": "def differ_At_One_Bit_Pos(num1, num2):\n    # Calculate the XOR of the two numbers\n    xor = num1 ^ num2\n\n    # Check if the XOR has exactly one bit set\n    return xor != 0 and (xor & (xor - 1)) == 0"}
{"task_id": "Mbpp/7", "solution": "def find_char_long(input_string):\n    \"\"\"\n    This function takes a string as input and returns a set of all words in the string that are at least 4 characters long.\n\n    Args:\n    input_string (str): The input string to search for words.\n\n    Returns:\n    set: A set of all words in the input string that are at least 4 characters long.\n    \"\"\"\n    # Split the input string into a list of words\n    words = input_string.split()\n\n    # Filter out any words that are shorter than 4 characters\n    long_words = [word for word in words if len(word) >= 4]\n\n    # Convert the list of long words into a set and return it\n    return set(long_words)"}
{"task_id": "Mbpp/8", "solution": "def square_nums(nums):\n    return [num ** 2 for num in nums]"}
{"task_id": "Mbpp/9", "solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if all(s[(j + i) % n] == s[j] for j in range(n)):\n            return i\n    return n"}
{"task_id": "Mbpp/11", "solution": "def remove_Occ(input_string, char_to_remove):\n    # Find the first occurrence of the character\n    first_occ = input_string.find(char_to_remove)\n\n    # If the character is not found, return the original string\n    if first_occ == -1:\n        return input_string\n\n    # Find the last occurrence of the character\n    last_occ = input_string.rfind(char_to_remove)\n\n    # If the first and last occurrences are the same, remove only that occurrence\n    if first_occ == last_occ:\n        return input_string[:first_occ] + input_string[first_occ+1:]\n\n    # Remove the first and last occurrences of the character\n    return input_string[:first_occ] + input_string[first_occ+1:last_occ] + input_string[last_occ+1:]"}
{"task_id": "Mbpp/12", "solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n\n    # Sort the matrix based on the sum of its rows\n    sorted_matrix = [x for _, x in sorted(zip(row_sums, matrix))]\n\n    return sorted_matrix"}
{"task_id": "Mbpp/14", "solution": "def find_Volume(base: float, height: float, depth: float) -> float:\n    \"\"\"\n    This function calculates the volume of a triangular prism.\n    It takes three parameters: base, height, and depth of the prism.\n    It returns the volume as a float.\n    \"\"\"\n    # Calculate the area of the base triangle\n    base_area = 0.5 * base * height\n\n    # Calculate the volume of the prism\n    volume = base_area * depth\n\n    return volume"}
{"task_id": "Mbpp/16", "solution": "def text_lowercase_underscore(input_string):\n    # Check if the first character is a lowercase letter\n    if not input_string[0].islower():\n        return False\n\n    # Iterate over the rest of the string\n    for i in range(1, len(input_string)):\n        # If the current character is an underscore, check that the next character is a lowercase letter\n        if input_string[i] == '_':\n            if i == len(input_string) - 1 or not input_string[i + 1].islower():\n                return False\n        # If the current character is not an underscore, check that it is a lowercase letter\n        elif not input_string[i].islower():\n            return False\n\n    # If we have made it through the entire string without returning False, then the string is valid\n    return True"}
{"task_id": "Mbpp/17", "solution": "def square_perimeter(side_length):\n    return 4 * side_length"}
{"task_id": "Mbpp/18", "solution": "def remove_dirty_chars(s1, s2):\n    return ''.join(char for char in s1 if char not in s2)"}
{"task_id": "Mbpp/19", "solution": "def test_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False"}
{"task_id": "Mbpp/20", "solution": "def is_woodall(n):\n    # A Woodall number is a number of the form n*2^n + 1 for some non-negative integer n.\n    # We will check if n can be expressed in this form.\n\n    # Start with n = 0\n    i = 0\n    while True:\n        # Calculate the Woodall number for the current value of i\n        woodall_number = i * (2 ** i) + 1\n\n        # If the Woodall number is equal to n, then n is a Woodall number\n        if woodall_number == n:\n            return True\n\n        # If the Woodall number is greater than n, then n is not a Woodall number\n        elif woodall_number > n:\n            return False\n\n        # If the Woodall number is less than n, then increment i and continue the loop\n        else:\n            i += 1"}
{"task_id": "Mbpp/56", "solution": "def check(n):\n    reverse_n = int(str(n)[::-1])\n    if n == 2 * reverse_n - 1:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/57", "solution": "def find_Max_Num(digits):\n    # Sort the digits in descending order\n    digits.sort(reverse=True)\n\n    # Concatenate the digits to form the largest possible number\n    largest_num = int(''.join(map(str, digits)))\n\n    return largest_num"}
{"task_id": "Mbpp/58", "solution": "def opposite_signs(num1, num2):\n    if (num1 >= 0 and num2 < 0) or (num1 < 0 and num2 >= 0):\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/59", "solution": "def is_octagonal(n):\n    # The nth octagonal number can be calculated using the formula: n * (5n - 3)\n    return n * (5 * n - 3)"}
{"task_id": "Mbpp/61", "solution": "def count_Substrings(s):\n    count = 0\n    n = len(s)\n\n    # Iterate through all possible substrings\n    for i in range(n):\n        for j in range(i, n):\n            substring = s[i:j+1]\n\n            # Check if the sum of digits is equal to the length of the substring\n            if sum(int(digit) for digit in substring) == len(substring):\n                count += 1\n\n    return count"}
{"task_id": "Mbpp/62", "solution": "def smallest_num(num_list):\n    if not num_list:\n        return None\n    smallest = num_list[0]\n    for num in num_list:\n        if num < smallest:\n            smallest = num\n    return smallest"}
{"task_id": "Mbpp/63", "solution": "def max_difference(tuples):\n    max_diff = float('-inf')\n    for t in tuples:\n        diff = abs(t[1] - t[0])\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff"}
{"task_id": "Mbpp/64", "solution": "def subject_marks(marks_list):\n    return sorted(marks_list, key=lambda x: x[1])"}
{"task_id": "Mbpp/65", "solution": "def recursive_list_sum(lst):\n    total = 0\n    for i in lst:\n        if type(i) == list:\n            total += recursive_list_sum(i)\n        else:\n            total += i\n    return total"}
{"task_id": "Mbpp/66", "solution": "def pos_count(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count"}
{"task_id": "Mbpp/67", "solution": "def bell_numbers(n):\n    \"\"\"Calculate Bell numbers up to n.\"\"\"\n    bell = [[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    return [bell[i][i] for i in range(n+1)]\n\ndef partition_bell_numbers(n):\n    \"\"\"Find the number of ways to partition a set of Bell numbers.\"\"\"\n    bell = bell_numbers(n)\n    partition = [0 for i in range(n+1)]\n    partition[0] = 1\n    partition[1] = 1\n    for i in range(2, n+1):\n        for j in range(i):\n            partition[i] += partition[j] * bell[i-j]\n    return partition[n]"}
{"task_id": "Mbpp/68", "solution": "def is_Monotonic(arr):\n    if len(arr) < 2:\n        return True\n\n    direction = arr[1] - arr[0]\n    for i in range(2, len(arr)):\n        if direction == 0:\n            direction = arr[i] - arr[i - 1]\n            if direction != 0:\n                break\n        elif (arr[i] - arr[i - 1]) * direction < 0:\n            return False\n    return True"}
{"task_id": "Mbpp/69", "solution": "def is_sublist(lst, sublst):\n    sublst_len = len(sublst)\n    for i in range(len(lst) - sublst_len + 1):\n        if lst[i:i+sublst_len] == sublst:\n            return True\n    return False"}
{"task_id": "Mbpp/70", "solution": "def get_equal(tuples_list):\n    \"\"\"\n    This function takes a list of tuples as input and returns True if all tuples have equal length,\n    otherwise it returns False.\n    \"\"\"\n    # Get the length of the first tuple\n    first_tuple_length = len(tuples_list[0])\n\n    # Iterate through each tuple in the list\n    for t in tuples_list:\n        # If the length of the current tuple is not equal to the length of the first tuple, return False\n        if len(t) != first_tuple_length:\n            return False\n\n    # If all tuples have the same length, return True\n    return True"}
{"task_id": "Mbpp/71", "solution": "def comb_sort(arr):\n    gap = len(arr)\n    shrink = 1.3\n    sorted = False\n\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n\n        i = 0\n        while i + gap < len(arr):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n            i += 1\n\n    return arr"}
{"task_id": "Mbpp/72", "solution": "def dif_Square(n):\n    i = 1\n    while i * i <= n:\n        j = 1\n        while j * j <= n:\n            if i * i - j * j == n:\n                return True\n            j += 1\n        i += 1\n    return False"}
{"task_id": "Mbpp/74", "solution": "def is_samepatterns(list1, list2):\n    if len(list1) != len(list2):\n        return False\n    pattern = {}\n    for i in range(len(list1)):\n        if list1[i] not in pattern:\n            pattern[list1[i]] = list2[i]\n        elif pattern[list1[i]] != list2[i]:\n            return False\n    return True"}
{"task_id": "Mbpp/75", "solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(i % k == 0 for i in t)]"}
{"task_id": "Mbpp/77", "solution": "def is_divisible_by_11(n):\n    # Convert the number to a string to easily iterate through its digits\n    num_str = str(n)\n\n    # Initialize the alternating sum of digits to 0\n    alt_sum = 0\n\n    # Iterate through the digits of the number\n    for i in range(len(num_str)):\n        # If the index is even, add the digit to the alternating sum\n        if i % 2 == 0:\n            alt_sum += int(num_str[i])\n        # If the index is odd, subtract the digit from the alternating sum\n        else:\n            alt_sum -= int(num_str[i])\n\n    # If the alternating sum is divisible by 11, then the original number is divisible by 11\n    return alt_sum % 11 == 0"}
{"task_id": "Mbpp/79", "solution": "def word_len(word):\n    # Calculate the length of the word\n    length = len(word)\n    # Check if the length is odd\n    if length % 2 == 1:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/80", "solution": "def tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6"}
{"task_id": "Mbpp/82", "solution": "import math\n\ndef volume_sphere(radius):\n    \"\"\"\n    Calculate the volume of a sphere given its radius.\n\n    The formula for the volume of a sphere is V = 4/3 * \u03c0 * r^3.\n    \"\"\"\n    volume = (4/3) * math.pi * (radius ** 3)\n    return volume"}
{"task_id": "Mbpp/83", "solution": "def get_Char(s):\n    ascii_sum = sum(ord(c) for c in s)\n    return chr((ascii_sum % 26) + 97)"}
{"task_id": "Mbpp/84", "solution": "def sequence(n):\n    # Initialize the sequence with the first two numbers\n    seq = [1, 1]\n\n    # Generate the sequence up to the nth number\n    while len(seq) < n:\n        # Find the next number in the sequence\n        next_num = 1\n        count = 1\n        for i in range(1, len(seq)):\n            if seq[i] == seq[-1]:\n                count += 1\n            else:\n                seq.append(count)\n                seq.append(seq[-1])\n                count = 1\n        seq.append(count)\n\n    # Return the nth number in the sequence\n    return seq[n - 1]"}
{"task_id": "Mbpp/85", "solution": "import math\n\ndef surfacearea_sphere(radius):\n    \"\"\"\n    Calculate the surface area of a sphere given its radius.\n\n    Parameters:\n    radius (float): The radius of the sphere.\n\n    Returns:\n    float: The surface area of the sphere.\n    \"\"\"\n    return 4 * math.pi * radius ** 2"}
{"task_id": "Mbpp/86", "solution": "def centered_hexagonal_number(n):\n    \"\"\"\n    Calculate the nth centered hexagonal number.\n\n    :param n: The index of the centered hexagonal number to calculate.\n    :return: The nth centered hexagonal number.\n    \"\"\"\n    return n * (2 * n - 1)"}
{"task_id": "Mbpp/87", "solution": "def merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = dict1.copy()\n    merged_dict.update(dict2)\n    merged_dict.update(dict3)\n    return merged_dict"}
{"task_id": "Mbpp/88", "solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict"}
{"task_id": "Mbpp/89", "solution": "def closest_num(n):\n    return n - 1\n\n# The function simply subtracts 1 from the input number to find the closest smaller number.\n# This is an efficient solution as it only requires a single subtraction operation, which has a time complexity of O(1).\n# The space complexity is also O(1) as no additional space is required.\n# This function assumes that the input number is a positive integer greater than 0.\n# If the input number is 0 or negative, the function will return a number that is 1 unit larger in magnitude.\n# If the input number is not an integer, the function will return the closest smaller integer."}
{"task_id": "Mbpp/90", "solution": "def len_log(words):\n    if not words:\n        return 0\n    max_length = len(words[0])\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length"}
{"task_id": "Mbpp/91", "solution": "def find_substring(string_list, substring):\n    for string in string_list:\n        if substring in string:\n            return True\n    return False"}
{"task_id": "Mbpp/92", "solution": "def is_undulating(n):\n    # Convert the number to a string\n    s = str(n)\n\n    # Check if the length of the string is even\n    if len(s) % 2 != 0:\n        return False\n\n    # Iterate over the string, checking if each pair of digits is undulating\n    for i in range(0, len(s), 2):\n        # Check if the pair of digits is not undulating\n        if s[i] == s[i + 1]:\n            return False\n\n    # If we've made it this far, the number is undulating\n    return True"}
{"task_id": "Mbpp/93", "solution": "def power(a, b):\n    result = 1\n    for i in range(b):\n        result *= a\n    return result"}
{"task_id": "Mbpp/94", "solution": "def index_minimum(tuples_list):\n    min_value = float('inf')\n    min_name = ''\n    for name, value in tuples_list:\n        if value < min_value:\n            min_value = value\n            min_name = name\n    return min_name"}
{"task_id": "Mbpp/95", "solution": "def Find_Min_Length(lst):\n    if not lst or not all(isinstance(i, list) for i in lst):\n        raise ValueError(\"Input should be a non-empty list of lists\")\n\n    min_length = float('inf')\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n\n    return min_length"}
{"task_id": "Mbpp/96", "solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count"}
{"task_id": "Mbpp/97", "solution": "def frequency_lists(lst):\n    # Flatten the list of lists\n    flat_list = [item for sublist in lst for item in sublist]\n\n    # Initialize an empty dictionary to store the frequency of each element\n    freq_dict = {}\n\n    # Iterate over the flattened list\n    for item in flat_list:\n        # If the item is already in the dictionary, increment its frequency\n        if item in freq_dict:\n            freq_dict[item] += 1\n        # Otherwise, add the item to the dictionary with a frequency of 1\n        else:\n            freq_dict[item] = 1\n\n    # Return the dictionary of frequencies\n    return freq_dict"}
{"task_id": "Mbpp/98", "solution": "def multiply_num(num_list):\n    if len(num_list) == 0:\n        return 0\n\n    product = 1\n    for num in num_list:\n        product *= num\n\n    return product / len(num_list)"}
{"task_id": "Mbpp/99", "solution": "def decimal_to_binary(n):\n    if n == 0:\n        return '0'\n    elif n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n\n    return binary"}
{"task_id": "Mbpp/100", "solution": "def next_smallest_palindrome(n):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    n -= 1\n    while n > 0:\n        if is_palindrome(n):\n            return n\n        n -= 1\n\n    return None"}
{"task_id": "Mbpp/101", "solution": "def kth_element(arr, k):\n    if 1 <= k <= len(arr):\n        return arr[k - 1]\n    else:\n        return None"}
{"task_id": "Mbpp/102", "solution": "def snake_to_camel(snake_str):\n    components = snake_str.split('_')\n    return components[0] + ''.join(x.title() for x in components[1:])\n\n# Test the function\nprint(snake_to_camel('python_program'))  # Expected output: 'PythonProgram'\nprint(snake_to_camel('python_language'))  # Expected output: 'PythonLanguage'\nprint(snake_to_camel('programming_language'))  # Expected output: 'ProgrammingLanguage'"}
{"task_id": "Mbpp/103", "solution": "def eulerian_num(n, m):\n    # Base cases\n    if n == 0 or m == 0 or m > n:\n        return 0\n    if n == 1 or m == 1:\n        return 1\n\n    # Recursive case\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)"}
{"task_id": "Mbpp/104", "solution": "def sort_sublists(lst):\n    \"\"\"\n    This function sorts each sublist of strings in a given list of lists.\n    \"\"\"\n    # Iterate over each sublist in the list\n    for sublist in lst:\n        # Sort the sublist in place\n        sublist.sort()\n    # Return the sorted list of lists\n    return lst"}
{"task_id": "Mbpp/105", "solution": "def count(lst):\n    return sum(1 for item in lst if item is True)"}
{"task_id": "Mbpp/106", "solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)"}
{"task_id": "Mbpp/108", "solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the first two lists\n    merged_list = merge(list1, list2)\n    # Merge the result with the third list\n    merged_list = merge(merged_list, list3)\n    return merged_list\n\ndef merge(list1, list2):\n    # Initialize an empty list to store the merged list\n    merged_list = []\n    # Initialize two pointers to traverse the two lists\n    i = j = 0\n    # Traverse both lists\n    while i < len(list1) and j < len(list2):\n        # If the current element of list1 is smaller, append it to the merged list\n        if list1[i] < list2[j]:\n            merged_list.append(list1[i])\n            i += 1\n        # Otherwise, append the current element of list2 to the merged list\n        else:\n            merged_list.append(list2[j])\n            j += 1\n    # If there are remaining elements in list1, append them to the merged list\n    while i < len(list1):\n        merged_list.append(list1[i])\n        i += 1\n    # If there are remaining elements in list2, append them to the merged list\n    while j < len(list2):\n        merged_list.append(list2[j])\n        j += 1\n    return merged_list"}
{"task_id": "Mbpp/109", "solution": "def odd_Equivalent(binary_string: str, rotations: int) -> int:\n    # Calculate the length of the binary string\n    length = len(binary_string)\n\n    # Calculate the effective number of rotations\n    # This is because rotating the string by 'length' times will result in the original string\n    rotations = rotations % length\n\n    # Initialize a counter for odd numbers\n    odd_count = 0\n\n    # Iterate over each digit in the binary string\n    for i in range(length):\n        # Calculate the index of the digit after rotation\n        rotated_index = (i + rotations) % length\n\n        # If the digit is '1' and its rotated index is odd, increment the counter\n        if binary_string[rotated_index] == '1' and rotated_index % 2 == 1:\n            odd_count += 1\n\n    # Return the final count of odd numbers\n    return odd_count"}
{"task_id": "Mbpp/111", "solution": "def common_in_nested_lists(nested_lists):\n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n\n    # Iterate over the remaining lists\n    for lst in nested_lists[1:]:\n        # Update the set with the intersection of the current set and the current list\n        common_elements.intersection_update(lst)\n\n    return common_elements"}
{"task_id": "Mbpp/113", "solution": "def check_integer(s):\n    try:\n        int(s)\n        return True\n    except ValueError:\n        return False"}
{"task_id": "Mbpp/115", "solution": "def empty_dict(lst):\n    for d in lst:\n        if d:\n            return False\n    return True"}
{"task_id": "Mbpp/116", "solution": "def tuple_to_int(tup):\n    # Convert each integer in the tuple to a string\n    str_list = [str(i) for i in tup]\n    # Concatenate the strings to form a single string\n    str_num = ''.join(str_list)\n    # Convert the string back to an integer and return it\n    return int(str_num)"}
{"task_id": "Mbpp/117", "solution": "def list_to_float(lst):\n    return [[float(i) for i in sublist] for sublist in lst]"}
{"task_id": "Mbpp/118", "solution": "def string_to_list(input_string):\n    # Split the input string on the space character and return the resulting list of strings\n    return input_string.split(' ')"}
{"task_id": "Mbpp/119", "solution": "def search(arr):\n    for i in range(0, len(arr)-1, 2):\n        if arr[i] != arr[i+1]:\n            return arr[i]\n    return arr[-1]\n\n# This function works by iterating over the array in steps of 2.\n# It compares each pair of elements and returns the first element of a pair that is not equal to its neighbor.\n# If no such element is found, it means that the last element is the one that appears only once, so it returns the last element."}
{"task_id": "Mbpp/120", "solution": "def max_product_tuple(tuples_list):\n    \"\"\"\n    Find the maximum absolute product between numbers in pairs of tuples within a given list.\n\n    Args:\n    tuples_list (list of tuples): A list of tuples, where each tuple contains two numbers.\n\n    Returns:\n    float: The maximum absolute product between numbers in pairs of tuples.\n    \"\"\"\n    max_product = float('-inf')\n\n    for tup in tuples_list:\n        product = abs(tup[0] * tup[1])\n        max_product = max(max_product, product)\n\n    return max_product"}
{"task_id": "Mbpp/123", "solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    This function calculates the sum of all amicable numbers up to a specified number.\n    An amicable number is a pair of two different numbers such that the sum of the proper divisors of each is equal to the other number.\n    \"\"\"\n    def proper_divisors_sum(num):\n        \"\"\"\n        This helper function calculates the sum of the proper divisors of a number.\n        \"\"\"\n        sum = 1\n        i = 2\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                if i * (num // i) == num:\n                    sum = sum + i + num//i\n                else:\n                    sum = sum + i\n                i += 1\n        return sum - num\n\n    total = 0\n    for i in range(2, n + 1):\n        j = proper_divisors_sum(i)\n        if i == proper_divisors_sum(j) and i != j:\n            total += i\n    return total"}
{"task_id": "Mbpp/124", "solution": "import cmath\n\ndef angle_complex(z):\n    # Use the cmath module's phase function to get the angle of the complex number\n    return cmath.phase(z)"}
{"task_id": "Mbpp/125", "solution": "def find_length(binary_string):\n    # Initialize prefix sum array\n    prefix_sum = [0] * len(binary_string)\n\n    # Calculate prefix sum\n    for i in range(len(binary_string)):\n        prefix_sum[i] = 1 if binary_string[i] == '1' else -1\n        if i > 0:\n            prefix_sum[i] += prefix_sum[i - 1]\n\n    # Initialize max_diff and min_prefix_sum\n    max_diff = 0\n    min_prefix_sum = 0\n\n    # Calculate max difference\n    for i in range(len(prefix_sum)):\n        max_diff = max(max_diff, prefix_sum[i] - min_prefix_sum)\n        min_prefix_sum = min(min_prefix_sum, prefix_sum[i])\n\n    return max_diff"}
{"task_id": "Mbpp/126", "solution": "def sum_of_common_divisors(num1, num2):\n    # Find the minimum of the two numbers\n    min_num = min(num1, num2)\n\n    # Initialize the sum of common divisors to 0\n    sum_divisors = 0\n\n    # Loop through all numbers up to the minimum number\n    for i in range(1, min_num + 1):\n        # If i is a divisor of both numbers, add it to the sum\n        if num1 % i == 0 and num2 % i == 0:\n            sum_divisors += i\n\n    # Return the sum of common divisors\n    return sum_divisors"}
{"task_id": "Mbpp/127", "solution": "def multiply_int(a: int, b: int) -> int:\n    \"\"\"\n    This function takes two integers as input and returns their product.\n    \"\"\"\n    return a * b\n\n# Test the function\nassert multiply_int(10,20)==200\nassert multiply_int(5,10)==50\nassert multiply_int(4,8)==32"}
{"task_id": "Mbpp/128", "solution": "def long_words(n, word_list):\n    # Split the word_list into individual words\n    words = word_list.split()\n\n    # Initialize an empty list to store the long words\n    long_words_list = []\n\n    # Iterate through the words\n    for word in words:\n        # If the length of the word is greater than n, add it to the long_words_list\n        if len(word) > n:\n            long_words_list.append(word)\n\n    # Return the list of long words\n    return long_words_list"}
{"task_id": "Mbpp/129", "solution": "def magic_square_test(matrix):\n    # Check if the matrix is a square matrix\n    if len(matrix) != len(matrix[0]):\n        return False\n\n    # Calculate the sum of the numbers in the first row\n    first_row_sum = sum(matrix[0])\n\n    # Calculate the sum of the numbers in all other rows\n    for row in matrix[1:]:\n        if sum(row) != first_row_sum:\n            return False\n\n    # Calculate the sum of the numbers in all columns\n    for col in range(len(matrix[0])):\n        col_sum = sum(matrix[row][col] for row in range(len(matrix)))\n        if col_sum != first_row_sum:\n            return False\n\n    # If all sums are equal, then the matrix is a magic square\n    return True"}
{"task_id": "Mbpp/130", "solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n\n    # Find the item with maximum frequency\n    max_freq = 0\n    max_item = None\n    for item, freq in freq_dict.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n\n    return max_item"}
{"task_id": "Mbpp/131", "solution": "def reverse_vowels(s):\n    vowels = set('aeiouAEIOU')\n    s = list(s)\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] not in vowels:\n            i += 1\n        elif s[j] not in vowels:\n            j -= 1\n        else:\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n    return ''.join(s)"}
{"task_id": "Mbpp/132", "solution": "def tup_string(tup):\n    return ''.join(tup)"}
{"task_id": "Mbpp/133", "solution": "def sum_negativenum(numbers):\n    sum_negative = 0\n    for num in numbers:\n        if num < 0:\n            sum_negative += num\n    return sum_negative"}
{"task_id": "Mbpp/135", "solution": "def hexagonal_num(n):\n    \"\"\"\n    Calculate the nth hexagonal number.\n\n    Parameters:\n    n (int): The position of the hexagonal number in the sequence.\n\n    Returns:\n    int: The nth hexagonal number.\n\n    Assumptions:\n    - n is a positive integer.\n\n    Limitations:\n    - This function does not handle non-positive integers or non-integer inputs.\n    \"\"\"\n    return n * (2 * n - 1)"}
{"task_id": "Mbpp/137", "solution": "def zero_count(arr):\n    zeroes = 0\n    non_zeroes = 0\n\n    for num in arr:\n        if num == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n\n    return zeroes / len(arr)"}
{"task_id": "Mbpp/138", "solution": "def is_Sum_Of_Powers_Of_Two(n):\n    # If n is 0, it cannot be represented as a sum of non-zero powers of 2\n    if n == 0:\n        return False\n\n    # Iterate through the powers of 2, starting from the largest possible power\n    i = 0\n    while 2 ** i <= n:\n        # If n is a power of 2, return True\n        if 2 ** i == n:\n            return True\n        # If n is greater than the current power of 2, subtract it from n\n        elif 2 ** i < n:\n            n -= 2 ** i\n        # If n is less than the current power of 2, move on to the next power\n        i += 1\n\n    # If n is not 0 at this point, it cannot be represented as a sum of non-zero powers of 2\n    return False"}
{"task_id": "Mbpp/139", "solution": "import math\n\ndef circle_circumference(radius):\n    return 2 * math.pi * radius"}
{"task_id": "Mbpp/140", "solution": "def extract_singly(lst):\n    # Initialize an empty set to store the numbers\n    num_set = set()\n\n    # Iterate through each sublist in the list\n    for sublist in lst:\n        # Iterate through each number in the sublist\n        for num in sublist:\n            # Add the number to the set\n            num_set.add(num)\n\n    # Return the set of numbers\n    return num_set"}
{"task_id": "Mbpp/141", "solution": "def pancake_sort(arr):\n    def flip(k):\n        i = 0\n        while i < k // 2:\n            arr[i], arr[k - i - 1] = arr[k - i - 1], arr[i]\n            i += 1\n\n    for i in range(len(arr), 1, -1):\n        max_idx = arr.index(max(arr[:i]))\n        if max_idx != i - 1:\n            flip(max_idx + 1)\n            flip(i)\n\n    return arr"}
{"task_id": "Mbpp/142", "solution": "def count_samepair(list1, list2, list3):\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    return count"}
{"task_id": "Mbpp/143", "solution": "def find_lists(t):\n    count = 0\n    for i in t:\n        if isinstance(i, list):\n            count += 1\n    return count"}
{"task_id": "Mbpp/145", "solution": "def max_Abs_Diff(arr):\n    # Find the minimum and maximum elements in the array\n    min_elem = min(arr)\n    max_elem = max(arr)\n\n    # Return the maximum difference between any two elements\n    return max_elem - min_elem"}
{"task_id": "Mbpp/160", "solution": "def find_solution(a, b, n):\n    # Iterate through all possible values of x\n    for x in range(n // a + 1):\n        # Check if y is an integer\n        if (n - a * x) % b == 0:\n            y = (n - a * x) // b\n            return (x, y)\n    # If no solution is found, return None\n    return None"}
{"task_id": "Mbpp/161", "solution": "def remove_elements(list1, list2):\n    return [element for element in list1 if element not in list2]"}
{"task_id": "Mbpp/162", "solution": "def sum_series(n):\n    total = 0\n    for i in range(0, n // 2 + 1):\n        total += (n - 2 * i)\n    return total\n\n# Test cases\nassert sum_series(0) == 0\nassert sum_series(6) == 12\nassert sum_series(10) == 30\nassert sum_series(9) == 25"}
{"task_id": "Mbpp/164", "solution": "def sum_of_divisors(n):\n    divisors_sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisors_sum += i\n    return divisors_sum\n\ndef are_equivalent(num1, num2):\n    return sum_of_divisors(num1) == sum_of_divisors(num2)"}
{"task_id": "Mbpp/165", "solution": "def count_char_position(s):\n    s = s.lower()\n    count = 0\n    for i in range(len(s)):\n        if ord(s[i]) - 97 == i:\n            count += 1\n    return count\n\nprint(count_char_position(\"xbcefg\"))\nprint(count_char_position(\"ABcED\"))\nprint(count_char_position(\"AbgdeF\"))"}
{"task_id": "Mbpp/166", "solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count"}
{"task_id": "Mbpp/167", "solution": "def next_power_of_2(n):\n    # If n is 0, return 1 as the smallest power of 2\n    if n == 0:\n        return 1\n\n    # Initialize power of 2 to 1\n    power = 1\n\n    # Keep doubling power until it becomes greater than or equal to n\n    while power < n:\n        power <<= 1\n\n    # Return the power of 2\n    return power"}
{"task_id": "Mbpp/168", "solution": "def frequency(num_list, target):\n    count = 0\n    for num in num_list:\n        if num == target:\n            count += 1\n    return count"}
{"task_id": "Mbpp/170", "solution": "def sum_range_list(numbers, start, end):\n    # Check if the start and end indices are within the list bounds\n    if start < 0 or end >= len(numbers) or start > end:\n        return \"Invalid indices\"\n\n    # Calculate the sum of numbers within the specified range\n    return sum(numbers[start:end+1])\n\n# Test cases\nprint(sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 8, 10))  # Output: 29\nprint(sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 5, 7))  # Output: 16\nprint(sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 7, 10))  # Output: 38"}
{"task_id": "Mbpp/171", "solution": "def perimeter_pentagon(side_length):\n    \"\"\"\n    This function calculates the perimeter of a regular pentagon given the length of its sides.\n\n    Parameters:\n    side_length (int or float): The length of one side of the pentagon.\n\n    Returns:\n    int or float: The perimeter of the pentagon.\n    \"\"\"\n    # A regular pentagon has 5 sides, so the perimeter is the side length multiplied by 5.\n    perimeter = side_length * 5\n    return perimeter"}
{"task_id": "Mbpp/172", "solution": "def count_occurrence(input_string):\n    \"\"\"\n    This function counts the number of occurrences of the string 'std' in a given string.\n\n    :param input_string: The string in which to count the occurrences of 'std'.\n    :return: The number of occurrences of 'std' in the input string.\n    \"\"\"\n    # Initialize a counter for the occurrences of 'std'\n    count = 0\n\n    # Iterate over the input string, checking each substring of length 3\n    for i in range(len(input_string) - 2):\n        if input_string[i:i+3] == 'std':\n            # If the substring is 'std', increment the counter\n            count += 1\n\n    # Return the final count\n    return count"}
{"task_id": "Mbpp/222", "solution": "def check_type(t):\n    first_type = type(t[0])\n    for i in t:\n        if type(i) != first_type:\n            return False\n    return True"}
{"task_id": "Mbpp/223", "solution": "def is_majority(arr, n, element):\n    # Find the first and last occurrences of the element in the array\n    def find_first(arr, n, element):\n        low = 0\n        high = n - 1\n        while low <= high:\n            mid = low + (high - low) // 2\n            if (mid == 0 or element > arr[mid - 1]) and arr[mid] == element:\n                return mid\n            elif element > arr[mid]:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return -1\n\n    def find_last(arr, n, element):\n        low = 0\n        high = n - 1\n        while low <= high:\n            mid = low + (high - low) // 2\n            if (mid == n - 1 or element < arr[mid + 1]) and arr[mid] == element:\n                return mid\n            elif element < arr[mid]:\n                high = mid - 1\n            else:\n                low = mid + 1\n        return -1\n\n    first = find_first(arr, n, element)\n    last = find_last(arr, n, element)\n\n    # If the element is not present in the array, return False\n    if first == -1 and last == -1:\n        return False\n\n    # If the difference between the last and first occurrences is greater than n/2, return True\n    if last - first + 1 > n // 2:\n        return True\n\n    return False"}
{"task_id": "Mbpp/224", "solution": "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"}
{"task_id": "Mbpp/226", "solution": "def odd_values_string(s):\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])"}
{"task_id": "Mbpp/227", "solution": "def min_of_three(a, b, c):\n    return min(a, min(b, c))\n\n# Test cases\nassert min_of_three(10,20,0)==0\nassert min_of_three(19,15,18)==15\nassert min_of_three(-10,-20,-30)==-30"}
{"task_id": "Mbpp/229", "solution": "def re_arrange_array(arr, n):\n    # Separate negative and positive elements\n    negatives = [x for x in arr[:n] if x < 0]\n    positives = [x for x in arr[:n] if x >= 0]\n\n    # Combine negative and positive elements while preserving order\n    rearranged = negatives + positives\n\n    # Replace the first n elements of the original array with the rearranged elements\n    arr[:n] = rearranged\n\n    return arr"}
{"task_id": "Mbpp/230", "solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    This function takes in a string and a character, replaces blank spaces in the string with the character, and returns the string.\n\n    Parameters:\n    input_string (str): The input string.\n    replacement_char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)"}
{"task_id": "Mbpp/232", "solution": "def larg_nnum(lst, n):\n    \"\"\"\n    This function takes in a list and an integer n and returns a list containing the n largest items from the list.\n\n    Parameters:\n    lst (list): The input list of numbers.\n    n (int): The number of largest items to return.\n\n    Returns:\n    list: A list containing the n largest items from the input list.\n    \"\"\"\n    # Sort the list in descending order\n    sorted_lst = sorted(lst, reverse=True)\n\n    # Return the first n elements from the sorted list\n    return sorted_lst[:n]"}
{"task_id": "Mbpp/233", "solution": "import math\n\ndef lateralsurface_cylinder(radius, height):\n    # Derive the formula for calculating the lateral surface area of a cylinder\n    lateral_surface_area = 2 * math.pi * radius * height\n\n    # Return the calculated lateral surface area\n    return lateral_surface_area"}
{"task_id": "Mbpp/234", "solution": "def volume_cube(side_length):\n    return side_length ** 3\n\n# Test the function\nassert volume_cube(3) == 27\nassert volume_cube(2) == 8\nassert volume_cube(5) == 125"}
{"task_id": "Mbpp/235", "solution": "def even_bit_set_number(n):\n    # Create a mask with all even bits set to 1 and all odd bits set to 0\n    mask = 0xAAAAAAAA\n    # Use bitwise OR operator to set all even bits of the number\n    result = n | mask\n    return result"}
{"task_id": "Mbpp/237", "solution": "def check_occurrences(tuples_list):\n    occurrences = {}\n    for t in tuples_list:\n        if t in occurrences:\n            occurrences[t] += 1\n        else:\n            occurrences[t] = 1\n    return occurrences"}
{"task_id": "Mbpp/238", "solution": "def number_of_substrings(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i:j] != \"\":\n                count += 1\n    return count\n\n# The function number_of_substrings takes a string s as input. It initializes a counter variable count to 0. It then iterates through the string using two nested loops. The outer loop iterates through each character in the string, and the inner loop iterates through each possible substring that starts at the current character of the outer loop. If the substring is not empty, the counter is incremented. Finally, the function returns the counter, which represents the total number of non-empty substrings in the input string."}
{"task_id": "Mbpp/239", "solution": "def get_total_number_of_sequences(m, n):\n    # Create a 2D array to store the number of possible sequences\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    # Initialize the base case: there is 1 possible sequence of length 1\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n\n    # Fill in the rest of the array using dynamic programming\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(j // 2, j):\n                dp[i][j] += dp[i - 1][k]\n\n    # Return the number of possible sequences of length n\n    return dp[n][m]"}
{"task_id": "Mbpp/240", "solution": "def replace_list(list1, list2):\n    # Remove the last element of the first list\n    list1.pop()\n    # Extend the first list with the elements of the second list\n    list1.extend(list2)\n    # Return the modified first list\n    return list1"}
{"task_id": "Mbpp/242", "solution": "def count_charac(input_string):\n    count = 0\n    for char in input_string:\n        count += 1\n    return count\n\n# Test cases\nassert count_charac(\"python programming\") == 18\nassert count_charac(\"language\") == 8\nassert count_charac(\"words\") == 5"}
{"task_id": "Mbpp/244", "solution": "import math\n\ndef next_Perfect_Square(n):\n    \"\"\"\n    This function takes a number as input and returns the next perfect square greater than that number.\n    \"\"\"\n    # Find the square root of the number and round it up to the nearest integer\n    root = math.isqrt(n) + 1\n\n    # Calculate the next perfect square\n    next_square = root * root\n\n    return next_square"}
{"task_id": "Mbpp/245", "solution": "def max_sum(arr):\n    n = len(arr)\n    # Initialize arrays for storing increasing and decreasing subsequence sums\n    inc = [0 for _ in range(n)]\n    dec = [0 for _ in range(n)]\n\n    # Calculate increasing subsequence sums\n    inc[0] = arr[0]\n    for i in range(1, n):\n        inc[i] = max(inc[j] for j in range(i) if arr[j] < arr[i]) + arr[i]\n\n    # Calculate decreasing subsequence sums\n    dec[n - 1] = arr[n - 1]\n    for i in range(n - 2, -1, -1):\n        dec[i] = max(dec[j] for j in range(i, n) if arr[j] < arr[i]) + arr[i]\n\n    # Calculate bitonic subsequence sums and return the maximum\n    return max(inc[i] + dec[i] - arr[i] for i in range(n))"}
{"task_id": "Mbpp/247", "solution": "def lps(s):\n    n = len(s)\n    # Create a table to store lengths of longest palindromic subsequences of substrings\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n\n    # Strings of length 1 are palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n\n    # Build the table. Note that the lower diagonal values of table are useless and not filled in the process\n    for cl in range(2, n+1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if s[i] == s[j] and cl == 2:\n                dp[i][j] = 2\n            elif s[i] == s[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n\n    return dp[0][n-1]"}
{"task_id": "Mbpp/249", "solution": "def intersection_array(arr1, arr2):\n    # Convert the arrays to sets\n    set1 = set(arr1)\n    set2 = set(arr2)\n\n    # Find the intersection of the sets\n    intersection = set1 & set2\n\n    # Convert the intersection set back to a list\n    result = list(intersection)\n\n    return result"}
{"task_id": "Mbpp/250", "solution": "def count_X(tup, element):\n    count = 0\n    for i in tup:\n        if i == element:\n            count += 1\n    return count"}
{"task_id": "Mbpp/251", "solution": "def insert_element(lst, element):\n    result = []\n    for i in lst:\n        result.append(element)\n        result.append(i)\n    return result"}
{"task_id": "Mbpp/252", "solution": "import cmath\n\ndef convert(complex_number):\n    # cmath.phase returns the phase of the complex number in radians\n    # abs(complex_number) returns the magnitude of the complex number\n    return abs(complex_number), cmath.phase(complex_number)"}
{"task_id": "Mbpp/253", "solution": "def count_integer(lst):\n    count = 0\n    for i in lst:\n        if isinstance(i, int):\n            count += 1\n    return count"}
{"task_id": "Mbpp/255", "solution": "def combinations_colors(lst, n):\n    if n == 0:\n        return [()]\n    elif n == 1:\n        return [(i,) for i in lst]\n    else:\n        result = []\n        for i in range(len(lst)):\n            for j in combinations_colors(lst, n-1):\n                result.append((lst[i],) + j)\n        return result"}
{"task_id": "Mbpp/256", "solution": "def count_primes_nums(n):\n    # Create a boolean array \"prime[0..n]\" and initialize all entries as true.\n    # A value in prime[i] will finally be false if i is Not a prime, else true.\n    prime = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        # If prime[p] is not changed, then it is a prime\n        if (prime[p] == True):\n            # Update all multiples of p\n            for i in range(p * p, n+1, p):\n                prime[i] = False\n        p += 1\n\n    # Return the count of prime numbers\n    return sum(prime[2:])"}
{"task_id": "Mbpp/257", "solution": "def swap_numbers(num1, num2):\n    return (num2, num1)"}
{"task_id": "Mbpp/259", "solution": "def maximize_elements(tuple1, tuple2):\n    # Sort both tuples based on the first element of each tuple\n    tuple1 = sorted(tuple1, key=lambda x: x[0])\n    tuple2 = sorted(tuple2, key=lambda x: x[0])\n\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over the tuples\n    for t1, t2 in zip(tuple1, tuple2):\n        # Choose the tuple with the larger second element\n        result.append(max(t1, t2, key=lambda x: x[1]))\n\n    # Return the result as a tuple\n    return tuple(result)"}
{"task_id": "Mbpp/260", "solution": "def newman_prime(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_newman_prime(num):\n        if not is_prime(num):\n            return False\n        for i in range(2, num):\n            if is_prime(i) and is_prime((num - i) // 2):\n                return True\n        return False\n\n    count = 0\n    num = 2\n    while count < n:\n        if is_newman_prime(num):\n            count += 1\n        num += 1\n    return num - 1"}
{"task_id": "Mbpp/261", "solution": "def division_elements(tuple1, tuple2):\n    # Check if the tuples have the same length\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Both tuples must have the same length\")\n\n    # Perform division operation element-wise\n    result = tuple(a / b for a, b in zip(tuple1, tuple2))\n\n    return result"}
{"task_id": "Mbpp/262", "solution": "def split_two_parts(lst, L):\n    return (lst[:L], lst[L:])"}
{"task_id": "Mbpp/264", "solution": "def dog_age(dog_years):\n    if dog_years < 0:\n        raise ValueError(\"Dog's age cannot be negative\")\n    elif dog_years <= 2:\n        human_years = dog_years * 10.5\n    else:\n        human_years = 21 + (dog_years - 2) * 4\n    return int(human_years)"}
{"task_id": "Mbpp/265", "solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]"}
{"task_id": "Mbpp/266", "solution": "def lateralsurface_cube(side):\n    return 6 * side ** 2"}
{"task_id": "Mbpp/267", "solution": "def square_sum(n):\n    sum = 0\n    for i in range(1, 2*n, 2):\n        sum += i**2\n    return sum\n\nprint(square_sum(2))  # Output: 10\nprint(square_sum(3))  # Output: 35\nprint(square_sum(4))  # Output: 84"}
{"task_id": "Mbpp/268", "solution": "def find_star_num(n):\n    \"\"\"\n    Calculate the n'th star number based on the pattern.\n\n    The pattern is not explicitly defined in the problem statement,\n    so this function assumes that the n'th star number is calculated\n    as 13 * n^2 - 7 * n + 2.\n\n    This is a placeholder function and may need to be adjusted based\n    on the actual pattern of star numbers.\n    \"\"\"\n    return 13 * n**2 - 7 * n + 2"}
{"task_id": "Mbpp/269", "solution": "def ascii_value(char):\n    return ord(char)"}
{"task_id": "Mbpp/270", "solution": "def sum_even_and_even_index(lst):\n    total = 0\n    for i in range(len(lst)):\n        if i % 2 == 0 and lst[i] % 2 == 0:\n            total += lst[i]\n    return total"}
{"task_id": "Mbpp/271", "solution": "def even_Power_Sum(n):\n    total = 0\n    for i in range(n):\n        num = 2 * (i + 1)\n        total += num ** 5\n    return total\n\n# Test cases\nassert even_Power_Sum(2) == 1056\nassert even_Power_Sum(3) == 8832\nassert even_Power_Sum(1) == 32"}
{"task_id": "Mbpp/272", "solution": "def rear_extract(tuples_list):\n    return [t[-1] for t in tuples_list]"}
{"task_id": "Mbpp/273", "solution": "def subtract_elements(tuple1, tuple2):\n    return tuple(x - y for x, y in zip(tuple1, tuple2))"}
{"task_id": "Mbpp/274", "solution": "from math import factorial\n\ndef even_binomial_Coeff_Sum(n):\n    def binomial_coeff(n, k):\n        return factorial(n) // (factorial(k) * factorial(n - k))\n\n    return sum(binomial_coeff(n, k) for k in range(0, n + 1, 2))"}
{"task_id": "Mbpp/276", "solution": "def volume_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder given its radius and height.\n\n    Parameters:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The volume of the cylinder.\n    \"\"\"\n    return math.pi * radius ** 2 * height"}
{"task_id": "Mbpp/277", "solution": "def dict_filter(dictionary, n):\n    return {key: value for key, value in dictionary.items() if value >= n}"}
{"task_id": "Mbpp/278", "solution": "def count_first_elements(tup):\n    count = 0\n    for element in tup:\n        if element == (4, 6):\n            break\n        count += 1\n    return count"}
{"task_id": "Mbpp/279", "solution": "def is_num_decagonal(n):\n    return 3 * n * n - 2 * n\n\n# The nth decagonal number can be calculated using the formula: n * (3n - 2)\n# This function takes an integer n as input and returns the nth decagonal number."}
{"task_id": "Mbpp/280", "solution": "def sequential_search(arr, element):\n    for i in range(len(arr)):\n        if arr[i] == element:\n            return (True, i)\n    return (False, -1)"}
{"task_id": "Mbpp/281", "solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))"}
{"task_id": "Mbpp/282", "solution": "def sub_list(list1, list2):\n    if len(list1) != len(list2):\n        raise ValueError(\"Both lists must have the same length\")\n    return [a - b for a, b in zip(list1, list2)]"}
{"task_id": "Mbpp/283", "solution": "def validate(n):\n    # Create a dictionary to store the frequency of each digit\n    freq = {}\n\n    # Iterate through each digit in the integer\n    for digit in str(n):\n        # If the digit is not in the dictionary, add it with a frequency of 1\n        if digit not in freq:\n            freq[digit] = 1\n        # If the digit is already in the dictionary, increment its frequency\n        else:\n            freq[digit] += 1\n\n        # If the frequency of the digit is greater than the digit itself, return False\n        if freq[digit] > int(digit):\n            return False\n\n    # If we've made it through all the digits without returning False, return True\n    return True"}
{"task_id": "Mbpp/284", "solution": "def check_element(lst, element):\n    for item in lst:\n        if item != element:\n            return False\n    return True"}
{"task_id": "Mbpp/285", "solution": "def text_match_two_three(s):\n    if 'a' in s:\n        a_index = s.index('a')\n        if a_index + 2 < len(s) and s[a_index+1:a_index+3] == 'bb':\n            return True\n        if a_index + 3 < len(s) and s[a_index+1:a_index+4] == 'bbb':\n            return True\n    return False"}
{"task_id": "Mbpp/286", "solution": "def max_sub_array_sum_repeated(arr, n, k):\n    # Calculate the sum of the array\n    arr_sum = sum(arr)\n\n    # If the sum is negative, the maximum sum is the maximum element in the array\n    if arr_sum < 0:\n        return max(arr)\n\n    # If the sum is positive, the maximum sum is the sum of the array times k\n    # If k is greater than 1, we need to consider the case where the maximum sum is achieved by wrapping around the array\n    # To do this, we calculate the maximum sum of a subarray that does not wrap around the array, and the maximum sum of a subarray that does wrap around the array\n    # The maximum sum is the maximum of these two values\n    else:\n        # Calculate the maximum sum of a subarray that does not wrap around the array\n        max_so_far = 0\n        max_ending_here = 0\n        for i in range(n * k):\n            max_ending_here = max(0, max_ending_here + arr[i % n])\n            max_so_far = max(max_so_far, max_ending_here)\n\n        # Calculate the maximum sum of a subarray that does wrap around the array\n        max_wrap_around = arr_sum * (k - 2) + max(0, max_ending_here - arr_sum)\n\n        return max(max_so_far, max_wrap_around)"}
{"task_id": "Mbpp/287", "solution": "def square_sum(n):\n    # Initialize the sum to 0\n    sum = 0\n    # Loop through the first n even natural numbers\n    for i in range(2, 2*n + 1, 2):\n        # Add the square of the current number to the sum\n        sum += i**2\n    # Return the sum\n    return sum"}
{"task_id": "Mbpp/290", "solution": "def max_length(lists):\n    max_len = 0\n    max_list = []\n\n    for lst in lists:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n\n    return max_len, max_list"}
{"task_id": "Mbpp/292", "solution": "def find_quotient(dividend, divisor):\n    \"\"\"\n    This function takes two integer arguments, dividend and divisor,\n    and returns the quotient of the division rounded down to the nearest integer.\n    \"\"\"\n    # Check that the divisor is not zero to avoid division by zero error\n    assert divisor != 0, \"Divisor cannot be zero\"\n\n    # Use integer division to get the quotient rounded down to the nearest integer\n    quotient = dividend // divisor\n\n    return quotient"}
{"task_id": "Mbpp/293", "solution": "import math\n\ndef otherside_rightangle(a, b):\n    \"\"\"\n    This function calculates the length of the third side of a right-angled triangle\n    given the lengths of the other two sides (a and b).\n\n    Parameters:\n    a (float): The length of one side of the triangle.\n    b (float): The length of the other side of the triangle.\n\n    Returns:\n    float: The length of the third side of the triangle.\n    \"\"\"\n    # Using the Pythagorean theorem to calculate the length of the third side\n    c = math.sqrt(a**2 + b**2)\n    return c"}
{"task_id": "Mbpp/294", "solution": "def max_val(lst):\n    max_value = float('-inf')\n    for item in lst:\n        if isinstance(item, int):\n            max_value = max(max_value, item)\n    return max_value"}
{"task_id": "Mbpp/295", "solution": "def sum_div(n):\n    divisors = [i for i in range(1, n + 1) if n % i == 0]\n    return sum(divisors)"}
{"task_id": "Mbpp/296", "solution": "def get_Inv_Count(arr):\n    # Helper function to merge two sorted subarrays and count inversions\n    def merge_sort_and_count(left, right):\n        i = j = k = 0\n        inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n                inv_count += len(left) - i\n            k += 1\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n        return inv_count\n\n    # Divide-and-conquer approach to count inversions\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return 0\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n        inv_count = merge_sort(left) + merge_sort(right)\n        inv_count += merge_sort_and_count(left, right)\n        return inv_count\n\n    return merge_sort(arr)"}
{"task_id": "Mbpp/297", "solution": "def flatten_list(nested_list):\n    # Initialize an empty list to store the flattened list\n    flattened_list = []\n\n    # Iterate through each element in the input list\n    for element in nested_list:\n        # Check if the element is a list\n        if isinstance(element, list):\n            # If it is a list, recursively apply the flattening process to that list\n            flattened_list.extend(flatten_list(element))\n        else:\n            # If it is not a list, add it to the flattened list\n            flattened_list.append(element)\n\n    # Return the flattened list\n    return flattened_list"}
{"task_id": "Mbpp/299", "solution": "def max_aggregate(scores):\n    # Create a dictionary to store the aggregate scores\n    aggregate_scores = {}\n\n    # Iterate through the list of tuples\n    for name, score in scores:\n        # If the name is already in the dictionary, add the score to the existing total\n        if name in aggregate_scores:\n            aggregate_scores[name] += score\n        # If the name is not in the dictionary, add it with the current score\n        else:\n            aggregate_scores[name] = score\n\n    # Find the name with the highest aggregate score\n    max_score = max(aggregate_scores.values())\n    max_name = [name for name, score in aggregate_scores.items() if score == max_score]\n\n    # Return the name with the highest aggregate score\n    return max_name[0], max_score"}
{"task_id": "Mbpp/300", "solution": "def count_binary_seq(n):\n    # Initialize a 2D array to store the count of binary sequences\n    dp = [[0 for _ in range(2 * n + 1)] for _ in range(n + 1)]\n\n    # Base case: when n = 0, there is only one binary sequence (an empty sequence)\n    dp[0][0] = 1\n\n    # Iterate over the length of the binary sequence\n    for i in range(1, n + 1):\n        # Iterate over the possible sums of the first n bits\n        for j in range(0, 2 * n + 1):\n            # If the current sum is greater than or equal to 1,\n            # add the count of binary sequences with sum j - 1 in the previous length\n            if j >= 1:\n                dp[i][j] += dp[i - 1][j - 1]\n            # Add the count of binary sequences with sum j in the previous length\n            dp[i][j] += dp[i - 1][j]\n\n    # The count of binary sequences with sum 0 in the first n bits is equal to\n    # the count of binary sequences with sum 0 in the last n bits\n    return dp[n][0] ** 2"}
{"task_id": "Mbpp/301", "solution": "def dict_depth(dictionary):\n    if isinstance(dictionary, dict):\n        return 1 + (max(map(dict_depth, dictionary.values()))\n                     if dictionary else 0)\n    return 0"}
{"task_id": "Mbpp/305", "solution": "def start_withp(words):\n    result = []\n    for word in words:\n        if word[0].lower() == 'p':\n            result.append(word)\n        if len(result) == 2:\n            return tuple(result)\n    return None"}
{"task_id": "Mbpp/306", "solution": "def max_sum_increasing_subseq(nums, n, k, i):\n    dp = [0] * n\n    dp[0] = nums[0]\n    max_sum = nums[0]\n\n    for j in range(1, n):\n        dp[j] = nums[j]\n        for l in range(j):\n            if nums[l] < nums[j] and dp[l] + nums[j] > dp[j]:\n                dp[j] = dp[l] + nums[j]\n        if j == k:\n            dp[j] += nums[i]\n        max_sum = max(max_sum, dp[j])\n\n    return max_sum"}
{"task_id": "Mbpp/308", "solution": "def large_product(list1, list2, n):\n    # Sort both lists in descending order\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n\n    # Initialize an empty list to store the products\n    products = []\n\n    # Loop through the first n elements of both lists\n    for i in range(n):\n        # Multiply the ith element of list1 with the ith element of list2\n        # and append the result to the products list\n        products.append(list1[i] * list2[i])\n\n    # Return the products list\n    return products"}
{"task_id": "Mbpp/309", "solution": "def maximum(a, b):\n    if a > b:\n        return a\n    else:\n        return b"}
{"task_id": "Mbpp/310", "solution": "def string_to_tuple(s):\n    return tuple(s)\n\n# Test cases\nassert string_to_tuple(\"python 3.0\")==('p', 'y', 't', 'h', 'o', 'n', ' ', '3', '.', '0')\nassert string_to_tuple(\"item1\")==('i', 't', 'e', 'm', '1')\nassert string_to_tuple(\"15.10\")==('1', '5', '.', '1', '0')"}
{"task_id": "Mbpp/311", "solution": "def set_left_most_unset_bit(n):\n    # Find the position of the leftmost unset bit\n    pos = 0\n    m = 1\n    while (n & m) > 0:\n        pos += 1\n        m <<= 1\n\n    # Set the leftmost unset bit\n    return n | (1 << pos)"}
{"task_id": "Mbpp/312", "solution": "def volume_cone(radius, height):\n    \"\"\"\n    This function calculates the volume of a cone given its radius and height.\n    The formula for the volume of a cone is (1/3) * \u03c0 * r^2 * h, where r is the radius and h is the height.\n    \"\"\"\n    volume = (1/3) * math.pi * radius**2 * height\n    return volume"}
{"task_id": "Mbpp/388", "solution": "def highest_Power_of_2(n):\n    power = 0\n    while (2 ** power <= n):\n        power += 1\n    return 2 ** (power - 1)"}
{"task_id": "Mbpp/389", "solution": "def find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        lucas_sequence = [2, 1]\n        for i in range(2, n+1):\n            lucas_sequence.append(lucas_sequence[i-1] + lucas_sequence[i-2])\n        return lucas_sequence[n]"}
{"task_id": "Mbpp/390", "solution": "def add_string(lst, format_str):\n    return [format_str.format(i) for i in lst]"}
{"task_id": "Mbpp/391", "solution": "def convert_list_dictionary(keys, values1, values2):\n    return [{key: {value1: value2}} for key, value1, value2 in zip(keys, values1, values2)]"}
{"task_id": "Mbpp/392", "solution": "def get_max_sum(n):\n    # Initialize a list to store the maximum sum for each number up to n\n    max_sum = [0] * (n + 1)\n\n    # Iterate through each number up to n\n    for i in range(1, n + 1):\n        # Calculate the maximum sum for the current number\n        max_sum[i] = max(max_sum[i // 2] + max_sum[i // 3] + max_sum[i // 4] + max_sum[i // 5], i)\n\n    # Return the maximum sum for n\n    return max_sum[n]"}
{"task_id": "Mbpp/394", "solution": "def check_distinct(input_tuple):\n    # Convert the tuple to a set\n    input_set = set(input_tuple)\n\n    # If the length of the set is equal to the length of the tuple,\n    # it means that all elements in the tuple are distinct\n    if len(input_set) == len(input_tuple):\n        return True\n    else:\n        return False\n\n# Test cases\n# print(check_distinct((1, 4, 5, 6, 1, 4))) # Expected output: False\n# print(check_distinct((1, 4, 5, 6))) # Expected output: True\n# print(check_distinct((2, 3, 4, 5, 6))) # Expected output: True"}
{"task_id": "Mbpp/395", "solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    char_freq = {}\n    for char in s:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n    # Iterate through the string again to find the first character with a frequency of 1\n    for char in s:\n        if char_freq[char] == 1:\n            return char\n\n    # If no non-repeated character is found, return None\n    return None"}
{"task_id": "Mbpp/396", "solution": "def check_char(s):\n    if len(s) < 2:\n        return True\n    else:\n        return s[0] == s[-1]"}
{"task_id": "Mbpp/397", "solution": "def median_numbers(a, b, c):\n    numbers = [a, b, c]\n    numbers.sort()\n    return numbers[1]"}
{"task_id": "Mbpp/398", "solution": "def sum_of_digits(numbers):\n    total_sum = 0\n    for number in numbers:\n        if isinstance(number, int) and number >= 0:\n            while number > 0:\n                total_sum += number % 10\n                number //= 10\n    return total_sum"}
{"task_id": "Mbpp/400", "solution": "def extract_freq(tuples_list):\n    # Convert the list to a set to remove duplicates\n    unique_tuples = set(tuples_list)\n    # Return the number of unique tuples\n    return len(unique_tuples)"}
{"task_id": "Mbpp/404", "solution": "def minimum(a, b):\n    \"\"\"\n    Returns the minimum of two numbers.\n\n    Args:\n    a (int or float): The first number.\n    b (int or float): The second number.\n\n    Returns:\n    int or float: The minimum of a and b.\n    \"\"\"\n    return a if a < b else b"}
{"task_id": "Mbpp/405", "solution": "def check_tuplex(tuplex, element):\n    return element in tuplex"}
{"task_id": "Mbpp/406", "solution": "def find_Parity(n):\n    return n % 2 == 1"}
{"task_id": "Mbpp/407", "solution": "def rearrange_bigger(n):\n    # Convert the number to a list of digits\n    digits = list(str(n))\n\n    # Find the rightmost digit that is smaller than the digit to its right\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n\n    # If no such digit is found, return None\n    if i == -1:\n        return None\n\n    # Find the rightmost digit that is greater than the digit at index i\n    j = len(digits) - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n\n    # Swap the digits at indices i and j\n    digits[i], digits[j] = digits[j], digits[i]\n\n    # Sort the digits to the right of index i in ascending order\n    digits[i + 1:] = sorted(digits[i + 1:])\n\n    # Convert the list of digits back to a number\n    result = int(''.join(digits))\n\n    # Return the result\n    return result"}
{"task_id": "Mbpp/409", "solution": "def min_product_tuple(tuples_list):\n    min_product = float('inf')\n    for t in tuples_list:\n        product = t[0] * t[1]\n        if product < min_product:\n            min_product = product\n    return min_product"}
{"task_id": "Mbpp/410", "solution": "def min_val(lst):\n    # Initialize minimum value to None\n    min_value = None\n\n    # Iterate over each element in the list\n    for elem in lst:\n        # If the element is a number and (min_value is None or the element is less than min_value)\n        if isinstance(elem, (int, float)) and (min_value is None or elem < min_value):\n            # Update min_value to the current element\n            min_value = elem\n\n    # Return the minimum value\n    return min_value"}
{"task_id": "Mbpp/412", "solution": "def remove_odd(numbers):\n    \"\"\"\n    This function takes a list of numbers as input and returns a new list\n    containing only the even numbers from the input list.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    list: A new list containing only the even numbers from the input list.\n    \"\"\"\n    # Initialize an empty list to store the even numbers\n    even_numbers = []\n\n    # Iterate over each number in the input list\n    for number in numbers:\n        # Check if the number is even\n        if number % 2 == 0:\n            # If the number is even, add it to the list of even numbers\n            even_numbers.append(number)\n\n    # Return the list of even numbers\n    return even_numbers"}
{"task_id": "Mbpp/413", "solution": "def extract_nth_element(tuples_list, n):\n    return [t[n] for t in tuples_list]"}
{"task_id": "Mbpp/414", "solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    This function checks whether any value in a sequence exists in another sequence or not.\n\n    Parameters:\n    seq1 (list): The first sequence of values.\n    seq2 (list): The second sequence of values.\n\n    Returns:\n    bool: True if any value exists in both sequences, False otherwise.\n    \"\"\"\n    for value in seq1:\n        if value in seq2:\n            return True\n    return False"}
{"task_id": "Mbpp/415", "solution": "def max_Product(arr):\n    arr.sort()\n    return (arr[-1], arr[-2]) if arr[-1]*arr[-2] > arr[0]*arr[1] else (arr[0], arr[1])"}
{"task_id": "Mbpp/418", "solution": "def Find_Max(lst):\n    max_length = 0\n    max_element = None\n\n    for element in lst:\n        if len(element) > max_length:\n            max_length = len(element)\n            max_element = element\n\n    return max_element"}
{"task_id": "Mbpp/419", "solution": "def round_and_sum(numbers):\n    # Round each number in the list\n    rounded_numbers = [round(num) for num in numbers]\n\n    # Calculate the sum of the rounded numbers\n    sum_of_rounded_numbers = sum(rounded_numbers)\n\n    # Multiply the sum by the length of the list\n    result = sum_of_rounded_numbers * len(numbers)\n\n    return result"}
{"task_id": "Mbpp/420", "solution": "def cube_Sum(n):\n    sum = 0\n    for i in range(2, 2*n+1, 2):\n        sum += i**3\n    return sum\n\n# This function calculates the cube sum of the first n even natural numbers.\n# It initializes a variable 'sum' to 0 and then iterates over the range of even numbers from 2 to 2*n (with a step of 2)\n# In each iteration, it adds the cube of the current number to the 'sum' variable.\n# Finally, it returns the value of 'sum' which is the cube sum of the first n even natural numbers."}
{"task_id": "Mbpp/421", "solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    # Convert each element of the tuple to a string\n    string_tuple = tuple(str(element) for element in input_tuple)\n\n    # Use the join method to concatenate the elements of the tuple with the delimiter\n    result = delimiter.join(string_tuple)\n\n    return result"}
{"task_id": "Mbpp/422", "solution": "def find_Average_Of_Cube(n):\n    # Calculate the sum of cubes of first n natural numbers\n    sum_of_cubes = sum([i**3 for i in range(1, n+1)])\n    # Calculate the average\n    average = sum_of_cubes / n\n    return average"}
{"task_id": "Mbpp/424", "solution": "def extract_rear(strings):\n    return [string[-1] for string in strings]"}
{"task_id": "Mbpp/425", "solution": "def count_element_in_list(lst, target):\n    count = 0\n    for sublist in lst:\n        if target in sublist:\n            count += 1\n    return count\n\n# Test cases\nassert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]],1)==3\nassert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'A')==3\nassert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'E')==1"}
{"task_id": "Mbpp/426", "solution": "def filter_oddnumbers(numbers):\n    return [num for num in numbers if num % 2 != 0]"}
{"task_id": "Mbpp/427", "solution": "def change_date_format(date_str):\n    # Split the date string into year, month, and day\n    year, month, day = date_str.split('-')\n\n    # Reorder the year, month, and day to the desired format\n    new_date_str = '-'.join([day, month, year])\n\n    # Return the new date string\n    return new_date_str"}
{"task_id": "Mbpp/428", "solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Do a gapped insertion sort for each gap size.\n    # Last gap is always 1, but it's not necessary to perform a pass for it.\n    while gap > 0:\n\n        # Perform a gapped insertion sort for this gap size.\n        # The first gap elements a[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, n):\n\n            # add a[i] to the elements that have been gap sorted\n            # save a[i] in temp and make a hole at position i\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr"}
{"task_id": "Mbpp/429", "solution": "def and_tuples(tuple1, tuple2):\n    # Check if the tuples are of the same length\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Both tuples must be of the same length\")\n\n    # Initialize an empty tuple to store the results\n    result = ()\n\n    # Iterate over the tuples using the index\n    for i in range(len(tuple1)):\n        # Perform the bitwise AND operation and append the result to the result tuple\n        result += (tuple1[i] & tuple2[i],)\n\n    return result"}
{"task_id": "Mbpp/430", "solution": "The function `parabola_directrix` takes three arguments: `a`, `b`, and `c`, which represent the coefficients of the parabola's equation `y = ax^2 + bx + c`. The function calculates and returns the x-coordinate of the directrix of the parabola.\n\nThe formula to find the directrix of a parabola is `x = -b / (2a) - p^2 / (4a)`, where `p` is the distance from the vertex to the focus of the parabola. In this case, `p` is the absolute value of `c` (the y-coordinate of the vertex).\n\nThe function first calculates `p` and then uses it to calculate the x-coordinate of the directrix. The result is then returned."}
{"task_id": "Mbpp/431", "solution": "def common_element(list1, list2):\n    # Convert list1 to a set for efficient lookup\n    set1 = set(list1)\n\n    # Iterate through list2 and check if each element is in set1\n    for element in list2:\n        if element in set1:\n            return True\n\n    # If no common element is found, return False\n    return False"}
{"task_id": "Mbpp/432", "solution": "def median_trapezium(a, b, c):\n    # Calculate the average of the two parallel sides\n    median = (a + b) / 2\n    return median"}
{"task_id": "Mbpp/433", "solution": "def check_greater(arr, num):\n    for element in arr:\n        if element >= num:\n            return False\n    return True"}
{"task_id": "Mbpp/435", "solution": "def last_Digit(number):\n    return number % 10"}
{"task_id": "Mbpp/436", "solution": "def neg_nos(numbers):\n    # Analyze the input data and identify the logical criteria for determining which numbers are negative\n    negative_numbers = [num for num in numbers if num < 0]\n    # Write a function that uses this criteria to filter the list and return only the negative numbers\n    return negative_numbers"}
{"task_id": "Mbpp/437", "solution": "def remove_odd(string):\n    # Define a function to check if a character is odd\n    def is_odd(char):\n        return ord(char) % 2 != 0\n\n    # Use list comprehension to filter out odd characters\n    filtered_chars = [char for char in string if not is_odd(char)]\n\n    # Join the filtered characters back into a string and return\n    return ''.join(filtered_chars)"}
{"task_id": "Mbpp/438", "solution": "def count_bidirectional(tuples):\n    # Create a set to store the unique tuple pairs\n    unique_pairs = set()\n\n    # Iterate over each tuple in the list\n    for t in tuples:\n        # Create the reversed tuple\n        reversed_t = (t[1], t[0])\n\n        # If the reversed tuple is already in the set,\n        # it means we have a bidirectional pair\n        if reversed_t in unique_pairs:\n            # Remove the reversed tuple from the set\n            unique_pairs.remove(reversed_t)\n        else:\n            # Otherwise, add the tuple to the set\n            unique_pairs.add(t)\n\n    # Return the number of unique bidirectional pairs\n    return len(unique_pairs) // 2"}
{"task_id": "Mbpp/439", "solution": "def multiple_to_single(lst):\n    result = \"\"\n    for num in lst:\n        result += str(num)\n    return int(result)"}
{"task_id": "Mbpp/440", "solution": "import re\n\ndef find_adverb_position(sentence):\n    # Define a regular expression pattern to match adverbs\n    pattern = r'\\b\\w+ly\\b'\n\n    # Search for the first adverb in the sentence\n    match = re.search(pattern, sentence)\n\n    # If an adverb is found, return its position and the adverb itself\n    if match:\n        return match.start(), match.end(), match.group()\n\n    # If no adverb is found, return None\n    else:\n        return None"}
{"task_id": "Mbpp/441", "solution": "def surfacearea_cube(side_length):\n    \"\"\"\n    This function calculates the surface area of a cube given its side length.\n    The formula for the surface area of a cube is 6 * side^2.\n    \"\"\"\n    return 6 * side_length ** 2"}
{"task_id": "Mbpp/442", "solution": "def positive_count(arr):\n    # Count the number of positive integers in the array\n    positive_numbers = sum(1 for num in arr if num > 0)\n\n    # Calculate the ratio of positive numbers to the total number of elements in the array\n    ratio = positive_numbers / len(arr)\n\n    return ratio"}
{"task_id": "Mbpp/445", "solution": "def index_multiplication(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        result.append((tuple1[i][0] * tuple2[i][0], tuple1[i][1] * tuple2[i][1]))\n    return tuple(result)"}
{"task_id": "Mbpp/446", "solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    This function counts the occurrence of all elements of a list in a tuple.\n\n    Parameters:\n    tup (tuple): The tuple in which to count the occurrences.\n    lst (list): The list of elements to count.\n\n    Returns:\n    int: The total count of the elements in the list that occur in the tuple.\n    \"\"\"\n    # Initialize a counter\n    count = 0\n    # Iterate through the tuple\n    for element in tup:\n        # If the element is in the list, increment the counter\n        if element in lst:\n            count += 1\n    # Return the counter\n    return count"}
{"task_id": "Mbpp/447", "solution": "def cube_nums(nums):\n    return [num ** 3 for num in nums]"}
{"task_id": "Mbpp/448", "solution": "def cal_sum(n):\n    # Initialize the first three Perrin numbers\n    perrin = [3, 0, 2]\n\n    # Calculate the remaining Perrin numbers up to the nth number\n    for i in range(3, n):\n        perrin.append(perrin[i-2] + perrin[i-3])\n\n    # Return the sum of the Perrin numbers\n    return sum(perrin[:n])"}
{"task_id": "Mbpp/450", "solution": "def extract_string(string_list, length):\n    return [string for string in string_list if len(string) <= length]"}
{"task_id": "Mbpp/451", "solution": "def remove_whitespaces(s):\n    return s.replace(' ', '')"}
{"task_id": "Mbpp/453", "solution": "def sumofFactors(n):\n    factors = [i for i in range(1, n+1) if n % i == 0]\n    even_factors = [i for i in factors if i % 2 == 0]\n    return sum(even_factors)"}
{"task_id": "Mbpp/454", "solution": "def text_match_wordz(word):\n    if 'z' in word:\n        return True\n    else:\n        return False\n\n# This function checks if the character 'z' is present in the input word. If it is, the function returns True; otherwise, it returns False. This solution is simple and efficient, as it only requires a single pass through the string."}
{"task_id": "Mbpp/455", "solution": "def check_monthnumb_number(month):\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/456", "solution": "def reverse_string_list(string_list):\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list"}
{"task_id": "Mbpp/457", "solution": "def Find_Min(lst):\n    \"\"\"\n    This function takes a list of sublists as input and returns the sublist(s) with the minimum length.\n\n    Parameters:\n    lst (list): A list of sublists.\n\n    Returns:\n    list: A list of sublist(s) with the minimum length.\n\n    Assumptions:\n    - The input list is not empty.\n    - The input list contains only sublists.\n    - The sublists may contain any type of elements.\n    \"\"\"\n    # Find the length of each sublist\n    lengths = [len(sublist) for sublist in lst]\n\n    # Find the minimum length\n    min_length = min(lengths)\n\n    # Return the sublist(s) with the minimum length\n    return [sublist for sublist in lst if len(sublist) == min_length]"}
{"task_id": "Mbpp/458", "solution": "def rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    Parameters:\n    length (int or float): The length of the rectangle.\n    width (int or float): The width of the rectangle.\n\n    Returns:\n    int or float: The area of the rectangle.\n    \"\"\"\n    return length * width"}
{"task_id": "Mbpp/459", "solution": "def remove_uppercase(s):\n    result = ''\n    i = 0\n    while i < len(s):\n        if s[i].isupper():\n            while i < len(s) and s[i].isupper():\n                i += 1\n        else:\n            result += s[i]\n            i += 1\n    return result"}
{"task_id": "Mbpp/460", "solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]"}
{"task_id": "Mbpp/461", "solution": "def upper_ctr(input_string):\n    \"\"\"\n    This function takes a string as input and returns the count of upper case characters in the string.\n\n    Args:\n    input_string (str): The input string to count upper case characters in.\n\n    Returns:\n    int: The count of upper case characters in the input string.\n    \"\"\"\n    # Initialize a counter for upper case characters\n    count = 0\n\n    # Iterate through each character in the input string\n    for char in input_string:\n        # Check if the character is upper case\n        if char.isupper():\n            # If the character is upper case, increment the counter\n            count += 1\n\n    # Return the final count of upper case characters\n    return count"}
{"task_id": "Mbpp/462", "solution": "def combinations_list(lst):\n    # Base case: if the list is empty, return a list containing an empty list\n    if len(lst) == 0:\n        return [[]]\n\n    # Recursive case:\n    # 1. Remove the first element from the list\n    # 2. Find all combinations of the remaining elements\n    # 3. For each combination, create a new combination with the first element added to it\n    # 4. Combine the two lists of combinations and return the result\n    first_element = lst[0]\n    remaining_elements = lst[1:]\n    combinations_without_first = combinations_list(remaining_elements)\n    combinations_with_first = [combination + [first_element] for combination in combinations_without_first]\n    return combinations_without_first + combinations_with_first"}
{"task_id": "Mbpp/463", "solution": "def max_subarray_product(nums):\n    if not nums:\n        return 0\n\n    max_product = min_product = result = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n\n        result = max(result, max_product)\n\n    return result"}
{"task_id": "Mbpp/465", "solution": "def drop_empty(dictionary):\n    # Create a new dictionary to store the non-empty items\n    new_dict = {}\n\n    # Iterate over the items in the original dictionary\n    for key, value in dictionary.items():\n        # If the value is not empty, add it to the new dictionary\n        if value is not None:\n            new_dict[key] = value\n\n    # Return the new dictionary\n    return new_dict"}
{"task_id": "Mbpp/468", "solution": "def max_product(arr):\n    n = len(arr)\n    dp = [0]*n\n    dp[0] = arr[0]\n    max_prod = dp[0]\n\n    for i in range(1, n):\n        max_val = 0\n        for j in range(i):\n            if arr[i] > arr[j]:\n                max_val = max(max_val, dp[j])\n        dp[i] = max_val * arr[i]\n        max_prod = max(max_prod, dp[i])\n\n    return max_prod"}
{"task_id": "Mbpp/470", "solution": "def add_pairwise(t):\n    return tuple(t[i] + t[i + 1] for i in range(len(t) - 1))"}
{"task_id": "Mbpp/471", "solution": "def find_remainder(arr, n):\n    product = 1\n    for num in arr:\n        product = (product * num) % n\n    return product"}
{"task_id": "Mbpp/472", "solution": "def check_Consecutive(lst):\n    for i in range(len(lst) - 1):\n        if lst[i] + 1 != lst[i + 1]:\n            return False\n    return True"}
{"task_id": "Mbpp/473", "solution": "def tuple_intersection(list1, list2):\n    # Convert the lists of tuples to sets of tuples, which automatically removes duplicates\n    set1 = set(list1)\n    set2 = set(list2)\n\n    # Use the intersection() method to find the common elements between the two sets\n    intersection = set1.intersection(set2)\n\n    # Convert the set back to a list and return it\n    return intersection"}
{"task_id": "Mbpp/474", "solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    This function takes an input string, an old character, and a new character.\n    It replaces all occurrences of the old character in the input string with the new character.\n    \"\"\"\n    # Using the replace() method to replace characters\n    output_string = input_string.replace(old_char, new_char)\n\n    return output_string"}
{"task_id": "Mbpp/475", "solution": "def sort_counter(dictionary):\n    # Convert dictionary to list of tuples\n    items = list(dictionary.items())\n\n    # Sort the list of tuples by value in descending order\n    items.sort(key=lambda x: x[1], reverse=True)\n\n    return items"}
{"task_id": "Mbpp/476", "solution": "def big_sum(arr):\n    \"\"\"\n    This function takes an array of numbers as input and returns the sum of the largest and smallest value in the array.\n\n    Parameters:\n    arr (list): A list of numbers.\n\n    Returns:\n    int: The sum of the largest and smallest value in the array.\n    \"\"\"\n    # Check if the array is not empty\n    if not arr:\n        return None\n\n    # Find the maximum and minimum values in the array\n    max_val = max(arr)\n    min_val = min(arr)\n\n    # Return the sum of the maximum and minimum values\n    return max_val + min_val"}
{"task_id": "Mbpp/477", "solution": "def is_lower(input_string):\n    return input_string.lower()"}
{"task_id": "Mbpp/478", "solution": "def remove_lowercase(input_string):\n    \"\"\"\n    This function takes a string as input and removes all lowercase substrings from it.\n    It returns the modified string as output.\n    \"\"\"\n    # Initialize an empty string to store the result\n    result = ''\n\n    # Iterate over each character in the input string\n    for char in input_string:\n        # If the character is not lowercase, add it to the result string\n        if not char.islower():\n            result += char\n\n    # Return the result string\n    return result"}
{"task_id": "Mbpp/479", "solution": "def first_Digit(n):\n    while n >= 10:\n        n = n // 10\n    return n"}
{"task_id": "Mbpp/554", "solution": "def Split(lst):\n    return [i for i in lst if i % 2 != 0]"}
{"task_id": "Mbpp/555", "solution": "def difference(n):\n    sum_of_n = n * (n + 1) // 2\n    sum_of_cubes = (sum_of_n ** 2)\n    return sum_of_cubes - sum_of_n"}
{"task_id": "Mbpp/556", "solution": "def find_Odd_Pair(nums, n):\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] ^ nums[j]) & 1:\n                count += 1\n    return count"}
{"task_id": "Mbpp/557", "solution": "def toggle_string(input_string):\n    output_string = \"\"\n    for char in input_string:\n        if char.isupper():\n            output_string += char.lower()\n        else:\n            output_string += char.upper()\n    return output_string"}
{"task_id": "Mbpp/558", "solution": "def digit_distance_nums(num1, num2):\n    # Convert numbers to lists of digits\n    digits1 = [int(d) for d in str(num1)]\n    digits2 = [int(d) for d in str(num2)]\n\n    # Make sure both lists have the same length\n    while len(digits1) < len(digits2):\n        digits1.insert(0, 0)\n    while len(digits2) < len(digits1):\n        digits2.insert(0, 0)\n\n    # Calculate the absolute difference between each pair of digits\n    differences = [abs(d1 - d2) for d1, d2 in zip(digits1, digits2)]\n\n    # Sum up the differences and return the result\n    return sum(differences)"}
{"task_id": "Mbpp/559", "solution": "def max_sub_array_sum(nums, n):\n    max_so_far = float('-inf')\n    max_ending_here = 0\n\n    for i in range(n):\n        max_ending_here = max_ending_here + nums[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n    return max_so_far"}
{"task_id": "Mbpp/560", "solution": "def union_elements(tuple1, tuple2):\n    # Use set to eliminate duplicates and then convert back to tuple\n    union = tuple(set(tuple1) | set(tuple2))\n    # Sort the tuple and return\n    return tuple(sorted(union))"}
{"task_id": "Mbpp/562", "solution": "def Find_Max_Length(sublists):\n    max_length = 0\n    for sublist in sublists:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n    return max_length"}
{"task_id": "Mbpp/563", "solution": "import re\n\ndef extract_values(s):\n    return re.findall('\"([^\"]*)\"', s)"}
{"task_id": "Mbpp/564", "solution": "def count_Pairs(lst, n):\n    # Input validation\n    if not isinstance(lst, list) or not all(isinstance(i, int) for i in lst) or len(lst) != n:\n        raise ValueError(\"Input must be a list of integers with length equal to n\")\n\n    # Count the number of unique pairs\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if lst[i] != lst[j]:\n                count += 1\n\n    return count"}
{"task_id": "Mbpp/565", "solution": "def split(input_string):\n    return [char for char in input_string]"}
{"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    # Initialize the sum to 0\n    total = 0\n\n    # While n is not equal to 0\n    while n != 0:\n        # Add the last digit of n to the total\n        total += n % 10\n\n        # Remove the last digit of n\n        n //= 10\n\n    # Return the total sum of digits\n    return total"}
{"task_id": "Mbpp/567", "solution": "def issort_list(lst):\n    return all(lst[i] <= lst[i + 1] for i in range(len(lst) - 1)) or all(lst[i] >= lst[i + 1] for i in range(len(lst) - 1))"}
{"task_id": "Mbpp/568", "solution": "def empty_list(N):\n    return [{} for _ in range(N)]"}
{"task_id": "Mbpp/569", "solution": "def sort_sublists(lst):\n    return [sorted(sublist) for sublist in lst]"}
{"task_id": "Mbpp/572", "solution": "def two_unique_nums(num_lists):\n    # Create an empty list to store unique numbers\n    unique_nums = []\n\n    # Iterate over each number in the input list\n    for num in num_lists:\n        # If the number is not already in the unique_nums list, add it\n        if num not in unique_nums:\n            unique_nums.append(num)\n\n    # Return the list of unique numbers\n    return unique_nums"}
{"task_id": "Mbpp/573", "solution": "def unique_product(numbers):\n    \"\"\"\n    Calculate the product of the unique numbers in a given list.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The product of the unique numbers in the list.\n    \"\"\"\n    # Use a set to filter out the unique numbers in the list\n    unique_numbers = set(numbers)\n\n    # Initialize the product to 1\n    product = 1\n\n    # Calculate the product of the unique numbers\n    for number in unique_numbers:\n        product *= number\n\n    # Return the product\n    return product"}
{"task_id": "Mbpp/574", "solution": "import math\n\ndef surfacearea_cylinder(radius, height):\n    \"\"\"\n    Calculate the surface area of a cylinder.\n\n    Parameters:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The surface area of the cylinder.\n    \"\"\"\n    # The formula for the surface area of a cylinder is 2\u03c0rh + 2\u03c0r\u00b2\n    base_area = math.pi * radius ** 2\n    lateral_area = 2 * math.pi * radius * height\n    return base_area + lateral_area"}
{"task_id": "Mbpp/576", "solution": "def is_Sub_Array(main_list, sub_list):\n    main_len = len(main_list)\n    sub_len = len(sub_list)\n\n    # Iterate through the main list\n    for i in range(main_len):\n        # Check if the sublist starts at the current position\n        if main_list[i:i+sub_len] == sub_list:\n            return True\n\n    # If no match is found, return False\n    return False"}
{"task_id": "Mbpp/577", "solution": "def last_Digit_Factorial(n):\n    # Factorial of numbers ending in 0 or 5 will always end in 0\n    if n % 5 == 0 or n % 10 == 5:\n        return 0\n    # For other numbers, the last digit of the factorial is the same as the last digit of the number\n    else:\n        result = 1\n        for i in range(1, n + 1):\n            result = (result * i) % 10\n        return result"}
{"task_id": "Mbpp/578", "solution": "def interleave_lists(list1, list2, list3):\n    return [val for sublist in zip(list1, list2, list3) for val in sublist]"}
{"task_id": "Mbpp/579", "solution": "def find_dissimilar(tuple1, tuple2):\n    # Find elements in tuple1 that are not in tuple2\n    dissimilar1 = tuple(set(tuple1) - set(tuple2))\n    # Find elements in tuple2 that are not in tuple1\n    dissimilar2 = tuple(set(tuple2) - set(tuple1))\n    # Combine the two results and return\n    return dissimilar1 + dissimilar2"}
{"task_id": "Mbpp/580", "solution": "def extract_even(t):\n    result = []\n    for i in t:\n        if isinstance(i, tuple):\n            result.append(extract_even(i))\n        elif i % 2 == 0:\n            result.append(i)\n    return tuple(result)"}
{"task_id": "Mbpp/581", "solution": "import math\n\ndef surface_Area(base_edge, height):\n    # Calculate the area of the base square\n    base_area = base_edge ** 2\n\n    # Calculate the perimeter of the base square\n    base_perimeter = 4 * base_edge\n\n    # Calculate the slant height using Pythagorean theorem\n    slant_height = math.sqrt(height ** 2 + (base_edge / 2) ** 2)\n\n    # Calculate the area of the four triangular faces\n    triangular_area = 0.5 * base_perimeter * slant_height\n\n    # Calculate the total surface area\n    total_area = base_area + triangular_area\n\n    return total_area"}
{"task_id": "Mbpp/582", "solution": "def my_dict(dictionary):\n    if len(dictionary) == 0:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/583", "solution": "def catalan_number(n):\n    if n <=1 :\n        return 1\n\n    # Table to store results of subproblems\n    catalan = [0 for i in range(n+1)]\n\n    # Initialize first two values in table\n    catalan[0] = 1\n    catalan[1] = 1\n\n    # Fill entries in catalan[] using recursive formula\n    for i in range(2, n + 1):\n        catalan[i] = 0\n        for j in range(i):\n            catalan[i] = catalan[i] + catalan[j] * catalan[i-j-1]\n\n    # Return last entry\n    return catalan[n]"}
{"task_id": "Mbpp/585", "solution": "def expensive_items(dataset, n):\n    # Sort the dataset by price in descending order\n    sorted_dataset = sorted(dataset, key=lambda x: x['price'], reverse=True)\n\n    # Return the first n items\n    return sorted_dataset[:n]"}
{"task_id": "Mbpp/586", "solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]"}
{"task_id": "Mbpp/587", "solution": "def list_tuple(lst):\n    return tuple(lst)"}
{"task_id": "Mbpp/588", "solution": "def big_diff(nums):\n    \"\"\"\n    This function takes a list of numbers as input and returns the difference between the largest and smallest value in the list.\n\n    Args:\n    nums: A list of numbers.\n\n    Returns:\n    The difference between the largest and smallest value in the list.\n    \"\"\"\n    # Initialize the minimum and maximum values to the first element of the list\n    min_val = max_val = nums[0]\n\n    # Iterate through the list to find the minimum and maximum values\n    for num in nums:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n\n    # Return the difference between the maximum and minimum values\n    return max_val - min_val"}
{"task_id": "Mbpp/589", "solution": "def perfect_squares(start, end):\n    # Initialize an empty list to store the perfect squares\n    squares = []\n\n    # Iterate through each number in the range\n    for i in range(start, end + 1):\n        # Check if the number is a perfect square\n        if int(i ** 0.5) ** 2 == i:\n            # If it is, add it to the list\n            squares.append(i)\n\n    # Return the list of perfect squares\n    return squares"}
{"task_id": "Mbpp/590", "solution": "import math\n\ndef polar_rect(r, theta):\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    return (x, y), complex(x, y)"}
{"task_id": "Mbpp/591", "solution": "def swap_List(lst):\n    # Check if the list has at least two elements\n    if len(lst) >= 2:\n        # Swap the first and last elements using tuple packing and unpacking\n        lst[0], lst[-1] = lst[-1], lst[0]\n    return lst"}
{"task_id": "Mbpp/592", "solution": "def sum_Of_product(n):\n    # Function to calculate binomial coefficient\n    def binomial_coefficient(n, k):\n        if k == 0 or k == n:\n            return 1\n        else:\n            return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k)\n\n    # Calculate the sum of the product of consecutive binomial coefficients\n    sum_of_products = 0\n    for k in range(n):\n        sum_of_products += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n\n    return sum_of_products"}
{"task_id": "Mbpp/593", "solution": "def removezero_ip(ip_address):\n    octets = ip_address.split('.')\n    cleaned_octets = [str(int(octet)) for octet in octets]\n    return '.'.join(cleaned_octets)"}
{"task_id": "Mbpp/594", "solution": "def diff_even_odd(lst):\n    first_even = None\n    first_odd = None\n\n    for num in lst:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        elif first_odd is None and num % 2 != 0:\n            first_odd = num\n\n        if first_even is not None and first_odd is not None:\n            break\n\n    if first_even is None or first_odd is None:\n        return None\n    else:\n        return first_even - first_odd"}
{"task_id": "Mbpp/595", "solution": "def min_Swaps(bin1, bin2):\n    # Convert binary strings to lists for easier manipulation\n    list1 = list(bin1)\n    list2 = list(bin2)\n\n    # Initialize swap count\n    swaps = 0\n\n    # Iterate over the lists\n    for i in range(len(list1)):\n        # If the bits are not equal\n        if list1[i] != list2[i]:\n            # Find the index of the next bit that needs to be swapped\n            for j in range(i+1, len(list1)):\n                if list1[j] != list2[j] and list1[i] == list2[j]:\n                    # Swap the bits\n                    list1[i], list1[j] = list1[j], list1[i]\n                    # Increment swap count\n                    swaps += 1\n                    break\n            else:\n                # If no swap is possible, return None\n                return None\n\n    # Return the swap count\n    return swaps"}
{"task_id": "Mbpp/596", "solution": "import sys\n\ndef tuple_size(t):\n    size = sys.getsizeof(t)\n    for item in t:\n        size += sys.getsizeof(item)\n    return size"}
{"task_id": "Mbpp/597", "solution": "def find_kth(arr1, arr2, k):\n    if len(arr1) > len(arr2):\n        arr1, arr2 = arr2, arr1\n    if not arr1:\n        return arr2[k - 1]\n    if k == 1:\n        return min(arr1[0], arr2[0])\n    i = min(k // 2, len(arr1))\n    j = k - i\n    if arr1[i - 1] > arr2[j - 1]:\n        return find_kth(arr1, arr2[j:], i)\n    else:\n        return find_kth(arr1[i:], arr2, j)"}
{"task_id": "Mbpp/598", "solution": "def armstrong_number(num):\n    # Convert the number to string to find the number of digits\n    num_str = str(num)\n    # Calculate the sum of each digit raised to the power of the number of digits\n    sum_of_digits = sum(int(digit) ** len(num_str) for digit in num_str)\n    # Check if the sum is equal to the original number\n    return sum_of_digits == num"}
{"task_id": "Mbpp/599", "solution": "def sum_average(n):\n    # Calculate sum of first n natural numbers\n    sum_n = n * (n + 1) // 2\n\n    # Calculate average of first n natural numbers\n    average_n = sum_n / n\n\n    return sum_n, average_n\n\n# Test the function\nprint(sum_average(10))  # Expected output: (55, 5.5)\nprint(sum_average(15))  # Expected output: (120, 8.0)\nprint(sum_average(20))  # Expected output: (210, 10.5)"}
{"task_id": "Mbpp/600", "solution": "def is_Even(n):\n    \"\"\"\n    Returns True if the given number is even, and False otherwise.\n    \"\"\"\n    return n % 2 == 0"}
{"task_id": "Mbpp/602", "solution": "def first_repeated_char(input_string):\n    \"\"\"\n    This function takes a string as input and returns the first repeated character in the string.\n    If there is no repeated character, the function returns None.\n\n    :param input_string: str\n    :return: str or None\n    \"\"\"\n    # Create an empty set to keep track of the characters we have seen so far\n    seen_chars = set()\n\n    # Iterate through the string\n    for char in input_string:\n        # If the character is already in the set, it is the first repeated character\n        if char in seen_chars:\n            return char\n        # Otherwise, add the character to the set\n        else:\n            seen_chars.add(char)\n\n    # If we have iterated through the entire string and have not found a repeated character, return None\n    return None"}
{"task_id": "Mbpp/603", "solution": "def get_ludic(n):\n    ludic_numbers = []\n    for i in range(1, n+1):\n        if is_ludic(i):\n            ludic_numbers.append(i)\n    return ludic_numbers\n\ndef is_ludic(n):\n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = sum(int(digit)**2 for digit in str(n))\n    return n == 1"}
{"task_id": "Mbpp/604", "solution": "def reverse_words(string):\n    # Split the string into a list of words\n    words = string.split(' ')\n\n    # Reverse the list of words\n    reversed_words = words[::-1]\n\n    # Join the reversed list of words into a string, separated by spaces\n    reversed_string = ' '.join(reversed_words)\n\n    # Return the reversed string\n    return reversed_string"}
{"task_id": "Mbpp/605", "solution": "def prime_num(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True"}
{"task_id": "Mbpp/606", "solution": "def radian_degree(degrees):\n    \"\"\"\n    Function to convert degrees to radians.\n    \"\"\"\n    # The mathematical relationship between degrees and radians is:\n    # 1 radian = \u03c0/180 degrees\n    # So, to convert degrees to radians, we multiply the degrees by \u03c0/180\n    import math\n    radians = degrees * math.pi / 180\n    return radians\n\n# Testing the function\nprint(radian_degree(90))  # Should print: 1.5707963267948966\nprint(radian_degree(60))  # Should print: 1.0471975511965976\nprint(radian_degree(120))  # Should print: 2.0943951023931953"}
{"task_id": "Mbpp/607", "solution": "import re\n\ndef find_literals(string, pattern):\n    match = re.search(pattern, string)\n    if match:\n        return match.group(), match.start(), match.end()\n    else:\n        return None"}
{"task_id": "Mbpp/608", "solution": "def bell_Number(n):\n    bell = [[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        # Explicitly fill for j = 0\n        bell[i][0] = bell[i-1][i-1]\n        # Fill for remaining values of j\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    return bell[n][0]"}
{"task_id": "Mbpp/610", "solution": "def remove_kth_element(lst, k):\n    return lst[:k] + lst[k+1:]"}
{"task_id": "Mbpp/611", "solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column\n    column = [row[n] for row in matrix]\n    # Return the maximum value in the column\n    return max(column)"}
{"task_id": "Mbpp/612", "solution": "def merge(lst):\n    return [[i[0] for i in lst], [i[1] for i in lst]]"}
{"task_id": "Mbpp/614", "solution": "def cummulative_sum(tuple_list):\n    total_sum = 0\n    for tup in tuple_list:\n        total_sum += sum(tup)\n    return total_sum\n\n# Test cases\nprint(cummulative_sum([(1, 3), (5, 6, 7), (2, 6)]))  # Expected output: 30\nprint(cummulative_sum([(2, 4), (6, 7, 8), (3, 7)]))  # Expected output: 37\nprint(cummulative_sum([(3, 5), (7, 8, 9), (4, 8)]))  # Expected output: 44"}
{"task_id": "Mbpp/615", "solution": "def average_tuple(tuples):\n    averages = []\n    for t in tuples:\n        averages.append(sum(t) / len(t))\n    return averages"}
{"task_id": "Mbpp/616", "solution": "def tuple_modulo(tuple1, tuple2):\n    \"\"\"\n    This function takes two tuples of the same length and performs the element-wise modulo operation.\n\n    Args:\n    tuple1 (tuple): The first tuple.\n    tuple2 (tuple): The second tuple.\n\n    Returns:\n    tuple: A tuple containing the element-wise modulo of the input tuples.\n    \"\"\"\n    # Check if the tuples are of the same length\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"The input tuples must be of the same length.\")\n\n    # Perform the element-wise modulo operation\n    result = tuple(a % b for a, b in zip(tuple1, tuple2))\n\n    return result"}
{"task_id": "Mbpp/618", "solution": "def div_list(list1, list2):\n    if len(list1) != len(list2):\n        raise ValueError(\"Both lists must have the same length\")\n\n    result = []\n    for i in range(len(list1)):\n        if list2[i] == 0:\n            raise ZeroDivisionError(\"Cannot divide by zero\")\n        result.append(list1[i] / list2[i])\n\n    return result"}
{"task_id": "Mbpp/619", "solution": "def move_num(input_string):\n    numbers = []\n    letters = []\n\n    for char in input_string:\n        if char.isdigit():\n            numbers.append(char)\n        else:\n            letters.append(char)\n\n    return ''.join(letters) + ''.join(numbers)"}
{"task_id": "Mbpp/620", "solution": "def largest_subset(numbers):\n    # Sort the numbers\n    numbers.sort()\n\n    # Initialize the count of subsets\n    count = 0\n\n    # Initialize the current subset size\n    subset_size = 1\n\n    # Iterate through the numbers\n    for i in range(1, len(numbers)):\n        # If the current number is divisible by the first number of the current subset\n        if numbers[i] % numbers[i - subset_size] == 0:\n            # Increment the current subset size\n            subset_size += 1\n        else:\n            # Update the count of subsets\n            count = max(count, subset_size)\n            # Reset the current subset size\n            subset_size = 1\n\n    # Update the count of subsets\n    count = max(count, subset_size)\n\n    # Return the count of subsets\n    return count"}
{"task_id": "Mbpp/622", "solution": "def get_median(list1, list2, n):\n    i = j = 0\n    m1 = m2 = -1\n\n    for count in range(n + 1):\n        if i == n:\n            m1 = m2\n            m2 = list2[0]\n            break\n\n        if j == n:\n            m1 = m2\n            m2 = list1[0]\n            break\n\n        if list1[i] < list2[j]:\n            m1 = m2\n            m2 = list1[i]\n            i += 1\n        else:\n            m1 = m2\n            m2 = list2[j]\n            j += 1\n\n    return (m1 + m2) / 2"}
{"task_id": "Mbpp/623", "solution": "def nth_nums(nums, n):\n    return [num ** n for num in nums]"}
{"task_id": "Mbpp/624", "solution": "def is_upper(input_string):\n    \"\"\"\n    This function takes a string as input and returns the string converted to uppercase.\n\n    Parameters:\n    input_string (str): The string to be converted to uppercase.\n\n    Returns:\n    str: The input string converted to uppercase.\n    \"\"\"\n    return input_string.upper()"}
{"task_id": "Mbpp/626", "solution": "import math\n\ndef triangle_area(radius):\n    if radius < 0:\n        return None\n    else:\n        side_length = 2 * radius\n        return (math.sqrt(3) / 4) * side_length ** 2"}
{"task_id": "Mbpp/628", "solution": "def replace_spaces(s):\n    return s.replace(\" \", \"%20\")"}
{"task_id": "Mbpp/629", "solution": "def find_even_numbers(numbers):\n    even_numbers = [num for num in numbers if num % 2 == 0]\n    return even_numbers"}
{"task_id": "Mbpp/630", "solution": "def get_coordinates(coord):\n    x, y = coord\n    return [[i, j] for i in range(x-1, x+2) for j in range(y-1, y+2)]"}
{"task_id": "Mbpp/631", "solution": "def replace_spaces(s):\n    result = \"\"\n    for char in s:\n        if char == \" \":\n            result += \"_\"\n        elif char == \"_\":\n            result += \" \"\n        else:\n            result += char\n    return result"}
{"task_id": "Mbpp/632", "solution": "def move_zero(nums):\n    # Initialize two pointers, one for the current position and one for the position where the next non-zero element should be placed\n    i = 0\n    j = 0\n\n    # Iterate through the list\n    while i < len(nums):\n        # If the current element is non-zero, swap it with the element at the j-th position and increment j\n        if nums[i] != 0:\n            nums[i], nums[j] = nums[j], nums[i]\n            j += 1\n        i += 1\n\n    # Return the modified list\n    return nums"}
{"task_id": "Mbpp/633", "solution": "def pair_xor_Sum(nums, n):\n    # Initialize the result\n    result = 0\n\n    # Iterate over all bits\n    for i in range(32):\n        # Count the number of numbers with the current bit set\n        count_set = sum((num >> i) & 1 for num in nums)\n\n        # Count the number of numbers with the current bit unset\n        count_unset = n - count_set\n\n        # Add the contribution of the current bit to the result\n        result += (count_set * count_unset) << i\n\n    return result"}
{"task_id": "Mbpp/635", "solution": "def heapify(arr, n, i):\n    largest = i\n    l = 2 * i + 1\n    r = 2 * i + 2\n\n    if l < n and arr[i] < arr[l]:\n        largest = l\n\n    if r < n and arr[largest] < arr[r]:\n        largest = r\n\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n\ndef heap_sort(arr):\n    n = len(arr)\n\n    for i in range(n, -1, -1):\n        heapify(arr, n, i)\n\n    for i in range(n-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)\n\n    return arr"}
{"task_id": "Mbpp/637", "solution": "def noprofit_noloss(amount, cost):\n    if amount == cost:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/638", "solution": "def wind_chill(wind_velocity, temperature):\n    wind_chill_index = 13.12 + 0.6215*temperature - 11.37*(wind_velocity**0.16) + 0.3965*temperature*(wind_velocity**0.16)\n    return round(wind_chill_index)"}
{"task_id": "Mbpp/639", "solution": "def sum_uppercase_names(names):\n    return sum(len(name) for name in names if name[0].isupper())\n\n# Test cases\nassert sum_uppercase_names(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16\nassert sum_uppercase_names([\"php\", \"res\", \"Python\", \"abcd\", \"Java\", \"aaa\"]) == 10\nassert sum_uppercase_names([\"abcd\", \"Python\", \"abba\", \"aba\"]) == 6"}
{"task_id": "Mbpp/640", "solution": "import re\n\ndef remove_parenthesis(s):\n    return re.sub(r'\\([^()]*\\)', '', s)"}
{"task_id": "Mbpp/641", "solution": "def is_nonagonal(n):\n    # Nonagonal numbers follow the formula: n*(7n-5)/2\n    return n * (7*n - 5) // 2"}
{"task_id": "Mbpp/643", "solution": "def text_match_wordz_middle(s):\n    # Remove the first and last characters of the string\n    s = s[1:-1]\n\n    # Check if 'z' is present in the remaining string\n    if 'z' in s:\n        return True\n    else:\n        return False\n\n# Test cases\nprint(text_match_wordz_middle(\"pythonzabc.\"))  # True\nprint(text_match_wordz_middle(\"zxyabc.\"))  # False\nprint(text_match_wordz_middle(\"  lang  .\"))  # False"}
{"task_id": "Mbpp/644", "solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the elements up to the given position\n    arr[:k] = arr[:k][::-1]\n    return arr"}
{"task_id": "Mbpp/720", "solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Analyze the problem logically and objectively\n    # The function takes a tuple and a dictionary as input\n    # The output should be a new tuple that contains all the elements of the original tuple, followed by the dictionary\n\n    # Develop a plan to solve the problem\n    # Create a new tuple that contains all the elements of the original tuple, followed by the dictionary\n\n    # Write the code to implement this plan\n    output_tuple = input_tuple + (input_dict,)\n\n    # Return the new tuple\n    return output_tuple"}
{"task_id": "Mbpp/721", "solution": "def maxAverageOfPath(matrix):\n    n = len(matrix)\n    dp = [[0.0] * n for _ in range(n)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, n):\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = matrix[i][j] + max(dp[i-1][j], dp[i][j-1])\n\n    path_length = 2 * n - 2\n    return dp[n-1][n-1] / path_length"}
{"task_id": "Mbpp/722", "solution": "def filter_data(students, min_height, min_weight):\n    filtered_students = {}\n    for student, data in students.items():\n        height, weight = data\n        if height > min_height and weight > min_weight:\n            filtered_students[student] = data\n    return filtered_students"}
{"task_id": "Mbpp/723", "solution": "def count_same_pair(list1, list2):\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i]:\n            count += 1\n    return count"}
{"task_id": "Mbpp/724", "solution": "def power_base_sum(base, power):\n    # Calculate base to the power\n    result = base ** power\n\n    # Convert the result to string to iterate through its digits\n    result_str = str(result)\n\n    # Initialize sum of digits\n    sum_digits = 0\n\n    # Iterate through each digit and add it to the sum\n    for digit in result_str:\n        sum_digits += int(digit)\n\n    return sum_digits\n\n# Test cases\nprint(power_base_sum(2,100)) # Expected output: 115\nprint(power_base_sum(8,10)) # Expected output: 37\nprint(power_base_sum(8,15)) # Expected output: 62\nprint(power_base_sum(3,3)) # Expected output: 9"}
{"task_id": "Mbpp/725", "solution": "import re\n\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)"}
{"task_id": "Mbpp/726", "solution": "def multiply_elements(t):\n    \"\"\"\n    This function takes a tuple of numbers as input and returns a tuple of length N\n    where the i-th element of the tuple is equal to t_i * t_{i+1}.\n    \"\"\"\n    # Initialize an empty list to store the results\n    result = []\n\n    # Iterate through the tuple up to the second last element\n    for i in range(len(t) - 1):\n        # Multiply the current element by the next one and append the result to the list\n        result.append(t[i] * t[i + 1])\n\n    # Convert the list to a tuple and return it\n    return tuple(result)"}
{"task_id": "Mbpp/728", "solution": "def sum_list(list1, list2):\n    return [a + b for a, b in zip(list1, list2)]"}
{"task_id": "Mbpp/730", "solution": "def consecutive_duplicates(lst):\n    if not lst:\n        return []\n\n    result = [lst[0]]\n\n    for i in range(1, len(lst)):\n        if lst[i] != lst[i - 1]:\n            result.append(lst[i])\n\n    return result"}
{"task_id": "Mbpp/731", "solution": "import math\n\ndef lateralsurface_cone(r, h):\n    # Calculate the lateral surface area of a cone\n    # r: radius of the base of the cone\n    # h: height of the cone\n    # Returns: lateral surface area of the cone\n\n    # Check if the inputs are non-negative\n    if r < 0 or h < 0:\n        raise ValueError(\"Radius and height must be non-negative.\")\n\n    # Calculate the lateral surface area\n    lateral_surface_area = math.pi * r * math.sqrt(r**2 + h**2)\n\n    return lateral_surface_area"}
{"task_id": "Mbpp/732", "solution": "import re\n\ndef replace_specialchar(input_string):\n    # Use regular expressions to match spaces, commas, and dots and replace them with a colon\n    output_string = re.sub(r'[ ,.]', ':', input_string)\n    return output_string"}
{"task_id": "Mbpp/733", "solution": "def find_first_occurrence(arr, target):\n    low = 0\n    high = len(arr) - 1\n    result = -1\n\n    while low <= high:\n        mid = (low + high) // 2\n\n        if arr[mid] == target:\n            result = mid\n            high = mid - 1\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return result"}
{"task_id": "Mbpp/734", "solution": "def sum_Of_Subarray_Prod(arr):\n    n = len(arr)\n    result = 0\n\n    # Iterate through all possible sublists\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            result += product\n\n    return result\n\n# Test cases\nprint(sum_Of_Subarray_Prod([1,2,3])) # Expected output: 20\nprint(sum_Of_Subarray_Prod([1,2])) # Expected output: 5\nprint(sum_Of_Subarray_Prod([1,2,3,4])) # Expected output: 84"}
{"task_id": "Mbpp/735", "solution": "def toggle_middle_bits(n):\n    # Get the number of bits in the number\n    num_bits = len(bin(n)) - 2\n\n    # Create a mask with all bits set to 1 except for the first and the last bit\n    mask = (1 << num_bits) - 1 - (1 << (num_bits - 1))\n\n    # Toggle the bits of the number using the mask\n    toggled_n = n ^ mask\n\n    return toggled_n"}
{"task_id": "Mbpp/736", "solution": "def left_insertion(sorted_list, value):\n    low = 0\n    high = len(sorted_list)\n\n    while low < high:\n        mid = (low + high) // 2\n        if sorted_list[mid] < value:\n            low = mid + 1\n        else:\n            high = mid\n\n    return low"}
{"task_id": "Mbpp/737", "solution": "import re\n\ndef check_str(s):\n    pattern = r'^[aeiouAEIOU]'\n    if re.match(pattern, s):\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/739", "solution": "def find_Index(n):\n    # Calculate the number of digits in the smallest triangular number with n digits\n    # This is done using the formula: T(n) = n*(n+1)/2\n    # We want to find the smallest n such that T(n) has at least n digits\n    # This can be done by solving the inequality: n*(n+1)/2 >= 10^(n-1)\n    # This simplifies to: n^2 + n - 2*10^(n-1) >= 0\n    # We can use the quadratic formula to solve this inequality\n    a = 1\n    b = 1\n    c = -2 * (10 ** (n - 1))\n    discriminant = b**2 - 4*a*c\n    n = int((-b + discriminant**0.5) / (2*a))\n\n    # Calculate the index of the smallest triangular number with n digits\n    # This is done using the formula: index = n*(n+1)/2\n    index = n * (n + 1) // 2\n\n    return index"}
{"task_id": "Mbpp/740", "solution": "def tuple_to_dict(tup):\n    # Create an empty dictionary\n    dict_out = {}\n\n    # Iterate through the tuple, taking two elements at a time\n    for i in range(0, len(tup), 2):\n        # Add these elements to the dictionary as a key-value pair\n        dict_out[tup[i]] = tup[i + 1]\n\n    # Return the resulting dictionary\n    return dict_out"}
{"task_id": "Mbpp/741", "solution": "def all_Characters_Same(input_string):\n    first_char = input_string[0]\n    for char in input_string:\n        if char != first_char:\n            return False\n    return True"}
{"task_id": "Mbpp/742", "solution": "import math\n\ndef area_tetrahedron(side_length):\n    # Calculate the area of one face of the tetrahedron\n    face_area = math.sqrt(3) / 4 * side_length ** 2\n\n    # A tetrahedron has 4 faces, so the total area is 4 times the area of one face\n    total_area = 4 * face_area\n\n    return total_area"}
{"task_id": "Mbpp/743", "solution": "def rotate_right(lst, n):\n    n = n % len(lst)\n    return lst[-n:] + lst[:-n]"}
{"task_id": "Mbpp/744", "solution": "def check_none(input_tuple):\n    for value in input_tuple:\n        if value is None:\n            return True\n    return False"}
{"task_id": "Mbpp/745", "solution": "def divisible_by_digits(startnum, endnum):\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = [int(d) for d in str(num)]\n        if all(num % d == 0 for d in digits):\n            result.append(num)\n    return result"}
{"task_id": "Mbpp/746", "solution": "import math\n\ndef sector_area(radius, angle):\n    if angle > 360:\n        return None\n    else:\n        return (angle / 360) * math.pi * radius ** 2"}
{"task_id": "Mbpp/748", "solution": "def capital_words_spaces(s):\n    result = ''\n    for i in range(len(s)):\n        if i != 0 and s[i].isupper():\n            result += ' '\n        result += s[i]\n    return result"}
{"task_id": "Mbpp/749", "solution": "def sort_numeric_strings(lst):\n    return sorted(lst, key=int)"}
{"task_id": "Mbpp/750", "solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Function to add the given tuple to the given list.\n\n    Parameters:\n    lst (list): The input list.\n    tpl (tuple): The input tuple.\n\n    Returns:\n    list: The input list with the elements of the input tuple added to it.\n    \"\"\"\n    return lst + list(tpl)"}
{"task_id": "Mbpp/751", "solution": "def check_min_heap(arr, i=0):\n    left = 2 * i + 1\n    right = 2 * i + 2\n    size = len(arr)\n\n    if left < size and arr[i] > arr[left]:\n        return False\n\n    if right < size and arr[i] > arr[right]:\n        return False\n\n    if left < size and not check_min_heap(arr, left):\n        return False\n\n    if right < size and not check_min_heap(arr, right):\n        return False\n\n    return True"}
{"task_id": "Mbpp/752", "solution": "def jacobsthal_num(n):\n    \"\"\"\n    Calculate the nth Jacobsthal number.\n\n    The Jacobsthal sequence is defined as:\n    J(0) = 0, J(1) = 1, and J(n) = J(n-1) + 2*J(n-2) for n > 1.\n\n    Args:\n    n (int): The index of the Jacobsthal number to calculate.\n\n    Returns:\n    int: The nth Jacobsthal number.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        # Initialize the first two Jacobsthal numbers.\n        j_n_minus_2 = 0\n        j_n_minus_1 = 1\n\n        # Calculate the nth Jacobsthal number.\n        for _ in range(2, n + 1):\n            j_n = j_n_minus_1 + 2 * j_n_minus_2\n            j_n_minus_2 = j_n_minus_1\n            j_n_minus_1 = j_n\n\n        return j_n"}
{"task_id": "Mbpp/753", "solution": "def min_k(tuples, k):\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n\n    # Return the first k elements\n    return sorted_tuples[:k]"}
{"task_id": "Mbpp/754", "solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function takes three lists as input and returns a new list containing the elements\n    that are common to all three lists at the same index.\n    \"\"\"\n    common_elements = []\n    for i in range(len(l1)):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements"}
{"task_id": "Mbpp/755", "solution": "def second_smallest(numbers):\n    # Remove duplicates from the list\n    unique_numbers = list(set(numbers))\n\n    # Check if there are at least two unique numbers in the list\n    if len(unique_numbers) < 2:\n        return None\n\n    # Sort the list of unique numbers\n    unique_numbers.sort()\n\n    # Return the second smallest number\n    return unique_numbers[1]"}
{"task_id": "Mbpp/757", "solution": "def count_reverse_pairs(strings):\n    # Create a dictionary to store the reverse of each string as the key and the string itself as the value\n    reverse_dict = {s[::-1]: s for s in strings}\n\n    # Initialize a counter for the pairs of reverse strings\n    count = 0\n\n    # Iterate over the strings in the list\n    for s in strings:\n        # If the reverse of the string is in the dictionary and it is not the same string, increment the counter\n        if s in reverse_dict and reverse_dict[s] != s:\n            count += 1\n            # Remove the reverse string from the dictionary to avoid counting it again\n            del reverse_dict[s]\n\n    # Return the count of pairs of reverse strings\n    return count"}
{"task_id": "Mbpp/758", "solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    return count_dict"}
{"task_id": "Mbpp/759", "solution": "import re\n\ndef is_decimal(s):\n    pattern = r'^\\d+\\.\\d{2}$'\n    if re.match(pattern, s):\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/760", "solution": "def unique_element(lst):\n    return len(set(lst)) == 1"}
{"task_id": "Mbpp/762", "solution": "def check_monthnumber_number(month):\n    \"\"\"\n    This function checks whether the given month number contains 30 days or not.\n    Months are given as a number from 1 to 12.\n\n    Parameters:\n    month (int): The month number to check.\n\n    Returns:\n    bool: True if the month has 30 days, False otherwise.\n    \"\"\"\n    # Define the list of months that have 30 days\n    months_with_30_days = [4, 6, 9, 11]\n\n    # Check if the given month number is in the list of months with 30 days\n    if month in months_with_30_days:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/763", "solution": "def find_min_diff(arr, n):\n    # Sort the array in ascending order\n    arr.sort()\n\n    # Initialize minimum difference as the maximum possible value\n    min_diff = float('inf')\n\n    # Iterate through the array and find the minimum difference\n    for i in range(1, n):\n        min_diff = min(min_diff, arr[i] - arr[i-1])\n\n    # Return the minimum difference\n    return min_diff"}
{"task_id": "Mbpp/764", "solution": "def number_ctr(input_string):\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count"}
{"task_id": "Mbpp/765", "solution": "def is_polite(n):\n    # Initialize a list to store polite numbers\n    polite_numbers = [0] * n\n\n    # Initialize variables to keep track of the next polite number and the current index\n    next_polite_number = 1\n    index = 0\n\n    # Loop until we have found the nth polite number\n    while index < n:\n        # Check if the next number is polite\n        if all(next_polite_number % i != 0 for i in range(2, int(next_polite_number ** 0.5) + 1)):\n            # If it is polite, add it to the list of polite numbers\n            polite_numbers[index] = next_polite_number\n            index += 1\n        # Move on to the next number\n        next_polite_number += 1\n\n    # Return the nth polite number\n    return polite_numbers[-1]"}
{"task_id": "Mbpp/766", "solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]"}
{"task_id": "Mbpp/767", "solution": "def get_pairs_count(nums, target_sum):\n    count = 0\n    num_dict = {}\n\n    for num in nums:\n        complement = target_sum - num\n        if complement in num_dict:\n            count += num_dict[complement]\n        if num in num_dict:\n            num_dict[num] += 1\n        else:\n            num_dict[num] = 1\n\n    return count"}
{"task_id": "Mbpp/769", "solution": "def Diff(li1, li2):\n    return list(set(li1) - set(li2)) + list(set(li2) - set(li1))"}
{"task_id": "Mbpp/770", "solution": "def odd_num_sum(n):\n    # The first n odd natural numbers are 1, 3, 5, ..., 2n-1\n    # The sum of the fourth powers of these numbers can be calculated using the formula:\n    # sum = (n * (8 * n^4 - 8 * n^2 + 1)) / 3\n    return (n * (8 * n**4 - 8 * n**2 + 1)) // 3"}
{"task_id": "Mbpp/771", "solution": "def check_expression(expression):\n    stack = []\n    opening = ['(', '{', '[']\n    closing = [')', '}', ']']\n    mapping = {')': '(', '}': '{', ']': '['}\n\n    for char in expression:\n        if char in opening:\n            stack.append(char)\n        elif char in closing:\n            if not stack or mapping[char] != stack.pop():\n                return False\n    return not stack"}
{"task_id": "Mbpp/772", "solution": "def remove_length(s, k):\n    # Split the string into words\n    words = s.split()\n\n    # Filter out the words with length k\n    filtered_words = [word for word in words if len(word) != k]\n\n    # Join the filtered words back into a string\n    result = ' '.join(filtered_words)\n\n    return result"}
{"task_id": "Mbpp/773", "solution": "def occurance_substring(string, substring):\n    index = string.find(substring)\n    if index != -1:\n        return (substring, index, index + len(substring))\n    else:\n        return None"}
{"task_id": "Mbpp/775", "solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True"}
{"task_id": "Mbpp/777", "solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set(lst)\n\n    # Initialize sum to 0\n    sum_unique = 0\n\n    # Iterate over the list\n    for element in lst:\n        # If the element is in the set, add it to the sum and remove it from the set\n        if element in unique_elements:\n            sum_unique += element\n            unique_elements.remove(element)\n\n    # Return the sum of unique elements\n    return sum_unique"}
{"task_id": "Mbpp/778", "solution": "def pack_consecutive_duplicates(lst):\n    if not lst:\n        return []\n\n    result = []\n    current_sublist = [lst[0]]\n\n    for i in range(1, len(lst)):\n        if lst[i] == lst[i - 1]:\n            current_sublist.append(lst[i])\n        else:\n            result.append(current_sublist)\n            current_sublist = [lst[i]]\n\n    result.append(current_sublist)\n    return result"}
{"task_id": "Mbpp/780", "solution": "from itertools import combinations\n\ndef find_combinations(tuples):\n    sums = []\n    for r in range(2, len(tuples) + 1):\n        for combination in combinations(tuples, r):\n            sums.append(tuple(sum(t) for t in combination))\n    return sums"}
{"task_id": "Mbpp/781", "solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0"}
{"task_id": "Mbpp/782", "solution": "def odd_length_sum(arr):\n    n = len(arr)\n    total = 0\n    for i in range(n):\n        total += ((i + 1) * (n - i) + 1) // 2 * arr[i]\n    return total"}
{"task_id": "Mbpp/783", "solution": "def rgb_to_hsv(r, g, b):\n    r, g, b = r / 255.0, g / 255.0, b / 255.0\n\n    max_val = max(r, g, b)\n    min_val = min(r, g, b)\n    diff = max_val - min_val\n\n    if max_val == min_val:\n        h = 0\n    elif max_val == r:\n        h = (60 * ((g - b) / diff) + 360) % 360\n    elif max_val == g:\n        h = (60 * ((b - r) / diff) + 120) % 360\n    elif max_val == b:\n        h = (60 * ((r - g) / diff) + 240) % 360\n\n    if max_val == 0:\n        s = 0\n    else:\n        s = (diff / max_val) * 100\n\n    v = max_val * 100\n\n    return h, s, v"}
{"task_id": "Mbpp/784", "solution": "def mul_even_odd(lst):\n    even = None\n    odd = None\n\n    for num in lst:\n        if num % 2 == 0:\n            even = num\n            if odd is not None:\n                break\n        else:\n            odd = num\n            if even is not None:\n                break\n\n    if even is not None and odd is not None:\n        return even * odd\n    else:\n        return None"}
{"task_id": "Mbpp/785", "solution": "def tuple_str_int(s):\n    # Remove the parentheses from the string\n    s = s[1:-1]\n\n    # Split the string into a list of strings, each representing an integer\n    str_list = s.split(', ')\n\n    # Convert each string to an integer and store the results in a list\n    int_list = [int(x) for x in str_list]\n\n    # Convert the list to a tuple and return the result\n    return tuple(int_list)"}
{"task_id": "Mbpp/786", "solution": "def right_insertion(sorted_list, value):\n    low = 0\n    high = len(sorted_list)\n\n    while low < high:\n        mid = (low + high) // 2\n        if sorted_list[mid] < value:\n            low = mid + 1\n        else:\n            high = mid\n\n    return low"}
{"task_id": "Mbpp/787", "solution": "import re\n\ndef text_match_three(text):\n    pattern = r'abbb'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/788", "solution": "def new_tuple(lst, string):\n    return tuple(lst + [string])"}
{"task_id": "Mbpp/790", "solution": "def even_position(lst):\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            return False\n    return True"}
{"task_id": "Mbpp/791", "solution": "def remove_nested(t):\n    # Base case: if t is not a tuple, return a tuple containing t\n    if not isinstance(t, tuple):\n        return (t,)\n\n    # Recursive case: if t is a tuple, recursively remove nested tuples from its elements\n    result = ()\n    for element in t:\n        result += remove_nested(element)\n\n    return result"}
{"task_id": "Mbpp/792", "solution": "def count_list(lst):\n    return len(lst)"}
{"task_id": "Mbpp/793", "solution": "def last(arr, x):\n    low = 0\n    high = len(arr) - 1\n    result = -1\n\n    while low <= high:\n        mid = (low + high) // 2\n\n        if arr[mid] == x:\n            result = mid\n            low = mid + 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return result"}
{"task_id": "Mbpp/794", "solution": "import re\n\ndef text_starta_endb(s):\n    pattern = r'^a.*b$'\n    if re.match(pattern, s):\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/796", "solution": "def return_sum(dictionary):\n    total_sum = 0\n    for value in dictionary.values():\n        total_sum += value\n    return total_sum"}
{"task_id": "Mbpp/797", "solution": "def sum_in_range(l, r):\n    \"\"\"\n    This function calculates the sum of all odd natural numbers within the range l and r.\n    \"\"\"\n    # Initialize the sum to 0\n    sum = 0\n\n    # Iterate through the range of numbers\n    for num in range(l, r + 1):\n        # Check if the number is odd\n        if num % 2 != 0:\n            # If the number is odd, add it to the sum\n            sum += num\n\n    # Return the sum of all odd numbers\n    return sum"}
{"task_id": "Mbpp/798", "solution": "def _sum(arr):\n    total = 0\n    for num in arr:\n        total += num\n    return total"}
{"task_id": "Mbpp/799", "solution": "def left_rotate(n, d):\n    return (n << d) | (n >> (32 - d))"}
{"task_id": "Mbpp/800", "solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')"}
{"task_id": "Mbpp/801", "solution": "def test_three_equal(a, b, c):\n    if a == b == c:\n        return 3\n    elif a == b or a == c or b == c:\n        return 2\n    else:\n        return 0"}
{"task_id": "Mbpp/803", "solution": "def is_perfect_square(n):\n    if n < 0:\n        return False\n    root = int(n ** 0.5)\n    return root * root == n"}
{"task_id": "Mbpp/804", "solution": "def is_product_even(numbers):\n    \"\"\"\n    This function takes a list of numbers as input and returns True if the product of all numbers in the list is even,\n    and False otherwise.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    bool: True if the product of all numbers in the list is even, False otherwise.\n    \"\"\"\n    product = 1\n    for number in numbers:\n        product *= number\n    return product % 2 == 0"}
{"task_id": "Mbpp/805", "solution": "def max_sum_list(lists):\n    max_sum = float('-inf')\n    max_list = []\n\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list"}
{"task_id": "Mbpp/806", "solution": "def max_run_uppercase(s):\n    max_run = 0\n    current_run = 0\n\n    for char in s:\n        if char.isupper():\n            current_run += 1\n            max_run = max(max_run, current_run)\n        else:\n            current_run = 0\n\n    return max_run"}
{"task_id": "Mbpp/807", "solution": "def first_odd(numbers):\n    for num in numbers:\n        if num % 2 != 0:\n            return num\n    return None"}
{"task_id": "Mbpp/808", "solution": "def check_K(tup, k):\n    return k in tup"}
{"task_id": "Mbpp/809", "solution": "def check_smaller(tuple1, tuple2):\n    for i in range(len(tuple1)):\n        if tuple2[i] >= tuple1[i]:\n            return False\n    return True"}
