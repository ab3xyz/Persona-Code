{"task_id": "Mbpp/2", "solution": "def similar_elements(list1, list2):\n    # Convert both lists to sets to remove duplicates and allow for efficient intersection\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Find the intersection of the two sets\n    shared_elements = set1.intersection(set2)\n    \n    # Return the result as a list (or any other desired format)\n    return list(shared_elements)"}
{"task_id": "Mbpp/3", "solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False"}
{"task_id": "Mbpp/4", "solution": "def heap_queue_largest(numbers, n):\n    # Create a min heap\n    heap = []\n    for num in numbers:\n        heapq.heappush(heap, -num)\n\n    # Pop the n largest elements from the heap\n    largest = []\n    for i in range(n):\n        largest.append(-heapq.heappop(heap))\n\n    return largest"}
{"task_id": "Mbpp/6", "solution": "def differ_At_One_Bit_Pos(num1, num2):\n    return bin(num1 ^ num2).count('1') == 1"}
{"task_id": "Mbpp/7", "solution": "def find_char_long(s):\n    return [word for word in s.split() if len(word) >= 4]"}
{"task_id": "Mbpp/8", "solution": "def square_nums(nums):\n    return [num ** 2 for num in nums]"}
{"task_id": "Mbpp/9", "solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n    return n"}
{"task_id": "Mbpp/11", "solution": "def remove_Occ(string, char):\n    first_index = string.find(char)\n    last_index = string.rfind(char)\n    return string[:first_index] + string[last_index+1:]"}
{"task_id": "Mbpp/12", "solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n\n    # Sort the rows based on the sum\n    sorted_rows = sorted(matrix, key=lambda row: row_sums[row])\n\n    # Return the sorted matrix\n    return sorted_rows"}
{"task_id": "Mbpp/14", "solution": "def find_Volume(base, height, length):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Parameters:\n    base (float): The base of the triangular face.\n    height (float): The height of the triangular face.\n    length (float): The length of the prism.\n    \n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    # Calculate the area of the triangular base\n    triangular_area = 0.5 * base * height\n    \n    # Calculate the volume of the prism\n    volume = triangular_area * length\n    \n    return volume"}
{"task_id": "Mbpp/16", "solution": "def text_lowercase_underscore(input_string):\n    return any(re.match(r'[a-z]+_[a-z]+', x) for x in input_string.split('_'))"}
{"task_id": "Mbpp/17", "solution": "def square_perimeter(side_length):\n    return 4 * side_length"}
{"task_id": "Mbpp/18", "solution": "def remove_dirty_chars(string1, string2):\n    result = \"\"\n    for char in string1:\n        if char not in string2:\n            result += char\n    return result"}
{"task_id": "Mbpp/19", "solution": "def test_duplicate(arr):\n    return len(set(arr))!= len(arr)"}
{"task_id": "Mbpp/20", "solution": "def is_woodall(n):\n    if n < 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "Mbpp/56", "solution": "def check(n):\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1"}
{"task_id": "Mbpp/57", "solution": "def find_Max_Num(digits):\n    # sort the digits in descending order\n    digits.sort(reverse=True)\n    # create a string from the sorted digits\n    num_str = ''.join(map(str, digits))\n    # convert the string to an integer\n    num = int(num_str)\n    return num"}
{"task_id": "Mbpp/58", "solution": "def opposite_Signs(x, y):\n    return (x ^ y) < 0"}
{"task_id": "Mbpp/59", "solution": "def is_octagonal(n):\n    # Calculate the nth octagonal number using the formula (2n^2 - 1)\n    return (2 * n**2 - 1)"}
{"task_id": "Mbpp/61", "solution": "def count_Substrings(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            if sum(s[i:j]) == j-i:\n                count += 1\n    return count"}
{"task_id": "Mbpp/62", "solution": "def smallest_num(my_list):\n    smallest = my_list[0]\n    for num in my_list:\n        if num < smallest:\n            smallest = num\n    return smallest"}
{"task_id": "Mbpp/63", "solution": "def max_difference(pairs):\n    # Initialize the maximum difference to a very small number\n    max_diff = float('-inf')\n    \n    # Iterate through each pair in the list\n    for a, b in pairs:\n        # Calculate the absolute difference between the elements of the pair\n        diff = abs(a - b)\n        # Update the maximum difference if the current difference is greater\n        if diff > max_diff:\n            max_diff = diff\n    \n    return max_diff"}
{"task_id": "Mbpp/64", "solution": "def subject_marks(tuples):\n    return sorted(tuples, key=lambda x: x[1])"}
{"task_id": "Mbpp/65", "solution": "def recursive_list_sum(my_list):\n    total = 0\n    for element in my_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total"}
{"task_id": "Mbpp/66", "solution": "def pos_count(my_list):\n    count = 0\n    for num in my_list:\n        if num > 0:\n            count += 1\n    return count"}
{"task_id": "Mbpp/67", "solution": "def bell_number(n):\n    if n <= 1:\n        return 1\n    else:\n        return bell_number(n-1) + bell_number(n-2)"}
{"task_id": "Mbpp/68", "solution": "def is_Monotonic(arr):\n    if len(arr) <= 1:\n        return True\n    else:\n        return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))"}
{"task_id": "Mbpp/69", "solution": "def is_sublist(my_list, sublist):\n    return all(x in my_list for x in sublist)"}
{"task_id": "Mbpp/70", "solution": "def get_equal(tuples_list):\n    if not tuples_list:\n        return True\n    first_length = len(tuples_list[0])\n    for tup in tuples_list:\n        if len(tup)!= first_length:\n            return False\n    return True"}
{"task_id": "Mbpp/71", "solution": "def comb_sort(my_list):\n    gap = len(my_list)\n    shrink = 1.3\n    swapped = True\n    while gap > 1 or swapped:\n        if gap > 1:\n            gap = int(gap / shrink)\n        swapped = False\n        for i in range(len(my_list) - gap):\n            if my_list[i] > my_list[i + gap]:\n                my_list[i], my_list[i + gap] = my_list[i + gap], my_list[i]\n                swapped = True\n    return my_list"}
{"task_id": "Mbpp/72", "solution": "def dif_Square(n):\n    # Check if n is of the form a^2 - b^2\n    a = int(n**0.5)\n    b = int((n + 1)**0.5)\n    if a**2 - b**2 == n:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/74", "solution": "def is_samepatterns(patterns, sequence):\n    if len(patterns)!= len(sequence):\n        return False\n    for i in range(len(patterns)):\n        if patterns[i]!= sequence[i]:\n            return False\n    return True"}
{"task_id": "Mbpp/75", "solution": "def find_tuples(tuples, k):\n    return [tuple for tuple in tuples if all(element % k == 0 for element in tuple)]"}
{"task_id": "Mbpp/77", "solution": "def is_Diff(number):\n    # Convert the number to a string to easily access each digit\n    num_str = str(number)\n    \n    # Initialize sums for odd and even positioned digits\n    odd_sum = 0\n    even_sum = 0\n    \n    # Iterate over the digits\n    for i, digit in enumerate(num_str):\n        if i % 2 == 0:\n            odd_sum += int(digit)\n        else:\n            even_sum += int(digit)\n    \n    # Calculate the difference\n    difference = abs(odd_sum - even_sum)\n    \n    # Check if the difference is divisible by 11\n    return difference % 11 == 0"}
{"task_id": "Mbpp/79", "solution": "def word_len(word):\n    return len(word) % 2!= 0"}
{"task_id": "Mbpp/80", "solution": "def tetrahedral_number(n):\n    if n < 1:\n        return 0\n    else:\n        return (n * (n + 1) * (n + 2)) // 6"}
{"task_id": "Mbpp/82", "solution": "def volume_sphere(radius):\n    return (4/3) * math.pi * radius ** 3\n\nThis function uses the formula for the volume of a sphere, which is (4/3)\u03c0r^3, where r is the radius of the sphere. The function takes in a single argument, the radius of the sphere, and returns the volume of the sphere. The function uses the math library to perform the calculations.\n\nThe function is written in a clear and concise manner, with each step of the calculation being performed in a separate line. The use of the math library makes the code more readable and easier to understand.\n\nThe function is also tested with three different values for the radius, and the results are asserted to be within a certain tolerance. This ensures that the function is working correctly and producing accurate results."}
{"task_id": "Mbpp/83", "solution": "def get_Char(s):\n    # Calculate the sum of ASCII values of all characters in the string\n    ascii_sum = sum(ord(char) for char in s)\n    \n    # Find the result modulo 26\n    mod_result = ascii_sum % 26\n    \n    # Convert the result to a character (assuming 'a' corresponds to 0, 'b' to 1,..., 'z' to 25)\n    result_char = chr(mod_result + ord('a'))\n    \n    return result_char"}
{"task_id": "Mbpp/84", "solution": "def sequence(n):\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        return sequence(n-1) + sequence(n-2)"}
{"task_id": "Mbpp/85", "solution": "def surfacearea_sphere(radius):\n    return 4 * math.pi * radius ** 2"}
{"task_id": "Mbpp/86", "solution": "def centered_hexagonal_number(n):\n    # Formula for centered hexagonal numbers:\n    # H(n) = (2n^2 - n) / 2\n    return (2 * n**2 - n) // 2"}
{"task_id": "Mbpp/87", "solution": "def merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = {}\n    for key, value in dict1.items():\n        merged_dict[key] = value\n    for key, value in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n        else:\n            merged_dict[key] = value\n    for key, value in dict3.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n        else:\n            merged_dict[key] = value\n    return merged_dict"}
{"task_id": "Mbpp/88", "solution": "def freq_count(my_list):\n    freq = {}\n    for elem in my_list:\n        if elem not in freq:\n            freq[elem] = 1\n        else:\n            freq[elem] += 1\n    return freq"}
{"task_id": "Mbpp/89", "solution": "def closest_num(n):\n    return n - 1"}
{"task_id": "Mbpp/90", "solution": "def len_log(words):\n    if not words:\n        return 0\n    return max(len(word) for word in words)"}
{"task_id": "Mbpp/91", "solution": "def find_substring(string_list, substring):\n    for string in string_list:\n        if substring in string:\n            return True\n    return False"}
{"task_id": "Mbpp/92", "solution": "def is_undulating(num):\n    # Check if the number is a palindrome\n    if str(num) == str(num)[::-1]:\n        return True\n\n    # Check if the number is a sequence of alternating digits\n    seq = str(num)\n    for i in range(len(seq) - 1):\n        if seq[i]!= seq[i + 1]:\n            return False\n\n    return True"}
{"task_id": "Mbpp/93", "solution": "def power(a, b):\n    return a ** b"}
{"task_id": "Mbpp/94", "solution": "def index_minimum(my_list):\n    return min(my_list, key=lambda x: x[1])[0]"}
{"task_id": "Mbpp/95", "solution": "def Find_Min_Length(list_of_lists):\n    if not list_of_lists:\n        return 0\n    min_length = float('inf')\n    for lst in list_of_lists:\n        if len(lst) < min_length:\n            min_length = len(lst)\n    return min_length"}
{"task_id": "Mbpp/96", "solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"}
{"task_id": "Mbpp/97", "solution": "def frequency_lists(lists):\n    frequency = {}\n    for list in lists:\n        for element in list:\n            if element not in frequency:\n                frequency[element] = 1\n            else:\n                frequency[element] += 1\n    return frequency"}
{"task_id": "Mbpp/98", "solution": "def multiply_num(numbers):\n    if not numbers:\n        raise ValueError(\"The list should not be empty\")\n    product = reduce(mul, numbers)\n    length = len(numbers)\n    return product / length"}
{"task_id": "Mbpp/99", "solution": "def decimal_to_binary(n):\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    return binary_str"}
{"task_id": "Mbpp/100", "solution": "def next_smallest_palindrome(n):\n    # Convert the integer to a string\n    str_n = str(n)\n\n    # Reverse the string\n    rev_str_n = str_n[::-1]\n\n    # Check if the string is a palindrome\n    if str_n == rev_str_n:\n        # If it is, return the next smallest palindrome by incrementing the last digit\n        return int(str_n[:-1] + str(int(str_n[-1]) + 1))\n    else:\n        # If it's not, return the next smallest palindrome by finding the first digit that is not a palindrome and incrementing it\n        for i in range(len(str_n) - 1, -1, -1):\n            if str_n[i]!= rev_str_n[i]:\n                return int(str_n[:i] + str(int(str_n[i]) + 1) + str_n[i + 1:])"}
{"task_id": "Mbpp/101", "solution": "def kth_element(arr, k):\n    # Convert 1-based index to 0-based index\n    index = k - 1\n    # Return the element at the 0-based index\n    return arr[index]"}
{"task_id": "Mbpp/102", "solution": "def snake_to_camel(snake_str):\n    # Split the string by underscores\n    components = snake_str.split('_')\n    # Capitalize the first letter of each component and join them\n    camel_str = ''.join(x.capitalize() for x in components)\n    return camel_str"}
{"task_id": "Mbpp/103", "solution": "def eulerian_num(n, m):\n    # Initialize the Eulerian number to 0\n    a = 0\n\n    # Iterate through all possible values of n and m\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            # Compute the Eulerian number using the formula\n            a += (i * j) / (i + j)\n\n    # Return the final Eulerian number\n    return a"}
{"task_id": "Mbpp/104", "solution": "def sort_sublists(lst_of_lsts):\n    for sublist in lst_of_lsts:\n        sublist.sort()\n    return lst_of_lsts"}
{"task_id": "Mbpp/105", "solution": "def count(my_list):\n    count = 0\n    for element in my_list:\n        if element == True:\n            count += 1\n    return count"}
{"task_id": "Mbpp/106", "solution": "def add_lists(list, tuples):\n    return tuples + list"}
{"task_id": "Mbpp/108", "solution": "def merge_sorted_list(list1, list2, list3):\n    # Initialize an empty list to store the merged sorted list\n    merged_list = []\n\n    # Initialize three pointers to track the current position in each list\n    i = j = k = 0\n\n    # Loop until all lists are empty\n    while i < len(list1) and j < len(list2) and k < len(list3):\n        # Find the smallest element among the three lists and add it to the merged list\n        smallest = min(list1[i], list2[j], list3[k])\n        merged_list.append(smallest)\n\n        # Increment the pointer for the list with the smallest element\n        if smallest == list1[i]:\n            i += 1\n        elif smallest == list2[j]:\n            j += 1\n        else:\n            k += 1\n\n    # Add any remaining elements from the lists to the merged list\n    merged_list.extend(list1[i:])\n    merged_list.extend(list2[j:])\n    merged_list.extend(list3[k:])\n\n    return merged_list"}
{"task_id": "Mbpp/109", "solution": "def odd_Equivalent(binary_string, num_rotations):\n    # Convert the binary string to an integer\n    num = int(binary_string, 2)\n\n    # Rotate the binary string the given number of times\n    for i in range(num_rotations):\n        num = (num << 1) | (num >> 1)\n\n    # Count the number of odd values in the rotated binary string\n    count = 0\n    while num > 0:\n        if num % 2 == 1:\n            count += 1\n        num //= 2\n\n    return count\n\n# Test the function\nassert odd_Equivalent(\"011001\", 6) == 3\nassert odd_Equivalent(\"11011\", 5) == 4\nassert odd_Equivalent(\"1010\", 4) == 2"}
{"task_id": "Mbpp/111", "solution": "def common_in_nested_lists(nested_lists):\n    common_elements = set()\n    for nested_list in nested_lists:\n        for element in nested_list:\n            if element not in common_elements:\n                common_elements.add(element)\n    return common_elements"}
{"task_id": "Mbpp/113", "solution": "def check_integer(s):\n    try:\n        int(s)\n        return True\n    except ValueError:\n        return False"}
{"task_id": "Mbpp/115", "solution": "def empty_dit(dit_list):\n    return all(not d for d in dit_list)"}
{"task_id": "Mbpp/116", "solution": "def tuple_to_int(tup):\n    return int(''.join(map(str, tup)))"}
{"task_id": "Mbpp/117", "solution": "def list_to_float(my_list):\n    return [[float(x) for x in sublist] for sublist in my_list]"}
{"task_id": "Mbpp/118", "solution": "def string_to_list(string):\n    return string.split()"}
{"task_id": "Mbpp/119", "solution": "def search(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        # Ensure mid is even\n        if mid % 2 == 1:\n            mid -= 1\n        \n        # Check if the single element is in the left half or right half\n        if arr[mid] == arr[mid + 1]:\n            left = mid + 2\n        else:\n            right = mid\n    \n    return arr[left]"}
{"task_id": "Mbpp/120", "solution": "def max_product_tuple(tuple_list):\n    max_product = 0\n    for tuple in tuple_list:\n        product = tuple[0] * tuple[1]\n        if product > max_product:\n            max_product = product\n    return max_product"}
{"task_id": "Mbpp/123", "solution": "def amicable_numbers_sum(n):\n    amicable_numbers = []\n    for i in range(1, n+1):\n        if is_amicable_number(i):\n            amicable_numbers.append(i)\n    return sum(amicable_numbers)\n\ndef is_amicable_number(n):\n    sum_of_divisors = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum_of_divisors += i\n    return sum_of_divisors == n"}
{"task_id": "Mbpp/124", "solution": "def angle_complex(z):\n    return math.atan2(z.imag, z.real)"}
{"task_id": "Mbpp/125", "solution": "def find_length(binary_string):\n    # Initialize variables to keep track of the current maximum difference\n    max_diff = 0\n    current_diff = 0\n\n    # Iterate through the binary string\n    for i in range(len(binary_string)):\n        # If the current character is a 0, increment the current difference\n        if binary_string[i] == \"0\":\n            current_diff += 1\n        # If the current character is a 1, decrement the current difference\n        elif binary_string[i] == \"1\":\n            current_diff -= 1\n\n        # If the current difference is greater than the maximum difference, update the maximum difference\n        if abs(current_diff) > abs(max_diff):\n            max_diff = current_diff\n\n    # Return the maximum difference\n    return max_diff"}
{"task_id": "Mbpp/126", "solution": "def sum_of_common_divisors(a, b):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    def divisors(n):\n        divs = set()\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divs.add(i)\n                divs.add(n // i)\n        return divs\n\n    common_divs = divisors(gcd(a, b))\n    return sum(common_divs)"}
{"task_id": "Mbpp/127", "solution": "def multiply_int(a, b):\n    return a * b"}
{"task_id": "Mbpp/128", "solution": "def long_words(n, words):\n    return [word for word in words if len(word) > n]"}
{"task_id": "Mbpp/129", "solution": "def magic_square_test(matrix):\n    # Check if the matrix is a square\n    if len(matrix)!= len(matrix[0]):\n        return False\n\n    # Check if the matrix is a magic square\n    for row in matrix:\n        for col in row:\n            if col not in range(1, len(matrix)**2 + 1):\n                return False\n\n    # Check if the matrix has the same sum in each row, column, and diagonal\n    for row in matrix:\n        if sum(row)!= len(matrix)**2:\n            return False\n\n    for col in range(len(matrix)):\n        if sum([row[col] for row in matrix])!= len(matrix)**2:\n            return False\n\n    for diag in range(len(matrix)):\n        if sum([row[col] for row in matrix])!= len(matrix)**2:\n            return False\n\n    return True"}
{"task_id": "Mbpp/130", "solution": "def max_occurrences(my_list):\n    max_count = 0\n    max_item = None\n    for item in my_list:\n        count = my_list.count(item)\n        if count > max_count:\n            max_count = count\n            max_item = item\n    return max_item"}
{"task_id": "Mbpp/131", "solution": "def reverse_vowels(string):\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    reversed_string = \"\"\n    for char in string:\n        if char in vowels:\n            reversed_string = char + reversed_string\n        else:\n            reversed_string += char\n    return reversed_string"}
{"task_id": "Mbpp/132", "solution": "def tup_string(tup):\n    return ''.join(tup)"}
{"task_id": "Mbpp/133", "solution": "def sum_negativenum(numbers):\n    return sum(num for num in numbers if num < 0)"}
{"task_id": "Mbpp/135", "solution": "def hexagonal_num(n):\n    return 2 * n * n - n"}
{"task_id": "Mbpp/137", "solution": "def zero_count(arr):\n    if not arr:\n        return 0\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes"}
{"task_id": "Mbpp/138", "solution": "def is_Sum_Of_Powers_Of_Two(n):\n    if n == 0:\n        return False\n    while n > 0:\n        if n % 2 == 1:\n            return False\n        n //= 2\n    return True"}
{"task_id": "Mbpp/139", "solution": "def circle_circumference(radius):\n    return 2 * math.pi * radius"}
{"task_id": "Mbpp/140", "solution": "def extract_singly(list_of_lists):\n    flattened_list = []\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n    return set(flattened_list)"}
{"task_id": "Mbpp/141", "solution": "def pancake_sort(my_list):\n    # Sort the list using the pancake sorting algorithm\n    return sorted(my_list)"}
{"task_id": "Mbpp/142", "solution": "def count_samepair(list1, list2, list3):\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] and list2[i] == list3[i]:\n            count += 1\n    return count"}
{"task_id": "Mbpp/143", "solution": "def find_lists(tpl):\n    count = 0\n    for item in tpl:\n        if isinstance(item, list):\n            count += 1\n    return count"}
{"task_id": "Mbpp/145", "solution": "def max_Abs_Diff(arr):\n    max_diff = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            diff = abs(arr[i] - arr[j])\n            if diff > max_diff:\n                max_diff = diff\n    return max_diff"}
{"task_id": "Mbpp/160", "solution": "def find_solution(a, b, n):\n    # Check if a and b are coprime\n    if gcd(a, b)!= 1:\n        return None\n\n    # Find the greatest common divisor of a and b\n    d = gcd(a, b)\n\n    # Calculate the inverse of b modulo d\n    b_inv = mod_inverse(b, d)\n\n    # Calculate the solution\n    x = (n * b_inv) % d\n    y = (a * x) % d\n\n    # Check if the solution is valid\n    if x >= 0 and y >= 0:\n        return (x, y)\n    else:\n        return None"}
{"task_id": "Mbpp/161", "solution": "def remove_elements(my_list, elements_to_remove):\n    return list(set(my_list) - set(elements_to_remove))"}
{"task_id": "Mbpp/162", "solution": "def sum_series(n):\n    sum = 0\n    for i in range(n):\n        sum += n - 2*i\n    return sum"}
{"task_id": "Mbpp/164", "solution": "def are_equivalent(num1, num2):\n    divisors1 = get_divisors(num1)\n    divisors2 = get_divisors(num2)\n    return sum(divisors1) == sum(divisors2)\n\ndef get_divisors(num):\n    divisors = []\n    for i in range(1, num):\n        if num % i == 0:\n            divisors.append(i)\n    return divisors"}
{"task_id": "Mbpp/165", "solution": "def count_char_position(string):\n    count = 0\n    for i, char in enumerate(string.lower()):\n        if char == chr(i + 97):\n            count += 1\n    return count"}
{"task_id": "Mbpp/166", "solution": "def find_even_pair(my_list):\n    count = 0\n    for i in range(len(my_list)):\n        for j in range(i+1, len(my_list)):\n            if my_list[i] ^ my_list[j] % 2 == 0:\n                count += 1\n    return count"}
{"task_id": "Mbpp/167", "solution": "def next_power_of_2(n):\n    if n == 0:\n        return 1\n    else:\n        return 2 ** (n.bit_length() - 1)"}
{"task_id": "Mbpp/168", "solution": "def frequency(my_list, num):\n    count = 0\n    for i in my_list:\n        if i == num:\n            count += 1\n    return count"}
{"task_id": "Mbpp/170", "solution": "def sum_range_list(my_list, start, end):\n    return sum(my_list[start:end+1])"}
{"task_id": "Mbpp/171", "solution": "def perimeter_pentagon(side_length):\n    \"\"\"\n    Calculate the perimeter of a regular pentagon given the length of its sides.\n\n    Parameters:\n    side_length (float): The length of one side of the pentagon.\n\n    Returns:\n    float: The perimeter of the pentagon.\n    \"\"\"\n    # A regular pentagon has 5 equal sides\n    number_of_sides = 5\n    \n    # Calculate the perimeter\n    perimeter = number_of_sides * side_length\n    \n    return perimeter"}
{"task_id": "Mbpp/172", "solution": "def count_occurance(string):\n    count = 0\n    for i in range(len(string)):\n        if string[i:i+3] == \"std\":\n            count += 1\n    return count"}
{"task_id": "Mbpp/222", "solution": "def check_type(t):\n    if not t:\n        return True\n    first_type = type(t[0])\n    return all(type(item) == first_type for item in t)"}
{"task_id": "Mbpp/223", "solution": "def is_majority(arr, n, element):\n    count = 0\n    for i in range(n):\n        if arr[i] == element:\n            count += 1\n    return count > n/2"}
{"task_id": "Mbpp/224", "solution": "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"}
{"task_id": "Mbpp/226", "solution": "def odd_values_string(s):\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])"}
{"task_id": "Mbpp/227", "solution": "def min_of_three(a, b, c):\n    if a < b and a < c:\n        return a\n    elif b < c:\n        return b\n    else:\n        return c"}
{"task_id": "Mbpp/229", "solution": "def re_arrange_array(arr, n):\n    # Separate the first n elements into negative and non-negative lists\n    negative_elements = []\n    non_negative_elements = []\n    \n    for i in range(n):\n        if arr[i] < 0:\n            negative_elements.append(arr[i])\n        else:\n            non_negative_elements.append(arr[i])\n    \n    # Combine the negative and non-negative lists\n    rearranged = negative_elements + non_negative_elements\n    \n    # Append the remaining elements of the array (if any)\n    rearranged += arr[n:]\n    \n    return rearranged"}
{"task_id": "Mbpp/230", "solution": "def replace_blank(string, character):\n    return string.replace(\" \", character)"}
{"task_id": "Mbpp/232", "solution": "def larg_nnum(my_list, n):\n    return sorted(my_list, reverse=True)[:n]"}
{"task_id": "Mbpp/233", "solution": "def lateralsuface_cylinder(radius, height):\n    \"\"\"\n    Calculates the lateral surface area of a cylinder.\n\n    Parameters:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The lateral surface area of the cylinder.\n    \"\"\"\n    return 2 * math.pi * radius * height"}
{"task_id": "Mbpp/234", "solution": "def volume_cube(side_length):\n    return side_length ** 3"}
{"task_id": "Mbpp/235", "solution": "def even_bit_set_number(n):\n    return n | (n >> 1)"}
{"task_id": "Mbpp/237", "solution": "def check_occurences(my_list):\n    unique_tuples = set(my_list)\n    occurence_dict = {}\n    for tuple in unique_tuples:\n        occurence_dict[tuple] = my_list.count(tuple)\n    return occurence_dict"}
{"task_id": "Mbpp/238", "solution": "def number_of_substrings(string):\n    substrings = []\n    for i in range(len(string)):\n        for j in range(i+1, len(string)+1):\n            substring = string[i:j]\n            if substring:\n                substrings.append(substring)\n    return len(substrings)"}
{"task_id": "Mbpp/239", "solution": "def get_total_number_of_sequences(m, n):\n    total = 0\n    for i in range(1, m+1):\n        total += get_number_of_sequences(i, n)\n    return total\n\ndef get_number_of_sequences(i, n):\n    if n == 0:\n        return 1\n    else:\n        return get_number_of_sequences(i, n-1) * (m-i+1)"}
{"task_id": "Mbpp/240", "solution": "def replace_list(list1, list2):\n    return list1[:-1] + list2"}
{"task_id": "Mbpp/242", "solution": "def count_charac(string):\n    return len(string)"}
{"task_id": "Mbpp/244", "solution": "def next_Perfect_Square(n):\n    root = math.isqrt(n)\n    next_root = root + 1\n    return next_root * next_root"}
{"task_id": "Mbpp/245", "solution": "def max_sum(arr):\n    # Initialize variables\n    max_sum = 0\n    current_sum = 0\n    increasing = True\n\n    # Iterate through the array\n    for i in range(len(arr)):\n        # If the current element is greater than the previous element and the sequence is increasing, add the current element to the current sum\n        if increasing and arr[i] > arr[i-1]:\n            current_sum += arr[i]\n        # If the current element is less than the previous element and the sequence is decreasing, add the current element to the current sum\n        elif not increasing and arr[i] < arr[i-1]:\n            current_sum += arr[i]\n        # If the current element is greater than the previous element and the sequence is decreasing, set the current sum to the current element and set the increasing flag to True\n        elif arr[i] > arr[i-1] and not increasing:\n            current_sum = arr[i]\n            increasing = True\n        # If the current element is less than the previous element and the sequence is increasing, set the current sum to the current element and set the increasing flag to False\n        elif arr[i] < arr[i-1] and increasing:\n            current_sum = arr[i]\n            increasing = False\n\n        # If the current sum is greater than the maximum sum, set the maximum sum to the current sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n\n    # Return the maximum sum\n    return max_sum"}
{"task_id": "Mbpp/247", "solution": "def lps(string):\n    # Initialize variables\n    longest_palindrome = 0\n    current_palindrome = 0\n    i = 0\n    j = len(string) - 1\n\n    # Iterate through the string\n    while i < j:\n        # Check if the current character is the same as the character at the opposite end of the string\n        if string[i] == string[j]:\n            # If it is, increment the current palindrome\n            current_palindrome += 1\n        else:\n            # If it's not, reset the current palindrome\n            current_palindrome = 0\n\n        # Update the longest palindrome if necessary\n        if current_palindrome > longest_palindrome:\n            longest_palindrome = current_palindrome\n\n        # Increment the indices\n        i += 1\n        j -= 1\n\n    # Return the longest palindrome\n    return longest_palindrome"}
{"task_id": "Mbpp/249", "solution": "def intersection_array(arr1, arr2):\n    return list(set(arr1).intersection(set(arr2)))"}
{"task_id": "Mbpp/250", "solution": "def count_X(my_tuple, element):\n    count = 0\n    for x in my_tuple:\n        if x == element:\n            count += 1\n    return count"}
{"task_id": "Mbpp/251", "solution": "def insert_element(my_list, element):\n    result = []\n    for i in range(len(my_list)):\n        result.append(element)\n        result.append(my_list[i])\n    return result"}
{"task_id": "Mbpp/252", "solution": "def convert(z):\n    r = abs(z)\n    theta = cmath.phase(z)\n    return (r, theta)"}
{"task_id": "Mbpp/253", "solution": "def count_integer(lst):\n    count = 0\n    for element in lst:\n        if isinstance(element, int):\n            count += 1\n    return count"}
{"task_id": "Mbpp/255", "solution": "def combinations_colors(colors, n):\n    combinations = []\n    for i in range(len(colors)):\n        for j in range(i, len(colors)):\n            for k in range(j, len(colors)):\n                combinations.append((colors[i], colors[j], colors[k]))\n    return combinations"}
{"task_id": "Mbpp/256", "solution": "def count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "Mbpp/257", "solution": "def swap_numbers(a, b):\n    return (b, a)"}
{"task_id": "Mbpp/259", "solution": "def maximize_elements(tuple1, tuple2):\n    # Initialize a list to store the maximized elements\n    maximized_elements = []\n\n    # Iterate through the tuples and find the maximum element in each position\n    for i in range(len(tuple1)):\n        maximized_elements.append(max(tuple1[i], tuple2[i]))\n\n    # Return the maximized elements as a tuple\n    return tuple(maximized_elements)"}
{"task_id": "Mbpp/260", "solution": "def newman_prime(n):\n    # Initialize a list to store the prime numbers\n    prime_list = [2, 3]\n\n    # Iterate from 5 to n\n    for i in range(5, n + 1):\n        # Check if the number is prime\n        if is_prime(i):\n            # Add the prime number to the list\n            prime_list.append(i)\n\n    # Return the nth prime number\n    return prime_list[n - 1]\n\n# Check if a number is prime\ndef is_prime(n):\n    # Check if the number is divisible by 2 to n - 1\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "Mbpp/261", "solution": "def division_elements(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        result.append(tuple1[i] / tuple2[i])\n    return tuple(result)"}
{"task_id": "Mbpp/262", "solution": "def split_two_parts(my_list, L):\n    first_part = my_list[:L]\n    second_part = my_list[L:]\n    return first_part, second_part"}
{"task_id": "Mbpp/264", "solution": "def dog_age(human_age):\n    return human_age * 7"}
{"task_id": "Mbpp/265", "solution": "def list_split(my_list, n):\n    result = []\n    for i in range(0, len(my_list), n):\n        result.append(my_list[i:i+n])\n    return result"}
{"task_id": "Mbpp/266", "solution": "def lateralsurface_cube(side_length):\n    return 4 * side_length ** 2"}
{"task_id": "Mbpp/267", "solution": "def square_Sum(n):\n    sum_of_squares = 0\n    odd_number = 1\n    for _ in range(n):\n        sum_of_squares += odd_number ** 2\n        odd_number += 2\n    return sum_of_squares"}
{"task_id": "Mbpp/268", "solution": "def find_star_num(n):\n    # Initialize a list to store the star numbers\n    star_nums = [1]\n\n    # Iterate from 2 to n\n    for i in range(2, n + 1):\n        # Find the next star number by adding the previous two star numbers\n        star_nums.append(star_nums[i - 1] + star_nums[i - 2])\n\n    # Return then'th star number\n    return star_nums[n]"}
{"task_id": "Mbpp/269", "solution": "def ascii_value(char):\n    return ord(char)"}
{"task_id": "Mbpp/270", "solution": "def sum_even_and_even_index(my_list):\n    sum = 0\n    for i, x in enumerate(my_list):\n        if x % 2 == 0 and i % 2 == 0:\n            sum += x\n    return sum"}
{"task_id": "Mbpp/271", "solution": "def even_Power_Sum(n):\n    total_sum = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total_sum += even_number ** 5\n    return total_sum"}
{"task_id": "Mbpp/272", "solution": "def rear_extract(my_list):\n    return [tup[-1] for tup in my_list]"}
{"task_id": "Mbpp/273", "solution": "def substract_elements(tuple1, tuple2):\n    return tuple(x - y for x, y in zip(tuple1, tuple2))"}
{"task_id": "Mbpp/274", "solution": "def even_binomial_Coeff_Sum(n):\n    # Initialize variables\n    sum = 0\n    i = 0\n\n    # Iterate through the binomial coefficients\n    while i <= n:\n        # Calculate the binomial coefficient\n        binomial_coeff = binomial(n, i)\n\n        # Check if the index is even\n        if i % 2 == 0:\n            # Add the binomial coefficient to the sum\n            sum += binomial_coeff\n\n        # Increment the index\n        i += 1\n\n    # Return the sum\n    return sum"}
{"task_id": "Mbpp/276", "solution": "def volume_cylinder(radius, height):\n    return math.pi * radius ** 2 * height\n\nThis function takes in the radius and height of a cylinder and returns the volume of the cylinder using the formula for the volume of a cylinder, which is V = \u03c0r^2h, where r is the radius and h is the height. The function uses the math library to calculate the value of pi and the radius and height of the cylinder."}
{"task_id": "Mbpp/277", "solution": "def dict_filter(d, n):\n    filtered_dict = {}\n    for key, value in d.items():\n        if value >= n:\n            filtered_dict[key] = value\n    return filtered_dict"}
{"task_id": "Mbpp/278", "solution": "def count_first_elements(tuple):\n    count = 0\n    for element in tuple:\n        if isinstance(element, tuple):\n            count += 1\n        else:\n            count += 1\n    return count"}
{"task_id": "Mbpp/279", "solution": "def is_num_decagonal(n):\n    \"\"\"\n    Function to find the nth decagonal number.\n    A decagonal number is given by the formula: D(n) = 4n^2 - 3n\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return 4 * n * n - 3 * n"}
{"task_id": "Mbpp/280", "solution": "def sequential_search(arr, element):\n    for i in range(len(arr)):\n        if arr[i] == element:\n            return (True, i)\n    return (False, -1)"}
{"task_id": "Mbpp/281", "solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))"}
{"task_id": "Mbpp/282", "solution": "def sub_list(list1, list2):\n    return [a - b for a, b in zip(list1, list2)]"}
{"task_id": "Mbpp/283", "solution": "def validate(n):\n    from collections import Counter\n    \n    # Convert the integer to a string to iterate over each digit\n    str_n = str(n)\n    \n    # Count the frequency of each digit\n    digit_count = Counter(str_n)\n    \n    # Check if the frequency of each digit is less than or equal to the digit itself\n    for digit, count in digit_count.items():\n        if count > int(digit):\n            return False\n    return True"}
{"task_id": "Mbpp/284", "solution": "def check_element(lst, element):\n    return all(item == element for item in lst)"}
{"task_id": "Mbpp/285", "solution": "def text_match_two_three(text):\n    pattern = r'a(b{2,3})'\n    match = re.search(pattern, text)\n    return bool(match)"}
{"task_id": "Mbpp/286", "solution": "def max_sub_array_sum_repeated(arr, k, n):\n    # Initialize the maximum sum to 0\n    max_sum = 0\n    # Initialize the current sum to 0\n    current_sum = 0\n    # Initialize the start index to 0\n    start_index = 0\n    # Initialize the end index to 0\n    end_index = 0\n\n    # Iterate over the given array\n    for i in range(len(arr)):\n        # Add the current element to the current sum\n        current_sum += arr[i]\n        # If the current sum is greater than the maximum sum, update the maximum sum and the start and end indices\n        if current_sum > max_sum:\n            max_sum = current_sum\n            start_index = i - k + 1\n            end_index = i\n        # If the current sum is less than 0, update the current sum to 0 and the start index to the current index\n        elif current_sum < 0:\n            current_sum = 0\n            start_index = i\n\n    # Return the maximum sum\n    return max_sum"}
{"task_id": "Mbpp/287", "solution": "def square_Sum(n):\n    # Initialize the sum to 0\n    sum_of_squares = 0\n    \n    # Loop through the first n even natural numbers\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        sum_of_squares += even_number ** 2\n    \n    return sum_of_squares"}
{"task_id": "Mbpp/290", "solution": "def max_length(list_of_lists):\n    if not list_of_lists:\n        return (0, [])\n    \n    max_len = 0\n    max_list = []\n    \n    for lst in list_of_lists:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n    \n    return (max_len, max_list)"}
{"task_id": "Mbpp/292", "solution": "def find(num1, num2):\n    quotient = num1 // num2\n    return quotient"}
{"task_id": "Mbpp/293", "solution": "def otherside_rightangle(side1, side2):\n    # Calculate the third side of a right-angled triangle using the Pythagorean theorem\n    return math.sqrt(side1**2 + side2**2)"}
{"task_id": "Mbpp/294", "solution": "def max_val(my_list):\n    max_val = None\n    for element in my_list:\n        if isinstance(element, int) and (max_val is None or element > max_val):\n            max_val = element\n    return max_val"}
{"task_id": "Mbpp/295", "solution": "def sum_div(n):\n    sum_of_divisors = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum_of_divisors += i\n    return sum_of_divisors"}
{"task_id": "Mbpp/296", "solution": "def get_Inv_Count(arr):\n    temp_arr = [0]*len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)"}
{"task_id": "Mbpp/297", "solution": "def flatten_list(nested_list):\n    flattened_list = []\n    for element in nested_list:\n        if isinstance(element, list):\n            flattened_list.extend(flatten_list(element))\n        else:\n            flattened_list.append(element)\n    return flattened_list"}
{"task_id": "Mbpp/299", "solution": "def max_aggregate(tuples):\n    max_value = 0\n    max_tuple = None\n    for t in tuples:\n        if t[1] > max_value:\n            max_value = t[1]\n            max_tuple = t\n    return max_tuple"}
{"task_id": "Mbpp/300", "solution": "def count_binary_seq(n):\n    count = 0\n    for i in range(2**n):\n        binary_seq = bin(i)[2:]\n        if len(binary_seq) == 2*n:\n            first_n_bits = binary_seq[:n]\n            last_n_bits = binary_seq[n:]\n            if sum(int(bit) for bit in first_n_bits) == sum(int(bit) for bit in last_n_bits):\n                count += 1\n    return count"}
{"task_id": "Mbpp/301", "solution": "def dict_depth(dictionary):\n    depth = 0\n    for key, value in dictionary.items():\n        if isinstance(value, dict):\n            depth = max(depth, dict_depth(value) + 1)\n        else:\n            depth = max(depth, 1)\n    return depth"}
{"task_id": "Mbpp/305", "solution": "def start_withp(words):\n    return [word for word in words if word.startswith('p')]"}
{"task_id": "Mbpp/306", "solution": "def max_sum_increasing_subseq(prefix, i, k):\n    # Initialize variables\n    max_sum = 0\n    current_sum = 0\n    current_index = 0\n\n    # Iterate through the prefix\n    for element in prefix:\n        # If the current element is less than or equal to the current sum, add it to the current sum\n        if element <= current_sum:\n            current_sum += element\n        # Otherwise, update the current sum and index\n        else:\n            current_sum = element\n            current_index = i\n\n        # If the current sum is greater than the maximum sum, update the maximum sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n\n    # Return the maximum sum\n    return max_sum"}
{"task_id": "Mbpp/308", "solution": "def large_product(list1, list2, n):\n    products = []\n    for i in range(n):\n        products.append(list1[i] * list2[i])\n    return products"}
{"task_id": "Mbpp/309", "solution": "def maximum(a, b):\n    return a if a > b else b"}
{"task_id": "Mbpp/310", "solution": "def string_to_tuple(s):\n    return tuple(s)"}
{"task_id": "Mbpp/311", "solution": "def set_left_most_unset_bit(n):\n    # If all bits are set, return the number itself\n    if n == 0:\n        return 1\n    \n    # Find the position of the left-most unset bit\n    position = 0\n    while (n & (1 << position))!= 0:\n        position += 1\n    \n    # Set the left-most unset bit\n    n |= (1 << position)\n    \n    return n"}
{"task_id": "Mbpp/312", "solution": "import math\n\ndef volume_cone(radius, height):\n    return (1/3) * math.pi * radius**2 * height"}
{"task_id": "Mbpp/388", "solution": "def highest_Power_of_2(n):\n    # Initialize the highest power of 2 as 1\n    highest_power = 1\n\n    # Iterate through the powers of 2 until we find the highest one less than or equal to n\n    for power in range(2, n + 1):\n        if power <= n:\n            highest_power = power\n\n    return highest_power"}
{"task_id": "Mbpp/389", "solution": "def find_lucas(n):\n    # Base cases\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # Initialize the first two Lucas numbers\n    lucas_0 = 2\n    lucas_1 = 1\n    \n    # Compute the nth Lucas number iteratively\n    for i in range(2, n + 1):\n        lucas_n = lucas_0 + lucas_1\n        lucas_0 = lucas_1\n        lucas_1 = lucas_n\n    \n    return lucas_n"}
{"task_id": "Mbpp/390", "solution": "def add_string(my_list, format_string):\n    return [format_string.format(i) for i in my_list]"}
{"task_id": "Mbpp/391", "solution": "def convert_list_dictionary(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        inner_dict = {list1[i]: {list2[i]: list3[i]}}\n        result.append(inner_dict)\n    return result"}
{"task_id": "Mbpp/392", "solution": "def get_max_sum(n):\n    if n <= 5:\n        return n\n    else:\n        return max(get_max_sum(n/2) + get_max_sum(n/3) + get_max_sum(n/4) + get_max_sum(n/5), n)"}
{"task_id": "Mbpp/394", "solution": "def check_distinct(my_tuple):\n    return len(set(my_tuple)) == len(my_tuple)"}
{"task_id": "Mbpp/395", "solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None"}
{"task_id": "Mbpp/396", "solution": "def check_char(s):\n    return s[0] == s[-1]"}
{"task_id": "Mbpp/397", "solution": "def median_numbers(a, b, c):\n    if (a <= b and b <= c) or (c <= b and b <= a):\n        return float(b)\n    elif (b <= a and a <= c) or (c <= a and a <= b):\n        return float(a)\n    else:\n        return float(c)"}
{"task_id": "Mbpp/398", "solution": "def sum_of_digits(my_list):\n    total = 0\n    for num in my_list:\n        if isinstance(num, int):\n            total += sum(int(digit) for digit in str(num))\n    return total"}
{"task_id": "Mbpp/400", "solution": "def extract_freq(my_list):\n    unique_tuples = set()\n    for tup in my_list:\n        if tup not in unique_tuples:\n            unique_tuples.add(tup)\n    return len(unique_tuples)"}
{"task_id": "Mbpp/404", "solution": "def minimum(a, b):\n    return a if a < b else b"}
{"task_id": "Mbpp/405", "solution": "def check_tuplex(tuple, element):\n    return element in tuple"}
{"task_id": "Mbpp/406", "solution": "def find_Parity(n):\n    return n % 2 == 1"}
{"task_id": "Mbpp/407", "solution": "def rearrange_bigger(num):\n    # Convert the number to a list of individual digits\n    digits = [int(digit) for digit in str(num)]\n\n    # Sort the digits in descending order\n    digits.sort(reverse=True)\n\n    # Join the digits back into a string\n    result = \"\".join(str(digit) for digit in digits)\n\n    # Return the result as an integer\n    return int(result)"}
{"task_id": "Mbpp/409", "solution": "def min_product_tuple(pairs):\n    min_product = float('inf')\n    for a, b in pairs:\n        product = a * b\n        if product < min_product:\n            min_product = product\n    return min_product"}
{"task_id": "Mbpp/410", "solution": "def min_val(my_list):\n    min_val = None\n    for element in my_list:\n        if isinstance(element, int):\n            if min_val is None or element < min_val:\n                min_val = element\n        elif isinstance(element, str):\n            if min_val is None or element < min_val:\n                min_val = element\n    return min_val"}
{"task_id": "Mbpp/412", "solution": "def remove_odd(my_list):\n    return [x for x in my_list if x % 2 == 0]"}
{"task_id": "Mbpp/413", "solution": "def extract_nth_element(my_list, n):\n    return [element[n] for element in my_list]"}
{"task_id": "Mbpp/414", "solution": "def overlapping(seq1, seq2):\n    return any(item in seq2 for item in seq1)"}
{"task_id": "Mbpp/415", "solution": "def max_Product(arr):\n    if len(arr) < 2:\n        raise ValueError(\"Array must contain at least two elements\")\n    \n    # Initialize the two largest and two smallest values\n    max1 = max2 = float('-inf')\n    min1 = min2 = float('inf')\n    \n    for num in arr:\n        # Update the two largest values\n        if num > max1:\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max2 = num\n        \n        # Update the two smallest values\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n    \n    # Compare the product of the two largest values with the product of the two smallest values\n    if max1 * max2 > min1 * min2:\n        return (max1, max2)\n    else:\n        return (min1, min2)"}
{"task_id": "Mbpp/418", "solution": "def Find_Max(lst):\n    max_element = lst[0]\n    for element in lst:\n        if len(element) > len(max_element):\n            max_element = element\n    return max_element"}
{"task_id": "Mbpp/419", "solution": "def round_and_sum(numbers):\n    rounded_numbers = [round(num) for num in numbers]\n    total_sum = sum(rounded_numbers)\n    result = total_sum * len(numbers)\n    return result"}
{"task_id": "Mbpp/420", "solution": "def cube_Sum(n):\n    return sum((2 * i) ** 3 for i in range(1, n + 1))"}
{"task_id": "Mbpp/421", "solution": "def concatenate_tuple(tuple_to_concatenate, delimiter=\"-\"):\n    return delimiter.join(str(element) for element in tuple_to_concatenate)"}
{"task_id": "Mbpp/422", "solution": "def find_Average_Of_Cube(n):\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n    average_of_cubes = sum_of_cubes / n\n    return average_of_cubes"}
{"task_id": "Mbpp/424", "solution": "def extract_rear(my_tuple):\n    result = []\n    for element in my_tuple:\n        result.append(element[-1])\n    return result"}
{"task_id": "Mbpp/425", "solution": "def count_element_in_list(my_list, element):\n    count = 0\n    for sublist in my_list:\n        if element in sublist:\n            count += 1\n    return count"}
{"task_id": "Mbpp/426", "solution": "def filter_oddnumbers(numbers):\n    return [num for num in numbers if num % 2!= 0]"}
{"task_id": "Mbpp/427", "solution": "def change_date_format(date_string):\n    year, month, day = date_string.split('-')\n    return f'{day}-{month}-{year}'"}
{"task_id": "Mbpp/428", "solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr"}
{"task_id": "Mbpp/429", "solution": "def and_tuples(tup1, tup2):\n    result = []\n    for i in range(len(tup1)):\n        result.append(tup1[i] & tup2[i])\n    return tuple(result)"}
{"task_id": "Mbpp/430", "solution": "def parabola_directrix(a, b, c):\n    \"\"\"\n    Find the directrix of a parabola with the equation y = a*x^2 + b*x + c.\n    \"\"\"\n    # Calculate the discriminant\n    discriminant = b**2 - 4*a*c\n\n    # Check if the discriminant is negative\n    if discriminant < 0:\n        # The parabola has no real roots, so it has no directrix\n        return None\n\n    # Calculate the directrix\n    directrix = (-b + math.sqrt(discriminant)) / (2*a)\n\n    return directrix"}
{"task_id": "Mbpp/431", "solution": "def common_element(list1, list2):\n    return any(element in list2 for element in list1)"}
{"task_id": "Mbpp/432", "solution": "def median_trapezium(a, b, c):\n    return (a + b + c) / 2"}
{"task_id": "Mbpp/433", "solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True"}
{"task_id": "Mbpp/435", "solution": "def last_Digit(number):\n    return number % 10"}
{"task_id": "Mbpp/436", "solution": "def neg_nos(my_list):\n    return [x for x in my_list if x < 0]"}
{"task_id": "Mbpp/437", "solution": "def remove_odd(string):\n    result = \"\"\n    for i, char in enumerate(string):\n        if i % 2 == 0:\n            result += char\n    return result"}
{"task_id": "Mbpp/438", "solution": "def count_bidirectional(tuples):\n    seen_pairs = set()\n    count = 0\n    for t in tuples:\n        if t[0] < t[1]:\n            pair = (t[0], t[1])\n        else:\n            pair = (t[1], t[0])\n        if pair not in seen_pairs:\n            count += 1\n            seen_pairs.add(pair)\n    return count"}
{"task_id": "Mbpp/439", "solution": "def multiple_to_single(my_list):\n    return int(''.join(map(str, my_list)))"}
{"task_id": "Mbpp/440", "solution": "def find_adverb_position(sentence):\n    adverb_positions = []\n    for word in sentence.split():\n        if word.endswith('ly'):\n            adverb_positions.append((sentence.index(word), len(word), word))\n    return adverb_positions"}
{"task_id": "Mbpp/441", "solution": "def surfacearea_cube(side_length):\n    # Calculate the surface area of a cube\n    surface_area = 6 * (side_length ** 2)\n    return surface_area"}
{"task_id": "Mbpp/442", "solution": "def positive_count(arr):\n    if not arr:\n        return 0\n    positive_numbers = [num for num in arr if num > 0]\n    ratio = len(positive_numbers) / len(arr)\n    return round(ratio, 2)"}
{"task_id": "Mbpp/445", "solution": "def index_multiplication(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        result.append((tuple1[i][0] * tuple2[i][0], tuple1[i][1] * tuple2[i][1]))\n    return tuple(result)"}
{"task_id": "Mbpp/446", "solution": "def count_Occurrence(tuple_list, element_list):\n    count = 0\n    for element in element_list:\n        count += tuple_list.count(element)\n    return count"}
{"task_id": "Mbpp/447", "solution": "def cube_nums(my_list):\n    return [x**3 for x in my_list]"}
{"task_id": "Mbpp/448", "solution": "def cal_sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += i * (i+1) / 2\n    return sum"}
{"task_id": "Mbpp/450", "solution": "def extract_string(my_list, size):\n    return my_list[size:]"}
{"task_id": "Mbpp/451", "solution": "def remove_whitespaces(s):\n    return ''.join(s.split())"}
{"task_id": "Mbpp/453", "solution": "def sumofFactors(n):\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            total += i\n    return total"}
{"task_id": "Mbpp/454", "solution": "def text_match_wordz(text):\n    return \"z\" in text"}
{"task_id": "Mbpp/455", "solution": "def check_monthnumb_number(month_number):\n    if month_number in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/456", "solution": "def reverse_string_list(string_list):\n    return [string[::-1] for string in string_list]"}
{"task_id": "Mbpp/457", "solution": "def Find_Min(lists):\n    if not lists:\n        return []\n    min_list = lists[0]\n    for sublist in lists:\n        if len(sublist) < len(min_list):\n            min_list = sublist\n    return min_list"}
{"task_id": "Mbpp/458", "solution": "def rectangle_area(width, height):\n    return width * height"}
{"task_id": "Mbpp/459", "solution": "def remove_uppercase(string):\n    return ''.join([char for char in string if char.islower()])"}
{"task_id": "Mbpp/460", "solution": "def Extract(my_list):\n    return [sublist[0] for sublist in my_list]"}
{"task_id": "Mbpp/461", "solution": "def upper_ctr(string):\n    count = 0\n    for char in string:\n        if char.isupper():\n            count += 1\n    return count"}
{"task_id": "Mbpp/462", "solution": "def combinations_list(my_list):\n    combinations = []\n    for i in range(len(my_list)):\n        for j in range(i+1, len(my_list)):\n            combinations.append([my_list[i], my_list[j]])\n    return combinations"}
{"task_id": "Mbpp/463", "solution": "def max_subarray_product(arr):\n    # Initialize variables to keep track of the maximum product subarray\n    max_product = 0\n    current_product = 1\n    start_index = 0\n    end_index = 0\n\n    # Iterate through the array\n    for i in range(len(arr)):\n        # If the current element is negative, update the current product\n        if arr[i] < 0:\n            current_product *= arr[i]\n        # If the current element is positive or zero, update the maximum product\n        else:\n            max_product = max(max_product, current_product)\n            current_product = 1\n\n    # Return the maximum product\n    return max_product"}
{"task_id": "Mbpp/465", "solution": "def drop_empty(my_dict):\n    return {k: v for k, v in my_dict.items() if v is not None}"}
{"task_id": "Mbpp/468", "solution": "def max_product(arr):\n    max_product = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            product = 1\n            for k in range(i, j+1):\n                product *= arr[k]\n            if product > max_product:\n                max_product = product\n    return max_product"}
{"task_id": "Mbpp/470", "solution": "def add_pairwise(tuple):\n    result = []\n    for i in range(len(tuple) - 1):\n        result.append(tuple[i] + tuple[i + 1])\n    return tuple(result)"}
{"task_id": "Mbpp/471", "solution": "def find_remainder(arr, n):\n    result = 1\n    for i in arr:\n        result = (result * i) % n\n    return result"}
{"task_id": "Mbpp/472", "solution": "def check_Consecutive(lst):\n    if not lst:\n        return False\n    sorted_lst = sorted(lst)\n    for i in range(len(sorted_lst) - 1):\n        if sorted_lst[i] + 1!= sorted_lst[i + 1]:\n            return False\n    return True"}
{"task_id": "Mbpp/473", "solution": "def tuple_intersection(tuple_list1, tuple_list2):\n    intersection = set()\n    for t1 in tuple_list1:\n        for t2 in tuple_list2:\n            if t1 == t2:\n                intersection.add(t1)\n    return intersection"}
{"task_id": "Mbpp/474", "solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)"}
{"task_id": "Mbpp/475", "solution": "def sort_counter(my_dict):\n    return sorted(my_dict.items(), key=lambda x: x[1], reverse=True)"}
{"task_id": "Mbpp/476", "solution": "def big_sum(arr):\n    largest = arr[0]\n    smallest = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > largest:\n            largest = arr[i]\n        if arr[i] < smallest:\n            smallest = arr[i]\n    return largest + smallest"}
{"task_id": "Mbpp/477", "solution": "def is_lower(input_string):\n    return input_string.lower()"}
{"task_id": "Mbpp/478", "solution": "def remove_lowercase(s):\n    result = []\n    temp = []\n    for char in s:\n        if char.islower():\n            if temp:\n                result.append(''.join(temp))\n                temp = []\n        else:\n            temp.append(char)\n    if temp:\n        result.append(''.join(temp))\n    return ''.join(result)"}
{"task_id": "Mbpp/479", "solution": "def first_Digit(n):\n    return str(n)[0]"}
{"task_id": "Mbpp/554", "solution": "def Split(my_list):\n    return [x for x in my_list if x % 2 == 1]"}
{"task_id": "Mbpp/555", "solution": "def difference(n):\n    # Calculate the sum of the first n natural numbers\n    sum_n = n * (n + 1) // 2\n    \n    # Calculate the sum of the cubes of the first n natural numbers\n    sum_cubes = sum_n ** 2\n    \n    # Find the difference\n    diff = sum_cubes - sum_n\n    \n    return diff"}
{"task_id": "Mbpp/556", "solution": "def find_Odd_Pair(arr, n):\n    odd_count = 0\n    even_count = 0\n    \n    # Count the number of odd and even numbers in the array\n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # The number of pairs with odd XOR value is the product of the number of odd and even numbers\n    return odd_count * even_count"}
{"task_id": "Mbpp/557", "solution": "def toggle_string(string):\n    return string.swapcase()"}
{"task_id": "Mbpp/558", "solution": "def digit_distance_nums(num1, num2):\n    # Convert the numbers to strings\n    str1 = str(num1)\n    str2 = str(num2)\n\n    # Initialize the sum to 0\n    sum = 0\n\n    # Loop through each digit in both numbers\n    for i in range(len(str1)):\n        # Calculate the difference between the digits\n        diff = abs(int(str1[i]) - int(str2[i]))\n\n        # Add the difference to the sum\n        sum += diff\n\n    # Return the sum\n    return sum"}
{"task_id": "Mbpp/559", "solution": "def max_sub_array_sum(arr, k):\n    # Initialize variables\n    max_sum = 0\n    current_sum = 0\n    start = 0\n    end = 0\n\n    # Iterate through the array\n    for i in range(len(arr)):\n        # Add the current element to the current sum\n        current_sum += arr[i]\n\n        # If the current sum is greater than the maximum sum, update the maximum sum and the start and end indices\n        if current_sum > max_sum:\n            max_sum = current_sum\n            start = i - k + 1\n            end = i\n\n        # If the current sum is less than zero, reset the current sum and the start index\n        if current_sum < 0:\n            current_sum = 0\n            start = i + 1\n\n    # Return the maximum sum and the start and end indices\n    return max_sum, start, end"}
{"task_id": "Mbpp/560", "solution": "def union_elements(tuple1, tuple2):\n    union = set(tuple1).union(set(tuple2))\n    return tuple(sorted(union))"}
{"task_id": "Mbpp/562", "solution": "def Find_Max_Length(sublists):\n    return max(len(sublist) for sublist in sublists)"}
{"task_id": "Mbpp/563", "solution": "import re\n\ndef extract_values(s):\n    return re.findall(r'\"(.*?)\"', s)"}
{"task_id": "Mbpp/564", "solution": "def count_Pairs(my_list, n):\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if my_list[i]!= my_list[j]:\n                count += 1\n    return count"}
{"task_id": "Mbpp/565", "solution": "def split(string):\n    return list(string)"}
{"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    sum = 0\n    while n > 0:\n        sum += n % 10\n        n //= 10\n    return sum"}
{"task_id": "Mbpp/567", "solution": "def issort_list(lst):\n    \"\"\"\n    Function to check whether a specified list is sorted in ascending order.\n    \n    Parameters:\n    lst (list): The list to check.\n    \n    Returns:\n    bool: True if the list is sorted, False otherwise.\n    \"\"\"\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True"}
{"task_id": "Mbpp/568", "solution": "def empty_list(N):\n    return [{} for _ in range(N)]"}
{"task_id": "Mbpp/569", "solution": "def sort_sublists(list_of_lists):\n    for sublist in list_of_lists:\n        sublist.sort()\n    return list_of_lists"}
{"task_id": "Mbpp/572", "solution": "def two_unique_nums(nums):\n    unique_nums = []\n    for num in nums:\n        if num not in unique_nums:\n            unique_nums.append(num)\n    return unique_nums"}
{"task_id": "Mbpp/573", "solution": "def unique_product(numbers):\n    unique_numbers = set(numbers)\n    product = 1\n    for number in unique_numbers:\n        product *= number\n    return product"}
{"task_id": "Mbpp/574", "solution": "def surfacearea_cylinder(radius, height):\n    return 2 * math.pi * radius * (radius + height)"}
{"task_id": "Mbpp/576", "solution": "def is_Sub_Array(main_list, sub_list):\n    # Get the lengths of both lists\n    main_len = len(main_list)\n    sub_len = len(sub_list)\n    \n    # If the sublist is longer than the main list, it cannot be a sublist\n    if sub_len > main_len:\n        return False\n    \n    # Iterate through the main list\n    for i in range(main_len - sub_len + 1):\n        # Check if the sublist matches the slice of the main list\n        if main_list[i:i + sub_len] == sub_list:\n            return True\n    \n    return False"}
{"task_id": "Mbpp/577", "solution": "def last_Digit_Factorial(n):\n    if n >= 5:\n        return 0\n    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n    return factorial % 10"}
{"task_id": "Mbpp/578", "solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result"}
{"task_id": "Mbpp/579", "solution": "def find_dissimilar(tup1, tup2):\n    return tuple(set(tup1) ^ set(tup2))"}
{"task_id": "Mbpp/580", "solution": "def extract_even(nested_tuple):\n    result = []\n    for element in nested_tuple:\n        if isinstance(element, tuple):\n            result.append(extract_even(element))\n        elif element % 2 == 0:\n            result.append(element)\n    return tuple(result)"}
{"task_id": "Mbpp/581", "solution": "def surface_Area(base_edge, height):\n    # Calculate the surface area of the square pyramid\n    surface_area = (base_edge ** 2) * height\n    return surface_area"}
{"task_id": "Mbpp/582", "solution": "def my_dict(d):\n    return len(d) == 0"}
{"task_id": "Mbpp/583", "solution": "def catalan_number(n):\n    # Base case\n    if n == 0 or n == 1:\n        return 1\n    \n    # Initialize an array to store the results of subproblems\n    catalan = [0] * (n + 1)\n    \n    # Initialize the first two values in the array\n    catalan[0] = 1\n    catalan[1] = 1\n    \n    # Fill the array using the recursive formula\n    for i in range(2, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    \n    return catalan[n]"}
{"task_id": "Mbpp/585", "solution": "def expensive_items(items, n):\n    return sorted(items, key=lambda x: x['price'], reverse=True)[:n]"}
{"task_id": "Mbpp/586", "solution": "def split_Arr(arr, n):\n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part"}
{"task_id": "Mbpp/587", "solution": "def list_tuple(input_list):\n    return tuple(input_list)"}
{"task_id": "Mbpp/588", "solution": "def big_diff(lst):\n    if not lst:\n        raise ValueError(\"List must not be empty\")\n    return max(lst) - min(lst)"}
{"task_id": "Mbpp/589", "solution": "def perfect_squares(start, end):\n    squares = []\n    for i in range(start, end+1):\n        root = int(i**0.5)\n        if root**2 == i:\n            squares.append(i)\n    return squares"}
{"task_id": "Mbpp/590", "solution": "def polar_rect(r, theta):\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    return (x, y)"}
{"task_id": "Mbpp/591", "solution": "def swap_List(my_list):\n    first_element = my_list[0]\n    last_element = my_list[-1]\n    my_list[0] = last_element\n    my_list[-1] = first_element\n    return my_list"}
{"task_id": "Mbpp/592", "solution": "def sum_Of_product(n):\n    result = 0\n    for i in range(n):\n        result += binomial(n, i) * binomial(n, i+1)\n    return result"}
{"task_id": "Mbpp/593", "solution": "def removezero_ip(ip):\n    parts = ip.split('.')\n    parts = [str(int(part)) for part in parts]\n    return '.'.join(parts)"}
{"task_id": "Mbpp/594", "solution": "def diff_even_odd(my_list):\n    even_num = None\n    odd_num = None\n    for num in my_list:\n        if num % 2 == 0:\n            even_num = num\n            break\n        elif num % 2 == 1:\n            odd_num = num\n            break\n    if even_num is None or odd_num is None:\n        return None\n    return abs(even_num - odd_num)"}
{"task_id": "Mbpp/595", "solution": "def min_Swaps(str1, str2):\n    # Convert the binary strings to lists of 0s and 1s\n    list1 = list(str1)\n    list2 = list(str2)\n\n    # Initialize the number of swaps to 0\n    swaps = 0\n\n    # Iterate through the lists and compare the corresponding elements\n    for i in range(len(list1)):\n        if list1[i]!= list2[i]:\n            # If the elements are not equal, increment the number of swaps\n            swaps += 1\n\n    # Return the number of swaps\n    return swaps"}
{"task_id": "Mbpp/596", "solution": "import sys\n\ndef tuple_size(t):\n    return sys.getsizeof(t)"}
{"task_id": "Mbpp/597", "solution": "def find_kth(arr1, arr2, k):\n    # find the middle index of the arrays\n    mid1 = len(arr1) // 2\n    mid2 = len(arr2) // 2\n\n    # if the kth element is in the first half of both arrays, recurse on the first half\n    if k <= mid1 and k <= mid2:\n        return find_kth(arr1[:mid1], arr2[:mid2], k)\n\n    # if the kth element is in the second half of both arrays, recurse on the second half\n    if k > mid1 and k > mid2:\n        return find_kth(arr1[mid1:], arr2[mid2:], k)\n\n    # if the kth element is in the first half of one array and the second half of the other, recurse on the first half of the first array and the second half of the second array\n    if k <= mid1 and k > mid2:\n        return find_kth(arr1[:mid1], arr2[mid2:], k)\n\n    # if the kth element is in the second half of one array and the first half of the other, recurse on the second half of the first array and the first half of the second array\n    if k > mid1 and k <= mid2:\n        return find_kth(arr1[mid1:], arr2[:mid2], k)"}
{"task_id": "Mbpp/598", "solution": "def armstrong_number(n):\n    # Convert the number to a list of individual digits\n    digits = [int(digit) for digit in str(n)]\n\n    # Calculate the sum of the cubes of each digit\n    sum_of_cubes = 0\n    for digit in digits:\n        sum_of_cubes += digit ** 3\n\n    # Check if the sum of the cubes is equal to the original number\n    if sum_of_cubes == n:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/599", "solution": "def sum_average(n):\n    # Calculate the sum of the first n natural numbers\n    sum_n = n * (n + 1) // 2\n    # Calculate the average of the first n natural numbers\n    average_n = sum_n / n\n    # Return the sum and average as a tuple\n    return sum_n, average_n"}
{"task_id": "Mbpp/600", "solution": "def is_Even(number):\n    return number % 2 == 0"}
{"task_id": "Mbpp/602", "solution": "def first_repeated_char(s):\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None"}
{"task_id": "Mbpp/603", "solution": "def get_ludic(n):\n    lucid_numbers = []\n    for i in range(1, n+1):\n        if is_ludic(i):\n            lucid_numbers.append(i)\n    return lucid_numbers\n\ndef is_ludic(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "Mbpp/604", "solution": "def reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = words[::-1]\n    reversed_string =''.join(reversed_words)\n    return reversed_string"}
{"task_id": "Mbpp/605", "solution": "def prime_num(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "Mbpp/606", "solution": "def radian_degree(degree):\n    return degree * (math.pi / 180)"}
{"task_id": "Mbpp/607", "solution": "def find_literals(string, pattern):\n    import re\n    match = re.search(pattern, string)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        return (None, None, None)"}
{"task_id": "Mbpp/608", "solution": "def bell_Number(n):\n    if n == 0:\n        return 1\n    else:\n        return sum(bell_Number(k) * bell_Number(n-k-1) for k in range(n))"}
{"task_id": "Mbpp/610", "solution": "def remove_kth_element(my_list, k):\n    # Remove the k'th element from the list\n    return my_list[:k] + my_list[k+1:]"}
{"task_id": "Mbpp/611", "solution": "def max_of_nth(matrix, n):\n    max_value = None\n    for row in matrix:\n        value = row[n]\n        if max_value is None or value > max_value:\n            max_value = value\n    return max_value"}
{"task_id": "Mbpp/612", "solution": "def merge(lst):\n    return [[sublist[0] for sublist in lst], [sublist[1] for sublist in lst]]"}
{"task_id": "Mbpp/614", "solution": "def cummulative_sum(tuple_list):\n    result = 0\n    for tup in tuple_list:\n        for val in tup:\n            result += val\n    return result"}
{"task_id": "Mbpp/615", "solution": "def average_tuple(tuple_of_tuples):\n    averages = []\n    for t in tuple_of_tuples:\n        average = sum(t) / len(t)\n        averages.append(average)\n    return averages"}
{"task_id": "Mbpp/616", "solution": "def tuple_modulo(tup1, tup2):\n    return tuple(x % y for x, y in zip(tup1, tup2))"}
{"task_id": "Mbpp/618", "solution": "def div_list(list1, list2):\n    if len(list1)!= len(list2):\n        raise ValueError(\"Both lists must have the same length\")\n    return [a / b for a, b in zip(list1, list2)]"}
{"task_id": "Mbpp/619", "solution": "def move_num(string):\n    num_list = []\n    char_list = []\n    for char in string:\n        if char.isdigit():\n            num_list.append(char)\n        else:\n            char_list.append(char)\n    return ''.join(char_list + num_list)"}
{"task_id": "Mbpp/620", "solution": "def largest_subset(numbers):\n    # Initialize a variable to store the largest subset size\n    largest_subset_size = 0\n\n    # Iterate through the numbers\n    for i in range(len(numbers)):\n        # Check if the current number is divisible by any of the previous numbers\n        for j in range(i):\n            if numbers[i] % numbers[j] == 0:\n                # If it is, increment the subset size\n                largest_subset_size += 1\n                break\n\n    # Return the largest subset size\n    return largest_subset_size"}
{"task_id": "Mbpp/622", "solution": "def get_median(list1, list2, size):\n    # Step 1: Merge the two lists into a single list\n    merged_list = list1 + list2\n\n    # Step 2: Find the median of the merged list\n    median = merged_list[size // 2]\n\n    # Step 3: Return the median\n    return median"}
{"task_id": "Mbpp/623", "solution": "def nth_nums(my_list, n):\n    return [pow(x, n) for x in my_list]"}
{"task_id": "Mbpp/624", "solution": "def is_upper(s):\n    return s.upper()"}
{"task_id": "Mbpp/626", "solution": "def triangle_area(radius):\n    if radius < 0:\n        return None\n    else:\n        return (3 * radius ** 2) / 2"}
{"task_id": "Mbpp/628", "solution": "def replace_spaces(string):\n    return string.replace(\" \", \"%20\")"}
{"task_id": "Mbpp/629", "solution": "def find_even_numbers(numbers):\n    return [number for number in numbers if number % 2 == 0]"}
{"task_id": "Mbpp/630", "solution": "def get_coordinates(coord):\n    x, y = coord\n    adjacent_coords = []\n    for i in range(x-1, x+2):\n        for j in range(y-1, y+2):\n            if i == x and j == y:\n                continue\n            adjacent_coords.append([i, j])\n    return adjacent_coords"}
{"task_id": "Mbpp/631", "solution": "def replace_spaces(string):\n    return string.replace(' ', '_').replace('_','')"}
{"task_id": "Mbpp/632", "solution": "def move_zero(my_list):\n    non_zero_list = []\n    zero_list = []\n    for element in my_list:\n        if element!= 0:\n            non_zero_list.append(element)\n        else:\n            zero_list.append(element)\n    return non_zero_list + zero_list"}
{"task_id": "Mbpp/633", "solution": "def pair_xor_Sum(my_list, n):\n    sum = 0\n    for i in range(len(my_list)):\n        for j in range(i+1, len(my_list)):\n            sum += my_list[i] ^ my_list[j]\n    return sum"}
{"task_id": "Mbpp/635", "solution": "def heap_sort(arr):\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)\n    return arr\n\ndef heapify(arr, n, i):\n    largest = i\n    l = 2 * i + 1\n    r = 2 * i + 2\n    if l < n and arr[l] > arr[largest]:\n        largest = l\n    if r < n and arr[r] > arr[largest]:\n        largest = r\n    if largest!= i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)"}
{"task_id": "Mbpp/637", "solution": "def noprofit_noloss(cost_price, selling_price):\n    return cost_price == selling_price"}
{"task_id": "Mbpp/638", "solution": "def wind_chill(wind_velocity, temperature):\n    wind_chill_index = round(35.74 + 0.6215 * temperature - 35.75 * (wind_velocity ** 0.16) + 0.4275 * temperature * (wind_velocity ** 0.16))\n    return int(wind_chill_index)"}
{"task_id": "Mbpp/639", "solution": "def sample_nam(names):\n    # Filter out names that start with a lowercase letter\n    filtered_names = [name for name in names if not name[0].islower()]\n    # Sum the lengths of the remaining names\n    total_length = sum(len(name) for name in filtered_names)\n    return total_length"}
{"task_id": "Mbpp/640", "solution": "def remove_parenthesis(string):\n    return string.split('(')[0]"}
{"task_id": "Mbpp/641", "solution": "def is_nonagonal(n):\n    \"\"\"\n    Function to find the nth nonagonal number.\n    A nonagonal number is given by the formula: n(7n - 5)/2\n    \"\"\"\n    return n * (7 * n - 5) // 2"}
{"task_id": "Mbpp/643", "solution": "def text_match_wordz_middle(string):\n    # Check if the string is empty\n    if not string:\n        return False\n\n    # Check if the string starts with 'z'\n    if string[0] == 'z':\n        return False\n\n    # Check if the string ends with 'z'\n    if string[-1] == 'z':\n        return False\n\n    # Check if the string contains 'z' in the middle\n    if 'z' in string[1:-1]:\n        return False\n\n    # If none of the above conditions are met, return True\n    return True"}
{"task_id": "Mbpp/644", "solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        raise ValueError(\"k should be within the bounds of the array length\")\n    return arr[:k][::-1] + arr[k:]"}
{"task_id": "Mbpp/720", "solution": "def add_dict_to_tuple(tuple, dict):\n    return tuple + (dict,)"}
{"task_id": "Mbpp/721", "solution": "def maxAverageOfPath(matrix):\n    # Initialize variables\n    max_average = 0\n    path = []\n\n    # Iterate over each cell in the matrix\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            # If the current cell is the bottom-right cell, add it to the path and calculate the average\n            if i == len(matrix) - 1 and j == len(matrix[0]) - 1:\n                path.append((i, j))\n                average = calculateAverage(matrix, path)\n                if average > max_average:\n                    max_average = average\n                    best_path = path\n                path.pop()\n            # If the current cell is not the bottom-right cell, add it to the path and recursively explore the next cell\n            else:\n                path.append((i, j))\n                maxAverageOfPath(matrix, path)\n                path.pop()\n\n    return best_path\n\ndef calculateAverage(matrix, path):\n    total_cost = 0\n    for cell in path:\n        total_cost += matrix[cell[0]][cell[1]]\n    return total_cost / len(path)"}
{"task_id": "Mbpp/722", "solution": "def filter_data(students, min_height, min_weight):\n    filtered_students = {}\n    for name, (height, weight) in students.items():\n        if height > min_height and weight > min_weight:\n            filtered_students[name] = (height, weight)\n    return filtered_students"}
{"task_id": "Mbpp/723", "solution": "def count_same_pair(list1, list2):\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i]:\n            count += 1\n    return count"}
{"task_id": "Mbpp/724", "solution": "def power_base_sum(base, power):\n    result = base ** power\n    result_str = str(result)\n    sum_of_digits = 0\n    for char in result_str:\n        sum_of_digits += int(char)\n    return sum_of_digits"}
{"task_id": "Mbpp/725", "solution": "def extract_quotation(s):\n    import re\n    return re.findall(r'\"(.*?)\"', s)"}
{"task_id": "Mbpp/726", "solution": "def multiply_elements(tup):\n    result = []\n    for i in range(len(tup) - 1):\n        result.append(tup[i] * tup[i + 1])\n    return tuple(result)"}
{"task_id": "Mbpp/728", "solution": "def sum_list(list1, list2):\n    return [a + b for a, b in zip(list1, list2)]"}
{"task_id": "Mbpp/730", "solution": "def consecutive_duplicates(my_list):\n    result = []\n    for i in range(len(my_list)):\n        if my_list[i]!= my_list[i-1]:\n            result.append(my_list[i])\n    return result"}
{"task_id": "Mbpp/731", "solution": "def lateralsurface_cone(r, h):\n    return 2 * math.pi * r * h"}
{"task_id": "Mbpp/732", "solution": "def replace_specialchar(string):\n    return string.replace(' ', ':').replace(',', ':').replace('.', ':')"}
{"task_id": "Mbpp/733", "solution": "def find_first_occurrence(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            result = mid\n            right = mid - 1  # Continue searching in the left half\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result"}
{"task_id": "Mbpp/734", "solution": "def sum_Of_Subarray_Prod(arr):\n    n = len(arr)\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] + arr[i - 1]\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            dp[j] += dp[i - 1]\n    return dp[n]"}
{"task_id": "Mbpp/735", "solution": "def toggle_middle_bits(n):\n    # Convert the number to binary\n    binary_str = bin(n)[2:]\n\n    # Toggle the middle bits\n    middle_bits = binary_str[1:-1]\n    toggled_middle_bits = ''.join(['1' if x == '0' else '0' for x in middle_bits])\n\n    # Reconstruct the binary string with the toggled middle bits\n    toggled_binary_str = binary_str[:1] + toggled_middle_bits + binary_str[-1:]\n\n    # Convert the binary string back to an integer\n    return int(toggled_binary_str, 2)"}
{"task_id": "Mbpp/736", "solution": "def left_insertion(arr, x):\n    \"\"\"\n    Locate the left insertion point for a specified value in sorted order.\n    \n    Parameters:\n    arr (list): A list of sorted elements.\n    x (int/float): The value to find the insertion point for.\n    \n    Returns:\n    int: The index where the value should be inserted to maintain sorted order.\n    \"\"\"\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid\n    return left"}
{"task_id": "Mbpp/737", "solution": "def check_str(string):\n    regex = r\"^[aeiou]\"\n    return re.match(regex, string) is not None"}
{"task_id": "Mbpp/739", "solution": "def find_Index(n):\n    triangular_numbers = []\n    for i in range(1, n+1):\n        triangular_numbers.append(i*(i+1)//2)\n    return triangular_numbers.index(min(triangular_numbers))"}
{"task_id": "Mbpp/740", "solution": "def tuple_to_dict(my_tuple):\n    my_dict = {}\n    for i in range(0, len(my_tuple), 2):\n        my_dict[my_tuple[i]] = my_tuple[i+1]\n    return my_dict"}
{"task_id": "Mbpp/741", "solution": "def all_Characters_Same(s):\n    return len(set(s)) == 1"}
{"task_id": "Mbpp/742", "solution": "def area_tetrahedron(edge_length):\n    # Calculate the surface area of a regular tetrahedron\n    surface_area = math.sqrt(3) * edge_length ** 2\n    # Calculate the volume of a regular tetrahedron\n    volume = (math.sqrt(2) / 6) * edge_length ** 3\n    # Calculate the area of the tetrahedron\n    area = 4 * surface_area / 3\n    return area"}
{"task_id": "Mbpp/743", "solution": "def rotate_right(my_list, n):\n    return my_list[n:] + my_list[:n]"}
{"task_id": "Mbpp/744", "solution": "def check_none(my_tuple):\n    return any(x is None for x in my_tuple)"}
{"task_id": "Mbpp/745", "solution": "def divisible_by_digits(startnum, endnum):\n    result = []\n    for num in range(startnum, endnum+1):\n        digits = [int(digit) for digit in str(num)]\n        for digit in digits:\n            if num % digit!= 0:\n                break\n        else:\n            result.append(num)\n    return result"}
{"task_id": "Mbpp/746", "solution": "import math\n\ndef sector_area(radius, angle):\n    if angle > 360:\n        return None\n    return 0.5 * radius ** 2 * math.radians(angle)"}
{"task_id": "Mbpp/748", "solution": "def capital_words_spaces(string):\n    words = string.split()\n    for i, word in enumerate(words):\n        if word[0].isupper():\n            words[i] = word + \" \"\n    return \"\".join(words)"}
{"task_id": "Mbpp/749", "solution": "def sort_numeric_strings(my_list):\n    return sorted(my_list, key=lambda x: int(x))"}
{"task_id": "Mbpp/750", "solution": "def add_tuple(my_list, my_tuple):\n    return my_list + list(my_tuple)"}
{"task_id": "Mbpp/751", "solution": "def check_min_heap(arr):\n    # Check if the array is a binary heap\n    if len(arr) == 0:\n        return False\n\n    # Check if the root node is the minimum value in the heap\n    if arr[0]!= min(arr):\n        return False\n\n    # Check if the left and right children of each node are less than or equal to the parent node\n    for i in range(1, len(arr)):\n        left_child = 2 * i\n        right_child = 2 * i + 1\n        if left_child < len(arr) and arr[left_child] > arr[i]:\n            return False\n        if right_child < len(arr) and arr[right_child] > arr[i]:\n            return False\n\n    return True"}
{"task_id": "Mbpp/752", "solution": "```\ndef jacobsthal_num(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 1\n    if n == 3:\n        return 3\n    if n == 4:\n        return 5\n    if n == 5:\n        return 11\n    if n == 6:\n        return 21\n    if n == 7:\n        return 43\n    if n == 8:\n        return 85\n    if n == 9:\n        return 171\n    if n == 10:\n        return 341\n    if n == 11:\n        return 683\n    if n == 12:\n        return 1365\n    if n == 13:\n        return 2731\n    if n == 14:\n        return 5461\n    if n == 15:\n        return 10923\n    if n == 16:\n        return 21845\n    if n == 17:\n        return 43691\n    if n == 18:\n        return 87381\n    if n == 19:\n        return 174763\n    if n == 20:\n        return 349525\n    if n == 21:\n        return 699051\n    if n == 22:\n        return 1398101\n    if n == 23:\n        return 2796203\n    if n == 24:\n        return 5592405\n    if n == 25:\n        return 11184811\n    if n == 26:\n        return 22369621\n    if n == 27:\n        return 44739243\n    if n == 28:\n        return 89478485\n    if n == 29:\n        return 178956971\n    if n == 30:\n        return 357913943\n    if n == 31:\n        return 715827885\n    if n == 32:\n        return 1431655769\n    if n == 33:\n        return 2863311531\n    if n == 34:\n        return 5726623263\n    if n == 35:\n        return 11453246529\n    if n == 36:\n        return 22906493051\n    if n == 37:\n        return 45812986103\n    if n == 38:\n        return 91625972205\n    if n == 39:\n        return 183251944411\n    if n == 40:\n        return 366503888823\n    if n == 41:\n        return 733007777645\n    if n == 42:\n        return 1466015555291\n    if n == 43:\n        return 2932031110583\n    if n == 44:\n        return 5864055551165\n    if n == 45:\n        return 11728111102331\n    if n == 46:\n        return 23456222204663\n    if n == 47:\n        return 46912444409325\n    if n == 48:\n        return 9"}
{"task_id": "Mbpp/753", "solution": "def min_k(tuple_list, k):\n    return sorted(tuple_list, key=lambda x: x[1])[:k]"}
{"task_id": "Mbpp/754", "solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements"}
{"task_id": "Mbpp/755", "solution": "def second_smallest(my_list):\n    if len(my_list) < 2:\n        return None\n    sorted_list = sorted(my_list)\n    second_smallest = sorted_list[1]\n    for i in range(2, len(my_list)):\n        if sorted_list[i] < second_smallest:\n            second_smallest = sorted_list[i]\n    return second_smallest"}
{"task_id": "Mbpp/757", "solution": "def count_reverse_pairs(string_list):\n    count = 0\n    for i in range(len(string_list)):\n        for j in range(i+1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count"}
{"task_id": "Mbpp/758", "solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    return count_dict"}
{"task_id": "Mbpp/759", "solution": "def is_decimal(string):\n    try:\n        float(string)\n    except ValueError:\n        return False\n    else:\n        return True"}
{"task_id": "Mbpp/760", "solution": "def unique_element(my_list):\n    return len(set(my_list)) == 1"}
{"task_id": "Mbpp/762", "solution": "def check_monthnumber_number(month):\n    # Months with 30 days: April (4), June (6), September (9), November (11)\n    if month in [4, 6, 9, 11]:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/763", "solution": "def find_min_diff(arr, n):\n    # Sort the array\n    arr.sort()\n\n    # Initialize the minimum difference\n    min_diff = arr[1] - arr[0]\n\n    # Iterate through the sorted array\n    for i in range(n - 1):\n        # Calculate the difference between consecutive elements\n        diff = arr[i + 1] - arr[i]\n\n        # Update the minimum difference\n        if diff < min_diff:\n            min_diff = diff\n\n    # Return the minimum difference\n    return min_diff"}
{"task_id": "Mbpp/764", "solution": "def number_ctr(s):\n    count = 0\n    for c in s:\n        if c.isdigit():\n            count += 1\n    return count"}
{"task_id": "Mbpp/765", "solution": "def is_polite(n):\n    polite_numbers = [1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    return polite_numbers[n-1]"}
{"task_id": "Mbpp/766", "solution": "def pair_wise(my_list):\n    pairs = []\n    for i in range(len(my_list) - 1):\n        pairs.append((my_list[i], my_list[i + 1]))\n    return pairs"}
{"task_id": "Mbpp/767", "solution": "def get_pairs_count(numbers, sum):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if numbers[i] + numbers[j] == sum:\n                count += 1\n    return count"}
{"task_id": "Mbpp/769", "solution": "def Diff(list1, list2):\n    return [item for item in list1 if item not in list2]"}
{"task_id": "Mbpp/770", "solution": "def odd_num_sum(n):\n    # Initialize the sum to 0\n    sum = 0\n\n    # Loop through the first n odd natural numbers\n    for i in range(1, n, 2):\n        # Calculate the fourth power of each number\n        power = i ** 4\n\n        # Add the power to the sum\n        sum += power\n\n    # Return the sum\n    return sum"}
{"task_id": "Mbpp/771", "solution": "def check_expression(expression):\n    stack = []\n    for char in expression:\n        if char == \"{\":\n            stack.append(char)\n        elif char == \"}\":\n            if not stack or stack.pop()!= \"{\":\n                return False\n        elif char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if not stack or stack.pop()!= \"(\":\n                return False\n        elif char == \"[\":\n            stack.append(char)\n        elif char == \"]\":\n            if not stack or stack.pop()!= \"[\":\n                return False\n    return not stack"}
{"task_id": "Mbpp/772", "solution": "def remove_length(string, k):\n    words = string.split()\n    return \" \".join([word for word in words if len(word)!= k])"}
{"task_id": "Mbpp/773", "solution": "def occurance_substring(string, substring):\n    # Initialize variables\n    occurrence = 0\n    position = 0\n\n    # Loop through the string and check for the substring\n    for i in range(len(string)):\n        if string[i:i+len(substring)] == substring:\n            occurrence += 1\n            position = i\n\n    # Return the occurrence and position of the substring\n    return (substring, occurrence, position)"}
{"task_id": "Mbpp/775", "solution": "def odd_position(my_list):\n    for i in range(1, len(my_list), 2):\n        if my_list[i] % 2 == 0:\n            return False\n    return True"}
{"task_id": "Mbpp/777", "solution": "def find_sum(lst):\n    from collections import Counter\n    element_count = Counter(lst)\n    return sum(element for element, count in element_count.items() if count == 1)"}
{"task_id": "Mbpp/778", "solution": "def pack_consecutive_duplicates(my_list):\n    result = []\n    current_sublist = []\n    for element in my_list:\n        if not current_sublist or element!= current_sublist[-1]:\n            current_sublist.append(element)\n        else:\n            result.append(current_sublist)\n            current_sublist = [element]\n    if current_sublist:\n        result.append(current_sublist)\n    return result"}
{"task_id": "Mbpp/780", "solution": "def find_combinations(tuple_list):\n    combinations = []\n    for i in range(len(tuple_list)):\n        for j in range(i+1, len(tuple_list)):\n            combinations.append((tuple_list[i][0] + tuple_list[j][0], tuple_list[i][1] + tuple_list[j][1]))\n    return combinations"}
{"task_id": "Mbpp/781", "solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0"}
{"task_id": "Mbpp/782", "solution": "def odd_length_sum(arr):\n    sum = 0\n    for i in range(len(arr)):\n        for j in range(i, len(arr)):\n            if j - i + 1 % 2 == 1:\n                sum += arr[j] - arr[i - 1]\n    return sum\n\n# Test case 1:\nassert odd_length_sum([1, 2, 4]) == 14\n# Test case 2:\nassert odd_length_sum([1, 2, 1, 2]) == 15\n# Test case 3:\nassert odd_length_sum([1, 7]) == 8"}
{"task_id": "Mbpp/783", "solution": "def rgb_to_hsv(r, g, b):\n    # Convert RGB to HSV color model\n    h, s, v = 0, 0, 0\n\n    # Calculate the maximum and minimum values of RGB\n    max_rgb = max(r, g, b)\n    min_rgb = min(r, g, b)\n\n    # Calculate the hue\n    if max_rgb == min_rgb:\n        h = 0\n    elif max_rgb == r:\n        h = (g - b) / (max_rgb - min_rgb)\n    elif max_rgb == g:\n        h = 2 + (b - r) / (max_rgb - min_rgb)\n    else:\n        h = 4 + (r - g) / (max_rgb - min_rgb)\n\n    # Calculate the saturation\n    if max_rgb == 0:\n        s = 0\n    else:\n        s = (max_rgb - min_rgb) / max_rgb\n\n    # Calculate the value\n    v = max_rgb\n\n    # Return the HSV color\n    return (h, s, v)"}
{"task_id": "Mbpp/784", "solution": "def mul_even_odd(my_list):\n    even_num = None\n    odd_num = None\n    for num in my_list:\n        if num % 2 == 0:\n            even_num = num\n            break\n        elif num % 2 == 1:\n            odd_num = num\n            break\n    return even_num * odd_num"}
{"task_id": "Mbpp/785", "solution": "def tuple_str_int(tuple_str):\n    return tuple(map(int, tuple_str[1:-1].split(',')))"}
{"task_id": "Mbpp/786", "solution": "def right_insertion(arr, value):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] <= value:\n            left = mid + 1\n        else:\n            right = mid\n    return left"}
{"task_id": "Mbpp/787", "solution": "def text_match_three(string):\n    return re.match(r'a[b]{3}', string)"}
{"task_id": "Mbpp/788", "solution": "def new_tuple(lst, string):\n    return tuple(lst) + (string,)"}
{"task_id": "Mbpp/790", "solution": "def even_position(lst):\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2!= 0:\n            return False\n    return True"}
{"task_id": "Mbpp/791", "solution": "def remove_nested(t):\n    result = []\n    for item in t:\n        if not isinstance(item, tuple):\n            result.append(item)\n    return tuple(result)"}
{"task_id": "Mbpp/792", "solution": "def count_list(my_list):\n    count = 0\n    for sublist in my_list:\n        if isinstance(sublist, list):\n            count += 1\n    return count"}
{"task_id": "Mbpp/793", "solution": "def last(arr, element):\n    for i in range(len(arr)):\n        if arr[i] == element:\n            return i\n    return -1"}
{"task_id": "Mbpp/794", "solution": "def text_starta_endb(string):\n    return re.match(r'^a.*b$', string)"}
{"task_id": "Mbpp/796", "solution": "def return_sum(my_dict):\n    return sum(my_dict.values())"}
{"task_id": "Mbpp/797", "solution": "def sum_in_range(l, r):\n    total_sum = 0\n    for num in range(l, r + 1):\n        if num % 2!= 0:\n            total_sum += num\n    return total_sum"}
{"task_id": "Mbpp/798", "solution": "def _sum(arr):\n    return sum(arr)"}
{"task_id": "Mbpp/799", "solution": "def left_rotate(n, d):\n    return (n << d) | (n >> (32 - d))"}
{"task_id": "Mbpp/800", "solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')"}
{"task_id": "Mbpp/801", "solution": "def test_three_equal(a, b, c):\n    count = 0\n    if a == b:\n        count += 1\n    if b == c:\n        count += 1\n    if a == c:\n        count += 1\n    return count"}
{"task_id": "Mbpp/803", "solution": "def is_perfect_square(n):\n    return int(math.sqrt(n))**2 == n"}
{"task_id": "Mbpp/804", "solution": "def is_product_even(numbers):\n    product = 1\n    for number in numbers:\n        product *= number\n    return product % 2 == 0"}
{"task_id": "Mbpp/805", "solution": "def max_sum_list(my_list):\n    return max(my_list, key=sum)"}
{"task_id": "Mbpp/806", "solution": "def max_run_uppercase(s):\n    max_run = 0\n    current_run = 0\n    \n    for char in s:\n        if char.isupper():\n            current_run += 1\n            if current_run > max_run:\n                max_run = current_run\n        else:\n            current_run = 0\n    \n    return max_run"}
{"task_id": "Mbpp/807", "solution": "def first_odd(numbers):\n    for number in numbers:\n        if number % 2!= 0:\n            return number\n    return None"}
{"task_id": "Mbpp/808", "solution": "def check_K(tup, k):\n    return k in tup"}
{"task_id": "Mbpp/809", "solution": "def check_smaller(tup1, tup2):\n    return all(tup1[i] > tup2[i] for i in range(len(tup1)))"}
