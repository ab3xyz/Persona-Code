{"solution": "def max_accordion_length(s):\n    # Check if the string can contain an accordion at all\n    if '[' not in s or ']' not in s or ':' not in s:\n        return -1\n\n    # Find the first opening bracket and the last closing bracket\n    first_open = s.find('[')\n    last_close = s.rfind(']')\n\n    # Check if there's a valid position for the colons\n    if first_open >= last_close:\n        return -1\n\n    # Count the vertical bars between the first opening bracket and the last closing bracket\n    bars_count = s.count('|', first_open, last_close)\n\n    # Find the positions of the colons within the valid range\n    colons_in_range = [i for i, char in enumerate(s) if char == ':' and first_open < i < last_close]\n\n    # If there are less than 2 colons, it's not possible to form an accordion\n    if len(colons_in_range) < 2:\n        return -1\n\n    # The length of the accordion is the number of bars plus 4 (for the brackets and colons)\n    return bars_count + 4\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(max_accordion_length(s))"}
{"solution": "def max_digit_sum_number(x):\n    # Function to calculate the sum of digits of a number\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(n))\n\n    # Start with the number itself\n    best_number = x\n    max_sum = sum_of_digits(x)\n\n    # Convert the number to a string for easier manipulation\n    str_x = str(x)\n\n    # Try to find a number with a higher sum of digits by changing digits from left to right\n    for i in range(len(str_x)):\n        if str_x[i] != '0':\n            # Decrease the current digit by 1 and make all following digits '9'\n            candidate = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (len(str_x) - i - 1)\n            candidate_sum = sum_of_digits(candidate)\n\n            # If the candidate has a higher sum of digits or is equal but larger, update the best number\n            if candidate_sum > max_sum or (candidate_sum == max_sum and int(candidate) > int(best_number)):\n                best_number = candidate\n                max_sum = candidate_sum\n\n    return int(best_number)\n\n# Read input\nx = int(input().strip())\n\n# Output the result\nprint(max_digit_sum_number(x))"}
{"solution": "def next_lucky_year(current_year):\n    year = current_year + 1\n    while True:\n        if len(set(str(year))) <= 2 and '0' not in str(year):\n            return year - current_year\n        year += 1\n\n# Example usage:\n# print(next_lucky_year(4))    # Output: 1\n# print(next_lucky_year(201))  # Output: 99\n# print(next_lucky_year(4000)) # Output: 1000"}
{"solution": "def maximize_painted_sections(n, q, painters):\n    # Initialize a list to keep track of painted sections\n    painted = [0] * (n + 1)\n    \n    # Calculate the total number of sections painted by all painters\n    for l, r in painters:\n        painted[l - 1] += 1\n        painted[r] -= 1\n    \n    # Apply prefix sum to determine the actual painted sections\n    for i in range(1, n + 1):\n        painted[i] += painted[i - 1]\n    \n    # Convert the painted list to a binary list where 1 indicates a painted section\n    painted = [1 if x > 0 else 0 for x in painted[:-1]]\n    \n    # Calculate the prefix sums of the painted sections\n    prefix_sums = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + painted[i - 1]\n    \n    # Initialize the maximum number of painted sections\n    max_painted = 0\n    \n    # Iterate over all pairs of painters to find the optimal pair to exclude\n    for i in range(q):\n        for j in range(i + 1, q):\n            # Calculate the number of sections painted by the current pair of painters\n            l1, r1 = painters[i]\n            l2, r2 = painters[j]\n            \n            # Calculate the number of painted sections if these two painters are excluded\n            current_painted = prefix_sums[r1] - prefix_sums[l1 - 1] + prefix_sums[r2] - prefix_sums[l2 - 1]\n            \n            # Subtract the overlap between the two painters\n            if r1 > l2:\n                overlap_start = l2\n                overlap_end = min(r1, r2)\n                current_painted -= prefix_sums[overlap_end] - prefix_sums[overlap_start - 1]\n            \n            # Update the maximum number of painted sections\n            max_painted = max(max_painted, prefix_sums[n] - current_painted)\n    \n    return max_painted\n\n# Read input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Print the result\nprint(maximize_painted_sections(n, q, painters))"}
{"solution": "def contains_seven(hh, mm):\n    return '7' in str(hh) or '7' in str(mm)\n\ndef find_snooze_count(x, hh, mm):\n    snooze_count = 0\n    while not contains_seven(hh, mm):\n        mm -= x\n        if mm < 0:\n            mm += 60\n            hh -= 1\n        if hh < 0:\n            hh += 24\n        snooze_count += 1\n    return snooze_count\n\n# Read input\nx = int(input())\nhh, mm = map(int, input().split())\n\n# Find and print the result\nprint(find_snooze_count(x, hh, mm))"}
{"solution": "def min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0\n    elif l == 1:\n        return abs(pos - r) + 1\n    elif r == n:\n        return abs(pos - l) + 1\n    else:\n        return min(abs(pos - l), abs(pos - r)) + (r - l) + 2\n\n# Example usage:\nn, pos, l, r = map(int, input().split())\nprint(min_seconds_to_close_tabs(n, pos, l, r))"}
{"solution": "def min_blows_to_defeat_zmei_gorynich(t, queries):\n    results = []\n    for n, x, blows in queries:\n        max_damage = max_self_heal = 0\n        for d, h in blows:\n            max_damage = max(max_damage, d)\n            max_self_heal = max(max_self_heal, d - h)\n        \n        if max_damage >= x:\n            results.append(1)\n        elif max_self_heal <= 0:\n            results.append(-1)\n        else:\n            remaining_heads = x - max_damage\n            additional_blows = (remaining_heads + max_self_heal - 1) // max_self_heal\n            results.append(additional_blows + 1)\n    \n    return results\n\n# Example usage:\n# t = 3\n# queries = [\n#     (3, 10, [(6, 3), (8, 2), (1, 4)]),\n#     (4, 10, [(4, 1), (3, 2), (2, 6), (1, 100)]),\n#     (2, 15, [(10, 11), (14, 100)])\n# ]\n# print(min_blows_to_defeat_zmei_gorynich(t, queries))"}
{"solution": "def find_empty_day(n, m):\n    day = 1\n    while n > 0:\n        if n <= m:\n            n = 0\n        else:\n            n -= m\n            n -= day\n            day += 1\n    return day\n\n# Read input\nn, m = map(int, input().split())\n\n# Find and print the result\nprint(find_empty_day(n, m))"}
{"solution": "def min_draws_to_win(tiles):\n    # Parse the input tiles\n    tile1, tile2, tile3 = tiles.split()\n    \n    # Extract numbers and suits\n    num1, suit1 = int(tile1[0]), tile1[1]\n    num2, suit2 = int(tile2[0]), tile2[1]\n    num3, suit3 = int(tile3[0]), tile3[1]\n    \n    # Check for koutsu (triplet)\n    if tile1 == tile2 == tile3:\n        return 0\n    \n    # Check for shuntsu (sequence)\n    def is_shuntsu(n1, n2, n3):\n        return sorted([n1, n2, n3]) in [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9]]\n    \n    if suit1 == suit2 == suit3 and is_shuntsu(num1, num2, num3):\n        return 0\n    \n    # Check for possible koutsu with one more draw\n    if tile1 == tile2 or tile1 == tile3 or tile2 == tile3:\n        return 1\n    \n    # Check for possible shuntsu with one more draw\n    def needs_one_for_shuntsu(n1, n2):\n        return abs(n1 - n2) == 1 or abs(n1 - n2) == 2\n    \n    if suit1 == suit2 and needs_one_for_shuntsu(num1, num2):\n        return 1\n    if suit1 == suit3 and needs_one_for_shuntsu(num1, num3):\n        return 1\n    if suit2 == suit3 and needs_one_for_shuntsu(num2, num3):\n        return 1\n    \n    # If no koutsu or shuntsu can be formed with one more draw, return 2\n    return 2\n\n# Example usage\nprint(min_draws_to_win(\"1s 2s 3s\"))  # Output: 0\nprint(min_draws_to_win(\"9m 9m 9m\"))  # Output: 0\nprint(min_draws_to_win(\"3p 9m 2p\"))  # Output: 1"}
{"solution": "def find_maks_sofa(d, n, m, sofas, conditions):\n    cnt_l, cnt_r, cnt_t, cnt_b = conditions\n    \n    # Initialize counters for each sofa\n    left_counts = [0] * d\n    right_counts = [0] * d\n    top_counts = [0] * d\n    bottom_counts = [0] * d\n    \n    # Calculate the number of sofas to the left, right, top, and bottom for each sofa\n    for i in range(d):\n        for j in range(d):\n            if i != j:\n                # Check if sofa j is to the left of sofa i\n                if (sofas[j][0] < sofas[i][0] or sofas[j][2] < sofas[i][0]) or \\\n                   (sofas[j][0] < sofas[i][2] or sofas[j][2] < sofas[i][2]):\n                    left_counts[i] += 1\n                # Check if sofa j is to the right of sofa i\n                if (sofas[j][0] > sofas[i][0] or sofas[j][2] > sofas[i][0]) or \\\n                   (sofas[j][0] > sofas[i][2] or sofas[j][2] > sofas[i][2]):\n                    right_counts[i] += 1\n                # Check if sofa j is to the top of sofa i\n                if (sofas[j][1] < sofas[i][1] or sofas[j][3] < sofas[i][1]) or \\\n                   (sofas[j][1] < sofas[i][3] or sofas[j][3] < sofas[i][3]):\n                    top_counts[i] += 1\n                # Check if sofa j is to the bottom of sofa i\n                if (sofas[j][1] > sofas[i][1] or sofas[j][3] > sofas[i][1]) or \\\n                   (sofas[j][1] > sofas[i][3] or sofas[j][3] > sofas[i][3]):\n                    bottom_counts[i] += 1\n    \n    # Find the sofa that matches the conditions\n    for i in range(d):\n        if left_counts[i] == cnt_l and right_counts[i] == cnt_r and \\\n           top_counts[i] == cnt_t and bottom_counts[i] == cnt_b:\n            return i + 1  # Sofas are numbered starting from 1\n    \n    return -1\n\n# Read input\nd = int(input())\nn, m = map(int, input().split())\nsofas = [list(map(int, input().split())) for _ in range(d)]\nconditions = list(map(int, input().split()))\n\n# Find and print the result\nprint(find_maks_sofa(d, n, m, sofas, conditions))"}
{"solution": "def mars_days_off(n):\n    full_weeks = n // 7\n    remaining_days = n % 7\n    \n    min_days_off = full_weeks * 2\n    max_days_off = full_weeks * 2 + min(remaining_days, 2)\n    \n    return min_days_off, max_days_off\n\n# Assuming the input is provided through standard input\nn = int(input())\nmin_days_off, max_days_off = mars_days_off(n)\nprint(min_days_off, max_days_off)"}
{"solution": "def max_chocolates(n, a, b, p, q):\n    # Calculate the number of tiles divisible by a, b, and both a and b\n    count_a = n // a\n    count_b = n // b\n    count_ab = n // (a * b)\n    \n    # Calculate the number of tiles that can be painted Red or Blue exclusively\n    exclusive_red = count_a - count_ab\n    exclusive_blue = count_b - count_ab\n    \n    # Determine the optimal choice for tiles that can be either Red or Blue\n    if p > q:\n        max_chocolates = exclusive_red * p + exclusive_blue * q + count_ab * p\n    else:\n        max_chocolates = exclusive_red * p + exclusive_blue * q + count_ab * q\n    \n    return max_chocolates\n\n# Read input\nn, a, b, p, q = map(int, input().split())\n\n# Calculate and print the result\nprint(max_chocolates(n, a, b, p, q))"}
{"solution": "def max_golden_subsegment_length(n, trophies):\n    # Count the total number of golden trophies\n    total_gold = trophies.count('G')\n    \n    # If there are no golden trophies or all trophies are golden, return the total number of golden trophies\n    if total_gold == 0 or total_gold == n:\n        return total_gold\n    \n    # Split the trophies string by silver trophies to get segments of golden trophies\n    gold_segments = trophies.split('S')\n    \n    # Initialize the maximum length of a golden subsegment\n    max_length = 0\n    \n    # Initialize the length of the last golden segment\n    last_length = 0\n    \n    # Iterate through the golden segments to find the maximum length\n    for segment in gold_segments:\n        if len(segment) > max_length:\n            max_length = len(segment)\n        last_length = len(segment)\n    \n    # Initialize the length of the current golden segment\n    current_length = 0\n    \n    # Iterate through the golden segments again to check if we can increase the maximum length by one swap\n    for i in range(len(gold_segments) - 1):\n        current_length = len(gold_segments[i])\n        # If the current segment and the next segment, plus one for the swap, are longer than the max length, update the max length\n        if current_length + len(gold_segments[i + 1]) + 1 > max_length:\n            max_length = current_length + len(gold_segments[i + 1]) + 1\n    \n    # Ensure that the maximum length does not exceed the total number of golden trophies\n    return min(max_length, total_gold)\n\n# Read input\nn = int(input())\ntrophies = input()\n\n# Print the result\nprint(max_golden_subsegment_length(n, trophies))"}
{"solution": "from collections import defaultdict, deque\n\ndef topological_sort(graph, in_degree, n):\n    queue = deque()\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    order = []\n    while queue:\n        course = queue.popleft()\n        order.append(course)\n        for dependent in graph[course]:\n            in_degree[dependent] -= 1\n            if in_degree[dependent] == 0:\n                queue.append(dependent)\n    \n    return order\n\ndef main():\n    n, k = map(int, input().split())\n    main_courses = list(map(int, input().split()))\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    \n    for i in range(1, n + 1):\n        data = list(map(int, input().split()))\n        t_i = data[0]\n        dependencies = data[1:]\n        for dep in dependencies:\n            graph[dep].append(i)\n            in_degree[i] += 1\n    \n    order = topological_sort(graph, in_degree, n)\n    \n    if len(order) != n:\n        print(-1)\n        return\n    \n    required_courses = set(main_courses)\n    for course in order:\n        if course in required_courses:\n            required_courses.remove(course)\n        if not required_courses:\n            break\n    \n    if required_courses:\n        print(-1)\n    else:\n        print(len(order))\n        print(' '.join(map(str, order)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def restore_stack_sortable_permutation(n, k, p):\n    if k > 1:\n        # Check if the first k elements are already not stack-sortable\n        for i in range(1, k):\n            if p[i] < p[i - 1]:\n                return -1\n    \n    # Initialize the remaining elements to be added\n    remaining = list(range(k + 1, n + 1))\n    remaining.sort(reverse=True)\n    \n    # Try to build the lexicographically maximal stack-sortable permutation\n    result = p[:]\n    stack = []\n    idx = 0\n    \n    for num in range(1, n + 1):\n        if idx < k and p[idx] == num:\n            idx += 1\n        else:\n            while stack and stack[-1] == num:\n                stack.pop()\n                break\n            if remaining:\n                stack.append(remaining.pop(0))\n    \n    # If stack is not empty, it means we couldn't sort the permutation\n    if stack:\n        return -1\n    \n    return result + remaining\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result and print it\nresult = restore_stack_sortable_permutation(n, k, p)\nprint(' '.join(map(str, result)) if result != -1 else -1)"}
{"solution": "def does_b_appear_in_sequence(a, b, c):\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n# Read input from stdin\na, b, c = map(int, input().split())\nprint(does_b_appear_in_sequence(a, b, c))"}
{"solution": "def can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    if cnt_1 == cnt_4:\n        return 1\n    else:\n        return 0\n\n# Read input\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\n# Output result\nprint(can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4))"}
{"solution": "def mexican_wave_standing_spectators(n, k, t):\n    if t <= k:\n        return t\n    elif t <= n:\n        return k\n    else:\n        return n + k - t\n\n# Read input\nn, k, t = map(int, input().split())\n\n# Calculate and print the number of standing spectators at time t\nprint(mexican_wave_standing_spectators(n, k, t))"}
{"solution": "def lexicographically_minimal_string(s):\n    t = []\n    u = []\n    min_char = min(s)\n    s = list(s)\n    \n    while s or t:\n        if t and (not s or t[-1] <= min_char):\n            u.append(t.pop())\n        else:\n            char = s.pop(0)\n            t.append(char)\n            if s:\n                min_char = min(s)\n    \n    return ''.join(u)\n\n# Input\ns = input().strip()\nprint(lexicographically_minimal_string(s))"}
{"solution": "def check_stats_consistency(T, test_cases):\n    results = []\n    for case in test_cases:\n        n = case[0]\n        stats = case[1]\n        valid = True\n        prev_plays, prev_clears = 0, 0\n        \n        for i in range(n):\n            plays, clears = stats[i]\n            if plays < prev_plays or clears < prev_clears or plays < clears or clears - prev_clears > plays - prev_plays:\n                valid = False\n                break\n            prev_plays, prev_clears = plays, clears\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Example usage (commented out as per request):\n# T = 6\n# test_cases = [\n#     (3, [(0, 0), (1, 1), (1, 2)]),\n#     (2, [(1, 0), (1000, 3)]),\n#     (4, [(10, 1), (15, 2), (10, 2), (15, 2)]),\n#     (1, [(765, 432)]),\n#     (2, [(4, 4), (4, 3)]),\n#     (5, [(0, 0), (1, 0), (1, 0), (1, 0), (1, 0)])\n# ]\n# print(\"\\n\".join(check_stats_consistency(T, test_cases)))"}
{"solution": "def is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindromic_time(hh, mm):\n    minutes = hh * 60 + mm\n    for i in range(minutes, minutes + 1440):  # Check within the next 24 hours\n        current_time = i % 1440\n        current_hh, current_mm = divmod(current_time, 60)\n        time_str = f\"{current_hh:02d}{current_mm:02d}\"\n        if is_palindrome(time_str):\n            return current_time - minutes\n    return None  # This should never happen as there's always a palindromic time within 24 hours\n\n# Read input\nhh, mm = map(int, input().strip().split(':'))\n\n# Calculate and print the output\nprint(next_palindromic_time(hh, mm))"}
{"solution": "def maximize_distance(n, permutation):\n    min_index = permutation.index(1)\n    max_index = permutation.index(n)\n    \n    # Calculate the maximum possible distance by considering the best swap\n    # options: swap min to the end, max to the start, or swap min and max directly.\n    max_distance = max(max_index, min_index, n - 1 - min_index, n - 1 - max_index)\n    \n    # The maximum distance is the sum of the distances from the current positions\n    # to the opposite ends, minus the overlap if they are swapped directly.\n    return max_distance\n\n# Read input\nn = int(input())\npermutation = list(map(int, input().split()))\n\n# Output the result\nprint(maximize_distance(n, permutation))"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    mid = n // 2\n    if n % 2 == 0:\n        first_half = s[:mid]\n        second_half = s[mid:]\n    else:\n        first_half = s[:mid]\n        second_half = s[mid+1:]\n    \n    if first_half == second_half[::-1]:\n        return \"TAK\"\n    else:\n        return \"NIE\"\n\n# Example usage:\ns = input().strip()\nprint(is_s_palindrome(s))"}
{"solution": "from itertools import permutations\n\ndef max_permutation_not_exceeding(a, b):\n    a_digits = list(str(a))\n    b_digits = list(str(b))\n    \n    # Sort the digits of a in descending order to get the maximum possible number\n    a_digits.sort(reverse=True)\n    \n    # If the maximum permutation of a is still less than b, return it\n    if int(''.join(a_digits)) <= b:\n        return ''.join(a_digits)\n    \n    # Otherwise, find the largest permutation of a that does not exceed b\n    for perm in sorted(set(permutations(a_digits)), reverse=True):\n        if perm[0] == '0':  # Skip permutations that start with 0\n            continue\n        perm_num = int(''.join(perm))\n        if perm_num <= b:\n            return str(perm_num)\n    \n    # This line should never be reached since it's guaranteed that an answer exists\n    return None\n\n# Read input\na = int(input().strip())\nb = int(input().strip())\n\n# Print output\nprint(max_permutation_not_exceeding(a, b))"}
{"solution": "def check_win(board, x, y, dx, dy):\n    count = 0\n    for i in range(5):\n        nx, ny = x + dx * i, y + dy * i\n        if 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n            count += 1\n        else:\n            break\n    return count == 5\n\ndef can_win_in_one_turn(board):\n    directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                for dx, dy in directions:\n                    if (check_win(board, i, j, dx, dy) or\n                        check_win(board, i - dx, j - dy, dx, dy) or\n                        (check_win(board, i - dx, j - dy, dx, dy) and check_win(board, i + dx * 4, j + dy * 4, -dx, -dy))):\n                        return 'YES'\n    return 'NO'\n\n# Example usage:\n# board = [input().strip() for _ in range(10)]\n# print(can_win_in_one_turn(board))"}
{"solution": "def symmetric_lexicographically_maximal_matrix(n, k):\n    if k > n * n:\n        return -1\n    \n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        for j in range(i, n):\n            if k <= 0:\n                break\n            if i == j:\n                if k > 0:\n                    matrix[i][j] = 1\n                    k -= 1\n            else:\n                if k > 1:\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n                elif k == 1:\n                    matrix[i][i] = 1\n                    k -= 1\n    \n    if k > 0:\n        return -1\n    \n    return matrix\n\ndef print_matrix(matrix):\n    for row in matrix:\n        print(' '.join(map(str, row)))\n\n# Read input\nn, k = map(int, input().split())\n\n# Get the result\nresult = symmetric_lexicographically_maximal_matrix(n, k)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    print_matrix(result)"}
{"solution": "import math\n\ndef evaluate_expressions(x, y, z):\n    expressions = [\n        x**(y**z), x**(z**y), (x**y)**z, (x**z)**y,\n        y**(x**z), y**(z**x), (y**x)**z, (y**z)**x,\n        z**(x**y), z**(y**x), (z**x)**y, (z**y)**x\n    ]\n    return expressions\n\ndef find_max_expression(x, y, z):\n    expressions = evaluate_expressions(x, y, z)\n    max_value = max(expressions)\n    max_index = expressions.index(max_value)\n    \n    # Mapping index to the corresponding expression string\n    expression_strings = [\n        \"x^y^z\", \"x^z^y\", \"(x^y)^z\", \"(x^z)^y\",\n        \"y^x^z\", \"y^z^x\", \"(y^x)^z\", \"(y^z)^x\",\n        \"z^x^y\", \"z^y^x\", \"(z^x)^y\", \"(z^y)^x\"\n    ]\n    \n    return expression_strings[max_index]\n\n# Read input\nx, y, z = map(float, input().split())\n\n# Find and print the maximum expression\nprint(find_max_expression(x, y, z))"}
{"solution": "def min_operations_to_type_string(n, s):\n    # Initialize the minimum operations to the length of the string\n    min_ops = n\n    \n    # Check for the possibility of copying the string at some point\n    for i in range(1, n):\n        # If the substring from the start to the current position i\n        # is a prefix of the remaining string, we can consider copying it\n        if s[:i] == s[i:2*i]:\n            # Operations are the length of the prefix plus 1 (for copying)\n            # plus the remaining characters after the copied part\n            min_ops = min(min_ops, i + 1 + (n - 2*i))\n    \n    return min_ops\n\n# Read input\nn = int(input())\ns = input()\n\n# Output the result\nprint(min_operations_to_type_string(n, s))"}
{"solution": "def generate_rename_script(n, files):\n    examples = []\n    regular = []\n    for name, type_ in files:\n        if type_ == '1':\n            examples.append(name)\n        else:\n            regular.append(name)\n    \n    # Sort examples and regular tests to maintain order\n    examples.sort()\n    regular.sort()\n    \n    # Create a list to hold the script commands\n    script = []\n    \n    # Rename examples first\n    for i, example in enumerate(examples, start=1):\n        script.append(f\"move {example} {i}\")\n    \n    # Rename regular tests next\n    for i, reg in enumerate(regular, start=len(examples) + 1):\n        script.append(f\"move {reg} {i}\")\n    \n    # Print the number of lines in the script\n    print(len(script))\n    \n    # Print the script\n    for line in script:\n        print(line)\n\n# Read input\nn = int(input().strip())\nfiles = [input().strip().split() for _ in range(n)]\n\n# Generate and print the script\ngenerate_rename_script(n, files)"}
{"solution": "def min_replacements_to_make_ticket_lucky(ticket):\n    # Calculate the sum of the first and last three digits\n    sum_first_half = sum(int(digit) for digit in ticket[:3])\n    sum_last_half = sum(int(digit) for digit in ticket[3:])\n    \n    # If the ticket is already lucky, no replacements are needed\n    if sum_first_half == sum_last_half:\n        return 0\n    \n    # Determine the difference between the sums\n    difference = abs(sum_first_half - sum_last_half)\n    \n    # Create lists of the digits in the first and last halves\n    first_half_digits = [int(digit) for digit in ticket[:3]]\n    last_half_digits = [int(digit) for digit in ticket[3:]]\n    \n    # Sort the lists to easily find the minimum changes needed\n    first_half_digits.sort()\n    last_half_digits.sort()\n    \n    # Initialize the number of replacements needed\n    replacements = 0\n    \n    # If the sum of the first half is greater, we need to reduce it or increase the last half\n    if sum_first_half > sum_last_half:\n        larger_half, smaller_half = first_half_digits, last_half_digits\n    else:\n        larger_half, smaller_half = last_half_digits, first_half_digits\n    \n    # Use two pointers to find the minimum number of replacements\n    i, j = 0, 2\n    while difference > 0:\n        # If we can reduce the difference by changing a digit in the larger half\n        if i <= 2 and 9 - larger_half[i] >= difference:\n            difference -= (9 - larger_half[i])\n            i += 1\n        # If we can reduce the difference by changing a digit in the smaller half\n        elif j >= 0 and smaller_half[j] >= difference:\n            difference -= smaller_half[j]\n            j -= 1\n        else:\n            # If neither condition is met, we need to make another replacement\n            if i <= 2:\n                difference -= (9 - larger_half[i])\n                i += 1\n            else:\n                difference -= smaller_half[j]\n                j -= 1\n        replacements += 1\n    \n    return replacements\n\n# Example usage:\n# ticket = \"123456\"\n# print(min_replacements_to_make_ticket_lucky(ticket))  # Output: 2"}
{"solution": "def minimum_traps(m, x):\n    return m - 1"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef mod_inverse(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    return x1 + m0 if x1 < 0 else x1\n\ndef mod_exp(base, exp, mod):\n    result = 1\n    base = base % mod\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        exp = exp >> 1\n        base = (base * base) % mod\n    return result\n\ndef solve(n, k):\n    MOD = 10**6 + 3\n    if k > 2**n:\n        return 1, 1\n    \n    # Calculate the probability of no shared birthdays\n    no_shared_birthdays = 1\n    for i in range(k - 1):\n        no_shared_birthdays = (no_shared_birthdays * (2**n - i)) % MOD\n    no_shared_birthdays = (no_shared_birthdays * mod_inverse(2**(n * (k - 1)), MOD)) % MOD\n    \n    # Calculate the total number of possible combinations\n    total_combinations = mod_exp(2**n, k - 1, MOD)\n    \n    # Calculate the probability of at least one shared birthday\n    shared_birthdays = (total_combinations - no_shared_birthdays + MOD) % MOD\n    \n    # Calculate the denominator\n    denominator = mod_exp(2**n, k - 1, MOD)\n    \n    # Reduce the fraction\n    g = gcd(shared_birthdays, denominator)\n    A = shared_birthdays // g\n    B = denominator // g\n    \n    return A, B\n\n# Read input\nn, k = map(int, input().split())\n\n# Solve the problem\nA, B = solve(n, k)\n\n# Print the result\nprint(A, B)"}
{"solution": "def is_valid_journey(n, instructions):\n    current_position = 0  # Starting at the North Pole\n\n    for t, dir in instructions:\n        if dir == \"North\":\n            if current_position < t:\n                return \"NO\"  # Moving beyond the North Pole\n            current_position -= t\n        elif dir == \"South\":\n            if current_position + t > 20000:\n                return \"NO\"  # Moving beyond the South Pole\n            current_position += t\n        elif dir == \"West\" or dir == \"East\":\n            if current_position == 0 or current_position == 20000:\n                return \"NO\"  # Moving West or East at the poles\n\n    return \"YES\" if current_position == 0 else \"NO\"\n\n# Reading input\nn = int(input().strip())\ninstructions = [input().strip().split() for _ in range(n)]\ninstructions = [(int(t), dir) for t, dir in instructions]\n\n# Checking the journey\nprint(is_valid_journey(n, instructions))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef find_common_elements(a1, b1, a2, b2, L, R):\n    # Adjust the progressions to start from the same point\n    if b1 < b2:\n        a1, b1, a2, b2 = a2, b2, a1, b1\n    while b1 % a2 != b2 % a2:\n        b1 += a1\n    # Calculate the least common multiple of a1 and a2\n    lcm = a1 * a2 // gcd(a1, a2)\n    # Calculate the first common element\n    first_common = b1\n    # Calculate the number of common elements in the range [L, R]\n    if first_common > R:\n        return 0\n    start = max(L, first_common)\n    end = R\n    if first_common < L:\n        start = L\n        end = R - (L - first_common) % lcm\n    return (end - start) // lcm + 1\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Find and print the number of common elements\nprint(find_common_elements(a1, b1, a2, b2, L, R))"}
{"solution": "def max_min_pieces_per_plate(n, a, b):\n    max_x = min(a, b, n)  # The maximum possible x is limited by the smallest cake or the number of plates\n    while max_x > 0:\n        # Check if we can distribute the cakes such that each plate has at least max_x pieces\n        if (a // max_x) + (b // max_x) >= n:\n            return max_x\n        max_x -= 1\n    return 0  # This should never happen given the problem constraints\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(max_min_pieces_per_plate(n, a, b))"}
{"solution": "def is_valid_flag(n, m, field):\n    # Check if the field can be divided into three equal parts\n    if n % 3 != 0 and m % 3 != 0:\n        return \"NO\"\n    \n    # Determine if the stripes are horizontal or vertical\n    horizontal = n % 3 == 0\n    vertical = m % 3 == 0\n    \n    if horizontal:\n        stripe_height = n // 3\n        for i in range(3):\n            color = field[i * stripe_height][0]\n            for j in range(stripe_height):\n                if field[i * stripe_height + j] != color * m:\n                    return \"NO\"\n            if i > 0 and color == field[(i - 1) * stripe_height][0]:\n                return \"NO\"\n    elif vertical:\n        stripe_width = m // 3\n        for i in range(3):\n            color = field[0][i * stripe_width]\n            for j in range(stripe_width):\n                for k in range(n):\n                    if field[k][i * stripe_width + j] != color:\n                        return \"NO\"\n            if i > 0 and color == field[0][(i - 1) * stripe_width]:\n                return \"NO\"\n    else:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\n# Output result\nprint(is_valid_flag(n, m, field))"}
{"solution": "def spiral_hex_move(n):\n    # Define the pattern of movement in the spiral\n    # Each cycle consists of 6 moves, each move is a step in one of the 6 directions\n    # The length of each move increases every 6 moves\n    # Directions: 0 = right, 1 = up-right, 2 = up-left, 3 = left, 4 = down-left, 5 = down-right\n    \n    # Determine the cycle and the position within the cycle\n    cycle = n // 6\n    position_in_cycle = n % 6\n    \n    # Calculate the length of the current move\n    move_length = cycle + 1\n    \n    # Initialize coordinates\n    x, y = 0, 0\n    \n    # Move according to the pattern\n    if position_in_cycle == 0:\n        x += move_length\n    elif position_in_cycle == 1:\n        x += move_length\n        y += move_length\n    elif position_in_cycle == 2:\n        x -= move_length\n        y += move_length\n    elif position_in_cycle == 3:\n        x -= 2 * move_length\n    elif position_in_cycle == 4:\n        x -= move_length\n        y -= move_length\n    elif position_in_cycle == 5:\n        x += move_length\n        y -= move_length\n    \n    # Adjust coordinates for the previous cycles\n    x += (cycle * (cycle + 1)) // 2 * 6\n    y += cycle * (cycle + 1)\n    \n    return x, y\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the coordinates\nx, y = spiral_hex_move(n)\nprint(x, y)"}
{"solution": "import math\n\ndef can_break_shield(a, b, c):\n    gcd_ab = math.gcd(a, b)\n    return \"Yes\" if c % gcd_ab == 0 else \"No\"\n\na, b, c = map(int, input().split())\nprint(can_break_shield(a, b, c))"}
{"solution": "def can_tracks_coincide(n, L, kefa_barriers, sasha_barriers):\n    # Calculate distances between consecutive barriers for Kefa\n    kefa_distances = [(kefa_barriers[(i + 1) % n] - kefa_barriers[i]) % L for i in range(n)]\n    # Calculate distances between consecutive barriers for Sasha\n    sasha_distances = [(sasha_barriers[(i + 1) % n] - sasha_barriers[i]) % L for i in range(n)]\n    \n    # Double the kefa_distances to handle circular rotation\n    doubled_kefa_distances = kefa_distances + kefa_distances\n    \n    # Check if sasha_distances is a sublist of doubled_kefa_distances\n    for i in range(n):\n        if doubled_kefa_distances[i:i + n] == sasha_distances:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_barriers, sasha_barriers))"}
{"solution": "def longest_non_palindromic_substring(s):\n    # Check if the entire string is a palindrome\n    if s == s[::-1]:\n        # If the string is a single character or all characters are the same,\n        # there is no non-palindromic substring\n        if len(s) == 1 or all(c == s[0] for c in s):\n            return 0\n        # Otherwise, the longest non-palindromic substring is the entire string minus one character\n        else:\n            return len(s) - 1\n    # If the string is not a palindrome, the longest non-palindromic substring is the string itself\n    else:\n        return len(s)\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(longest_non_palindromic_substring(s))"}
{"solution": "def determine_round_status(n, ratings):\n    # Check if any rating has changed\n    for i in range(n):\n        if ratings[i][0] != ratings[i][1]:\n            return \"rated\"\n    \n    # Check if the standings are in non-increasing order of rating before the round\n    for i in range(1, n):\n        if ratings[i][0] > ratings[i-1][0]:\n            return \"unrated\"\n    \n    # If no rating has changed and standings are in order, it's impossible to determine\n    return \"maybe\"\n\n# Read input\nn = int(input())\nratings = [list(map(int, input().split())) for _ in range(n)]\n\n# Determine and print the status of the round\nprint(determine_round_status(n, ratings))"}
{"solution": "def nearest_zero_distances(n, arr):\n    # Initialize the result array with a large number\n    result = [float('inf')] * n\n    \n    # First pass: left to right\n    last_zero = -float('inf')\n    for i in range(n):\n        if arr[i] == 0:\n            last_zero = i\n        result[i] = min(result[i], i - last_zero)\n    \n    # Second pass: right to left\n    last_zero = float('inf')\n    for i in range(n - 1, -1, -1):\n        if arr[i] == 0:\n            last_zero = i\n        result[i] = min(result[i], last_zero - i)\n    \n    return result\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Getting the result and printing it\nresult = nearest_zero_distances(n, arr)\nprint(' '.join(map(str, result)))"}
{"solution": "def count_distinct_cyclical_strings(n, s):\n    from itertools import product\n    \n    def is_substring_in_cyclical_shifts(t, s):\n        t_extended = t + t\n        return any(s in t_extended[i:i+len(t)] for i in range(len(t)))\n    \n    distinct_cyclical_strings = set()\n    \n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if is_substring_in_cyclical_shifts(t, s):\n            distinct_cyclical_strings.add(t)\n    \n    return len(distinct_cyclical_strings)\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Print output\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import math\n\ndef minimal_non_oriented_angle(vectors):\n    def angle_between(v1, v2):\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        magnitudes = math.sqrt(v1[0]**2 + v1[1]**2) * math.sqrt(v2[0]**2 + v2[1]**2)\n        cos_theta = dot_product / magnitudes\n        angle = math.acos(cos_theta)\n        return angle\n\n    min_angle = math.pi\n    min_pair = None\n\n    for i in range(len(vectors)):\n        for j in range(i + 1, len(vectors)):\n            angle = angle_between(vectors[i], vectors[j])\n            if angle < min_angle:\n                min_angle = angle\n                min_pair = (i + 1, j + 1)\n\n    return min_pair\n\n# Read input\nn = int(input())\nvectors = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Find and print the result\nresult = minimal_non_oriented_angle(vectors)\nprint(result[0], result[1])"}
{"solution": "def minimal_time(d, k, a, b, t):\n    if d <= k:\n        return d * a\n    \n    full_segments = d // k\n    remaining_distance = d % k\n    \n    time_for_full_segments = full_segments * k * a + (full_segments - 1) * t\n    \n    if remaining_distance == 0:\n        return time_for_full_segments\n    else:\n        time_drive_remaining = remaining_distance * a + t\n        time_walk_remaining = remaining_distance * b\n        \n        return time_for_full_segments + min(time_drive_remaining, time_walk_remaining)"}
{"solution": "def find_gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef max_gcd_sequence(n, k):\n    if k > n or k == 1:\n        return [-1]\n    \n    # The maximum GCD we can achieve is n // k\n    max_gcd = n // k\n    \n    # Start with the maximum GCD and try to build the sequence\n    sequence = [max_gcd * (i + 1) for i in range(k)]\n    \n    # Adjust the last element to ensure the sum is exactly n\n    sequence[-1] = n - sum(sequence[:-1])\n    \n    # Check if the last element is divisible by the max_gcd\n    if sequence[-1] % max_gcd != 0:\n        return [-1]\n    \n    return sequence\n\n# Read input\nn, k = map(int, input().split())\n\n# Get the sequence\nresult = max_gcd_sequence(n, k)\n\n# Print the result\nprint(' '.join(map(str, result)))"}
{"solution": "def count_pairs_divisible_by_5(n, m):\n    # Initialize the count of pairs\n    count = 0\n    \n    # Calculate the number of integers in each column that give a specific remainder when divided by 5\n    remainders_n = [0] * 5\n    remainders_m = [0] * 5\n    \n    for i in range(1, n + 1):\n        remainders_n[i % 5] += 1\n    for i in range(1, m + 1):\n        remainders_m[i % 5] += 1\n    \n    # For each possible remainder in n, find the corresponding remainder in m that makes (x + y) divisible by 5\n    for i in range(5):\n        count += remainders_n[i] * remainders_m[(5 - i) % 5]\n    \n    return count\n\n# Read input\nn, m = map(int, input().split())\n\n# Output the result\nprint(count_pairs_divisible_by_5(n, m))"}
{"solution": "def max_beauty_after_multiplication(n, x, a):\n    # Initialize variables to keep track of the best subarray sum and the current subarray sum\n    best = 0\n    current_sum = 0\n    max_sum = 0\n    \n    # Iterate through the array to find the maximum subarray sum without multiplication\n    for num in a:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    # Reset current_sum for the next phase\n    current_sum = 0\n    \n    # Iterate through the array again to find the best subarray to multiply by x\n    for num in a:\n        # Update the current sum without multiplication\n        current_sum = max(num, current_sum + num)\n        # Update the best sum considering the current subarray can be multiplied by x\n        best = max(best, current_sum, current_sum * x, best + num * x)\n    \n    # Return the maximum beauty of the array\n    return max(best, max_sum)\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(max_beauty_after_multiplication(n, x, a))"}
{"solution": "def find_kth_largest(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(m, x // i)\n        return count\n\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_less_equal(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\n# Assuming the input is provided in the format specified\nn, m, k = map(int, input().split())\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    # Initialize variables\n    length = 0\n    chunk = 1\n    next_boundary = 9\n\n    # Determine the chunk (number of digits) where the k-th digit is located\n    while k > next_boundary:\n        length += next_boundary * chunk\n        chunk += 1\n        next_boundary = 9 * (10 ** (chunk - 1)) * chunk\n\n    # Calculate the exact number where the k-th digit is located\n    remaining_length = k - length - 1\n    number = 10 ** (chunk - 1) + remaining_length // chunk\n    digit_position = remaining_length % chunk\n\n    # Extract the k-th digit from the number\n    return int(str(number)[digit_position])\n\n# Read input\nk = int(input().strip())\n\n# Output the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "def max_bourles_after_evening(n, m, r, s, b):\n    # Find the minimum buying price and maximum selling price\n    min_buy_price = min(s)\n    max_sell_price = max(b)\n    \n    # If it's profitable to trade\n    if min_buy_price < max_sell_price:\n        # Calculate the maximum number of shares to buy\n        max_shares_to_buy = r // min_buy_price\n        # Calculate the total bourles after selling all bought shares\n        total_bourles = max_shares_to_buy * max_sell_price\n        return total_bourles\n    else:\n        # It's not profitable to trade, so return the initial amount of bourles\n        return r\n\n# Read input\nn, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_bourles_after_evening(n, m, r, s, b))"}
{"solution": "def find_original_message(t):\n    n = len(t)\n    \n    for overlap in range(1, n // 2 + 1):\n        if t[:overlap] == t[-overlap:]:\n            s = t[:-overlap]\n            if s + t[-overlap:] == t:\n                return \"YES\", s\n    \n    return \"NO\", None\n\nt = input().strip()\n\nresult, s = find_original_message(t)\n\nprint(result)\nif result == \"YES\":\n    print(s)"}
{"solution": "def find_teams(n):\n    # Function to calculate the number of teams for a given number of games\n    def calculate_teams(games):\n        teams = 1\n        while games > 0:\n            if games % 2 == 0:\n                teams *= 2\n                games //= 2\n            else:\n                break\n        return teams\n\n    # List to store all possible numbers of teams\n    possible_teams = []\n\n    # Start with the given number of games and work backwards\n    while n > 0:\n        # Calculate the number of teams for the current number of games\n        teams = calculate_teams(n)\n        # If the calculated number of teams is valid, add it to the list\n        if teams > 0:\n            possible_teams.append(teams)\n        # Subtract the number of games for the round robin tournament\n        n -= (teams * (teams - 1)) // 2\n\n    # If no valid numbers of teams were found, return -1\n    if not possible_teams:\n        return [-1]\n\n    # Sort the list of possible teams in ascending order\n    possible_teams.sort()\n    return possible_teams\n\n# Read the input\nn = int(input())\n\n# Find and print all possible numbers of teams\nfor teams in find_teams(n):\n    print(teams)"}
{"solution": "def max_antipalindromic_beauty(n, s, b):\n    # Initialize the maximum beauty to 0\n    max_beauty = 0\n    \n    # Iterate through the string to find the maximum beauty\n    for i in range(n // 2):\n        # Calculate the beauty if we leave the characters as they are\n        beauty_same = b[i] + b[n - i - 1]\n        # Calculate the beauty if we swap the characters\n        beauty_swap = max(b[i], b[n - i - 1])\n        \n        # Update the maximum beauty considering both possibilities\n        max_beauty += max(beauty_same, beauty_swap)\n    \n    return max_beauty\n\n# Read input\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\n# Calculate and print the maximum possible beauty\nprint(max_antipalindromic_beauty(n, s, b))"}
{"solution": "def can_weigh_item(w, m):\n    while m > 0:\n        remainder = m % w\n        if remainder == 0:\n            m //= w\n        elif remainder == 1:\n            m = (m - 1) // w\n        elif remainder == w - 1:\n            m = (m + 1) // w\n        else:\n            return 'NO'\n    return 'YES'\n\n# Read input\nw, m = map(int, input().split())\n\n# Output result\nprint(can_weigh_item(w, m))"}
{"solution": "def find_sequence(n, k):\n    # Check if it's possible to find such a sequence\n    if k > n or (k == 1 and n != 1 and (n & (n - 1)) != 0):\n        return \"No\"\n    \n    # Start with the largest power of 2 that fits into n\n    power = 1\n    while (1 << power) <= n:\n        power += 1\n    power -= 1\n    \n    # Initialize the sequence with the largest power of 2 possible\n    sequence = [power] * k\n    current_sum = (1 << power) * k\n    \n    # Adjust the sequence to match the sum n\n    for i in range(k):\n        while current_sum - (1 << sequence[i]) + (1 << (sequence[i] - 1)) >= n and sequence[i] > 0:\n            current_sum += (1 << (sequence[i] - 1)) - (1 << sequence[i])\n            sequence[i] -= 1\n        if current_sum == n:\n            break\n    \n    # If the sum matches n, return the sequence, otherwise return \"No\"\n    if current_sum == n:\n        return \"Yes\\n\" + \" \".join(map(str, sequence))\n    else:\n        return \"No\"\n\n# Read input\nn, k = map(int, input().split())\n\n# Output the result\nprint(find_sequence(n, k))"}
{"solution": "def full_glasses(n, t):\n    # Initialize a 2D list to represent the glasses in the pyramid\n    glasses = [[0] * (i + 1) for i in range(n)]\n    \n    for second in range(t):\n        overflow = 0.5  # Amount of champagne that overflows from one glass\n        for level in range(n):\n            for glass in range(level + 1):\n                # Pour champagne into the current glass\n                poured = 1 - glasses[level][glass]\n                if poured > 0:\n                    glasses[level][glass] += min(poured, 1)\n                    overflow = max(0, poured - 1)\n                else:\n                    poured = 0\n                \n                # Distribute overflow to glasses below\n                if level < n - 1:\n                    glasses[level + 1][glass] += overflow / 2\n                    glasses[level + 1][glass + 1] += overflow / 2\n    \n    # Count the number of completely full glasses\n    full_count = sum(glass == 1 for level in glasses for glass in level)\n    return full_count\n\n# Read input\nn, t = map(int, input().split())\n\n# Print output\nprint(full_glasses(n, t))"}
{"solution": "def calculate_area(n, vertices):\n    if n == 1:\n        return -1\n    elif n == 2:\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        if x1 != x2 and y1 != y2:\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 3:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 4:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n\n# Example usage:\nn = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\nprint(calculate_area(n, vertices))"}
{"solution": "def minimal_wooden_bars(n, a, b):\n    # Calculate the total length needed for two doors\n    total_length_needed = 4 * a + 2 * b\n    \n    # Calculate the minimal number of bars needed\n    minimal_bars = (total_length_needed + n - 1) // n\n    \n    return minimal_bars\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\n\n# Calculate and print the result\nprint(minimal_wooden_bars(n, a, b))"}
{"solution": "def can_sort_array(n, a, swaps):\n    # Find the positions where swaps are allowed\n    swap_positions = [i for i in range(n - 1) if swaps[i] == '1']\n    \n    # Check if there's a continuous sequence of swaps from 1 to n-1\n    continuous_swap = False\n    for i in range(len(swap_positions) - 1):\n        if swap_positions[i] + 1 == swap_positions[i + 1]:\n            continuous_swap = True\n        else:\n            continuous_swap = False\n            break\n    \n    # If there's a continuous sequence of swaps, the array can be sorted\n    if continuous_swap:\n        return \"YES\"\n    \n    # Check if each element is in its correct position or can be moved to its correct position\n    for i in range(n):\n        # If the element is not in its correct position\n        if a[i] != i + 1:\n            # Check if it can be moved to its correct position\n            can_move = False\n            for j in swap_positions:\n                if j >= i and j < a[i] - 1:\n                    can_move = True\n                    break\n            if not can_move:\n                return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nswaps = input()\n\n# Output the result\nprint(can_sort_array(n, a, swaps))"}
{"solution": "def calculate_waiting_time(n, s):\n    # Define the sequence of moves for the flight attendants\n    move_sequence = [2, 1]\n    \n    # Calculate the total number of moves needed to reach row n\n    total_moves = 0\n    current_row = 1\n    while current_row < n:\n        total_moves += move_sequence[(current_row - 1) % 2]\n        current_row += move_sequence[(current_row - 1) % 2]\n    \n    # Calculate the time to serve all passengers up to row n\n    time_to_serve = total_moves * 6  # 6 passengers per row\n    \n    # Calculate the time to move to row n\n    time_to_move = total_moves\n    \n    # Calculate the time to serve passengers in row n\n    seats_right = ['f', 'e', 'd']\n    seats_left = ['c', 'b', 'a']\n    \n    if s in seats_right:\n        time_to_serve_row = seats_right.index(s) + 1\n    else:\n        time_to_serve_row = seats_right.index('d') + 1 + seats_left.index(s) + 1\n    \n    # Total waiting time\n    total_waiting_time = time_to_serve + time_to_move + time_to_serve_row\n    \n    return total_waiting_time\n\n# Read input\nimport sys\ninput = sys.stdin.read().strip()\nn = int(input[:-1])\ns = input[-1]\n\n# Calculate and print the result\nprint(calculate_waiting_time(n, s))"}
{"solution": "def convert_to_base_10(digits, base):\n    value = 0\n    for digit in digits:\n        value = value * base + digit\n    return value\n\ndef compare_numbers(n, b_x, x_digits, m, b_y, y_digits):\n    x_value = convert_to_base_10(x_digits, b_x)\n    y_value = convert_to_base_10(y_digits, b_y)\n    \n    if x_value < y_value:\n        return '<'\n    elif x_value > y_value:\n        return '>'\n    else:\n        return '='\n\n# Read input\nn, b_x = map(int, input().split())\nx_digits = list(map(int, input().split()))\nm, b_y = map(int, input().split())\ny_digits = list(map(int, input().split()))\n\n# Compare and print the result\nprint(compare_numbers(n, b_x, x_digits, m, b_y, y_digits))"}
{"solution": "def bitlandian_game_winner(n, a):\n    if n == 1:\n        return \"BitLGM\" if a[0] != 0 else \"BitAryo\"\n    elif n == 2:\n        # Use a dynamic programming approach to determine the winner for n=2\n        dp = [[False] * 300 for _ in range(300)]\n        for i in range(300):\n            for j in range(300):\n                if not dp[i][j]:\n                    for k in range(1, 300 - i):\n                        dp[i + k][j] = True\n                    for k in range(1, 300 - j):\n                        dp[i][j + k] = True\n                    for k in range(1, 300 - min(i, j)):\n                        dp[i + k][j + k] = True\n        return \"BitLGM\" if dp[a[0]][a[1]] else \"BitAryo\"\n    elif n == 3:\n        # For n=3, the game is a Nim game where each pile is the value of an element in the sequence\n        # The winner is determined by the xor of all elements\n        xor_sum = a[0] ^ a[1] ^ a[2]\n        return \"BitLGM\" if xor_sum != 0 else \"BitAryo\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Determine and print the winner\nprint(bitlandian_game_winner(n, a))"}
{"solution": "from math import gcd\nfrom itertools import accumulate\n\ndef prime_factors(n):\n    factors = {}\n    for i in range(2, int(n**0.5) + 1):\n        while n % i == 0:\n            factors[i] = factors.get(i, 0) + 1\n            n //= i\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef solve(n, k, cards):\n    factors = prime_factors(k)\n    prefix_products = list(accumulate(cards, func=lambda x, y: x * y, initial=1))\n    right = {p: n for p in factors}\n    count = 0\n\n    for i in range(n, 0, -1):\n        for p, exp in factors.items():\n            while right[p] > 0 and gcd(prefix_products[i], k) % (p ** exp) == 0:\n                right[p] -= 1\n                if right[p] == 0:\n                    count += 1\n        if i > 1:\n            for p, exp in factors.items():\n                while right[p] < n and gcd(prefix_products[i - 1], k) % (p ** exp) == 0:\n                    right[p] += 1\n                    if right[p] == n:\n                        count -= 1\n\n    return count\n\n# Read input\nn, k = map(int, input().split())\ncards = list(map(int, input().split()))\n\n# Solve the problem and print the output\nprint(solve(n, k, cards))"}
{"solution": "def can_distribute_balloons(n, k, s):\n    # Create a dictionary to count the occurrences of each color\n    color_count = {}\n    for color in s:\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n    \n    # Check if any color appears more times than the number of friends\n    for count in color_count.values():\n        if count > k:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ns = input()\n\n# Print the result\nprint(can_distribute_balloons(n, k, s))"}
{"solution": "def find_nearest_minimum_distance(n, arr):\n    min_value = min(arr)\n    last_min_index = None\n    min_distance = n\n\n    for i in range(n):\n        if arr[i] == min_value:\n            if last_min_index is not None:\n                min_distance = min(min_distance, i - last_min_index)\n            last_min_index = i\n\n    return min_distance\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Finding and printing the result\nprint(find_nearest_minimum_distance(n, arr))"}
{"solution": "from math import gcd\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef solve(t, w, b):\n    # Calculate the least common multiple of w and b\n    lcm_wb = lcm(w, b)\n    \n    # Calculate the number of ties\n    min_step = min(w, b)\n    ties = (t // lcm_wb) * min_step + min(min_step - 1, t % lcm_wb)\n    \n    # Calculate the probability\n    g = gcd(ties, t)\n    p = ties // g\n    q = t // g\n    \n    return f\"{p}/{q}\"\n\n# Read input\nt, w, b = map(int, input().split())\n\n# Output the result\nprint(solve(t, w, b))"}
{"solution": "def determine_vote_result(x, y, z):\n    # Calculate the minimum and maximum possible upvotes\n    min_upvotes = x\n    max_upvotes = x + z\n    \n    # Calculate the minimum and maximum possible downvotes\n    min_downvotes = y\n    max_downvotes = y + z\n    \n    # Determine the result based on the possible upvotes and downvotes\n    if max_upvotes > min_downvotes and min_upvotes > max_downvotes:\n        return \"+\"\n    elif max_downvotes > min_upvotes and min_downvotes > max_upvotes:\n        return \"-\"\n    elif min_upvotes == max_upvotes and min_downvotes == max_downvotes and min_upvotes == min_downvotes:\n        return \"0\"\n    else:\n        return \"?\"\n\n# Read input\nx, y, z = map(int, input().split())\n\n# Print the result\nprint(determine_vote_result(x, y, z))"}
{"solution": "def min_subsegment_length_to_reach(n, operations, target_x, target_y):\n    # Calculate the prefix sums for horizontal and vertical movements\n    prefix_x = [0] * (n + 1)\n    prefix_y = [0] * (n + 1)\n    \n    for i, op in enumerate(operations):\n        prefix_x[i + 1] = prefix_x[i]\n        prefix_y[i + 1] = prefix_y[i]\n        if op == 'L':\n            prefix_x[i + 1] -= 1\n        elif op == 'R':\n            prefix_x[i + 1] += 1\n        elif op == 'U':\n            prefix_y[i + 1] += 1\n        elif op == 'D':\n            prefix_y[i + 1] -= 1\n    \n    # Function to check if it's possible to reach (target_x, target_y) by changing a subsegment\n    def can_reach(length):\n        for start in range(n - length + 1):\n            end = start + length\n            current_x = prefix_x[start] + (prefix_x[n] - prefix_x[end])\n            current_y = prefix_y[start] + (prefix_y[n] - prefix_y[end])\n            if abs(target_x - current_x) + abs(target_y - current_y) <= length:\n                return True\n        return False\n    \n    # Binary search to find the minimum length of the subsegment to change\n    left, right = 0, n\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if can_reach(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\n# Read input\nn = int(input())\noperations = input().strip()\nx, y = map(int, input().split())\n\n# Calculate and print the result\nprint(min_subsegment_length_to_reach(n, operations, x, y))"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    \n    results = []\n    \n    for _ in range(T):\n        n = int(data[index])\n        x = int(data[index + 1])\n        s = data[index + 2]\n        index += 3\n        \n        balance_s = s.count('0') - s.count('1')\n        prefix_balances = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix_balances[i + 1] = prefix_balances[i] + (1 if s[i] == '0' else -1)\n        \n        if balance_s == 0:\n            if x in prefix_balances:\n                results.append(-1)\n            else:\n                results.append(0)\n        else:\n            count = 0\n            for b in prefix_balances:\n                if (x - b) % balance_s == 0 and (x - b) // balance_s >= 0:\n                    count += 1\n            results.append(count)\n    \n    for result in results:\n        print(result)"}
{"solution": "def min_digits_to_delete(n, k):\n    # Convert the number to a string for easier manipulation\n    n_str = str(n)\n    \n    # Initialize the count of digits to delete\n    digits_to_delete = 0\n    \n    # Start from the end of the string and move backwards\n    for i in range(len(n_str) - 1, -1, -1):\n        # If we have found enough zeros to make the number divisible by 10^k, break\n        if k == 0:\n            break\n        \n        # If the current digit is '0', decrement k\n        if n_str[i] == '0':\n            k -= 1\n        else:\n            # If the current digit is not '0', increment the count of digits to delete\n            digits_to_delete += 1\n    \n    # If k is not zero, it means we didn't find enough zeros, so we need to delete all digits except the last one\n    if k != 0:\n        return len(n_str) - 1\n    \n    return digits_to_delete\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the result\nprint(min_digits_to_delete(n, k))"}
{"solution": "def calculate_question_counts(n, m, k, x, y):\n    # Calculate the number of complete cycles of asking all pupils\n    full_cycles = k // (n * m)\n    # Calculate the remaining questions after the full cycles\n    remaining_questions = k % (n * m)\n\n    # Initialize the counts for maximum, minimum, and Sergei's questions\n    max_questions = full_cycles\n    min_questions = full_cycles\n    sergei_questions = full_cycles\n\n    # If there's more than one row, adjust for the zigzag pattern\n    if n > 1:\n        max_questions = (full_cycles * 2) + (1 if remaining_questions > (n * m) // 2 else 0)\n        min_questions = full_cycles // 2\n        # Sergei's row is in the first half of the zigzag pattern\n        if x <= n // 2:\n            sergei_questions = full_cycles\n        else:\n            sergei_questions = full_cycles * 2\n\n    # Adjust counts based on the remaining questions\n    for i in range(1, remaining_questions + 1):\n        row = (i - 1) // m + 1\n        col = (i - 1) % m + 1\n        if n > 1:\n            row = min(row, n - row + 1)\n        if row == x and col == y:\n            sergei_questions += 1\n        if n > 1 and row == 1:\n            max_questions += 1\n\n    return max_questions, min_questions, sergei_questions\n\n# Read input\nn, m, k, x, y = map(int, input().split())\n\n# Calculate and print the results\nmax_questions, min_questions, sergei_questions = calculate_question_counts(n, m, k, x, y)\nprint(max_questions, min_questions, sergei_questions)"}
{"solution": "from collections import Counter\n\ndef calculate_beauty(ribbon, n):\n    counter = Counter(ribbon)\n    most_common_count = counter.most_common(1)[0][1]\n    # If n is enough to change all other characters to the most common one,\n    # we need to check if it's possible to exceed the length of the ribbon.\n    if most_common_count + n > len(ribbon):\n        # If n is exactly 1 less than the length of the ribbon, we can reach the length.\n        if n == len(ribbon) and most_common_count == len(ribbon):\n            return len(ribbon) - 1\n        # Otherwise, we can't exceed the length of the ribbon.\n        return min(most_common_count + n, len(ribbon))\n    else:\n        return most_common_count + n\n\ndef determine_winner(n, ribbons):\n    beauties = [calculate_beauty(ribbon, n) for ribbon in ribbons]\n    max_beauty = max(beauties)\n    winners = [i for i, beauty in enumerate(beauties) if beauty == max_beauty]\n    \n    if len(winners) > 1:\n        return \"Draw\"\n    else:\n        return [\"Kuro\", \"Shiro\", \"Katie\"][winners[0]]\n\n# Read input\nn = int(input())\nribbons = [input().strip() for _ in range(3)]\n\n# Determine the winner\nwinner = determine_winner(n, ribbons)\nprint(winner)"}
{"solution": "def calculate_days_to_finish_book(c, v_0, v_1, a, l):\n    days = 0\n    total_read = 0\n    current_speed = v_0\n    \n    while total_read < c:\n        if days > 0:\n            total_read -= l\n        total_read += min(current_speed, v_1)\n        current_speed += a\n        days += 1\n    \n    return days\n\n# Example usage:\n# c, v_0, v_1, a, l = map(int, input().split())\n# print(calculate_days_to_finish_book(c, v_0, v_1, a, l))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_prime_sum(n):\n    primes = []\n    for i in range(2, n + 1):\n        if is_prime(i):\n            primes.append(i)\n            if sum(primes) == n:\n                return primes\n            elif sum(primes) > n:\n                primes.pop()\n            if len(primes) == 3:\n                break\n    return primes\n\ndef main():\n    n = int(input().strip())\n    if is_prime(n):\n        print(1)\n        print(n)\n    else:\n        primes = find_prime_sum(n)\n        while len(primes) < 3 and sum(primes) != n:\n            for p in primes:\n                for i in range(2, n - p + 1):\n                    if is_prime(i) and sum(primes) - p + i == n:\n                        primes.remove(p)\n                        primes.append(i)\n                        break\n                if sum(primes) == n:\n                    break\n        print(len(primes))\n        print(' '.join(map(str, primes)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_wipe_out_all_walls(n, m, grid):\n    row_walls = [0] * n\n    col_walls = [0] * m\n    total_walls = 0\n\n    # Count walls in each row and column\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*':\n                row_walls[i] += 1\n                col_walls[j] += 1\n                total_walls += 1\n\n    # Check each cell to see if it can wipe out all walls\n    for i in range(n):\n        for j in range(m):\n            walls_cleared = row_walls[i] + col_walls[j]\n            if grid[i][j] == '*':  # Subtract overlap if cell (i, j) has a wall\n                walls_cleared -= 1\n            if walls_cleared == total_walls:\n                return \"YES\", i + 1, j + 1  # Return 1-indexed coordinates\n\n    return \"NO\", None, None\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Solve the problem\nresult, x, y = can_wipe_out_all_walls(n, m, grid)\n\n# Print the output\nprint(result)\nif result == \"YES\":\n    print(x, y)"}
{"solution": "def minimal_cost_to_satisfy_delegations(n, m, a, b):\n    # Calculate the remainder when n is divided by m\n    remainder = n % m\n    \n    # If the remainder is 0, no action is needed\n    if remainder == 0:\n        return 0\n    \n    # Calculate the cost to build enough boxes to make n divisible by m\n    build_cost = (m - remainder) * a\n    \n    # Calculate the cost to demolish enough boxes to make n divisible by m\n    demolish_cost = remainder * b\n    \n    # Return the minimum of the two costs\n    return min(build_cost, demolish_cost)\n\n# Read input from standard input\nn, m, a, b = map(int, input().split())\n\n# Output the result\nprint(minimal_cost_to_satisfy_delegations(n, m, a, b))"}
{"solution": "def max_odd_sum_subsequence(n, sequence):\n    # Separate positive and negative numbers, and odd and even numbers\n    pos_odd, neg_odd, pos_even, neg_even = [], [], [], []\n    for num in sequence:\n        if num > 0:\n            if num % 2 == 0:\n                pos_even.append(num)\n            else:\n                pos_odd.append(num)\n        else:\n            if num % 2 == 0:\n                neg_even.append(num)\n            else:\n                neg_odd.append(num)\n    \n    # Sort the lists for efficient selection\n    pos_odd.sort(reverse=True)\n    neg_odd.sort()\n    pos_even.sort(reverse=True)\n    neg_even.sort()\n    \n    # Start with the maximum sum of positive numbers\n    max_sum = sum(pos_even) + sum(pos_odd)\n    \n    # If the sum is odd, it's already the maximum odd sum\n    if max_sum % 2 != 0:\n        return max_sum\n    \n    # Otherwise, we need to make the sum odd\n    # We can either remove the smallest positive odd number or add the largest negative odd number\n    remove_pos_odd = float('inf') if not pos_odd else pos_odd[-1]\n    add_neg_odd = float('-inf') if not neg_odd else neg_odd[0]\n    \n    # Choose the option that maximizes the sum\n    max_sum -= min(remove_pos_odd, -add_neg_odd)\n    \n    return max_sum\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Print the result\nprint(max_odd_sum_subsequence(n, sequence))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_playlists(n, T, songs):\n    dp = [[[0 for _ in range(4)] for _ in range(T+1)] for _ in range(1 << n)]\n    for i in range(n):\n        if songs[i][0] <= T:\n            dp[1 << i][songs[i][0]][songs[i][1]] = 1\n    \n    for mask in range(1 << n):\n        for i in range(n):\n            if mask & (1 << i):\n                continue\n            for t in range(T + 1):\n                for g in range(1, 4):\n                    if t + songs[i][0] <= T and g != songs[i][1]:\n                        dp[mask | (1 << i)][t + songs[i][0]][songs[i][1]] += dp[mask][t][g]\n                        dp[mask | (1 << i)][t + songs[i][0]][songs[i][1]] %= MOD\n    \n    result = 0\n    for mask in range(1 << n):\n        for g in range(1, 4):\n            result += dp[mask][T][g]\n            result %= MOD\n    \n    return result\n\n# Read input\nn, T = map(int, input().split())\nsongs = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(count_playlists(n, T, songs))"}
{"solution": "MOD = 10**9 + 7\n\ndef modinv(a, m):\n    return pow(a, m - 2, m)\n\ndef expected_length(m):\n    # Calculate the expected length of the array a\n    # The expected length can be represented as a sum of geometric series\n    # E = 1 + (m-1)/m + ((m-1)/m)^2 + ...\n    # This is a geometric series with the first term 1 and common ratio (m-1)/m\n    # The sum of infinite geometric series is a / (1 - r)\n    # Here, a = 1 and r = (m-1)/m\n    r = (m - 1) * modinv(m, MOD) % MOD\n    E = modinv(1 - r, MOD)\n    return E\n\n# Read input\nm = int(input())\n\n# Calculate and print the result\nprint(expected_length(m))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_good_pairs(l, r, x, y):\n    if y % x != 0:\n        return 0\n    \n    count = 0\n    for a in range(l, r + 1):\n        if a % x == 0:\n            b = y // a\n            if b >= l and b <= r and gcd(a, b) == x and y == a * b:\n                count += 1\n    return count\n\n# Read input\nl, r, x, y = map(int, input().split())\n\n# Calculate and print the result\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef find_smallest_k(a, b):\n    if a == b:\n        return 0\n    if a > b:\n        a, b = b, a\n    diff = b - a\n    min_lcm = float('inf')\n    best_k = 0\n    for i in range(1, int(diff**0.5) + 1):\n        if diff % i == 0:\n            k = (i - a % i) % i\n            lcm = (a + k) * (b + k) // gcd(a + k, b + k)\n            if lcm < min_lcm:\n                min_lcm = lcm\n                best_k = k\n            k = (diff // i - a % (diff // i)) % (diff // i)\n            lcm = (a + k) * (b + k) // gcd(a + k, b + k)\n            if lcm < min_lcm:\n                min_lcm = lcm\n                best_k = k\n    return best_k\n\n# Read input\na, b = map(int, input().split())\n\n# Find and print the smallest k\nprint(find_smallest_k(a, b))"}
{"solution": "def minimal_additional_marks(n, k, marks):\n    current_sum = sum(marks)\n    target_sum = k * (n + 1) - current_sum\n    if target_sum <= 0:\n        return 0\n    additional_marks = 0\n    while (current_sum + additional_marks * k) / (n + additional_marks) < k - 0.5:\n        additional_marks += 1\n    return additional_marks\n\n# Read input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(minimal_additional_marks(n, k, marks))"}
{"solution": "def find_divisor(n, arr):\n    for d in range(-1000, 1001):\n        if d == 0:\n            continue\n        positive_count = sum(1 for a in arr if a / d > 0)\n        if positive_count >= (n + 1) // 2:\n            return d\n    return 0\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Find and print the result\nprint(find_divisor(n, arr))"}
{"solution": "def max_nines_pairs(n):\n    # Function to calculate the number of pairs with sums ending in the maximum number of nines\n    def count_pairs(target):\n        # Count pairs that sum up to 'target'\n        return (target // 10) * 10 - max(0, target - n - 1)\n    \n    # Initialize the maximum number of nines and the count of such pairs\n    max_nines = 0\n    count = 0\n    \n    # Check for each possible number of nines from 1 to 9\n    for i in range(1, 10):\n        target = 10**i - 1  # The target sum that ends with 'i' nines\n        if target > 2 * n - 1:  # If target is beyond the possible sum of two shovels\n            break\n        # Calculate the number of pairs for the current target\n        current_count = count_pairs(target) + count_pairs(target + 1) - (n if target == 10**i - 1 else 0)\n        # Update the maximum number of nines and the count of pairs if a new maximum is found\n        if current_count > 0:\n            max_nines = i\n            count = current_count\n    \n    return count\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(max_nines_pairs(n))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef min_minutes_to_equalize(a1, b1, a2, b2):\n    # Calculate the initial number of squares in each bar\n    squares1 = a1 * b1\n    squares2 = a2 * b2\n    \n    # If they already have the same number of squares, no minutes are needed\n    if squares1 == squares2:\n        return 0, a1, b1, a2, b2\n    \n    # Find the least common multiple of the two numbers of squares\n    common_squares = lcm(squares1, squares2)\n    \n    # Calculate the number of minutes needed to reach the common number of squares\n    minutes1 = 0\n    while common_squares % (squares1 * 2) == 0:\n        squares1 *= 2\n        minutes1 += 1\n    while common_squares % (squares1 * 3) == 0:\n        squares1 *= 3\n        minutes1 += 1\n    \n    minutes2 = 0\n    while common_squares % (squares2 * 2) == 0:\n        squares2 *= 2\n        minutes2 += 1\n    while common_squares % (squares2 * 3) == 0:\n        squares2 *= 3\n        minutes2 += 1\n    \n    # If we can't reach the common number of squares, return -1\n    if squares1 != common_squares or squares2 != common_squares:\n        return -1, None, None, None, None\n    \n    # Calculate the final sizes of the bars\n    final_a1, final_b1 = a1, b1\n    for _ in range(minutes1):\n        if final_a1 % 2 == 0:\n            final_a1 //= 2\n        elif final_b1 % 2 == 0:\n            final_b1 //= 2\n        elif final_a1 % 3 == 0:\n            final_a1 //= 3\n            final_a1 *= 2\n        else:\n            final_b1 //= 3\n            final_b1 *= 2\n    \n    final_a2, final_b2 = a2, b2\n    for _ in range(minutes2):\n        if final_a2 % 2 == 0:\n            final_a2 //= 2\n        elif final_b2 % 2 == 0:\n            final_b2 //= 2\n        elif final_a2 % 3 == 0:\n            final_a2 //= 3\n            final_a2 *= 2\n        else:\n            final_b2 //= 3\n            final_b2 *= 2\n    \n    return minutes1 + minutes2, final_a1, final_b1, final_a2, final_b2\n\n# Read input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\n# Calculate and print the result\nminutes, final_a1, final_b1, final_a2, final_b2 = min_minutes_to_equalize(a1, b1, a2, b2)\nif minutes == -1:\n    print(minutes)\nelse:\n    print(minutes)\n    print(final_a1, final_b1)\n    print(final_a2, final_b2)"}
{"solution": "def determine_winner(x_p, y_p, x_v, y_v):\n    # Polycarp can always move diagonally towards (0, 0) if he is on the diagonal\n    if x_p + y_p <= max(x_v, y_v):\n        return \"Polycarp\"\n    # If Vasiliy is closer to the diagonal than Polycarp, he can mirror Polycarp's moves\n    elif x_p >= x_v and y_p >= y_v:\n        return \"Vasiliy\"\n    # Otherwise, Polycarp can move straight towards (0, 0) and win\n    else:\n        return \"Polycarp\"\n\n# Read input\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Determine and print the winner\nprint(determine_winner(x_p, y_p, x_v, y_v))"}
{"solution": "def calculate_columns(m, d):\n    # Days in each month\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    # Calculate the number of days in the given month\n    days = days_in_month[m - 1]\n    \n    # Calculate the number of full weeks and the remaining days\n    full_weeks = (days - (8 - d)) // 7\n    remaining_days = (days - (8 - d)) % 7\n    \n    # Add an extra column if there are remaining days\n    extra_column = 1 if remaining_days > 0 else 0\n    \n    # Total columns is the sum of full weeks, the initial week, and any extra column\n    total_columns = full_weeks + 1 + extra_column\n    \n    return total_columns\n\n# Read input\nm, d = map(int, input().split())\n\n# Calculate and print the number of columns\nprint(calculate_columns(m, d))"}
{"solution": "def count_years_with_one_zero(a, b):\n    def has_exactly_one_zero(n):\n        binary_str = bin(n)[2:]\n        return binary_str.count('0') == 1\n    \n    count = 0\n    for year in range(a, b + 1):\n        if has_exactly_one_zero(year):\n            count += 1\n    return count\n\n# Read input\na, b = map(int, input().split())\n\n# Output the result\nprint(count_years_with_one_zero(a, b))"}
{"solution": "def minimal_layers(N):\n    return (N * (N + 1)) // 2\n\n# Assuming the input is provided through standard input (stdin)\nN = int(input().strip())\nprint(minimal_layers(N))"}
{"solution": "from math import factorial\nfrom itertools import combinations\n\ndef count_ways(n, k, S, cubes):\n    ways = 0\n    for r in range(1, n + 1):  # Choose r cubes out of n\n        for chosen_cubes in combinations(range(n), r):\n            for marks in range(k + 1):  # Use up to k exclamation marks\n                for marked_cubes in combinations(chosen_cubes, marks):\n                    current_sum = sum(factorial(cubes[i]) if i in marked_cubes else cubes[i] for i in chosen_cubes)\n                    if current_sum == S:\n                        ways += 1\n    return ways\n\n# Read input\nn, k, S = map(int, input().split())\ncubes = list(map(int, input().split()))\n\n# Calculate and print the number of ways\nprint(count_ways(n, k, S, cubes))"}
{"solution": "def can_transform_array(n, k, a):\n    max_power = 0\n    while k ** max_power <= max(a):\n        max_power += 1\n    \n    for power in range(max_power, -1, -1):\n        remainder = 0\n        for i in range(n):\n            if a[i] >= k ** power:\n                a[i] -= k ** power\n                remainder += 1\n            if remainder > 1:\n                return \"NO\"\n    \n    return \"YES\" if all(x == 0 for x in a) else \"NO\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        n = int(data[index])\n        k = int(data[index + 1])\n        a = list(map(int, data[index + 2:index + 2 + n]))\n        index += 2 + n\n        results.append(can_transform_array(n, k, a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def number_of_divisors(n):\n    divisors = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors += 1\n            if i != n // i:\n                divisors += 1\n    return divisors\n\ndef calculate_sum(a, b, c):\n    MOD = 1073741824  # 2^30\n    total_sum = 0\n    d_cache = {}\n\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                product = i * j * k\n                if product not in d_cache:\n                    d_cache[product] = number_of_divisors(product)\n                total_sum += d_cache[product]\n                total_sum %= MOD\n\n    return total_sum\n\n# Read input\na, b, c = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_sum(a, b, c))"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    neighbors = []\n    idx = state.index('X')\n    if idx == 0:\n        neighbors.append(swap(state, 0, 1))\n        neighbors.append(swap(state, 0, 2))\n    elif idx == 1:\n        neighbors.append(swap(state, 1, 0))\n        neighbors.append(swap(state, 1, 3))\n    elif idx == 2:\n        neighbors.append(swap(state, 2, 0))\n        neighbors.append(swap(state, 2, 3))\n    elif idx == 3:\n        neighbors.append(swap(state, 3, 1))\n        neighbors.append(swap(state, 3, 2))\n    return neighbors\n\ndef swap(state, i, j):\n    state = list(state)\n    state[i], state[j] = state[j], state[i]\n    return ''.join(state)\n\ndef bfs(start):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        current = queue.popleft()\n        for neighbor in get_neighbors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return visited\n\ndef can_be_same_configuration(bessie, elsie):\n    bessie_start = ''.join(bessie)\n    elsie_start = ''.join(elsie)\n    \n    bessie_reachable = bfs(bessie_start)\n    elsie_reachable = bfs(elsie_start)\n    \n    return not bessie_reachable.isdisjoint(elsie_reachable)\n\n# Input reading\nbessie = [input().strip() for _ in range(2)]\nelsie = [input().strip() for _ in range(2)]\n\nif can_be_same_configuration(bessie, elsie):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_decimal_from_base_n(n, k):\n    # Convert the number k from base n to decimal\n    decimal_value = 0\n    base = 1\n    for digit in reversed(k):\n        decimal_value += int(digit) * base\n        base *= n\n    return decimal_value\n\n# Read input\nn = int(input().strip())\nk = input().strip()\n\n# Output the result\nprint(min_decimal_from_base_n(n, k))"}
{"solution": "def is_unimodal(n, arr):\n    i = 0\n    # Check for strictly increasing part\n    while i + 1 < n and arr[i] < arr[i + 1]:\n        i += 1\n    # Check for constant part\n    while i + 1 < n and arr[i] == arr[i + 1]:\n        i += 1\n    # Check for strictly decreasing part\n    while i + 1 < n and arr[i] > arr[i + 1]:\n        i += 1\n    return \"YES\" if i == n - 1 else \"NO\"\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output result\nprint(is_unimodal(n, arr))"}
{"solution": "def max_value_in_at_least_k_paths(n, k):\n    # Initialize the maximum value to be returned\n    max_value = 1\n    \n    # We will use a dictionary to count occurrences of each value in paths\n    occurrences = {}\n    \n    # Function to generate path for a given value and update occurrences\n    def generate_path(x):\n        while x > 1:\n            if x in occurrences:\n                occurrences[x] += 1\n            else:\n                occurrences[x] = 1\n            if x % 2 == 0:\n                x //= 2\n            else:\n                x -= 1\n        # Count occurrence of 1 as well\n        if 1 in occurrences:\n            occurrences[1] += 1\n        else:\n            occurrences[1] = 1\n    \n    # Generate paths for all values from 1 to n\n    for i in range(1, n + 1):\n        generate_path(i)\n    \n    # Sort the occurrences by value in descending order\n    sorted_occurrences = sorted(occurrences.items(), key=lambda item: item[0], reverse=True)\n    \n    # Find the maximum value that occurs in at least k paths\n    for value, count in sorted_occurrences:\n        if count >= k:\n            max_value = value\n            break\n    \n    return max_value\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the output\nprint(max_value_in_at_least_k_paths(n, k))"}
{"solution": "def billiard_ball_pocket(n, m, x, y, vx, vy):\n    # If the ball is moving vertically and is already on a vertical edge\n    if vx == 0:\n        if x in [0, n]:\n            return f\"{x} {0 if y == 0 and vy < 0 else m}\"\n        else:\n            return -1\n    \n    # If the ball is moving horizontally and is already on a horizontal edge\n    if vy == 0:\n        if y in [0, m]:\n            return f\"{0 if x == 0 and vx < 0 else n} {y}\"\n        else:\n            return -1\n    \n    # If the ball is moving at a 45-degree angle\n    if abs(vx) == abs(vy):\n        # Calculate the number of bounces needed to reach a pocket\n        bounces_x = (n - x) // vx if vx > 0 else x // -vx\n        bounces_y = (m - y) // vy if vy > 0 else y // -vy\n        \n        # If the number of bounces to reach a pocket is the same for both axes\n        if bounces_x == bounces_y:\n            return f\"{n if vx > 0 else 0} {m if vy > 0 else 0}\"\n        else:\n            return -1\n    \n    return -1\n\n# Read input\nn, m, x, y, vx, vy = map(int, input().split())\n\n# Get the result and print it\nresult = billiard_ball_pocket(n, m, x, y, vx, vy)\nprint(result)"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    def fits(w1, h1, w2, h2, W, H):\n        return (w1 + w2 <= W and max(h1, h2) <= H) or (h1 + h2 <= H and max(w1, w2) <= W)\n    \n    if (fits(a2, b2, a3, b3, a1, b1) or fits(b2, a2, a3, b3, a1, b1) or\n        fits(a2, b2, b3, a3, a1, b1) or fits(b2, a2, b3, a3, a1, b1) or\n        fits(a3, b3, a2, b2, a1, b1) or fits(b3, a3, a2, b2, a1, b1) or\n        fits(a3, b3, b2, a2, a1, b1) or fits(b3, a3, b2, a2, a1, b1)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input from stdin\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\n# Output result\nprint(can_place_paintings(a1, b1, a2, b2, a3, b3))"}
{"solution": "def geometric_progression_terms(b_1, q, l, m, bad_integers):\n    if abs(b_1) > l:\n        return 0\n    if b_1 == 0:\n        return \"inf\" if 0 not in bad_integers else 0\n    if q == 0:\n        if 0 in bad_integers:\n            return 1 if b_1 not in bad_integers else 0\n        else:\n            return \"inf\"\n    if q == 1:\n        return \"inf\" if b_1 not in bad_integers else 0\n    if q == -1:\n        if b_1 in bad_integers and -b_1 in bad_integers:\n            return 0\n        else:\n            return \"inf\"\n\n    written_terms = 0\n    current_term = b_1\n    while abs(current_term) <= l:\n        if current_term not in bad_integers:\n            written_terms += 1\n        current_term *= q\n\n    return written_terms\n\n# Read input\nb_1, q, l, m = map(int, input().split())\nbad_integers = set(map(int, input().split()))\n\n# Calculate and print the result\nresult = geometric_progression_terms(b_1, q, l, m, bad_integers)\nprint(result if result != \"inf\" else \"inf\")"}
{"solution": "def find_smallest_frame(n, m, screen):\n    white_pixels = []\n    for i in range(n):\n        for j in range(m):\n            if screen[i][j] == 'w':\n                white_pixels.append((i, j))\n    \n    if not white_pixels:\n        return -1\n    \n    min_x = min(white_pixels, key=lambda x: x[0])[0]\n    max_x = max(white_pixels, key=lambda x: x[0])[0]\n    min_y = min(white_pixels, key=lambda x: x[1])[1]\n    max_y = max(white_pixels, key=lambda x: x[1])[1]\n    \n    frame_size = max(max_x - min_x + 1, max_y - min_y + 1)\n    \n    if frame_size > n or frame_size > m:\n        return -1\n    \n    for i in range(min_x, min_x + frame_size):\n        for j in range(min_y, min_y + frame_size):\n            if screen[i][j] != 'w' and (i == min_x or i == min_x + frame_size - 1 or j == min_y or j == min_y + frame_size - 1):\n                screen[i] = screen[i][:j] + '+' + screen[i][j+1:]\n    \n    return screen\n\ndef main():\n    n, m = map(int, input().split())\n    screen = [input() for _ in range(n)]\n    \n    result = find_smallest_frame(n, m, screen)\n    \n    if result == -1:\n        print(result)\n    else:\n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_spend_exactly(n, a, b):\n    for x in range(n // a + 1):\n        if (n - x * a) % b == 0:\n            y = (n - x * a) // b\n            return \"YES\", x, y\n    return \"NO\", 0, 0\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\n\n# Process and output the result\nresult, x, y = can_spend_exactly(n, a, b)\nprint(result)\nif result == \"YES\":\n    print(x, y)"}
{"solution": "def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\n# Assuming the input is provided correctly as per the problem statement\ns = int(input().strip())\nprint(number_to_words(s))"}
{"solution": "def max_elements_to_erase(n, arr):\n    # The maximum number of consecutive elements that can be erased is determined by\n    # the smallest gap between consecutive elements in the array.\n    max_erase = 0\n    for i in range(1, n):\n        # Calculate the gap between the current element and the previous one.\n        gap = arr[i] - arr[i - 1] - 1\n        # Update the maximum number of elements that can be erased if the current gap is larger.\n        max_erase = max(max_erase, gap)\n    return max_erase\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output the result\nprint(max_elements_to_erase(n, arr))"}
{"solution": "def find_equator_day(n, a):\n    total_problems = sum(a)\n    half_problems = (total_problems + 1) // 2\n    \n    cumulative_problems = 0\n    for i in range(n):\n        cumulative_problems += a[i]\n        if cumulative_problems >= half_problems:\n            return i + 1\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find and print the equator day\nprint(find_equator_day(n, a))"}
{"solution": "from collections import deque\n\ndef get_moves(piece, x, y, N):\n    if piece == 'knight':\n        moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    elif piece == 'bishop':\n        moves = [(i, i) for i in range(-N+1, N) if i != 0] + [(i, -i) for i in range(-N+1, N) if i != 0]\n    elif piece == 'rook':\n        moves = [(i, 0) for i in range(-N+1, N) if i != 0] + [(0, i) for i in range(-N+1, N) if i != 0]\n    else:\n        return []\n    \n    valid_moves = [(x+dx, y+dy) for dx, dy in moves if 0 < x+dx <= N and 0 < y+dy <= N]\n    return valid_moves\n\ndef bfs(start, end, N, board):\n    queue = deque([(start, 'knight', 0, 0)])  # (position, piece, steps, replacements)\n    visited = set()\n    \n    while queue:\n        (x, y), piece, steps, replacements = queue.popleft()\n        \n        if (x, y) == end:\n            return steps, replacements\n        \n        if ((x, y), piece) in visited:\n            continue\n        visited.add(((x, y), piece))\n        \n        # Move with the current piece\n        for (nx, ny) in get_moves(piece, x, y, N):\n            if 1 <= nx <= N and 1 <= ny <= N:\n                queue.append(((nx, ny), piece, steps + 1, replacements))\n        \n        # Replace the piece\n        for new_piece in ['knight', 'bishop', 'rook']:\n            if new_piece != piece:\n                queue.append(((x, y), new_piece, steps + 1, replacements + 1))\n    \n    return float('inf'), float('inf')\n\ndef solve(N, board):\n    positions = {board[i][j]: (i+1, j+1) for i in range(N) for j in range(N)}\n    total_steps, total_replacements = 0, 0\n    \n    for i in range(1, N*N):\n        steps, replacements = bfs(positions[i], positions[i+1], N, board)\n        total_steps += steps\n        total_replacements += replacements\n    \n    return total_steps, total_replacements\n\n# Read input\nN = int(input())\nboard = [list(map(int, input().split())) for _ in range(N)]\n\n# Solve the problem\nsteps, replacements = solve(N, board)\nprint(steps, replacements)"}
{"solution": "def calculate_time(n, m, k, a, b):\n    # Calculate the entrance, floor, and room within the floor for both Edward and Natasha\n    def get_position(apartment_number):\n        entrance = (apartment_number - 1) // (m * k)\n        floor = ((apartment_number - 1) % (m * k)) // k\n        room = (apartment_number - 1) % k\n        return entrance, floor, room\n\n    edward_entrance, edward_floor, _ = get_position(a)\n    natasha_entrance, natasha_floor, _ = get_position(b)\n\n    # Calculate the time to move between entrances\n    def entrance_time(from_entrance, to_entrance):\n        return min(abs(from_entrance - to_entrance), n - abs(from_entrance - to_entrance)) * 15\n\n    # Calculate the time to move between floors using stairs or elevator\n    def floor_time(from_floor, to_floor, use_elevator):\n        if use_elevator:\n            return 10 + abs(from_floor - to_floor)  # 10 seconds waiting time + 1 second per floor\n        else:\n            return abs(from_floor - to_floor) * 5  # 5 seconds per floor\n\n    # Calculate the minimum time for Edward to reach Natasha's apartment\n    min_time = float('inf')\n    for use_elevator in [True, False]:  # Check both using elevator and stairs\n        for direction in [1, -1]:  # Check both directions around the house\n            time = 0\n            # Move to the first floor if not already there\n            if edward_floor != 0:\n                time += floor_time(edward_floor, 0, use_elevator)\n            # Move to Natasha's entrance\n            time += entrance_time(edward_entrance, natasha_entrance)\n            # Move to Natasha's floor\n            time += floor_time(0, natasha_floor, use_elevator)\n            min_time = min(min_time, time)\n\n    return min_time\n\n# Read input\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_time(n, m, k, a, b))"}
{"solution": "def can_form_divisible_by_64(s):\n    # A number is divisible by 64 if its binary representation ends with '0000000'\n    # We need to check if we can remove some digits to make the string end with '0000000'\n    if len(s) < 7:  # '0000000' is 7 digits long\n        return \"no\"\n    \n    # Check if there is a substring of length 7 that matches '0000000'\n    for i in range(len(s) - 6):\n        if s[i:i+7] == '0' * 7:\n            return \"yes\"\n    \n    return \"no\"\n\n# Read input\ns = input().strip()\n\n# Output result\nprint(can_form_divisible_by_64(s))"}
{"solution": "def transform_to_alphabet_subsequence(s):\n    # Initialize the target alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    # Initialize a pointer for the alphabet\n    alpha_ptr = 0\n    # Initialize a list to store the transformed string\n    transformed = []\n    \n    for char in s:\n        # If we haven't reached the end of the alphabet and the current character\n        # can be transformed into the current target alphabet character\n        if alpha_ptr < len(alphabet) and char <= alphabet[alpha_ptr]:\n            # Append the target alphabet character to the transformed list\n            transformed.append(alphabet[alpha_ptr])\n            # Move the alphabet pointer to the next character\n            alpha_ptr += 1\n        else:\n            # If the current character cannot help form the alphabet subsequence,\n            # just append it as it is\n            transformed.append(char)\n    \n    # If we have successfully transformed the string to contain the alphabet as a subsequence\n    if alpha_ptr == len(alphabet):\n        return ''.join(transformed)\n    else:\n        return '-1'\n\n# Read input\ns = input().strip()\n# Print the result\nprint(transform_to_alphabet_subsequence(s))"}
{"solution": "from heapq import heappush, heappop\n\ndef calculate_expected_value(n, m, r, k):\n    def count_covered_cells(x, y):\n        return (min(n - r + 1, x + r) - max(1, x)) * (min(m - r + 1, y + r) - max(1, y))\n\n    def get_neighbors(x, y):\n        neighbors = []\n        if x > 1: neighbors.append((x - 1, y))\n        if x < n: neighbors.append((x + 1, y))\n        if y > 1: neighbors.append((x, y - 1))\n        if y < m: neighbors.append((x, y + 1))\n        return neighbors\n\n    visited = set()\n    max_heap = []\n    total_covered = 0\n    possible_positions = (n - r + 1) * (m - r + 1)\n\n    # Start from the center of the pond\n    start_x, start_y = (n + 1) // 2, (m + 1) // 2\n    start_covered = count_covered_cells(start_x, start_y)\n    heappush(max_heap, (-start_covered, start_x, start_y))\n\n    while k > 0 and max_heap:\n        covered, x, y = heappop(max_heap)\n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n        total_covered -= covered\n        k -= 1\n\n        for nx, ny in get_neighbors(x, y):\n            if (nx, ny) not in visited:\n                covered = count_covered_cells(nx, ny)\n                heappush(max_heap, (-covered, nx, ny))\n\n    return total_covered / possible_positions\n\n# Read input\nn, m, r, k = map(int, input().split())\n\n# Calculate and print the result\nprint(f\"{calculate_expected_value(n, m, r, k):.10f}\")"}
{"solution": "def maximize_product(n, a):\n    # If there's only one element and it's 0, we can't do anything to increase the product\n    if n == 1 and a[0] == 0:\n        return a\n    \n    # Count the number of negative elements and check if there's a zero\n    negative_count = 0\n    has_zero = False\n    for num in a:\n        if num < 0:\n            negative_count += 1\n        elif num == 0:\n            has_zero = True\n    \n    # If the number of negative elements is odd and there's no zero, we need to apply the operation to the smallest absolute value\n    if negative_count % 2 == 1 and not has_zero:\n        min_abs_value = min(a, key=abs)\n        min_index = a.index(min_abs_value)\n        a[min_index] = -a[min_index] - 1\n    # If there's a zero or the number of negative elements is even, apply the operation to all negative elements\n    else:\n        for i in range(n):\n            if a[i] < 0:\n                a[i] = -a[i] - 1\n    \n    return a\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the array with the maximal possible product\nresult = maximize_product(n, a)\n\n# Print the result\nprint(' '.join(map(str, result)))"}
{"solution": "def kth_smallest_divisor(n, k):\n    # Initialize counters for divisors\n    divisors_count = 0\n    \n    # Check divisors up to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_count += 1\n            # If we reach the k-th divisor before reaching the square root\n            if divisors_count == k:\n                return i\n    \n    # If n is a perfect square, we've counted the square root twice\n    if (n**0.5).is_integer():\n        last_divisor = int(n**0.5)\n    else:\n        last_divisor = int(n**0.5) + 1\n    \n    # Calculate total number of divisors\n    total_divisors = divisors_count * 2 if n != last_divisor * last_divisor else divisors_count * 2 - 1\n    \n    # If k is greater than the total number of divisors\n    if k > total_divisors:\n        return -1\n    \n    # If the k-th divisor is among the larger divisors\n    if k > divisors_count:\n        return n // (divisors_count - (k - divisors_count))\n    \n    return -1\n\n# Read input\nn, k = map(int, input().split())\n\n# Print output\nprint(kth_smallest_divisor(n, k))"}
{"solution": "def can_form_number(cubes, number):\n    number_str = str(number)\n    for digit in number_str:\n        if not any(digit in cube for cube in cubes):\n            return False\n    return True\n\ndef max_number_to_x(n, cubes):\n    x = 0\n    while can_form_number(cubes, x + 1):\n        x += 1\n    return x\n\n# Read input\nn = int(input())\ncubes = [set(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(max_number_to_x(n, cubes))"}
{"solution": "def k_rounding(n, k):\n    # Calculate the number of trailing zeros by finding the least power of 10 that is divisible by n\n    x = 10 ** k\n    # Find the least common multiple (LCM) of n and 10^k\n    # Since 10^k is always divisible by 2 and 5, we can simplify the LCM calculation\n    # We need to ensure that the result is divisible by n, so we multiply n by the necessary factor\n    factor = x // gcd(n, x)\n    result = n * factor\n    return result\n\ndef gcd(a, b):\n    # Euclidean algorithm to find the greatest common divisor\n    while b:\n        a, b = b, a % b\n    return a\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the k-rounding of n\nprint(k_rounding(n, k))"}
{"solution": "def transform_matrix(n, m, A):\n    operations = []\n    B = [[0] * m for _ in range(n)]\n    \n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                operations.append((i + 1, j + 1))\n                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1\n    \n    for i in range(n):\n        for j in range(m):\n            if A[i][j] != B[i][j]:\n                return -1\n    \n    return operations\n\n# Input reading\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\n# Process the transformation\nresult = transform_matrix(n, m, A)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for x, y in result:\n        print(x, y)"}
{"solution": "def bad_luck_island(r, s, p):\n    # Initialize the DP table\n    dp = [[[0.0 for _ in range(p+1)] for _ in range(s+1)] for _ in range(r+1)]\n    dp[r][s][p] = 1.0  # The probability at the start is 100%\n\n    # Function to calculate the total number of possible meetings\n    def total_meetings(i, j, k):\n        return i * j + j * k + k * i\n\n    # Dynamic programming to calculate probabilities\n    for i in range(r, -1, -1):\n        for j in range(s, -1, -1):\n            for k in range(p, -1, -1):\n                if i == 0 or j == 0 or k == 0:\n                    continue\n                t = total_meetings(i, j, k)\n                # Probability of rock killing scissors\n                dp[i][j-1][k] += dp[i][j][k] * (i * j / t)\n                # Probability of scissors killing paper\n                dp[i][j][k-1] += dp[i][j][k] * (j * k / t)\n                # Probability of paper killing rock\n                dp[i-1][j][k] += dp[i][j][k] * (k * i / t)\n\n    # Calculate the final probabilities\n    prob_r, prob_s, prob_p = 0.0, 0.0, 0.0\n    for i in range(1, r+1):\n        prob_r += dp[i][0][0]\n    for j in range(1, s+1):\n        prob_s += dp[0][j][0]\n    for k in range(1, p+1):\n        prob_p += dp[0][0][k]\n\n    return prob_r, prob_s, prob_p\n\n# Read input\nr, s, p = map(int, input().split())\n\n# Calculate probabilities\nprob_r, prob_s, prob_p = bad_luck_island(r, s, p)\n\n# Print the result\nprint(f\"{prob_r:.12f} {prob_s:.12f} {prob_p:.12f}\")"}
{"solution": "def calculate_overlap_time(l_1, r_1, l_2, r_2, k):\n    # Calculate the overlap between Sonya's and Filya's time intervals\n    overlap_start = max(l_1, l_2)\n    overlap_end = min(r_1, r_2)\n    \n    # If there is no overlap, they cannot spend time together\n    if overlap_start > overlap_end:\n        return 0\n    \n    # Calculate the total overlap time\n    total_overlap = overlap_end - overlap_start + 1\n    \n    # Subtract the minute Sonya prinks if it's within the overlap\n    if overlap_start <= k <= overlap_end:\n        total_overlap -= 1\n    \n    return total_overlap\n\n# Read input from standard input\nl_1, r_1, l_2, r_2, k = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_overlap_time(l_1, r_1, l_2, r_2, k))"}
{"solution": "def calculate_reachable_area(N, M, north_south_lines, east_west_lines):\n    # Initialize the boundaries of the reachable area\n    min_x, max_x, min_y, max_y = float('-inf'), float('inf'), float('-inf'), float('inf')\n\n    # Process north-south lines to update the x boundaries\n    for A_i, B_i, C_i in north_south_lines:\n        if C_i == 0:\n            # If the line passes through the origin, it splits the field\n            if A_i <= 0 <= B_i:\n                return \"INF\"\n            elif B_i < 0:\n                max_x = min(max_x, A_i)\n            else:  # A_i > 0\n                min_x = max(min_x, B_i)\n\n    # Process east-west lines to update the y boundaries\n    for D_j, E_j, F_j in east_west_lines:\n        if D_j == 0:\n            # If the line passes through the origin, it splits the field\n            if E_j <= 0 <= F_j:\n                return \"INF\"\n            elif F_j < 0:\n                max_y = min(max_y, E_j)\n            else:  # E_j > 0\n                min_y = max(min_y, F_j)\n\n    # If any boundary is still infinite, the area is infinite\n    if min_x == float('-inf') or max_x == float('inf') or min_y == float('-inf') or max_y == float('inf'):\n        return \"INF\"\n\n    # Calculate the area of the reachable region\n    return (max_x - min_x) * (max_y - min_y)\n\n# Read input\nN, M = map(int, input().split())\nnorth_south_lines = [tuple(map(int, input().split())) for _ in range(N)]\neast_west_lines = [tuple(map(int, input().split())) for _ in range(M)]\n\n# Calculate and print the result\nprint(calculate_reachable_area(N, M, north_south_lines, east_west_lines))"}
{"solution": "def will_pineapple_bark(t, s, x):\n    if x < t:\n        return \"NO\"\n    if x == t:\n        return \"YES\"\n    if (x - t) % s == 0 or (x - t - 1) % s == 0:\n        return \"YES\"\n    return \"NO\"\n\n# Read input\nt, s, x = map(int, input().split())\n\n# Output result\nprint(will_pineapple_bark(t, s, x))"}
{"solution": "def find_nested_segments(n, segments):\n    # Sort segments by their left endpoint, then by their right endpoint in descending order\n    sorted_segments = sorted(enumerate(segments, start=1), key=lambda x: (x[1][0], -x[1][1]))\n    \n    # Initialize variables to store the maximum right endpoint found so far and the corresponding index\n    max_right = -1\n    max_right_index = -1\n    \n    # Iterate through the sorted segments to find a nested segment\n    for index, (left, right) in sorted_segments:\n        # If the current segment's right endpoint is less than or equal to the max_right,\n        # it means we found a nested segment\n        if right <= max_right:\n            return max_right_index, index\n        # Update max_right and max_right_index if the current segment's right endpoint is greater\n        if right > max_right:\n            max_right = right\n            max_right_index = index\n    \n    # If no nested segments are found, return -1 -1\n    return -1, -1\n\n# Read input\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Find and print the result\ni, j = find_nested_segments(n, segments)\nprint(i, j)"}
{"solution": "def decode_genome(n, s):\n    # Count the number of each nucleotide and '?'\n    counts = {'A': 0, 'C': 0, 'G': 0, 'T': 0, '?': 0}\n    for nucleotide in s:\n        counts[nucleotide] += 1\n    \n    # Calculate the required number of each nucleotide\n    required_count = (n // 4)\n    \n    # Check if it's possible to distribute the nucleotides equally\n    if n % 4 != 0 or any(counts[nucleotide] > required_count for nucleotide in 'ACGT'):\n        return \"===\"\n    \n    # Replace '?' with the missing nucleotides\n    result = list(s)\n    for i in range(n):\n        if result[i] == '?':\n            for nucleotide in 'ACGT':\n                if counts[nucleotide] < required_count:\n                    result[i] = nucleotide\n                    counts[nucleotide] += 1\n                    break\n    \n    return ''.join(result)\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Print output\nprint(decode_genome(n, s))"}
{"solution": "def can_ilya_win(board):\n    # Check horizontal and vertical lines\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                # Try placing 'x' and check if it wins\n                board[i][j] = 'x'\n                if is_winning_move(board, i, j):\n                    return \"YES\"\n                board[i][j] = '.'\n    return \"NO\"\n\ndef is_winning_move(board, row, col):\n    # Check horizontal\n    if board[row].count('x') == 3:\n        return True\n    # Check vertical\n    if [board[i][col] for i in range(4)].count('x') == 3:\n        return True\n    # Check diagonal (top-left to bottom-right)\n    if row == col and [board[i][i] for i in range(4)].count('x') == 3:\n        return True\n    # Check diagonal (top-right to bottom-left)\n    if row + col == 3 and [board[i][3-i] for i in range(4)].count('x') == 3:\n        return True\n    return False\n\n# Read input\nboard = [list(input().strip()) for _ in range(4)]\n\n# Output result\nprint(can_ilya_win(board))"}
{"solution": "def can_balance_array(n, arr):\n    total_sum = sum(arr)\n    if total_sum % 2 != 0:\n        return \"NO\"\n    \n    half_sum = total_sum // 2\n    current_sum = 0\n    for i in range(n):\n        current_sum += arr[i]\n        if current_sum == half_sum:\n            return \"YES\"\n        if current_sum > half_sum:\n            break\n    \n    current_sum = 0\n    for i in range(n-1, -1, -1):\n        current_sum += arr[i]\n        if current_sum == half_sum:\n            return \"YES\"\n        if current_sum > half_sum:\n            break\n    \n    return \"NO\"\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output result\nprint(can_balance_array(n, arr))"}
{"solution": "def can_make_non_increasing(n, k, a, b):\n    # Sort the elements of b in descending order to use them to replace zeros in a\n    b.sort(reverse=True)\n    \n    # Replace zeros in a with elements from b\n    b_index = 0\n    for i in range(n):\n        if a[i] == 0:\n            a[i] = b[b_index]\n            b_index += 1\n    \n    # Check if the resulting sequence is not increasing\n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            return \"Yes\"\n    \n    return \"No\"\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Output the result\nprint(can_make_non_increasing(n, k, a, b))"}
{"solution": "def can_distribute_grapes(x, y, z, a, b, c):\n    # First, try to satisfy Andrew with green grapes\n    if a < x:\n        return \"NO\"\n    a -= x\n\n    # Next, try to satisfy Dmitry with remaining green and purple grapes\n    if a + b < y:\n        return \"NO\"\n    remaining_for_dmitry = y\n    if a > 0:\n        if a >= remaining_for_dmitry:\n            a -= remaining_for_dmitry\n            remaining_for_dmitry = 0\n        else:\n            remaining_for_dmitry -= a\n            a = 0\n    if remaining_for_dmitry > 0:\n        b -= remaining_for_dmitry\n\n    # Finally, try to satisfy Michal with the remaining grapes\n    if a + b + c < z:\n        return \"NO\"\n\n    return \"YES\"\n\n# Read input\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Output result\nprint(can_distribute_grapes(x, y, z, a, b, c))"}
{"solution": "def is_accident_possible(lights):\n    for i in range(4):\n        if lights[i][3] == 1 and (lights[i][0] == 1 or lights[i][1] == 1 or lights[i][2] == 1):\n            return \"YES\"\n        if i < 3 and lights[i][2] == 1 and lights[i + 1][3] == 1:\n            return \"YES\"\n        if i == 2 and lights[i][2] == 1 and lights[0][3] == 1:\n            return \"YES\"\n        if i > 0 and lights[i][0] == 1 and lights[i - 1][3] == 1:\n            return \"YES\"\n        if i == 3 and lights[i][0] == 1 and lights[2][3] == 1:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nlights = []\nfor _ in range(4):\n    lights.append(list(map(int, input().split())))\n\n# Output result\nprint(is_accident_possible(lights))"}
{"solution": "def get_coordinates(digit):\n    keypad = {\n        '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2),\n        '0': (3, 1)\n    }\n    return keypad[digit]\n\ndef get_vectors(number):\n    vectors = []\n    for i in range(len(number) - 1):\n        x1, y1 = get_coordinates(number[i])\n        x2, y2 = get_coordinates(number[i + 1])\n        vectors.append((x2 - x1, y2 - y1))\n    return vectors\n\ndef is_unique_finger_movement(n, number):\n    original_vectors = get_vectors(number)\n    for i in range(10**(n-1), 10**n):\n        candidate = str(i).zfill(n)\n        if candidate != number:\n            if get_vectors(candidate) == original_vectors:\n                return \"NO\"\n    return \"YES\"\n\n# Input reading\nn = int(input())\nnumber = input().strip()\n\n# Output the result\nprint(is_unique_finger_movement(n, number))"}
{"solution": "def maximize_sales(n, f, days):\n    # Calculate the potential additional sales from doubling the products for each day\n    additional_sales = [(min(2 * k, l) - min(k, l), i) for i, (k, l) in enumerate(days)]\n    \n    # Sort by the potential additional sales in descending order\n    additional_sales.sort(reverse=True)\n    \n    # Select the top f days for sell-outs\n    sell_out_days = set(day_index for _, day_index in additional_sales[:f])\n    \n    # Calculate the total number of sold products\n    total_sold = 0\n    for i, (k, l) in enumerate(days):\n        if i in sell_out_days:\n            total_sold += min(2 * k, l)\n        else:\n            total_sold += min(k, l)\n    \n    return total_sold\n\n# Read input\nn, f = map(int, input().split())\ndays = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(maximize_sales(n, f, days))"}
{"solution": "def max_messiness(n, k):\n    # The maximum messiness for any permutation of n cows is the number of inversions in the sorted order,\n    # which is n*(n-1)/2. However, we can only perform k swaps, so we need to calculate the maximum messiness\n    # we can achieve with k swaps.\n    \n    # If k is greater than or equal to n-1, we can achieve the maximum messiness by reversing the array,\n    # which gives us n*(n-1)/2 inversions.\n    if k >= n - 1:\n        return n * (n - 1) // 2\n    \n    # If k is less than n-1, we can achieve the maximum messiness by creating the largest possible inversions\n    # with the available swaps. We can do this by swapping the first k+1 elements in reverse order,\n    # which creates k*(k+1)/2 inversions, plus the remaining (n-k-1)*k inversions from the rest of the array.\n    return k * (k + 1) // 2 + (n - k - 1) * k\n\n# Read input\nn, k = map(int, input().split())\n\n# Output the result\nprint(max_messiness(n, k))"}
{"solution": "def min_coins_to_gift(N, M, K, L):\n    # Check if it's possible to satisfy all conditions\n    if L > N - K:  # Not enough different coins to satisfy the new coins condition\n        return -1\n    if M * (N - K) < L:  # Not enough friends to gift the required number of new coins\n        return -1\n    \n    # Calculate the minimum number of coins each friend needs to gift\n    coins_per_friend = (L + M - 1) // M  # This is equivalent to ceil(L / M)\n    \n    return coins_per_friend\n\n# Read input\nN, M, K, L = map(int, input().split())\n\n# Output the result\nprint(min_coins_to_gift(N, M, K, L))"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    # Find the bounds of the black cells\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # If no black cells are found\n    if min_row == n:\n        return 1\n    \n    # Calculate the side length of the square\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    \n    # Check if the square can fit within the grid\n    if side_length > n or side_length > m:\n        return -1\n    \n    # Count the number of white cells within the square\n    min_paint = float('inf')\n    for i in range(n - side_length + 1):\n        for j in range(m - side_length + 1):\n            paint_count = 0\n            for x in range(i, i + side_length):\n                for y in range(j, j + side_length):\n                    if grid[x][y] == 'W':\n                        paint_count += 1\n            min_paint = min(min_paint, paint_count)\n    \n    return min_paint\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Print output\nprint(min_cells_to_paint(n, m, grid))"}
{"solution": "def can_be_correct(n, x, y):\n    # Calculate the total number of stones in both sequences\n    total_stones_x = sum(x)\n    total_stones_y = sum(y)\n    \n    # If the total number of stones is not the same, it's impossible to transform x into y\n    if total_stones_x != total_stones_y:\n        return \"No\"\n    \n    # If the total number of stones is the same, we need to check if the transformation is possible\n    # Given the problem constraints, the only operation that can change the total number of stones\n    # in a pile is taking a stone away, which would decrease the total. Since we know the total\n    # is the same, we can conclude that the transformation is possible.\n    return \"Yes\"\n\n# Read input\nn = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Output the result\nprint(can_be_correct(n, x, y))"}
{"solution": "def min_angle_difference(n, angles):\n    total_angle = 360\n    min_diff = total_angle\n    current_sum = 0\n    \n    # Two pointers approach to find the minimum difference\n    j = 0\n    for i in range(n):\n        while (current_sum + angles[j]) <= total_angle / 2:\n            current_sum += angles[j]\n            j = (j + 1) % n\n        # Calculate the difference for the current partition\n        diff = abs(total_angle - 2 * current_sum)\n        min_diff = min(min_diff, diff)\n        # Move the left pointer and adjust the current sum\n        current_sum -= angles[i]\n    \n    return min_diff\n\n# Read input\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Output the result\nprint(min_angle_difference(n, angles))"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_pow(base, exponent, modulus):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % modulus\n        base = (base * base) % modulus\n        exponent //= 2\n    return result\n\ndef count_packing_ways(n, m):\n    # The problem can be reduced to finding the number of ways to distribute\n    # n distinct items into m distinct boxes with no more than one item per box,\n    # and each item must be in at least one box. This is equivalent to calculating\n    # the number of non-empty subsets of n items taken m times with repetition\n    # allowed but with no more than one item per subset.\n    \n    # The formula for this is (n + m - 1) choose (n - 1), which is the number of\n    # ways to choose n - 1 items from n + m - 1 items, considering that we have\n    # n items and we want to place them into m boxes with the condition that each\n    # item must be in at least one box.\n    \n    # Since we need to calculate this modulo 10^9 + 7, we use modular exponentiation\n    # for the factorials and their inverses.\n    \n    def mod_factorial(x, modulus):\n        result = 1\n        for i in range(2, x + 1):\n            result = (result * i) % modulus\n        return result\n    \n    def mod_inverse(a, modulus):\n        return mod_pow(a, modulus - 2, modulus)\n    \n    def mod_binomial(n, k, modulus):\n        if k > n:\n            return 0\n        numerator = mod_factorial(n, modulus)\n        denominator = (mod_factorial(k, modulus) * mod_factorial(n - k, modulus)) % modulus\n        return (numerator * mod_inverse(denominator, modulus)) % modulus\n    \n    # Calculate the number of ways using the binomial coefficient\n    return mod_binomial(n + m - 1, n - 1, MOD)\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(count_packing_ways(n, m))"}
{"solution": "import math\n\ndef find_pythagorean_triple(n):\n    if n == 1 or n == 2:\n        return -1  # No Pythagorean triple exists for n = 1 or n = 2\n    \n    # Check if n can be the longer leg of a primitive Pythagorean triple\n    if n % 2 == 0:\n        # For even n, we can find m and k such that n^2 = (m - k) * (m + k)\n        # We need to find integers m and k such that m and k are half of n^2's factors\n        n_squared = n ** 2\n        for i in range(1, int(math.sqrt(n_squared)) + 1):\n            if n_squared % i == 0:\n                m = (n_squared // i + i) // 2\n                k = (n_squared // i - i) // 2\n                if (m - k) % 2 == 0 and (m + k) % 2 == 0 and m > 0 and k > 0:\n                    return k * n, m * n\n    \n    # Check if n can be the shorter leg or the hypotenuse\n    if n % 2 != 0:\n        # For odd n, we can directly use the formula for generating primitive Pythagorean triples\n        # n = a, m = (a^2 - 1) / 2, k = (a^2 + 1) / 2\n        m = (n ** 2 - 1) // 2\n        k = (n ** 2 + 1) // 2\n        return m, k\n    \n    return -1  # If no triple is found\n\n# Read input\nn = int(input())\n\n# Find and print the Pythagorean triple\nresult = find_pythagorean_triple(n)\nif result == -1:\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "def distinct_remainders(n, k):\n    # If k is 1, the only remainder is 0, which is distinct by default\n    if k == 1:\n        return \"Yes\"\n    \n    # For k > 1, we need to check if there are any repeated remainders\n    # The smallest possible repeated remainder occurs when n % i == 0 for some i\n    # Since we are checking for distinct remainders from 1 to k, we can directly check\n    # if n % i == 0 for any i in the range from 2 to k (inclusive)\n    for i in range(2, k + 1):\n        if n % i == 0:\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nn, k = map(int, input().split())\n\n# Output result\nprint(distinct_remainders(n, k))"}
{"solution": "import sys\n\n# Fast input method\ninput = sys.stdin.readline\n\n# Read the two integers as strings\na = input().strip()\nb = input().strip()\n\n# Remove leading zeroes\na = a.lstrip('0') or '0'\nb = b.lstrip('0') or '0'\n\n# Compare the lengths of the strings\nif len(a) > len(b):\n    print('>')\nelif len(a) < len(b):\n    print('<')\nelse:\n    # If lengths are equal, compare lexicographically\n    if a > b:\n        print('>')\n    elif a < b:\n        print('<')\n    else:\n        print('=')"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, p, colors):\n    # Initialize the DP array\n    dp = [[[0 for _ in range(2)] for _ in range(2)] for _ in range(n+1)]\n    dp[0][0][0] = 1  # Base case: no pieces, no arrows, score is 0\n\n    # Iterate over each piece\n    for i in range(1, n+1):\n        # Determine if the current piece is colored or not\n        if colors[i-1] == -1:\n            # If uncolored, consider both colors (0 and 1)\n            for color in range(2):\n                for parity in range(2):\n                    for prev_color in range(2):\n                        # Calculate the new score parity\n                        new_parity = parity ^ (color != prev_color)\n                        # Update the DP table\n                        dp[i][color][new_parity] += dp[i-1][prev_color][parity]\n                        dp[i][color][new_parity] %= MOD\n        else:\n            # If colored, only consider the given color\n            color = colors[i-1]\n            for parity in range(2):\n                for prev_color in range(2):\n                    # Calculate the new score parity\n                    new_parity = parity ^ (color != prev_color)\n                    # Update the DP table\n                    dp[i][color][new_parity] += dp[i-1][prev_color][parity]\n                    dp[i][color][new_parity] %= MOD\n\n    # Sum up the ways that match the desired parity\n    result = 0\n    for color in range(2):\n        result += dp[n][color][p]\n        result %= MOD\n\n    return result\n\n# Read input\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_ways(n, p, colors))"}
{"solution": "def min_rubles_to_pay(n, a, b, c):\n    # Calculate the remainder when n is divided by 4\n    remainder = n % 4\n    \n    # If n is already divisible by 4, no additional copybooks are needed\n    if remainder == 0:\n        return 0\n    \n    # Calculate the number of additional copybooks needed to make n + k divisible by 4\n    additional_needed = 4 - remainder\n    \n    # Initialize the minimum cost to a large number\n    min_cost = float('inf')\n    \n    # Check each possible combination of packs to find the minimum cost\n    for i in range(4):\n        for j in range(4):\n            for k in range(4):\n                if (i + 2 * j + 3 * k) % 4 == additional_needed % 4 and i + 2 * j + 3 * k >= additional_needed:\n                    cost = i * a + j * b + k * c\n                    min_cost = min(min_cost, cost)\n    \n    return min_cost\n\n# Read input\nn, a, b, c = map(int, input().split())\n\n# Print the result\nprint(min_rubles_to_pay(n, a, b, c))"}
{"solution": "def is_acyclic_after_one_removal(n, m, edges):\n    # Create adjacency list and reverse adjacency list for the graph\n    adj_list = {i: [] for i in range(1, n + 1)}\n    reverse_adj_list = {i: [] for i in range(1, n + 1)}\n    for u, v in edges:\n        adj_list[u].append(v)\n        reverse_adj_list[v].append(u)\n\n    # Function to detect cycle in the graph\n    def has_cycle(node, visited, rec_stack):\n        if not visited[node]:\n            visited[node] = True\n            rec_stack[node] = True\n\n            for neighbour in adj_list[node]:\n                if not visited[neighbour] and has_cycle(neighbour, visited, rec_stack):\n                    return True\n                elif rec_stack[neighbour]:\n                    return True\n\n        rec_stack[node] = False\n        return False\n\n    # Check for cycle in the original graph\n    visited = [False] * (n + 1)\n    rec_stack = [False] * (n + 1)\n    for node in range(1, n + 1):\n        if not visited[node] and has_cycle(node, visited, rec_stack):\n            break\n    else:\n        return \"YES\"  # No cycle found\n\n    # If there's a cycle, try removing each edge in the cycle and check again\n    for u, v in edges:\n        # Temporarily remove the edge\n        adj_list[u].remove(v)\n\n        # Reset visited and rec_stack for the new check\n        visited = [False] * (n + 1)\n        rec_stack = [False] * (n + 1)\n        cycle_found = False\n        for node in range(1, n + 1):\n            if not visited[node] and has_cycle(node, visited, rec_stack):\n                cycle_found = True\n                break\n\n        # Re-add the edge\n        adj_list[u].append(v)\n\n        if not cycle_found:\n            return \"YES\"  # Found an edge that can be removed to make the graph acyclic\n\n    return \"NO\"  # No single edge removal can make the graph acyclic\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output result\nprint(is_acyclic_after_one_removal(n, m, edges))"}
{"solution": "def min_coins_to_modernize_street(n, m, antennas):\n    # Sort antennas by their position\n    antennas.sort()\n    \n    # Initialize the dynamic programming table\n    # dp[i] will store the minimum cost to cover positions up to i\n    dp = [float('inf')] * (m + 1)\n    dp[0] = 0  # Base case: no cost to cover 0 positions\n    \n    for x, s in antennas:\n        # Calculate the effective range of the antenna after potential extensions\n        left_coverage = max(1, x - s)\n        right_coverage = min(m, x + s)\n        \n        # Update the dp table for each position from left_coverage to right_coverage\n        for i in range(left_coverage, right_coverage + 1):\n            # Calculate the cost to extend the antenna to cover position i\n            cost = max(0, left_coverage - 1)\n            dp[i] = min(dp[i], dp[left_coverage - 1] + cost)\n    \n    # The answer is the minimum cost to cover all positions up to m\n    return dp[m]\n\n# Read input\nn, m = map(int, input().split())\nantennas = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(min_coins_to_modernize_street(n, m, antennas))"}
{"solution": "def max_good_subset_weight(W, cnt):\n    # Initialize the maximum weight to 0\n    max_weight = 0\n    \n    # Iterate through each weight from 1 to 8\n    for weight in range(1, 9):\n        # While we can add items of the current weight without exceeding W\n        while cnt[weight - 1] > 0 and max_weight + weight <= W:\n            # Add the item to the subset\n            max_weight += weight\n            # Decrease the count of items of this weight\n            cnt[weight - 1] -= 1\n    \n    return max_weight\n\n# Read input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Print the result\nprint(max_good_subset_weight(W, cnt))"}
{"solution": "def min_cost_to_buy_lemonade(n, L, costs):\n    # Create a list to store the cost per liter for each bottle type\n    cost_per_liter = [(2**i - 1, c_i) for i, c_i in enumerate(costs)]\n    \n    # Sort the list by cost per liter in ascending order\n    cost_per_liter.sort(key=lambda x: x[1] / (2**x[0] - 1))\n    \n    # Initialize the total cost\n    total_cost = 0\n    \n    # Start buying from the cheapest cost per liter\n    while L > 0:\n        # Find the best deal\n        best_deal = None\n        for volume, cost in cost_per_liter:\n            if 2**volume - 1 <= L:\n                best_deal = (volume, cost)\n                break\n        \n        if best_deal:\n            volume, cost = best_deal\n            # Calculate the number of bottles needed\n            num_bottles = L // (2**volume - 1)\n            # Add the cost of these bottles to the total cost\n            total_cost += num_bottles * cost\n            # Reduce the amount of lemonade needed\n            L -= num_bottles * (2**volume - 1)\n        else:\n            # If no suitable bottle is found, buy the smallest one available\n            total_cost += costs[0]\n            L -= 1\n    \n    return total_cost\n\n# Read input\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_cost_to_buy_lemonade(n, L, costs))"}
{"solution": "def max_mex(n, a):\n    a.sort()\n    mex = 1\n    for num in a:\n        if num >= mex:\n            mex += 1\n    return mex\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = max_mex(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(int(digit) for digit in digits)\n    \n    for segment_sum in range(1, total_sum + 1):\n        if total_sum % segment_sum == 0:\n            current_sum = 0\n            valid_partition = True\n            for digit in digits:\n                current_sum += int(digit)\n                if current_sum > segment_sum:\n                    valid_partition = False\n                    break\n                elif current_sum == segment_sum:\n                    current_sum = 0\n            if valid_partition and current_sum == 0:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nn = int(input())\ndigits = input().strip()\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\"\n\n# Example usage:\nusername = input().strip()\nprint(determine_gender(username))"}
{"solution": "def max_absolute_difference(n, k, tabs):\n    max_diff = 0\n    for b in range(n):\n        test_tabs = 0\n        social_tabs = 0\n        for i in range(n):\n            if (i - b) % k != 0:\n                if tabs[i] == 1:\n                    test_tabs += 1\n                else:\n                    social_tabs += 1\n        max_diff = max(max_diff, abs(test_tabs - social_tabs))\n    return max_diff\n\n# Read input\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Output the result\nprint(max_absolute_difference(n, k, tabs))"}
{"solution": "def min_total_cost(n, c_0, c_1):\n    # Calculate the minimum possible total cost of the whole alphabet\n    # The optimal encoding for n letters is to use binary representation of numbers from 0 to n-1\n    # This ensures that no letter's sequence is a prefix of another letter's sequence\n    \n    # Calculate the number of bits needed to represent n-1 in binary\n    bits_needed = (n-1).bit_length()\n    \n    # Calculate the total number of '0's and '1's used in the encoding\n    total_zeros = 0\n    total_ones = 0\n    \n    # For each bit position, calculate the number of '0's and '1's\n    for bit_position in range(bits_needed):\n        # Count the number of '1's at the current bit position\n        ones_at_position = (n >> bit_position) // 2\n        total_ones += ones_at_position * (1 << bit_position)\n        \n        # The number of '0's at the current bit position is the total number of bits minus the number of '1's\n        total_zeros += (n * bits_needed) - (total_ones * bits_needed)\n    \n    # Calculate the total cost\n    total_cost = (total_zeros * c_0) + (total_ones * c_1)\n    \n    return total_cost\n\n# Read input\nn, c_0, c_1 = map(int, input().split())\n\n# Output the result\nprint(min_total_cost(n, c_0, c_1))"}
{"solution": "def will_meet(n, a, x, b, y):\n    while a != x and b != y:\n        if a == b:\n            return \"YES\"\n        a = a + 1 if a < n else 1\n        b = b - 1 if b > 1 else n\n    return \"YES\" if a == b else \"NO\""}
{"solution": "def max_golden_age_length(x, y, l, r):\n    unlucky_years = set()\n    \n    # Generate all possible unlucky years within the range [l, r]\n    for a in range(64):  # 64 to cover the range of 10^18 for x and y\n        if x**a > r:\n            break\n        for b in range(64):\n            if y**b > r:\n                break\n            unlucky_year = x**a + y**b\n            if l <= unlucky_year <= r:\n                unlucky_years.add(unlucky_year)\n    \n    # Sort the unlucky years to find the intervals\n    sorted_unlucky_years = sorted(unlucky_years)\n    \n    # Find the maximum length of The Golden Age\n    max_length = 0\n    prev = l - 1\n    for year in sorted_unlucky_years:\n        if year > prev + 1:\n            max_length = max(max_length, year - prev - 1)\n        prev = year\n    max_length = max(max_length, r - prev)\n    \n    return max_length\n\n# Read input\nx, y, l, r = map(int, input().split())\n\n# Print the output\nprint(max_golden_age_length(x, y, l, r))"}
{"solution": "def min_tax(n):\n    # If n is a prime number, the maximum divisor (not equal to n) is 1,\n    # but since parts cannot be equal to 1, we need to split it.\n    # The best way to split a prime number is into two parts where one part is 2 and the other is n-2.\n    # This is because 2 is the smallest number greater than 1, and n-2 is the remainder,\n    # ensuring that the tax for the part 2 is 1 (since 2 is prime and its only divisor other than itself is 1).\n    if n == 2:\n        return 1  # Special case since n-2 would be 0, which is not allowed.\n    elif n % 2 == 0:\n        return 2  # If n is even, we can split it into two equal parts, each with a tax of 1.\n    else:\n        # If n is odd and not prime, we can find a divisor d such that n = d * (n/d),\n        # and both d and n/d are greater than 1. We need to check if n is prime.\n        # We only need to check up to the square root of n because if n is divisible by any number greater than its square root,\n        # then it must also be divisible by a number smaller than its square root.\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return i  # n is not prime and we found a divisor, so return it as the tax.\n        # If we exit the loop, n is prime, so we split it into 2 and n-2.\n        return 3  # The tax for 2 is 1 and for n-2 (which is prime) is also 1, so total tax is 3.\n\n# Read input\nn = int(input())\n\n# Print output\nprint(min_tax(n))"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    n = len(word)\n    result = []\n    i = 0\n    \n    while i < n:\n        result.append(word[i])\n        if word[i] not in vowels:\n            start = i\n            while i < n and word[i] not in vowels:\n                i += 1\n            if i - start >= 3:\n                block = word[start:i]\n                if len(set(block)) > 1:\n                    result.append(' ')\n        i += 1\n    \n    return ''.join(result)"}
{"solution": "def min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d):\n    # Initialize the minimum time with the case where no spells are used\n    min_time = x * n\n    \n    # Check spells of the first type to reduce the preparation time per potion\n    for i in range(m):\n        if b[i] <= s:\n            # Calculate the remaining potions after using a spell of the first type\n            remaining_potions = n\n            current_time_per_potion = a[i]\n            \n            # Check spells of the second type to instantly prepare some potions\n            for j in range(k):\n                if d[j] <= s - b[i]:\n                    # Update the remaining potions and the total time\n                    remaining_potions -= c[j]\n                    if remaining_potions <= 0:\n                        min_time = 0\n                        break\n            if remaining_potions > 0:\n                # Calculate the time for the remaining potions\n                min_time = min(min_time, current_time_per_potion * remaining_potions)\n            else:\n                min_time = 0\n                break\n    \n    # Check spells of the second type alone to instantly prepare some potions\n    for j in range(k):\n        if d[j] <= s:\n            # Calculate the remaining potions after using a spell of the second type\n            remaining_potions = n - c[j]\n            if remaining_potions <= 0:\n                min_time = 0\n                break\n            else:\n                # Calculate the time for the remaining potions\n                min_time = min(min_time, x * remaining_potions)\n    \n    return min_time\n\n# Read input\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\n# Calculate and print the minimum time\nprint(min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d))"}
{"solution": "def max_points(n, k, M, t):\n    t.sort()\n    total_time = 0\n    points = 0\n    for i in range(k):\n        if total_time + t[i] * n <= M:\n            total_time += t[i] * n\n            points += n\n        else:\n            remaining_time = M - total_time\n            points += remaining_time // t[i]\n            break\n    # Check if Polycarp can complete any task for extra points\n    for i in range(k):\n        if total_time + sum(t[:i+1]) <= M:\n            total_time += sum(t[:i+1])\n            points += 1\n        else:\n            break\n    return points\n\n# Read input\nn, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Output the result\nprint(max_points(n, k, M, t))"}
{"solution": "MOD = 998244353\n\ndef count_perfectly_balanced_striped_bst(n):\n    # Initialize a dynamic programming table to store the number of ways\n    # to construct perfectly balanced striped BSTs for different sizes.\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case: an empty tree is trivially perfectly balanced and striped.\n\n    # Function to calculate the number of ways to split the keys into left and right subtrees\n    # while maintaining the striped property.\n    def count_splits(start, end):\n        if start >= end:\n            return 1\n        total = 0\n        for i in range(start, end + 1):\n            left_count = count_splits(start, i - 1) if (i - start) % 2 == 0 else 0\n            right_count = count_splits(i + 1, end) if (end - i) % 2 == 0 else 0\n            total += (left_count * right_count) % MOD\n        return total % MOD\n\n    # Fill the dp table using the count_splits function.\n    for i in range(1, n + 1):\n        dp[i] = count_splits(1, i)\n\n    return dp[n]\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the result\nprint(count_perfectly_balanced_striped_bst(n))"}
{"solution": "def determine_lara_position(n, m, k):\n    # Calculate the number of complete cycles Lara has made\n    cycles = k // (2 * m)\n    \n    # Calculate the remaining moves after the complete cycles\n    remaining_moves = k % (2 * m)\n    \n    # Determine the current row based on the remaining moves\n    if remaining_moves < m:\n        current_row = cycles * 2 + 1\n    else:\n        current_row = cycles * 2 + 2\n    \n    # Determine the current column based on the remaining moves\n    if remaining_moves < m:\n        current_column = remaining_moves + 1\n    else:\n        current_column = (2 * m - remaining_moves) + 1\n    \n    return current_row, current_column\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Determine and print Lara's current position\ncurrent_row, current_column = determine_lara_position(n, m, k)\nprint(current_row, current_column)"}
{"solution": "def find_min_max_pair_for_lcm(X):\n    # Start with the smallest possible values for a and b\n    a = 1\n    b = X\n    \n    # Iterate over all possible divisors of X to find the pair (a, b)\n    # that minimizes max(a, b) while ensuring LCM(a, b) = X\n    for i in range(1, int(X**0.5) + 1):\n        if X % i == 0:\n            # Check if the current divisor i and its pair X//i satisfy LCM(a, b) = X\n            if X // i % i == 0 and X // (X // i) == i:\n                a = i\n                b = X // i\n    \n    return a, b\n\n# Read input\nX = int(input().strip())\n\n# Find and print the pair\na, b = find_min_max_pair_for_lcm(X)\nprint(a, b)"}
{"solution": "def max_fruits_for_compote(a, b, c):\n    # Calculate the maximum number of complete sets for each fruit type\n    max_sets_lemons = a // 1\n    max_sets_apples = b // 2\n    max_sets_pears = c // 4\n    \n    # Find the limiting factor (minimum number of complete sets)\n    max_complete_sets = min(max_sets_lemons, max_sets_apples, max_sets_pears)\n    \n    # Calculate the total number of fruits used in the compote\n    total_fruits = max_complete_sets * (1 + 2 + 4)\n    \n    return total_fruits\n\n# Read input\na = int(input())\nb = int(input())\nc = int(input())\n\n# Print output\nprint(max_fruits_for_compote(a, b, c))"}
{"solution": "def can_divide_teams(n, ratings):\n    ratings.sort()\n    for i in range(n):\n        if ratings[i] >= ratings[i + n]:\n            return \"NO\"\n    return \"YES\""}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef make_coprime_array(n, arr):\n    result = []\n    for i in range(n - 1):\n        result.append(arr[i])\n        if gcd(arr[i], arr[i + 1]) != 1:\n            # Insert a number that is guaranteed to be co-prime with both numbers\n            result.append(2)  # 2 is a safe choice since it's co-prime with most numbers\n    result.append(arr[-1])  # Add the last element of the original array\n    return result\n\ndef main():\n    n = int(input().strip())\n    arr = list(map(int, input().strip().split()))\n    \n    new_arr = make_coprime_array(n, arr)\n    k = len(new_arr) - n\n    \n    print(k)\n    print(' '.join(map(str, new_arr)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\nfrom functools import reduce\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef compute_gcd_of_list(lst):\n    return reduce(gcd, lst)\n\ndef max_divisor_after_operations(N, K, A):\n    if N == 1:\n        return A[0]\n    \n    # Compute the GCD of the differences between all pairs\n    diffs = [abs(A[i] - A[j]) for i in range(N) for j in range(i + 1, N)]\n    initial_gcd = compute_gcd_of_list(diffs)\n    \n    # Check all divisors of the initial GCD\n    max_divisor = 1\n    for d in range(1, initial_gcd + 1):\n        if initial_gcd % d == 0:\n            # Check if we can make all elements divisible by d\n            if all((a % d) <= K for a in A):\n                max_divisor = d\n    \n    return max_divisor\n\n# Read input\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Compute and print the result\nprint(max_divisor_after_operations(N, K, A))"}
{"solution": "def cat_furrier_transform(x):\n    operations = []\n    while x != 0 and len(operations) < 40:\n        # Find the highest bit that is not set in x\n        n = 0\n        while (1 << (n + 1)) - 1 <= x:\n            n += 1\n        \n        # Perform Operation A\n        x ^= (1 << n) - 1\n        operations.append(n)\n        \n        # Check if x is now a perfect longcat\n        if x == (1 << n) - 1:\n            break\n        \n        # Perform Operation B\n        x += 1\n    \n    # Output the result\n    print(len(operations))\n    if operations:\n        print(\" \".join(map(str, operations)))\n\n# Read input\nx = int(input().strip())\n\n# Perform the Cat Furrier Transform\ncat_furrier_transform(x)"}
{"solution": "def min_hours_to_water_garden(n, k, buckets):\n    min_hours = float('inf')\n    for a_i in buckets:\n        if k % a_i == 0:\n            min_hours = min(min_hours, k // a_i)\n    return min_hours\n\n# Reading input\nn, k = map(int, input().split())\nbuckets = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(min_hours_to_water_garden(n, k, buckets))"}
{"solution": "def can_grasshopper_reach_insect(n, k, line):\n    # Find the positions of the grasshopper and the insect\n    grasshopper_pos = line.index('G')\n    insect_pos = line.index('T')\n    \n    # Determine the direction of the jump based on their positions\n    step = k if grasshopper_pos < insect_pos else -k\n    \n    # Start jumping from the grasshopper's position\n    pos = grasshopper_pos\n    while pos >= 0 and pos < n:\n        if line[pos] == '#':  # If an obstacle is encountered, break\n            break\n        if line[pos] == 'T':  # If the insect is reached, return \"YES\"\n            return \"YES\"\n        pos += step  # Make the next jump\n    \n    # If the loop ends without finding the insect, return \"NO\"\n    return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\nline = input().strip()\n\n# Output the result\nprint(can_grasshopper_reach_insect(n, k, line))"}
{"solution": "import math\n\ndef calculate_aiming_point(y1, y2, yw, xb, yb, r):\n    # Check if the ball is already within the goal range\n    if y1 <= yb <= y2 and xb <= 0:\n        return 0  # The ball is already in the goal range, no need to bounce\n\n    # Calculate the angle of incidence\n    angle_incidence = math.atan2(yw - yb, xb)\n\n    # Calculate the y-coordinate where the ball would hit the OY axis\n    y_goal = yb + math.tan(angle_incidence) * xb\n\n    # Check if the ball would hit the goal after bouncing\n    if not (y1 <= y_goal <= y2):\n        return -1  # The ball does not hit the goal after bouncing\n\n    # Calculate the x-coordinate on the wall to aim for\n    xw = (yw - yb) * xb / (y_goal - yb)\n\n    return xw\n\n# Read input\ny1, y2, yw, xb, yb, r = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_aiming_point(y1, y2, yw, xb, yb, r)\nprint(f\"{result:.10f}\" if result != -1 else result)"}
{"solution": "def min_missed_meals(b, d, s):\n    # Sort the meals to find the maximum count\n    meals = sorted([b, d, s])\n    \n    # Start by assuming Vasiliy could have missed all meals on the days before and after his stay\n    missed = (meals[2] - meals[1]) + (meals[2] - meals[0])\n    \n    # Subtract the meals that could not have been missed due to arrival and departure times\n    # Vasiliy could have arrived and left at any time, so we subtract the maximum of 2 meals (one for arrival, one for departure)\n    missed -= min(2, meals[2] - 1)\n    \n    return max(missed, 0)\n\n# Read input\nb, d, s = map(int, input().split())\n\n# Print the result\nprint(min_missed_meals(b, d, s))"}
{"solution": "def find_matrix_dimensions(n, path):\n    # Function to calculate the possible dimensions of the matrix\n    def possible_dimensions(a1, a2):\n        # Calculate the possible x and y based on two consecutive numbers in the path\n        for x in range(1, int(a2 ** 0.5) + 1):\n            if a2 % x == 0:\n                y = a2 // x\n                if a1 == y * (x - 1) + 1:\n                    return x, y\n        return None, None\n\n    # Check for each pair of consecutive numbers in the path\n    for i in range(1, n):\n        x, y = possible_dimensions(path[i - 1], path[i])\n        if x is not None:\n            # Validate the entire path with the found dimensions\n            valid = True\n            for j in range(1, n):\n                if not (path[j] == y * (x - 1) + 1 or path[j] == y * x or path[j] == y * (x - 2) + 1 or path[j] == y * (x - 1)):\n                    valid = False\n                    break\n            if valid:\n                return \"YES\\n{} {}\".format(x, y)\n\n    return \"NO\"\n\n# Read input\nn = int(input().strip())\npath = list(map(int, input().strip().split()))\n\n# Output the result\nprint(find_matrix_dimensions(n, path))"}
{"solution": "def find_longest_subsequence(a, b):\n    # Initialize pointers for both strings\n    a_ptr, b_ptr = 0, 0\n    # Initialize lists to store the start and end indices of the subsequence in b\n    start_indices = []\n    end_indices = []\n    \n    # Find all matching subsequences\n    while a_ptr < len(a) and b_ptr < len(b):\n        if a[a_ptr] == b[b_ptr]:\n            if not start_indices or b_ptr != end_indices[-1]:\n                start_indices.append(b_ptr)\n            end_indices.append(b_ptr)\n            a_ptr += 1\n            b_ptr += 1\n        else:\n            a_ptr += 1\n    \n    # If no matching subsequence found, return \"-\"\n    if not start_indices:\n        return \"-\"\n    \n    # Find the longest subsequence by minimizing the number of removed consecutive characters\n    max_length = 0\n    best_start, best_end = 0, 0\n    for i in range(len(start_indices)):\n        current_length = end_indices[i] - start_indices[i] + 1\n        if current_length > max_length:\n            max_length = current_length\n            best_start, best_end = start_indices[i], end_indices[i]\n    \n    # Return the longest subsequence\n    return b[best_start:best_end + 1]\n\n# Read input\na = input().strip()\nb = input().strip()\n\n# Output the result\nprint(find_longest_subsequence(a, b))"}
{"solution": "def minimal_stones(n, s):\n    current_stones = 0\n    min_stones = 0\n    \n    for char in s:\n        if char == '+':\n            current_stones += 1\n        elif char == '-':\n            current_stones -= 1\n        min_stones = min(min_stones, current_stones)\n    \n    return max(0, -min_stones)\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Print output\nprint(minimal_stones(n, s))"}
{"solution": "def max_liters_of_kefir(n, a, b, c):\n    # If the cost of a glass bottle minus the return cost is less than the cost of a plastic bottle,\n    # it's more profitable to buy glass bottles and return them if possible.\n    if b - c < a:\n        # Calculate the maximum number of glass bottles Kolya can buy with his initial money.\n        # He can always buy at least one glass bottle if he has enough money for it.\n        glass_bottles = n // b\n        # Calculate the remaining money after buying the maximum number of glass bottles.\n        remaining_money = n - (glass_bottles * b)\n        # Calculate the total liters of kefir Kolya can drink from glass bottles.\n        liters_from_glass = glass_bottles\n        \n        # While Kolya has enough money to buy at least one more glass bottle after returning the previous one,\n        # he should continue to do so to maximize the amount of kefir he drinks.\n        while remaining_money + c >= b:\n            # Buy another glass bottle.\n            glass_bottles += 1\n            # Update the remaining money after buying and returning the glass bottle.\n            remaining_money = remaining_money + c - b\n            # Update the total liters of kefir from glass bottles.\n            liters_from_glass += 1\n        \n        # If Kolya has enough remaining money to buy at least one plastic bottle,\n        # he should do so to maximize the amount of kefir he drinks.\n        if remaining_money >= a:\n            liters_from_glass += 1\n        \n        return liters_from_glass\n    else:\n        # If it's more expensive or equal to buy glass bottles and return them compared to buying plastic bottles,\n        # Kolya should just buy plastic bottles with his initial money.\n        return n // a\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate and print the result\nprint(max_liters_of_kefir(n, a, b, c))"}
{"solution": "def card_war(n, k1, cards1, k2, cards2):\n    fights = 0\n    seen_states = set()\n    \n    while k1 > 0 and k2 > 0:\n        # Convert current state to a tuple to store in seen_states\n        state = (tuple(cards1), tuple(cards2))\n        if state in seen_states:\n            return -1  # Game will continue forever\n        seen_states.add(state)\n        \n        fight(cards1, cards2)\n        fights += 1\n        k1 = len(cards1)\n        k2 = len(cards2)\n    \n    winner = 1 if k1 > 0 else 2\n    return fights, winner\n\ndef fight(cards1, cards2):\n    card1 = cards1.pop(0)\n    card2 = cards2.pop(0)\n    \n    if card1 > card2:\n        cards1.append(card2)\n        cards1.append(card1)\n    else:\n        cards2.append(card1)\n        cards2.append(card2)\n\n# Read input\nn = int(input())\nk1 = int(input())\ncards1 = list(map(int, input().split()))\nk2 = int(input())\ncards2 = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = card_war(n, k1, cards1, k2, cards2)\nif result == -1:\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    \n    has_upper = False\n    has_lower = False\n    has_digit = False\n    \n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n    \n    if has_upper and has_lower and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\""}
{"solution": "def min_exchanges(n, group_a, group_b):\n    # Count the occurrences of each academic performance in both groups\n    count_a = [0] * 6\n    count_b = [0] * 6\n    \n    for perf in group_a:\n        count_a[perf] += 1\n    for perf in group_b:\n        count_b[perf] += 1\n    \n    # Calculate the total number of students for each performance\n    total_count = [count_a[i] + count_b[i] for i in range(6)]\n    \n    # Check if it's possible to balance the groups\n    for i in range(1, 6):\n        if total_count[i] % 2 != 0:\n            return -1\n    \n    # Calculate the number of students to exchange for each performance\n    exchanges = 0\n    for i in range(1, 6):\n        needed_exchanges = abs(count_a[i] - count_b[i]) // 2\n        exchanges += needed_exchanges\n    \n    # Since each exchange affects two students, divide by 2 to get the minimum number of exchanges\n    return exchanges // 2\n\n# Read input\nn = int(input())\ngroup_a = list(map(int, input().split()))\ngroup_b = list(map(int, input().split()))\n\n# Print the result\nprint(min_exchanges(n, group_a, group_b))"}
{"solution": "def can_reach_any_junction_from_any_other(n, m, horizontal_directions, vertical_directions):\n    # Check if there's at least one horizontal street that allows movement in both directions\n    horizontal_bidirectional = any(horizontal_directions.count(d) > 1 for d in ['<', '>'])\n    \n    # Check if there's at least one vertical street that allows movement in both directions\n    vertical_bidirectional = any(vertical_directions.count(d) > 1 for d in ['^', 'v'])\n    \n    # If there's at least one bidirectional street in both directions, return \"YES\"\n    return \"YES\" if horizontal_bidirectional and vertical_bidirectional else \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nhorizontal_directions = input().strip()\nvertical_directions = input().strip()\n\n# Output the result\nprint(can_reach_any_junction_from_any_other(n, m, horizontal_directions, vertical_directions))"}
{"solution": "def can_make_false(n, args):\n    if '1' not in args or '0' not in args:\n        return \"NO\"\n    \n    if n == 1:\n        return \"YES\\n0\" if args[0] == '0' else \"NO\"\n    \n    # Find the first '1' followed by a '0' to create a false implication\n    for i in range(n - 1):\n        if args[i] == '1' and args[i + 1] == '0':\n            # Create the false implication by grouping the '1' and '0' together\n            result = \"(\" * i + \"->\".join(args[:i + 2]) + \")\" + \"->\" + \"->\".join(args[i + 2:])\n            return \"YES\\n\" + result\n    \n    # If no such pair is found, it's not possible to make the expression false\n    return \"NO\"\n\n# Read input\nn = int(input())\nargs = input().split()\n\n# Output result\nprint(can_make_false(n, args))"}
{"solution": "def process_variables(a, b):\n    while a != 0 and b != 0:\n        if a >= 2 * b:\n            a %= 2 * b\n        elif b >= 2 * a:\n            b %= 2 * a\n        else:\n            break\n    return a, b\n\n# Assuming the input is provided as described in the problem statement\nn, m = map(int, input().split())\na, b = process_variables(n, m)\nprint(a, b)"}
{"solution": "def count_k_divisible_numbers(k, a, b):\n    # Adjust the range to start from the next k-divisible number greater than or equal to a\n    start = a if a % k == 0 else a + (k - a % k)\n    # Adjust the end range to the previous k-divisible number less than or equal to b\n    end = b if b % k == 0 else b - b % k\n    \n    # If start is greater than end, there are no k-divisible numbers in the range\n    if start > end:\n        return 0\n    \n    # Calculate the number of k-divisible numbers in the adjusted range\n    return (end - start) // k + 1\n\n# Read input\nk, a, b = map(int, input().split())\n\n# Print the result\nprint(count_k_divisible_numbers(k, a, b))"}
{"solution": "def find_kth_digit(k):\n    # Initialize the length of the current number and the total length of the sequence\n    length = 0\n    number_length = 1\n    # Find the number range where the k-th digit falls into\n    while length + 9 * (10 ** (number_length - 1)) * number_length < k:\n        length += 9 * (10 ** (number_length - 1)) * number_length\n        number_length += 1\n    # Calculate the exact number and the position within that number\n    k -= length\n    number = (10 ** (number_length - 1)) + (k - 1) // number_length\n    position = (k - 1) % number_length\n    # Return the digit at the calculated position\n    return str(number)[position]\n\n# Read input\nk = int(input())\n# Print the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "def can_vasya_win(n, s):\n    # Calculate the number of moves each player will make\n    moves_each = (n - 11) // 2\n    \n    # Count the number of '8's in the first n - 10 characters\n    count_8s = s[:n - 10].count('8')\n    \n    # Vasya wins if there are more '8's than the number of moves Petya can make\n    if count_8s > moves_each:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Determine if Vasya has a winning strategy\nresult = can_vasya_win(n, s)\nprint(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef binomial_coefficient(n, k):\n    if k > n:\n        return 0\n    result = factorial(n)\n    result = (result * pow(factorial(k), MOD - 2, MOD)) % MOD\n    result = (result * pow(factorial(n - k), MOD - 2, MOD)) % MOD\n    return result\n\ndef count_valid_permutations(n, x, pos):\n    less_than_x = x - 1\n    greater_than_x = n - x\n    left = 0\n    right = n\n    valid_permutations = 1\n    while left < right:\n        middle = (left + right) // 2\n        if middle <= pos:\n            if middle < pos:\n                valid_permutations = (valid_permutations * less_than_x) % MOD\n                less_than_x -= 1\n            left = middle + 1\n        else:\n            valid_permutations = (valid_permutations * greater_than_x) % MOD\n            greater_than_x -= 1\n            right = middle\n    if left > 0 and left - 1 == pos:\n        valid_permutations = (valid_permutations * factorial(less_than_x + greater_than_x)) % MOD\n    else:\n        valid_permutations = 0\n    return valid_permutations\n\n# Read input\nn, x, pos = map(int, input().split())\n\n# Calculate and print the result\nprint(count_valid_permutations(n, x, pos))"}
{"solution": "def decrypt_message(s, k):\n    # Count the number of letters that can be manipulated\n    manipulable_letters = sum(1 for i in range(len(s) - 1) if s[i + 1] in '?*')\n    \n    # Count the number of fixed letters\n    fixed_letters = len(s) - manipulable_letters\n    \n    # If k is less than the number of fixed letters minus manipulable letters, or more than the total length including all possible repetitions, it's impossible\n    if k < fixed_letters - manipulable_letters or k > len(s) - s.count('?') + s.count('*'):\n        return \"Impossible\"\n    \n    # Start building the message\n    message = []\n    extra_letters_needed = k - fixed_letters\n    \n    for i in range(len(s)):\n        if s[i] in '?*':\n            continue\n        if i + 1 < len(s) and s[i + 1] == '?':\n            if extra_letters_needed > 0:\n                message.append(s[i])\n                extra_letters_needed -= 1\n        elif i + 1 < len(s) and s[i + 1] == '*':\n            if extra_letters_needed > 0:\n                message.append(s[i])\n                extra_letters_needed -= 1\n            while extra_letters_needed > 0:\n                message.append(s[i])\n                extra_letters_needed -= 1\n        else:\n            message.append(s[i])\n    \n    return ''.join(message)\n\n# Read input\ns = input().strip()\nk = int(input().strip())\n\n# Output the result\nprint(decrypt_message(s, k))"}
{"solution": "def min_turns_to_correct_orientation(angle):\n    # Normalize the angle to be within the range [0, 360)\n    normalized_angle = angle % 360\n    if normalized_angle < 0:\n        normalized_angle += 360\n    \n    # Calculate the minimum number of 90-degree clockwise turns needed\n    # by finding the closest multiple of 90 to the normalized angle\n    turns = (normalized_angle + 45) // 90\n    \n    # Since we can only turn clockwise, we need to ensure the turns are minimized\n    # by taking the modulo 4 of the turns (since 4 turns bring us back to the start)\n    return turns % 4\n\n# Example usage:\n# angle = 60\n# print(min_turns_to_correct_orientation(angle))  # Output: 1\n\n# angle = -60\n# print(min_turns_to_correct_orientation(angle))  # Output: 3"}
{"solution": "def can_transform_spheres(a, b, c, x, y, z):\n    # Calculate the excess or deficit of each color\n    blue_diff = a - x\n    violet_diff = b - y\n    orange_diff = c - z\n\n    # Check if we have enough to transform into the required amounts\n    if blue_diff >= 0 and violet_diff >= 0 and orange_diff >= 0:\n        # Check if we can balance the excess by transforming into other colors\n        if blue_diff // 2 + violet_diff // 2 + orange_diff // 2 >= (blue_diff % 2 + violet_diff % 2 + orange_diff % 2):\n            return \"Yes\"\n    elif blue_diff <= 0 and violet_diff <= 0 and orange_diff <= 0:\n        # Check if we can transform from other colors to cover the deficit\n        if -blue_diff // 2 + -violet_diff // 2 + -orange_diff // 2 <= min(a, b, c):\n            return \"Yes\"\n    else:\n        # Mixed situation: some excess and some deficit\n        excess = [val for val in [blue_diff, violet_diff, orange_diff] if val > 0]\n        deficit = [val for val in [blue_diff, violet_diff, orange_diff] if val < 0]\n        if sum(excess) // 2 >= sum(deficit):\n            return \"Yes\"\n\n    return \"No\"\n\n# Read input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Output result\nprint(can_transform_spheres(a, b, c, x, y, z))"}
{"solution": "def count_valid_numbers(n, k, m):\n    # Initialize the count of valid numbers\n    count = 0\n    \n    # Helper function to calculate the number of valid suffixes of length i\n    def valid_suffixes(i):\n        if i == 1:\n            return sum(1 for d in range(1, 10) if d % k == 0)\n        else:\n            return sum(10 ** (i - 1) for d in range(1, 10) if d % k == 0)\n    \n    # Iterate over all possible lengths of suffixes\n    for i in range(1, n + 1):\n        # Calculate the number of valid numbers with suffix length i\n        count += valid_suffixes(i) * (10 ** (n - i))\n        count %= m\n    \n    return count\n\n# Read input\nn, k, m = map(int, input().split())\n\n# Output the result\nprint(count_valid_numbers(n, k, m))"}
{"solution": "def max_team_size(l, r, a):\n    while a > 0:\n        if l < r:\n            l += 1\n        else:\n            r += 1\n        a -= 1\n    return 2 * min(l, r)\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nl, r, a = map(int, data)\n\n# Print the output\nprint(max_team_size(l, r, a))"}
{"solution": "def min_moves_to_pick_all_coins(n, k):\n    # Calculate the total moves needed to clear the stones and pick the coins\n    # for the manholes to the left and right of Nastya's initial position\n    left_moves = (k - 1) * 2 + 1 if k > 1 else 0\n    right_moves = (n - k) * 2 + 1 if k < n else 0\n\n    # Determine the direction with the least number of moves\n    if left_moves < right_moves:\n        # If it's more efficient to go left, calculate the total moves for the left side\n        total_moves = left_moves + sum(range(1, k)) * 2\n    else:\n        # If it's more efficient to go right or equal, calculate the total moves for the right side\n        total_moves = right_moves + sum(range(k, n)) * 2\n\n    return total_moves\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the minimum number of moves\nprint(min_moves_to_pick_all_coins(n, k))"}
{"solution": "def min_tallest_tower(n, m):\n    # Start with the smallest possible heights for the towers\n    two_block_heights = [2 * i for i in range(1, n + 1)]\n    three_block_heights = [3 * i for i in range(1, m + 1)]\n    \n    # Combine the heights and check for duplicates\n    all_heights = set(two_block_heights + three_block_heights)\n    \n    # If there are no duplicates, the tallest tower is the maximum height\n    if len(all_heights) == n + m:\n        return max(all_heights)\n    \n    # If there are duplicates, we need to adjust the heights\n    # We will try to increase the heights of the two-block towers first\n    for i in range(n):\n        while two_block_heights[i] in all_heights:\n            two_block_heights[i] += 2\n        all_heights.add(two_block_heights[i])\n    \n    # Then, we will adjust the heights of the three-block towers\n    for i in range(m):\n        while three_block_heights[i] in all_heights:\n            three_block_heights[i] += 3\n        all_heights.add(three_block_heights[i])\n    \n    # The tallest tower is the maximum height after adjustments\n    return max(all_heights)\n\n# Read input\nn, m = map(int, input().split())\n\n# Print the result\nprint(min_tallest_tower(n, m))"}
{"solution": "def can_play_fair(n, cards):\n    # Count the occurrences of each number\n    from collections import Counter\n    counts = Counter(cards)\n    \n    # Find the two most common numbers\n    most_common = counts.most_common(2)\n    \n    # Check if the two most common numbers can be chosen to make the game fair\n    if len(most_common) == 2 and most_common[0][1] + most_common[1][1] == n and most_common[0][1] == most_common[1][1]:\n        return \"YES\", most_common[0][0], most_common[1][0]\n    else:\n        return \"NO\", None, None\n\n# Read input\nn = int(input())\ncards = [int(input()) for _ in range(n)]\n\n# Determine if the game can be fair and print the result\nresult, petya_number, vasya_number = can_play_fair(n, cards)\nprint(result)\nif result == \"YES\":\n    print(petya_number, vasya_number)"}
{"solution": "def can_place_soldiers(n, k, groups):\n    # Calculate the total number of soldiers\n    total_soldiers = sum(groups)\n    \n    # Calculate the maximum number of soldiers that can be placed without conflict in one row\n    max_soldiers_per_row = 4  # Since we can place up to 4 soldiers in a row without conflict (e.g., 1, 3, 5, 7)\n    \n    # Calculate the total number of soldiers that can be placed without conflict in the entire plane\n    max_total_soldiers = max_soldiers_per_row * n\n    \n    # If the total number of soldiers is less than or equal to the maximum number that can be placed without conflict, return \"YES\"\n    if total_soldiers <= max_total_soldiers:\n        return \"YES\"\n    else:\n        # Otherwise, we need to check if we can distribute the soldiers in such a way that no two soldiers from different groups are neighbors\n        # This is a more complex check, but for simplicity, we'll assume it's not possible if we exceed the max_total_soldiers\n        return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Output the result\nprint(can_place_soldiers(n, k, groups))"}
{"solution": "def min_cost_to_make_sticks_almost_good(n, a):\n    min_cost = float('inf')\n    optimal_t = 0\n    \n    # Since the lengths of the sticks are between 1 and 100, we only need to consider t values in that range\n    for t in range(1, 101):\n        current_cost = 0\n        for length in a:\n            if abs(length - t) > 1:  # If the stick length is not almost good for t\n                current_cost += min(abs(length - t + 1), abs(length - t - 1))\n        if current_cost < min_cost:\n            min_cost = current_cost\n            optimal_t = t\n    \n    return optimal_t, min_cost\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Finding and printing the result\nt, cost = min_cost_to_make_sticks_almost_good(n, a)\nprint(t, cost)"}
{"solution": "def min_square_side(n, m, sky_map):\n    min_x = min_y = float('inf')\n    max_x = max_y = -float('inf')\n    \n    for i in range(n):\n        for j in range(m):\n            if sky_map[i][j] == '*':\n                min_x = min(min_x, i)\n                max_x = max(max_x, i)\n                min_y = min(min_y, j)\n                max_y = max(max_y, j)\n    \n    side_x = max_x - min_x + 1\n    side_y = max_y - min_y + 1\n    \n    return max(side_x, side_y)\n\n# \u0427\u0442\u0435\u043d\u0438\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\nn, m = map(int, input().split())\nsky_map = [input() for _ in range(n)]\n\n# \u0412\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u0438 \u0432\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\nprint(min_square_side(n, m, sky_map))"}
{"solution": "MOD = 10**9 + 7\n\ndef modinv(a, m=MOD):\n    return pow(a, m-2, m)\n\ndef solve(n, k, a):\n    # If the array is already sorted, the probability is 1\n    if all(a[i] <= a[i+1] for i in range(n-1)):\n        return 1\n    \n    # If there's only one operation or the array is of size 2,\n    # the array can only be sorted if it's already sorted\n    if k == 1 or n == 2:\n        return 0\n    \n    # Count the number of 0s and 1s\n    zeros = a.count(0)\n    ones = n - zeros\n    \n    # If the number of 0s or 1s is 0, the array will always be sorted\n    if zeros == 0 or ones == 0:\n        return 1\n    \n    # Calculate the number of ways to sort the array\n    # This is a simplified approach assuming k is large enough\n    # to make the array sorted with high probability\n    # The exact calculation would involve combinatorics and dynamic programming\n    # but for the sake of this example, we'll use a simplified approach\n    \n    # Calculate the factorial of k to approximate the number of combinations\n    fact_k = 1\n    for i in range(1, k+1):\n        fact_k = (fact_k * i) % MOD\n    \n    # The denominator is the factorial of k, and the numerator is approximated\n    # as the number of ways to arrange the array into sorted order\n    # This is a simplification and may not be accurate for all cases\n    numerator = fact_k\n    denominator = fact_k\n    \n    # Calculate the result as P * Q^-1 mod MOD\n    result = (numerator * modinv(denominator)) % MOD\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Solve the problem and print the result\nprint(solve(n, k, a))"}
{"solution": "def min_seconds_to_devolve_triangle(x, y):\n    # The minimum number of operations is the difference between x and y\n    # because in each operation, we can reduce one side by 1 and adjust the other two sides\n    # to maintain a non-degenerate triangle.\n    return x - y\n\n# Read input\nx, y = map(int, input().split())\n\n# Output the result\nprint(min_seconds_to_devolve_triangle(x, y))"}
{"solution": "def min_norm_degenerate_matrix(a, b, c, d):\n    # Calculate the determinant of A\n    det_A = a * d - b * c\n    \n    # If A is already degenerate, return 0\n    if det_A == 0:\n        return 0.0\n    \n    # Initialize the minimum norm to a large number\n    min_norm = float('inf')\n    \n    # Try making each element of B equal to the corresponding element of A\n    # and adjust the other elements to make B degenerate\n    for i in range(4):\n        if i == 0:  # Adjust a\n            B = [a, 0, 0, (b * c) / a]\n        elif i == 1:  # Adjust b\n            B = [0, b, (a * d) / b, 0]\n        elif i == 2:  # Adjust c\n            B = [(b * d) / c, 0, c, 0]\n        else:  # Adjust d\n            B = [0, (a * c) / d, 0, d]\n        \n        # Calculate the norm of A - B\n        norm_A_B = max(abs(a - B[0]), abs(b - B[1]), abs(c - B[2]), abs(d - B[3]))\n        \n        # Update the minimum norm if a smaller value is found\n        if norm_A_B < min_norm:\n            min_norm = norm_A_B\n    \n    return min_norm\n\n# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate and print the result\nprint(\"{:.10f}\".format(min_norm_degenerate_matrix(a, b, c, d)))"}
{"solution": "def restaurant_service(n, a, b, groups):\n    denied_service = 0\n    one_seater_tables = a\n    two_seater_tables = b\n    single_occupants = 0\n\n    for group in groups:\n        if group == 1:\n            if one_seater_tables > 0:\n                one_seater_tables -= 1\n            elif two_seater_tables > 0:\n                two_seater_tables -= 1\n                single_occupants += 1\n            elif single_occupants > 0:\n                single_occupants -= 1\n            else:\n                denied_service += 1\n        elif group == 2:\n            if two_seater_tables > 0:\n                two_seater_tables -= 1\n            else:\n                denied_service += 2\n\n    return denied_service\n\n# Reading input\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(restaurant_service(n, a, b, groups))"}
{"solution": "def determine_students_not_passing(A, B, C, N):\n    # Calculate the total number of students who celebrated\n    total_celebrated = A + B - C\n    \n    # Check if the total number of students who celebrated is greater than N\n    if total_celebrated >= N:\n        return -1\n    \n    # Calculate the number of students who didn't pass the exam\n    not_passing = N - total_celebrated\n    \n    # If the number of students who didn't pass is 0 or less, it's a contradiction\n    if not_passing <= 0:\n        return -1\n    \n    return not_passing\n\n# Read input\nA, B, C, N = map(int, input().split())\n\n# Output the result\nprint(determine_students_not_passing(A, B, C, N))"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_pow(base, exponent, modulus):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % modulus\n        base = (base * base) % modulus\n        exponent //= 2\n    return result\n\ndef expected_dresses(x, k):\n    if x == 0:\n        return 0\n    # Calculate the expected number of dresses after k months\n    # The formula is derived from the problem statement and the geometric series\n    # E(x, k) = x * (3/2)^k - (1/2)^k\n    # We use modular arithmetic to handle large numbers\n    three_halves_pow_k = mod_pow(3, k, MOD) * mod_pow(2, MOD - 1 - k, MOD) % MOD\n    half_pow_k = mod_pow(2, MOD - 1 - k, MOD)\n    expected = (x * three_halves_pow_k - half_pow_k) % MOD\n    return expected\n\n# Read input\nx, k = map(int, input().split())\n\n# Calculate and print the expected number of dresses modulo 10^9 + 7\nprint(expected_dresses(x, k))"}
{"solution": "MOD = 998244353\n\ndef modinv(a, m):\n    return pow(a, m - 2, m)\n\ndef solve(n, ranges):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    total_ways = 1\n    for i in range(1, n + 1):\n        l_i, r_i = ranges[i - 1]\n        total_ways = total_ways * (r_i - l_i + 1) % MOD\n        for j in range(i + 1):\n            if j > 0:\n                dp[i][j] = dp[i - 1][j - 1] if j - 1 <= i - 1 else 0\n            if j <= i - 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j] * (min(r_i, ranges[i - 2][1]) - max(l_i, ranges[i - 2][0]) + 1)) % MOD\n    \n    no_inversions_ways = sum(dp[n][j] for j in range(n + 1)) % MOD\n    return no_inversions_ways * modinv(total_ways, MOD) % MOD\n\ndef main():\n    n = int(input())\n    ranges = [tuple(map(int, input().split())) for _ in range(n)]\n    print(solve(n, ranges))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_ways_to_cut_stick(n):\n    # If n is odd, it's impossible to divide it into four parts that can form a rectangle\n    if n % 2 != 0:\n        return 0\n    \n    # If n is even, the number of ways to cut the stick depends on whether n/2 is even or odd\n    half_n = n // 2\n    if half_n % 2 == 0:\n        # If half_n is even, we can't form a square, so we have (half_n/2 - 1) ways to cut the stick\n        return half_n // 2 - 1\n    else:\n        # If half_n is odd, we have (half_n - 1)/2 ways to cut the stick\n        return (half_n - 1) // 2\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(count_ways_to_cut_stick(n))"}
{"solution": "def max_kvass_in_least_keg(n, s, volumes):\n    # Sort the volumes to easily find the minimum after pouring\n    volumes.sort()\n    \n    # Check if it's possible to pour s liters\n    if sum(volumes) < s:\n        return -1\n    \n    # Start pouring from the largest keg to maintain the minimum volume in the least keg\n    for i in range(n - 1, 0, -1):\n        # Calculate how much we can pour from the current keg\n        pour_amount = min(volumes[i] - volumes[0], s)\n        # Update the volume of the current keg and the total amount to pour\n        volumes[i] -= pour_amount\n        s -= pour_amount\n        \n        # If we've poured enough, break out of the loop\n        if s == 0:\n            break\n    \n    # If there's still kvass to pour after adjusting all kegs, take from the least keg\n    if s > 0:\n        volumes[0] -= s\n    \n    # Return the volume of the least keg after all pouring\n    return volumes[0]\n\n# Read input\nn, s = map(int, input().split())\nvolumes = list(map(int, input().split()))\n\n# Get the result and print it\nprint(max_kvass_in_least_keg(n, s, volumes))"}
{"solution": "def caterpillar_to_apple(h_1, h_2, a, b):\n    # Calculate the net gain per day\n    net_gain_per_day = (a * 10) - (b * 12)\n    \n    # If the caterpillar gains no height or loses height during a day, it can't reach the apple\n    if net_gain_per_day <= 0:\n        return -1\n    \n    # Calculate the initial height difference\n    height_difference = h_2 - h_1\n    \n    # If the caterpillar can reach the apple on the first day\n    if height_difference <= a * 8:\n        return 0\n    \n    # Calculate the number of full days needed to reach the apple\n    full_days_needed = (height_difference - (a * 8)) // net_gain_per_day\n    \n    # Check if an additional day is needed\n    if (height_difference - (a * 8)) % net_gain_per_day != 0:\n        full_days_needed += 1\n    \n    return full_days_needed + 1  # Add the first day when Gabriel noticed the caterpillar\n\n# Read input\nh_1, h_2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(caterpillar_to_apple(h_1, h_2, a, b))"}
{"solution": "def max_joy_units(C, H_r, H_b, W_r, W_b):\n    # Calculate the maximum number of candies Om Nom can eat without exceeding the weight limit\n    max_candies_r = C // W_r\n    max_candies_b = C // W_b\n    \n    # Initialize the maximum joy units to 0\n    max_joy = 0\n    \n    # Iterate over possible numbers of red candies to eat\n    for i in range(max_candies_r + 1):\n        # Calculate the remaining weight capacity after eating i red candies\n        remaining_capacity = C - i * W_r\n        \n        # Calculate the number of blue candies that can be eaten with the remaining capacity\n        j = remaining_capacity // W_b\n        \n        # Calculate the total joy units for this combination of red and blue candies\n        joy = i * H_r + j * H_b\n        \n        # Update the maximum joy units if the current combination yields more joy\n        if joy > max_joy:\n            max_joy = joy\n    \n    return max_joy\n\n# Read input from stdin\nC, H_r, H_b, W_r, W_b = map(int, input().split())\n\n# Calculate and print the maximum number of joy units\nprint(max_joy_units(C, H_r, H_b, W_r, W_b))"}
{"solution": "def minimal_steps_to_finish(x_1, y_1, x_2, y_2):\n    # Calculate the absolute differences in x and y coordinates\n    dx = abs(x_2 - x_1)\n    dy = abs(y_2 - y_1)\n    \n    # The minimal number of steps is the maximum of the differences\n    # because the robot can move diagonally, which counts as one step\n    # but covers both x and y differences simultaneously.\n    return max(dx, dy)\n\n# Read input from the user\nx_1, y_1 = map(int, input().split())\nx_2, y_2 = map(int, input().split())\n\n# Calculate and print the minimal number of steps\nprint(minimal_steps_to_finish(x_1, y_1, x_2, y_2))"}
{"solution": "def predict_vote_outcome(n, employees):\n    depublicans = employees.count('D')\n    remocrats = n - depublicans\n    \n    # Simulate the voting process using a queue for each fraction\n    d_queue = deque(range(n)[::-1] for _ in range(depublicans))\n    r_queue = deque(range(n)[::-1] for _ in range(remocrats))\n    \n    while d_queue and r_queue:\n        # Process the next employee's turn\n        d_turn = d_queue.popleft()\n        r_turn = r_queue.popleft()\n        \n        if d_turn < r_turn:\n            d_queue.append(d_turn + n)  # Dequeue the next D employee\n        else:\n            r_queue.append(r_turn + n)  # Dequeue the next R employee\n    \n    # Determine the winning fraction\n    return 'D' if d_queue else 'R'\n\n# Read input\nn = int(input())\nemployees = input()\n\n# Predict and print the outcome\nprint(predict_vote_outcome(n, employees))"}
{"solution": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef count_valid_tv_sets(a, b, x, y):\n    # Find the greatest common divisor (GCD) of x and y to normalize the aspect ratio\n    g = gcd(x, y)\n    x //= g\n    y //= g\n    \n    # Calculate the maximum width and height that fit within the constraints while maintaining the aspect ratio\n    max_width = a // x\n    max_height = b // y\n    \n    # The number of valid TV sets is the minimum of max_width and max_height\n    return min(max_width, max_height)\n\n# Read input\na, b, x, y = map(int, input().split())\n\n# Calculate and print the number of valid TV sets\nprint(count_valid_tv_sets(a, b, x, y))"}
{"solution": "def prime_factors(n):\n    factors = {}\n    d = 2\n    while d * d <= n:\n        while (n % d) == 0:\n            factors[d] = factors.get(d, 0) + 1\n            n //= d\n        d += 1\n    if n > 1:\n       factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef count_factor_in_factorial(n, p):\n    count = 0\n    while n:\n        n //= p\n        count += n\n    return count\n\ndef count_trailing_zeros(n, b):\n    factors = prime_factors(b)\n    min_zeros = float('inf')\n    for p, exp in factors.items():\n        count = count_factor_in_factorial(n, p)\n        min_zeros = min(min_zeros, count // exp)\n    return min_zeros\n\n# Read input\nn, b = map(int, input().split())\n\n# Calculate and print the number of trailing zeros\nprint(count_trailing_zeros(n, b))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(m, a, b):\n    MOD = 10**9 + 7\n    g = gcd(a, b)\n    max_reachable = (m // g) * g + g - 1 if m % g != 0 else m\n    \n    dp = [0] * (max_reachable + 1)\n    dp[0] = 1\n    reachable_count = 1\n    sum_f = 1\n    \n    for i in range(1, max_reachable + 1):\n        if i >= a and dp[i - a] > 0:\n            dp[i] = dp[i - a]\n            for j in range(i + b, max_reachable + 1, b):\n                if dp[j] == 0:\n                    dp[j] = dp[i]\n                else:\n                    break\n        if dp[i] > 0:\n            reachable_count += 1\n        sum_f += reachable_count\n        sum_f %= MOD\n    \n    if m > max_reachable:\n        sum_f += (m - max_reachable) * reachable_count\n        sum_f %= MOD\n    \n    return sum_f\n\n# Read input\nm, a, b = map(int, input().split())\n\n# Print output\nprint(solve(m, a, b))"}
{"solution": "def can_divide_into_odd_subsegments(n, sequence):\n    # Check if the sequence length is odd and the first and last elements are odd\n    if n % 2 == 1 and sequence[0] % 2 == 1 and sequence[-1] % 2 == 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Output result\nprint(can_divide_into_odd_subsegments(n, sequence))"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    # Check if the trees are on the same vertical or horizontal line\n    if x1 == x2:\n        side_length = abs(y1 - y2)\n        x3, y3 = x1 + side_length, y1\n        x4, y4 = x2 + side_length, y2\n    elif y1 == y2:\n        side_length = abs(x1 - x2)\n        x3, y3 = x1, y1 + side_length\n        x4, y4 = x2, y2 + side_length\n    else:\n        # Check if the trees form a diagonal of the square\n        if abs(x1 - x2) != abs(y1 - y2):\n            return -1  # The trees do not form a square\n        x3, y3 = x1, y2\n        x4, y4 = x2, y1\n    \n    return f\"{x3} {y3} {x4} {y4}\"\n\n# Read input from the user\nx1, y1, x2, y2 = map(int, input().split())\n\n# Find and print the coordinates of the remaining trees\nprint(find_remaining_trees(x1, y1, x2, y2))"}
{"solution": "MOD = 1000000007\n\ndef calculate_f_n(x, y, n):\n    # The sequence repeats every 6 terms due to the recurrence relation\n    # f_i = f_{i-1} + f_{i+1}\n    sequence = [x, y, y - x, -x, -y, x - y]\n    # Adjust n to be zero-indexed and find the corresponding term in the sequence\n    n = (n - 1) % 6\n    return sequence[n] % MOD\n\n# Read input\nx, y = map(int, input().split())\nn = int(input())\n\n# Calculate and print the result\nprint(calculate_f_n(x, y, n))"}
{"solution": "def split_array(n, arr):\n    # Check if the entire array sum is not zero\n    if sum(arr) != 0:\n        return \"YES\", [(1, n)]\n    \n    # Try to find a split point where the sum of elements before and after the split are not zero\n    for i in range(1, n):\n        if sum(arr[:i]) != 0 and sum(arr[i:]) != 0:\n            return \"YES\", [(1, i), (i + 1, n)]\n    \n    # If no valid split point is found, return \"NO\"\n    return \"NO\", []\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Solve the problem\nresult, splits = split_array(n, arr)\n\n# Print the result\nprint(result)\nif result == \"YES\":\n    print(len(splits))\n    for l, r in splits:\n        print(l, r)"}
{"solution": "MOD = 1000000009\n\ndef min_score(n, m, k):\n    # Calculate the number of times the score can be doubled\n    double_opportunities = n // k\n    \n    # If Manao answered more questions than the opportunities to double,\n    # he must have used some of the opportunities to double the score\n    if m > double_opportunities:\n        # Calculate the number of times Manao used the doubling opportunity\n        used_doubling = (m - double_opportunities + k - 2) // (k - 1)\n        \n        # Calculate the score from the used doubling opportunities\n        score_from_doubling = (pow(2, used_doubling, MOD) - 1) * k % MOD\n        \n        # Calculate the remaining correct answers after using the doubling opportunities\n        remaining_correct = m - used_doubling * (k - 1)\n        \n        # Calculate the total score\n        total_score = (score_from_doubling + remaining_correct) % MOD\n    else:\n        # If Manao didn't use any doubling opportunities, his score is simply m\n        total_score = m\n    \n    return total_score\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Print the output\nprint(min_score(n, m, k))"}
{"solution": "def is_divisible_by_8(n):\n    # Check if the number itself is divisible by 8\n    if int(n) % 8 == 0:\n        return \"YES\", n\n    \n    # Check all possible combinations of the last three digits\n    for i in range(len(n)):\n        for j in range(i + 1, len(n)):\n            for k in range(j + 1, len(n)):\n                num = n[i] + n[j] + n[k]\n                if int(num) % 8 == 0:\n                    return \"YES\", num\n    \n    # Check all possible combinations of the last two digits\n    for i in range(len(n)):\n        for j in range(i + 1, len(n)):\n            num = n[i] + n[j]\n            if int(num) % 8 == 0:\n                return \"YES\", num\n    \n    # Check all possible single digits\n    for digit in n:\n        if int(digit) % 8 == 0:\n            return \"YES\", digit\n    \n    return \"NO\", \"\"\n\n# Read input\nn = input().strip()\n\n# Determine if it's possible and print the result\nresult, number = is_divisible_by_8(n)\nprint(result)\nif result == \"YES\":\n    print(number)"}
{"solution": "def determine_floor(n, m, memory):\n    possible_floors = set(range(1, 101))  # Initially, any number of flats per floor is possible\n\n    for k, f in memory:\n        new_possible_floors = set()\n        for flats_per_floor in possible_floors:\n            if (k - 1) // flats_per_floor + 1 == f:\n                new_possible_floors.add(flats_per_floor)\n        possible_floors = new_possible_floors\n\n    if len(possible_floors) == 1:\n        flats_per_floor = next(iter(possible_floors))\n        return (n - 1) // flats_per_floor + 1\n    else:\n        return -1\n\n# Read input\nn, m = map(int, input().split())\nmemory = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Determine and print the floor\nprint(determine_floor(n, m, memory))"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    board = [[board1[i], board2[i]] for i in range(n)]\n    \n    # Define the four possible shapes of the bishwock\n    bishwock_shapes = [\n        [(0, 0), (0, 1), (1, 0)],  # Original L shape\n        [(0, 0), (0, 1), (1, 1)],  # Rotated 90 degrees\n        [(0, 1), (1, 0), (1, 1)],  # Rotated 180 degrees\n        [(0, 0), (1, 0), (1, 1)]   # Rotated 270 degrees\n    ]\n    \n    def can_place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            if nx >= 2 or ny >= n or board[ny][nx] == 'X':\n                return False\n        return True\n    \n    def place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            board[ny][nx] = 'X'\n    \n    count = 0\n    for y in range(n):\n        for x in range(2):\n            for shape in bishwock_shapes:\n                if can_place_bishwock(x, y, shape):\n                    place_bishwock(x, y, shape)\n                    count += 1\n                    break\n    \n    return count"}
{"solution": "def max_pretty_set_length(n, s):\n    max_length = 0\n    current_set = set()\n    \n    for char in s:\n        if char.islower():\n            current_set.add(char)\n        else:\n            max_length = max(max_length, len(current_set))\n            current_set.clear()\n    \n    # Check the last segment\n    max_length = max(max_length, len(current_set))\n    \n    return max_length\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult = max_pretty_set_length(n, s)\n\n# Print the result\nprint(result)"}
{"solution": "def max_difference(n, a):\n    # Sort the sequence to make it easier to partition\n    a.sort()\n    \n    # Initialize sums for B and C\n    B = 0\n    C = 0\n    \n    # Assign elements to B or C based on their sign\n    for num in a:\n        if num >= 0:\n            B += num\n        else:\n            C += num\n    \n    # Return the maximum possible value of B - C\n    return B - C\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_difference(n, a))"}
{"solution": "def min_refuels(a, b, f, k):\n    if b < f or b < (a - f):\n        return -1\n    \n    fuel = b\n    refuels = 0\n    for i in range(k):\n        if i % 2 == 0:  # Going from 0 to a\n            if i == k - 1:  # Last journey\n                if fuel < (a - f) + (a if i > 0 else 0):\n                    fuel = b\n                    refuels += 1\n                if fuel < (a - f):\n                    return -1\n            else:\n                if fuel < 2 * (a - f):\n                    fuel = b\n                    refuels += 1\n                if fuel < (a - f):\n                    return -1\n            fuel -= a\n        else:  # Going from a to 0\n            if i == k - 1:  # Last journey\n                if fuel < f + (a if i > 0 else 0):\n                    fuel = b\n                    refuels += 1\n                if fuel < f:\n                    return -1\n            else:\n                if fuel < 2 * f:\n                    fuel = b\n                    refuels += 1\n                if fuel < f:\n                    return -1\n            fuel -= a\n    \n    return refuels\n\n# Read input\na, b, f, k = map(int, input().split())\n\n# Output the result\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    # Check if it's possible to split the string using only p or only q\n    if n % p == 0:\n        return [s[i:i+p] for i in range(0, n, p)], n // p\n    elif n % q == 0:\n        return [s[i:i+q] for i in range(0, n, q)], n // q\n    \n    # Try to find a combination of p and q that works\n    for i in range(1, n // p + 1):\n        remaining = n - i * p\n        if remaining % q == 0:\n            parts = [s[j:j+p] for j in range(0, i*p, p)]\n            parts += [s[i*p+k:i*p+k+q] for k in range(0, remaining, q)]\n            return parts, i + remaining // q\n    \n    return -1, -1\n\n# Read input\nn, p, q = map(int, input().split())\ns = input().strip()\n\n# Solve the problem\nresult, count = split_string(n, p, q, s)\n\n# Print the output\nif result == -1:\n    print(-1)\nelse:\n    print(count)\n    for part in result:\n        print(part)"}
{"solution": "def can_reach_finish(n, m, s, d, obstacles):\n    obstacles.sort()\n    actions = []\n    current_position = 0\n    \n    i = 0\n    while i < n:\n        # Find the next gap where we can run\n        next_obstacle = obstacles[i]\n        if next_obstacle - current_position < s:\n            return \"IMPOSSIBLE\"\n        \n        # Run to the start of the next jump\n        actions.append(f\"RUN {next_obstacle - current_position}\")\n        current_position = next_obstacle - 1\n        \n        # Find the end of the gap to jump over\n        j = i\n        while j < n and obstacles[j] - current_position <= d:\n            j += 1\n        \n        if j == i:\n            return \"IMPOSSIBLE\"\n        \n        # Jump over the obstacles\n        jump_length = obstacles[j - 1] - current_position\n        actions.append(f\"JUMP {jump_length}\")\n        current_position = obstacles[j - 1]\n        \n        i = j\n    \n    # Run to the finish if we are not already there\n    if current_position < m:\n        actions.append(f\"RUN {m - current_position}\")\n    \n    return \"\\n\".join(actions)\n\n# Read input\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\n# Output result\nprint(can_reach_finish(n, m, s, d, obstacles))"}
{"solution": "def count_ordered_pairs(s, x):\n    # Check if s - x is even and non-negative\n    if (s - x) % 2 != 0 or s < x:\n        return 0\n    \n    # Calculate b\n    b = (s - x) // 2\n    \n    # Check if a and b are positive integers\n    if b < 0 or s - b < 0:\n        return 0\n    \n    # Check if there are no conflicts with the XOR operation\n    if b & x != 0:\n        return 0\n    \n    # If there are no conflicts, there are 2 solutions for each valid pair\n    return 2\n\n# Read input\ns, x = map(int, input().split())\n\n# Print the number of solutions\nprint(count_ordered_pairs(s, x))"}
{"solution": "def min_actions_to_turn_over_skewers(n, k):\n    actions = []\n    for i in range(1, n + 1, 2 * k + 1):\n        actions.append(i + k if i + k <= n else i)\n    return len(actions), actions\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nnum_actions, actions = min_actions_to_turn_over_skewers(n, k)\nprint(num_actions)\nprint(' '.join(map(str, actions)))"}
{"solution": "import math\n\ndef min_operations_to_square(n):\n    n_str = str(n)\n    n_len = len(n_str)\n    \n    # Generate all possible squares up to the maximum possible value\n    max_square_root = int(math.sqrt(2 * 10**9)) + 1\n    squares = [str(i * i) for i in range(1, max_square_root + 1)]\n    \n    def is_subsequence(small, large):\n        it = iter(large)\n        return all(char in it for char in small)\n    \n    min_deletions = float('inf')\n    \n    for square in squares:\n        if is_subsequence(square, n_str):\n            deletions = n_len - len(square)\n            min_deletions = min(min_deletions, deletions)\n    \n    return min_deletions if min_deletions != float('inf') else -1\n\n# The function min_operations_to_square is designed to be called with the input integer n.\n# The result will be printed by the caller based on the function's return value."}
{"solution": "MOD = 10**9 + 7\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_permutations(n):\n    if n == 2:\n        return 1\n    if n == 3:\n        return 4\n    \n    # For n > 3, we need to find the maximum value of f(p) and count the permutations that achieve this value.\n    # The maximum value of f(p) is achieved when the GCD of the prefixes changes as much as possible.\n    # This happens when the permutation includes numbers that are relatively prime to each other.\n    \n    # We can use a dynamic programming approach to count the permutations that achieve the maximum f(p).\n    dp = [0] * (n + 1)\n    dp[1] = 1  # There's only one way to arrange a single element\n    dp[2] = 1  # For two elements, there's only one way to achieve f(p) = 1\n    \n    # For n > 2, we need to consider permutations that maximize the number of distinct GCDs.\n    # We can start by considering the smallest numbers and their combinations.\n    for i in range(3, n + 1):\n        # If i is prime, we can achieve the maximum f(p) by placing it at the start and arranging the rest.\n        # If i is composite, we need to consider its prime factors and how they affect the GCDs.\n        dp[i] = dp[i - 1] * i  # This is a simplification and may not be correct for all cases.\n    \n    return dp[n] % MOD\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the result\nprint(count_permutations(n))"}
{"solution": "def minimum_jump_ability(s):\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    positions = [-1]  # Start position before the first character\n    \n    # Collect positions of all vowels\n    for i, char in enumerate(s):\n        if char in vowels:\n            positions.append(i)\n    \n    positions.append(len(s))  # End position after the last character\n    \n    # Calculate maximum distance between consecutive positions\n    max_distance = 0\n    for i in range(1, len(positions)):\n        max_distance = max(max_distance, positions[i] - positions[i - 1])\n    \n    return max_distance\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(minimum_jump_ability(s))"}
{"solution": "def can_distribute_equally(a1, a2, a3, a4):\n    # Calculate the total number of candies\n    total_candies = a1 + a2 + a3 + a4\n    \n    # Check if the total number of candies is even\n    if total_candies % 2 != 0:\n        return \"NO\"\n    \n    # Calculate the half of the total number of candies\n    half_candies = total_candies // 2\n    \n    # Check if any combination of three bags sums up to half of the total candies\n    if (a1 + a2 == half_candies) or (a1 + a3 == half_candies) or (a1 + a4 == half_candies) or \\\n       (a2 + a3 == half_candies) or (a2 + a4 == half_candies) or (a3 + a4 == half_candies) or \\\n       (a1 == half_candies) or (a2 == half_candies) or (a3 == half_candies) or (a4 == half_candies):\n        return \"YES\"\n    \n    return \"NO\"\n\n# Read input\na1, a2, a3, a4 = map(int, input().split())\n\n# Output result\nprint(can_distribute_equally(a1, a2, a3, a4))"}
{"solution": "def maximize_pie_distribution(N, pie_sizes):\n    alice_total = 0\n    bob_total = 0\n    decider = 'Bob'\n\n    while pie_sizes:\n        if decider == 'Bob':\n            # Bob takes the largest slice available for himself\n            bob_total += pie_sizes.pop()\n            decider = 'Alice'\n        else:\n            # Alice gives the largest slice available to Bob and keeps the decider token\n            bob_total += pie_sizes.pop()\n            decider = 'Bob'\n\n    return alice_total, bob_total\n\n# Read input\nN = int(input().strip())\npie_sizes = list(map(int, input().strip().split()))\n\n# Ensure pie sizes are sorted in descending order\npie_sizes.sort(reverse=True)\n\n# Calculate the optimal distribution\nalice_total, bob_total = maximize_pie_distribution(N, pie_sizes)\n\n# Print the result\nprint(alice_total, bob_total)"}
{"solution": "def min_variables_needed(n, sequence):\n    # Sort the sequence to make it easier to find the minimum number of variables needed\n    sequence.sort()\n    \n    # If the sequence contains only one number, only one variable is needed\n    if n == 1:\n        return 1\n    \n    # If the smallest number in the sequence is not 1, it's impossible to generate the sequence\n    if sequence[0] != 1:\n        return -1\n    \n    # Initialize the count of variables needed\n    variables_needed = 1\n    \n    # Initialize a set to keep track of the sums we can generate with the variables\n    sums_generated = {1}\n    \n    # Iterate through the sequence starting from the second element\n    for num in sequence[1:]:\n        # If the current number is not in the set of generated sums, we need another variable\n        if num not in sums_generated:\n            variables_needed += 1\n            # Update the set of generated sums with the new variable\n            new_sums = set()\n            for s in sums_generated:\n                new_sums.add(s + num)\n            sums_generated.update(new_sums)\n        # Update the set of generated sums with the current number\n        sums_generated.add(num)\n    \n    return variables_needed\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Print the result\nprint(min_variables_needed(n, sequence))"}
{"solution": "def determine_winner(n, piles):\n    odd_count = sum(1 for pile in piles if pile % 2 != 0)\n    if odd_count % 2 == 0:\n        return \"Alice\"\n    else:\n        return \"Bob\"\n\n# Read input\nn = int(input())\npiles = list(map(int, input().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, piles))"}
{"solution": "def can_make_equal(n, arr):\n    unique_values = set(arr)\n    if len(unique_values) > 3:\n        return \"NO\"\n    if len(unique_values) == 1:\n        return \"YES\"\n    if len(unique_values) == 2:\n        return \"YES\"\n    if len(unique_values) == 3:\n        sorted_values = sorted(unique_values)\n        if sorted_values[1] - sorted_values[0] == sorted_values[2] - sorted_values[1]:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output the result\nprint(can_make_equal(n, arr))"}
{"solution": "def longest_non_overlapping_substring(N, S):\n    max_len = 0\n    for len in range(1, N):\n        for l1 in range(N - len):\n            for l2 in range(l1 + len + 1, N - len + 1):\n                if S[l1:l1 + len] == S[l2:l2 + len]:\n                    max_len = max(max_len, len)\n                    break  # No need to check further l2 for this len and l1\n            if max_len == len:\n                break  # No need to check further l1 for this len\n    return max_len\n\n# Read input\nN = int(input())\nS = input()\n\n# Output the result\nprint(longest_non_overlapping_substring(N, S))"}
{"solution": "def minimum_time_to_house(n, a):\n    if a % 2 == 1:\n        # a is odd\n        return (a + 1) // 2\n    else:\n        # a is even\n        return (n - a + 2) // 2\n\n# Read input\nn, a = map(int, input().split())\n\n# Calculate and print the result\nprint(minimum_time_to_house(n, a))"}
{"solution": "def can_select_jedi(n, m, colors, k_counts):\n    # Initialize a window to track the counts of each color\n    window_counts = [0] * (m + 1)\n    \n    # Iterate over all possible starting points of the window\n    for start in range(n):\n        # Reset the window counts\n        window_counts = [0] * (m + 1)\n        \n        # Try to expand the window from the current start point\n        for end in range(start, n):\n            # Update the count of the current color\n            window_counts[colors[end]] += 1\n            \n            # Check if the current window meets the required counts\n            if window_counts == k_counts:\n                return \"YES\"\n            \n            # If the current window exceeds the required counts, break\n            if window_counts > k_counts:\n                break\n    \n    # If no valid window is found, return \"NO\"\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\nk_counts = [0] + list(map(int, input().split()))  # Adjust for 1-based indexing\n\n# Output the result\nprint(can_select_jedi(n, m, colors, k_counts))"}
{"solution": "def determine_winner(n, rounds):\n    mishka_wins = 0\n    chris_wins = 0\n    \n    for m, c in rounds:\n        if m > c:\n            mishka_wins += 1\n        elif c > m:\n            chris_wins += 1\n    \n    if mishka_wins > chris_wins:\n        return \"Mishka\"\n    elif chris_wins > mishka_wins:\n        return \"Chris\"\n    else:\n        return \"Friendship is magic!^^\"\n\n# Read input from standard input\nn = int(input())\nrounds = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Determine and print the winner\nprint(determine_winner(n, rounds))"}
{"solution": "def is_valid_minesweeper_field(n, m, field):\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] != '.' and field[i][j] != '*':\n                bomb_count = 0\n                for x in range(max(0, i - 1), min(n, i + 2)):\n                    for y in range(max(0, j - 1), min(m, j + 2)):\n                        if field[x][y] == '*':\n                            bomb_count += 1\n                if bomb_count != int(field[i][j]):\n                    return \"NO\"\n            elif field[i][j] == '.':\n                for x in range(max(0, i - 1), min(n, i + 2)):\n                    for y in range(max(0, j - 1), min(m, j + 2)):\n                        if field[x][y] == '*':\n                            return \"NO\"\n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\n# Output result\nprint(is_valid_minesweeper_field(n, m, field))"}
{"solution": "def can_vasya_eat_half(n, k):\n    total_candies = n\n    vasya_eaten = 0\n    \n    while total_candies > 0:\n        # Vasya eats k candies\n        vasya_eaten += min(k, total_candies)\n        total_candies -= min(k, total_candies)\n        \n        # Petya eats 10% of the remaining candies\n        petya_eaten = total_candies // 10\n        total_candies -= petya_eaten\n    \n    return vasya_eaten >= (n + 1) // 2\n\ndef find_min_k(n):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Read input\nn = int(input().strip())\n\n# Find and print the minimal k\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace(s):\n    p = s.count('o')\n    l = s.count('-')\n    \n    if p == 0 or p == 1:\n        return \"YES\"\n    if l % p == 0:\n        return \"YES\"\n    return \"NO\""}
{"solution": "def max_frodo_pillows(n, m, k):\n    left = 1\n    right = m\n    while left < right:\n        mid = (left + right + 1) // 2\n        if is_valid_distribution(n, m, k, mid):\n            left = mid\n        else:\n            right = mid - 1\n    return left\n\ndef is_valid_distribution(n, m, k, frodo_pillows):\n    total_pillows = frodo_pillows\n    # Calculate pillows needed for the left side\n    for i in range(k - 1, 0, -1):\n        total_pillows += max(1, frodo_pillows - (k - i))\n        if total_pillows > m:\n            return False\n    # Calculate pillows needed for the right side\n    for i in range(k + 1, n + 1):\n        total_pillows += max(1, frodo_pillows - (i - k))\n        if total_pillows > m:\n            return False\n    return total_pillows <= m\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Calculate and print the result\nprint(max_frodo_pillows(n, m, k))"}
{"solution": "def max_subarray_cost(n, m, k, a):\n    max_cost = 0\n    current_sum = 0\n    penalty = 0\n    queue = []\n\n    for i in range(n):\n        current_sum += a[i]\n        if i >= m:\n            current_sum -= a[i - m]\n            penalty -= k * (queue.pop(0) if queue else 0)\n\n        penalty += k\n        while queue and queue[-1] > current_sum - penalty:\n            queue.pop()\n        queue.append(current_sum - penalty)\n\n        max_cost = max(max_cost, current_sum - penalty)\n\n    return max_cost\n\n# Reading input\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_subarray_cost(n, m, k, a))"}
{"solution": "def longest_polyline(n, m):\n    # The strategy to maximize the length is to use the diagonal as much as possible.\n    # We can achieve this by placing points at the corners and midpoints of the grid.\n    \n    # If both n and m are greater than 0, we can use the corners and midpoints.\n    if n > 0 and m > 0:\n        return [\n            (n, m),\n            (0, 0),\n            (n, 0),\n            (0, m)\n        ]\n    # If one of the dimensions is 0, we can only use the other dimension.\n    elif n == 0:\n        return [\n            (0, m),\n            (0, 0),\n            (0, 1),\n            (0, m-1)\n        ]\n    else:  # m == 0\n        return [\n            (n, 0),\n            (0, 0),\n            (1, 0),\n            (n-1, 0)\n        ]\n\n# Read input\nn, m = map(int, input().split())\n\n# Get the points for the longest polyline\npoints = longest_polyline(n, m)\n\n# Print the points\nfor point in points:\n    print(point[0], point[1])"}
{"solution": "def find_smallest_n(shuffled, remembered):\n    from collections import Counter\n    \n    # Count occurrences of each digit in the shuffled string and the remembered substring\n    shuffled_counter = Counter(shuffled)\n    remembered_counter = Counter(remembered)\n    \n    # Find the length of the original number n\n    k = len(shuffled) - len(remembered)\n    \n    # Subtract the remembered digits from the shuffled digits to find the digits of n\n    n_counter = shuffled_counter - remembered_counter\n    \n    # Extract the digits of n from the counter\n    n_digits = sorted(n_counter.elements())\n    \n    # If the remembered substring has leading zeros, we need to ensure that the smallest possible n\n    # does not have leading zeros unless n is zero itself\n    if remembered[0] == '0':\n        # Find the smallest non-zero digit in n to place at the beginning\n        for i, digit in enumerate(n_digits):\n            if digit != '0':\n                # Swap the smallest non-zero digit to the front\n                n_digits[0], n_digits[i] = n_digits[i], n_digits[0]\n                break\n    \n    # Combine the digits of n with the remembered substring to form the smallest possible n\n    n = ''.join(n_digits) + remembered\n    \n    return n\n\n# Read input\nshuffled = input().strip()\nremembered = input().strip()\n\n# Find and print the smallest possible n\nprint(find_smallest_n(shuffled, remembered))"}
{"solution": "def check_temperatures(n, m, min_temp, max_temp, temps):\n    # Check if the minimum and maximum temperatures are already in the list\n    if min_temp in temps and max_temp in temps:\n        return 'Correct'\n    \n    # Check if we can add the missing minimum or maximum temperature\n    if min_temp not in temps:\n        if len(temps) < n:\n            temps.append(min_temp)\n        else:\n            return 'Incorrect'\n    \n    if max_temp not in temps:\n        if len(temps) < n:\n            temps.append(max_temp)\n        else:\n            return 'Incorrect'\n    \n    # Check if the list can be extended to n elements without violating min and max\n    if len(temps) < n:\n        return 'Correct'\n    \n    return 'Incorrect'\n\n# Read input\nn, m, min_temp, max_temp = map(int, input().split())\ntemps = list(map(int, input().split()))\n\n# Check and print the result\nprint(check_temperatures(n, m, min_temp, max_temp, temps))"}
{"solution": "def trailing_zeroes_count(n):\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count\n\ndef find_numbers_with_m_trailing_zeroes(m):\n    low, high = 0, 5 * m\n    while low < high:\n        mid = (low + high) // 2\n        if trailing_zeroes_count(mid) < m:\n            low = mid + 1\n        else:\n            high = mid\n    \n    result = []\n    while trailing_zeroes_count(low) == m:\n        result.append(low)\n        low += 1\n    \n    return result\n\ndef main():\n    m = int(input().strip())\n    numbers = find_numbers_with_m_trailing_zeroes(m)\n    print(len(numbers))\n    if len(numbers) > 0:\n        print(' '.join(map(str, numbers)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from heapq import heappush, heappop\n\ndef dijkstra(graph, start, n):\n    # Initialize distances with infinity\n    distances = [float('inf')] * n\n    distances[start] = 0\n    max_cost = [0] * n\n    max_cost[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_vertex = heappop(pq)\n        \n        # If current_distance is greater than stored distance, skip\n        if current_distance > distances[current_vertex]:\n            continue\n        \n        for neighbor, weight in graph[current_vertex]:\n            # Update distance with the maximum weight encountered\n            distance = max(current_distance, weight)\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                max_cost[neighbor] = max(max_cost[current_vertex], weight)\n                heappush(pq, (distance, neighbor))\n    \n    return max_cost\n\ndef solve(n, m, k, special_vertices, edges):\n    # Create adjacency list for the graph\n    graph = [[] for _ in range(n)]\n    for u, v, w in edges:\n        graph[u-1].append((v-1, w))\n        graph[v-1].append((u-1, w))\n    \n    # Run Dijkstra's algorithm for each special vertex\n    farthest_distances = []\n    for sv in special_vertices:\n        max_cost = dijkstra(graph, sv-1, n)\n        # Find the maximum distance among all special vertices\n        farthest_distance = max(max_cost[sv-1] for sv in special_vertices)\n        farthest_distances.append(farthest_distance)\n    \n    return farthest_distances\n\n# Read input\nn, m, k = map(int, input().split())\nspecial_vertices = list(map(int, input().split()))\nedges = [list(map(int, input().split())) for _ in range(m)]\n\n# Solve the problem and print the output\nresult = solve(n, m, k, special_vertices, edges)\nprint(' '.join(map(str, result)))"}
{"solution": "def initial_position(n, x):\n    # The pattern of swaps results in a cycle of length 6 for any starting position.\n    # The cycles are as follows:\n    # - Starting at 0: 0 -> 1 -> 2 -> 1 -> 0 -> 2\n    # - Starting at 1: 1 -> 0 -> 1 -> 2 -> 1 -> 0\n    # - Starting at 2: 2 -> 1 -> 0 -> 1 -> 2 -> 1\n    # Therefore, we can reduce n modulo 6 to find the position after n moves.\n    n %= 6\n    \n    # Simulate the swaps based on the reduced n\n    for _ in range(n):\n        if x == 0:\n            x = 1\n        elif x == 1:\n            if _ % 2 == 0:\n                x = 0\n            else:\n                x = 2\n        else:  # x == 2\n            x = 1\n    \n    return x\n\n# Read input\nn = int(input())\nx = int(input())\n\n# Output the initial position\nprint(initial_position(n, x))"}
{"solution": "def rectangles_form_square(rectangles):\n    # Find the bounding box\n    min_x = min(rect[0] for rect in rectangles)\n    max_x = max(rect[2] for rect in rectangles)\n    min_y = min(rect[1] for rect in rectangles)\n    max_y = max(rect[3] for rect in rectangles)\n    \n    # Check if the bounding box is a square\n    if max_x - min_x != max_y - min_y:\n        return \"NO\"\n    \n    # Create a grid to check coverage\n    grid = [[0] * (max_x - min_x) for _ in range(max_y - min_y)]\n    \n    for x1, y1, x2, y2 in rectangles:\n        for x in range(x1 - min_x, x2 - min_x):\n            for y in range(y1 - min_y, y2 - min_y):\n                if grid[y][x] == 1:\n                    return \"NO\"  # Overlap detected\n                grid[y][x] = 1\n    \n    # Check if the entire grid is covered\n    for row in grid:\n        for cell in row:\n            if cell == 0:\n                return \"NO\"  # Gap detected\n    \n    return \"YES\"\n\n# Read input\nn = int(input())\nrectangles = [list(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(rectangles_form_square(rectangles))"}
{"solution": "def count_really_big_numbers(n, s):\n    count = 0\n    for x in range(s, n + 1):\n        if x - sum_of_digits(x) >= s:\n            count += 1\n    return count\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\n# Read input\nn, s = map(int, input().split())\n\n# Calculate and print the result\nprint(count_really_big_numbers(n, s))"}
{"solution": "def can_cover_with_two_lines(n, points):\n    if n <= 2:\n        return \"YES\"\n    \n    # Function to check if all points lie on a single line\n    def is_collinear(p1, p2, p3):\n        return (p1[0] - p2[0]) * (p1[1] - p3[1]) == (p1[0] - p3[0]) * (p1[1] - p2[1])\n    \n    # Try all combinations of three points to see if they form a line\n    for i in range(3):\n        for j in range(i + 1, 3):\n            for k in range(j + 1, 3):\n                if is_collinear(points[i], points[j], points[k]):\n                    line1 = [points[i], points[j], points[k]]\n                    break\n            else:\n                continue\n            break\n        else:\n            continue\n        break\n    else:\n        return \"NO\"  # If no three points form a line, it's impossible\n\n    # Separate the points into two groups: those on the found line and those not\n    line1_points = set(line1)\n    other_points = [p for p in points if p not in line1_points]\n\n    if not other_points:\n        return \"YES\"  # All points are collinear\n\n    # Check if all other points are collinear\n    for i in range(len(other_points)):\n        for j in range(i + 1, len(other_points)):\n            if all(is_collinear(other_points[i], other_points[j], p) for p in other_points):\n                return \"YES\"\n\n    return \"NO\"\n\n# Read input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(can_cover_with_two_lines(n, points))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_winning_games(a, b, k, t):\n    # Initialize a 2D list to store the number of ways to reach each score difference\n    dp = [[0] * (2 * k * t + 1) for _ in range(t + 1)]\n    offset = k * t  # Offset to handle negative scores\n\n    # Base case: 1 way to have a score difference of 0 after 0 turns\n    dp[0][offset] = 1\n\n    # Fill the DP table\n    for turn in range(1, t + 1):\n        # Use a sliding window to sum up the ways for the current turn\n        window = [0] * (2 * k * t + 1)\n        for i in range(2 * k * t + 1):\n            window[i] = (window[i - 1] if i > 0 else 0) + dp[turn - 1][i]\n\n        for score_diff in range(2 * k * t + 1):\n            dp[turn][score_diff] = (window[min(2 * k * t, score_diff + k)] - window[max(0, score_diff - k - 1)]) % MOD\n\n    # Calculate the total number of winning games\n    winning_games = 0\n    for score_diff in range(1, 2 * k * t + 1):\n        if score_diff - offset > 0:  # Memory wins if the score difference is positive\n            winning_games = (winning_games + dp[t][score_diff] * dp[t][score_diff - offset - 1]) % MOD\n\n    return winning_games\n\n# Read input\na, b, k, t = map(int, input().split())\n\n# Calculate and print the result\nprint(count_winning_games(a, b, k, t))"}
{"solution": "def min_additional_marks(n, l, x, y, marks):\n    def can_measure(distance):\n        for mark in marks:\n            if mark + distance in marks or mark - distance in marks:\n                return True\n        return False\n\n    need_x = not can_measure(x)\n    need_y = not can_measure(y)\n\n    if not need_x and not need_y:\n        return 0, []\n\n    for mark in marks:\n        if need_x and (mark + x <= l and mark + x not in marks):\n            if (not need_y or can_measure(y)) and mark + x not in marks:\n                return 1, [mark + x]\n            if need_y and mark + x + y <= l and mark + x + y not in marks:\n                return 1, [mark + x]\n            if need_y and mark + x - y >= 0 and mark + x - y not in marks:\n                return 1, [mark + x]\n        if need_y and (mark + y <= l and mark + y not in marks):\n            if (not need_x or can_measure(x)) and mark + y not in marks:\n                return 1, [mark + y]\n            if need_x and mark + y + x <= l and mark + y + x not in marks:\n                return 1, [mark + y]\n            if need_x and mark + y - x >= 0 and mark + y - x not in marks:\n                return 1, [mark + y]\n\n    if need_x and need_y:\n        return 2, [x, y]\n    elif need_x:\n        return 1, [x]\n    else:\n        return 1, [y]\n\n# Read input\nn, l, x, y = map(int, input().split())\nmarks = set(map(int, input().split()))\n\n# Calculate and print the result\nnum_marks, new_marks = min_additional_marks(n, l, x, y, marks)\nprint(num_marks)\nif num_marks > 0:\n    print(' '.join(map(str, new_marks)))"}
{"solution": "def max_cake_volume(n, cakes):\n    # Calculate the volume of each cake\n    volumes = [cake[0]**2 * cake[1] for cake in cakes]\n    \n    # Initialize a list to store the maximum volume achievable with each cake on top\n    max_volumes = [0] * n\n    \n    # The first cake can only be on its own\n    max_volumes[0] = volumes[0]\n    \n    # Iterate through each cake to find the maximum volume achievable\n    for i in range(1, n):\n        max_volumes[i] = volumes[i]\n        for j in range(i):\n            if volumes[i] > volumes[j]:\n                max_volumes[i] = max(max_volumes[i], max_volumes[j] + volumes[i])\n    \n    # The answer is the maximum volume found\n    return max(max_volumes) * 3.141592653589793\n\n# Read input\nn = int(input())\ncakes = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(\"{:.9f}\".format(max_cake_volume(n, cakes)))"}
{"solution": "def min_good_slices(n, k, heights):\n    heights.sort()\n    prefix_sums = [0] * (max(heights) + 1)\n    \n    # Calculate prefix sums of the number of towers at each height\n    for height in heights:\n        prefix_sums[height] += 1\n    for i in range(1, len(prefix_sums)):\n        prefix_sums[i] += prefix_sums[i - 1]\n    \n    # Calculate suffix sums of the number of cubes removed if slicing at each height\n    suffix_sums = [0] * (max(heights) + 1)\n    for i in range(len(suffix_sums) - 2, -1, -1):\n        suffix_sums[i] = suffix_sums[i + 1] + prefix_sums[i + 1]\n    \n    # Find the minimum number of good slices\n    slices = 0\n    current_height = max(heights)\n    while current_height > 0:\n        cost = suffix_sums[current_height]\n        if cost <= k:\n            slices += 1\n            k -= cost\n            current_height -= 1\n        else:\n            break\n    \n    return slices\n\n# Read input\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Print output\nprint(min_good_slices(n, k, heights))"}
{"solution": "def max_score(n, a):\n    # Calculate prefix sums\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n    \n    max_score = float('-inf')\n    \n    # Iterate over all possible segments [l, r]\n    for l in range(n):\n        max_in_segment = float('-inf')\n        for r in range(l, n):\n            # Update the maximum value in the current segment\n            max_in_segment = max(max_in_segment, a[r])\n            # Calculate the sum of the current segment\n            segment_sum = prefix_sum[r + 1] - prefix_sum[l]\n            # Calculate the score after Bob removes the max value\n            score = segment_sum - max_in_segment\n            # Update the maximum score\n            max_score = max(max_score, score)\n    \n    return max_score\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_score(n, a))"}
{"solution": "def can_garlands_be_lit(k1, k2, k3):\n    # Sort the intervals to simplify the logic\n    intervals = sorted([k1, k2, k3])\n    \n    # Check if the smallest two intervals are 1 and 2, which can always cover all seconds\n    if intervals[:2] == [1, 2]:\n        return \"YES\"\n    \n    # Check if the smallest interval is 1, which can be combined with other intervals to cover all seconds\n    if intervals[0] == 1:\n        return \"YES\"\n    \n    # Check if the smallest interval is 2 and the next one is 2 or 3, which can cover all seconds\n    if intervals[:2] in ([2, 2], [2, 3]):\n        return \"YES\"\n    \n    # Check if the intervals are 3, 3, and some other interval, which can cover all seconds\n    if intervals == [3, 3, 3]:\n        return \"YES\"\n    \n    # If none of the above conditions are met, it's not possible to cover all seconds\n    return \"NO\"\n\n# Read input\nk1, k2, k3 = map(int, input().split())\n\n# Output result\nprint(can_garlands_be_lit(k1, k2, k3))"}
{"solution": "def min_operations_to_delete_string(n, s):\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = 1\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j-1]\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n    \n    return dp[0][n-1]\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "def max_pairs(boys, girls):\n    boys.sort()\n    girls.sort()\n    pairs = 0\n    i, j = 0, 0\n    while i < len(boys) and j < len(girls):\n        if abs(boys[i] - girls[j]) <= 1:\n            pairs += 1\n            i += 1\n            j += 1\n        elif boys[i] < girls[j]:\n            i += 1\n        else:\n            j += 1\n    return pairs\n\n# Read input\nn = int(input())\nboys_skills = list(map(int, input().split()))\nm = int(input())\ngirls_skills = list(map(int, input().split()))\n\n# Output the result\nprint(max_pairs(boys_skills, girls_skills))"}
{"solution": "def determine_winner(skills):\n    # Extract skills for easier reference\n    a1, b1 = skills[0]\n    a2, b2 = skills[1]\n    a3, b3 = skills[2]\n    a4, b4 = skills[3]\n\n    # Check if Team 1 can guarantee a win\n    if (a1 > b3 and b2 > a4) and (a1 > b4 and b2 > a3):\n        return \"Team 1\"\n    if (a2 > b3 and b1 > a4) and (a2 > b4 and b1 > a3):\n        return \"Team 1\"\n\n    # Check if Team 2 can guarantee a win\n    if (a3 > b1 and b4 > a2) and (a3 > b2 and b4 > a1):\n        return \"Team 2\"\n    if (a4 > b1 and b3 > a2) and (a4 > b2 and b3 > a1):\n        return \"Team 2\"\n\n    # If neither team can guarantee a win\n    return \"Draw\"\n\n# Read input\nskills = [tuple(map(int, input().split())) for _ in range(4)]\n\n# Determine the winner\nprint(determine_winner(skills))"}
{"solution": "import sys\nimport math\n\ndef read_input():\n    N, K = map(int, input().split())\n    meats = [list(map(int, input().split())) for _ in range(N)]\n    return N, K, meats\n\ndef calculate_time(X, Y, meat):\n    x_i, y_i, c_i = meat\n    return c_i * math.sqrt((X - x_i) ** 2 + (Y - y_i) ** 2)\n\ndef find_optimal_heat_source(N, K, meats):\n    # Define the search space for X and Y\n    min_X, max_X = min(meats, key=lambda x: x[0])[0], max(meats, key=lambda x: x[0])[0]\n    min_Y, max_Y = min(meats, key=lambda x: x[1])[1], max(meats, key=lambda x: x[1])[1]\n    \n    # Initialize the minimum time to a large number\n    min_time = float('inf')\n    \n    # Perform a grid search within the defined space\n    for X in range(min_X, max_X + 1):\n        for Y in range(min_Y, max_Y + 1):\n            # Calculate the time for each meat piece to be ready\n            times = [calculate_time(X, Y, meat) for meat in meats]\n            # Sort the times and take the K-th smallest time\n            times.sort()\n            min_time = min(min_time, times[K - 1])\n    \n    return min_time\n\ndef main():\n    N, K, meats = read_input()\n    result = find_optimal_heat_source(N, K, meats)\n    print(f\"{result:.6f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def determine_winner(n, ticket):\n    # Initialize counters for the sums of the first and second halves, and for the number of '?' in each half\n    sum_first_half = sum_second_half = 0\n    question_marks_first_half = question_marks_second_half = 0\n\n    # Calculate the sums and counts for each half\n    for i in range(n // 2):\n        if ticket[i] != '?':\n            sum_first_half += int(ticket[i])\n        else:\n            question_marks_first_half += 1\n        if ticket[n // 2 + i] != '?':\n            sum_second_half += int(ticket[n // 2 + i])\n        else:\n            question_marks_second_half += 1\n\n    # Calculate the net effect of replacing '?' with digits\n    net_question_marks = question_marks_first_half - question_marks_second_half\n    net_sum = sum_first_half - sum_second_half\n\n    # If the net number of '?' is zero, the game is decided by the sums\n    if net_question_marks == 0:\n        return \"Bicarp\" if net_sum == 0 else \"Monocarp\"\n\n    # If the net number of '?' is positive, Monocarp can always prevent Bicarp from making the ticket happy\n    if net_question_marks > 0:\n        return \"Monocarp\" if net_sum >= 0 or net_sum + 9 * net_question_marks < 0 else \"Bicarp\"\n\n    # If the net number of '?' is negative, Monocarp can always prevent Bicarp from making the ticket happy\n    if net_question_marks < 0:\n        return \"Monocarp\" if net_sum <= 0 or net_sum - 9 * abs(net_question_marks) > 0 else \"Bicarp\"\n\n# Read input\nn = int(input())\nticket = input()\n\n# Determine the winner and print the result\nprint(determine_winner(n, ticket))"}
{"solution": "def find_bus_route(n, t, bus_routes):\n    earliest_time = float('inf')\n    chosen_route = -1\n    \n    for i in range(n):\n        s_i, d_i = bus_routes[i]\n        \n        if s_i >= t:\n            next_bus_time = s_i\n        else:\n            # Calculate the next bus time after t\n            if (t - s_i) % d_i == 0:\n                next_bus_time = t\n            else:\n                next_bus_time = s_i + ((t - s_i) // d_i + 1) * d_i\n        \n        if next_bus_time < earliest_time:\n            earliest_time = next_bus_time\n            chosen_route = i + 1\n    \n    return chosen_route\n\n# Read input\nn, t = map(int, input().split())\nbus_routes = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(find_bus_route(n, t, bus_routes))"}
{"solution": "def find_n(m, k):\n    # Initialize n to a value that ensures we can find at least m numbers with k ones in binary\n    n = (1 << (k - 1)) - 1  # Start with the smallest number that has k ones in binary\n\n    # Function to count numbers with exactly k ones in binary within a range\n    def count_k_ones(start, end):\n        count = 0\n        for i in range(start, end + 1):\n            if bin(i).count('1') == k:\n                count += 1\n        return count\n\n    # Adjust n until we find exactly m numbers with k ones in binary in the range [n+1, 2*n]\n    while True:\n        count = count_k_ones(n + 1, 2 * n)\n        if count == m:\n            return n\n        n += 1\n\n# Example usage:\n# m, k = map(int, input().split())\n# print(find_n(m, k))"}
{"solution": "def is_good_level(n, level_scheme):\n    # Iterate through the level scheme to find sequences of platforms\n    for i in range(n):\n        # Check if there's enough space for a sequence of 5 platforms with equal intervals\n        for interval in range(1, (n - i) // 4 + 1):\n            if all(level_scheme[i + j * interval] == '*' for j in range(5)):\n                return \"yes\"\n    return \"no\"\n\n# Read input\nn = int(input())\nlevel_scheme = input()\n\n# Check if the level is good and print the result\nprint(is_good_level(n, level_scheme))"}
{"solution": "def find_magic_number(grid, n):\n    # Find the position of the empty cell\n    empty_row, empty_col = None, None\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                empty_row, empty_col = i, j\n                break\n        if empty_row is not None:\n            break\n\n    # Calculate the target sum by summing up a row or column without the empty cell\n    target_sum = sum(grid[empty_row]) if empty_row < n - 1 else sum(grid[0])\n\n    # Calculate the sum of the main diagonal and the secondary diagonal\n    main_diag_sum = sum(grid[i][i] for i in range(n) if i != empty_row or i != empty_col)\n    secondary_diag_sum = sum(grid[i][n - i - 1] for i in range(n) if i != empty_row or n - i - 1 != empty_col)\n\n    # Check if the diagonals can match the target sum\n    if n > 1 and (main_diag_sum != target_sum or secondary_diag_sum != target_sum):\n        return -1\n\n    # Calculate the number to fill in the empty cell\n    missing_number = target_sum - sum(grid[empty_row])\n\n    # Check if the missing number is positive and fits within the constraints\n    if missing_number <= 0 or missing_number > 10**18:\n        return -1\n\n    # Verify the grid with the missing number\n    grid[empty_row][empty_col] = missing_number\n    for i in range(n):\n        if sum(grid[i]) != target_sum or sum(grid[j][i] for j in range(n)) != target_sum:\n            return -1\n    if sum(grid[i][i] for i in range(n)) != target_sum or sum(grid[i][n - i - 1] for i in range(n)) != target_sum:\n        return -1\n\n    return missing_number\n\n# Read input\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\n# Find and print the magic number\nprint(find_magic_number(grid, n))"}
{"solution": "import math\n\ndef calculate_min_max_k(n, m, a):\n    max_k = max(a) + m\n    total_people = sum(a) + m\n    min_k = math.ceil(total_people / n)\n    return min_k, max_k\n\n# Read input\nn = int(input())\nm = int(input())\na = [int(input()) for _ in range(n)]\n\n# Calculate and print the result\nmin_k, max_k = calculate_min_max_k(n, m, a)\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, m):\n    # Initialize the result\n    result = 0\n    \n    # Calculate the number of ways for each possible number of unique seats assigned\n    for unique_seats in range(1, min(n, m) + 1):\n        # Calculate the number of ways to choose unique_seats from n seats\n        choose_seats = binomial_coefficient(n, unique_seats)\n        \n        # Calculate the number of ways to assign these unique_seats to m passengers\n        assign_seats = pow(unique_seats, m, MOD)\n        \n        # Calculate the number of ways to choose the entrance for each unique seat\n        choose_entrance = pow(2, unique_seats, MOD)\n        \n        # Add the product of these to the result\n        result += (choose_seats * assign_seats * choose_entrance) % MOD\n        result %= MOD\n    \n    return result\n\ndef binomial_coefficient(n, k):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c % MOD\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(count_ways(n, m))"}
{"solution": "from itertools import combinations\nfrom collections import defaultdict\n\ndef read_input():\n    n, m = map(int, input().split())\n    friends_preferences = [set(map(int, input().split()[1:])) for _ in range(n)]\n    pizzas = [list(map(int, input().split())) for _ in range(m)]\n    return n, m, friends_preferences, pizzas\n\ndef solve(n, m, friends_preferences, pizzas):\n    # Convert pizza descriptions to a more convenient form\n    pizza_details = [(set(p[2:]), p[0]) for p in pizzas]\n    \n    # Initialize variables to store the best result\n    max_pleased_friends = 0\n    min_total_cost = float('inf')\n    best_pair = None\n    \n    # Iterate over all pairs of pizzas\n    for (pizza1_ingredients, cost1), (pizza2_ingredients, cost2) in combinations(pizza_details, 2):\n        combined_ingredients = pizza1_ingredients | pizza2_ingredients\n        pleased_friends = sum(all(pref.intersection(combined_ingredients) for pref in friends_preferences) for pref in friends_preferences)\n        \n        # Check if this pair is better than the current best\n        if pleased_friends > max_pleased_friends or (pleased_friends == max_pleased_friends and cost1 + cost2 < min_total_cost):\n            max_pleased_friends = pleased_friends\n            min_total_cost = cost1 + cost2\n            best_pair = (pizza1_ingredients, pizza2_ingredients)\n    \n    # Find the indices of the best pair of pizzas\n    best_indices = [i for i, p in enumerate(pizza_details) if p[0] in best_pair][:2]\n    \n    return best_indices[0] + 1, best_indices[1] + 1  # Convert to 1-based indexing\n\n# Read input and solve the problem\nn, m, friends_preferences, pizzas = read_input()\nj1, j2 = solve(n, m, friends_preferences, pizzas)\nprint(j1, j2)"}
{"solution": "def find_numbers(m, s):\n    # If the sum is zero and m is greater than 1, it's impossible to form a number without leading zeroes\n    if s == 0:\n        return \"-1 -1\" if m > 1 else \"0 0\"\n    \n    # If the sum is greater than the maximum possible sum for the given length, it's impossible\n    if s > 9 * m:\n        return \"-1 -1\"\n    \n    # Find the smallest number\n    smallest = \"\"\n    sum_left = s\n    for i in range(m):\n        for digit in range(10):\n            if (smallest or digit > 0) and (sum_left - digit <= 9 * (m - i - 1)):\n                smallest += str(digit)\n                sum_left -= digit\n                break\n    \n    # Find the largest number\n    largest = \"\"\n    sum_left = s\n    for i in range(m):\n        for digit in range(9, -1, -1):\n            if sum_left - digit >= 0 and sum_left - digit <= 9 * (m - i - 1):\n                largest += str(digit)\n                sum_left -= digit\n                break\n    \n    return f\"{smallest} {largest}\"\n\n# Read input\nm, s = map(int, input().split())\n\n# Print output\nprint(find_numbers(m, s))"}
{"solution": "MOD = 998244353\n\ndef count_digits(n):\n    return len(set(str(n)))\n\ndef sum_with_constraints(l, r, k):\n    total_sum = 0\n    for number in range(l, r + 1):\n        if count_digits(number) <= k:\n            total_sum += number\n            total_sum %= MOD\n    return total_sum\n\n# Read input\nl, r, k = map(int, input().split())\n\n# Calculate and print the result\nprint(sum_with_constraints(l, r, k))"}
{"solution": "def can_distribute_pencils(n, k, d, saturations):\n    # Sort the saturations to make it easier to check the difference condition\n    saturations.sort()\n    \n    # Initialize a dynamic programming array to keep track of the possibility\n    # of distributing pencils up to a certain point\n    dp = [False] * (n + 1)\n    dp[0] = True  # Base case: no pencils means it's trivially true\n    \n    # Iterate through the sorted saturations to update the dp array\n    for i in range(k, n + 1):\n        # Check if we can form a box ending at i with at least k pencils\n        if i >= k and dp[i - k]:\n            # Check if the difference condition is satisfied for this box\n            if saturations[i - 1] - saturations[i - k] <= d:\n                dp[i] = True\n        # If we can't form a box of size k, try smaller sizes\n        else:\n            for j in range(1, k):\n                if i >= j and dp[i - j] and saturations[i - 1] - saturations[i - j] <= d:\n                    dp[i] = True\n                    break\n    \n    # The answer is whether it's possible to distribute all pencils (dp[n])\n    return \"YES\" if dp[n] else \"NO\"\n\n# Read input\nn, k, d = map(int, input().split())\nsaturations = list(map(int, input().split()))\n\n# Print the result\nprint(can_distribute_pencils(n, k, d, saturations))"}
{"solution": "def count_dead_bulbs(garland):\n    # Initialize a dictionary to store the count of dead bulbs for each color\n    dead_bulbs = {'R': 0, 'B': 0, 'Y': 0, 'G': 0}\n    \n    # Initialize a dictionary to store the position of the last working bulb for each color\n    positions = {'R': None, 'B': None, 'Y': None, 'G': None}\n    \n    # Find the positions of the last working bulb for each color\n    for i, bulb in enumerate(garland):\n        if bulb in positions:\n            positions[bulb] = i\n    \n    # Calculate the number of dead bulbs for each color\n    for i, bulb in enumerate(garland):\n        if bulb == '!':\n            # Determine the color of the dead bulb based on the position of the last working bulb\n            for color, pos in positions.items():\n                if pos is not None and (i - pos) % 4 == 0:\n                    dead_bulbs[color] += 1\n                    break\n    \n    # Return the count of dead bulbs for each color\n    return dead_bulbs['R'], dead_bulbs['B'], dead_bulbs['Y'], dead_bulbs['G']\n\n# Read input\ngarland = input().strip()\n\n# Get the count of dead bulbs for each color\nkr, kb, ky, kg = count_dead_bulbs(garland)\n\n# Print the result\nprint(kr, kb, ky, kg)"}
{"solution": "import sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heapq.heappush(pq, (dist[v], v))\n    return dist\n\ndef solve(n, m, edges):\n    graph = {i: [] for i in range(1, n + 1)}\n    reverse_graph = {i: [] for i in range(1, n + 1)}\n    for s, t in edges:\n        graph[s].append((t, 1))\n        reverse_graph[t].append((s, 1))\n\n    # Calculate the shortest path from each room to the exit (Room N)\n    shortest_path_to_exit = dijkstra(reverse_graph, n, n)\n\n    # Calculate the expected number of passages without blocking any passage\n    expected_passages = [0] * (n + 1)\n    probability = [0] * (n + 1)\n    probability[n] = 1\n    for i in range(n - 1, 0, -1):\n        total_prob = 0\n        for v, _ in graph[i]:\n            total_prob += probability[v]\n        for v, _ in graph[i]:\n            probability[i] += probability[v] / total_prob\n            expected_passages[i] += (expected_passages[v] + 1) / total_prob\n\n    # Find the minimum expected number of passages by blocking one passage\n    min_expected = expected_passages[1]\n    for s, t in edges:\n        if shortest_path_to_exit[s] == 1 + shortest_path_to_exit[t]:\n            # Temporarily block this passage and recalculate the expected number of passages\n            temp_graph = {i: [] for i in range(1, n + 1)}\n            for u, v in edges:\n                if (u, v) != (s, t):\n                    temp_graph[u].append((v, 1))\n            temp_expected_passages = [0] * (n + 1)\n            temp_probability = [0] * (n + 1)\n            temp_probability[n] = 1\n            for i in range(n - 1, 0, -1):\n                total_prob = 0\n                for v, _ in temp_graph[i]:\n                    total_prob += temp_probability[v]\n                for v, _ in temp_graph[i]:\n                    temp_probability[i] += temp_probability[v] / total_prob\n                    temp_expected_passages[i] += (temp_expected_passages[v] + 1) / total_prob\n            min_expected = min(min_expected, temp_expected_passages[1])\n\n    return min_expected\n\n# Read input\ninput_data = sys.stdin.readlines()\nn, m = map(int, input_data[0].split())\nedges = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n# Solve the problem and print the result\nprint(f\"{solve(n, m, edges):.10f}\")"}
{"solution": "def round_to_nearest_zero(n):\n    if n % 10 == 0:\n        return n\n    lower = n - (n % 10)\n    upper = lower + 10\n    return lower if n - lower <= upper - n else upper\n\n# Assuming the input is provided through a standard input method (e.g., input() function)\nn = int(input())\nprint(round_to_nearest_zero(n))"}
{"solution": "def find_swaps(s, t):\n    if len(s) != len(t):\n        return -1\n    \n    mismatches = {}\n    \n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if s[i] in mismatches and mismatches[s[i]] != t[i]:\n                return -1\n            if t[i] in mismatches and mismatches[t[i]] != s[i]:\n                return -1\n            mismatches[s[i]] = t[i]\n            mismatches[t[i]] = s[i]\n    \n    visited = set()\n    swaps = []\n    \n    for key in mismatches:\n        if key not in visited:\n            cycle = []\n            current = key\n            while current not in visited:\n                visited.add(current)\n                cycle.append(current)\n                current = mismatches[current]\n            if len(cycle) != 2:\n                return -1\n            swaps.append((cycle[0], cycle[1]))\n    \n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0], swap[1])"}
{"solution": "def alphabetically_earliest_login(first_name, last_name):\n    earliest_login = None\n    for i in range(1, len(first_name) + 1):\n        for j in range(1, len(last_name) + 1):\n            login = first_name[:i] + last_name[:j]\n            if earliest_login is None or login < earliest_login:\n                earliest_login = login\n    return earliest_login\n\n# Assuming the input is provided in the correct format as described\nfirst_name, last_name = input().split()\nprint(alphabetically_earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(sequence):\n    n = len(sequence)\n    height = 0\n    current_height = 0\n    heights = []\n\n    # Calculate the height for each bracket\n    for bracket in sequence:\n        if bracket == '[':\n            current_height += 1\n            heights.append(current_height)\n            height = max(height, current_height)\n        else:\n            current_height -= 1\n            heights.append(current_height)\n\n    # Prepare the output\n    output = [[' ' for _ in range(n * 4 + 1)] for _ in range(height * 2 + 1)]\n\n    def draw_vertical(x, y, length):\n        for i in range(length):\n            output[x + i][y] = '|'\n\n    def draw_horizontal(x, y, length):\n        for i in range(length):\n            output[x][y + i] = '-'\n\n    def draw_plus(x, y):\n        output[x][y] = '+'\n\n    x = height * 2\n    y = 0\n\n    for i, bracket in enumerate(sequence):\n        if bracket == '[':\n            draw_horizontal(x, y, 4)\n            draw_plus(x, y)\n            draw_plus(x, y + 3)\n            draw_vertical(x - heights[i] * 2 + 1, y, heights[i] * 2)\n            y += 1\n        else:\n            y -= 1\n            draw_horizontal(x, y, 4)\n            draw_plus(x, y)\n            draw_plus(x, y + 3)\n            draw_vertical(x - heights[i] * 2 + 1, y + 3, heights[i] * 2)\n        y += 3\n\n    # Print the output\n    for line in output:\n        print(''.join(line).rstrip())\n\n# Read input\nn = int(input())\nsequence = input()\n\n# Draw the brackets\ndraw_brackets(sequence)"}
{"solution": "def normalize_golden_number(golden_number):\n    golden_number = list(map(int, golden_number))\n    n = len(golden_number)\n    \n    for i in range(n - 1, 0, -1):\n        if golden_number[i] > 1:\n            golden_number[i] -= 2\n            golden_number[i - 1] += 1\n            if i - 2 >= 0:\n                golden_number[i - 2] += 1\n    \n    while len(golden_number) > 1 and golden_number[0] == 0:\n        golden_number.pop(0)\n    \n    return golden_number\n\ndef compare_golden_numbers(num1, num2):\n    norm_num1 = normalize_golden_number(num1)\n    norm_num2 = normalize_golden_number(num2)\n    \n    if len(norm_num1) > len(norm_num2):\n        return \">\"\n    elif len(norm_num1) < len(norm_num2):\n        return \"<\"\n    \n    for digit1, digit2 in zip(norm_num1, norm_num2):\n        if digit1 > digit2:\n            return \">\"\n        elif digit1 < digit2:\n            return \"<\"\n    \n    return \"=\"\n\nnum1 = input().strip()\nnum2 = input().strip()\n\nresult = compare_golden_numbers(num1, num2)\nprint(result)"}
{"solution": "def determine_absent_gems(n, seen_colors):\n    # Define the mapping of colors to gem names\n    color_to_gem = {\n        \"purple\": \"Power\",\n        \"green\": \"Time\",\n        \"blue\": \"Space\",\n        \"orange\": \"Soul\",\n        \"red\": \"Reality\",\n        \"yellow\": \"Mind\"\n    }\n    \n    # Determine the absent colors by subtracting seen colors from all colors\n    all_colors = set(color_to_gem.keys())\n    absent_colors = all_colors - set(seen_colors)\n    \n    # Convert absent colors to gem names\n    absent_gems = [color_to_gem[color] for color in absent_colors]\n    \n    # Output the number of absent gems and their names\n    print(len(absent_gems))\n    for gem in absent_gems:\n        print(gem)\n\n# Read input\nn = int(input())\nseen_colors = [input().strip() for _ in range(n)]\n\n# Determine and print the absent gems\ndetermine_absent_gems(n, seen_colors)"}
{"solution": "def determine_meeting_round(n, a, b):\n    round_number = 1\n    while n > 1:\n        # Check if a and b are in the same pair in the current round\n        if (a + 1) // 2 == (b + 1) // 2:\n            break\n        # Move to the next round\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n //= 2\n        round_number += 1\n    \n    # If the round is the final one\n    if n == 2:\n        return \"Final!\"\n    else:\n        return round_number\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Output the result\nprint(determine_meeting_round(n, a, b))"}
{"solution": "def min_changes_to_permutation_and_sequence(n, p, b):\n    # Check if the permutation is already a cycle that visits all positions\n    visited = [False] * n\n    cycles = []\n    for i in range(n):\n        if not visited[i]:\n            cycle = []\n            while not visited[i]:\n                visited[i] = True\n                cycle.append(i)\n                i = p[i] - 1\n            cycles.append(cycle)\n    \n    # If there's only one cycle and all elements in b are 0, we need to change one element in b\n    if len(cycles) == 1 and all(x == 0 for x in b):\n        return 1\n    \n    # If there are multiple cycles, we need to change the permutation to form a single cycle\n    if len(cycles) > 1:\n        return len(cycles)\n    \n    # If there's only one cycle and there's at least one '1' in b, no changes are needed\n    return 0\n\n# Read input\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_changes_to_permutation_and_sequence(n, p, b))"}
{"solution": "def max_path_length(v_1, v_2, t, d):\n    # Initialize the list to store speeds for each second\n    speeds = [0] * t\n    speeds[0] = v_1  # Speed at the beginning\n    speeds[-1] = v_2  # Speed at the end\n\n    # Calculate the maximum possible speed for each second from the start\n    for i in range(1, t):\n        speeds[i] = min(speeds[i-1] + d, v_2 + d * (t - 1 - i))\n\n    # Calculate the maximum possible speed for each second from the end\n    for i in range(t - 2, -1, -1):\n        speeds[i] = min(speeds[i], speeds[i+1] + d)\n\n    # Calculate the total path length\n    total_length = sum(speeds)\n\n    return total_length\n\n# Read input\nv_1, v_2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Calculate and print the maximum possible length of the path segment\nprint(max_path_length(v_1, v_2, t, d))"}
{"solution": "from itertools import permutations\n\ndef can_cross_bridge(N, M, weights, bridge_parts):\n    def check_arrangement(arrangement, distances):\n        for l, v in bridge_parts:\n            max_weight_in_part = 0\n            for i in range(N - 1):\n                for j in range(i + 1, N):\n                    if distances[i] < l and distances[j] - distances[i] < l:\n                        max_weight_in_part = max(max_weight_in_part, sum(weights[arrangement[k] - 1] for k in range(i, j + 1))))\n            if max_weight_in_part > v:\n                return False\n        return True\n\n    min_distance = float('inf')\n    for arrangement in permutations(range(1, N + 1)):\n        low, high = 0, sum(l for l, _ in bridge_parts)\n        while low < high:\n            mid = (low + high) // 2\n            distances = [0] + [mid // (N - 1)] * (N - 1)\n            if check_arrangement(arrangement, distances):\n                high = mid\n                min_distance = min(min_distance, mid)\n            else:\n                low = mid + 1\n\n    return min_distance if min_distance != float('inf') else -1\n\n# Read input\nN, M = map(int, input().split())\nweights = list(map(int, input().split()))\nbridge_parts = [tuple(map(int, input().split())) for _ in range(M)]\n\n# Output result\nprint(can_cross_bridge(N, M, weights, bridge_parts))"}
{"solution": "def last_digit_of_phoenix_reincarnations(a, b):\n    # If a is 0, then a! = 0! = 1, and any b! divided by 1 will end in 0\n    if a == 0:\n        return 0\n    \n    # If b >= a, then b! will include a! as a factor, so b! / a! will be an integer\n    # and the last digit will depend on the factorial product from (a+1) to b\n    # However, for a >= 5, a! will end in 0, so any factorial product from (a+1) to b\n    # will also end in 0. Therefore, we only need to consider cases where a < 5.\n    if b >= a:\n        if a < 2:\n            return 1  # 0! and 1! both end in 1\n        elif a == 2:\n            return 2 if b % 4 == 2 else 0  # 2! * 3! * 4! * ... ends in 2 every 4 cycles\n        elif a == 3:\n            return 6 if b % 4 == 3 else 0  # 3! * 4! * 5! * ... ends in 6 every 4 cycles\n        else:  # a == 4\n            return 4 if b % 2 == 1 else 0  # 4! * 5! * 6! * ... ends in 4 every 2 cycles\n    \n    # If b < a, we need to calculate the last digit of a! / b!\n    # This is equivalent to calculating the last digit of the product of numbers from (b+1) to a\n    # We can optimize this by noting the periodicity in the last digits of factorials\n    last_digit = 1\n    for i in range(b + 1, a + 1):\n        last_digit = (last_digit * i) % 10\n    \n    return last_digit\n\n# Read input\na, b = map(int, input().split())\n\n# Output the result\nprint(last_digit_of_phoenix_reincarnations(a, b))"}
{"solution": "from collections import deque\n\ndef min_jumps_to_home(n, d, s):\n    # Initialize a queue for BFS with starting point and jump count\n    queue = deque([(1, 0)])  # (current_position, jumps)\n    visited = [False] * (n + 1)\n    visited[1] = True\n    \n    while queue:\n        current, jumps = queue.popleft()\n        \n        # Check all possible jumps from the current position\n        for a in range(1, d + 1):\n            next_pos = current + a\n            if next_pos > n:\n                break\n            if next_pos == n:\n                return jumps + 1\n            if s[next_pos - 1] == '1' and not visited[next_pos]:\n                visited[next_pos] = True\n                queue.append((next_pos, jumps + 1))\n    \n    return -1\n\n# Read input\nn, d = map(int, input().split())\ns = input()\n\n# Output the result\nprint(min_jumps_to_home(n, d, s))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_counterexample(n):\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\n# Read input\nn = int(input().strip())\n\n# Find and print the counterexample\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all_coins(n):\n    # Define the costs of houses, cars, and computers\n    house_cost = 1234567\n    car_cost = 123456\n    computer_cost = 1234\n    \n    # Iterate over possible number of houses\n    for a in range(n // house_cost + 1):\n        remaining_after_houses = n - a * house_cost\n        \n        # Iterate over possible number of cars\n        for b in range(remaining_after_houses // car_cost + 1):\n            remaining_after_cars = remaining_after_houses - b * car_cost\n            \n            # Check if the remaining amount can be spent on computers\n            if remaining_after_cars % computer_cost == 0:\n                return \"YES\"\n    \n    # If no combination is found, return \"NO\"\n    return \"NO\"\n\n# Read input\nn = int(input().strip())\n\n# Output result\nprint(can_spend_all_coins(n))"}
{"solution": "def find_intersection_in_strip(n, x1, x2, lines):\n    # Sort lines based on their y-values at x1 and x2\n    lines.sort(key=lambda line: line[0] * x1 + line[1])\n    lines.sort(key=lambda line: line[0] * x2 + line[1])\n    \n    # Check if any two lines intersect strictly inside the strip\n    for i in range(n - 1):\n        if lines[i][0] * x2 + lines[i][1] > lines[i + 1][0] * x2 + lines[i + 1][1]:\n            return \"Yes\"\n    \n    return \"No\"\n\n# Read input\nn = int(input())\nx1, x2 = map(int, input().split())\nlines = [list(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(find_intersection_in_strip(n, x1, x2, lines))"}
{"solution": "def count_different_weights(n):\n    # The maximum weight of a split is n if the split is [n] itself.\n    # The minimum weight is 1, which occurs when the split is [1, 1, ..., 1] (n times).\n    # For any other weight k, there exists a split where the first element is n // k.\n    # Therefore, the number of different weights is the number of divisors of n.\n    # However, since we are only interested in the number of different weights,\n    # we can simplify the problem by noting that the number of different weights\n    # is at most the square root of n (since divisors come in pairs that multiply to n).\n    \n    # Initialize the count of different weights.\n    different_weights = 0\n    \n    # Iterate over possible divisors up to the square root of n.\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # i is a divisor, so it can be a weight.\n            different_weights += 1\n            # If i is not the square root of n, then n // i is also a different divisor.\n            if i != n // i:\n                different_weights += 1\n    \n    return different_weights\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(count_different_weights(n))"}
{"solution": "def find_good_apartments(n, k):\n    if k == 0:\n        min_good = 0\n        max_good = 0\n    else:\n        min_good = 1\n        max_good = min(n - k, 2 * k)\n    \n    return min_good, max_good\n\n# Example usage:\nn, k = 6, 3\nmin_good, max_good = find_good_apartments(n, k)\nprint(min_good, max_good)  # Output: 1 3"}
{"solution": "import math\n\ndef max_games_winner_can_play(n):\n    return math.floor(math.log2(n))\n\n# Read input from stdin\nn = int(input().strip())\n\n# Output the result\nprint(max_games_winner_can_play(n))"}
{"solution": "def max_vk_occurrences(s):\n    # Initialize the count of \"VK\" occurrences\n    count = 0\n    # Flag to check if we have made a change\n    changed = False\n    \n    # Iterate through the string to find \"VK\" and potential changes\n    i = 0\n    while i < len(s) - 1:\n        # If we find \"VK\", increment the count and move two steps forward\n        if s[i] == 'V' and s[i + 1] == 'K':\n            count += 1\n            i += 2\n        # If we find \"VV\" and haven't changed yet, and the next character is not 'K'\n        # or if we find \"KK\" and the previous character is not 'V', we can change one character\n        elif (s[i] == 'V' and s[i + 1] == 'V' and not changed and (i + 2 == len(s) or s[i + 2] != 'K')) or \\\n             (s[i] == 'K' and s[i + 1] == 'K' and not changed and (i == 0 or s[i - 1] != 'V')):\n            changed = True\n            count += 1\n            i += 2\n        else:\n            i += 1\n    \n    return count\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(max_vk_occurrences(s))"}
{"solution": "import math\n\ndef min_segments(n):\n    a = int(math.sqrt(n))\n    b = (n + a - 1) // a  # This is equivalent to math.ceil(n / a)\n    return a + b + 2\n\n# Read input\nn = int(input().strip())\nprint(min_segments(n))"}
{"solution": "def years_to_outweigh(a, b):\n    years = 0\n    while a <= b:\n        a *= 3\n        b *= 2\n        years += 1\n    return years\n\n# Read input from the user\na, b = map(int, input().split())\n\n# Calculate and print the number of years\nprint(years_to_outweigh(a, b))"}
{"solution": "def count_visited_nodes(h, n):\n    # Initialize the count of visited nodes\n    visited_nodes = 0\n    # Initialize the current level and the current node index\n    current_level = 0\n    current_node_index = 1\n    # Initialize the direction (0 for left, 1 for right)\n    direction = 0\n    \n    # Loop until we reach the target leaf node\n    while current_level < h:\n        # Check if the current node is the target node\n        if current_node_index == n:\n            visited_nodes += 1\n            break\n        \n        # Determine the next move based on the direction\n        if direction == 0:  # Move left\n            current_node_index *= 2\n        else:  # Move right\n            current_node_index = current_node_index * 2 + 1\n        \n        # Increment the count of visited nodes\n        visited_nodes += 1\n        # Increment the current level\n        current_level += 1\n        # Flip the direction for the next move\n        direction = 1 - direction\n        \n        # If we skipped two consecutive commands, move back to the parent node\n        if current_level > h:\n            current_level -= 1\n            current_node_index //= 2\n            visited_nodes -= 1\n    \n    return visited_nodes\n\n# Read input from the user\nh, n = map(int, input().split())\n\n# Calculate and print the number of visited nodes\nprint(count_visited_nodes(h, n))"}
{"solution": "def find_pairs(x):\n    pairs = []\n    # The maximum side length of a square that can fit into a table with x squares\n    # is the integer part of the square root of x, because a square with side length\n    # sqrt(x) would have sqrt(x)^2 = x squares.\n    max_side = int(x**0.5)\n    \n    # Iterate over possible values of n\n    for n in range(1, max_side + 1):\n        # Calculate m using the formula derived from the sum of squares formula\n        # x = n*m*(m+1)/2 + n*(n-1)*(2*n-1)/6\n        # Solving for m gives us a quadratic equation in terms of m:\n        # a = n/2, b = (n^2 - n)/2, c = -x\n        a = n / 2\n        b = (n**2 - n) / 2\n        c = -x\n        \n        # Calculate the discriminant\n        discriminant = b**2 - 4*a*c\n        if discriminant < 0:\n            continue\n        \n        # Calculate the two possible solutions for m\n        m1 = (-b + discriminant**0.5) / (2*a)\n        m2 = (-b - discriminant**0.5) / (2*a)\n        \n        # Check if either solution is an integer and positive\n        for m in [m1, m2]:\n            if m.is_integer() and m > 0:\n                pairs.append((n, int(m)))\n                if n != m:  # Avoid adding the same pair twice\n                    pairs.append((int(m), n))\n    \n    # Sort the pairs first by n, then by m\n    pairs.sort(key=lambda pair: (pair[0], pair[1]))\n    \n    return pairs\n\n# Read input\nx = int(input().strip())\n\n# Find pairs and print output\npairs = find_pairs(x)\nprint(len(pairs))\nfor pair in pairs:\n    print(pair[0], pair[1])"}
{"solution": "def is_leap_year(year):\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\ndef check_month_sequence(n, months):\n    month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    for start_month in range(12):\n        for year in range(2):  # Check for non-leap and leap year\n            valid = True\n            for i in range(n):\n                month = (start_month + i) % 12\n                expected_days = month_days[month]\n                if month == 1 and is_leap_year(year):\n                    expected_days += 1\n                if months[i] != expected_days:\n                    valid = False\n                    break\n            if valid:\n                return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\nmonths = list(map(int, input().split()))\n\n# Check and print the result\nprint(check_month_sequence(n, months))"}
{"solution": "def find_fraction_sequence(n):\n    # Check if n is even, as we need an even number to find a solution\n    if n % 2 == 0:\n        # Calculate the target sum\n        target = 1 - 1/n\n        # Initialize the sequence with the first fraction\n        sequence = [(1, n//2)]\n        # Calculate the remaining sum needed\n        remaining_sum = target - 1/(n//2)\n        # Find additional fractions to reach the target sum\n        for i in range(2, n//2):\n            if remaining_sum == 0:\n                break\n            if i % 2 == 0:\n                sequence.append((1, i))\n                remaining_sum -= 1/i\n        # Check if we have reached the target sum\n        if remaining_sum == 0:\n            print(\"YES\")\n            print(len(sequence))\n            for fraction in sequence:\n                print(fraction[0], fraction[1])\n        else:\n            print(\"NO\")\n    else:\n        print(\"NO\")\n\n# Read input\nn = int(input())\nfind_fraction_sequence(n)"}
{"solution": "def min_unattractiveness(n, a, b, heights):\n    # Initialize the minimum unattractiveness to a large number\n    min_unattractiveness = float('inf')\n    \n    # Try painting each board red and calculate the unattractiveness\n    for i in range(n):\n        # Calculate the total area painted red if the i-th board is painted red\n        red_area = heights[i]\n        # Calculate the total area painted green if the i-th board is painted green\n        green_area = sum(heights) - heights[i]\n        \n        # Check if the painting is possible within the given constraints\n        if red_area <= a and green_area <= b:\n            # Calculate the unattractiveness value\n            unattractiveness = 0\n            for j in range(n - 1):\n                if (heights[j] in heights[:i+1] and heights[j+1] in heights[i+1:]) or \\\n                   (heights[j] in heights[i+1:] and heights[j+1] in heights[:i+1]):\n                    unattractiveness += min(heights[j], heights[j+1])\n            \n            # Update the minimum unattractiveness\n            min_unattractiveness = min(min_unattractiveness, unattractiveness)\n    \n    # If it's impossible to paint the fence, return -1\n    return -1 if min_unattractiveness == float('inf') else min_unattractiveness\n\n# Read input\nn = int(input())\na, b = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Print the result\nprint(min_unattractiveness(n, a, b, heights))"}
{"solution": "def find_triangle_points(n, m, k):\n    # Check if it's possible to form a triangle with the given area\n    if 2 * m * n % k != 0:\n        return \"NO\"\n    \n    # Calculate the area of the triangle\n    area = (n * m) // k\n    \n    # Find the side lengths that can form the triangle with the given area\n    for x in range(1, n + 1):\n        for y in range(1, m + 1):\n            # Check if the current pair of sides can form the triangle\n            if 2 * x * y == area * k or 2 * x * (m - y) == area * k or 2 * (n - x) * y == area * k or 2 * (n - x) * (m - y) == area * k:\n                return \"YES\\n0 0\\n{} {}\\n{} {}\".format(x, 0, 0, y)\n    \n    return \"NO\"\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Find and print the result\nprint(find_triangle_points(n, m, k))"}
{"solution": "def determine_winner(n, k):\n    # Calculate the total number of moves each player can make\n    total_moves = n // k\n    \n    # Sasha wins if the total number of moves is odd, because he moves first\n    if total_moves % 2 == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input from standard input\nn, k = map(int, input().split())\n\n# Output the result\nprint(determine_winner(n, k))"}
{"solution": "def determine_most_exercised_muscle(n, repetitions):\n    # Initialize counters for each muscle group\n    chest_count = 0\n    biceps_count = 0\n    back_count = 0\n    \n    # Iterate through the repetitions and assign them to the corresponding muscle group\n    for i in range(n):\n        if (i + 1) % 3 == 1:  # First exercise in the cycle is for chest\n            chest_count += repetitions[i]\n        elif (i + 1) % 3 == 2:  # Second exercise in the cycle is for biceps\n            biceps_count += repetitions[i]\n        else:  # Third exercise in the cycle is for back\n            back_count += repetitions[i]\n    \n    # Determine which muscle group has the highest count\n    max_count = max(chest_count, biceps_count, back_count)\n    \n    # Return the corresponding muscle group\n    if max_count == chest_count:\n        return \"chest\"\n    elif max_count == biceps_count:\n        return \"biceps\"\n    else:\n        return \"back\"\n\n# Read input\nn = int(input())\nrepetitions = list(map(int, input().split()))\n\n# Output the result\nprint(determine_most_exercised_muscle(n, repetitions))"}
{"solution": "def min_redos_to_get_five(n, grades):\n    current_sum = sum(grades)\n    target_sum = n * 4.5\n    \n    if current_sum >= target_sum:\n        return 0\n    \n    grades.sort()\n    redos = 0\n    \n    for grade in grades:\n        if current_sum >= target_sum:\n            break\n        current_sum += (5 - grade)\n        redos += 1\n    \n    return redos\n\n# Example usage:\nn = int(input())\ngrades = list(map(int, input().split()))\nprint(min_redos_to_get_five(n, grades))"}
{"solution": "def find_shortest_array(u, v):\n    # If u is greater than v or the parity of u and v is different, no solution exists\n    if u > v or (u % 2 != v % 2):\n        return -1\n    \n    # If u and v are both 0, the array is empty\n    if u == 0 and v == 0:\n        return 0, []\n    \n    # If u equals v, the array contains only one element, u\n    if u == v:\n        return 1, [u]\n    \n    # Calculate the half difference between v and u\n    half_diff = (v - u) // 2\n    \n    # If u and half_diff have no bits in common, the array can be of length 2\n    if u & half_diff == 0:\n        return 2, [u + half_diff, half_diff]\n    \n    # Otherwise, the array must be of length 3\n    return 3, [u, half_diff, half_diff]\n\n# Read input\nu, v = map(int, input().split())\n\n# Find the shortest array\nn, array = find_shortest_array(u, v)\n\n# Print the result\nif n == -1:\n    print(n)\nelse:\n    print(n)\n    if n > 0:\n        print(*array)"}
{"solution": "def min_ones_sum(n):\n    count = 0\n    while n > 0:\n        count += n % 10\n        n //= 10\n    return count\n\n# Read input\nn = int(input())\n\n# Calculate and print the result\nprint(min_ones_sum(n))"}
{"solution": "def can_reach_treasure(x_1, y_1, x_2, y_2, x, y):\n    # Calculate the differences between starting and ending positions\n    dx = abs(x_2 - x_1)\n    dy = abs(y_2 - y_1)\n    \n    # Check if the differences can be expressed as multiples of x and y\n    if dx % x == 0 and dy % y == 0:\n        # Check if the number of steps in both directions is the same\n        if dx // x == dy // y:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nx_1, y_1, x_2, y_2 = map(int, input().split())\nx, y = map(int, input().split())\n\n# Output result\nprint(can_reach_treasure(x_1, y_1, x_2, y_2, x, y))"}
{"solution": "from itertools import permutations\n\ndef count_valid_bus_numbers(n):\n    digits = list(str(n))\n    all_permutations = set(permutations(digits))\n    valid_permutations = {perm for perm in all_permutations if perm[0] != '0'}\n    return len(valid_permutations)\n\nn = int(input().strip())\nresult = count_valid_bus_numbers(n)\nprint(result)"}
{"solution": "def max_possible_cost(a, b, c, d, e, f):\n    # Initialize the maximum cost\n    max_cost = 0\n\n    # Determine the maximum number of suits of each type that can be made\n    # Start with the type that gives the higher cost per suit\n    if e >= f:\n        # Calculate the number of first type suits that can be made\n        first_type_suits = min(a, d)\n        max_cost += first_type_suits * e\n        # Update the remaining jackets\n        d -= first_type_suits\n\n        # Calculate the number of second type suits that can be made with the remaining jackets\n        second_type_suits = min(b, c, d)\n        max_cost += second_type_suits * f\n    else:\n        # Calculate the number of second type suits that can be made\n        second_type_suits = min(b, c, d)\n        max_cost += second_type_suits * f\n        # Update the remaining jackets\n        d -= second_type_suits\n\n        # Calculate the number of first type suits that can be made with the remaining jackets\n        first_type_suits = min(a, d)\n        max_cost += first_type_suits * e\n\n    return max_cost\n\n# Read input\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\n# Calculate and print the maximum possible cost\nprint(max_possible_cost(a, b, c, d, e, f))"}
{"solution": "def solve(a, b, p, x):\n    count = 0\n    a_inv = pow(a, p - 2, p)  # Fermat's Little Theorem to find modular inverse of a\n    current = b\n    \n    for n in range(1, p):\n        current = (current * a_inv) % p  # Move backwards in the sequence to find n\n        if 1 <= n <= x and (n * current) % p == b:\n            count += 1\n            max_n = (x - n) // p  # Find the maximum multiple of p that can be added to n\n            count += max_n\n    \n    return count\n\n# Read input\na, b, p, x = map(int, input().split())\n\n# Output the result\nprint(solve(a, b, p, x))"}
{"solution": "def max_possible_sum(k_2, k_3, k_5, k_6):\n    # First, try to form as many 256 as possible\n    count_256 = min(k_2, k_5, k_6)\n    k_2 -= count_256\n    k_5 -= count_256\n    k_6 -= count_256\n    \n    # Then, try to form as many 32 as possible with the remaining 2's and 3's\n    count_32 = min(k_2, k_3)\n    \n    # Calculate the total sum\n    total_sum = count_256 * 256 + count_32 * 32\n    \n    return total_sum\n\n# Read input\nk_2, k_3, k_5, k_6 = map(int, input().split())\n\n# Calculate and print the result\nprint(max_possible_sum(k_2, k_3, k_5, k_6))"}
{"solution": "def calculate_seconds_to_happiness(n, x, y, c):\n    # Directions for side-adjacent cells: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Function to count the number of switched on cells after a given number of seconds\n    def count_switched_on_cells(seconds):\n        # Initialize the queue with the initial switched on cell\n        queue = [(x - 1, y - 1)]\n        visited = set(queue)\n        for _ in range(seconds):\n            new_queue = []\n            for row, col in queue:\n                for dr, dc in directions:\n                    new_row, new_col = row + dr, col + dc\n                    if 0 <= new_row < n and 0 <= new_col < n and (new_row, new_col) not in visited:\n                        visited.add((new_row, new_col))\n                        new_queue.append((new_row, new_col))\n            queue = new_queue\n        return len(visited)\n    \n    # Binary search to find the minimum number of seconds needed\n    left, right = 0, 2 * n\n    while left < right:\n        mid = (left + right) // 2\n        if count_switched_on_cells(mid) >= c:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Read input\nn, x, y, c = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_seconds_to_happiness(n, x, y, c))"}
{"solution": "def max_xor(l, r):\n    xor = l ^ r\n    significant_bit = 0\n    while xor:\n        significant_bit += 1\n        xor >>= 1\n    return (1 << significant_bit) - 1\n\n# Read input\nl, r = map(int, input().split())\n\n# Output the result\nprint(max_xor(l, r))"}
{"solution": "def minimum_height(n, k):\n    left, right = 1, k  # The height cannot be more than k because the area is k\n    \n    while left < right:\n        mid = (left + right) // 2\n        if n * mid >= k:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Read input\nn, k = map(int, input().split())\n\n# Output the result\nprint(minimum_height(n, k))"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    stairs_time = abs(x - y) * t1\n    \n    elevator_to_masha_time = abs(z - x) * t2 + t3\n    elevator_to_egor_time = abs(x - y) * t2 + 2 * t3\n    elevator_time = elevator_to_masha_time + elevator_to_egor_time\n    \n    if stairs_time < elevator_time:\n        return \"NO\"\n    else:\n        return \"YES\"\n\n# Example usage:\nx, y, z, t1, t2, t3 = map(int, input().split())\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "def optimal_a(n, m):\n    if m > n // 2:\n        return 1\n    else:\n        return n\n\n# Read input\nn, m = map(int, input().split())\n\n# Output the result\nprint(optimal_a(n, m))"}
{"solution": "def calculate_pairs_at_university(n, schedule):\n    pairs_at_university = 0\n    i = 0\n    while i < n:\n        if schedule[i] == 1:\n            pairs_at_university += 1\n            if i > 0 and schedule[i - 1] == 0:\n                # Check if the previous pair was a break of at least two pairs\n                if i > 1 and schedule[i - 2] == 0:\n                    # Alena goes home, skip the break\n                    i += 1\n            i += 1\n        else:\n            i += 1\n    return pairs_at_university\n\n# Read input\nn = int(input())\nschedule = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(calculate_pairs_at_university(n, schedule))"}
{"solution": "def min_days_to_give_candies(n, k, candies_per_day):\n    total_candies = 0\n    for day in range(n):\n        total_candies += candies_per_day[day]\n        given_candies = min(total_candies, 8)\n        k -= given_candies\n        total_candies -= given_candies\n        if k <= 0:\n            return day + 1\n    return -1\n\n# Reading input\nn, k = map(int, input().split())\ncandies_per_day = list(map(int, input().split()))\n\n# Output the result\nprint(min_days_to_give_candies(n, k, candies_per_day))"}
{"solution": "def minimum_additional_walks(n, k, a):\n    b = a[:]\n    additional_walks = 0\n    \n    for i in range(n - 1):\n        if b[i] + b[i + 1] < k:\n            needed_walks = k - (b[i] + b[i + 1])\n            b[i + 1] += needed_walks\n            additional_walks += needed_walks\n    \n    return additional_walks, b\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nadditional_walks, b = minimum_additional_walks(n, k, a)\n\n# Print the result\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "def number_of_cells_in_nth_order_rhombus(n):\n    if n == 1:\n        return 1\n    else:\n        # The pattern for the number of cells in a nth order rhombus follows the formula:\n        # 1 + 4 * (n - 1) + 4 * (n - 2) + ... + 4 * 1\n        # This can be simplified to 1 + 4 * (sum of first (n-1) natural numbers)\n        # The sum of the first (n-1) natural numbers is (n-1) * n / 2\n        # Therefore, the formula becomes 1 + 4 * ((n-1) * n / 2)\n        return 1 + 4 * ((n - 1) * n // 2)\n\n# Read input\nn = int(input())\n\n# Output the result\nprint(number_of_cells_in_nth_order_rhombus(n))"}
{"solution": "def is_pangram(n, s):\n    if n < 26:\n        return \"NO\"\n    letters = set(s.lower())\n    return \"YES\" if len(letters) == 26 else \"NO\"\n\n# Assuming the input is provided correctly as described in the problem statement\nn = int(input())\ns = input()\n\nprint(is_pangram(n, s))"}
{"solution": "def calculate_time_after_minutes(current_time, minutes_to_add):\n    # Split the current time into hours and minutes\n    hours, minutes = map(int, current_time.split(':'))\n    \n    # Calculate the total minutes after adding the given minutes\n    total_minutes = hours * 60 + minutes + minutes_to_add\n    \n    # Calculate the new hours and minutes\n    new_hours = total_minutes // 60 % 24\n    new_minutes = total_minutes % 60\n    \n    # Format the new time to ensure two digits for hours and minutes\n    new_time = f\"{new_hours:02d}:{new_minutes:02d}\"\n    \n    return new_time\n\n# Read input from the user\ncurrent_time = input().strip()\nminutes_to_add = int(input().strip())\n\n# Calculate and print the new time\nprint(calculate_time_after_minutes(current_time, minutes_to_add))"}
{"solution": "def can_ignore_one_switch(n, m, matrix):\n    # Convert the matrix to a list of sets for faster operations\n    switch_to_lamps = [set() for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == '1':\n                switch_to_lamps[i].add(j)\n    \n    # Check for each switch if ignoring it still turns on all lamps\n    for i in range(n):\n        # Combine all other switches' lamps\n        combined_lamps = set()\n        for j in range(n):\n            if i != j:\n                combined_lamps |= switch_to_lamps[j]\n        \n        # Check if all lamps are turned on\n        if len(combined_lamps) == m:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nmatrix = [input() for _ in range(n)]\n\n# Output result\nprint(can_ignore_one_switch(n, m, matrix))"}
{"solution": "def min_rotations_for_even_sums(n, dominoes):\n    upper_sum = sum(x for x, _ in dominoes)\n    lower_sum = sum(y for _, y in dominoes)\n    \n    # Check if both sums are already even\n    if upper_sum % 2 == 0 and lower_sum % 2 == 0:\n        return 0\n    \n    # Check if one sum is even and the other is odd, which is impossible to fix\n    if upper_sum % 2 != lower_sum % 2:\n        return -1\n    \n    # If both sums are odd, check if there's at least one domino that can be rotated to make both sums even\n    for x, y in dominoes:\n        if (x % 2 != y % 2):\n            return 1\n    \n    # If no such domino exists, it's impossible to make both sums even\n    return -1\n\n# Read input\nn = int(input())\ndominoes = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(min_rotations_for_even_sums(n, dominoes))"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        a, b = map(int, input().split())\n        area = (a - b) * (a + b)\n        print(\"YES\" if is_prime(area) else \"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_remove_one_point(n, points):\n    positive_count = 0\n    negative_count = 0\n    \n    for x, y in points:\n        if x > 0:\n            positive_count += 1\n        else:\n            negative_count += 1\n    \n    if positive_count <= 1 or negative_count <= 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Reading input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_remove_one_point(n, points))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n\ndef gcd_of_factorials(A, B):\n    # Since factorial of a number includes all numbers up to that number,\n    # the GCD of A! and B! will be the factorial of the smaller number.\n    return factorial(min(A, B))\n\n# Read input\nA, B = map(int, input().split())\n\n# Output the result\nprint(gcd_of_factorials(A, B))"}
{"solution": "def find_composite_pair(n):\n    # If n is even, we can use 4 and 4+n as our composites\n    if n % 2 == 0:\n        return 4 + n, 4\n    # If n is odd, we need to find the smallest composite number that is even\n    # and add n to it to make the result composite. The smallest even composite\n    # is 4, so we check if adding n to 4 results in a composite. If not, we use\n    # the next smallest even composite, which is 6.\n    else:\n        # Check if adding n to 4 results in a composite\n        if (4 + n) % 2 == 0:\n            return 4 + n, 4\n        else:\n            return 6 + n, 6\n\n# Read input\nn = int(input())\n\n# Find and print the composite pair\na, b = find_composite_pair(n)\nprint(a, b)"}
{"solution": "import sys\nfrom collections import deque\n\ndef read_input():\n    N, M, P = map(int, sys.stdin.readline().split())\n    edges = [list(map(int, sys.stdin.readline().split())) for _ in range(M)]\n    return N, M, P, edges\n\ndef solve(N, M, P, edges):\n    # Create adjacency list and coin list\n    adj_list = [[] for _ in range(N + 1)]\n    coin_list = [[] for _ in range(N + 1)]\n    for A_i, B_i, C_i in edges:\n        adj_list[A_i].append(B_i)\n        coin_list[A_i].append(C_i)\n    \n    # Initialize variables for BFS\n    max_coins = [-float('inf')] * (N + 1)\n    max_coins[1] = 0\n    queue = deque([(1, 0)])  # (current vertex, current coins)\n    \n    # BFS to find the maximum coins at each vertex\n    while queue:\n        v, coins = queue.popleft()\n        for next_v, C_i in zip(adj_list[v], coin_list[v]):\n            next_coins = coins + C_i\n            if max_coins[next_v] < next_coins:\n                max_coins[next_v] = next_coins\n                queue.append((next_v, next_coins))\n    \n    # Calculate the maximum score\n    max_score = max_coins[N] - P * (len(queue) + 1)\n    return max_score if max_score > 0 else -1\n\n# Read input and solve the problem\nN, M, P, edges = read_input()\nprint(solve(N, M, P, edges))"}
{"solution": "def min_cost_to_palindrome(N, strings_costs):\n    # Initialize the minimum cost to a large number\n    min_cost = float('inf')\n\n    # Helper function to check if a string can form a palindrome\n    def can_form_palindrome(s):\n        from collections import Counter\n        count = Counter(s)\n        odd_count = sum(1 for k, v in count.items() if v % 2 != 0)\n        return odd_count <= 1\n\n    # Helper function to calculate the cost of forming a palindrome\n    def calculate_cost(strings):\n        return sum(strings_costs[s] for s in strings)\n\n    # Try all combinations of strings to find the minimum cost\n    from itertools import combinations\n    for r in range(1, N + 1):  # Try combinations of 1 to N strings\n        for combo in combinations(strings_costs.keys(), r):\n            # Check if the combination can form a palindrome\n            if all(can_form_palindrome(s) for s in combo):\n                # Calculate the cost of this combination\n                cost = calculate_cost(combo)\n                # Update the minimum cost if this is lower\n                min_cost = min(min_cost, cost)\n\n    # If min_cost is still the initial large number, no palindrome can be formed\n    return -1 if min_cost == float('inf') else min_cost\n\n# Read input\nN = int(input())\nstrings_costs = {}\nfor _ in range(N):\n    S_i, C_i = input().split()\n    strings_costs[S_i] = int(C_i)\n\n# Calculate and print the minimum cost\nprint(min_cost_to_palindrome(N, strings_costs))"}
{"solution": "def largest_xor_sum(n, k):\n    num_bits = n.bit_length()\n    max_xor_sum = (1 << num_bits) - 1\n    return max_xor_sum\n\nn, k = map(int, input().split())\nprint(largest_xor_sum(n, k))"}
{"solution": "def min_length_isosceles_triangle(n, points):\n    # Find the maximum x and y coordinates among all points\n    max_x = max(points, key=lambda p: p[0])[0]\n    max_y = max(points, key=lambda p: p[1])[1]\n    \n    # The minimum length of the shorter side of the triangle is the maximum of max_x and max_y\n    return max(max_x, max_y)\n\n# Read input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(min_length_isosceles_triangle(n, points))"}
{"solution": "from collections import Counter\n\ndef max_nineteens(s):\n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # Define the required frequency of each character in the word \"nineteen\"\n    required_counts = {'n': 3, 'i': 1, 'e': 3, 't': 1}\n    \n    # Calculate the maximum number of \"nineteen\" words that can be formed\n    max_nineteens = float('inf')\n    for char, required in required_counts.items():\n        if char in char_count:\n            max_nineteens = min(max_nineteens, char_count[char] // required)\n        else:\n            return 0  # If any required character is missing, we can't form \"nineteen\"\n    \n    return max_nineteens\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(max_nineteens(s))"}
{"solution": "def highest_branch(p, y):\n    # Function to check if a number is a multiple of any number from 2 to p\n    def is_multiple_of_any(number, p):\n        for i in range(2, p + 1):\n            if number % i == 0:\n                return True\n        return False\n\n    # Start checking from y downwards to find the highest branch that cannot be reached\n    for branch in range(y, p, -1):\n        if not is_multiple_of_any(branch, p):\n            return branch\n    return -1\n\n# Example usage:\n# p, y = map(int, input().split())\n# print(highest_branch(p, y))"}
{"solution": "def find_minimum_distance(n, m, k, house_prices):\n    # Initialize the minimum distance to a large number\n    min_distance = float('inf')\n    \n    # Iterate through each house to find the closest affordable one\n    for i in range(n):\n        # Check if the house is affordable and unoccupied\n        if house_prices[i] > 0 and house_prices[i] <= k:\n            # Calculate the distance to the crush's house\n            distance = abs(i + 1 - m) * 10\n            # Update the minimum distance if this house is closer\n            if distance < min_distance:\n                min_distance = distance\n                \n    return min_distance\n\n# Read input\nn, m, k = map(int, input().split())\nhouse_prices = list(map(int, input().split()))\n\n# Find and print the minimum distance\nprint(find_minimum_distance(n, m, k, house_prices))"}
{"solution": "def can_transform(n, m, A, B):\n    # Count the occurrences of each element in both matrices\n    count_A = {}\n    count_B = {}\n    \n    for i in range(n):\n        for j in range(m):\n            count_A[A[i][j]] = count_A.get(A[i][j], 0) + 1\n            count_B[B[i][j]] = count_B.get(B[i][j], 0) + 1\n    \n    # Check if the count of each element is the same in both matrices\n    return count_A == count_B\n\n# Read input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nB = [list(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(\"YES\" if can_transform(n, m, A, B) else \"NO\")"}
{"solution": "def longest_uncommon_subsequence(a, b):\n    if a == b:\n        return -1\n    return max(len(a), len(b))\n\n# Read input\na = input().strip()\nb = input().strip()\n\n# Output the result\nprint(longest_uncommon_subsequence(a, b))"}
{"solution": "def find_intersection(a, b, c, d):\n    # Rick's screams: b, b + a, b + 2a, ...\n    # Morty's screams: d, d + c, d + 2c, ...\n    # We need to find the smallest t such that b + xa = d + yc for some non-negative integers x and y.\n    # This can be rearranged to b - d = yc - xa, which is a linear Diophantine equation.\n    # We need to find the smallest t = b + xa (or equivalently t = d + yc) that satisfies this equation.\n\n    # First, check if they can never meet\n    if a % c == 0:\n        if (b - d) % c != 0:\n            return -1\n    elif c % a == 0:\n        if (d - b) % a != 0:\n            return -1\n    else:\n        # Use the Chinese Remainder Theorem to find the solution\n        for t in range(max(b, d), a * c + 1, max(a, c)):\n            if (t - b) % a == 0 and (t - d) % c == 0:\n                return t\n    return -1\n\n# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Find and print the result\nprint(find_intersection(a, b, c, d))"}
{"solution": "def split_number(n):\n    # Since we need to ensure that none of a, b, or c is a multiple of 3,\n    # we can start by assigning 1 to each if n % 3 != 0, or adjust if n is divisible by 3.\n    if n % 3 == 0:\n        a = b = 1\n        c = n - 2\n    else:\n        a = b = c = n // 3\n        # Adjust to ensure none of them is a multiple of 3\n        if n % 3 == 1:\n            a += 1\n            b += 1\n        else:  # n % 3 == 2\n            a += 1\n            b += 1\n            c += 1\n    return a, b, c\n\n# Read input\nn = int(input().strip())\n\n# Get the result and print it\na, b, c = split_number(n)\nprint(a, b, c)"}
{"solution": "def count_valid_squares(n, a, b, c, d):\n    # Calculate the sum of the known elements in the top-left 2x2 square\n    top_left_sum = a + b\n    \n    # Initialize the count of valid squares\n    valid_squares_count = 0\n    \n    # Iterate through all possible values for the missing elements\n    for x in range(1, n + 1):\n        for y in range(1, n + 1):\n            for z in range(1, n + 1):\n                # Calculate the value for the bottom-right element to satisfy the condition\n                bottom_right = top_left_sum - (c + d)\n                \n                # Check if the bottom-right value is within the valid range\n                if 1 <= bottom_right <= n:\n                    # Check if the sum of each 2x2 square is equal to the top-left sum\n                    if (a + x == top_left_sum and\n                        b + y == top_left_sum and\n                        c + z == top_left_sum and\n                        d + bottom_right == top_left_sum):\n                        valid_squares_count += 1\n    \n    return valid_squares_count\n\n# Read input\nn, a, b, c, d = map(int, input().split())\n\n# Print the result\nprint(count_valid_squares(n, a, b, c, d))"}
{"solution": "def calculate_final_weight(w, h, u1, d1, u2, d2):\n    while h > 0:\n        w += h  # Weight increases by current height\n        if h == d1:\n            w = max(0, w - u1)  # Subtract weight of the first stone if at the same height\n        if h == d2:\n            w = max(0, w - u2)  # Subtract weight of the second stone if at the same height\n        h -= 1  # Move one meter down\n    return w\n\n# Read input\nw, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\n# Calculate and print the final weight\nprint(calculate_final_weight(w, h, u1, d1, u2, d2))"}
{"solution": "def find_passing_rate(m, c, x, y):\n    total_students = sum(c)\n    for k in range(1, m + 1):\n        beginners = sum(c[:k])\n        intermediates = total_students - beginners\n        \n        if x <= beginners <= y and x <= intermediates <= y:\n            return k\n    return 0\n\n# Read input\nm = int(input())\nc = list(map(int, input().split()))\nx, y = map(int, input().split())\n\n# Find and print the passing rate\nprint(find_passing_rate(m, c, x, y))"}
{"solution": "def min_coins_to_make_one(n, k, A, B):\n    coins = 0\n    while n > 1:\n        if n % k == 0:\n            potential_savings = (n - n // k) * A\n            if potential_savings > B:\n                n //= k\n                coins += B\n            else:\n                coins += (n - 1) * A\n                n = 1\n        else:\n            if n > k:\n                coins += (n % k) * A\n                n -= n % k\n            else:\n                coins += (n - 1) * A\n                n = 1\n    return coins\n\n# Reading input\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\n# Output the result\nprint(min_coins_to_make_one(n, k, A, B))"}
{"solution": "import math\n\ndef min_value_and_operations(n):\n    operations = 0\n    while n > 1:\n        sqrt_n = math.isqrt(n)\n        if sqrt_n * sqrt_n == n:\n            n = sqrt_n\n            operations += 1\n        else:\n            largest_factor = n // sqrt_n\n            n //= largest_factor\n            operations += 1\n    return n, operations\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the result\nmin_n, min_ops = min_value_and_operations(n)\nprint(min_n, min_ops)"}
{"solution": "def max_score_rps_battle(N, K, R, S, P, T):\n    # Initialize the score to 0\n    score = 0\n    \n    # Create a dictionary to map the machine's hand to the player's winning hand and points\n    hand_points = {'r': ('P', P), 's': ('R', R), 'p': ('S', S)}\n    \n    # Create a list to store the player's hands for the last K rounds\n    last_hands = []\n    \n    # Iterate over each round\n    for i in range(N):\n        machine_hand = T[i]\n        # Get the player's winning hand and points for the machine's hand\n        player_hand, points = hand_points[machine_hand]\n        \n        # If it's within the first K rounds or the player's hand is not the same as K rounds ago\n        if i < K or player_hand != last_hands[i - K]:\n            # Add the points to the score\n            score += points\n            # Store the player's hand for this round\n            last_hands.append(player_hand)\n        else:\n            # If the player's hand would be the same as K rounds ago, choose a hand that won't win\n            last_hands.append('X')  # 'X' represents a hand that won't contribute to the score\n    \n    return score\n\n# Read input\nN, K = map(int, input().split())\nR, S, P = map(int, input().split())\nT = input()\n\n# Calculate and print the maximum total score\nprint(max_score_rps_battle(N, K, R, S, P, T))"}
{"solution": "def longest_good_string(a, b, c):\n    # Start with the 'ab' strings since they are already good\n    length = 2 * c\n    \n    # Use the remaining 'a' and 'b' strings to extend the good string\n    # We can alternate between 'a' and 'b' to maintain the good string property\n    # The key is to always start with the smaller number to maximize the length\n    if a > b:\n        a, b = b, a  # Swap to ensure a is the smaller one\n    \n    # Now, a <= b\n    # We can use 'a' pairs of 'ab' and then use the remaining 'b'\n    length += 2 * a  # Each 'a' can pair with a 'b' to form 'ab'\n    b -= a  # We've used 'a' 'b's to pair with 'a' 'a's\n    \n    # If there are any 'b' left, we can add one more 'b' to the end\n    if b > 0:\n        length += 1\n    \n    return length\n\n# Read input\na, b, c = map(int, input().split())\n\n# Print the result\nprint(longest_good_string(a, b, c))"}
{"solution": "def determine_marks(n, k, p, x, y, a):\n    # Calculate the remaining tests and the sum of current marks\n    remaining_tests = n - k\n    current_sum = sum(a)\n    \n    # Calculate the number of marks needed to ensure the median is at least y\n    median_position = (n + 1) // 2\n    a_sorted = sorted(a)\n    marks_needed_for_median = 0\n    for i in range(median_position):\n        if a_sorted[i] < y:\n            marks_needed_for_median += 1\n        else:\n            break\n    \n    # If we need more marks to ensure the median than remaining tests, it's impossible\n    if marks_needed_for_median > remaining_tests:\n        return \"-1\"\n    \n    # Calculate the maximum number of '1' marks Vova can get\n    max_ones = remaining_tests - marks_needed_for_median\n    if current_sum + marks_needed_for_median * y + max_ones > x:\n        return \"-1\"\n    \n    # Construct the output\n    result = [y] * marks_needed_for_median + [1] * max_ones\n    return ' '.join(map(str, result))\n\n# Read input\nn, k, p, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\n# Determine and print the marks\nprint(determine_marks(n, k, p, x, y, a))"}
{"solution": "def is_berlanese(s):\n    vowels = \"aouie\"\n    for i in range(len(s)):\n        if s[i] not in vowels:\n            if s[i] == 'n':\n                continue\n            if i == len(s) - 1 or s[i + 1] not in vowels:\n                return \"NO\"\n    return \"YES\"\n\n# Read input\ns = input().strip()\n\n# Output result\nprint(is_berlanese(s))"}
{"solution": "def max_dominoes(n, m, edges):\n    # If there are no edges, no dominoes can be placed\n    if m == 0:\n        return 0\n\n    # Create a degree list for each vertex\n    degree = [0] * (n + 1)\n    for a, b in edges:\n        degree[a] += 1\n        degree[b] += 1\n\n    # The maximum number of dominoes that can be placed is determined by\n    # the vertex with the highest degree, as each vertex must have the same\n    # number of dots on the halves of dominoes directed towards it.\n    max_degree = max(degree)\n\n    # The number of dominoes that can be placed is limited by the vertex with\n    # the highest degree, but it cannot exceed the total number of edges.\n    return min(max_degree, m)\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Calculate and print the result\nprint(max_dominoes(n, m, edges))"}
{"solution": "def maximize_r2_points(n, m, prices, auction_questions):\n    # Sort the prices in descending order to always pick the highest value first\n    sorted_prices = sorted(enumerate(prices, start=1), key=lambda x: -x[1])\n    \n    # Initialize variables\n    r2_points = 0\n    current_points = 0\n    \n    # Iterate through sorted questions\n    for question_index, price in sorted_prices:\n        if question_index in auction_questions:\n            # If it's an auction question and R2 has more points than the price,\n            # R2 can set the price to their current points to maximize gain\n            if current_points > price:\n                r2_points += current_points\n                current_points += current_points  # R2 doubles their points\n            else:\n                # If R2 doesn't have enough points, they can't change the price,\n                # so they just add the original price to their points\n                r2_points += price\n                current_points += price\n        else:\n            # For regular questions, R2 simply adds the price to their points\n            r2_points += price\n            current_points += price\n    \n    return r2_points\n\n# Read input\nn, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauction_questions = set(map(int, input().split()))\n\n# Calculate and print the maximum points R2 can get\nprint(maximize_r2_points(n, m, prices, auction_questions))"}
{"solution": "def compute_final_score(m_values, w_values, hs, hu):\n    problem_points = [500, 1000, 1500, 2000, 2500]\n    total_score = 0\n\n    for i in range(5):\n        m = m_values[i]\n        w = w_values[i]\n        x = problem_points[i]\n        score = max(0.3 * x, (1 - m / 250) * x - 50 * w)\n        total_score += score\n\n    total_score += 100 * hs\n    total_score -= 50 * hu\n\n    return int(total_score)\n\n# Read input\nm_values = list(map(int, input().split()))\nw_values = list(map(int, input().split()))\nhs, hu = map(int, input().split())\n\n# Compute and print the final score\nprint(compute_final_score(m_values, w_values, hs, hu))"}
{"solution": "MOD = 998244353\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef solve(n, m, L, R):\n    total_cells = n * m\n    if total_cells % 2 == 1:\n        return power(R - L + 1, total_cells, MOD)\n    else:\n        even_count = (R // 2) - ((L - 1) // 2)\n        odd_count = (R - L + 1) - even_count\n        return (power(even_count + odd_count, total_cells, MOD) + power(even_count - odd_count, total_cells, MOD)) * power(2, MOD - 2, MOD) % MOD\n\n# Read input\nn, m, L, R = map(int, input().split())\n\n# Output the result\nprint(solve(n, m, L, R))"}
{"solution": "def is_possible_to_make_increasing(n, m, matrix_a, matrix_b):\n    for i in range(n):\n        for j in range(m):\n            # Ensure that matrix_a[i][j] is the smaller or equal element\n            if matrix_a[i][j] > matrix_b[i][j]:\n                matrix_a[i][j], matrix_b[i][j] = matrix_b[i][j], matrix_a[i][j]\n    \n    # Check rows for strictly increasing property\n    for i in range(n):\n        for j in range(1, m):\n            if matrix_a[i][j] <= matrix_a[i][j-1] or matrix_b[i][j] <= matrix_b[i][j-1]:\n                return \"Impossible\"\n    \n    # Check columns for strictly increasing property\n    for j in range(m):\n        for i in range(1, n):\n            if matrix_a[i][j] <= matrix_a[i-1][j] or matrix_b[i][j] <= matrix_b[i-1][j]:\n                return \"Impossible\"\n    \n    return \"Possible\"\n\n# Read input\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\nmatrix_b = [list(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(is_possible_to_make_increasing(n, m, matrix_a, matrix_b))"}
{"solution": "def max_length_string(n, limits):\n    # Sort the limits in descending order to start assigning the highest possible distinct counts\n    limits.sort(reverse=True)\n    \n    # Initialize the maximum length of the string\n    max_length = 0\n    \n    # The first letter can be used up to its limit\n    current_count = limits[0]\n    \n    # Iterate over the sorted limits to assign distinct counts\n    for i in range(1, n):\n        # If the current limit is less than or equal to the number of distinct counts we need, break\n        if limits[i] <= i:\n            break\n        # Otherwise, add the current count to the max_length and decrement the current count for the next letter\n        max_length += current_count\n        current_count = max(current_count - 1, 1)\n    \n    return max_length\n\n# Read input\nn = int(input())\nlimits = list(map(int, input().split()))\n\n# Print the output\nprint(max_length_string(n, limits))"}
{"solution": "def min_problems_to_solve(n, k, difficulties):\n    difficulties.sort(reverse=True)\n    problems_to_solve = 0\n    i = 0\n    while i < n:\n        if difficulties[i] > 2 * k:\n            problems_to_solve += 1\n            k = difficulties[i]\n        else:\n            break\n        i += 1\n    return problems_to_solve\n\n# Reading input\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Output the result\nprint(min_problems_to_solve(n, k, difficulties))"}
{"solution": "def distribute_diplomas(n, min_max_1, min_max_2, min_max_3):\n    min_1, max_1 = min_max_1\n    min_2, max_2 = min_max_2\n    min_3, max_3 = min_max_3\n    \n    # Start by maximizing the number of first-degree diplomas\n    first_degree = min(max_1, n - min_2 - min_3)\n    remaining_n = n - first_degree\n    \n    # Then, maximize the number of second-degree diplomas\n    second_degree = min(max_2, remaining_n - min_3)\n    remaining_n -= second_degree\n    \n    # The rest will get third-degree diplomas, ensuring it's within the limit\n    third_degree = min(max_3, remaining_n)\n    \n    return first_degree, second_degree, third_degree\n\n# Read input\nn = int(input())\nmin_max_1 = tuple(map(int, input().split()))\nmin_max_2 = tuple(map(int, input().split()))\nmin_max_3 = tuple(map(int, input().split()))\n\n# Calculate and print the result\nresult = distribute_diplomas(n, min_max_1, min_max_2, min_max_3)\nprint(result[0], result[1], result[2])"}
{"solution": "def predict_moon_phase(n, observations):\n    # Check if there's enough data to predict the next phase\n    if n == 1:\n        if observations[0] == 0:\n            return \"UP\"\n        elif observations[0] == 15:\n            return \"DOWN\"\n        else:\n            return -1\n    \n    # Determine the trend based on the last two observations\n    last_observation = observations[-1]\n    second_last_observation = observations[-2]\n    \n    if last_observation > second_last_observation:\n        # If the last observation is 15, the next will be DOWN\n        if last_observation == 15:\n            return \"DOWN\"\n        else:\n            return \"UP\"\n    else:\n        # If the last observation is 0, the next will be UP\n        if last_observation == 0:\n            return \"UP\"\n        else:\n            return \"DOWN\"\n\n# Read input\nn = int(input())\nobservations = list(map(int, input().split()))\n\n# Predict and print the result\nprint(predict_moon_phase(n, observations))"}
{"solution": "def can_transform(s, t):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    # Check if lengths are the same\n    if len(s) != len(t):\n        return \"No\"\n    \n    # Check each character\n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels) != (char_t in vowels):\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(can_transform(s, t))"}
{"solution": "def determine_winner(board):\n    # Initialize the minimum steps for both players to a large number\n    min_steps_A = 8\n    min_steps_B = 8\n\n    # Iterate through each cell on the board\n    for row in range(8):\n        for col in range(8):\n            if board[row][col] == 'W':\n                # Check for the minimum steps for player A to reach row 1\n                steps_A = row\n                # Ensure there are no black pawns blocking the way\n                for i in range(row):\n                    if board[i][col] != '.':\n                        steps_A = 8\n                        break\n                min_steps_A = min(min_steps_A, steps_A)\n            elif board[row][col] == 'B':\n                # Check for the minimum steps for player B to reach row 8\n                steps_B = 7 - row\n                # Ensure there are no white pawns blocking the way\n                for i in range(row + 1, 8):\n                    if board[i][col] != '.':\n                        steps_B = 8\n                        break\n                min_steps_B = min(min_steps_B, steps_B)\n\n    # Determine the winner based on the minimum steps required\n    if min_steps_A <= min_steps_B:\n        return 'A'\n    else:\n        return 'B'\n\n# Read the board configuration from input\nboard = [input().strip() for _ in range(8)]\n\n# Determine the winner and print the result\nprint(determine_winner(board))"}
{"solution": "def max_equal_length(n, A, m, B):\n    if sum(A) != sum(B):\n        return -1\n    \n    i, j = 0, 0\n    sumA, sumB = 0, 0\n    count = 0\n    \n    while i < n and j < m:\n        sumA += A[i]\n        sumB += B[j]\n        \n        if sumA == sumB:\n            count += 1\n            sumA = 0\n            sumB = 0\n            i += 1\n            j += 1\n        elif sumA < sumB:\n            i += 1\n        else:\n            j += 1\n    \n    return count\n\n# Read input\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\n# Output the result\nprint(max_equal_length(n, A, m, B))"}
{"solution": "def is_contest_problem(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    count = sum(problem_name.count(friend) for friend in friends)\n    return \"YES\" if count == 1 else \"NO\"\n\n# Assuming the input is provided through a method that returns the problem name as a string\n# For example, using input() in a real scenario:\n# problem_name = input()\n# print(is_contest_problem(problem_name))"}
{"solution": "def sieve(n):\n    is_prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (is_prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n    is_prime[0], is_prime[1] = False, False  # 0 and 1 are not primes\n    return is_prime\n\ndef count_primes_in_range(is_prime, a, b):\n    prime_count = [0] * (b + 1)\n    for i in range(a, b + 1):\n        prime_count[i] = prime_count[i - 1] + (1 if is_prime[i] else 0)\n    return prime_count\n\ndef min_length_with_k_primes(a, b, k):\n    is_prime = sieve(b)\n    prime_count = count_primes_in_range(is_prime, a, b)\n    \n    def has_k_primes_in_length(l):\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] >= k:\n                return True\n        return False\n    \n    left, right = 1, b - a + 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if has_k_primes_in_length(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\n# Input\na, b, k = map(int, input().split())\n\n# Output\nprint(min_length_with_k_primes(a, b, k))"}
{"solution": "import math\n\ndef min_distance(a, h, w):\n    if a > h or a > w:\n        return -1\n    \n    # Calculate the maximum number of photos that can fit in each dimension\n    max_rows = h // a\n    max_cols = w // a\n    \n    # Initialize the minimum distance to a large number\n    min_x = float('inf')\n    \n    # Try different combinations of rows and columns\n    for rows in range(1, max_rows + 1):\n        for cols in range(1, max_cols + 1):\n            # Calculate the total height and width occupied by the photos and the gaps\n            total_height = rows * a + (rows + 1) * x\n            total_width = cols * a + (cols + 1) * x\n            \n            # Check if the total dimensions fit within the wall\n            if total_height <= h and total_width <= w:\n                # Calculate the distance x based on the current configuration\n                x = min((h - rows * a) / (rows + 1), (w - cols * a) / (cols + 1))\n                min_x = min(min_x, x)\n    \n    return min_x if min_x != float('inf') else -1\n\n# Read input\na, h, w = map(int, input().split())\n\n# Calculate and print the result\nresult = min_distance(a, h, w)\nprint(f\"{result:.6f}\" if result != -1 else -1)"}
{"solution": "def chapters_to_read(n, chapters, k):\n    # Initialize the count of chapters not completely read\n    chapters_not_read = 0\n    \n    # Iterate through each chapter\n    for chapter in chapters:\n        # If the marked page is within the current chapter, increment the count\n        if k >= chapter[0] and k <= chapter[1]:\n            chapters_not_read += 1\n    \n    # The number of chapters not completely read is the total number of chapters minus the chapters not read\n    return n - chapters_not_read + 1\n\n# Read input\nn = int(input())\nchapters = [tuple(map(int, input().split())) for _ in range(n)]\nk = int(input())\n\n# Calculate and print the result\nprint(chapters_to_read(n, chapters, k))"}
{"solution": "def can_form_codeforces(word):\n    target = \"CODEFORCES\"\n    n = len(word)\n    m = len(target)\n    \n    if n < m:\n        return \"NO\"\n    \n    for i in range(m + 1):\n        if word[:i] == target[:i] and word[n - (m - i):] == target[i:]:\n            return \"YES\"\n    \n    return \"NO\""}
{"solution": "def min_weight_triangulation(n):\n    if n < 3:\n        return 0\n    if n == 3:\n        return 1 * 2 * 3\n    \n    # Initialize a table to store the minimum weights\n    dp = [[0] * n for _ in range(n)]\n    \n    # Fill the table using dynamic programming\n    for length in range(3, n + 1):  # length of the subpolygon\n        for i in range(n - length + 1):  # start index of the subpolygon\n            j = i + length - 1  # end index of the subpolygon\n            dp[i][j] = float('inf')\n            for k in range(i + 1, j):  # potential vertex to form a triangle\n                weight = (i + 1) * (k + 1) * (j + 1)\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + weight)\n    \n    return dp[0][n - 1]\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the minimum weight triangulation\nprint(min_weight_triangulation(n))"}
{"solution": "def count_digits_for_books(n):\n    digits = 0\n    length = 1\n    start = 1\n    \n    while start <= n:\n        end = start * 10 - 1 if start * 10 - 1 <= n else n\n        digits += (end - start + 1) * length\n        length += 1\n        start *= 10\n    \n    return digits\n\n# Read input\nn = int(input())\n\n# Output the result\nprint(count_digits_for_books(n))"}
{"solution": "def find_winning_color(n, A, car_colors):\n    # Initialize a dictionary to count occurrences of each color\n    color_counts = {}\n    # Initialize a variable to track the count of Alice's chosen color\n    alice_count = 0\n    \n    # Iterate through the car colors to count occurrences\n    for color in car_colors:\n        if color == A:\n            alice_count += 1\n        else:\n            if color not in color_counts:\n                color_counts[color] = 0\n            color_counts[color] += 1\n    \n    # Find a color for Bob that ensures he wins\n    for color, count in color_counts.items():\n        if count >= alice_count:\n            return color\n    \n    # If no such color exists, return -1\n    return -1\n\n# Read input\nn, A = map(int, input().split())\ncar_colors = list(map(int, input().split()))\n\n# Find and print the winning color for Bob\nprint(find_winning_color(n, A, car_colors))"}
{"solution": "def can_form_unique_crossword(n, x, encoding):\n    # Calculate the total length required by the encoding\n    total_length_required = sum(encoding) + len(encoding) - 1\n    \n    # Check if the total length required exceeds the given length x\n    if total_length_required > x:\n        return \"NO\"\n    \n    # Check if the difference between x and total_length_required is even\n    # This is to ensure we can distribute the remaining 0's evenly between segments\n    if (x - total_length_required) % 2 != 0:\n        return \"NO\"\n    \n    # If both conditions are satisfied, there is exactly one crossword possible\n    return \"YES\"\n\n# Read input\nn, x = map(int, input().split())\nencoding = list(map(int, input().split()))\n\n# Print the result\nprint(can_form_unique_crossword(n, x, encoding))"}
{"solution": "def min_coins_required(n, S):\n    # The minimum number of coins required to get sum S is to use the largest coin value as much as possible.\n    # This is because using larger coins reduces the total number of coins needed.\n    # The largest coin value we can use is 'n', so we calculate how many 'n' coins we can use.\n    # If S is divisible by n, we use S // n coins of value n.\n    # If S is not divisible by n, we still use S // n coins of value n and then use smaller coins to make up the remainder.\n    # However, for the purpose of finding the minimum number of coins, we only need to consider the quotient.\n    return S // n\n\n# Read input\nn, S = map(int, input().split())\n\n# Output the result\nprint(min_coins_required(n, S))"}
{"solution": "def min_changes_to_palindrome(s):\n    n = len(s)\n    changes = 0\n    # Create a frequency map for the characters in the string\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n    \n    # Determine the number of changes needed to make the string a palindrome\n    for char, count in freq.items():\n        if count % 2 != 0:\n            changes += 1\n    \n    # If the number of changes is greater than 1, we can reduce it by pairing odd counts\n    if changes > 1:\n        changes -= (changes - 1) // 2\n    \n    # Create the lexicographically smallest palindrome\n    half = [''] * (n // 2)\n    odd_char = ''\n    for char in sorted(freq.keys()):\n        count = freq[char]\n        # If the count is odd and we don't have an odd character yet, assign it\n        if count % 2 != 0 and not odd_char:\n            odd_char = char\n            count -= 1\n        # Fill the first half of the palindrome with even counts\n        while count > 0 and count % 2 == 0:\n            if '' in half:\n                pos = half.index('')\n                half[pos] = char\n                count -= 2\n            else:\n                break\n    \n    # Construct the palindrome\n    first_half = ''.join(half)\n    second_half = first_half[::-1]\n    if n % 2 == 1:\n        return first_half + odd_char + second_half\n    else:\n        return first_half + second_half\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(min_changes_to_palindrome(s))"}
{"solution": "def calculate_weight(board):\n    piece_weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n    }\n    \n    white_weight = 0\n    black_weight = 0\n    \n    for row in board:\n        for piece in row:\n            if piece in piece_weights:\n                if piece.isupper():\n                    white_weight += piece_weights[piece]\n                else:\n                    black_weight += piece_weights[piece]\n    \n    if white_weight > black_weight:\n        return \"White\"\n    elif black_weight > white_weight:\n        return \"Black\"\n    else:\n        return \"Draw\""}
{"solution": "from collections import deque\n\ndef solve_sugoroku(N, M, S):\n    # Initialize a queue for BFS and a set to keep track of visited states\n    queue = deque()\n    visited = set()\n    \n    # Start from square 0 with an empty path\n    queue.append((0, []))\n    visited.add(0)\n    \n    while queue:\n        current_square, path = queue.popleft()\n        \n        # Check all possible moves from the current square\n        for move in range(1, M + 1):\n            next_square = current_square + move\n            \n            # If the next square is the goal and it's not a Game Over Square, return the path\n            if next_square == N and S[next_square] == '0':\n                return path + [move]\n            \n            # If the next square is within bounds, not a Game Over Square, and not visited\n            if next_square < N + 1 and S[next_square] == '0' and next_square not in visited:\n                queue.append((next_square, path + [move]))\n                visited.add(next_square)\n    \n    # If no valid path is found, return -1\n    return -1\n\n# Read input\nN, M = map(int, input().split())\nS = input()\n\n# Solve the problem and print the result\nresult = solve_sugoroku(N, M, S)\nif result == -1:\n    print(result)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "def solve_golf_problem(K, X, Y):\n    # Check if the goal is reachable directly\n    if (abs(X) + abs(Y)) % K == 0:\n        return [(X, Y)]\n    \n    # If the sum of absolute X and Y is not divisible by K, it's impossible if K is odd\n    if (abs(X) + abs(Y)) % 2 != 0 and K % 2 == 0:\n        return -1\n    \n    # Calculate the number of steps needed\n    steps = (abs(X) + abs(Y) + K - 1) // K\n    \n    # If the sum of absolute X and Y is odd, we need an extra step if K is even\n    if (abs(X) + abs(Y)) % 2 != 0:\n        steps += 1\n    \n    # Initialize the path\n    path = []\n    \n    # Calculate the path\n    for i in range(steps - 1):\n        # Calculate the remaining distance after this step\n        remaining_distance = abs(X) + abs(Y) - i * K\n        \n        # Determine the direction of the move\n        if abs(X) > abs(Y):\n            move_x = min(K, abs(X)) * (1 if X > 0 else -1)\n            move_y = (K - abs(move_x)) * (1 if Y > 0 else -1)\n        else:\n            move_y = min(K, abs(Y)) * (1 if Y > 0 else -1)\n            move_x = (K - abs(move_y)) * (1 if X > 0 else -1)\n        \n        # Update the current position\n        X -= move_x\n        Y -= move_y\n        \n        # Add the move to the path\n        path.append((X, Y))\n    \n    # Add the final move to the goal\n    path.append((X, Y))\n    \n    return path\n\n# Read input\nK = int(input())\nX, Y = map(int, input().split())\n\n# Solve the problem\nresult = solve_golf_problem(K, X, Y)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for point in result:\n        print(point[0], point[1])"}
{"solution": "def find_smallest_n(m):\n    if m == 1:\n        return 8\n    elif m == 8:\n        return 54\n    elif m == 10:\n        return -1\n    else:\n        # Binary search to find the smallest n\n        left, right = 8, 10**15\n        while left < right:\n            mid = (left + right) // 2\n            ways = count_ways(mid)\n            if ways == m:\n                right = mid\n            elif ways < m:\n                left = mid + 1\n            else:\n                right = mid - 1\n        if count_ways(left) == m:\n            return left\n        else:\n            return -1\n\ndef count_ways(n):\n    ways = 0\n    for k in range(2, n):\n        if n // k < 4:\n            break\n        total = 0\n        term = 1\n        while term <= n:\n            total += term\n            term *= k\n            if total > n:\n                break\n            if term > n:\n                break\n        if total <= n:\n            ways += 1\n    return ways\n\n# Read input\nm = int(input().strip())\n\n# Find and print the smallest n\nprint(find_smallest_n(m))"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    \n    # If the circles do not intersect\n    if d >= r1 + r2:\n        return 0.0\n    \n    # If one circle is inside the other\n    if d <= abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n    \n    # Calculate the intersection area\n    r1_sq = r1 ** 2\n    r2_sq = r2 ** 2\n    d_sq = d ** 2\n    \n    alpha = math.acos((d_sq + r1_sq - r2_sq) / (2 * d * r1))\n    beta = math.acos((d_sq + r2_sq - r1_sq) / (2 * d * r2))\n    \n    intersection_area = alpha * r1_sq + beta * r2_sq - 0.5 * (r1_sq * math.sin(2 * alpha) + r2_sq * math.sin(2 * beta))\n    \n    return intersection_area\n\n# Read input\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\n# Calculate and print the intersection area\nprint(\"{:.20f}\".format(circle_intersection_area(x1, y1, r1, x2, y2, r2)))"}
{"solution": "def minimize_n(v):\n    # The strategy to minimize n is to always subtract the largest non-divisor\n    # of n that is less than n. However, since the goal is to minimize n as\n    # quickly as possible, we can observe that if n > 1, we can always reduce\n    # n to 1 by subtracting 1 (since 1 is not a divisor of any number greater\n    # than 1 and is less than any such number).\n    return 1 if v > 1 else v\n\n# Read input\nv = int(input().strip())\n\n# Output the result\nprint(minimize_n(v))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    n = int(sys.stdin.readline().strip())\n    p = list(map(int, sys.stdin.readline().strip().split()))\n    a = list(map(int, sys.stdin.readline().strip().split()))\n    return n, p, a\n\ndef solve(n, p, a):\n    # Create a graph representation of the city\n    graph = defaultdict(list)\n    for i in range(2, n + 1):\n        graph[p[i - 2]].append(i)\n    \n    # Calculate the number of citizens that can reach each square\n    citizens_reaching = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        citizens_reaching[i] += a[i - 1]\n        if i > 1:\n            citizens_reaching[p[i - 2]] += citizens_reaching[i]\n    \n    # Calculate the maximum number of citizens the bandit can catch\n    max_catch = 0\n    for i in range(1, n + 1):\n        max_catch = max(max_catch, citizens_reaching[i])\n    \n    return max_catch\n\ndef main():\n    n, p, a = read_input()\n    result = solve(n, p, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_typo_words(n, S, T):\n    count = 0\n    for i in range(n + 1):\n        # Construct W by inserting a character at position i in both S and T\n        if i == 0:\n            W1 = S[0] + S\n            W2 = T[0] + T\n        elif i == n:\n            W1 = S + S[-1]\n            W2 = T + T[-1]\n        else:\n            W1 = S[:i] + S[i] + S[i:]\n            W2 = T[:i] + T[i] + T[i:]\n        \n        # Check if the constructed words are the same\n        if W1 == W2:\n            count += 1\n    \n    return count\n\n# Example usage:\nn = int(input())\nS = input().strip()\nT = input().strip()\nprint(count_typo_words(n, S, T))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_ints():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef read_int():\n    return int(sys.stdin.readline().strip())\n\ndef main():\n    n = read_int()\n    bank_strengths = read_ints()\n    connections = defaultdict(list)\n    \n    for _ in range(n - 1):\n        u, v = read_ints()\n        connections[u].append(v)\n        connections[v].append(u)\n    \n    # Strategy: Start by hacking the bank with the highest strength, then continue\n    # hacking the next highest strength bank that is neighboring an already hacked bank.\n    # This ensures that the strength of the computer needed is minimized.\n    \n    # Sort banks by their strength in descending order\n    sorted_banks = sorted([(strength, i) for i, strength in enumerate(bank_strengths)], reverse=True)\n    \n    # Initialize the minimum computer strength needed to the highest bank strength\n    min_computer_strength = sorted_banks[0][0]\n    \n    # Track hacked banks\n    hacked = [False] * n\n    \n    # Hack banks in the order of their strength\n    for strength, index in sorted_banks:\n        index -= 1  # Adjust index to be zero-based\n        if not hacked[index]:\n            # Hack this bank\n            hacked[index] = True\n            # Update the strength of neighboring and semi-neighboring banks\n            for neighbor in connections[index + 1]:\n                neighbor -= 1  # Adjust neighbor index to be zero-based\n                bank_strengths[neighbor] += 1\n                if not hacked[neighbor]:\n                    # Re-sort the list to maintain the order by strength\n                    sorted_banks.remove((bank_strengths[neighbor] - 1, neighbor + 1))\n                    sorted_banks.append((bank_strengths[neighbor], neighbor + 1))\n                    sorted_banks.sort(reverse=True)\n    \n    print(min_computer_strength)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_groups(n, m):\n    return min(m, n - m)\n\n# Read input\nn, m = map(int, input().split())\n\n# Print output\nprint(max_groups(n, m))"}
{"solution": "def min_shovels_to_buy(k, r):\n    shovels = 1\n    while (shovels * k) % 10 != 0 and (shovels * k) % 10 != r:\n        shovels += 1\n    return shovels\n\n# Read input\nk, r = map(int, input().split())\n\n# Output the result\nprint(min_shovels_to_buy(k, r))"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # Dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Extract the bounding box\n    piece = []\n    for i in range(min_row, max_row + 1):\n        piece.append(grid[i][min_col:max_col + 1])\n    \n    # Check horizontal placement\n    if width * 2 == m:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j] != piece[i][j + width]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    # Check vertical placement\n    if height * 2 == n:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j] != piece[i + height][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "def min_segments(x1, y1, x2, y2, x3, y3):\n    # Check if all points are collinear on the same x-axis or y-axis\n    if x1 == x2 == x3 or y1 == y2 == y3:\n        return 1\n    # Check if two points share the same x-coordinate or y-coordinate\n    elif x1 == x2 or x1 == x3 or x2 == x3 or y1 == y2 or y1 == y3 or y2 == y3:\n        return 2\n    # If no two points share the same x-coordinate or y-coordinate\n    else:\n        return 3\n\n# Read input\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\n# Output the result\nprint(min_segments(x1, y1, x2, y2, x3, y3))"}
{"solution": "def construct_k_regular_graph_with_bridge(k):\n    if k == 1:\n        return \"YES\\n2 1\\n1 2\"\n    elif k % 2 == 0:\n        n = k + 2\n        edges = []\n        # Connect the first k vertices in a cycle\n        for i in range(1, k + 1):\n            edges.append((i, i + 1 if i < k else 1))\n        # Connect the last two vertices to all others to make it k-regular\n        for i in range(1, k + 1):\n            edges.append((i, k + 1))\n            edges.append((i, k + 2))\n        # The bridge will be between the last two vertices\n        edges.append((k + 1, k + 2))\n        return f\"YES\\n{n} {len(edges)}\\n\" + \"\\n\".join(f\"{a} {b}\" for a, b in edges)\n    else:\n        return \"NO\"\n\n# Read input\nk = int(input())\n# Output the result\nprint(construct_k_regular_graph_with_bridge(k))"}
{"solution": "def preprocess(s, t):\n    n = len(s)\n    m = len(t)\n    prefix_counts = [0] * (n + 1)\n    \n    for i in range(n - m + 1):\n        if s[i:i + m] == t:\n            prefix_counts[i + m] = 1\n    \n    for i in range(1, n + 1):\n        prefix_counts[i] += prefix_counts[i - 1]\n    \n    return prefix_counts\n\ndef count_occurrences(s, t, queries):\n    prefix_counts = preprocess(s, t)\n    results = []\n    \n    for l, r in queries:\n        if r - l + 1 < len(t):\n            results.append(0)\n        else:\n            results.append(prefix_counts[r - len(t) + 1] - prefix_counts[l - 1])\n    \n    return results\n\n# Read input\nn, m, q = map(int, input().split())\ns = input().strip()\nt = input().strip()\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Get results and print them\nresults = count_occurrences(s, t, queries)\nfor result in results:\n    print(result)"}
{"solution": "MOD = 1000000007\n\ndef count_paths(n, k, d):\n    # Initialize a DP table where dp[i][j] represents the number of ways to achieve weight i\n    # with j indicating whether a path contains at least one edge of weight at least d\n    dp = [[0 for _ in range(2)] for _ in range(n + 1)]\n    \n    # Base case: There's one way to achieve weight 0 (using no edges) without any edge of weight at least d\n    dp[0][0] = 1\n    \n    for weight in range(1, n + 1):\n        for edge_weight in range(1, k + 1):\n            if weight >= edge_weight:\n                if edge_weight >= d:\n                    dp[weight][1] = (dp[weight][1] + dp[weight - edge_weight][0]) % MOD\n                else:\n                    dp[weight][0] = (dp[weight][0] + dp[weight - edge_weight][0]) % MOD\n                    dp[weight][1] = (dp[weight][1] + dp[weight - edge_weight][1]) % MOD\n    \n    # The answer is the number of paths of total weight n that contain at least one edge of weight at least d\n    return dp[n][1]\n\n# Read input\nn, k, d = map(int, input().split())\n\n# Print the output\nprint(count_paths(n, k, d))"}
{"solution": "def encrypt_japanese_crossword(n, row):\n    groups = []\n    count = 0\n    \n    for char in row:\n        if char == 'B':\n            count += 1\n        else:\n            if count > 0:\n                groups.append(count)\n                count = 0\n    \n    if count > 0:\n        groups.append(count)\n    \n    print(len(groups))\n    if groups:\n        print(\" \".join(map(str, groups)))\n\n# Example usage:\n# n = int(input())\n# row = input().strip()\n# encrypt_japanese_crossword(n, row)"}
{"solution": "class TextEditor:\n    def __init__(self, n, m, p, cbs, operations):\n        self.n = n\n        self.m = m\n        self.p = p\n        self.cbs = list(cbs)\n        self.operations = operations\n        self.pair_map = self.create_pair_map()\n\n    def create_pair_map(self):\n        stack = []\n        pair_map = {}\n        for i, bracket in enumerate(self.cbs):\n            if bracket == '(':\n                stack.append(i)\n            else:\n                paired_index = stack.pop()\n                pair_map[i] = paired_index\n                pair_map[paired_index] = i\n        return pair_map\n\n    def execute_operations(self):\n        for operation in self.operations:\n            if operation == 'L':\n                self.p = max(1, self.p - 1)\n            elif operation == 'R':\n                self.p = min(self.n, self.p + 1)\n            elif operation == 'D':\n                start, end = sorted([self.p - 1, self.pair_map[self.p - 1]])\n                self.cbs = self.cbs[:start] + self.cbs[end + 1:]\n                self.n -= (end - start + 1)\n                if self.p - 1 == end:\n                    self.p = max(1, start)\n                else:\n                    self.p = min(self.n, end + 1)\n                self.pair_map = self.create_pair_map()\n\n    def get_result(self):\n        return ''.join(self.cbs)\n\ndef main():\n    n, m, p = map(int, input().split())\n    cbs = input().strip()\n    operations = input().strip()\n    editor = TextEditor(n, m, p, cbs, operations)\n    editor.execute_operations()\n    print(editor.get_result())\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_valid_y(n, questions_answers):\n    min_y = -2 * 10**9\n    max_y = 2 * 10**9\n    \n    for qa in questions_answers:\n        sign, x, answer = qa.split()\n        x = int(x)\n        \n        if sign == '>':\n            if answer == 'Y':\n                min_y = max(min_y, x + 1)\n            else:\n                max_y = min(max_y, x)\n        elif sign == '<':\n            if answer == 'Y':\n                max_y = min(max_y, x - 1)\n            else:\n                min_y = max(min_y, x)\n        elif sign == '>=':\n            if answer == 'Y':\n                min_y = max(min_y, x)\n            else:\n                max_y = min(max_y, x - 1)\n        elif sign == '<=':\n            if answer == 'Y':\n                max_y = min(max_y, x)\n            else:\n                min_y = max(min_y, x + 1)\n    \n    if min_y > max_y:\n        return \"Impossible\"\n    else:\n        return min_y\n\n# Read input\nn = int(input())\nquestions_answers = [input() for _ in range(n)]\n\n# Find and print the result\nprint(find_valid_y(n, questions_answers))"}
{"solution": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef count_periods(a, b):\n    if a == 0 or b == 0:\n        return 1\n    total = a + b\n    return gcd(a, total)\n\na, b = map(int, input().split())\nprint(count_periods(a, b))"}
{"solution": "def generate_names(n, k, conditions):\n    # Predefined list of unique names\n    names = [\"Adam\", \"Bob\", \"Charlie\", \"David\", \"Edward\", \"Frank\", \"George\", \"Henry\", \"Isaac\", \"Jack\",\n             \"Kyle\", \"Liam\", \"Mason\", \"Noah\", \"Oliver\", \"Parker\", \"Quinn\", \"Ryan\", \"Samuel\", \"Thomas\",\n             \"Ulysses\", \"Victor\", \"William\", \"Xavier\", \"Yusuf\", \"Zachary\"]\n    \n    # Initialize the result list with the first k names\n    result = names[:k]\n    \n    for i in range(1, n - k + 1):\n        if conditions[i - 1] == \"YES\":\n            # If the group should be effective, add a new unique name\n            result.append(names[k + i - 1])\n        else:\n            # If the group should not be effective, repeat the last name\n            result.append(result[-1])\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\nconditions = input().split()\n\n# Generate and print the names\nnames = generate_names(n, k, conditions)\nprint(\" \".join(names))"}
{"solution": "def min_operations_to_equal(a, b):\n    def count_factors(n, factor):\n        count = 0\n        while n % factor == 0:\n            n //= factor\n            count += 1\n        return count, n\n\n    a2, a = count_factors(a, 2)\n    a3, a = count_factors(a, 3)\n    a5, a = count_factors(a, 5)\n    \n    b2, b = count_factors(b, 2)\n    b3, b = count_factors(b, 3)\n    b5, b = count_factors(b, 5)\n    \n    if a != b:\n        return -1\n    \n    operations = abs(a2 - b2) + abs(a3 - b3) + abs(a5 - b5)\n    \n    return operations\n\n# Read input\na, b = map(int, input().split())\n\n# Print output\nprint(min_operations_to_equal(a, b))"}
{"solution": "def minimal_cost_to_palindrome(n, a, b, colors):\n    # Check if it's already a palindrome\n    for i in range(n // 2):\n        if colors[i] != 2 and colors[n - i - 1] != 2 and colors[i] != colors[n - i - 1]:\n            return -1\n\n    # Calculate the minimal cost\n    cost = 0\n    for i in range(n // 2):\n        if colors[i] == 2 and colors[n - i - 1] == 2:\n            cost += 2 * min(a, b)\n        elif colors[i] == 2 or colors[n - i - 1] == 2:\n            if colors[i] == 0 or colors[n - i - 1] == 0:\n                cost += a\n            else:\n                cost += b\n        elif colors[i] == colors[n - i - 1]:\n            continue\n\n    # Handle the middle element if n is odd\n    if n % 2 == 1 and colors[n // 2] == 2:\n        cost += min(a, b)\n\n    return cost\n\n# Read input\nn, a, b = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(minimal_cost_to_palindrome(n, a, b, colors))"}
{"solution": "def paint_cube(k):\n    if k == 1:\n        return -1\n    \n    # Initialize the cube with 'b' for black\n    cube = [['b' for _ in range(k)] for _ in range(k)]\n    \n    # Paint the cube according to the conditions\n    for layer in range(k):\n        for row in range(k):\n            for col in range(k):\n                # Check if the current position should be white\n                if (layer + row + col) % 2 == 0:\n                    cube[layer][row * k + col] = 'w'\n                else:\n                    cube[layer][row * k + col] = 'b'\n    \n    return cube\n\ndef print_cube(cube, k):\n    if cube == -1:\n        print(-1)\n    else:\n        for layer in cube:\n            for i in range(0, len(layer), k):\n                print(''.join(layer[i:i+k]))\n            print()  # Print an empty line after each layer\n\n# Read input\nk = int(input().strip())\n\n# Get the solution\nsolution = paint_cube(k)\n\n# Print the solution\nprint_cube(solution, k)"}
{"solution": "def largest_lovely_number(n):\n    import math\n    from collections import Counter\n\n    def prime_factors(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            while (n % i) == 0:\n                factors.append(i)\n                n //= i\n            i += 1\n        if n > 1:\n            factors.append(n)\n        return factors\n\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n    \n    lovely_number = 1\n    for prime, count in factor_counts.items():\n        lovely_number *= prime\n    \n    return lovely_number\n\n# Read input\nn = int(input())\nprint(largest_lovely_number(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    # Check for adjacent occupied seats\n    for i in range(n - 1):\n        if seating[i] == '1' and seating[i + 1] == '1':\n            return \"No\"\n    \n    # Check for possible additional seating\n    for i in range(n):\n        if seating[i] == '0':\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nn = int(input())\nseating = input().strip()\n\n# Print output\nprint(is_maximal_seating(n, seating))"}
{"solution": "def find_possible_k(n, a):\n    possible_k = []\n    \n    # Check each possible k from 1 to n\n    for k in range(1, n + 1):\n        valid = True\n        # Calculate the expected x values based on the current k\n        x_values = [a[i] - a[i - 1] for i in range(1, k)]\n        for i in range(k, n + 1):\n            if a[i] - a[i - 1] != x_values[(i - 1) % k]:\n                valid = False\n                break\n        if valid:\n            possible_k.append(k)\n    \n    return possible_k\n\n# Read input\nn = int(input())\na = [0] + list(map(int, input().split()))  # Include a_0 as 0 for simplicity\n\n# Find all possible values of k\npossible_k = find_possible_k(n, a)\n\n# Output the result\nprint(len(possible_k))\nprint(' '.join(map(str, possible_k)))"}
{"solution": "def can_form_equal_teams(scores):\n    total_score = sum(scores)\n    # Since we need to form two teams of three, the total score must be even for equal teams to be possible\n    if total_score % 2 != 0:\n        return \"NO\"\n    \n    half_score = total_score // 2\n    # Check if we can find a combination of three scores that sum up to half the total score\n    for i in range(6):\n        for j in range(i + 1, 6):\n            for k in range(j + 1, 6):\n                if scores[i] + scores[j] + scores[k] == half_score:\n                    return \"YES\"\n    return \"NO\"\n\n# Read input\nscores = list(map(int, input().split()))\n\n# Output result\nprint(can_form_equal_teams(scores))"}
{"solution": "def count_2_3_integers(l, r):\n    count = 0\n    x = 0\n    while True:\n        y = 0\n        while True:\n            num = (2 ** x) * (3 ** y)\n            if num > r:\n                break\n            if l <= num <= r:\n                count += 1\n            y += 1\n        if 2 ** x > r:\n            break\n        x += 1\n    return count\n\n# Read input\nl, r = map(int, input().split())\n\n# Output the result\nprint(count_2_3_integers(l, r))"}
{"solution": "def find_candies_eaten(n, k):\n    # Initialize the number of candies eaten\n    candies_eaten = 0\n    \n    # Calculate the maximum number of candies that could be in the box if only adding candies\n    max_candies = (n * (n + 1)) // 2 - (n - 1)\n    \n    # If the final number of candies is less than or equal to the maximum possible by adding only,\n    # then all actions were adding candies except for the last one which could be eating a candy\n    if k == max_candies:\n        return n - 1\n    \n    # Binary search to find the number of candies added before starting to eat\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        added_candies = (mid * (mid + 1)) // 2\n        if added_candies >= k:\n            right = mid\n        else:\n            left = mid + 1\n    \n    # The number of candies added before starting to eat\n    added_before_eat = left\n    \n    # The total number of candies in the box after adding before eating\n    total_added = (added_before_eat * (added_before_eat + 1)) // 2\n    \n    # The number of candies eaten is the difference between total added and final candies\n    candies_eaten = total_added - k\n    \n    # The total number of actions is n, so the number of candies eaten is n minus the number of adding actions\n    return candies_eaten + (n - added_before_eat)\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the result\nprint(find_candies_eaten(n, k))"}
{"solution": "def can_form_triangle(n, lengths):\n    lengths.sort()\n    for i in range(n - 2):\n        if lengths[i] + lengths[i + 1] > lengths[i + 2]:\n            return \"YES\"\n    return \"NO\"\n\n# Reading input\nn = int(input())\nlengths = list(map(int, input().split()))\n\n# Output result\nprint(can_form_triangle(n, lengths))"}
{"solution": "def can_achieve_configuration(x, y):\n    # Initially, Imp has 1 original toy and 0 copies.\n    # We need to check if we can reach y original toys and x copies.\n    \n    # If y is 1, it means we cannot apply the machine to any toy since we need at least one original toy to start.\n    if y == 1:\n        return x == 0  # The only possible configuration is 1 original toy and 0 copies.\n    \n    # We start with 1 original toy.\n    original = 1\n    copies = 0\n    \n    # We need to apply the machine y-1 times to the original toys to get y original toys.\n    # Each time we apply the machine to an original toy, we get 1 more original and 1 copy.\n    # So, after y-1 applications, we have y original toys and y-1 copies.\n    original = y\n    copies = y - 1\n    \n    # Now, we need to check if we can get x copies by applying the machine to copies.\n    # Each application to a copy gives us 2 more copies.\n    # We need to check if (x - (y - 1)) is even and non-negative, because we can only increase copies in steps of 2.\n    if x >= y - 1 and (x - (y - 1)) % 2 == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input\nx, y = map(int, input().split())\n\n# Print output\nprint(can_achieve_configuration(x, y))"}
{"solution": "def maximize_rating(n, k, skills):\n    # Calculate the initial total rating\n    initial_rating = sum(a // 10 for a in skills)\n    \n    # Calculate the number of units needed to increase each skill to the next multiple of 10\n    units_needed = [(10 - (a % 10)) % 10 for a in skills if a < 100]\n    \n    # Sort the units needed in ascending order to prioritize skills requiring fewer units\n    units_needed.sort()\n    \n    # Allocate units to increase skills to the next multiple of 10\n    for units in units_needed:\n        if k >= units:\n            k -= units\n            initial_rating += 1\n        else:\n            break\n    \n    # Use remaining units to increase skills as much as possible without exceeding 100\n    for i in range(n):\n        if skills[i] < 100:\n            # Calculate the maximum units that can be used on this skill without exceeding 100\n            max_units = min(100 - skills[i], k)\n            k -= max_units\n            skills[i] += max_units\n            initial_rating += max_units // 10\n        \n        # If no units left, break the loop\n        if k == 0:\n            break\n    \n    return initial_rating\n\n# Read input\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Calculate and print the maximum total rating\nprint(maximize_rating(n, k, skills))"}
{"solution": "def find_smallest_pretty_integer(n, m, list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    common_digits = set1.intersection(set2)\n    if common_digits:\n        return min(common_digits)\n    \n    min1 = min(list1)\n    min2 = min(list2)\n    \n    smallest_pretty = min(int(str(min1) + str(min2)), int(str(min2) + str(min1)))\n    return smallest_pretty\n\n# Reading input\nn, m = map(int, input().split())\nlist1 = list(map(int, input().split()))\nlist2 = list(map(int, input().split()))\n\n# Output the result\nprint(find_smallest_pretty_integer(n, m, list1, list2))"}
{"solution": "def max_problems_solved(n, k):\n    total_time_available = 240 - k  # Total time available to solve problems\n    problems_solved = 0\n    time_spent = 0\n\n    for i in range(1, n + 1):\n        time_to_solve = 5 * i\n        if time_spent + time_to_solve <= total_time_available:\n            time_spent += time_to_solve\n            problems_solved += 1\n        else:\n            break\n\n    return problems_solved\n\n# Reading input\nn, k = map(int, input().split())\n\n# Printing output\nprint(max_problems_solved(n, k))"}
{"solution": "def max_teams(n, x, y, a):\n    a.sort()\n    double_sided = x\n    single_sided = y\n    count = 0\n\n    for pages in a:\n        double_needed = pages // 2\n        single_needed = pages % 2\n\n        if double_needed <= double_sided:\n            double_sided -= double_needed\n            if single_needed <= single_sided:\n                single_sided -= single_needed\n                count += 1\n            else:\n                double_sided += double_needed\n                break\n        else:\n            remaining_pages = pages - 2 * double_sided\n            if remaining_pages <= single_sided:\n                single_sided -= remaining_pages\n                double_sided = 0\n                count += 1\n            else:\n                break\n\n    return count\n\n# \u0427\u0442\u0435\u043d\u0438\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\n# \u0412\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\nprint(max_teams(n, x, y, a))"}
{"solution": "def count_divisors(n):\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return len(divisors)\n\n# Read input\nb = int(input().strip())\n\n# Calculate the number of distinct values\nresult = count_divisors(b)\n\n# Print the result\nprint(result)"}
{"solution": "def count_falling_positions(n, bumpers):\n    # Initialize the count of positions where the ball will fall\n    count = 0\n    \n    # Check for '<' at the beginning and '>' at the end\n    for i in range(n):\n        if bumpers[i] == '<' or bumpers[n - 1 - i] == '>':\n            count += 1\n        else:\n            break\n    \n    return count\n\n# Read input\nn = int(input())\nbumpers = input()\n\n# Calculate and print the result\nprint(count_falling_positions(n, bumpers))"}
{"solution": "def max_rectangle_area(n, lengths):\n    from collections import Counter\n    \n    # Count the occurrences of each length\n    length_counts = Counter(lengths)\n    \n    # Sort the unique lengths\n    unique_lengths = sorted(length_counts.keys())\n    \n    # Initialize variables\n    max_area = 0\n    i = len(unique_lengths) - 1\n    \n    # Iterate from the longest stick to the shortest\n    while i >= 0:\n        length = unique_lengths[i]\n        count = length_counts[length]\n        \n        # If there are at least two sticks of the same length\n        while count >= 2:\n            count -= 2\n            length_counts[length] = count\n            \n            # Try to find a pair for the second side of the rectangle\n            for j in range(i, -1, -1):\n                if length_counts[unique_lengths[j]] >= 2:\n                    # Calculate the area and update max_area if it's larger\n                    area = length * unique_lengths[j]\n                    max_area += area\n                    length_counts[unique_lengths[j]] -= 2\n                    break\n            else:\n                # If no pair is found, try reducing the current length by 1\n                if length > 2 and length_counts[length - 1] >= 2:\n                    area = (length - 1) * (length - 1)\n                    max_area += area\n                    length_counts[length - 1] -= 2\n        \n        # Move to the next length\n        i -= 1\n    \n    return max_area\n\n# Read input\nn = int(input())\nlengths = list(map(int, input().split()))\n\n# Calculate and print the maximum total area\nprint(max_rectangle_area(n, lengths))"}
{"solution": "from collections import defaultdict\nfrom itertools import permutations\n\ndef restore_numbers(n, strings):\n    # Create a dictionary to map letters to digits\n    letter_to_digit = {}\n    # Create a list to store the restored numbers\n    restored_numbers = []\n    \n    # Function to convert a string of letters to a number based on the current mapping\n    def convert_to_number(s):\n        num = 0\n        for char in s:\n            num = num * 10 + letter_to_digit[char]\n        return num\n    \n    # Generate all possible permutations of the digits 1-9 for the letters 'a'-'j'\n    for perm in permutations(range(1, 10), len(set(''.join(strings)))):\n        # Assign the permutation to the letters\n        letter_to_digit = {letter: digit for letter, digit in zip(set(''.join(strings)), perm)}\n        \n        # Convert each string to a number and check for leading zeros\n        valid = True\n        for s in strings:\n            if letter_to_digit[s[0]] == 0:\n                valid = False\n                break\n        \n        # If valid, calculate the sum of the restored numbers\n        if valid:\n            sum_of_numbers = sum(convert_to_number(s) for s in strings)\n            restored_numbers.append(sum_of_numbers)\n    \n    # Return the minimum sum of the restored numbers\n    return min(restored_numbers)\n\n# Read input\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(restore_numbers(n, strings))"}
{"solution": "def max_teams(n, m):\n    # Binary search to find the maximum number of teams\n    low, high = 0, min(n, m, (n + m) // 3)\n    \n    while low < high:\n        mid = (low + high + 1) // 2\n        if mid <= n and mid <= m and 2 * mid <= n + m:\n            low = mid\n        else:\n            high = mid - 1\n    \n    return low\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    n = len(s)\n    \n    # Check for \"AB\" followed by \"BA\"\n    found_AB = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"AB\":\n            found_AB = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"BA\":\n                    print(\"YES\")\n                    return\n            break\n    \n    # Check for \"BA\" followed by \"AB\"\n    found_BA = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"BA\":\n            found_BA = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"AB\":\n                    print(\"YES\")\n                    return\n            break\n    \n    # If neither condition is met\n    print(\"NO\")\n\n# Example usage\ns = input().strip()\ncheck_substrings(s)"}
{"solution": "def can_monsters_eat(n, initial_weights, k, final_weights):\n    if n != k + sum(final_weights):\n        return \"NO\"\n    \n    def find_eaters(weights, target_weights):\n        eaters = []\n        stack = []\n        for weight in weights:\n            if weight in target_weights:\n                if stack:\n                    eaters.append(stack)\n                stack = [weight]\n            else:\n                stack.append(weight)\n        if stack:\n            eaters.append(stack)\n        return eaters\n    \n    eaters = find_eaters(initial_weights, final_weights)\n    \n    actions = []\n    for i, eater_group in enumerate(eaters):\n        total_weight = eater_group[-1]\n        for weight in eater_group[:-1]:\n            if weight >= total_weight:\n                return \"NO\"\n            total_weight += weight\n            actions.append((i + 1, 'L' if weight == eater_group[0] else 'R'))\n    \n    result = [\"YES\"]\n    for action in actions:\n        result.append(f\"{action[0]} {action[1]}\")\n    \n    return \"\\n\".join(result)\n\n# Example usage:\n# n = 6\n# initial_weights = [1, 2, 2, 2, 1, 2]\n# k = 2\n# final_weights = [5, 5]\n# print(can_monsters_eat(n, initial_weights, k, final_weights))"}
{"solution": "def is_possible_to_assign(R, B, spaceships, bases):\n    if R != B:\n        return \"No\"\n    \n    # Sort spaceships and bases by their x-coordinate, then by y-coordinate\n    spaceships.sort(key=lambda x: (x[0], x[1]))\n    bases.sort(key=lambda x: (x[0], x[1]))\n    \n    # Check for intersection of paths\n    for i in range(R):\n        for j in range(i+1, R):\n            # Paths intersect if one point is to the left of another and its corresponding point is to the right\n            if (spaceships[i][0] < spaceships[j][0] and bases[i][0] > bases[j][0]) or \\\n               (spaceships[i][0] > spaceships[j][0] and bases[i][0] < bases[j][0]):\n                return \"No\"\n            # Check for vertical intersection\n            elif spaceships[i][0] == spaceships[j][0] and bases[i][0] == bases[j][0]:\n                if (spaceships[i][1] < spaceships[j][1] and bases[i][1] > bases[j][1]) or \\\n                   (spaceships[i][1] > spaceships[j][1] and bases[i][1] < bases[j][1]):\n                    return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nR, B = map(int, input().split())\nspaceships = [tuple(map(int, input().split())) for _ in range(R)]\nbases = [tuple(map(int, input().split())) for _ in range(B)]\n\n# Output result\nprint(is_possible_to_assign(R, B, spaceships, bases))"}
{"solution": "def max_power_of_two_divisor(sequence):\n    max_power = 0\n    count = 0\n    for number in sequence:\n        power = 0\n        while number % 2 == 0:\n            number //= 2\n            power += 1\n        if power > max_power:\n            max_power = power\n            count = 1\n        elif power == max_power:\n            count += 1\n    return max_power, count\n\ndef main():\n    n = int(input())\n    sequence = list(map(int, input().split()))\n    r, count = max_power_of_two_divisor(sequence)\n    print(2**r, count)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_clicks_to_transform(n, m):\n    clicks = 0\n    while m > n:\n        if m % 2 == 0:\n            m //= 2\n        else:\n            m += 1\n        clicks += 1\n    return clicks + (n - m)\n\n# Assuming the input is provided in the format specified\nn, m = map(int, input().split())\nprint(min_clicks_to_transform(n, m))"}
{"solution": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            if self.rank[rootX] > self.rank[rootY]:\n                self.parent[rootY] = rootX\n            elif self.rank[rootX] < self.rank[rootY]:\n                self.parent[rootX] = rootY\n            else:\n                self.parent[rootY] = rootX\n                self.rank[rootX] += 1\n            return True\n        return False\n\ndef isTree(n, segments):\n    uf = UnionFind(n)\n    edges = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if segments[i][0] < segments[j][0] < segments[i][1] < segments[j][1] or segments[j][0] < segments[i][0] < segments[j][1] < segments[i][1]:\n                if not uf.union(i, j):\n                    return \"NO\"\n                edges += 1\n            elif not (segments[i][1] <= segments[j][0] or segments[j][1] <= segments[i][0]):\n                return \"NO\"\n    return \"YES\" if edges == n - 1 else \"NO\"\n\nn = int(input().strip())\nsegments = [tuple(map(int, input().strip().split())) for _ in range(n)]\nprint(isTree(n, segments))"}
{"solution": "def longest_ddos_period(n, requests):\n    max_length = 0\n    for start in range(n):\n        total_requests = 0\n        for end in range(start, n):\n            total_requests += requests[end]\n            if total_requests > 100 * (end - start + 1):\n                max_length = max(max_length, end - start + 1)\n    return max_length\n\n# Reading input\nn = int(input())\nrequests = list(map(int, input().split()))\n\n# Output the result\nprint(longest_ddos_period(n, requests))"}
{"solution": "def can_dissatisfaction_be_exactly_k(n, k, sequence):\n    # Initialize variables to track the maximum dissatisfaction and the current streak of 'N's\n    max_dissatisfaction = 0\n    current_streak = 0\n    for episode in sequence:\n        if episode == 'N':\n            current_streak += 1\n            max_dissatisfaction = max(max_dissatisfaction, current_streak)\n        else:\n            current_streak = 0\n    \n    # If the maximum dissatisfaction is already greater than k, return \"NO\"\n    if max_dissatisfaction > k:\n        return \"NO\"\n    \n    # If the maximum dissatisfaction is exactly k, return \"YES\"\n    if max_dissatisfaction == k:\n        return \"YES\"\n    \n    # If there are enough '?' to potentially increase the dissatisfaction to k, check further\n    if '?' in sequence:\n        # Count the number of '?' and 'N' in the sequence\n        question_marks = sequence.count('?')\n        nos = sequence.count('N')\n        \n        # If we can replace '?' with 'N' to reach exactly k dissatisfaction, return \"YES\"\n        if max_dissatisfaction + question_marks >= k and nos + question_marks - k >= 0:\n            return \"YES\"\n    \n    # If none of the above conditions are met, return \"NO\"\n    return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\nsequence = input()\n\n# Print the result\nprint(can_dissatisfaction_be_exactly_k(n, k, sequence))"}
{"solution": "def count_possible_values(N, X, D):\n    if D == 0:\n        return 1 if X == 0 else N + 1\n    \n    # Calculate the sequence\n    sequence = [X + i * D for i in range(N)]\n    \n    # Calculate the sum of the sequence\n    total_sum = sum(sequence)\n    \n    # Calculate the number of possible values of S - T\n    # The difference between the sums of any two subsets of the sequence can range from -total_sum to total_sum\n    # However, we need to consider the constraints and the fact that the sequence is arithmetic\n    \n    # The number of possible values is the number of distinct sums of pairs of subsets\n    # This can be calculated by considering the number of ways to partition the sequence into two subsets\n    # For each element, it can either be in Takahashi's subset or Aoki's subset, giving us 2^N possibilities\n    # However, we need to subtract the cases where either subset is empty, which gives us 2^N - 2\n    # Since we are interested in the absolute difference, we multiply by 2 (for positive and negative differences)\n    # and subtract 1 (to exclude the case where both subsets are empty, which gives a difference of 0)\n    \n    return 2**N - 1\n\n# Read input\nN, X, D = map(int, input().split())\n\n# Output the result\nprint(count_possible_values(N, X, D))"}
{"solution": "def did_anton_perform_good(n, participants):\n    for participant in participants:\n        handle, before, after = participant\n        if before >= 2400 and after > before:\n            return \"YES\"\n    return \"NO\"\n\n# Reading input\nn = int(input())\nparticipants = [input().split() for _ in range(n)]\nparticipants = [(handle, int(before), int(after)) for handle, before, after in participants]\n\n# Output result\nprint(did_anton_perform_good(n, participants))"}
{"solution": "def count_missed_trains(s):\n    # Convert the binary string to an integer\n    s_decimal = int(s, 2)\n    \n    # Initialize the count of missed trains\n    missed_trains = 0\n    \n    # Initialize the power of 4\n    power_of_4 = 1\n    \n    # Loop until the power of 4 is greater than s_decimal\n    while power_of_4 < s_decimal:\n        # Increment the count of missed trains\n        missed_trains += 1\n        \n        # Calculate the next power of 4\n        power_of_4 *= 4\n    \n    return missed_trains\n\n# Read the input\ns = input().strip()\n\n# Output the result\nprint(count_missed_trains(s))"}
{"solution": "def min_rows_for_mirroring(n, m, matrix_a):\n    # Function to check if the matrix can be formed by mirroring a smaller matrix\n    def can_form_by_mirroring(rows):\n        for i in range(rows):\n            for j in range(m):\n                if matrix_a[i][j] != matrix_a[2 * rows - i - 1][j]:\n                    return False\n        return True\n\n    # Start with the smallest possible number of rows and increase until we find the minimum\n    for rows in range(1, n + 1):\n        if n % rows == 0 and can_form_by_mirroring(rows):\n            return rows\n    return n  # If no smaller matrix can be found, the original matrix itself is the answer\n\n# Read input\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(min_rows_for_mirroring(n, m, matrix_a))"}
{"solution": "def max_orders(n, orders):\n    # Sort orders by their finish time\n    orders.sort(key=lambda x: x[1])\n    \n    # Initialize variables to keep track of the last finish time and the count of accepted orders\n    last_finish = -1\n    accepted_count = 0\n    \n    # Iterate through the sorted orders\n    for order in orders:\n        # If the start time of the current order is after the last finish time, accept the order\n        if order[0] > last_finish:\n            accepted_count += 1\n            last_finish = order[1]\n    \n    return accepted_count\n\n# Read input\nn = int(input())\norders = [list(map(int, input().split())) for _ in range(n)]\n\n# Print the result\nprint(max_orders(n, orders))"}
{"solution": "def can_vova_avoid_boredom(n, k, tables, formulas):\n    max_tables_in_row = 0\n    max_formulas_in_row = 0\n    current_tables_in_row = 0\n    current_formulas_in_row = 0\n\n    for i in range(n):\n        current_tables_in_row += tables[i]\n        current_formulas_in_row += formulas[i]\n\n        # If the current row of tables or formulas exceeds k, we need to rearrange\n        while current_tables_in_row > k or current_formulas_in_row > k:\n            # Try to rearrange by swapping a table with a formula if possible\n            if current_tables_in_row > k and current_formulas_in_row < k:\n                # Swap a table with a formula\n                swap_count = min(current_tables_in_row - k, k - current_formulas_in_row)\n                current_tables_in_row -= swap_count\n                current_formulas_in_row += swap_count\n            elif current_formulas_in_row > k and current_tables_in_row < k:\n                # Swap a formula with a table\n                swap_count = min(current_formulas_in_row - k, k - current_tables_in_row)\n                current_formulas_in_row -= swap_count\n                current_tables_in_row += swap_count\n            else:\n                # If we can't rearrange, update the max counts and reset the current counts\n                max_tables_in_row = max(max_tables_in_row, current_tables_in_row)\n                max_formulas_in_row = max(max_formulas_in_row, current_formulas_in_row)\n                current_tables_in_row = tables[i]\n                current_formulas_in_row = formulas[i]\n\n        # Update the max counts after processing each page\n        max_tables_in_row = max(max_tables_in_row, current_tables_in_row)\n        max_formulas_in_row = max(max_formulas_in_row, current_formulas_in_row)\n\n        # If at any point the max counts exceed k, return \"NO\"\n        if max_tables_in_row > k or max_formulas_in_row > k:\n            return \"NO\"\n\n    return \"YES\"\n\n# Example usage:\n# n, k = 2, 2\n# tables = [5, 5]\n# formulas = [2, 2]\n# print(can_vova_avoid_boredom(n, k, tables, formulas))  # Output: YES"}
{"solution": "def can_human_guarantee_victory(n, k, coefficients):\n    # Check if the polynomial is already divisible by Q(x) = x - k\n    def is_divisible_by_q(coefficients, k):\n        # Evaluate the polynomial at x = k\n        result = 0\n        for coeff in reversed(coefficients):\n            result = result * k + coeff\n        return result == 0\n\n    # If all coefficients are defined, check divisibility\n    if '?' not in coefficients:\n        return \"Yes\" if is_divisible_by_q(coefficients, k) else \"No\"\n\n    # If there's at least one undefined coefficient, simulate optimal play\n    # The human can always guarantee a victory if they can set the last coefficient to -k times the sum of the other coefficients\n    # This is because setting the last coefficient in this way will make the polynomial divisible by x - k\n    # The computer will try to prevent this by setting coefficients in a way that makes the sum of the other coefficients non-zero\n\n    # Calculate the sum of the known coefficients\n    known_sum = sum(coeff for coeff in coefficients if coeff != '?')\n\n    # Count the number of undefined coefficients\n    undefined_count = coefficients.count('?')\n\n    # If there's an odd number of undefined coefficients, the human can always win by setting the last coefficient optimally\n    if undefined_count % 2 == 1:\n        return \"Yes\"\n\n    # If there's an even number of undefined coefficients, the outcome depends on the known sum\n    # If the known sum is zero, the human can't guarantee a victory because the computer can always set coefficients to zero\n    # If the known sum is non-zero, the human can still guarantee a victory by setting the last coefficient to -k times the known sum\n    return \"No\" if known_sum == 0 else \"Yes\"\n\n# Read input\nn, k = map(int, input().split())\ncoefficients = [int(input()) if input() != '?' else '?' for _ in range(n + 1)]\n\n# Determine if the human can guarantee a victory\nresult = can_human_guarantee_victory(n, k, coefficients)\n\n# Print the result\nprint(result)"}
{"solution": "def smallest_prime_factor(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return i\n    return n\n\ndef find_smallest_X0(X2):\n    # Start from the smallest possible X0 which is 3\n    X0 = 3\n    while True:\n        # Simulate the game to see if we can reach X2 starting from X0\n        X1 = X0\n        # Alice's turn\n        p1 = smallest_prime_factor(X1)\n        X1 = max(X1, (X1 // p1 + (1 if X1 % p1 else 0)) * p1)\n        # Bob's turn\n        p2 = smallest_prime_factor(X1)\n        X1 = max(X1, (X1 // p2 + (1 if X1 % p2 else 0)) * p2)\n        \n        # If we can reach X2, then X0 is the answer\n        if X1 == X2:\n            return X0\n        # Otherwise, increment X0 and try again\n        X0 += 1\n\n# Read input\nX2 = int(input())\n\n# Find and print the smallest possible X0\nprint(find_smallest_X0(X2))"}
{"solution": "def min_p_binary_summands(n, p):\n    def can_form_n(n, count):\n        # Calculate the potential sum of p-binary numbers\n        potential_sum = count * p\n        # Check if the remaining value can be formed by powers of 2\n        remaining = n - potential_sum\n        if remaining < 0:\n            return False\n        # Count the number of 1s in the binary representation of remaining\n        ones_count = bin(remaining).count('1')\n        return ones_count <= count <= remaining\n\n    for count in range(1, 32):  # Since 2^31 is the largest power of 2 within 10^9\n        if can_form_n(n, count):\n            return count\n    return -1\n\n# Example usage:\n# n, p = map(int, input().split())\n# print(min_p_binary_summands(n, p))"}
{"solution": "def minimize_integer(n, k, S):\n    S = list(S)\n    changes = 0\n    \n    # Change the first digit if necessary\n    if n > 1 and S[0] != '1':\n        S[0] = '1'\n        changes += 1\n    \n    # Change subsequent digits to '0'\n    for i in range(1, n):\n        if changes >= k:\n            break\n        if S[i] != '0':\n            S[i] = '0'\n            changes += 1\n    \n    return ''.join(S)\n\n# Read input\nn, k = map(int, input().split())\nS = input().strip()\n\n# Output the result\nprint(minimize_integer(n, k, S))"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_min_v(cnt_1, cnt_2, x, y):\n    # Ensure x is the smaller prime\n    if x > y:\n        x, y = y, x\n    \n    # Start with the smallest possible v that could satisfy the conditions\n    v = max(cnt_1 * x, cnt_2 * y) - 1\n    \n    # Function to count numbers disliked by a friend up to a given number\n    def count_disliked(limit, prime):\n        return limit // prime\n    \n    # Binary search to find the minimum v\n    left, right = 1, v + max(cnt_1, cnt_2)\n    while left < right:\n        mid = (left + right) // 2\n        disliked_by_1 = count_disliked(mid, x)\n        disliked_by_2 = count_disliked(mid, y)\n        # Numbers disliked by both (since they are primes and co-prime, their product is unique)\n        disliked_by_both = count_disliked(mid, x * y)\n        \n        # Available numbers for each friend\n        available_for_1 = mid - disliked_by_1\n        available_for_2 = mid - disliked_by_2\n        \n        # Check if we can distribute the numbers as required\n        if available_for_1 >= cnt_1 and available_for_2 >= cnt_2 and mid - disliked_by_both >= cnt_1 + cnt_2:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Read input\ncnt_1, cnt_2, x, y = map(int, input().split())\n\n# Find and print the result\nprint(find_min_v(cnt_1, cnt_2, x, y))"}
{"solution": "def predict_bear_position(n, sx, sy, dx, dy, t):\n    # Function to calculate the new position after one second\n    def move(x, y, dx, dy):\n        k = x + y  # Number of bushes eaten, increases speed by k\n        dx += k\n        dy += k\n        x = ((x + dx - 1) % n) + 1\n        y = ((y + dy - 1) % n) + 1\n        return x, y, dx, dy\n\n    # Simulate the bear's movement for t seconds\n    for _ in range(t):\n        sx, sy, dx, dy = move(sx, sy, dx, dy)\n\n    return sx, sy\n\n# Read input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Predict and print the final position\nfinal_x, final_y = predict_bear_position(n, sx, sy, dx, dy, t)\nprint(final_x, final_y)"}
{"solution": "def make_nice_word(s):\n    if len(s) < 26:\n        return \"-1\"\n    \n    for i in range(len(s) - 25):\n        substring = s[i:i+26]\n        if '?' in substring:\n            missing_letters = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ') - set(substring.replace('?', ''))\n            if len(missing_letters) == substring.count('?'):\n                replacement_letters = list(missing_letters)\n                new_substring = list(substring)\n                for j in range(26):\n                    if new_substring[j] == '?':\n                        new_substring[j] = replacement_letters.pop(0)\n                s = s[:i] + ''.join(new_substring) + s[i+26:]\n                return s.replace('?', 'A')\n    return \"-1\"\n\n# Read input\ns = input().strip()\n\n# Output result\nprint(make_nice_word(s))"}
{"solution": "def can_divide_apples(n, weights):\n    # Count the number of apples of each weight\n    count_100 = weights.count(100)\n    count_200 = weights.count(200)\n    \n    # Check if the total weight can be divided equally\n    if (count_100 * 100 + count_200 * 200) % 200 != 0:\n        return \"NO\"\n    \n    # If there are even number of 200-gram apples, they can be divided equally\n    if count_200 % 2 == 0:\n        return \"YES\"\n    \n    # If there are more than one 100-gram apples and an odd number of 200-gram apples,\n    # we can use two 100-gram apples to make a 200-gram apple\n    if count_100 >= 2 and count_200 % 2 != 0:\n        return \"YES\"\n    \n    # If there's only one type of apple and it's 200-gram apples, it's impossible to divide\n    if count_100 == 0 and count_200 % 2 != 0:\n        return \"NO\"\n    \n    # In all other cases, it's possible to divide the apples equally\n    return \"YES\"\n\n# Read input\nn = int(input())\nweights = list(map(int, input().split()))\n\n# Print output\nprint(can_divide_apples(n, weights))"}
{"solution": "def min_time_to_turn_off_lights(n, m, building):\n    total_time = 0\n    current_position = 0  # Starting at the left stairs\n\n    for floor in range(n):\n        floor_description = building[n - 1 - floor]  # Read floors from bottom to top\n        left_most_light = floor_description.find('1')\n        right_most_light = floor_description.rfind('1')\n\n        if left_most_light == -1:  # No lights to turn off on this floor\n            continue\n\n        if floor == 0:  # Ground floor\n            total_time += right_most_light  # Go to the rightmost light and turn it off\n        else:\n            # Calculate the time to turn off lights on this floor\n            if current_position == 0:  # At the left stairs\n                total_time += min(right_most_light * 2, m + 1) + 1  # Move to the right or use stairs\n            else:  # At the right stairs\n                total_time += min((m + 1 - left_most_light) * 2, m + 1) + 1  # Move to the left or use stairs\n\n        current_position = 0 if right_most_light * 2 <= m + 1 else m + 1  # Decide where to go next\n\n    return total_time\n\n# Read input\nn, m = map(int, input().split())\nbuilding = [input().strip() for _ in range(n)]\n\n# Calculate and print the result\nprint(min_time_to_turn_off_lights(n, m, building))"}
{"solution": "def find_min_trap_cost(n, costs, transitions):\n    visited = [False] * n\n    in_stack = [False] * n\n    min_cost = 0\n\n    def dfs(node):\n        stack = []\n        while True:\n            if visited[node]:\n                if in_stack[node]:\n                    # Found a cycle, calculate the minimum cost in this cycle\n                    cycle_min_cost = float('inf')\n                    while stack:\n                        cycle_node = stack.pop()\n                        in_stack[cycle_node] = False\n                        cycle_min_cost = min(cycle_min_cost, costs[cycle_node])\n                        if cycle_node == node:\n                            break\n                    return cycle_min_cost\n                else:\n                    return 0\n            visited[node] = True\n            in_stack[node] = True\n            stack.append(node)\n            node = transitions[node] - 1\n\n    for i in range(n):\n        if not visited[i]:\n            min_cost += dfs(i)\n\n    return min_cost\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(find_min_trap_cost(n, costs, transitions))"}
{"solution": "def determine_entrance(n, a, b):\n    # Calculate the final position by adding b to a and taking modulo n\n    # If the result is 0, it means Vasya is at the last entrance, so we return n\n    final_position = (a + b - 1) % n + 1\n    return final_position\n\n# Read input from the user\nn, a, b = map(int, input().split())\n\n# Determine and print the final entrance number\nprint(determine_entrance(n, a, b))"}
{"solution": "def min_arithmetic_progressions(n, sequence):\n    # Initialize the count of progressions\n    progressions = 0\n    \n    # Initialize variables to track the current progression\n    current_start = None\n    current_diff = None\n    \n    # Iterate through the sequence\n    for i in range(n):\n        if sequence[i] == -1:\n            continue\n        \n        if current_start is None:\n            # Start a new progression\n            current_start = sequence[i]\n            current_diff = None\n            progressions += 1\n        else:\n            # Check if we can continue the current progression\n            if current_diff is None:\n                if i > 0 and sequence[i-1] != -1:\n                    current_diff = sequence[i] - sequence[i-1]\n                else:\n                    continue\n            elif sequence[i] - current_start != current_diff * (i - sequence.index(current_start)):\n                # Start a new progression if the difference doesn't match\n                current_start = sequence[i]\n                current_diff = None\n                progressions += 1\n    \n    return progressions\n\n# Example usage:\n# n = 9\n# sequence = [8, 6, 4, 2, 1, 4, 7, 10, 2]\n# print(min_arithmetic_progressions(n, sequence))  # Output: 3"}
{"solution": "def max_beauty(n, k, s):\n    max_len = 0\n    for char in ['a', 'b']:\n        changes = 0\n        left = 0\n        for right in range(n):\n            if s[right] != char:\n                changes += 1\n            while changes > k:\n                if s[left] != char:\n                    changes -= 1\n                left += 1\n            max_len = max(max_len, right - left + 1)\n    return max_len\n\n# Reading input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, a):\n    total_seats = sum(a)\n    majority_seats = total_seats // 2 + 1\n    alice_seats = a[0]\n\n    # If Alice's party alone has a strict majority, no need to form a coalition\n    if alice_seats >= majority_seats:\n        return [1], 1\n\n    # Sort parties by their seats in descending order, excluding Alice's party\n    sorted_parties = sorted(enumerate(a[1:], start=2), key=lambda x: x[1], reverse=True)\n\n    # Try to form a coalition\n    for i in range(n - 1):\n        coalition = [1]\n        coalition_seats = alice_seats\n\n        # Add parties to the coalition until the majority is reached or no more parties can be added\n        for j in range(i + 1):\n            party_index, party_seats = sorted_parties[j]\n            if alice_seats >= 2 * party_seats:\n                coalition.append(party_index)\n                coalition_seats += party_seats\n                if coalition_seats >= majority_seats:\n                    return coalition, len(coalition)\n\n        # Check if adding the rest of the parties can form a majority\n        for j in range(i + 1, n - 1):\n            party_index, party_seats = sorted_parties[j]\n            if coalition_seats + party_seats >= majority_seats:\n                coalition.append(party_index)\n                coalition_seats += party_seats\n                if coalition_seats >= majority_seats:\n                    return coalition, len(coalition)\n\n    return [], 0\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find and print the coalition\ncoalition, k = find_coalition(n, a)\nprint(k)\nif k > 0:\n    print(' '.join(map(str, coalition)))"}
{"solution": "def max_reward(n):\n    harmonic_sum = 0.0\n    for i in range(1, n + 1):\n        harmonic_sum += 1.0 / i\n    return harmonic_sum\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the maximum reward\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "def distribute_candies(n):\n    k = 0\n    while (k * (k + 1)) // 2 <= n:\n        k += 1\n    k -= 1  # The last increment made the sum exceed n\n\n    candies_given = [i for i in range(1, k + 1)]\n    remaining_candies = n - sum(candies_given)\n\n    # Distribute remaining candies if any\n    if remaining_candies > 0:\n        candies_given[-1] += remaining_candies\n\n    return k, candies_given\n\n# Read input\nn = int(input().strip())\n\n# Get the distribution\nk, candies_distribution = distribute_candies(n)\n\n# Print the output\nprint(k)\nprint(' '.join(map(str, candies_distribution)))"}
{"solution": "def calculate_mod(n, m):\n    # Calculate m mod 2^n using bitwise AND operation\n    return m & ((1 << n) - 1)\n\n# Read input\nn = int(input().strip())\nm = int(input().strip())\n\n# Calculate and print the result\nprint(calculate_mod(n, m))"}
{"solution": "def word_corrector(n, s):\n    vowels = 'aeiouy'\n    i = 0\n    while i < len(s) - 1:\n        if s[i] in vowels and s[i + 1] in vowels:\n            s = s[:i] + s[i + 1:]\n        else:\n            i += 1\n    return s\n\n# Assuming the input is provided in the specified format\nn = int(input())\ns = input()\n\nprint(word_corrector(n, s))"}
{"solution": "def max_students(n, a, b, seats):\n    segments = []\n    i = 0\n    \n    # Identify segments of empty seats\n    while i < n:\n        if seats[i] == '.':\n            start = i\n            while i < n and seats[i] == '.':\n                i += 1\n            segments.append(i - start)\n        else:\n            i += 1\n    \n    total_students = 0\n    \n    # Place students in each segment\n    for length in segments:\n        # Calculate the number of students that can be placed in this segment\n        # We will place students in an alternating fashion\n        if a > b:\n            # Start with a student-programmer if more student-programmers are available\n            programmers = (length + 1) // 2\n            athletes = length // 2\n        else:\n            # Start with a student-athlete if more student-athletes are available\n            athletes = (length + 1) // 2\n            programmers = length // 2\n        \n        # Place the students\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n        \n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n    \n    return total_students\n\n# Read input\nn, a, b = map(int, input().split())\nseats = input().strip()\n\n# Output the result\nprint(max_students(n, a, b, seats))"}
{"solution": "def find_pair(r):\n    # Since H(x, y) = x^2 + 2xy + x + 1, we can rewrite it as H(x, y) = (x+1)^2 + x(y-1)\n    # We need to find x and y such that (x+1)^2 + x(y-1) = r\n    # We iterate over possible values of x, starting from the smallest,\n    # and check if there exists a y that satisfies the equation.\n    \n    for x in range(1, int(r**0.5) + 1):  # x must be less than sqrt(r) for practicality\n        # Calculate the term (x+1)^2\n        term = (x + 1) ** 2\n        # Check if the remaining part r - term is divisible by x\n        if (r - term) % x == 0:\n            y = (r - term) // x + 1\n            if y > 0:  # y must be a positive integer\n                return x, y\n    return \"NO\"\n\n# Read input\nr = int(input().strip())\n\n# Find and print the result\nresult = find_pair(r)\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "def divide_balloons(n, a):\n    if n == 1:\n        return -1  # Only one packet, cannot divide\n\n    total_balloons = sum(a)\n    for i in range(1, 1 << n):  # Iterate over all subsets\n        grigory_packets = []\n        grigory_balloons = 0\n        for j in range(n):\n            if i & (1 << j):\n                grigory_packets.append(j + 1)\n                grigory_balloons += a[j]\n        \n        if grigory_packets and grigory_balloons != total_balloons - grigory_balloons:\n            return len(grigory_packets), grigory_packets\n    \n    return -1  # No valid division found\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Solve the problem and print the result\nresult = divide_balloons(n, a)\nif result == -1:\n    print(result)\nelse:\n    k, packets = result\n    print(k)\n    print(*packets)"}
{"solution": "def minimal_digit_partition(n):\n    # Start with the largest digit possible (9) and work downwards\n    digits = []\n    for digit in range(9, 0, -1):\n        # While the current digit can be subtracted from n, do so\n        while n >= digit:\n            digits.append(digit)\n            n -= digit\n    return digits\n\n# Read input\nn = int(input())\n\n# Get the minimal digit partition\npartition = minimal_digit_partition(n)\n\n# Output the result\nprint(len(partition))\nprint(' '.join(map(str, partition)))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_max_simple_subset(n, a):\n    a.sort()\n    subset = []\n    for num in a:\n        if all(is_prime(num + x) for x in subset):\n            subset.append(num)\n    return subset\n\ndef main():\n    n = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    subset = find_max_simple_subset(n, a)\n    print(len(subset))\n    print(' '.join(map(str, subset)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_beautiful(num):\n    # Check if the number is beautiful\n    k = 1\n    while (2**k - 1) * 2**k <= num:\n        if num % ((2**k - 1) * 2**k) == 0:\n            return True\n        k += 1\n    return False\n\ndef greatest_beautiful_divisor(n):\n    # Start from the largest possible divisor and go down to 1\n    for divisor in range(n, 0, -1):\n        if n % divisor == 0 and is_beautiful(divisor):\n            return divisor\n\n# Read input\nn = int(input().strip())\n\n# Output the greatest beautiful divisor\nprint(greatest_beautiful_divisor(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_d_magic_numbers(m, d, a, b):\n    def is_d_magic(number, d):\n        str_num = str(number)\n        for i, digit in enumerate(str_num):\n            if (i % 2 == 0) and (digit != str(d)):\n                return False\n            if (i % 2 == 1) and (digit == str(d)):\n                return False\n        return True\n\n    def count_multiples_in_range(start, end, m):\n        return (end // m) - ((start - 1) // m)\n\n    count = 0\n    for number in range(a, b + 1):\n        if number % m == 0 and is_d_magic(number, d):\n            count += 1\n            count %= MOD\n\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    m = int(data[0])\n    d = int(data[1])\n    a = int(data[2])\n    b = int(data[3])\n    \n    result = count_d_magic_numbers(m, d, a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def last_child_to_go_home(n, m, a):\n    queue = list(range(1, n + 1))\n    candies_received = [0] * (n + 1)\n    last_child = None\n\n    while queue:\n        current_child = queue.pop(0)\n        candies_received[current_child] += m\n        if candies_received[current_child] < a[current_child - 1]:\n            queue.append(current_child)\n        else:\n            last_child = current_child\n\n    return last_child\n\n# Reading input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(last_child_to_go_home(n, m, a))"}
{"solution": "def min_bills(n):\n    denominations = [100, 20, 10, 5, 1]\n    count = 0\n    for denomination in denominations:\n        count += n // denomination\n        n %= denomination\n    return count\n\n# Assuming the input is provided through a standard input method (e.g., input() in Python)\nn = int(input())\nprint(min_bills(n))"}
{"solution": "MOD = 1000000007\n\ndef binomial_mod(n, k, mod=MOD):\n    if k > n or k < 0:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)\n    c = 1\n    for i in range(k):\n        c = c * (n - i) * pow(i + 1, mod - 2, mod) % mod\n    return c\n\ndef count_permutations(n, k):\n    dp = [0] * (k + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, k), 0, -1):\n            dp[j] = (dp[j] * j + dp[j - 1] * (i - j + 1)) % MOD\n        dp[0] = dp[0] * i % MOD\n    \n    result = 0\n    for i in range(k + 1):\n        result = (result + dp[i] * binomial_mod(n - 1, n - 1 - i)) % MOD\n    \n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    print(count_permutations(n, k))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_beauty_bouquet(n, k, beauties, colors):\n    # Separate roses by color\n    roses = {'W': [], 'O': [], 'R': []}\n    for beauty, color in zip(beauties, colors):\n        roses[color].append(beauty)\n    \n    # Sort each color's roses by beauty in descending order\n    for color in roses:\n        roses[color].sort(reverse=True)\n    \n    # Function to calculate the maximum beauty for a given color combination\n    def calculate_max_beauty(color1, color2):\n        max_beauty = 0\n        # Use two pointers to find the optimal combination\n        i, j = 0, 0\n        while i < len(roses[color1]) and j < len(roses[color2]) and (i + j) < k:\n            if roses[color1][i] >= roses[color2][j]:\n                max_beauty += roses[color1][i]\n                i += 1\n            else:\n                max_beauty += roses[color2][j]\n                j += 1\n        # Add remaining roses from the color with more remaining roses\n        while (i + j) < k and (i < len(roses[color1]) or j < len(roses[color2])):\n            if i < len(roses[color1]):\n                max_beauty += roses[color1][i]\n                i += 1\n            elif j < len(roses[color2]):\n                max_beauty += roses[color2][j]\n                j += 1\n        return max_beauty if (i + j) == k else -1\n    \n    # Calculate the maximum beauty for valid color combinations\n    max_beauty = -1\n    for color1, color2 in [('W', 'O'), ('W', 'R'), ('O', 'R')]:\n        max_beauty = max(max_beauty, calculate_max_beauty(color1, color2))\n    \n    return max_beauty\n\n# Read input\nn, k = map(int, input().split())\nbeauties = list(map(int, input().split()))\ncolors = input().strip()\n\n# Output the result\nprint(max_beauty_bouquet(n, k, beauties, colors))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef reduce_fraction(p, q):\n    common_divisor = gcd(p, q)\n    return p // common_divisor, q // common_divisor\n\ndef evaluate_continued_fraction(a):\n    numerator, denominator = a[-1], 1\n    for i in range(len(a) - 2, -1, -1):\n        numerator, denominator = denominator, numerator\n        numerator += a[i] * denominator\n    return reduce_fraction(numerator, denominator)\n\ndef compare_fractions(p, q, n, a):\n    p, q = reduce_fraction(p, q)\n    continued_fraction_numerator, continued_fraction_denominator = evaluate_continued_fraction(a)\n    return p == continued_fraction_numerator and q == continued_fraction_denominator\n\n# Reading input\np, q = map(int, input().split())\nn = int(input())\na = list(map(int, input().split()))\n\n# Comparing fractions and printing result\nprint(\"YES\" if compare_fractions(p, q, n, a) else \"NO\")"}
{"solution": "def correct_expression(expression):\n    # Split the expression into parts\n    parts = expression.split('+')\n    a_part, rest = parts[0], parts[1]\n    b_part, c_part = rest.split('=')\n    \n    # Convert parts to numbers\n    a = len(a_part)\n    b = len(b_part)\n    c = len(c_part)\n    \n    # Check if the expression is already correct\n    if a + b == c:\n        return expression\n    \n    # Try to shift one stick from A to B or C\n    if a > 1 and a - 1 + b == c + 1:\n        return '|' * (a - 1) + '+' + '|' * b + '=' + '|' * (c + 1)\n    if a > 1 and a - 1 + b + 1 == c:\n        return '|' * (a - 1) + '+' + '|' * (b + 1) + '=' + '|' * c\n    \n    # Try to shift one stick from B to A or C\n    if b > 1 and a + b - 1 == c + 1:\n        return '|' * a + '+' + '|' * (b - 1) + '=' + '|' * (c + 1)\n    if b > 1 and a + b - 1 + 1 == c:\n        return '|' * a + '+' + '|' * (b - 1) + '=' + '|' * (c + 1)\n    \n    # Try to shift one stick from C to A or B\n    if c > 1 and a + 1 + b == c - 1:\n        return '|' * (a + 1) + '+' + '|' * b + '=' + '|' * (c - 1)\n    if c > 1 and a + b + 1 == c - 1:\n        return '|' * a + '+' + '|' * (b + 1) + '=' + '|' * (c - 1)\n    \n    # If no valid move is found, return \"Impossible\"\n    return \"Impossible\"\n\n# Read input\nexpression = input().strip()\n\n# Output the result\nprint(correct_expression(expression))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_permutations_with_oddness(n, k):\n    # Initialize a 3D array to store the counts of permutations with a certain oddness\n    dp = [[[0 for _ in range(n * n + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 1  # Base case: 0 elements, 0 oddness, 1 permutation (the empty permutation)\n\n    # Fill the DP table\n    for i in range(1, n + 1):  # For each number of elements\n        for j in range(i):  # For each number of elements already placed\n            for oddness in range(k + 1):  # For each possible oddness\n                # Calculate the new oddness if we place the i-th element at position j\n                new_oddness = oddness + abs(i - 1 - j)\n                if new_oddness <= k:\n                    dp[i][j + 1][new_oddness] += dp[i - 1][j][oddness]\n                    dp[i][j + 1][new_oddness] %= MOD\n\n    # Sum up all permutations with the exact oddness k\n    result = 0\n    for j in range(n + 1):\n        result += dp[n][j][k]\n        result %= MOD\n\n    return result\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(count_permutations_with_oddness(n, k))"}
{"solution": "def can_reach_all_points(N, points):\n    # Check if it's possible to reach all points with a robot arm\n    # This is a placeholder function, you need to implement the logic\n    return True\n\ndef find_robot_arm_configuration(N, points):\n    # Find a robot arm configuration that can reach all points\n    # This is a placeholder function, you need to implement the logic\n    m = 2  # Example value for m\n    d = [1, 2]  # Example values for d_i\n    ways = [\"RL\", \"UU\", \"DR\"]  # Example ways to reach each point\n    return m, d, ways\n\ndef main():\n    N = int(input().strip())\n    points = [tuple(map(int, input().strip().split())) for _ in range(N)]\n    \n    if not can_reach_all_points(N, points):\n        print(-1)\n        return\n    \n    m, d, ways = find_robot_arm_configuration(N, points)\n    \n    print(m)\n    print(' '.join(map(str, d)))\n    for way in ways:\n        print(way)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import re\n\ndef replace_fillers(s):\n    # Regular expression to match the filler words\n    filler_pattern = r'ogo(go)*'\n    # Replace all occurrences of the filler pattern with '***'\n    return re.sub(filler_pattern, '***', s)\n\n# Read input\nn = int(input())\ns = input()\n\n# Process and print the output\nprint(replace_fillers(s))"}
{"solution": "def prime_factors(n):\n    factors = set()\n    # Check for divisibility by 2\n    while n % 2 == 0:\n        factors.add(2)\n        n //= 2\n    # Check for odd factors\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            factors.add(i)\n            n //= i\n    # If n is a prime number greater than 2\n    if n > 2:\n        factors.add(n)\n    return factors\n\ndef g(x, p):\n    max_power = 1\n    while x % p == 0:\n        max_power *= p\n        x //= p\n    return max_power\n\ndef f(x, y):\n    product = 1\n    for p in prime_factors(x):\n        product *= g(y, p)\n    return product\n\ndef calculate_product(x, n):\n    MOD = 10**9 + 7\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * f(x, i)) % MOD\n    return result\n\n# Read input\nx, n = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_product(x, n))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for s in range(1, 82):  # s(x) can be at most 81\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and sum_of_digits(x) == s:\n            solutions.append(x)\n    solutions.sort()\n    return solutions\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find solutions\nsolutions = find_solutions(a, b, c)\n\n# Print results\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "def can_solve_with_one_move(cube_state):\n    # Define the possible rotations for a 2x2x2 Rubik's cube\n    rotations = [\n        # Rotate the front face clockwise\n        [0, 1, 18, 19, 4, 5, 6, 7, 16, 17, 14, 15, 12, 13, 10, 11, 8, 9, 22, 23, 20, 21, 2, 3],\n        # Rotate the back face clockwise\n        [20, 21, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0, 1, 22, 23],\n        # Rotate the left face clockwise\n        [4, 5, 2, 3, 20, 21, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0, 1, 22, 23],\n        # Rotate the right face clockwise\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23],\n        # Rotate the top face clockwise\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23],\n        # Rotate the bottom face clockwise\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]\n    ]\n    \n    # Check each rotation to see if it solves the cube\n    for rotation in rotations:\n        if all(cube_state[rotation[i]] == cube_state[rotation[i + 1]] for i in range(0, len(rotation), 2)):\n            return \"YES\"\n    return \"NO\"\n\n# Read input\ncube_state = list(map(int, input().split()))\n\n# Output result\nprint(can_solve_with_one_move(cube_state))"}
{"solution": "def calculate_hacks(p, x, y):\n    def is_winner(score):\n        i = (score // 50) % 475\n        for _ in range(25):\n            i = (i * 96 + 42) % 475\n            if 26 + i == p:\n                return True\n        return False\n\n    successful_hacks = 0\n    while x < y or not is_winner(x):\n        x += 100  # Increase score by 100 for each successful hack\n        successful_hacks += 1\n        if is_winner(x):\n            break\n        if x - 50 >= y and is_winner(x - 50):  # Check if an unsuccessful hack can still win\n            break\n\n    return successful_hacks\n\n# Read input\np, x, y = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_hacks(p, x, y))"}
{"solution": "def min_distance_for_meals(n, a, b, c):\n    # If Winnie needs to eat only once, he doesn't need to travel at all\n    if n == 1:\n        return 0\n    \n    # Calculate the minimum distance to the next house for the first move\n    # Winnie starts at Rabbit's house, so we consider paths from Rabbit's house\n    first_move_distance = min(a, b)\n    \n    # If Winnie needs to eat twice, he only needs to travel to one of the other houses\n    if n == 2:\n        return first_move_distance\n    \n    # For more than two meals, Winnie will need to travel between Owl's and Eeyore's houses\n    # after the first move. We choose the minimum distance between these two houses.\n    return first_move_distance + (n - 2) * min(a, b, c)\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate and print the minimum distance\nprint(min_distance_for_meals(n, a, b, c))"}
{"solution": "def min_total_distance(x1, x2, x3):\n    # Calculate the distances between each pair of friends\n    dist12 = abs(x1 - x2)\n    dist23 = abs(x2 - x3)\n    dist13 = abs(x1 - x3)\n    \n    # The minimum total distance is the sum of the two smallest distances\n    # because the friends should meet at the midpoint of the two friends who are farthest apart\n    return dist12 + dist23 + dist13 - max(dist12, dist23, dist13)\n\n# Read input\nx1, x2, x3 = map(int, input().split())\n\n# Print the output\nprint(min_total_distance(x1, x2, x3))"}
{"solution": "def min_operations_to_equalize(n, x, arr):\n    # Check if there are already equal elements\n    if len(set(arr)) < n:\n        return 0\n    \n    # Check if applying the operation once can make elements equal\n    for a in arr:\n        if (a & x) != a and (a & x) in arr:\n            return 1\n    \n    # Check if applying the operation twice can make elements equal\n    if len(set(a & x for a in arr)) < n:\n        return 2\n    \n    # If none of the above, it's impossible\n    return -1\n\n# Read input\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Print the result\nprint(min_operations_to_equalize(n, x, arr))"}
{"solution": "def has_single_plus_shape(h, w, picture):\n    center = None\n    for i in range(1, h - 1):\n        for j in range(1, w - 1):\n            if picture[i][j] == '*' and picture[i - 1][j] == '*' and picture[i + 1][j] == '*' and picture[i][j - 1] == '*' and picture[i][j + 1] == '*':\n                if center is not None:\n                    return \"NO\"  # More than one potential center found\n                center = (i, j)\n\n    if center is None:\n        return \"NO\"  # No potential center found\n\n    i, j = center\n    # Check all directions from the center\n    up, down, left, right = i, i, j, j\n    while up >= 0 and picture[up][j] == '*':\n        picture[up][j] = '.'\n        up -= 1\n    while down < h and picture[down][j] == '*':\n        picture[down][j] = '.'\n        down += 1\n    while left >= 0 and picture[i][left] == '*':\n        picture[i][left] = '.'\n        left -= 1\n    while right < w and picture[i][right] == '*':\n        picture[i][right] = '.'\n        right += 1\n\n    # Check if all '*' have been accounted for\n    for row in picture:\n        if '*' in row:\n            return \"NO\"\n\n    return \"YES\"\n\n# Read input\nh, w = map(int, input().split())\npicture = [list(input().strip()) for _ in range(h)]\n\n# Output result\nprint(has_single_plus_shape(h, w, picture))"}
{"solution": "def find_adjacency_matrix(n, a, b):\n    if a + b > n + 1 or a * b != n:\n        return \"NO\"\n    \n    # Initialize an empty adjacency matrix\n    adj_matrix = [[0] * n for _ in range(n)]\n    \n    # Create a fully connected graph for the complement\n    for i in range(a - 1):\n        for j in range(i + 1, a):\n            adj_matrix[i][j] = adj_matrix[j][i] = 1\n    \n    # Connect the remaining components to form 'b' components in the complement\n    for i in range(a, n):\n        adj_matrix[i][a - 1] = adj_matrix[a - 1][i] = 1\n    \n    # Ensure symmetry and main diagonal zeroes\n    for i in range(n):\n        for j in range(i + 1, n):\n            adj_matrix[j][i] = adj_matrix[i][j]\n    \n    return [\"YES\"] + [\"\".join(map(str, row)) for row in adj_matrix]\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Get the result\nresult = find_adjacency_matrix(n, a, b)\n\n# Print the result\nfor line in result:\n    print(line)"}
{"solution": "def min_problems_needed(c, d, n, m, k):\n    # Calculate the number of winners needed from elimination rounds\n    winners_needed = n * m - k\n    \n    # If no additional winners are needed, return 0\n    if winners_needed <= 0:\n        return 0\n    \n    # Calculate the maximum number of winners from main rounds\n    max_main_winners = (winners_needed // n) * n\n    \n    # Calculate the remaining winners needed from additional rounds\n    additional_winners_needed = winners_needed - max_main_winners\n    \n    # Calculate the number of problems needed\n    problems_needed = (max_main_winners // n) * c + additional_winners_needed * d\n    \n    return problems_needed\n\n# Read input\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\n# Calculate and print the result\nprint(min_problems_needed(c, d, n, m, k))"}
{"solution": "def find_grid_path(s):\n    # Check if the string length is exactly 27\n    if len(s) != 27:\n        return \"Impossible\"\n\n    # Function to check if two tiles are adjacent\n    def is_adjacent(i, j):\n        row_i, col_i = divmod(i, 13)\n        row_j, col_j = divmod(j, 13)\n        return abs(row_i - row_j) <= 1 and abs(col_i - col_j) <= 1\n\n    # Try to find a path by backtracking\n    def backtrack(path, used):\n        if len(path) == 27:\n            return path\n        for i in range(27):\n            if not used[i] and (len(path) == 0 or is_adjacent(path[-1], i)):\n                used[i] = True\n                result = backtrack(path + [i], used)\n                if result:\n                    return result\n                used[i] = False\n        return None\n\n    # Initialize used array to keep track of used tiles\n    used = [False] * 27\n    path = backtrack([], used)\n\n    if not path:\n        return \"Impossible\"\n\n    # Construct the grid from the path\n    grid = [[''] * 13 for _ in range(2)]\n    for i, pos in enumerate(path):\n        row, col = divmod(pos, 13)\n        grid[row][col] = s[i]\n\n    return ''.join(grid[0]) + '\\n' + ''.join(grid[1])\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(find_grid_path(s))"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<' if y > 1 else '='\n    elif y == 1:\n        return '>' if x > 1 else '='\n    else:\n        lhs = y * math.log(x)\n        rhs = x * math.log(y)\n        \n        if lhs < rhs:\n            return '<'\n        elif lhs > rhs:\n            return '>'\n        else:\n            return '='\n\n# Read input\nx, y = map(int, input().split())\n\n# Output the result of the comparison\nprint(compare_powers(x, y))"}
{"solution": "import math\n\ndef calculate_max_balloons(r, h):\n    # Calculate the number of balloons that can fit in the semicircle part\n    balloons_in_semicircle = (math.pi * r ** 2) // (math.pi * (r / 2) ** 2)\n    \n    # Calculate the number of balloons that can fit in the rectangular part\n    # The height of the rectangular part is h, and each balloon has a diameter of r\n    balloons_in_rectangle = (h // (r / 2)) * (r // (r / 2))\n    \n    # The total number of balloons is the sum of the balloons in the semicircle and the rectangle\n    total_balloons = balloons_in_semicircle + balloons_in_rectangle\n    \n    return total_balloons\n\n# Read input\nr, h = map(int, input().split())\n\n# Calculate and print the maximum number of balloons\nprint(calculate_max_balloons(r, h))"}
{"solution": "def min_sum_after_discard(t1, t2, t3, t4, t5):\n    # Count occurrences of each number\n    counts = {}\n    for num in [t1, t2, t3, t4, t5]:\n        counts[num] = counts.get(num, 0) + 1\n    \n    # Initialize the minimum sum to the sum of all numbers\n    min_sum = sum([t1, t2, t3, t4, t5])\n    \n    # Check if any number can be discarded\n    for num, count in counts.items():\n        if count == 2 or count == 3:\n            min_sum -= num * count\n        elif count > 3:\n            min_sum -= num * 3\n    \n    return min_sum\n\n# Read input\nt1, t2, t3, t4, t5 = map(int, input().split())\n\n# Print the result\nprint(min_sum_after_discard(t1, t2, t3, t4, t5))"}
{"solution": "def min_distance_to_checkpoints(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    # Calculate distances to the furthest checkpoints from both ends\n    distance_to_furthest = max(abs(a - checkpoints[0]), abs(a - checkpoints[-1]))\n    # Calculate the distance to visit n-1 checkpoints\n    distance_to_n_minus_1 = min(abs(a - checkpoints[1]), abs(a - checkpoints[-2])) + (checkpoints[-1] - checkpoints[0])\n    return min(distance_to_furthest, distance_to_n_minus_1)\n\n# Read input\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Calculate and print the minimum distance\nprint(min_distance_to_checkpoints(n, a, checkpoints))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_root(n):\n    for x in range(1, 10**9):  # Arbitrary large upper bound for x\n        if x**2 + sum_of_digits(x) * x - n == 0:\n            return x\n    return -1\n\n# Read input\nn = int(input().strip())\n\n# Find and print the result\nprint(find_root(n))"}
{"solution": "def time_to_minutes(time_str):\n    hours, minutes = map(int, time_str.split(':'))\n    return hours * 60 + minutes\n\ndef minutes_to_time(minutes):\n    hours = minutes // 60\n    minutes = minutes % 60\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef calculate_bedtime(current_time, sleep_duration):\n    current_minutes = time_to_minutes(current_time)\n    sleep_minutes = time_to_minutes(sleep_duration)\n    bedtime_minutes = (current_minutes - sleep_minutes) % (24 * 60)\n    return minutes_to_time(bedtime_minutes)\n\n# Read input\ncurrent_time = input().strip()\nsleep_duration = input().strip()\n\n# Calculate and print the bedtime\nprint(calculate_bedtime(current_time, sleep_duration))"}
{"solution": "def find_longest_subsegment_with_max_mean(n, a):\n    max_val = max(a)\n    max_len = 0\n    current_len = 0\n\n    for val in a:\n        if val == max_val:\n            current_len += 1\n            max_len = max(max_len, current_len)\n        else:\n            current_len = 0\n\n    return max_len\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Finding and printing the result\nprint(find_longest_subsegment_with_max_mean(n, a))"}
{"solution": "MOD = 998244353\n\ndef mod_pow(base, exponent, modulus):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % modulus\n        base = (base * base) % modulus\n        exponent //= 2\n    return result\n\ndef mod_inverse(a, modulus):\n    return mod_pow(a, modulus - 2, modulus)\n\ndef nCr_mod(n, r, modulus):\n    if r > n:\n        return 0\n    if r == 0 or n == r:\n        return 1\n    numerator = 1\n    denominator = 1\n    for i in range(r):\n        numerator = (numerator * (n - i)) % modulus\n        denominator = (denominator * (i + 1)) % modulus\n    return (numerator * mod_inverse(denominator, modulus)) % modulus\n\ndef count_ways(n, m, k):\n    return (nCr_mod(n - 1, k, MOD) * m * mod_pow(m - 1, k, MOD)) % MOD\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Calculate and print the result\nprint(count_ways(n, m, k))"}
{"solution": "import re\n\ndef is_magic_number(n):\n    pattern = re.compile(r'^(1|14|144)+$')\n    if pattern.match(str(n)):\n        return \"YES\"\n    else:\n        return \"NO\""}
{"solution": "def min_moves_to_corner(n, m, i, j, a, b):\n    def can_reach_corner(x, y, a, b):\n        return (x - 1) % a == 0 and (y - 1) % b == 0\n\n    def moves_needed(x, y, a, b):\n        return ((x - 1) // a, (y - 1) // b)\n\n    corners = [(1, m), (n, 1), (n, m), (1, 1)]\n    min_moves = float('inf')\n\n    for corner in corners:\n        if can_reach_corner(corner[0], corner[1], a, b):\n            moves_x, moves_y = moves_needed(abs(corner[0] - i), abs(corner[1] - j), a, b)\n            if (moves_x % 2 == moves_y % 2):\n                min_moves = min(min_moves, max(moves_x, moves_y))\n\n    return min_moves if min_moves != float('inf') else \"Poor Inna and pony!\"\n\n# Read input\nn, m, i, j, a, b = map(int, input().split())\n\n# Output the result\nprint(min_moves_to_corner(n, m, i, j, a, b))"}
{"solution": "def max_removals(s):\n    removals = 0\n    while True:\n        removed = False\n        i = 0\n        while i < len(s):\n            if (i > 0 and s[i-1] == chr(ord(s[i])-1)) or (i < len(s)-1 and s[i+1] == chr(ord(s[i])-1)):\n                s = s[:i] + s[i+1:]\n                removals += 1\n                removed = True\n                break\n            i += 1\n        if not removed:\n            break\n    return removals\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Extract the length of the string (not used in this solution)\n# n = int(data[0])\n\n# Extract the string\ns = data[1]\n\n# Print the result\nprint(max_removals(s))"}
{"solution": "def atm_withdrawal(n, k, denominations, q, requests):\n    results = []\n    \n    for request in requests:\n        min_bills = float('inf')\n        for i in range(n):\n            for j in range(i, n):\n                if denominations[i] == denominations[j]:\n                    # Only one denomination\n                    if request % denominations[i] == 0:\n                        num_bills = request // denominations[i]\n                        if num_bills <= k:\n                            min_bills = min(min_bills, num_bills)\n                else:\n                    # Two distinct denominations\n                    for num_bills_i in range(k + 1):\n                        remaining = request - num_bills_i * denominations[i]\n                        if remaining < 0:\n                            break\n                        if remaining % denominations[j] == 0:\n                            num_bills_j = remaining // denominations[j]\n                            total_bills = num_bills_i + num_bills_j\n                            if total_bills <= k:\n                                min_bills = min(min_bills, total_bills)\n        if min_bills == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_bills)\n    \n    return results\n\n# Read input\nn, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\nrequests = [int(input()) for _ in range(q)]\n\n# Get results and print them\nresults = atm_withdrawal(n, k, denominations, q, requests)\nfor result in results:\n    print(result)"}
{"solution": "def min_time_to_reach(s, x1, x2, t1, t2, p, d):\n    # Calculate the time Igor would take to walk the entire distance\n    walking_time = abs(x2 - x1) * t2\n    \n    # If Igor's walking speed is equal to or faster than the tram's, he should walk\n    if t2 <= t1:\n        return walking_time\n    \n    # Calculate the time the tram would take to reach Igor's position from its current position\n    if d == 1:  # Tram moving towards s\n        if p <= x1:\n            tram_to_igor_time = (x1 - p) * t1\n        else:\n            tram_to_igor_time = (s - p + s + x1) * t1\n    else:  # Tram moving towards 0\n        if p >= x1:\n            tram_to_igor_time = (p - x1) * t1\n        else:\n            tram_to_igor_time = (p + s + (s - x1)) * t1\n    \n    # Calculate the time the tram would take to reach the destination from Igor's position\n    if d == 1:  # Tram moving towards s\n        if x1 <= x2:\n            tram_to_destination_time = (x2 - x1) * t1\n        else:\n            tram_to_destination_time = (s - x1 + s + x2) * t1\n    else:  # Tram moving towards 0\n        if x1 >= x2:\n            tram_to_destination_time = (x1 - x2) * t1\n        else:\n            tram_to_destination_time = (x1 + s + (s - x2)) * t1\n    \n    # Total time if Igor waits for the tram and then rides it to the destination\n    tram_time = tram_to_igor_time + tram_to_destination_time\n    \n    # Return the minimum time between walking and using the tram\n    return min(walking_time, tram_time)\n\n# Read input\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Calculate and print the minimum time\nprint(min_time_to_reach(s, x1, x2, t1, t2, p, d))"}
{"solution": "def count_occurrences_in_table(n, x):\n    count = 0\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            j = x // i\n            if i <= n and j <= n:\n                count += 1 if i == j else 2\n    return count\n\n# Reading input\nn, x = map(int, input().split())\n\n# Output the result\nprint(count_occurrences_in_table(n, x))"}
{"solution": "def generate_password(n, k):\n    # Define the set of lowercase Latin letters\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    \n    # Initialize the password with the first k distinct letters\n    password = letters[:k]\n    \n    # Fill the rest of the password with the first letter to ensure no consecutive symbols are the same\n    while len(password) < n:\n        password += letters[0]\n    \n    return password\n\n# Read input\nn, k = map(int, input().split())\n\n# Generate and print the password\nprint(generate_password(n, k))"}
{"solution": "def first_collision_time(n, directions, positions):\n    min_time = float('inf')\n    collision_found = False\n    \n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            collision_time = (positions[i + 1] - positions[i]) // 2\n            min_time = min(min_time, collision_time)\n            collision_found = True\n    \n    if collision_found:\n        return min_time\n    else:\n        return -1\n\n# Function to read input from standard input\ndef read_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    directions = data[1]\n    positions = list(map(int, data[2:]))\n    \n    return n, directions, positions\n\n# Main function to execute the program\ndef main():\n    n, directions, positions = read_input()\n    result = first_collision_time(n, directions, positions)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_area_of_two_seals(n, a, b, seals):\n    max_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for orientation_i in [(seals[i][0], seals[i][1]), (seals[i][1], seals[i][0])]:\n                for orientation_j in [(seals[j][0], seals[j][1]), (seals[j][1], seals[j][0])]:\n                    if (orientation_i[0] + orientation_j[0] <= a and max(orientation_i[1], orientation_j[1]) <= b) or \\\n                       (orientation_i[0] + orientation_j[0] <= b and max(orientation_i[1], orientation_j[1]) <= a) or \\\n                       (orientation_i[1] + orientation_j[1] <= a and max(orientation_i[0], orientation_j[0]) <= b) or \\\n                       (orientation_i[1] + orientation_j[1] <= b and max(orientation_i[0], orientation_j[0]) <= a):\n                        max_area = max(max_area, orientation_i[0] * orientation_i[1] + orientation_j[0] * orientation_j[1])\n    return max_area\n\n# Read input\nn, a, b = map(int, input().split())\nseals = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(max_area_of_two_seals(n, a, b, seals))"}
{"solution": "def find_non_boundary_point(n, points):\n    # Create sets for each boundary condition\n    x_values = set()\n    y_values = set()\n    \n    for x, y in points:\n        x_values.add(x)\n        y_values.add(y)\n    \n    # Determine the boundaries of the square\n    min_x = min(x_values)\n    max_x = max(x_values)\n    min_y = min(y_values)\n    max_y = max(y_values)\n    \n    # Check each point to see if it's on the boundary\n    for x, y in points:\n        if not (x == min_x or x == max_x or y == min_y or y == max_y):\n            return x, y\n    \n    return None\n\n# Read input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(4*n + 1)]\n\n# Find and print the non-boundary point\nnon_boundary_point = find_non_boundary_point(n, points)\nprint(*non_boundary_point)"}
{"solution": "def max_digit_product(n):\n    def product_of_digits(num):\n        product = 1\n        while num > 0:\n            product *= num % 10\n            num //= 10\n        return product\n\n    # Start with the number itself and check its product of digits\n    max_product = product_of_digits(n)\n\n    # Try to maximize the product by replacing digits from the end to the beginning\n    str_n = str(n)\n    for i in range(len(str_n) - 1, -1, -1):\n        if str_n[i] == '0':\n            continue\n        # Replace the current digit with the next lower digit and fill the rest with 9s\n        new_number = int(str_n[:i] + str(int(str_n[i]) - 1) + '9' * (len(str_n) - i - 1))\n        max_product = max(max_product, product_of_digits(new_number))\n\n    return max_product\n\n# Read input\nn = int(input().strip())\n\n# Output the result\nprint(max_digit_product(n))"}
{"solution": "def find_smallest_k(n, votes):\n    total_elodreip_votes = sum(votes)\n    max_ai = max(votes)\n    \n    for k in range(max_ai, total_elodreip_votes + 2):\n        awruk_votes = sum(k - ai for ai in votes)\n        if awruk_votes > total_elodreip_votes:\n            return k\n\n# Reading input\nn = int(input())\nvotes = list(map(int, input().split()))\n\n# Finding and printing the smallest k\nprint(find_smallest_k(n, votes))"}
{"solution": "def count_operations(colors):\n    operations = 0\n    while True:\n        to_delete = [False] * len(colors)\n        deleted = False\n        for i in range(1, len(colors) - 1):\n            if colors[i - 1] != colors[i] and colors[i] != colors[i + 1]:\n                to_delete[i] = True\n                deleted = True\n        if not deleted:\n            break\n        new_colors = []\n        for i in range(len(colors)):\n            if not to_delete[i]:\n                new_colors.append(colors[i])\n        colors = new_colors\n        operations += 1\n    return operations\n\n# Read input from stdin\ncolors = input().strip()\n\n# Output the result\nprint(count_operations(colors))"}
{"solution": "def count_minimum_product_triples(n, a):\n    # Sort the array to easily find the minimum product of three elements\n    a.sort()\n    \n    # The minimum product of three numbers will be the product of the first three numbers\n    # after sorting, since multiplying smaller numbers gives the smallest product.\n    min_product = a[0] * a[1] * a[2]\n    \n    # Initialize the count of such triples\n    count = 0\n    \n    # We will count how many times each of the three smallest numbers appear\n    # to calculate the number of unique triples that can be formed.\n    freq = [0, 0, 0]\n    for num in a:\n        if num == a[2]:\n            freq[2] += 1\n        elif num == a[1]:\n            freq[1] += 1\n        elif num == a[0]:\n            freq[0] += 1\n    \n    # If all three smallest numbers are the same, we calculate the number of ways\n    # to choose 3 out of their total occurrences using combinations formula.\n    if a[0] == a[1] == a[2]:\n        count = freq[0] * (freq[0] - 1) * (freq[0] - 2) // 6\n    # If the two smallest numbers are the same, we choose one of them and then\n    # choose one from the remaining occurrences of the third number.\n    elif a[0] == a[1]:\n        count = freq[2] * (freq[0] * (freq[0] - 1)) // 2\n    # If the two largest numbers are the same, we choose one of them and then\n    # choose one from the remaining occurrences of the smallest number.\n    elif a[1] == a[2]:\n        count = freq[0] * (freq[1] * (freq[1] - 1)) // 2\n    # If all three numbers are different, we simply multiply their frequencies\n    # to get the number of unique triples.\n    else:\n        count = freq[0] * freq[1] * freq[2]\n    \n    return count\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(count_minimum_product_triples(n, a))"}
{"solution": "def min_cuts_for_equal_slices(n):\n    # If there are no friends, Shiro only needs to cut for herself\n    if n == 0:\n        return 0\n    # If the number of slices is a power of 2, the minimum cuts is equal to the number of slices\n    if (n + 1) & (n) == 0:\n        return n\n    # Otherwise, the minimum cuts is the number of slices minus 1\n    return n + 1\n\n# Read input from stdin\nn = int(input().strip())\n\n# Output the result\nprint(min_cuts_for_equal_slices(n))"}
{"solution": "def maximize_bank_account(n):\n    if n >= 0:\n        return n\n    else:\n        n_str = str(n)\n        last_digit_removed = int(n_str[:-1])\n        second_last_digit_removed = int(n_str[:-2] + n_str[-1])\n        return max(last_digit_removed, second_last_digit_removed)\n\n# Assuming the input is provided through a standard input method (e.g., input() function)\nn = int(input().strip())\nprint(maximize_bank_account(n))"}
{"solution": "def determine_spinner_direction(start, end, n):\n    # Define the positions in order\n    positions = ['v', '<', '^', '>']\n    \n    # Find the index of the start and end positions\n    start_index = positions.index(start)\n    end_index = positions.index(end)\n    \n    # Calculate the difference in positions\n    diff = (end_index - start_index) % 4\n    \n    # Determine the direction based on the difference and n\n    if diff == n % 4:\n        return \"cw\"\n    elif -diff % 4 == n % 4:\n        return \"ccw\"\n    else:\n        return \"undefined\"\n\n# Read input\nstart, end = input().split()\nn = int(input())\n\n# Output the result\nprint(determine_spinner_direction(start, end, n))"}
{"solution": "def count_vertical_dominoes(n, s):\n    # Initialize the count of vertical dominoes\n    vertical_count = 0\n    \n    # Initialize a list to keep track of the state of each domino\n    domino_states = ['V'] * n  # 'V' for vertical, 'F' for fallen\n    \n    # Process the dominoes that are pushed initially\n    for i in range(n):\n        if s[i] == 'L':\n            domino_states[i] = 'F'  # Fallen to the left\n            j = i - 1\n            while j >= 0 and s[j] == '.' and domino_states[j] == 'V':\n                domino_states[j] = 'F'\n                j -= 1\n        elif s[i] == 'R':\n            domino_states[i] = 'F'  # Fallen to the right\n            j = i + 1\n            while j < n and s[j] == '.' and domino_states[j] == 'V':\n                domino_states[j] = 'F'\n                j += 1\n    \n    # Count the vertical dominoes\n    for state in domino_states:\n        if state == 'V':\n            vertical_count += 1\n    \n    return vertical_count\n\n# Read input\nn = int(input())\ns = input()\n\n# Output the result\nprint(count_vertical_dominoes(n, s))"}
{"solution": "def restore_permutation(n, m, leaders):\n    # Initialize an array to keep track of the permutation\n    permutation = [0] * n\n    # Initialize a set to keep track of used numbers\n    used_numbers = set()\n    \n    # Function to find the next leader based on the current leader and the permutation\n    def find_next_leader(current_leader, step_count):\n        return (current_leader + step_count - 1) % n + 1\n    \n    # Iterate through each leader index\n    for i in range(m - 1):\n        current_leader = leaders[i]\n        next_leader = leaders[i + 1]\n        \n        # Calculate the step count needed to reach the next leader\n        step_count = ((next_leader - current_leader + n - 1) % n) + 1\n        \n        # If the position in the permutation is already filled, check if it matches the step count\n        if permutation[current_leader - 1] != 0:\n            if permutation[current_leader - 1] != step_count:\n                return -1\n        else:\n            # If the number is already used, it's not a valid permutation\n            if step_count in used_numbers:\n                return -1\n            # Assign the step count to the permutation and mark the number as used\n            permutation[current_leader - 1] = step_count\n            used_numbers.add(step_count)\n    \n    # Fill in the remaining numbers in the permutation\n    for i in range(n):\n        if permutation[i] == 0:\n            for j in range(1, n + 1):\n                if j not in used_numbers:\n                    permutation[i] = j\n                    used_numbers.add(j)\n                    break\n    \n    return permutation\n\n# Read input\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\n# Restore the permutation and print the result\nresult = restore_permutation(n, m, leaders)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def max_number_after_swaps(a, k):\n    digits = [int(d) for d in str(a)]\n    n = len(digits)\n    \n    for i in range(n):\n        if k == 0:\n            break\n        max_digit = digits[i]\n        max_index = i\n        for j in range(i + 1, min(n, i + k + 1)):\n            if digits[j] > max_digit:\n                max_digit = digits[j]\n                max_index = j\n        \n        if max_index != i:\n            for j in range(max_index, i, -1):\n                digits[j], digits[j - 1] = digits[j - 1], digits[j]\n                k -= 1\n                if k == 0:\n                    break\n    \n    return int(''.join(map(str, digits)))\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\na = int(data[0])\nk = int(data[1])\n\n# Output the result\nprint(max_number_after_swaps(a, k))"}
{"solution": "def determine_next_number(sequence):\n    a1, a2, a3, a4 = sequence\n    \n    # Check for arithmetic progression\n    d = a2 - a1\n    if a3 - a2 == d and a4 - a3 == d:\n        return a4 + d\n    \n    # Check for geometric progression\n    if a1 != 0:\n        q = a2 / a1\n        if a3 / a2 == q and a4 / a3 == q:\n            next_element = a4 * q\n            if next_element.is_integer():\n                return int(next_element)\n    \n    # If neither, return 42\n    return 42\n\n# Read input\nsequence = list(map(int, input().split()))\n\n# Determine and print the next number\nprint(determine_next_number(sequence))"}
{"solution": "def max_distance(n, colors):\n    # Find the first and last occurrence of each color\n    first_occurrence = {}\n    last_occurrence = {}\n    \n    for i in range(n):\n        color = colors[i]\n        if color not in first_occurrence:\n            first_occurrence[color] = i\n        last_occurrence[color] = i\n    \n    # Get the list of unique colors\n    unique_colors = list(first_occurrence.keys())\n    \n    # Calculate the maximum distance\n    max_dist = 0\n    \n    # Compare distances from the first house to the last house of a different color\n    for color in unique_colors:\n        if colors[0] != color:\n            max_dist = max(max_dist, last_occurrence[color])\n        if colors[-1] != color:\n            max_dist = max(max_dist, n - 1 - first_occurrence[color])\n    \n    return max_dist\n\n# Read input\nn = int(input())\ncolors = list(map(int, input().split()))\n\n# Print the result\nprint(max_distance(n, colors))"}
{"solution": "def determine_santa_place(n, m, k):\n    # Calculate the lane number\n    lane = (k - 1) // (2 * m) + 1\n    # Calculate the desk number within the lane\n    desk = ((k - 1) // 2) % m + 1\n    # Determine if the place is on the left or right\n    side = 'L' if k % 2 != 0 else 'R'\n    \n    return lane, desk, side\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Determine and print the output\nr, d, s = determine_santa_place(n, m, k)\nprint(r, d, s)"}
{"solution": "def possible_final_colors(s):\n    # Count the occurrences of each color\n    counts = {'B': 0, 'G': 0, 'R': 0}\n    for color in s:\n        counts[color] += 1\n    \n    # Determine the possible final colors based on the parity of counts\n    final_colors = []\n    if counts['B'] % 2 == 1 or (counts['G'] % 2 == 0 and counts['R'] % 2 == 0):\n        final_colors.append('B')\n    if counts['G'] % 2 == 1 or (counts['B'] % 2 == 0 and counts['R'] % 2 == 0):\n        final_colors.append('G')\n    if counts['R'] % 2 == 1 or (counts['B'] % 2 == 0 and counts['G'] % 2 == 0):\n        final_colors.append('R')\n    \n    return ''.join(sorted(final_colors))\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Output the possible final colors\nprint(possible_final_colors(s))"}
