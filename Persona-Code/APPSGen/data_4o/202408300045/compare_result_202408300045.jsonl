{"solution": "def max_accordion_length(s):\n    n = len(s)\n    left_bracket = s.find('[')\n    right_bracket = s.rfind(']')\n    \n    if left_bracket == -1 or right_bracket == -1 or left_bracket >= right_bracket:\n        return -1\n    \n    left_colon = s.find(':', left_bracket + 1, right_bracket)\n    right_colon = s.rfind(':', left_bracket + 1, right_bracket)\n    \n    if left_colon == -1 or right_colon == -1 or left_colon >= right_colon:\n        return -1\n    \n    pipe_count = s[left_colon + 1:right_colon].count('|')\n    \n    return 4 + pipe_count\n\ns = input().strip()\nprint(max_accordion_length(s))"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef find_max_digit_sum(x):\n    str_x = str(x)\n    max_sum = sum_of_digits(x)\n    result = x\n\n    for i in range(len(str_x)):\n        if str_x[i] == '0':\n            continue\n        candidate = int(str_x[:i] + str(int(str_x[i]) - 1) + '9' * (len(str_x) - i - 1))\n        if candidate > 0:\n            candidate_sum = sum_of_digits(candidate)\n            if candidate_sum > max_sum or (candidate_sum == max_sum and candidate > result):\n                max_sum = candidate_sum\n                result = candidate\n\n    return result\n\nx = int(input().strip())\nprint(find_max_digit_sum(x))"}
{"solution": "def is_lucky(year):\n    non_zero_digits = sum(1 for digit in str(year) if digit != '0')\n    return non_zero_digits <= 1\n\ndef next_lucky_year(current_year):\n    year = current_year + 1\n    while not is_lucky(year):\n        year += 1\n    return year - current_year\n\nn = int(input())\nprint(next_lucky_year(n))"}
{"solution": "def max_painted_sections(n, q, painters):\n    # Initialize the coverage array\n    coverage = [0] * (n + 1)\n    \n    # Calculate the initial coverage by all painters\n    for l, r in painters:\n        for i in range(l, r + 1):\n            coverage[i] += 1\n    \n    # Calculate the total number of painted sections with all painters\n    total_painted = sum(1 for x in coverage if x > 0)\n    \n    # Calculate the impact of removing each painter\n    impact = []\n    for l, r in painters:\n        impact.append(sum(1 for i in range(l, r + 1) if coverage[i] == 1))\n    \n    # Find the two painters whose removal has the least impact\n    impact.sort()\n    min_impact = impact[0] + impact[1]\n    \n    # The result is the total painted sections minus the least impact of removing two painters\n    return total_painted - min_impact\n\n# Read input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Calculate and print the result\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def contains_seven(h, m):\n    return '7' in f\"{h:02d}\" or '7' in f\"{m:02d}\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    x = int(data[0])\n    hh = int(data[1])\n    mm = int(data[2])\n    \n    presses = 0\n    \n    while not contains_seven(hh, mm):\n        presses += 1\n        mm -= x\n        if mm < 0:\n            mm += 60\n            hh -= 1\n            if hh < 0:\n                hh += 24\n    \n    print(presses)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0\n    elif l == 1:\n        return abs(pos - r) + 1\n    elif r == n:\n        return abs(pos - l) + 1\n    else:\n        return min(abs(pos - l), abs(pos - r)) + (r - l) + 2\n\n# Read input\nn, pos, l, r = map(int, input().strip().split())\n\n# Calculate and print the result\nprint(min_seconds_to_close_tabs(n, pos, l, r))"}
{"solution": "def min_blows_to_defeat(t, queries):\n    results = []\n    for query in queries:\n        n, x, blows = query\n        max_d_minus_h = -1\n        max_d = 0\n        for d, h in blows:\n            max_d_minus_h = max(max_d_minus_h, d - h)\n            max_d = max(max_d, d)\n        \n        if max_d >= x:\n            results.append(1)\n            continue\n        \n        if max_d_minus_h <= 0:\n            results.append(-1)\n            continue\n        \n        remaining_heads = x - max_d\n        blows_needed = (remaining_heads + max_d_minus_h - 1) // max_d_minus_h\n        results.append(blows_needed + 1)\n    \n    return results\n\n# Read input\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Get results\nresults = min_blows_to_defeat(t, queries)\n\n# Print results\nfor result in results:\n    print(result)"}
{"solution": "def find_empty_day(n, m):\n    day = 0\n    while n > 0:\n        day += 1\n        n += m\n        n -= day\n        if n < 0:\n            n = 0\n    return day\n\n# Read input\nn, m = map(int, input().split())\n\n# Find and print the day when the barn becomes empty\nprint(find_empty_day(n, m))"}
{"solution": "def min_tiles_to_draw(tiles):\n    # Parse the input tiles\n    tile_counts = {}\n    for tile in tiles:\n        if tile in tile_counts:\n            tile_counts[tile] += 1\n        else:\n            tile_counts[tile] = 1\n\n    # Check for koutsu (triplet)\n    for count in tile_counts.values():\n        if count == 3:\n            return 0\n\n    # Check for shuntsu (sequence)\n    suits = {'m': [], 'p': [], 's': []}\n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        suits[suit].append(number)\n\n    for suit in suits.values():\n        suit.sort()\n        if len(suit) == 3:\n            if suit[2] - suit[0] == 2 and suit[1] - suit[0] == 1:\n                return 0\n\n    # Check for possible shuntsu with one extra tile\n    for suit in suits.values():\n        if len(suit) == 2:\n            if suit[1] - suit[0] <= 2:\n                return 1\n\n    # If no koutsu or shuntsu found, return 2\n    return 2\n\n# Read input\ntiles = input().split()\n\n# Get the result\nresult = min_tiles_to_draw(tiles)\n\n# Print the result\nprint(result)"}
{"solution": "def find_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b):\n    left_count = [0] * d\n    right_count = [0] * d\n    top_count = [0] * d\n    bottom_count = [0] * d\n\n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        for j in range(d):\n            if i == j:\n                continue\n            x1_j, y1_j, x2_j, y2_j = sofas[j]\n            if x1 < x1_j and x2 < x1_j:\n                right_count[i] += 1\n            if x1 > x2_j and x2 > x2_j:\n                left_count[i] += 1\n            if y1 < y1_j and y2 < y1_j:\n                bottom_count[i] += 1\n            if y1 > y2_j and y2 > y2_j:\n                top_count[i] += 1\n\n    for i in range(d):\n        if (left_count[i] == cnt_l and right_count[i] == cnt_r and\n                top_count[i] == cnt_t and bottom_count[i] == cnt_b):\n            return i + 1\n\n    return -1\n\n# Read input\nd = int(input())\nn, m = map(int, input().split())\nsofas = [tuple(map(int, input().split())) for _ in range(d)]\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\n# Find and print the result\nresult = find_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b)\nprint(result)"}
{"solution": "def mars_days_off(n):\n    # Calculate the number of complete weeks and remaining days\n    complete_weeks = n // 7\n    remaining_days = n % 7\n\n    # Minimum days off: all remaining days are work days\n    min_days_off = complete_weeks * 2\n\n    # Maximum days off: all remaining days are days off, but not more than 2\n    max_days_off = min_days_off + min(remaining_days, 2)\n\n    print(min_days_off, max_days_off)\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the result\nmars_days_off(n)"}
{"solution": "def max_chocolates(n, a, b, p, q):\n    from math import gcd\n\n    lcm_ab = (a * b) // gcd(a, b)\n    \n    red_tiles = n // a\n    blue_tiles = n // b\n    both_tiles = n // lcm_ab\n    \n    max_chocolates = red_tiles * p + blue_tiles * q - both_tiles * min(p, q)\n    \n    return max_chocolates\n\n# Read input\nn, a, b, p, q = map(int, input().strip().split())\n\n# Calculate and print the result\nprint(max_chocolates(n, a, b, p, q))"}
{"solution": "def max_beauty(n, trophies):\n    # Find all segments of golden trophies\n    segments = []\n    current_length = 0\n    for i in range(n):\n        if trophies[i] == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n    if current_length > 0:\n        segments.append(current_length)\n    \n    # If there are no golden trophies\n    if not segments:\n        return 0\n    \n    # If there is only one segment of golden trophies\n    if len(segments) == 1:\n        return min(segments[0] + 1, n)\n    \n    # Calculate the maximum beauty with at most one swap\n    max_beauty = 0\n    for i in range(len(segments) - 1):\n        # Check if there is exactly one silver trophy between two segments\n        if trophies[trophies.index('G' * segments[i]) + segments[i]] == 'S' and trophies[trophies.index('G' * segments[i]) + segments[i] + 1] == 'G':\n            max_beauty = max(max_beauty, segments[i] + segments[i + 1] + 1)\n        else:\n            max_beauty = max(max_beauty, segments[i] + 1, segments[i + 1] + 1)\n    \n    return max(max_beauty, max(segments))\n\n# Read input\nn = int(input())\ntrophies = input().strip()\n\n# Print the result\nprint(max_beauty(n, trophies))"}
{"solution": "from collections import deque, defaultdict\n\ndef find_course_order(n, k, main_courses, dependencies):\n    # Create a graph and in-degree count\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        for dep in dependencies[i - 1]:\n            graph[dep].append(i)\n            in_degree[i] += 1\n    \n    # Topological sort using Kahn's algorithm\n    queue = deque()\n    for i in range(1, n + 1):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    topo_order = []\n    while queue:\n        course = queue.popleft()\n        topo_order.append(course)\n        for neighbor in graph[course]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check if we have a valid topological order\n    if len(topo_order) != n:\n        return -1, []\n    \n    # Find the minimum set of courses to take\n    required_courses = set(main_courses)\n    result = []\n    visited = set()\n    \n    def dfs(course):\n        if course in visited:\n            return\n        visited.add(course)\n        for dep in dependencies[course - 1]:\n            dfs(dep)\n        result.append(course)\n    \n    for course in main_courses:\n        dfs(course)\n    \n    result.reverse()\n    return len(result), result\n\n# Read input\nn, k = map(int, input().split())\nmain_courses = list(map(int, input().split()))\ndependencies = []\nfor _ in range(n):\n    line = list(map(int, input().split()))\n    dependencies.append(line[1:])\n\n# Find the order of courses\nm, order = find_course_order(n, k, main_courses, dependencies)\n\n# Print the result\nif m == -1:\n    print(-1)\nelse:\n    print(m)\n    print(\" \".join(map(str, order)))"}
{"solution": "def is_stack_sortable(a):\n    s = []\n    b = []\n    for num in a:\n        while s and (not b or s[-1] < b[-1]):\n            b.append(s.pop())\n        s.append(num)\n    while s:\n        b.append(s.pop())\n    return b == sorted(b)\n\ndef solve(n, k, p):\n    remaining = set(range(1, n + 1)) - set(p)\n    remaining = sorted(remaining, reverse=True)\n    \n    for i in range(len(remaining)):\n        candidate = p + remaining[:i+1] + sorted(remaining[i+1:], reverse=True)\n        if is_stack_sortable(candidate):\n            return candidate\n    return -1\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\np = list(map(int, data[2:2+k]))\n\n# Solve the problem\nresult = solve(n, k, p)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "def does_b_appear_in_sequence(a, b, c):\n    if c == 0:\n        if a == b:\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n# Read input\na, b, c = map(int, input().strip().split())\n\n# Determine if b appears in the sequence\nresult = does_b_appear_in_sequence(a, b, c)\n\n# Print the result\nprint(result)"}
{"solution": "cnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\nif cnt_1 == cnt_4 and cnt_2 == cnt_3:\n    if cnt_2 == 0 or cnt_1 > 0:\n        print(1)\n    else:\n        print(0)\nelse:\n    print(0)"}
{"solution": "def standing_spectators(n, k, t):\n    if t <= k:\n        return t\n    elif t <= n:\n        return k\n    else:\n        return n + k - t\n\n# Read input\nn, k, t = map(int, input().split())\n\n# Calculate and print the result\nprint(standing_spectators(n, k, t))"}
{"solution": "def petya_game(s):\n    t = []\n    u = []\n    s = list(s)\n    \n    while s or t:\n        if t and (not s or t[-1] <= min(s)):\n            u.append(t.pop())\n        else:\n            t.append(s.pop(0))\n    \n    print(\"\".join(u))\n\n# Read input\ns = input().strip()\npetya_game(s)"}
{"solution": "def is_valid_sequence(n, stats):\n    for i in range(n):\n        p, c = stats[i]\n        if c > p:\n            return False\n        if i > 0:\n            prev_p, prev_c = stats[i-1]\n            if p < prev_p or c < prev_c or (p - prev_p) < (c - prev_c):\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        n = int(data[index])\n        index += 1\n        stats = []\n        for _ in range(n):\n            p = int(data[index])\n            c = int(data[index + 1])\n            stats.append((p, c))\n            index += 2\n        if is_valid_sequence(n, stats):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_palindrome(time):\n    return time == time[::-1]\n\ndef increment_time(hh, mm):\n    mm += 1\n    if mm == 60:\n        mm = 0\n        hh += 1\n        if hh == 24:\n            hh = 0\n    return hh, mm\n\ndef format_time(hh, mm):\n    return f\"{hh:02}:{mm:02}\"\n\ndef min_minutes_to_palindrome(time):\n    hh, mm = map(int, time.split(':'))\n    minutes = 0\n    while True:\n        formatted_time = format_time(hh, mm)\n        if is_palindrome(formatted_time.replace(':', '')):\n            return minutes\n        hh, mm = increment_time(hh, mm)\n        minutes += 1\n\n# Read input\ntime = input().strip()\n# Calculate and print the result\nprint(min_minutes_to_palindrome(time))"}
{"solution": "def max_distance_after_swap(n, a):\n    min_index = a.index(1)\n    max_index = a.index(n)\n    \n    # Calculate the possible distances after swapping\n    dist1 = abs(min_index - 0)  # Swap min element to the start\n    dist2 = abs(min_index - (n - 1))  # Swap min element to the end\n    dist3 = abs(max_index - 0)  # Swap max element to the start\n    dist4 = abs(max_index - (n - 1))  # Swap max element to the end\n    \n    # The maximum distance after one swap\n    return max(dist1, dist2, dist3, dist4)\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = max_distance_after_swap(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    for i in range(n // 2):\n        if s[i] != s[n - 1 - i]:\n            return \"NIE\"\n    return \"TAK\"\n\n# Read input\ns = input().strip()\n\n# Check if the string is s-palindrome and print the result\nprint(is_s_palindrome(s))"}
{"solution": "from itertools import permutations\n\ndef find_max_permutation(a, b):\n    a_str = str(a)\n    b_str = str(b)\n    max_num = -1\n    \n    for perm in permutations(a_str):\n        perm_num = int(''.join(perm))\n        if perm_num <= b and perm_num > max_num and str(perm_num)[0] != '0':\n            max_num = perm_num\n    \n    return max_num\n\n# Read input\na = int(input().strip())\nb = int(input().strip())\n\n# Find and print the result\nresult = find_max_permutation(a, b)\nprint(result)"}
{"solution": "def check_win(board, x, y):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]\n    for dx, dy in directions:\n        count = 1\n        for i in range(1, 5):\n            nx, ny = x + i * dx, y + i * dy\n            if 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n            else:\n                break\n        for i in range(1, 5):\n            nx, ny = x - i * dx, y - i * dy\n            if 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n            else:\n                break\n        if count >= 5:\n            return True\n    return False\n\ndef can_alice_win(board):\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i][j] = 'X'\n                if check_win(board, i, j):\n                    return True\n                board[i][j] = '.'\n    return False\n\nboard = [input().strip() for _ in range(10)]\nif can_alice_win(board):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def generate_matrix(n, k):\n    if k > n * n:\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        if k <= 0:\n            break\n        if k >= 2:\n            matrix[i][i] = 1\n            k -= 1\n            for j in range(i + 1, n):\n                if k >= 2:\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n                else:\n                    break\n        elif k == 1:\n            matrix[i][i] = 1\n            k -= 1\n\n    if k > 0:\n        return -1\n\n    return matrix\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    n = int(data[0])\n    k = int(data[1])\n\n    result = generate_matrix(n, k)\n    if result == -1:\n        print(-1)\n    else:\n        for row in result:\n            print(' '.join(map(str, row)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef calculate_expressions(x, y, z):\n    expressions = [\n        (x ** (y ** z), \"x^y^z\"),\n        (x ** (z ** y), \"x^z^y\"),\n        ((x ** y) ** z, \"(x^y)^z\"),\n        ((x ** z) ** y, \"(x^z)^y\"),\n        (y ** (x ** z), \"y^x^z\"),\n        (y ** (z ** x), \"y^z^x\"),\n        ((y ** x) ** z, \"(y^x)^z\"),\n        ((y ** z) ** x, \"(y^z)^x\"),\n        (z ** (x ** y), \"z^x^y\"),\n        (z ** (y ** x), \"z^y^x\"),\n        ((z ** x) ** y, \"(z^x)^y\"),\n        ((z ** y) ** x, \"(z^y)^x\")\n    ]\n    return expressions\n\ndef find_max_expression(x, y, z):\n    expressions = calculate_expressions(x, y, z)\n    max_value, max_expression = max(expressions, key=lambda item: item[0])\n    return max_expression\n\nif __name__ == \"__main__\":\n    x, y, z = map(float, input().split())\n    result = find_max_expression(x, y, z)\n    print(result)"}
{"solution": "def min_operations_to_type_string(n, s):\n    min_operations = n  # Start with the worst case: typing all characters one by one\n\n    for i in range(1, n // 2 + 1):\n        if s[:i] == s[i:2*i]:\n            min_operations = min(min_operations, i + 1 + (n - 2 * i))\n\n    return min_operations\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Calculate and print the minimum number of operations\nprint(min_operations_to_type_string(n, s))"}
{"solution": "n = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = []\nregulars = []\n\nfor name, type_ in files:\n    if type_ == '1':\n        examples.append(name)\n    else:\n        regulars.append(name)\n\nmoves = []\ntemp_name = 'temp'\n\n# Move examples to the beginning\nfor i in range(len(examples)):\n    if examples[i] != str(i + 1):\n        if str(i + 1) in examples or str(i + 1) in regulars:\n            moves.append(f\"move {i + 1} {temp_name}\")\n        moves.append(f\"move {examples[i]} {i + 1}\")\n        if str(i + 1) in examples or str(i + 1) in regulars:\n            moves.append(f\"move {temp_name} {examples[i]}\")\n\n# Move regulars to the correct positions\nfor i in range(len(regulars)):\n    if regulars[i] != str(len(examples) + i + 1):\n        if str(len(examples) + i + 1) in examples or str(len(examples) + i + 1) in regulars:\n            moves.append(f\"move {len(examples) + i + 1} {temp_name}\")\n        moves.append(f\"move {regulars[i]} {len(examples) + i + 1}\")\n        if str(len(examples) + i + 1) in examples or str(len(examples) + i + 1) in regulars:\n            moves.append(f\"move {temp_name} {regulars[i]}\")\n\nprint(len(moves))\nfor move in moves:\n    print(move)"}
{"solution": "def min_replacements_to_lucky(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n\n    sum_first_half = sum(first_half)\n    sum_second_half = sum(second_half)\n\n    if sum_first_half == sum_second_half:\n        return 0\n\n    diff = abs(sum_first_half - sum_second_half)\n\n    if sum_first_half > sum_second_half:\n        first_half, second_half = second_half, first_half\n\n    changes = []\n    for i in range(3):\n        changes.append(9 - first_half[i])\n        changes.append(second_half[i])\n\n    changes.sort(reverse=True)\n\n    replacements = 0\n    for change in changes:\n        diff -= change\n        replacements += 1\n        if diff <= 0:\n            return replacements\n\n    return replacements\n\nticket = input().strip()\nprint(min_replacements_to_lucky(ticket))"}
{"solution": "def min_traps(m, x):\n    # Since GCD(x, m) = 1, x is a generator of the multiplicative group of integers modulo m\n    # The number of distinct rooms the x-mouse can visit is equal to the order of this group, which is m-1\n    return m - 1\n\n# Read input\nm, x = map(int, input().split())\n\n# Print the result\nprint(min_traps(m, x))"}
{"solution": "import math\n\nMOD = 10**6 + 3\n\ndef modinv(a, m):\n    return pow(a, m-2, m)\n\ndef solve(n, k):\n    if k > (1 << n):\n        print(1, 1)\n        return\n    \n    total_days = 1 << n\n    numerator = 1\n    denominator = 1\n    \n    for i in range(k):\n        numerator = (numerator * (total_days - i)) % MOD\n        denominator = (denominator * total_days) % MOD\n    \n    prob_no_shared_birthday = (numerator * modinv(denominator, MOD)) % MOD\n    prob_shared_birthday = (1 - prob_no_shared_birthday + MOD) % MOD\n    \n    gcd = math.gcd(prob_shared_birthday, MOD)\n    A = prob_shared_birthday // gcd\n    B = MOD // gcd\n    \n    print(A, B)\n\nn, k = map(int, input().split())\nsolve(n, k)"}
{"solution": "def is_valid_journey(n, journey):\n    position = 0  # Start at the North Pole\n\n    for t, dir in journey:\n        if dir == \"North\":\n            if position == 0:\n                return \"NO\"\n            position -= t\n        elif dir == \"South\":\n            if position == 20000:\n                return \"NO\"\n            position += t\n        elif dir in [\"West\", \"East\"]:\n            if position == 0 or position == 20000:\n                return \"NO\"\n        \n        if position < 0 or position > 20000:\n            return \"NO\"\n\n    return \"YES\" if position == 0 else \"NO\"\n\n# Read input\nn = int(input())\njourney = [input().split() for _ in range(n)]\njourney = [(int(t), dir) for t, dir in journey]\n\n# Check if the journey is valid\nprint(is_valid_journey(n, journey))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef find_common_elements(a1, b1, a2, b2, L, R):\n    g = gcd(a1, a2)\n    if (b2 - b1) % g != 0:\n        return 0\n\n    lcm = (a1 // g) * a2\n    start = max(L, min(b1, b2))\n    end = min(R, max(b1, b2) + lcm - 1)\n\n    if start > end:\n        return 0\n\n    count = 0\n    for x in range(start, end + 1):\n        if (x - b1) % a1 == 0 and (x - b2) % a2 == 0:\n            count += 1\n\n    return count\n\na1, b1, a2, b2, L, R = map(int, input().split())\nprint(find_common_elements(a1, b1, a2, b2, L, R))"}
{"solution": "def max_min_pieces(n, a, b):\n    left, right = 1, min(a, b)\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if (a // mid) + (b // mid) >= n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return right\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(max_min_pieces(n, a, b))"}
{"solution": "def is_berland_flag(n, m, field):\n    def check_stripes(lines):\n        if len(lines) % 3 != 0:\n            return False\n        stripe_height = len(lines) // 3\n        colors = set()\n        for i in range(3):\n            stripe = lines[i * stripe_height:(i + 1) * stripe_height]\n            color = stripe[0]\n            if any(row != color for row in stripe):\n                return False\n            colors.add(color)\n        return len(colors) == 3\n\n    # Check horizontal stripes\n    if check_stripes(field):\n        return \"YES\"\n\n    # Check vertical stripes\n    transposed_field = [''.join(row[i] for row in field) for i in range(m)]\n    if check_stripes(transposed_field):\n        return \"YES\"\n\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Output result\nprint(is_berland_flag(n, m, field))"}
{"solution": "def find_coordinates(n):\n    if n == 0:\n        return (0, 0)\n    \n    # Directions in the order of the spiral\n    directions = [(1, 0), (0, 1), (-1, 1), (-1, 0), (0, -1), (1, -1)]\n    \n    # Initialize starting point\n    x, y = 0, 0\n    step = 1\n    move_count = 0\n    \n    while move_count < n:\n        for direction in directions:\n            for _ in range(step):\n                if move_count == n:\n                    return (x, y)\n                x += direction[0]\n                y += direction[1]\n                move_count += 1\n            if direction == directions[2] or direction == directions[5]:\n                step += 1\n\n    return (x, y)\n\n# Read input\nn = int(input().strip())\n\n# Find coordinates after n moves\nx, y = find_coordinates(n)\n\n# Print the result\nprint(x, y)"}
{"solution": "def can_break_shield(a, b, c):\n    for i in range(c // a + 1):\n        if (c - i * a) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Read input\na, b, c = map(int, input().split())\n\n# Print the result\nprint(can_break_shield(a, b, c))"}
{"solution": "def check_tracks(n, L, kefa, sasha):\n    def get_diffs(arr):\n        return [(arr[i] - arr[i-1]) % L for i in range(1, n)] + [(arr[0] - arr[-1]) % L]\n\n    kefa_diffs = get_diffs(kefa)\n    sasha_diffs = get_diffs(sasha)\n\n    for i in range(n):\n        if kefa_diffs == sasha_diffs[i:] + sasha_diffs[:i]:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa = list(map(int, input().split()))\nsasha = list(map(int, input().split()))\n\n# Check if tracks coincide\nresult = check_tracks(n, L, kefa, sasha)\nprint(result)"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring_length(s):\n    n = len(s)\n    if not is_palindrome(s):\n        return n\n    for length in range(n-1, 0, -1):\n        for start in range(n - length + 1):\n            substring = s[start:start + length]\n            if not is_palindrome(substring):\n                return length\n    return 0\n\ns = input().strip()\nprint(longest_non_palindrome_substring_length(s))"}
{"solution": "n = int(input())\nparticipants = [tuple(map(int, input().split())) for _ in range(n)]\n\nrated = False\nunrated = False\n\nfor a, b in participants:\n    if a != b:\n        rated = True\n        break\n\nif not rated:\n    for i in range(1, n):\n        if participants[i-1][0] < participants[i][0]:\n            unrated = True\n            break\n\nif rated:\n    print(\"rated\")\nelif unrated:\n    print(\"unrated\")\nelse:\n    print(\"maybe\")"}
{"solution": "def nearest_zero_distances(n, arr):\n    distances = [float('inf')] * n\n    last_zero = -1\n\n    # Forward pass to find nearest zero on the left\n    for i in range(n):\n        if arr[i] == 0:\n            last_zero = i\n        if last_zero != -1:\n            distances[i] = i - last_zero\n\n    last_zero = -1\n\n    # Backward pass to find nearest zero on the right\n    for i in range(n-1, -1, -1):\n        if arr[i] == 0:\n            last_zero = i\n        if last_zero != -1:\n            distances[i] = min(distances[i], last_zero - i)\n\n    return distances\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Get the distances\ndistances = nearest_zero_distances(n, arr)\n\n# Print the result\nprint(' '.join(map(str, distances)))"}
{"solution": "def count_distinct_cyclical_strings(n, s):\n    from itertools import product\n\n    def is_cyclical_substring(t, s):\n        t = t + t\n        return s in t\n\n    count = 0\n    for t in product('01', repeat=n):\n        t = ''.join(t)\n        if is_cyclical_substring(t, s):\n            count += 1\n\n    return count\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Calculate and print the result\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import math\n\ndef angle_between(v1, v2):\n    dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n    magnitude_v1 = math.sqrt(v1[0]**2 + v1[1]**2)\n    magnitude_v2 = math.sqrt(v2[0]**2 + v2[1]**2)\n    cos_theta = dot_product / (magnitude_v1 * magnitude_v2)\n    return math.acos(cos_theta)\n\nn = int(input())\nvectors = []\n\nfor i in range(n):\n    x, y = map(int, input().split())\n    vectors.append((x, y, i + 1))\n\nvectors.sort(key=lambda v: math.atan2(v[1], v[0]))\n\nmin_angle = float('inf')\nmin_pair = (0, 0)\n\nfor i in range(n):\n    v1 = vectors[i]\n    v2 = vectors[(i + 1) % n]\n    angle = angle_between(v1, v2)\n    if angle < min_angle:\n        min_angle = angle\n        min_pair = (v1[2], v2[2])\n\nprint(min_pair[0], min_pair[1])"}
{"solution": "def minimal_time(d, k, a, b, t):\n    if d <= k:\n        return d * a\n    \n    # Time to drive the first k kilometers\n    time = k * a\n    d -= k\n    \n    # Full cycles of k kilometers\n    full_cycles = d // k\n    remaining_distance = d % k\n    \n    # Time for full cycles\n    time += full_cycles * (k * a + t)\n    \n    # Time for remaining distance\n    if remaining_distance > 0:\n        time += min(remaining_distance * a + t, remaining_distance * b)\n    \n    return time\n\n# Read input\nd, k, a, b, t = map(int, input().split())\n\n# Calculate and print the minimal time\nprint(minimal_time(d, k, a, b, t))"}
{"solution": "def find_sequence(n, k):\n    if k * (k + 1) // 2 > n:\n        return -1\n    \n    base = n // k\n    remainder = n % k\n    \n    sequence = [base + i for i in range(1, k + 1)]\n    \n    for i in range(k):\n        if remainder > 0:\n            sequence[i] += 1\n            remainder -= 1\n    \n    return sequence\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    n = int(data[0])\n    k = int(data[1])\n    \n    result = find_sequence(n, k)\n    if result == -1:\n        print(-1)\n    else:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_pairs(n, m):\n    count = 0\n    for i in range(5):\n        for j in range(5):\n            if (i + j) % 5 == 0:\n                count += ((n - i + 4) // 5) * ((m - j + 4) // 5)\n    return count\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(count_pairs(n, m))"}
{"solution": "def max_beauty(n, x, a):\n    max_ending_here = 0\n    max_so_far = 0\n    max_ending_here_with_x = 0\n    max_so_far_with_x = 0\n    max_ending_here_with_x_and_after = 0\n    max_so_far_with_x_and_after = 0\n\n    for i in range(n):\n        max_ending_here = max(0, max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n\n        max_ending_here_with_x = max(0, max_ending_here_with_x + a[i] * x)\n        max_so_far_with_x = max(max_so_far_with_x, max_ending_here_with_x)\n\n        max_ending_here_with_x_and_after = max(max_ending_here_with_x_and_after + a[i], max_ending_here_with_x)\n        max_so_far_with_x_and_after = max(max_so_far_with_x_and_after, max_ending_here_with_x_and_after)\n\n    return max(max_so_far, max_so_far_with_x, max_so_far_with_x_and_after)\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_beauty(n, x, a))"}
{"solution": "def find_kth_largest(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(x // i, m)\n        return count\n\n    left, right = 1, n * m\n    while left < right:\n        mid = (left + right) // 2\n        if count_less_equal(mid) < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Read input\nn, m, k = map(int, input().strip().split())\n\n# Find and print the k-th largest number\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    start += (k - 1) // length\n    s = str(start)\n    return s[(k - 1) % length]\n\nk = int(input().strip())\nprint(find_kth_digit(k))"}
{"solution": "def max_bourles(n, m, r, s, b):\n    min_buy_price = min(s)\n    max_sell_price = max(b)\n    \n    if min_buy_price >= max_sell_price:\n        return r\n    \n    shares_to_buy = r // min_buy_price\n    remaining_bourles = r % min_buy_price\n    total_bourles = shares_to_buy * max_sell_price + remaining_bourles\n    \n    return total_bourles\n\n# Read input\nn, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_bourles(n, m, r, s, b))"}
{"solution": "def find_possible_message(t):\n    n = len(t)\n    for i in range(1, n):\n        if t[:i] == t[-i:]:\n            s = t[:-i]\n            if s + t[:i] == t:\n                return \"YES\\n\" + s\n    return \"NO\"\n\n# Read input\nt = input().strip()\n\n# Find and print the result\nprint(find_possible_message(t))"}
{"solution": "def find_teams(n):\n    results = []\n    \n    def count_games(teams):\n        games = 0\n        while teams % 2 == 0:\n            games += teams // 2\n            teams //= 2\n        if teams > 1:\n            games += teams * (teams - 1) // 2\n        return games\n    \n    for teams in range(1, n + 1):\n        if count_games(teams) == n:\n            results.append(teams)\n    \n    if results:\n        for result in results:\n            print(result)\n    else:\n        print(-1)\n\n# Read input\nn = int(input().strip())\nfind_teams(n)"}
{"solution": "def max_beauty(n, s, b):\n    from collections import Counter\n\n    # Count the frequency of each character in the string\n    freq = Counter(s)\n    \n    # Sort the characters by their frequency in descending order\n    sorted_chars = sorted(freq.items(), key=lambda x: -x[1])\n    \n    # Sort the beauty values in descending order\n    sorted_beauty = sorted(b, reverse=True)\n    \n    # Create a list to store the final string t\n    t = [''] * n\n    \n    # Fill the first half of t with the most frequent characters\n    index = 0\n    for char, count in sorted_chars:\n        for _ in range(count):\n            if index < n // 2:\n                t[index] = char\n                index += 1\n            else:\n                break\n    \n    # Fill the second half of t with the remaining characters\n    index = n // 2\n    for char, count in sorted_chars:\n        for _ in range(count):\n            if index < n:\n                t[index] = char\n                index += 1\n            else:\n                break\n    \n    # Calculate the maximum possible beauty\n    max_beauty = 0\n    for i in range(n):\n        if s[i] == t[i]:\n            max_beauty += sorted_beauty[i]\n    \n    return max_beauty\n\n# Read input\nn = int(input())\ns = input().strip()\nb = list(map(int, input().split()))\n\n# Get the maximum possible beauty\nresult = max_beauty(n, s, b)\n\n# Print the result\nprint(result)"}
{"solution": "def can_weight(w, m):\n    while m > 0:\n        if m % w == 0:\n            m //= w\n        elif (m + 1) % w == 0:\n            m = (m + 1) // w\n        elif (m - 1) % w == 0:\n            m = (m - 1) // w\n        else:\n            return \"NO\"\n    return \"YES\"\n\n# Read input\nw, m = map(int, input().split())\n\n# Print the result\nprint(can_weight(w, m))"}
{"solution": "def solve(n, k):\n    if k > n:\n        print(\"No\")\n        return\n\n    powers = []\n    for i in range(60, -61, -1):\n        if n >= (1 << i):\n            powers.append(i)\n            n -= (1 << i)\n\n    if len(powers) > k:\n        print(\"No\")\n        return\n\n    while len(powers) < k:\n        smallest = powers.pop()\n        powers.append(smallest - 1)\n        powers.append(smallest - 1)\n\n    powers.sort(reverse=True)\n    print(\"Yes\")\n    print(\" \".join(map(str, powers)))\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    solve(n, k)"}
{"solution": "def count_full_glasses(n, t):\n    glasses = [[0] * (i + 1) for i in range(n)]\n    glasses[0][0] = t\n\n    for i in range(n):\n        for j in range(i + 1):\n            if glasses[i][j] > 1:\n                overflow = glasses[i][j] - 1\n                glasses[i][j] = 1\n                if i + 1 < n:\n                    glasses[i + 1][j] += overflow / 2\n                    glasses[i + 1][j + 1] += overflow / 2\n\n    full_glasses = sum(1 for i in range(n) for j in range(i + 1) if glasses[i][j] >= 1)\n    return full_glasses\n\n# Read input\nn, t = map(int, input().split())\n\n# Calculate and print the result\nprint(count_full_glasses(n, t))"}
{"solution": "def calculate_area(vertices):\n    if len(vertices) == 1:\n        return -1\n    elif len(vertices) == 2:\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        return abs(x2 - x1) * abs(y2 - y1)\n    elif len(vertices) == 3:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x2 - x1) * abs(y2 - y1)\n        else:\n            return -1\n    elif len(vertices) == 4:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x2 - x1) * abs(y2 - y1)\n        else:\n            return -1\n\nn = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\nprint(calculate_area(vertices))"}
{"solution": "def minimal_wooden_bars(n, a, b):\n    total_length_needed = 4 * a + 2 * b\n    bars_needed = (total_length_needed + n - 1) // n\n    return bars_needed\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = int(input())\n    b = int(input())\n    print(minimal_wooden_bars(n, a, b))"}
{"solution": "def can_sort_array(n, a, s):\n    segments = []\n    start = 0\n\n    for i in range(n - 1):\n        if s[i] == '0':\n            segments.append((start, i))\n            start = i + 1\n    segments.append((start, n - 1))\n\n    for start, end in segments:\n        segment = a[start:end + 1]\n        if sorted(segment) != segment:\n            return \"NO\"\n    return \"YES\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\ns = input().strip()\n\n# Output result\nprint(can_sort_array(n, a, s))"}
{"solution": "def time_to_get_lunch(seat):\n    n = int(seat[:-1])\n    s = seat[-1]\n    \n    # Time to serve one row\n    time_per_row = 6\n    \n    # Determine the base time for the row\n    if n % 4 == 1 or n % 4 == 2:\n        base_time = (n - 1) // 2 * (time_per_row + 1)\n    else:\n        base_time = (n - 1) // 2 * (time_per_row + 1) + time_per_row + 1\n    \n    # Determine the additional time based on the seat\n    seat_time = {'a': 5, 'b': 4, 'c': 3, 'd': 3, 'e': 2, 'f': 1}\n    \n    return base_time + seat_time[s]\n\n# Read input\nseat = input().strip()\n\n# Calculate and print the result\nprint(time_to_get_lunch(seat))"}
{"solution": "def base_to_decimal(digits, base):\n    decimal_value = 0\n    for digit in digits:\n        decimal_value = decimal_value * base + digit\n    return decimal_value\n\n# Read input\nn, b_x = map(int, input().split())\nx_digits = list(map(int, input().split()))\nm, b_y = map(int, input().split())\ny_digits = list(map(int, input().split()))\n\n# Convert both numbers to decimal\nX = base_to_decimal(x_digits, b_x)\nY = base_to_decimal(y_digits, b_y)\n\n# Compare and print the result\nif X < Y:\n    print('<')\nelif X > Y:\n    print('>')\nelse:\n    print('=')"}
{"solution": "def determine_winner(n, a):\n    if n == 1:\n        return \"BitLGM\" if a[0] > 0 else \"BitAryo\"\n    elif n == 2:\n        return \"BitLGM\" if a[0] != a[1] else \"BitAryo\"\n    else:\n        xor_sum = a[0] ^ a[1] ^ a[2]\n        return \"BitLGM\" if xor_sum != 0 else \"BitAryo\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, a))"}
{"solution": "def count_valid_decks(n, k, cards):\n    from math import gcd\n    from functools import reduce\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def product_mod_k(arr, k):\n        result = 1\n        for num in arr:\n            result = (result * num) % k\n            if result == 0:\n                return 0\n        return result\n\n    total_product = reduce(lambda x, y: x * y, cards)\n    if total_product % k == 0:\n        return n * (n + 1) // 2\n\n    valid_ways = 0\n    prefix_product = [1] * (n + 1)\n    suffix_product = [1] * (n + 1)\n\n    for i in range(n):\n        prefix_product[i + 1] = (prefix_product[i] * cards[i]) % k\n\n    for i in range(n - 1, -1, -1):\n        suffix_product[i] = (suffix_product[i + 1] * cards[i]) % k\n\n    for x in range(n):\n        for y in range(n - x):\n            if (prefix_product[x] * suffix_product[n - y]) % k == 0:\n                valid_ways += 1\n\n    return valid_ways\n\n# Read input\nn, k = map(int, input().split())\ncards = list(map(int, input().split()))\n\n# Calculate and print the number of valid ways\nprint(count_valid_decks(n, k, cards))"}
{"solution": "def can_distribute_balloons(n, k, s):\n    from collections import Counter\n    \n    balloon_counts = Counter(s)\n    \n    for count in balloon_counts.values():\n        if count > k:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Determine if Kefa can distribute the balloons\nresult = can_distribute_balloons(n, k, s)\nprint(result)"}
{"solution": "n = int(input())\narr = list(map(int, input().split()))\n\nmin_val = min(arr)\nmin_indices = [i for i, x in enumerate(arr) if x == min_val]\n\nmin_distance = float('inf')\nfor i in range(1, len(min_indices)):\n    min_distance = min(min_distance, min_indices[i] - min_indices[i - 1])\n\nprint(min_distance)"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(t, w, b):\n    if w > b:\n        w, b = b, w\n\n    l = lcm(w, b)\n    full_cycles = t // l\n    remainder = t % l\n\n    tie_count = full_cycles * w + min(w - 1, remainder)\n    tie_count += min(w - 1, t)\n\n    p = tie_count\n    q = t\n\n    g = gcd(p, q)\n    p //= g\n    q //= g\n\n    print(f\"{p}/{q}\")\n\n# Read input\nt, w, b = map(int, input().split())\n\n# Solve the problem\nsolve(t, w, b)"}
{"solution": "def determine_result(x, y, z):\n    if x > y + z:\n        return \"+\"\n    elif y > x + z:\n        return \"-\"\n    elif x == y and z == 0:\n        return \"0\"\n    else:\n        return \"?\"\n\n# Read input\nx, y, z = map(int, input().split())\n\n# Determine and print the result\nprint(determine_result(x, y, z))"}
{"solution": "def min_length_to_reach_target(n, operations, x, y):\n    # Calculate the final position after performing the given operations\n    final_x, final_y = 0, 0\n    for op in operations:\n        if op == 'U':\n            final_y += 1\n        elif op == 'D':\n            final_y -= 1\n        elif op == 'L':\n            final_x -= 1\n        elif op == 'R':\n            final_x += 1\n\n    # If the final position is already the target, no changes are needed\n    if final_x == x and final_y == y:\n        return 0\n\n    # Calculate the difference between the final position and the target\n    dx, dy = x - final_x, y - final_y\n\n    # If the difference is odd, it's impossible to reach the target\n    if (dx + dy) % 2 != 0:\n        return -1\n\n    # Use a sliding window to find the minimum length of the subsegment to change\n    min_length = float('inf')\n    current_x, current_y = 0, 0\n    left = 0\n\n    for right in range(n):\n        if operations[right] == 'U':\n            current_y += 1\n        elif operations[right] == 'D':\n            current_y -= 1\n        elif operations[right] == 'L':\n            current_x -= 1\n        elif operations[right] == 'R':\n            current_x += 1\n\n        while left <= right and abs(current_x - dx) + abs(current_y - dy) <= (right - left + 1):\n            min_length = min(min_length, right - left + 1)\n            if operations[left] == 'U':\n                current_y -= 1\n            elif operations[left] == 'D':\n                current_y += 1\n            elif operations[left] == 'L':\n                current_x += 1\n            elif operations[left] == 'R':\n                current_x -= 1\n            left += 1\n\n    return min_length if min_length != float('inf') else -1\n\n# Read input\nn = int(input())\noperations = input().strip()\nx, y = map(int, input().split())\n\n# Get the result and print it\nresult = min_length_to_reach_target(n, operations, x, y)\nprint(result)"}
{"solution": "def count_prefixes_with_balance(n, x, s):\n    balance = 0\n    prefix_balances = []\n    \n    for char in s:\n        if char == '0':\n            balance += 1\n        else:\n            balance -= 1\n        prefix_balances.append(balance)\n    \n    total_balance = balance\n    count = 0\n    \n    if total_balance == 0:\n        if x in prefix_balances:\n            return -1\n        else:\n            return 0\n    \n    for i in range(n):\n        if (x - prefix_balances[i]) % total_balance == 0 and (x - prefix_balances[i]) // total_balance >= 0:\n            count += 1\n    \n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        n = int(data[index])\n        x = int(data[index + 1])\n        s = data[index + 2]\n        index += 3\n        \n        result = count_prefixes_with_balance(n, x, s)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_digits_to_remove(n, k):\n    n_str = str(n)\n    count_zeros = 0\n    digits_to_remove = 0\n\n    for digit in reversed(n_str):\n        if digit == '0':\n            count_zeros += 1\n        else:\n            digits_to_remove += 1\n        if count_zeros == k:\n            return digits_to_remove\n\n    return len(n_str) - 1\n\n# Read input\nn, k = map(int, input().split())\n\n# Get the result\nresult = min_digits_to_remove(n, k)\n\n# Print the result\nprint(result)"}
{"solution": "def literature_lesson(n, m, k, x, y):\n    if n == 1:\n        max_questions = (k + m - 1) // m\n        min_questions = k // m\n        sergei_questions = (k + y - 1) // m\n    else:\n        full_cycle = 2 * n - 2\n        full_cycle_questions = full_cycle * m\n        full_cycles = k // full_cycle_questions\n        remaining_questions = k % full_cycle_questions\n\n        max_questions = full_cycles * 2\n        min_questions = full_cycles\n\n        if remaining_questions > 0:\n            max_questions += 1\n            if remaining_questions > n * m:\n                max_questions += 1\n\n        if remaining_questions > 0:\n            min_questions += 1\n\n        sergei_questions = full_cycles\n        if x == 1 or x == n:\n            sergei_questions *= 2\n        else:\n            sergei_questions *= 2\n\n        if remaining_questions > 0:\n            if x == 1:\n                if remaining_questions >= (x - 1) * m + y:\n                    sergei_questions += 1\n            elif x == n:\n                if remaining_questions >= (n - 1) * m + y:\n                    sergei_questions += 1\n            else:\n                if remaining_questions >= (x - 1) * m + y:\n                    sergei_questions += 1\n                if remaining_questions > n * m and remaining_questions >= (full_cycle - x + 1) * m + y:\n                    sergei_questions += 1\n\n    print(max_questions, min_questions, sergei_questions)\n\n# Example usage\nn, m, k, x, y = map(int, input().split())\nliterature_lesson(n, m, k, x, y)"}
{"solution": "def max_beauty_after_turns(ribbon, n):\n    from collections import Counter\n    length = len(ribbon)\n    counter = Counter(ribbon)\n    max_freq = max(counter.values())\n    \n    if max_freq == length and n == 1:\n        return length - 1\n    return min(length, max_freq + n)\n\ndef find_winner(n, ribbons):\n    beauties = [max_beauty_after_turns(ribbon, n) for ribbon in ribbons]\n    max_beauty = max(beauties)\n    if beauties.count(max_beauty) > 1:\n        return \"Draw\"\n    if beauties[0] == max_beauty:\n        return \"Kuro\"\n    if beauties[1] == max_beauty:\n        return \"Shiro\"\n    return \"Katie\"\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    ribbons = data[1:4]\n    \n    print(find_winner(n, ribbons))"}
{"solution": "def days_to_finish_book(c, v_0, v_1, a, l):\n    days = 0\n    pages_read = 0\n    current_speed = v_0\n\n    while pages_read < c:\n        days += 1\n        pages_read += current_speed\n        if pages_read >= c:\n            break\n        pages_read -= l\n        current_speed = min(current_speed + a, v_1)\n\n    return days\n\n# Read input\nc, v_0, v_1, a, l = map(int, input().split())\n\n# Calculate and print the number of days needed to finish the book\nprint(days_to_finish_book(c, v_0, v_1, a, l))"}
{"solution": "import sys\nimport math\n\ndef is_prime(x):\n    if x <= 1:\n        return False\n    if x <= 3:\n        return True\n    if x % 2 == 0 or x % 3 == 0:\n        return False\n    i = 5\n    while i * i <= x:\n        if x % i == 0 or x % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_primes(n):\n    if is_prime(n):\n        return [n]\n    for i in range(2, n):\n        if is_prime(i) and is_prime(n - i):\n            return [i, n - i]\n    for i in range(2, n):\n        if is_prime(i):\n            for j in range(2, n - i):\n                if is_prime(j) and is_prime(n - i - j):\n                    return [i, j, n - i - j]\n\ndef main():\n    input = sys.stdin.read().strip()\n    n = int(input)\n    primes = find_primes(n)\n    print(len(primes))\n    print(' '.join(map(str, primes)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_wipe_out_all_walls(n, m, field):\n    row_walls = [0] * n\n    col_walls = [0] * m\n    total_walls = 0\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                row_walls[i] += 1\n                col_walls[j] += 1\n                total_walls += 1\n\n    for i in range(n):\n        for j in range(m):\n            if row_walls[i] + col_walls[j] - (1 if field[i][j] == '*' else 0) == total_walls:\n                return \"YES\", i + 1, j + 1\n\n    return \"NO\",\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Get the result\nresult = can_wipe_out_all_walls(n, m, field)\n\n# Print the result\nif result[0] == \"NO\":\n    print(result[0])\nelse:\n    print(result[0])\n    print(result[1], result[2])"}
{"solution": "def minimal_burles(n, m, a, b):\n    remainder = n % m\n    if remainder == 0:\n        return 0\n    add_cost = (m - remainder) * a\n    remove_cost = remainder * b\n    return min(add_cost, remove_cost)\n\n# Read input\nn, m, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(minimal_burles(n, m, a, b))"}
{"solution": "def max_odd_sum_subsequence(n, a):\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return total_sum\n    \n    min_odd = float('inf')\n    for num in a:\n        if num % 2 != 0:\n            min_odd = min(min_odd, abs(num))\n    \n    return total_sum - min_odd\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = max_odd_sum_subsequence(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef count_playlists(n, T, songs):\n    dp = [[[[0] * 4 for _ in range(T + 1)] for _ in range(1 << n)] for _ in range(n + 1)]\n    dp[0][0][0][0] = 1\n\n    for i in range(n):\n        for mask in range(1 << n):\n            for t in range(T + 1):\n                for last_genre in range(4):\n                    if dp[i][mask][t][last_genre] == 0:\n                        continue\n                    for j in range(n):\n                        if mask & (1 << j):\n                            continue\n                        song_time, song_genre = songs[j]\n                        if t + song_time > T or song_genre == last_genre:\n                            continue\n                        new_mask = mask | (1 << j)\n                        dp[i + 1][new_mask][t + song_time][song_genre] += dp[i][mask][t][last_genre]\n                        dp[i + 1][new_mask][t + song_time][song_genre] %= MOD\n\n    result = 0\n    for i in range(1, n + 1):\n        for last_genre in range(1, 4):\n            result = (result + dp[i][(1 << n) - 1][T][last_genre]) % MOD\n\n    return result\n\nif __name__ == \"__main__\":\n    n, T = map(int, input().split())\n    songs = [tuple(map(int, input().split())) for _ in range(n)]\n    print(count_playlists(n, T, songs))"}
{"solution": "MOD = 10**9 + 7\n\ndef modinv(a, p):\n    return pow(a, p - 2, p)\n\ndef expected_length(m):\n    prob = [0] * (m + 1)\n    for i in range(m, 0, -1):\n        prob[i] = m // i\n        for j in range(2 * i, m + 1, i):\n            prob[i] -= prob[j]\n    \n    P = 0\n    Q = m\n    for i in range(1, m + 1):\n        P += prob[i] * i\n        P %= MOD\n    \n    Q_inv = modinv(Q, MOD)\n    result = (P * Q_inv) % MOD\n    return result\n\nm = int(input())\nprint(expected_length(m))"}
{"solution": "import math\n\ndef count_good_pairs(l, r, x, y):\n    if y % x != 0:\n        return 0\n    \n    count = 0\n    product = y // x\n    \n    for a in range(1, int(math.isqrt(product)) + 1):\n        if product % a == 0:\n            b = product // a\n            a *= x\n            b *= x\n            if l <= a <= r and l <= b <= r and math.gcd(a, b) == x and (a * b) // math.gcd(a, b) == y:\n                if a == b:\n                    count += 1\n                else:\n                    count += 2\n    \n    return count\n\n# Read input\nl, r, x, y = map(int, input().split())\n\n# Print the result\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "import math\n\ndef lcm(x, y):\n    return x * y // math.gcd(x, y)\n\ndef find_min_k(a, b):\n    if a == b:\n        return 0\n    \n    diff = abs(a - b)\n    min_lcm = float('inf')\n    best_k = 0\n    \n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            for d in [i, diff // i]:\n                k = (d - a % d) % d\n                current_lcm = lcm(a + k, b + k)\n                if current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n                    min_lcm = current_lcm\n                    best_k = k\n    \n    return best_k\n\na, b = map(int, input().split())\nprint(find_min_k(a, b))"}
{"solution": "import math\n\ndef minimal_additional_marks(n, k, marks):\n    current_sum = sum(marks)\n    current_count = n\n    \n    while True:\n        average = current_sum / current_count\n        if round(average) == k:\n            return current_count - n\n        current_sum += k\n        current_count += 1\n\n# Read input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(minimal_additional_marks(n, k, marks))"}
{"solution": "import math\n\ndef find_d(n, arr):\n    required_positive_count = math.ceil(n / 2)\n    \n    for d in range(1, 1001):\n        positive_count = sum(1 for x in arr if x / d > 0)\n        if positive_count >= required_positive_count:\n            return d\n    \n    for d in range(-1, -1001, -1):\n        positive_count = sum(1 for x in arr if x / d > 0)\n        if positive_count >= required_positive_count:\n            return d\n    \n    return 0\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Find and print the result\nprint(find_d(n, arr))"}
{"solution": "def count_pairs_with_max_nines(n):\n    max_nines = 0\n    count = 0\n\n    for i in range(1, n // 2 + 1):\n        j = n - i\n        total_cost = i + j\n        nines = 0\n\n        while total_cost % 10 == 9:\n            nines += 1\n            total_cost //= 10\n\n        if nines > max_nines:\n            max_nines = nines\n            count = 1\n        elif nines == max_nines:\n            count += 1\n\n    return count\n\nn = int(input())\nprint(count_pairs_with_max_nines(n))"}
{"solution": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef can_be_equal(a1, b1, a2, b2):\n    area1 = a1 * b1\n    area2 = a2 * b2\n    if area1 == area2:\n        return 0, (a1, b1), (a2, b2)\n    \n    g1 = gcd(a1, b1)\n    g2 = gcd(a2, b2)\n    \n    a1 //= g1\n    b1 //= g1\n    a2 //= g2\n    b2 //= g2\n    \n    if a1 * b1 != a2 * b2:\n        return -1, None, None\n    \n    steps = 0\n    while a1 % 2 == 0 and a2 % 2 == 0:\n        a1 //= 2\n        a2 //= 2\n        steps += 1\n    while b1 % 2 == 0 and b2 % 2 == 0:\n        b1 //= 2\n        b2 //= 2\n        steps += 1\n    while a1 % 3 == 0 and a2 % 3 == 0:\n        a1 //= 3\n        a2 //= 3\n        steps += 1\n    while b1 % 3 == 0 and b2 % 3 == 0:\n        b1 //= 3\n        b2 //= 3\n        steps += 1\n    \n    if a1 == a2 and b1 == b2:\n        return steps, (a1 * g1, b1 * g1), (a2 * g2, b2 * g2)\n    else:\n        return -1, None, None\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\nsteps, bar1, bar2 = can_be_equal(a1, b1, a2, b2)\n\nif steps == -1:\n    print(-1)\nelse:\n    print(steps)\n    print(bar1[0], bar1[1])\n    print(bar2[0], bar2[1])"}
{"solution": "def determine_winner(xp, yp, xv, yv):\n    if max(xp, yp) <= max(xv, yv):\n        return \"Polycarp\"\n    else:\n        return \"Vasiliy\"\n\n# Read input\nxp, yp, xv, yv = map(int, input().split())\n\n# Determine and print the winner\nprint(determine_winner(xp, yp, xv, yv))"}
{"solution": "def number_of_columns(m, d):\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    days = days_in_month[m - 1]\n    first_week_days = 8 - d\n    remaining_days = days - first_week_days\n    full_weeks = (remaining_days + 6) // 7\n    total_columns = 1 + full_weeks\n    return total_columns\n\n# Read input\nm, d = map(int, input().split())\n\n# Calculate and print the number of columns\nprint(number_of_columns(m, d))"}
{"solution": "def count_years_with_one_zero(a, b):\n    def has_exactly_one_zero_in_binary(n):\n        binary_representation = bin(n)[2:]\n        return binary_representation.count('0') == 1\n\n    count = 0\n    for year in range(a, b + 1):\n        if has_exactly_one_zero_in_binary(year):\n            count += 1\n\n    return count\n\n# Read input\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(count_years_with_one_zero(a, b))"}
{"solution": "def minimal_layers(N):\n    return (N * (N + 1)) // 2\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print(minimal_layers(N))"}
{"solution": "from itertools import combinations\nfrom math import factorial\n\ndef count_ways(n, k, S, a):\n    # Precompute factorials for all numbers in a\n    factorials = {x: factorial(x) for x in set(a)}\n    \n    # Function to calculate the number of ways to achieve the sum S\n    def calculate_ways(index, remaining_k, current_sum):\n        if current_sum == S:\n            return 1\n        if index == n or current_sum > S:\n            return 0\n        \n        ways = 0\n        # Option 1: Do not choose the current cube\n        ways += calculate_ways(index + 1, remaining_k, current_sum)\n        \n        # Option 2: Choose the current cube without sticking a sticker\n        ways += calculate_ways(index + 1, remaining_k, current_sum + a[index])\n        \n        # Option 3: Choose the current cube and stick a sticker (if remaining_k > 0)\n        if remaining_k > 0:\n            ways += calculate_ways(index + 1, remaining_k - 1, current_sum + factorials[a[index]])\n        \n        return ways\n    \n    return calculate_ways(0, k, 0)\n\n# Read input\nn, k, S = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_ways(n, k, S, a))"}
{"solution": "def can_achieve_array(n, k, a):\n    max_power = 0\n    while k ** max_power <= 10**16:\n        max_power += 1\n\n    powers = [0] * max_power\n    for num in a:\n        for i in range(max_power - 1, -1, -1):\n            power_val = k ** i\n            if num >= power_val:\n                num -= power_val\n                powers[i] += 1\n                if powers[i] > 1:\n                    return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        a = list(map(int, data[index:index + n]))\n        index += n\n        results.append(can_achieve_array(n, k, a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 1073741824\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    a, b, c = map(int, data)\n    \n    total_sum = 0\n    \n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                product = i * j * k\n                total_sum += count_divisors(product)\n                total_sum %= MOD\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import deque\n\ndef puzzle_to_tuple(puzzle):\n    return tuple(tuple(row) for row in puzzle)\n\ndef find_empty(puzzle):\n    for i in range(2):\n        for j in range(2):\n            if puzzle[i][j] == 'X':\n                return (i, j)\n\ndef get_neighbors(pos):\n    i, j = pos\n    neighbors = []\n    if i > 0: neighbors.append((i-1, j))\n    if i < 1: neighbors.append((i+1, j))\n    if j > 0: neighbors.append((i, j-1))\n    if j < 1: neighbors.append((i, j+1))\n    return neighbors\n\ndef bfs(start, target):\n    queue = deque([start])\n    visited = set()\n    visited.add(start)\n    \n    while queue:\n        current = queue.popleft()\n        if current == target:\n            return True\n        \n        empty_pos = find_empty(current)\n        for neighbor in get_neighbors(empty_pos):\n            new_puzzle = [list(row) for row in current]\n            new_puzzle[empty_pos[0]][empty_pos[1]], new_puzzle[neighbor[0]][neighbor[1]] = new_puzzle[neighbor[0]][neighbor[1]], new_puzzle[empty_pos[0]][empty_pos[1]]\n            new_puzzle_tuple = puzzle_to_tuple(new_puzzle)\n            if new_puzzle_tuple not in visited:\n                visited.add(new_puzzle_tuple)\n                queue.append(new_puzzle_tuple)\n    \n    return False\n\ndef main():\n    bessie_puzzle = [input().strip() for _ in range(2)]\n    elsie_puzzle = [input().strip() for _ in range(2)]\n    \n    bessie_tuple = puzzle_to_tuple(bessie_puzzle)\n    elsie_tuple = puzzle_to_tuple(elsie_puzzle)\n    \n    if bfs(bessie_tuple, elsie_tuple):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def convert_to_decimal(n, k):\n    k = str(k)\n    length = len(k)\n    decimal_value = 0\n    for i in range(length):\n        decimal_value += int(k[i]) * (n ** (length - i - 1))\n    return decimal_value\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    k = input().strip()\n    result = convert_to_decimal(n, k)\n    print(result)"}
{"solution": "def is_unimodal(arr):\n    n = len(arr)\n    if n == 1:\n        return True\n    \n    i = 0\n    \n    # Check for strictly increasing part\n    while i < n - 1 and arr[i] < arr[i + 1]:\n        i += 1\n    \n    # Check for constant part\n    while i < n - 1 and arr[i] == arr[i + 1]:\n        i += 1\n    \n    # Check for strictly decreasing part\n    while i < n - 1 and arr[i] > arr[i + 1]:\n        i += 1\n    \n    # If we have traversed the entire array, it is unimodal\n    return i == n - 1\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Check if the array is unimodal\nif is_unimodal(arr):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def max_value_in_k_paths(n, k):\n    def count_occurrences(y):\n        count = 0\n        for i in range(1, n + 1):\n            x = i\n            while x >= y:\n                if x == y:\n                    count += 1\n                    break\n                if x % 2 == 0:\n                    x //= 2\n                else:\n                    x -= 1\n        return count\n\n    left, right = 1, n\n    result = 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if count_occurrences(mid) >= k:\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the result\nprint(max_value_in_k_paths(n, k))"}
{"solution": "def find_pocket(n, m, x, y, vx, vy):\n    if vx == 0:\n        if vy == 1:\n            if y == m:\n                return -1\n            else:\n                return (x, m)\n        elif vy == -1:\n            if y == 0:\n                return -1\n            else:\n                return (x, 0)\n    elif vy == 0:\n        if vx == 1:\n            if x == n:\n                return -1\n            else:\n                return (n, y)\n        elif vx == -1:\n            if x == 0:\n                return -1\n            else:\n                return (0, y)\n    else:\n        if vx == 1 and vy == 1:\n            t1 = (n - x) // vx\n            t2 = (m - y) // vy\n        elif vx == 1 and vy == -1:\n            t1 = (n - x) // vx\n            t2 = y // -vy\n        elif vx == -1 and vy == 1:\n            t1 = x // -vx\n            t2 = (m - y) // vy\n        else:\n            t1 = x // -vx\n            t2 = y // -vy\n\n        t = min(t1, t2)\n        x += t * vx\n        y += t * vy\n\n        if x == n and y == m:\n            return (n, m)\n        elif x == n and y == 0:\n            return (n, 0)\n        elif x == 0 and y == m:\n            return (0, m)\n        elif x == 0 and y == 0:\n            return (0, 0)\n        else:\n            return -1\n\nn, m, x, y, vx, vy = map(int, input().split())\nresult = find_pocket(n, m, x, y, vx, vy)\nif result == -1:\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    # Check all possible orientations of the paintings\n    orientations = [\n        (a2, b2, a3, b3),\n        (a2, b2, b3, a3),\n        (b2, a2, a3, b3),\n        (b2, a2, b3, a3)\n    ]\n    \n    for (w2, h2, w3, h3) in orientations:\n        if (w2 + w3 <= a1 and max(h2, h3) <= b1) or (max(w2, w3) <= a1 and h2 + h3 <= b1):\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\n# Print the result\nprint(can_place_paintings(a1, b1, a2, b2, a3, b3))"}
{"solution": "def count_written_terms(b1, q, l, m, bad_integers):\n    bad_set = set(bad_integers)\n    count = 0\n    current_term = b1\n\n    if abs(current_term) > l:\n        return 0\n\n    if q == 0:\n        if current_term in bad_set:\n            return 0\n        else:\n            return 1 if 0 in bad_set else \"inf\"\n\n    if q == 1:\n        if current_term in bad_set:\n            return 0\n        else:\n            return \"inf\"\n\n    if q == -1:\n        if current_term in bad_set and -current_term in bad_set:\n            return 0\n        else:\n            return \"inf\"\n\n    while abs(current_term) <= l:\n        if current_term not in bad_set:\n            count += 1\n        current_term *= q\n\n    return count\n\n# Read input\nb1, q, l, m = map(int, input().split())\nbad_integers = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = count_written_terms(b1, q, l, m, bad_integers)\nprint(result)"}
{"solution": "def find_frame(n, m, screen):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n\n    # Find the bounding box of the white pixels\n    for i in range(n):\n        for j in range(m):\n            if screen[i][j] == 'w':\n                if i < min_row:\n                    min_row = i\n                if i > max_row:\n                    max_row = i\n                if j < min_col:\n                    min_col = j\n                if j > max_col:\n                    max_col = j\n\n    # Calculate the size of the frame\n    frame_size = max(max_row - min_row + 1, max_col - min_col + 1)\n\n    # Check if the frame fits within the screen\n    if min_row + frame_size > n or min_col + frame_size > m:\n        return -1\n\n    # Create a copy of the screen to modify\n    result = [list(row) for row in screen]\n\n    # Draw the frame\n    for i in range(frame_size):\n        for j in range(frame_size):\n            if i == 0 or i == frame_size - 1 or j == 0 or j == frame_size - 1:\n                if result[min_row + i][min_col + j] == '.':\n                    result[min_row + i][min_col + j] = '+'\n\n    return result\n\n# Read input\nn, m = map(int, input().split())\nscreen = [input().strip() for _ in range(n)]\n\n# Find the frame\nresult = find_frame(n, m, screen)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(''.join(row))"}
{"solution": "def find_combination(n, a, b):\n    for x in range(n // a + 1):\n        if (n - x * a) % b == 0:\n            y = (n - x * a) // b\n            print(\"YES\")\n            print(x, y)\n            return\n    print(\"NO\")\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\n\n# Find and print the combination\nfind_combination(n, a, b)"}
{"solution": "def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\ns = int(input())\nprint(number_to_words(s))"}
{"solution": "def max_erase_length(n, arr):\n    max_erase = 0\n    for i in range(n):\n        for j in range(i, n):\n            if i == 0 or j == n - 1 or arr[j + 1] - arr[i - 1] > j - i + 1:\n                max_erase = max(max_erase, j - i + 1)\n    return max_erase\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_erase_length(n, arr))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ntotal_problems = sum(a)\nhalf_problems = (total_problems + 1) // 2\n\ncurrent_sum = 0\nfor i in range(n):\n    current_sum += a[i]\n    if current_sum >= half_problems:\n        print(i + 1)\n        break"}
{"solution": "from collections import deque\n\ndef get_moves(piece, x, y, N):\n    moves = []\n    if piece == 'knight':\n        knight_moves = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)]\n        for dx, dy in knight_moves:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                moves.append((nx, ny))\n    elif piece == 'bishop':\n        for d in range(1, N):\n            for dx, dy in [(-d, -d), (-d, d), (d, -d), (d, d)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < N and 0 <= ny < N:\n                    moves.append((nx, ny))\n    elif piece == 'rook':\n        for i in range(N):\n            if i != x:\n                moves.append((i, y))\n            if i != y:\n                moves.append((x, i))\n    return moves\n\ndef bfs(start, end, N, board):\n    queue = deque([(start[0], start[1], 0, 'knight', 0), (start[0], start[1], 0, 'bishop', 0), (start[0], start[1], 0, 'rook', 0)])\n    visited = set()\n    visited.add((start[0], start[1], 'knight'))\n    visited.add((start[0], start[1], 'bishop'))\n    visited.add((start[0], start[1], 'rook'))\n    \n    while queue:\n        x, y, steps, piece, changes = queue.popleft()\n        if (x, y) == end:\n            return steps, changes\n        \n        for next_piece in ['knight', 'bishop', 'rook']:\n            if next_piece != piece:\n                if (x, y, next_piece) not in visited:\n                    visited.add((x, y, next_piece))\n                    queue.append((x, y, steps + 1, next_piece, changes + 1))\n        \n        for nx, ny in get_moves(piece, x, y, N):\n            if (nx, ny, piece) not in visited:\n                visited.add((nx, ny, piece))\n                queue.append((nx, ny, steps + 1, piece, changes))\n    \n    return float('inf'), float('inf')\n\ndef solve_chess_puzzle(N, board):\n    positions = {}\n    for i in range(N):\n        for j in range(N):\n            positions[board[i][j]] = (i, j)\n    \n    total_steps = 0\n    total_changes = 0\n    \n    for num in range(1, N * N):\n        start = positions[num]\n        end = positions[num + 1]\n        steps, changes = bfs(start, end, N, board)\n        total_steps += steps\n        total_changes += changes\n    \n    print(total_steps, total_changes)\n\n# Input reading\nN = int(input())\nboard = [list(map(int, input().split())) for _ in range(N)]\n\nsolve_chess_puzzle(N, board)"}
{"solution": "def min_time_to_reach(n, m, k, a, b):\n    def get_entrance_and_floor(apartment):\n        entrance = (apartment - 1) // (m * k) + 1\n        floor = ((apartment - 1) % (m * k)) // k + 1\n        return entrance, floor\n\n    a_entrance, a_floor = get_entrance_and_floor(a)\n    b_entrance, b_floor = get_entrance_and_floor(b)\n\n    if a_entrance == b_entrance:\n        return abs(a_floor - b_floor) * 5\n\n    time_to_exit_a = 10 + (a_floor - 1)\n    time_to_enter_b = abs(b_floor - 1) * 5\n\n    clockwise_distance = (b_entrance - a_entrance) % n\n    counterclockwise_distance = (a_entrance - b_entrance) % n\n\n    min_distance = min(clockwise_distance, counterclockwise_distance) * 15\n\n    return time_to_exit_a + min_distance + time_to_enter_b\n\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\nprint(min_time_to_reach(n, m, k, a, b))"}
{"solution": "def is_divisible_by_64(s):\n    # We need at least one '1' followed by at least six '0's\n    if '1' in s:\n        index_of_first_one = s.index('1')\n        if s[index_of_first_one:].count('0') >= 6:\n            return \"yes\"\n    return \"no\"\n\n# Read input\ns = input().strip()\n\n# Print the result\nprint(is_divisible_by_64(s))"}
{"solution": "def get_alphabet_subsequence(s):\n    target = \"abcdefghijklmnopqrstuvwxyz\"\n    target_index = 0\n    s = list(s)\n    \n    for i in range(len(s)):\n        if target_index < len(target) and s[i] <= target[target_index]:\n            s[i] = target[target_index]\n            target_index += 1\n        if target_index == len(target):\n            return \"\".join(s)\n    \n    return \"-1\"\n\n# Read input\ns = input().strip()\n# Print the result\nprint(get_alphabet_subsequence(s))"}
{"solution": "def max_expected_fishes(n, m, r, k):\n    def count_positions(x, y):\n        return (min(x, n - r + 1) - max(1, x - r + 1) + 1) * (min(y, m - r + 1) - max(1, y - r + 1) + 1)\n\n    total_positions = (n - r + 1) * (m - r + 1)\n    fish_positions = []\n\n    for x in range(1, n + 1):\n        for y in range(1, m + 1):\n            fish_positions.append((count_positions(x, y), x, y))\n\n    fish_positions.sort(reverse=True, key=lambda pos: pos[0])\n\n    max_fishes = 0\n    for i in range(k):\n        max_fishes += fish_positions[i][0]\n\n    return max_fishes / total_positions\n\n# Read input\nn, m, r, k = map(int, input().split())\n\n# Calculate and print the result\nresult = max_expected_fishes(n, m, r, k)\nprint(f\"{result:.10f}\")"}
{"solution": "def maximize_product(n, a):\n    # Apply the operation to all non-negative numbers\n    for i in range(n):\n        if a[i] >= 0:\n            a[i] = -a[i] - 1\n    \n    # If the number of elements is odd, we need to flip one element back\n    if n % 2 != 0:\n        # Find the smallest (most negative) element\n        min_index = a.index(min(a))\n        a[min_index] = -a[min_index] - 1\n    \n    return a\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = maximize_product(n, a)\n\n# Print the result\nprint(\" \".join(map(str, result)))"}
{"solution": "def kth_smallest_divisor(n, k):\n    divisors = []\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.sort()\n    \n    if k > len(divisors):\n        return -1\n    else:\n        return divisors[k-1]\n\n# Read input\nn, k = map(int, input().split())\n\n# Find and print the k-th smallest divisor\nprint(kth_smallest_divisor(n, k))"}
{"solution": "def can_form_number(cubes, number):\n    str_num = str(number)\n    for digit in str_num:\n        found = False\n        for cube in cubes:\n            if digit in cube:\n                found = True\n                break\n        if not found:\n            return False\n    return True\n\ndef max_number(cubes):\n    x = 1\n    while True:\n        if not can_form_number(cubes, x):\n            return x - 1\n        x += 1\n\nn = int(input())\ncubes = [input().split() for _ in range(n)]\n\nprint(max_number(cubes))"}
{"solution": "def k_rounding(n, k):\n    multiplier = 10 ** k\n    x = (n + multiplier - 1) // multiplier * multiplier\n    print(x)\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    n = int(data[0])\n    k = int(data[1])\n    k_rounding(n, k)"}
{"solution": "def solve(n, m, A):\n    operations = []\n    B = [[0] * m for _ in range(n)]\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                operations.append((i + 1, j + 1))\n                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1\n\n    if B == A:\n        print(len(operations))\n        for op in operations:\n            print(op[0], op[1])\n    else:\n        print(-1)\n\n# Read input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve the problem\nsolve(n, m, A)"}
{"solution": "def bad_luck_island(r, s, p):\n    dp = [[[0.0 for _ in range(p + 1)] for _ in range(s + 1)] for _ in range(r + 1)]\n    \n    for i in range(r + 1):\n        for j in range(s + 1):\n            for k in range(p + 1):\n                if i == 0 and j == 0 and k == 0:\n                    continue\n                if i == 0 and j == 0:\n                    dp[i][j][k] = 1.0\n                elif i == 0 and k == 0:\n                    dp[i][j][k] = 1.0\n                elif j == 0 and k == 0:\n                    dp[i][j][k] = 1.0\n                else:\n                    total_pairs = i * j + j * k + k * i\n                    if total_pairs == 0:\n                        continue\n                    if i > 0 and j > 0:\n                        dp[i][j][k] += dp[i][j - 1][k] * (i * j / total_pairs)\n                    if j > 0 and k > 0:\n                        dp[i][j][k] += dp[i][j][k - 1] * (j * k / total_pairs)\n                    if k > 0 and i > 0:\n                        dp[i][j][k] += dp[i - 1][j][k] * (k * i / total_pairs)\n    \n    rock_prob = sum(dp[i][0][0] for i in range(1, r + 1))\n    scissors_prob = sum(dp[0][j][0] for j in range(1, s + 1))\n    paper_prob = sum(dp[0][0][k] for k in range(1, p + 1))\n    \n    return rock_prob, scissors_prob, paper_prob\n\nr, s, p = map(int, input().split())\nrock_prob, scissors_prob, paper_prob = bad_luck_island(r, s, p)\nprint(f\"{rock_prob:.12f} {scissors_prob:.12f} {paper_prob:.12f}\")"}
{"solution": "# Read input values\nl_1, r_1, l_2, r_2, k = map(int, input().split())\n\n# Calculate the overlapping interval\nstart = max(l_1, l_2)\nend = min(r_1, r_2)\n\n# Calculate the number of minutes they can spend together\nif start > end:\n    print(0)\nelse:\n    overlap = end - start + 1\n    if start <= k <= end:\n        overlap -= 1\n    print(overlap)"}
{"solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    north_south_lines = []\n    east_west_lines = []\n    \n    index = 2\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        C = int(data[index + 2])\n        north_south_lines.append((A, B, C))\n        index += 3\n    \n    for _ in range(M):\n        D = int(data[index])\n        E = int(data[index + 1])\n        F = int(data[index + 2])\n        east_west_lines.append((D, E, F))\n        index += 3\n    \n    min_x = -float('inf')\n    max_x = float('inf')\n    min_y = -float('inf')\n    max_y = float('inf')\n    \n    for A, B, C in north_south_lines:\n        if C == 0:\n            min_x = max(min_x, B)\n        elif C == 1:\n            max_x = min(max_x, A)\n    \n    for D, E, F in east_west_lines:\n        if D == 0:\n            min_y = max(min_y, F)\n        elif D == 1:\n            max_y = min(max_y, E)\n    \n    if min_x >= max_x or min_y >= max_y:\n        print(\"INF\")\n    else:\n        area = (max_x - min_x) * (max_y - min_y)\n        print(area)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "t, s, x = map(int, input().split())\n\nif x == t:\n    print(\"YES\")\nelif x > t and ((x - t) % s == 0 or (x - t - 1) % s == 0 and x != t + 1):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def find_segments(n, segments):\n    indexed_segments = [(segments[i][0], segments[i][1], i + 1) for i in range(n)]\n    indexed_segments.sort()\n\n    min_right = float('inf')\n    min_right_index = -1\n\n    for l, r, idx in indexed_segments:\n        if r <= min_right:\n            min_right = r\n            min_right_index = idx\n\n    for l, r, idx in indexed_segments:\n        if idx != min_right_index and l >= indexed_segments[min_right_index - 1][0] and r <= indexed_segments[min_right_index - 1][1]:\n            return idx, min_right_index\n\n    return -1, -1\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    segments = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(n)]\n    \n    i, j = find_segments(n, segments)\n    print(i, j)"}
{"solution": "def decode_genome(n, s):\n    if n % 4 != 0:\n        return \"===\"\n\n    count = {'A': 0, 'C': 0, 'G': 0, 'T': 0, '?': 0}\n    for char in s:\n        count[char] += 1\n\n    required_each = n // 4\n    for nucleotide in 'ACGT':\n        if count[nucleotide] > required_each:\n            return \"===\"\n\n    for nucleotide in 'ACGT':\n        count['?'] -= (required_each - count[nucleotide])\n        count[nucleotide] = required_each\n\n    if count['?'] != 0:\n        return \"===\"\n\n    result = []\n    for char in s:\n        if char == '?':\n            for nucleotide in 'ACGT':\n                if count[nucleotide] > 0:\n                    result.append(nucleotide)\n                    count[nucleotide] -= 1\n                    break\n        else:\n            result.append(char)\n\n    return ''.join(result)\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Decode genome and print result\nprint(decode_genome(n, s))"}
{"solution": "def check_win(board, x, y):\n    # Check horizontal\n    if y <= 1 and board[x][y] == 'x' and board[x][y+1] == 'x' and board[x][y+2] == 'x':\n        return True\n    if y >= 1 and y <= 2 and board[x][y-1] == 'x' and board[x][y] == 'x' and board[x][y+1] == 'x':\n        return True\n    if y >= 2 and board[x][y-2] == 'x' and board[x][y-1] == 'x' and board[x][y] == 'x':\n        return True\n\n    # Check vertical\n    if x <= 1 and board[x][y] == 'x' and board[x+1][y] == 'x' and board[x+2][y] == 'x':\n        return True\n    if x >= 1 and x <= 2 and board[x-1][y] == 'x' and board[x][y] == 'x' and board[x+1][y] == 'x':\n        return True\n    if x >= 2 and board[x-2][y] == 'x' and board[x-1][y] == 'x' and board[x][y] == 'x':\n        return True\n\n    # Check diagonal\n    if x <= 1 and y <= 1 and board[x][y] == 'x' and board[x+1][y+1] == 'x' and board[x+2][y+2] == 'x':\n        return True\n    if x >= 1 and x <= 2 and y >= 1 and y <= 2 and board[x-1][y-1] == 'x' and board[x][y] == 'x' and board[x+1][y+1] == 'x':\n        return True\n    if x >= 2 and y >= 2 and board[x-2][y-2] == 'x' and board[x-1][y-1] == 'x' and board[x][y] == 'x':\n        return True\n\n    if x <= 1 and y >= 2 and board[x][y] == 'x' and board[x+1][y-1] == 'x' and board[x+2][y-2] == 'x':\n        return True\n    if x >= 1 and x <= 2 and y >= 1 and y <= 2 and board[x-1][y+1] == 'x' and board[x][y] == 'x' and board[x+1][y-1] == 'x':\n        return True\n    if x >= 2 and y <= 1 and board[x-2][y+2] == 'x' and board[x-1][y+1] == 'x' and board[x][y] == 'x':\n        return True\n\n    return False\n\ndef can_win(board):\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                board[i][j] = 'x'\n                if check_win(board, i, j):\n                    return True\n                board[i][j] = '.'\n    return False\n\nboard = [input().strip() for _ in range(4)]\nboard = [list(row) for row in board]\n\nif can_win(board):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def can_divide_array(n, a):\n    total_sum = sum(a)\n    \n    # If the total sum is odd, it's impossible to split into two equal parts\n    if total_sum % 2 != 0:\n        return \"NO\"\n    \n    target_sum = total_sum // 2\n    \n    # Check if we can find a prefix with sum equal to target_sum\n    prefix_sum = 0\n    prefix_sums = set()\n    for num in a:\n        prefix_sum += num\n        prefix_sums.add(prefix_sum)\n    \n    # Check if we can find a suffix with sum equal to target_sum\n    suffix_sum = 0\n    suffix_sums = set()\n    for num in reversed(a):\n        suffix_sum += num\n        suffix_sums.add(suffix_sum)\n    \n    # Check if there is a prefix or suffix that matches the target_sum\n    if target_sum in prefix_sums or target_sum in suffix_sums:\n        return \"YES\"\n    \n    # Check if moving one element can make the division possible\n    for i in range(n):\n        current_sum = total_sum - a[i]\n        if current_sum % 2 == 0:\n            half_sum = current_sum // 2\n            if half_sum in prefix_sums or half_sum in suffix_sums:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print output\nprint(can_divide_array(n, a))"}
{"solution": "def can_be_non_increasing(n, k, a, b):\n    b.sort(reverse=True)\n    j = 0\n    for i in range(n):\n        if a[i] == 0:\n            a[i] = b[j]\n            j += 1\n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            return \"Yes\"\n    return \"No\"\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Output result\nprint(can_be_non_increasing(n, k, a, b))"}
{"solution": "def can_distribute_grapes(x, y, z, a, b, c):\n    # Andrew takes x green grapes\n    if a < x:\n        return \"NO\"\n    a -= x\n    \n    # Dmitry takes y grapes from remaining green and purple grapes\n    if a + b < y:\n        return \"NO\"\n    remaining = a + b - y\n    \n    # Michal takes z grapes from remaining grapes\n    if remaining + c < z:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Print the result\nprint(can_distribute_grapes(x, y, z, a, b, c))"}
{"solution": "def is_accident_possible(lights):\n    for i in range(4):\n        l, s, r, p = lights[i]\n        if p == 1:\n            if l == 1 or s == 1 or r == 1:\n                return \"YES\"\n            if lights[(i + 1) % 4][0] == 1 or lights[(i + 2) % 4][1] == 1 or lights[(i + 3) % 4][2] == 1:\n                return \"YES\"\n    return \"NO\"\n\nlights = [list(map(int, input().split())) for _ in range(4)]\nprint(is_accident_possible(lights))"}
{"solution": "def get_vector(a, b):\n    keypad = {\n        '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2),\n        '0': (3, 1)\n    }\n    return (keypad[b][0] - keypad[a][0], keypad[b][1] - keypad[a][1])\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    number = data[1]\n    \n    if n == 1:\n        print(\"YES\")\n        return\n    \n    movements = []\n    for i in range(n - 1):\n        movements.append(get_vector(number[i], number[i + 1]))\n    \n    unique_movements = set(movements)\n    \n    if len(unique_movements) == len(movements):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_sold_products(n, f, days):\n    # Calculate the initial sales without any sell-out days\n    initial_sales = [min(k, l) for k, l in days]\n    \n    # Calculate the potential additional sales if a sell-out day is chosen\n    additional_sales = [min(2 * k, l) - min(k, l) for k, l in days]\n    \n    # Sort the additional sales in descending order to maximize the benefit\n    additional_sales.sort(reverse=True)\n    \n    # Sum the initial sales and the top f additional sales\n    max_sales = sum(initial_sales) + sum(additional_sales[:f])\n    \n    return max_sales\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nf = int(data[1])\ndays = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(n)]\n\n# Calculate and print the result\nprint(max_sold_products(n, f, days))"}
{"solution": "def max_messiness(n, k):\n    # The maximum number of inversions in an array of size n is n * (n - 1) / 2\n    max_inversions = n * (n - 1) // 2\n    \n    # If k is large enough to reverse the entire array, we can achieve the maximum number of inversions\n    if k >= n // 2:\n        return max_inversions\n    \n    # Otherwise, we can achieve at most k * (2 * n - 2 * k - 1) inversions\n    return k * (2 * n - 2 * k - 1)\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(max_messiness(n, k))"}
{"solution": "def min_coins_per_friend(N, M, K, L):\n    # Check if it's possible to have M friends gift different coins\n    if M > N:\n        return -1\n    \n    # Calculate the minimum number of coins each friend must gift\n    min_total_gifts = L + K\n    if min_total_gifts > N:\n        return -1\n    \n    min_coins_per_friend = (min_total_gifts + M - 1) // M\n    \n    if min_coins_per_friend * M > N:\n        return -1\n    \n    return min_coins_per_friend\n\n# Read input\nN, M, K, L = map(int, input().split())\n\n# Print the result\nprint(min_coins_per_friend(N, M, K, L))"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    black_cells = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 'B']\n    \n    if not black_cells:\n        return 1\n    \n    min_row = min(black_cells, key=lambda x: x[0])[0]\n    max_row = max(black_cells, key=lambda x: x[0])[0]\n    min_col = min(black_cells, key=lambda x: x[1])[1]\n    max_col = max(black_cells, key=lambda x: x[1])[1]\n    \n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    \n    if side_length > n or side_length > m:\n        return -1\n    \n    min_paint = float('inf')\n    \n    for i in range(n - side_length + 1):\n        for j in range(m - side_length + 1):\n            paint_count = 0\n            for x in range(i, i + side_length):\n                for y in range(j, j + side_length):\n                    if grid[x][y] == 'W':\n                        paint_count += 1\n            min_paint = min(min_paint, paint_count)\n    \n    return min_paint\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Get the result\nresult = min_cells_to_paint(n, m, grid)\n\n# Print the result\nprint(result)"}
{"solution": "def can_be_consistent(n, x, y):\n    if sum(x) < sum(y):\n        return \"No\"\n    return \"Yes\"\n\n# Read input\nn = int(input().strip())\nx = list(map(int, input().strip().split()))\ny = list(map(int, input().strip().split()))\n\n# Check if the records can be consistent\nresult = can_be_consistent(n, x, y)\nprint(result)"}
{"solution": "def minimal_difference(n, angles):\n    total_sum = sum(angles)\n    min_diff = float('inf')\n    \n    for i in range(1 << n):\n        subset_sum = 0\n        for j in range(n):\n            if i & (1 << j):\n                subset_sum += angles[j]\n        other_sum = total_sum - subset_sum\n        min_diff = min(min_diff, abs(subset_sum - other_sum))\n    \n    return min_diff\n\n# Read input\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Calculate and print the minimal difference\nprint(minimal_difference(n, angles))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, m):\n    return (pow(2, m, MOD) - 1) ** n % MOD\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(count_ways(n, m))"}
{"solution": "def find_pythagorean_triple(n):\n    if n == 1:\n        return -1\n    if n % 2 == 0:\n        m = (n // 2) ** 2 - 1\n        k = (n // 2) ** 2 + 1\n    else:\n        m = (n ** 2 - 1) // 2\n        k = (n ** 2 + 1) // 2\n    return m, k\n\nn = int(input())\nresult = find_pythagorean_triple(n)\nif result == -1:\n    print(-1)\nelse:\n    print(result[0], result[1])"}
{"solution": "def are_remainders_distinct(n, k):\n    remainders = set()\n    for i in range(1, k + 1):\n        remainder = n % i\n        if remainder in remainders:\n            return \"No\"\n        remainders.add(remainder)\n    return \"Yes\"\n\n# Read input\nn, k = map(int, input().strip().split())\n\n# Print the result\nprint(are_remainders_distinct(n, k))"}
{"solution": "import sys\ninput = sys.stdin.read\n\ndef compare_large_numbers():\n    data = input().split()\n    a = data[0].lstrip('0') or '0'\n    b = data[1].lstrip('0') or '0'\n    \n    if len(a) < len(b):\n        print(\"<\")\n    elif len(a) > len(b):\n        print(\">\")\n    else:\n        if a < b:\n            print(\"<\")\n        elif a > b:\n            print(\">\")\n        else:\n            print(\"=\")\n\ncompare_large_numbers()"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, p, colors):\n    # Count the number of uncolored pieces\n    uncolored_count = colors.count(-1)\n    \n    # If there are no uncolored pieces, we need to check the parity directly\n    if uncolored_count == 0:\n        score = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if colors[i] != colors[j]:\n                    score += 1\n        return 1 if score % 2 == p else 0\n    \n    # If there are uncolored pieces, we need to consider all possible colorings\n    total_ways = 0\n    for mask in range(1 << uncolored_count):\n        new_colors = colors[:]\n        idx = 0\n        for i in range(n):\n            if new_colors[i] == -1:\n                new_colors[i] = (mask >> idx) & 1\n                idx += 1\n        \n        score = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if new_colors[i] != new_colors[j]:\n                    score += 1\n        \n        if score % 2 == p:\n            total_ways += 1\n    \n    return total_ways % MOD\n\n# Read input\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_ways(n, p, colors))"}
{"solution": "def min_rubles_to_buy_copybooks(n, a, b, c):\n    remainder = n % 4\n    if remainder == 0:\n        return 0\n    elif remainder == 1:\n        return min(3 * a, a + b, c)\n    elif remainder == 2:\n        return min(2 * a, b, 2 * c)\n    elif remainder == 3:\n        return min(a, b + c, 3 * c)\n\n# Read input\nn, a, b, c = map(int, input().split())\n\n# Calculate and print the result\nprint(min_rubles_to_buy_copybooks(n, a, b, c))"}
{"solution": "def is_cyclic(graph, n):\n    visited = [False] * n\n    rec_stack = [False] * n\n\n    def cycle_util(v):\n        visited[v] = True\n        rec_stack[v] = True\n\n        for neighbor in graph[v]:\n            if not visited[neighbor]:\n                if cycle_util(neighbor):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[v] = False\n        return False\n\n    for node in range(n):\n        if not visited[node]:\n            if cycle_util(node):\n                return True\n    return False\n\ndef can_be_acyclic(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u-1].append(v-1)\n\n    if not is_cyclic(graph, n):\n        return \"YES\"\n\n    for u, v in edges:\n        graph[u-1].remove(v-1)\n        if not is_cyclic(graph, n):\n            return \"YES\"\n        graph[u-1].append(v-1)\n\n    return \"NO\"\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n\n    print(can_be_acyclic(n, m, edges))"}
{"solution": "def min_coins_to_cover_street(n, m, antennas):\n    # Initialize the dp array with infinity\n    dp = [float('inf')] * (m + 1)\n    dp[0] = 0  # No cost to cover position 0\n\n    # Sort antennas by their position\n    antennas.sort()\n\n    for i in range(1, m + 1):\n        for x, s in antennas:\n            if x + s >= i:\n                left = max(1, x - s)\n                dp[i] = min(dp[i], dp[left - 1] + max(0, i - (x + s)))\n\n    return dp[m]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nantennas = []\n\nfor i in range(n):\n    x = int(data[2 + 2 * i])\n    s = int(data[3 + 2 * i])\n    antennas.append((x, s))\n\n# Calculate and print the result\nprint(min_coins_to_cover_street(n, m, antennas))"}
{"solution": "def max_good_subset_weight(W, cnt):\n    max_weight = 0\n    for i in range(256):\n        current_weight = 0\n        for j in range(8):\n            if i & (1 << j):\n                current_weight += (j + 1) * min(cnt[j], (W - current_weight) // (j + 1))\n        max_weight = max(max_weight, current_weight)\n    return max_weight\n\n# Read input\nW = int(input().strip())\ncnt = list(map(int, input().strip().split()))\n\n# Calculate and print the result\nprint(max_good_subset_weight(W, cnt))"}
{"solution": "def min_cost(n, L, costs):\n    # Initialize the minimum cost array\n    min_costs = [float('inf')] * n\n    min_costs[0] = costs[0]\n\n    # Calculate the minimum cost for each type of bottle\n    for i in range(1, n):\n        min_costs[i] = min(costs[i], 2 * min_costs[i - 1])\n\n    total_cost = 0\n    remaining_liters = L\n\n    # Traverse from the largest bottle to the smallest\n    for i in range(n - 1, -1, -1):\n        bottle_volume = (1 << i) - 1\n        if remaining_liters > bottle_volume:\n            num_bottles = remaining_liters // (1 << i)\n            total_cost += num_bottles * min_costs[i]\n            remaining_liters -= num_bottles * (1 << i)\n\n    # Check if we need to buy an additional bottle for the remaining liters\n    for i in range(n):\n        if remaining_liters > 0:\n            total_cost = min(total_cost, min_costs[i] + total_cost - min_costs[i] * (remaining_liters > 0))\n            remaining_liters = 0\n\n    return total_cost\n\n# Read input\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Calculate and print the minimum cost\nprint(min_cost(n, L, costs))"}
{"solution": "def max_mex(n, arr):\n    arr.sort()\n    mex = 1\n    for num in arr:\n        if num >= mex:\n            mex += 1\n    return mex\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_mex(n, arr))"}
{"solution": "def is_lucky_ticket(n, ticket):\n    for length in range(1, n):\n        target_sum = sum(int(ticket[i]) for i in range(length))\n        current_sum = 0\n        count = 0\n        for digit in ticket:\n            current_sum += int(digit)\n            if current_sum == target_sum:\n                current_sum = 0\n                count += 1\n        if current_sum == 0 and count > 1:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\nticket = input().strip()\n\n# Check if the ticket is lucky\nresult = is_lucky_ticket(n, ticket)\nprint(result)"}
{"solution": "# Read the input username\nusername = input().strip()\n\n# Determine the number of distinct characters in the username\ndistinct_characters = set(username)\n\n# Check if the number of distinct characters is odd or even\nif len(distinct_characters) % 2 == 0:\n    print(\"CHAT WITH HER!\")\nelse:\n    print(\"IGNORE HIM!\")"}
{"solution": "def max_abs_difference(n, k, tabs):\n    max_diff = 0\n    for b in range(1, k + 1):\n        remaining_tabs = [tabs[i] for i in range(n) if (i + 1 - b) % k != 0]\n        e = remaining_tabs.count(1)\n        s = remaining_tabs.count(-1)\n        max_diff = max(max_diff, abs(e - s))\n    return max_diff\n\n# Read input\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_abs_difference(n, k, tabs))"}
{"solution": "def min_cost(n, c0, c1):\n    # Calculate the length of the binary representation needed\n    length = n.bit_length()\n    \n    # Calculate the number of bits needed\n    num_bits = length * n\n    \n    # Calculate the minimum cost\n    min_cost = min(c0, c1) * num_bits + abs(c0 - c1) * (num_bits // 2)\n    \n    return min_cost\n\n# Read input\nn, c0, c1 = map(int, input().split())\n\n# Calculate and print the minimum possible total cost\nprint(min_cost(n, c0, c1))"}
{"solution": "def will_meet(n, a, x, b, y):\n    while a != x and b != y:\n        if a == b:\n            return \"YES\"\n        a = a + 1 if a < n else 1\n        b = b - 1 if b > 1 else n\n    return \"YES\" if a == b else \"NO\"\n\n# Read input\nn, a, x, b, y = map(int, input().split())\n\n# Print output\nprint(will_meet(n, a, x, b, y))"}
{"solution": "def find_unlucky_years(x, y, l, r):\n    unlucky_years = set()\n    a = 0\n    while x ** a <= r:\n        b = 0\n        while x ** a + y ** b <= r:\n            year = x ** a + y ** b\n            if l <= year <= r:\n                unlucky_years.add(year)\n            b += 1\n            if y ** b > r:\n                break\n        a += 1\n        if x ** a > r:\n            break\n    return unlucky_years\n\ndef max_golden_age_length(x, y, l, r):\n    unlucky_years = find_unlucky_years(x, y, l, r)\n    unlucky_years = sorted(unlucky_years)\n    \n    if not unlucky_years:\n        return r - l + 1\n    \n    max_length = 0\n    prev = l - 1\n    \n    for year in unlucky_years:\n        if year > r:\n            break\n        if year > prev + 1:\n            max_length = max(max_length, year - prev - 1)\n        prev = year\n    \n    if prev < r:\n        max_length = max(max_length, r - prev)\n    \n    return max_length\n\nif __name__ == \"__main__\":\n    x, y, l, r = map(int, input().split())\n    print(max_golden_age_length(x, y, l, r))"}
{"solution": "def min_tax(n):\n    if n % 2 == 0:\n        return n // 2\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return n // i\n    return 1\n\nn = int(input())\nprint(min_tax(n))"}
{"solution": "def is_vowel(c):\n    return c in 'aeiou'\n\ndef has_typo(word):\n    n = len(word)\n    i = 0\n    result = []\n    while i < n:\n        if i + 2 < n and not is_vowel(word[i]) and not is_vowel(word[i+1]) and not is_vowel(word[i+2]):\n            if word[i] != word[i+1] or word[i+1] != word[i+2]:\n                result.append(word[:i+2])\n                word = word[i+2:]\n                n = len(word)\n                i = -1\n        i += 1\n    result.append(word)\n    return ' '.join(result)\n\nword = input().strip()\nprint(has_typo(word))"}
{"solution": "def min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d):\n    min_time = n * x\n\n    for i in range(m):\n        if b[i] <= s:\n            min_time = min(min_time, n * a[i])\n\n    for j in range(k):\n        if d[j] <= s:\n            potions_left = n - c[j]\n            if potions_left <= 0:\n                min_time = 0\n            else:\n                min_time = min(min_time, potions_left * x)\n\n    for i in range(m):\n        if b[i] <= s:\n            for j in range(k):\n                if b[i] + d[j] <= s:\n                    potions_left = n - c[j]\n                    if potions_left <= 0:\n                        min_time = 0\n                    else:\n                        min_time = min(min_time, potions_left * a[i])\n\n    return min_time\n\n# Read input\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d))"}
{"solution": "def max_points(n, k, M, t):\n    t.sort()\n    max_points = 0\n\n    for full_tasks in range(n + 1):\n        time_spent = full_tasks * sum(t)\n        if time_spent > M:\n            break\n\n        remaining_time = M - time_spent\n        points = full_tasks * (k + 1)\n\n        for i in range(n - full_tasks):\n            for j in range(k):\n                if remaining_time >= t[j]:\n                    remaining_time -= t[j]\n                    points += 1\n                else:\n                    break\n\n        max_points = max(max_points, points)\n\n    return max_points\n\n# Read input\nn, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_points(n, k, M, t))"}
{"solution": "MOD = 998244353\n\ndef count_balanced_striped_bsts(n):\n    if n % 2 == 1:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[2] = 1\n    \n    for i in range(4, n + 1, 2):\n        for j in range(2, i + 1, 2):\n            dp[i] = (dp[i] + dp[j - 2] * dp[i - j]) % MOD\n    \n    return dp[n]\n\nn = int(input().strip())\nprint(count_balanced_striped_bsts(n))"}
{"solution": "def find_position(n, m, k):\n    if k < n:\n        # Moving down the first column\n        print(k + 1, 1)\n    else:\n        k -= n\n        full_rows = k // (m - 1)\n        remaining_steps = k % (m - 1)\n        \n        if full_rows % 2 == 0:\n            # Moving right on an even full row\n            print(n - full_rows, 2 + remaining_steps)\n        else:\n            # Moving left on an odd full row\n            print(n - full_rows, m - remaining_steps)\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Find and print the position\nfind_position(n, m, k)"}
{"solution": "import math\n\ndef find_min_max_pair(X):\n    a, b = 1, X\n    for i in range(1, int(math.sqrt(X)) + 1):\n        if X % i == 0:\n            j = X // i\n            if max(i, j) < max(a, b):\n                a, b = i, j\n    return a, b\n\nX = int(input())\na, b = find_min_max_pair(X)\nprint(a, b)"}
{"solution": "a = int(input())\nb = int(input())\nc = int(input())\n\n# Find the maximum number of sets of fruits that can be used in the ratio 1:2:4\nmax_sets = min(a, b // 2, c // 4)\n\n# Calculate the total number of fruits used\ntotal_fruits = max_sets * 7\n\nprint(total_fruits)"}
{"solution": "n = int(input())\nratings = list(map(int, input().split()))\n\nratings.sort()\n\nteam1 = ratings[:n]\nteam2 = ratings[n:]\n\nif all(team1[i] < team2[i] for i in range(n)):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\ndef is_coprime(x, y):\n    return math.gcd(x, y) == 1\n\ndef make_coprime_array(n, arr):\n    result = []\n    k = 0\n    \n    for i in range(n - 1):\n        result.append(arr[i])\n        if not is_coprime(arr[i], arr[i + 1]):\n            result.append(1)\n            k += 1\n    \n    result.append(arr[-1])\n    \n    return k, result\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Process the array to make it co-prime\nk, result = make_coprime_array(n, arr)\n\n# Print the result\nprint(k)\nprint(\" \".join(map(str, result)))"}
{"solution": "import math\nfrom functools import reduce\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef gcd_list(lst):\n    return reduce(gcd, lst)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n    \n    total_sum = sum(A)\n    max_gcd = gcd_list(A)\n    \n    if K >= total_sum:\n        print(max_gcd)\n        return\n    \n    for i in range(1, int(math.sqrt(total_sum)) + 1):\n        if total_sum % i == 0:\n            if i <= K:\n                max_gcd = max(max_gcd, i)\n            if total_sum // i <= K:\n                max_gcd = max(max_gcd, total_sum // i)\n    \n    print(max_gcd)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def cat_furrier_transform(x):\n    operations = []\n    count = 0\n\n    while (x & (x + 1)) != 0:\n        if count % 2 == 0:\n            n = 0\n            while (1 << (n + 1)) - 1 <= x:\n                n += 1\n            operations.append(n)\n            x ^= (1 << n) - 1\n        else:\n            x += 1\n        count += 1\n\n    print(count)\n    for i in range(0, len(operations), 2):\n        print(operations[i], end=' ')\n    if operations:\n        print()\n\n# Read input\nx = int(input().strip())\ncat_furrier_transform(x)"}
{"solution": "# Read input values\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize the minimum hours to a large number\nmin_hours = float('inf')\n\n# Iterate through each bucket\nfor length in a:\n    # Check if the bucket can water the garden in an integer number of hours\n    if k % length == 0:\n        # Calculate the number of hours required\n        hours = k // length\n        # Update the minimum hours if the current bucket is better\n        if hours < min_hours:\n            min_hours = hours\n\n# Print the minimum number of hours required\nprint(min_hours)"}
{"solution": "def can_grasshopper_reach_insect(n, k, line):\n    g_pos = line.index('G')\n    t_pos = line.index('T')\n    \n    if g_pos > t_pos:\n        g_pos, t_pos = t_pos, g_pos\n    \n    for i in range(g_pos, t_pos + 1, k):\n        if line[i] == '#':\n            return \"NO\"\n    \n    if (t_pos - g_pos) % k == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\nline = input().strip()\n\n# Determine if the grasshopper can reach the insect\nresult = can_grasshopper_reach_insect(n, k, line)\nprint(result)"}
{"solution": "def find_aiming_point(y1, y2, yw, xb, yb, r):\n    # Check if the ball can be aimed to the wall and bounce into the goal\n    if yb + r >= yw or yb - r <= 0 or y1 + r >= y2 - r:\n        return -1\n\n    # Calculate the y-coordinate of the ball after bouncing off the wall\n    y_goal = (2 * yw - yb)\n\n    # Check if the ball can go into the goal after bouncing\n    if y_goal < y1 + r or y_goal > y2 - r:\n        return -1\n\n    # Calculate the x-coordinate of the aiming point on the wall\n    xw = xb * (yw - yb) / (yw - y_goal)\n\n    return xw\n\n# Read input\ny1, y2, yw, xb, yb, r = map(int, input().split())\n\n# Find the aiming point\nresult = find_aiming_point(y1, y2, yw, xb, yb, r)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    print(f\"{result:.10f}\")"}
{"solution": "def min_missed_meals(b, d, s):\n    max_meals = max(b, d, s)\n    missed_meals = max(0, (max_meals - 1) - b) + max(0, (max_meals - 1) - d) + max(0, (max_meals - 1) - s)\n    return missed_meals\n\n# Read input\nb, d, s = map(int, input().split())\n\n# Calculate and print the result\nprint(min_missed_meals(b, d, s))"}
{"solution": "def find_matrix_dimensions(n, path):\n    from math import gcd\n    from functools import reduce\n\n    def find_factors(num):\n        factors = set()\n        for i in range(1, int(num**0.5) + 1):\n            if num % i == 0:\n                factors.add(i)\n                factors.add(num // i)\n        return factors\n\n    def possible_dimensions(diffs):\n        common_gcd = reduce(gcd, diffs)\n        return find_factors(common_gcd)\n\n    diffs = [abs(path[i] - path[i - 1]) for i in range(1, n)]\n    possible_ys = possible_dimensions(diffs)\n\n    for y in possible_ys:\n        if y > 0 and y <= 10**9:\n            x = (max(path) + y - 1) // y\n            if x > 0 and x <= 10**9:\n                return \"YES\", x, y\n\n    return \"NO\",\n\n# Read input\nn = int(input().strip())\npath = list(map(int, input().strip().split()))\n\n# Find and print the result\nresult = find_matrix_dimensions(n, path)\nif result[0] == \"NO\":\n    print(result[0])\nelse:\n    print(result[0])\n    print(result[1], result[2])"}
{"solution": "def min_remove_to_subsequence(a, b):\n    n, m = len(a), len(b)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    lcs_length = dp[n][m]\n    if lcs_length == 0:\n        return \"-\"\n    \n    i, j = n, m\n    lcs = []\n    while i > 0 and j > 0:\n        if a[i - 1] == b[j - 1]:\n            lcs.append(a[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    \n    return ''.join(reversed(lcs))\n\na = input().strip()\nb = input().strip()\nprint(min_remove_to_subsequence(a, b))"}
{"solution": "n = int(input())\ns = input().strip()\n\nmin_stones = 0\ncurrent_stones = 0\n\nfor operation in s:\n    if operation == '+':\n        current_stones += 1\n    else:\n        if current_stones > 0:\n            current_stones -= 1\n        else:\n            min_stones += 1\n\nprint(current_stones)"}
{"solution": "def max_kefir(n, a, b, c):\n    if a <= b - c:\n        return n // a\n    else:\n        max_liters = 0\n        if n >= b:\n            max_liters += (n - b) // (b - c) + 1\n            n = (n - b) % (b - c) + c\n        max_liters += n // a\n        return max_liters\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate and print the result\nprint(max_kefir(n, a, b, c))"}
{"solution": "def card_war(n, k1, cards1, k2, cards2):\n    from collections import deque\n\n    deck1 = deque(cards1)\n    deck2 = deque(cards2)\n    seen_states = set()\n    fight_count = 0\n\n    while deck1 and deck2:\n        state = (tuple(deck1), tuple(deck2))\n        if state in seen_states:\n            return -1\n        seen_states.add(state)\n\n        card1 = deck1.popleft()\n        card2 = deck2.popleft()\n\n        if card1 > card2:\n            deck1.append(card2)\n            deck1.append(card1)\n        else:\n            deck2.append(card1)\n            deck2.append(card2)\n\n        fight_count += 1\n\n    if deck1:\n        return fight_count, 1\n    else:\n        return fight_count, 2\n\n# Read input\nn = int(input())\nk1, *cards1 = map(int, input().split())\nk2, *cards2 = map(int, input().split())\n\n# Get result\nresult = card_war(n, k1, cards1, k2, cards2)\n\n# Print result\nif result == -1:\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "import re\n\ndef check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    if not re.search(r'[A-Z]', password):\n        return \"Too weak\"\n    if not re.search(r'[a-z]', password):\n        return \"Too weak\"\n    if not re.search(r'\\d', password):\n        return \"Too weak\"\n    return \"Correct\"\n\npassword = input().strip()\nprint(check_password_complexity(password))"}
{"solution": "def min_exchanges(n, group_a, group_b):\n    from collections import Counter\n\n    # Count the occurrences of each academic performance in both groups\n    count_a = Counter(group_a)\n    count_b = Counter(group_b)\n\n    # Check if it's possible to balance the groups\n    for i in range(1, 6):\n        if (count_a[i] + count_b[i]) % 2 != 0:\n            return -1\n\n    # Calculate the number of exchanges needed\n    exchanges = 0\n    for i in range(1, 6):\n        diff = abs(count_a[i] - count_b[i]) // 2\n        exchanges += diff\n\n    return exchanges // 2\n\n# Read input\nn = int(input())\ngroup_a = list(map(int, input().split()))\ngroup_b = list(map(int, input().split()))\n\n# Print the result\nprint(min_exchanges(n, group_a, group_b))"}
{"solution": "def is_reachable(n, m, horizontal, vertical):\n    # Check if all horizontal streets are the same direction\n    if horizontal[0] == '<':\n        if any(h != '<' for h in horizontal):\n            return \"NO\"\n    else:\n        if any(h != '>' for h in horizontal):\n            return \"NO\"\n    \n    # Check if all vertical streets are the same direction\n    if vertical[0] == '^':\n        if any(v != '^' for v in vertical):\n            return \"NO\"\n    else:\n        if any(v != 'v' for v in vertical):\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nhorizontal = input().strip()\nvertical = input().strip()\n\n# Check if the pattern meets the criteria\nresult = is_reachable(n, m, horizontal, vertical)\nprint(result)"}
{"solution": "def implication(a, b):\n    return not a or b\n\ndef find_false_implication(n, arr):\n    if n == 1:\n        if arr[0] == 0:\n            return \"YES\\n0\"\n        else:\n            return \"NO\"\n    \n    if arr[-1] == 0:\n        return \"YES\\n\" + \"->\".join([\"(\" * (n - 1) + str(arr[0])] + [str(arr[i]) + \")\" for i in range(1, n)])\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input().strip())\narr = list(map(int, input().strip().split()))\n\n# Find and print the result\nresult = find_false_implication(n, arr)\nprint(result)"}
{"solution": "def process_values(a, b):\n    while a != 0 and b != 0:\n        if a >= 2 * b:\n            a = a % (2 * b)\n        elif b >= 2 * a:\n            b = b % (2 * a)\n        else:\n            break\n    return a, b\n\n# Read input\nn, m = map(int, input().split())\n\n# Process the values\nresult_a, result_b = process_values(n, m)\n\n# Print the result\nprint(result_a, result_b)"}
{"solution": "def count_k_divisible(k, a, b):\n    if a % k == 0:\n        start = a\n    else:\n        start = a + (k - a % k)\n    \n    if b % k == 0:\n        end = b\n    else:\n        end = b - (b % k)\n    \n    if start > end:\n        return 0\n    \n    return (end - start) // k + 1\n\n# Read input\nk, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(count_k_divisible(k, a, b))"}
{"solution": "def find_kth_digit(k):\n    length = 0\n    number = 1\n    while length < k:\n        length += len(str(number))\n        number += 1\n    number -= 1\n    length -= len(str(number))\n    return str(number)[k - length - 1]\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "def can_vasya_win(n, s):\n    # Calculate the number of moves each player will make\n    vasya_moves = (n - 11) // 2 + 1\n    petya_moves = (n - 11) // 2\n\n    # Count the number of '8's in the first (n-10) characters\n    count_8 = s[:n-10].count('8')\n\n    # Vasya wins if he can ensure that there are at least as many '8's as his moves\n    if count_8 >= vasya_moves:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Determine if Vasya can win\nresult = can_vasya_win(n, s)\nprint(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial(n):\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef count_permutations(n, x, pos):\n    less_than_x = x - 1\n    greater_than_x = n - x\n    left = 0\n    right = n\n    less_count = 0\n    greater_count = 0\n\n    while left < right:\n        middle = (left + right) // 2\n        if middle <= pos:\n            if middle != pos:\n                less_count += 1\n            left = middle + 1\n        else:\n            greater_count += 1\n            right = middle\n\n    if less_count > less_than_x or greater_count > greater_than_x:\n        return 0\n\n    less_permutations = factorial(less_than_x) // factorial(less_than_x - less_count)\n    greater_permutations = factorial(greater_than_x) // factorial(greater_than_x - greater_count)\n    remaining_permutations = factorial(n - 1 - less_count - greater_count)\n\n    result = (less_permutations * greater_permutations) % MOD\n    result = (result * remaining_permutations) % MOD\n\n    return result\n\nn, x, pos = map(int, input().split())\nprint(count_permutations(n, x, pos))"}
{"solution": "def decode_message(encoded_str, k):\n    n = len(encoded_str)\n    dp = [[False] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(n):\n        for j in range(k + 1):\n            if not dp[i][j]:\n                continue\n            if encoded_str[i].isalpha():\n                if j + 1 <= k:\n                    dp[i + 1][j + 1] = True\n                if i + 1 < n and encoded_str[i + 1] == '?':\n                    dp[i + 2][j] = True\n                    if j + 1 <= k:\n                        dp[i + 2][j + 1] = True\n                elif i + 1 < n and encoded_str[i + 1] == '*':\n                    dp[i + 2][j] = True\n                    for l in range(1, k - j + 1):\n                        dp[i + 2][j + l] = True\n            elif encoded_str[i] in '?*':\n                dp[i + 1][j] = True\n\n    if not dp[n][k]:\n        return \"Impossible\"\n\n    result = []\n    i, j = n, k\n    while i > 0:\n        if encoded_str[i - 1].isalpha():\n            if j > 0 and dp[i - 1][j - 1]:\n                result.append(encoded_str[i - 1])\n                i -= 1\n                j -= 1\n            elif i > 1 and encoded_str[i - 2] == '?':\n                if dp[i - 2][j]:\n                    i -= 2\n                else:\n                    result.append(encoded_str[i - 1])\n                    i -= 2\n                    j -= 1\n            elif i > 1 and encoded_str[i - 2] == '*':\n                if dp[i - 2][j]:\n                    i -= 2\n                else:\n                    count = 0\n                    while j > 0 and dp[i - 2][j - 1]:\n                        result.append(encoded_str[i - 1])\n                        j -= 1\n                        count += 1\n                    i -= 2\n        else:\n            i -= 1\n\n    return ''.join(result[::-1])\n\n# Read input\nencoded_str = input().strip()\nk = int(input().strip())\n\n# Get the decoded message\nresult = decode_message(encoded_str, k)\n\n# Print the result\nprint(result)"}
{"solution": "x = int(input())\n\n# Normalize the angle to be within the range [0, 360)\nx = x % 360\n\n# Calculate the number of 90 degree turns needed\nturns = (360 - x) // 90\n\n# Output the result\nprint(turns)"}
{"solution": "def can_transform_spheres(a, b, c, x, y, z):\n    # Calculate the surplus or deficit of each color\n    surplus_blue = a - x\n    surplus_violet = b - y\n    surplus_orange = c - z\n\n    # Calculate the total surplus\n    total_surplus = 0\n    if surplus_blue > 0:\n        total_surplus += surplus_blue // 2\n    if surplus_violet > 0:\n        total_surplus += surplus_violet // 2\n    if surplus_orange > 0:\n        total_surplus += surplus_orange // 2\n\n    # Calculate the total deficit\n    total_deficit = 0\n    if surplus_blue < 0:\n        total_deficit -= surplus_blue\n    if surplus_violet < 0:\n        total_deficit -= surplus_violet\n    if surplus_orange < 0:\n        total_deficit -= surplus_orange\n\n    # Check if the total surplus can cover the total deficit\n    return total_surplus >= total_deficit\n\n# Read input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Determine if the transformation is possible\nif can_transform_spheres(a, b, c, x, y, z):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def count_numbers(n, k, m):\n    # Initialize the dp array\n    dp = [[0] * k for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(10):\n            for r in range(k):\n                dp[i][(r * 10 + j) % k] = (dp[i][(r * 10 + j) % k] + dp[i - 1][r]) % m\n\n    # Calculate the result\n    result = 0\n    for i in range(1, 10):\n        result = (result + dp[n - 1][(k - i % k) % k]) % m\n\n    return result\n\n# Read input\nn, k, m = map(int, input().split())\n\n# Print the result\nprint(count_numbers(n, k, m))"}
{"solution": "def max_team_size(l, r, a):\n    # Balance the left and right handers using ambidexters\n    if l < r:\n        l, r = r, l  # Ensure l is always greater or equal to r\n    if l - r > a:\n        return 2 * (r + a)\n    else:\n        return 2 * ((l + r + a) // 2)\n\n# Read input\nl, r, a = map(int, input().split())\n\n# Calculate and print the result\nprint(max_team_size(l, r, a))"}
{"solution": "def min_moves_to_pick_all_coins(n, k):\n    # Calculate the minimum moves required to pick all coins\n    left_moves = (k - 1) * 2 + (n - 1)\n    right_moves = (n - k) * 2 + (n - 1)\n    return min(left_moves, right_moves) + 3 * n\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the result\nprint(min_moves_to_pick_all_coins(n, k))"}
{"solution": "def min_tallest_tower_height(n, m):\n    heights = set()\n    for i in range(1, n + 1):\n        heights.add(2 * i)\n    for j in range(1, m + 1):\n        heights.add(3 * j)\n    \n    return max(heights)\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(min_tallest_tower_height(n, m))"}
{"solution": "n = int(input())\ncards = [int(input()) for _ in range(n)]\n\nfrom collections import Counter\n\ncount = Counter(cards)\n\nif len(count) != 2:\n    print(\"NO\")\nelse:\n    values = list(count.values())\n    if values[0] == values[1]:\n        keys = list(count.keys())\n        print(\"YES\")\n        print(keys[0], keys[1])\n    else:\n        print(\"NO\")"}
{"solution": "def can_place_soldiers(n, k, groups):\n    # Each row has 4 pairs of neighboring seats\n    max_pairs = 4 * n\n    \n    # Count the number of pairs needed\n    pairs_needed = 0\n    for soldiers in groups:\n        pairs_needed += (soldiers + 1) // 2\n    \n    # Check if the number of pairs needed is less than or equal to the available pairs\n    if pairs_needed <= max_pairs:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Output the result\nprint(can_place_soldiers(n, k, groups))"}
{"solution": "def find_min_cost(n, sticks):\n    min_cost = float('inf')\n    best_t = -1\n\n    for t in range(1, 101):\n        current_cost = 0\n        for stick in sticks:\n            current_cost += min(abs(stick - t), abs(stick - (t - 1)), abs(stick - (t + 1)))\n        if current_cost < min_cost:\n            min_cost = current_cost\n            best_t = t\n\n    return best_t, min_cost\n\n# Read input\nn = int(input())\nsticks = list(map(int, input().split()))\n\n# Find the best t and the minimum cost\nt, cost = find_min_cost(n, sticks)\n\n# Print the result\nprint(t, cost)"}
{"solution": "def find_min_square_side(n, m, sky_map):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n\n    for i in range(n):\n        for j in range(m):\n            if sky_map[i][j] == '*':\n                if i < min_row:\n                    min_row = i\n                if i > max_row:\n                    max_row = i\n                if j < min_col:\n                    min_col = j\n                if j > max_col:\n                    max_col = j\n\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    return side_length\n\n# Read input\nn, m = map(int, input().split())\nsky_map = [input().strip() for _ in range(n)]\n\n# Find and print the result\nprint(find_min_square_side(n, m, sky_map))"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_inv(x, mod):\n    return pow(x, mod - 2, mod)\n\ndef solve(n, k, a):\n    if sorted(a) == a:\n        print(1)\n        return\n    \n    ones = sum(a)\n    zeros = n - ones\n    \n    if ones == 0 or zeros == 0:\n        print(1)\n        return\n    \n    if k == 1:\n        print(0)\n        return\n    \n    P = ones * zeros\n    Q = n * (n - 1) // 2\n    \n    P %= MOD\n    Q %= MOD\n    \n    result = (P * mod_inv(Q, MOD)) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    solve(n, k, a)"}
{"solution": "def min_seconds_to_obtain_triangle(x, y):\n    # The minimum number of seconds required is simply the difference between x and y\n    return x - y\n\n# Read input\nx, y = map(int, input().split())\n\n# Calculate and print the result\nprint(min_seconds_to_obtain_triangle(x, y))"}
{"solution": "def min_norm(a, b, c, d):\n    det = a * d - b * c\n    if det == 0:\n        return 0.0\n\n    norm = abs(det) / ((a * a + c * c) ** 0.5 + (b * b + d * d) ** 0.5)\n    return norm\n\nif __name__ == \"__main__\":\n    a, b = map(int, input().split())\n    c, d = map(int, input().split())\n    result = min_norm(a, b, c, d)\n    print(f\"{result:.10f}\")"}
{"solution": "def denied_service(n, a, b, groups):\n    denied = 0\n    one_seater = a\n    two_seater = b\n    one_person_on_two_seater = 0\n\n    for group in groups:\n        if group == 1:\n            if one_seater > 0:\n                one_seater -= 1\n            elif two_seater > 0:\n                two_seater -= 1\n                one_person_on_two_seater += 1\n            elif one_person_on_two_seater > 0:\n                one_person_on_two_seater -= 1\n            else:\n                denied += 1\n        elif group == 2:\n            if two_seater > 0:\n                two_seater -= 1\n            else:\n                denied += 2\n\n    return denied\n\n# Read input\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(denied_service(n, a, b, groups))"}
{"solution": "def calculate_students(A, B, C, N):\n    # Check for invalid conditions\n    if C > A or C > B or A + B - C >= N:\n        return -1\n    \n    # Calculate the number of students who didn't pass the exam\n    students_did_not_pass = N - (A + B - C)\n    \n    # Check if the number of students who didn't pass is at least 1\n    if students_did_not_pass < 1:\n        return -1\n    \n    return students_did_not_pass\n\n# Read input values\nA, B, C, N = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_students(A, B, C, N))"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_exp(base, exp, mod):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return result\n\ndef expected_dresses(x, k):\n    if x == 0:\n        return 0\n    # Calculate 2^(k+1) % MOD\n    power = mod_exp(2, k + 1, MOD)\n    # Calculate (2^(k+1) * x - (2^k - 1)) % MOD\n    result = (power * x - (power // 2 - 1)) % MOD\n    return result\n\n# Read input\nx, k = map(int, input().split())\n\n# Calculate and print the result\nprint(expected_dresses(x, k))"}
{"solution": "MOD = 998244353\n\ndef mod_inv(a, p):\n    return pow(a, p - 2, p)\n\ndef calculate_probability(n, ranges):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        l_i, r_i = ranges[i - 1]\n        for j in range(i + 1):\n            dp[i][j] = dp[i - 1][j] * (r_i - l_i + 1) % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * (r_i - l_i + 1) % MOD) % MOD\n\n    total_ways = 1\n    for l_i, r_i in ranges:\n        total_ways = total_ways * (r_i - l_i + 1) % MOD\n\n    no_inversion_ways = sum(dp[n][i] for i in range(n + 1)) % MOD\n    probability = no_inversion_ways * mod_inv(total_ways, MOD) % MOD\n\n    return probability\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    ranges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n)]\n    \n    result = calculate_probability(n, ranges)\n    print(result)"}
{"solution": "def count_ways(n):\n    if n % 2 != 0 or n < 8:\n        return 0\n    count = 0\n    for a in range(1, n // 4 + 1):\n        b = a\n        c = (n - 2 * a) // 2\n        if c > b and 2 * a + 2 * c == n:\n            count += 1\n    return count\n\nn = int(input())\nprint(count_ways(n))"}
{"solution": "def fair_nut_kvass(n, s, volumes):\n    total_kvass = sum(volumes)\n    if total_kvass < s:\n        return -1\n    \n    min_keg = min(volumes)\n    if total_kvass - s < min_keg * n:\n        return (total_kvass - s) // n\n    else:\n        return min_keg\n\n# Read input\nn, s = map(int, input().split())\nvolumes = list(map(int, input().split()))\n\n# Get the result\nresult = fair_nut_kvass(n, s, volumes)\n\n# Print the result\nprint(result)"}
{"solution": "def days_to_reach_apple(h1, h2, a, b):\n    # Initial height difference\n    height_diff = h2 - h1\n    \n    # Caterpillar's net gain in height per day\n    net_gain_per_day = (12 * a) - (12 * b)\n    \n    # If the caterpillar can reach the apple on the first day\n    if 8 * a >= height_diff:\n        return 0\n    \n    # If the caterpillar cannot make any progress\n    if net_gain_per_day <= 0:\n        return -1\n    \n    # Calculate the remaining height after the first day\n    remaining_height = height_diff - (8 * a)\n    \n    # Calculate the number of full days needed to reach the apple\n    full_days_needed = (remaining_height + net_gain_per_day - 1) // net_gain_per_day\n    \n    return full_days_needed + 1\n\n# Read input\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Print the result\nprint(days_to_reach_apple(h1, h2, a, b))"}
{"solution": "def max_joy(C, Hr, Hb, Wr, Wb):\n    max_joy_units = 0\n\n    if Wr > Wb:\n        Wr, Wb = Wb, Wr\n        Hr, Hb = Hb, Hr\n\n    for blue_candies in range(0, C // Wb + 1):\n        remaining_weight = C - blue_candies * Wb\n        red_candies = remaining_weight // Wr\n        joy_units = blue_candies * Hb + red_candies * Hr\n        max_joy_units = max(max_joy_units, joy_units)\n\n    return max_joy_units\n\n# Read input\nC, Hr, Hb, Wr, Wb = map(int, input().split())\n\n# Calculate and print the maximum joy units\nprint(max_joy(C, Hr, Hb, Wr, Wb))"}
{"solution": "# Read input values\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\n# Calculate the minimal number of steps\nsteps = max(abs(x2 - x1), abs(y2 - y1))\n\n# Print the result\nprint(steps)"}
{"solution": "def predict_vote_outcome(n, employees):\n    from collections import deque\n\n    depublicans = deque()\n    remocrats = deque()\n\n    for i in range(n):\n        if employees[i] == 'D':\n            depublicans.append(i)\n        else:\n            remocrats.append(i)\n\n    while depublicans and remocrats:\n        d = depublicans.popleft()\n        r = remocrats.popleft()\n        if d < r:\n            depublicans.append(d + n)\n        else:\n            remocrats.append(r + n)\n\n    if depublicans:\n        return 'D'\n    else:\n        return 'R'\n\n# Read input\nn = int(input().strip())\nemployees = input().strip()\n\n# Predict and print the outcome\nprint(predict_vote_outcome(n, employees))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_tv_sets(a, b, x, y):\n    g = gcd(x, y)\n    x //= g\n    y //= g\n    \n    max_w = a // x\n    max_h = b // y\n    \n    return min(max_w, max_h)\n\n# Read input\na, b, x, y = map(int, input().split())\n\n# Calculate and print the result\nprint(count_tv_sets(a, b, x, y))"}
{"solution": "def prime_factors(b):\n    factors = {}\n    d = 2\n    while d * d <= b:\n        while (b % d) == 0:\n            if d in factors:\n                factors[d] += 1\n            else:\n                factors[d] = 1\n            b //= d\n        d += 1\n    if b > 1:\n        factors[b] = 1\n    return factors\n\ndef count_factors_in_factorial(n, p):\n    count = 0\n    power = p\n    while power <= n:\n        count += n // power\n        power *= p\n    return count\n\ndef trailing_zeros_in_base(n, b):\n    factors = prime_factors(b)\n    min_trailing_zeros = float('inf')\n    for p in factors:\n        count_p = count_factors_in_factorial(n, p)\n        min_trailing_zeros = min(min_trailing_zeros, count_p // factors[p])\n    return min_trailing_zeros\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    n, b = map(int, input().strip().split())\n    print(trailing_zeros_in_base(n, b))"}
{"solution": "def sum_f(m, a, b):\n    if a > b:\n        a, b = b, a\n\n    visited = set()\n    queue = [0]\n    visited.add(0)\n\n    while queue:\n        current = queue.pop(0)\n        if current + a <= m and current + a not in visited:\n            visited.add(current + a)\n            queue.append(current + a)\n        if current - b >= 0 and current - b not in visited:\n            visited.add(current - b)\n            queue.append(current - b)\n\n    f_values = [0] * (m + 1)\n    for i in range(m + 1):\n        f_values[i] = len([x for x in visited if x <= i])\n\n    return sum(f_values)\n\n# Read input\nm, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(sum_f(m, a, b))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nif n % 2 == 1 and a[0] % 2 == 1 and a[-1] % 2 == 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    if x1 == x2:\n        side_length = abs(y2 - y1)\n        x3, y3 = x1 + side_length, y1\n        x4, y4 = x2 + side_length, y2\n    elif y1 == y2:\n        side_length = abs(x2 - x1)\n        x3, y3 = x1, y1 + side_length\n        x4, y4 = x2, y2 + side_length\n    elif abs(x2 - x1) == abs(y2 - y1):\n        x3, y3 = x1, y2\n        x4, y4 = x2, y1\n    else:\n        return -1\n    \n    return x3, y3, x4, y4\n\nx1, y1, x2, y2 = map(int, input().split())\nresult = find_remaining_trees(x1, y1, x2, y2)\nif result == -1:\n    print(result)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def calculate_fn(x, y, n):\n    MOD = 1000000007\n    sequence = [x, y, y - x, -x, -y, x - y]\n    return sequence[(n - 1) % 6] % MOD\n\n# Read input\nx, y = map(int, input().split())\nn = int(input())\n\n# Calculate and print the result\nprint(calculate_fn(x, y, n))"}
{"solution": "def split_array(n, A):\n    total_sum = sum(A)\n    \n    if total_sum != 0:\n        print(\"YES\")\n        print(1)\n        print(1, n)\n    else:\n        for i in range(n):\n            if A[i] != 0:\n                print(\"YES\")\n                print(2)\n                print(1, i + 1)\n                print(i + 2, n)\n                return\n        print(\"NO\")\n\n# Read input\nn = int(input())\nA = list(map(int, input().split()))\n\n# Call the function\nsplit_array(n, A)"}
{"solution": "MOD = 1000000009\n\ndef min_score(n, m, k):\n    if m < k:\n        return m % MOD\n    \n    full_sets = m // k\n    remaining_correct = m % k\n    max_full_sets = (n - m) // (k - 1)\n    \n    if full_sets <= max_full_sets:\n        return m % MOD\n    \n    extra_sets = full_sets - max_full_sets\n    score = (max_full_sets * k + remaining_correct) % MOD\n    score = (score + (k * (pow(2, extra_sets, MOD) - 1) % MOD) * pow(2, MOD-2, MOD)) % MOD\n    return score\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Calculate and print the result\nprint(min_score(n, m, k))"}
{"solution": "def is_divisible_by_8(n):\n    length = len(n)\n    \n    # Check all single digit numbers\n    for i in range(length):\n        if int(n[i]) % 8 == 0:\n            return \"YES\", n[i]\n    \n    # Check all two digit numbers\n    for i in range(length):\n        for j in range(i + 1, length):\n            if int(n[i] + n[j]) % 8 == 0:\n                return \"YES\", n[i] + n[j]\n    \n    # Check all three digit numbers\n    for i in range(length):\n        for j in range(i + 1, length):\n            for k in range(j + 1, length):\n                if int(n[i] + n[j] + n[k]) % 8 == 0:\n                    return \"YES\", n[i] + n[j] + n[k]\n    \n    return \"NO\", \"\"\n\nn = input().strip()\nresult, number = is_divisible_by_8(n)\nprint(result)\nif result == \"YES\":\n    print(number)"}
{"solution": "def find_floor(n, m, memories):\n    possible_floors = set()\n    \n    for flats_per_floor in range(1, 101):\n        consistent = True\n        for k, f in memories:\n            if (k - 1) // flats_per_floor + 1 != f:\n                consistent = False\n                break\n        if consistent:\n            possible_floors.add((n - 1) // flats_per_floor + 1)\n    \n    if len(possible_floors) == 1:\n        return possible_floors.pop()\n    else:\n        return -1\n\n# Read input\nn, m = map(int, input().split())\nmemories = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Find and print the floor\nprint(find_floor(n, m, memories))"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    count = 0\n    i = 0\n\n    while i < n:\n        if i + 1 < n:\n            if board1[i] == '0' and board1[i + 1] == '0' and board2[i] == '0':\n                count += 1\n                i += 2\n                continue\n            if board1[i] == '0' and board1[i + 1] == '0' and board2[i + 1] == '0':\n                count += 1\n                i += 2\n                continue\n            if board2[i] == '0' and board2[i + 1] == '0' and board1[i] == '0':\n                count += 1\n                i += 2\n                continue\n            if board2[i] == '0' and board2[i + 1] == '0' and board1[i + 1] == '0':\n                count += 1\n                i += 2\n                continue\n\n        if i + 1 < n:\n            if board1[i] == '0' and board2[i] == '0' and board2[i + 1] == '0':\n                count += 1\n                i += 2\n                continue\n            if board1[i] == '0' and board2[i] == '0' and board1[i + 1] == '0':\n                count += 1\n                i += 2\n                continue\n            if board2[i] == '0' and board1[i] == '0' and board1[i + 1] == '0':\n                count += 1\n                i += 2\n                continue\n            if board2[i] == '0' and board1[i] == '0' and board2[i + 1] == '0':\n                count += 1\n                i += 2\n                continue\n\n        i += 1\n\n    return count\n\n# Read input\nboard1 = input().strip()\nboard2 = input().strip()\n\n# Calculate and print the result\nprint(max_bishwocks(board1, board2))"}
{"solution": "def max_pretty_set_length(n, s):\n    max_length = 0\n    current_set = set()\n    current_length = 0\n\n    for char in s:\n        if char.islower():\n            if char not in current_set:\n                current_set.add(char)\n                current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_set.clear()\n            current_length = 0\n\n    max_length = max(max_length, current_length)\n    return max_length\n\n# Read input\nn = int(input())\ns = input()\n\n# Get the result\nresult = max_pretty_set_length(n, s)\n\n# Print the result\nprint(result)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# To maximize B - C, we should put all positive numbers in b and all negative numbers in c\nB = sum(x for x in a if x > 0)\nC = sum(x for x in a if x < 0)\n\n# Since C is negative, B - C is equivalent to B + abs(C)\nresult = B - C\n\nprint(result)"}
{"solution": "def min_refuels(a, b, f, k):\n    if b < f or b < (a - f):\n        return -1\n\n    refuels = 0\n    current_fuel = b\n    position = 0\n\n    for i in range(k):\n        if i % 2 == 0:\n            distance_to_travel = a\n            distance_to_station = f\n        else:\n            distance_to_travel = a\n            distance_to_station = a - f\n\n        if current_fuel < distance_to_station:\n            return -1\n\n        current_fuel -= distance_to_station\n\n        if current_fuel < (distance_to_travel - distance_to_station):\n            refuels += 1\n            current_fuel = b\n\n        current_fuel -= (distance_to_travel - distance_to_station)\n\n    return refuels\n\n# Read input\na, b, f, k = map(int, input().split())\n\n# Calculate and print the result\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    for i in range(n // p + 1):\n        for j in range(n // q + 1):\n            if i * p + j * q == n:\n                print(i + j)\n                index = 0\n                for _ in range(i):\n                    print(s[index:index + p])\n                    index += p\n                for _ in range(j):\n                    print(s[index:index + q])\n                    index += q\n                return\n    print(-1)\n\n# Read input\nn, p, q = map(int, input().split())\ns = input().strip()\n\n# Call the function\nsplit_string(n, p, q, s)"}
{"solution": "def can_reach_finish(n, m, s, d, obstacles):\n    obstacles.sort()\n    current_position = 0\n    result = []\n\n    for i in range(n):\n        if obstacles[i] - current_position - 1 >= s:\n            run_distance = obstacles[i] - current_position - 1\n            if i < n - 1 and obstacles[i + 1] - obstacles[i] - 1 < s:\n                if obstacles[i + 1] - current_position - 1 > d:\n                    return \"IMPOSSIBLE\"\n                jump_distance = obstacles[i + 1] - current_position\n                result.append(f\"RUN {run_distance}\")\n                result.append(f\"JUMP {jump_distance}\")\n                current_position = obstacles[i + 1]\n            else:\n                if run_distance > d:\n                    return \"IMPOSSIBLE\"\n                result.append(f\"RUN {run_distance}\")\n                result.append(f\"JUMP {d}\")\n                current_position = obstacles[i] + d\n        else:\n            return \"IMPOSSIBLE\"\n\n    if m - current_position - 1 >= s:\n        result.append(f\"RUN {m - current_position - 1}\")\n    else:\n        return \"IMPOSSIBLE\"\n\n    return \"\\n\".join(result)\n\n# Read input\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\n# Get the result\nresult = can_reach_finish(n, m, s, d, obstacles)\n\n# Print the result\nprint(result)"}
{"solution": "def count_pairs(s, x):\n    # If s < x or (s - x) % 2 != 0, there are no solutions\n    if s < x or (s - x) % 2 != 0:\n        return 0\n    \n    a_plus_b = s\n    a_xor_b = x\n    \n    a_and_b = (a_plus_b - a_xor_b) // 2\n    \n    # If a_and_b is negative, there are no solutions\n    if a_and_b < 0:\n        return 0\n    \n    count = 0\n    for i in range(60):  # 2^60 > 10^12, so we check up to 60 bits\n        if (a_xor_b & (1 << i)) != 0:\n            if (a_and_b & (1 << i)) != 0:\n                return 0\n    \n    # Each bit in a_xor_b can be either 0 or 1 independently\n    # So the number of solutions is 2^(number of 1s in a_xor_b)\n    count = 1 << bin(a_xor_b).count('1')\n    \n    # We need to subtract the case where a = b = 0\n    if a_plus_b == a_xor_b:\n        count -= 2\n    \n    return count\n\n# Read input\ns, x = map(int, input().split())\n\n# Print the result\nprint(count_pairs(s, x))"}
{"solution": "def turn_skewers(n, k):\n    # Calculate the step size\n    step = 2 * k + 1\n    \n    # Calculate the number of actions needed\n    actions = (n + step - 1) // step\n    \n    # Calculate the positions to turn\n    positions = []\n    start = (n - (actions - 1) * step + 1) // 2\n    for i in range(actions):\n        positions.append(start + i * step)\n    \n    return actions, positions\n\n# Read input\nn, k = map(int, input().split())\n\n# Get the result\nactions, positions = turn_skewers(n, k)\n\n# Print the result\nprint(actions)\nprint(\" \".join(map(str, positions)))"}
{"solution": "import math\n\ndef is_square(x):\n    root = int(math.isqrt(x))\n    return root * root == x\n\ndef min_operations_to_square(n):\n    n_str = str(n)\n    length = len(n_str)\n    min_operations = float('inf')\n    found = False\n    \n    for i in range(1, 1 << length):\n        candidate = []\n        for j in range(length):\n            if i & (1 << j):\n                candidate.append(n_str[j])\n        candidate_num = int(''.join(candidate))\n        if is_square(candidate_num):\n            found = True\n            min_operations = min(min_operations, length - len(candidate))\n    \n    if found:\n        return min_operations\n    else:\n        return -1\n\n# Read input\nn = int(input().strip())\n\n# Print output\nprint(min_operations_to_square(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial(n):\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef solve(n):\n    if n == 2:\n        print(1)\n        return\n    \n    # For n >= 3, the number of permutations such that f(p) = f_max(n) is (n-1)!\n    result = factorial(n - 1)\n    print(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\nn = int(input().strip())\n\n# Solve the problem\nsolve(n)"}
{"solution": "def min_jump_ability(s):\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    max_jump = 0\n    last_vowel_pos = -1\n\n    for i, char in enumerate(s):\n        if char in vowels:\n            max_jump = max(max_jump, i - last_vowel_pos)\n            last_vowel_pos = i\n\n    max_jump = max(max_jump, len(s) - last_vowel_pos)\n    return max_jump\n\n# Read input\ns = input().strip()\n\n# Calculate and print the minimum jump ability\nprint(min_jump_ability(s))"}
{"solution": "def can_distribute_equally(a1, a2, a3, a4):\n    candies = [a1, a2, a3, a4]\n    total = sum(candies)\n    \n    # If the total number of candies is odd, it's impossible to split them equally\n    if total % 2 != 0:\n        return \"NO\"\n    \n    half = total // 2\n    \n    # Check all possible combinations of distributing the bags\n    for i in range(1 << 4):\n        sum1 = 0\n        for j in range(4):\n            if i & (1 << j):\n                sum1 += candies[j]\n        if sum1 == half:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\na1, a2, a3, a4 = map(int, input().split())\n\n# Print the result\nprint(can_distribute_equally(a1, a2, a3, a4))"}
{"solution": "def optimal_pie_distribution(N, slices):\n    # Initialize sums for Alice and Bob\n    alice_sum = 0\n    bob_sum = 0\n    \n    # Initialize the decider token holder (0 for Bob, 1 for Alice)\n    decider = 0\n    \n    # Iterate through the slices\n    for i in range(N):\n        if decider == 0:  # Bob's turn to decide\n            if i < N - 1 and slices[i] < slices[i + 1]:\n                # Give the current slice to Alice and pass the decider token to her\n                alice_sum += slices[i]\n                decider = 1\n            else:\n                # Take the current slice for Bob and pass the decider token to Alice\n                bob_sum += slices[i]\n                decider = 1\n        else:  # Alice's turn to decide\n            if i < N - 1 and slices[i] < slices[i + 1]:\n                # Give the current slice to Bob and pass the decider token to him\n                bob_sum += slices[i]\n                decider = 0\n            else:\n                # Take the current slice for Alice and pass the decider token to Bob\n                alice_sum += slices[i]\n                decider = 0\n    \n    return alice_sum, bob_sum\n\n# Read input\nN = int(input())\nslices = list(map(int, input().split()))\n\n# Get the result\nalice_sum, bob_sum = optimal_pie_distribution(N, slices)\n\n# Print the result\nprint(alice_sum, bob_sum)"}
{"solution": "def min_variables(n, a):\n    a.sort()\n    if a[0] != 1:\n        return -1\n\n    variables = [0] * n\n    variables[0] = a[0]\n    used = 1\n\n    for i in range(1, n):\n        found = False\n        for j in range(used):\n            for k in range(j, used):\n                if variables[j] + variables[k] == a[i]:\n                    variables[used] = a[i]\n                    used += 1\n                    found = True\n                    break\n            if found:\n                break\n        if not found:\n            return -1\n\n    return used\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = min_variables(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def determine_winner(n, piles):\n    # If all piles have the same number of stones, Bob wins\n    if len(set(piles)) == 1:\n        return \"Bob\"\n    else:\n        return \"Alice\"\n\n# Read input\nn = int(input().strip())\npiles = list(map(int, input().strip().split()))\n\n# Determine the winner\nwinner = determine_winner(n, piles)\n\n# Print the result\nprint(winner)"}
{"solution": "def can_make_elements_equal(n, arr):\n    unique_elements = sorted(set(arr))\n    \n    if len(unique_elements) == 1:\n        return \"YES\"\n    elif len(unique_elements) == 2:\n        return \"YES\"\n    elif len(unique_elements) == 3:\n        if unique_elements[2] - unique_elements[1] == unique_elements[1] - unique_elements[0]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Print the result\nprint(can_make_elements_equal(n, arr))"}
{"solution": "def find_max_length(N, S):\n    def has_repeated_substring_of_length(length):\n        seen = set()\n        for i in range(N - length + 1):\n            substring = S[i:i + length]\n            if substring in seen:\n                return True\n            seen.add(substring)\n        return False\n\n    left, right = 1, N\n    max_len = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if has_repeated_substring_of_length(mid):\n            max_len = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return max_len\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nS = data[1]\n\n# Find and print the result\nprint(find_max_length(N, S))"}
{"solution": "def min_time_to_reach_house(n, a):\n    if a % 2 == 1:\n        return (a + 1) // 2\n    else:\n        return (n - a + 2) // 2\n\n# Read input\nn, a = map(int, input().split())\n\n# Calculate and print the result\nprint(min_time_to_reach_house(n, a))"}
{"solution": "def find_jedi_interval(n, m, colors, k):\n    # Initialize the count of each color in the current window\n    current_count = [0] * m\n    \n    # Initialize the start of the window\n    start = 0\n    \n    # Iterate over the end of the window\n    for end in range(n):\n        # Increment the count of the current color\n        current_count[colors[end] - 1] += 1\n        \n        # Check if the current window is valid\n        while all(current_count[i] >= k[i] for i in range(m)):\n            # If the current window is valid, return YES\n            if all(current_count[i] == k[i] for i in range(m)):\n                return \"YES\"\n            # Move the start of the window to the right\n            current_count[colors[start] - 1] -= 1\n            start += 1\n    \n    # If no valid window is found, return NO\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\nk = list(map(int, input().split()))\n\n# Find and print the result\nprint(find_jedi_interval(n, m, colors, k))"}
{"solution": "n = int(input())\nmishka_wins = 0\nchris_wins = 0\n\nfor _ in range(n):\n    m, c = map(int, input().split())\n    if m > c:\n        mishka_wins += 1\n    elif c > m:\n        chris_wins += 1\n\nif mishka_wins > chris_wins:\n    print(\"Mishka\")\nelif chris_wins > mishka_wins:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")"}
{"solution": "def is_valid_minesweeper_field(n, m, field):\n    def count_bombs_around(x, y):\n        count = 0\n        for dx in range(-1, 2):\n            for dy in range(-1, 2):\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and field[nx][ny] == '*':\n                    count += 1\n        return count\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '.':\n                if count_bombs_around(i, j) != 0:\n                    return \"NO\"\n            elif field[i][j].isdigit():\n                if count_bombs_around(i, j) != int(field[i][j]):\n                    return \"NO\"\n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Check if the field is valid\nprint(is_valid_minesweeper_field(n, m, field))"}
{"solution": "def can_vasya_eat_half(n, k):\n    vasya_eaten = 0\n    total_candies = n\n    \n    while total_candies > 0:\n        vasya_eaten += min(k, total_candies)\n        total_candies -= min(k, total_candies)\n        petya_eaten = total_candies // 10\n        total_candies -= petya_eaten\n    \n    return vasya_eaten * 2 >= n\n\ndef find_min_k(n):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\nn = int(input())\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace(s):\n    pearls = s.count('o')\n    links = s.count('-')\n    \n    if pearls == 0:\n        print(\"YES\")\n        return\n    \n    if links % pearls == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n# Read input\ns = input().strip()\ncan_rearrange_necklace(s)"}
{"solution": "def max_pillows(n, m, k):\n    def can_distribute(p):\n        left = k - 1\n        right = n - k\n        total = p\n        if left > 0:\n            if p > left:\n                total += (p - 1) * left - (left * (left - 1)) // 2\n            else:\n                total += (p * (p - 1)) // 2 + (left - p + 1)\n        if right > 0:\n            if p > right:\n                total += (p - 1) * right - (right * (right - 1)) // 2\n            else:\n                total += (p * (p - 1)) // 2 + (right - p + 1)\n        return total <= m\n\n    low, high = 1, m\n    while low < high:\n        mid = (low + high + 1) // 2\n        if can_distribute(mid):\n            low = mid\n        else:\n            high = mid - 1\n    return low\n\n# Read input\nn, m, k = map(int, input().strip().split())\n\n# Print the result\nprint(max_pillows(n, m, k))"}
{"solution": "import sys\nimport math\n\ndef max_subarray_cost(n, m, k, a):\n    max_cost = 0\n    current_sum = 0\n    dp = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        current_sum += a[i - 1]\n        dp[i] = max(dp[i - 1], current_sum - k * math.ceil(i / m))\n        max_cost = max(max_cost, dp[i])\n        \n        if i >= m:\n            current_sum -= a[i - m]\n    \n    return max_cost\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2])\n    a = list(map(int, data[3:]))\n    \n    print(max_subarray_cost(n, m, k, a))"}
{"solution": "def find_longest_polyline(n, m):\n    if n == 0:\n        return [(0, 1), (0, m), (0, 0), (0, m-1)]\n    elif m == 0:\n        return [(1, 0), (n, 0), (0, 0), (n-1, 0)]\n    else:\n        return [(0, 0), (n, m), (0, m), (n, 0)]\n\n# Read input\nn, m = map(int, input().strip().split())\n\n# Find the longest polyline\npoints = find_longest_polyline(n, m)\n\n# Print the points\nfor point in points:\n    print(point[0], point[1])"}
{"solution": "def find_smallest_n(received, remembered):\n    len_remembered = len(remembered)\n    possible_ns = []\n\n    for i in range(len(received)):\n        if received[i:i+len_remembered] == remembered:\n            possible_n = received[:i] + received[i+len_remembered:]\n            if possible_n:\n                possible_ns.append(possible_n)\n\n    possible_ns = sorted(possible_ns, key=lambda x: (len(x), x))\n    return possible_ns[0]\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    received = data[0]\n    remembered = data[1]\n    print(find_smallest_n(received, remembered))"}
{"solution": "# Read input values\nn, m, min_temp, max_temp = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\n# Check if the given temperatures already contain min and max\ncontains_min = min_temp in temperatures\ncontains_max = max_temp in temperatures\n\n# Calculate how many more temperatures we need to add\nremaining_temps = n - m\n\n# Check if we can add the necessary min and max temperatures\nif contains_min and contains_max:\n    print(\"Correct\")\nelif contains_min and not contains_max and remaining_temps >= 1:\n    print(\"Correct\")\nelif not contains_min and contains_max and remaining_temps >= 1:\n    print(\"Correct\")\nelif not contains_min and not contains_max and remaining_temps >= 2:\n    print(\"Correct\")\nelse:\n    print(\"Incorrect\")"}
{"solution": "def count_trailing_zeroes(n):\n    count = 0\n    power_of_5 = 5\n    while n >= power_of_5:\n        count += n // power_of_5\n        power_of_5 *= 5\n    return count\n\ndef find_numbers_with_m_zeroes(m):\n    low, high = 0, 5 * (m + 1)\n    result = []\n    \n    while low <= high:\n        mid = (low + high) // 2\n        zeroes = count_trailing_zeroes(mid)\n        \n        if zeroes < m:\n            low = mid + 1\n        elif zeroes > m:\n            high = mid - 1\n        else:\n            result = [i for i in range(mid - mid % 5, mid - mid % 5 + 5) if count_trailing_zeroes(i) == m]\n            break\n    \n    return result\n\nm = int(input().strip())\nresult = find_numbers_with_m_zeroes(m)\nprint(len(result))\nif result:\n    print(\" \".join(map(str, result)))"}
{"solution": "import heapq\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\nspecial_vertices = list(map(int, data[3:3+k]))\n\nedges = []\nindex = 3 + k\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index+1])\n    w = int(data[index+2])\n    edges.append((w, u, v))\n    index += 3\n\n# Kruskal's algorithm to find the Minimum Spanning Tree (MST)\nparent = list(range(n + 1))\nrank = [0] * (n + 1)\n\ndef find(u):\n    if parent[u] != u:\n        parent[u] = find(parent[u])\n    return parent[u]\n\ndef union(u, v):\n    root_u = find(u)\n    root_v = find(v)\n    if root_u != root_v:\n        if rank[root_u] > rank[root_v]:\n            parent[root_v] = root_u\n        elif rank[root_u] < rank[root_v]:\n            parent[root_u] = root_v\n        else:\n            parent[root_v] = root_u\n            rank[root_u] += 1\n\nedges.sort()\nmst = defaultdict(list)\nfor w, u, v in edges:\n    if find(u) != find(v):\n        union(u, v)\n        mst[u].append((v, w))\n        mst[v].append((u, w))\n\n# Dijkstra's algorithm to find the maximum edge weight in the shortest path\ndef dijkstra_max_edge(start):\n    max_edge = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    pq = [(0, start)]\n    while pq:\n        max_w, u = heapq.heappop(pq)\n        if visited[u]:\n            continue\n        visited[u] = True\n        for v, w in mst[u]:\n            if not visited[v]:\n                new_max_w = max(max_w, w)\n                if new_max_w < max_edge[v] or max_edge[v] == 0:\n                    max_edge[v] = new_max_w\n                    heapq.heappush(pq, (new_max_w, v))\n    return max_edge\n\nmax_distances = [0] * (k + 1)\nfor i in range(k):\n    max_edge = dijkstra_max_edge(special_vertices[i])\n    for j in range(k):\n        if i != j:\n            max_distances[i] = max(max_distances[i], max_edge[special_vertices[j]])\n\nprint(\" \".join(map(str, max_distances)))"}
{"solution": "def find_initial_position(n, x):\n    # We will reverse the moves to find the initial position\n    for i in range(n, 0, -1):\n        if i % 2 == 1:\n            # Odd move: swap left (0) and middle (1)\n            if x == 0:\n                x = 1\n            elif x == 1:\n                x = 0\n        else:\n            # Even move: swap middle (1) and right (2)\n            if x == 1:\n                x = 2\n            elif x == 2:\n                x = 1\n    return x\n\n# Read input\nn = int(input())\nx = int(input())\n\n# Find and print the initial position\nprint(find_initial_position(n, x))"}
{"solution": "def is_square(rectangles):\n    min_x = min(rect[0] for rect in rectangles)\n    max_x = max(rect[2] for rect in rectangles)\n    min_y = min(rect[1] for rect in rectangles)\n    max_y = max(rect[3] for rect in rectangles)\n\n    side_length = max_x - min_x\n    if side_length != (max_y - min_y):\n        return \"NO\"\n\n    covered_area = 0\n    for rect in rectangles:\n        covered_area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n\n    if covered_area == side_length * side_length:\n        return \"YES\"\n    else:\n        return \"NO\"\n\nn = int(input())\nrectangles = [tuple(map(int, input().split())) for _ in range(n)]\nprint(is_square(rectangles))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef count_really_big_numbers(n, s):\n    count = 0\n    for x in range(s, n + 1):\n        if x - sum_of_digits(x) >= s:\n            count += 1\n    return count\n\n# Read input\nn, s = map(int, input().split())\n\n# Calculate and print the result\nprint(count_really_big_numbers(n, s))"}
{"solution": "def is_possible_to_draw_two_lines(points):\n    def collinear(p1, p2, p3):\n        return (p2[1] - p1[1]) * (p3[0] - p1[0]) == (p3[1] - p1[1]) * (p2[0] - p1[0])\n\n    n = len(points)\n    if n <= 2:\n        return True\n\n    for i in range(3):\n        for j in range(i + 1, 3):\n            line1 = [points[i], points[j]]\n            line2 = []\n            for k in range(n):\n                if not collinear(points[i], points[j], points[k]):\n                    line2.append(points[k])\n            if len(line2) <= 2:\n                return True\n            if all(collinear(line2[0], line2[1], line2[k]) for k in range(2, len(line2))):\n                return True\n\n    return False\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\nif is_possible_to_draw_two_lines(points):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(a, b, k, t):\n    dp = [[0] * (2 * k * t + 1) for _ in range(2)]\n    offset = k * t\n    dp[0][a - b + offset] = 1\n\n    for turn in range(1, t + 1):\n        current = turn % 2\n        previous = 1 - current\n        for i in range(2 * k * t + 1):\n            dp[current][i] = 0\n\n        for i in range(2 * k * t + 1):\n            if dp[previous][i] == 0:\n                continue\n            for j in range(-k, k + 1):\n                for l in range(-k, k + 1):\n                    ni = i + j - l\n                    if 0 <= ni < 2 * k * t + 1:\n                        dp[current][ni] = (dp[current][ni] + dp[previous][i]) % MOD\n\n    result = 0\n    for i in range(offset + 1, 2 * k * t + 1):\n        result = (result + dp[t % 2][i]) % MOD\n\n    print(result)\n\n# Example usage\na, b, k, t = map(int, input().split())\nsolve(a, b, k, t)"}
{"solution": "def find_minimum_marks(n, l, x, y, marks):\n    marks_set = set(marks)\n    can_measure_x = False\n    can_measure_y = False\n\n    for mark in marks:\n        if mark + x in marks_set or mark - x in marks_set:\n            can_measure_x = True\n        if mark + y in marks_set or mark - y in marks_set:\n            can_measure_y = True\n\n    if can_measure_x and can_measure_y:\n        return 0, []\n\n    if can_measure_x:\n        for mark in marks:\n            if mark + y <= l and (mark + y) not in marks_set:\n                return 1, [mark + y]\n            if mark - y >= 0 and (mark - y) not in marks_set:\n                return 1, [mark - y]\n        return 1, [y]\n\n    if can_measure_y:\n        for mark in marks:\n            if mark + x <= l and (mark + x) not in marks_set:\n                return 1, [mark + x]\n            if mark - x >= 0 and (mark - x) not in marks_set:\n                return 1, [mark - x]\n        return 1, [x]\n\n    for mark in marks:\n        if mark + x <= l and (mark + x + y in marks_set or mark + x - y in marks_set):\n            return 1, [mark + x]\n        if mark - x >= 0 and (mark - x + y in marks_set or mark - x - y in marks_set):\n            return 1, [mark - x]\n        if mark + y <= l and (mark + y + x in marks_set or mark + y - x in marks_set):\n            return 1, [mark + y]\n        if mark - y >= 0 and (mark - y + x in marks_set or mark - y - x in marks_set):\n            return 1, [mark - y]\n\n    return 2, [x, y]\n\n# Read input\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Find the minimum number of marks to add\nv, new_marks = find_minimum_marks(n, l, x, y, marks)\n\n# Print the result\nprint(v)\nif v > 0:\n    print(\" \".join(map(str, new_marks)))"}
{"solution": "import math\nimport sys\ninput = sys.stdin.read\n\ndef max_cake_volume(n, cakes):\n    volumes = [(math.pi * r * r * h) for r, h in cakes]\n    dp = [0] * n\n    dp[0] = volumes[0]\n    \n    for i in range(1, n):\n        dp[i] = volumes[i]\n        for j in range(i):\n            if volumes[i] > volumes[j]:\n                dp[i] = max(dp[i], dp[j] + volumes[i])\n    \n    return max(dp)\n\nif __name__ == \"__main__\":\n    data = input().split()\n    n = int(data[0])\n    cakes = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(n)]\n    result = max_cake_volume(n, cakes)\n    print(f\"{result:.9f}\")"}
{"solution": "def min_good_slices(n, k, heights):\n    from collections import Counter\n\n    # Count the frequency of each height\n    height_count = Counter(heights)\n    \n    # Sort the heights in descending order\n    unique_heights = sorted(height_count.keys(), reverse=True)\n    \n    # Initialize variables\n    total_slices = 0\n    current_height = unique_heights[0]\n    current_count = 0\n    \n    # Iterate through the unique heights\n    for height in unique_heights:\n        current_count += height_count[height]\n        if current_height != height:\n            slice_cost = current_count * (current_height - height)\n            if slice_cost <= k:\n                total_slices += 1\n                k -= slice_cost\n                current_height = height\n            else:\n                break\n    \n    # If we still have some height difference left, we need one more slice\n    if current_height != unique_heights[-1]:\n        total_slices += 1\n    \n    return total_slices\n\n# Read input\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_good_slices(n, k, heights))"}
{"solution": "def max_score(n, a):\n    # Initialize prefix sums\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    max_score = float('-inf')\n\n    # Iterate over all possible segments [l, r]\n    for l in range(n):\n        for r in range(l, n):\n            # Calculate the sum of the segment [l, r]\n            segment_sum = prefix_sum[r + 1] - prefix_sum[l]\n            # Find the minimum value in the segment [l, r]\n            min_value = min(a[l:r + 1])\n            # Calculate the score after Bob removes the minimum value\n            score = segment_sum - min_value\n            # Update the maximum score\n            max_score = max(max_score, score)\n\n    return max_score\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the maximum score\nprint(max_score(n, a))"}
{"solution": "def can_decorate_tree(k1, k2, k3):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    lcm12 = lcm(k1, k2)\n    lcm123 = lcm(lcm12, k3)\n\n    if lcm123 <= max(k1, k2, k3):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nk1, k2, k3 = map(int, input().split())\n\n# Print output\nprint(can_decorate_tree(k1, k2, k3))"}
{"solution": "def min_operations_to_delete_string(n, s):\n    dp = [[0] * n for _ in range(n)]\n    \n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if length == 1:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i + 1][j] + 1\n                if s[i] == s[i + 1]:\n                    dp[i][j] = min(dp[i][j], dp[i + 1][j])\n                for k in range(i + 2, j + 1):\n                    if s[i] == s[k]:\n                        dp[i][j] = min(dp[i][j], dp[i + 1][k - 1] + dp[k + 1][j])\n    \n    return dp[0][n - 1]\n\nn = int(input())\ns = input().strip()\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "n = int(input())\nboys = list(map(int, input().split()))\nm = int(input())\ngirls = list(map(int, input().split()))\n\nboys.sort()\ngirls.sort()\n\ni, j = 0, 0\npairs = 0\n\nwhile i < n and j < m:\n    if abs(boys[i] - girls[j]) <= 1:\n        pairs += 1\n        i += 1\n        j += 1\n    elif boys[i] < girls[j]:\n        i += 1\n    else:\n        j += 1\n\nprint(pairs)"}
{"solution": "def can_team_win(team1_def, team1_att, team2_def, team2_att):\n    return team1_def > team2_att and team1_att > team2_def\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    a1, b1 = int(data[0]), int(data[1])\n    a2, b2 = int(data[2]), int(data[3])\n    a3, b3 = int(data[4]), int(data[5])\n    a4, b4 = int(data[6]), int(data[7])\n    \n    team1_options = [(a1, b2), (a2, b1)]\n    team2_options = [(a3, b4), (a4, b3)]\n    \n    team1_wins = False\n    team2_wins = False\n    \n    for team1_def, team1_att in team1_options:\n        for team2_def, team2_att in team2_options:\n            if can_team_win(team1_def, team1_att, team2_def, team2_att):\n                team1_wins = True\n            if can_team_win(team2_def, team2_att, team1_def, team1_att):\n                team2_wins = True\n    \n    if team1_wins and not team2_wins:\n        print(\"Team 1\")\n    elif team2_wins and not team1_wins:\n        print(\"Team 2\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\nimport math\nfrom scipy.optimize import minimize\n\ndef time_to_grill(XY, meats, K):\n    X, Y = XY\n    times = []\n    for x, y, c in meats:\n        time = c * math.sqrt((X - x) ** 2 + (Y - y) ** 2)\n        times.append(time)\n    times.sort()\n    return times[K-1]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    meats = []\n    index = 2\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        c = int(data[index + 2])\n        meats.append((x, y, c))\n        index += 3\n    \n    initial_guess = [0, 0]\n    result = minimize(time_to_grill, initial_guess, args=(meats, K), method='Nelder-Mead')\n    \n    print(f\"{result.fun:.6f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def determine_winner(n, ticket):\n    first_half = ticket[:n//2]\n    second_half = ticket[n//2:]\n    \n    sum_first_half = sum(int(c) for c in first_half if c != '?')\n    sum_second_half = sum(int(c) for c in second_half if c != '?')\n    \n    count_first_half = first_half.count('?')\n    count_second_half = second_half.count('?')\n    \n    if count_first_half == count_second_half:\n        if sum_first_half == sum_second_half:\n            return \"Bicarp\"\n        else:\n            return \"Monocarp\"\n    \n    diff = abs(sum_first_half - sum_second_half)\n    count_diff = abs(count_first_half - count_second_half)\n    \n    if diff == (count_diff // 2) * 9:\n        return \"Bicarp\"\n    else:\n        return \"Monocarp\"\n\n# Read input\nn = int(input().strip())\nticket = input().strip()\n\n# Determine and print the winner\nprint(determine_winner(n, ticket))"}
{"solution": "n, t = map(int, input().split())\nbus_routes = []\n\nfor _ in range(n):\n    s, d = map(int, input().split())\n    bus_routes.append((s, d))\n\nmin_wait_time = float('inf')\nchosen_route = -1\n\nfor i, (s, d) in enumerate(bus_routes):\n    if s >= t:\n        wait_time = s - t\n    else:\n        wait_time = ((t - s + d - 1) // d) * d + s - t\n    \n    if wait_time < min_wait_time:\n        min_wait_time = wait_time\n        chosen_route = i + 1\n\nprint(chosen_route)"}
{"solution": "def count_ones_in_binary(x):\n    return bin(x).count('1')\n\ndef find_n(m, k):\n    for n in range(1, 10**18 + 1):\n        count = 0\n        for i in range(n + 1, 2 * n + 1):\n            if count_ones_in_binary(i) == k:\n                count += 1\n        if count == m:\n            return n\n    return -1\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    m = int(data[0])\n    k = int(data[1])\n    result = find_n(m, k)\n    print(result)"}
{"solution": "def is_good_level(n, level):\n    platforms = [i for i in range(n) if level[i] == '*']\n    for i in range(len(platforms) - 4):\n        for j in range(i + 1, len(platforms) - 3):\n            step = platforms[j] - platforms[i]\n            if all(platforms[i] + k * step in platforms for k in range(1, 5)):\n                return \"yes\"\n    return \"no\"\n\n# Read input\nn = int(input())\nlevel = input().strip()\n\n# Check if the level is good\nresult = is_good_level(n, level)\nprint(result)"}
{"solution": "def find_magic_number(n, grid):\n    # Find the position of the empty cell\n    empty_i, empty_j = -1, -1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                empty_i, empty_j = i, j\n                break\n        if empty_i != -1:\n            break\n\n    # Calculate the target sum using a row that doesn't contain the empty cell\n    target_sum = -1\n    for i in range(n):\n        if i != empty_i:\n            target_sum = sum(grid[i])\n            break\n\n    # Calculate the sum of the row and column containing the empty cell\n    row_sum = sum(grid[empty_i])\n    col_sum = sum(grid[i][empty_j] for i in range(n))\n\n    # Calculate the required value to fill the empty cell\n    fill_value = target_sum - row_sum\n\n    # Check if the fill_value is positive\n    if fill_value <= 0:\n        return -1\n\n    # Temporarily fill the empty cell to check the sums\n    grid[empty_i][empty_j] = fill_value\n\n    # Check all rows and columns\n    for i in range(n):\n        if sum(grid[i]) != target_sum:\n            return -1\n        if sum(grid[j][i] for j in range(n)) != target_sum:\n            return -1\n\n    # Check the main diagonal\n    if sum(grid[i][i] for i in range(n)) != target_sum:\n        return -1\n\n    # Check the secondary diagonal\n    if sum(grid[i][n - i - 1] for i in range(n)) != target_sum:\n        return -1\n\n    return fill_value\n\n# Read input\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\n# Find the magic number to fill the empty cell\nresult = find_magic_number(n, grid)\n\n# Print the result\nprint(result)"}
{"solution": "def calculate_min_max_k(n, m, a):\n    max_initial = max(a)\n    total_people = sum(a) + m\n\n    # Maximum possible k\n    max_k = max_initial + m\n\n    # Minimum possible k\n    min_k = (total_people + n - 1) // n\n\n    return min_k, max_k\n\n# Read input\nn = int(input())\nm = int(input())\na = [int(input()) for _ in range(n)]\n\n# Calculate and print the result\nmin_k, max_k = calculate_min_max_k(n, m, a)\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, m):\n    if m == 1:\n        return 2 * n % MOD\n    \n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(0, m + 1):\n            dp[i][j] = dp[i - 1][j] * 2 % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * 2 % MOD) % MOD\n    \n    return dp[n][m]\n\nn, m = map(int, input().split())\nprint(count_ways(n, m))"}
{"solution": "def main():\n    import sys\n    input = sys.stdin.read\n    from itertools import combinations\n\n    data = input().split()\n    idx = 0\n\n    n = int(data[idx])\n    m = int(data[idx + 1])\n    idx += 2\n\n    friends = []\n    for _ in range(n):\n        f_i = int(data[idx])\n        ingredients = set(map(int, data[idx + 1: idx + 1 + f_i]))\n        friends.append(ingredients)\n        idx += 1 + f_i\n\n    pizzas = []\n    for j in range(m):\n        c_j = int(data[idx])\n        r_j = int(data[idx + 1])\n        ingredients = set(map(int, data[idx + 2: idx + 2 + r_j]))\n        pizzas.append((c_j, ingredients, j + 1))\n        idx += 2 + r_j\n\n    max_friends_pleased = 0\n    min_cost = float('inf')\n    best_pair = (1, 2)\n\n    for (c1, ing1, idx1), (c2, ing2, idx2) in combinations(pizzas, 2):\n        combined_ingredients = ing1 | ing2\n        friends_pleased = sum(1 for friend in friends if friend <= combined_ingredients)\n        total_cost = c1 + c2\n\n        if (friends_pleased > max_friends_pleased) or (friends_pleased == max_friends_pleased and total_cost < min_cost):\n            max_friends_pleased = friends_pleased\n            min_cost = total_cost\n            best_pair = (idx1, idx2)\n\n    print(best_pair[0], best_pair[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_min_max(m, s):\n    if s == 0:\n        if m == 1:\n            return \"0 0\"\n        else:\n            return \"-1 -1\"\n    \n    if s > 9 * m:\n        return \"-1 -1\"\n    \n    min_num = [0] * m\n    max_num = [0] * m\n    \n    # Construct the minimum number\n    sum_digits = s\n    for i in range(m - 1, -1, -1):\n        if sum_digits > 9:\n            min_num[i] = 9\n            sum_digits -= 9\n        else:\n            min_num[i] = sum_digits\n            sum_digits = 0\n    \n    if min_num[0] == 0:\n        for i in range(1, m):\n            if min_num[i] > 0:\n                min_num[i] -= 1\n                min_num[0] = 1\n                break\n    \n    # Construct the maximum number\n    sum_digits = s\n    for i in range(m):\n        if sum_digits > 9:\n            max_num[i] = 9\n            sum_digits -= 9\n        else:\n            max_num[i] = sum_digits\n            sum_digits = 0\n    \n    min_num_str = ''.join(map(str, min_num))\n    max_num_str = ''.join(map(str, max_num))\n    \n    return f\"{min_num_str} {max_num_str}\"\n\n# Read input\nm, s = map(int, input().split())\n\n# Find and print the result\nprint(find_min_max(m, s))"}
{"solution": "MOD = 998244353\n\ndef count_unique_digits(n):\n    return len(set(str(n)))\n\ndef sum_of_numbers_with_k_digits(l, r, k):\n    total_sum = 0\n    for num in range(l, r + 1):\n        if count_unique_digits(num) <= k:\n            total_sum = (total_sum + num) % MOD\n    return total_sum\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    l = int(data[0])\n    r = int(data[1])\n    k = int(data[2])\n    result = sum_of_numbers_with_k_digits(l, r, k)\n    print(result)"}
{"solution": "def can_distribute_pencils(n, k, d, saturations):\n    saturations.sort()\n    dp = [False] * (n + 1)\n    dp[0] = True\n    count = [0] * (n + 1)\n    count[0] = 1\n\n    for i in range(1, n + 1):\n        if i >= k and dp[i - k]:\n            count[i] = count[i - k]\n        if i > k and dp[i - k - 1]:\n            count[i] -= count[i - k - 1]\n        if i > 1 and abs(saturations[i - 1] - saturations[i - 2]) > d:\n            count[i] = 0\n        dp[i] = count[i] > 0\n        count[i] += count[i - 1]\n\n    return \"YES\" if dp[n] else \"NO\"\n\n# Read input\nn, k, d = map(int, input().split())\nsaturations = list(map(int, input().split()))\n\n# Print the result\nprint(can_distribute_pencils(n, k, d, saturations))"}
{"solution": "def count_dead_bulbs(s):\n    n = len(s)\n    color_positions = {'R': -1, 'B': -1, 'Y': -1, 'G': -1}\n    dead_counts = {'R': 0, 'B': 0, 'Y': 0, 'G': 0}\n\n    # Determine the positions of each color in the first four characters\n    for i in range(4):\n        if s[i] != '!':\n            color_positions[s[i]] = i\n\n    # Iterate through the string and count dead bulbs\n    for i in range(n):\n        if s[i] == '!':\n            # Determine the color of the dead bulb based on its position\n            pos = i % 4\n            for color, position in color_positions.items():\n                if position == pos:\n                    dead_counts[color] += 1\n                    break\n\n    print(dead_counts['R'], dead_counts['B'], dead_counts['Y'], dead_counts['G'])\n\n# Read input\ns = input().strip()\ncount_dead_bulbs(s)"}
{"solution": "import sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    pq = [(0, start)]\n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances\n\ndef minimize_expected_passages(n, m, passages):\n    graph = [[] for _ in range(n + 1)]\n    for s, t in passages:\n        graph[s].append((t, 1))\n    \n    original_distances = dijkstra(graph, 1, n)\n    min_expected_passages = original_distances[n]\n    \n    for s, t in passages:\n        graph[s].remove((t, 1))\n        new_distances = dijkstra(graph, 1, n)\n        if new_distances[n] < float('inf'):\n            min_expected_passages = min(min_expected_passages, new_distances[n])\n        graph[s].append((t, 1))\n    \n    return min_expected_passages\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    passages = []\n    index = 2\n    for _ in range(m):\n        s = int(data[index])\n        t = int(data[index + 1])\n        passages.append((s, t))\n        index += 2\n    \n    result = minimize_expected_passages(n, m, passages)\n    print(f\"{result:.10f}\")"}
{"solution": "n = int(input())\n\nif n % 10 == 0:\n    print(n)\nelse:\n    lower = (n // 10) * 10\n    upper = lower + 10\n    if n - lower < upper - n:\n        print(lower)\n    else:\n        print(upper)"}
{"solution": "def find_swaps(s, t):\n    if len(s) != len(t):\n        return -1\n\n    swaps = []\n    used = set()\n    swap_map = {}\n\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if s[i] in used or t[i] in used:\n                return -1\n            if s[i] in swap_map:\n                if swap_map[s[i]] != t[i]:\n                    return -1\n            else:\n                swap_map[s[i]] = t[i]\n                swap_map[t[i]] = s[i]\n                swaps.append((s[i], t[i]))\n                used.add(s[i])\n                used.add(t[i])\n\n    return swaps\n\ndef main():\n    s = input().strip()\n    t = input().strip()\n\n    swaps = find_swaps(s, t)\n    if swaps == -1:\n        print(-1)\n    else:\n        print(len(swaps))\n        for swap in swaps:\n            print(swap[0], swap[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def earliest_login(first_name, last_name):\n    earliest = first_name[0] + last_name[0]\n    for i in range(1, len(first_name) + 1):\n        for j in range(1, len(last_name) + 1):\n            login = first_name[:i] + last_name[:j]\n            if login < earliest:\n                earliest = login\n    return earliest\n\n# Read input\nfirst_name, last_name = input().split()\n\n# Get the earliest login\nresult = earliest_login(first_name, last_name)\n\n# Print the result\nprint(result)"}
{"solution": "def draw_brackets(n, sequence):\n    def get_height(seq):\n        max_depth = 0\n        current_depth = 0\n        for char in seq:\n            if char == '[':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            else:\n                current_depth -= 1\n        return max_depth\n\n    def draw(seq, depth, max_depth):\n        if not seq:\n            return [' ' * (2 * max_depth + 1)]\n        \n        if seq[0] == '[':\n            close_index = 1\n            balance = 1\n            while balance != 0:\n                if seq[close_index] == '[':\n                    balance += 1\n                else:\n                    balance -= 1\n                close_index += 1\n            \n            inner = draw(seq[1:close_index-1], depth + 1, max_depth)\n            outer = draw(seq[close_index:], depth, max_depth)\n            \n            width = 2 * (max_depth - depth) + 1\n            top_bottom = '+' + '-' * (width - 2) + '+'\n            middle = '|' + ' ' * (width - 2) + '|'\n            \n            result = [top_bottom]\n            for line in inner:\n                result.append('|' + line + '|')\n            result.append(middle)\n            result.append(top_bottom)\n            \n            if outer:\n                for i in range(len(result)):\n                    result[i] += ' ' + outer[i]\n            \n            return result\n        else:\n            return draw(seq[1:], depth, max_depth)\n    \n    max_depth = get_height(sequence)\n    result = draw(sequence, 0, max_depth)\n    for line in result:\n        print(line)\n\n# Read input\nn = int(input())\nsequence = input().strip()\n\n# Draw the brackets\ndraw_brackets(n, sequence)"}
{"solution": "def golden_compare(num1, num2):\n    # Remove leading zeros\n    num1 = num1.lstrip('0')\n    num2 = num2.lstrip('0')\n    \n    # Compare lengths first\n    if len(num1) > len(num2):\n        return \">\"\n    elif len(num1) < len(num2):\n        return \"<\"\n    \n    # If lengths are equal, compare lexicographically\n    if num1 > num2:\n        return \">\"\n    elif num1 < num2:\n        return \"<\"\n    else:\n        return \"=\"\n\n# Read input\nnum1 = input().strip()\nnum2 = input().strip()\n\n# Print the result of comparison\nprint(golden_compare(num1, num2))"}
{"solution": "# Define the mapping of colors to gem names\ncolor_to_gem = {\n    \"purple\": \"Power\",\n    \"green\": \"Time\",\n    \"blue\": \"Space\",\n    \"orange\": \"Soul\",\n    \"red\": \"Reality\",\n    \"yellow\": \"Mind\"\n}\n\n# Read input\nn = int(input().strip())\npresent_colors = [input().strip() for _ in range(n)]\n\n# Determine the absent gems\nabsent_gems = [gem for color, gem in color_to_gem.items() if color not in present_colors]\n\n# Output the result\nprint(len(absent_gems))\nfor gem in absent_gems:\n    print(gem)"}
{"solution": "def find_round(n, a, b):\n    round_num = 1\n    while n > 1:\n        if (a + 1) // 2 == (b + 1) // 2:\n            return round_num\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n //= 2\n        round_num += 1\n    return \"Final!\"\n\n# Read input\nn, a, b = map(int, input().strip().split())\n\n# Ensure a is less than b for simplicity\nif a > b:\n    a, b = b, a\n\n# Find and print the round in which teams a and b can meet\nresult = find_round(n, a, b)\nprint(result if result == \"Final!\" else result)"}
{"solution": "def min_changes_to_suit_pavel(n, p, b):\n    # Function to find the minimum number of changes required\n    def find_min_changes(n, p, b):\n        visited = [False] * n\n        cycles = []\n        \n        # Find all cycles in the permutation\n        for i in range(n):\n            if not visited[i]:\n                cycle = []\n                x = i\n                while not visited[x]:\n                    visited[x] = True\n                    cycle.append(x)\n                    x = p[x] - 1\n                cycles.append(cycle)\n        \n        # Count the number of cycles with odd length\n        odd_cycles = sum(1 for cycle in cycles if len(cycle) % 2 == 1)\n        \n        # Count the number of 1s in b\n        ones_in_b = sum(b)\n        \n        # Minimum changes required\n        min_changes = max(odd_cycles - ones_in_b, 0)\n        \n        return min_changes\n    \n    return find_min_changes(n, p, b)\n\n# Read input\nn = int(input().strip())\np = list(map(int, input().strip().split()))\nb = list(map(int, input().strip().split()))\n\n# Get the result\nresult = min_changes_to_suit_pavel(n, p, b)\n\n# Print the result\nprint(result)"}
{"solution": "def max_path_length(v1, v2, t, d):\n    speeds = [v1]\n    for i in range(1, t - 1):\n        next_speed = min(speeds[-1] + d, v2 + (t - 1 - i) * d)\n        speeds.append(next_speed)\n    speeds.append(v2)\n    return sum(speeds)\n\n# Read input\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Calculate and print the maximum possible length of the path segment\nprint(max_path_length(v1, v2, t, d))"}
{"solution": "from itertools import permutations\n\ndef can_cross(perm, weights, bridge_parts):\n    n = len(weights)\n    for l, v in bridge_parts:\n        current_weight = 0\n        for i in range(n):\n            if current_weight + weights[perm[i]] > v:\n                return False\n            current_weight += weights[perm[i]]\n            if i < n - 1:\n                current_weight -= weights[perm[i]]\n    return True\n\ndef min_distance(N, M, weights, bridge_parts):\n    min_dist = float('inf')\n    for perm in permutations(range(N)):\n        if can_cross(perm, weights, bridge_parts):\n            dist = sum(bridge_parts[i][0] for i in range(M))\n            min_dist = min(min_dist, dist)\n    return min_dist if min_dist != float('inf') else -1\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nweights = list(map(int, data[2:N+2]))\nbridge_parts = [(int(data[i]), int(data[i+1])) for i in range(N+2, len(data), 2)]\n\n# Find and print the minimum possible distance\nprint(min_distance(N, M, weights, bridge_parts))"}
{"solution": "def last_digit_of_reincarnations(a, b):\n    if a == b:\n        print(1)\n        return\n    if b - a >= 5:\n        print(0)\n        return\n    \n    result = 1\n    for i in range(a + 1, b + 1):\n        result *= i\n        result %= 10\n    \n    print(result)\n\n# Read input\na, b = map(int, input().split())\nlast_digit_of_reincarnations(a, b)"}
{"solution": "def min_jumps_to_home(n, d, s):\n    jumps = 0\n    position = 0\n    \n    while position < n - 1:\n        next_position = position\n        for i in range(1, d + 1):\n            if position + i < n and s[position + i] == '1':\n                next_position = position + i\n        if next_position == position:\n            return -1\n        position = next_position\n        jumps += 1\n    \n    return jumps\n\n# Read input\nn, d = map(int, input().split())\ns = input().strip()\n\n# Calculate and print the result\nprint(min_jumps_to_home(n, d, s))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_counterexample(n):\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\nn = int(input())\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all_coins(n):\n    house_cost = 1234567\n    car_cost = 123456\n    computer_cost = 1234\n\n    for a in range(n // house_cost + 1):\n        for b in range((n - a * house_cost) // car_cost + 1):\n            remaining = n - a * house_cost - b * car_cost\n            if remaining % computer_cost == 0:\n                return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input().strip())\n\n# Print the result\nprint(can_spend_all_coins(n))"}
{"solution": "def check_intersection(n, x1, x2, lines):\n    # Calculate the y-values at x1 and x2 for each line\n    y_values_at_x1 = [(k * x1 + b, i) for i, (k, b) in enumerate(lines)]\n    y_values_at_x2 = [(k * x2 + b, i) for i, (k, b) in enumerate(lines)]\n    \n    # Sort the y-values at x1 and x2\n    y_values_at_x1.sort()\n    y_values_at_x2.sort()\n    \n    # Check if the order of lines changes between x1 and x2\n    for i in range(n - 1):\n        if y_values_at_x1[i][1] != y_values_at_x2[i][1]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx1 = int(data[1])\nx2 = int(data[2])\nlines = [(int(data[3 + 2 * i]), int(data[4 + 2 * i])) for i in range(n)]\n\n# Check for intersection\nresult = check_intersection(n, x1, x2, lines)\nprint(result)"}
{"solution": "def count_weights(n):\n    weights = set()\n    i = 1\n    while i * (i + 1) // 2 <= n:\n        if (n - i * (i + 1) // 2) % i == 0:\n            weights.add(i)\n        i += 1\n    return len(weights)\n\nn = int(input())\nprint(count_weights(n))"}
{"solution": "def find_good_apartments(n, k):\n    if k == 0:\n        min_good = 0\n        max_good = 0\n    elif k == n:\n        min_good = 0\n        max_good = 0\n    else:\n        min_good = 1\n        max_good = min(2 * k, n - k)\n    \n    print(min_good, max_good)\n\n# Read input\nn, k = map(int, input().split())\n\n# Find and print the result\nfind_good_apartments(n, k)"}
{"solution": "import math\n\ndef max_games(n):\n    return int(math.log2(n))\n\n# Read input\nn = int(input().strip())\n\n# Print the output\nprint(max_games(n))"}
{"solution": "def max_vk_occurrences(s):\n    n = len(s)\n    max_count = 0\n\n    # Count initial VK occurrences\n    initial_count = 0\n    for i in range(n - 1):\n        if s[i] == 'V' and s[i + 1] == 'K':\n            initial_count += 1\n\n    max_count = initial_count\n\n    # Try changing each character and count VK occurrences\n    for i in range(n):\n        original_char = s[i]\n        for new_char in 'VK':\n            if original_char == new_char:\n                continue\n            s = s[:i] + new_char + s[i + 1:]\n            count = 0\n            for j in range(n - 1):\n                if s[j] == 'V' and s[j + 1] == 'K':\n                    count += 1\n            max_count = max(max_count, count)\n        s = s[:i] + original_char + s[i + 1:]\n\n    return max_count\n\n# Read input\ns = input().strip()\n# Print output\nprint(max_vk_occurrences(s))"}
{"solution": "import math\n\ndef min_segments(n):\n    side_length = math.isqrt(n)\n    if side_length * side_length == n:\n        return 2 * side_length\n    else:\n        return 2 * side_length + 1\n\nn = int(input())\nprint(min_segments(n))"}
{"solution": "a, b = map(int, input().split())\nyears = 0\n\nwhile a <= b:\n    a *= 3\n    b *= 2\n    years += 1\n\nprint(years)"}
{"solution": "def count_visited_nodes(h, n):\n    visited = set()\n    current_node = 1\n    visited.add(current_node)\n    command_index = 0\n    consecutive_skips = 0\n    total_visited = 1\n\n    while True:\n        if current_node == n:\n            break\n\n        command = 'L' if command_index % 2 == 0 else 'R'\n        command_index += 1\n\n        if command == 'L':\n            next_node = current_node * 2\n        else:\n            next_node = current_node * 2 + 1\n\n        if next_node in visited:\n            consecutive_skips += 1\n            if consecutive_skips == 2:\n                current_node //= 2\n                consecutive_skips = 0\n        else:\n            visited.add(next_node)\n            total_visited += 1\n            current_node = next_node\n            consecutive_skips = 0\n\n        if current_node >= 2 ** h:\n            current_node //= 2\n\n    return total_visited - 1\n\n# Read input\nh, n = map(int, input().split())\n\n# Calculate and print the result\nprint(count_visited_nodes(h, n))"}
{"solution": "def count_squares(n, m):\n    total_squares = 0\n    for k in range(1, min(n, m) + 1):\n        total_squares += (n - k + 1) * (m - k + 1)\n    return total_squares\n\ndef find_tables(x):\n    tables = []\n    for n in range(1, int(x**0.5) + 1):\n        for m in range(n, x + 1):\n            if count_squares(n, m) == x:\n                tables.append((n, m))\n                if n != m:\n                    tables.append((m, n))\n    tables.sort()\n    return tables\n\nx = int(input())\ntables = find_tables(x)\nprint(len(tables))\nfor n, m in tables:\n    print(n, m)"}
{"solution": "def is_leap_year(year):\n    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\ndef check_consecutive_months(n, days):\n    # Days in each month for non-leap and leap years\n    non_leap_year = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    leap_year = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    # Create a list of all possible month sequences\n    all_months = non_leap_year + non_leap_year + leap_year + leap_year\n    \n    # Check if the sequence exists in the list of all possible month sequences\n    for i in range(len(all_months) - n + 1):\n        if all_months[i:i+n] == days:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\ndays = list(map(int, input().split()))\n\n# Check and print the result\nprint(check_consecutive_months(n, days))"}
{"solution": "def find_sequence(n):\n    if n == 2:\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    k = 0\n    fractions = []\n    \n    for b in range(2, n):\n        if n % b == 0:\n            a = 1\n            fractions.append((a, b))\n            k += 1\n            if sum(a / b for a, b in fractions) >= 1 - 1 / n:\n                break\n    \n    print(k)\n    for a, b in fractions:\n        print(a, b)\n\n# Read input\nn = int(input().strip())\nfind_sequence(n)"}
{"solution": "def min_unattractiveness(n, a, b, heights):\n    # Initialize DP table with infinity\n    dp = [[float('inf')] * (a + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for red_area in range(a + 1):\n            green_area = sum(heights[:i]) - red_area\n            if green_area < 0 or green_area > b:\n                continue\n\n            if red_area >= heights[i - 1]:\n                dp[i][red_area] = min(dp[i][red_area], dp[i - 1][red_area - heights[i - 1]])\n            if green_area >= heights[i - 1]:\n                dp[i][red_area] = min(dp[i][red_area], dp[i - 1][red_area] + heights[i - 1])\n\n    result = min(dp[n])\n    return result if result != float('inf') else -1\n\n# Read input\nn = int(input())\na, b = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_unattractiveness(n, a, b, heights))"}
{"solution": "def find_triangle(n, m, k):\n    area = n * m\n    if area % k != 0:\n        print(\"NO\")\n        return\n    \n    target_area = area // k\n    \n    if k % 2 == 0:\n        x1, y1 = 0, 0\n        x2, y2 = n, 0\n        x3, y3 = 0, m\n        print(\"YES\")\n        print(x1, y1)\n        print(x2, y2)\n        print(x3, y3)\n    else:\n        if 2 * n % k == 0:\n            x1, y1 = 0, 0\n            x2, y2 = 2 * n // k, 0\n            x3, y3 = 0, m\n            print(\"YES\")\n            print(x1, y1)\n            print(x2, y2)\n            print(x3, y3)\n        elif 2 * m % k == 0:\n            x1, y1 = 0, 0\n            x2, y2 = n, 0\n            x3, y3 = 0, 2 * m // k\n            print(\"YES\")\n            print(x1, y1)\n            print(x2, y2)\n            print(x3, y3)\n        else:\n            print(\"NO\")\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Find and print the triangle\nfind_triangle(n, m, k)"}
{"solution": "def sasha_wins(n, k):\n    # Calculate the number of moves each player can make\n    sasha_moves = (n + k - 1) // k // 2\n    lena_moves = (n + k - 1) // k - sasha_moves\n    \n    # Sasha wins if he makes strictly more moves than Lena\n    if sasha_moves > lena_moves:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\n\n# Determine if Sasha wins and print the result\nprint(sasha_wins(n, k))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nchest = sum(a[i] for i in range(0, n, 3))\nbiceps = sum(a[i] for i in range(1, n, 3))\nback = sum(a[i] for i in range(2, n, 3))\n\nif chest > biceps and chest > back:\n    print(\"chest\")\nelif biceps > chest and biceps > back:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "def min_redos_to_get_five(n, grades):\n    current_sum = sum(grades)\n    redos = 0\n    grades.sort()\n    \n    while round(current_sum / n) < 5:\n        current_sum += 5 - grades[redos]\n        redos += 1\n    \n    return redos\n\n# Read input\nn = int(input())\ngrades = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_redos_to_get_five(n, grades))"}
{"solution": "def find_shortest_array(u, v):\n    if u > v or (v - u) % 2 != 0:\n        print(-1)\n        return\n    \n    if u == v:\n        if u == 0:\n            print(0)\n        else:\n            print(1)\n            print(u)\n        return\n    \n    x = (v - u) // 2\n    if (u & x) == 0:\n        print(2)\n        print(u + x, x)\n    else:\n        print(3)\n        print(u, (v - u) // 2, (v - u) // 2)\n\n# Read input\nu, v = map(int, input().split())\n\n# Find and print the shortest array\nfind_shortest_array(u, v)"}
{"solution": "def min_digits_of_1(n):\n    count = 0\n    while n > 0:\n        # Find the largest number consisting of only 1s that is less than or equal to n\n        num_of_1s = 1\n        while int('1' * (num_of_1s + 1)) <= n:\n            num_of_1s += 1\n        # Subtract this number from n\n        n -= int('1' * num_of_1s)\n        # Add the number of 1s in this number to the count\n        count += num_of_1s\n    return count\n\n# Read input\nn = int(input().strip())\n\n# Print the result\nprint(min_digits_of_1(n))"}
{"solution": "def can_reach_treasure(x1, y1, x2, y2, x, y):\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    \n    if dx % x == 0 and dy % y == 0:\n        if (dx // x) % 2 == (dy // y) % 2:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\n# Print the result\nprint(can_reach_treasure(x1, y1, x2, y2, x, y))"}
{"solution": "from itertools import permutations\n\ndef count_possible_bus_numbers(n):\n    n_str = str(n)\n    unique_numbers = set()\n    \n    for i in range(1, len(n_str) + 1):\n        for perm in permutations(n_str, i):\n            if perm[0] != '0':\n                unique_numbers.add(int(''.join(perm)))\n    \n    return len(unique_numbers)\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the result\nprint(count_possible_bus_numbers(n))"}
{"solution": "def max_suit_cost(a, b, c, d, e, f):\n    # Calculate the maximum cost if we prioritize type 1 suits first\n    type1_suits = min(a, d)\n    remaining_jackets = d - type1_suits\n    type2_suits = min(b, c, remaining_jackets)\n    cost1 = type1_suits * e + type2_suits * f\n\n    # Calculate the maximum cost if we prioritize type 2 suits first\n    type2_suits = min(b, c, d)\n    remaining_jackets = d - type2_suits\n    type1_suits = min(a, remaining_jackets)\n    cost2 = type2_suits * f + type1_suits * e\n\n    # Return the maximum of the two calculated costs\n    return max(cost1, cost2)\n\n# Read input values\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\n# Calculate and print the maximum possible cost\nprint(max_suit_cost(a, b, c, d, e, f))"}
{"solution": "def mod_exp(base, exp, mod):\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return result\n\ndef solve(a, b, p, x):\n    count = 0\n    inv_a = mod_exp(a, p-2, p)\n    for n in range(1, p):\n        an_mod_p = mod_exp(a, n, p)\n        if (n * an_mod_p) % p == b:\n            max_n = (x - n) // p\n            count += max_n + 1\n    return count\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    a = int(data[0])\n    b = int(data[1])\n    p = int(data[2])\n    x = int(data[3])\n    print(solve(a, b, p, x))"}
{"solution": "def max_sum_of_favorite_integers(k_2, k_3, k_5, k_6):\n    # Calculate the number of 256 we can form\n    num_256 = min(k_2, k_5, k_6)\n    \n    # Update the count of 2s after forming 256\n    k_2 -= num_256\n    \n    # Calculate the number of 32 we can form\n    num_32 = min(k_2, k_3)\n    \n    # Calculate the total sum\n    total_sum = num_256 * 256 + num_32 * 32\n    \n    return total_sum\n\n# Read input\nk_2, k_3, k_5, k_6 = map(int, input().split())\n\n# Get the result\nresult = max_sum_of_favorite_integers(k_2, k_3, k_5, k_6)\n\n# Print the result\nprint(result)"}
{"solution": "def min_seconds_to_happiness(n, x, y, c):\n    def cells_covered_in_time(t):\n        total = 0\n        for dx in range(-t, t + 1):\n            for dy in range(-t, t + 1):\n                if abs(dx) + abs(dy) <= t:\n                    if 1 <= x + dx <= n and 1 <= y + dy <= n:\n                        total += 1\n        return total\n\n    left, right = 0, 2 * n\n    while left < right:\n        mid = (left + right) // 2\n        if cells_covered_in_time(mid) >= c:\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\n# Read input\nn, x, y, c = map(int, input().split())\n\n# Calculate and print the result\nprint(min_seconds_to_happiness(n, x, y, c))"}
{"solution": "def max_xor(l, r):\n    xor = l ^ r\n    significant_bit = 1\n    while xor > 0:\n        significant_bit <<= 1\n        xor >>= 1\n    return significant_bit - 1\n\nif __name__ == \"__main__\":\n    l, r = map(int, input().split())\n    print(max_xor(l, r))"}
{"solution": "def min_height(n, k):\n    # The minimum height can be calculated by the formula:\n    # height = (k + n - 1) // n\n    return (k + n - 1) // n\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the minimum possible height\nprint(min_height(n, k))"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    stairs_time = abs(x - y) * t1\n    elevator_time = abs(z - x) * t2 + t3 + t3 + abs(x - y) * t2 + t3\n    \n    if elevator_time <= stairs_time:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nx, y, z, t1, t2, t3 = map(int, input().split())\n\n# Determine whether to use the elevator or the stairs\nresult = should_use_elevator(x, y, z, t1, t2, t3)\n\n# Print the result\nprint(result)"}
{"solution": "def find_best_a(n, m):\n    if m == 1:\n        return 2\n    elif m == n:\n        return n - 1\n    else:\n        return m - 1 if m - 1 >= n - m else m + 1\n\n# Read input\nn, m = map(int, stdin.readline().split())\n\n# Find the best value for Andrew\nresult = find_best_a(n, m)\n\n# Print the result\nprint(result)"}
{"solution": "def count_pairs_at_university(n, pairs):\n    # Find the first and last pair with a class\n    first_class = -1\n    last_class = -1\n    for i in range(n):\n        if pairs[i] == 1:\n            if first_class == -1:\n                first_class = i\n            last_class = i\n\n    # If there are no classes at all\n    if first_class == -1:\n        return 0\n\n    # Count the number of pairs Alena stays at the university\n    stay_count = 0\n    i = first_class\n    while i <= last_class:\n        if pairs[i] == 1:\n            stay_count += 1\n            i += 1\n        else:\n            # Check for breaks of at least two free pairs in a row\n            break_length = 0\n            while i <= last_class and pairs[i] == 0:\n                break_length += 1\n                i += 1\n            if break_length < 2:\n                stay_count += break_length\n\n    return stay_count\n\n# Read input\nn = int(input())\npairs = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_pairs_at_university(n, pairs))"}
{"solution": "def min_days_to_give_candies(n, k, candies):\n    total_given = 0\n    saved_candies = 0\n\n    for day in range(n):\n        saved_candies += candies[day]\n        give_today = min(saved_candies, 8)\n        total_given += give_today\n        saved_candies -= give_today\n\n        if total_given >= k:\n            return day + 1\n\n    return -1\n\n# Read input\nn, k = map(int, input().split())\ncandies = list(map(int, input().split()))\n\n# Get the result\nresult = min_days_to_give_candies(n, k, candies)\n\n# Print the result\nprint(result)"}
{"solution": "def min_additional_walks(n, k, a):\n    b = a[:]\n    additional_walks = 0\n\n    for i in range(1, n):\n        if b[i - 1] + b[i] < k:\n            needed_walks = k - (b[i - 1] + b[i])\n            b[i] += needed_walks\n            additional_walks += needed_walks\n\n    return additional_walks, b\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nadditional_walks, b = min_additional_walks(n, k, a)\n\n# Print the result\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "def number_of_cells(n):\n    return 2 * n * (n - 1) + 1\n\nn = int(input())\nprint(number_of_cells(n))"}
{"solution": "def is_pangram(n, s):\n    s = s.lower()\n    alphabet_set = set('abcdefghijklmnopqrstuvwxyz')\n    s_set = set(s)\n    if alphabet_set.issubset(s_set):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input()\n\n# Check if the string is a pangram\nresult = is_pangram(n, s)\nprint(result)"}
{"solution": "# Read input\ncurrent_time = input().strip()\na = int(input().strip())\n\n# Parse the current time\nhh, mm = map(int, current_time.split(':'))\n\n# Calculate total minutes from the start of the day\ntotal_minutes = hh * 60 + mm\n\n# Add the given minutes\ntotal_minutes += a\n\n# Calculate new hours and minutes\nnew_hh = (total_minutes // 60) % 24\nnew_mm = total_minutes % 60\n\n# Format the result with leading zeroes\nresult = f\"{new_hh:02}:{new_mm:02}\"\n\n# Print the result\nprint(result)"}
{"solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    switches = []\n    index = 2\n    for i in range(n):\n        switches.append(data[index])\n        index += 1\n    \n    for i in range(n):\n        can_ignore = True\n        for j in range(m):\n            lamp_on = False\n            for k in range(n):\n                if k != i and switches[k][j] == '1':\n                    lamp_on = True\n                    break\n            if not lamp_on:\n                can_ignore = False\n                break\n        if can_ignore:\n            print(\"YES\")\n            return\n    \n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\ndominoes = [tuple(map(int, input().split())) for _ in range(n)]\n\nupper_sum = sum(x for x, y in dominoes)\nlower_sum = sum(y for x, y in dominoes)\n\nif upper_sum % 2 == 0 and lower_sum % 2 == 0:\n    print(0)\nelif upper_sum % 2 == 1 and lower_sum % 2 == 1:\n    for x, y in dominoes:\n        if (x % 2) != (y % 2):\n            print(1)\n            break\n    else:\n        print(-1)\nelse:\n    print(-1)"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef remaining_cloth_prime(t, test_cases):\n    results = []\n    for a, b in test_cases:\n        area = a * a - b * b\n        if is_prime(area):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    return results\n\n# Read input\nt = int(input())\ntest_cases = [tuple(map(int, input().split())) for _ in range(t)]\n\n# Get results\nresults = remaining_cloth_prime(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)"}
{"solution": "n = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\nleft_count = sum(1 for x, y in points if x < 0)\nright_count = n - left_count\n\nif left_count <= 1 or right_count <= 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "import math\n\ndef gcd_of_factorials(A, B):\n    return math.factorial(min(A, B))\n\n# Read input\nA, B = map(int, input().split())\n\n# Calculate and print the result\nprint(gcd_of_factorials(A, B))"}
{"solution": "def is_composite(x):\n    if x <= 3:\n        return False\n    if x % 2 == 0 or x % 3 == 0:\n        return True\n    i = 5\n    while i * i <= x:\n        if x % i == 0 or x % (i + 2) == 0:\n            return True\n        i += 6\n    return False\n\ndef find_composite_pair(n):\n    a = 4 + n\n    b = 4\n    while not (is_composite(a) and is_composite(b)):\n        a += 1\n        b += 1\n    return a, b\n\nn = int(input())\na, b = find_composite_pair(n)\nprint(a, b)"}
{"solution": "import sys\nimport heapq\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    P = int(data[2])\n    \n    edges = []\n    index = 3\n    for _ in range(M):\n        A = int(data[index]) - 1\n        B = int(data[index + 1]) - 1\n        C = int(data[index + 2])\n        edges.append((A, B, C))\n        index += 3\n    \n    # Bellman-Ford to find the maximum coins we can collect\n    dist = [-float('inf')] * N\n    dist[0] = 0\n    \n    for _ in range(N - 1):\n        for u, v, c in edges:\n            if dist[u] != -float('inf') and dist[u] + c > dist[v]:\n                dist[v] = dist[u] + c\n    \n    # Check for positive weight cycles reachable from vertex 1\n    reachable = [False] * N\n    reachable[0] = True\n    for _ in range(N):\n        for u, v, c in edges:\n            if reachable[u]:\n                reachable[v] = True\n    \n    for _ in range(N):\n        for u, v, c in edges:\n            if dist[u] != -float('inf') and dist[u] + c > dist[v]:\n                if reachable[v]:\n                    dist[v] = float('inf')\n    \n    if dist[N-1] == float('inf'):\n        print(-1)\n    else:\n        max_coins = dist[N-1]\n        min_time = max_coins // P if P > 0 else 0\n        max_score = max_coins - min_time * P\n        print(max_score)"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef min_cost_palindrome(N, strings_costs):\n    from itertools import combinations_with_replacement\n\n    min_cost = float('inf')\n    found_palindrome = False\n\n    for r in range(1, N + 1):\n        for combo in combinations_with_replacement(strings_costs, r):\n            combined_string = ''.join(s for s, c in combo)\n            if is_palindrome(combined_string):\n                cost = sum(c for s, c in combo)\n                if cost < min_cost:\n                    min_cost = cost\n                found_palindrome = True\n\n    return min_cost if found_palindrome else -1\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN = int(data[0])\nstrings_costs = []\n\nfor i in range(1, N + 1):\n    s, c = data[i].split()\n    c = int(c)\n    strings_costs.append((s, c))\n\n# Find and print the minimum cost\nprint(min_cost_palindrome(N, strings_costs))"}
{"solution": "def largest_xor_sum(n, k):\n    # If k is equal to or greater than n, the largest xor-sum is the xor of all numbers from 1 to n\n    if k >= n:\n        # The largest xor-sum for any n is the xor of all numbers from 1 to n\n        # which is the same as the xor of all bits set to 1 up to the highest bit in n\n        highest_bit = 1\n        while highest_bit <= n:\n            highest_bit <<= 1\n        return highest_bit - 1\n    else:\n        # If k < n, the largest xor-sum is the xor of the k largest numbers\n        # The largest k numbers are n, n-1, ..., n-k+1\n        # The xor of these numbers is the same as the xor of the first k numbers\n        highest_bit = 1\n        while highest_bit <= k:\n            highest_bit <<= 1\n        return highest_bit - 1\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(largest_xor_sum(n, k))"}
{"solution": "def min_shorter_side(n, points):\n    max_x = max(point[0] for point in points)\n    max_y = max(point[1] for point in points)\n    return max(max_x, max_y) * 2\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    points = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(n)]\n    \n    result = min_shorter_side(n, points)\n    print(result)"}
{"solution": "from collections import Counter\n\ndef max_nineteens(s):\n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # \"nineteen\" has the following character counts:\n    # n: 3, i: 1, e: 3, t: 1\n    # We need to find the limiting character\n    n_count = char_count['n'] // 3\n    i_count = char_count['i'] // 1\n    e_count = char_count['e'] // 3\n    t_count = char_count['t'] // 1\n    \n    # The maximum number of \"nineteen\"s we can form is limited by the minimum of these counts\n    return min(n_count, i_count, e_count, t_count)\n\n# Read input\ns = input().strip()\n\n# Print the result\nprint(max_nineteens(s))"}
{"solution": "def highest_suitable_branch(p, y):\n    def is_safe(branch):\n        for i in range(2, min(p + 1, int(branch**0.5) + 1)):\n            if branch % i == 0:\n                return False\n        return True\n\n    for branch in range(y, p, -1):\n        if is_safe(branch):\n            return branch\n    return -1\n\n# Read input\np, y = map(int, input().strip().split())\n\n# Find and print the highest suitable branch\nprint(highest_suitable_branch(p, y))"}
{"solution": "# Read input values\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize the minimum distance to a large number\nmin_distance = float('inf')\n\n# Check houses to the left of the girl's house\nfor i in range(m - 2, -1, -1):\n    if a[i] != 0 and a[i] <= k:\n        min_distance = min(min_distance, (m - 1 - i) * 10)\n        break\n\n# Check houses to the right of the girl's house\nfor i in range(m, n):\n    if a[i] != 0 and a[i] <= k:\n        min_distance = min(min_distance, (i - (m - 1)) * 10)\n        break\n\n# Print the minimum distance\nprint(min_distance)"}
{"solution": "def can_transform(A, B, n, m):\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] != B[i][j]:\n                return \"NO\"\n    return \"YES\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    A = []\n    B = []\n    \n    index = 2\n    for i in range(n):\n        A.append([int(data[index + j]) for j in range(m)])\n        index += m\n    \n    for i in range(n):\n        B.append([int(data[index + j]) for j in range(m)])\n        index += m\n    \n    print(can_transform(A, B, n, m))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def longest_uncommon_subsequence(a, b):\n    if a == b:\n        return -1\n    else:\n        return max(len(a), len(b))\n\n# Read input\na = input().strip()\nb = input().strip()\n\n# Get the result\nresult = longest_uncommon_subsequence(a, b)\n\n# Print the result\nprint(result)"}
{"solution": "def find_scream_time(a, b, c, d):\n    rick_screams = set()\n    time = b\n    while time <= 10000:\n        rick_screams.add(time)\n        time += a\n\n    time = d\n    while time <= 10000:\n        if time in rick_screams:\n            return time\n        time += c\n\n    return -1\n\n# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Find and print the result\nprint(find_scream_time(a, b, c, d))"}
{"solution": "def split_number(n):\n    if n % 3 == 0:\n        print(1, 1, n - 2)\n    elif n % 3 == 1:\n        print(1, 2, n - 3)\n    else:\n        print(2, 2, n - 4)\n\n# Read input\nn = int(input().strip())\n\n# Call the function to split the number and print the result\nsplit_number(n)"}
{"solution": "def count_valid_squares(n, a, b, c, d):\n    count = 0\n    for x in range(1, n + 1):\n        for y in range(1, n + 1):\n            if a + b + x + y == b + c + x + y == c + d + x + y == d + a + x + y:\n                count += 1\n    return count\n\n# Read input\nn, a, b, c, d = map(int, input().split())\n\n# Calculate and print the result\nprint(count_valid_squares(n, a, b, c, d))"}
{"solution": "def snowball_weight(w, h, u1, d1, u2, d2):\n    for i in range(h, 0, -1):\n        w += i\n        if i == d1:\n            w -= u1\n        elif i == d2:\n            w -= u2\n        if w < 0:\n            w = 0\n    return w\n\n# Read input\nw, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\n# Calculate and print the final weight of the snowball\nprint(snowball_weight(w, h, u1, d1, u2, d2))"}
{"solution": "def find_passing_rate(m, scores, x, y):\n    prefix_sum = [0] * (m + 1)\n    for i in range(1, m + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + scores[i - 1]\n\n    for k in range(1, m):\n        beginners = prefix_sum[k]\n        intermediates = prefix_sum[m] - prefix_sum[k]\n        if x <= beginners <= y and x <= intermediates <= y:\n            return k\n    return 0\n\n# Read input\nm = int(input())\nscores = list(map(int, input().split()))\nx, y = map(int, input().split())\n\n# Find and print the passing rate\nprint(find_passing_rate(m, scores, x, y))"}
{"solution": "def min_coins(n, k, A, B):\n    coins = 0\n    while n > 1:\n        if k == 1:\n            coins += (n - 1) * A\n            break\n        if n % k == 0:\n            cost_divide = B\n            cost_subtract = (n - n // k) * A\n            if cost_divide < cost_subtract:\n                coins += cost_divide\n                n //= k\n            else:\n                coins += cost_subtract\n                n -= (n - n // k)\n        else:\n            remainder = n % k\n            if remainder == 0:\n                remainder = k\n            if n - remainder > 0:\n                coins += remainder * A\n                n -= remainder\n            else:\n                coins += (n - 1) * A\n                n = 1\n    return coins\n\n# Read input\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\n# Calculate and print the result\nprint(min_coins(n, k, A, B))"}
{"solution": "import math\nfrom collections import deque\n\ndef min_operations(n):\n    visited = set()\n    queue = deque([(n, 0)])\n    \n    while queue:\n        current, steps = queue.popleft()\n        \n        if current == 1:\n            return (1, steps)\n        \n        if current not in visited:\n            visited.add(current)\n            \n            # Try sqrt operation if possible\n            sqrt_val = int(math.isqrt(current))\n            if sqrt_val * sqrt_val == current:\n                queue.append((sqrt_val, steps + 1))\n            \n            # Try multiplication operations\n            for x in range(2, int(math.sqrt(current)) + 1):\n                new_val = current * x\n                if new_val not in visited:\n                    queue.append((new_val, steps + 1))\n    \n    return (n, 0)\n\n# Read input\nn = int(input().strip())\n\n# Get the result\nresult = min_operations(n)\n\n# Print the result\nprint(result[0], result[1])"}
{"solution": "def max_score(N, K, R, S, P, T):\n    # Initialize the dp array to store the maximum score up to each round\n    dp = [[0] * 3 for _ in range(N)]\n    \n    # Mapping for the hands\n    hand_to_index = {'r': 0, 's': 1, 'p': 2}\n    index_to_hand = ['r', 's', 'p']\n    points = [P, R, S]  # Points for winning with Paper, Rock, Scissors respectively\n    \n    for i in range(N):\n        for j in range(3):\n            if i < K:\n                if index_to_hand[j] == 'r' and T[i] == 's':\n                    dp[i][j] = points[j]\n                elif index_to_hand[j] == 's' and T[i] == 'p':\n                    dp[i][j] = points[j]\n                elif index_to_hand[j] == 'p' and T[i] == 'r':\n                    dp[i][j] = points[j]\n            else:\n                max_prev = max(dp[i-K])\n                if index_to_hand[j] == 'r' and T[i] == 's':\n                    dp[i][j] = max_prev + points[j]\n                elif index_to_hand[j] == 's' and T[i] == 'p':\n                    dp[i][j] = max_prev + points[j]\n                elif index_to_hand[j] == 'p' and T[i] == 'r':\n                    dp[i][j] = max_prev + points[j]\n                else:\n                    dp[i][j] = max_prev\n    \n    # The answer is the maximum score we can get after all rounds\n    return max(dp[N-1])\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nR = int(data[2])\nS = int(data[3])\nP = int(data[4])\nT = data[5]\n\n# Calculate and print the result\nprint(max_score(N, K, R, S, P, T))"}
{"solution": "def max_good_string_length(a, b, c):\n    # The maximum length of the good string can be calculated as follows:\n    # We can use all 'ab' strings, which will contribute 2*c to the length.\n    # Then we can use min(a, b) pairs of 'a' and 'b', which will contribute 2*min(a, b) to the length.\n    # If there are remaining 'a' or 'b' strings, we can add one more to the length.\n    \n    min_ab = min(a, b)\n    max_length = 2 * c + 2 * min_ab\n    \n    if a > min_ab or b > min_ab:\n        max_length += 1\n    \n    return max_length\n\n# Read input\na, b, c = map(int, input().split())\n\n# Calculate and print the result\nprint(max_good_string_length(a, b, c))"}
{"solution": "def solve_vova_problem(n, k, p, x, y, marks):\n    remaining_tests = n - k\n    current_sum = sum(marks)\n    marks_needed = []\n\n    # Count how many marks are less than y\n    less_than_y = sum(1 for mark in marks if mark < y)\n    greater_or_equal_y = k - less_than_y\n\n    # We need at least (n // 2 + 1) marks to be >= y to satisfy the median condition\n    needed_y_marks = (n // 2 + 1) - greater_or_equal_y\n\n    if needed_y_marks > remaining_tests:\n        return -1\n\n    # Add the necessary y marks\n    for _ in range(needed_y_marks):\n        marks_needed.append(y)\n        current_sum += y\n        remaining_tests -= 1\n\n    # Add the remaining marks as 1 to minimize the sum\n    for _ in range(remaining_tests):\n        marks_needed.append(1)\n        current_sum += 1\n\n    if current_sum > x:\n        return -1\n\n    return marks_needed\n\n# Read input\nn, k, p, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Solve the problem\nresult = solve_vova_problem(n, k, p, x, y, marks)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def is_berlanese(s):\n    vowels = set(\"aouie\")\n    n = len(s)\n    \n    for i in range(n):\n        if s[i] not in vowels and s[i] != 'n':\n            if i == n - 1 or s[i + 1] not in vowels:\n                return \"NO\"\n    return \"YES\"\n\n# Read input\ns = input().strip()\n\n# Check if the word is Berlanese\nresult = is_berlanese(s)\n\n# Print the result\nprint(result)"}
{"solution": "def max_dominoes(n, m, edges):\n    from itertools import permutations\n\n    if m == 0:\n        return 0\n\n    def is_valid_assignment(assignment):\n        vertex_dots = {}\n        for (u, v), (a, b) in zip(edges, assignment):\n            if u not in vertex_dots:\n                vertex_dots[u] = a\n            elif vertex_dots[u] != a:\n                return False\n            if v not in vertex_dots:\n                vertex_dots[v] = b\n            elif vertex_dots[v] != b:\n                return False\n        return True\n\n    dominoes = [(a, b) for a in range(1, 7) for b in range(a, 7)]\n    max_dominoes_count = 0\n\n    for perm in permutations(dominoes, m):\n        if is_valid_assignment(perm):\n            max_dominoes_count = max(max_dominoes_count, m)\n\n    return max_dominoes_count\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Calculate and print the result\nprint(max_dominoes(n, m, edges))"}
{"solution": "def max_points(n, m, prices, auction_indices):\n    auction_indices = set(auction_indices)\n    auction_prices = [prices[i - 1] for i in auction_indices]\n    regular_prices = [prices[i] for i in range(n) if i + 1 not in auction_indices]\n\n    auction_prices.sort(reverse=True)\n    regular_prices.sort(reverse=True)\n\n    max_points = 0\n    current_points = 0\n\n    for price in regular_prices:\n        max_points += price\n        current_points += price\n\n    for price in auction_prices:\n        if current_points > price:\n            max_points += current_points\n            current_points *= 2\n        else:\n            max_points += price\n            current_points += price\n\n    return max_points\n\n# Read input\nn, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauction_indices = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_points(n, m, prices, auction_indices))"}
{"solution": "def calculate_score(submission_times, wrong_submissions, successful_hacks, unsuccessful_hacks):\n    max_points = [500, 1000, 1500, 2000, 2500]\n    total_score = 0\n    \n    for i in range(5):\n        m = submission_times[i]\n        w = wrong_submissions[i]\n        x = max_points[i]\n        score = max(0.3 * x, (1 - m / 250) * x - 50 * w)\n        total_score += score\n    \n    total_score += 100 * successful_hacks\n    total_score -= 50 * unsuccessful_hacks\n    \n    return int(total_score)\n\n# Read input\nsubmission_times = list(map(int, input().split()))\nwrong_submissions = list(map(int, input().split()))\nsuccessful_hacks, unsuccessful_hacks = map(int, input().split())\n\n# Calculate and print the final score\nfinal_score = calculate_score(submission_times, wrong_submissions, successful_hacks, unsuccessful_hacks)\nprint(final_score)"}
{"solution": "MOD = 998244353\n\ndef count_valid_grids(n, m, L, R):\n    if (n * m) % 2 == 0:\n        return pow(R - L + 1, n * m, MOD)\n    else:\n        total = pow(R - L + 1, n * m, MOD)\n        half = (R - L + 1) // 2\n        return (total + half) % MOD\n\n# Read input\nn, m, L, R = map(int, input().split())\n\n# Calculate and print the result\nprint(count_valid_grids(n, m, L, R))"}
{"solution": "def is_increasing(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n    \n    # Check rows\n    for i in range(n):\n        for j in range(1, m):\n            if matrix[i][j] <= matrix[i][j-1]:\n                return False\n    \n    # Check columns\n    for j in range(m):\n        for i in range(1, n):\n            if matrix[i][j] <= matrix[i-1][j]:\n                return False\n    \n    return True\n\ndef solve(n, m, a, b):\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] > b[i][j]:\n                a[i][j], b[i][j] = b[i][j], a[i][j]\n    \n    if is_increasing(a) and is_increasing(b):\n        print(\"Possible\")\n    else:\n        print(\"Impossible\")\n\n# Read input\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nb = [list(map(int, input().split())) for _ in range(n)]\n\nsolve(n, m, a, b)"}
{"solution": "def max_length_string(n, a):\n    a.sort(reverse=True)\n    used = set()\n    max_length = 0\n\n    for count in a:\n        while count in used and count > 0:\n            count -= 1\n        if count > 0:\n            used.add(count)\n            max_length += count\n\n    return max_length\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_length_string(n, a))"}
{"solution": "def min_problems_to_solve(n, k, difficulties):\n    difficulties.sort()\n    current_max = k\n    additional_problems = 0\n\n    for difficulty in difficulties:\n        while current_max < (difficulty + 1) // 2:\n            current_max *= 2\n            additional_problems += 1\n        current_max = max(current_max, difficulty)\n\n    return additional_problems\n\n# Read input\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_problems_to_solve(n, k, difficulties))"}
{"solution": "def distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3):\n    # Start with the minimum required diplomas\n    first = min_1\n    second = min_2\n    third = min_3\n\n    # Calculate the remaining diplomas to be distributed\n    remaining = n - (first + second + third)\n\n    # Distribute the remaining diplomas to maximize first degree diplomas\n    add_first = min(remaining, max_1 - first)\n    first += add_first\n    remaining -= add_first\n\n    # Distribute the remaining diplomas to maximize second degree diplomas\n    add_second = min(remaining, max_2 - second)\n    second += add_second\n    remaining -= add_second\n\n    # Distribute the remaining diplomas to third degree diplomas\n    third += remaining\n\n    return first, second, third\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nmin_1, max_1 = int(data[1]), int(data[2])\nmin_2, max_2 = int(data[3]), int(data[4])\nmin_3, max_3 = int(data[5]), int(data[6])\n\n# Get the optimal distribution of diplomas\nresult = distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3)\n\n# Print the result\nprint(result[0], result[1], result[2])"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    if a[0] == 0:\n        print(\"UP\")\n    elif a[0] == 15:\n        print(\"DOWN\")\n    else:\n        print(-1)\nelse:\n    if a[-1] == 0:\n        print(\"UP\")\n    elif a[-1] == 15:\n        print(\"DOWN\")\n    else:\n        if a[-1] > a[-2]:\n            print(\"UP\")\n        else:\n            print(\"DOWN\")"}
{"solution": "def can_transform(s, t):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    if len(s) != len(t):\n        return \"No\"\n    \n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels and char_t not in vowels) or (char_s not in vowels and char_t in vowels):\n            return \"No\"\n    \n    return \"Yes\"\n\ns = input().strip()\nt = input().strip()\n\nprint(can_transform(s, t))"}
{"solution": "def find_winner(board):\n    min_white_steps = float('inf')\n    min_black_steps = float('inf')\n\n    for col in range(8):\n        for row in range(8):\n            if board[row][col] == 'W':\n                steps = row\n                blocked = False\n                for r in range(row - 1, -1, -1):\n                    if board[r][col] != '.':\n                        blocked = True\n                        break\n                if not blocked:\n                    min_white_steps = min(min_white_steps, steps)\n            elif board[row][col] == 'B':\n                steps = 7 - row\n                blocked = False\n                for r in range(row + 1, 8):\n                    if board[r][col] != '.':\n                        blocked = True\n                        break\n                if not blocked:\n                    min_black_steps = min(min_black_steps, steps)\n\n    if min_white_steps <= min_black_steps:\n        return 'A'\n    else:\n        return 'B'\n\n# Read input\nboard = [input().strip() for _ in range(8)]\n\n# Determine the winner\nwinner = find_winner(board)\n\n# Print the result\nprint(winner)"}
{"solution": "def max_equal_length(n, A, m, B):\n    i, j = 0, 0\n    sumA, sumB = 0, 0\n    count = 0\n\n    while i < n and j < m:\n        if sumA == sumB:\n            count += 1\n            sumA += A[i]\n            sumB += B[j]\n            i += 1\n            j += 1\n        elif sumA < sumB:\n            sumA += A[i]\n            i += 1\n        else:\n            sumB += B[j]\n            j += 1\n\n    while i < n:\n        sumA += A[i]\n        i += 1\n\n    while j < m:\n        sumB += B[j]\n        j += 1\n\n    if sumA == sumB:\n        return count\n    else:\n        return -1\n\n# Read input\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\n# Get the result\nresult = max_equal_length(n, A, m, B)\n\n# Print the result\nprint(result)"}
{"solution": "def is_contest_problem(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    count = 0\n    for friend in friends:\n        count += problem_name.count(friend)\n    if count == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\nproblem_name = input().strip()\nprint(is_contest_problem(problem_name))"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef count_primes_in_range(a, b):\n    return sum(is_prime(i) for i in range(a, b + 1))\n\ndef find_min_l(a, b, k):\n    if k == 0:\n        return 1\n    primes = [0] * (b - a + 2)\n    for i in range(a, b + 1):\n        primes[i - a + 1] = primes[i - a] + (1 if is_prime(i) else 0)\n    \n    for l in range(1, b - a + 2):\n        for x in range(a, b - l + 2):\n            if primes[x - a + l] - primes[x - a] >= k:\n                return l\n    return -1\n\na, b, k = map(int, input().split())\nprint(find_min_l(a, b, k))"}
{"solution": "def min_x(a, h, w):\n    def check(n, m):\n        return (h - n * a) / (n + 1) >= 0 and (w - m * a) / (m + 1) >= 0\n\n    min_x = float('inf')\n    found = False\n\n    for n in range(1, h // a + 1):\n        for m in range(1, w // a + 1):\n            if check(n, m):\n                x1 = (h - n * a) / (n + 1)\n                x2 = (w - m * a) / (m + 1)\n                min_x = min(min_x, max(x1, x2))\n                found = True\n\n    if not found:\n        return -1\n    return min_x\n\na, h, w = map(int, input().split())\nresult = min_x(a, h, w)\nif result == -1:\n    print(result)\nelse:\n    print(f\"{result:.6f}\")"}
{"solution": "n = int(input())\nchapters = []\n\nfor _ in range(n):\n    l, r = map(int, input().split())\n    chapters.append((l, r))\n\nk = int(input())\n\nremaining_chapters = 0\n\nfor l, r in chapters:\n    if k <= r:\n        remaining_chapters += 1\n\nprint(remaining_chapters)"}
{"solution": "def can_form_codeforces(banner):\n    target = \"CODEFORCES\"\n    n = len(banner)\n    m = len(target)\n    \n    if n < m:\n        return \"NO\"\n    \n    for i in range(m + 1):\n        prefix = target[:i]\n        suffix = target[i:]\n        if banner.startswith(prefix) and banner.endswith(suffix):\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nbanner = input().strip()\n\n# Print output\nprint(can_form_codeforces(banner))"}
{"solution": "def min_triangulation_weight(n):\n    # Initialize the dp array\n    dp = [[float('inf')] * n for _ in range(n)]\n    \n    # Base case: a triangle has no need to be divided\n    for i in range(n - 1):\n        dp[i][i + 1] = 0\n    dp[n - 1][0] = 0\n    \n    # Fill the dp array\n    for length in range(2, n):\n        for i in range(n):\n            j = (i + length) % n\n            for k in range(i + 1, j):\n                k = k % n\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + (i + 1) * (k + 1) * (j + 1))\n    \n    # The result is the minimum weight triangulation of the whole polygon\n    return dp[0][n - 1]\n\n# Read input\nn = int(input().strip())\n\n# Print the result\nprint(min_triangulation_weight(n))"}
{"solution": "def count_digits(n):\n    digits = 0\n    length = 1\n    start = 1\n    while start <= n:\n        end = min(n, start * 10 - 1)\n        digits += (end - start + 1) * length\n        length += 1\n        start *= 10\n    return digits\n\nn = int(input())\nprint(count_digits(n))"}
{"solution": "def find_winning_color(n, A, cars):\n    from collections import defaultdict\n\n    # Count occurrences of each color\n    color_count = defaultdict(int)\n    for color in cars:\n        color_count[color] += 1\n\n    # Initialize counters for Alice's color and other colors\n    cnt_A = 0\n    cnt_B = defaultdict(int)\n\n    # Iterate through the cars and update counts\n    for color in cars:\n        if color == A:\n            cnt_A += 1\n        else:\n            cnt_B[color] += 1\n\n        # Check if any color B has cnt_B >= cnt_A at every point\n        for color_B in cnt_B:\n            if cnt_B[color_B] >= cnt_A:\n                return color_B\n\n    return -1\n\n# Read input\nn, A = map(int, input().split())\ncars = list(map(int, input().split()))\n\n# Find and print the winning color\nprint(find_winning_color(n, A, cars))"}
{"solution": "# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate the minimum length required\nmin_length = sum(a) + (n - 1)\n\n# Check if the minimum length matches the given length\nif min_length == x:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_coins(n, S):\n    # The largest coin value we have is n\n    max_coin_value = n\n    \n    # The minimum number of coins required to get sum S\n    min_coins_required = S // max_coin_value\n    \n    # If there is a remainder, we need one more coin\n    if S % max_coin_value != 0:\n        min_coins_required += 1\n    \n    return min_coins_required\n\n# Read input\nn, S = map(int, input().split())\n\n# Calculate and print the result\nprint(min_coins(n, S))"}
{"solution": "def smallest_palindrome(s):\n    from collections import Counter\n\n    n = len(s)\n    count = Counter(s)\n    odd_count = sum(1 for v in count.values() if v % 2 != 0)\n\n    if odd_count > 1:\n        return \"\"\n\n    half = []\n    middle = \"\"\n    for char in sorted(count):\n        if count[char] % 2 != 0:\n            middle = char\n        half.extend(char * (count[char] // 2))\n\n    half = ''.join(half)\n    return half + middle + half[::-1]\n\ns = input().strip()\nprint(smallest_palindrome(s))"}
{"solution": "# Define the weights of the pieces\nweights = {\n    'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n    'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n}\n\n# Initialize the weights for white and black\nwhite_weight = 0\nblack_weight = 0\n\n# Read the board input\nboard = [input().strip() for _ in range(8)]\n\n# Calculate the weights\nfor row in board:\n    for piece in row:\n        if piece in weights:\n            if piece.isupper():\n                white_weight += weights[piece]\n            else:\n                black_weight += weights[piece]\n\n# Determine the result\nif white_weight > black_weight:\n    print(\"White\")\nelif black_weight > white_weight:\n    print(\"Black\")\nelse:\n    print(\"Draw\")"}
{"solution": "from collections import deque\n\ndef solve_sugoroku(N, M, S):\n    # Initialize the queue for BFS\n    queue = deque([(0, [])])\n    visited = [False] * (N + 1)\n    visited[0] = True\n    \n    while queue:\n        current_square, path = queue.popleft()\n        \n        # Try all possible moves from the current square\n        for move in range(1, M + 1):\n            next_square = current_square + move\n            \n            if next_square == N:\n                print(\" \".join(map(str, path + [move])))\n                return\n            \n            if next_square < N and not visited[next_square] and S[next_square] == '0':\n                visited[next_square] = True\n                queue.append((next_square, path + [move]))\n    \n    print(-1)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nS = data[2]\n\nsolve_sugoroku(N, M, S)"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    K = int(data[0])\n    X = int(data[1])\n    Y = int(data[2])\n    \n    if (X + Y) % 2 != K % 2:\n        print(-1)\n        return\n    \n    steps = []\n    current_x, current_y = 0, 0\n    \n    while abs(current_x - X) + abs(current_y - Y) > K:\n        if abs(X - current_x) > abs(Y - current_y):\n            if X > current_x:\n                current_x += K\n            else:\n                current_x -= K\n        else:\n            if Y > current_y:\n                current_y += K\n            else:\n                current_y -= K\n        steps.append((current_x, current_y))\n    \n    if current_x != X or current_y != Y:\n        dx = X - current_x\n        dy = Y - current_y\n        if abs(dx) + abs(dy) == K:\n            steps.append((X, Y))\n        else:\n            if abs(dx) > abs(dy):\n                if dx > 0:\n                    steps.append((current_x + dx, current_y))\n                else:\n                    steps.append((current_x + dx, current_y))\n            else:\n                if dy > 0:\n                    steps.append((current_x, current_y + dy))\n                else:\n                    steps.append((current_x, current_y + dy))\n            steps.append((X, Y))\n    \n    print(len(steps))\n    for step in steps:\n        print(step[0], step[1])\n\nsolve()"}
{"solution": "def count_ways(n):\n    count = 0\n    for a in range(1, n + 1):\n        for k in range(2, n + 1):\n            b = a * k\n            c = b * k\n            d = c * k\n            if d > n:\n                break\n            if d <= n:\n                count += 1\n    return count\n\ndef find_min_n(m):\n    left, right = 1, 10**18\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if count_ways(mid) == m:\n            result = mid\n            right = mid - 1\n        elif count_ways(mid) < m:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result\n\nm = int(input().strip())\nprint(find_min_n(m))"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    \n    if d >= r1 + r2:\n        return 0.0\n    if d <= abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n    \n    r1_sq = r1 ** 2\n    r2_sq = r2 ** 2\n    \n    part1 = r1_sq * math.acos((d ** 2 + r1_sq - r2_sq) / (2 * d * r1))\n    part2 = r2_sq * math.acos((d ** 2 + r2_sq - r1_sq) / (2 * d * r2))\n    part3 = 0.5 * math.sqrt((-d + r1 + r2) * (d + r1 - r2) * (d - r1 + r2) * (d + r1 + r2))\n    \n    return part1 + part2 - part3\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\narea = circle_intersection_area(x1, y1, r1, x2, y2, r2)\nprint(f\"{area:.20f}\")"}
{"solution": "def minimize_n(v):\n    if v == 1:\n        return 1\n    for x in range(2, v):\n        if v % x != 0:\n            return 1\n    return v\n\nv = int(input())\nprint(minimize_n(v))"}
{"solution": "import sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\np = list(map(int, data[1:n]))\na = list(map(int, data[n:]))\n\n# Create adjacency list for the tree\nadj = defaultdict(list)\nfor i in range(2, n + 1):\n    adj[p[i - 2]].append(i)\n\n# Calculate the number of citizens in each subtree\nsubtree_citizens = [0] * (n + 1)\nfor i in range(1, n + 1):\n    subtree_citizens[i] = a[i - 1]\n\n# Post-order DFS to calculate subtree citizens\ndef dfs(node):\n    total = subtree_citizens[node]\n    for neighbor in adj[node]:\n        total += dfs(neighbor)\n    subtree_citizens[node] = total\n    return total\n\ndfs(1)\n\n# Find the maximum citizens in any subtree\nmax_citizens = max(subtree_citizens[1:])\n\nprint(max_citizens)"}
{"solution": "def count_possible_words(n, S, T):\n    count = 0\n    for i in range(n + 1):\n        for j in range(n + 1):\n            if i != j:\n                W1 = S[:i] + S[i:]\n                W2 = T[:j] + T[j:]\n                if W1 == W2:\n                    count += 1\n    return count\n\n# Read input\nn = int(input().strip())\nS = input().strip()\nT = input().strip()\n\n# Calculate and print the result\nprint(count_possible_words(n, S, T))"}
{"solution": "import sys\nimport collections\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nstrengths = list(map(int, data[1:n+1]))\nedges = [(int(data[i]), int(data[i+1])) for i in range(n+1, len(data), 2)]\n\n# Create adjacency list\nadj = collections.defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n# BFS to find the maximum strength in the tree\ndef bfs(start):\n    visited = [False] * (n + 1)\n    queue = collections.deque([start])\n    visited[start] = True\n    max_strength = strengths[start - 1]\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                max_strength = max(max_strength, strengths[neighbor - 1])\n    \n    return max_strength\n\n# Since the graph is connected, we can start BFS from any node, here we start from node 1\nresult = bfs(1)\nprint(result)"}
{"solution": "def max_groups(n, m):\n    if m == 0:\n        return 1\n    elif m == n:\n        return 0\n    else:\n        return min(m, n - m)\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(max_groups(n, m))"}
{"solution": "def minimum_shovels(k, r):\n    for i in range(1, 11):\n        if (k * i) % 10 == 0 or (k * i) % 10 == r:\n            return i\n\n# Read input\nk, r = map(int, input().split())\n\n# Print the result\nprint(minimum_shovels(k, r))"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, 0\n    min_col, max_col = m, 0\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # Check if the bounding box forms a solid rectangle\n    for i in range(min_row, max_row + 1):\n        for j in range(min_col, max_col + 1):\n            if grid[i][j] != 'X':\n                return \"NO\"\n    \n    # Check if the bounding box can be doubled to form a rectangle\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    if (height * 2 <= n and width <= m) or (height <= n and width * 2 <= m):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "def min_segments(points):\n    points.sort()\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n\n    if (x1 == x2 == x3) or (y1 == y2 == y3):\n        return 1\n    elif (x1 == x2 and y2 == y3) or (y1 == y2 and x2 == x3):\n        return 2\n    else:\n        return 3\n\npoints = [tuple(map(int, input().split())) for _ in range(3)]\nprint(min_segments(points))"}
{"solution": "def build_k_regular_graph(k):\n    if k == 1:\n        print(\"YES\")\n        print(\"2 1\")\n        print(\"1 2\")\n        return\n    \n    if k % 2 != 0:\n        print(\"NO\")\n        return\n    \n    n = k + 2\n    m = (k * n) // 2\n    edges = []\n    \n    for i in range(1, n - 1):\n        for j in range(i + 1, n):\n            if len(edges) == m:\n                break\n            edges.append((i, j))\n        if len(edges) == m:\n            break\n    \n    if len(edges) < m:\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    print(n, m)\n    for edge in edges:\n        print(edge[0], edge[1])\n\nk = int(input().strip())\nbuild_k_regular_graph(k)"}
{"solution": "def count_occurrences(s, t, l, r):\n    substring = s[l-1:r]\n    count = 0\n    t_len = len(t)\n    for i in range(len(substring) - t_len + 1):\n        if substring[i:i + t_len] == t:\n            count += 1\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    q = int(data[2])\n    \n    s = data[3]\n    t = data[4]\n    \n    queries = []\n    index = 5\n    for _ in range(q):\n        l = int(data[index])\n        r = int(data[index + 1])\n        queries.append((l, r))\n        index += 2\n    \n    results = []\n    for l, r in queries:\n        results.append(count_occurrences(s, t, l, r))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 1000000007\n\ndef count_paths(n, k, d):\n    dp = [[0 for _ in range(2)] for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if i - j >= 0:\n                if j < d:\n                    dp[i][0] = (dp[i][0] + dp[i - j][0]) % MOD\n                    dp[i][1] = (dp[i][1] + dp[i - j][1]) % MOD\n                else:\n                    dp[i][1] = (dp[i][1] + dp[i - j][0] + dp[i - j][1]) % MOD\n\n    return dp[n][1]\n\nif __name__ == \"__main__\":\n    n, k, d = map(int, input().split())\n    print(count_paths(n, k, d))"}
{"solution": "n = int(input())\nrow = input().strip()\n\ngroups = []\ncount = 0\n\nfor char in row:\n    if char == 'B':\n        count += 1\n    else:\n        if count > 0:\n            groups.append(count)\n            count = 0\n\nif count > 0:\n    groups.append(count)\n\nprint(len(groups))\nif groups:\n    print(' '.join(map(str, groups)))"}
{"solution": "def process_bracket_sequence(n, m, p, brackets, operations):\n    stack = []\n    pair = [-1] * n\n    for i in range(n):\n        if brackets[i] == '(':\n            stack.append(i)\n        else:\n            j = stack.pop()\n            pair[i] = j\n            pair[j] = i\n\n    cursor = p - 1\n    deleted = [False] * n\n\n    for op in operations:\n        if op == 'L':\n            cursor -= 1\n            while deleted[cursor]:\n                cursor -= 1\n        elif op == 'R':\n            cursor += 1\n            while deleted[cursor]:\n                cursor += 1\n        elif op == 'D':\n            left = min(cursor, pair[cursor])\n            right = max(cursor, pair[cursor])\n            for i in range(left, right + 1):\n                deleted[i] = True\n            cursor = right + 1\n            while cursor < n and deleted[cursor]:\n                cursor += 1\n            if cursor == n:\n                cursor = left - 1\n                while deleted[cursor]:\n                    cursor -= 1\n\n    result = []\n    for i in range(n):\n        if not deleted[i]:\n            result.append(brackets[i])\n\n    return ''.join(result)\n\n# Read input\nn, m, p = map(int, input().split())\nbrackets = input().strip()\noperations = input().strip()\n\n# Process the bracket sequence\nresult = process_bracket_sequence(n, m, p, brackets, operations)\n\n# Print the result\nprint(result)"}
{"solution": "def find_possible_y(n, queries):\n    lower_bound = -2 * 10**9\n    upper_bound = 2 * 10**9\n\n    for query in queries:\n        sign, x, answer = query.split()\n        x = int(x)\n        if answer == 'Y':\n            if sign == '>':\n                lower_bound = max(lower_bound, x + 1)\n            elif sign == '>=':\n                lower_bound = max(lower_bound, x)\n            elif sign == '<':\n                upper_bound = min(upper_bound, x - 1)\n            elif sign == '<=':\n                upper_bound = min(upper_bound, x)\n        else:\n            if sign == '>':\n                upper_bound = min(upper_bound, x)\n            elif sign == '>=':\n                upper_bound = min(upper_bound, x - 1)\n            elif sign == '<':\n                lower_bound = max(lower_bound, x)\n            elif sign == '<=':\n                lower_bound = max(lower_bound, x + 1)\n\n    if lower_bound <= upper_bound:\n        return lower_bound\n    else:\n        return \"Impossible\"\n\n# Read input\nn = int(input().strip())\nqueries = [input().strip() for _ in range(n)]\n\n# Find and print the possible y\nresult = find_possible_y(n, queries)\nprint(result)"}
{"solution": "import math\n\ndef count_periods(a, b):\n    n = a + b\n    periods = set()\n    \n    for k in range(1, int(math.sqrt(n)) + 1):\n        if n % k == 0:\n            periods.add(k)\n            periods.add(n // k)\n    \n    return len(periods)\n\n# Read input\na, b = map(int, input().split())\n\n# Calculate and print the number of different periods\nprint(count_periods(a, b))"}
{"solution": "def generate_names(n, k, notes):\n    names = []\n    for i in range(n):\n        names.append(chr(65 + i) + 'a')  # Generate unique names like Aa, Ba, Ca, etc.\n\n    for i in range(n - k + 1):\n        if notes[i] == \"NO\":\n            names[i + k - 1] = names[i]  # Make the last name in the group same as the first to ensure \"NO\"\n\n    return names\n\n# Read input\nn, k = map(int, input().split())\nnotes = input().split()\n\n# Generate and print names\nnames = generate_names(n, k, notes)\nprint(\" \".join(names))"}
{"solution": "def min_operations_to_equal(a, b):\n    def reduce_to_base(n):\n        count = 0\n        while n % 2 == 0:\n            n //= 2\n            count += 1\n        while n % 3 == 0:\n            n //= 3\n            count += 1\n        while n % 5 == 0:\n            n //= 5\n            count += 1\n        return n, count\n\n    base_a, count_a = reduce_to_base(a)\n    base_b, count_b = reduce_to_base(b)\n\n    if base_a != base_b:\n        return -1\n    else:\n        return abs(count_a - count_b)\n\n# Read input\na, b = map(int, input().split())\n\n# Get the result\nresult = min_operations_to_equal(a, b)\n\n# Print the result\nprint(result)"}
{"solution": "def min_cost_to_palindrome(n, a, b, c):\n    cost = 0\n    for i in range(n // 2):\n        left = c[i]\n        right = c[n - i - 1]\n        \n        if left == 2 and right == 2:\n            cost += 2 * min(a, b)\n        elif left == 2:\n            cost += a if right == 0 else b\n        elif right == 2:\n            cost += a if left == 0 else b\n        elif left != right:\n            return -1\n    \n    if n % 2 == 1 and c[n // 2] == 2:\n        cost += min(a, b)\n    \n    return cost\n\n# Read input\nn, a, b = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_cost_to_palindrome(n, a, b, c))"}
{"solution": "def paint_cube(k):\n    if k == 1:\n        print(-1)\n        return\n    \n    for z in range(k):\n        for y in range(k):\n            row = \"\"\n            for x in range(k):\n                if (x + y + z) % 2 == 0:\n                    row += \"b\"\n                else:\n                    row += \"w\"\n            print(row)\n        if z != k - 1:\n            print()\n\n# Read input\nk = int(input().strip())\n\n# Paint the cube\npaint_cube(k)"}
{"solution": "def is_lovely(x):\n    a = 2\n    while a * a <= x:\n        if x % (a * a) == 0:\n            return False\n        a += 1\n    return True\n\ndef largest_lovely_divisor(n):\n    for i in range(n, 0, -1):\n        if n % i == 0 and is_lovely(i):\n            return i\n\nn = int(input())\nprint(largest_lovely_divisor(n))"}
{"solution": "n = int(input())\nseating = input().strip()\n\ndef is_maximal_seating(n, seating):\n    if '11' in seating:\n        return \"No\"\n    if '000' in seating:\n        return \"No\"\n    if n > 1 and (seating[:2] == '00' or seating[-2:] == '00'):\n        return \"No\"\n    return \"Yes\"\n\nprint(is_maximal_seating(n, seating))"}
{"solution": "def find_possible_lengths(n, a):\n    possible_lengths = []\n    \n    for k in range(1, n + 1):\n        valid = True\n        for i in range(k, n):\n            if a[i] - a[i - k] != a[k] - a[0]:\n                valid = False\n                break\n        if valid:\n            possible_lengths.append(k)\n    \n    return possible_lengths\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find possible lengths\npossible_lengths = find_possible_lengths(n, a)\n\n# Print output\nprint(len(possible_lengths))\nprint(\" \".join(map(str, possible_lengths)))"}
{"solution": "def can_form_equal_teams(scores):\n    from itertools import combinations\n\n    # Generate all possible combinations of 3 participants out of 6\n    for team1 in combinations(scores, 3):\n        team1_score = sum(team1)\n        remaining_scores = scores[:]\n        for member in team1:\n            remaining_scores.remove(member)\n        team2_score = sum(remaining_scores)\n        if team1_score == team2_score:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nscores = list(map(int, input().split()))\n\n# Check if it's possible to form two teams with equal scores\nresult = can_form_equal_teams(scores)\nprint(result)"}
{"solution": "def count_2_3_integers(l, r):\n    count = 0\n    x = 1\n    while x <= r:\n        y = x\n        while y <= r:\n            if y >= l:\n                count += 1\n            y *= 3\n        x *= 2\n    return count\n\n# Read input\nl, r = map(int, input().split())\n\n# Print the result\nprint(count_2_3_integers(l, r))"}
{"solution": "def find_candies_eaten(n, k):\n    # Initialize the number of candies put in the box\n    candies_put = 0\n    # Initialize the number of candies eaten\n    candies_eaten = 0\n    \n    # Iterate through the number of actions\n    for i in range(1, n + 1):\n        # If the number of candies in the box is greater than k, Alya must have eaten a candy\n        if candies_put - candies_eaten > k:\n            candies_eaten += 1\n        else:\n            # Otherwise, Alya puts candies in the box\n            candies_put += i\n    \n    return candies_eaten\n\n# Read input\nn, k = map(int, input().split())\n\n# Find and print the number of candies eaten\nprint(find_candies_eaten(n, k))"}
{"solution": "def can_form_triangle(n, segments):\n    segments.sort()\n    for i in range(n - 2):\n        if segments[i] + segments[i + 1] > segments[i + 2]:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\nsegments = list(map(int, input().split()))\n\n# Check if a non-degenerate triangle can be formed\nresult = can_form_triangle(n, segments)\nprint(result)"}
{"solution": "def can_get_toys(x, y):\n    # Check if the number of original toys is at least 1\n    if y < 1:\n        return \"No\"\n    \n    # Check if the number of original toys is enough to produce the required copies\n    if x > 2 * (y - 1):\n        return \"No\"\n    \n    # Check if the number of copies is even\n    if x % 2 != 0:\n        return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nx, y = map(int, input().split())\n\n# Print the result\nprint(can_get_toys(x, y))"}
{"solution": "def max_total_rating(n, k, skills):\n    # Calculate initial rating\n    initial_rating = sum(skill // 10 for skill in skills)\n    \n    # Calculate the number of units needed to increase each skill to the next multiple of 10\n    units_needed = [(10 - skill % 10) % 10 for skill in skills]\n    \n    # Sort the units needed in ascending order\n    units_needed.sort()\n    \n    # Use the improvement units to maximize the rating\n    for units in units_needed:\n        if k >= units:\n            k -= units\n            initial_rating += 1\n        else:\n            break\n    \n    # Calculate the remaining possible improvements\n    remaining_improvements = sum(min(10, skill + k) // 10 - skill // 10 for skill in skills)\n    \n    return initial_rating + remaining_improvements\n\n# Read input\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Calculate and print the maximum total rating\nprint(max_total_rating(n, k, skills))"}
{"solution": "# Read input values\nn, m = map(int, input().split())\nlist1 = list(map(int, input().split()))\nlist2 = list(map(int, input().split()))\n\n# Find the smallest digit in both lists\nmin1 = min(list1)\nmin2 = min(list2)\n\n# Check if there is a common digit\ncommon_digits = set(list1) & set(list2)\n\nif common_digits:\n    # If there is a common digit, the smallest pretty integer is the smallest common digit\n    result = min(common_digits)\nelse:\n    # Otherwise, the smallest pretty integer is the smallest combination of digits from both lists\n    result = min(min1 * 10 + min2, min2 * 10 + min1)\n\n# Print the result\nprint(result)"}
{"solution": "def max_problems_solved(n, k):\n    total_time = 240 - k  # Total time available for solving problems\n    time_spent = 0\n    problems_solved = 0\n    \n    for i in range(1, n + 1):\n        time_needed = 5 * i\n        if time_spent + time_needed <= total_time:\n            time_spent += time_needed\n            problems_solved += 1\n        else:\n            break\n    \n    return problems_solved\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the result\nprint(max_problems_solved(n, k))"}
{"solution": "def max_teams(n, x, y, a):\n    a.sort()\n    count = 0\n\n    for pages in a:\n        if pages <= y:\n            y -= pages\n            count += 1\n        else:\n            pages -= y\n            y = 0\n            if pages <= 2 * x:\n                x -= (pages + 1) // 2\n                count += 1\n            else:\n                break\n\n    return count\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\ny = int(data[2])\na = list(map(int, data[3:]))\n\n# Calculate and print the result\nprint(max_teams(n, x, y, a))"}
{"solution": "import math\n\ndef count_distinct_numbers(b):\n    distinct_numbers = set()\n    for i in range(1, int(math.sqrt(b)) + 1):\n        if b % i == 0:\n            distinct_numbers.add(i)\n            distinct_numbers.add(b // i)\n    return len(distinct_numbers)\n\nb = int(input().strip())\nprint(count_distinct_numbers(b))"}
{"solution": "def count_fall_positions(n, bumpers):\n    left_fall = 0\n    right_fall = 0\n\n    # Count positions where the ball falls to the left\n    for i in range(n):\n        if bumpers[i] == '>':\n            break\n        left_fall += 1\n\n    # Count positions where the ball falls to the right\n    for i in range(n-1, -1, -1):\n        if bumpers[i] == '<':\n            break\n        right_fall += 1\n\n    return left_fall + right_fall\n\n# Read input\nn = int(input())\nbumpers = input().strip()\n\n# Calculate and print the result\nprint(count_fall_positions(n, bumpers))"}
{"solution": "def max_total_area(n, lengths):\n    from collections import Counter\n\n    # Count the frequency of each length\n    count = Counter(lengths)\n    \n    # Create a list to store the possible lengths of sides\n    sides = []\n    \n    # Check each length and its frequency\n    for length in sorted(count.keys(), reverse=True):\n        while count[length] >= 2:\n            sides.append(length)\n            count[length] -= 2\n        if count[length] == 1 and count[length - 1] > 0:\n            sides.append(length - 1)\n            count[length] -= 1\n            count[length - 1] -= 1\n    \n    # Calculate the maximum total area\n    total_area = 0\n    for i in range(0, len(sides) - 1, 2):\n        total_area += sides[i] * sides[i + 1]\n    \n    return total_area\n\n# Read input\nn = int(input())\nlengths = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_total_area(n, lengths))"}
{"solution": "def min_sum_of_numbers(n, strings):\n    from collections import defaultdict\n    import heapq\n\n    # Frequency of each character in each position\n    freq = defaultdict(int)\n    leading = set()\n\n    for s in strings:\n        leading.add(s[0])\n        for i, char in enumerate(s[::-1]):\n            freq[char] += 10 ** i\n\n    # Create a min-heap based on frequency\n    heap = []\n    for char, value in freq.items():\n        heapq.heappush(heap, (value, char))\n\n    # Assign digits from 0 to 9\n    digit_map = {}\n    available_digits = list(range(10))\n    while heap:\n        value, char = heapq.heappop(heap)\n        if char in leading and available_digits[0] == 0:\n            # Skip 0 if it's a leading character\n            digit_map[char] = available_digits.pop(1)\n        else:\n            digit_map[char] = available_digits.pop(0)\n\n    # Calculate the minimum sum\n    min_sum = 0\n    for s in strings:\n        num = int(''.join(str(digit_map[char]) for char in s))\n        min_sum += num\n\n    return min_sum\n\n# Read input\nn = int(input().strip())\nstrings = [input().strip() for _ in range(n)]\n\n# Calculate and print the result\nprint(min_sum_of_numbers(n, strings))"}
{"solution": "def max_teams(n, m):\n    # Initialize the number of teams to 0\n    teams = 0\n    \n    # Loop until we can't form any more teams\n    while n > 0 and m > 0:\n        if n > m:\n            # If there are more experienced participants, form a team of (XP, XP, NB)\n            if n >= 2 and m >= 1:\n                n -= 2\n                m -= 1\n                teams += 1\n            else:\n                break\n        else:\n            # If there are more or equal newbies, form a team of (XP, NB, NB)\n            if n >= 1 and m >= 2:\n                n -= 1\n                m -= 2\n                teams += 1\n            else:\n                break\n    \n    return teams\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    ab_found = False\n    ba_found = False\n\n    for i in range(len(s) - 1):\n        if s[i:i+2] == \"AB\":\n            if ba_found:\n                return \"YES\"\n            ab_found = True\n            i += 1\n        elif s[i:i+2] == \"BA\":\n            if ab_found:\n                return \"YES\"\n            ba_found = True\n            i += 1\n\n    ab_found = False\n    ba_found = False\n\n    for i in range(len(s) - 1):\n        if s[i:i+2] == \"BA\":\n            if ab_found:\n                return \"YES\"\n            ba_found = True\n            i += 1\n        elif s[i:i+2] == \"AB\":\n            if ba_found:\n                return \"YES\"\n            ab_found = True\n            i += 1\n\n    return \"NO\"\n\ns = input().strip()\nprint(check_substrings(s))"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:n+1]))\n    k = int(data[n+1])\n    b = list(map(int, data[n+2:n+2+k]))\n    \n    if sum(a) != sum(b):\n        print(\"NO\")\n        return\n    \n    actions = []\n    i, j = 0, 0\n    \n    while i < n and j < k:\n        current_sum = 0\n        start = i\n        while i < n and current_sum < b[j]:\n            current_sum += a[i]\n            i += 1\n        if current_sum != b[j]:\n            print(\"NO\")\n            return\n        if i - start > 1:\n            max_index = start + a[start:i].index(max(a[start:i]))\n            for idx in range(max_index - 1, start - 1, -1):\n                actions.append((idx + 1, 'R'))\n            for idx in range(max_index + 1, i):\n                actions.append((max_index + 1, 'L'))\n        j += 1\n    \n    if j != k:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for action in actions:\n            print(action[0], action[1])"}
{"solution": "from itertools import permutations\n\ndef ccw(A, B, C):\n    return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])\n\ndef intersect(A, B, C, D):\n    return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D)\n\ndef is_valid_matching(rebels, bases, matching):\n    for i in range(len(matching)):\n        for j in range(i + 1, len(matching)):\n            if intersect(rebels[i], bases[matching[i]], rebels[j], bases[matching[j]]):\n                return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    R = int(data[0])\n    B = int(data[1])\n    \n    rebels = []\n    bases = []\n    \n    index = 2\n    for _ in range(R):\n        x = int(data[index])\n        y = int(data[index + 1])\n        rebels.append((x, y))\n        index += 2\n    \n    for _ in range(B):\n        x = int(data[index])\n        y = int(data[index + 1])\n        bases.append((x, y))\n        index += 2\n    \n    if R != B:\n        print(\"No\")\n        return\n    \n    for perm in permutations(range(B)):\n        if is_valid_matching(rebels, bases, perm):\n            print(\"Yes\")\n            return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_power_of_two(n, sequence):\n    def largest_power_of_two(x):\n        power = 1\n        while x % 2 == 0:\n            x //= 2\n            power *= 2\n        return power\n\n    max_power = 1\n    for num in sequence:\n        max_power = max(max_power, largest_power_of_two(num))\n\n    count = sum(1 for num in sequence if num % max_power == 0)\n    \n    return max_power, count\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Get the result\nresult = max_power_of_two(n, sequence)\n\n# Print the result\nprint(result[0], result[1])"}
{"solution": "def min_clicks(n, m):\n    from collections import deque\n\n    queue = deque([(n, 0)])\n    visited = set()\n    visited.add(n)\n\n    while queue:\n        current, clicks = queue.popleft()\n\n        if current == m:\n            return clicks\n\n        if current * 2 <= 10000 and current * 2 not in visited:\n            queue.append((current * 2, clicks + 1))\n            visited.add(current * 2)\n\n        if current - 1 > 0 and current - 1 not in visited:\n            queue.append((current - 1, clicks + 1))\n            visited.add(current - 1)\n\nn, m = map(int, input().split())\nprint(min_clicks(n, m))"}
{"solution": "def is_tree(n, segments):\n    from collections import defaultdict, deque\n\n    def intersect(s1, s2):\n        l1, r1 = s1\n        l2, r2 = s2\n        return l1 < l2 < r1 < r2 or l2 < l1 < r2 < r1\n\n    graph = defaultdict(list)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if intersect(segments[i], segments[j]) or intersect(segments[j], segments[i]):\n                graph[i].append(j)\n                graph[j].append(i)\n\n    visited = [False] * n\n    parent = [-1] * n\n\n    def bfs(start):\n        queue = deque([start])\n        visited[start] = True\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n                elif parent[node] != neighbor:\n                    return False\n        return True\n\n    if not bfs(0):\n        return \"NO\"\n    if not all(visited):\n        return \"NO\"\n    return \"YES\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nsegments = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n)]\n\n# Determine if the graph is a tree\nresult = is_tree(n, segments)\nprint(result)"}
{"solution": "def longest_ddos_period(n, requests):\n    max_length = 0\n    for start in range(n):\n        total_requests = 0\n        for end in range(start, n):\n            total_requests += requests[end]\n            time_period = end - start + 1\n            if total_requests > 100 * time_period:\n                max_length = max(max_length, time_period)\n    return max_length\n\n# Read input\nn = int(input())\nrequests = list(map(int, input().split()))\n\n# Find and print the length of the longest DDoS period\nprint(longest_ddos_period(n, requests))"}
{"solution": "def can_dissatisfaction_be_k(n, k, sequence):\n    max_dissatisfaction = 0\n    current_dissatisfaction = 0\n\n    for char in sequence:\n        if char == 'N':\n            current_dissatisfaction += 1\n        else:\n            max_dissatisfaction = max(max_dissatisfaction, current_dissatisfaction)\n            current_dissatisfaction = 0\n\n    max_dissatisfaction = max(max_dissatisfaction, current_dissatisfaction)\n\n    if max_dissatisfaction >= k:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n# Read input\nn, k = map(int, input().split())\nsequence = input().strip()\n\n# Check dissatisfaction\ncan_dissatisfaction_be_k(n, k, sequence)"}
{"solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    N = int(data[0])\n    X = int(data[1])\n    D = int(data[2])\n    \n    if D == 0:\n        if X == 0:\n            print(1)\n        else:\n            print(N + 1)\n        return\n    \n    from math import gcd\n    from collections import defaultdict\n    \n    g = gcd(D, N)\n    possible_values = defaultdict(set)\n    \n    for k in range(N + 1):\n        remainder = (k * X) % g\n        sum_k = k * (2 * X + (k - 1) * D) // 2\n        possible_values[remainder].add(sum_k)\n    \n    result = 0\n    for values in possible_values.values():\n        result += len(values)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\nperformed_good = False\n\nfor _ in range(n):\n    handle, before, after = input().split()\n    before = int(before)\n    after = int(after)\n    \n    if before >= 2400 and after > before:\n        performed_good = True\n        break\n\nif performed_good:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_missed_trains(s):\n    # Convert binary string to integer\n    s_int = int(s, 2)\n    \n    # Initialize count of missed trains\n    count = 0\n    \n    # Initialize the departure time of the first train\n    departure_time = 1\n    \n    # Count the number of trains that have departed strictly before time s\n    while departure_time < s_int:\n        count += 1\n        departure_time *= 4\n    \n    return count\n\n# Read input\ns = input().strip()\n\n# Calculate and print the number of missed trains\nprint(count_missed_trains(s))"}
{"solution": "def min_rows_for_mirroring(n, m, matrix):\n    for x in range(1, n + 1):\n        valid = True\n        for i in range(x):\n            for j in range(m):\n                if matrix[i][j] != matrix[n - x + i][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return x\n    return n\n\n# Read input\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Find and print the minimum number of rows of matrix b\nprint(min_rows_for_mirroring(n, m, matrix))"}
{"solution": "def max_orders(n, orders):\n    # Sort orders by their end time\n    orders.sort(key=lambda x: x[1])\n    \n    count = 0\n    last_end_time = 0\n    \n    for order in orders:\n        if order[0] > last_end_time:\n            count += 1\n            last_end_time = order[1]\n    \n    return count\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\norders = []\n\nfor i in range(n):\n    l = int(data[2 * i + 1])\n    r = int(data[2 * i + 2])\n    orders.append((l, r))\n\n# Get the result and print it\nresult = max_orders(n, orders)\nprint(result)"}
{"solution": "def can_rearrange(n, k, x, y):\n    # Initialize the current streaks of tables and formulas\n    current_tables = 0\n    current_formulas = 0\n    \n    for i in range(n):\n        # Add the current page's tables and formulas to the streaks\n        current_tables += x[i]\n        current_formulas += y[i]\n        \n        # Check if the current streaks exceed the limit\n        if current_tables > k and current_formulas > k:\n            return \"NO\"\n        \n        # If tables exceed the limit, reset the tables streak\n        if current_tables > k:\n            current_tables = x[i]\n            current_formulas = 0\n        \n        # If formulas exceed the limit, reset the formulas streak\n        if current_formulas > k:\n            current_formulas = y[i]\n            current_tables = 0\n    \n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Print the result\nprint(can_rearrange(n, k, x, y))"}
{"solution": "def is_human_winner(n, k, coefficients):\n    # Check if all coefficients are already defined\n    all_defined = all(c != '?' for c in coefficients)\n    \n    if all_defined:\n        # Evaluate P(k) to check if it is zero\n        P_k = sum(int(coefficients[i]) * (k ** i) for i in range(n + 1))\n        return P_k == 0\n    \n    # If there are undefined coefficients, human can always set them to make P(k) zero\n    return True\n\n# Read input\nn, k = map(int, input().split())\ncoefficients = [input().strip() for _ in range(n + 1)]\n\n# Determine if human has a winning strategy\nif is_human_winner(n, k, coefficients):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def smallest_starting_number(X_2):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def primes_less_than(n):\n        primes = []\n        for i in range(2, n):\n            if is_prime(i):\n                primes.append(i)\n        return primes\n\n    primes = primes_less_than(X_2)\n    min_X0 = float('inf')\n\n    for p1 in primes:\n        for p2 in primes:\n            if p1 >= X_2 or p2 >= X_2:\n                continue\n            X1 = (X_2 // p2) * p2\n            if X1 < X_2:\n                X1 += p2\n            X0 = (X1 // p1) * p1\n            if X0 < X1:\n                X0 += p1\n            if X0 >= 3:\n                min_X0 = min(min_X0, X0)\n\n    return min_X0\n\nX_2 = int(input())\nprint(smallest_starting_number(X_2))"}
{"solution": "def min_p_binary_numbers(n, p):\n    for k in range(1, 1001):\n        m = n - k * p\n        if m < k:\n            break\n        if bin(m).count('1') <= k:\n            return k\n    return -1\n\n# Read input\nn, p = map(int, input().split())\n\n# Get the result\nresult = min_p_binary_numbers(n, p)\n\n# Print the result\nprint(result)"}
{"solution": "def minimal_possible_value(n, k, S):\n    S = list(S)\n    if k > 0 and S[0] != '1':\n        S[0] = '1'\n        k -= 1\n    for i in range(1, n):\n        if k == 0:\n            break\n        if S[i] != '0':\n            S[i] = '0'\n            k -= 1\n    return ''.join(S)\n\n# Read input\nn, k = map(int, input().split())\nS = input().strip()\n\n# Get the minimal possible value\nresult = minimal_possible_value(n, k, S)\n\n# Print the result\nprint(result)"}
{"solution": "def find_min_v(cnt_1, cnt_2, x, y):\n    def count_valid_numbers(v, prime):\n        return v // prime\n\n    def count_valid_numbers_both(v, prime1, prime2):\n        return v // (prime1 * prime2)\n\n    def is_valid(v):\n        count_x = count_valid_numbers(v, x)\n        count_y = count_valid_numbers(v, y)\n        count_both = count_valid_numbers_both(v, x, y)\n        \n        valid_for_first = v - count_x\n        valid_for_second = v - count_y\n        valid_for_both = v - count_x - count_y + count_both\n        \n        return valid_for_first >= cnt_1 and valid_for_second >= cnt_2 and valid_for_both >= cnt_1 + cnt_2\n\n    left, right = 1, 2 * (cnt_1 + cnt_2)\n    while left < right:\n        mid = (left + right) // 2\n        if is_valid(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\ncnt_1, cnt_2, x, y = map(int, input().split())\nprint(find_min_v(cnt_1, cnt_2, x, y))"}
{"solution": "def bear_walk(n, sx, sy, dx, dy, t):\n    x, y = sx, sy\n    for _ in range(t):\n        k = x + y\n        dx += k\n        dy += k\n        x = ((x + dx - 1) % n) + 1\n        y = ((y + dy - 1) % n) + 1\n    return x, y\n\n# Read input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Get the final position\nfinal_x, final_y = bear_walk(n, sx, sy, dx, dy, t)\n\n# Print the result\nprint(final_x, final_y)"}
{"solution": "def find_nice_word(s):\n    n = len(s)\n    if n < 26:\n        return -1\n\n    for i in range(n - 25):\n        substring = s[i:i+26]\n        count = [0] * 26\n        question_marks = 0\n\n        for char in substring:\n            if char == '?':\n                question_marks += 1\n            else:\n                count[ord(char) - ord('A')] += 1\n\n        if all(c <= 1 for c in count) and sum(count) + question_marks == 26:\n            result = list(s)\n            used = [False] * 26\n\n            for j in range(26):\n                if substring[j] != '?':\n                    used[ord(substring[j]) - ord('A')] = True\n\n            for j in range(26):\n                if substring[j] == '?':\n                    for k in range(26):\n                        if not used[k]:\n                            result[i + j] = chr(k + ord('A'))\n                            used[k] = True\n                            break\n\n            for j in range(n):\n                if result[j] == '?':\n                    result[j] = 'A'\n\n            return ''.join(result)\n\n    return -1\n\ns = input().strip()\nprint(find_nice_word(s))"}
{"solution": "n = int(input())\nweights = list(map(int, input().split()))\n\ncount_100 = weights.count(100)\ncount_200 = weights.count(200)\n\ntotal_weight = count_100 * 100 + count_200 * 200\n\nif total_weight % 2 != 0:\n    print(\"NO\")\nelse:\n    half_weight = total_weight // 2\n    if half_weight % 200 <= count_100 * 100 and half_weight // 200 <= count_200:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "def min_time_to_turn_off_lights(n, m, building):\n    total_time = 0\n    current_position = 0  # Start at the left stairs of the ground floor\n\n    for floor in range(n):\n        lights = building[floor]\n        leftmost = lights.find('1')\n        rightmost = lights.rfind('1')\n\n        if leftmost == -1:\n            # No lights on this floor\n            total_time += 1  # Move to the next floor\n            continue\n\n        if floor % 2 == 0:\n            # Even floor: move from left to right\n            total_time += max(rightmost, current_position) + 1\n            current_position = rightmost\n        else:\n            # Odd floor: move from right to left\n            total_time += max(m + 1 - leftmost, m + 1 - current_position) + 1\n            current_position = leftmost\n\n    return total_time\n\n# Read input\nn, m = map(int, input().split())\nbuilding = [input().strip() for _ in range(n)]\n\n# Calculate and print the result\nprint(min_time_to_turn_off_lights(n, m, building))"}
{"solution": "def find_min_cost(n, costs, next_rooms):\n    visited = [False] * n\n    in_cycle = [False] * n\n    min_cost = 0\n\n    def dfs(node):\n        stack = []\n        while not visited[node]:\n            visited[node] = True\n            stack.append(node)\n            node = next_rooms[node] - 1\n\n        if in_cycle[node]:\n            return\n\n        cycle_cost = float('inf')\n        while stack:\n            current = stack.pop()\n            in_cycle[current] = True\n            cycle_cost = min(cycle_cost, costs[current])\n            if current == node:\n                break\n\n        nonlocal min_cost\n        min_cost += cycle_cost\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n\n    return min_cost\n\n# Read input\nn = int(input().strip())\ncosts = list(map(int, input().strip().split()))\nnext_rooms = list(map(int, input().strip().split()))\n\n# Calculate and print the result\nprint(find_min_cost(n, costs, next_rooms))"}
{"solution": "def find_entrance(n, a, b):\n    return (a + b - 1) % n + 1\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(find_entrance(n, a, b))"}
{"solution": "def min_arithmetic_progressions(n, a):\n    def is_arithmetic_progression(seq):\n        if len(seq) <= 1:\n            return True\n        diff = seq[1] - seq[0]\n        for i in range(1, len(seq)):\n            if seq[i] - seq[i - 1] != diff:\n                return False\n        return True\n\n    count = 0\n    i = 0\n    while i < n:\n        if a[i] == -1:\n            i += 1\n            continue\n        j = i\n        while j < n and (a[j] == -1 or (j > i and (a[j] - a[j - 1] == a[i + 1] - a[i] if a[i + 1] != -1 else True))):\n            j += 1\n        count += 1\n        i = j\n\n    print(count)\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Call the function\nmin_arithmetic_progressions(n, a)"}
{"solution": "def max_beauty(n, k, s):\n    def max_length_with_char(char):\n        left = 0\n        max_len = 0\n        count = 0\n        \n        for right in range(n):\n            if s[right] != char:\n                count += 1\n            \n            while count > k:\n                if s[left] != char:\n                    count -= 1\n                left += 1\n            \n            max_len = max(max_len, right - left + 1)\n        \n        return max_len\n    \n    return max(max_length_with_char('a'), max_length_with_char('b'))\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Calculate and print the result\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, a):\n    alice_seats = a[0]\n    total_seats = sum(a)\n    majority_seats = total_seats // 2 + 1\n\n    coalition = [1]\n    coalition_seats = alice_seats\n\n    for i in range(1, n):\n        if alice_seats >= 2 * a[i]:\n            coalition.append(i + 1)\n            coalition_seats += a[i]\n        if coalition_seats >= majority_seats:\n            break\n\n    if coalition_seats >= majority_seats:\n        print(len(coalition))\n        print(\" \".join(map(str, coalition)))\n    else:\n        print(0)\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find and print coalition\nfind_coalition(n, a)"}
{"solution": "def max_reward(n):\n    reward = 0.0\n    for i in range(1, n + 1):\n        reward += 1 / i\n    return reward\n\nn = int(input())\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "def distribute_candies(n):\n    k = 0\n    total = 0\n    candies = []\n    \n    while total + (k + 1) <= n:\n        k += 1\n        total += k\n        candies.append(k)\n    \n    if total < n:\n        candies[-1] += n - total\n    \n    print(k)\n    print(\" \".join(map(str, candies)))\n\n# Read input\nn = int(input().strip())\ndistribute_candies(n)"}
{"solution": "n = int(input())\nm = int(input())\n\nresult = m % (2 ** n)\nprint(result)"}
{"solution": "def correct_word(n, s):\n    vowels = set('aeiouy')\n    result = []\n    i = 0\n    while i < n:\n        result.append(s[i])\n        if i < n - 1 and s[i] in vowels and s[i + 1] in vowels:\n            i += 1\n        i += 1\n    return ''.join(result)\n\n# Read input\nn = int(input())\ns = input()\n\n# Get the corrected word\ncorrected_word = correct_word(n, s)\n\n# Print the result\nprint(corrected_word)"}
{"solution": "def max_students(n, a, b, seats):\n    segments = seats.split('*')\n    total_students = 0\n\n    for segment in segments:\n        length = len(segment)\n        if length == 0:\n            continue\n\n        # Calculate the number of students that can be placed in this segment\n        programmers = (length + 1) // 2\n        athletes = length // 2\n\n        if a < b:\n            programmers, athletes = athletes, programmers\n\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n\n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n\n    return total_students\n\n# Read input\nn, a, b = map(int, input().split())\nseats = input().strip()\n\n# Calculate and print the result\nprint(max_students(n, a, b, seats))"}
{"solution": "def find_xy(r):\n    for x in range(1, int(r**0.5) + 1):\n        # Calculate the value of H(x, y) for given x and solve for y\n        # H(x, y) = x^2 + 2xy + x + 1\n        # Rearrange to find y: 2xy + x = r - x^2 - x - 1\n        # 2xy = r - x^2 - x - 1\n        # y = (r - x^2 - x - 1) / (2x)\n        rhs = r - x**2 - x - 1\n        if rhs > 0 and rhs % (2 * x) == 0:\n            y = rhs // (2 * x)\n            if y > 0:\n                return x, y\n    return \"NO\"\n\n# Read input\nr = int(input().strip())\n\n# Find and print the result\nresult = find_xy(r)\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "def divide_balloons(n, a):\n    total_sum = sum(a)\n    \n    # If there's only one packet, it's impossible to divide\n    if n == 1:\n        return -1\n    \n    # Try to find a valid division\n    for i in range(1, 1 << n):\n        group1 = []\n        group2 = []\n        sum1 = 0\n        sum2 = 0\n        \n        for j in range(n):\n            if i & (1 << j):\n                group1.append(j + 1)\n                sum1 += a[j]\n            else:\n                group2.append(j + 1)\n                sum2 += a[j]\n        \n        if sum1 != sum2 and len(group1) > 0 and len(group2) > 0:\n            return (len(group1), group1)\n    \n    return -1\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\nresult = divide_balloons(n, a)\n\nif result == -1:\n    print(-1)\nelse:\n    k, indices = result\n    print(k)\n    print(\" \".join(map(str, indices)))"}
{"solution": "def split_number(n):\n    # The best way to minimize the number of different digits is to use the largest digit possible, which is 9.\n    # We will use as many 9s as possible, and if there is a remainder, we will add it as the last digit.\n    \n    # Calculate the number of 9s we can use\n    num_nines = n // 9\n    remainder = n % 9\n    \n    # If there is a remainder, we need one more digit for it\n    if remainder > 0:\n        k = num_nines + 1\n    else:\n        k = num_nines\n    \n    # Print the number of digits\n    print(k)\n    \n    # Print the digits\n    for _ in range(num_nines):\n        print(9, end=' ')\n    if remainder > 0:\n        print(remainder)\n    else:\n        print()\n\n# Read input\nn = int(input().strip())\n\n# Call the function to split the number\nsplit_number(n)"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_max_simple_subset(arr):\n    n = len(arr)\n    arr.sort()\n    max_subset = []\n    \n    for i in range(n):\n        current_subset = [arr[i]]\n        for j in range(i + 1, n):\n            valid = True\n            for k in current_subset:\n                if not is_prime(k + arr[j]):\n                    valid = False\n                    break\n            if valid:\n                current_subset.append(arr[j])\n        if len(current_subset) > len(max_subset):\n            max_subset = current_subset\n    \n    return max_subset\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum simple subset\nresult = find_max_simple_subset(a)\n\n# Output the result\nprint(len(result))\nprint(' '.join(map(str, result)))"}
{"solution": "def is_beautiful(num):\n    k = 1\n    while True:\n        beautiful_num = (2**(k+1) - 1) * (2**k - 1)\n        if beautiful_num > num:\n            break\n        if num % beautiful_num == 0:\n            return beautiful_num\n        k += 1\n    return 1\n\nn = int(input())\nprint(is_beautiful(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef is_d_magic(number, d):\n    number_str = str(number)\n    for i, digit in enumerate(number_str):\n        if (i % 2 == 1 and digit != str(d)) or (i % 2 == 0 and digit == str(d)):\n            return False\n    return True\n\ndef count_d_magic_numbers(m, d, a, b):\n    count = 0\n    for number in range(int(a), int(b) + 1):\n        if number % m == 0 and is_d_magic(number, d):\n            count = (count + 1) % MOD\n    return count\n\nif __name__ == \"__main__\":\n    m, d = map(int, input().split())\n    a = input().strip()\n    b = input().strip()\n    result = count_d_magic_numbers(m, d, a, b)\n    print(result)"}
{"solution": "def last_child(n, m, a):\n    from collections import deque\n\n    queue = deque([(i + 1, a[i]) for i in range(n)])\n    last = -1\n\n    while queue:\n        child, candies_needed = queue.popleft()\n        candies_needed -= m\n        if candies_needed > 0:\n            queue.append((child, candies_needed))\n        last = child\n\n    return last\n\n# Read input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nresult = last_child(n, m, a)\n\n# Print the result\nprint(result)"}
{"solution": "def min_bills(n):\n    denominations = [100, 20, 10, 5, 1]\n    count = 0\n    for denom in denominations:\n        count += n // denom\n        n %= denom\n    return count\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the result\nprint(min_bills(n))"}
{"solution": "MOD = 1000000007\n\ndef count_permutations(n, k):\n    # Initialize dp array\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j > 0:\n                dp[i][j] = (dp[i][j] + (i - 1) * dp[i - 2][j - 1]) % MOD\n    \n    return dp[n][k]\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the result\nprint(count_permutations(n, k))"}
{"solution": "def max_beauty(n, k, beauties, colors):\n    white_roses = []\n    orange_roses = []\n    red_roses = []\n\n    for i in range(n):\n        if colors[i] == 'W':\n            white_roses.append(beauties[i])\n        elif colors[i] == 'O':\n            orange_roses.append(beauties[i])\n        elif colors[i] == 'R':\n            red_roses.append(beauties[i])\n\n    white_roses.sort(reverse=True)\n    orange_roses.sort(reverse=True)\n    red_roses.sort(reverse=True)\n\n    max_beauty = -1\n\n    for w in range(min(k, len(white_roses)) + 1):\n        for r in range(min(k - w, len(red_roses)) + 1):\n            o = k - w - r\n            if o > len(orange_roses):\n                continue\n            if w > 0 and r > 0:\n                continue\n            total_beauty = sum(white_roses[:w]) + sum(orange_roses[:o]) + sum(red_roses[:r])\n            max_beauty = max(max_beauty, total_beauty)\n\n    return max_beauty\n\n# Read input\nn, k = map(int, input().split())\nbeauties = list(map(int, input().split()))\ncolors = input().strip()\n\n# Compute and print the result\nprint(max_beauty(n, k, beauties, colors))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef continued_fraction_to_fraction(a):\n    n = len(a)\n    num = 1\n    den = a[-1]\n    for i in range(n - 2, -1, -1):\n        num, den = den, a[i] * den + num\n    return den, num\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    p = int(data[0])\n    q = int(data[1])\n    n = int(data[2])\n    a = list(map(int, data[3:3+n]))\n    \n    num1, den1 = p, q\n    den2, num2 = continued_fraction_to_fraction(a)\n    \n    gcd1 = gcd(num1, den1)\n    gcd2 = gcd(num2, den2)\n    \n    num1 //= gcd1\n    den1 //= gcd1\n    num2 //= gcd2\n    den2 //= gcd2\n    \n    if num1 == num2 and den1 == den2:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve_expression(expression):\n    parts = expression.split('+')\n    A = len(parts[0])\n    B, C = parts[1].split('=')\n    B = len(B)\n    C = len(C)\n\n    if A + B == C:\n        print(expression)\n        return\n\n    if A + B + 1 == C - 1:\n        if A > 1:\n            print('|' * (A - 1) + '+' + '|' * B + '=' + '|' * (C + 1))\n        elif B > 1:\n            print('|' * A + '+' + '|' * (B - 1) + '=' + '|' * (C + 1))\n        else:\n            print('|' * A + '+' + '|' * B + '=' + '|' * (C + 1))\n        return\n\n    if A + B - 1 == C + 1:\n        if C > 1:\n            print('|' * (A + 1) + '+' + '|' * B + '=' + '|' * (C - 1))\n        elif B > 1:\n            print('|' * A + '+' + '|' * (B + 1) + '=' + '|' * (C - 1))\n        else:\n            print('|' * A + '+' + '|' * B + '=' + '|' * (C - 1))\n        return\n\n    print(\"Impossible\")\n\n# Read input\nexpression = input().strip()\nsolve_expression(expression)"}
{"solution": "MOD = 10**9 + 7\n\ndef count_permutations_with_oddness(n, k):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            for l in range(i):\n                if j >= abs(i - (l + 1)):\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - abs(i - (l + 1))]) % MOD\n\n    return dp[n][k]\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    n, k = map(int, input().strip().split())\n    print(count_permutations_with_oddness(n, k))"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    points = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N)]\n    \n    # Check if all points have the same parity\n    parity = (points[0][0] + points[0][1]) % 2\n    for x, y in points:\n        if (x + y) % 2 != parity:\n            print(-1)\n            return\n    \n    # Determine the number of sections m\n    m = 40\n    d = [1 << i for i in range(m)]\n    \n    print(m)\n    print(\" \".join(map(str, d)))\n    \n    for x, y in points:\n        x, y = abs(x), abs(y)\n        w = []\n        for i in range(m-1, -1, -1):\n            if x >= y:\n                if x >= d[i]:\n                    w.append('R')\n                    x -= d[i]\n                else:\n                    w.append('L')\n            else:\n                if y >= d[i]:\n                    w.append('U')\n                    y -= d[i]\n                else:\n                    w.append('D')\n        print(\"\".join(w))\n\nsolve()"}
{"solution": "def replace_fillers(n, s):\n    i = 0\n    result = []\n    while i < n:\n        if s[i:i+3] == 'ogo':\n            result.append('***')\n            i += 3\n            while i + 1 < n and s[i:i+2] == 'go':\n                i += 2\n        else:\n            result.append(s[i])\n            i += 1\n    return ''.join(result)\n\n# Read input\nn = int(input())\ns = input()\n\n# Process and print the result\nprint(replace_fillers(n, s))"}
{"solution": "MOD = 10**9 + 7\n\ndef prime_factors(x):\n    factors = set()\n    d = 2\n    while d * d <= x:\n        while (x % d) == 0:\n            factors.add(d)\n            x //= d\n        d += 1\n    if x > 1:\n        factors.add(x)\n    return factors\n\ndef g(y, p):\n    result = 1\n    while y % p == 0:\n        y //= p\n        result *= p\n    return result\n\ndef f(x, y):\n    primes = prime_factors(x)\n    result = 1\n    for p in primes:\n        result *= g(y, p)\n    return result\n\ndef calculate(x, n):\n    primes = prime_factors(x)\n    result = 1\n    for p in primes:\n        power = p\n        while power <= n:\n            result = (result * pow(p, n // power, MOD)) % MOD\n            if power > n // p:\n                break\n            power *= p\n    return result\n\nx, n = map(int, input().split())\nprint(calculate(x, n))"}
{"solution": "def s(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for s_x in range(1, 82):  # s(x) can be at most 81 (for x = 999,999,999)\n        x = b * (s_x ** a) + c\n        if 0 < x < 10**9 and s(x) == s_x:\n            solutions.append(x)\n    return solutions\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    a = int(data[0])\n    b = int(data[1])\n    c = int(data[2])\n    \n    solutions = find_solutions(a, b, c)\n    solutions.sort()\n    \n    print(len(solutions))\n    if solutions:\n        print(\" \".join(map(str, solutions)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_solvable(cube):\n    # Define the rotations that can solve the cube\n    rotations = [\n        # Front face rotations\n        [0, 1, 2, 3, 8, 9, 10, 11, 16, 17, 18, 19, 20, 21, 22, 23],\n        [0, 1, 2, 3, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23],\n        # Back face rotations\n        [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 20, 21, 22, 23],\n        [4, 5, 6, 7, 0, 1, 2, 3, 12, 13, 14, 15, 20, 21, 22, 23],\n        # Left face rotations\n        [0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23],\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 20, 21, 22, 23],\n        # Right face rotations\n        [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23],\n        [0, 1, 2, 3, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23],\n        # Top face rotations\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n        [0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23],\n        # Bottom face rotations\n        [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23],\n        [0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23]\n    ]\n\n    # Check if a rotation can solve the cube\n    for rotation in rotations:\n        if all(cube[rotation[i]] == cube[rotation[i + 1]] for i in range(0, 16, 4)):\n            return \"YES\"\n    return \"NO\"\n\n# Read input\ncube = list(map(int, input().split()))\n\n# Check if the cube can be solved with one rotation\nprint(is_solvable(cube))"}
{"solution": "def will_get_tshirt(p, s):\n    i = (s // 50) % 475\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        if 26 + i == p:\n            return True\n    return False\n\ndef min_successful_hacks(p, x, y):\n    for k in range(0, 1000):\n        for m in range(0, k + 1):\n            score = x + 100 * m - 50 * (k - m)\n            if score >= y and will_get_tshirt(p, score):\n                return m\n    return -1\n\np, x, y = map(int, input().split())\nprint(min_successful_hacks(p, x, y))"}
{"solution": "def min_distance(n, a, b, c):\n    if n == 1:\n        return 0\n    if n == 2:\n        return min(a, b)\n    \n    # For n > 2, we need to calculate the minimum distance\n    # Winnie starts at Rabbit's house\n    # He needs to visit n-1 more times\n    # We need to find the minimum distance for n-1 visits\n    # We can use dynamic programming to solve this problem\n    \n    # dp[i] will store the minimum distance to have i meals\n    dp = [float('inf')] * (n + 1)\n    dp[1] = 0\n    dp[2] = min(a, b)\n    \n    for i in range(3, n + 1):\n        dp[i] = min(dp[i-1] + a, dp[i-1] + b, dp[i-2] + a + c, dp[i-2] + b + c)\n    \n    return dp[n]\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate and print the result\nprint(min_distance(n, a, b, c))"}
{"solution": "# Read input\nx1, x2, x3 = map(int, input().split())\n\n# Sort the coordinates\ncoordinates = sorted([x1, x2, x3])\n\n# The optimal meeting point is the median of the three points\nmeeting_point = coordinates[1]\n\n# Calculate the total distance\ntotal_distance = abs(x1 - meeting_point) + abs(x2 - meeting_point) + abs(x3 - meeting_point)\n\n# Print the result\nprint(total_distance)"}
{"solution": "def minimal_operations(n, x, arr):\n    from collections import defaultdict\n\n    original_count = defaultdict(int)\n    and_count = defaultdict(int)\n\n    for num in arr:\n        original_count[num] += 1\n        if original_count[num] > 1:\n            return 0\n\n    for num in arr:\n        and_result = num & x\n        if and_result in original_count:\n            return 1\n        and_count[and_result] += 1\n        if and_count[and_result] > 1:\n            return 2\n\n    return -1\n\n# Read input\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Get the result\nresult = minimal_operations(n, x, arr)\n\n# Print the result\nprint(result)"}
{"solution": "def is_single_plus(h, w, picture):\n    def is_valid_center(x, y):\n        if picture[x][y] != '*':\n            return False\n        # Check up\n        if x == 0 or picture[x-1][y] != '*':\n            return False\n        # Check down\n        if x == h-1 or picture[x+1][y] != '*':\n            return False\n        # Check left\n        if y == 0 or picture[x][y-1] != '*':\n            return False\n        # Check right\n        if y == w-1 or picture[x][y+1] != '*':\n            return False\n        return True\n\n    def mark_plus(x, y):\n        picture[x][y] = '.'\n        # Mark up\n        i = x - 1\n        while i >= 0 and picture[i][y] == '*':\n            picture[i][y] = '.'\n            i -= 1\n        # Mark down\n        i = x + 1\n        while i < h and picture[i][y] == '*':\n            picture[i][y] = '.'\n            i += 1\n        # Mark left\n        j = y - 1\n        while j >= 0 and picture[x][j] == '*':\n            picture[x][j] = '.'\n            j -= 1\n        # Mark right\n        j = y + 1\n        while j < w and picture[x][j] == '*':\n            picture[x][j] = '.'\n            j += 1\n\n    center_found = False\n    for i in range(h):\n        for j in range(w):\n            if is_valid_center(i, j):\n                if center_found:\n                    return \"NO\"\n                center_found = True\n                mark_plus(i, j)\n\n    for i in range(h):\n        for j in range(w):\n            if picture[i][j] == '*':\n                return \"NO\"\n\n    return \"YES\" if center_found else \"NO\"\n\n# Read input\nh, w = map(int, input().split())\npicture = [list(input().strip()) for _ in range(h)]\n\n# Determine if the picture has a single \"+\" shape\nresult = is_single_plus(h, w, picture)\nprint(result)"}
{"solution": "def solve(n, a, b):\n    if (a == 1 and b == 1 and n > 1) or (a > 1 and b > 1):\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    matrix = [[0] * n for _ in range(n)]\n\n    if a == 1:\n        for i in range(1, n):\n            matrix[i][i-1] = matrix[i-1][i] = 1\n    else:\n        for i in range(n - a + 1):\n            for j in range(i + 1, n - a + 1):\n                matrix[i][j] = matrix[j][i] = 1\n\n    for row in matrix:\n        print(\"\".join(map(str, row)))\n\n# Example usage:\nn, a, b = map(int, input().split())\nsolve(n, a, b)"}
{"solution": "c, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\nrequired_finalists = n * m\nremaining_finalists = required_finalists - k\n\nif remaining_finalists <= 0:\n    print(0)\nelse:\n    main_rounds_needed = remaining_finalists // n\n    additional_rounds_needed = remaining_finalists % n\n\n    if additional_rounds_needed > 0:\n        main_rounds_needed += 1\n\n    total_problems = main_rounds_needed * c + additional_rounds_needed * d\n    print(total_problems)"}
{"solution": "def find_grid(s):\n    if len(s) != 27:\n        return \"Impossible\"\n    \n    # Create a dictionary to store the positions of each character in the string\n    pos = {}\n    for i, char in enumerate(s):\n        if char in pos:\n            pos[char].append(i)\n        else:\n            pos[char] = [i]\n    \n    # Check if there is any character that appears more than twice\n    for key in pos:\n        if len(pos[key]) > 2:\n            return \"Impossible\"\n    \n    # Try to construct the grid\n    grid = [['' for _ in range(13)] for _ in range(2)]\n    used = set()\n    \n    def is_valid(x, y):\n        return 0 <= x < 2 and 0 <= y < 13\n    \n    def dfs(x, y, idx):\n        if idx == 27:\n            return True\n        if not is_valid(x, y) or grid[x][y] != '':\n            return False\n        \n        char = s[idx]\n        if char in used:\n            return False\n        \n        grid[x][y] = char\n        used.add(char)\n        \n        # Try all 8 possible directions\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n        for dx, dy in directions:\n            if dfs(x + dx, y + dy, idx + 1):\n                return True\n        \n        # Backtrack\n        grid[x][y] = ''\n        used.remove(char)\n        return False\n    \n    # Start DFS from each possible starting position\n    for i in range(2):\n        for j in range(13):\n            if dfs(i, j, 0):\n                return '\\n'.join([''.join(row) for row in grid])\n    \n    return \"Impossible\"\n\n# Read input\ns = input().strip()\n\n# Find and print the grid\nresult = find_grid(s)\nprint(result)"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<'\n    elif y == 1:\n        return '>'\n    else:\n        log_x = math.log(x)\n        log_y = math.log(y)\n        if y * log_x < x * log_y:\n            return '<'\n        elif y * log_x > x * log_y:\n            return '>'\n        else:\n            return '='\n\nx, y = map(int, input().split())\nprint(compare_powers(x, y))"}
{"solution": "import math\n\ndef max_balloons(r, h):\n    # Calculate the number of balloons that can fit in the semicircle part\n    semicircle_balloons = (r // (r // 2)) * (r // (r // 2)) // 2\n    \n    # Calculate the number of balloons that can fit in the rectangular part\n    rectangle_balloons = (h // (r // 2)) * (r // (r // 2))\n    \n    # Total balloons is the sum of balloons in the semicircle and rectangle parts\n    total_balloons = semicircle_balloons + rectangle_balloons\n    \n    return total_balloons\n\n# Read input\nr, h = map(int, input().split())\n\n# Calculate and print the result\nprint(max_balloons(r, h))"}
{"solution": "def min_sum_after_discard(cards):\n    from collections import Counter\n    \n    card_counts = Counter(cards)\n    total_sum = sum(cards)\n    min_sum = total_sum\n    \n    for card, count in card_counts.items():\n        if count >= 2:\n            min_sum = min(min_sum, total_sum - card * min(count, 3))\n    \n    return min_sum\n\n# Read input\ncards = list(map(int, input().split()))\n\n# Calculate and print the minimum sum\nprint(min_sum_after_discard(cards))"}
{"solution": "def min_distance_to_visit_checkpoints(n, a, checkpoints):\n    checkpoints.sort()\n    if n == 1:\n        return 0\n    # Calculate the distance if we skip the first checkpoint\n    distance_skip_first = abs(a - checkpoints[1]) + abs(checkpoints[1] - checkpoints[-1])\n    # Calculate the distance if we skip the last checkpoint\n    distance_skip_last = abs(a - checkpoints[-2]) + abs(checkpoints[-2] - checkpoints[0])\n    # Return the minimum of the two distances\n    return min(distance_skip_first, distance_skip_last)\n\n# Read input\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_distance_to_visit_checkpoints(n, a, checkpoints))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_smallest_root(n):\n    for x in range(1, int(n**0.5) + 1):\n        if x**2 + sum_of_digits(x) * x == n:\n            return x\n    return -1\n\nn = int(input().strip())\nprint(find_smallest_root(n))"}
{"solution": "def time_to_bed(current_time, sleep_duration):\n    # Parse the current time\n    current_hours, current_minutes = map(int, current_time.split(':'))\n    \n    # Parse the sleep duration\n    sleep_hours, sleep_minutes = map(int, sleep_duration.split(':'))\n    \n    # Calculate the total minutes for current time and sleep duration\n    total_current_minutes = current_hours * 60 + current_minutes\n    total_sleep_minutes = sleep_hours * 60 + sleep_minutes\n    \n    # Calculate the time George went to bed in minutes\n    bed_time_minutes = total_current_minutes - total_sleep_minutes\n    \n    # If bed time is negative, it means he went to bed the previous day\n    if bed_time_minutes < 0:\n        bed_time_minutes += 24 * 60\n    \n    # Convert the bed time back to hours and minutes\n    bed_hours = bed_time_minutes // 60\n    bed_minutes = bed_time_minutes % 60\n    \n    # Format the result to \"hh:mm\"\n    bed_time = f\"{bed_hours:02}:{bed_minutes:02}\"\n    \n    return bed_time\n\n# Read input\ncurrent_time = input().strip()\nsleep_duration = input().strip()\n\n# Calculate and print the time George went to bed\nprint(time_to_bed(current_time, sleep_duration))"}
{"solution": "def find_longest_subsegment_with_max_mean(n, a):\n    max_value = max(a)\n    max_length = 0\n    current_length = 0\n\n    for value in a:\n        if value == max_value:\n            current_length += 1\n            if current_length > max_length:\n                max_length = current_length\n        else:\n            current_length = 0\n\n    return max_length\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find and print the length of the longest subsegment with maximum mean\nprint(find_longest_subsegment_with_max_mean(n, a))"}
{"solution": "MOD = 998244353\n\ndef count_ways(n, m, k):\n    # Initialize a 2D dp array with zeros\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    # Base case: 1 way to paint 1 brick with any color\n    dp[1][0] = m\n    \n    # Fill the dp table\n    for i in range(2, n + 1):\n        for j in range(k + 1):\n            dp[i][j] = dp[i - 1][j] * m % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * (m - 1)) % MOD\n    \n    return dp[n][k]\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Calculate and print the result\nprint(count_ways(n, m, k))"}
{"solution": "def is_magic_number(n):\n    s = str(n)\n    i = 0\n    while i < len(s):\n        if s[i:i+3] == '144':\n            i += 3\n        elif s[i:i+2] == '14':\n            i += 2\n        elif s[i:i+1] == '1':\n            i += 1\n        else:\n            return \"NO\"\n    return \"YES\"\n\nn = int(input())\nprint(is_magic_number(n))"}
{"solution": "def min_moves_to_corner(n, m, i, j, a, b):\n    corners = [(1, 1), (1, m), (n, 1), (n, m)]\n    min_moves = float('inf')\n    \n    for (x, y) in corners:\n        if (abs(i - x) % a == 0) and (abs(j - y) % b == 0):\n            moves_x = abs(i - x) // a\n            moves_y = abs(j - y) // b\n            if (moves_x % 2) == (moves_y % 2):\n                moves = max(moves_x, moves_y)\n                if (x + a <= n or x - a >= 1) and (y + b <= m or y - b >= 1):\n                    min_moves = min(min_moves, moves)\n    \n    if min_moves == float('inf'):\n        return \"Poor Inna and pony!\"\n    else:\n        return min_moves\n\n# Read input\nn, m, i, j, a, b = map(int, input().split())\n\n# Get the result\nresult = min_moves_to_corner(n, m, i, j, a, b)\n\n# Print the result\nprint(result)"}
{"solution": "def max_removals(s):\n    n = len(s)\n    removed = 0\n    while True:\n        to_remove = set()\n        for i in range(n):\n            if i > 0 and ord(s[i]) == ord(s[i-1]) + 1:\n                to_remove.add(i)\n            if i < n-1 and ord(s[i]) == ord(s[i+1]) + 1:\n                to_remove.add(i)\n        if not to_remove:\n            break\n        s = ''.join([s[i] for i in range(n) if i not in to_remove])\n        removed += len(to_remove)\n        n = len(s)\n    return removed\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result and print it\nresult = max_removals(s)\nprint(result)"}
{"solution": "def min_bills(n, k, denominations, q, requests):\n    results = []\n    for x in requests:\n        min_bills_needed = float('inf')\n        found = False\n        for i in range(n):\n            for j in range(i, n):\n                d1, d2 = denominations[i], denominations[j]\n                if d1 == d2:\n                    if x % d1 == 0 and x // d1 <= k:\n                        min_bills_needed = min(min_bills_needed, x // d1)\n                        found = True\n                else:\n                    for b1 in range(k + 1):\n                        if b1 * d1 > x:\n                            break\n                        remaining = x - b1 * d1\n                        if remaining % d2 == 0:\n                            b2 = remaining // d2\n                            if b1 + b2 <= k:\n                                min_bills_needed = min(min_bills_needed, b1 + b2)\n                                found = True\n        if found:\n            results.append(min_bills_needed)\n        else:\n            results.append(-1)\n    return results\n\n# Read input\nn, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\nrequests = [int(input()) for _ in range(q)]\n\n# Get results\nresults = min_bills(n, k, denominations, q, requests)\n\n# Print results\nfor result in results:\n    print(result)"}
{"solution": "def minimum_time(s, x1, x2, t1, t2, p, d):\n    if t2 <= t1:\n        return abs(x2 - x1) * t2\n\n    if d == 1:\n        if p <= x1:\n            tram_time = (x1 - p) * t1\n        else:\n            tram_time = (s - p + s + x1) * t1\n    else:\n        if p >= x1:\n            tram_time = (p - x1) * t1\n        else:\n            tram_time = (p + s + s - x1) * t1\n\n    tram_time += abs(x2 - x1) * t1\n    walk_time = abs(x2 - x1) * t2\n\n    return min(tram_time, walk_time)\n\n# Read input\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Calculate and print the result\nprint(minimum_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "def count_occurrences(n, x):\n    count = 0\n    for i in range(1, n + 1):\n        if x % i == 0 and x // i <= n:\n            count += 1\n    return count\n\n# Read input\nn, x = map(int, input().strip().split())\n\n# Get the result\nresult = count_occurrences(n, x)\n\n# Print the result\nprint(result)"}
{"solution": "def generate_password(n, k):\n    import string\n    letters = string.ascii_lowercase[:k]\n    password = []\n    \n    for i in range(n):\n        password.append(letters[i % k])\n    \n    return ''.join(password)\n\n# Read input\nn, k = map(int, input().split())\n\n# Generate and print the password\nprint(generate_password(n, k))"}
{"solution": "def find_first_collision(n, directions, positions):\n    min_time = float('inf')\n    collision_found = False\n\n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            time_to_collision = (positions[i + 1] - positions[i]) // 2\n            if time_to_collision < min_time:\n                min_time = time_to_collision\n                collision_found = True\n\n    if collision_found:\n        return min_time\n    else:\n        return -1\n\n# Read input\nn = int(input().strip())\ndirections = input().strip()\npositions = list(map(int, input().strip().split()))\n\n# Find and print the first collision time\nprint(find_first_collision(n, directions, positions))"}
{"solution": "def largest_area(n, a, b, seals):\n    max_area = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = seals[i]\n            x2, y2 = seals[j]\n\n            # Check all possible orientations and placements\n            for (w1, h1) in [(x1, y1), (y1, x1)]:\n                for (w2, h2) in [(x2, y2), (y2, x2)]:\n                    if (w1 + w2 <= a and max(h1, h2) <= b) or (w1 + w2 <= b and max(h1, h2) <= a):\n                        max_area = max(max_area, w1 * h1 + w2 * h2)\n                    if (h1 + h2 <= b and max(w1, w2) <= a) or (h1 + h2 <= a and max(w1, w2) <= b):\n                        max_area = max(max_area, w1 * h1 + w2 * h2)\n\n    return max_area\n\n# Read input\nn, a, b = map(int, input().split())\nseals = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(largest_area(n, a, b, seals))"}
{"solution": "def find_non_boundary_point(points):\n    x_count = {}\n    y_count = {}\n    \n    for x, y in points:\n        if x in x_count:\n            x_count[x] += 1\n        else:\n            x_count[x] = 1\n        \n        if y in y_count:\n            y_count[y] += 1\n        else:\n            y_count[y] = 1\n    \n    for x, y in points:\n        if x_count[x] > 2 and y_count[y] > 2:\n            return x, y\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(4 * n + 1)]\nresult = find_non_boundary_point(points)\nprint(result[0], result[1])"}
{"solution": "def digit_product(x):\n    product = 1\n    while x > 0:\n        product *= x % 10\n        x //= 10\n    return product\n\ndef max_digit_product(n):\n    max_product = digit_product(n)\n    str_n = str(n)\n    for i in range(len(str_n)):\n        if str_n[i] == '0':\n            continue\n        new_num = list(str_n)\n        new_num[i] = str(int(new_num[i]) - 1)\n        for j in range(i + 1, len(new_num)):\n            new_num[j] = '9'\n        new_num = int(''.join(new_num))\n        max_product = max(max_product, digit_product(new_num))\n    return max_product\n\nn = int(input())\nprint(max_digit_product(n))"}
{"solution": "def smallest_winning_k(n, votes):\n    max_a = max(votes)\n    total_votes_elodreip = sum(votes)\n    \n    # We need to find the smallest k such that Awruk's votes are strictly more than Elodreip's votes\n    k = max_a\n    while True:\n        total_votes_awruk = n * k - total_votes_elodreip\n        if total_votes_awruk > total_votes_elodreip:\n            return k\n        k += 1\n\n# Read input\nn = int(input())\nvotes = list(map(int, input().split()))\n\n# Get the smallest winning k\nresult = smallest_winning_k(n, votes)\n\n# Print the result\nprint(result)"}
{"solution": "def count_operations(points):\n    operations = 0\n    while True:\n        to_delete = set()\n        n = len(points)\n        for i in range(n):\n            if (i > 0 and points[i] != points[i-1]) or (i < n-1 and points[i] != points[i+1]):\n                to_delete.add(i)\n        if not to_delete:\n            break\n        points = ''.join(points[i] for i in range(n) if i not in to_delete)\n        operations += 1\n    return operations\n\n# Read input\npoints = input().strip()\n\n# Calculate and print the number of operations\nprint(count_operations(points))"}
{"solution": "from collections import Counter\nfrom math import comb\n\ndef count_minimum_triples(n, a):\n    a.sort()\n    min1, min2, min3 = a[0], a[1], a[2]\n    \n    if min1 == min2 == min3:\n        count1 = a.count(min1)\n        return comb(count1, 3)\n    elif min1 == min2:\n        count1 = a.count(min1)\n        count3 = a.count(min3)\n        return comb(count1, 2) * count3\n    else:\n        count1 = a.count(min1)\n        count2 = a.count(min2)\n        count3 = a.count(min3)\n        return count1 * count2 * count3\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_minimum_triples(n, a))"}
{"solution": "def min_cuts(n):\n    if n == 0:\n        return 0\n    elif (n + 1) % 2 == 0:\n        return (n + 1) // 2\n    else:\n        return n + 1\n\nn = int(input())\nprint(min_cuts(n))"}
{"solution": "n = int(input().strip())\n\nif n >= 0:\n    print(n)\nelse:\n    option1 = int(str(n)[:-1])\n    option2 = int(str(n)[:-2] + str(n)[-1])\n    print(max(option1, option2))"}
{"solution": "def determine_direction(start, end, n):\n    positions = ['v', '<', '^', '>']\n    start_index = positions.index(start)\n    end_index = positions.index(end)\n    \n    # Calculate the positions after n seconds in both directions\n    cw_index = (start_index + n) % 4\n    ccw_index = (start_index - n) % 4\n    \n    if positions[cw_index] == end and positions[ccw_index] == end:\n        return \"undefined\"\n    elif positions[cw_index] == end:\n        return \"cw\"\n    elif positions[ccw_index] == end:\n        return \"ccw\"\n    else:\n        return \"undefined\"\n\n# Read input\nstart, end = input().split()\nn = int(input())\n\n# Determine and print the direction\nprint(determine_direction(start, end, n))"}
{"solution": "def count_standing_dominoes(n, s):\n    standing_count = 0\n    i = 0\n\n    while i < n:\n        if s[i] == '.':\n            standing_count += 1\n            i += 1\n        elif s[i] == 'L':\n            i += 1\n        elif s[i] == 'R':\n            j = i + 1\n            while j < n and s[j] == '.':\n                j += 1\n            if j < n and s[j] == 'L':\n                distance = j - i - 1\n                if distance % 2 == 0:\n                    standing_count += 1\n            i = j\n\n    return standing_count\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Calculate and print the result\nprint(count_standing_dominoes(n, s))"}
{"solution": "def find_permutation(n, m, leaders):\n    a = [0] * n\n    used = [False] * (n + 1)\n    \n    for i in range(m - 1):\n        current_leader = leaders[i] - 1\n        next_leader = leaders[i + 1] - 1\n        steps = (next_leader - current_leader) % n\n        if steps == 0:\n            steps = n\n        if a[current_leader] == 0:\n            if used[steps]:\n                return -1\n            a[current_leader] = steps\n            used[steps] = True\n        elif a[current_leader] != steps:\n            return -1\n    \n    remaining = [i for i in range(1, n + 1) if not used[i]]\n    for i in range(n):\n        if a[i] == 0:\n            a[i] = remaining.pop(0)\n    \n    return a\n\n# Read input\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\n# Find permutation\nresult = find_permutation(n, m, leaders)\n\n# Print result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def maximize_number(a, k):\n    a = list(str(a))\n    n = len(a)\n    \n    for i in range(n):\n        if k == 0:\n            break\n        \n        max_digit = a[i]\n        max_pos = i\n        \n        for j in range(i + 1, min(n, i + k + 1)):\n            if a[j] > max_digit:\n                max_digit = a[j]\n                max_pos = j\n        \n        if max_pos != i:\n            for j in range(max_pos, i, -1):\n                a[j], a[j - 1] = a[j - 1], a[j]\n            k -= (max_pos - i)\n    \n    return ''.join(a)\n\n# Read input\na, k = input().split()\na = int(a)\nk = int(k)\n\n# Get the result\nresult = maximize_number(a, k)\n\n# Print the result\nprint(result)"}
{"solution": "def find_next_number(sequence):\n    a1, a2, a3, a4 = sequence\n\n    # Check for arithmetic progression\n    if a2 - a1 == a3 - a2 == a4 - a3:\n        d = a2 - a1\n        next_number = a4 + d\n        print(next_number)\n        return\n\n    # Check for geometric progression\n    if a1 != 0 and a2 % a1 == 0 and a3 % a2 == 0 and a4 % a3 == 0:\n        q = a2 // a1\n        if a2 == a1 * q and a3 == a2 * q and a4 == a3 * q:\n            next_number = a4 * q\n            print(next_number)\n            return\n\n    # If neither, print 42\n    print(42)\n\n# Read input\nsequence = list(map(int, input().split()))\nfind_next_number(sequence)"}
{"solution": "def max_distance(n, colors):\n    # Find the first and last occurrence of each color\n    first_occurrence = {}\n    last_occurrence = {}\n    \n    for i in range(n):\n        color = colors[i]\n        if color not in first_occurrence:\n            first_occurrence[color] = i\n        last_occurrence[color] = i\n    \n    # Get the first and last house colors\n    first_color = colors[0]\n    last_color = colors[-1]\n    \n    # Calculate the maximum distance\n    max_dist = 0\n    for color in first_occurrence:\n        if color != first_color:\n            max_dist = max(max_dist, first_occurrence[color])\n        if color != last_color:\n            max_dist = max(max_dist, n - 1 - first_occurrence[color])\n    \n    return max_dist\n\n# Read input\nn = int(input())\ncolors = list(map(int, input().split()))\n\n# Print the result\nprint(max_distance(n, colors))"}
{"solution": "def find_santa_place(n, m, k):\n    # Determine the lane number\n    lane = (k - 1) // (2 * m) + 1\n    \n    # Determine the desk number within the lane\n    desk = ((k - 1) % (2 * m)) // 2 + 1\n    \n    # Determine the side of the desk\n    side = \"L\" if k % 2 != 0 else \"R\"\n    \n    return lane, desk, side\n\n# Read input\nn, m, k = map(int, input().strip().split())\n\n# Find Santa's place\nlane, desk, side = find_santa_place(n, m, k)\n\n# Print the result\nprint(lane, desk, side)"}
{"solution": "def possible_final_colors(n, s):\n    from collections import Counter\n\n    count = Counter(s)\n    b, g, r = count['B'], count['G'], count['R']\n\n    # If all cards are of the same color\n    if (b == n) or (g == n) or (r == n):\n        return ''.join(sorted(set(s)))\n\n    # If there are cards of all three colors\n    if b > 0 and g > 0 and r > 0:\n        return 'BGR'\n\n    # If there are cards of exactly two colors\n    if (b > 0 and g > 0) or (b > 0 and r > 0) or (g > 0 and r > 0):\n        return ''.join(sorted(set(s)))\n\n    return ''.join(sorted(set(s)))\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Get the possible final colors\nresult = possible_final_colors(n, s)\n\n# Print the result\nprint(result)"}
