{"solution": "def max_accordion_length(s):\n    stack = []\n    open_brackets = 0\n    colons = 0\n    lines = 0\n    \n    for char in s:\n        if char == '[':\n            open_brackets += 1\n            stack.append(char)\n        elif char == ':':\n            if open_brackets > 0:\n                colons += 1\n                stack.append(char)\n                open_brackets -= 1\n            else:\n                colons = 0\n        elif char == '|':\n            lines += 1\n            stack.append(char)\n        elif char == ']':\n            if colons > 0:\n                colons -= 1\n                stack.append(char)\n                lines = 0\n            else:\n                lines = 0\n    \n    # Check if a valid accordion can be formed\n    if open_brackets != 0 or colons % 2 != 0:\n        return -1\n    \n    # Count the maximum number of vertical lines between colons\n    max_lines = 0\n    current_lines = 0\n    colon_count = 0\n    \n    for char in stack:\n        if char == '[':\n            colon_count = 0\n        elif char == ':':\n            colon_count += 1\n            if colon_count == 2:\n                max_lines = max(max_lines, current_lines)\n                current_lines = 0\n                colon_count = 0\n        elif char == '|':\n            current_lines += 1\n    \n    # Calculate the length of the accordion\n    if max_lines == 0:\n        return -1\n    else:\n        return 4 + 2 * max_lines\n\n# Read input\ns = input()\n\n# Solve and print output\nprint(max_accordion_length(s))"}
{"solution": "def max_digit_sum(x):\n    x_str = str(x)\n    length = len(x_str)\n    \n    # If the number is all 9s or a single digit, return the number itself\n    if set(x_str) == {'9'} or length == 1:\n        return x\n    \n    # Find the position where the number is less than 9\n    for i in range(length):\n        if x_str[i] != '9':\n            break\n    else:\n        # If the loop completed without break, all digits were 9\n        return x\n    \n    # Calculate the new number with max sum of digits\n    new_number = '9' * i + str(min(int(x_str[i]), x % (10 ** (length - i)) + 10 ** (length - i - 1))) + '0' * (length - i - 1)\n    \n    return int(new_number)\n\n# Read input\nx = int(input())\n\n# Compute and print the result\nprint(max_digit_sum(x))"}
{"solution": "def is_lucky_year(year):\n    digits = [int(d) for d in str(year)]\n    non_zero_count = sum(1 for d in digits if d != 0)\n    return non_zero_count <= 1\n\ndef find_next_lucky_year(current_year):\n    next_year = current_year + 1\n    while not is_lucky_year(next_year):\n        next_year += 1\n    return next_year - current_year\n\ncurrent_year = int(input())\nprint(find_next_lucky_year(current_year))"}
{"solution": "from itertools import accumulate\n\ndef max_painted_sections(n, q, painters):\n    events = []\n    for l, r in painters:\n        events.append((l, 1))  # Start painting\n        events.append((r + 1, -1))  # End painting (offset by 1)\n    \n    # Sort events by position\n    events.sort()\n    \n    # Create a list to track active painters\n    active_painters = [0] * (n + 2)\n    active_count = 0\n    \n    for pos, delta in events:\n        if 1 <= pos <= n:\n            active_painters[pos] = active_count\n        active_count += delta\n    \n    # Calculate coverage for each position\n    coverage = list(accumulate(active_painters))\n    \n    # Find the positions where exactly 3 painters are active\n    three_painters_coverage = [pos for pos in range(1, n + 1) if active_painters[pos] == 3]\n    \n    # Calculate the maximum coverage excluding any two painters\n    max_coverage = max(coverage[pos] - coverage[pos - 1] for pos in three_painters_coverage)\n    \n    return max_coverage\n\n# Read input\nn, q = map(int, input().split())\npainters = [list(map(int, input().split())) for _ in range(q)]\n\n# Compute and print the result\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def is_lucky(time_str):\n    return '7' in time_str\n\ndef prev_lucky_time(hh, mm, x):\n    # Convert hh:mm to total minutes\n    total_minutes = hh * 60 + mm\n    \n    # Start from the current time and go backwards in steps of x\n    for i in range(total_minutes // x + 1):\n        # Calculate the time x * i minutes ago\n        minutes_ago = total_minutes - i * x\n        # Convert back to hh:mm format\n        hours_ago = (minutes_ago // 60) % 24\n        minutes_ago %= 60\n        # Format the time as a string\n        time_str = f\"{hours_ago:02d}:{minutes_ago:02d}\"\n        # Check if the time is lucky\n        if is_lucky(time_str):\n            return i\n    return -1  # Should never happen given the problem constraints\n\n# Read input\nx = int(input())\nhh, mm = map(int, input().split())\n\n# Calculate and print the result\nprint(prev_lucky_time(hh, mm, x))"}
{"solution": "def min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0\n    elif l == 1:\n        return abs(pos - r) + 1\n    elif r == n:\n        return abs(pos - l) + 1\n    else:\n        # Calculate the cost for moving to each boundary and closing tabs\n        cost_left = abs(pos - l) + (r - l) + 1\n        cost_right = abs(pos - r) + (r - l) + 1\n        # Return the minimum of the two costs\n        return min(cost_left, cost_right)\n\n# Read input\nn, pos, l, r = map(int, input().split())\n# Print the result\nprint(min_seconds_to_close_tabs(n, pos, l, r))"}
{"solution": "from typing import List\n\ndef min_blows_to_defeat(zmei_heads: int, blows: List[List[int]]) -> int:\n    # Sort blows by damage dealt in descending order\n    blows.sort(key=lambda x: x[0], reverse=True)\n    \n    def can_defeat_with_k_blows(k):\n        heads = zmei_heads\n        for d, h in blows:\n            # Calculate the maximum possible reduction in heads with k blows\n            max_reduction = min(d * k, heads)\n            heads -= max_reduction\n            heads += min(h * k, heads)\n            if heads <= 0:\n                return True\n        return False\n    \n    lo, hi = 0, 10**10\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if can_defeat_with_k_blows(mid):\n            hi = mid\n        else:\n            lo = mid + 1\n            \n    return lo if lo < 10**10 else -1\n\n# Read input\nt = int(input())\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Calculate and print the result\n    print(min_blows_to_defeat(x, blows))"}
{"solution": "def day_barn_empty(n, m):\n    day = 1\n    grains = n\n    while True:\n        # Grains added at the beginning of the day\n        grains += m\n        # Ensure grains do not exceed the barn's capacity\n        grains = min(grains, n)\n        # Sparrows eat grains at the end of the day\n        grains -= day\n        if grains <= 0:\n            return day\n        day += 1\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(day_barn_empty(n, m))"}
{"solution": "def min_draws_to_win(tiles):\n    # Parse the input tiles\n    tile1, tile2, tile3 = tiles.split()\n    \n    # Extract numbers and suits\n    num1, suit1 = int(tile1[0]), tile1[1]\n    num2, suit2 = int(tile2[0]), tile2[1]\n    num3, suit3 = int(tile3[0]), tile3[1]\n    \n    # Check for koutsu (triplet)\n    if tile1 == tile2 == tile3:\n        return 0\n    \n    # Check for shuntsu (sequence)\n    def is_shuntsu(n1, n2, n3):\n        return sorted([n1, n2, n3]) in [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9]]\n    \n    if suit1 == suit2 == suit3 and is_shuntsu(num1, num2, num3):\n        return 0\n    \n    # Check for possible koutsu with one more draw\n    if tile1 == tile2 or tile1 == tile3 or tile2 == tile3:\n        return 1\n    \n    # Check for possible shuntsu with one more draw\n    def needs_one_for_shuntsu(n1, n2):\n        return abs(n1 - n2) == 1 or abs(n1 - n2) == 2\n    \n    if suit1 == suit2 and needs_one_for_shuntsu(num1, num2):\n        return 1\n    if suit1 == suit3 and needs_one_for_shuntsu(num1, num3):\n        return 1\n    if suit2 == suit3 and needs_one_for_shuntsu(num2, num3):\n        return 1\n    \n    # If no koutsu or shuntsu can be formed with one more draw, return 2\n    return 2\n\n# Example usage\nprint(min_draws_to_win(\"1s 2s 3s\"))\nprint(min_draws_to_win(\"9m 9m 9m\"))\nprint(min_draws_to_win(\"3p 9m 2p\"))"}
{"solution": "def find_grandpas_sofa(d, n, m, sofas, cnt):\n    def count_sofas_relative_to(s, sofas, condition):\n        count = 0\n        for other in sofas:\n            if condition(s, other):\n                count += 1\n        return count\n\n    def is_left_of(s, other):\n        return min(s[0][1], s[1][1]) < max(other[0][1], other[1][1])\n\n    def is_right_of(s, other):\n        return max(s[0][1], s[1][1]) > min(other[0][1], other[1][1])\n\n    def is_above(s, other):\n        return min(s[0][0], s[1][0]) < max(other[0][0], other[1][0])\n\n    def is_below(s, other):\n        return max(s[0][0], s[1][0]) > min(other[0][0], other[1][0])\n\n    # Convert input coordinates to a simpler form\n    sofas_list = []\n    for i, (x1, y1, x2, y2) in enumerate(sofas):\n        sofas_list.append(((x1, y1), (x2, y2)))\n\n    for i, sofa in enumerate(sofas_list):\n        counts = [\n            count_sofas_relative_to(sofa, [s for j, s in enumerate(sofas_list) if i != j], is_left_of),\n            count_sofas_relative_to(sofa, [s for j, s in enumerate(sofas_list) if i != j], is_right_of),\n            count_sofas_relative_to(sofa, [s for j, s in enumerate(sofas_list) if i != j], is_above),\n            count_sofas_relative_to(sofa, [s for j, s in enumerate(sofas_list) if i != j], is_below)\n        ]\n        if counts == cnt:\n            return i + 1\n    return -1\n\n# Read input\nd = int(input())\nn, m = map(int, input().split())\nsofas = [list(map(int, input().split())) for _ in range(d)]\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\n# Find and print the answer\nprint(find_grandpas_sofa(d, n, m, sofas, [cnt_l, cnt_r, cnt_t, cnt_b]))"}
{"solution": "def mars_days_off(n):\n    full_weeks = n // 7\n    remaining_days = n % 7\n    \n    min_days_off = full_weeks * 2\n    max_days_off = full_weeks * 2 + min(remaining_days, 2)\n    \n    return min_days_off, max_days_off\n\nn = int(input())\nmin_days_off, max_days_off = mars_days_off(n)\nprint(min_days_off, max_days_off)"}
{"solution": "def max_chocolates(n, a, b, p, q):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    lcm = a * b // gcd(a, b)\n\n    # Count multiples of a, b, and lcm within n\n    red_tiles = n // a\n    blue_tiles = n // b\n    both_tiles = n // lcm\n\n    # Total chocolates for red and blue tiles\n    total_red = red_tiles * p\n    total_blue = blue_tiles * q\n\n    # Adjust for tiles that can be both red and blue\n    # Choose the maximum between p and q for these tiles\n    both_max = both_tiles * max(p, q)\n\n    # Final calculation\n    total_chocolates = (total_red + total_blue - both_max)\n\n    return total_chocolates\n\n# Read input\nn, a, b, p, q = map(int, input().split())\n\n# Calculate and print the result\nprint(max_chocolates(n, a, b, p, q))"}
{"solution": "def max_golden_segment(n, trophies):\n    # Convert the string to a list of integers for easier manipulation (0 for S, 1 for G)\n    trophies = [1 if trophy == 'G' else 0 for trophy in trophies]\n    \n    max_length = 0\n    prefix_sum = [0]\n    for i in range(n):\n        prefix_sum.append(prefix_sum[-1] + trophies[i])\n    \n    # Find the maximum length of consecutive golden trophies\n    current_max = 0\n    for i in range(n):\n        if trophies[i] == 0:\n            left_sum = prefix_sum[i]\n            right_sum = prefix_sum[n] - prefix_sum[i + 1]\n            max_length = max(max_length, left_sum + right_sum + 1)\n        else:\n            current_max += 1\n    max_length = max(max_length, current_max)\n    \n    return max_length\n\n# Read input\nn = int(input())\ntrophies = input().strip()\n\n# Compute and print the result\nprint(max_golden_segment(n, trophies))"}
{"solution": "from collections import defaultdict, deque\n\ndef topological_sort(n, k, prerequisites):\n    # Build graph and indegree map\n    graph = defaultdict(list)\n    indegree = {i: 0 for i in range(1, n + 1)}\n    \n    for course in range(1, n + 1):\n        num_prereqs, *prereqs = prerequisites[course - 1]\n        for prereq in prereqs:\n            graph[prereq].append(course)\n            indegree[course] += 1\n    \n    # Queue for courses with no prerequisites\n    queue = deque([course for course in range(1, n + 1) if indegree[course] == 0])\n    visited = []\n    course_count = 0\n    \n    while queue:\n        course = queue.popleft()\n        visited.append(course)\n        course_count += 1\n        \n        for next_course in graph[course]:\n            indegree[next_course] -= 1\n            if indegree[next_course] == 0:\n                queue.append(next_course)\n    \n    if course_count < n:\n        print(-1)\n        return\n    \n    required_courses = set(map(int, input().split()))\n    result = [course for course in visited if course in required_courses]\n    \n    if len(result) < k:\n        print(-1)\n        return\n    \n    additional_courses = [course for course in visited if course not in required_courses]\n    for course in additional_courses:\n        if len(result) == k:\n            break\n        result.append(course)\n    \n    print(len(result))\n    print(' '.join(map(str, result)))\n\n# Read input\nn, k = map(int, input().split())\nprerequisites = [list(map(int, input().split())) for _ in range(n)]\n\ntopological_sort(n, k, prerequisites)"}
{"solution": "def is_stack_sortable(arr):\n    stack = []\n    sorted_arr = []\n    max_val = 0\n    for val in arr:\n        if val < max_val:\n            return False\n        max_val = max(max_val, val)\n        stack.append(val)\n        while stack and (not sorted_arr or stack[-1] >= sorted_arr[-1]):\n            sorted_arr.append(stack.pop())\n    return True\n\ndef restore_permutation(n, k, initial_elements):\n    remaining_elements = set(range(1, n + 1)) - set(initial_elements)\n    remaining_list = list(remaining_elements)\n    remaining_list.sort(reverse=True)\n    \n    result = list(initial_elements)\n    stack = []\n    max_seen = 0\n    \n    for i in range(k):\n        if initial_elements[i] < max_seen:\n            return [-1]\n        max_seen = max(max_seen, initial_elements[i])\n        stack.append(initial_elements[i])\n        while stack and (not result or stack[-1] >= result[-1]):\n            result.append(stack.pop())\n    \n    for val in remaining_list:\n        stack.append(val)\n        while stack and (not result or stack[-1] >= result[-1]):\n            result.append(stack.pop())\n    \n    if len(result) != n or not is_stack_sortable(result):\n        return [-1]\n    \n    return result\n\nn, k = map(int, input().split())\ninitial_elements = list(map(int, input().split()))\nprint(' '.join(map(str, restore_permutation(n, k, initial_elements))))"}
{"solution": "def does_b_appear_in_sequence(a, b, c):\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\na, b, c = map(int, input().split())\nprint(does_b_appear_in_sequence(a, b, c))"}
{"solution": "def can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    return 1 if cnt_1 == cnt_4 else 0\n\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\nprint(can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4))"}
{"solution": "def standing_spectators(n, k, t):\n    # Calculate the number of complete cycles of k stand-ups and k sit-downs before time t\n    full_cycles = t // k\n    # Calculate the number of spectators currently standing after full cycles\n    standing = min(n, full_cycles * k)\n    # Calculate the remaining time after full cycles\n    remaining_time = t % k\n    # Add the number of spectators standing up in the remaining time\n    standing += remaining_time\n    # If there have been more than n stand-ups, subtract the number of spectators who have sat down\n    if t >= n:\n        standing -= (t - n)\n    return standing\n\n# Read input\nn, k, t = map(int, input().split())\n\n# Output the result\nprint(standing_spectators(n, k, t))"}
{"solution": "def lexicographically_minimal_string(s):\n    t = []\n    u = []\n    s = list(s)\n    min_char_index = 0\n    \n    while s or t:\n        if t and (not s or s[min_char_index] > t[-1]):\n            u.append(t.pop())\n        else:\n            t.append(s.pop(min_char_index))\n            min_char_index = min(range(len(s)), key=lambda i: s[i] if i < len(s) else '')\n    \n    return ''.join(u)\n\n# Read input\ns = input().strip()\nprint(lexicographically_minimal_string(s))"}
{"solution": "def check_stats(test_cases):\n    for _ in range(test_cases):\n        n = int(input())\n        stats = []\n        for _ in range(n):\n            p, c = map(int, input().split())\n            stats.append((p, c))\n        \n        prev_plays, prev_clears = stats[0]\n        valid = True\n        \n        for i in range(1, n):\n            current_plays, current_clears = stats[i]\n            delta_plays = current_plays - prev_plays\n            delta_clears = current_clears - prev_clears\n            \n            if delta_plays < delta_clears or delta_plays < 0:\n                valid = False\n                break\n            \n            prev_plays, prev_clears = current_plays, current_clears\n        \n        print(\"YES\" if valid else \"NO\")\n\n# Read the number of test cases\nT = int(input())\ncheck_stats(T)"}
{"solution": "from datetime import datetime, timedelta\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef next_palindromic_time(current_time):\n    current = datetime.strptime(current_time, '%H:%M')\n    next_time = current\n    \n    while True:\n        next_time += timedelta(minutes=1)\n        time_str = next_time.strftime('%H:%M')\n        if is_palindrome(time_str.replace(\":\", \"\")):\n            break\n    \n    minutes_to_sleep = (next_time - current).seconds // 60\n    return minutes_to_sleep\n\n# Read input\ncurrent_time = input().strip()\n\n# Calculate and print the result\nprint(next_palindromic_time(current_time))"}
{"solution": "def max_distance_after_swap(n, arr):\n    # Find positions of 1 and n\n    pos_1 = arr.index(1)\n    pos_n = arr.index(n)\n    \n    # Calculate current distance\n    current_distance = abs(pos_n - pos_1)\n    \n    # Calculate potential maximum distance\n    max_distance = max(pos_1, pos_n) + (n - 1 - min(pos_1, pos_n))\n    \n    # Check if swap is needed\n    if current_distance < max_distance:\n        return max_distance\n    else:\n        return current_distance\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_distance_after_swap(n, arr))"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    mid = n // 2\n    first_half = s[:mid]\n    second_half = s[mid + 1:] if n % 2 else s[mid:]\n    \n    if first_half == second_half[::-1]:\n        return \"TAK\"\n    else:\n        return \"NIE\"\n\ns = input().strip()\nprint(is_s_palindrome(s))"}
{"solution": "def max_permutation(a, b):\n    a_str = list(str(a))\n    b_str = str(b)\n    len_a = len(a_str)\n    \n    if len(b_str) < len_a:\n        return -1  # This case is impossible based on the problem statement\n    \n    result = [-1] * len_a\n    used_digits = [0] * 10\n    \n    for digit in a_str:\n        used_digits[int(digit)] += 1\n    \n    pos = 0\n    for i in range(len_a):\n        for d in range(9, -1, -1):\n            if used_digits[d] > 0 and (pos == 0 and d != 0 or d <= int(b_str[pos])):\n                result[i] = d\n                used_digits[d] -= 1\n                pos += 1\n                break\n    \n    return int(\"\".join(map(str, result)))\n\n# Reading input\na = int(input())\nb = int(input())\n\n# Calculating and printing the output\nprint(max_permutation(a, b))"}
{"solution": "def check_win(matrix, row, col):\n    def check_line(dx, dy):\n        count = 1\n        for i in range(1, 5):\n            nx, ny = row + dx * i, col + dy * i\n            if 0 <= nx < 10 and 0 <= ny < 10 and matrix[nx][ny] == 'X':\n                count += 1\n            else:\n                break\n        for i in range(1, 5):\n            nx, ny = row - dx * i, col - dy * i\n            if 0 <= nx < 10 and 0 <= ny < 10 and matrix[nx][ny] == 'X':\n                count += 1\n            else:\n                break\n        return count >= 5\n\n    # Check horizontal, vertical, and diagonals\n    return any(check_line(d1, d2) for d1 in (0, 1) for d2 in (0, 1))\n\ndef can_alice_win(matrix):\n    for i in range(10):\n        for j in range(10):\n            if matrix[i][j] == '.':\n                matrix[i] = matrix[i][:j] + 'X' + matrix[i][j+1:]\n                if check_win(matrix, i, j):\n                    return 'YES'\n                matrix[i] = matrix[i][:j] + '.' + matrix[i][j+1:]\n    return 'NO'\n\n# Read input\nmatrix = [input() for _ in range(10)]\n\n# Output result\nprint(can_alice_win(matrix))"}
{"solution": "def print_matrix(matrix):\n    for row in matrix:\n        print(' '.join(map(str, row)))\n\ndef fill_symmetric_matrix(n, k):\n    matrix = [[0] * n for _ in range(n)]\n    placed_ones = 0\n    \n    # Fill the upper triangle and main diagonal\n    for i in range(n):\n        for j in range(i, n):\n            if placed_ones < k:\n                matrix[i][j] = 1\n                placed_ones += 1\n                if placed_ones == k:\n                    break\n    \n    # Check if k ones can be placed\n    if placed_ones < k:\n        return -1\n    \n    # Ensure symmetry\n    for i in range(n):\n        for j in range(i + 1, n):\n            matrix[j][i] = matrix[i][j]\n    \n    return matrix\n\n# Read input\nn, k = map(int, input().split())\n\n# Solve and print result\nresult = fill_symmetric_matrix(n, k)\nif result == -1:\n    print(-1)\nelse:\n    print_matrix(result)"}
{"solution": "from math import pow\n\ndef calculate_expression(x, y, z):\n    # Define the 12 expressions\n    expressions = [\n        (pow(x, pow(y, z)), \"x^y^z\"),\n        (pow(x, pow(z, y)), \"x^z^y\"),\n        (pow(pow(x, y), z), \"(x^y)^z\"),\n        (pow(pow(x, z), y), \"(x^z)^y\"),\n        (pow(y, pow(x, z)), \"y^x^z\"),\n        (pow(y, pow(z, x)), \"y^z^x\"),\n        (pow(pow(y, x), z), \"(y^x)^z\"),\n        (pow(pow(y, z), x), \"(y^z)^x\"),\n        (pow(z, pow(x, y)), \"z^x^y\"),\n        (pow(z, pow(y, x)), \"z^y^x\"),\n        (pow(pow(z, x), y), \"(z^x)^y\"),\n        (pow(pow(z, y), x), \"(z^y)^x\")\n    ]\n    \n    # Find the maximum value and its corresponding expression\n    max_value, max_expression = max(expressions)\n    \n    return max_expression\n\n# Read input\nx, y, z = map(float, input().split())\n\n# Calculate and print the expression with the maximum value\nprint(calculate_expression(x, y, z))"}
{"solution": "def min_operations_to_type_string(n, s):\n    # Base case: if the string is of length 1 or doesn't contain repeating patterns\n    if n == 1 or len(set(s)) == len(s):\n        return n\n    \n    # Initialize the minimum operations to the length of the string\n    min_ops = n\n    \n    # Iterate over possible substrings to find the optimal copy-paste operation\n    for i in range(1, n // 2 + 1):\n        # Check if the current substring can be repeated to form the entire string\n        if n % i == 0:\n            substring = s[:i]\n            if substring * (n // i) == s:\n                # Calculate the operations needed for typing the substring and appending\n                min_ops = min(min_ops, i + n // i - 1)\n    \n    return min_ops\n\n# Read input\nn = int(input())\ns = input()\n\n# Print the result\nprint(min_operations_to_type_string(n, s))"}
{"solution": "from collections import defaultdict\n\ndef min_script_moves(n, files):\n    # Separate files by type and sort them\n    examples = sorted([name for name, type_ in files if type_ == '1'])\n    regulars = sorted([name for name, type_ in files if type_ == '0'])\n\n    # Initialize variables\n    total_moves = 0\n    script = []\n\n    # Number of examples\n    num_examples = len(examples)\n\n    # Rename examples\n    for i, example in enumerate(examples):\n        if example != str(i + 1):\n            script.append(f\"move {example} {i + 1}\")\n            total_moves += 1\n\n    # Rename regulars\n    for i, regular in enumerate(regulars):\n        new_index = num_examples + i + 1\n        if regular != str(new_index):\n            script.append(f\"move {regular} {new_index}\")\n            total_moves += 1\n\n    return total_moves, script\n\n# Read input\nn = int(input())\nfiles = [input().split() for _ in range(n)]\n\n# Generate script\ntotal_moves, script = min_script_moves(n, files)\n\n# Print output\nprint(total_moves)\nfor line in script:\n    print(line)"}
{"solution": "def min_replacements_to_make_lucky_ticket(ticket):\n    # Calculate the sum of the first and last three digits\n    first_half_sum = sum(int(digit) for digit in ticket[:3])\n    second_half_sum = sum(int(digit) for digit in ticket[3:])\n    \n    # Calculate the difference between the sums\n    diff = abs(first_half_sum - second_half_sum)\n    \n    # Initialize the result variable\n    result = 0\n    \n    # Iterate over each digit in the ticket\n    for i in range(6):\n        # Calculate the maximum possible reduction in the difference\n        # by replacing the current digit with another digit\n        max_reduction = min(diff, 9 - int(ticket[i]))\n        \n        # Update the difference and result accordingly\n        diff -= max_reduction\n        result += 1\n        \n        # If the difference reaches 0, break the loop\n        if diff == 0:\n            break\n    \n    return result\n\n# Read input\nticket = input()\n\n# Calculate and print the minimum number of replacements\nprint(min_replacements_to_make_lucky_ticket(ticket))"}
{"solution": "from math import gcd\n\ndef minimum_traps(m, x):\n    # Since GCD(x, m) = 1, x and m are coprime.\n    # The mouse will visit all rooms in a cycle, thus the minimum number of traps is m - 1.\n    return m - 1\n\n# Reading input\nm, x = map(int, input().split())\n\n# Ensuring GCD(x, m) = 1 as per the problem statement\nassert gcd(x, m) == 1\n\n# Printing the output\nprint(minimum_traps(m, x))"}
{"solution": "from math import gcd\n\nMOD = 10**6 + 3\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef solve(n, k):\n    n = pow(2, n, MOD - 1)\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator = (numerator * (n - i)) % MOD\n        denominator = (denominator * (i + 1)) % MOD\n    numerator = (numerator * modinv(denominator)) % MOD\n    denominator = pow(n, k, MOD)\n    # Simplify fraction\n    common_divisor = gcd(numerator, denominator)\n    numerator //= common_divisor\n    denominator //= common_divisor\n    return numerator % MOD, denominator % MOD\n\ndef main():\n    n, k = map(int, input().split())\n    a, b = solve(n, k)\n    print(a, b)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def check_journey(n, journey):\n    latitude = 90.0  # Start at the North Pole\n    longitude = 0.0  # Longitude does not matter for poles, but we start at 0\n\n    for t, direction in journey:\n        if direction == \"North\":\n            if latitude == 90.0:\n                return \"NO\"\n            latitude = min(90.0, latitude + t)\n        elif direction == \"South\":\n            if latitude == -90.0:\n                return \"NO\"\n            latitude = max(-90.0, latitude - t)\n        elif direction == \"East\":\n            longitude = (longitude + t) % 40000\n        elif direction == \"West\":\n            longitude = (longitude - t) % 40000\n\n    if latitude != 90.0:\n        return \"NO\"\n\n    return \"YES\"\n\n# Reading input\nn = int(input())\njourney = []\nfor _ in range(n):\n    t, direction = input().split()\n    t = int(t)\n    journey.append((t, direction))\n\n# Printing output\nprint(check_journey(n, journey))"}
{"solution": "from math import gcd\n\ndef find_common_elements(a1, b1, a2, b2, L, R):\n    # Calculate the greatest common divisor (gcd)\n    common_diff = a1 * a2 // gcd(a1, a2)\n    \n    # Initialize counters for the number of valid k' and l'\n    count = 0\n    \n    # Check if L is a valid starting point\n    if (L - b1) % a1 == 0 and (L - b2) % a2 == 0 and (L - b1) % common_diff == 0:\n        current = L\n    else:\n        current = L + (common_diff - (L - b1) % common_diff) % common_diff\n    \n    # Iterate through all possible values of x within the range [L, R]\n    while current <= R:\n        if (current - b1) % a1 == 0 and (current - b2) % a2 == 0:\n            count += 1\n        current += common_diff\n    \n    return count\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Output the result\nprint(find_common_elements(a1, b1, a2, b2, L, R))"}
{"solution": "def max_pieces_per_plate(n, a, b):\n    # Initialize the minimum number of pieces per plate\n    min_pieces = 0\n    # Initialize the maximum number of pieces per plate\n    max_pieces = max(a, b) + 1\n    \n    while min_pieces < max_pieces - 1:\n        mid = (min_pieces + max_pieces) // 2\n        can_distribute_a = (a // mid) + (a % mid > 0)\n        can_distribute_b = (b // mid) + (b % mid > 0)\n        \n        if can_distribute_a + can_distribute_b >= n:\n            min_pieces = mid\n        else:\n            max_pieces = mid\n            \n    return min_pieces\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(max_pieces_per_plate(n, a, b))"}
{"solution": "def is_valid_flag(n, m, flag):\n    # Check if dimensions are divisible by 3\n    if n % 3 != 0 or m % 3 != 0:\n        return \"NO\"\n    \n    stripe_height = n // 3\n    stripe_width = m // 3\n    \n    # Define the expected pattern\n    expected_pattern = ['RRR', 'GGG', 'BBB']\n    \n    # Check each stripe\n    for i in range(3):\n        start_row = i * stripe_height\n        end_row = (i + 1) * stripe_height\n        for row in range(start_row, end_row):\n            for col in range(stripe_width):\n                if flag[row][col] != expected_pattern[i][col // (m // 3)]:\n                    return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nflag = [input() for _ in range(n)]\n\n# Print the result\nprint(is_valid_flag(n, m, flag))"}
{"solution": "def calculate_hexagon_coordinates(n):\n    if n == 0:\n        return (0, 0)\n    \n    # Determine the ring and starting position\n    ring = 1\n    while True:\n        if n <= 6 * ring:\n            break\n        n -= 6 * ring\n        ring += 1\n    \n    # Determine the side of the hexagon\n    side_length = ring\n    side = n // side_length\n    offset = n % side_length\n    \n    # Calculate coordinates based on the side\n    if side == 0:\n        x, y = -ring + offset, ring - 1\n    elif side == 1:\n        x, y = -ring + 1, ring - 2 - offset\n    elif side == 2:\n        x, y = offset - ring + 1, -ring + 1\n    elif side == 3:\n        x, y = ring - 1 - offset, -ring + 1\n    elif side == 4:\n        x, y = -ring + 1, offset - ring\n    else:  # side == 5\n        x, y = ring - 1, ring - 1 - offset\n    \n    return (x, y)\n\n# Read input\nn = int(input())\n\n# Calculate and print the coordinates\nx, y = calculate_hexagon_coordinates(n)\nprint(x, y)"}
{"solution": "import math\n\ndef can_break_shield(a, b, c):\n    # Calculate the greatest common divisor of a and b\n    gcd_ab = math.gcd(a, b)\n    \n    # Check if c is divisible by the gcd of a and b\n    if c % gcd_ab == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input values\na, b, c = map(int, input().split())\n\n# Output the result\nprint(can_break_shield(a, b, c))"}
{"solution": "def can_tracks_coincide(n, L, kefa_barriers, sasha_barriers):\n    # Calculate distances between consecutive barriers for Kefa\n    kefa_distances = [(kefa_barriers[(i + 1) % n] - kefa_barriers[i]) % L for i in range(n)]\n    # Calculate distances between consecutive barriers for Sasha\n    sasha_distances = [(sasha_barriers[(i + 1) % n] - sasha_barriers[i]) % L for i in range(n)]\n    \n    # Double the kefa_distances to handle circular rotation\n    doubled_kefa_distances = kefa_distances + kefa_distances\n    \n    # Check if sasha_distances is a sublist of doubled_kefa_distances\n    for i in range(n):\n        if doubled_kefa_distances[i:i + n] == sasha_distances:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_barriers, sasha_barriers))"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindromic_substring(s):\n    n = len(s)\n    max_len = 0\n    \n    for i in range(n):\n        for j in range(i+1, n+1):\n            if not is_palindrome(s[i:j]):\n                max_len = max(max_len, j-i)\n    \n    return max_len\n\n# Reading input\ns = input().strip()\n\n# Calculating the result\nresult = longest_non_palindromic_substring(s)\n\n# Printing the output\nprint(result)"}
{"solution": "def determine_round_status(n, participants):\n    # Check if any rating has changed\n    rating_changed = any(a != b for a, b in participants)\n    \n    # Check if standings are in non-increasing order\n    standings_correct = all(a >= b for a, _ in zip(participants, participants[1:]))\n    \n    if rating_changed:\n        return \"rated\"\n    elif not standings_correct:\n        return \"unrated\"\n    else:\n        return \"maybe\"\n\n# Read input\nn = int(input())\nparticipants = [list(map(int, input().split())) for _ in range(n)]\n\n# Determine and print the result\nprint(determine_round_status(n, participants))"}
{"solution": "def find_nearest_zero_distances(n, arr):\n    # Initialize distances list with maximum possible distance\n    distances = [n] * n\n    \n    # Forward pass to update distances towards the left\n    for i in range(n):\n        if arr[i] == 0:\n            distances[i] = 0\n        else:\n            if i > 0:\n                distances[i] = min(distances[i], distances[i - 1] + 1)\n    \n    # Backward pass to update distances towards the right\n    for i in range(n - 2, -1, -1):\n        distances[i] = min(distances[i], distances[i + 1] + 1)\n    \n    return distances\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate and print the distances\nresult = find_nearest_zero_distances(n, arr)\nprint(' '.join(map(str, result)))"}
{"solution": "from itertools import product\n\ndef is_substring_in_cyclical_shifts(t, s):\n    t_extended = t + t\n    return any(s in t_extended[i:i+len(t)] for i in range(len(t)))\n\ndef count_distinct_cyclical_strings(n, s):\n    distinct_cyclical_strings = set()\n    \n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if is_substring_in_cyclical_shifts(t, s):\n            distinct_cyclical_strings.add(t)\n    \n    return len(distinct_cyclical_strings)\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import math\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    angles = []\n    \n    # Convert each vector to polar coordinates and extract the angle\n    for x, y in vectors:\n        angle = math.atan2(y, x)\n        if angle < 0:\n            angle += 2 * math.pi\n        angles.append(angle)\n    \n    # Sort the angles along with their original indices\n    sorted_angles = sorted((angle, i) for i, angle in enumerate(angles))\n    \n    min_diff = 2 * math.pi\n    result = (0, 1)\n    \n    # Calculate the minimal non-oriented angle\n    for i in range(n):\n        for j in range(i + 1, min(i + 3, n)):\n            diff = abs(sorted_angles[j][0] - sorted_angles[i][0])\n            if diff > math.pi:\n                diff = 2 * math.pi - diff\n            \n            if diff < min_diff:\n                min_diff = diff\n                result = (sorted_angles[i][1], sorted_angles[j][1])\n    \n    # Check for the case where the minimal angle might wrap around 2\u03c0\n    diff = abs(sorted_angles[0][0] - sorted_angles[-1][0])\n    if diff > math.pi:\n        diff = 2 * math.pi - diff\n    \n    if diff < min_diff:\n        result = (sorted_angles[-1][1], sorted_angles[0][1])\n    \n    return result\n\n# Read input\nn = int(input())\nvectors = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Find and print the indices of the pair with the minimal non-oriented angle\na, b = find_min_angle_pair(vectors)\nprint(a + 1, b + 1)"}
{"solution": "def minimal_time(d, k, a, b, t):\n    if d <= k:\n        return d * a\n    \n    # Full segments\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Time for full segments\n    time_for_full_segments = full_segments * k * a + (full_segments - 1) * t\n    \n    # Time for remaining distance\n    if remaining_distance == 0:\n        return time_for_full_segments\n    else:\n        # Option 1: Drive the remaining distance\n        time_drive_remaining = remaining_distance * a + t\n        # Option 2: Walk the remaining distance\n        time_walk_remaining = remaining_distance * b\n        \n        return time_for_full_segments + min(time_drive_remaining, time_walk_remaining)\n\n# Read input\nd, k, a, b, t = map(int, input().split())\n\n# Calculate and print the minimal time\nprint(minimal_time(d, k, a, b, t))"}
{"solution": "import math\n\ndef find_max_gcd_sequence(n, k):\n    if n < k:\n        return [-1]\n    \n    gcd = n // k\n    remainder = n % k\n    \n    # Check if the sequence can be formed with the current gcd\n    if remainder == 0 or (remainder > 0 and gcd > 0):\n        sequence = [gcd + (1 if i < remainder else 0) for i in range(k)]\n        return sequence\n    else:\n        return [-1]\n\n# Read input\nn, k = map(int, input().split())\n\n# Generate and print the sequence\nresult = find_max_gcd_sequence(n, k)\nprint(' '.join(map(str, result)))"}
{"solution": "def count_pairs(n, m):\n    # Initialize counts for each remainder\n    counts = [0] * 5\n    result = 0\n    \n    # Count remainders for n\n    for i in range(1, n + 1):\n        counts[i % 5] += 1\n    \n    # Calculate pairs for m\n    for j in range(1, m + 1):\n        needed_remainder = (5 - j % 5) % 5\n        result += counts[needed_remainder]\n    \n    return result\n\n# Read input\nn, m = map(int, input().split())\n\n# Compute and print the result\nprint(count_pairs(n, m))"}
{"solution": "def max_beauty(n, x, a):\n    dp = [[0] * 3 for _ in range(n + 1)]\n    max_beauty = 0\n    \n    for i in range(1, n + 1):\n        dp[i][0] = max(dp[i - 1][0] + a[i - 1], 0)\n        dp[i][1] = max(dp[i - 1][0] + a[i - 1] * x, a[i - 1] * x, dp[i - 1][1] + a[i - 1] * x)\n        dp[i][2] = max(dp[i - 1][1] + a[i - 1], dp[i - 1][2] + a[i - 1], a[i - 1])\n        \n        max_beauty = max(max_beauty, dp[i][0], dp[i][1], dp[i][2])\n    \n    print(max_beauty)\n\n# Reading input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Solving and printing the output\nmax_beauty(n, x, a)"}
{"solution": "def find_kth_largest(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(m, x // i)\n        return count\n\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_less_equal(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\nn, m, k = map(int, input().split())\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    \"\"\"\n    Finds the k-th digit in the concatenated sequence of all positive integers.\n    \n    :param k: The 1-based index of the digit in the sequence.\n    :return: The k-th digit in the sequence.\n    \"\"\"\n    if k < 10:\n        return k\n\n    # Initialize variables to calculate the range where the k-th digit falls into\n    base = 9  # The base count of digits for the current range\n    digits = 1  # The number of digits in the numbers of the current range\n    while k > base * digits:\n        k -= base * digits\n        base *= 10\n        digits += 1\n\n    # Find the actual number that contains the k-th digit\n    number = (k - 1) // digits + base // 9\n    # Find the position of the digit within the number\n    digit_index = (k - 1) % digits\n\n    # Extract and return the k-th digit\n    return int(str(number)[digit_index])\n\n# Read input\nk = int(input())\n\n# Compute and print the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "def max_bourles(n, m, r, buy_prices, sell_prices):\n    # Sort the buy and sell prices\n    buy_prices.sort()\n    sell_prices.sort(reverse=True)\n    \n    max_profit = r\n    for buy_price in buy_prices:\n        if buy_price == 0:\n            continue  # Avoid division by zero\n        shares = r // buy_price\n        for sell_price in sell_prices:\n            if sell_price <= buy_price:\n                break  # No profit can be made\n            current_profit = (shares * sell_price) + (r % buy_price)\n            max_profit = max(max_profit, current_profit)\n    \n    return max_profit\n\n# Read input\nn, m, r = map(int, input().split())\nbuy_prices = list(map(int, input().split()))\nsell_prices = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_bourles(n, m, r, buy_prices, sell_prices))"}
{"solution": "def find_original_message(t):\n    n = len(t)\n    for overlap in range(1, n // 2 + 1):\n        if t[:n - overlap] == t[overlap:]:\n            return \"YES\", t[:n - overlap]\n    return \"NO\", None\n\nt = input().strip()\nresult, s = find_original_message(t)\nprint(result)\nif result == \"YES\":\n    print(s)"}
{"solution": "def find_teams(n):\n    def solve(k):\n        total_games = 0\n        while k > 1:\n            if k % 2 == 0:\n                total_games += k // 2\n                k //= 2\n            else:\n                total_games += k * (k - 1) // 2\n                break\n        return total_games == n\n\n    results = []\n    i = 1\n    while True:\n        if solve(i):\n            results.append(i)\n        if i > 2 * n + 2:\n            break\n        i += 1\n\n    if not results:\n        return [-1]\n    return results\n\nn = int(input())\nresults = find_teams(n)\nfor result in results:\n    print(result)"}
{"solution": "def max_antipalindromic_beauty(n, s, b):\n    from collections import Counter\n    \n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # Check if the string can be rearranged to form an antipalindromic string\n    if any(freq > n // 2 for freq in char_count.values()):\n        return 0  # Not possible to form an antipalindromic string\n    \n    # Sort the beauty values in descending order\n    sorted_b = sorted(b, reverse=True)\n    \n    # Initialize the result variable\n    result = 0\n    \n    # Assign characters to positions based on beauty values\n    for i in range(n // 2):\n        # Use the highest beauty values for non-matching pairs\n        result += sorted_b[i] + sorted_b[n - i - 1]\n    \n    return result\n\n# Read input\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\n# Calculate and print the maximum possible beauty\nprint(max_antipalindromic_beauty(n, s, b))"}
{"solution": "def can_weigh(w, m):\n    # Initialize a set to store the achievable weights\n    achievable_weights = {0}\n    \n    # Iterate through the possible weights from w^0 to w^100\n    for i in range(101):\n        current_weight = w ** i\n        # Update the set of achievable weights by adding and subtracting the current weight\n        new_weights = set()\n        for weight in achievable_weights:\n            new_weights.add(weight + current_weight)\n            new_weights.add(abs(weight - current_weight))\n        # Update the set of achievable weights\n        achievable_weights |= new_weights\n        \n        # Check if m is in the set of achievable weights\n        if m in achievable_weights:\n            return 'YES'\n    \n    return 'NO'\n\n# Read input\nw, m = map(int, input().split())\n\n# Output the result\nprint(can_weigh(w, m))"}
{"solution": "def find_sequence(n, k):\n    # Function to convert n to binary and find the highest bit set\n    def highest_bit_set(x):\n        bit = -1\n        while x > 0:\n            bit = x & -x\n            x -= bit\n        return bit\n\n    # Initialize variables\n    sequence = []\n    remaining = n\n    smallest_max = -1\n\n    # Find the highest bits set and distribute them\n    while k > 0 and remaining > 0:\n        bit = highest_bit_set(remaining)\n        exponent = 0\n        while (1 << exponent) < bit:\n            exponent += 1\n        sequence.append(exponent - 1)\n        remaining -= bit\n        smallest_max = max(smallest_max, exponent - 1)\n        k -= 1\n\n    # If k is still positive, fill with smallest_max - 1\n    while k > 0:\n        sequence.append(smallest_max - 1)\n        k -= 1\n\n    # Check if the sequence is valid\n    if len(sequence) == 0 or sum(2**x for x in sequence) != n:\n        print(\"No\")\n    else:\n        print(\"Yes\")\n        print(*sequence)\n\n# Example usage\nn, k = map(int, input().split())\nfind_sequence(n, k)"}
{"solution": "def pour_champagne(n, t):\n    # Initialize a list to represent the pyramid, filled with zeros\n    pyramid = [[0] * (i + 1) for i in range(n)]\n    \n    # Start pouring champagne from the top\n    current_level = 0\n    while t > 0:\n        # Pour champagne into the top glass\n        pyramid[current_level][0] += 1\n        \n        # Distribute overflow to the next level\n        for level in range(current_level + 1):\n            for glass in range(len(pyramid[level])):\n                overflow = pyramid[level][glass] - 1\n                if overflow > 0:\n                    pyramid[level][glass] = 1  # Fill the glass to the brim\n                    t -= overflow  # Subtract the overflow from the total time\n                    if level + 1 < n:\n                        # Distribute overflow to the two glasses below\n                        pyramid[level + 1][glass] += overflow / 2\n                        pyramid[level + 1][glass + 1] += overflow / 2\n        \n        # Move to the next level if needed\n        if current_level < n - 1:\n            current_level += 1\n    \n    # Count the number of completely full glasses\n    full_glasses = sum(1 for row in pyramid for glass in row if glass >= 1)\n    \n    return full_glasses\n\n# Read input\nn, t = map(int, input().split())\n\n# Solve the problem\nresult = pour_champagne(n, t)\n\n# Print the result\nprint(result)"}
{"solution": "def calculate_area(n, vertices):\n    if n == 1:\n        return -1\n    elif n == 2:\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        if x1 != x2 and y1 != y2:\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 3:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 4:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n\n# Read input\nn = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the area\nprint(calculate_area(n, vertices))"}
{"solution": "def min_wooden_bars(n, a, b):\n    total_sides = 2 * a + b\n    total_for_two_doors = 2 * total_sides\n    return -(-total_for_two_doors // n)\n\nn = int(input())\na = int(input())\nb = int(input())\n\nprint(min_wooden_bars(n, a, b))"}
{"solution": "def can_sort_array(n, a, swaps):\n    # Convert the swaps string into a list of boolean values\n    allowed_swaps = [s == '1' for s in swaps]\n    \n    # Find the segments where swaps are allowed\n    segments = []\n    start = 0\n    for i in range(n - 1):\n        if not allowed_swaps[i] and i != start:\n            segments.append((start, i))\n            start = i + 1\n    if start < n - 1:\n        segments.append((start, n - 1))\n    elif start == n - 1:\n        segments.append((start, start))\n    \n    # Check if each segment can be sorted independently\n    for start, end in segments:\n        subarray = a[start:end+1]\n        if sorted(subarray) != list(range(start + 1, end + 2)) if start == 0 else list(range(start + 2, end + 2)):\n            return \"NO\"\n    \n    # Check if the segments are in the correct order\n    for i in range(len(segments) - 1):\n        if a[segments[i][1]] > a[segments[i + 1][0]]:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nswaps = input()\n\n# Output the result\nprint(can_sort_array(n, a, swaps))"}
{"solution": "def calculate_waiting_time(seat_info):\n    row, seat = seat_info[:-1], seat_info[-1]\n    row = int(row)\n    sequence_position = (row - 1) // 2\n    total_seconds = 0\n    \n    # Calculate time to reach the current row\n    if row % 2 == 1:\n        total_seconds += sequence_position * 6 + 3 * (sequence_position * (sequence_position + 1))\n    else:\n        total_seconds += (sequence_position + 1) * 6 + 3 * (sequence_position * (sequence_position + 1))\n    \n    # Calculate movement time to the current row\n    total_seconds += (row - 1) * 2\n    \n    # Calculate time to serve previous passengers in the current row\n    if seat in 'def':\n        total_seconds += ord(seat) - ord('d') + 3\n    else:\n        total_seconds += ord('d') - ord('a') + ord(seat) - ord('a') + 1\n    \n    return total_seconds\n\n# Read input\nseat_info = input().strip()\n\n# Calculate and print the waiting time\nprint(calculate_waiting_time(seat_info))"}
{"solution": "from itertools import accumulate\nfrom operator import mul\n\ndef convert_to_decimal(digits, base):\n    # Convert a number from a given base to decimal\n    return sum(val * (base ** idx) for idx, val in enumerate(reversed(digits)))\n\ndef compare_numbers():\n    # Read input for X\n    n, bx = map(int, input().split())\n    x_digits = list(map(int, input().split()))\n    \n    # Read input for Y\n    m, by = map(int, input().split())\n    y_digits = list(map(int, input().split()))\n    \n    # Convert X and Y to decimal\n    x_decimal = convert_to_decimal(x_digits, bx)\n    y_decimal = convert_to_decimal(y_digits, by)\n    \n    # Compare X and Y\n    if x_decimal == y_decimal:\n        print('=')\n    elif x_decimal < y_decimal:\n        print('<')\n    else:\n        print('>')\n\ncompare_numbers()"}
{"solution": "def calculate_grundy_number(nums):\n    max_val = max(nums)\n    grundy_numbers = [0] * (max_val + 1)\n    \n    # Calculate Grundy numbers for all possible values\n    for i in range(1, max_val + 1):\n        # Initialize the set of possible Grundy numbers\n        seen = set()\n        # Apply the first operation: decrease by x (1 <= x <= i)\n        for x in range(1, i + 1):\n            seen.add(grundy_numbers[i - x])\n        # Apply the second operation: decrease all by x (1 <= x <= min(nums))\n        for x in range(1, min(nums) + 1):\n            seen.add(grundy_numbers[i - x])\n        \n        # Find the minimum excluded value (mex)\n        mex = 0\n        while mex in seen:\n            mex += 1\n        grundy_numbers[i] = mex\n    \n    # XOR all Grundy numbers to find the overall game state\n    xor_result = 0\n    for num in nums:\n        xor_result ^= grundy_numbers[num]\n    \n    return xor_result\n\ndef main():\n    n = int(input())\n    nums = list(map(int, input().split()))\n    \n    # Calculate the Grundy number for the current state\n    grundy = calculate_grundy_number(nums)\n    \n    # Determine the winner\n    if grundy == 0:\n        print(\"BitAryo\")\n    else:\n        print(\"BitLGM\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from math import gcd\n\ndef count_valid_decks(n, k, cards):\n    prefix_gcd = [0] * (n + 1)\n    suffix_gcd = [0] * (n + 1)\n    \n    # Calculate prefix gcds\n    for i in range(1, n + 1):\n        prefix_gcd[i] = gcd(prefix_gcd[i - 1], cards[i - 1])\n    \n    # Calculate suffix gcds\n    for i in range(n - 1, -1, -1):\n        suffix_gcd[i] = gcd(suffix_gcd[i + 1], cards[i])\n    \n    # Count valid decks\n    valid_decks = 0\n    for i in range(n):\n        if gcd(prefix_gcd[i], suffix_gcd[i + 1]) % k == 0:\n            valid_decks += 1\n    \n    return valid_decks\n\n# Read input\nn, k = map(int, input().split())\ncards = list(map(int, input().split()))\n\n# Output result\nprint(count_valid_decks(n, k, cards))"}
{"solution": "from collections import Counter\n\ndef can_distribute_balloons(n, k, s):\n    # Count the frequency of each balloon color\n    color_counts = Counter(s)\n    \n    # Check if it's possible to distribute the balloons without upsetting any friend\n    max_color_count = max(color_counts.values())\n    return \"YES\" if max_color_count <= k else \"NO\"\n\n# Read input\nn, k = map(int, input().split())\ns = input()\n\n# Solve and print the result\nprint(can_distribute_balloons(n, k, s))"}
{"solution": "# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Finding the minimum value in the array\nmin_value = min(a)\n\n# Finding the indices of the minimum value\nindices_of_min = [i for i, x in enumerate(a) if x == min_value]\n\n# Calculating the distance between the two closest minimums\nmin_distance = min(indices_of_min[i+1] - indices_of_min[i] for i in range(len(indices_of_min)-1))\n\n# Printing the output\nprint(min_distance)"}
{"solution": "from math import gcd\n\ndef find_tie_probability(t, w, b):\n    def count_multiples(n, step):\n        return n // step\n    \n    def lcm(a, b):\n        return a * b // gcd(a, b)\n    \n    # Count multiples of w and b up to t\n    multiples_w = count_multiples(t, w)\n    multiples_b = count_multiples(t, b)\n    \n    # Count multiples of lcm(w, b) up to t\n    lcm_wb = lcm(w, b)\n    multiples_lcm = count_multiples(t, lcm_wb)\n    \n    # Calculate the number of ties\n    ties = multiples_w + multiples_b - 2 * multiples_lcm\n    \n    # Calculate the probability as an irreducible fraction\n    numerator = ties\n    denominator = t\n    common_divisor = gcd(numerator, denominator)\n    \n    return f\"{numerator // common_divisor}/{denominator // common_divisor}\"\n\n# Read input\nt, w, b = map(int, input().split())\n\n# Print the result\nprint(find_tie_probability(t, w, b))"}
{"solution": "def determine_vote_result(x, y, z):\n    # Check if the result is certain or uncertain based on x, y, and z\n    if z == 0:\n        # If z is 0, the result is certain based on x and y\n        if x > y:\n            return \"+\"\n        elif y > x:\n            return \"-\"\n        else:\n            return \"0\"\n    else:\n        # If z is not 0, check if the result can be uncertain\n        if x + z < y or y + z < x:\n            # If one side can never be equal or greater than the other, the result is certain\n            return \"-\" if x + z < y else \"+\"\n        else:\n            # If there's any possibility of changing the result, it is uncertain\n            return \"?\"\n\n# Read input\nx, y, z = map(int, input().split())\n\n# Output the result\nprint(determine_vote_result(x, y, z))"}
{"solution": "def min_subsegment_length(n, ops, target):\n    x, y = 0, 0\n    x_diff = 0\n    y_diff = 0\n    x_moves = [0] * (n + 1)\n    y_moves = [0] * (n + 1)\n    \n    for i, op in enumerate(ops):\n        if op == 'R': x += 1\n        elif op == 'L': x -= 1\n        elif op == 'U': y += 1\n        elif op == 'D': y -= 1\n        \n        x_diff = max(x_diff, abs(x - target[0]))\n        y_diff = max(y_diff, abs(y - target[1]))\n        \n        x_moves[i + 1] = x\n        y_moves[i + 1] = y\n    \n    if x_diff >= abs(target[0]) and y_diff >= abs(target[1]):\n        min_x = min(x_moves)\n        max_x = max(x_moves)\n        min_y = min(y_moves)\n        max_y = max(y_moves)\n        \n        for i in range(n + 1):\n            if (max_x - min_x >= abs(target[0]) and\n                max_y - min_y >= abs(target[1])):\n                return i\n            \n            if i < n:\n                if ops[i] in 'RL':\n                    min_x, max_x = min(min_x, x_moves[i]), max(max_x, x_moves[i])\n                else:\n                    min_y, max_y = min(min_y, y_moves[i]), max(max_y, y_moves[i])\n    return -1\n\n# Read input\nn = int(input())\nops = input()\ntarget = list(map(int, input().split()))\n\n# Compute and print the result\nprint(min_subsegment_length(n, ops, target))"}
{"solution": "from collections import defaultdict\n\ndef solve():\n    import sys\n    input = sys.stdin.readline\n    \n    T = int(input())\n    for _ in range(T):\n        n, x = map(int, input().split())\n        s = input().strip()\n        \n        balance_s = s.count('0') - s.count('1')\n        prefix_balances = [0]\n        \n        current_balance = 0\n        for char in s:\n            current_balance += 1 if char == '0' else -1\n            prefix_balances.append(current_balance)\n        \n        balance_count = defaultdict(int)\n        for balance in prefix_balances:\n            balance_count[balance] += 1\n        \n        if balance_s == 0:\n            if x == 0:\n                print(-1)\n            else:\n                print(0)\n        else:\n            count = 0\n            target_balance = x % balance_s\n            if target_balance < 0:\n                target_balance += balance_s\n            \n            for balance in prefix_balances:\n                if (balance == target_balance) and ((x - balance) % balance_s == 0):\n                    count += 1\n            \n            print(count)\n\nsolve()"}
{"solution": "def min_digits_to_delete(n, k):\n    # Convert the number to a string to easily manipulate individual digits\n    str_n = str(n)\n    # Calculate the divisor\n    divisor = 10 ** k\n    \n    # If n is already divisible by divisor, no digits need to be removed\n    if n % divisor == 0:\n        return 0\n    \n    # Initialize variables to track the minimum deletions and current deletions\n    min_deletions = float('inf')\n    current_deletions = 0\n    \n    # Iterate over each digit in the number\n    for i in range(len(str_n)):\n        # Check if the remaining part of the number is divisible by the divisor\n        suffix = int(str_n[i:])\n        if suffix % divisor == 0:\n            min_deletions = min(min_deletions, current_deletions)\n        else:\n            # If not, increment the current deletions\n            current_deletions += 1\n    \n    return min_deletions\n\n# Read input\nn, k = map(int, input().split())\n\n# Compute and print the result\nprint(min_digits_to_delete(n, k))"}
{"solution": "def calculate_questions(n, m, k, x, y):\n    # Calculate the number of students\n    num_students = n * m\n    \n    # Calculate the number of questions per full cycle\n    full_cycle_questions = 2 * (n - 1) if n > 1 else 1\n    \n    # Calculate the number of full cycles and remaining questions\n    full_cycles, remaining_questions = divmod(k, full_cycle_questions * m)\n    \n    # Calculate the maximum and minimum number of questions per student\n    max_questions = full_cycles * m\n    min_questions = max_questions\n    \n    # Adjust maximum if there are extra questions\n    if remaining_questions > 0:\n        max_questions += remaining_questions // m + 1\n    elif full_cycles % 2 == 1:\n        max_questions += 1\n    \n    # Adjust minimum if there are extra questions\n    if remaining_questions < m:\n        min_questions += remaining_questions // m\n    elif full_cycles % 2 == 0:\n        min_questions += 1\n    \n    # Calculate the number of times Sergei is asked\n    sergei_questions = full_cycles * (m if n > 1 else 1)\n    \n    # Determine the position of Sergei in the cycle\n    if n > 1:\n        if full_cycles % 2 == 0:\n            if remaining_questions >= (x - 1) * m + y:\n                sergei_questions += 1\n        else:\n            if remaining_questions >= (2 * n - x - 1) * m + y:\n                sergei_questions += 1\n    \n    return max_questions, min_questions, sergei_questions\n\n# Read input\nn, m, k, x, y = map(int, input().split())\n\n# Calculate and print the results\nmax_questions, min_questions, sergei_questions = calculate_questions(n, m, k, x, y)\nprint(max_questions, min_questions, sergei_questions)"}
{"solution": "from collections import Counter\n\ndef calculate_max_beauty(ribbon, turns):\n    ribbon_length = len(ribbon)\n    most_common_char, current_max_count = Counter(ribbon).most_common(1)[0]\n    current_beauty = current_max_count\n    max_possible_beauty = min(current_max_count + turns, ribbon_length)\n    \n    # Check if it's possible to make all characters the same\n    if max_possible_beauty == ribbon_length:\n        return ribbon_length\n    \n    # Otherwise, calculate the maximum beauty achievable\n    for char, count in Counter(ribbon).items():\n        if char != most_common_char:\n            new_count = count - (count - (ribbon_length - max_possible_beauty))\n            if new_count < 0:\n                new_count = 0\n            max_possible_beauty = max(max_possible_beauty, current_max_count + turns - (ribbon_length - new_count))\n    \n    return max_possible_beauty\n\ndef determine_winner(turns, ribbons):\n    max_beauties = [calculate_max_beauty(ribbon, turns) for ribbon in ribbons]\n    max_beauty = max(max_beauties)\n    \n    if max_beauties.count(max_beauty) > 1:\n        return \"Draw\"\n    \n    winners = [\"Kuro\", \"Shiro\", \"Katie\"]\n    return winners[max_beauties.index(max_beauty)]\n\n# Reading input\nturns = int(input())\nribbons = [input() for _ in range(3)]\n\n# Determining the winner\nwinner = determine_winner(turns, ribbons)\nprint(winner)"}
{"solution": "def calculate_reading_days(c, v_0, v_1, a, l):\n    total_pages_read = 0\n    current_speed = v_0\n    days = 0\n    \n    while total_pages_read < c:\n        days += 1\n        if current_speed > v_1:\n            current_speed = v_1\n        else:\n            current_speed = min(v_0 + (days - 1) * a, v_1)\n        \n        if days == 1:\n            pages_read_today = current_speed\n        else:\n            pages_read_today = current_speed - l\n        \n        if total_pages_read + pages_read_today >= c:\n            pages_read_today = c - total_pages_read\n        \n        total_pages_read += pages_read_today\n    \n    return days\n\n# Reading input\nc, v_0, v_1, a, l = map(int, input().split())\n\n# Calculating and printing the result\nprint(calculate_reading_days(c, v_0, v_1, a, l))"}
{"solution": "from math import sqrt\n\ndef is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_prime_sum(n):\n    if is_prime(n):\n        print(1)\n        print(n)\n    elif is_prime(n - 2):\n        print(2)\n        print(2, n - 2)\n    else:\n        for i in range(2, n):\n            if is_prime(i) and is_prime(n - i - 2) and is_prime(2):\n                print(3)\n                print(2, i, n - i - 2)\n                return\n\nn = int(input())\nfind_prime_sum(n)"}
{"solution": "def can_wipe_out_walls(rows, cols, grid):\n    wall_counts = [0] * (rows + cols)\n    wall_indices = set()\n    \n    # Count walls in each row and column\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '*':\n                wall_counts[i] += 1\n                wall_counts[rows + j] += 1\n                wall_indices.add((i, j))\n                \n    total_walls = sum(wall_counts) // 2\n    \n    # Check each cell\n    for i in range(rows):\n        for j in range(cols):\n            if (wall_counts[i] + wall_counts[rows + j] - (grid[i][j] == '*')) == total_walls:\n                return \"YES\", (i + 1, j + 1)\n    \n    return \"NO\", None\n\n# Read input\nn, m = map(int, input().split())\ndepot = [input() for _ in range(n)]\n\n# Solve the problem\nresult, coordinates = can_wipe_out_walls(n, m, depot)\n\n# Output the result\nprint(result)\nif result == \"YES\":\n    print(*coordinates)"}
{"solution": "def min_burles(n, m, a, b):\n    remainder = n % m\n    build_cost = (m - remainder) * a if remainder > 0 else 0\n    demolish_cost = remainder * b if remainder < m else 0\n    if b <= a:\n        return demolish_cost\n    else:\n        return min(build_cost, demolish_cost)\n\n# Example usage\nn, m, a, b = map(int, input().split())\nprint(min_burles(n, m, a, b))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmax_odd_sum = float('-inf')\nmax_even_sum = 0\nhas_odd = False\n\nfor num in a:\n    if num % 2 != 0:\n        has_odd = True\n        max_odd_sum = max(max_odd_sum, max_even_sum + num)\n    max_even_sum = max(max_even_sum + num, 0)\n\nif not has_odd:\n    # Since it's guaranteed there's at least one subsequence with an odd sum,\n    # this case won't happen, but included for completeness.\n    max_odd_sum = max(a)\n\nprint(max_odd_sum)"}
{"solution": "from collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_playlists(n, T, songs):\n    dp = [[[0 for _ in range(4)] for _ in range(T + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 1\n    \n    for i in range(n):\n        ti, gi = songs[i]\n        for j in range(T + 1):\n            for k in range(4):\n                if j >= ti:\n                    dp[i + 1][j][gi] += dp[i][j - ti][k]\n                    dp[i + 1][j][gi] %= MOD\n                if k != 0:\n                    dp[i + 1][j][k] += dp[i][j][k]\n                    dp[i + 1][j][k] %= MOD\n    \n    result = sum(dp[n][T][1:]) % MOD\n    return result\n\n# Read input\nn, T = map(int, input().split())\nsongs = [list(map(int, input().split())) for _ in range(n)]\n\n# Compute and print the result\nprint(count_playlists(n, T, songs))"}
{"solution": "from math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef mod_inverse(x):\n    return pow(x, MOD - 2, MOD)\n\ndef expected_length(m):\n    if m == 1:\n        return 1\n    \n    # Precompute factorials and their modular inverses\n    fact = [1] * (m + 1)\n    inv_fact = [1] * (m + 1)\n    for i in range(1, m + 1):\n        fact[i] = fact[i - 1] * i % MOD\n        inv_fact[i] = mod_inverse(fact[i])\n    \n    # Calculate the expected length\n    numerator = 0\n    denominator = 1\n    for x in range(1, m + 1):\n        prob = 1\n        for y in range(1, m + 1):\n            if gcd(x, y) == 1:\n                prob += 1 / m\n        numerator += x * prob\n        denominator += 1 / m\n    \n    # Simplify the fraction\n    gcd_val = reduce(gcd, [numerator, denominator])\n    P = int(numerator // gcd_val)\n    Q = int(denominator // gcd_val)\n    \n    # Calculate P * Q^-1 mod MOD\n    result = P * mod_inverse(Q) % MOD\n    return result\n\n# Read input\nm = int(input())\n\n# Print the result\nprint(expected_length(m))"}
{"solution": "from math import gcd\n\ndef count_good_pairs(l, r, x, y):\n    count = 0\n    # Check if y is divisible by x, since LCM(a, b) * GCD(a, b) = a * b\n    if y % x != 0:\n        return 0\n    \n    k = y // x  # k = a // x or b // x\n    for a in range(max(l, x), min(r + 1, x * k) + 1, x):\n        b_max = min(r, a * k)\n        b_min = max(l, a + 1)\n        if b_min <= b_max:\n            count += (b_max - b_min) // x + 1\n            if b_max % x == 0:\n                count -= 1\n    return count\n\n# Read input\nl, r, x, y = map(int, input().split())\n\n# Calculate and print the result\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "from math import gcd\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef find_smallest_k(a, b):\n    # Calculate the difference\n    diff = abs(a - b)\n    \n    # Calculate the initial gcd\n    initial_gcd = gcd(a, b)\n    \n    # Find the smallest k that minimizes the LCM\n    if a == b:\n        return 0\n    else:\n        # Check for the smallest k that makes gcd(a+k, b+k) maximum\n        for k in range(diff + 1):\n            if gcd(a + k, b + k) > initial_gcd:\n                return k\n        return diff\n\n# Read input\na, b = map(int, input().split())\n\n# Output the result\nprint(find_smallest_k(a, b))"}
{"solution": "def min_additional_marks(n, k, marks):\n    current_sum = sum(marks)\n    target_avg = k - 1 + 0.5  # Target average to round up to k\n    \n    # Calculate the minimum number of marks needed to reach the target average\n    min_marks_needed = max(0, int((target_avg * (n + 1) - current_sum + 0.5) / k))\n    \n    return min_marks_needed\n\n# Read input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_additional_marks(n, k, marks))"}
{"solution": "from math import ceil\n\ndef find_divisor(arr):\n    n = len(arr)\n    required_positives = ceil(n / 2)\n    pos_count = sum(1 for num in arr if num > 0)\n    \n    if pos_count >= required_positives:\n        return 1\n    \n    for d in range(-1000, 1001):\n        if d == 0:\n            continue\n        new_pos_count = sum(1 for num in arr if num / d > 0)\n        if new_pos_count >= required_positives:\n            return d\n    \n    return 0\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Solve and print the result\nprint(find_divisor(arr))"}
{"solution": "def max_nines_pairs(n):\n    # Calculate the maximum number of nines at the end of the sum\n    def max_nines(x):\n        count = 0\n        while x % 10 == 9:\n            count += 1\n            x //= 10\n        return count\n    \n    # Initialize variables\n    max_count = 0\n    pairs_count = 0\n    \n    # Iterate through possible pairs\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            current_sum = i + j\n            current_nines = max_nines(current_sum)\n            \n            # Update max_count if a new maximum is found\n            if current_nines > max_count:\n                max_count = current_nines\n                pairs_count = 1\n            elif current_nines == max_count:\n                pairs_count += 1\n                \n    return pairs_count\n\n# Read input\nn = int(input())\n\n# Compute and print the result\nprint(max_nines_pairs(n))"}
{"solution": "from math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef find_min_minutes(a1, b1, a2, b2):\n    area1 = a1 * b1\n    area2 = a2 * b2\n    \n    # Check if it's impossible to equalize the areas\n    if lcm(area1, area2) > 10**18:\n        return -1, None, None\n    \n    lcm_area = lcm(area1, area2)\n    minutes1 = 0\n    minutes2 = 0\n    \n    # Calculate minutes to reach LCM area for both bars\n    while area1 != lcm_area:\n        if area1 % 2 == 0:\n            area1 //= 2\n            minutes1 += 1\n        elif area1 % 3 == 0:\n            area1 //= 3\n            minutes1 += 1\n        else:\n            return -1, None, None\n    \n    while area2 != lcm_area:\n        if area2 % 2 == 0:\n            area2 //= 2\n            minutes2 += 1\n        elif area2 % 3 == 0:\n            area2 //= 3\n            minutes2 += 1\n        else:\n            return -1, None, None\n    \n    total_minutes = minutes1 + minutes2\n    \n    # Generate possible sizes after the process\n    size1 = (a1 * (lcm_area // area1), b1 * (lcm_area // area1))\n    size2 = (a2 * (lcm_area // area2), b2 * (lcm_area // area2))\n    \n    return total_minutes, size1, size2\n\n# Read input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\n# Calculate result\nresult = find_min_minutes(a1, b1, a2, b2)\n\nif result[0] == -1:\n    print(-1)\nelse:\n    print(result[0])\n    print(*result[1])\n    print(*result[2])"}
{"solution": "def determine_winner(x_p, y_p, x_v, y_v):\n    # Polycarp's moves\n    polycarp_moves = x_p + y_p\n    \n    # Vasiliy's moves\n    vasiliy_moves = min(x_v, y_v) + abs(x_v - y_v)\n    \n    # Determine the winner based on the minimum number of moves required\n    if polycarp_moves < vasiliy_moves:\n        return \"Polycarp\"\n    else:\n        return \"Vasiliy\"\n\n# Read input\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Output the winner\nprint(determine_winner(x_p, y_p, x_v, y_v))"}
{"solution": "# Import necessary library\nfrom math import ceil\n\ndef calculate_calendar_columns(month, start_day):\n    \"\"\"\n    Calculate the number of columns needed for a monthly calendar.\n    \n    Args:\n    month (int): The month number (1-12).\n    start_day (int): The weekday of the first date of the month (1-Monday, 7-Sunday).\n    \n    Returns:\n    int: The number of columns required for the calendar.\n    \"\"\"\n    # Days in each month for a non-leap year\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    # Adjust start_day to be 0-based index (Monday=0, ..., Sunday=6)\n    start_day -= 1\n    \n    # Total number of days in the given month\n    total_days = days_in_month[month - 1]\n    \n    # Calculate the number of full weeks and the remaining days\n    full_weeks = total_days // 7\n    remaining_days = total_days % 7\n    \n    # Calculate the total number of columns\n    # First column may not start from Monday\n    first_column_days = 7 - start_day if (start_day + remaining_days) >= 7 else (7 - start_day) + remaining_days\n    columns_needed = full_weeks + ceil(remaining_days / 7) + (1 if start_day > 0 else 0)\n    \n    return max(ceil((start_day + total_days) / 7), columns_needed)\n\n# Read input\nm, d = map(int, input().split())\n\n# Calculate and print the number of columns\nprint(calculate_calendar_columns(m, d))"}
{"solution": "def count_years_with_one_zero(a, b):\n    def count_up_to(n):\n        if n == 0:\n            return 0\n        \n        binary_str = bin(n)[2:]  # Convert to binary and remove the '0b' prefix.\n        count = 0\n        length = len(binary_str)\n        \n        # Count years with exactly one zero up to the highest bit position.\n        for i in range(1, length):\n            if binary_str[i] == '0':\n                count += int(binary_str[:i], 2) * (2 ** (length - i - 1))\n        \n        # Handle the remaining part after the last zero.\n        remaining = int(binary_str[length - 1])\n        if remaining == 0:\n            count += 1\n        \n        # Subtract the count of years with more than one zero in the remaining part.\n        for i in range(length - 1):\n            if binary_str[i] == '0':\n                remaining_part = int(binary_str[i + 1:], 2)\n                if remaining_part > 0:\n                    count -= 1\n        \n        return count\n    \n    return count_up_to(b) - count_up_to(a - 1)\n\n# Read input\na, b = map(int, input().split())\n\n# Output result\nprint(count_years_with_one_zero(a, b))"}
{"solution": "def minimal_layers(N):\n    return (N * (N + 1)) // 2\n\nN = int(input())\nprint(minimal_layers(N))"}
{"solution": "from itertools import combinations\nfrom math import factorial\n\ndef count_ways(n, k, S, cubes):\n    # Precompute factorials for efficiency\n    precomputed_factorials = {cube: factorial(cube) for cube in cubes}\n    \n    def dfs(index, remaining_k, current_sum, target):\n        if current_sum == target:\n            return 1\n        if index >= n or current_sum > target:\n            return 0\n        \n        # Skip current cube\n        ways = dfs(index + 1, remaining_k, current_sum, target)\n        \n        # Include current cube without sticker\n        ways += dfs(index + 1, remaining_k, current_sum + cubes[index], target)\n        \n        # Include current cube with sticker if possible\n        if remaining_k > 0:\n            ways += dfs(index + 1, remaining_k - 1, current_sum + precomputed_factorials[cubes[index]], target)\n        \n        return ways\n    \n    return dfs(0, k, 0, S)\n\n# Read input\nn, k, S = map(int, input().split())\ncubes = list(map(int, input().split()))\n\n# Compute and print the result\nprint(count_ways(n, k, S, cubes))"}
{"solution": "from collections import defaultdict\n\ndef can_transform(n, k, a):\n    powers = defaultdict(int)\n    for value in a:\n        current = value\n        while current > 0:\n            found = False\n            for power in range(20):  # Considering the maximum power of k that fits within 10^16\n                if current % (k ** power) == 0:\n                    current //= (k ** power)\n                    powers[power] += 1\n                    found = True\n                    break\n            if not found:\n                return \"NO\"\n    for count in powers.values():\n        if count > 1:\n            return \"NO\"\n    return \"YES\"\n\n# Reading input\nT = int(input())\nfor _ in range(T):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(can_transform(n, k, a))"}
{"solution": "def d(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count\n\ndef calculate_divisor_sum(a, b, c):\n    MOD = 1073741824\n    total_sum = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                total_sum += d(i * j * k)\n                total_sum %= MOD\n    return total_sum\n\n# Read input\na, b, c = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_divisor_sum(a, b, c))"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    neighbors = []\n    idx = state.index('X')\n    moves = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    for dx, dy in moves:\n        new_idx = idx + dx + dy * 2\n        if 0 <= new_idx < 4:\n            new_state = list(state)\n            new_state[idx], new_state[new_idx] = new_state[new_idx], new_state[idx]\n            neighbors.append(''.join(new_state))\n    return neighbors\n\ndef bfs(start):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        current = queue.popleft()\n        for neighbor in get_neighbors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return visited\n\ndef can_be_same_configuration(bessie, elsie):\n    bessie_start = ''.join(bessie)\n    elsie_start = ''.join(elsie)\n    \n    bessie_reachable = bfs(bessie_start)\n    elsie_reachable = bfs(elsie_start)\n    \n    return not bessie_reachable.isdisjoint(elsie_reachable)\n\n# Input reading\nbessie = [input().strip() for _ in range(2)]\nelsie = [input().strip() for _ in range(2)]\n\nif can_be_same_configuration(bessie, elsie):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_decimal_number(n, k):\n    def convert_to_decimal(num_str, base):\n        num_str = str(num_str)\n        length = len(num_str)\n        decimal_num = 0\n        for i in range(length):\n            decimal_num += int(num_str[i]) * (base ** (length - i - 1))\n        return decimal_num\n\n    left, right = 0, 10**18\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if convert_to_decimal(mid, n) >= k:\n            right = mid\n        else:\n            left = mid\n\n    if convert_to_decimal(right, n) == k:\n        return right\n    return left\n\n# Reading input\nn = int(input())\nk = int(input())\n\n# Calculating and printing the result\nprint(min_decimal_number(n, k))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ndef is_unimodal(arr):\n    increasing = False\n    constant = True\n    decreasing = False\n    \n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            if decreasing:\n                return False\n            increasing = True\n            constant = False\n        elif arr[i] < arr[i - 1]:\n            if not increasing and not constant:\n                return False\n            decreasing = True\n        else:  # Constant\n            if decreasing:\n                return False\n            constant = True\n    \n    return True\n\nif is_unimodal(a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def max_value_in_paths(n, k):\n    def path_length(x):\n        length = 0\n        while x > 0:\n            if x % 2 == 0:\n                x //= 2\n            else:\n                x -= 1\n            length += 1\n        return length\n\n    low, high = 1, n\n    result = 0\n\n    while low <= high:\n        mid = (low + high) // 2\n        count = 0\n        current_max = mid\n\n        # Calculate the number of times 'mid' can appear in paths\n        while mid >= 1 and count < k:\n            if mid % 2 == 0:\n                mid //= 2\n            else:\n                mid -= 1\n            count += 1\n\n        # Calculate the number of paths that include 'current_max'\n        total_paths = n - (n - current_max + 1 - path_length(current_max))\n\n        if total_paths >= k:\n            result = current_max\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return result\n\n# Read input\nn, k = map(int, input().split())\n\n# Output the result\nprint(max_value_in_paths(n, k))"}
{"solution": "def determine_pocket(n, m, x, y, vx, vy):\n    if vx == 0 and vy == 0:\n        return -1  # Ball does not move\n    \n    # Check if the ball is initially in a pocket\n    if x in [0, n] or y in [0, m]:\n        return -1\n    \n    # Calculate the next intersection points\n    if vx != 0:\n        t = (n - x) // abs(vx) if vx > 0 else -x // abs(vx)\n        y_next = y + vy * t\n        if 0 <= y_next < m:\n            x += vx * t\n        else:\n            t = (m - y) // abs(vy) if vy > 0 else -y // abs(vy)\n            x_next = x + vx * t\n            if 0 <= x_next < n:\n                y += vy * t\n            else:\n                return -1\n    else:\n        t = (m - y) // abs(vy) if vy > 0 else -y // abs(vy)\n        y += vy * t\n    \n    # Determine the pocket based on the final coordinates\n    if x == n and 0 <= y < m:\n        return n, m\n    elif x == 0 and 0 <= y < m:\n        return 0, y\n    elif 0 <= x < n and y == m:\n        return x, m\n    elif 0 <= x < n and y == 0:\n        return x, 0\n    else:\n        return -1\n\n# Read input\nn, m, x, y, vx, vy = map(int, input().split())\n\n# Determine and print the pocket\nresult = determine_pocket(n, m, x, y, vx, vy)\nprint(*result)"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    # Check if two rectangles (a2, b2) and (a3, b3) can fit in (a1, b1)\n    def fits(w1, h1, w2, h2, W, H):\n        return (w1 + w2 <= W and max(h1, h2) <= H) or (h1 + h2 <= H and max(w1, w2) <= W)\n    \n    # Check all combinations of orientations\n    if (fits(a2, b2, a3, b3, a1, b1) or fits(b2, a2, a3, b3, a1, b1) or\n        fits(a2, b2, b3, a3, a1, b1) or fits(b2, a2, b3, a3, a1, b1) or\n        fits(a3, b3, a2, b2, a1, b1) or fits(b3, a3, a2, b2, a1, b1) or\n        fits(a3, b3, b2, a2, a1, b1) or fits(b3, a3, b2, a2, a1, b1)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\n# Output result\nprint(can_place_paintings(a1, b1, a2, b2, a3, b3))"}
{"solution": "def count_good_terms(b1, q, l, bad_integers):\n    if q == 0:\n        if abs(b1) <= l and b1 not in bad_integers:\n            return \"inf\"\n        else:\n            return 0\n    \n    count = 0\n    current_term = b1\n    seen = set()\n    \n    while abs(current_term) <= l and current_term not in bad_integers and current_term not in seen:\n        seen.add(current_term)\n        count += 1\n        current_term *= q\n    \n    if current_term in seen:\n        return \"inf\"\n    \n    return count\n\n# Reading input\nb1, q, l, m = map(int, input().split())\nbad_integers = set(map(int, input().split()))\n\n# Calculating and printing the result\nresult = count_good_terms(b1, q, l, bad_integers)\nprint(result)"}
{"solution": "def find_smallest_frame(matrix):\n    n, m = len(matrix), len(matrix[0])\n    \n    # Find top-left and bottom-right corners of the white pixels\n    top, left, bottom, right = n, m, 0, 0\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == 'w':\n                top = min(top, i)\n                left = min(left, j)\n                bottom = max(bottom, i)\n                right = max(right, j)\n    \n    # Check if the white pixels form a valid frame\n    valid_frame = True\n    for i in range(top, bottom + 1):\n        if matrix[i][left] != 'w' or matrix[i][right] != 'w':\n            valid_frame = False\n            break\n    for j in range(left, right + 1):\n        if matrix[top][j] != 'w' or matrix[bottom][j] != 'w':\n            valid_frame = False\n            break\n    \n    if not valid_frame:\n        return -1\n    \n    # Draw the frame\n    for i in range(top, bottom + 1):\n        for j in range(left, right + 1):\n            if (i == top or i == bottom) or (j == left or j == right):\n                if matrix[i][j] != 'w':\n                    matrix[i] = matrix[i][:j] + '+' + matrix[i][j+1:]\n    \n    # Convert matrix back to string\n    result = '\\n'.join(matrix)\n    return result\n\n# Read input\nn, m = map(int, input().split())\nmatrix = [input() for _ in range(n)]\n\n# Solve and print output\nresult = find_smallest_frame(matrix)\nprint(result)"}
{"solution": "def can_spend_exactly(n, a, b):\n    for x in range(n // a + 1):\n        y = (n - a * x) / b\n        if y.is_integer() and y >= 0:\n            return \"YES\\n{} {}\".format(x, int(y))\n    return \"NO\"\n\n# Reading input\nn = int(input())\na = int(input())\nb = int(input())\n\n# Processing and printing output\nprint(can_spend_exactly(n, a, b))"}
{"solution": "def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\ns = int(input())\nprint(number_to_words(s))"}
{"solution": "def max_elements_to_erase(n, arr):\n    # Edge case: if the array has only one element, no elements can be erased\n    if n == 1:\n        return 0\n    \n    # Find the minimum number of elements needed to determine the sequence\n    min_needed = 2  # At least two elements are needed to determine the sequence\n    \n    # Check if the first two or last two elements are enough\n    if arr[0] > 1:\n        return min(n - 2, n - 1)\n    elif arr[-1] < 1000:\n        return min(n - 2, n - 1)\n    \n    # Iterate through the array to find the minimum number of elements needed\n    for i in range(1, n):\n        if arr[i] - arr[i - 1] > 1:\n            min_needed = i + 1\n            break\n    \n    # Calculate the maximum number of elements that can be erased\n    max_erase = n - min_needed\n    \n    # Ensure the maximum number of elements to erase is not more than n - 2\n    return min(max_erase, n - 2)\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output the result\nprint(max_elements_to_erase(n, arr))"}
{"solution": "# Import necessary packages\nfrom itertools import accumulate\n\ndef find_equator_day(n, problems):\n    # Calculate the cumulative sum of problems solved each day\n    cumulative_problems = list(accumulate(problems))\n    \n    # Total number of problems to be solved\n    total_problems = cumulative_problems[-1]\n    \n    # Find the day when Polycarp solves half or more of all the problems\n    for day in range(n):\n        if cumulative_problems[day] >= total_problems / 2:\n            return day + 1  # Days are 1-indexed\n\n# Read input\nn = int(input())\nproblems = list(map(int, input().split()))\n\n# Output the result\nprint(find_equator_day(n, problems))"}
{"solution": "from collections import defaultdict, deque\n\ndef bfs(graph, start, target, piece):\n    queue = deque([(start, 0, 0)])  # (position, steps, replacements)\n    visited = {start}\n    \n    while queue:\n        pos, steps, replacements = queue.popleft()\n        if pos == target:\n            return steps, replacements\n        \n        for next_pos in graph[piece][pos]:\n            if next_pos not in visited:\n                visited.add(next_pos)\n                queue.append((next_pos, steps + 1, replacements))\n    \n    return float('inf'), float('inf')\n\ndef solve_chess_puzzle(N, board):\n    # Initialize graphs for each piece\n    knight_graph = defaultdict(list)\n    bishop_graph = defaultdict(list)\n    rook_graph = defaultdict(list)\n    \n    # Populate the graphs based on the board layout\n    for i in range(N):\n        for j in range(N):\n            pos = (i, j)\n            num = board[i][j]\n            \n            # Knight moves\n            knight_moves = [(i + 2, j + 1), (i + 2, j - 1), (i - 2, j + 1), (i - 2, j - 1),\n                            (i + 1, j + 2), (i + 1, j - 2), (i - 1, j + 2), (i - 1, j - 2)]\n            for move in knight_moves:\n                if 0 <= move[0] < N and 0 <= move[1] < N:\n                    knight_graph[num].append(board[move[0]][move[1]])\n            \n            # Bishop moves\n            directions = [(1, 1), (-1, -1), (1, -1), (-1, 1)]\n            for dx, dy in directions:\n                x, y = pos\n                while 0 <= x + dx < N and 0 <= y + dy < N:\n                    x, y = x + dx, y + dy\n                    bishop_graph[num].append(board[x][y])\n            \n            # Rook moves\n            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                x, y = pos\n                while 0 <= x + dx < N and 0 <= y + dy < N:\n                    x, y = x + dx, y + dy\n                    rook_graph[num].append(board[x][y])\n    \n    # BFS to find the shortest path and minimum replacements\n    start = 1\n    target = N * N\n    min_steps = float('inf')\n    min_replacements = float('inf')\n    \n    for piece in ['knight', 'bishop', 'rook']:\n        steps, replacements = bfs({piece: getattr(defaultdict(list), piece)}, start, target, piece)\n        if steps < min_steps or (steps == min_steps and replacements < min_replacements):\n            min_steps = steps\n            min_replacements = replacements\n    \n    return min_steps, min_replacements\n\n# Read input\nN = int(input())\nboard = [list(map(int, input().split())) for _ in range(N)]\n\n# Solve the puzzle\nresult = solve_chess_puzzle(N, board)\nprint(*result)"}
{"solution": "from collections import deque\n\ndef min_time_to_reach(n, m, k, a, b):\n    def apartment_to_coords(apartment):\n        return (apartment - 1) // (m * k), ((apartment - 1) % (m * k)) // k, (apartment - 1) % k\n\n    edward_building, edward_floor, _ = apartment_to_coords(a)\n    natasha_building, natasha_floor, _ = apartment_to_coords(b)\n\n    # Time to move between buildings\n    time_between_buildings = abs(edward_building - natasha_building) * 15\n    if time_between_buildings == 0:\n        time_between_buildings = 15  # Going out and back in\n\n    # Time to use stairs or elevator\n    def calculate_time(current_floor, target_floor):\n        # Using stairs\n        stairs_time = abs(current_floor - target_floor) * 5\n        # Using elevator\n        elevator_time = 10 + abs(current_floor - target_floor)\n        return min(stairs_time, elevator_time)\n\n    # Calculate time to reach target floor\n    time_to_target_floor = calculate_time(edward_floor, natasha_floor)\n\n    # Total time considering both building transition and floor transition\n    total_time = time_between_buildings + time_to_target_floor\n    return total_time\n\n# Read input\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(min_time_to_reach(n, m, k, a, b))"}
{"solution": "def is_divisible_by_64(binary_str):\n    # Check if the string can be transformed to be divisible by 64\n    # A binary number is divisible by 64 if its last 6 bits are zeros\n    # Remove all '1's except the leading one (if any)\n    cleaned_str = binary_str.lstrip('1')\n    \n    # Check if the remaining string is all zeros and at least 6 zeros long\n    return len(cleaned_str) >= 6 and '1' not in cleaned_str\n\n# Read input\nbinary_str = input()\n\n# Output result\nprint('yes' if is_divisible_by_64(binary_str) else 'no')"}
{"solution": "from collections import defaultdict\n\ndef next_char(c):\n    return 'a' if c == 'z' else chr(ord(c) + 1)\n\ndef find_solution(s):\n    alphabet_count = defaultdict(int)\n    for char in s:\n        alphabet_count[char] += 1\n    \n    result = []\n    current_char = 'a'\n    \n    while len(result) < 26:\n        found = False\n        for char in sorted(alphabet_count.keys()):\n            if char >= current_char:\n                result.append(char)\n                alphabet_count[char] -= 1\n                if alphabet_count[char] == 0:\n                    del alphabet_count[char]\n                found = True\n                break\n        if not found:\n            return -1\n        current_char = next_char(current_char)\n    \n    return ''.join(result)\n\ns = input()\nprint(find_solution(s))"}
{"solution": "from math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef max_expected_fish(n, m, r, k):\n    total_positions = (n - r + 1) * (m - r + 1)\n    \n    def compute_expected_value(row_coverage, col_coverage):\n        valid_positions = (n - r + 1 - row_coverage) * (m - r + 1 - col_coverage)\n        fish_in_scoop = row_coverage * col_coverage\n        return fish_in_scoop * (total_positions - valid_positions) / total_positions\n    \n    max_expected = 0\n    for row_coverage in range(min(n, r, k) + 1):\n        remaining_fish = k - row_coverage\n        if remaining_fish < 0:\n            break\n        col_coverage = min(remaining_fish // (r - row_coverage), m - 1)\n        max_expected = max(max_expected, compute_expected_value(row_coverage, col_coverage))\n    \n    # Special case where all fishes fit perfectly within the scoop-net\n    if k <= r * r:\n        max_expected = max(max_expected, k * (r * r) / (r * r))\n    \n    return max_expected\n\n# Reading input\nn, m, r, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(max_expected_fish(n, m, r, k))"}
{"solution": "def max_product_array(n, a):\n    # Count negative and non-positive numbers\n    count_negative = sum(1 for x in a if x < 0)\n    count_non_positive = sum(1 for x in a if x <= 0)\n    \n    # If there are no negative numbers or exactly one negative number and no zeros, invert all\n    if count_negative == 0 or (count_negative == 1 and count_non_positive == 1):\n        a = [-x - 1 for x in a]\n    else:\n        # Otherwise, only invert non-positive numbers\n        a = [-x - 1 if x <= 0 else x for x in a]\n    \n    return a\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Compute and print the result\nresult = max_product_array(n, a)\nprint(*result)"}
{"solution": "import math\n\ndef find_kth_divisor(n, k):\n    def enough_divisors(x):\n        count, max_divisor = 0, min(int(math.sqrt(n)), n // x)\n        for i in range(1, max_divisor + 1):\n            if n % i == 0:\n                count += 1\n                if i >= x:\n                    break\n                if n // i != i and n // i < x:\n                    count += 1\n        return count >= k\n\n    low, high = 1, n + 1\n    while low < high:\n        mid = (low + high) // 2\n        if enough_divisors(mid):\n            high = mid\n        else:\n            low = mid + 1\n    \n    if low == n + 1 or not enough_divisors(low):\n        return -1\n    else:\n        return low\n\n# Read input\nn, k = map(int, input().split())\n\n# Solve and print the result\nprint(find_kth_divisor(n, k))"}
{"solution": "def max_number_formable(cubes):\n    # Check if a number can be formed\n    def can_form_number(number):\n        required_digits = [int(digit) for digit in str(number)]\n        for digit in required_digits:\n            if digit == 6 or digit == 9:\n                if counts[6] + counts[9] < required_digits.count(6) + required_digits.count(9):\n                    return False\n            elif digit not in available_digits:\n                return False\n        return True\n\n    available_digits = set()\n    counts = {6: 0, 9: 0}\n    \n    for cube in cubes:\n        for face in cube:\n            if face == 6 or face == 9:\n                counts[6] += 1\n            else:\n                available_digits.add(face)\n    \n    max_x = 0\n    for x in range(1, 1000):  # Assuming the maximum number is within a reasonable range\n        if can_form_number(x):\n            max_x = x\n        else:\n            break\n    \n    return max_x\n\n# Read input\nn = int(input())\ncubes = []\nfor _ in range(n):\n    cubes.append(list(map(int, input().split())))\n\n# Print the result\nprint(max_number_formable(cubes))"}
{"solution": "def k_rounding(n, k):\n    if k == 0:\n        return n\n    power_of_5 = 0\n    power_of_2 = 0\n    \n    # Calculate the number of 5s in the factorization of n\n    while n % 5 == 0:\n        n //= 5\n        power_of_5 += 1\n    \n    # Calculate the number of 2s in the factorization of n\n    while n % 2 == 0:\n        n //= 2\n        power_of_2 += 1\n    \n    # Determine the minimum power needed to achieve k zeros\n    min_power = max(k - power_of_5, k - power_of_2)\n    \n    # Calculate the result\n    result = n * (2 ** max(0, min_power - power_of_2)) * (5 ** max(0, min_power - power_of_5))\n    return result * (10 ** max(0, k - min_power))\n\n# Read input\nn, k = map(int, input().split())\n\n# Compute and print the k-rounding of n\nprint(k_rounding(n, k))"}
{"solution": "def transform_matrix(n, m, A):\n    operations = []\n    B = [[0] * m for _ in range(n)]\n    \n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                operations.append((i + 1, j + 1))\n                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1\n    \n    for i in range(n):\n        for j in range(m):\n            if A[i][j] != B[i][j]:\n                return -1\n    \n    return operations\n\n# Input reading\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\n# Process the transformation\nresult = transform_matrix(n, m, A)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for x, y in result:\n        print(x, y)"}
{"solution": "from itertools import accumulate\n\ndef solve(r, s, p):\n    def compute_prob(x, y):\n        if x == 0:\n            return 0\n        if y == 0:\n            return 1\n        return (x / (x + y)) * (1 - compute_prob(y, x))\n\n    total = r + s + p\n    prob_r = compute_prob(r, s + p)\n    prob_s = compute_prob(s, r + p)\n    prob_p = 1 - (prob_r + prob_s)\n\n    # Normalize probabilities\n    normalization_factor = 1 / (compute_prob(r, s + p) + compute_prob(s, r + p) + compute_prob(p, r + s))\n    prob_r *= normalization_factor\n    prob_s *= normalization_factor\n    prob_p *= normalization_factor\n\n    return prob_r, prob_s, prob_p\n\nr, s, p = map(int, input().split())\nresult = solve(r, s, p)\nprint(f\"{result[0]:.15f} {result[1]:.15f} {result[2]:.15f}\")"}
{"solution": "def calculate_together_time(l1, r1, l2, r2, k):\n    # Find the intersection of the two intervals\n    start = max(l1, l2)\n    end = min(r1, r2)\n    \n    # If there is no intersection, return 0\n    if start > end:\n        return 0\n    \n    # Adjust the intersection if it includes the prinking minute\n    if start <= k <= end:\n        end = k - 1\n    \n    # Calculate the duration of the intersection\n    together_time = max(0, end - start + 1)\n    \n    return together_time\n\n# Read input\nl1, r1, l2, r2, k = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_together_time(l1, r1, l2, r2, k))"}
{"solution": "from typing import List, Tuple\nimport sys\n\ndef cross(a: Tuple[int, int], b: Tuple[int, int]) -> int:\n    return a[0] * b[1] - a[1] * b[0]\n\ndef ccw(p: Tuple[int, int], q: Tuple[int, int], r: Tuple[int, int]) -> int:\n    a = (q[0] - p[0], q[1] - p[1])\n    b = (r[0] - p[0], r[1] - p[1])\n    return cross(a, b)\n\ndef intersect(p1: Tuple[int, int], p2: Tuple[int, int], q1: Tuple[int, int], q2: Tuple[int, int]) -> bool:\n    return ccw(p1, p2, q1) * ccw(p1, p2, q2) <= 0 and ccw(q1, q2, p1) * ccw(q1, q2, p2) <= 0\n\ndef find_intersection(p1: Tuple[int, int], p2: Tuple[int, int], q1: Tuple[int, int], q2: Tuple[int, int]) -> Tuple[int, int]:\n    det = (p2[0] - p1[0]) * (q2[1] - q1[1]) - (p2[1] - p1[1]) * (q2[0] - q1[0])\n    if det == 0:\n        return (0, 0)\n    t = ((p2[0] - p1[0]) * (q2[0] - q1[0]), (p2[1] - p1[1]) * (q2[1] - q1[1]))\n    u = ((p2[0] - p1[0]) * (q1[1] - p1[1]), (p2[1] - p1[1]) * (q1[0] - p1[0]))\n    return (u[0] // det, u[1] // det)\n\ndef calculate_area(points: List[Tuple[int, int]]) -> int:\n    area = 0\n    n = len(points)\n    for i in range(n):\n        j = (i + 1) % n\n        area += points[i][0] * points[j][1]\n        area -= points[j][0] * points[i][1]\n    return abs(area) // 2\n\ndef main():\n    input = sys.stdin.readline\n    N, M = map(int, input().split())\n    vertical_lines = [tuple(map(int, input().split())) for _ in range(N)]\n    horizontal_lines = [tuple(map(int, input().split())) for _ in range(M)]\n\n    intersections = set([(0, 0)])\n    \n    for i in range(N):\n        for j in range(M):\n            if intersect((vertical_lines[i][0], vertical_lines[i][2]), (vertical_lines[i][1], vertical_lines[i][2]),\n                         (horizontal_lines[j][1], horizontal_lines[j][2]), (horizontal_lines[j][1], horizontal_lines[j][3])):\n                intersection_point = find_intersection((vertical_lines[i][0], vertical_lines[i][2]), (vertical_lines[i][1], vertical_lines[i][2]),\n                                                       (horizontal_lines[j][1], horizontal_lines[j][2]), (horizontal_lines[j][1], horizontal_lines[j][3]))\n                intersections.add(intersection_point)\n\n    if len(intersections) <= 2:\n        print(\"INF\")\n        return\n\n    points = sorted(list(intersections))\n    area = calculate_area(points)\n    print(area)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "t, s, x = map(int, input().split())\n\nif t == x or (x - t) % (s + 1) < 2 and (x - t) % (s + 1) >= 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "from typing import List\n\ndef find_nested_segments(segments: List[List[int]]) -> List[int]:\n    n = len(segments)\n    result = [-1, -1]\n    \n    # Sort segments by their left boundary, and then by right boundary in descending order\n    segments.sort(key=lambda x: (x[0], -x[1]))\n    \n    max_right = -1\n    for i in range(n):\n        if segments[i][1] < max_right:\n            result = [i + 1, segments.index([segments[i][0], max_right]) + 1]\n            break\n        else:\n            max_right = segments[i][1]\n    \n    return result\n\n# Reading input\nn = int(input())\nsegments = [list(map(int, input().split())) for _ in range(n)]\n\n# Solving the problem\nresult = find_nested_segments(segments)\n\n# Printing output\nprint(*result)"}
{"solution": "def decode_genome(n, s):\n    counts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\n    question_marks = 0\n    \n    # Count existing nucleotides and question marks\n    for char in s:\n        if char != '?':\n            counts[char] += 1\n        else:\n            question_marks += 1\n    \n    # Calculate the target count for each nucleotide\n    target_count = n // 4\n    \n    # Check if it's possible to decode\n    if n % 4 != 0 or sum(count > target_count for count in counts.values()) > question_marks:\n        return \"===\"\n\n    # Decode the genome\n    result = list(s)\n    for char in 'ACGT':\n        needed = target_count - counts[char]\n        index = 0\n        while needed > 0:\n            if result[index] == '?':\n                result[index] = char\n                needed -= 1\n            index += 1\n    \n    return ''.join(result)\n\n# Read input\nn = int(input())\ns = input()\n\n# Print output\nprint(decode_genome(n, s))"}
{"solution": "def check_horizontal(board):\n    for row in board:\n        count_x = sum(1 for cell in row if cell == 'x')\n        dots = sum(1 for cell in row if cell == '.')\n        if count_x == 2 and dots >= 1:\n            return True\n    return False\n\ndef check_vertical(board):\n    for col in range(4):\n        count_x = sum(1 for row in board for cell in row[col:col+4:4] if cell == 'x')\n        dots = sum(1 for row in board for cell in row[col:col+4:4] if cell == '.')\n        if count_x == 2 and dots >= 1:\n            return True\n    return False\n\ndef check_diagonal(board):\n    # Main diagonal\n    count_x = sum(1 for i in range(4) for cell in board[i][i:i+1] if cell == 'x')\n    dots = sum(1 for i in range(4) for cell in board[i][i:i+1] if cell == '.')\n    if count_x == 2 and dots >= 1:\n        return True\n    \n    # Anti-diagonal\n    count_x = sum(1 for i in range(4) for cell in board[i][3-i:4-i] if cell == 'x')\n    dots = sum(1 for i in range(4) for cell in board[i][3-i:4-i] if cell == '.')\n    if count_x == 2 and dots >= 1:\n        return True\n    \n    return False\n\ndef can_ilya_win(board):\n    if check_horizontal(board) or check_vertical(board) or check_diagonal(board):\n        return \"YES\"\n    return \"NO\"\n\n# Reading the board\nboard = [input() for _ in range(4)]\n\n# Output the result\nprint(can_ilya_win(board))"}
{"solution": "def can_balance_array(n, arr):\n    total_sum = sum(arr)\n    prefix_sum = 0\n    \n    # Count occurrences of each number\n    count_map = {}\n    for num in arr:\n        if num in count_map:\n            count_map[num] += 1\n        else:\n            count_map[num] = 1\n    \n    # Check if balancing is possible by moving one element\n    for i in range(n):\n        prefix_sum += arr[i]\n        suffix_sum = total_sum - prefix_sum + arr[i]\n        \n        if prefix_sum == suffix_sum:\n            # Check if removing the current element leaves enough occurrences to still form the required sum\n            if count_map[arr[i]] > 1 or (count_map[arr[i]] == 1 and i != 0 and i != n - 1):\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output result\nprint(can_balance_array(n, arr))"}
{"solution": "def can_make_non_increasing(n, k, a, b):\n    # Identify the positions of zeros in sequence a\n    zero_positions = [i for i, x in enumerate(a) if x == 0]\n    \n    # Sort sequence b in non-decreasing order\n    b.sort()\n    \n    # Try to place elements from b into the positions of zeros in a\n    for i in range(k - 1, -1, -1):\n        pos = zero_positions[i]\n        val = b[i]\n        a[pos] = val\n        \n        # Check if the current placement makes the sequence non-increasing\n        if pos > 0 and a[pos] > a[pos - 1]:\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Output result\nprint(can_make_non_increasing(n, k, a, b))"}
{"solution": "def can_make_everyone_happy(x, y, z, a, b, c):\n    # Check if Andrew's requirement can be met\n    if a < x:\n        return \"NO\"\n    \n    # Check if Dmitry's requirement can be met after Andrew's share\n    remaining_green = a - x\n    total_non_black = remaining_green + b\n    if total_non_black < y:\n        return \"NO\"\n    \n    # Check if Michal's requirement can be met after Andrew and Dmitry's shares\n    remaining_grapes = c + (total_non_black - y)\n    if remaining_grapes < z:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Output result\nprint(can_make_everyone_happy(x, y, z, a, b, c))"}
{"solution": "def is_accident_possible(lights):\n    # Iterate over each part of the intersection\n    for i in range(4):\n        # Check if the pedestrian light is green\n        if lights[i][3] == 1:\n            # Check if any car light (left, straight, right) is also green\n            if any(lights[i][:3]):\n                return \"YES\"\n            # Check if any other part's pedestrian light is green and its corresponding car light is green\n            for j in range(4):\n                if i != j and lights[j][3] == 1 and any(lights[j][:3]):\n                    return \"YES\"\n    return \"NO\"\n\n# Read input\nlights = []\nfor _ in range(4):\n    lights.append(list(map(int, input().split())))\n\n# Print the result\nprint(is_accident_possible(lights))"}
{"solution": "def get_coordinates(digit):\n    keypad = {\n        '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2),\n        '0': (3, 1)\n    }\n    return keypad[digit]\n\ndef get_vectors(number):\n    vectors = []\n    for i in range(len(number) - 1):\n        x1, y1 = get_coordinates(number[i])\n        x2, y2 = get_coordinates(number[i + 1])\n        vectors.append((x2 - x1, y2 - y1))\n    return vectors\n\ndef is_unique_finger_movement(n, number):\n    original_vectors = get_vectors(number)\n    for i in range(10**(n-1), 10**n):\n        candidate = str(i).zfill(n)\n        if candidate != number:\n            if get_vectors(candidate) == original_vectors:\n                return \"NO\"\n    return \"YES\"\n\n# Input reading\nn = int(input())\nnumber = input().strip()\n\n# Output the result\nprint(is_unique_finger_movement(n, number))"}
{"solution": "import heapq\n\ndef max_products_sold(n, f, days):\n    # Calculate the initial sold products and potential gain from doubling\n    sold = 0\n    gains = []\n    for k, l in days:\n        sold += min(k, l)\n        if k < l:\n            gains.append(l - k)\n    \n    # Convert list to a max heap\n    gains = [-gain for gain in gains]\n    heapq.heapify(gains)\n    \n    # Apply the sell-out days to maximize the total sold products\n    for _ in range(f):\n        if gains and gains[0] < 0:\n            heapq.heappop(gains)\n        elif gains:\n            gain = heapq.heappop(gains)\n            heapq.heappush(gains, gain * 2)\n    \n    # Calculate the final total sold products\n    return sold - sum(gains)\n\n# Read input\nn, f = map(int, input().split())\ndays = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Compute and print the result\nprint(max_products_sold(n, f, days))"}
{"solution": "import heapq\n\ndef max_messiness(n, k):\n    # Initialize a min heap with the first half of the indices\n    min_heap = list(range(n // 2))\n    heapq.heapify(min_heap)\n    \n    # Initialize a max heap with the second half of the indices, negated to use as a max heap\n    max_heap = [-x for x in range(n // 2, n)]\n    heapq.heapify(max_heap)\n    \n    messiness = 0\n    for _ in range(k):\n        # Pop the smallest element from the min heap and the largest from the max heap\n        min_val = heapq.heappop(min_heap)\n        max_val = -heapq.heappop(max_heap)\n        \n        # Update the messiness based on the current indices\n        messiness += (max_val - min_val) * (n - max_val + min_val - 1)\n        \n        # Push the next elements into the heaps if available\n        if min_val + 1 <= max_val - 1:\n            heapq.heappush(min_heap, min_val + 1)\n            heapq.heappush(max_heap, -(max_val - 1))\n    \n    return messiness\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the maximum messiness\nprint(max_messiness(n, k))"}
{"solution": "def min_coins_needed(N, M, K, L):\n    # Check if it's impossible to meet all conditions\n    if N - K < L:\n        return -1\n    if N < M:\n        return -1\n    \n    # Calculate minimum number of coins each friend needs to give\n    min_coins_per_friend = max((L + M - 1) // M, (N + M - 1) // M)\n    \n    return min_coins_per_friend\n\n# Read input\nN, M, K, L = map(int, input().split())\n\n# Calculate and print the result\nprint(min_coins_needed(N, M, K, L))"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    # Find the bounds of the black cells\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # If no black cells are found\n    if min_row == n:\n        return 1\n    \n    # Calculate the side length of the square\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    \n    # Check if the square can fit within the grid\n    if side_length > n or side_length > m:\n        return -1\n    \n    # Count the number of white cells within the square\n    min_paint = float('inf')\n    for i in range(n - side_length + 1):\n        for j in range(m - side_length + 1):\n            paint_count = 0\n            for x in range(i, i + side_length):\n                for y in range(j, j + side_length):\n                    if grid[x][y] == 'W':\n                        paint_count += 1\n            min_paint = min(min_paint, paint_count)\n    \n    return min_paint\n\n# Input handling\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Output the result\nprint(min_cells_to_paint(n, m, grid))"}
{"solution": "def can_transform(x, y):\n    diff = [a - b for a, b in zip(x, y)]\n    positive_diff = sum(d for d in diff if d > 0)\n    negative_diff = sum(d for d in diff if d < 0)\n    \n    # Check if the total positive difference can be balanced by the negative difference\n    if positive_diff == -negative_diff:\n        # Check if each pile's reduction can be covered by the increase in other piles\n        taken = 0\n        for d in sorted(diff):\n            if d > 0:\n                if taken < d:\n                    return \"No\"\n                taken -= d\n            else:\n                taken += d\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input\nn = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Output result\nprint(can_transform(x, y))"}
{"solution": "def min_angle_difference(n, angles):\n    total_angle = sum(angles)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    current_sum = 0\n    \n    for i in range(n):\n        current_sum += angles[i]\n        dp[i + 1] = current_sum\n        for j in range(i + 1):\n            diff = abs(current_sum - (total_angle - current_sum + angles[j]))\n            dp[i + 1] = min(dp[i + 1], diff)\n    \n    return min(dp)\n\n# Reading input\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(min_angle_difference(n, angles))"}
{"solution": "MOD = 10**9 + 7\n\ndef power(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef solve(n, m):\n    # Calculate (m + n - 1) choose (n - 1)\n    numerator = power(m, n)\n    denominator = power((power(m, MOD - 2)), (MOD - 2))\n    return (numerator * denominator) % MOD\n\ndef main():\n    n, m = map(int, input().split())\n    print(solve(n, m))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef find_pythagorean_triple(n):\n    # Check if n is a cathetus\n    for m in range(1, int(math.sqrt(n)) + 1):\n        if n % m == 0:\n            k = n // m\n            if k > m and math.isqrt(k * k - m * m) * math.isqrt(k * k - m * m) == k * k - m * m:\n                return m, k\n    \n    # Check if n is a hypotenuse\n    for m in range(1, n):\n        k = math.isqrt(n * n - m * m)\n        if k * k == n * n - m * m:\n            return m, k\n    \n    return -1\n\n# Read input\nn = int(input())\n\n# Find and print the Pythagorean triple\nresult = find_pythagorean_triple(n)\nprint(*result)"}
{"solution": "def are_remainders_distinct(n, k):\n    seen = set()\n    for i in range(1, min(k + 1, n + 1)):\n        remainder = n % i\n        if remainder in seen:\n            return \"No\"\n        seen.add(remainder)\n    return \"Yes\"\n\n# Read input\nn, k = map(int, input().split())\n\n# Check and print the result\nprint(are_remainders_distinct(n, k))"}
{"solution": "import sys\n\n# Fast input method\ndef read_int():\n    return int(sys.stdin.readline().strip())\n\ndef compare_long_integers(a, b):\n    # Remove leading zeros for accurate comparison\n    a = a.lstrip('0')\n    b = b.lstrip('0')\n    \n    # Compare lengths directly\n    if len(a) != len(b):\n        return \"<\" if len(a) < len(b) else \">\"\n    \n    # If lengths are equal, compare lexicographically\n    for i in range(len(a)):\n        if a[i] != b[i]:\n            return \"<\" if a[i] < b[i] else \">\"\n    \n    # If all characters are equal, the numbers are equal\n    return \"=\"\n\n# Read input\na = sys.stdin.readline().strip()\nb = sys.stdin.readline().strip()\n\n# Output result\nprint(compare_long_integers(a, b))"}
{"solution": "from itertools import permutations\nMOD = 10**9 + 7\n\ndef calculate_ways(n, p, colors):\n    def is_valid_path(color_sequence):\n        score = 0\n        for i in range(len(color_sequence) - 1):\n            if color_sequence[i] != color_sequence[i + 1]:\n                score += 1\n        return score % 2 == p\n    \n    def count_valid_colorings():\n        # Count the number of uncolored pieces\n        uncolored = sum(1 for c in colors if c == -1)\n        \n        # Generate all possible colorings for uncolored pieces\n        total_ways = 1\n        for perm in permutations([0]*uncolored + [1]*uncolored):\n            new_colors = list(colors)\n            idx = 0\n            for i, c in enumerate(new_colors):\n                if c == -1:\n                    new_colors[i] = perm[idx]\n                    idx += 1\n            \n            # Calculate the number of valid paths for each permutation\n            if is_valid_path(new_colors):\n                total_ways += 1\n        \n        return total_ways % MOD\n    \n    def count_arrows():\n        # Since any valid permutation of arrows is allowed, we only need to count valid colorings\n        return count_valid_colorings()\n    \n    return count_arrows()\n\n# Reading input\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(calculate_ways(n, p, colors))"}
{"solution": "def min_cost(n, a, b, c):\n    # Calculate the remainder when n is divided by 4\n    remainder = n % 4\n    # Initialize the minimum cost to a large number\n    min_cost = float('inf')\n    \n    # Try all possible values of k that make n + k divisible by 4\n    for k in range(4 - remainder, 4 + 1, 4):\n        cost = 0\n        # Calculate the number of additional copybooks needed\n        needed = k\n        \n        # Try buying packs of 3 copybooks\n        if needed >= 3:\n            num_packs_of_3 = needed // 3\n            remaining = needed % 3\n            cost = num_packs_of_3 * c\n            if remaining == 1:\n                cost += a\n            elif remaining == 2:\n                cost += min(a * 2, b)\n            min_cost = min(min_cost, cost)\n        \n        # Try buying packs of 2 copybooks\n        if needed >= 2:\n            num_packs_of_2 = needed // 2\n            remaining = needed % 2\n            cost = num_packs_of_2 * b\n            if remaining == 1:\n                cost += a\n            min_cost = min(min_cost, cost)\n        \n        # Try buying packs of 1 copybook\n        if needed >= 1:\n            cost = needed * a\n            min_cost = min(min_cost, cost)\n    \n    return min_cost\n\n# Read input\nn, a, b, c = map(int, input().split())\n\n# Calculate and print the minimum cost\nprint(min_cost(n, a, b, c))"}
{"solution": "from collections import defaultdict, deque\n\ndef find_cycle(n, graph):\n    indegree = [0] * (n + 1)\n    topo_order = []\n    for node in graph:\n        for neighbor in graph[node]:\n            indegree[neighbor] += 1\n    \n    queue = deque()\n    for i in range(1, n + 1):\n        if indegree[i] == 0:\n            queue.append(i)\n    \n    while queue:\n        node = queue.popleft()\n        topo_order.append(node)\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    if len(topo_order) == n:\n        return None\n    else:\n        return topo_order\n\ndef can_make_acyclic(n, m, edges):\n    graph = defaultdict(list)\n    reverse_graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        reverse_graph[v].append(u)\n    \n    cycle = find_cycle(n, graph)\n    if cycle is None:\n        return \"YES\"\n    \n    visited = set(cycle)\n    for u, v in edges:\n        if u in visited and v in visited:\n            new_graph = defaultdict(list)\n            for src, dests in graph.items():\n                for dest in dests:\n                    if (src, dest) != (u, v):\n                        new_graph[src].append(dest)\n            if find_cycle(n, new_graph) is None:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Reading input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Solving and printing output\nprint(can_make_acyclic(n, m, edges))"}
{"solution": "def min_coins_for_coverage(n, m, antennas):\n    # Sort antennas by their position\n    antennas.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    total_cost = 0\n    current_coverage_end = 0\n    \n    i = 0\n    while i < n and current_coverage_end < m:\n        max_scope = -1\n        max_scope_index = -1\n        for j in range(i, n):\n            start, end = antennas[j][0] - antennas[j][1], antennas[j][0] + antennas[j][1]\n            if start <= current_coverage_end:\n                if end > max_scope:\n                    max_scope = end\n                    max_scope_index = j\n            else:\n                break\n        \n        if max_scope_index == -1:\n            # No antenna can cover the current position, find the closest antenna\n            for j in range(i, n):\n                start = antennas[j][0] - antennas[j][1]\n                if start > current_coverage_end:\n                    diff = start - current_coverage_end\n                    total_cost += diff\n                    current_coverage_end = antennas[j][0] + antennas[j][1] + diff\n                    break\n        else:\n            # Extend the chosen antenna to cover the gap\n            if max_scope < m:\n                diff = max(0, current_coverage_end + 1 - antennas[max_scope_index][0])\n                total_cost += diff\n                current_coverage_end = antennas[max_scope_index][0] + antennas[max_scope_index][1] + diff\n            i = max_scope_index + 1\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\n\n# Compute and print the result\nprint(min_coins_for_coverage(n, m, antennas))"}
{"solution": "def max_good_subset_weight(W, weights):\n    # Initialize the result\n    result = 0\n    \n    # Iterate through each weight from 8 to 1\n    for i in range(8, 0, -1):\n        cnt_i = weights[i-1]\n        # Add as many items of weight i as possible without exceeding W\n        result += min(cnt_i, W // i) * i\n        # Update W to reflect the remaining capacity\n        W -= min(cnt_i, W // i) * i\n    \n    return result\n\n# Read input\nW = int(input())\nweights = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_good_subset_weight(W, weights))"}
{"solution": "def min_cost_lemonade(n, L, costs):\n    # Initialize the total cost\n    total_cost = 0\n    \n    # Create a list of tuples containing volume and cost\n    bottles = [(2**i - 1, costs[i]) for i in range(n)]\n    \n    # Sort the bottles by cost per liter\n    bottles.sort(key=lambda x: x[1] / x[0])\n    \n    # Iterate through sorted bottles\n    for volume, cost in bottles:\n        if L > 0:\n            # Calculate how many liters we can buy from the current bottle\n            buy = min(volume, L)\n            # Update the total cost\n            total_cost += (buy / volume) * cost\n            # Decrease the required liters\n            L -= buy\n    \n    return int(total_cost)\n\n# Read input\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Calculate and print the minimum cost\nprint(min_cost_lemonade(n, L, costs))"}
{"solution": "def max_mex(n, a):\n    a.sort()\n    mex = 1\n    for num in a:\n        if num >= mex:\n            mex += 1\n    return mex\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = max_mex(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(int(digit) for digit in digits)\n    \n    for segment_sum in range(1, total_sum + 1):\n        if total_sum % segment_sum == 0:\n            num_segments = total_sum // segment_sum\n            current_sum = 0\n            segments_count = 0\n            for digit in digits:\n                current_sum += int(digit)\n                if current_sum == segment_sum:\n                    current_sum = 0\n                    segments_count += 1\n            if segments_count >= 2 and current_sum == 0:\n                return \"YES\"\n    \n    return \"NO\"\n\nn = int(input())\ndigits = input().strip()\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\"\n\nusername = input().strip()\nprint(determine_gender(username))"}
{"solution": "def max_tab_difference(n, k, tabs):\n    def calculate_difference(start_index):\n        closed_tabs = set()\n        current_index = start_index\n        while 1 <= current_index <= n:\n            closed_tabs.add(current_index)\n            current_index += k\n        \n        e_count = s_count = 0\n        for i in range(1, n + 1):\n            if i not in closed_tabs:\n                if tabs[i - 1] == 1:\n                    e_count += 1\n                else:\n                    s_count += 1\n        \n        return abs(e_count - s_count)\n    \n    max_diff = 0\n    for start_index in range(1, n + 1):\n        diff = calculate_difference(start_index)\n        max_diff = max(max_diff, diff)\n    \n    return max_diff\n\n# Reading input\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(max_tab_difference(n, k, tabs))"}
{"solution": "def min_cost_encoding(n, c0, c1):\n    if c0 > c1:\n        c0, c1 = c1, c0\n    if c0 == 0:\n        return (n - 1) * c1\n    total_cost = 0\n    layer = 1\n    while n > 1:\n        cost = min(c0 * layer, c1)\n        num_in_layer = min(n - 1, layer + 1)\n        total_cost += num_in_layer * cost\n        n -= num_in_layer\n        layer += 1\n    return total_cost\n\n# Reading input\nn, c0, c1 = map(int, input().split())\n\n# Calculating and printing the output\nprint(min_cost_encoding(n, c0, c1))"}
{"solution": "def will_meet(n, a, x, b, y):\n    while a != x and b != y:\n        if a == b:\n            return \"YES\"\n        a = a + 1 if a < n else 1\n        b = b - 1 if b > 1 else n\n    return \"YES\" if a == b else \"NO\"\n\n# Example usage:\n# n, a, x, b, y = 5, 1, 4, 3, 2\n# print(will_meet(n, a, x, b, y))"}
{"solution": "import math\n\ndef generate_unlucky_years(x, y, max_year):\n    unlucky_years = set()\n    max_power = int(math.log(max_year, min(x, y))) + 1\n    \n    for a in range(max_power):\n        for b in range(max_power):\n            year = x**a + y**b\n            if year <= max_year:\n                unlucky_years.add(year)\n    \n    return unlucky_years\n\ndef find_max_golden_age(x, y, l, r):\n    unlucky_years = generate_unlucky_years(x, y, r)\n    max_length = 0\n    current_start = l\n    last_unlucky = l - 1\n    \n    for year in range(l, r + 1):\n        if year in unlucky_years:\n            if last_unlucky + 1 < year:\n                max_length = max(max_length, year - (last_unlucky + 1))\n            last_unlucky = year\n            current_start = year + 1\n    \n    if last_unlucky + 1 < r + 1:\n        max_length = max(max_length, r + 1 - (last_unlucky + 1))\n    \n    return max_length\n\n# Read input\nx, y, l, r = map(int, input().split())\n\n# Find and print the maximum length of The Golden Age\nprint(find_max_golden_age(x, y, l, r))"}
{"solution": "def min_tax(n):\n    if n % 2 == 0:\n        return n // 2\n    else:\n        # Find the largest even divisor less than n\n        for i in range(n - 1, 1, -1):\n            if n % i == 0 and i % 2 == 0:\n                return i // 2\n        return 1  # Fallback, should not happen for n >= 2\n\n# Read input\nn = int(input())\n\n# Calculate and print the minimum tax\nprint(min_tax(n))"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    n = len(word)\n    result = []\n    i = 0\n    \n    while i < n:\n        result.append(word[i])\n        if word[i] not in vowels:\n            start = i\n            while i < n and word[i] not in vowels:\n                i += 1\n            if i - start >= 3:\n                block = word[start:i]\n                if len(set(block)) > 1:\n                    result.append(' ')\n        i += 1\n    \n    return ''.join(result)\n\nword = input().strip()\nprint(fix_typos(word))"}
{"solution": "import bisect\n\ndef min_potion_prep_time(n, m, k, x, s, a, b, c, d):\n    # Sort spells by cost-effectiveness\n    a_b = sorted(zip(a, b), key=lambda x: (x[0], -x[1]))\n    c_d = sorted(zip(c, d), key=lambda x: (x[1], x[0]))\n\n    a, b = zip(*a_b) if a_b else ([], [])\n    c, d = zip(*c_d) if c_d else ([], [])\n\n    def enough_time(t):\n        # Find the best first-type spell that fits within the time limit\n        i = bisect.bisect_left(a, t)\n        if i < m:\n            prep_time = a[i]\n            mana_used = b[i]\n        else:\n            prep_time = x\n            mana_used = 0\n\n        # Remaining time after using the first-type spell\n        remaining_time = t - (n - c[-1]) * prep_time if c else t\n        remaining_mana = s - mana_used\n\n        # Find the best second-type spell that fits within the mana limit\n        j = bisect.bisect_right(d, remaining_mana) - 1\n        if j >= 0:\n            potions_created = c[j]\n            mana_used += d[j]\n        else:\n            potions_created = 0\n            mana_used = 0\n\n        # Check if the remaining mana is sufficient\n        return (n - potions_created) * prep_time <= remaining_time and mana_used <= s\n\n    # Binary search for the minimum time\n    low, high = 0, n * x\n    while low < high:\n        mid = (low + high) // 2\n        if enough_time(mid):\n            high = mid\n        else:\n            low = mid + 1\n\n    return low\n\n# Read input\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_potion_prep_time(n, m, k, x, s, a, b, c, d))"}
{"solution": "def max_points(n, k, M, times):\n    from itertools import accumulate\n    \n    # Calculate prefix sums of times\n    prefix_sums = [0] + list(accumulate(times))\n    \n    # Function to calculate points for a given number of minutes\n    def calculate_points(minutes):\n        complete_tasks = 0\n        while complete_tasks < len(prefix_sums) and prefix_sums[complete_tasks + 1] <= minutes:\n            complete_tasks += 1\n        remaining_time = minutes - prefix_sums[complete_tasks]\n        incomplete_tasks = min(complete_tasks, remaining_time // times[0]) if complete_tasks > 0 else 0\n        return complete_tasks * (k + 1) + incomplete_tasks\n    \n    # Binary search to find the maximum number of points\n    low, high = 0, M\n    while low < high:\n        mid = (low + high + 1) // 2\n        if calculate_points(mid) > calculate_points(mid - 1):\n            low = mid\n        else:\n            high = mid - 1\n    \n    return calculate_points(low)\n\n# Read input\nn, k, M = map(int, input().split())\ntimes = list(map(int, input().split()))\n\n# Print the result\nprint(max_points(n, k, M, times))"}
{"solution": "MOD = 998244353\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef C(n, k):\n    if k > n:\n        return 0\n    res = 1\n    for i in range(k):\n        res = res * (n - i) % MOD\n        res = res * modinv(i + 1) % MOD\n    return res\n\ndef solve(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = 0\n        for j in range((i + 1) // 2):\n            left = C(i - 1, j)\n            right = C(i - 1 - j, i - 1 - 2 * j)\n            dp[i] += dp[j] * dp[i - 1 - j] * left * right % MOD\n            dp[i] %= MOD\n    \n    result = dp[n]\n    return result\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def find_laras_position(n, m, k):\n    # Determine the direction of movement and the current position\n    def move(row, col, direction):\n        if direction == 'down':\n            return row + 1, col, 'right'\n        elif direction == 'right':\n            return row, col + 1, 'up'\n        elif direction == 'up':\n            return row - 1, col, 'left'\n        elif direction == 'left':\n            return row, col - 1, 'down'\n\n    row, col = 1, 1\n    direction = 'down'\n    steps_down = n // 2\n    steps_across = (m - 1) // 2\n\n    while k > 0:\n        if direction == 'down':\n            steps = min(steps_down, k)\n            row += steps\n            k -= steps\n            direction = 'right'\n        elif direction == 'right':\n            steps = min(steps_across * 2, k)\n            col += steps\n            k -= steps\n            direction = 'up'\n        elif direction == 'up':\n            steps = min(steps_down, k)\n            row -= steps\n            k -= steps\n            direction = 'left'\n        elif direction == 'left':\n            steps = min(steps_across, k)\n            col -= steps\n            k -= steps\n            direction = 'down'\n\n        steps_down -= 1\n        steps_across -= 1\n\n    return row, col\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Find Lara's position\nposition = find_laras_position(n, m, k)\n\n# Print the result\nprint(*position)"}
{"solution": "from math import gcd\n\ndef find_min_max_pair(X):\n    # Find the largest divisor of X that when squared does not exceed X\n    for a in range(int(X**0.5), 0, -1):\n        if X % a == 0:\n            b = X // a\n            return [a, b]\n\n# Read input\nX = int(input())\n\n# Find and print the pair (a, b)\na, b = find_min_max_pair(X)\nprint(a, b)"}
{"solution": "def max_fruits_for_compote(a, b, c):\n    # Calculate the maximum number of complete sets for each fruit type\n    max_sets_lemons = a // 1\n    max_sets_apples = b // 2\n    max_sets_pears = c // 4\n    \n    # Find the limiting factor (minimum number of complete sets)\n    max_complete_sets = min(max_sets_lemons, max_sets_apples, max_sets_pears)\n    \n    # Calculate the total number of fruits used in the compote\n    total_fruits = max_complete_sets * (1 + 2 + 4)\n    \n    return total_fruits\n\n# Read input\na = int(input())\nb = int(input())\nc = int(input())\n\n# Print the result\nprint(max_fruits_for_compote(a, b, c))"}
{"solution": "def can_divide_teams(n, ratings):\n    ratings.sort()\n    for i in range(n):\n        if ratings[i] >= ratings[i + n]:\n            return \"NO\"\n    return \"YES\"\n\n# Reading input\nn = int(input())\nratings = list(map(int, input().split()))\n\n# Printing output\nprint(can_divide_teams(n, ratings))"}
{"solution": "from math import gcd\n\ndef find_next_coprime(arr):\n    n = len(arr)\n    result = []\n    insertions = 0\n    \n    for i in range(n - 1):\n        if gcd(arr[i], arr[i + 1]) > 1:\n            # Find the smallest coprime number between arr[i] and arr[i + 1]\n            next_val = 1\n            while gcd(next_val, arr[i]) != 1 or gcd(next_val, arr[i + 1]) != 1:\n                next_val += 1\n            result.append(arr[i])\n            result.append(next_val)\n            insertions += 1\n        else:\n            result.append(arr[i])\n    \n    # Add the last element\n    result.append(arr[-1])\n    \n    return insertions, result\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Processing\ninsertions, new_arr = find_next_coprime(arr)\n\n# Printing output\nprint(insertions)\nprint(*new_arr)"}
{"solution": "from math import gcd\nfrom functools import reduce\n\ndef compute_gcd_of_list(lst):\n    return reduce(gcd, lst)\n\ndef max_divisor_after_operations(N, K, A):\n    total_sum = sum(A)\n    possible_divisors = set()\n\n    # Find all possible divisors of the total sum\n    for i in range(1, int(total_sum**0.5) + 1):\n        if total_sum % i == 0:\n            possible_divisors.add(i)\n            possible_divisors.add(total_sum // i)\n\n    max_divisor = 1\n    for d in sorted(possible_divisors, reverse=True):\n        mods = sorted([a % d for a in A])\n        prefix_sum = list(mods)\n        for i in range(1, N):\n            prefix_sum[i] += prefix_sum[i - 1]\n        \n        for i in range(N):\n            add_cost = prefix_sum[i]\n            sub_cost = (N - i - 1) * d - (prefix_sum[-1] - prefix_sum[i])\n            if add_cost == sub_cost and add_cost <= K:\n                return d\n\n    return max_divisor\n\n# Read input\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Compute and print the result\nprint(max_divisor_after_operations(N, K, A))"}
{"solution": "def find_transformation(x):\n    # Function to count the number of set bits (1s) in the binary representation of x\n    def count_set_bits(n):\n        count = 0\n        while n:\n            n &= (n - 1)\n            count += 1\n        return count\n\n    # Determine the number of set bits and the highest bit position\n    set_bits = count_set_bits(x)\n    highest_bit = x.bit_length() - 1\n\n    # Initialize variables for the transformation plan\n    operations = []\n    target = 2**set_bits - 1\n    current = x\n    steps = 0\n\n    while current != target and steps < 40:\n        if current < target:\n            # Apply Operation B (x + 1)\n            current += 1\n            steps += 1\n            if current == target:\n                break\n\n        # Find the next suitable n for Operation A (x XOR (2^n - 1))\n        for n in range(highest_bit + 1):\n            if (current & (2**n - 1)) != (2**n - 1):\n                operations.append(n)\n                current ^= (2**n - 1)\n                steps += 1\n                break\n\n    # Output the number of operations and the sequence of n values\n    print(steps)\n    for n in operations:\n        print(n, end=' ')\n    print()\n\n# Read input\nx = int(input())\n\n# Generate and print the transformation plan\nfind_transformation(x)"}
{"solution": "# Import necessary packages\nfrom math import inf\n\ndef min_hours_to_water_garden(n, k, bucket_lengths):\n    \"\"\"\n    Determines the minimum number of hours required to water the garden.\n    \n    Parameters:\n    n (int): The number of buckets.\n    k (int): The length of the garden.\n    bucket_lengths (list): The lengths that can be watered by each bucket in one hour.\n    \n    Returns:\n    int: The minimum number of hours required to water the garden.\n    \"\"\"\n    # Initialize minimum hours to infinity\n    min_hours = inf\n    \n    # Iterate through each bucket length\n    for length in bucket_lengths:\n        # Check if the garden length is divisible by the bucket length\n        if k % length == 0:\n            # Calculate hours required and update minimum hours\n            hours_required = k // length\n            min_hours = min(min_hours, hours_required)\n    \n    # Return the minimum hours required\n    return min_hours\n\n# Read input\nn, k = map(int, input().split())\nbucket_lengths = list(map(int, input().split()))\n\n# Calculate and print the minimum number of hours\nprint(min_hours_to_water_garden(n, k, bucket_lengths))"}
{"solution": "def can_grasshopper_reach_insect(n, k, line):\n    from collections import deque\n    \n    # Find the positions of the grasshopper (G) and the insect (T)\n    grasshopper_pos = line.find('G')\n    insect_pos = line.find('T')\n    \n    # Check if the grasshopper and the insect are already in the same position\n    if grasshopper_pos == insect_pos:\n        return \"YES\"\n    \n    visited = set()\n    queue = deque([grasshopper_pos])\n    \n    while queue:\n        pos = queue.popleft()\n        \n        # Check if the grasshopper has reached the insect\n        if pos == insect_pos:\n            return \"YES\"\n        \n        # Check if the position has been visited before\n        if pos in visited:\n            continue\n        visited.add(pos)\n        \n        # Calculate the next possible positions\n        next_positions = [pos + k, pos - k]\n        \n        # Add valid next positions to the queue\n        for next_pos in next_positions:\n            if 0 <= next_pos < n and line[next_pos] != '#':\n                queue.append(next_pos)\n    \n    return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\nline = input()\n\n# Output result\nprint(can_grasshopper_reach_insect(n, k, line))"}
{"solution": "from math import fabs\n\ndef check_collision(x_b, y_b, x_w, y_w, y1, y2, r):\n    dx = x_w - x_b\n    dy = y_w - y_b\n    slope = dy / dx\n    x_intercept = -y_b / slope\n    y_intercept = y_b - x_b * slope\n\n    if x_intercept >= 0 and fabs(y_intercept - y1) <= r or fabs(y_intercept - y2) <= r:\n        return True\n    if y_intercept >= y1 and y_intercept <= y2 and fabs(x_intercept) <= r:\n        return True\n    return False\n\ndef find_target_point(y1, y2, y_w, x_b, y_b, r):\n    x_w = x_b * (y2 - y_b) / (y_w - y_b)\n    if x_w <= 0 or check_collision(x_b, y_b, x_w, y_w, y1, y2, r):\n        return -1\n    return x_w\n\ndef main():\n    y1, y2, y_w, x_b, y_b, r = map(int, input().split())\n    result = find_target_point(y1, y2, y_w, x_b, y_b, r)\n    print(f\"{result:.10f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_missed_meals(breakfasts, dinners, suppers):\n    # Calculate the minimum number of missed meals\n    total_meals = breakfasts + dinners + suppers\n    min_missed = total_meals - max(breakfasts, dinners, suppers)\n    return max(0, min_missed * 2 - total_meals + 1)\n\n# Read input\nb, d, s = map(int, input().split())\n\n# Calculate and print the result\nprint(min_missed_meals(b, d, s))"}
{"solution": "def find_possible_dimensions(path):\n    def get_position(value, x, y):\n        row = (value - 1) // y\n        col = (value - 1) % y\n        return row, col\n\n    def is_valid_move(pos1, pos2):\n        row1, col1 = pos1\n        row2, col2 = pos2\n        return abs(row1 - row2) + abs(col1 - col2) == 1\n\n    n = len(path)\n    for y in range(1, 1000001):  # Limiting y to a reasonable range for practical computation\n        for x in range(1, 1000001):\n            valid_path = True\n            for i in range(n - 1):\n                pos1 = get_position(path[i], x, y)\n                pos2 = get_position(path[i + 1], x, y)\n                if not is_valid_move(pos1, pos2):\n                    valid_path = False\n                    break\n            if valid_path:\n                return \"YES\\n\" + str(x) + \" \" + str(y)\n    return \"NO\"\n\n# Reading input\nn = int(input())\npath = list(map(int, input().split()))\n\n# Printing output\nprint(find_possible_dimensions(path))"}
{"solution": "def find_min_consecutive_removals(a, b):\n    m, n = len(a), len(b)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Fill dp table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    # Reconstruct the subsequence\n    i, j = m, n\n    subsequence = []\n    while i > 0 and j > 0:\n        if a[i - 1] == b[j - 1]:\n            subsequence.append(a[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    # Reverse to get correct order\n    subsequence = ''.join(reversed(subsequence))\n\n    # Handle empty subsequence case\n    if not subsequence:\n        return '-'\n    return subsequence\n\n# Read input\na = input().strip()\nb = input().strip()\n\n# Output result\nprint(find_min_consecutive_removals(a, b))"}
{"solution": "def minimal_stones(n, s):\n    current_stones = 0\n    min_stones = 0\n    \n    for char in s:\n        if char == '+':\n            current_stones += 1\n        elif char == '-':\n            current_stones -= 1\n        min_stones = min(min_stones, current_stones)\n    \n    return max(0, -min_stones)\n\n# Reading input\nn = int(input())\ns = input().strip()\n\n# Printing output\nprint(minimal_stones(n, s))"}
{"solution": "def max_kefir_liters(n, a, b, c):\n    def calculate_liters(money, bottle_cost, refund):\n        total_liters = 0\n        while money >= bottle_cost:\n            bottles_bought = money // bottle_cost\n            total_liters += bottles_bought\n            refunds = bottles_bought * refund\n            money = money % bottle_cost + refunds\n        return total_liters\n    \n    # Calculate liters from buying only plastic bottles\n    plastic_liters = n // a\n    \n    # Calculate liters from buying glass bottles and returning them\n    glass_liters = calculate_liters(n, b, c)\n    \n    # Return the maximum of the two options\n    return max(plastic_liters, glass_liters)\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate and print the result\nprint(max_kefir_liters(n, a, b, c))"}
{"solution": "from collections import deque\n\ndef read_cards():\n    n = int(input())\n    k1 = int(input())\n    soldier1 = deque(map(int, input().split()))\n    k2 = int(input())\n    soldier2 = deque(map(int, input().split()))\n    return n, soldier1, soldier2\n\ndef simulate_game(soldier1, soldier2):\n    fights = 0\n    winner = 0\n    while True:\n        if not soldier1 or not soldier2:\n            break\n        card1 = soldier1.popleft()\n        card2 = soldier2.popleft()\n        if card1 > card2:\n            soldier1.extend([card2, card1])\n        else:\n            soldier2.extend([card1, card2])\n        fights += 1\n        if fights > 10**6:  # Assuming a maximum of 10^6 fights to prevent infinite loops\n            return -1\n    if soldier1:\n        winner = 1\n    else:\n        winner = 2\n    return fights, winner\n\nn, soldier1, soldier2 = read_cards()\nresult = simulate_game(soldier1, soldier2)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    \n    has_upper = any(char.isupper() for char in password)\n    has_lower = any(char.islower() for char in password)\n    has_digit = any(char.isdigit() for char in password)\n    \n    if has_upper and has_lower and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\"\n\n# Read input\npassword = input().strip()\nprint(check_password_complexity(password))"}
{"solution": "def min_exchanges_to_balance_groups(n, group_a, group_b):\n    from collections import Counter\n    \n    # Count academic performances in each group\n    counter_a = Counter(group_a)\n    counter_b = Counter(group_b)\n    \n    # Calculate differences in counts\n    differences = Counter()\n    for perf in range(1, 6):\n        differences[perf] = abs(counter_a[perf] - counter_b[perf])\n    \n    # Sum of all differences divided by 2 gives the minimum number of exchanges\n    total_exchanges = sum(differences.values()) // 2\n    \n    # Check if it's possible to balance the groups\n    if any(val % 2 != 0 for val in differences.values()):\n        return -1\n    else:\n        return total_exchanges\n\n# Reading input\nn = int(input())\ngroup_a = list(map(int, input().split()))\ngroup_b = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(min_exchanges_to_balance_groups(n, group_a, group_b))"}
{"solution": "def is_reachable(n, m, horizontal_streets, vertical_streets):\n    # Check if there is at least one east-west and one west-east horizontal street\n    has_east = '>' in horizontal_streets\n    has_west = '<' in horizontal_streets\n    \n    # Check if there is at least one north-south and one south-north vertical street\n    has_north = '^' in vertical_streets\n    has_south = 'v' in vertical_streets\n    \n    # If all conditions are met, return \"YES\", otherwise return \"NO\"\n    if has_east and has_west and has_north and has_south:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nhorizontal_streets = input()\nvertical_streets = input()\n\n# Print the result\nprint(is_reachable(n, m, horizontal_streets, vertical_streets))"}
{"solution": "def can_make_false(n, sequence):\n    count_true = 0\n    for value in sequence:\n        if value == 1:\n            count_true += 1\n            if count_true > 1:\n                return \"NO\"\n        else:\n            count_true = max(count_true - 1, 0)\n    \n    if count_true == 0:\n        return \"NO\"\n    \n    expression = \"\"\n    pending_true = False\n    for value in sequence:\n        if value == 1:\n            if pending_true:\n                expression += \"(1->1)\"\n                pending_true = False\n            else:\n                expression += \"1\"\n                pending_true = True\n        else:\n            if pending_true:\n                expression += f\"(1->{expression})\"\n                pending_true = False\n            else:\n                expression += f\"(0->{expression})\"\n            expression = \"(\" + expression + \")\"\n    \n    return f\"YES\\n{expression}\"\n\n# Reading input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Processing and printing output\nprint(can_make_false(n, sequence))"}
{"solution": "def process_variables(a, b):\n    while a > 0 and b > 0:\n        if a >= 2 * b:\n            a -= 2 * b\n        elif b >= 2 * a:\n            b -= 2 * a\n        else:\n            break\n    return a, b\n\nn, m = map(int, input().split())\nresult_a, result_b = process_variables(n, m)\nprint(result_a, result_b)"}
{"solution": "def count_k_divisible(k, a, b):\n    # Calculate the number of k-divisible numbers in the range [a, b]\n    start = (a + k - 1) // k * k if a % k != 0 else a\n    end = b - b % k if b % k == 0 else b - b % k + k\n    return max(0, (end - start) // k + 1)\n\n# Read input\nk, a, b = map(int, input().split())\n\n# Print the result\nprint(count_k_divisible(k, a, b))"}
{"solution": "def find_kth_digit(k):\n    # Initialize variables\n    total_digits = 0\n    current_range_start = 1\n    digits_in_range = 1\n    \n    # Find the range where the k-th digit is located\n    while total_digits + digits_in_range * 9 * current_range_start < k:\n        total_digits += digits_in_range * 9 * current_range_start\n        current_range_start *= 10\n        digits_in_range += 1\n    \n    # Calculate the actual number where the k-th digit starts\n    remaining_digits = k - total_digits - 1\n    number = current_range_start + remaining_digits // digits_in_range\n    \n    # Find the exact digit within the number\n    digit_index = remaining_digits % digits_in_range\n    return int(str(number)[digit_index])\n\n# Read input\nk = int(input())\n\n# Output the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "def can_vasya_win(n, s):\n    # Calculate the number of moves each player will make\n    moves_each = (n - 11) // 2\n    \n    # Count the number of '8's in the first n - 10 characters\n    count_8s = s[:n - 10].count('8')\n    \n    # Vasya wins if there are more '8's than the number of moves Petya can make\n    if count_8s > moves_each:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Determine if Vasya has a winning strategy\nresult = can_vasya_win(n, s)\nprint(result)"}
{"solution": "from math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_permutations(n, x, pos):\n    if pos == 0:\n        # If pos is 0, the number x is at the beginning, so we only need to ensure\n        # that the numbers greater than x are placed in the correct positions.\n        return (factorial(n - 1) * pow(2, n - x - 1, MOD)) % MOD\n    elif pos == n - 1:\n        # If pos is n-1, the number x is at the end, so we only need to ensure\n        # that the numbers less than x are placed in the correct positions.\n        return (factorial(n - 1) * pow(2, x - 1, MOD)) % MOD\n    else:\n        # For other positions, we need to consider both sides of x.\n        # The number of ways to place numbers less than x on the left side\n        # and numbers greater than x on the right side.\n        left_ways = pow(2, x - 1 - (pos == 0), MOD)\n        right_ways = pow(2, n - x - 1 - (pos == n - 1), MOD)\n        return (factorial(pos) * factorial(n - pos - 1) * left_ways * right_ways) % MOD\n\n# Reading input\nn, x, pos = map(int, input().split())\n\n# Calculating and printing the result\nprint(calculate_permutations(n, x, pos))"}
{"solution": "def decode_message(s, k):\n    i, n = 0, len(s)\n    message = []\n    \n    while i < n and len(message) < k:\n        start_i = i\n        while i < n and s[i] in \"?*\":\n            i += 1\n        if i == start_i:  # No '?' or '*' found, must include the letter\n            message.append(s[start_i])\n            i += 1\n        else:\n            count = i - start_i + 1\n            if s[start_i] != '?':\n                message.extend([s[start_i]] * count)  # Use the letter with '*' or '?'\n            else:\n                message.append('a')  # Use 'a' if '?' is present\n                count -= 1\n                message.extend(['b'] * count)  # Use 'b' for remaining counts\n        \n        i += 1\n    \n    # Adjust message length to k\n    while len(message) < k:\n        message.append('z')\n    \n    if len(message) > k:\n        return \"Impossible\"\n    \n    return \"\".join(message[:k])\n\n# Read input\ns = input().strip()\nk = int(input().strip())\n\n# Output result\nprint(decode_message(s, k))"}
{"solution": "def min_clockwise_turns(x):\n    # Normalize the angle to be within 0 to 360 degrees\n    normalized_angle = x % 360\n    # Determine the minimum number of 90-degree clockwise turns\n    if normalized_angle <= 90:\n        return 0 if normalized_angle == 0 else 1\n    elif normalized_angle <= 180:\n        return 2 if normalized_angle == 180 else 1\n    elif normalized_angle <= 270:\n        return 2\n    else:\n        return 3\n\n# Read input\nx = int(input())\n\n# Output the result\nprint(min_clockwise_turns(x))"}
{"solution": "def can_transform_spheres(a, b, c, x, y, z):\n    # Calculate the deficit for each color\n    delta_b = max(0, x - a)\n    delta_v = max(0, y - b)\n    delta_o = max(0, z - c)\n    \n    # Total surplus spheres available for transformation\n    surplus = a + b + c - (x + y + z)\n    \n    # Total deficit needed to be transformed\n    total_deficit = delta_b + delta_v + delta_o\n    \n    # Check if the surplus can cover the deficit\n    return surplus >= total_deficit\n\n# Read input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Determine if the transformation is possible\nif can_transform_spheres(a, b, c, x, y, z):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def calculate_suffix_numbers(n, k, m):\n    power_10_mod_m = [1]\n    for _ in range(1, n + 1):\n        power_10_mod_m.append((power_10_mod_m[-1] * 10) % m)\n    \n    mod_inverse = [0] * (n + 1)\n    mod_inverse[n] = pow(power_10_mod_m[n], -1, m)\n    for i in range(n - 1, 0, -1):\n        mod_inverse[i] = (10 * mod_inverse[i + 1]) % m\n    \n    result = 0\n    for i in range(1, 10):\n        if (i * mod_inverse[1]) % k == 0:\n            result += 9 ** (n - 1)\n    \n    for j in range(2, n + 1):\n        for i in range(10):\n            if (i * mod_inverse[j]) % k == 0:\n                result += 9 ** (n - j) * j\n    \n    return result % m\n\n# Reading input\nn, k, m = map(int, input().split())\n\n# Calculating and printing the result\nprint(calculate_suffix_numbers(n, k, m))"}
{"solution": "def max_team_size(l, r, a):\n    if l > r:\n        l, r = r, l  # Ensure l is always the smaller or equal group\n    \n    # Use ambidexters to balance the difference\n    d = r - l\n    if a >= d:\n        l += d\n        a -= d\n        # Now l == r, distribute remaining ambidexters equally\n        l += a // 2\n        r += a // 2\n    else:\n        l += a\n        # Not enough ambidexters to balance completely, r remains larger\n    \n    # The maximum team size is twice the smaller group\n    return 2 * l\n\n# Read input\nl, r, a = map(int, input().split())\n\n# Calculate and print the result\nprint(max_team_size(l, r, a))"}
{"solution": "def min_moves(n, k):\n    # Initialize the result variable\n    result = 0\n    \n    # Calculate the total moves needed\n    for i in range(1, n + 1):\n        # Distance to the current manhole from the starting point\n        dist = abs(i - k) + 1\n        \n        # Add the distance twice (once for moving the stone, once for picking the coin)\n        result += dist * 2\n        \n        # Subtract one move for picking the coin at the current position\n        if i == k:\n            result -= 1\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the minimum number of moves\nprint(min_moves(n, k))"}
{"solution": "import heapq\n\ndef min_tallest_tower_height(n, m):\n    used_heights = set()\n    heap = [2, 3]\n    heapq.heapify(heap)\n    for _ in range(n + m):\n        smallest = heapq.heappop(heap)\n        while smallest in used_heights:\n            smallest += 1\n        used_heights.add(smallest)\n        heapq.heappush(heap, smallest * 2)\n        heapq.heappush(heap, smallest * 3)\n    return max(used_heights)\n\n# Read input\nn, m = map(int, input().split())\n\n# Compute and print the result\nprint(min_tallest_tower_height(n, m))"}
{"solution": "from collections import Counter\n\ndef is_fair_game(cards):\n    n = len(cards)\n    card_counts = Counter(cards)\n    for petya_choice in card_counts:\n        vasya_choices = [card for card in card_counts if card != petya_choice]\n        for vasya_choice in vasya_choices:\n            petya_count = card_counts[petya_choice]\n            vasya_count = card_counts[vasya_choice]\n            remaining_cards = n - petya_count - vasya_count\n            if petya_count == vasya_count and remaining_cards == 0:\n                return True, (petya_choice, vasya_choice)\n    return False, None\n\n# Read input\nn = int(input())\ncards = [int(input()) for _ in range(n)]\n\n# Check if the game can be fair\nis_fair, choices = is_fair_game(cards)\n\n# Output result\nif is_fair:\n    print(\"YES\")\n    print(*choices)\nelse:\n    print(\"NO\")"}
{"solution": "def can_arrange_soldiers(n, k, groups):\n    total_seats = 8 * n\n    total_soldiers = sum(groups)\n    \n    # Check if the total number of soldiers can fit in the airplane\n    if total_soldiers > total_seats:\n        return \"NO\"\n    \n    # Calculate the maximum number of soldiers that can be placed without neighbors\n    max_non_neighbor_seats = 4 * n\n    \n    # Check if the largest group can fit without having neighbors\n    if max(groups) > max_non_neighbor_seats:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Output result\nprint(can_arrange_soldiers(n, k, groups))"}
{"solution": "def min_cost_to_almost_good(n, sticks):\n    \"\"\"\n    Finds the minimum cost to adjust the lengths of the sticks so that all lengths are almost good for some t.\n    \n    Parameters:\n    n (int): Number of sticks.\n    sticks (list): List of integers representing the lengths of the sticks.\n    \n    Returns:\n    tuple: A tuple containing the value of t and the minimum cost.\n    \"\"\"\n    # Count occurrences of each length\n    counts = [0] * 101\n    for stick in sticks:\n        counts[stick] += 1\n    \n    min_cost = float('inf')\n    optimal_t = None\n    \n    # Calculate cost for each possible t\n    for t in range(1, 101):\n        cost = sum(counts[max(1, t-1):t] + counts[t+1:min(101, t+2)])\n        if cost < min_cost:\n            min_cost = cost\n            optimal_t = t\n            \n    return (optimal_t, min_cost)\n\n# Read input\nn = int(input())\nsticks = list(map(int, input().split()))\n\n# Compute and print the result\nresult = min_cost_to_almost_good(n, sticks)\nprint(*result)"}
{"solution": "def find_min_square_side(n, m, sky_map):\n    # Initialize minimum and maximum coordinates\n    min_row, max_row, min_col, max_col = None, None, None, None\n    \n    # Find the bounding box of stars\n    for i in range(n):\n        for j in range(m):\n            if sky_map[i][j] == '*':\n                if min_row is None or i < min_row:\n                    min_row = i\n                if max_row is None or i > max_row:\n                    max_row = i\n                if min_col is None or j < min_col:\n                    min_col = j\n                if max_col is None or j > max_col:\n                    max_col = j\n    \n    # Calculate the side length of the square\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    side_length = max(height, width)\n    \n    return side_length\n\n# Read input\nn, m = map(int, input().split())\nsky_map = [input() for _ in range(n)]\n\n# Convert each row to a list of characters\nsky_map = [list(row) for row in sky_map]\n\n# Find and print the minimum side length of the square\nprint(find_min_square_side(n, m, sky_map))"}
{"solution": "from math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef mod_inverse(x):\n    return pow(x, MOD - 2, MOD)\n\ndef count_zeros_ones(arr):\n    zeros = ones = 0\n    for num in arr:\n        if num == 0:\n            zeros += 1\n        else:\n            ones += 1\n    return zeros, ones\n\ndef is_sorted(arr):\n    return arr == sorted(arr)\n\ndef calculate_probability(n, k, arr):\n    zeros, ones = count_zeros_ones(arr)\n    \n    if not is_sorted(arr):\n        if k % 2 == 1:\n            return 0\n        else:\n            # Since the array is not sorted initially and k is even, it remains unsorted.\n            return 0\n    \n    # Calculate the number of ways to choose pairs (i, j) for swaps\n    total_pairs = n * (n - 1) // 2\n    swap_pairs = (total_pairs * pow(total_pairs, k - 1, MOD)) % MOD\n    \n    # Calculate the number of valid sorted sequences\n    valid_sorted = 1\n    for i in range(1, zeros + 1):\n        valid_sorted *= i\n        valid_sorted %= MOD\n    for i in range(1, ones + 1):\n        valid_sorted *= i\n        valid_sorted %= MOD\n    valid_sorted = pow(valid_sorted, MOD - 2, MOD)\n    \n    # Calculate the final probability\n    result = (valid_sorted * swap_pairs) % MOD\n    return result\n\n# Read input\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(calculate_probability(n, k, arr))"}
{"solution": "def min_seconds(x, y):\n    seconds = 0\n    while x > y:\n        if x > y * 2:\n            x //= 2\n            seconds += 1\n        else:\n            diff = x - y\n            x -= diff\n            seconds += diff\n    return seconds\n\nx, y = map(int, input().split())\nprint(min_seconds(x, y))"}
{"solution": "from math import sqrt\n\ndef min_norm_degenerate_matrix(a, b, c, d):\n    det = a * d - b * c\n    if det == 0:\n        return 0.0\n    else:\n        options = [\n            abs(a),\n            abs(b),\n            abs(c),\n            abs(d),\n            abs(a + c),\n            abs(a + d),\n            abs(b + c),\n            abs(b + d),\n            abs(a - c),\n            abs(a - d),\n            abs(b - c),\n            abs(b - d)\n        ]\n        return min(options) / sqrt(2)\n\n# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate and print the result\nprint(min_norm_degenerate_matrix(a, b, c, d))"}
{"solution": "n, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\ndenied = 0\none_seater_used = 0\ntwo_seater_used = 0\none_person_at_two_seater = 0\n\nfor group in groups:\n    if group == 1:\n        if a - one_seater_used > 0:\n            one_seater_used += 1\n        elif b - two_seater_used > 0:\n            two_seater_used += 1\n        elif one_person_at_two_seater < two_seater_used:\n            one_person_at_two_seater += 1\n        else:\n            denied += 1\n    else:\n        if b - two_seater_used > 0:\n            two_seater_used += 1\n        else:\n            denied += 2\n\nprint(denied)"}
{"solution": "def calculate_failed_students(A, B, C, N):\n    # Calculate the number of students who visited only one restaurant\n    only_BugDonalds = A - C\n    only_BeverKing = B - C\n    \n    # Total number of students who visited at least one restaurant\n    total_visited = only_BugDonalds + only_BeverKing + C\n    \n    # Check if the data is consistent\n    if total_visited > N or (N - total_visited) < 1:\n        return -1\n    else:\n        # Number of students who did not pass the exam\n        failed_students = N - total_visited\n        return failed_students\n\n# Read input\nA, B, C, N = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_failed_students(A, B, C, N))"}
{"solution": "def expected_dresses(x, k):\n    MOD = 10**9 + 7\n    \n    def power_two_mod(n, k, mod):\n        result = 1\n        while k > 0:\n            if k % 2 == 1:\n                result = (result * n) % mod\n            n = (n * n) % mod\n            k //= 2\n        return result\n    \n    # Calculate the effect of the wardrobe eating a dress\n    eat_effect = (power_two_mod(2, k, MOD) - power_two_mod(2, k, MOD - 1)) % MOD\n    \n    # Calculate the final expected number of dresses\n    final_dresses = (power_two_mod(2, k + 1, MOD) * x - eat_effect) % MOD\n    \n    return final_dresses\n\n# Read input\nx, k = map(int, input().split())\n\n# Compute and print the result\nprint(expected_dresses(x, k))"}
{"solution": "from math import gcd\nfrom functools import reduce\n\nMOD = 998244353\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef process_problem(l, r, prev_l, prev_r):\n    total_combinations = (r - l + 1) * (prev_r - prev_l + 1)\n    non_inversion_combinations = max(0, (prev_r - l + 1) * (r - prev_l + 1))\n    return non_inversion_combinations, total_combinations\n\ndef calculate_probability(n, problems):\n    # Initialize variables\n    numerator = 1\n    denominator = 1\n    \n    # Sort problems by lower bounds, then by upper bounds\n    problems.sort(key=lambda x: (x[0], x[1]))\n    \n    for i in range(1, n):\n        l_i, r_i = problems[i]\n        l_j, r_j = problems[i-1]\n        \n        non_inv_comb, tot_comb = process_problem(l_i, r_i, l_j, r_j)\n        \n        numerator = (numerator * non_inv_comb) % MOD\n        denominator = (denominator * tot_comb) % MOD\n    \n    # Calculate modular inverse of denominator\n    denominator_inv = modinv(denominator)\n    \n    # Final result\n    result = (numerator * denominator_inv) % MOD\n    return result\n\n# Read input\nn = int(input())\nproblems = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(calculate_probability(n, problems))"}
{"solution": "def count_ways_to_form_rectangle(n):\n    # Initialize the count of ways to form a rectangle but not a square\n    count = 0\n    \n    # Iterate over possible lengths for the sides of the rectangle\n    for a in range(1, n // 4 + 1):\n        for b in range(a, (n - 2 * a) // 2 + 1):\n            c = n - 2 * a - 2 * b\n            # Check if the sides form a rectangle but not a square\n            if c >= b and a != b:\n                count += 1\n                \n    return count\n\n# Read input\nn = int(input())\n\n# Calculate and print the result\nprint(count_ways_to_form_rectangle(n))"}
{"solution": "def max_min_kvass(n, s, volumes):\n    def is_possible(mid):\n        total = 0\n        for v in volumes:\n            total += max(0, v - mid)\n        return total >= s\n\n    if sum(volumes) < s:\n        return -1\n\n    low, high = 0, max(volumes)\n    while low < high:\n        mid = (low + high + 1) // 2\n        if is_possible(mid):\n            low = mid\n        else:\n            high = mid - 1\n\n    return low\n\n# Reading input\nn, s = map(int, input().split())\nvolumes = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(max_min_kvass(n, s, volumes))"}
{"solution": "def caterpillar_and_apple(h1, h2, a, b):\n    net_gain_per_day = a * 12 - b * 12  # Gain during the day minus loss during the night over 24 hours\n    \n    if net_gain_per_day <= 0:\n        # If the caterpillar doesn't gain height overall, check if it can reach the apple in one day\n        if a * (10 - 2) >= h2 - h1:\n            return 0\n        else:\n            return -1\n    \n    # Calculate the remaining distance to the apple\n    remaining_distance = h2 - h1\n    \n    # Calculate the number of full days required\n    full_days = (remaining_distance + net_gain_per_day - 1) // net_gain_per_day\n    \n    # Check if the caterpillar reaches the apple on the last day before slipping down\n    final_height_after_full_days = h1 + (full_days * net_gain_per_day)\n    \n    if final_height_after_full_days >= h2:\n        return full_days\n    \n    # If not, calculate the additional time needed on the final day\n    additional_hours_needed = (h2 - final_height_after_full_days) * 12 // a\n    \n    # Convert additional hours to days if needed\n    if additional_hours_needed > 0:\n        full_days += 1\n    \n    return full_days\n\n# Read input\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Print output\nprint(caterpillar_and_apple(h1, h2, a, b))"}
{"solution": "def max_joy_units(C, H_r, H_b, W_r, W_b):\n    # Calculate the maximum number of candies Om Nom can eat without getting sick\n    max_red = C // W_r\n    max_blue = C // W_b\n    \n    # Initialize the maximum joy units\n    max_joy = 0\n    \n    # Iterate through all possible combinations of red and blue candies\n    for red in range(max_red + 1):\n        remaining_weight = C - (red * W_r)\n        if remaining_weight >= 0:\n            blue = remaining_weight // W_b\n            joy_units = (red * H_r) + (blue * H_b)\n            max_joy = max(max_joy, joy_units)\n    \n    return max_joy\n\n# Read input\nC, H_r, H_b, W_r, W_b = map(int, input().split())\n\n# Calculate and print the maximum number of joy units\nprint(max_joy_units(C, H_r, H_b, W_r, W_b))"}
{"solution": "def minimal_steps(start_x, start_y, end_x, end_y):\n    # Calculate the differences in x and y coordinates\n    delta_x = abs(start_x - end_x)\n    delta_y = abs(start_y - end_y)\n    \n    # The minimal number of steps required is the maximum of the two differences\n    # because the robot can move diagonally (both x and y at the same time).\n    return max(delta_x, delta_y)\n\n# Read input\nstart_x, start_y = map(int, input().split())\nend_x, end_y = map(int, input().split())\n\n# Calculate and print the minimal number of steps\nprint(minimal_steps(start_x, start_y, end_x, end_y))"}
{"solution": "from collections import deque\n\ndef predict_vote_outcome(n, employees):\n    depublicans = deque()\n    remocrats = deque()\n    for i, emp in enumerate(employees):\n        if emp == 'D':\n            depublicans.append(i)\n        else:\n            remocrats.append(i)\n\n    while len(depublicans) > 0 and len(remocrats) > 0:\n        for _ in range(len(depublicans)):\n            if remocrats:\n                remocrats.popleft()\n            else:\n                break\n        for _ in range(len(remocrats)):\n            if depublicans:\n                depublicans.popleft()\n            else:\n                break\n\n    return 'D' if depublicans else 'R'\n\n# Read input\nn = int(input())\nemployees = input().strip()\n\n# Predict the outcome\noutcome = predict_vote_outcome(n, employees)\nprint(outcome)"}
{"solution": "def count_tv_sets(a, b, x, y):\n    # Calculate the maximum possible value for w and h\n    max_w = a // (x // gcd(x, y))\n    max_h = b // (y // gcd(x, y))\n    \n    # Return the minimum of the two to get the number of valid TV sets\n    return min(max_w, max_h)\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Read input\na, b, x, y = map(int, input().split())\n\n# Calculate and print the result\nprint(count_tv_sets(a, b, x, y))"}
{"solution": "import math\n\ndef max_power_of(n, p):\n    \"\"\"\n    Calculate the maximum power of p that divides n!\n    \"\"\"\n    result = 0\n    while n:\n        n //= p\n        result += n\n    return result\n\ndef count_trailing_zeros_in_factorial(n, b):\n    \"\"\"\n    Calculate the number of trailing zeros in the b-ary representation of n!\n    \"\"\"\n    # Prime factorization of b\n    factors = {}\n    temp_b = b\n    for i in range(2, int(math.sqrt(b)) + 1):\n        while temp_b % i == 0:\n            factors[i] = factors.get(i, 0) + 1\n            temp_b //= i\n    if temp_b > 1:\n        factors[temp_b] = 1\n    \n    # Find the minimum power of the prime factors that divide n!\n    min_power = float('inf')\n    for p, power in factors.items():\n        min_power = min(min_power, max_power_of(n, p) // power)\n    \n    return min_power\n\n# Read input\nn, b = map(int, input().split())\n\n# Calculate and print the number of trailing zeros\nprint(count_trailing_zeros_in_factorial(n, b))"}
{"solution": "def calculate_sum(m, a, b):\n    gcd = math.gcd(a, b)\n    a //= gcd\n    b //= gcd\n    \n    if a == 1 or b == 1:\n        return (m + 1) * (m + 2) // 2\n    \n    period = a * b - a - b + 1\n    full_periods = m // period\n    remainder = m % period\n    \n    total_sum = full_periods * (a + b + (period - a - b) * (a + b) // 2)\n    current_pos = full_periods * period\n    while current_pos <= m:\n        total_sum += current_pos + 1\n        current_pos += a\n    current_pos = full_periods * period\n    while current_pos <= m:\n        total_sum += current_pos + 1\n        current_pos += b\n    \n    return total_sum\n\nimport math\n\nm, a, b = map(int, input().split())\nprint(calculate_sum(m, a, b))"}
{"solution": "def can_divide_into_odd_subsegments(n, sequence):\n    odd_count = 0\n    start = -1\n    \n    for i in range(n):\n        if sequence[i] % 2 != 0:\n            if start == -1:\n                start = i\n        else:\n            if start != -1:\n                if (i - start) % 2 == 1:\n                    odd_count += 1\n                    start = -1\n    \n    # Check the last segment if it ends with an odd number\n    if start != -1 and (n - start) % 2 == 1:\n        odd_count += 1\n    \n    return \"Yes\" if odd_count % 2 == 1 and odd_count > 0 else \"No\"\n\n# Reading input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Processing and printing output\nprint(can_divide_into_odd_subsegments(n, sequence))"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    # Check if the points form a vertical or horizontal line\n    if x1 == x2:\n        x3, x4 = x1, x2\n        y3, y4 = y2, y1\n    elif y1 == y2:\n        x3, x4 = x2, x1\n        y3, y4 = y1, y2\n    else:\n        # Check if the points can form a square\n        if abs(x1 - x2) == abs(y1 - y2):\n            x3, x4 = x1, x2\n            y3, y4 = y2, y1\n        else:\n            return [-1]\n\n    # Ensure the coordinates are within the valid range\n    if not (-1000 <= x3 <= 1000) or not (-1000 <= y3 <= 1000) or not (-1000 <= x4 <= 1000) or not (-1000 <= y4 <= 1000):\n        return [-1]\n    \n    return [x3, y3, x4, y4]\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\n\n# Calculate and print the result\nresult = find_remaining_trees(x1, y1, x2, y2)\nprint(*result)"}
{"solution": "MOD = 1000000007\n\ndef solve(x, y, n):\n    if n == 1:\n        return x % MOD\n    if n == 2:\n        return y % MOD\n    \n    # From the recurrence relation, we derive that f3 = y - x and fn = (-1)^(n+1) * (x - y)\n    if n >= 3:\n        if n % 2 == 0:\n            return ((y - x) % MOD + MOD) % MOD\n        else:\n            return ((x - y) % MOD + MOD) % MOD\n\n# Read input\nx, y = map(int, input().split())\nn = int(input())\n\n# Calculate and print the result\nprint(solve(x, y, n))"}
{"solution": "def can_split_array(n, arr):\n    # Initialize variables\n    start = 0\n    splits = []\n    \n    # Iterate through the array\n    for end in range(n):\n        # Check if the current subarray sum is non-zero\n        while start < end and sum(arr[start:end+1]) == 0:\n            start += 1\n        \n        # If the entire array has been traversed and the sum is still zero\n        if start == end and sum(arr[start:end+1]) == 0:\n            return \"NO\", []\n        \n        # If a valid subarray is found, record its indices\n        if start != end:\n            splits.append((start + 1, end + 1))\n            start = end\n    \n    # Add the last subarray if it's non-zero\n    if start == end and sum(arr[start:end+1]) != 0:\n        splits.append((start + 1, end + 1))\n    \n    # Prepare the output\n    output = \"YES\\n\"\n    output += str(len(splits)) + \"\\n\"\n    for split in splits:\n        output += f\"{split[0]} {split[1]}\\n\"\n    \n    return output, splits\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Solve and print the result\nresult, _ = can_split_array(n, arr)\nprint(result)"}
{"solution": "def min_quiz_score(n, m, k):\n    MOD = 1000000009\n    if k > m:\n        return m\n    dp = [0] * (m + 1)\n    dp[0] = 0\n    current_max = 0\n    for i in range(1, m + 1):\n        current_max = (current_max + 1) % MOD\n        if i >= k:\n            current_max = (current_max + (dp[i - k] * (1 << k)) % MOD) % MOD\n        dp[i] = current_max\n    return dp[m]\n\n# Reading input\nn, m, k = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_quiz_score(n, m, k))"}
{"solution": "def is_divisible_by_8(num_str):\n    def find_substring(s, length):\n        for i in range(len(s) - length + 1):\n            if int(s[i:i+length]) % 8 == 0:\n                return s[i:i+length]\n        return None\n\n    # Check for any 1-digit number that is 0\n    if '0' in num_str:\n        return \"YES\\n0\"\n\n    # Check for any 2-digit or 3-digit substring divisible by 8\n    for length in [2, 3]:\n        result = find_substring(num_str, length)\n        if result is not None:\n            return f\"YES\\n{result}\"\n\n    return \"NO\"\n\n# Read input\nn = input().strip()\n\n# Process and print output\nprint(is_divisible_by_8(n))"}
{"solution": "def find_floor(n, m, memory):\n    possible_flats_per_floor = set(range(1, 101))\n    \n    for k, f in memory:\n        if k % f == 0:\n            possible_flats_per_floor &= set(range(k // f, 101))\n        else:\n            possible_flats_per_floor &= set(range((k // f) + 1, 101))\n        \n        if f > 1:\n            if k % (f - 1) == 0:\n                possible_flats_per_floor -= set(range(1, k // (f - 1) + 1))\n            else:\n                possible_flats_per_floor -= set(range(1, (k // (f - 1)) + 1))\n    \n    if len(possible_flats_per_floor) == 1:\n        x = next(iter(possible_flats_per_floor))\n        return (n + x - 1) // x\n    else:\n        floors = {(n + x - 1) // x for x in possible_flats_per_floor}\n        if len(floors) == 1:\n            return next(iter(floors))\n        else:\n            return -1\n\n# Reading input\nn, m = map(int, input().split())\nmemory = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Calculating and printing the output\nprint(find_floor(n, m, memory))"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    board = [list(board1), list(board2)]\n    \n    # Define the four possible shapes of the bishwock\n    bishwock_shapes = [\n        [(0, 0), (0, 1), (1, 0)],  # Original L shape\n        [(0, 0), (0, 1), (1, 1)],  # Rotated 90 degrees\n        [(0, 1), (1, 0), (1, 1)],  # Rotated 180 degrees\n        [(0, 0), (1, 0), (1, 1)]   # Rotated 270 degrees\n    ]\n    \n    def can_place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            if nx < 0 or nx >= 2 or ny < 0 or ny >= n or board[nx][ny] == 'X':\n                return False\n        return True\n    \n    def place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            board[nx][ny] = 'X'\n    \n    count = 0\n    for y in range(n):\n        for x in range(2):\n            for shape in bishwock_shapes:\n                if can_place_bishwock(x, y, shape):\n                    place_bishwock(x, y, shape)\n                    count += 1\n                    break\n    \n    return count\n\n# Example usage\nboard1 = \"00X00X0XXX0\"\nboard2 = \"0XXX0X00X00\"\nprint(max_bishwocks(board1, board2))  # Output: 4"}
{"solution": "def max_pretty_set_length(s):\n    max_length = 0\n    current_set = set()\n    \n    for char in s:\n        if char.islower():\n            current_set.add(char)\n        else:\n            max_length = max(max_length, len(current_set))\n            current_set.clear()\n    \n    # Check the last segment\n    max_length = max(max_length, len(current_set))\n    \n    return max_length\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult = max_pretty_set_length(s)\n\n# Print the result\nprint(result)"}
{"solution": "def max_difference_partition(n, sequence):\n    # Calculate the total sum of the sequence\n    total_sum = sum(sequence)\n    # Initialize the minimum sum to be subtracted\n    min_sum = float('inf')\n    \n    # Iterate through the sequence to find the minimum sum partition\n    current_sum = 0\n    for num in sequence:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n    \n    # Calculate the maximum difference\n    max_diff = total_sum - 2 * min_sum\n    return max_diff\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_difference_partition(n, sequence))"}
{"solution": "def min_refuels(a, b, f, k):\n    # Calculate the maximum distance the bus can travel without refueling\n    max_distance_without_refuel = 2 * f if 2 * f <= b else b + (b - 2 * f)\n    \n    # Check if the bus can complete a single journey without refueling\n    if 2 * a <= b:\n        return 0\n    \n    # Check if the bus can reach the gas station at least once\n    if f > b:\n        return -1\n    \n    # Calculate the minimum number of refuels needed per round trip\n    refuels_per_round_trip = 0\n    if 2 * f > b:\n        refuels_per_round_trip = 1\n    elif f + a > b:\n        refuels_per_round_trip = 1\n    \n    # Calculate the total number of refuels needed\n    total_refuels = 0\n    remaining_journeys = k\n    while remaining_journeys > 0:\n        # Calculate how many round trips can be made without refueling\n        trips_without_refuel = (b - f) // (a - f)\n        if trips_without_refuel >= remaining_journeys:\n            return total_refuels + (remaining_journeys - 1) * refuels_per_round_trip\n        else:\n            total_refuels += trips_without_refuel * refuels_per_round_trip\n            remaining_journeys -= trips_without_refuel\n            # Refuel after completing the trips\n            total_refuels += 1\n            b = 2 * f  # Refuel to the gas station\n    \n    return total_refuels\n\n# Read input\na, b, f, k = map(int, input().split())\n\n# Output the result\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(s, p, q):\n    n = len(s)\n    result = []\n    \n    def can_split(length_p, length_q, remaining):\n        if length_p * p + length_q * q != remaining:\n            return False\n        return True\n    \n    for i in range(n // p + 1):\n        if can_split(i, (n - i * p) // q, n):\n            for _ in range(i):\n                result.append(s[:p])\n                s = s[p:]\n            for _ in range((n - i * p) // q):\n                result.append(s[:q])\n                s = s[q:]\n            return len(result), result\n    return -1\n\nif __name__ == \"__main__\":\n    n, p, q = map(int, input().split())\n    s = input()\n    output = split_string(s, p, q)\n    if output == -1:\n        print(-1)\n    else:\n        k, strings = output\n        print(k)\n        for string in strings:\n            print(string)"}
{"solution": "from bisect import bisect_left\n\ndef can_reach_finish(n, m, s, d, obstacles):\n    obstacles.sort()\n    obstacles.append(m)\n    \n    def can_reach(start, end):\n        if start >= end:\n            return True\n        index = bisect_left(obstacles, start + s, hi=len(obstacles) - 1)\n        if index == len(obstacles) - 1:\n            return False\n        max_jump_end = min(end, obstacles[index + 1] - 1)\n        if start + s <= max_jump_end and start + s + d >= end:\n            return True\n        return False\n    \n    def find_path(start, end):\n        if start >= end:\n            return []\n        index = bisect_left(obstacles, start + s, hi=len(obstacles) - 1)\n        if index == len(obstacles) - 1:\n            return [\"IMPOSSIBLE\"]\n        \n        # Find the furthest obstacle we can jump to\n        max_jump_end = min(end, obstacles[index + 1] - 1)\n        for i in range(index, -1, -1):\n            if obstacles[i] + s <= max_jump_end and obstacles[i] + s + d >= obstacles[i + 1]:\n                path = find_path(start, obstacles[i]) + [f\"RUN {obstacles[i] - start}\"] + [f\"JUMP {obstacles[i + 1] - (obstacles[i] + s)}\"]\n                if obstacles[i + 1] == end:\n                    return path\n                remaining_path = find_path(obstacles[i + 1], end)\n                if remaining_path:\n                    return path + remaining_path\n        \n        return [\"IMPOSSIBLE\"]\n    \n    result = find_path(0, m)\n    if result[0] == \"IMPOSSIBLE\":\n        print(\"IMPOSSIBLE\")\n    else:\n        for step in result:\n            print(step)\n\n# Read input\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\ncan_reach_finish(n, m, s, d, obstacles)"}
{"solution": "def count_pairs(s, x):\n    # Check if s - x is even, which is a necessary condition for valid pairs\n    if (s - x) % 2 == 0:\n        # Calculate b\n        b = (s - x) // 2\n        # Check if b is non-negative\n        if b >= 0:\n            # a = s - b, check if a is also non-negative (which it will be if b is valid)\n            return 2  # Each valid pair can be ordered in 2 ways\n    return 0  # No valid pairs\n\n# Reading input\ns, x = map(int, input().split())\n\n# Printing the output\nprint(count_pairs(s, x))"}
{"solution": "def min_actions(n, k):\n    # Calculate the minimum number of actions needed\n    actions = (n + (2 * k) - 1) // (2 * k + 1)\n    # Generate the sequence of actions\n    result = [(i * (2 * k + 1)) + 1 for i in range(actions)]\n    # Adjust for index out of bounds\n    result = [min(x, n) for x in result]\n    return actions, result\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nactions, skewers = min_actions(n, k)\nprint(actions)\nprint(' '.join(map(str, skewers)))"}
{"solution": "import math\n\ndef min_operations_to_square(n):\n    n_str = str(n)\n    n_len = len(n_str)\n    \n    # Generate all possible squares up to the maximum possible value\n    max_square_root = int(math.sqrt(2 * 10**9)) + 1\n    squares = [str(i * i) for i in range(1, max_square_root + 1)]\n    \n    def is_subsequence(small, large):\n        it = iter(large)\n        return all(char in it for char in small)\n    \n    min_deletions = float('inf')\n    \n    for square in squares:\n        if is_subsequence(square, n_str):\n            deletions = n_len - len(square)\n            min_deletions = min(min_deletions, deletions)\n    \n    return min_deletions if min_deletions != float('inf') else -1\n\n# Read input\nn = int(input())\n\n# Process and print output\nprint(min_operations_to_square(n))"}
{"solution": "from math import gcd\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef mod_inverse(x):\n    return pow(x, MOD - 2, MOD)\n\ndef mod_factorial(n):\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n        inv_fact[i] = mod_inverse(fact[i])\n    return fact, inv_fact\n\ndef mod_combinations(n, k, fact, inv_fact):\n    return fact[n] * inv_fact[k] * inv_fact[n - k] % MOD\n\ndef count_good_permutations(n):\n    fact, inv_fact = mod_factorial(n)\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    result = 0\n    \n    for i in range(2, n + 1):\n        dp[i] = mod_combinations(i - 1, 1, fact, inv_fact) * dp[i - 1] % MOD\n        for j in range(i // 2, 1, -1):\n            dp[i] += mod_combinations(i - 1, j - 1, fact, inv_fact) * dp[j] % MOD\n            dp[i] %= MOD\n        \n        if i % 2 == 0:\n            dp[i] += mod_combinations(i - 1, i // 2 - 1, fact, inv_fact)\n            dp[i] %= MOD\n        \n        result += dp[i]\n        result %= MOD\n    \n    return result\n\nn = int(input())\nprint(count_good_permutations(n))"}
{"solution": "def minimum_jump_ability(s):\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    positions = [-1]  # Start position before the first character\n    \n    # Collect positions of all vowels\n    for i, char in enumerate(s):\n        if char in vowels:\n            positions.append(i)\n    \n    positions.append(len(s))  # End position after the last character\n    \n    # Calculate maximum distance between consecutive positions\n    max_distance = 0\n    for i in range(1, len(positions)):\n        max_distance = max(max_distance, positions[i] - positions[i - 1])\n    \n    return max_distance\n\n# Read input\ns = input().strip()\n\n# Calculate and print the minimum jump ability\nprint(minimum_jump_ability(s))"}
{"solution": "def can_distribute_equally(a1, a2, a3, a4):\n    total_candies = a1 + a2 + a3 + a4\n    # If the total number of candies is odd, it's impossible to distribute equally\n    if total_candies % 2 != 0:\n        return \"NO\"\n    \n    # Check if there's a way to split the candies equally\n    target = total_candies // 2\n    candies = [a1, a2, a3, a4]\n    for i in range(4):\n        for j in range(i + 1, 4):\n            if candies[i] + candies[j] == target:\n                return \"YES\"\n    return \"NO\"\n\n# Read input\na1, a2, a3, a4 = map(int, input().split())\n\n# Output result\nprint(can_distribute_equally(a1, a2, a3, a4))"}
{"solution": "def optimal_pie_distribution(pie_slices):\n    n = len(pie_slices)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for length in range(1, n + 1):\n        for start in range(n - length + 1):\n            end = start + length\n            if length == 1:\n                dp[start][end] = pie_slices[start]\n            else:\n                take_start = pie_slices[start] + dp[start + 1][end] - dp[start + 1][start + length - 1]\n                take_end = pie_slices[start + length - 1] + dp[start][end - 1] - dp[start + length - 1][end - 1]\n                dp[start][end] = max(take_start, take_end)\n    \n    alice_score = dp[0][n]\n    bob_score = sum(pie_slices) - alice_score\n    return alice_score, bob_score\n\n# Reading input\nn = int(input())\npie_slices = list(map(int, input().split()))\n\n# Calculating and printing output\nalice_score, bob_score = optimal_pie_distribution(pie_slices)\nprint(alice_score, bob_score)"}
{"solution": "from collections import defaultdict\n\ndef min_variables(n, seq):\n    # Track the factors of each number in the sequence\n    factors = defaultdict(set)\n    \n    def prime_factors(num):\n        \"\"\"Return the prime factors of a number.\"\"\"\n        i = 2\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                num //= i\n                yield i\n        if num > 1:\n            yield num\n    \n    # Populate the factors dictionary\n    for num in seq:\n        factors[num].add(num)\n        for factor in prime_factors(num):\n            factors[num].add(factor)\n    \n    # Find the intersection of all sets of factors\n    common_factors = set.intersection(*factors.values())\n    \n    # If there are no common factors, it's impossible to perform the operations\n    if len(common_factors) == 0:\n        return -1\n    \n    # Determine the minimum number of variables needed\n    min_vars = max([len(factors[num]) for num in seq])\n    \n    return min_vars\n\n# Read input\nn = int(input())\nseq = list(map(int, input().split()))\n\n# Compute and print the result\nprint(min_variables(n, seq))"}
{"solution": "def determine_winner(n, piles):\n    odd_count = sum(1 for pile in piles if pile % 2 != 0)\n    if odd_count % 2 == 0:\n        return \"Alice\"\n    else:\n        return \"Bob\"\n\n# Read input\nn = int(input())\npiles = list(map(int, input().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, piles))"}
{"solution": "def can_make_equal(arr):\n    arr.sort()\n    n = len(arr)\n    \n    # Check if it's possible to make all elements equal\n    if (arr[-1] - arr[0]) % 2 == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Printing output\nprint(can_make_equal(arr))"}
{"solution": "def find_longest_repeated_substring(s):\n    n = len(s)\n    max_len = 0\n    # Create a set to store seen substrings\n    seen = set()\n    \n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            # Extract substring\n            substring = s[i:j]\n            if substring in seen and i + len(substring) <= j:\n                max_len = max(max_len, len(substring))\n            else:\n                seen.add(substring)\n                \n    return max_len\n\n# Read input\nn = int(input())\ns = input()\n\n# Find and print the maximum length\nprint(find_longest_repeated_substring(s))"}
{"solution": "def minimum_time_to_house(n, a):\n    if a % 2 == 1:\n        # a is odd\n        return (a + 1) // 2\n    else:\n        # a is even\n        return (n - a + 2) // 2\n\n# Read input\nn, a = map(int, input().split())\n\n# Calculate and print the result\nprint(minimum_time_to_house(n, a))"}
{"solution": "def is_mission_possible(n, m, lightsabers, color_counts):\n    from collections import defaultdict\n\n    # Initialize variables\n    required_sum = sum(color_counts)\n    current_counts = defaultdict(int)\n    current_sum = 0\n    left = 0\n\n    # Function to update counts when adding or removing elements\n    def update_counts(action, color):\n        nonlocal current_sum\n        if action == 'add':\n            current_counts[color] += 1\n            if current_counts[color] <= m:\n                current_sum += 1\n        else:\n            current_counts[color] -= 1\n            if current_counts[color] >= 1:\n                current_sum -= 1\n\n    # Iterate over the sequence with a sliding window\n    for right in range(n):\n        update_counts('add', lightsabers[right])\n        while current_sum == required_sum:\n            if all(current_counts[i] == color_counts[i] for i in range(1, m + 1)):\n                return \"YES\"\n            update_counts('remove', lightsabers[left])\n            left += 1\n\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nlightsabers = list(map(int, input().split()))\ncolor_counts = list(map(int, input().split()))\n\n# Output result\nprint(is_mission_possible(n, m, lightsabers, color_counts))"}
{"solution": "def determine_winner(n, rounds):\n    mishka_wins = 0\n    chris_wins = 0\n    \n    for m, c in rounds:\n        if m > c:\n            mishka_wins += 1\n        elif c > m:\n            chris_wins += 1\n    \n    if mishka_wins > chris_wins:\n        return \"Mishka\"\n    elif chris_wins > mishka_wins:\n        return \"Chris\"\n    else:\n        return \"Friendship is magic!^^\"\n\n# Reading input\nn = int(input())\nrounds = [list(map(int, input().split())) for _ in range(n)]\n\n# Determining and printing the winner\nprint(determine_winner(n, rounds))"}
{"solution": "def is_valid_minesweeper_field(n, m, field):\n    def count_bombs(i, j):\n        count = 0\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                nx, ny = i + dx, j + dy\n                if 0 <= nx < n and 0 <= ny < m and field[nx][ny] == '*':\n                    count += 1\n        return count\n\n    for i in range(n):\n        for j in range(m):\n            cell = field[i][j]\n            if cell == '.':\n                if any(0 <= i + dx < n and 0 <= j + dy < m and field[i + dx][j + dy] == '*' for dx in [-1, 0, 1] for dy in [-1, 0, 1]):\n                    return \"NO\"\n            elif cell.isdigit():\n                expected_bombs = int(cell)\n                actual_bombs = count_bombs(i, j)\n                if expected_bombs != actual_bombs:\n                    return \"NO\"\n    return \"YES\"\n\n# Reading input\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\n# Printing output\nprint(is_valid_minesweeper_field(n, m, field))"}
{"solution": "def can_vasya_eat_half(n, k):\n    total_candies = n\n    vasya_eaten = 0\n    \n    while total_cries > 0:\n        # Vasya eats k candies\n        vasya_eaten += min(k, total_candies)\n        total_candies -= min(k, total_candies)\n        \n        # Petya eats 10% of the remaining candies\n        petya_eaten = total_candies // 10\n        total_candies -= petya_eaten\n    \n    return vasya_eaten >= (n + 1) // 2\n\ndef find_min_k(n):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Read input\nn = int(input().strip())\n\n# Find and print the minimal k\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace(s):\n    p = s.count('o')\n    l = s.count('-')\n    \n    if p == 0 or p == 1:\n        return \"YES\"\n    if l % p == 0:\n        return \"YES\"\n    return \"NO\"\n\n# Function to read input and call the can_rearrange_necklace function\ndef solve():\n    s = input().strip()\n    print(can_rearrange_necklace(s))\n\n# Call the solve function\nsolve()"}
{"solution": "def max_pillows_for_frodo(n, m, k):\n    low, high = 1, m\n    result = 0\n    \n    while low <= high:\n        mid = (low + high) // 2\n        required_pillows = 0\n        \n        # Calculate the number of pillows required if Frodo has mid pillows\n        for i in range(1, n + 1):\n            if i == k:\n                required_pillows += mid\n            else:\n                required_pillows += max(1, mid - 1 - abs(k - i))\n        \n        if required_pillows <= m:\n            result = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return result\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Calculate and print the result\nprint(max_pillows_for_frodo(n, m, k))"}
{"solution": "from math import ceil\n\ndef max_subarray_cost(n, m, k, a):\n    dp = [0] * (n + 1)\n    max_cost = 0\n    queue = []\n    \n    for i in range(1, n + 1):\n        dp[i] = a[i - 1] + dp[i - 1]\n        while queue and dp[queue[-1]] < dp[i]:\n            queue.pop()\n        while queue and i - queue[0] >= m:\n            queue.pop(0)\n        current_cost = dp[i] - k * ceil(i / m)\n        max_cost = max(max_cost, current_cost - (dp[queue[0]] - k * ceil(queue[0] / m)) if queue else current_cost)\n        queue.append(i)\n    \n    return max_cost\n\n# Reading input\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(max_subarray_cost(n, m, k, a))"}
{"solution": "def find_longest_polyline(n, m):\n    # Define the four points to maximize the polyline length\n    p1 = (0, 0)\n    p2 = (n, 0)\n    p3 = (n, m)\n    p4 = (0, m)\n    \n    # Print the coordinates of the four points\n    print(p1[0], p1[1])\n    print(p2[0], p2[1])\n    print(p3[0], p3[1])\n    print(p4[0], p4[1])\n\n# Read input\nn, m = map(int, input().split())\n\n# Solve and print the result\nfind_longest_polyline(n, m)"}
{"solution": "def find_smallest_number(shuffled_str, remembered_substring):\n    def is_subsequence(s, sub):\n        it = iter(s)\n        return all(c in it for c in sub)\n\n    n = len(shuffled_str)\n    m = len(remembered_substring)\n    dp = [0] * (n + 1)\n    for i in range(n):\n        dp[i + 1] = dp[i] * 10 + int(shuffled_str[i])\n        if shuffled_str[i] == '0' and dp[i + 1] > 0:\n            dp[i + 1] = 0\n\n    result = float('inf')\n    for length in range(m, n + 1):\n        for start in range(n - length + 1):\n            segment = shuffled_str[start:start + length]\n            if is_subsequence(segment, remembered_substring):\n                prefix = dp[start]\n                suffix = int(shuffled_str[start:start + length])\n                if prefix < 10**(length - len(str(prefix))) or str(prefix).lstrip('0') == '':\n                    candidate = prefix * 10**length + suffix\n                    result = min(result, candidate)\n    return str(result)\n\n# Reading input\nshuffled_str = input().strip()\nremembered_substring = input().strip()\n\n# Solving the problem\nsmallest_number = find_smallest_number(shuffled_str, remembered_substring)\n\n# Printing the output\nprint(smallest_number)"}
{"solution": "def check_temperatures(n, m, min_temp, max_temp, temperatures):\n    # Initialize counters for temperatures below and above the given temperatures\n    below_min = above_max = 0\n    \n    # Count how many temperatures are below the minimum and above the maximum\n    for temp in temperatures:\n        if temp < min_temp:\n            below_min += 1\n        if temp > max_temp:\n            above_max += 1\n    \n    # Check if it's possible to add temperatures to meet the requirements\n    if below_min + (n - m) >= 1 and above_max + (n - m) >= 1:\n        return \"Correct\"\n    else:\n        return \"Incorrect\"\n\n# Read input\nn, m, min_temp, max_temp = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\n# Output result\nprint(check_temperatures(n, m, min_temp, max_temp, temperatures))"}
{"solution": "def count_trailing_zeroes(n):\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count\n\ndef find_numbers_with_m_zeroes(m):\n    start, end = 0, 1000000  # Adjust the range based on the problem constraints\n    \n    # Binary search to find the range of numbers\n    while start <= end:\n        mid = (start + end) // 2\n        if count_trailing_zeroes(mid) < m:\n            start = mid + 1\n        else:\n            end = mid - 1\n            \n    lower_bound = start\n    \n    start, end = lower_bound, 1000000  # Reset the search for the upper bound\n    \n    while start <= end:\n        mid = (start + end) // 2\n        if count_trailing_zeroes(mid) <= m:\n            start = mid + 1\n        else:\n            end = mid - 1\n            \n    upper_bound = end\n    \n    # Collect all numbers within the bounds that have exactly m trailing zeroes\n    results = []\n    for n in range(lower_bound, upper_bound + 1):\n        if count_trailing_zeroes(n) == m:\n            results.append(n)\n    \n    return results\n\n# Read input\nm = int(input())\n\n# Find numbers with exactly m trailing zeroes\nresults = find_numbers_with_m_zeroes(m)\n\n# Output the result\nprint(len(results))\nprint(' '.join(map(str, results)))"}
{"solution": "from heapq import heappush, heappop\nfrom collections import defaultdict\n\ndef dijkstra(graph, start):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        d, u = heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[v] > w:\n                dist[v] = w\n                heappush(pq, (w, v))\n    return dist\n\ndef find_farthest_special_vertices(n, m, k, special_vertices, edges):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u-1].append((v-1, w))\n        graph[v-1].append((u-1, w))\n    \n    # Compute distances from each special vertex to all other vertices\n    distances_from_special = []\n    for sv in special_vertices:\n        distances_from_special.append(dijkstra(graph, sv-1))\n    \n    # Find the farthest special vertex for each special vertex\n    result = []\n    for i, sv in enumerate(special_vertices):\n        max_distance = 0\n        for j, other_sv in enumerate(special_vertices):\n            if i != j:\n                max_distance = max(max_distance, distances_from_special[i][other_sv-1])\n        result.append(max_distance)\n    \n    return result\n\n# Read input\nn, m, k = map(int, input().split())\nspecial_vertices = list(map(int, input().split()))\nedges = [list(map(int, input().split())) for _ in range(m)]\n\n# Solve and print output\noutput = find_farthest_special_vertices(n, m, k, special_vertices, edges)\nprint(*output)"}
{"solution": "def initial_position(n, x):\n    # Determine the initial position of the ball based on the number of moves and final position\n    if n % 2 == 0:\n        # For even number of moves, the positions remain unchanged\n        return x\n    else:\n        # For odd number of moves, swap positions accordingly\n        if x == 0:\n            return 1\n        elif x == 1:\n            return 0\n        else:\n            return 1\n\n# Read input\nn = int(input())\nx = int(input())\n\n# Print the initial position of the ball\nprint(initial_position(n, x))"}
{"solution": "def check_square(rectangles):\n    min_x, min_y = float('inf'), float('inf')\n    max_x, max_y = float('-inf'), float('-inf')\n    \n    # Determine bounding box\n    for x1, y1, x2, y2 in rectangles:\n        min_x, min_y = min(min_x, x1), min(min_y, y1)\n        max_x, max_y = max(max_x, x2), max(max_y, y2)\n    \n    # Check if bounding box forms a square\n    if max_x - min_x != max_y - min_y:\n        return \"NO\"\n    \n    # Initialize grid\n    width = max_x - min_x + 1\n    height = max_y - min_y + 1\n    grid = [[False] * width for _ in range(height)]\n    \n    # Fill grid based on rectangles\n    for x1, y1, x2, y2 in rectangles:\n        for x in range(x1, x2):\n            for y in range(y1, y2):\n                if grid[y - min_y][x - min_x]:\n                    return \"NO\"  # Overlap detected\n                grid[y - min_y][x - min_x] = True\n    \n    # Check if the grid is fully covered\n    for row in grid:\n        if not all(row):\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn = int(input())\nrectangles = [list(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(check_square(rectangles))"}
{"solution": "def count_digits(n):\n    return len(str(n))\n\ndef sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef count_really_big_numbers(n, s):\n    if s <= 9:\n        return max(0, n - 10 + 1)\n    \n    dp = {}\n    \n    def dfs(pos, sum_digits, is_limit, is_nonzero):\n        if pos == 0:\n            return 1 if sum_digits <= s else 0\n        \n        if (pos, sum_digits, is_limit, is_nonzero) in dp:\n            return dp[(pos, sum_digits, is_limit, is_nonzero)]\n        \n        hi = int(str(n)[pos]) if is_limit else 9\n        lo = 0 if is_nonzero else 1\n        total = 0\n        \n        for digit in range(lo, hi + 1):\n            new_limit = is_limit and (digit == int(str(n)[pos]))\n            total += dfs(pos - 1, sum_digits + digit, new_limit, is_nonzero or (digit != 0))\n        \n        dp[(pos, sum_digits, is_limit, is_nonzero)] = total\n        return total\n    \n    num_digits = count_digits(n)\n    result = dfs(num_digits - 1, 0, True, False)\n    return result\n\n# Reading input\nn, s = map(int, input().split())\n\n# Calculating and printing the result\nprint(count_really_big_numbers(n, s))"}
{"solution": "from collections import defaultdict\n\ndef can_cover_with_two_lines(n, points):\n    # Create dictionaries to count occurrences of x and y coordinates\n    x_count = defaultdict(int)\n    y_count = defaultdict(int)\n    \n    # Count occurrences of each x and y coordinate\n    for x, y in points:\n        x_count[x] += 1\n        y_count[y] += 1\n    \n    # Check if any x or y coordinate appears in at least n-1 points\n    if any(count >= n - 1 for count in x_count.values()):\n        return \"YES\"\n    if any(count >= n - 1 for count in y_count.values()):\n        return \"YES\"\n    \n    # Calculate slopes for each pair of points\n    slopes = defaultdict(int)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dx = points[j][0] - points[i][0]\n            dy = points[j][1] - points[i][1]\n            if dx == 0:\n                slope = 'inf'\n            else:\n                slope = dy / dx\n            slopes[slope] += 1\n    \n    # Check if there exists a slope with at least n-2 points\n    if any(count >= n - 2 for count in slopes.values()):\n        return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Determine if the points can be covered by two lines\nprint(can_cover_with_two_lines(n, points))"}
{"solution": "from collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef solve(a, b, k, t):\n    diff = a - b\n    dp = defaultdict(int)\n    dp[diff] = 1\n    \n    for _ in range(t):\n        new_dp = defaultdict(int)\n        for d, count in dp.items():\n            for x in range(-k, k + 1):\n                new_diff = d + x\n                new_dp[new_diff] = (new_dp[new_diff] + count) % MOD\n        dp = new_dp\n    \n    result = sum(dp[d] for d in dp if d > 0) % MOD\n    return result\n\na, b, k, t = map(int, input().split())\nprint(solve(a, b, k, t))"}
{"solution": "from typing import List\n\ndef min_marks(n: int, l: int, x: int, y: int, marks: List[int]) -> List[int]:\n    def can_measure(distance: int, marks: List[int]) -> bool:\n        seen = set(marks)\n        for mark in marks:\n            if distance + mark in seen or abs(mark - distance) in seen:\n                return True\n        return False\n\n    needed_marks = set()\n    if not can_measure(x, marks):\n        needed_marks.add(x)\n    if not can_measure(y, marks):\n        needed_marks.add(y)\n\n    return [len(needed_marks)] + sorted(list(needed_marks))\n\n# Read input\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Compute and print the result\nresult = min_marks(n, l, x, y, marks)\nprint(result[0])\nprint(' '.join(map(str, result[1:])))"}
{"solution": "import math\n\ndef max_cake_volume(n, cakes):\n    # Calculate volumes and store them in a list\n    volumes = [math.pi * r**2 * h for r, h in cakes]\n    \n    # Initialize DP array to store the maximum volume up to each index\n    dp = [0] * n\n    \n    # Function to perform binary search\n    def binary_search(volumes, current_index, start, end):\n        while start < end:\n            mid = (start + end) // 2\n            if volumes[mid] < volumes[current_index]:\n                start = mid + 1\n            else:\n                end = mid\n        return start\n    \n    # Initialize a list to keep track of the indices of the smallest tail of all increasing subsequences\n    tails_indices = []\n    \n    for i in range(n):\n        pos = binary_search(volumes, i, 0, len(tails_indices))\n        dp[i] = volumes[i] + (dp[tails_indices[pos-1]] if pos > 0 else 0)\n        \n        # Update tails_indices\n        if pos == len(tails_indices):\n            tails_indices.append(i)\n        else:\n            tails_indices[pos] = i\n    \n    # Find the maximum volume\n    return max(dp)\n\n# Read input\nn = int(input())\ncakes = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(max_cake_volume(n, cakes))"}
{"solution": "def min_good_slices(n, k, heights):\n    def is_possible(cuts):\n        target_height = heights[n - cuts]\n        total_cost = 0\n        for height in heights[:n - cuts]:\n            if height > target_height:\n                total_cost += height - target_height\n                if total_cost > k:\n                    return False\n        return True\n\n    heights.sort()\n    low, high = 0, n\n    while low < high:\n        mid = (low + high) // 2\n        if is_possible(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\n# Reading input\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(min_good_slices(n, k, heights))"}
{"solution": "def max_game_score(n, a):\n    # Calculate prefix sums\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n    \n    # Initialize variables to track the maximum score and the maximum value in the array\n    max_score = float('-inf')\n    max_value = max(a)\n    \n    # Calculate the initial score without removing any card\n    total_sum = prefix_sum[n]\n    \n    # Initialize left and right pointers for the sliding window\n    l = 0\n    for r in range(n):\n        # Update the total sum by removing the leftmost element when the window slides\n        total_sum -= a[l]\n        l += 1\n        \n        # If the current element is the maximum, update the score\n        if a[r] == max_value:\n            score = total_sum\n            max_score = max(max_score, score)\n        \n        # If there are multiple maximum values, check the segments excluding each one\n        if a[r] == max_value:\n            temp_l = l - 1\n            if temp_l >= 0:\n                temp_sum = prefix_sum[n] - prefix_sum[temp_l] - max_value\n                max_score = max(max_score, temp_sum)\n            \n            temp_r = r\n            if temp_r < n - 1:\n                temp_sum = prefix_sum[temp_r + 1] - prefix_sum[l - 1] - max_value\n                max_score = max(max_score, temp_sum)\n    \n    return max_score\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the maximum score\nprint(max_game_score(n, a))"}
{"solution": "from math import gcd\n\ndef find_lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef can_light_continuously(k1, k2, k3):\n    lcm12 = find_lcm(k1, k2)\n    lcm123 = find_lcm(lcm12, k3)\n    return lcm123 == 1 or (lcm123 // k1 != k2 and lcm123 // k2 != k1 and lcm123 // k3 != k1 and lcm123 // k3 != k2)\n\ndef main():\n    k1, k2, k3 = map(int, input().split())\n    print(\"YES\" if can_light_continuously(k1, k2, k3) else \"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_operations_to_delete_string(n, s):\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(n)]\n    \n    # Base case: single character substrings\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the DP table for substrings of length greater than 1\n    for length in range(2, n + 1):  # length of the substring\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j-1]\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n    \n    # The result for the entire string\n    return dp[0][n-1]\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Output the result\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "# Read the number of boys and their dancing skills\nn = int(input())\nboys = list(map(int, input().split()))\n\n# Read the number of girls and their dancing skills\nm = int(input())\ngirls = list(map(int, input().split()))\n\n# Sort both lists to make it easier to find matching pairs\nboys.sort()\ngirls.sort()\n\n# Initialize pointers for boys and girls lists\nboy_idx, girl_idx = 0, 0\npairs = 0\n\n# Iterate through both lists to find matching pairs\nwhile boy_idx < n and girl_idx < m:\n    # Check if the difference in skills is within the allowed limit\n    if abs(boys[boy_idx] - girls[girl_idx]) <= 1:\n        pairs += 1\n        boy_idx += 1\n        girl_idx += 1\n    elif boys[boy_idx] < girls[girl_idx]:\n        boy_idx += 1\n    else:\n        girl_idx += 1\n\n# Print the maximum number of pairs\nprint(pairs)"}
{"solution": "def determine_winner(a, b):\n    # Calculate all possible configurations for Team 1\n    team1_configs = [(a[0], b[0], a[1], b[1]), (a[1], b[1], a[0], b[0])]\n    team2_configs = [(a[2], b[2], a[3], b[3]), (a[3], b[3], a[2], b[2])]\n\n    # Check if Team 1 can guarantee a win\n    team1_can_win = any(\n        all(\n            (team1_def >= team2_att and team1_att >= team2_def)\n            for team2_def, team2_att, _, _ in team2_configs\n        )\n        for team1_def, team1_att, _, _ in team1_configs\n    )\n\n    # Check if Team 2 can guarantee a win\n    team2_can_win = any(\n        all(\n            (team2_def >= team1_att and team2_att >= team1_def)\n            for team1_def, team1_att, _, _ in team1_configs\n        )\n        for team2_def, team2_att, _, _ in team2_configs\n    )\n\n    # Determine the winner or if it's a draw\n    if team1_can_win and not team2_can_win:\n        return \"Team 1\"\n    elif team2_can_win and not team1_can_win:\n        return \"Team 2\"\n    else:\n        return \"Draw\"\n\n# Read input\na = []\nb = []\nfor _ in range(4):\n    ai, bi = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\n\n# Output the result\nprint(determine_winner(a, b))"}
{"solution": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef calculate_time(X, Y, meats, K):\n    distances = [(c * np.sqrt((X - x) ** 2 + (Y - y) ** 2)) for x, y, c in meats]\n    return np.partition(distances, K - 1)[K - 1]\n\ndef objective_func(position, meats, K):\n    X, Y = position\n    return calculate_time(X, Y, meats, K)\n\ndef find_optimal_position(meats, K):\n    initial_guess = (0.0, 0.0)\n    result = minimize(lambda pos: objective_func(pos, meats, K), initial_guess, method='Powell')\n    return result.fun\n\n# Reading input\nN, K = map(int, input().split())\nmeats = [tuple(map(int, input().split())) + (i,) for i in range(N)]\n\n# Solving for the optimal position\noptimal_time = find_optimal_position(meats, K)\nprint(f\"{optimal_time:.6f}\")"}
{"solution": "def determine_winner(n, ticket):\n    left_sum = 0\n    right_sum = 0\n    left_erasures = 0\n    right_erasures = 0\n    \n    half = n // 2\n    \n    for i, char in enumerate(ticket):\n        if char == '?':\n            if i < half:\n                left_erasures += 1\n            else:\n                right_erasures += 1\n        else:\n            if i < half:\n                left_sum += int(char)\n            else:\n                right_sum += int(char)\n    \n    # Calculate the maximum possible sum that can be achieved by replacing erasures\n    max_left_sum = left_sum + min(9 * (left_erasures // 2), 9 * (right_erasures // 2))\n    max_right_sum = right_sum + min(9 * (right_erasures // 2), 9 * (left_erasures // 2))\n    \n    # Check if the sums can be made equal\n    if left_erasures % 2 == 0 and right_erasures % 2 == 0 and max_left_sum == max_right_sum:\n        return \"Bicarp\"\n    else:\n        return \"Monocarp\"\n\n# Read input\nn = int(input())\nticket = input()\n\n# Determine and print the winner\nprint(determine_winner(n, ticket))"}
{"solution": "def find_bus_route(n, t, bus_routes):\n    earliest_time = float('inf')\n    chosen_route = -1\n    \n    for i in range(n):\n        s_i, d_i = bus_routes[i]\n        \n        if s_i >= t:\n            next_bus_time = s_i\n        else:\n            # Calculate the next bus time after t\n            if (t - s_i) % d_i == 0:\n                next_bus_time = t\n            else:\n                next_bus_time = s_i + ((t - s_i) // d_i + 1) * d_i\n        \n        if next_bus_time <= t and next_bus_time < earliest_time:\n            earliest_time = next_bus_time\n            chosen_route = i + 1\n    \n    return chosen_route\n\n# Reading input\nn, t = map(int, input().split())\nbus_routes = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Printing output\nprint(find_bus_route(n, t, bus_routes))"}
{"solution": "def count_ones_in_range(start, end, k):\n    count = 0\n    for i in range(start, end + 1):\n        if bin(i).count('1') == k:\n            count += 1\n    return count\n\ndef find_n(m, k):\n    low, high = 1, 10**18\n    while low <= high:\n        mid = (low + high) // 2\n        count = count_ones_in_range(mid + 1, 2 * mid, k)\n        if count == m:\n            return mid\n        elif count < m:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low\n\n# Reading input\nm, k = map(int, input().split())\n\n# Finding and printing the result\nprint(find_n(m, k))"}
{"solution": "def is_good_level(n, level_scheme):\n    # Convert the level scheme into a list of indices where platforms are located\n    platforms = [i for i, char in enumerate(level_scheme) if char == '*']\n    \n    # Check for a sequence of four jumps of the same length\n    for i in range(len(platforms)):\n        for j in range(i + 1, len(platforms)):\n            if platforms[j] - platforms[i] > 2:  # Ensure the gap is more than 2 to avoid trivial cases\n                k = platforms[j] + (platforms[j] - platforms[i])\n                l = k + (platforms[j] - platforms[i])\n                m = l + (platforms[j] - platforms[i])\n                if k in platforms and l in platforms and m in platforms:\n                    return \"yes\"\n    return \"no\"\n\n# Read input\nn = int(input())\nlevel_scheme = input()\n\n# Output result\nprint(is_good_level(n, level_scheme))"}
{"solution": "def read_matrix(n):\n    matrix = []\n    for _ in range(n):\n        row = list(map(int, input().split()))\n        matrix.append(row)\n    return matrix\n\ndef find_empty_cell(matrix):\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            if matrix[i][j] == 0:\n                return i, j\n    return None\n\ndef calculate_magic_constant(matrix, n, row_sum):\n    # Check columns\n    for j in range(n):\n        col_sum = sum(matrix[i][j] for i in range(n))\n        if col_sum != row_sum:\n            return -1\n\n    # Check main diagonal\n    main_diag_sum = sum(matrix[i][i] for i in range(n))\n    if main_diag_sum != row_sum:\n        return -1\n\n    # Check secondary diagonal\n    sec_diag_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if sec_diag_sum != row_sum:\n        return -1\n\n    return row_sum\n\ndef solve_magic_square(matrix, n):\n    row_sums = [sum(row) for row in matrix]\n    col_sums = [sum(matrix[i][j] for i in range(n)) for j in range(n)]\n    \n    # Find the empty cell\n    empty_cell = find_empty_cell(matrix)\n    if empty_cell is None:\n        return -1\n    \n    row, col = empty_cell\n    row_sum = row_sums[row]\n    \n    # Calculate the missing value\n    missing_value = calculate_magic_constant(matrix, n, row_sum - matrix[row][col])\n    \n    # Check if the calculated value fits in the column and diagonals\n    if missing_value != -1 and col_sums[col] + missing_value == row_sum:\n        return missing_value\n    else:\n        return -1\n\nn = int(input())\nmatrix = read_matrix(n)\nprint(solve_magic_square(matrix, n))"}
{"solution": "def calculate_min_max_k(n, m, a):\n    # Calculate the maximum possible k\n    max_k = max(a) + m\n    \n    # Calculate the total number of people after adding m people\n    total_people = sum(a) + m\n    \n    # Calculate the minimum possible k\n    min_k = (total_people + n - 1) // n\n    \n    return min_k, max_k\n\n# Read input\nn = int(input())\nm = int(input())\na = [int(input()) for _ in range(n)]\n\n# Calculate and print the result\nmin_k, max_k = calculate_min_max_k(n, m, a)\nprint(min_k, max_k)"}
{"solution": "def calculate_ways(n, m):\n    MOD = 10**9 + 7\n    \n    # Precompute factorials and their modular inverses\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    \n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n        inv_fact[i] = pow(fact[i], MOD - 2, MOD)\n    \n    def nCr(n, r):\n        return fact[n] * inv_fact[r] * inv_fact[n - r] % MOD\n    \n    # Calculate the number of ways\n    ways = 1\n    for i in range(1, m + 1):\n        ways = ways * nCr(n, i) * pow(2, i, MOD) % MOD\n    \n    return ways\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_ways(n, m))"}
{"solution": "from collections import defaultdict\n\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef read_pizzas(m):\n    pizzas = []\n    for _ in range(m):\n        c, r, *a = read_ints()\n        pizzas.append((c, set(a)))\n    return pizzas\n\ndef read_friends(n):\n    friends = []\n    for _ in range(n):\n        f, *b = read_ints()\n        friends.append(set(b))\n    return friends\n\ndef max_satisfaction(pizzas, friends):\n    n, m = len(friends), len(pizzas)\n    satisfied_counts = [[0] * m for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            combined_ingredients = pizzas[i][1] | pizzas[j][1]\n            for friend in friends:\n                if friend.issubset(combined_ingredients):\n                    satisfied_counts[i][j] += 1\n                    satisfied_counts[j][i] += 1\n    \n    max_satisfied = 0\n    min_cost = float('inf')\n    best_pair = (0, 1)\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            cost = pizzas[i][0] + pizzas[j][0]\n            if satisfied_counts[i][j] > max_satisfied or (satisfied_counts[i][j] == max_satisfied and cost < min_cost):\n                max_satisfied = satisfied_counts[i][j]\n                min_cost = cost\n                best_pair = (i + 1, j + 1)\n    \n    print(*best_pair)\n\ndef main():\n    n, m = read_ints()\n    friends = read_friends(n)\n    pizzas = read_pizzas(m)\n    max_satisfaction(pizzas, friends)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_min_max_numbers(m, s):\n    def build_number(is_min):\n        result = []\n        if is_min:\n            # Build the minimum number\n            i = 1\n            while s > 0 and m > 0:\n                if s >= 9:\n                    result.append(9)\n                    s -= 9\n                else:\n                    result.append(s)\n                    s = 0\n                m -= 1\n            if s > 0:  # Sum cannot be distributed\n                return -1\n            result.extend([0] * m)\n        else:\n            # Build the maximum number\n            while m > 0:\n                if s >= 9:\n                    result.append(9)\n                    s -= 9\n                else:\n                    result.append(s)\n                    s = 0\n                m -= 1\n            if s > 0:  # Sum cannot be distributed\n                return -1\n            result[0] = min(9, s + result[0])\n        \n        # Handle leading zero for min\n        if is_min and result[-1] == 0:\n            return -1\n        \n        return int(''.join(map(str, reversed(result))))\n    \n    min_num = build_number(True)\n    max_num = build_number(False)\n    \n    if min_num == -1 or max_num == -1:\n        return [-1, -1]\n    else:\n        return [min_num, max_num]\n\n# Read input\nm, s = map(int, input().split())\n\n# Calculate and print the result\nresult = find_min_max_numbers(m, s)\nprint(f\"{result[0]} {result[1]}\")"}
{"solution": "MOD = 998244353\n\ndef sum_of_numbers_with_k_digits(l, r, k):\n    def sum_range(start, end):\n        return ((end * (end + 1)) // 2 - (start * (start - 1)) // 2) % MOD\n    \n    def is_valid_number(n, k):\n        digits = set()\n        while n > 0:\n            digits.add(n % 10)\n            n //= 10\n        return len(digits) <= k\n    \n    total_sum = 0\n    current_sum = 0\n    for num in range(l, r + 1):\n        if is_valid_number(num, k):\n            current_sum += num\n            current_sum %= MOD\n        total_sum += current_sum\n        total_sum %= MOD\n    \n    return total_sum\n\n# Reading input\nl, r, k = map(int, input().split())\n\n# Calculating the result\nresult = sum_of_numbers_with_k_digits(l, r, k)\n\n# Printing the output\nprint(result)"}
{"solution": "def can_distribute_pencils(n, k, d, pencils):\n    pencils.sort()\n    groups = 0\n    last_group_max = -1\n    \n    for i in range(n):\n        if i == 0 or (pencils[i] - last_group_max <= d):\n            if (n - i) % k == 0:\n                last_group_max = pencils[i]\n        else:\n            groups += 1\n            last_group_max = pencils[i]\n            if (n - i) % k != 0:\n                return \"NO\"\n    \n    # Check if the last group can be formed\n    if (n - i) % k == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, k, d = map(int, input().split())\npencils = list(map(int, input().split()))\n\n# Output result\nprint(can_distribute_pencils(n, k, d, pencils))"}
{"solution": "from collections import Counter\n\ndef count_dead_bulbs(garland):\n    # Count occurrences of each color\n    color_counts = Counter(garland)\n    \n    # Calculate the total length of the garland\n    total_length = len(garland)\n    \n    # Calculate the expected minimum occurrences of each color\n    expected_min_occurrences = total_length // 4\n    \n    # Initialize counters for dead bulbs of each color\n    dead_counts = {'R': 0, 'B': 0, 'Y': 0, 'G': 0}\n    \n    # Calculate the number of dead bulbs for each color\n    for color in 'RBYG':\n        # The number of dead bulbs for a color is the difference between expected and actual occurrences\n        dead_counts[color] = expected_min_occurrences - color_counts.get(color, 0)\n    \n    # Adjust for any extra dead bulbs if total_length % 4 != 0\n    extra_deads = total_length % 4\n    for color in 'RBYG':\n        if extra_deads > 0 and color_counts.get('!', 0) > 0:\n            dead_counts[color] += 1\n            extra_deads -= 1\n    \n    # Print the result\n    print(dead_counts['R'], dead_counts['B'], dead_counts['Y'], dead_counts['G'])\n\n# Read input\ngarland = input().strip()\n\n# Process and print the result\ncount_dead_bulbs(garland)"}
{"solution": "from collections import defaultdict, deque\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    N, M = map(int, input().split())\n    graph = defaultdict(list)\n    outdeg = [0] * (N + 1)\n    for _ in range(M):\n        s, t = map(int, input().split())\n        graph[s].append(t)\n        outdeg[s] += 1\n\n    # Topological Sort\n    queue = deque([i for i in range(1, N + 1) if outdeg[i] == 0])\n    order = []\n    while queue:\n        node = queue.popleft()\n        order.append(node)\n        for neighbor in graph[node]:\n            outdeg[neighbor] -= 1\n            if outdeg[neighbor] == 0:\n                queue.append(neighbor)\n\n    # Calculate expected values\n    exp_val = [0] * (N + 1)\n    for node in reversed(order):\n        if node == N:\n            exp_val[node] = 0\n        else:\n            exp_val[node] = 1 + sum(exp_val[neighbor] for neighbor in graph[node]) / len(graph[node])\n\n    # Find minimum expected value after blocking\n    min_exp_val = exp_val[1]\n    for node in graph[1]:\n        new_exp_val = (exp_val[1] * len(graph[1]) - exp_val[node]) / (len(graph[1]) - 1)\n        min_exp_val = min(min_exp_val, new_exp_val)\n\n    print(f\"{min_exp_val:.10f}\")\n\nsolve()"}
{"solution": "n = int(input())\nlast_digit = n % 10\nif last_digit < 5:\n    n -= last_digit\nelse:\n    n += (10 - last_digit)\nprint(n)"}
{"solution": "def find_swaps(s, t):\n    if len(s) != len(t):\n        return -1\n    \n    mismatches = {}\n    swaps = []\n    \n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if s[i] in mismatches and mismatches[s[i]] != t[i]:\n                return -1\n            if t[i] in mismatches and mismatches[t[i]] != s[i]:\n                return -1\n            mismatches[s[i]] = t[i]\n            mismatches[t[i]] = s[i]\n    \n    visited = set()\n    \n    for key in mismatches:\n        if key not in visited:\n            cycle = []\n            current = key\n            while current not in visited:\n                visited.add(current)\n                cycle.append(current)\n                current = mismatches[current]\n            if len(cycle) != 2:\n                return -1\n            swaps.append((cycle[0], cycle[1]))\n    \n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0], swap[1])\n\n# Example usage:\ns = \"helloworld\"\nt = \"ehoolwlroz\"\nfind_swaps(s, t)\n\ns = \"hastalavistababy\"\nt = \"hastalavistababy\"\nfind_swaps(s, t)\n\ns = \"merrychristmas\"\nt = \"christmasmerry\"\nfind_swaps(s, t)"}
{"solution": "def earliest_login(first_name, last_name):\n    # Initialize the earliest login with the concatenation of both full names\n    earliest = first_name + last_name\n    \n    # Iterate through all possible prefixes of the first name\n    for i in range(1, len(first_name) + 1):\n        # Iterate through all possible prefixes of the last name\n        for j in range(1, len(last_name) + 1):\n            # Generate the current combination of prefixes\n            current = first_name[:i] + last_name[:j]\n            # Update the earliest login if the current combination is alphabetically earlier\n            if current < earliest:\n                earliest = current\n                \n    return earliest\n\n# Read input\nfirst_name, last_name = input().split()\n\n# Calculate and print the alphabetically earliest login\nprint(earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(n, sequence):\n    def draw(bracket_stack, height):\n        if not bracket_stack:\n            return [\"+\" + \"-\" * (2 * height - 1) + \"+\"]\n        \n        current, rest = bracket_stack[0], bracket_stack[1:]\n        top = \"+\" + \"-\" * (2 * height - 1) + \"+\"\n        lines = [top]\n        for i in range(height):\n            line = \"|\" + \" \" * (2 * height - 1) + \"|\"\n            lines.append(line)\n        lines.extend(draw(rest, height - 1))\n        \n        if current == '[':\n            return lines\n        else:\n            return [lines[0]] + [line.replace(\" \", \"|\", 1) for line in lines[1:]]\n\n    bracket_stack = []\n    for char in sequence:\n        if char == '[':\n            bracket_stack.append('[')\n        elif char == ']':\n            height = len(bracket_stack)\n            bracket_stack.pop()\n            drawing = draw([']', bracket_stack[:]], height)\n            bracket_stack.append(drawing)\n\n    final_drawing = bracket_stack[-1]\n    if isinstance(final_drawing, list):\n        for i, line in enumerate(final_drawing):\n            final_drawing[i] = line.replace(\" \", \"|\", 1)\n    return \"\\n\".join(final_drawing)\n\n# Reading input\nn = int(input())\nsequence = input()\n\n# Generating and printing the output\nprint(draw_brackets(n, sequence))"}
{"solution": "def normalize_golden_number(golden_number):\n    # Convert the golden number string to a list of integers for easier manipulation\n    golden_number = list(map(int, golden_number))\n    n = len(golden_number)\n    \n    # Normalize the number using the property q^2 = q + 1\n    for i in range(n - 1, 0, -1):\n        if golden_number[i] > 1:\n            golden_number[i] -= 2\n            golden_number[i - 1] += 1\n            if i - 2 >= 0:\n                golden_number[i - 2] += 1\n    \n    # Remove leading zeros\n    while len(golden_number) > 1 and golden_number[0] == 0:\n        golden_number.pop(0)\n    \n    return golden_number\n\ndef compare_golden_numbers(num1, num2):\n    # Normalize both numbers\n    norm_num1 = normalize_golden_number(num1)\n    norm_num2 = normalize_golden_number(num2)\n    \n    # Compare lengths first\n    if len(norm_num1) > len(norm_num2):\n        return \">\"\n    elif len(norm_num1) < len(norm_num2):\n        return \"<\"\n    \n    # If lengths are equal, compare digit by digit\n    for digit1, digit2 in zip(norm_num1, norm_num2):\n        if digit1 > digit2:\n            return \">\"\n        elif digit1 < digit2:\n            return \"<\"\n    \n    # If all digits are equal\n    return \"=\"\n\n# Read input\nnum1 = input().strip()\nnum2 = input().strip()\n\n# Compare the numbers and print the result\nresult = compare_golden_numbers(num1, num2)\nprint(result)"}
{"solution": "# Define the mapping of gem colors to their names\ngem_colors_to_names = {\n    'purple': 'Power',\n    'green': 'Time',\n    'blue': 'Space',\n    'orange': 'Soul',\n    'red': 'Reality',\n    'yellow': 'Mind'\n}\n\n# Read the number of gems in the gauntlet\nn = int(input())\n\n# Initialize a set to store the colors of the gems seen\nseen_gems = set()\n\n# Read the colors of the gems seen\nfor _ in range(n):\n    color = input().strip()\n    seen_gems.add(color)\n\n# Determine the absent gems\nabsent_gems = [gem_colors_to_names[color] for color in gem_colors_to_names if color not in seen_gems]\n\n# Output the number of absent gems\nprint(len(absent_gems))\n\n# Output the names of the absent gems\nfor gem_name in absent_gems:\n    print(gem_name)"}
{"solution": "def find_meeting_round(n, a, b):\n    while n > 1:\n        if abs(a - b) == 1:\n            return n // 2\n        elif a > b:\n            a, b = b, a\n        if b - a > n // 2:\n            return \"Final!\"\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n //= 2\n    return \"Final!\"\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Print output\nprint(find_meeting_round(n, a, b))"}
{"solution": "def min_changes(n, p, b):\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n            size[rootY] += size[rootX]\n\n    parent = list(range(2 * n))\n    size = [1] * (2 * n)\n\n    for i in range(n):\n        pi = p[i] - 1\n        bi = b[i]\n        union(i, pi + n * bi)\n\n    components = sum(1 for i in range(n) if find(i) == i)\n    return 2 * n - components\n\n# Reading input\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(min_changes(n, p, b))"}
{"solution": "def max_path_length(v1, v2, t, d):\n    # Initialize variables\n    path_length = 0\n    current_speed = v1\n    \n    # Calculate the maximum path length for the first t-1 seconds\n    for i in range(t - 1):\n        path_length += current_speed\n        # Adjust speed towards v2 with maximum change d per second\n        if current_speed < v2:\n            current_speed = min(current_speed + d, v2)\n        else:\n            current_speed = max(current_speed - d, v2)\n    \n    # Add the speed of the last second\n    path_length += current_speed\n    \n    return path_length\n\n# Read input\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Calculate and print the maximum possible length of the path section\nprint(max_path_length(v1, v2, t, d))"}
{"solution": "from itertools import permutations\nfrom bisect import bisect_left\n\ndef check_order(perm, L, V, W):\n    max_dist = 0\n    for i in range(len(L)):\n        start, end = max_dist, max_dist + L[i]\n        camels_in_part = [W[j] for j in range(len(W)) if perm[j] >= start and perm[j] < end]\n        if sum(camels_in_part) > V[i]:\n            return False, 0\n        max_dist = end\n    return True, max_dist\n\ndef solve(N, M, W, L, V):\n    W.sort(reverse=True)\n    min_distance = float('inf')\n    \n    for perm in permutations(range(N), N):\n        camel_positions = [0] + list(perm) + [M]\n        distances = [camel_positions[i+1] - camel_positions[i] for i in range(len(camel_positions)-1)]\n        \n        for d in range(max(distances), 1000000001):\n            valid, dist = check_order([distances[i] + d * (i+1) for i in range(N)], L, V, W)\n            if valid:\n                min_distance = min(min_distance, dist)\n                break\n    \n    if min_distance == float('inf'):\n        return -1\n    else:\n        return min_distance\n\n# Reading input\nN, M = map(int, input().split())\nW = list(map(int, input().split()))\nL, V = [], []\nfor _ in range(M):\n    l, v = map(int, input().split())\n    L.append(l)\n    V.append(v)\n\n# Solving and printing output\nprint(solve(N, M, W, L, V))"}
{"solution": "def last_digit_of_factorial_ratio(a, b):\n    \"\"\"\n    Calculate the last digit of the ratio of b! to a!.\n    \"\"\"\n    # For b >= 5 and a >= 5, the last digit is 0 because the factorial includes a 10 (2*5)\n    if b >= 5 and a >= 5:\n        return 0\n    \n    # Calculate factorial of b and a, but only for values less than 5\n    def factorial(n):\n        if n == 0:\n            return 1\n        fact = 1\n        for i in range(1, n + 1):\n            fact *= i\n        return fact\n    \n    # Calculate the last digit of the ratio\n    last_digit_b = factorial(b) % 10\n    last_digit_a = factorial(a) % 10\n    \n    # If a is 0, the result is simply the last digit of b!\n    if a == 0:\n        return last_digit_b\n    \n    # Calculate the last digit of the ratio b! / a!\n    last_digit_ratio = (last_digit_b * pow(last_digit_a, -1, 10)) % 10\n    \n    return last_digit_ratio\n\n# Read input\na, b = map(int, input().split())\n\n# Output the last digit\nprint(last_digit_of_factorial_ratio(a, b))"}
{"solution": "from collections import deque\n\ndef min_jumps(n, d, s):\n    # Initialize the queue and visited array\n    queue = deque([(1, 0)])  # (position, jumps)\n    visited = [False] * (n + 1)\n    visited[1] = True\n    \n    while queue:\n        position, jumps = queue.popleft()\n        \n        # Check if we have reached the target\n        if position == n:\n            return jumps + 1\n        \n        # Explore all possible jumps from the current position\n        for jump in range(1, d + 1):\n            next_position = position + jump\n            \n            # Check if the next position is within bounds and has a lily\n            if 1 <= next_position <= n and s[next_position - 1] == '1' and not visited[next_position]:\n                visited[next_position] = True\n                queue.append((next_position, jumps + 1))\n    \n    # If we cannot reach the target\n    return -1\n\n# Read input\nn, d = map(int, input().split())\ns = input()\n\n# Compute and print the result\nprint(min_jumps(n, d, s))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_counterexample(n):\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\nn = int(input().strip())\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all(n):\n    # Constants representing the costs of houses, cars, and computers\n    cost_house = 1234567\n    cost_car = 123456\n    cost_computer = 1234\n    \n    # Loop through possible number of houses\n    for a in range(n // cost_house + 1):\n        # Remaining amount after buying 'a' houses\n        remaining_after_houses = n - a * cost_house\n        \n        # Loop through possible number of cars\n        for b in range(remaining_after_houses // cost_car + 1):\n            # Remaining amount after buying 'b' cars\n            remaining_after_cars = remaining_after_houses - b * cost_car\n            \n            # Check if the remaining amount can be spent on computers\n            if remaining_after_cars % cost_computer == 0:\n                return \"YES\"\n    \n    # If no combination of houses, cars, and computers sums up to n\n    return \"NO\"\n\n# Read input\nn = int(input())\n\n# Print output\nprint(can_spend_all(n))"}
{"solution": "def find_intersection(k1, b1, k2, b2):\n    if k1 == k2:\n        return None\n    x = (b2 - b1) / (k1 - k2)\n    return x\n\ndef check_intersection_inside_strip(n, x1, x2, lines):\n    for i in range(n):\n        for j in range(i + 1, n):\n            x = find_intersection(lines[i][0], lines[i][1], lines[j][0], lines[j][1])\n            if x1 < x < x2:\n                return \"Yes\"\n    return \"No\"\n\n# Reading input\nn = int(input())\nx1, x2 = map(int, input().split())\nlines = []\nfor _ in range(n):\n    k, b = map(int, input().split())\n    lines.append((k, b))\n\n# Solving and printing output\nprint(check_intersection_inside_strip(n, x1, x2, lines))"}
{"solution": "def count_different_weights(n):\n    # The maximum possible weight is n (all elements being 1)\n    # The minimum possible weight is 1 (the sequence being [n])\n    # We need to count the number of divisors of n, which will give us the different weights\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # i is a divisor\n            count += 1\n            # Check if n // i is a different divisor\n            if n // i != i:\n                count += 1\n    return count\n\n# Read input\nn = int(input())\n\n# Calculate and print the result\nprint(count_different_weights(n))"}
{"solution": "def find_good_apartments(n, k):\n    if k == 0:\n        min_good = 0\n        max_good = 0\n    else:\n        min_good = 1\n        max_good = min(n - k, 2 * k)\n    \n    return min_good, max_good\n\n# Reading input\nn, k = map(int, input().split())\n\n# Calculating and printing the result\nmin_good, max_good = find_good_apartments(n, k)\nprint(min_good, max_good)"}
{"solution": "import math\n\ndef max_games_winner_can_play(n):\n    \"\"\"\n    Determine the maximum number of games the winner of the tournament can take part in.\n    \n    Args:\n    n (int): The number of players participating in the tournament.\n    \n    Returns:\n    int: The maximum number of games the winner can play.\n    \"\"\"\n    return int(math.floor(math.log2(n)))\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the result\nprint(max_games_winner_can_play(n))"}
{"solution": "def max_vk_occurrences(s):\n    n = len(s)\n    vk_count = 0\n    v_count = 0\n    k_after_v = 0\n    \n    for i in range(n):\n        if s[i] == 'V':\n            v_count += 1\n            k_after_v = 0\n        elif s[i] == 'K' and v_count > 0:\n            vk_count += 1\n            v_count -= 1\n            k_after_v = 1\n    \n    # If there's a 'V' at the end, changing it to 'K' won't help, but changing 'K' before it to 'V' can help\n    max_possible = vk_count + min(v_count, 1) + k_after_v\n    \n    return max_possible\n\n# Read input\ns = input()\n\n# Compute and print the result\nprint(max_vk_occurrences(s))"}
{"solution": "import math\n\ndef min_segments(n):\n    a = int(math.sqrt(n))\n    b = (n + a - 1) // a  # Equivalent to math.ceil(n / a)\n    return a + b + 2\n\n# Read input\nn = int(input().strip())\nprint(min_segments(n))"}
{"solution": "a, b = map(int, input().split())\nyears = 0\n\nwhile a <= b:\n    a *= 3\n    b *= 2\n    years += 1\n\nprint(years)"}
{"solution": "def calculate_visited_nodes(h, n):\n    visited = 0\n    position = 0\n    level = 0\n    skipped = 0\n    command_index = 0\n    \n    while True:\n        if level == h:\n            break\n        \n        # Determine the direction based on the command string\n        direction = 'L' if command_index % 2 == 0 else 'R'\n        \n        # Calculate the new position\n        new_position = (2 * position) + (1 if direction == 'R' else 0)\n        \n        # Check if the new position is within bounds\n        if new_position < 2 ** (level + 1):\n            position = new_position\n            level += 1\n            visited += 1\n            command_index += 1\n            skipped = 0\n        else:\n            skipped += 1\n        \n        # If two consecutive commands are skipped, go up one level\n        if skipped == 2:\n            level -= 1\n            position //= 2\n            skipped = 0\n            command_index += 1\n    \n    return visited\n\n# Read input\nh, n = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_visited_nodes(h, n))"}
{"solution": "def find_tables(x):\n    def num_squares(n, m):\n        return sum(min(n, i) * min(m, i) for i in range(1, min(n, m) + 1))\n\n    result = []\n    max_dim = int(x ** 0.5) + 1  # Upper bound for dimensions\n    \n    for n in range(1, max_dim):\n        low, high = 1, max_dim\n        while low <= high:\n            m = (low + high) // 2\n            total_squares = num_squares(n, m)\n            if total_squares == x:\n                result.append((n, m))\n                break\n            elif total_squares < x:\n                low = m + 1\n            else:\n                high = m - 1\n    \n    # Ensure the result is sorted by n, then by m\n    result.sort()\n    \n    # Output\n    print(len(result))\n    for n, m in result:\n        print(n, m)\n\n# Read input\nx = int(input())\n\n# Solve and print the result\nfind_tables(x)"}
{"solution": "def is_leap_year(year):\n    return (year % 400 == 0) or (year % 4 == 0 and year % 100 != 0)\n\ndef days_in_month(month, year):\n    if month == 2:\n        return 29 if is_leap_year(year) else 28\n    return 31 if month in [1, 3, 5, 7, 8, 10, 12] else 30\n\ndef check_consecutive_months(durations):\n    current_year = 1900  # Starting year\n    current_month = 1    # January\n    \n    for day_count in durations:\n        if day_count != days_in_month(current_month, current_year):\n            return False\n        current_month += 1\n        if current_month > 12:\n            current_month = 1\n            current_year += 1\n    \n    return True\n\ndef main():\n    n = int(input())\n    durations = list(map(int, input().split()))\n    \n    print(\"Yes\" if check_consecutive_months(durations) else \"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from math import gcd\n\ndef find_sequence(n):\n    if n == 2:\n        return \"NO\"\n    \n    # Function to check if a number is a divisor of n\n    def is_divisor(x, n):\n        return n % x == 0\n    \n    # Function to simplify a fraction\n    def simplify(a, b):\n        common_divisor = gcd(a, b)\n        return a // common_divisor, b // common_divisor\n    \n    # Initialize variables\n    sequence = []\n    used_divisors = set()\n    \n    # Find divisors of n\n    for b in range(2, n):\n        if is_divisor(b, n) and b not in used_divisors:\n            a = b - 1\n            while a > 1 and a >= b // 2:\n                if gcd(a, b) == 1:\n                    sequence.append((a, b))\n                    used_divisors.add(b)\n                    break\n                a -= 1\n    \n    # Check if the sum of the sequence equals 1 - 1/n\n    total_sum = 0\n    for a, b in sequence:\n        total_sum += a / b\n    \n    if total_sum != 1 - 1 / n:\n        return \"NO\"\n    \n    return \"YES\", len(sequence), sequence\n\n# Read input\nn = int(input())\n\n# Find and print the sequence\nresult = find_sequence(n)\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(result[1])\n    for a, b in result[2]:\n        print(a, b)"}
{"solution": "def min_unattractiveness(n, limits, heights):\n    a, b = limits\n    total_area = sum(heights)\n    \n    if a + b < total_area:\n        return -1\n    \n    dp = [[float('inf')] * (n + 1) for _ in range(2)]\n    dp[0][0] = 0\n    dp[1][0] = 0\n    \n    for i in range(n):\n        for j in range(i + 1):\n            dp[0][i + 1] = min(dp[0][i + 1], dp[0][j] + (heights[i] if j > 0 else 0))\n            dp[1][i + 1] = min(dp[1][i + 1], dp[1][j] + (heights[i] if j > 0 else 0))\n            \n            if j > 0:\n                dp[1][i + 1] = min(dp[1][i + 1], dp[0][j - 1] + heights[j - 1])\n                dp[0][i + 1] = min(dp[0][i + 1], dp[1][j - 1] + heights[j - 1])\n                \n        for j in range(i + 1):\n            if dp[0][j] != float('inf') and a < sum(heights[:i + 1]) - sum(heights[:j]):\n                dp[0][j] = float('inf')\n            if dp[1][j] != float('inf') and b < sum(heights[:i + 1]) - sum(heights[:j]):\n                dp[1][j] = float('inf')\n                \n    result = min(dp[0][-1], dp[1][-1])\n    return result if result != float('inf') else -1\n\n# Reading input\nn = int(input())\nlimits = list(map(int, input().split()))\nheights = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(min_unattractiveness(n, limits, heights))"}
{"solution": "from math import gcd\n\ndef find_triangle_points(n, m, k):\n    area = (n * m) // k\n    if area == 0 or (n * m) % (2 * k) != 0:\n        print(\"NO\")\n        return\n    \n    # Check if it's possible to form a triangle with the given area\n    if area <= n * m // 2:\n        print(\"YES\")\n        # Example points that satisfy the condition\n        print(0, 0)\n        print(n, 0)\n        height = min(m, 2 * area // n)\n        print(0, height)\n    else:\n        print(\"NO\")\n\n# Reading input\nn, m, k = map(int, input().split())\nfind_triangle_points(n, m, k)"}
{"solution": "def sasha_wins(n, k):\n    # Calculate the total number of moves possible in the game\n    total_moves = n // k\n    # Sasha wins if he can make more moves than Lena. Since they alternate,\n    # Sasha wins if the total number of moves is odd (he goes first).\n    return \"YES\" if total_moves % 2 == 1 else \"NO\"\n\n# Read input\nn, k = map(int, input().split())\n\n# Print the result\nprint(sasha_wins(n, k))"}
{"solution": "# Reading input\nn = int(input())\nrepetitions = list(map(int, input().split()))\n\n# Initializing counters for each muscle group\nchest_count = 0\nbiceps_count = 0\nback_count = 0\n\n# Iterating through the list of repetitions\nfor i, rep in enumerate(repetitions):\n    # Determining the muscle group based on the index\n    if (i % 3) == 0:\n        chest_count += rep\n    elif (i % 3) == 1:\n        biceps_count += rep\n    else:\n        back_count += rep\n\n# Determining which muscle group has the most repetitions\nif chest_count > biceps_count and chest_count > back_count:\n    print(\"chest\")\nelif biceps_count > chest_count and biceps_count > back_count:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "def min_redos_to_get_five(n, grades):\n    current_sum = sum(grades)\n    target_sum = n * 4.5\n    \n    if current_sum >= target_sum:\n        return 0\n    \n    grades.sort()\n    redos = 0\n    \n    for i in range(n):\n        if current_sum >= target_sum:\n            break\n        # Replace the lowest grade with 5\n        current_sum += (5 - grades[i])\n        redos += 1\n    \n    return redos\n\n# Read input\nn = int(input())\ngrades = list(map(int, input().split()))\n\n# Output the result\nprint(min_redos_to_get_five(n, grades))"}
{"solution": "def find_shortest_array(u, v):\n    if u == 0:\n        if v == 0:\n            print(0)\n        else:\n            print(-1)\n        return\n    \n    # If v < u, it's impossible to achieve the sum with positive integers\n    if v < u:\n        print(-1)\n        return\n    \n    n = 1\n    arr = [u]\n    remaining_sum = v - u\n    \n    # Add 1s to the array until the sum matches v\n    while remaining_sum > 0:\n        arr.append(1)\n        remaining_sum -= 1\n        n += 1\n    \n    print(n)\n    print(\" \".join(map(str, arr)))\n\n# Reading input\nu, v = map(int, input().split())\n\n# Solving the problem\nfind_shortest_array(u, v)"}
{"solution": "def min_ones(n):\n    ones = [1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 1111111111, 11111111111, 111111111111, 1111111111111, 11111111111111, 111111111111111]\n    dp = [0] + [float('inf')] * n\n    \n    for i in range(1, len(dp)):\n        for one in ones:\n            if i - one >= 0:\n                dp[i] = min(dp[i], dp[i - one] + 1)\n    \n    return dp[n]\n\nn = int(input())\nprint(min_ones(n))"}
{"solution": "def can_reach_treasure(start_x, start_y, treasure_x, treasure_y, potion_x, potion_y):\n    # Calculate the differences in x and y coordinates\n    diff_x = abs(treasure_x - start_x)\n    diff_y = abs(treasure_y - start_y)\n    \n    # Check if the differences are multiples of the potion's x and y values\n    if (diff_x % (2 * potion_x) == 0) and (diff_y % (2 * potion_y) == 0):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nstart_x, start_y, treasure_x, treasure_y = map(int, input().split())\npotion_x, potion_y = map(int, input().split())\n\n# Determine if Captain Bill the Hummingbird can reach the treasure\nprint(can_reach_treasure(start_x, start_y, treasure_x, treasure_y, potion_x, potion_y))"}
{"solution": "from itertools import permutations\n\ndef count_valid_bus_numbers(n):\n    digits = list(str(n))\n    all_permutations = set(permutations(digits))\n    valid_permutations = {int(''.join(perm)) for perm in all_permutations if perm[0] != '0'}\n    return len(valid_permutations)\n\nn = int(input().strip())\nresult = count_valid_bus_numbers(n)\nprint(result)"}
{"solution": "# Import necessary packages if any required here\n# In this case, no additional packages are needed.\n\ndef max_suit_cost(a, b, c, d, e, f):\n    # Calculate the maximum number of suits of the first type (tie and jacket)\n    max_type_1 = min(a, d) * e\n    \n    # Calculate the maximum number of suits of the second type (scarf, vest, and jacket)\n    max_type_2 = min(b, c, d) * f\n    \n    # Calculate the remaining jackets after making suits of the first type\n    remaining_jackets = d - min(a, d)\n    \n    # If there are remaining jackets, check if making more suits of the second type is beneficial\n    if remaining_jackets > 0:\n        # Calculate the additional suits of the second type that can be made with remaining jackets\n        additional_type_2 = min(b - min(b, c, d), c - min(b, c, d), remaining_jackets) * f\n        max_type_2 += additional_type_2\n    \n    # Return the maximum total cost\n    return max(max_type_1, max_type_2)\n\n# Read input values\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\n# Calculate and print the maximum total cost\nprint(max_suit_cost(a, b, c, d, e, f))"}
{"solution": "from math import gcd\n\ndef mod_pow(base, exponent, modulus):\n    result = 1\n    base = base % modulus\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % modulus\n        exponent = exponent >> 1\n        base = (base * base) % modulus\n    return result\n\ndef find_possible_ns(a, b, p, x):\n    count = 0\n    # Calculate the multiplicative inverse of a modulo p\n    inv_a = pow(a, p - 2, p)\n    \n    # Check each n from 1 to x\n    for n in range(1, min(x + 1, p)):\n        # Calculate the left-hand side of the congruence\n        lhs = (n * mod_pow(a, n, p)) % p\n        \n        # Check if the congruence holds\n        if lhs == (b % p):\n            count += 1\n    \n    # Special case handling for when x >= p\n    if x >= p:\n        # Determine the period length\n        period = p\n        for n in range(p, x + 1, p):\n            # Calculate the left-hand side for n = k * p + m where m is the previous valid n\n            lhs = (n * mod_pow(a, n, p)) % p\n            if lhs == (b % p):\n                count += (x // p) - (n // p) + 1\n                break\n    \n    return count\n\n# Read input\na, b, p, x = map(int, input().split())\n\n# Solve the problem\nresult = find_possible_ns(a, b, p, x)\n\n# Output the result\nprint(result)"}
{"solution": "def max_sum(k2, k3, k5, k6):\n    # Calculate the minimum number of '2's and '3's needed for 32\n    num_32 = min(k2, k3)\n    \n    # Calculate the remaining digits after forming 32\n    k2 -= num_32\n    k3 -= num_32\n    \n    # Calculate the number of '2's, '5's, and '6's needed for 256\n    num_256_2 = k2 // 8\n    num_256_5 = k5 // 1\n    num_256_6 = k6 // 4\n    \n    # Find the minimum of these to determine how many 256s can be formed\n    num_256 = min(num_256_2, num_256_5, num_256_6)\n    \n    # Calculate the total sum\n    total_sum = num_32 * 32 + num_256 * 256\n    \n    return total_sum\n\n# Read input\nk2, k3, k5, k6 = map(int, input().split())\n\n# Print the output\nprint(max_sum(k2, k3, k5, k6))"}
{"solution": "import math\n\ndef time_to_happiness(n, x, y, c):\n    # Calculate the maximum distance a cell can be from the center\n    max_distance = max(abs(x - (n + 1) // 2), abs(y - (n + 1) // 2))\n    \n    # Calculate the minimum number of cells that can be turned on if the initial cell is at the center\n    min_cells_center = (max(0, n - 2 * max_distance)) ** 2\n    \n    # If the initial cell is at the center and enough cells are already on, no time is needed\n    if min_cells_center >= c:\n        return 0\n    \n    # Calculate the number of additional cells needed\n    additional_cells_needed = max(0, c - (n - 2 * max_distance) ** 2)\n    \n    # Calculate the number of layers needed to turn on the required number of cells\n    layers_needed = math.ceil(math.sqrt(additional_cells_needed)) - 1\n    \n    # Total time is the maximum of the initial distance and the layers needed\n    total_time = max(max_distance, layers_needed)\n    \n    return total_time\n\n# Read input\nn, x, y, c = map(int, input().split())\n\n# Output the result\nprint(time_to_happiness(n, x, y, c))"}
{"solution": "import sys\n\ndef max_bitwise_xor(l, r):\n    if l == r:\n        return 0\n    bin_l = bin(l)[2:]  # Convert l to binary and remove the '0b' prefix\n    bin_r = bin(r)[2:]  # Convert r to binary and remove the '0b' prefix\n    \n    # Find the position of the first differing bit\n    i = 0\n    while i < len(bin_l) and i < len(bin_r) and bin_l[-(i + 1)] == bin_r[-(i + 1)]:\n        i += 1\n    \n    # Calculate the maximum XOR value\n    max_xor = ((1 << (len(bin_l) - i)) - 1) ^ l\n    \n    return max_xor\n\n# Read input from stdin\nl, r = map(int, sys.stdin.readline().strip().split())\n\n# Compute and print the result\nprint(max_bitwise_xor(l, r))"}
{"solution": "def minimum_height(n, k):\n    left, right = 1, k  # The height cannot be more than k because the area is k\n    \n    while left < right:\n        mid = (left + right) // 2\n        if n * mid >= k:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Example usage:\nn, k = map(int, input().split())\nprint(minimum_height(n, k))"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    # Calculate time using stairs\n    stairs_time = abs(x - y) * t1\n    \n    # Calculate time using elevator\n    # Time to reach Masha\n    elevator_to_masha_time = abs(z - x) * t2 + t3\n    # Time to reach Egor's floor\n    elevator_to_egor_time = abs(x - y) * t2 + 2 * t3\n    elevator_time = elevator_to_masha_time + elevator_to_egor_time\n    \n    # Compare times and return result\n    if stairs_time < elevator_time:\n        return \"NO\"\n    else:\n        return \"YES\"\n\n# Read input\nx, y, z, t1, t2, t3 = map(int, input().split())\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "def find_optimal_a(n, m):\n    # If m is exactly in the middle or the middle-biased value, choose the closest integer to the middle\n    if m <= (n + 1) // 2:\n        return m + 1\n    else:\n        return m - 1\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the optimal value of a\nprint(find_optimal_a(n, m))"}
{"solution": "n = int(input())\nschedule = list(map(int, input().split()))\n\npairs_at_university = 0\nin_university = False\n\nfor i in range(n):\n    if schedule[i] == 1:\n        if not in_university:\n            pairs_at_university += 1\n            in_university = True\n        pairs_at_university += 1\n    else:\n        if in_university and (i + 1 < n and schedule[i + 1] == 0):\n            in_university = False\n\nprint(pairs_at_university)"}
{"solution": "def min_days_to_give_candies(n, k, candies_per_day):\n    total_candies = 0\n    for day in range(n):\n        total_candies += candies_per_day[day]\n        if total_candies >= k:\n            return day + 1\n    return -1\n\n# Reading input\nn, k = map(int, input().split())\ncandies_per_day = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(min_days_to_give_candies(n, k, candies_per_day))"}
{"solution": "def minimum_additional_walks(n, k, a):\n    b = a[:]\n    additional_walks = 0\n    \n    for i in range(n - 1):\n        if b[i] + b[i + 1] < k:\n            needed_walks = k - (b[i] + b[i + 1])\n            b[i + 1] += needed_walks\n            additional_walks += needed_walks\n    \n    return additional_walks, b\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nadditional_walks, b = minimum_additional_walks(n, k, a)\n\n# Print the result\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "def compute_rhombus_cells(n):\n    # Base case for 1st order rhombus\n    if n == 1:\n        return 1\n    \n    # Calculate the number of cells for n-th order rhombus\n    return 4 * n * (n - 1) + 1\n\n# Read input\nn = int(input())\n\n# Compute and print the number of cells\nprint(compute_rhombus_cells(n))"}
{"solution": "# Import necessary package\nfrom string import ascii_uppercase\n\n# Read the number of characters in the string\nn = int(input())\n\n# Read the string\ns = input()\n\n# Convert the string to uppercase to simplify comparison\ns_upper = s.upper()\n\n# Initialize a set to keep track of unique letters found\nunique_letters = set(s_upper)\n\n# Define the set of all uppercase letters in the Latin alphabet\nall_letters = set(ascii_uppercase)\n\n# Check if all letters of the alphabet are present in the string\nis_pangram = unique_letters == all_letters\n\n# Output the result\nprint(\"YES\" if is_pangram else \"NO\")"}
{"solution": "from datetime import datetime, timedelta\n\n# Read the current time in 24-hour format\ncurrent_time_str = input()\n# Read the number of minutes to add\nminutes_to_add = int(input())\n\n# Convert the current time string to a datetime object\ncurrent_time = datetime.strptime(current_time_str, \"%H:%M\")\n\n# Add the specified number of minutes\nnew_time = current_time + timedelta(minutes=minutes_to_add)\n\n# Format the new time back to a string in 24-hour format with leading zeros\nnew_time_str = new_time.strftime(\"%H:%M\")\n\n# Print the new time\nprint(new_time_str)"}
{"solution": "def can_ignore_switch(n, m, switches):\n    # Convert the switch matrix into a list of sets for easier manipulation\n    switch_sets = [set([j for j in range(m) if switches[i][j] == '1']) for i in range(n)]\n    \n    # Check each switch to see if ignoring it still turns on all lamps\n    for i in range(n):\n        combined_set = set().union(*[switch_sets[j] for j in range(n) if j != i])\n        if len(combined_set) == m:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nswitches = [input() for _ in range(n)]\n\n# Output result\nprint(can_ignore_switch(n, m, switches))"}
{"solution": "def min_rotation_time(n, dominoes):\n    upper_sum = 0\n    lower_sum = 0\n    can_rotate_upper = 0\n    can_rotate_lower = 0\n    \n    for x, y in dominoes:\n        upper_sum += x\n        lower_sum += y\n        if x % 2 != 0 and y % 2 == 0:\n            can_rotate_upper += 1\n        if x % 2 == 0 and y % 2 != 0:\n            can_rotate_lower += 1\n    \n    if (upper_sum % 2 == 0 and lower_sum % 2 == 0):\n        return 0\n    elif (upper_sum % 2 != 0 and lower_sum % 2 != 0) and (can_rotate_upper + can_rotate_lower > 0):\n        return 1\n    elif (upper_sum % 2 != 0 and lower_sum % 2 == 0) and can_rotate_upper > 0:\n        return 1\n    elif (upper_sum % 2 == 0 and lower_sum % 2 != 0) and can_rotate_lower > 0:\n        return 1\n    else:\n        if can_rotate_upper >= 1 and can_rotate_lower >= 1:\n            return 2\n        else:\n            return -1\n\n# Read input\nn = int(input())\ndominoes = [list(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(min_rotation_time(n, dominoes))"}
{"solution": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef remaining_area(a, b):\n    return (a * a) - (b * b)\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        a, b = map(int, input().split())\n        area = remaining_area(a, b)\n        if is_prime(area):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nsolve()"}
{"solution": "def can_remove_one_point(n, points):\n    positive_count = 0\n    negative_count = 0\n    \n    for x, y in points:\n        if x > 0:\n            positive_count += 1\n        else:\n            negative_count += 1\n    \n    if positive_count <= 1 or negative_count <= 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Reading input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_remove_one_point(n, points))"}
{"solution": "def gcd_factorials(A, B):\n    min_val = min(A, B)\n    gcd = 1\n    for i in range(1, min_val + 1):\n        gcd *= i\n    return gcd\n\n# Reading input\nA, B = map(int, input().split())\n\n# Calculating and printing the output\nprint(gcd_factorials(A, B))"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_composite_pair(n):\n    a = n + 4  # Start with a number greater than n and ensure it's composite\n    while is_prime(a):\n        a += 1\n    b = a - n\n    while is_prime(b):\n        a += 1\n        b = a - n\n    return a, b\n\nn = int(input())\na, b = find_composite_pair(n)\nprint(a, b)"}
{"solution": "from collections import defaultdict, deque\n\ndef max_score(N, M, P, edges):\n    # Build the graph\n    graph = defaultdict(list)\n    for A, B, C in edges:\n        graph[A].append((B, C))\n\n    # Initialize DP table\n    dp = [-float('inf')] * (N + 1)\n    dp[1] = 0\n    time = [0] * (N + 1)\n\n    # BFS to find the shortest path lengths\n    queue = deque([1])\n    while queue:\n        node = queue.popleft()\n        for next_node, _ in graph[node]:\n            if time[next_node] == 0:\n                time[next_node] = time[node] + 1\n                queue.append(next_node)\n\n    # Bellman-Ford like relaxation to detect negative cycles\n    for _ in range(N):\n        updated = False\n        for A, B, C in edges:\n            if time[B] > 0 and dp[B] < dp[A] + C * time[B]:\n                dp[B] = dp[A] + C * time[B]\n                updated = True\n        if not updated:\n            break\n\n    # Check for negative cycle reachable from N\n    for A, B, C in edges:\n        if time[B] > 0 and dp[B] < dp[A] + C * time[B]:\n            if time[N] > 0:\n                return -1\n\n    # Calculate the maximum score\n    max_score = -float('inf')\n    for t in range(1, max(time) + 1):\n        coins_needed = t * P\n        if dp[N] >= coins_needed:\n            max_score = max(max_score, dp[N] - coins_needed)\n\n    return max_score\n\n# Read input\nN, M, P = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(M)]\n\n# Compute and print the result\nprint(max_score(N, M, P, edges))"}
{"solution": "from collections import defaultdict\nimport heapq\n\ndef min_cost_palindrome(n, strings):\n    # Initialize dictionaries to store costs and occurrences\n    costs = {}\n    occurrences = defaultdict(int)\n    \n    # Process input strings and costs\n    for _ in range(n):\n        s, c = input().split()\n        c = int(c)\n        costs[s] = c\n        rev_s = s[::-1]\n        \n        # Check if the string and its reverse are distinct\n        if s != rev_s:\n            if rev_s in costs:\n                occurrences[s] += 1\n                occurrences[rev_s] += 1\n        else:\n            occurrences[s] += 1\n    \n    # Priority queue for minimum costs\n    pq = []\n    for s, count in occurrences.items():\n        if s not in costs or (s == s[::-1] and count % 2 == 0):\n            continue\n        cost = costs[s] * (count // 2)\n        heapq.heappush(pq, cost)\n    \n    # Calculate the middle string cost if any\n    middle_cost = float('inf')\n    for s, c in costs.items():\n        if s == s[::-1] and occurrences[s] % 2 == 1:\n            middle_cost = min(middle_cost, c)\n    \n    # Calculate the total cost\n    total_cost = sum(heapq.heappop(pq) for _ in range(len(pq)))\n    if middle_cost == float('inf'):\n        return total_cost if pq else -1\n    else:\n        return total_cost + middle_cost\n\n# Read input\nn = int(input())\nprint(min_cost_palindrome(n, []))"}
{"solution": "def largest_xor_sum(n, k):\n    # Find the number of bits in n\n    num_bits = n.bit_length()\n    # The largest possible xor-sum\n    max_xor_sum = (1 << num_bits) - 1\n    return max_xor_sum\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the largest possible xor-sum\nprint(largest_xor_sum(n, k))"}
{"solution": "from typing import List, Tuple\n\ndef min_shorter_side_triangle(points: List[Tuple[int, int]]) -> int:\n    max_x = max_y = 0\n    for x, y in points:\n        max_x = max(max_x, x)\n        max_y = max(max_y, y)\n    return min(max_x, max_y) * 2\n\n# Read input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(min_shorter_side_triangle(points))"}
{"solution": "from collections import Counter\n\ndef max_nineteens(s):\n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # Define the required frequency of each character in the word \"nineteen\"\n    required_counts = {'n': 3, 'i': 1, 'e': 3, 't': 1}\n    \n    # Calculate the maximum number of \"nineteen\" words that can be formed\n    max_nineteens = float('inf')\n    for char, required in required_counts.items():\n        if char in char_count:\n            max_nineteens = min(max_nineteens, char_count[char] // required)\n        else:\n            return 0  # If any required character is missing, we can't form \"nineteen\"\n    \n    return max_nineteens\n\n# Read input\ns = input().strip()\n\n# Output the result\nprint(max_nineteens(s))"}
{"solution": "def find_highest_unreachable_branch(p, y):\n    if y == p:\n        return -1\n    if y % p == 0:\n        return p + 1\n    if y < 2 * p:\n        return y\n    \n    max_reachable = p\n    for i in range(2, int(y ** 0.5) + 1):\n        if p % i == 0:\n            current = i\n            while current <= y:\n                max_reachable = max(max_reachable, current)\n                current *= i\n            while p % (i + 1) == 0:\n                i += 1\n                current = i\n                while current <= y:\n                    max_reachable = max(max_reachable, current)\n                    current *= i\n    \n    if max_reachable >= y:\n        return -1\n    else:\n        return max_reachable + 1\n\n# Reading input\np, y = map(int, input().split())\n\n# Calculating and printing the result\nprint(find_highest_unreachable_branch(p, y))"}
{"solution": "def min_distance_to_affordable_house(n, m, k, prices):\n    # Filter out the houses that Zane can afford\n    affordable_houses = [i for i, price in enumerate(prices) if 0 < price <= k]\n    \n    # Calculate the minimum distance\n    min_dist = float('inf')\n    for house in affordable_houses:\n        dist = abs(house - (m - 1)) * 10  # Convert house index difference to meters\n        min_dist = min(min_dist, dist)\n    \n    return min_dist\n\n# Read input\nn, m, k = map(int, input().split())\nprices = list(map(int, input().split()))\n\n# Compute and print the result\nprint(min_distance_to_affordable_house(n, m, k, prices))"}
{"solution": "def can_transform(A, B):\n    def transpose_submatrix(matrix, x, y, k):\n        temp = [matrix[i][y:y+k] for i in range(x, x+k)]\n        for i in range(x, x+k):\n            for j in range(y, y+k):\n                matrix[i][j] = temp[j-y][i-x]\n\n    n, m = len(A), len(A[0])\n    if sorted([item for sublist in A for item in sublist]) != sorted([item for sublist in B for item in sublist]):\n        return \"NO\"\n\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] != B[i][j]:\n                k = 1\n                while i + k <= n and j + k <= m:\n                    if all(A[i+dx][j+dy] == B[i+dy][j+dx] for dx in range(k) for dy in range(k)):\n                        transpose_submatrix(A, i, j, k)\n                        break\n                    k += 1\n                else:\n                    return \"NO\"\n    return \"YES\"\n\n# Reading input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nB = [list(map(int, input().split())) for _ in range(n)]\n\n# Printing output\nprint(can_transform(A, B))"}
{"solution": "def longest_uncommon_subsequence(a, b):\n    if a == b:\n        print(-1)\n    else:\n        print(max(len(a), len(b)))\n\n# Read input strings\na = input().strip()\nb = input().strip()\n\n# Calculate and print the result\nlongest_uncommon_subsequence(a, b)"}
{"solution": "def find_intersection(a, b, c, d):\n    # Calculate the least common multiple (LCM) of a and c\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    lcm = a * c // gcd(a, c)\n\n    # Check if there is an intersection\n    if (d - b) % lcm == 0:\n        time = b + ((d - b) // lcm) * lcm\n        return time\n    else:\n        return -1\n\n# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Output the result\nprint(find_intersection(a, b, c, d))"}
{"solution": "def find_solution(n):\n    if n % 3 == 0:\n        # If n is a multiple of 3, adjust a, b, and c accordingly\n        a = n // 3 - 1\n        b = n // 3 - 1\n        c = n // 3 + 2\n    elif n % 3 == 1:\n        # If n gives a remainder of 1 when divided by 3\n        a = n // 3\n        b = n // 3\n        c = n // 3 + 1\n    else:\n        # If n gives a remainder of 2 when divided by 3\n        a = n // 3\n        b = n // 3 + 1\n        c = n // 3 + 1\n    \n    return a, b, c\n\n# Read input\nn = int(input())\n\n# Find and print the solution\na, b, c = find_solution(n)\nprint(a, b, c)"}
{"solution": "def count_valid_paintings(n, a, b, c, d):\n    valid_paintings = 0\n    target_sum = a + b + c + d - b\n    \n    for x1 in range(1, n + 1):\n        for x2 in range(1, n + 1):\n            for x3 in range(1, n + 1):\n                for x4 in range(1, n + 1):\n                    for x5 in range(1, n + 1):\n                        y1 = target_sum - x2 - x3 - x1\n                        y2 = target_sum - a - x2 - x5\n                        y3 = target_sum - c - x3 - x5\n                        y4 = target_sum - x4 - x5 - d\n                        \n                        if (1 <= y1 <= n and 1 <= y2 <= n and 1 <= y3 <= n and 1 <= y4 <= n and\n                            (y1 + b + x3 + y2 == target_sum) and\n                            (b + y2 + x5 + y4 == target_sum)):\n                            valid_paintings += 1\n    return valid_paintings\n\n# Read input\nn, a, b, c, d = map(int, input().split())\n\n# Calculate and print the result\nprint(count_valid_paintings(n, a, b, c, d))"}
{"solution": "def final_snowball_weight(w, h, u1, d1, u2, d2):\n    # Ensure the stones are processed in order of their heights\n    if d1 > d2:\n        d1, d2 = d2, d1\n        u1, u2 = u2, u1\n\n    while h > 0:\n        w += h  # Increase weight by current height\n        if h == d1:\n            w -= u1  # Lose weight hitting the first stone\n            w = max(0, w)  # Ensure weight doesn't go below zero\n        elif h == d2:\n            w -= u2  # Lose weight hitting the second stone\n            w = max(0, w)  # Ensure weight doesn't go below zero\n        h -= 1  # Move down one meter\n\n    return w\n\n# Read input\nw, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\n# Compute and print the final weight\nprint(final_snowball_weight(w, h, u1, d1, u2, d2))"}
{"solution": "def find_passing_rate(m, scores, min_max):\n    # Calculate cumulative scores\n    cumulative_scores = [0]\n    for score in scores:\n        cumulative_scores.append(cumulative_scores[-1] + score)\n    \n    x, y = min_max\n    \n    # Check for valid passing rate\n    for k in range(1, m + 1):\n        beginners = cumulative_scores[k]\n        intermediates = cumulative_scores[m] - beginners\n        \n        if x <= beginners <= y and x <= intermediates <= y:\n            return k\n    \n    return 0\n\n# Read input\nm = int(input())\nscores = list(map(int, input().split()))\nx, y = map(int, input().split())\n\n# Output result\nprint(find_passing_rate(m, scores, (x, y)))"}
{"solution": "def min_coins_to_one(n, k, A, B):\n    operations = []\n    while n > 1:\n        if n % k == 0 and (len(operations) == 0 or operations[-1] != B):\n            operations.append(B)\n            n //= k\n        else:\n            operations.append(A)\n            n -= 1\n    return sum(operations)\n\n# Reading input\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\n# Calculating and printing the output\nprint(min_coins_to_one(n, k, A, B))"}
{"solution": "from math import sqrt\n\ndef min_value_operations(n):\n    # Initialize the minimum value and operations count\n    min_value = n\n    operations = 0\n    \n    # Factorize n and calculate the minimum value and operations\n    while n > 1:\n        is_prime = True\n        for x in range(2, int(sqrt(n)) + 1):\n            if n % (x * x) == 0:\n                is_prime = False\n                break\n        if is_prime:\n            min_value = int(sqrt(n))\n            operations += 1\n            break\n        else:\n            temp_min = float('inf')\n            temp_ops = float('inf')\n            for x in range(2, int(sqrt(n)) + 1):\n                if n % (x * x) == 0:\n                    new_n = n // (x * x)\n                    new_ops = 1 + (operations + 1 if sqrt(new_n) == int(sqrt(new_n)) else operations)\n                    if new_n < temp_min or (new_n == temp_min and new_ops < temp_ops):\n                        temp_min = new_n\n                        temp_ops = new_ops\n            n = temp_min\n            operations = temp_ops\n    \n    return min_value, operations\n\n# Read input\nn = int(input())\n\n# Calculate and print the result\nmin_val, ops = min_value_operations(n)\nprint(min_val, ops)"}
{"solution": "import sys\n\ndef max_score(N, K, R, S, P, T):\n    dp = [[0, 0, 0] for _ in range(N + 1)]\n    \n    for i in range(K, N):\n        dp[i + 1][0] = max(dp[i - K + 1][1], dp[i - K + 1][2]) + (P if T[i] == 'r' else 0)\n        dp[i + 1][1] = max(dp[i - K + 1][0], dp[i - K + 1][2]) + (R if T[i] == 's' else 0)\n        dp[i + 1][2] = max(dp[i - K + 1][0], dp[i - K + 1][1]) + (S if T[i] == 'p' else 0)\n    \n    # Handle the initial K rounds separately\n    for i in range(min(K, N)):\n        dp[i + 1][0] = (P if T[i] == 'r' else 0)\n        dp[i + 1][1] = (R if T[i] == 's' else 0)\n        dp[i + 1][2] = (S if T[i] == 'p' else 0)\n    \n    return max(dp[N])\n\n# Read input\nN, K = map(int, input().split())\nR, S, P = map(int, input().split())\nT = input()\n\nprint(max_score(N, K, R, S, P, T))"}
{"solution": "def longest_good_string(a, b, c):\n    # Calculate the maximum possible length of the good string\n    max_length = min(a, b) * 2 + 2 * c + abs(a - b)\n    return max_length\n\n# Read input\na, b, c = map(int, input().split())\n\n# Calculate and print the output\nprint(longest_good_string(a, b, c))"}
{"solution": "def find_marks(n, k, p, x, y, marks):\n    total_marks_so_far = sum(marks)\n    remaining_marks_needed = x - total_marks_so_far\n    if remaining_marks_needed < 0:\n        return -1\n\n    # Calculate the median position\n    median_pos = (n + 1) // 2\n\n    # Sort the existing marks to find the current median\n    marks.sort()\n\n    # Determine the required marks for the remaining tests\n    required_marks = []\n    for i in range(n - k):\n        if len(required_marks) < median_pos - k:\n            # Ensure the median is at least y\n            required_marks.append(max(y, 1))\n        else:\n            # Ensure the total does not exceed x\n            required_marks.append(min(p, remaining_marks_needed))\n            remaining_marks_needed -= min(p, remaining_marks_needed)\n            if remaining_marks_needed <= 0:\n                break\n\n    # Check if the requirements can be met\n    if remaining_marks_needed > 0:\n        return -1\n\n    # Update the marks list and sort it to check the median\n    updated_marks = marks + required_marks\n    updated_marks.sort()\n    if updated_marks[median_pos - 1] < y or sum(updated_marks) > x:\n        return -1\n\n    return required_marks\n\n# Read input\nn, k, p, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Solve and print the result\nresult = find_marks(n, k, p, x, y, marks)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "def is_berlanese(word):\n    vowels = \"aeiou\"\n    prev_char = ''\n    \n    for char in word:\n        if char not in vowels:  # Current character is a consonant\n            if char != 'n' and prev_char in vowels:\n                return \"NO\"\n            elif char != 'n' and prev_char not in vowels and prev_char != '':\n                return \"NO\"\n        prev_char = char\n    \n    # Special case for 'n', it can be followed by any letter or be the last letter\n    if word[-1] not in vowels and word[-1] != 'n':\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nword = input()\n\n# Output result\nprint(is_berlanese(word))"}
{"solution": "from collections import defaultdict\n\ndef max_dominoes_on_graph(n, edges):\n    # Create an adjacency list to represent the graph\n    adj_list = defaultdict(set)\n    for u, v in edges:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n    \n    # Count the degrees of each vertex\n    degrees = {vertex: len(neighbors) for vertex, neighbors in adj_list.items()}\n    \n    # Find the vertex with the minimum degree\n    min_degree_vertex = min(degrees, key=degrees.get)\n    \n    # Calculate the maximum number of dominoes\n    max_dominoes = sum(1 for vertex in degrees if degrees[vertex] > degrees[min_degree_vertex])\n    \n    return min(max_dominoes, len(edges))\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Compute and print the result\nprint(max_dominoes_on_graph(n, edges))"}
{"solution": "from typing import List\n\ndef max_points(n: int, m: int, prices: List[int], auctions: List[int]) -> int:\n    from sortedcontainers import SortedList\n    \n    # Convert auction indices to 0-based indexing and sort\n    auctions = sorted(a - 1 for a in auctions)\n    \n    # Initialize variables\n    points = 0\n    current_score = 0\n    next_non_auction = 0\n    auction_indices = SortedList()\n    \n    # Populate the list of auction indices\n    for i in range(m):\n        auction_indices.add(auctions[i])\n    \n    for i in range(n):\n        # If the current question is an auction question\n        if i in auction_indices:\n            # Find the position of the current auction question\n            pos = auction_indices.index(i)\n            \n            # Calculate the new price based on the current score\n            new_price = min(current_score, prices[i])\n            current_score += new_price\n            \n            # Remove the current auction question index\n            auction_indices.pop(pos)\n            \n            # Update the next non-auction question index if needed\n            if next_non_auction < i:\n                next_non_auction = i + 1\n        else:\n            # Handle the case when the next non-auction question is beyond the current index\n            if next_non_auction >= n:\n                break\n            \n            # If the next non-auction question is not an auction question\n            while next_non_auction < n and next_non_auction not in auction_indices:\n                current_score += prices[next_non_auction]\n                next_non_auction += 1\n            \n            # Update the next non-auction question index\n            if next_non_auction < n:\n                next_non_auction += 1\n        \n        # Add the price of the current question to the total points\n        points += prices[i]\n    \n    return points\n\n# Read input\nn, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauctions = list(map(int, input().split()))\n\n# Calculate and print the maximum points\nprint(max_points(n, m, prices, auctions))"}
{"solution": "# Import necessary package for reading input\nfrom sys import stdin\n\n# Read input\nm = list(map(int, stdin.readline().strip().split()))\nw = list(map(int, stdin.readline().strip().split()))\nh_s, h_u = map(int, stdin.readline().strip().split())\n\n# Define the maximum point values for each problem\npoints = [500, 1000, 1500, 2000, 2500]\n\n# Initialize total score\ntotal_score = 0\n\n# Calculate score for each problem\nfor i in range(5):\n    score = max(0.3 * points[i], (1 - m[i] / 250) * points[i] - 50 * w[i])\n    total_score += int(score)\n\n# Add points for successful and unsuccessful hacks\ntotal_score += 100 * h_s - 50 * h_u\n\n# Print the final score\nprint(total_score)"}
{"solution": "MOD = 998244353\n\ndef mod_pow(base, exponent, modulus):\n    result = 1\n    base %= modulus\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % modulus\n        exponent = exponent >> 1\n        base = (base * base) % modulus\n    return result\n\ndef solve(n, m, L, R):\n    if (n * m) % 2 == 1:\n        return 0\n    total_cells = n * m\n    even_cells = total_cells // 2\n    odd_cells = total_cells - even_cells\n    if L % 2 == 0:\n        valid_range = min(R, L + 1)\n    else:\n        valid_range = min(R, L)\n    even_count = (valid_range - L) // 2 + 1\n    odd_count = (valid_range - L) // 2 + 1\n    total_even = mod_pow(even_count, even_cells, MOD)\n    total_odd = mod_pow(odd_count, odd_cells, MOD)\n    return (total_even * total_odd) % MOD\n\n# Reading input\nn, m, L, R = map(int, input().split())\n\n# Solving the problem\nresult = solve(n, m, L, R)\n\n# Printing the output\nprint(result)"}
{"solution": "def is_possible_to_make_increasing(n, m, matrix_a, matrix_b):\n    # Ensure that matrix_a[i][j] is the smaller or equal element\n    for i in range(n):\n        for j in range(m):\n            if matrix_a[i][j] > matrix_b[i][j]:\n                matrix_a[i][j], matrix_b[i][j] = matrix_b[i][j], matrix_a[i][j]\n    \n    # Check rows for strictly increasing property\n    for i in range(n):\n        for j in range(1, m):\n            if matrix_a[i][j] <= matrix_a[i][j-1] or matrix_b[i][j] <= matrix_b[i][j-1]:\n                return \"Impossible\"\n    \n    # Check columns for strictly increasing property\n    for j in range(m):\n        for i in range(1, n):\n            if matrix_a[i][j] <= matrix_a[i-1][j] or matrix_b[i][j] <= matrix_b[i-1][j]:\n                return \"Impossible\"\n    \n    return \"Possible\"\n\n# Input handling\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\nmatrix_b = [list(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(is_possible_to_make_increasing(n, m, matrix_a, matrix_b))"}
{"solution": "import heapq\n\ndef max_string_length(n, limits):\n    # Initialize a min heap for the limits\n    min_heap = []\n    for i in range(1, n + 1):\n        heapq.heappush(min_heap, (limits[i - 1], i))\n    \n    # Initialize a set to keep track of used occurrence values\n    used_values = set()\n    \n    result = 0\n    \n    while min_heap:\n        limit, letter = heapq.heappop(min_heap)\n        max_possible = min(limit, n)\n        \n        for i in range(max_possible, 0, -1):\n            if i not in used_values:\n                used_values.add(i)\n                result += i\n                n -= 1\n                break\n    \n    return result\n\n# Read input\nn = int(input())\nlimits = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_string_length(n, limits))"}
{"solution": "def min_problems_to_solve(n, k, difficulties):\n    # Initialize the count of additional problems needed\n    additional_problems = 0\n    # Create a set to keep track of difficulties that have been solved\n    solved_difficulties = set()\n    \n    # Add initial difficulty k to the set\n    solved_difficulties.add(k)\n    \n    # Function to ensure the difficulty or its half is in the set\n    def ensure_difficulty_or_half(difficulty):\n        while difficulty > 0 and difficulty not in solved_difficulties:\n            difficulty //= 2\n        return difficulty\n    \n    # Process each difficulty in the list\n    for difficulty in difficulties:\n        # Ensure the difficulty or its half is in the set\n        min_required = ensure_difficulty_or_half(difficulty)\n        if min_required == 0:\n            # If no suitable difficulty is found, add the necessary difficulty to the set\n            min_required = (difficulty + 1) // 2\n            additional_problems += 1\n            solved_difficulties.add(min_required)\n        # Add the current difficulty to the set\n        solved_difficulties.add(difficulty)\n    \n    return additional_problems\n\n# Read input\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_problems_to_solve(n, k, difficulties))"}
{"solution": "def distribute_diplomas(n, min_max_1, min_max_2, min_max_3):\n    min_1, max_1 = min_max_1\n    min_2, max_2 = min_max_2\n    min_3, max_3 = min_max_3\n    \n    # Initialize diplomas count\n    diplomas_1 = max(min_1, n - max_2 - max_3)\n    diplomas_2 = max(min_2, n - diplomas_1 - max_3)\n    diplomas_3 = n - diplomas_1 - diplomas_2\n    \n    # Adjust diplomas count within constraints\n    if diplomas_1 > max_1:\n        excess = diplomas_1 - max_1\n        diplomas_1 = max_1\n        diplomas_2 += min(excess, max_2 - diplomas_2)\n        excess -= min(excess, max_2 - diplomas_2)\n        diplomas_3 += excess\n    \n    if diplomas_2 > max_2:\n        excess = diplomas_2 - max_2\n        diplomas_2 = max_2\n        diplomas_3 += excess\n    \n    if diplomas_3 < min_3:\n        deficit = min_3 - diplomas_3\n        diplomas_3 = min_3\n        diplomas_2 -= min(deficit, diplomas_2)\n        deficit -= min(deficit, diplomas_2)\n        diplomas_1 -= deficit\n    \n    if diplomas_2 < min_2:\n        deficit = min_2 - diplomas_2\n        diplomas_2 = min_2\n        diplomas_1 -= deficit\n    \n    return diplomas_1, diplomas_2, diplomas_3\n\n# Read input\nn = int(input())\nmin_max_1 = list(map(int, input().split()))\nmin_max_2 = list(map(int, input().split()))\nmin_max_3 = list(map(int, input().split()))\n\n# Output the result\nprint(*distribute_diplomas(n, min_max_1, min_max_2, min_max_3))"}
{"solution": "def moon_cycle_prediction(n, observations):\n    # Moon cycle data\n    moon_cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n                  14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    \n    # Find the starting index in the cycle\n    start_index = moon_cycle.index(observations[0])\n    \n    # Check if the sequence matches the moon cycle\n    for i in range(n):\n        if moon_cycle[start_index + i] != observations[i]:\n            return -1\n    \n    # Predict the next day\n    if start_index + n < len(moon_cycle) - 1:\n        if moon_cycle[start_index + n] < moon_cycle[start_index + n - 1]:\n            return \"DOWN\"\n        elif moon_cycle[start_index + n] > moon_cycle[start_index + n - 1]:\n            return \"UP\"\n    else:\n        # Handle wrapping around the cycle\n        if moon_cycle[(start_index + n) % len(moon_cycle)] < moon_cycle[(start_index + n - 1) % len(moon_cycle)]:\n            return \"DOWN\"\n        elif moon_cycle[(start_index + n) % len(moon_cycle)] > moon_cycle[(start_index + n - 1) % len(moon_cycle)]:\n            return \"UP\"\n    \n    return -1\n\n# Read input\nn = int(input())\nobservations = list(map(int, input().split()))\n\n# Output result\nprint(moon_cycle_prediction(n, observations))"}
{"solution": "def can_transform(s, t):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    # Check if lengths are the same\n    if len(s) != len(t):\n        return \"No\"\n    \n    # Check each character\n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels) != (char_t in vowels):\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(can_transform(s, t))"}
{"solution": "def determine_winner(board):\n    min_white_distance = 8\n    max_black_distance = 0\n    \n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'W':\n                distance_to_top = i\n                min_white_distance = min(min_white_distance, distance_to_top)\n            elif board[i][j] == 'B':\n                distance_to_bottom = 7 - i\n                max_black_distance = max(max_black_distance, distance_to_bottom)\n    \n    if min_white_distance < max_black_distance:\n        return 'A'\n    else:\n        return 'B'\n\n# Read the board from input\nboard = [input() for _ in range(8)]\n\n# Determine and print the winner\nprint(determine_winner(board))"}
{"solution": "def max_equal_length(n, A, m, B):\n    if sum(A) != sum(B):\n        return -1\n    \n    i, j = 0, 0\n    sumA, sumB = 0, 0\n    count = 0\n    \n    while i < n and j < m:\n        sumA += A[i]\n        sumB += B[j]\n        \n        if sumA == sumB:\n            count += 1\n            sumA = 0\n            sumB = 0\n            i += 1\n            j += 1\n        elif sumA < sumB:\n            i += 1\n            sumA -= A[i-1]\n        else:\n            j += 1\n            sumB -= B[j-1]\n    \n    if i < n or j < m:\n        return -1\n    \n    return count\n\n# Example usage:\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\nprint(max_equal_length(n, A, m, B))"}
{"solution": "def is_alex_friend_name_included(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    friend_count = sum(problem_name.count(friend) for friend in friends)\n    \n    if friend_count == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Reading input\nproblem_name = input()\n\n# Processing and printing output\nprint(is_alex_friend_name_included(problem_name))"}
{"solution": "def sieve(n):\n    is_prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (is_prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n    is_prime[0], is_prime[1] = False, False  # 0 and 1 are not primes\n    return is_prime\n\ndef count_primes_in_range(is_prime, a, b):\n    prime_count = [0] * (b + 1)\n    for i in range(a, b + 1):\n        prime_count[i] = prime_count[i - 1] + (1 if is_prime[i] else 0)\n    return prime_count\n\ndef min_length_with_k_primes(a, b, k):\n    is_prime = sieve(b)\n    prime_count = count_primes_in_range(is_prime, a, b)\n    \n    def has_k_primes_in_length(l):\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] >= k:\n                return True\n        return False\n    \n    left, right = 1, b - a + 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if has_k_primes_in_length(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\n# Input\na, b, k = map(int, input().split())\n\n# Output\nprint(min_length_with_k_primes(a, b, k))"}
{"solution": "from math import gcd\n\ndef min_distance(a, h, w):\n    def feasible(r, c):\n        if r * a + r * x > h or c * a + c * x > w:\n            return False\n        if (h - r * a) % r != 0 or (w - c * a) % c != 0:\n            return False\n        return True\n\n    def find_min_x(r, c):\n        x = max((h - r * a) / r, 0)\n        if (w - c * a) % c == 0:\n            y = (w - c * a) / c\n            x = min(x, y)\n        return x\n\n    min_x = float('inf')\n    for r in range(1, h // a + 1):\n        for c in range(1, w // a + 1):\n            g = gcd(r, c)\n            r, c = r // g, c // g\n            if feasible(r, c):\n                min_x = min(min_x, find_min_x(r, c))\n    \n    return min_x if min_x != float('inf') else -1\n\n# Reading input\na, h, w = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_distance(a, h, w))"}
{"solution": "n = int(input())\nchapters = []\nfor _ in range(n):\n    li, ri = map(int, input().split())\n    chapters.append((li, ri))\nk = int(input())\n\nunread_chapters = 0\nfor li, ri in chapters:\n    if k <= li:\n        unread_chapters += 1\n\n# Check if the marked page is within a chapter that hasn't been fully read\nfor li, ri in chapters:\n    if li < k <= ri:\n        break\n    else:\n        unread_chapters += 1\n\nprint(unread_chapters)"}
{"solution": "def can_form_codeforces(word):\n    target = \"CODEFORCES\"\n    n = len(word)\n    m = len(target)\n    \n    if n < m:\n        return \"NO\"\n    \n    for i in range(m + 1):\n        if word[:i] == target[:i] and word[n - (m - i):] == target[i:]:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Reading input\nword = input()\nprint(can_form_codeforces(word))"}
{"solution": "def min_weight_triangulation(n):\n    # Initialize a DP table\n    dp = [[0] * n for _ in range(n)]\n    \n    # Fill the table\n    for gap in range(2, n):\n        for i in range(n - gap):\n            j = i + gap\n            dp[i][j] = float('inf')\n            for k in range(i + 1, j):\n                weight = (i + 1) * (k + 1) * (j + 1) + dp[i][k] + dp[k][j]\n                dp[i][j] = min(dp[i][j], weight)\n    \n    return dp[0][n - 1]\n\n# Read input\nn = int(input())\n\n# Calculate and print the result\nprint(min_weight_triangulation(n))"}
{"solution": "def count_digits(n):\n    if n < 10:\n        return n\n    digits = 0\n    current_length = 1\n    while n >= 10 ** current_length:\n        digits += current_length * (10 ** (current_length - 1))\n        n -= 10 ** current_length\n        current_length += 1\n    digits += current_length * n\n    return digits\n\nn = int(input())\nprint(count_digits(n))"}
{"solution": "from collections import defaultdict\n\ndef find_bobs_winning_color():\n    n, A = map(int, input().split())\n    colors = list(map(int, input().split()))\n    \n    # Track the count of Alice's color and all other colors\n    alice_count = 0\n    other_counts = defaultdict(int)\n    max_other_count = 0\n    \n    # Track the maximum count of any other color seen so far\n    for color in colors:\n        if color == A:\n            alice_count += 1\n        else:\n            other_counts[color] += 1\n            max_other_count = max(max_other_count, other_counts[color])\n        \n        # If Alice's count is ever greater than or equal to the max other count, reset max_other_count\n        if alice_count >= max_other_count:\n            max_other_count = 0\n    \n    # Find the winning color for Bob\n    for color, count in other_counts.items():\n        if count == max_other_count:\n            return color\n    \n    return -1\n\n# Call the function and print the result\nprint(find_bobs_winning_color())"}
{"solution": "def check_crossword(n, x, encoding):\n    # Initial gap before the first segment\n    initial_gap = 1\n    total_length = initial_gap\n    \n    for length in encoding:\n        total_length += length + 1  # Add segment length and gap\n    \n    # Remove the last added gap\n    total_length -= 1\n    \n    # Check if the total length matches the required length\n    if total_length == x:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, x = map(int, input().split())\nencoding = list(map(int, input().split()))\n\n# Print the result\nprint(check_crossword(n, x, encoding))"}
{"solution": "def min_coins(n, S):\n    dp = [0] + [float('inf')] * S\n    for s in range(1, S + 1):\n        for coin in range(1, min(n + 1, s) + 1):\n            dp[s] = min(dp[s], dp[s - coin] + 1)\n    return dp[S]\n\n# Reading input\nn, S = map(int, input().split())\n\n# Calculating and printing the output\nprint(min_coins(n, S))"}
{"solution": "from collections import Counter\n\ndef smallest_palindrome(s):\n    char_count = Counter(s)\n    left_part = []\n    middle_char = ''\n    \n    # Count characters and prepare the left part\n    for char in sorted(char_count.keys()):\n        count = char_count[char]\n        half_count = count // 2\n        for _ in range(half_count):\n            left_part.append(char)\n        if count % 2 != 0 and middle_char == '':\n            middle_char = char\n    \n    # Construct the left part of the palindrome\n    left_part = ''.join(left_part)\n    # If no odd-count character, use 'a' as the middle character\n    if not middle_char:\n        middle_char = 'a'\n    # Construct the right part of the palindrome\n    right_part = left_part[::-1]\n    \n    # Combine the parts to form the palindrome\n    if len(s) % 2 == 0:\n        return left_part + right_part\n    else:\n        return left_part + middle_char + right_part\n\n# Read input\ns = input()\n# Print output\nprint(smallest_palindrome(s))"}
{"solution": "def calculate_weight(board):\n    piece_weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n    }\n    \n    white_weight = 0\n    black_weight = 0\n    \n    for row in board:\n        for piece in row:\n            if piece in piece_weights:\n                if piece.isupper():\n                    white_weight += piece_weights[piece]\n                else:\n                    black_weight += piece_weights[piece]\n    \n    if white_weight > black_weight:\n        return \"White\"\n    elif black_weight > white_weight:\n        return \"Black\"\n    else:\n        return \"Draw\"\n\n# Read input from stdin\nboard = [input() for _ in range(8)]\n\n# Calculate and print the result\nprint(calculate_weight(board))"}
{"solution": "from collections import deque\n\ndef solve(N, M, S):\n    # Initialize dynamic programming table\n    dp = [-1] * (N + 1)\n    dp[N] = 0\n    path = [None] * (N + 1)\n\n    # Queue for BFS\n    queue = deque([N])\n\n    while queue:\n        pos = queue.popleft()\n\n        # Check all possible moves backwards\n        for move in range(1, min(M, pos) + 1):\n            next_pos = pos - move\n            if S[next_pos] == '0' and (dp[next_pos] == -1 or dp[next_pos] > dp[pos] + 1):\n                dp[next_pos] = dp[pos] + 1\n                path[next_pos] = move\n                queue.append(next_pos)\n\n    # Reconstruct the path if possible\n    if dp[0] != -1:\n        result = []\n        current_pos = 0\n        while current_pos < N:\n            result.append(path[current_pos])\n            current_pos += path[current_pos]\n        return ' '.join(map(str, result))\n    else:\n        return -1\n\n# Read input\nN, M = map(int, input().split())\nS = input()\n\n# Solve and print the result\nprint(solve(N, M, S))"}
{"solution": "from math import gcd\nfrom collections import defaultdict\n\ndef solve(K, X, Y):\n    def reachable(K, x, y):\n        g = gcd(K, abs(x) + abs(y))\n        return (abs(x) % g == 0) and (abs(y) % g == 0)\n    \n    def bfs(K, X, Y):\n        visited = defaultdict(lambda: float('inf'))\n        queue = [(0, 0, 0)]\n        visited[(0, 0)] = 0\n        \n        while queue:\n            score, x, y = queue.pop(0)\n            if (x, y) == (X, Y):\n                return score, x, y\n            \n            for dx in range(-K, K+1):\n                for dy in range(-K, K+1):\n                    if abs(dx) + abs(dy) == K:\n                        nx, ny = x + dx, y + dy\n                        if visited[(nx, ny)] > score + 1:\n                            visited[(nx, ny)] = score + 1\n                            queue.append((score + 1, nx, ny))\n        return -1\n    \n    result = bfs(K, X, Y)\n    if result == -1:\n        print(-1)\n    else:\n        path = []\n        score, x, y = result\n        while (x, y) != (0, 0):\n            path.append((x, y))\n            for dx in range(-K, K+1):\n                for dy in range(-K, K+1):\n                    if abs(dx) + abs(dy) == K and visited[(x-dx, y-dy)] == visited[(x, y)] - 1:\n                        x, y = x - dx, y - dy\n                        break\n        path.reverse()\n        print(len(path))\n        for x, y in path:\n            print(x, y)\n\n# Reading input\nK = int(input())\nX, Y = map(int, input().split())\n\n# Solving and printing output\nsolve(K, X, Y)"}
{"solution": "from math import gcd\n\ndef find_smallest_n(m):\n    def count_ways(n):\n        total = 0\n        for a in range(1, n + 1):\n            limit = n // a\n            for k in range(2, limit + 1):\n                b = a * k\n                if b > n:\n                    break\n                c = b * k\n                if c > n:\n                    break\n                d = c * k\n                if d > n:\n                    break\n                total += 1\n        return total\n    \n    if m == 1:\n        return 8  # Special case as per the problem statement\n    \n    # Binary search for the smallest n\n    low, high = 1, int(1e15)\n    while low < high:\n        mid = (low + high) // 2\n        if count_ways(mid) < m:\n            low = mid + 1\n        else:\n            high = mid\n            \n    if count_ways(low) == m:\n        return low\n    return -1\n\n# Read input\nm = int(input())\n\n# Solve and print the result\nprint(find_smallest_n(m))"}
{"solution": "import math\n\ndef intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    \n    if d >= r1 + r2:\n        return 0.0  # No intersection\n    if d <= abs(r1 - r2):\n        return 0.0  # One circle is fully inside the other, no intersection area\n    if d == 0 and r1 == r2:\n        return math.pi * r1**2  # Circles are the same\n    \n    alpha = math.acos((r1**2 + d**2 - r2**2) / (2 * r1 * d))\n    beta = math.acos((r2**2 + d**2 - r1**2) / (2 * r2 * d))\n    \n    area1 = r1**2 * alpha - r1**2 * math.sin(2 * alpha) / 2\n    area2 = r2**2 * beta - r2**2 * math.sin(2 * beta) / 2\n    \n    return area1 + area2\n\n# Reading input\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\n# Calculating and printing the result\nprint(intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "def minimize_n(v):\n    if v == 1:\n        return 1\n    # Find the smallest prime number greater than or equal to v\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    # Start checking from v and go down to find the smallest non-prime number\n    while not is_prime(v):\n        v -= 1\n    return v - 1\n\n# Read input\nv = int(input())\n\n# Calculate and print the output\nprint(minimize_n(v))"}
{"solution": "from collections import defaultdict\n\ndef dfs(node, parent, depth, citizens, graph, dp):\n    dp[node] = citizens[node]\n    for child in graph[node]:\n        if child != parent:\n            dfs(child, node, depth + 1, citizens, graph, dp)\n            dp[node] = min(dp[node], citizens[node] + (dp[child] if depth > 0 else float('inf')))\n\ndef min_citizens_caught(n, roads, citizens):\n    # Build the graph\n    graph = defaultdict(list)\n    for i, p in enumerate(roads, start=2):\n        graph[p].append(i)\n    \n    # Dynamic Programming table\n    dp = [0] * (n + 1)\n    \n    # Perform DFS starting from the main square\n    dfs(1, -1, 0, citizens, graph, dp)\n    \n    return dp[1]\n\n# Read input\nn = int(input())\nroads = list(map(int, input().split()))\ncitizens = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_citizens_caught(n, roads, citizens))"}
{"solution": "def count_typo_words(n, S, T):\n    count = 0\n    i = 0\n    j = n - 1\n    \n    # Find the first differing character from the start\n    while i < n and S[i] == T[i]:\n        i += 1\n    \n    # Find the first differing character from the end\n    while j >= 0 and S[j] == T[j]:\n        j -= 1\n    \n    # Check if S[i:j+1] matches T[i+1:j+2] or T[i:j+1] matches S[i+1:j+2]\n    if S[i:j+1] == T[i+1:j+2] or T[i:j+1] == S[i+1:j+2]:\n        count = 2\n    elif S[i:j+1] == T[i+1:j+2] + T[j] or T[i:j+1] == S[i+1:j+2] + S[j]:\n        count = 1\n    \n    return count\n\n# Example usage:\nn = int(input())\nS = input().strip()\nT = input().strip()\nprint(count_typo_words(n, S, T))"}
{"solution": "import sys\ninput = sys.stdin.readline\n\ndef dfs(v, p, depth):\n    global max_strength\n    max_child_strength = A[v]\n    \n    for u in G[v]:\n        if u == p:\n            continue\n        child_strength = dfs(u, v, depth + 1)\n        max_strength = max(max_strength, max_child_strength + depth - 1)\n        max_child_strength = max(max_child_strength, child_strength + 1)\n\n    return max_child_strength\n\nn = int(input())\nA = list(map(int, input().split()))\nG = [[] for _ in range(n)]\n\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    G[u - 1].append(v - 1)\n    G[v - 1].append(u - 1)\n\nmax_strength = 0\ndfs(0, -1, 0)\nprint(max_strength)"}
{"solution": "def max_groups(n, m):\n    return min(m, n - m)\n\n# Reading input\nn, m = map(int, input().split())\n\n# Calculating and printing the maximum number of groups\nprint(max_groups(n, m))"}
{"solution": "def min_shovels(k, r):\n    for n in range(1, 11):\n        if (n * k) % 10 == r:\n            return n\n    return 10\n\nk, r = map(int, input().split())\nprint(min_shovels(k, r))"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # Dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Extract the bounding box\n    piece = []\n    for i in range(min_row, max_row + 1):\n        piece.append(grid[i][min_col:max_col + 1])\n    \n    # Check horizontal placement\n    if width * 2 == m:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j] != piece[i][j + width]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    # Check vertical placement\n    if height * 2 == n:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j] != piece[i + height][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "def min_segments(x1, y1, x2, y2, x3, y3):\n    # Check if all points are collinear on the same axis\n    if x1 == x2 == x3:\n        return 1\n    if y1 == y2 == y3:\n        return 1\n    \n    # Check if two points share the same x-coordinate or y-coordinate\n    if (x1 == x2 or x1 == x3 or x2 == x3) or (y1 == y2 or y1 == y3 or y2 == y3):\n        return 2\n    \n    # General case where no two points share the same coordinate\n    return 3\n\n# Read input\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\n# Calculate and print the minimum number of segments\nprint(min_segments(x1, y1, x2, y2, x3, y3))"}
{"solution": "def build_k_regular_graph(k):\n    if k == 1:\n        return \"YES\\n2 1\\n1 2\"\n    elif k % 2 == 0:\n        return \"NO\"\n    else:\n        n = 2 * k + 1\n        m = (n * k) // 2\n        edges = []\n        \n        # Create a cycle to ensure connectivity\n        for i in range(n - 1):\n            edges.append((i + 1, i + 2))\n        edges.append((n, 1))\n        \n        # Add remaining edges to make the graph k-regular\n        for i in range(1, n // 2 + 1):\n            for j in range(1, k):\n                if i + j >= n:\n                    edges.append((i, i + j - n))\n                else:\n                    edges.append((i, i + j))\n        \n        # Ensure the last vertex has the correct degree\n        for j in range(1, k):\n            if n - 1 + j >= n:\n                edges.append((n, n - 1 + j - n))\n            else:\n                edges.append((n, n - 1 + j))\n        \n        return f\"YES\\n{n} {m}\\n\" + \"\\n\".join(f\"{u} {v}\" for u, v in edges)\n\n# Read input\nk = int(input())\n\n# Output the result\nprint(build_k_regular_graph(k))"}
{"solution": "def build_z_function(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            z[i] = min(r - i + 1, z[i - l])\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > r:\n            l, r = i, i + z[i] - 1\n    return z\n\ndef preprocess(s, t):\n    concatenated = t + '$' + s\n    z_values = build_z_function(concatenated)\n    m = len(t)\n    occurrences = [0] * (len(s) + 1)\n    for i in range(m + 1, len(concatenated)):\n        if z_values[i] == m:\n            occurrences[i - m - 1] += 1\n        if z_values[i] >= m:\n            occurrences[i - m] -= 1\n    return occurrences\n\ndef process_queries(n, m, q, s, t, queries):\n    occurrences = preprocess(s, t)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + occurrences[i - 1]\n    for l, r in queries:\n        count = prefix_sum[r] - prefix_sum[l - 1]\n        print(count)\n\n# Reading input\nn, m, q = map(int, input().split())\ns = input()\nt = input()\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Processing queries and printing output\nprocess_queries(n, m, q, s, t, queries)"}
{"solution": "def count_paths(n, k, d):\n    MOD = 1000000007\n\n    # Initialize DP tables\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill DP table\n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            for w in range(1, k + 1):\n                if i >= w:\n                    dp[i][j] += dp[i - w][max(j - 1, 0)] if w >= d else dp[i - w][j]\n                    dp[i][j] %= MOD\n\n    # Sum all valid paths\n    result = sum(dp[n]) % MOD\n    return result\n\n# Read input\nn, k, d = map(int, input().split())\n\n# Compute and print the result\nprint(count_paths(n, k, d))"}
{"solution": "def encrypt_japanese_crossword(n, row):\n    groups = []\n    count = 0\n    \n    for char in row:\n        if char == 'B':\n            count += 1\n        else:\n            if count > 0:\n                groups.append(count)\n                count = 0\n    \n    if count > 0:\n        groups.append(count)\n    \n    print(len(groups))\n    if groups:\n        print(\" \".join(map(str, groups)))\n\n# Reading input\nn = int(input())\nrow = input().strip()\nencrypt_japanese_crossword(n, row)"}
{"solution": "def process_operations(n, m, p, sequence, operations):\n    pairs = [-1] * n\n    stack = []\n    \n    # Pairing brackets\n    for i, char in enumerate(sequence):\n        if char == '(':\n            stack.append(i)\n        else:\n            pairs[stack.pop()] = i\n            pairs[i] = stack[-1] if stack else -1\n    \n    cursor = p - 1\n    remaining = list(range(n))\n    \n    for op in operations:\n        if op == 'L':\n            if cursor > 0:\n                cursor -= 1\n                while pairs[remaining[cursor]] != -1 and remaining[cursor] != pairs[remaining[cursor]]:\n                    cursor -= 1\n        elif op == 'R':\n            if cursor < n - 1:\n                cursor += 1\n                while pairs[remaining[cursor]] != -1 and remaining[cursor] != pairs[remaining[cursor]]:\n                    cursor += 1\n        elif op == 'D':\n            start = remaining[cursor]\n            end = pairs[start]\n            del_idx = set()\n            \n            # Find indices to delete\n            for i in range(min(start, end), max(start, end) + 1):\n                idx = remaining.index(i)\n                del_idx.add(idx)\n            \n            # Remove deleted indices\n            remaining = [r for i, r in enumerate(remaining) if i not in del_idx]\n            \n            # Update cursor position\n            cursor = remaining.index(start)\n            if cursor >= len(remaining):\n                cursor = len(remaining) - 1\n    \n    # Reconstruct the sequence\n    result = ''.join(sequence[r] for r in remaining)\n    print(result)\n\n# Example usage\nn, m, p = map(int, input().split())\nsequence = input()\noperations = input()\nprocess_operations(n, m, p, sequence, operations)"}
{"solution": "def find_valid_integer(n, queries):\n    lower_bound = -2 * 10**9\n    upper_bound = 2 * 10**9\n    \n    for query in queries:\n        sign, x, answer = query.split()\n        x = int(x)\n        \n        if sign == \">\":\n            if answer == \"Y\": lower_bound = max(lower_bound, x + 1)\n            else: upper_bound = min(upper_bound, x)\n        elif sign == \"<\":\n            if answer == \"Y\": upper_bound = min(upper_bound, x - 1)\n            else: lower_bound = max(lower_bound, x)\n        elif sign == \">=\":\n            if answer == \"Y\": lower_bound = max(lower_bound, x)\n            else: upper_bound = min(upper_bound, x - 1)\n        elif sign == \"<=\":\n            if answer == \"Y\": upper_bound = min(upper_bound, x)\n            else: lower_bound = max(lower_bound, x + 1)\n    \n    if lower_bound > upper_bound:\n        return \"Impossible\"\n    else:\n        return lower_bound\n\nn = int(input())\nqueries = [input() for _ in range(n)]\nprint(find_valid_integer(n, queries))"}
{"solution": "from math import gcd\n\ndef count_possible_periods(a, b):\n    \"\"\"\n    Calculate the number of different periods over all possible strings with a letters 'A' and b letters 'B'.\n    \"\"\"\n    # The maximum possible period is a + b\n    max_period = a + b\n    \n    # Initialize the result variable\n    result = 0\n    \n    # Iterate through all possible periods\n    for k in range(1, max_period + 1):\n        # Calculate the greatest common divisor of a + b and k\n        g = gcd(max_period, k)\n        \n        # Calculate the number of 'A's and 'B's in one period\n        a_in_period = (a // (max_period // g))\n        b_in_period = (b // (max_period // g))\n        \n        # Check if it's possible to distribute 'A's and 'B's evenly within one period\n        if a_in_period * (max_period // g) == a and b_in_period * (max_period // g) == b:\n            result += 1\n    \n    return result\n\n# Read input\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(count_possible_periods(a, b))"}
{"solution": "def generate_names(n, k, conditions):\n    names = [\"Aa\"] * n\n    unique_names = [\"Aa\"]\n    next_name_index = 1\n    \n    for i in range(1, 26):\n        unique_names.append(chr(65 + i) + \"a\")\n    \n    for i in range(n - k + 1):\n        if conditions[i] == \"YES\":\n            for j in range(k):\n                if names[i + j] in names[i:i+j]:\n                    names[i + j] = unique_names[next_name_index % len(unique_names)]\n                    next_name_index += 1\n        else:\n            for j in range(1, k):\n                if names[i + j] != names[i]:\n                    names[i + j] = names[i]\n    \n    return names\n\n# Reading input\nn, k = map(int, input().split())\nconditions = input().split()\n\n# Generate and print the names\nnames = generate_names(n, k, conditions)\nprint(\" \".join(names))"}
{"solution": "def min_operations_to_equal(a, b):\n    def count_factors(n, factor):\n        count = 0\n        while n % factor == 0:\n            n //= factor\n            count += 1\n        return count, n\n\n    # Count the number of times we can divide by 2, 3, and 5\n    a2, a = count_factors(a, 2)\n    a3, a = count_factors(a, 3)\n    a5, a = count_factors(a, 5)\n    \n    b2, b = count_factors(b, 2)\n    b3, b = count_factors(b, 3)\n    b5, b = count_factors(b, 5)\n    \n    # If the remaining parts are not equal, return -1\n    if a != b:\n        return -1\n    \n    # Calculate the total number of operations needed\n    operations = abs(a2 - b2) + abs(a3 - b3) + abs(a5 - b5)\n    \n    return operations\n\n# Read input\na, b = map(int, input().split())\n\n# Print the result\nprint(min_operations_to_equal(a, b))"}
{"solution": "def min_cost_palindrome(n, a, b, c):\n    dp = [[float('inf')] * (1 << n) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(n):\n        for mask in range(1 << n):\n            if dp[i][mask] == float('inf'):\n                continue\n            for j in range(n):\n                if not (mask & (1 << j)):\n                    if c[j] == 2 or (c[i - (i > j)] == c[j]):\n                        dp[i + 1][mask | (1 << j)] = min(dp[i + 1][mask | (1 << j)], dp[i][mask] + (a if c[j] == 0 else b if c[j] == 1 else 0))\n\n    result = float('inf')\n    for mask in range(1 << n):\n        valid = True\n        for i in range(n // 2):\n            if c[i] != c[n - 1 - i] and (c[i] != 2 and c[n - 1 - i] != 2):\n                valid = False\n                break\n        if valid:\n            result = min(result, dp[n][mask])\n\n    return result if result != float('inf') else -1\n\n# Reading input\nn, a, b = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(min_cost_palindrome(n, a, b, c))"}
{"solution": "def paint_cube(k):\n    if k == 1:\n        print(-1)\n        return\n    \n    # Initialize the cube as a 3D list filled with 'w'\n    cube = [[[None for _ in range(k)] for _ in range(k)] for _ in range(k)]\n    \n    # Fill the cube with alternating 'b' and 'w'\n    for z in range(k):\n        for x in range(k):\n            for y in range(k):\n                if (x + y + z) % 2 == 0:\n                    cube[z][x][y] = 'b'\n                else:\n                    cube[z][x][y] = 'w'\n    \n    # Check if the conditions are met\n    def check_conditions(cube, k):\n        directions = [(0, 1, 0), (1, 0, 0), (0, 0, 1)]\n        for z in range(k):\n            for x in range(k):\n                for y in range(k):\n                    color = cube[z][x][y]\n                    count = 0\n                    for dz, dx, dy in directions:\n                        nz, nx, ny = z + dz, x + dx, y + dy\n                        if 0 <= nz < k and 0 <= nx < k and 0 <= ny < k and cube[nz][nx][ny] == color:\n                            count += 1\n                    if count != 2:\n                        return False\n        return True\n    \n    if not check_conditions(cube, k):\n        print(-1)\n        return\n    \n    # Print the cube layer by layer\n    for z in range(k):\n        for x in range(k):\n            for y in range(k):\n                print(cube[z][x][y], end='')\n            print()\n        if z < k - 1:\n            print()\n\n# Read input\nk = int(input())\npaint_cube(k)"}
{"solution": "from math import sqrt\nfrom collections import Counter\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef largest_lovely_number(n):\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n    \n    lovely_number = 1\n    for prime, count in factor_counts.items():\n        lovely_number *= prime\n    \n    return lovely_number\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the largest lovely number\nprint(largest_lovely_number(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    # Check for adjacent occupied seats\n    for i in range(n - 1):\n        if seating[i] == '1' and seating[i + 1] == '1':\n            return \"No\"\n    \n    # Check for possible additional seating\n    for i in range(n):\n        if seating[i] == '0':\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nn = int(input())\nseating = input().strip()\nprint(is_maximal_seating(n, seating))"}
{"solution": "def find_possible_k_values(n, a):\n    def is_valid_period(k):\n        prefix_sums = [0]\n        for i in range(1, k + 1):\n            prefix_sums.append(a[i] - a[i - 1])\n        \n        for i in range(k + 1, n + 1):\n            current_diff = a[i] - a[i - 1]\n            expected_diff = prefix_sums[i % k] - prefix_sums[(i % k) - 1]\n            if current_diff != expected_diff:\n                return False\n        return True\n    \n    valid_ks = []\n    for k in range(1, n + 1):\n        if is_valid_period(k):\n            valid_ks.append(k)\n    \n    print(len(valid_ks))\n    print(\" \".join(map(str, valid_ks)))\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Solving and printing output\nfind_possible_k_values(n, a)"}
{"solution": "from itertools import combinations\n\ndef can_form_equal_teams(scores):\n    # Calculate the total sum of scores\n    total_sum = sum(scores)\n    # Check if the total sum is even, as both teams should have equal scores\n    if total_sum % 2 != 0:\n        return \"NO\"\n    \n    target_sum = total_sum // 2\n    # Generate all possible combinations of 3 participants\n    for combo in combinations(scores, 3):\n        if sum(combo) == target_sum:\n            # If one combination sums up to half of the total, the other half automatically forms the second team\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nscores = list(map(int, input().split()))\n\n# Output result\nprint(can_form_equal_teams(scores))"}
{"solution": "import math\n\ndef generate_2_3_integers(limit):\n    max_exp = int(math.log(limit, 2)) + 1\n    nums = set()\n    \n    for x in range(max_exp):\n        for y in range(int(math.log(limit // (2 ** x), 3)) + 1):\n            num = 2 ** x * 3 ** y\n            if num <= limit:\n                nums.add(num)\n                \n    return sorted(nums)\n\ndef count_2_3_integers_in_range(l, r):\n    # Generate all 2-3 integers up to the maximum limit\n    all_2_3_integers = generate_2_3_integers(r)\n    \n    # Count the 2-3 integers within the range [l, r]\n    count = sum(1 for num in all_2_3_integers if l <= num <= r)\n    \n    return count\n\n# Read input\nl, r = map(int, input().split())\n\n# Output the result\nprint(count_2_3_integers_in_range(l, r))"}
{"solution": "def candies_eaten(n, k):\n    eaten = 0\n    candies = 0\n    add = 1\n    \n    while True:\n        # Add candies\n        candies += add\n        n -= 1\n        if candies > k:\n            candies -= add\n            n += 1\n            break\n        if n == 0 and candies == k:\n            break\n        add += 1\n        \n        # Eat candies if possible\n        if n > 0 and candies > 0:\n            candies -= 1\n            eaten += 1\n            n -= 1\n            if n == 0 and candies == k:\n                break\n    \n    return eaten\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(candies_eaten(n, k))"}
{"solution": "def can_form_triangle(n, segments):\n    # Sort the segments to simplify comparison\n    segments.sort()\n    \n    # Iterate through the sorted segments to find a valid triangle\n    for i in range(n - 2):\n        # Check if the current set of three segments can form a non-degenerate triangle\n        if segments[i] + segments[i + 1] > segments[i + 2]:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\nsegments = list(map(int, input().split()))\n\n# Output result\nprint(can_form_triangle(n, segments))"}
{"solution": "def is_possible(x, y):\n    if y < 1:\n        return \"No\"\n    y -= 1  # Adjusting for the initial original toy\n    while y < x or y % 2:\n        if x < y or x % 2:\n            return \"No\"\n        x //= 2\n        y *= 2\n    return \"Yes\" if y == x == 0 else \"No\"\n\n# Reading input\nx, y = map(int, input().split())\n\n# Printing output\nprint(is_possible(x, y))"}
{"solution": "def max_character_rating(n, k, skills):\n    # Calculate initial total rating\n    initial_rating = sum(a // 10 for a in skills)\n    \n    # Calculate the number of units needed to reach the next multiple of 10 for each skill\n    improvements = [(10 * ((a + 9) // 10) - a, i) for i, a in enumerate(skills)]\n    improvements.sort()  # Sort by the number of units needed\n    \n    # Allocate improvement units\n    for units_needed, index in improvements:\n        if k >= units_needed:\n            k -= units_needed\n            skills[index] += units_needed\n        else:\n            break\n    \n    # Recalculate the total rating\n    final_rating = sum(a // 10 for a in skills)\n    \n    return final_rating\n\n# Read input\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Compute and print the maximum total rating\nprint(max_character_rating(n, k, skills))"}
{"solution": "def find_smallest_pretty_integer(n, m, list1, list2):\n    # Convert lists to sets for faster lookup\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check for common digits\n    common_digits = set1.intersection(set2)\n    if common_digits:\n        return min(common_digits)\n    \n    # If no common digits, find the smallest combination\n    min1 = min(list1)\n    min2 = min(list2)\n    \n    # Form the smallest two-digit number\n    smallest_pretty = min(int(f\"{min1}{min2}\"), int(f\"{min2}{min1}\"))\n    return smallest_pretty\n\n# Read input\nn, m = map(int, input().split())\nlist1 = list(map(int, input().split()))\nlist2 = list(map(int, input().split()))\n\n# Print the result\nprint(find_smallest_pretty_integer(n, m, list1, list2))"}
{"solution": "# Import necessary package\nfrom typing import Tuple\n\ndef max_problems_solved(n: int, k: int) -> int:\n    \"\"\"\n    Determines the maximum number of problems Limak can solve before leaving for the party.\n    \n    Args:\n    n (int): The number of problems in the contest.\n    k (int): The number of minutes Limak needs to get to the party.\n    \n    Returns:\n    int: The maximum number of problems Limak can solve.\n    \"\"\"\n    # Total time available for the contest in minutes (from 20:00 to 24:00)\n    total_time = 240  # 4 hours * 60 minutes/hour\n    \n    # Time left after accounting for travel time\n    time_left = total_time - k\n    \n    # Calculate the cumulative time needed to solve problems\n    for i in range(1, n + 1):\n        time_needed = 5 * i * i // 2  # Sum of the first i terms of 5*i\n        if time_needed > time_left:\n            return i - 1\n    return n\n\n# Example check function (not part of the solution)\ndef check_solution(input_data: Tuple[int, int], expected_output: int) -> None:\n    n, k = input_data\n    result = max_problems_solved(n, k)\n    assert result == expected_output, f\"Expected {expected_output}, got {result}\"\n\n# Uncomment the lines below to test the solution with provided data points\n# check_solution((3, 222), 2)\n# check_solution((4, 190), 4)\n# check_solution((7, 1), 7)\n\n# Final submission without test cases\nn, k = map(int, input().split())\nprint(max_problems_solved(n, k))"}
{"solution": "def max_teams(n, x, y, a):\n    a.sort()\n    double_sided = x\n    single_sided = y\n    count = 0\n    \n    for pages in a:\n        double_needed = pages // 2\n        single_needed = pages % 2\n        \n        if double_needed <= double_sided:\n            double_sided -= double_needed\n            if single_needed <= single_sided:\n                single_sided -= single_needed\n                count += 1\n            else:\n                double_sided += double_needed\n                break\n        else:\n            remaining_pages = pages - 2 * double_sided\n            if remaining_pages <= single_sided:\n                single_sided -= remaining_pages\n                double_sided = 0\n                count += 1\n            else:\n                break\n    \n    return count\n\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\nprint(max_teams(n, x, y, a))"}
{"solution": "from math import gcd\n\ndef count_divisors(n):\n    divisors = set()\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return len(divisors)\n\n# Read input\nb = int(input().strip())\n\n# Calculate the number of distinct values\nresult = count_divisors(b)\n\n# Print the result\nprint(result)"}
{"solution": "n = int(input())\nbumper_sequence = input()\n\n# Initialize counters\nleft_fall_count = 0\nright_fall_count = 0\nmax_left_fall = 0\nmax_right_fall = 0\n\n# Count consecutive '<' from the left\nfor i in range(n):\n    if bumper_sequence[i] == '<':\n        left_fall_count += 1\n    else:\n        max_left_fall = max(max_left_fall, left_fall_count)\n        left_fall_count = 0\n\n# Count consecutive '>' from the right\nfor i in range(n - 1, -1, -1):\n    if bumper_sequence[i] == '>':\n        right_fall_count += 1\n    else:\n        max_right_fall = max(max_right_fall, right_fall_count)\n        right_fall_count = 0\n\n# Final check for the last sequence of '<'\nmax_left_fall = max(max_left_fall, left_fall_count)\n# Final check for the last sequence of '>'\nmax_right_fall = max(max_right_fall, right_fall_count)\n\n# Calculate the number of positions where the ball will fall\nresult = max_left_fall + max_right_fall\n\nprint(result)"}
{"solution": "from collections import Counter\n\ndef max_rectangle_area(stick_lengths):\n    count = Counter(stick_lengths)\n    total_area = 0\n    \n    for length in sorted(count):\n        # Reduce length by 1 if it helps to match more pairs\n        count[length - 1] += count[length]\n        # Find the number of pairs that can be made\n        pairs = count[length - 1] // 2\n        # Add to total area\n        total_area += pairs * (length - 1) ** 2\n        # Remove used sticks\n        count[length - 1] -= pairs * 2\n    \n    return total_area\n\n# Read input\nn = int(input())\nstick_lengths = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_rectangle_area(stick_lengths))"}
{"solution": "from collections import defaultdict, Counter\nfrom itertools import permutations\n\ndef min_sum_of_restored_numbers(n, strings):\n    # Mapping letters to digits\n    letter_to_digit = {chr(97 + i): -1 for i in range(10)}  # 'a' to 'j'\n    \n    # Collect all unique characters\n    all_chars = set(''.join(strings))\n    \n    # Initialize the mapping and the result\n    min_sum = float('inf')\n    \n    # Generate all permutations of digits for mapping\n    for perm in permutations(range(10), len(all_chars)):\n        # Assign digits to letters\n        for char, digit in zip(sorted(all_chars), perm):\n            letter_to_digit[char] = digit\n        \n        # Check if the current mapping leads to a valid number without leading zeros\n        current_sum = 0\n        for s in strings:\n            num = int(s.translate(str.maketrans(letter_to_digit)))\n            if str(num).startswith('0'):\n                break\n            current_sum += num\n        else:\n            # Update the minimum sum if the current one is smaller\n            min_sum = min(min_sum, current_sum)\n    \n    return min_sum\n\n# Reading input\nn = int(input())\nstrings = [input().strip() for _ in range(n)]\n\n# Calculate and print the minimum sum\nprint(min_sum_of_restored_numbers(n, strings))"}
{"solution": "def max_teams(n, m):\n    # Binary search to find the maximum number of teams\n    low, high = 0, min(n, m, (n + m) // 3)\n    \n    while low < high:\n        mid = (low + high + 1) // 2\n        if mid <= n and mid <= m and 2 * mid <= n + m:\n            low = mid\n        else:\n            high = mid - 1\n    \n    return low\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    n = len(s)\n    \n    # Check for \"AB\" followed by \"BA\"\n    index_ab = -1\n    for i in range(n - 1):\n        if s[i:i+2] == \"AB\":\n            index_ab = i\n            break\n    \n    if index_ab != -1:\n        for j in range(index_ab + 2, n - 1):\n            if s[j:j+2] == \"BA\":\n                print(\"YES\")\n                return\n    \n    # Check for \"BA\" followed by \"AB\"\n    index_ba = -1\n    for i in range(n - 1):\n        if s[i:i+2] == \"BA\":\n            index_ba = i\n            break\n    \n    if index_ba != -1:\n        for j in range(index_ba + 2, n - 1):\n            if s[j:j+2] == \"AB\":\n                print(\"YES\")\n                return\n    \n    # If neither condition is met\n    print(\"NO\")\n\n# Read input\ns = input().strip()\ncheck_substrings(s)"}
{"solution": "def can_transform(a, b):\n    n = len(a)\n    k = len(b)\n    \n    stack = []\n    j = 0\n    \n    for i in range(n):\n        stack.append(a[i])\n        while stack and j < k and stack[-1] == b[j]:\n            if len(stack) > 1 and stack[-2] >= b[j]:\n                return \"NO\"\n            stack.pop()\n            j += 1\n    \n    if stack or j != k:\n        return \"NO\"\n    \n    # Reconstruct the sequence of actions\n    actions = []\n    j = 0\n    stack = []\n    \n    for i in range(n):\n        stack.append(a[i])\n        while stack and j < k and stack[-1] == b[j]:\n            action_stack = []\n            while stack and j < k and stack[-1] == b[j]:\n                if len(stack) > 1 and stack[-2] >= b[j]:\n                    action_stack.append((len(stack) - 1, 'L'))\n                else:\n                    return \"NO\"\n                stack.pop()\n                j += 1\n            \n            # Reverse the actions since we built them backwards\n            for idx, direction in reversed(action_stack):\n                actions.append(f\"{idx + 1} {direction}\")\n    \n    if j == k:\n        return \"YES\\n\" + \"\\n\".join(actions)\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nk = int(input())\nb = list(map(int, input().split()))\n\n# Output result\nprint(can_transform(a, b))"}
{"solution": "def is_possible_to_assign(rebels, bases):\n    def ccw(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    def segment_intersection(seg1, seg2):\n        p1, p2 = seg1\n        q1, q2 = seg2\n        return (ccw(p1, p2, q1) * ccw(p1, p2, q2) <= 0) and (ccw(q1, q2, p1) * ccw(q1, q2, p2) <= 0)\n\n    n = len(rebels)\n    m = len(bases)\n\n    if n != m:\n        return \"No\"\n\n    def check_assignment(assignment):\n        for i in range(n):\n            for j in range(i + 1, n):\n                if segment_intersection((rebels[i], bases[assignment[i]]), (rebels[j], bases[assignment[j]])):\n                    return False\n        return True\n\n    from itertools import permutations\n    for perm in permutations(range(n)):\n        if check_assignment(perm):\n            return \"Yes\"\n    return \"No\"\n\n# Reading input\nR, B = map(int, input().split())\nrebels = [tuple(map(int, input().split())) for _ in range(R)]\nbases = [tuple(map(int, input().split())) for _ in range(B)]\n\n# Printing output\nprint(is_possible_to_assign(rebels, bases))"}
{"solution": "def max_power_of_two(n, arr):\n    def highest_power_of_two(num):\n        power = 0\n        while num % 2 == 0:\n            num //= 2\n            power += 1\n        return power\n\n    max_power = 0\n    count = 0\n\n    for num in arr:\n        current_power = highest_power_of_two(num)\n        if current_power > max_power:\n            max_power = current_power\n            count = 1\n        elif current_power == max_power:\n            count += 1\n\n    # Calculate the actual value of r\n    r = 2 ** max_power\n    print(r, count)\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Solving and printing output\nmax_power_of_two(n, arr)"}
{"solution": "def min_clicks(n, m):\n    clicks = 0\n    while n != m:\n        if m < n or (m % 2 == 0 and n <= m):\n            m //= 2\n        else:\n            m += 1\n        clicks += 1\n    return clicks\n\nn, m = map(int, input().split())\nprint(min_clicks(n, m))"}
{"solution": "from collections import defaultdict\n\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    return find(parent, parent[i])\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef check_tree(n, segments):\n    edges = []\n    graph = defaultdict(list)\n    \n    # Build edges based on segment intersection rules\n    for i in range(n):\n        for j in range(i + 1, n):\n            li, ri = segments[i]\n            lj, rj = segments[j]\n            if lj < ri < rj or li < rj < ri:\n                if not (li <= lj and ri >= rj) and not (lj <= li and rj >= ri):\n                    edges.append((i, j))\n                    graph[i].append(j)\n                    graph[j].append(i)\n    \n    # Check connectivity and cycle using Union-Find\n    parent = list(range(n))\n    rank = [0] * n\n    expected_edges = n - 1\n    actual_edges = len(edges)\n    \n    for u, v in edges:\n        x = find(parent, u)\n        y = find(parent, v)\n        if x == y:\n            return \"NO\"  # Cycle detected\n        union(parent, rank, u, v)\n    \n    # Check if all vertices are connected\n    root = find(parent, 0)\n    for i in range(1, n):\n        if find(parent, i) != root:\n            return \"NO\"\n    \n    # Check the number of edges\n    if actual_edges != expected_edges:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Parse input\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(check_tree(n, segments))"}
{"solution": "def longest_ddos_attack(n, requests):\n    max_length = 0\n    for start in range(n):\n        total_requests = 0\n        for end in range(start, n):\n            total_requests += requests[end]\n            duration = end - start + 1\n            if total_requests > 100 * duration:\n                max_length = max(max_length, duration)\n            else:\n                break\n    return max_length\n\n# Read input\nn = int(input())\nrequests = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(longest_ddos_attack(n, requests))"}
{"solution": "def check_dissatisfaction(n, k, episodes):\n    def check_possible(max_consecutive, uncertain):\n        # Check if it's possible to have exactly k consecutive 'N's\n        if max_consecutive == k:\n            return True\n        # If max_consecutive is less than k, check if we can fill '?' to reach k\n        if max_consecutive < k:\n            return k - max_consecutive <= uncertain\n        return False\n\n    max_consecutive = 0\n    uncertain = 0\n    current_consecutive = 0\n\n    for episode in episodes:\n        if episode == 'N':\n            current_consecutive += 1\n            uncertain = 0\n        elif episode == '?':\n            uncertain += 1\n            if current_consecutive > 0:\n                max_consecutive = max(max_consecutive, current_consecutive)\n                current_consecutive = 0\n        else:  # episode == 'Y'\n            if current_consecutive > 0:\n                max_consecutive = max(max_consecutive, current_consecutive)\n                current_consecutive = 0\n\n    # Check the last segment if it ends with '?' or 'N'\n    if current_consecutive > 0:\n        max_consecutive = max(max_consecutive, current_consecutive)\n\n    return \"YES\" if check_possible(max_consecutive, uncertain) else \"NO\"\n\n# Read input\nn, k = map(int, input().split())\nepisodes = input()\n\n# Output result\nprint(check_dissatisfaction(n, k, episodes))"}
{"solution": "def count_possible_values(N, X, D):\n    # Calculate the total sum of the sequence\n    total_sum = X * N + (N * (N - 1) // 2) * D\n    \n    # Calculate the minimum and maximum possible values of S - T\n    min_diff = -(X + (N - 1) * D)\n    max_diff = X + (N - 1) * D\n    \n    # The possible values of S - T range from min_diff to max_diff with a step of 2D\n    possible_values = (max_diff - min_diff) // (2 * D) + 1\n    \n    return possible_values\n\n# Read input\nN, X, D = map(int, input().split())\n\n# Calculate and print the number of possible values of S - T\nprint(count_possible_values(N, X, D))"}
{"solution": "def did_anton_perform_good(n, participants):\n    for handle, before, after in participants:\n        if before >= 2400 and after > before:\n            return \"YES\"\n    return \"NO\"\n\n# Reading input\nn = int(input())\nparticipants = [input().split() for _ in range(n)]\nparticipants = [(handle, int(before), int(after)) for handle, before, after in participants]\n\n# Printing the result\nprint(did_anton_perform_good(n, participants))"}
{"solution": "def count_missed_trains(binary_time):\n    # Convert binary time to decimal\n    decimal_time = int(binary_time, 2)\n    missed_trains = 0\n    \n    # Iterate through powers of 4 until reaching the time\n    k = 0\n    while 4 ** k < decimal_time:\n        missed_trains += 1\n        k += 1\n    \n    return missed_trains\n\n# Read input\nbinary_time = input()\n\n# Calculate and print the number of missed trains\nprint(count_missed_trains(binary_time))"}
{"solution": "def min_rows_for_matrix_b(n, m, matrix_a):\n    # Initialize the result variable\n    result = 0\n    \n    # Iterate through the matrix to find the minimum number of unique rows\n    for i in range(n // 2):\n        # Check if the current row is the same as the corresponding mirrored row\n        if matrix_a[i] != matrix_a[n - 1 - i]:\n            result += 1\n        else:\n            # If the row and its mirror are identical, only count once\n            if result == 0:\n                result += 1\n    \n    # Handle the middle row if n is odd\n    if n % 2 == 1:\n        result += 1\n    \n    return result\n\n# Read input\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(min_rows_for_matrix_b(n, m, matrix_a))"}
{"solution": "import sys\n\n# Reading input\ninput = sys.stdin.read\ndata = list(map(int, input().split()))\n\n# Extracting the number of orders\nn = data[0]\ndata = data[1:]\n\n# Creating intervals from the input data\nintervals = [(data[2 * i], data[2 * i + 1]) for i in range(n)]\n\n# Sorting intervals based on their end times\nintervals.sort(key=lambda x: x[1])\n\n# Initializing variables\ncount = 0\nlast_end_time = -1\n\n# Iterating through the sorted intervals\nfor start, end in intervals:\n    if start >= last_end_time:\n        count += 1\n        last_end_time = end\n\n# Printing the result\nprint(count)"}
{"solution": "def can_rearrange(n, k, tables, formulas):\n    prev_table_count = 0\n    prev_formula_count = 0\n    \n    for i in range(n):\n        table_count = 0\n        formula_count = 0\n        \n        # Count consecutive tables and formulas\n        if prev_formula_count > 0:\n            table_count += prev_formula_count\n            prev_formula_count = 0\n        table_count += tables[i]\n        \n        if prev_table_count > 0:\n            formula_count += prev_table_count\n            prev_table_count = 0\n        formula_count += formulas[i]\n        \n        # Check if current page violates the constraint\n        if table_count > k or formula_count > k:\n            return \"NO\"\n        \n        # Update previous counts\n        if table_count % 2 == 1:\n            prev_table_count = (table_count + 1) // 2\n            prev_formula_count = (formula_count + 1) // 2\n        else:\n            prev_table_count = table_count // 2\n            prev_formula_count = formula_count // 2\n    \n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ntables = list(map(int, input().split()))\nformulas = list(map(int, input().split()))\n\n# Determine if rearrangement is possible\nprint(can_rearrange(n, k, tables, formulas))"}
{"solution": "from collections import deque\n\ndef can_human_win(n, k, coefficients):\n    # Initialize a queue to keep track of unset coefficients\n    unset_indices = deque()\n    \n    # Populate the queue with indices of unset coefficients\n    for i in range(n + 1):\n        if coefficients[i] == '?':\n            unset_indices.append(i)\n    \n    # Check if the first coefficient is set correctly\n    if len(unset_indices) == 0:\n        return \"Yes\" if coefficients[0] == str(-k * coefficients[1]) else \"No\"\n    \n    # If the first move is already made by the computer, adjust the queue\n    if coefficients[0] != '?':\n        if len(unset_indices) % 2 == 0:\n            return \"No\"\n        unset_indices.popleft()\n    \n    # Human can always win if they have an odd number of moves left\n    return \"Yes\" if len(unset_indices) % 2 == 1 else \"No\"\n\n# Read input\nn, k = map(int, input().split())\ncoefficients = [input().strip() for _ in range(n + 1)]\n\n# Determine and print the result\nprint(can_human_win(n, k, coefficients))"}
{"solution": "from sympy import primerange\n\ndef smallest_starting_number(X2):\n    def next_move(X, primes):\n        for p in primes:\n            if p < X - 1:\n                next_X = ((X - 1) // p + 1) * p\n                if next_X >= X:\n                    return next_X\n        return X\n\n    primes = list(primerange(2, X2))\n    possible_X0 = set()\n\n    for X1 in range(4, X2 + 1):\n        X2_calculated = next_move(next_move(X1, primes), primes)\n        if X2_calculated == X2:\n            for X0 in range(3, X1 + 1):\n                X1_calculated = next_move(X0, primes)\n                if X1_calculated == X1:\n                    possible_X0.add(X0)\n\n    return min(possible_X0)\n\n# Read input\nX2 = int(input())\n\n# Compute and print the output\nprint(smallest_starting_number(X2))"}
{"solution": "def min_p_binary_summands(n, p):\n    if p >= n:\n        return -1\n    if p == 0:\n        return bin(n).count('1')\n    \n    count = 0\n    while n > 0:\n        x = 1\n        while (1 << x) - p <= n:\n            x += 1\n        if x > 0:\n            n -= (1 << (x - 1)) - p\n            count += 1\n        else:\n            return -1\n    \n    return count\n\n# Reading input\nn, p = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_p_binary_summands(n, p))"}
{"solution": "def minimize_number(n, k, S):\n    # Convert S to a list of characters for easier manipulation\n    digits = list(S)\n    \n    # Initialize a variable to keep track of changes made\n    changes_made = 0\n    \n    # Iterate through each digit of S\n    for i in range(n):\n        # If we haven't used up all our changes and the current digit is not the smallest possible\n        if changes_made < k:\n            if i == 0 and digits[i] != '1':  # First digit can only be changed to '1' if not already\n                digits[i] = '1'\n                changes_made += 1\n            elif i != 0 and digits[i] != '0':  # Any other digit can be changed to '0'\n                digits[i] = '0'\n                changes_made += 1\n    \n    # If we have more changes left and the first digit is not '1', change it to '1'\n    if changes_made < k and digits[0] != '1':\n        digits[0] = '1'\n        changes_made += 1\n    \n    # Convert the list of digits back to a string\n    result = ''.join(digits)\n    \n    # Print the result\n    print(result)\n\n# Read input\nn, k = map(int, input().split())\nS = input()\n\n# Call the function with the provided input\nminimize_number(n, k, S)"}
{"solution": "import math\n\ndef lcm(a, b):\n    return abs(a * b) // math.gcd(a, b)\n\ndef find_minimum_v(cnt_1, cnt_2, x, y):\n    lcm_xy = lcm(x, y)\n    step_x = x * (lcm_xy // x)\n    step_y = y * (lcm_xy // y)\n    \n    cnt_1_lcm = (cnt_1 + (lcm_xy // x) - 1) // (lcm_xy // x)\n    cnt_2_lcm = (cnt_2 + (lcm_xy // y) - 1) // (lcm_xy // y)\n    \n    total_cnt_lcm = cnt_1_lcm + cnt_2_lcm\n    \n    return (total_cnt_lcm - 1) * lcm_xy\n\n# Reading input\ncnt_1, cnt_2, x, y = map(int, input().split())\n\n# Calculating and printing the answer\nprint(find_minimum_v(cnt_1, cnt_2, x, y))"}
{"solution": "def final_position(n, sx, sy, dx, dy, t):\n    def update_speed(dx, dy, k):\n        return dx + k, dy + k\n    \n    def next_cell(x, y, dx, dy, n):\n        return ((x + dx - 1) % n) + 1, ((y + dy - 1) % n) + 1\n    \n    current_x, current_y = sx, sy\n    current_dx, current_dy = dx, dy\n    \n    while t > 0:\n        k = current_x + current_y  # Number of bushes eaten\n        current_dx, current_dy = update_speed(current_dx, current_dy, k)\n        t -= 1  # Simulate one second\n        \n        # Calculate new position after one second\n        new_x, new_y = next_cell(current_x, current_y, current_dx, current_dy, n)\n        \n        # Adjust time remaining based on whether the bear will move again within t seconds\n        if t >= 1:\n            t -= 1\n            current_x, current_y = new_x, new_y\n        else:\n            # If t is not enough for another full second, calculate the exact position\n            steps_remaining = t\n            x_steps = (current_dx * steps_remaining) % n\n            y_steps = (current_dy * steps_remaining) % n\n            current_x = ((current_x - 1 + x_steps) % n) + 1\n            current_y = ((current_y - 1 + y_steps) % n) + 1\n            break\n    \n    return current_x, current_y\n\n# Read input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Calculate and print the final position\nresult_x, result_y = final_position(n, sx, sy, dx, dy, t)\nprint(result_x, result_y)"}
{"solution": "from collections import Counter\n\ndef is_nice_word(s):\n    # Count occurrences of each character\n    char_count = Counter(s)\n    # Check if '?' appears at least 26 times or any letter appears more than twice\n    if char_count['?'] < 26 and any(char_count[c] > 2 for c in char_count if c != '?'):\n        return -1\n    \n    # Generate a nice word if possible\n    nice_word = list(s)\n    used_letters = set()\n    question_marks = []\n    \n    for i, char in enumerate(nice_word):\n        if char == '?':\n            question_marks.append(i)\n        else:\n            used_letters.add(char)\n    \n    # Ensure all letters A-Z are present\n    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n        if letter not in used_letters:\n            for idx in question_marks:\n                if nice_word[idx] == '?':\n                    nice_word[idx] = letter\n                    used_letters.add(letter)\n                    question_marks.remove(idx)\n                    break\n    \n    # Fill remaining '?' with any letter that doesn't exceed 2 occurrences\n    for idx in question_marks:\n        for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n            if nice_word.count(letter) < 2:\n                nice_word[idx] = letter\n                break\n    \n    return ''.join(nice_word)\n\n# Read input\ns = input().strip()\n\n# Solve and print the result\nresult = is_nice_word(s)\nprint(result)"}
{"solution": "def can_divide_apples(n, weights):\n    total_weight = sum(weights)\n    # If the total weight is odd, it's impossible to divide equally\n    if total_weight % 2 != 0:\n        return \"NO\"\n    \n    # Count the number of 100g and 200g apples\n    count_100 = weights.count(100)\n    count_200 = weights.count(200)\n    \n    # If the total weight is even, check if it's possible to divide\n    if total_weight % 100 == 0:\n        # If all apples are 100g, it's always possible\n        if count_200 == 0:\n            return \"YES\"\n        # If there are more than 2 200g apples, it's possible\n        if count_200 > 2:\n            return \"YES\"\n        # If there are exactly 2 200g apples, check if there are at least 2 100g apples\n        if count_200 == 2 and count_100 >= 2:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\nweights = list(map(int, input().split()))\n\n# Output result\nprint(can_divide_apples(n, weights))"}
{"solution": "def min_time_to_turn_off_lights():\n    import sys\n    from functools import lru_cache\n\n    input = sys.stdin.read\n    data = input().split()\n    n, m = map(int, data[0:2])\n    building = ['0' * (m + 2)] + [s + '0' for s in data[2:n + 2]] + ['0' * (m + 2)]\n\n    @lru_cache(maxsize=None)\n    def dp(floor, side):\n        if floor == n + 1:\n            return 0\n        result = float('inf')\n        for room in range(1, m + 1):\n            if building[floor][room] == '1':\n                cost = room if side == 'left' else m + 1 - room\n                result = min(result, cost + dp(floor + 1, 'left') + dp(floor + 1, 'right'))\n        return result\n\n    return dp(1, 'left')\n\nprint(min_time_to_turn_off_lights())"}
{"solution": "from collections import defaultdict\n\ndef find_min_trap_cost(n, costs, transitions):\n    visited = [False] * n\n    in_stack = [False] * n\n    min_cost = 0\n\n    def dfs(node, cycle_costs):\n        nonlocal in_stack, visited\n        if visited[node]:\n            if in_stack[node]:\n                # Found a cycle, calculate the minimum cost in this cycle\n                return min(cycle_costs)\n            return float('inf')\n        visited[node] = True\n        in_stack[node] = True\n        cycle_costs.append(costs[node])\n        next_node = transitions[node] - 1\n        min_cost = dfs(next_node, cycle_costs)\n        in_stack[node] = False\n        cycle_costs.pop()\n        return min_cost\n\n    for i in range(n):\n        if not visited[i]:\n            min_cost += dfs(i, [])\n\n    return min_cost\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(find_min_trap_cost(n, costs, transitions))"}
{"solution": "n, a, b = map(int, input().split())\nresult = (a + b - 1) % n + 1\nprint(result)"}
{"solution": "from typing import List, Tuple\n\ndef min_arithmetic_progressions(n: int, sequence: List[int]) -> int:\n    def is_arithmetic(start: int, end: int, step: int) -> bool:\n        return (end - start) % step == 0\n\n    def extend_progression(start: int, end: int, step: int, index: int) -> Tuple[bool, int]:\n        if end != -1:\n            if is_arithmetic(start, end, step):\n                return True, step\n            else:\n                return False, 0\n        else:\n            # Calculate the possible value for the missing element\n            possible_value = start + step\n            sequence[index] = possible_value\n            return True, step\n\n    count = 0\n    i = 0\n    while i < n:\n        if sequence[i] == -1:\n            count += 1\n            i += 1\n            continue\n\n        if i + 1 < n and sequence[i + 1] != -1:\n            diff = sequence[i + 1] - sequence[i]\n            valid, _ = extend_progression(sequence[i], sequence[i + 1], diff, i + 1)\n            j = i + 2\n            while j < n:\n                if sequence[j] != -1:\n                    valid, diff = extend_progression(sequence[i], sequence[j], diff, j)\n                    if not valid:\n                        break\n                j += 1\n            if valid:\n                count += 1\n                i = j\n            else:\n                count += 1\n                i += 1\n        else:\n            count += 1\n            i += 1\n\n    return count\n\n# Read input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Print output\nprint(min_arithmetic_progressions(n, sequence))"}
{"solution": "def max_beauty(n, k, s):\n    left, max_length, changes = 0, 0, 0\n    char_count = {'a': 0, 'b': 0}\n\n    for right in range(n):\n        char_count[s[right]] += 1\n        max_char = max(char_count['a'], char_count['b'])\n        changes = right - left + 1 - max_char\n\n        while changes > k:\n            char_count[s[left]] -= 1\n            left += 1\n            max_char = max(char_count['a'], char_count['b'])\n            changes = right - left + 1 - max_char\n\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n\n# Reading input\nn, k = map(int, input().split())\ns = input()\n\n# Calculating and printing the result\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, seats):\n    alice_seats = seats[0]\n    total_seats = sum(seats)\n    majority = total_seats // 2 + 1\n    coalition_seats = alice_seats\n    coalition = [1]\n\n    for i in range(1, n):\n        if alice_seats >= 2 * seats[i]:\n            coalition_seats += seats[i]\n            coalition.append(i + 1)\n\n        if coalition_seats >= majority:\n            break\n\n    if coalition_seats < majority:\n        print(0)\n    else:\n        print(len(coalition))\n        print(' '.join(map(str, coalition)))\n\n# Read input\nn = int(input())\nseats = list(map(int, input().split()))\n\n# Solve and print output\nfind_coalition(n, seats)"}
{"solution": "def max_reward(n):\n    harmonic_sum = 0.0\n    for i in range(1, n + 1):\n        harmonic_sum += 1.0 / i\n    return harmonic_sum\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the maximum reward\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "def max_children_candies(n):\n    k = 1\n    while k * (k + 1) // 2 <= n:\n        k += 1\n    k -= 1\n    \n    candies_distribution = [i for i in range(1, k + 1)]\n    remaining_candies = n - sum(candies_distribution)\n    \n    if remaining_candies > 0:\n        candies_distribution[-1] += remaining_candies\n    \n    return k, candies_distribution\n\nn = int(input())\nk, candies_distribution = max_children_candies(n)\nprint(k)\nprint(' '.join(map(str, candies_distribution)))"}
{"solution": "# Reading input\nn = int(input())\nm = int(input())\n\n# Calculating m mod 2^n\nresult = m % (2 ** n)\n\n# Printing the output\nprint(result)"}
{"solution": "def correct_word(s):\n    vowels = 'aeiouy'\n    i = 0\n    while i < len(s) - 1:\n        if s[i] in vowels and s[i + 1] in vowels:\n            s = s[:i] + s[i + 1:]\n        else:\n            i += 1\n    return s\n\nn = int(input())\ns = input()\nprint(correct_word(s))"}
{"solution": "def max_students(n, a, b, seats):\n    segments = []\n    i = 0\n    \n    # Identify segments of empty seats\n    while i < n:\n        if seats[i] == '.':\n            start = i\n            while i < n and seats[i] == '.':\n                i += 1\n            segments.append(i - start)\n        else:\n            i += 1\n    \n    total_students = 0\n    \n    # Place students in each segment\n    for length in segments:\n        # Calculate the number of students that can be placed in this segment\n        # We will place students in an alternating fashion\n        if length % 2 == 0:\n            # Even length: alternate perfectly\n            programmers = athletes = length // 2\n        else:\n            # Odd length: one more programmer or athlete\n            programmers = athletes = length // 2\n            if a >= b:\n                programmers += 1\n            else:\n                athletes += 1\n        \n        # Place the students\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n        \n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n    \n    return total_students\n\n# Example usage\nn, a, b = map(int, input().split())\nseats = input()\nprint(max_students(n, a, b, seats))"}
{"solution": "from math import sqrt\n\ndef find_pair(r):\n    for x in range(1, int(sqrt(r)) + 1):\n        h_x = x**2 + x + 1\n        if r >= h_x:\n            delta = 1 + 4 * (r - h_x)\n            if delta >= 0:\n                y = (-1 + sqrt(delta)) / 2\n                if y.is_integer():\n                    return x, int(y)\n    return \"NO\"\n\n# Read input\nr = int(input())\n\n# Calculate and print the result\nresult = find_pair(r)\nprint(*result)"}
{"solution": "def can_divide_balloons(n, a):\n    total_balloons = sum(a)\n    for k in range(1, n):\n        for mask in range(1 << n):\n            if bin(mask).count('1') == k:\n                grigory_sum = sum(a[i] for i in range(n) if mask & (1 << i))\n                andrew_sum = total_balloons - grigory_sum\n                if grigory_sum != andrew_sum:\n                    grigory_indices = [i + 1 for i in range(n) if mask & (1 << i)]\n                    return k, grigory_indices\n    return -1\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Solve and print output\nresult = can_divide_balloons(n, a)\nif result == -1:\n    print(-1)\nelse:\n    k, indices = result\n    print(k)\n    print(*indices)"}
{"solution": "def min_different_digits(n):\n    # Calculate the minimal number of different digits\n    if n % 9 == 0:\n        k = 1\n    else:\n        k = n % 9\n    \n    # Determine the number of digits k\n    num_digits = n // 9 + (1 if k > 0 else 0)\n    \n    # Generate the output list\n    digits = [9] * (n // 9)\n    if k > 0:\n        digits.append(k)\n    \n    return num_digits, digits\n\n# Read input\nn = int(input())\n\n# Calculate and print the result\nnum_digits, digits = min_different_digits(n)\nprint(num_digits)\nprint(*digits)"}
{"solution": "from itertools import combinations\nfrom math import sqrt\n\ndef is_prime(num):\n    if num <= 1:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(sqrt(num)) + 1, 2):\n        if num % i == 0:\n            return False\n    return True\n\ndef find_max_simple_subset(arr):\n    max_size = 0\n    max_subset = []\n    \n    for r in range(1, len(arr) + 1):\n        for subset in combinations(arr, r):\n            if all(is_prime(x + y) for x, y in combinations(subset, 2)):\n                if len(subset) > max_size:\n                    max_size = len(subset)\n                    max_subset = list(subset)\n    \n    return max_size, max_subset\n\nn = int(input())\na = list(map(int, input().split()))\n\nmax_size, max_subset = find_max_simple_subset(a)\n\nprint(max_size)\nprint(' '.join(map(str, max_subset)))"}
{"solution": "def greatest_beautiful_divisor(n):\n    max_divisor = 0\n    k = 1\n    while True:\n        beautiful_number = (2**k - 1) * (2**k)\n        if beautiful_number > n:\n            break\n        if n % beautiful_number == 0:\n            max_divisor = beautiful_number\n        k += 1\n    return max_divisor\n\nn = int(input())\nprint(greatest_beautiful_divisor(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef multiply_mod(a, b):\n    return (a * b) % MOD\n\ndef power_mod(a, b):\n    result = 1\n    while b > 0:\n        if b & 1:\n            result = multiply_mod(result, a)\n        a = multiply_mod(a, a)\n        b >>= 1\n    return result\n\ndef count_d_magic(m, d, a, b):\n    a_len = len(str(a))\n    b_len = len(str(b))\n    \n    if a_len != b_len:\n        return 0\n    \n    dp = [[0] * 2 for _ in range(a_len + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, a_len + 1):\n        for j in range(2):\n            for k in range(10):\n                ni = i + 1\n                nj = j or k > 0\n                if (i % 2 == 1 and k == d) or (i % 2 == 0 and k != d):\n                    continue\n                dp[ni][nj] = (dp[ni][nj] + dp[i][j]) % MOD\n    \n    result = 0\n    for i in range(a_len):\n        for j in range(2):\n            if (i % 2 == 1 and d == 0) or (i % 2 == 0 and d != 0):\n                continue\n            if int(str(b)[i]) >= d:\n                result = (result + dp[i + 1][j]) % MOD\n            if int(str(a)[i]) > d:\n                result = (result + dp[i + 1][j]) % MOD\n            elif int(str(a)[i]) == d:\n                result = (result + dp[i + 1][j and 1]) % MOD\n    \n    return (result * power_mod(power_mod(5, m), MOD - 2)) % MOD\n\n# Reading input\nm, d = map(int, input().split())\na = int(input())\nb = int(input())\n\n# Calculating and printing the result\nprint(count_d_magic(m, d, a, b))"}
{"solution": "def last_child_home(n, m, candies_needed):\n    queue = list(range(1, n + 1))\n    while queue:\n        child = queue.pop(0)\n        candies_needed[child - 1] -= m\n        if candies_needed[child - 1] > 0:\n            queue.append(child)\n        else:\n            last_child = child\n    return last_child\n\n# Reading input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(last_child_home(n, m, a))"}
{"solution": "def min_bills(n):\n    denominations = [100, 20, 10, 5, 1]\n    count = 0\n    for denom in denominations:\n        count += n // denom\n        n %= denom\n    return count\n\n# Read input\nn = int(input())\n\n# Calculate and print the output\nprint(min_bills(n))"}
{"solution": "MOD = 1000000007\n\ndef factorial(n):\n    \"\"\"Compute factorial of n modulo MOD.\"\"\"\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n    return fact\n\ndef inverse_factorial(n, fact):\n    \"\"\"Compute modular inverse of factorial of n.\"\"\"\n    inv_fact = [1] * (n + 1)\n    inv_fact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 1, -1):\n        inv_fact[i - 1] = (inv_fact[i] * i) % MOD\n    return inv_fact\n\ndef comb(n, k, fact, inv_fact):\n    \"\"\"Compute binomial coefficient C(n, k) modulo MOD.\"\"\"\n    return (fact[n] * inv_fact[k] * inv_fact[n - k]) % MOD\n\ndef count_permutations(n, k):\n    \"\"\"Count the number of permutations of size n with exactly k good positions.\"\"\"\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    fact = factorial(n)\n    inv_fact = inverse_factorial(n, fact)\n    \n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(min(i, k) + 1):\n            dp[i][j] = dp[i - 1][j] * (i - 1) % MOD\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1] * (i - 1) % MOD\n            dp[i][j] %= MOD\n    \n    result = 0\n    for bad in range(k + 1):\n        good = k - bad\n        if (n - k) % 2 == bad % 2:\n            result += comb(n - k, bad, fact, inv_fact) * dp[n - bad][good] % MOD\n        else:\n            result -= comb(n - k, bad, fact, inv_fact) * dp[n - bad][good] % MOD\n        result %= MOD\n    \n    return (result + MOD) % MOD\n\n# Read input\nn, k = map(int, input().split())\n\n# Compute and print the result\nprint(count_permutations(n, k))"}
{"solution": "from collections import defaultdict\nimport heapq\n\ndef max_beauty_bouquet(n, k, beauties, colors):\n    color_count = defaultdict(int)\n    color_beauty = defaultdict(list)\n    \n    # Count roses by color and store their beauties\n    for beauty, color in zip(beauties, colors):\n        color_count[color] += 1\n        heapq.heappush(color_beauty[color], beauty)\n        if len(color_beauty[color]) > color_count[color]:\n            heapq.heappop(color_beauty[color])\n    \n    # Check if it's impossible to form a bouquet\n    if len(color_count) == 1 or (len(color_count) == 2 and ('W' in color_count and 'R' in color_count)):\n        return -1\n    \n    # Calculate the maximum beauty for k roses\n    max_beauty = -1\n    for color1 in ['W', 'O', 'R']:\n        for color2 in ['W', 'O', 'R']:\n            if color1 == color2 or (color1 == 'W' and color2 == 'R') or (color1 == 'R' and color2 == 'W'):\n                continue\n            \n            count1 = min(k, color_count[color1])\n            count2 = k - count1\n            \n            if count2 > color_count[color2]:\n                continue\n            \n            beauty1 = sum(heapq.nlargest(count1, color_beauty[color1]))\n            beauty2 = sum(heapq.nlargest(count2, color_beauty[color2]))\n            \n            max_beauty = max(max_beauty, beauty1 + beauty2)\n    \n    return max_beauty\n\n# Read input\nn, k = map(int, input().split())\nbeauties = list(map(int, input().split()))\ncolors = input()\n\n# Compute and print the result\nprint(max_beauty_bouquet(n, k, beauties, colors))"}
{"solution": "import sys\n\ndef continued_fraction_to_rational(a):\n    n = len(a)\n    if n == 1:\n        return (a[0], 1)\n    p1, q1 = a[n - 1], 1\n    p2, q2 = 1, 0\n    for i in range(n - 2, -1, -1):\n        temp = p1\n        p1 = a[i] * p1 + p2\n        p2 = temp\n        temp = q1\n        q1 = a[i] * q1 + q2\n        q2 = temp\n    return (p1, q1)\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef simplify_fraction(p, q):\n    g = gcd(p, q)\n    return (p // g, q // g)\n\ndef check_equal(p1, q1, p2, q2):\n    p1, q1 = simplify_fraction(p1, q1)\n    p2, q2 = simplify_fraction(p2, q2)\n    return p1 * q2 == p2 * q1\n\np, q = map(int, input().split())\nn = int(input())\na = list(map(int, input().split()))\n\np2, q2 = continued_fraction_to_rational(a)\nresult = \"YES\" if check_equal(p, q, p2, q2) else \"NO\"\nprint(result)"}
{"solution": "def shift_stick(expression):\n    parts = expression.split('+=')\n    a_sticks = parts[0]\n    b_sticks = parts[1].split('=')[0]\n    c_sticks = parts[1].split('=')[1]\n\n    a = len(a_sticks)\n    b = len(b_sticks)\n    c = len(c_sticks)\n\n    # Check if the expression is already correct\n    if a + b == c:\n        return f\"{a_sticks}+{b_sticks}={c_sticks}\"\n\n    # Try shifting one stick from C to A\n    if a + 1 + b == c - 1:\n        return f\"{a_sticks + '|' }+{b_sticks}={c_sticks[:-1]}\"\n\n    # Try shifting one stick from A to C\n    if a - 1 + b == c + 1:\n        return f\"{a_sticks[:-1]}+{b_sticks}={c_sticks + '|'}\"\n\n    # Try shifting one stick from B to C\n    if a + b - 1 == c + 1:\n        return f\"{a_sticks}+{b_sticks[:-1]}={c_sticks + '|'}\"\n\n    # Try shifting one stick from C to B\n    if a + b + 1 == c - 1:\n        return f\"{a_sticks}+{b_sticks + '|'}={c_sticks[:-1]}\"\n\n    return \"Impossible\"\n\n# Read input\nexpression = input().strip()\n\n# Solve and print the result\nprint(shift_stick(expression))"}
{"solution": "from itertools import permutations\n\nMOD = 10**9 + 7\n\ndef calculate_oddness(p):\n    return sum(abs(i + 1 - x) for i, x in enumerate(p))\n\ndef solve(n, k):\n    valid_permutations = 0\n    all_perms = list(permutations(range(1, n + 1)))\n    \n    for perm in all_perms:\n        if calculate_oddness(perm) == k:\n            valid_permutations += 1\n    \n    return valid_permutations % MOD\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "from itertools import product\n\ndef solve(N, points):\n    # Check if it's possible to reach all points with a single section\n    if any(x == 0 and y != 0 or y == 0 and x != 0 for x, y in points):\n        return -1\n\n    # Generate all possible combinations of modes for up to 40 sections\n    for m in range(1, 41):\n        for ds in product([1, -1], repeat=m):\n            for us in product([1, -1], repeat=m):\n                # Generate all possible positions for each combination\n                pos = set()\n                for modes in product('LRDU', repeat=m):\n                    x, y = 0, 0\n                    for i, mode in enumerate(modes):\n                        if mode == 'L':\n                            x -= abs(ds[i])\n                        elif mode == 'R':\n                            x += abs(ds[i])\n                        elif mode == 'D':\n                            y -= abs(us[i])\n                        elif mode == 'U':\n                            y += abs(us[i])\n                    pos.add((x, y))\n\n                # Check if all target points can be reached\n                if all(point in pos for point in points):\n                    d = [abs(d) for d in ds]\n                    ways = []\n                    for x, y in points:\n                        way = ''\n                        for i in range(m):\n                            if x < 0:\n                                x += abs(ds[i])\n                                way += 'L'\n                            else:\n                                x -= abs(ds[i])\n                                way += 'R'\n                            if y < 0:\n                                y += abs(us[i])\n                                way += 'D'\n                            else:\n                                y -= abs(us[i])\n                                way += 'U'\n                        ways.append(way)\n                    return m, d, ways\n\n    return -1\n\n# Read input\nN = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Solve and print output\nresult = solve(N, points)\nif result == -1:\n    print(-1)\nelse:\n    m, d, ways = result\n    print(m)\n    print(' '.join(map(str, d)))\n    for way in ways:\n        print(way)"}
{"solution": "n = int(input())\ns = input()\n\ndef replace_fillers(s):\n    i = 0\n    while i < len(s):\n        if s[i:i+3] == 'ogo':\n            k = 0\n            while s[i:i+3*(k+1)] == 'ogo' * (k+1):\n                k += 1\n            s = s[:i] + '*'*3 + s[i+3*k:]\n            i += 3\n        else:\n            i += 1\n    return s\n\nresult = replace_fillers(s)\nprint(result)"}
{"solution": "from math import sqrt\n\nMOD = 10**9 + 7\n\n# Sieve of Eratosthenes to find primes up to sqrt(x)\ndef sieve(limit):\n    limitn = limit+1\n    primes = dict()\n    for ind, val in enumerate([True] * limitn): primes[ind] = val\n\n    primes[0] = primes[1] = False\n\n    for ind, val in enumerate(primes):\n        if val is True:\n            primes[ind*2::ind] = [False] * (((limit - ind)//ind) + 1)\n    return primes\n\ndef prime_factors(n):\n    factors = set()\n    for i in range(2, int(sqrt(n)) + 1):\n        while n % i == 0:\n            factors.add(i)\n            n //= i\n    if n > 1:\n        factors.add(n)\n    return factors\n\ndef g(y, p):\n    k = 0\n    while y % p == 0:\n        y //= p\n        k += 1\n    return p ** k\n\ndef f(x, y):\n    product = 1\n    for p in prime_factors(x):\n        product *= g(y, p)\n        product %= MOD\n    return product\n\ndef solve(x, n):\n    result = 1\n    factors = prime_factors(x)\n    for p in factors:\n        power_sum = 0\n        current_n = 1\n        while current_n <= n:\n            power_sum += n // current_n\n            current_n *= p\n        result *= p ** power_sum\n        result %= MOD\n    return result\n\n# Read input\nx, n = map(int, input().split())\n\n# Solve and print the result\nprint(solve(x, n))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for s in range(1, 82):  # s(x) can be at most 81\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and sum_of_digits(x) == s:\n            solutions.append(x)\n    solutions.sort()\n    return solutions\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find solutions\nsolutions = find_solutions(a, b, c)\n\n# Print results\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "from collections import Counter\n\ndef is_solvable_with_one_rotation(colors):\n    # Count the frequency of each color\n    color_counts = Counter(colors)\n    \n    # Check if each color appears exactly 4 times\n    if any(count != 4 for count in color_counts.values()):\n        return \"NO\"\n    \n    # Define the positions of each face\n    faces = [\n        {0, 1, 2, 3},  # Top face\n        {4, 5, 6, 7},  # Bottom face\n        {8, 9, 10, 11},  # Left face\n        {12, 13, 14, 15},  # Right face\n        {0, 4, 8, 12},  # Front face\n        {2, 6, 10, 14}  # Back face\n    ]\n    \n    # Check if any face can be rotated to solve the cube\n    for face in faces:\n        if len(set(colors[i] for i in face)) == 1:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\ncolors = list(map(int, input().split()))\n\n# Print the result\nprint(is_solvable_with_one_rotation(colors))"}
{"solution": "def find_min_hacks(p, x, y):\n    def simulate(s):\n        i = (s // 50) % 475\n        for _ in range(25):\n            if 26 + i == p:\n                return True\n            i = (i * 96 + 42) % 475\n        return False\n\n    min_hacks = float('inf')\n    for s in range(y, 20001):\n        if simulate(s):\n            diff = s - x\n            successful_hacks = (diff + 50 - 1) // 150  # (successful * 100) - (unsuccessful * 50)\n            unsuccessful_hacks = (diff - successful_hacks * 100) // 50\n            min_hacks = min(min_hacks, successful_hacks)\n\n    return min_hacks\n\np, x, y = map(int, input().split())\nprint(find_min_hacks(p, x, y))"}
{"solution": "def min_distance(n, a, b, c):\n    if n == 1:\n        return 0\n    \n    # Initialize the current position and total distance\n    current_position = 'Rabbit'\n    total_distance = 0\n    \n    # Dictionary to represent the distances between houses\n    distances = {\n        ('Rabbit', 'Owl'): a,\n        ('Rabbit', 'Eeyore'): b,\n        ('Owl', 'Eeyore'): c,\n        ('Owl', 'Rabbit'): a,\n        ('Eeyore', 'Rabbit'): b,\n        ('Eeyore', 'Owl'): c\n    }\n    \n    # Determine the minimum distance for the first move\n    min_first_move = min(a, b)\n    \n    # Update the total distance and the current position after the first move\n    total_distance += min_first_move\n    if min_first_move == a:\n        current_position = 'Owl'\n    else:\n        current_position = 'Eeyore'\n    \n    # Calculate the remaining moves\n    for _ in range(2, n):\n        if current_position == 'Owl':\n            total_distance += min(a, c)\n            current_position = 'Rabbit' if min(a, c) == a else 'Eeyore'\n        elif current_position == 'Eeyore':\n            total_distance += min(b, c)\n            current_position = 'Rabbit' if min(b, c) == b else 'Owl'\n        else:  # current_position == 'Rabbit'\n            total_distance += min(a, b)\n            current_position = 'Owl' if min(a, b) == a else 'Eeyore'\n    \n    return total_distance\n\n# Read input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate and print the result\nprint(min_distance(n, a, b, c))"}
{"solution": "# Importing necessary functionality\nfrom typing import List\n\ndef min_total_distance(x: List[int]) -> int:\n    \"\"\"\n    Calculates the minimum total distance the friends need to travel to meet at one point.\n    \n    Parameters:\n    x (List[int]): A list containing the coordinates of the houses of the three friends.\n    \n    Returns:\n    int: The minimum total distance the friends need to travel.\n    \"\"\"\n    # Sort the coordinates to find the median\n    x.sort()\n    # The optimal meeting point is at the middle coordinate\n    meeting_point = x[1]\n    # Calculate the total distance by summing the absolute differences\n    total_distance = sum(abs(meeting_point - xi) for xi in x)\n    return total_distance\n\n# Reading input\nx = list(map(int, input().split()))\n\n# Calculating and printing the output\nprint(min_total_distance(x))"}
{"solution": "def min_operations(n, x, arr):\n    # Track occurrences of each element\n    count = {}\n    for num in arr:\n        count[num] = count.get(num, 0) + 1\n    \n    # Check if there are already at least two equal elements\n    for val in count.values():\n        if val >= 2:\n            return 0\n    \n    # Check if it's possible to make two elements equal using the bitwise AND operation\n    for num in arr:\n        new_num = num & x\n        if new_num in count:\n            return 1\n    \n    # Check if there's a common bit between any element and x\n    common_bit = False\n    for bit in range(20):  # Assuming the maximum value of elements is 100,000\n        if (x >> bit) & 1:\n            found = False\n            for num in arr:\n                if (num >> bit) & 1:\n                    found = True\n                    break\n            if found:\n                common_bit = True\n                break\n    \n    # If no common bit is found, it's impossible\n    if not common_bit:\n        return -1\n    \n    # Otherwise, it's possible with at most 2 operations\n    return 2\n\n# Read input\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Output result\nprint(min_operations(n, x, arr))"}
{"solution": "def is_plus_shape(picture):\n    h, w = len(picture), len(picture[0])\n    centers = []\n\n    # Find potential center points\n    for i in range(h):\n        for j in range(w):\n            if picture[i][j] == '*':\n                centers.append((i, j))\n\n    # Check if a center is valid\n    def is_valid_center(i, j):\n        # Check up, down, left, right\n        up, down, left, right = True, True, True, True\n        for k in range(1, max(i, h - 1 - i, j, w - 1 - j) + 1):\n            if i - k < 0 or picture[i - k][j] != '*': up = False\n            if i + k >= h or picture[i + k][j] != '*': down = False\n            if j - k < 0 or picture[i][j - k] != '*': left = False\n            if j + k >= w or picture[i][j + k] != '*': right = False\n            if not (up and down and left and right): break\n        return up and down and left and right\n\n    # Verify the shape\n    valid_centers = [center for center in centers if is_valid_center(*center)]\n    if len(valid_centers) != 1:\n        return \"NO\"\n\n    # Check for extra '*' outside the plus shape\n    center_i, center_j = valid_centers[0]\n    for i in range(h):\n        for j in range(w):\n            if picture[i][j] == '*' and not (\n                (i == center_i and abs(j - center_j) <= abs(center_i - center_i)) or\n                (j == center_j and abs(i - center_i) <= abs(center_j - center_j))\n            ):\n                return \"NO\"\n\n    return \"YES\"\n\n# Read input\nh, w = map(int, input().split())\npicture = [input() for _ in range(h)]\n\n# Output result\nprint(is_plus_shape(picture))"}
{"solution": "def find_adjacency_matrix(n, a, b):\n    # Check if the problem has a valid solution\n    if a + b - 1 != n:\n        print(\"NO\")\n        return\n    \n    print(\"YES\")\n    \n    # Initialize the adjacency matrix\n    adj_matrix = [[0] * n for _ in range(n)]\n    \n    # Create 'a' connected components in the graph\n    start = 0\n    while a > 1:\n        for i in range(start, start + 1):\n            for j in range(i + 1, start + 1):\n                adj_matrix[i][j] = 1\n                adj_matrix[j][i] = 1\n        start += 1\n        a -= 1\n    \n    # Create 'b' connected components in the complement graph\n    while b > 1:\n        for i in range(start, start + 1):\n            for j in range(i + 1, start + 1):\n                adj_matrix[i][j] = 0\n                adj_matrix[j][i] = 0\n        start += 1\n        b -= 1\n    \n    # Print the adjacency matrix\n    for row in adj_matrix:\n        print(''.join(map(str, row)))\n\n# Example usage\nn, a, b = map(int, input().split())\nfind_adjacency_matrix(n, a, b)"}
{"solution": "def min_problems_needed(c, d, n, m, k):\n    # Calculate the number of people needed to go to the finals\n    people_needed = n * m - k\n    \n    # If no more people are needed, return 0\n    if people_needed <= 0:\n        return 0\n    \n    # Calculate the minimum number of problems using main rounds\n    main_rounds = -(-people_needed // n)  # Ceiling division\n    problems_with_main_rounds = main_rounds * c\n    \n    # Calculate the minimum number of problems using additional rounds\n    additional_rounds = people_needed\n    problems_with_additional_rounds = additional_rounds * d\n    \n    # Return the minimum of the two options\n    return min(problems_with_main_rounds, problems_with_additional_rounds)\n\n# Read input\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\n# Calculate and print the result\nprint(min_problems_needed(c, d, n, m, k))"}
{"solution": "from collections import Counter\n\ndef find_grid_path(s):\n    # Count occurrences of each character\n    char_count = Counter(s)\n    \n    # Check if each letter occurs at least once\n    if len(char_count) != 26:\n        return \"Impossible\"\n    \n    # Initialize the grid\n    grid = [['' for _ in range(13)] for _ in range(2)]\n    \n    # Mapping of letters to positions\n    position_map = {}\n    index = 0\n    \n    # Fill the grid\n    for i in range(2):\n        for j in range(13):\n            while char_count[s[index]] == 1 and (index in position_map or index + 13 in position_map):\n                index += 1\n            position_map[index] = (i, j)\n            grid[i][j] = s[index]\n            char_count[s[index]] -= 1\n            index += 1\n            \n    # Verify the path\n    for i in range(26):\n        current_pos = position_map[i]\n        next_pos = position_map[i + 1]\n        \n        if abs(current_pos[0] - next_pos[0]) + abs(current_pos[1] - next_pos[1]) > 1:\n            return \"Impossible\"\n    \n    # Format and return the grid\n    return '\\n'.join([''.join(row) for row in grid])\n\n# Read input\ns = input().strip()\n\n# Generate and print the output\nprint(find_grid_path(s))"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<' if y > 1 else '='\n    elif y == 1:\n        return '>' if x > 1 else '='\n    else:\n        # Compute y * log(x) and x * log(y)\n        lhs = y * math.log(x)\n        rhs = x * math.log(y)\n        \n        if lhs < rhs:\n            return '<'\n        elif lhs > rhs:\n            return '>'\n        else:\n            return '='\n\n# Read input\nx, y = map(int, input().split())\n\n# Output the result of the comparison\nprint(compare_powers(x, y))"}
{"solution": "import math\n\ndef max_balloons(r, h):\n    # Calculate the number of balloons that can fit vertically\n    vertical_balloons = h // (r / 2)\n    \n    # Calculate the total number of balloons by adding the ones that can fit horizontally\n    # One in the middle (if possible) and two on the sides\n    if h >= r:\n        total_balloons = 2 + vertical_balloons\n    else:\n        total_balloons = vertical_balloons\n    \n    return total_balloons\n\n# Read input\nr, h = map(int, input().split())\n\n# Calculate and print the result\nprint(max_balloons(r, h))"}
{"solution": "from collections import Counter\n\ndef min_remaining_sum(cards):\n    card_counts = Counter(cards)\n    possible_to_discard = [num for num, count in card_counts.items() if count >= 2]\n    \n    min_sum = sum(cards)\n    for num in possible_to_discard:\n        # Discard two cards\n        new_sum = min_sum - 2 * num\n        min_sum = min(min_sum, new_sum)\n        \n        if card_counts[num] >= 3:\n            # Discard three cards if possible\n            new_sum = min_sum - num\n            min_sum = min(min_sum, new_sum)\n    \n    return min_sum\n\n# Read input\ncards = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_remaining_sum(cards))"}
{"solution": "def min_distance(n, a, checkpoints):\n    checkpoints.sort()\n    start_index = 0\n    for i, checkpoint in enumerate(checkpoints):\n        if checkpoint < a:\n            start_index = i + 1\n        else:\n            break\n    \n    left_distance = abs(a - checkpoints[start_index - 1]) if start_index > 0 else float('inf')\n    right_distance = abs(a - checkpoints[start_index]) if start_index < n else float('inf')\n    \n    if start_index == 0:\n        return sum(abs(checkpoints[i] - checkpoints[i + 1]) for i in range(n - 1))\n    elif start_index == n:\n        return sum(abs(checkpoints[i] - checkpoints[i + 1]) for i in range(n - 1))\n    else:\n        total_distance = float('inf')\n        # Visit left first\n        distance_left_first = left_distance\n        for i in range(start_index - 1, 0, -1):\n            distance_left_first += abs(checkpoints[i] - checkpoints[i - 1])\n        distance_left_first += abs(checkpoints[0] - checkpoints[-1])\n        for i in range(start_index, n - 1):\n            distance_left_first += abs(checkpoints[i] - checkpoints[i + 1])\n        \n        # Visit right first\n        distance_right_first = right_distance\n        for i in range(start_index, n - 1):\n            distance_right_first += abs(checkpoints[i] - checkpoints[i + 1])\n        distance_right_first += abs(checkpoints[-1] - checkpoints[0])\n        for i in range(start_index - 1, 0, -1):\n            distance_right_first += abs(checkpoints[i] - checkpoints[i - 1])\n        \n        total_distance = min(distance_left_first, distance_right_first)\n        \n        return total_distance\n\n# Read input\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_distance(n, a, checkpoints))"}
{"solution": "import sys\n\ndef s(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_smallest_root(n):\n    for x in range(1, min(int(n**0.5) + 1000000, 10**10)):\n        if x**2 + s(x) * x - n == 0:\n            return x\n    return -1\n\n# Read input\nn = int(input())\n\n# Solve and print output\nprint(find_smallest_root(n))"}
{"solution": "from datetime import datetime, timedelta\n\ndef calculate_bed_time(current_time_str, sleep_duration_str):\n    # Convert strings to datetime objects\n    current_time = datetime.strptime(current_time_str, \"%H:%M\")\n    sleep_duration = datetime.strptime(sleep_duration_str, \"%H:%M\")\n    \n    # Calculate the bedtime by subtracting sleep duration from current time\n    bedtime = current_time - sleep_duration\n    \n    # Adjust for crossing midnight\n    if bedtime.hour < 0:\n        bedtime = datetime.strptime(\"24:00\", \"%H:%M\") + bedtime\n    \n    # Format and return the bedtime as a string\n    return bedtime.strftime(\"%H:%M\")\n\n# Read input\ncurrent_time_str = input()\nsleep_duration_str = input()\n\n# Calculate and print the bedtime\nprint(calculate_bed_time(current_time_str, sleep_duration_str))"}
{"solution": "from itertools import accumulate\n\ndef find_longest_subsegment_with_max_mean(n, a):\n    # Calculate prefix sums\n    prefix_sums = [0] + list(accumulate(a))\n    \n    # Initialize variables to track the maximum mean and the corresponding segment length\n    max_mean = -1\n    max_length = 0\n    \n    # Use a dictionary to keep track of the minimum prefix sum index for a given \"adjusted\" sum\n    adjusted_sum_indices = {}\n    \n    for r in range(1, n + 1):\n        for l in range(r):\n            # Calculate the current mean\n            current_mean = (prefix_sums[r] - prefix_sums[l]) / (r - l)\n            \n            # Update max_mean and max_length if the current mean is greater than max_mean\n            if current_mean > max_mean:\n                max_mean = current_mean\n                max_length = r - l\n                break  # Move to the next right index since we found a better mean\n            \n            # Adjust the sum to use it as a key for tracking minimum indices\n            adjusted_sum = prefix_sums[r] - current_mean * (r - l)\n            \n            # If this adjusted sum has not been seen before, store the left index\n            if adjusted_sum not in adjusted_sum_indices:\n                adjusted_sum_indices[adjusted_sum] = l\n    \n    # Find the longest subsegment with the maximum mean\n    for r in range(n, 0, -1):\n        for l in range(r):\n            current_mean = (prefix_sums[r] - prefix_sums[l]) / (r - l)\n            if current_mean == max_mean:\n                adjusted_sum = prefix_sums[r] - current_mean * (r - l)\n                if adjusted_sum in adjusted_sum_indices and adjusted_sum_indices[adjusted_sum] == l:\n                    return r - l + 1\n    \n    return max_length\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the output\nprint(find_longest_subsegment_with_max_mean(n, a))"}
{"solution": "MOD = 998244353\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef preprocess(n):\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n        invfact[i] = modinv(fact[i])\n    return fact, invfact\n\ndef comb(n, k, fact, invfact):\n    return fact[n] * invfact[k] * invfact[n - k] % MOD\n\ndef count_ways(n, m, k):\n    fact, invfact = preprocess(n)\n    result = 0\n    for i in range(k + 1):\n        ways = comb(k, i, fact, invfact) * comb(n - 1, k - i, fact, invfact) % MOD\n        ways = ways * pow(m - 1, k - i, MOD) % MOD\n        ways = ways * m % MOD\n        result = (result + ways) % MOD\n    return result\n\n# Reading input\nn, m, k = map(int, input().split())\n\n# Calculating and printing the output\nprint(count_ways(n, m, k))"}
{"solution": "import re\n\ndef is_magic_number(n):\n    # Define the regular expression pattern for magic numbers\n    pattern = re.compile(r'^(1|14|144)*$')\n    \n    # Check if the entire number matches the pattern\n    if pattern.match(str(n)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\n\n# Print the result\nprint(is_magic_number(n))"}
{"solution": "def min_moves_to_corner(n, m, i, j, a, b):\n    # Function to calculate the minimum number of moves required to reach a corner\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    \n    # Check if it's possible to reach any corner\n    if (i == 1 and j == 1) or (i == 1 and j == m) or (i == n and j == 1) or (i == n and j == m):\n        return 0\n    \n    # Calculate the greatest common divisor of a and b\n    gcd_ab = gcd(a, b)\n    \n    # Check if it's possible to reach any of the corners\n    if (i - 1) % a != 0 or (j - m) % b != 0:\n        return \"Poor Inna and pony!\"\n    if (n - i) % a != 0 or (j - 1) % b != 0:\n        return \"Poor Inna and pony!\"\n    if (i - 1) % a != 0 or (j - 1) % b != 0:\n        return \"Poor Inna and pony!\"\n    if (n - i) % a != 0 or (m - j) % b != 0:\n        return \"Poor Inna and pony!\"\n    \n    # Calculate the minimum number of moves to reach each corner\n    moves_1_m = ((i - 1) // a + (m - j) // b) * 2\n    moves_n_1 = ((n - i) // a + (j - 1) // b) * 2\n    moves_n_m = ((n - i) // a + (m - j) // b) * 2\n    moves_1_1 = ((i - 1) // a + (j - 1) // b) * 2\n    \n    # Return the minimum number of moves\n    return min(moves_1_m, moves_n_1, moves_n_m, moves_1_1)\n\n# Read input\nn, m, i, j, a, b = map(int, input().split())\n\n# Print the result\nprint(min_moves_to_corner(n, m, i, j, a, b))"}
{"solution": "def max_removals(s):\n    # Function to check if a character can be removed\n    def can_remove(s, i):\n        if i == 0:\n            return ord(s[i]) - ord(s[i + 1]) == 1\n        elif i == len(s) - 1:\n            return ord(s[i]) - ord(s[i - 1]) == 1\n        else:\n            return ord(s[i]) - ord(s[i - 1]) == 1 or ord(s[i]) - ord(s[i + 1]) == 1\n\n    # Main loop to perform removals\n    while True:\n        max_index = -1\n        for i in range(len(s)):\n            if can_remove(s, i):\n                if max_index == -1 or ord(s[i]) > ord(s[max_index]):\n                    max_index = i\n        \n        if max_index == -1:\n            break\n        s = s[:max_index] + s[max_index + 1:]\n    \n    # Return the number of removed characters\n    return len(s) - len(s)\n\n# Read input\nn = int(input())\ns = input()\n\n# Calculate and print the result\nprint(n - max_removals(s))"}
{"solution": "from bisect import bisect_left\n\ndef can_withdraw(amount, k, denominations):\n    n = len(denominations)\n    min_bills = float('inf')\n    \n    for i in range(n):\n        for j in range(k + 1):\n            for l in range(k + 1 - j):\n                if j * denominations[i] + (amount - j * denominations[i]) / (l if l else 1) == amount:\n                    if l > 0 and (amount - j * denominations[i]) % l == 0 and (amount - j * denominations[i]) // l in denominations:\n                        min_bills = min(min_bills, j + l)\n    \n    return min_bills if min_bills != float('inf') else -1\n\ndef main():\n    n, k = map(int, input().split())\n    denominations = list(map(int, input().split()))\n    q = int(input())\n    \n    for _ in range(q):\n        amount = int(input())\n        print(can_withdraw(amount, k, denominations))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_time_to_reach(s, x1, x2, t1, t2, p, d):\n    def distance_to_meet(x1, x2, t1, t2, p, d):\n        v_tram = 1 / t1\n        v_igor = 1 / t2\n        relative_v = abs(v_tram - v_igor)\n        \n        if d == 1:\n            if p < x1:\n                meet_point = (x1 - p) / (v_tram + v_igor) + p\n            else:\n                meet_point = (p - x1) / (v_tram - v_igor) + x1\n        else:\n            if p > x1:\n                meet_point = (p - x1) / (v_tram + v_igor) + x1\n            else:\n                meet_point = (x1 - p) / (v_tram - v_igor) + p\n        \n        return meet_point\n    \n    def time_to_walk(x1, x2, t2):\n        return abs(x2 - x1) * t2\n    \n    def time_to_reach_with_tram(x1, x2, t1, t2, p, d):\n        if x1 == x2:\n            return 0\n        \n        if p == x1:\n            if d == 1 and x2 > x1 or d == -1 and x2 < x1:\n                return abs(x2 - x1) * t1\n            else:\n                return time_to_walk(x1, x2, t2)\n        \n        meet_point = distance_to_meet(x1, x2, t1, t2, p, d)\n        \n        if meet_point <= s and meet_point >= 0:\n            time_to_meet = time_to_walk(x1, meet_point, t2)\n            if d == 1 and meet_point < x2 or d == -1 and meet_point > x2:\n                time_to_x2 = time_to_walk(meet_point, x2, t2)\n            else:\n                time_to_x2 = time_to_reach_with_tram(meet_point, x2, t1, t2, meet_point, -d)\n        else:\n            time_to_meet = float('inf')\n            time_to_x2 = 0\n        \n        return time_to_meet + time_to_x2\n    \n    return min(time_to_walk(x1, x2, t2), time_to_reach_with_tram(x1, x2, t1, t2, p, d))\n\n# Reading input\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Calculating and printing the result\nprint(min_time_to_reach(s, x1, x2, t1, t2, p, d))"}
{"solution": "def count_occurrences(n, x):\n    count = 0\n    for i in range(1, n + 1):\n        if x % i == 0 and x // i <= n:\n            count += 1\n    return count\n\nn, x = map(int, input().split())\nprint(count_occurrences(n, x))"}
{"solution": "def generate_password(n, k):\n    # Initialize variables\n    password = []\n    alphabet = [chr(97 + i) for i in range(k)]  # Generate the first k lowercase letters\n    i = 0\n    \n    # Generate the password\n    for pos in range(n):\n        password.append(alphabet[i % k])\n        i += 1 if pos == 0 or password[pos - 1] != alphabet[(i + 1) % k] else 2\n    \n    # Print the generated password\n    print(''.join(password))\n\n# Read input\nn, k = map(int, input().split())\n\n# Generate and print the password\ngenerate_password(n, k)"}
{"solution": "def first_collision_time(n, directions, positions):\n    min_time = float('inf')\n    collision_found = False\n    \n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            collision_time = (positions[i + 1] - positions[i]) // 2\n            min_time = min(min_time, collision_time)\n            collision_found = True\n    \n    if collision_found:\n        return min_time\n    else:\n        return -1\n\n# Input handling\nn = int(input())\ndirections = input()\npositions = list(map(int, input().split()))\n\n# Function call and output\nresult = first_collision_time(n, directions, positions)\nprint(result)"}
{"solution": "def max_seal_area(n, a, b, seals):\n    # Sort each seal by its area in descending order, considering both orientations\n    seals = sorted([(max(x, y), min(x, y)) for x, y in seals], key=lambda s: s[0] * s[1], reverse=True)\n    \n    # Initialize the maximum area to 0\n    max_area = 0\n    \n    # Iterate through each pair of seals\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if both seals fit within the paper in their current orientation\n            if (seals[i][0] <= a and seals[i][1] <= b) and (seals[j][0] <= a and seals[j][1] <= b):\n                max_area = max(max_area, seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1])\n            # Check if both seals fit within the paper when one is rotated\n            if (seals[i][0] <= a and seals[i][1] <= b) and (seals[j][1] <= a and seals[j][0] <= b):\n                max_area = max(max_area, seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1])\n            if (seals[i][1] <= a and seals[i][0] <= b) and (seals[j][0] <= a and seals[j][1] <= b):\n                max_area = max(max_area, seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1])\n            if (seals[i][1] <= a and seals[i][0] <= b) and (seals[j][1] <= a and seals[j][0] <= b):\n                max_area = max(max_area, seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1])\n    \n    return max_area\n\n# Read input\nn, a, b = map(int, input().split())\nseals = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Compute and print the result\nprint(max_seal_area(n, a, b, seals))"}
{"solution": "def find_outlier_point(n, points):\n    x_counts = {}\n    y_counts = {}\n    \n    # Count occurrences of x and y coordinates\n    for x, y in points:\n        if x in x_counts:\n            x_counts[x] += 1\n        else:\n            x_counts[x] = 1\n        if y in y_counts:\n            y_counts[y] += 1\n        else:\n            y_counts[y] = 1\n    \n    # Find the point that is not on the boundary\n    for x, y in points:\n        if x_counts[x] <= n and y_counts[y] <= n:\n            return x, y\n\n# Read input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(4 * n + 1)]\n\n# Find and print the outlier point\noutlier_x, outlier_y = find_outlier_point(n, points)\nprint(outlier_x, outlier_y)"}
{"solution": "def max_product_of_digits(n):\n    if n < 10:\n        return n\n    length = len(str(n))\n    if length <= 2 or n < 25:\n        return int(max(str(n)))\n    if length <= 3 or n < 1000:\n        return 9 * max_product_of_digits((n - 1) // 9)\n    if n < 1111:\n        return 3 * max_product_of_digits((n - 1) // 3)\n    if n < 10 ** (length - 1) + 111:\n        return 9 * (max_product_of_digits((n - 1) // 9))\n    return 10 ** 9 + (n - 10 ** length + 1)\n\n# Reading input\nn = int(input().strip())\n\n# Calculating and printing the result\nprint(max_product_of_digits(n))"}
{"solution": "def find_smallest_k(n, votes_for_elodreip):\n    max_a = max(votes_for_elodreip)\n    awruk_votes = [max_a - a for a in votes_for_elodreip]\n    elodreip_total = sum(votes_for_elodreip)\n    \n    k = max_a\n    while True:\n        awruk_total = sum(k - a for a in votes_for_elodreip)\n        if awruk_total > elodreip_total:\n            return k\n        k += 1\n\n# Read input\nn = int(input())\nvotes_for_elodreip = list(map(int, input().split()))\n\n# Calculate and print the smallest k\nprint(find_smallest_k(n, votes_for_elodreip))"}
{"solution": "def count_operations(points):\n    # Convert the string of points into a list of characters for easier manipulation\n    colors = list(points)\n    operations = 0\n    \n    while True:\n        # Track if any points were deleted in this operation\n        deleted = False\n        new_colors = []\n        \n        # Iterate through the points to check for deletions\n        i = 0\n        while i < len(colors):\n            if i == 0 or i == len(colors) - 1:\n                # Edge points cannot be deleted\n                new_colors.append(colors[i])\n                i += 1\n                continue\n            \n            # Check if the current point should be deleted\n            if colors[i] != colors[i - 1] or colors[i] != colors[i + 1]:\n                deleted = True\n            else:\n                new_colors.append(colors[i])\n            \n            i += 1\n        \n        # Update the colors list\n        colors = new_colors\n        \n        # If no points were deleted, break the loop\n        if not deleted:\n            break\n        \n        operations += 1\n    \n    return operations\n\n# Read input\npoints = input()\n\n# Calculate and print the number of operations\nprint(count_operations(points))"}
{"solution": "def count_min_triples(n, arr):\n    min_val = min(arr)\n    indices = [i for i, x in enumerate(arr) if x == min_val]\n    \n    count = 0\n    for i in range(len(indices)):\n        for j in range(i + 1, len(indices)):\n            for k in range(j + 1, len(indices)):\n                count += 1\n                \n    return count\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(count_min_triples(n, arr))"}
{"solution": "def min_cuts_for_pizza(n):\n    if n == 0:\n        return 0\n    elif n <= 3:\n        return n\n    else:\n        return n - 1\n\n# Reading input\nn = int(input())\n\n# Calculating and printing the output\nprint(min_cuts_for_pizza(n))"}
{"solution": "def maximize_bank_account(n):\n    # Convert the number to a string to easily manipulate digits\n    str_n = str(n)\n    \n    # Check if the number is negative\n    is_negative = n < 0\n    \n    # If the number is negative, start by removing '-' for easier manipulation\n    if is_negative:\n        str_n = str_n[1:]\n    \n    # Initialize variables to store the results of removing the last and the second last digit\n    remove_last = int(str_n[:-1])\n    remove_second_last = int(str_n[:-2] + str_n[-1])\n    \n    # Adjust the results back to negative if the original number was negative\n    if is_negative:\n        remove_last = -remove_last\n        remove_second_last = -remove_second_last\n    \n    # Determine the maximum of the two options, and compare it with the original number\n    max_value = max(remove_last, remove_second_last, n)\n    \n    return max_value\n\n# Read the input\nn = int(input())\n\n# Compute and print the result\nprint(maximize_bank_account(n))"}
{"solution": "def spinner_direction(start, end, n):\n    positions = {'v': 0, '<': 1, '^': 2, '>': 3}\n    start_pos = positions[start]\n    end_pos = positions[end]\n    \n    # Calculate the effective position after n seconds\n    effective_pos = (start_pos + n) % 4\n    \n    # Check if the final position matches the expected position\n    if effective_pos == end_pos:\n        # Determine the direction\n        if (end_pos - start_pos) % 4 == n % 4:\n            return \"cw\" if n % 4 == 1 or n % 4 == 3 else \"undefined\"\n        elif (start_pos - end_pos) % 4 == n % 4:\n            return \"ccw\" if n % 4 == 1 or n % 4 == 3 else \"undefined\"\n        else:\n            return \"undefined\"\n    else:\n        return \"undefined\"\n\n# Read input\nstart, end = input().split()\nn = int(input())\n\n# Print output\nprint(spinner_direction(start, end, n))"}
{"solution": "def count_standing_dominos(n, s):\n    standing_count = 0\n    left_push = False\n    right_push = False\n    \n    for char in s:\n        if char == 'L':\n            if right_push:\n                standing_count += 1\n            right_push = False\n            left_push = True\n        elif char == 'R':\n            if not left_push:\n                right_push = True\n            else:\n                standing_count += 1\n                left_push = False\n        else:\n            if not left_push and not right_push:\n                standing_count += 1\n    \n    return standing_count\n\n# Read input\nn = int(input())\ns = input()\n\n# Calculate and print the result\nprint(count_standing_dominos(n, s))"}
{"solution": "def find_permutation(n, m, leaders):\n    permutation = [-1] * n\n    used = [False] * n\n    \n    for i in range(m):\n        if permutation[leaders[i] - 1] == -1:\n            permutation[leaders[i] - 1] = i + 1\n            used[i] = True\n    \n    for i in range(n):\n        if permutation[i] == -1:\n            for j in range(m):\n                if not used[j]:\n                    permutation[i] = j + 1\n                    used[j] = True\n                    break\n    \n    # Verify the solution\n    current_leader = leaders[0]\n    for i in range(m):\n        next_leader = (current_leader + permutation[current_leader - 1] - 1) % n + 1\n        if next_leader != leaders[i + 1]:\n            return -1\n        current_leader = next_leader\n    \n    return permutation\n\n# Reading input\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\n# Finding and printing the permutation\nresult = find_permutation(n, m, leaders)\nprint(*result)"}
{"solution": "def max_number(a, k):\n    from collections import deque\n    str_a = list(str(a))\n    n = len(str_a)\n    \n    for i in range(n):\n        # Find the index of the largest digit that can be swapped with the current digit\n        max_idx = i\n        for j in range(i + 1, min(n, i + k + 1)):\n            if str_a[j] > str_a[max_idx]:\n                max_idx = j\n        \n        # If we found a larger digit, swap it with the current one\n        if max_idx != i:\n            str_a[i], str_a[max_idx] = str_a[max_idx], str_a[i]\n            k -= (max_idx - i)\n    \n    return ''.join(str_a)\n\n# Read input\na, k = map(int, input().split())\n\n# Compute and print the result\nprint(max_number(a, k))"}
{"solution": "def find_next_in_sequence(a, b, c, d):\n    # Check for arithmetic progression\n    if (b - a) == (c - b) == (d - c):\n        return d + (b - a)\n    \n    # Check for geometric progression\n    if a != 0 and b != 0 and c != 0 and d != 0:\n        if (b / a) == (c / b) == (d / c):\n            next_element = d * (b / a)\n            if next_element.is_integer():\n                return int(next_element)\n    \n    # Default case\n    return 42\n\n# Read input\na, b, c, d = map(int, input().split())\n\n# Print output\nprint(find_next_in_sequence(a, b, c, d))"}
{"solution": "def max_distance(n, colors):\n    # Find the first and last occurrence of each color\n    first_occurrence = [float('inf')] * (n + 1)\n    last_occurrence = [float('-inf')] * (n + 1)\n    \n    for i in range(n):\n        color = colors[i]\n        first_occurrence[color] = min(first_occurrence[color], i)\n        last_occurrence[color] = max(last_occurrence[color], i)\n    \n    # Calculate the maximum distance\n    max_dist = 0\n    \n    # Compare distances from the first house to the last house of a different color\n    for color in range(1, n + 1):\n        if colors[0] != color:\n            max_dist = max(max_dist, last_occurrence[color])\n        if colors[-1] != color:\n            max_dist = max(max_dist, n - 1 - first_occurrence[color])\n    \n    return max_dist\n\n# Read input\nn = int(input())\ncolors = list(map(int, input().split()))\n\n# Print the result\nprint(max_distance(n, colors))"}
{"solution": "def find_santa_place(n, m, k):\n    # Determine the lane, desk, and side for Santa Claus' place\n    places_per_lane = m * 2\n    lane = (k - 1) // places_per_lane + 1\n    remaining_places = (k - 1) % places_per_lane + 1\n    desk = remaining_places // 2 if remaining_places % 2 == 0 else remaining_places // 2 + 1\n    side = \"L\" if remaining_places % 2 == 0 else \"R\"\n    \n    return f\"{lane} {desk} {side}\"\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Print output\nprint(find_santa_place(n, m, k))"}
{"solution": "def possible_final_card_colors(n, s):\n    # Count the occurrences of each color\n    counts = {'B': 0, 'G': 0, 'R': 0}\n    for card in s:\n        counts[card] += 1\n    \n    # Determine the parities of the counts\n    parity_b = counts['B'] % 2\n    parity_g = counts['G'] % 2\n    parity_r = counts['R'] % 2\n    \n    # Determine the possible final colors based on parities\n    final_colors = []\n    if parity_b == 1:\n        final_colors.append('B')\n    if parity_g == 1:\n        final_colors.append('G')\n    if parity_r == 1:\n        final_colors.append('R')\n    \n    # If there are no odd parities, all colors are possible\n    if not final_colors:\n        final_colors = ['B', 'G', 'R']\n    \n    # Sort and return the final colors\n    return ''.join(sorted(final_colors))\n\n# Read input\nn = int(input())\ns = input()\n\n# Print the result\nprint(possible_final_card_colors(n, s))"}
