{"solution": "def max_accordion_length(s):\n    open_brackets = []\n    colon_positions = []\n\n    for i, c in enumerate(s):\n        if c == '[':\n            open_brackets.append(i)\n        elif c == ':':\n            colon_positions.append(i)\n\n    max_length = -1\n    for i in range(len(colon_positions)):\n        for j in range(i + 1, len(colon_positions)):\n            if colon_positions[i] < colon_positions[j]:\n                open_bracket = next((x for x in open_brackets if x > colon_positions[i]), None)\n                close_bracket = next((x for x in reversed(open_brackets) if x < colon_positions[j]), None)\n                if open_bracket is not None and close_bracket is not None and open_bracket < close_bracket:\n                    length = (close_bracket - open_bracket + 1) + (colon_positions[j] - colon_positions[i] + 1)\n                    vertical_bars = sum(1 for k in range(colon_positions[i] + 1, colon_positions[j]) if s[k] == '|')\n                    max_length = max(max_length, length + vertical_bars * 2)\n\n    return max_length\n\n# Input and Output handling\ns = input().strip()\nprint(max_accordion_length(s))"}
{"solution": "def max_digit_sum_number(x):\n    x_str = str(x)\n    length = len(x_str)\n    \n    # Try to maximize the sum by making all digits 9\n    max_sum = 9 * (length - 1)\n    \n    # Calculate the remaining value to distribute\n    remaining = int(x_str[0]) - 1\n    \n    # Check if we can increase the sum with the remaining value\n    if remaining > 0:\n        max_sum += remaining\n    \n    # Special case handling for numbers like 19, 29, etc.\n    if int(x_str) < 10 * (length - 1) + 1:\n        max_sum = 9 * (length - 1) + int(x_str[0])\n    \n    result = ''\n    formed_sum = 0\n    \n    # Construct the number that gives the max sum\n    for i in range(length):\n        current_digit = int(x_str[i])\n        \n        if formed_sum + 9 * (length - i - 1) < max_sum:\n            result += '9'\n            formed_sum += 9\n        else:\n            needed = max_sum - formed_sum\n            if needed < current_digit:\n                result += str(needed)\n                break\n            else:\n                result += x_str[i]\n                formed_sum += current_digit\n    \n    return int(result)\n\n# Read input and print output\nif __name__ == \"__main__\":\n    x = int(input().strip())\n    print(max_digit_sum_number(x))"}
{"solution": "def next_lucky_year(current_year):\n    \"\"\"\n    Finds the next lucky year after the given current year.\n    A lucky year has no more than 1 non-zero digit in its number.\n    \"\"\"\n    str_year = str(current_year)\n    next_year = current_year\n    \n    # Increment the year until a lucky year is found\n    while True:\n        next_year += 1\n        if sum(1 for digit in str(next_year) if digit != '0') <= 1:\n            break\n    \n    return next_year - current_year\n\n# Read input\ncurrent_year = int(input())\n\n# Output result\nprint(next_lucky_year(current_year))"}
{"solution": "from itertools import accumulate\n\ndef max_painted_sections(n, q, painters):\n    events = []\n    for l, r in painters:\n        events.append((l, 1))\n        events.append((r + 1, -1))\n    events.sort()\n    \n    covered = [0] * (n + 1)\n    active_painters = 0\n    for i, (pos, delta) in enumerate(events):\n        if i > 0 and events[i - 1][0] < pos:\n            covered[active_painters] += pos - events[i - 1][0]\n        active_painters += delta\n    \n    prefix_sum_covered = list(accumulate(covered))\n    best = 0\n    for i in range(2, len(painters)):\n        best = max(best, prefix_sum_covered[-1] - prefix_sum_covered[i - 2])\n    return best\n\n# Reading input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Solving and printing output\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def has_seven(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef solve(x, hh, mm):\n    for i in range(1440):\n        y = i * x\n        new_hh = (hh - y // 60) % 24\n        new_mm = (mm - y % 60) % 60\n        if has_seven(new_hh, new_mm):\n            return i\n\nx = int(input())\nhh, mm = map(int, input().split())\nprint(solve(x, hh, mm))"}
{"solution": "def min_seconds(n, pos, l, r):\n    \"\"\"\n    Calculate the minimum number of seconds to close all tabs except those from l to r.\n    \"\"\"\n    # If pos is within the range [l, r], no need to move within the range\n    if l <= pos <= r:\n        # Calculate the minimum moves to close tabs on both sides\n        left_closing = pos - l\n        right_closing = r - pos\n        return min(pos - l, r - pos) + max(0, (l - 1) + (n - r))\n    \n    # If pos is outside the range [l, r]\n    move_to_range = abs(pos - l) if pos < l else abs(pos - r)\n    return move_to_range + max(0, (l - 1) + (n - r))\n\n# Read input\nn, pos, l, r = map(int, input().split())\n\n# Output result\nprint(min_seconds(n, pos, l, r))"}
{"solution": "import heapq\nfrom collections import defaultdict\n\ndef min_blows_to_defeat(zmei_heads, blows):\n    # Sort blows by net reduction (damage - healing)\n    blows.sort(key=lambda x: x[0] - x[1], reverse=True)\n\n    net_reductions = []\n    for damage, healing in blows:\n        net_reductions.append(damage - healing)\n\n    unique_net_reductions = sorted(set(net_reductions), reverse=True)\n\n    reductions_dict = defaultdict(list)\n    for i, val in enumerate(net_reductions):\n        reductions_dict[val].append(i)\n\n    total_blows = 0\n    current_heads = zmei_heads\n\n    while current_heads > 0:\n        max_reduction = None\n        for reduction in unique_net_reductions:\n            if reduction <= 0:\n                continue\n            if max_reduction is None or reduction > max_reduction:\n                max_reduction = reduction\n\n        if max_reduction is None or max_reduction <= 0:\n            return -1\n\n        best_index = reductions_dict[max_reduction][0]\n        best_damage = blows[best_index][0]\n\n        needed_blows = (current_heads + best_damage - 1) // best_damage\n        total_blows += needed_blows\n        current_heads -= needed_blows * max_reduction\n\n    return total_blows\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n, x = map(int, input().split())\n        blows = [tuple(map(int, input().split())) for _ in range(n)]\n        print(min_blows_to_defeat(x, blows))\n\nsolve()"}
{"solution": "import math\nn, m = map(int, input().split())\nif m == 0:\n    print(1)\nelse:\n    k = math.ceil((-1 + math.sqrt(1 + 4 * n * 2 / m)) / 2)\n    while (k * (k + 1) // 2) * m >= n * 2:\n        k -= 1\n    print(k + 1)"}
{"solution": "from collections import Counter\n\ndef can_form_sequence(counter):\n    for num in range(1, 8):\n        if counter[str(num)] and counter[str(num + 1)] and counter[str(num + 2)]:\n            return True\n    return False\n\ntiles = input().split()\ncounter = Counter(tile[:-1] for tile in tiles)\nsame = sum(v >= 3 for v in counter.values())\ndifferent = len(counter) - same\n\nif same >= 1 or can_form_sequence(counter):\n    print(0)\nelse:\n    if different == 3:\n        print(2)\n    else:\n        print(1)"}
{"solution": "import sys\n\ndef read_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef solve(n, m, sofas, cnt):\n    def compare_sofas(sofa1, sofa2):\n        x1, y1, x2, y2 = sofa1\n        a1, b1, a2, b2 = sofa2\n        if x1 == x2:  # Both sofas are horizontal\n            if y1 < y2:\n                return -1\n            elif y1 > y2:\n                return 1\n        elif y1 == y2:  # Both sofas are vertical\n            if x1 < x2:\n                return -1\n            elif x1 > x2:\n                return 1\n        else:  # One sofa is horizontal, the other is vertical\n            if y1 < y2 or (y1 == y2 and x1 < x2):\n                return -1\n            elif y1 > y2 or (y1 == y2 and x1 > x2):\n                return 1\n        return 0\n\n    def count_relations(sofa, sofas):\n        left, right, top, bottom = 0, 0, 0, 0\n        for other in sofas:\n            if other != sofa:\n                relation = compare_sofas(sofa, other)\n                if relation == -1:\n                    left += 1\n                elif relation == 1:\n                    right += 1\n        for other in sofas:\n            if other != sofa:\n                relation = compare_sofas((sofa[1], sofa[0], sofa[3], sofa[2]), (other[1], other[0], other[3], other[2]))\n                if relation == -1:\n                    top += 1\n                elif relation == 1:\n                    bottom += 1\n        return left, right, top, bottom\n\n    for i, sofa in enumerate(sofas):\n        sofa_cnt = count_relations(sofa, sofas)\n        if sofa_cnt == cnt:\n            return i + 1\n    return -1\n\nif __name__ == \"__main__\":\n    d, = read_ints()\n    n, m = read_ints()\n    sofas = [tuple(read_ints()) for _ in range(d)]\n    cnt_l, cnt_r, cnt_t, cnt_b = read_ints()\n    cnt = (cnt_l, cnt_r, cnt_t, cnt_b)\n    print(solve(n, m, sofas, cnt))"}
{"solution": "def mars_days_off(n):\n    min_days_off = (n // 7) * 2\n    max_days_off = ((n + 6) // 7) * 2\n    print(min_days_off, max_days_off)\n\n# Example usage:\n# mars_days_off(14)\n# mars_days_off(2)"}
{"solution": "def max_chocolates(n, a, b, p, q):\n    lcm = (a * b) // gcd(a, b)\n    full_cycles = n // lcm\n    red_in_cycle = min(a, lcm) * p\n    blue_in_cycle = min(b, lcm) * q\n    cycle_diff = blue_in_cycle - red_in_cycle\n\n    extra_a = max(0, n % lcm - a) * p\n    extra_b = n % lcm * q\n\n    max_extra = max(extra_a, extra_b)\n\n    return (full_cycles * (red_in_cycle if red_in_cycle > blue_in_cycle else blue_in_cycle) + max_extra)\n\nfrom math import gcd\n\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))"}
{"solution": "def max_golden_segment(trophies):\n    from collections import Counter\n    n = len(trophies)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + (1 if trophies[i - 1] == 'G' else 0)\n\n    max_len = 0\n    left_s_count = 0\n    right_s_count = Counter(trophies)['S']\n    \n    for i in range(n + 1):\n        current_len = prefix_sum[min(i + right_s_count, n)] - prefix_sum[max(0, i - left_s_count)] + (left_s_count + right_s_count > 0)\n        max_len = max(max_len, current_len)\n        \n        if i < n and trophies[i] == 'S':\n            left_s_count += 1\n            right_s_count -= 1\n    \n    return max_len\n\n# Reading input\nn = int(input())\ntrophies = input().strip()\n\n# Calculating and printing the result\nprint(max_golden_segment(trophies))"}
{"solution": "from collections import defaultdict, deque\n\ndef topological_sort(n, dependencies, main_courses):\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    for course, deps in enumerate(dependencies):\n        for dep in deps:\n            graph[dep].append(course + 1)\n            in_degree[course + 1] += 1\n\n    queue = deque([course for course in range(1, n + 1) if in_degree[course] == 0])\n    visited = set()\n    course_order = []\n\n    while queue:\n        current = queue.popleft()\n        visited.add(current)\n        course_order.append(current)\n\n        for neighbor in graph[current]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    # Filter out the relevant courses and sort them\n    relevant_courses = sorted(set(course_order) | set(main_courses))\n    sorted_courses = sorted(relevant_courses, key=lambda x: course_order.index(x))\n\n    # Check if all main courses are covered\n    if len(set(sorted_courses) & set(main_courses)) == len(main_courses):\n        return len(sorted_courses), sorted_courses\n    else:\n        return -1,\n\ndef read_input():\n    n, k = map(int, input().split())\n    main_courses = list(map(int, input().split()))\n    dependencies = []\n    for _ in range(n):\n        t, *deps = map(int, input().split())\n        dependencies.append(deps)\n    return n, dependencies, main_courses\n\nif __name__ == \"__main__\":\n    n, dependencies, main_courses = read_input()\n    result = topological_sort(n, dependencies, main_courses)\n    print(*result)"}
{"solution": "def solve(n, k, p):\n    s = []\n    used = set(p)\n    max_used = max(p)\n    next_available = max_used + 1\n    for i in range(k - 1, -1, -1):\n        while s and s[-1] < p[i]:\n            if s.pop() < next_available:\n                return -1\n        if p[i] >= next_available:\n            return -1\n        while next_available <= n and next_available < p[i]:\n            s.append(next_available)\n            next_available += 1\n        s.append(p[i])\n    while next_available <= n:\n        s.append(next_available)\n        next_available += 1\n    result = [str(s.pop()) for _ in range(n)]\n    return ' '.join(result)\n\nn, k = map(int, input().split())\np = list(map(int, input().split()))\nprint(solve(n, k, p))"}
{"solution": "a, b, c = map(int, input().split())\n\nif c == 0:\n    print(\"YES\") if a == b else print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "from sys import stdin\n\n# Reading the counts from stdin\ncnt_1 = int(stdin.readline())\ncnt_2 = int(stdin.readline())\ncnt_3 = int(stdin.readline())\ncnt_4 = int(stdin.readline())\n\n# Checking the conditions for forming a regular bracket sequence\nif cnt_1 == cnt_3 and cnt_2 >= abs(cnt_4 - cnt_1) and cnt_2 + min(cnt_4, cnt_1) >= abs(cnt_4 - cnt_1):\n    print(1)\nelse:\n    print(0)"}
{"solution": "def standing_spectators(n, k, t):\n    if t <= k:\n        return t\n    else:\n        cycle_length = n + k\n        full_cycles = t // cycle_length\n        remainder = t % cycle_length\n        if remainder <= k:\n            return remainder\n        else:\n            return k - (remainder - k)\n\n# Reading input\nn, k, t = map(int, input().split())\n\n# Calculating and printing the result\nprint(standing_spectators(n, k, t))"}
{"solution": "def min_lexico_string(s):\n    \"\"\"\n    Given a string s, perform operations to achieve an empty string s and derive a lexicographically minimal string u.\n    \"\"\"\n    stack = []\n    for char in s:\n        while stack and stack[-1] > char:\n            stack.pop()\n        stack.append(char)\n    u = ''.join(stack)\n    return u\n\n# We assume input() function will be used to take input at runtime.\ns = input().strip()\nprint(min_lexico_string(s))"}
{"solution": "def check_level_stats():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        prev_plays, prev_clears = map(int, input().split())\n        valid = True\n\n        for _ in range(1, n):\n            curr_plays, curr_clears = map(int, input().split())\n            if curr_plays < prev_plays or curr_clears < prev_clears:\n                valid = False\n                break\n            if curr_clears > prev_clears and curr_plays == prev_plays:\n                valid = False\n                break\n            prev_plays, prev_clears = curr_plays, curr_clears\n\n        print(\"YES\" if valid else \"NO\")\n\ncheck_level_stats()"}
{"solution": "from datetime import datetime, timedelta\n\ndef is_palindrome_time(time_str):\n    return time_str == time_str[::-1]\n\ndef minutes_until_palindrome(current_time_str):\n    current_time = datetime.strptime(current_time_str, '%H:%M')\n    next_palindrome_time = current_time\n    increment = timedelta(minutes=1)\n\n    while not is_palindrome_time(next_palindrome_time.strftime('%H%M')):\n        next_palindrome_time += increment\n\n    return (next_palindrome_time - current_time).seconds // 60\n\ncurrent_time = input().strip()\nprint(minutes_until_palindrome(current_time))"}
{"solution": "def max_distance_after_swap(n, arr):\n    min_pos = arr.index(1)\n    max_pos = arr.index(n)\n    \n    # Calculate current distance\n    current_dist = abs(max_pos - min_pos)\n    \n    # Calculate potential distances after swap\n    dist_with_start_swap = max(min_pos, max_pos)\n    dist_with_end_swap = n - 1 - min(min_pos, max_pos)\n    \n    # Return the maximum distance\n    return max(current_dist, dist_with_start_swap, dist_with_end_swap)\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculating and printing result\nprint(max_distance_after_swap(n, a))"}
{"solution": "def check_s_palindrome(s):\n    pairs = {\n        'a': 'a', 'b': 'd', 'd': 'b', 'e': 'm', 'm': 'e',\n        'h': 'h', 'i': 'i', 'n': 'u', 'o': 'o', 'u': 'n',\n        'v': 'v', 'w': 'w', 'x': 'x', 'y': 'y'\n    }\n    \n    length = len(s)\n    mid = length // 2\n    \n    for i in range(mid):\n        if s[i] != s[length - 1 - i]:\n            if (s[i] not in pairs) or (s[length - 1 - i] != pairs[s[i]]):\n                return \"NIE\"\n    \n    return \"TAK\"\n\n# Read input from stdin\ns = input().strip()\n\n# Print output to stdout\nprint(check_s_palindrome(s))"}
{"solution": "def max_permutation(a, b):\n    a_str, b_str = str(a), str(b)\n    a_len, b_len = len(a_str), len(b_str)\n\n    if a_len < b_len or (a_len == b_len and a_str <= b_str):\n        return a_str\n    else:\n        result = []\n        a_counts = [0] * 10\n        for digit in a_str:\n            a_counts[int(digit)] += 1\n\n        for i in range(b_len):\n            found = False\n            for d in range(9, -1, -1):\n                if b_str[i] >= str(d) and a_counts[d] > 0:\n                    result.append(str(d))\n                    a_counts[d] -= 1\n                    found = True\n                    break\n            if not found:\n                for d in range(9, -1, -1):\n                    if a_counts[d] > 0:\n                        result.append(str(d))\n                        a_counts[d] -= 1\n                        break\n\n        return ''.join(result).ljust(a_len, '0').lstrip('0') or '0'\n\n# Input\na = int(input())\nb = int(input())\n\n# Solution\nprint(max_permutation(a, b))"}
{"solution": "def check_win(matrix):\n    size = 10\n    directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n\n    for i in range(size):\n        for j in range(size):\n            if matrix[i][j] == '.':\n                matrix[i][j] = 'X'\n                for dx, dy in directions:\n                    x, y = i, j\n                    count = 0\n                    while 0 <= x < size and 0 <= y < size and matrix[x][y] == 'X':\n                        count += 1\n                        if count >= 5:\n                            return \"YES\"\n                        x, y = x + dx, y + dy\n                    # Check opposite direction\n                    x, y = i - dx, j - dy\n                    while 0 <= x < size and 0 <= y < size and matrix[x][y] == 'X':\n                        count -= 1\n                        x, y = x - dx, y - dy\n                matrix[i][j] = '.'\n    return \"NO\"\n\n# Reading input\ngrid = [input() for _ in range(10)]\n\n# Output result\nprint(check_win(grid))"}
{"solution": "def print_matrix(matrix):\n    for row in matrix:\n        print(' '.join(map(str, row)))\n\ndef generate_symmetric_matrix(n, k):\n    matrix = [[0] * n for _ in range(n)]\n    ones_placed = 0\n    # Fill the upper triangle and main diagonal\n    for i in range(n):\n        for j in range(i, n):\n            if ones_placed < k and (i == j or (i + j) % 2 == 0):\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                ones_placed += 1\n                if ones_placed == k:\n                    break\n        if ones_placed == k:\n            break\n    # Check if we have placed all ones\n    if ones_placed < k:\n        return -1\n    return matrix\n\n# Reading input\nn, k = map(int, input().split())\n\nresult = generate_symmetric_matrix(n, k)\nif result == -1:\n    print(-1)\nelse:\n    print_matrix(result)"}
{"solution": "def calculate(x, y, z):\n    return [\n        x**(y**z),\n        x**(z**y),\n        (x**y)**z,\n        (x**z)**y,\n        y**(x**z),\n        y**(z**x),\n        (y**x)**z,\n        (y**z)**x,\n        z**(x**y),\n        z**(y**x),\n        (z**x)**y,\n        (z**y)**x\n    ]\n\ndef main():\n    x, y, z = map(float, input().split())\n    values = calculate(x, y, z)\n    max_val = max(values)\n    index = values.index(max_val) + 1\n    \n    expressions = {\n        1: \"x^y^z\",\n        2: \"x^z^y\",\n        3: \"(x^y)^z\",\n        4: \"(x^z)^y\",\n        5: \"y^x^z\",\n        6: \"y^z^x\",\n        7: \"(y^x)^z\",\n        8: \"(y^z)^x\",\n        9: \"z^x^y\",\n        10: \"z^y^x\",\n        11: \"(z^x)^y\",\n        12: \"(z^y)^x\"\n    }\n    \n    print(expressions[index])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_operations(n, s):\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = i\n        for j in range(1, i // 2 + 1):\n            if s[:j] * (i // j) == s[:i] or s[:j] * (i // j + 1) == s[:i]:\n                dp[i] = min(dp[i], dp[j] + i % j)\n    return dp[n]\n\nn = int(input())\ns = input()\nprint(min_operations(n, s))"}
{"solution": "def sort_tests():\n    from collections import defaultdict\n\n    n = int(input())\n    files = [input().split() for _ in range(n)]\n    example_count = sum(1 for _, t in files if t == '1')\n\n    name_to_index = {name: i for i, (name, _) in enumerate(files)}\n    sorted_files = sorted(((name, t) for name, t in files), key=lambda x: (x[1] == '1', x[0]))\n\n    moves = []\n    new_names = [''] * n\n    for i, (name, t) in enumerate(sorted_files):\n        new_names[name_to_index[name]] = str(i + 1) if t == '1' else str(example_count + (i - example_count) + 1)\n\n    for original_name, new_name in zip([name for name, _ in files], new_names):\n        if original_name != new_name:\n            moves.append(f\"move {original_name} {new_name}\")\n\n    print(len(moves))\n    for move in moves:\n        print(move)\n\nsort_tests()"}
{"solution": "def min_replacements(ticket):\n    left_sum = sum(int(digit) for digit in ticket[:3])\n    right_sum = sum(int(digit) for digit in ticket[3:])\n    diff = abs(left_sum - right_sum)\n\n    # Calculate the minimum replacements needed\n    min_replacements = diff // 9 + (diff % 9 > 0)\n    return min_replacements\n\n# Read input\nticket = input()\n\n# Output the result\nprint(min_replacements(ticket))"}
{"solution": "from math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef min_traps(m, x):\n    return m // gcd(m, x)\n\nm, x = map(int, input().split())\nprint(min_traps(m, x))"}
{"solution": "MOD = 1000003\n\ndef mod_pow(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        exponent = exponent >> 1\n        base = (base * base) % MOD\n    return result\n\ndef mod_inv(num):\n    return mod_pow(num, MOD - 2)\n\ndef solve(n, k):\n    total_days = mod_pow(2, n)\n    numerator = total_days\n    denominator = 1\n    for i in range(1, k):\n        numerator = (numerator * (total_days - i)) % MOD\n        denominator = (denominator * (i + 1)) % MOD\n    prob_no_same_birthday = (numerator * mod_inv(denominator)) % MOD\n    prob_at_least_one_match = ((MOD - 1) - prob_no_same_birthday + MOD) % MOD\n    inv_denominator = mod_inv(denominator)\n    return (prob_at_least_one_match * inv_denominator) % MOD, denominator\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    a, b = solve(n, k)\n    print(a, b)"}
{"solution": "def validate_journey(n, moves):\n    latitude = 0  # Start at North Pole\n    on_north_pole = True\n    on_south_pole = False\n\n    for t, direction in moves:\n        if on_north_pole and direction != 'South':\n            return \"NO\"\n        if on_south_pole and direction != 'North':\n            return \"NO\"\n\n        if direction == 'South':\n            latitude -= t\n            if latitude < -20000:\n                return \"NO\"\n            on_north_pole = False\n        elif direction == 'North':\n            latitude += t\n            if latitude > 20000:\n                return \"NO\"\n            on_south_pole = False\n        else:  # East or West\n            if latitude == -20000:\n                on_south_pole = True\n\n    if latitude == 0 and not on_south_pole:\n        return \"YES\"\n    else:\n        return \"NO\"\n\nif __name__ == \"__main__\":\n    n = int(input())\n    moves = []\n    for _ in range(n):\n        t, direction = input().split()\n        moves.append((int(t), direction))\n    print(validate_journey(n, moves))"}
{"solution": "from math import gcd\n\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Calculate the common difference of the resulting sequence\ncommon_diff = a1 * a2 // gcd(a1, a2)\n\n# Adjust L and R to the nearest valid values in the sequence\nL = ((L - b1) // common_diff) * common_diff + b1\nif L < b1: L += common_diff\nif L < b2: L = b2\nif L > R: print(0); exit()\n\nR = ((R - b1) // common_diff) * common_diff + b1\nif R < b2: R += common_diff\nif R < L: print(0); exit()\n\n# Calculate and print the number of valid x values\nprint((R - L) // common_diff + 1)"}
{"solution": "def max_cake_pieces(n, a, b):\n    # Ensure the total number of pieces can cover all plates\n    if a + b < n:\n        return 0\n    \n    # Try to maximize the minimum number of pieces per plate\n    for x in range(min(a, b), 0, -1):\n        # Check if pieces can be distributed evenly with at least x pieces per plate\n        if (a - x) <= (n - 1) * x and (b - x) <= (n - 1) * x:\n            return x\n    \n    # If no distribution works, return 1 (each plate gets at least one piece)\n    return 1\n\n# Example usage based on provided inputs\nn, a, b = map(int, input().split())\nprint(max_cake_pieces(n, a, b))"}
{"solution": "def check_flag(n, m, flag):\n    color_counts = {'R': 0, 'G': 0, 'B': 0}\n\n    for row in flag:\n        for color in set(row):\n            color_counts[color] += 1\n\n    valid_stripe_count = n // 3\n\n    for color, count in color_counts.items():\n        if count not in [0, valid_stripe_count]:\n            return \"NO\"\n\n    stripe_heights = [0, 0, 0]\n    for i in range(3):\n        for j in range(i * valid_stripe_count, (i + 1) * valid_stripe_count):\n            stripe_heights[i] += len(set(flag[j]))\n\n    if sorted(stripe_heights) != [m, m, m]:\n        return \"NO\"\n\n    return \"YES\"\n\n# Reading input\nn, m = map(int, input().split())\nflag = [input() for _ in range(n)]\n\n# Printing output\nprint(check_flag(n, m, flag))"}
{"solution": "def move_in_hex_spiral(n):\n    \"\"\"\n    Given a number n, this function calculates the coordinates (x, y) on a hexagonal grid\n    after n moves along a spiral starting from (0, 0).\n    \"\"\"\n    x, y = 0, 0\n    direction = 0  # 0: NE, 1: SE, 2: SW, 3: NW, 4: N, 5: S\n    side_length = 1\n    while n > 0:\n        if direction % 2 == 0:\n            side_length += 1\n        for _ in range(side_length):\n            if n <= 0:\n                break\n            if direction == 0:\n                y += 1\n            elif direction == 1:\n                x += 1\n            elif direction == 2:\n                x -= 1\n                y -= 1\n            elif direction == 3:\n                y -= 1\n            elif direction == 4:\n                x -= 1\n            else:  # direction == 5\n                x += 1\n                y -= 1\n            n -= 1\n        direction = (direction + 1) % 6\n    return x, y\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    x, y = move_in_hex_spiral(n)\n    print(x, y)"}
{"solution": "a, b, c = map(int, input().split())\nfor x in range(c // a + 1):\n    if (c - a * x) % b == 0:\n        print(\"Yes\")\n        break\nelse:\n    print(\"No\")"}
{"solution": "def check_tracks(barriers1, barriers2, track_length):\n    for i in range(len(barriers1)):\n        shifted = [(barriers2[j] - barriers2[i]) % track_length for j in range(len(barriers2))]\n        if sorted(shifted) == barriers1:\n            return \"YES\"\n    return \"NO\"\n\nn, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\nprint(check_tracks(kefa_barriers, sasha_barriers, L))"}
{"solution": "def longest_non_palindrome_substring(s):\n    \"\"\"\n    Finds the longest substring that is not a palindrome.\n    If all substrings are palindromes, returns 0.\n    \"\"\"\n    def is_palindrome(sub):\n        return sub == sub[::-1]\n\n    max_len = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if not is_palindrome(s[i:j]):\n                max_len = max(max_len, j-i)\n    return max_len\n\n# Read input\ns = input()\n\n# Compute and print result\nprint(longest_non_palindrome_substring(s))"}
{"solution": "def is_round_rated(n, ratings):\n    unchanged = all(r[0] == r[1] for r in ratings)\n    ordered = all(ratings[i][0] >= ratings[i+1][0] for i in range(n-1))\n    \n    if not unchanged:\n        return \"rated\"\n    elif not ordered:\n        return \"unrated\"\n    else:\n        return \"maybe\"\n\nn = int(input())\nratings = [list(map(int, input().split())) for _ in range(n)]\n\nprint(is_round_rated(n, ratings))"}
{"solution": "def solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    # Forward pass\n    last_zero = -1\n    for i in range(n):\n        if arr[i] == 0:\n            last_zero = i\n        arr[i] = i - last_zero\n    \n    # Backward pass\n    last_zero = n\n    for i in range(n-1, -1, -1):\n        if arr[i] == 0:\n            last_zero = i\n        arr[i] = min(arr[i], last_zero - i)\n    \n    print(*arr)\n\nsolve()"}
{"solution": "from math import gcd\n\ndef z_function(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            z[i] = min(r - i + 1, z[i - l])\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > r:\n            l, r = i, i + z[i] - 1\n    return z\n\ndef solve():\n    n = int(input())\n    s = input()\n    m = len(s)\n    z = z_function(s)\n    ans = 0\n    for i in range(1, m):\n        if s[:i] == s[m-i:]:\n            period = i\n            break\n    else:\n        period = m\n    g = gcd(n, m // period)\n    ans = (2 ** n - 2 ** (n - m % period)) // g + 2 ** (n - m % period)\n    print(ans)\n\nsolve()"}
{"solution": "from math import atan2, pi\n\ndef find_min_angle_vectors():\n    n = int(input())\n    vectors = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        angle = atan2(y, x)\n        if angle < 0:\n            angle += 2 * pi\n        vectors.append((angle, _ + 1))\n\n    vectors.sort()\n    min_diff = 2 * pi\n    result = (0, 0)\n\n    for i in range(n):\n        for j in range(i + 1, min(i + 3, n)):\n            diff = vectors[j][0] - vectors[i][0]\n            if diff > pi:\n                diff = 2 * pi - diff\n            if diff < min_diff:\n                min_diff = diff\n                result = (vectors[i][1], vectors[j][1])\n\n    # Check the angle between the last and first vector\n    diff = 2 * pi - (vectors[n - 1][0] - vectors[0][0])\n    if diff < min_diff:\n        result = (vectors[n - 1][1], vectors[0][1])\n\n    print(*result)\n\nfind_min_angle_vectors()"}
{"solution": "def min_time_to_post_office(d, k, a, b, t):\n    if d % k == 0:\n        repair_times = d // k - 1\n    else:\n        repair_times = d // k\n    \n    time_by_car_with_repairs = (d // k) * a + repair_times * t\n    time_by_foot = d * b\n    \n    return min(time_by_car_with_repairs, time_by_foot)\n\nd, k, a, b, t = map(int, input().split())\nprint(min_time_to_post_office(d, k, a, b, t))"}
{"solution": "import math\n\ndef find_sequence(n, k):\n    gcd = n // k\n    sequence = [gcd * i for i in range(1, k)]\n    remainder = n - sum(sequence)\n    sequence.append(remainder + gcd * (k))\n    if min(sequence) < 1:\n        return [-1]\n    else:\n        return sequence\n\ndef main():\n    n, k = map(int, input().split())\n    result = find_sequence(n, k)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_pairs(n, m):\n    \"\"\"\n    Counts the number of pairs (x, y) such that 1 \u2264 x \u2264 n, 1 \u2264 y \u2264 m and (x + y) is divisible by 5.\n    \"\"\"\n    # Initialize the result\n    result = 0\n    \n    # Precompute counts of numbers modulo 5 for both sequences\n    mod_counts_n = [0] * 5\n    mod_counts_m = [0] * 5\n    \n    # Count for sequence 1 to n\n    for i in range(1, n + 1):\n        mod_counts_n[i % 5] += 1\n    \n    # Count for sequence 1 to m\n    for j in range(1, m + 1):\n        mod_counts_m[j % 5] += 1\n    \n    # Calculate pairs where (x + y) % 5 == 0\n    result += mod_counts_n[0] * mod_counts_m[0]  # (0+0)%5==0\n    for i in range(1, 5):\n        if (5 - i) % 5 != 0:  # Avoid double counting for remainder 0\n            result += mod_counts_n[i] * mod_counts_m[(5 - i) % 5]\n    \n    return result // 2  # Each pair is counted twice\n\n# Read input\nn, m = map(int, input().split())\n\n# Output the result\nprint(count_pairs(n, m))"}
{"solution": "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n, x = map(int, input().split())\n    arr = list(map(int, input().split()))\n\n    dp = [[0 for _ in range(3)] for _ in range(n + 1)]\n    ans = 0\n\n    for i in range(1, n + 1):\n        dp[i][0] = max(dp[i - 1][0] + arr[i - 1], arr[i - 1])\n        dp[i][1] = max(dp[i - 1][0] + arr[i - 1] * x, dp[i - 1][1] + arr[i - 1] * x)\n        dp[i][2] = max(dp[i - 1][1] + arr[i - 1], dp[i - 1][2] + arr[i - 1])\n\n        ans = max(ans, dp[i][0], dp[i][1], dp[i][2])\n\n    print(ans)\n\nsolve()"}
{"solution": "import sys\nimport math\n\ndef count_less_equal(x, n, m):\n    count = 0\n    for i in range(1, n + 1):\n        count += min(m, x // i)\n    return count\n\ndef kth_largest(n, m, k):\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_less_equal(mid, n, m) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\nn, m, k = map(int, sys.stdin.readline().split())\nprint(kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    digit_length = 1\n    while k > digit_length * 9 * 10 ** (digit_length - 1):\n        k -= digit_length * 9 * 10 ** (digit_length - 1)\n        digit_length += 1\n    \n    quotient, remainder = divmod(k - 1, digit_length)\n    number = 10 ** (digit_length - 1) + quotient\n    \n    return int(str(number)[remainder])\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "def max_profit(n, m, r, s, b):\n    dp = [[0] * (r + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = 0\n    \n    for j in range(1, r + 1):\n        dp[0][j] = j\n    \n    for i in range(1, n + 1):\n        for j in range(1, r + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= s[i - 1]:\n                for k in range(m):\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - s[i - 1]] + b[k] * (j // s[i - 1]))\n    \n    return dp[n][r]\n\nn, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(max_profit(n, m, r, s, b))"}
{"solution": "def find_overlap(s):\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if s.startswith(s[i:], n - i):\n            return s[:n - i]\n    return \"\"\n\ns = input().strip()\nn = len(s)\n\nif n == 1 or n == 2:\n    print(\"NO\")\nelse:\n    overlap = find_overlap(s)\n    if overlap == \"\":\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(overlap)"}
{"solution": "def find_teams(n):\n    \"\"\"\n    Finds the number of teams that can be invited so that the tournament needs exactly n games.\n    :param n: Total number of games to be played.\n    :return: A list of possible numbers of teams or -1 if not possible.\n    \"\"\"\n    possible_teams = []\n    while n > 0:\n        # Check if current n can be reached by the given process\n        m = 1\n        while n - m > 0 and (n - m) % m == 0:\n            if n - m == m * ((m - 1) // 2) or m == 1:\n                possible_teams.append(m + 2 * ((n - m) // m))\n            m *= 2\n        if m > n:\n            break\n        n -= m\n        m //= 2\n        while m > 0 and n % m == 0:\n            n //= m\n            m //= 2\n    return possible_teams if possible_teams else [-1]\n\n# Example usage\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    result = find_teams(n)\n    for team_count in result:\n        print(team_count)"}
{"solution": "from collections import Counter\n\ndef max_antipalindromic_beauty(n, s, b):\n    \"\"\"\n    Calculate the maximum possible beauty of an antipalindromic permutation of string s.\n    \n    :param n: Length of the string s (even)\n    :param s: String consisting of n lowercase Latin letters\n    :param b: List of integers representing the beauty of each index\n    :return: Maximum possible beauty of an antipalindromic permutation\n    \"\"\"\n    char_count = Counter(s)\n    if any(count > n // 2 for count in char_count.values()):\n        exit(-1)\n\n    char_index = {char: [] for char in char_count}\n    for i, char in enumerate(s):\n        char_index[char].append(i)\n\n    sorted_chars = sorted(char_count, key=lambda x: -len(char_index[x]))\n    used_indices = set()\n    beauty_sum = 0\n\n    for char in sorted_chars:\n        for i in range(len(char_index[char]) // 2):\n            left, right = char_index[char][i], char_index[char][-1 - i]\n            if left not in used_indices and right not in used_indices:\n                beauty_sum += max(b[left], b[right])\n                used_indices.update([left, right])\n\n    return beauty_sum\n\n# Input\nn = int(input())\ns = input().strip()\nb = list(map(int, input().split()))\n\nprint(max_antipalindromic_beauty(n, s, b))"}
{"solution": "def can_weigh(w, m):\n    if m == 0:\n        return \"YES\"\n    balances = {0}\n    for i in range(101):\n        new_balances = set()\n        for b in balances:\n            new_balances.add(b + w ** i)\n            new_balances.add(abs(b - w ** i))\n        balances = new_balances\n        if m in balances or -m in balances:\n            return \"YES\"\n    return \"NO\"\n\nw, m = map(int, input().split())\nprint(can_weigh(w, m))"}
{"solution": "import sys\n\ndef solve(n, k):\n    bits = []\n    i = 0\n    while n > 0:\n        if n & 1:\n            bits.append(i)\n        n >>= 1\n        i += 1\n    \n    if len(bits) > k:\n        print(\"No\")\n        return\n    \n    while len(bits) < k:\n        if bits:\n            bits.append(bits[-1])\n        else:\n            bits.append(-1)\n    \n    min_y = max(bits)\n    for i in range(k - 1, -1, -1):\n        if bits[i] == min_y:\n            continue\n        if min_y >= 0:\n            bits[i] = min_y - 1\n        else:\n            bits[i] = -1\n    \n    print(\"Yes\")\n    print(\" \".join(map(str, bits)))\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    solve(n, k)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def pour_champagne(n, t):\n    levels = [[0] * (i + 1) for i in range(n)]\n    levels[0][0] = t\n    for i in range(n):\n        for j in range(len(levels[i])):\n            if i > 0:\n                overflow_from_above = (levels[i-1][j] // 2) if j > 0 else 0\n                overflow_from_above += (levels[i-1][j-1] // 2) if j-1 >= 0 else 0\n                levels[i][j] += overflow_from_above\n            if levels[i][j] >= 1:\n                overflow = levels[i][j] - 1\n                levels[i][j] = 1\n                if i < n - 1:\n                    levels[i+1][j] += overflow / 2.0\n                    levels[i+1][j+1] += overflow / 2.0 if j+1 < len(levels[i+1]) else 0\n    return sum(1 for row in levels for glass in row if glass == 1)\n\n# Reading input\nn, t = map(int, input().split())\n\n# Processing and printing output\nprint(pour_champagne(n, t))"}
{"solution": "def calculate_area(points):\n    x_coords = sorted([point[0] for point in points])\n    y_coords = sorted([point[1] for point in points])\n\n    width = x_coords[-1] - x_coords[0]\n    height = y_coords[-1] - y_coords[0]\n\n    return width * height\n\ndef can_determine_area(n, vertices):\n    if n < 2:\n        return -1\n\n    unique_x = len(set(vertex[0] for vertex in vertices))\n    unique_y = len(set(vertex[1] for vertex in vertices))\n\n    if unique_x == 1 or unique_y == 1:\n        return -1\n\n    if (unique_x == 2 and unique_y == 2) or n == 4:\n        return calculate_area(vertices)\n\n    return -1\n\nn = int(input())\nvertices = [list(map(int, input().split())) for _ in range(n)]\n\nprint(can_determine_area(n, vertices))"}
{"solution": "def min_wooden_bars(n, a, b):\n    total_length_needed = 4 * a + 2 * b\n    if n >= total_length_needed:\n        return 1\n    else:\n        return -(-total_length_needed // n)  # Equivalent to ceil division\n\n# Reading input\nn = int(input())\na = int(input())\nb = int(input())\n\n# Output\nprint(min_wooden_bars(n, a, b))"}
{"solution": "def can_sort_by_swaps(n, a, swaps):\n    forbidden = set()\n    for i in range(n-1):\n        if swaps[i] == '0':\n            forbidden.add(a[i])\n            forbidden.add(a[i+1])\n    \n    last = None\n    for num in sorted(forbidden):\n        if last is not None and num < last:\n            return \"NO\"\n        last = num\n    \n    return \"YES\"\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\nswaps = input()\n\n# Printing output\nprint(can_sort_by_swaps(n, a, swaps))"}
{"solution": "def calculate_wait_time(seat_info: str) -> int:\n    \"\"\"\n    Calculates the wait time for Vasya to get his lunch based on his seat information.\n    \"\"\"\n    row, seat = seat_info[:-1], seat_info[-1]\n    row_num = int(row)\n    seconds = 0\n    current_row_first_attendant = 1\n    current_row_second_attendant = 3\n    move_by = 1\n\n    while True:\n        if current_row_first_attendant == row_num or current_row_second_attendant == row_num:\n            break\n        seconds += 6 + move_by\n        current_row_first_attendant += move_by\n        current_row_second_attendant += move_by\n        move_by = 3 - move_by\n\n    if current_row_first_attendant == row_num:\n        seconds += ['f', 'e', 'd', 'c'].index(seat) + 1\n    else:\n        seconds += ['d', 'e', 'f', 'c', 'b', 'a'].index(seat) + 1\n\n    return seconds\n\n# Reading input\nseat_info = input().strip()\nprint(calculate_wait_time(seat_info))"}
{"solution": "def convert_to_decimal(digits, base):\n    return sum(int(digit) * (base ** i) for i, digit in enumerate(reversed(digits)))\n\ndef compare_numbers(n, bx, x_digits, m, by, y_digits):\n    x_decimal = convert_to_decimal(x_digits, bx)\n    y_decimal = convert_to_decimal(y_digits, by)\n    \n    if x_decimal == y_decimal:\n        return '='\n    elif x_decimal < y_decimal:\n        return '<'\n    else:\n        return '>'\n\n# Input\nn, bx = map(int, input().split())\nx_digits = input().split()\nm, by = map(int, input().split())\ny_digits = input().split()\n\nprint(compare_numbers(n, bx, x_digits, m, by, y_digits))"}
{"solution": "from functools import reduce\nfrom operator import xor\n\ndef find_winner():\n    # Reading input\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    # Applying Sprague-Grundy theorem\n    # For each number, calculate the nim-sum (XOR) of the differences from the smallest number\n    smallest = min(a)\n    nim_sum = 0\n    for num in a:\n        nim_sum = nim_sum ^ (num - smallest)\n\n    # If the nim-sum is 0, the first player loses (since no winning move can be made)\n    # Otherwise, the first player wins\n    if nim_sum == 0:\n        print(\"BitAryo\")\n    else:\n        print(\"BitLGM\")\n\nfind_winner()"}
{"solution": "from math import gcd\n\ndef count_valid_decks(n, k, cards):\n    factors = []\n    for i in range(2, int(k**0.5) + 1):\n        if k % i == 0:\n            factors.append(i)\n            if i * i != k:\n                factors.append(k // i)\n    factors.append(k)\n    factors = list(set(factors))\n    \n    factor_counts = {f: [] for f in factors}\n    prefix_gcds = [0] * (n + 1)\n    suffix_gcds = [0] * (n + 1)\n    \n    current_gcd = 0\n    for i in range(n):\n        current_gcd = gcd(current_gcd, cards[i])\n        prefix_gcds[i + 1] = current_gcd\n        if current_gcd in factors:\n            factor_counts[current_gcd].append(i)\n\n    current_gcd = 0\n    for i in range(n - 1, -1, -1):\n        current_gcd = gcd(current_gcd, cards[i])\n        suffix_gcds[i] = current_gcd\n\n    total_ways = 0\n    for factor in factors:\n        for index in factor_counts[factor]:\n            left_options = n - index\n            right_options = index + 1\n            while index + 1 < n and prefix_gcds[index + 1] == factor:\n                right_options += 1\n            while suffix_gcds[index] == factor and index > 0:\n                left_options -= 1\n                index -= 1\n            total_ways += left_options * right_options\n    return total_ways\n\n# Reading input\nn, k = map(int, input().split())\ncards = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(count_valid_decks(n, k, cards))"}
{"solution": "def can_distribute_balloons(n, k, s):\n    from collections import Counter\n    balloon_counts = Counter(s)\n    max_count = max(balloon_counts.values())\n    return \"YES\" if max_count <= k else \"NO\"\n\n# Example usage:\n# n, k = map(int, input().split())\n# s = input()\n# print(can_distribute_balloons(n, k, s))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\nmin_val = min(a)\npositions = [i for i, x in enumerate(a) if x == min_val]\nprint(min(positions[i+1] - positions[i] for i in range(len(positions)-1)))"}
{"solution": "from math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(t, w, b):\n    if w == b:\n        numerator = t // w + 1\n        denominator = 2 * (t // w + 1)\n    else:\n        max_steps_w = (t // w) * w\n        max_steps_b = (t // b) * b\n        \n        common_step = lcm(w, b)\n        \n        full_cycles = min(max_steps_w, max_steps_b) // common_step\n        \n        cycle_length = common_step - 1\n        tied_distances = 0\n        \n        for distance in range(common_step):\n            if distance % w == 0 and distance % b == 0:\n                tied_distances += 1\n        \n        numerator = (tied_distances * (full_cycles)) + sum(1 for x in range(full_cycles * common_step, min(max_steps_w, max_steps_b) + 1) if x % w == 0 and x % b == 0)\n        denominator = t\n    \n    common_divisor = gcd(numerator, denominator)\n    \n    return f\"{numerator // common_divisor}/{denominator // common_divisor}\"\n\n# Reading input\nt, w, b = map(int, input().split())\n\n# Solving and printing output\nprint(solve(t, w, b))"}
{"solution": "def determine_vote_outcome(x, y, z):\n    if z == 0:\n        if x > y:\n            return '+'\n        elif y > x:\n            return '-'\n        else:\n            return '0'\n    \n    diff = x - y\n    max_possible_upvotes = x + z\n    max_possible_downvotes = y + z\n    \n    if abs(diff) > z:\n        return '+' if diff > 0 else '-'\n    elif diff == z:\n        return '0'\n    else:\n        if max_possible_upvotes > max_possible_downvotes:\n            return '?'\n        elif max_possible_downvotes > max_possible_upvotes:\n            return '?'\n        else:\n            return '0'\n\n# Read input\nx, y, z = map(int, input().split())\n\n# Determine and print the outcome\nprint(determine_vote_outcome(x, y, z))"}
{"solution": "def min_operations_to_target(n, ops, target):\n    x, y = 0, 0\n    min_x, max_x = 0, 0\n    min_y, max_y = 0, 0\n    for i, op in enumerate(ops):\n        if op == 'R':\n            x += 1\n            max_x = i + 1\n        elif op == 'L':\n            x -= 1\n            min_x = i + 1\n        elif op == 'U':\n            y += 1\n            max_y = i + 1\n        else:\n            y -= 1\n            min_y = i + 1\n\n    dx, dy = abs(target[0]), abs(target[1])\n    if dx + dy < n and (dx - (n - max_y - min_y)) * (dx - (max_x - min_x)) <= 0 and (dy - (n - max_x - min_x)) * (dy - (max_y - min_y)) <= 0:\n        return n - max(max_y - min_y, max_x - min_x) - (dx + dy - n)\n    elif dx + dy == n:\n        return n if (target[0] >= 0 and max_x - min_x >= dx) and (target[1] >= 0 and max_y - min_y >= dy) else -1\n    else:\n        return -1\n\n# Reading inputs\nn = int(input())\nops = input().strip()\ntarget = list(map(int, input().split()))\n\n# Output\nprint(min_operations_to_target(n, ops, target))"}
{"solution": "from collections import defaultdict\n\ndef solve_balance_prefixes(s, x):\n    \"\"\"\n    Solves for the number of prefixes of t with a balance equal to x.\n    If the number of such prefixes is infinite, returns -1.\n    \"\"\"\n    balance = 0\n    balance_counts = defaultdict(int)\n    balance_counts[0] = 1\n    cycle_balance = 0\n    cycle_count = 0\n    full_cycles = 0\n    \n    for char in s:\n        balance += 1 if char == '1' else -1\n        cycle_balance += 1 if char == '1' else -1\n        if balance - x in balance_counts:\n            if balance - x == 0 and balance_counts[0] > 1:\n                return -1\n            cycle_count += balance_counts[balance - x]\n        balance_counts[balance] += 1\n    \n    if cycle_balance == 0:\n        return -1 if x == 0 and 0 in balance_counts else len(balance_counts)\n    \n    if x % cycle_balance == 0:\n        full_cycles = x // cycle_balance\n        if balance - x in balance_counts:\n            return sum(range(1, full_cycles)) * cycle_count + balance_counts[balance - x]\n        else:\n            return sum(range(1, full_cycles)) * cycle_count\n    else:\n        return len(balance_counts)\n\n# Reading input\nT = int(input())\nresults = []\nfor _ in range(T):\n    n, x = map(int, input().split())\n    s = input()\n    results.append(solve_balance_prefixes(s, x))\n\n# Printing output\nprint('\\n'.join(map(str, results)))"}
{"solution": "def min_deletions_to_divisible(n, k):\n    n_str = str(n)\n    zeros_needed = k\n    non_zero_count = 0\n    result = 0\n\n    for i in range(len(n_str) - 1, -1, -1):\n        if zeros_needed == 0:\n            break\n        if n_str[i] != '0':\n            non_zero_count += 1\n        elif non_zero_count > 0:\n            result += 1\n            non_zero_count = 0\n            zeros_needed -= 1\n\n    return result + max(zeros_needed - 1, 0)\n\n# Example usage\nn, k = map(int, input().split())\nprint(min_deletions_to_divisible(n, k))"}
{"solution": "def solve(n, m, k, x, y):\n    cycle_len = 2 * n * m - 2 * m\n    cycles, remainder = divmod(k, cycle_len)\n    \n    max_questions = cycles\n    min_questions = cycles\n    \n    if n == 1 or m == 1:\n        sergei_questions = k // m if m == 1 else k\n    else:\n        sergei_questions = cycles * (m // (m - 1))\n        \n        up_rows = cycles * n\n        down_rows = cycles * (n - 1)\n        \n        while remainder > 0:\n            if up_rows < down_rows:\n                up_rows += 1\n                remainder -= m\n            else:\n                down_rows += 1\n                remainder -= m\n                \n            if remainder >= m:\n                remainder -= m\n                sergei_questions += 1\n        \n        max_questions += up_rows\n        min_questions += down_rows\n    \n    return max_questions, min_questions, sergei_questions\n\nn, m, k, x, y = map(int, input().split())\nmax_q, min_q, sergei_q = solve(n, m, k, x, y)\nprint(max_q, min_q, sergei_q)"}
{"solution": "from collections import Counter\n\ndef max_ribbon_beauty(s):\n    counts = Counter(s)\n    most_common = counts.most_common(1)[0][1]\n    return most_common + 1 if most_common * 2 > len(s) else most_common\n\ndef find_winner(n, ribbons):\n    names = [\"Kuro\", \"Shiro\", \"Katie\"]\n    beauties = [max_ribbon_beauty(ribbon) for ribbon in ribbons]\n\n    max_beauty = max(beauties)\n    winners = [names[i] for i, beauty in enumerate(beauties) if beauty == max_beauty]\n\n    return \"Draw\" if len(winners) > 1 else winners[0]\n\n# Reading input\nn = int(input())\nribbons = [input() for _ in range(3)]\n\n# Outputting result\nprint(find_winner(n, ribbons))"}
{"solution": "def days_to_finish_book(c, v0, v1, a, l):\n    days = 0\n    current_speed = v0\n    total_pages_read = 0\n    while total_pages_read < c:\n        # Adjust reading speed based on limits\n        if current_speed > v1:\n            current_speed = v1\n        else:\n            current_speed = min(current_speed, c - total_pages_read)\n\n        # Calculate new total pages read\n        if days > 0:\n            total_pages_read += current_speed - l\n        else:\n            total_pages_read += current_speed\n\n        # Increment day counter\n        days += 1\n\n        # Increase speed for next day if not already at max\n        if current_speed < v1:\n            current_speed += a\n\n    return days\n\n# Read input values\nc, v0, v1, a, l = map(int, input().split())\n\n# Calculate and print the result\nprint(days_to_finish_book(c, v0, v1, a, l))"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nn = int(input())\n\nif is_prime(n):\n    print(1)\n    print(n)\nelse:\n    for i in range(2, n):\n        if is_prime(i) and is_prime(n - i - 2):\n            print(3)\n            print(2, i, n - i - 2)\n            break\n    else:\n        print(2)\n        for i in range(2, n):\n            if is_prime(i) and is_prime(n - i):\n                print(i, n - i)\n                break"}
{"solution": "def solve():\n    from collections import Counter\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n)]\n    \n    row_counts = [row.count('*') for row in grid]\n    col_counts = [col.count('*') for col in zip(*grid)]\n    \n    total_walls = sum(row_counts)\n    \n    if total_walls == 0:\n        print(\"YES\")\n        print(1, 1)\n        return\n    \n    for i in range(n):\n        for j in range(m):\n            if row_counts[i] + col_counts[j] == total_walls:\n                print(\"YES\")\n                print(i + 1, j + 1)\n                return\n    \n    print(\"NO\")\n\nsolve()"}
{"solution": "def min_cost(n, m, a, b):\n    remainder = n % m\n    if remainder == 0:\n        return 0\n    cost_build = (m - remainder) * a if (n < (m - remainder)) else ((n + (m - remainder)) * a - n * b)\n    cost_demolish = remainder * b if (n > remainder) else ((n - remainder) * b - n * a)\n    return min(cost_build, cost_demolish)\n\nn, m, a, b = map(int, input().split())\nprint(min_cost(n, m, a, b))"}
{"solution": "def max_odd_subsequence_sum():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    max_even_sum = 0\n    max_odd_sum = float('-inf')\n    \n    for num in arr:\n        if num % 2 == 0:\n            max_even_sum = max(max_even_sum + num, 0)\n        else:\n            max_odd_sum = max(max_odd_sum, max_even_sum + num)\n            max_even_sum = max(max_even_sum, 0)\n    \n    print(max_odd_sum)\n\nmax_odd_subsequence_sum()"}
{"solution": "from collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef solve(songs, T):\n    dp = defaultdict(int)\n    dp[0, -1] = 1  # Base case: 0 time with no previous song\n    \n    for time in range(1, T + 1):\n        for prev_genre in range(3):\n            for i, (duration, genre) in enumerate(songs):\n                if time >= duration and prev_genre != genre:\n                    dp[time, i] += dp[time - duration, prev_genre]\n                    dp[time, i] %= MOD\n                    \n    result = sum(dp[T, i] for i in range(len(songs))) % MOD\n    return result\n\n# Read input\nn, T = map(int, input().split())\nsongs = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Solve and print the result\nprint(solve(songs, T))"}
{"solution": "from math import gcd\nMOD = 10**9 + 7\n\ndef mod_inverse(x):\n    return pow(x, MOD-2, MOD)\n\ndef solve(m):\n    dp = [0] * (m+1)\n    dp[1] = 1\n    for x in range(2, m+1):\n        lcm_x = x\n        dp[x] = (1 + sum(dp[gcd(x, y)] for y in range(1, m+1) if x != y and gcd(x, y) == 1)) % MOD\n    total_sum = sum(dp[i] for i in range(1, m+1))\n    return (total_sum * mod_inverse(m)) % MOD\n\nm = int(input())\nprint(solve(m))"}
{"solution": "from math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_good_pairs(l, r, x, y):\n    count = 0\n    for a in range(max(l, x), min(r + 1, y // x) + 1):\n        if y % a == 0:\n            b = y // a\n            if gcd(a, b) == x and a <= r and b >= l:\n                count += max(0, min(r, b) - max(l, a) + 1)\n    return count\n\ndef main():\n    l, r, x, y = map(int, input().split())\n    print(count_good_pairs(l, r, x, y))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef find_min_k(a, b):\n    min_lcm = lcm(a, b)\n    result_k = 0\n    \n    for k in range(0, max(a, b) + 1):\n        current_lcm = lcm(a + k, b + k)\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            result_k = k\n            \n    return result_k\n\na, b = map(int, input().split())\nprint(find_min_k(a, b))"}
{"solution": "def min_hacks(n, k, marks):\n    current_sum = sum(marks)\n    target_sum = ((n + 100) * k) // 10 // 9 * 9 + 10 - current_sum\n    \n    return max(0, (target_sum + k - 1) // k - n)\n\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\nprint(min_hacks(n, k, marks))"}
{"solution": "def find_divisor(arr):\n    \"\"\"\n    Finds a divisor d such that after dividing each element of arr by d,\n    at least half of the elements are positive.\n    Returns the divisor if found, otherwise returns 0.\n    \"\"\"\n    n = len(arr)\n    ceil_half = -(-n // 2)  # Equivalent to math.ceil(n / 2)\n\n    for d in range(-1000, 1001):\n        if d == 0:\n            continue\n        positive_count = sum(1 for x in arr if x / d > 0)\n        if positive_count >= ceil_half:\n            return d\n\n    return 0\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Processing and printing output\nprint(find_divisor(arr))"}
{"solution": "n = int(input())\nmod = n % 10\nif mod == 0:\n    print(n // 5 * (n // 5 - 1))\nelif mod <= 5:\n    print((n // 5 + 1) * mod - 1)\nelse:\n    print((n // 5 + 1) * (10 - mod) - 1)"}
{"solution": "from math import gcd\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\ns1 = a1 * b1\ns2 = a2 * b2\n\nif s1 == s2:\n    print(0)\n    print(f\"{a1} {b1}\")\n    print(f\"{a2} {b2}\")\nelse:\n    steps = 0\n    found = False\n    \n    def adjust_size(s1, s2, steps):\n        nonlocal found\n        if s1 % 2 == 0:\n            s1 //= 2\n            steps += 1\n            if s1 == s2:\n                found = True\n                return s1, s2, steps\n            else:\n                return adjust_size(s1, s2, steps)\n        elif s1 % 3 == 0:\n            s1 //= 3\n            steps += 1\n            if s1 == s2:\n                found = True\n                return s1, s2, steps\n            else:\n                return adjust_size(s1, s2, steps)\n        return s1, s2, steps\n    \n    if s1 > s2:\n        s1, s2, steps = adjust_size(s1, s2, steps)\n    else:\n        s1, s2, steps = adjust_size(s2, s1, steps)\n    \n    if found:\n        d1 = gcd(a1, b1)\n        d2 = gcd(a2, b2)\n        \n        a1 //= d1\n        b1 //= d1\n        a2 //= d2\n        b2 //= d2\n        \n        if s1 == s2:\n            print(steps)\n            print(f\"{a1} {b1}\")\n            print(f\"{a2} {b2}\")\n        else:\n            print(-1)\n    else:\n        print(-1)"}
{"solution": "def game_winner(xp, yp, xv, yv):\n    # Check if Polycarp can win in one move\n    if xp == 0 and yp == 0:\n        return \"Polycarp\"\n    \n    # Check if Vasiliy can win in one move\n    if xv == 0 and yv == 0:\n        return \"Vasiliy\"\n    \n    # Calculate the minimum moves required for each player to reach (0, 0)\n    polycarp_moves = xp + yp\n    vasiliy_moves = xv + yv - min(xv, yv)\n    \n    # If Polycarp can reach (0, 0) in fewer moves than Vasiliy, he wins\n    if polycarp_moves < vasiliy_moves:\n        return \"Polycarp\"\n    else:\n        return \"Vasiliy\"\n\n# Read input\nxp, yp, xv, yv = map(int, input().split())\n\n# Determine the winner\nwinner = game_winner(xp, yp, xv, yv)\n\n# Output the winner\nprint(winner)"}
{"solution": "def calendar_columns(month, first_day):\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    total_days = days_in_month[month - 1]\n    full_weeks, extra_days = divmod(total_days + first_day - 1, 7)\n    return full_weeks + (1 if extra_days > 0 else 0)\n\n# Reading input\nm, d = map(int, input().split())\n\n# Calculating and printing the result\nprint(calendar_columns(m, d))"}
{"solution": "import math\n\ndef count_zeros_in_range(start, end):\n    def count_for_year(year):\n        if year == 0:\n            return 0\n        exp = math.floor(math.log(year, 2))\n        base = 2 ** exp\n        full_cycles = year // (base * 2)\n        result = full_cycles * base\n        result += min(max(year % (base * 2) - base + 1, 0), base - 1)\n        return result\n\n    return count_for_year(end) - count_for_year(start - 1)\n\nif __name__ == \"__main__\":\n    a, b = map(int, input().split())\n    print(count_zeros_in_range(a, b))"}
{"solution": "def min_layers(N):\n    return N * (N + 1) // 2\n\n# Example check (This line is not part of the solution and should not be included in the submitted code)\nprint(min_layers(4))  # Expected output: 6"}
{"solution": "from math import factorial\n\ndef solve_cubes(n, k, S, cubes):\n    dp = [[[0 for _ in range(S + 1)] for _ in range(k + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        val, fact_val = cubes[i - 1], factorial(cubes[i - 1])\n        for j in range(k + 1):\n            for s in range(S + 1):\n                if s >= val:\n                    dp[i][j][s] += dp[i - 1][j][s - val]\n                if j > 0 and s >= fact_val:\n                    dp[i][j][s] += dp[i - 1][j - 1][s - fact_val]\n\n    return dp[n][k][S]\n\nn, k, S = map(int, input().split())\ncubes = list(map(int, input().split()))\nprint(solve_cubes(n, k, S, cubes))"}
{"solution": "from collections import Counter\n\ndef can_achieve_array(n, k, a):\n    power_counts = Counter()\n    max_power = 0\n    for value in a:\n        if value == 0:\n            continue\n        if value > k ** (n - 1):\n            return False\n        power = 0\n        while value > 0:\n            if value % k != 0:\n                if power_counts[power] >= k ** (n - 1 - max(0, max_power - power)):\n                    return False\n                power_counts[power] += 1\n                max_power = max(max_power, power)\n            value //= k\n            power += 1\n    return all(count <= k ** (n - 1 - max(0, max_power - power)) for power, count in power_counts.items())\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        n, k = map(int, input().split())\n        a = list(map(int, input().split()))\n        print(\"YES\" if can_achieve_array(n, k, a) else \"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 1073741824\n\ndef divisors_count(n):\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n        i += 1\n    return count\n\ndef compute_sum(a, b, c):\n    result = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                result += divisors_count(i * j * k)\n                result %= MOD\n    return result\n\na, b, c = map(int, input().split())\nprint(compute_sum(a, b, c))"}
{"solution": "# Capture the initial configurations of Bessie's and Elsie's puzzles\nbessie_puzzle = [input() for _ in range(2)]\nelsie_puzzle = [input() for _ in range(2)]\n\n# Flatten the puzzles for easier manipulation\nbessie_flat = ''.join(bessie_puzzle)\nelsie_flat = ''.join(elsie_puzzle)\n\n# Check if the puzzles are already in the same configuration\nif bessie_flat == elsie_flat:\n    print(\"YES\")\nelse:\n    # Identify the index of the empty space ('X') in both puzzles\n    bessie_empty_index = bessie_flat.index('X')\n    elsie_empty_index = elsie_flat.index('X')\n\n    # Possible configurations after moving the empty space ('X') in Bessie's puzzle\n    possible_bessie_configs = [\n        bessie_flat[0: bessie_empty_index] + bessie_flat[bessie_empty_index - 1] +\n        bessie_flat[bessie_empty_index] + bessie_flat[bessie_empty_index + 1:]\n        if bessie_empty_index != 0 and bessie_empty_index != 3 else bessie_flat,\n        bessie_flat[0: bessie_empty_index] + bessie_flat[bessie_empty_index + 1] +\n        bessie_flat[bessie_empty_index] + bessie_flat[bessie_empty_index - 1] +\n        bessie_flat[bessie_empty_index + 2:]\n        if bessie_empty_index != 1 and bessie_empty_index != 2 else bessie_flat,\n        bessie_flat[bessie_empty_index: bessie_empty_index + 2] +\n        bessie_flat[bessie_empty_index - 2] + bessie_flat[bessie_empty_index] +\n        bessie_flat[bessie_empty_index + 2:]\n        if bessie_empty_index != 0 and bessie_empty_index != 1 else bessie_flat,\n        bessie_flat[bessie_empty_index - 2] + bessie_flat[bessie_empty_index - 1] +\n        bessie_flat[bessie_empty_index] + bessie_flat[bessie_empty_index + 1]\n        if bessie_empty_index != 2 and bessie_empty_index != 3 else bessie_flat\n    ]\n\n    # Check if any of the possible configurations match Elsie's puzzle\n    if elsie_flat in possible_bessie_configs:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "def convert_to_decimal(n, k):\n    k = str(k)\n    length = len(k)\n    low, high = 0, 10**18\n\n    while low < high:\n        mid = (low + high) // 2\n        temp, power = 0, 1\n\n        for i in range(length - 1, -1, -1):\n            temp += int(k[i]) * power\n            if power > (10**18):\n                break\n            power *= n\n\n        if power > (10**18):\n            high = mid\n            continue\n\n        if temp == mid:\n            return mid\n        elif temp < mid:\n            low = mid\n        else:\n            high = mid\n\n    return low\n\nn = int(input())\nk = int(input())\nprint(convert_to_decimal(n, k))"}
{"solution": "def is_unimodal(arr):\n    n = len(arr)\n    increasing = True\n    constant_started = False\n    for i in range(1, n):\n        if increasing:\n            if arr[i] < arr[i - 1]:\n                increasing = False\n                constant_started = False\n            elif arr[i] == arr[i - 1]:\n                constant_started = True\n        else:\n            if arr[i] >= arr[i - 1]:\n                return False\n    return True if not increasing or constant_started else False\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(\"YES\" if is_unimodal(arr) else \"NO\")"}
{"solution": "import math\n\ndef find_max_value(n, k):\n    \"\"\"\n    Finds the maximum value that appears in at least k paths from 1 to n.\n    \"\"\"\n    def path_length(x):\n        length = 0\n        while x > 1:\n            x = x // 2 if x % 2 == 0 else x - 1\n            length += 1\n        return length\n    \n    low, high = 1, int(2e18)\n    \n    while low < high:\n        mid = (low + high + 1) // 2\n        # Calculate the number of numbers with path length >= mid\n        count = n - 2 * mid + 2 + max(0, (n - mid) // (mid * 2))\n        if count >= k:\n            low = mid\n        else:\n            high = mid - 1\n            \n    return low\n\n# Example check function calls\nprint(find_max_value(11, 3))  # Output: 5\nprint(find_max_value(11, 6))  # Output: 4\nprint(find_max_value(20, 20)) # Output: 1\nprint(find_max_value(14, 5))  # Output: 6\nprint(find_max_value(1000000, 100)) # Output: 31248"}
{"solution": "def find_pocket(n, m, x, y, vx, vy):\n    if vx == 0 and vy == 0:\n        return -1\n\n    if vx == 0:\n        if vy > 0:\n            return 0 if y + vy * m == m else -1\n        else:\n            return 0 if y + vy * m == 0 else -1\n\n    if vy == 0:\n        if vx > 0:\n            return 0 if x + vx * m == m else -1\n        else:\n            return 0 if x + vx * m == 0 else -1\n\n    slope = abs(vy / vx)\n    if vx > 0 and vy > 0:\n        meet_y = (m - y) / slope\n        meet_x = n - x\n        if meet_y < meet_x:\n            return 0 if y + vy * (m - y) == m else -1\n        else:\n            return 0 if x + vx * (n - x) == n else -1\n    elif vx > 0 and vy < 0:\n        meet_y = y / slope\n        meet_x = n - x\n        if meet_y < meet_x:\n            return 0 if y + vy * y == 0 else -1\n        else:\n            return 0 if x + vx * (n - x) == n else -1\n    elif vx < 0 and vy > 0:\n        meet_y = (m - y) / slope\n        meet_x = x\n        if meet_y < meet_x:\n            return 0 if y + vy * (m - y) == m else -1\n        else:\n            return 0 if x + vx * x == 0 else -1\n    else:\n        meet_y = y / slope\n        meet_x = x\n        if meet_y < meet_x:\n            return 0 if y + vy * y == 0 else -1\n        else:\n            return 0 if x + vx * x == 0 else -1\n\n# Example usage\nn, m, x, y, vx, vy = map(int, input().split())\nprint(find_pocket(n, m, x, y, vx, vy))"}
{"solution": "def can_place_paintings(board_dim, painting_dims):\n    \"\"\"\n    Determines if two paintings can be placed on a board without overlapping.\n    \n    :param board_dim: Tuple (a1, b1) representing dimensions of the board.\n    :param painting_dims: List of tuples [(a2, b2), (a3, b3)] representing dimensions of the paintings.\n    :return: \"YES\" if paintings can be placed on the board, \"NO\" otherwise.\n    \"\"\"\n    # Sort the board dimensions to ensure max dimension is always first\n    board_dim = sorted(board_dim, reverse=True)\n    # Sort each painting dimension and then sort the list of paintings\n    painting_dims = sorted([sorted(dim, reverse=True) for dim in painting_dims])\n    \n    # Check all combinations of placing paintings on the board\n    for _ in range(2):\n        if (painting_dims[0][0] + painting_dims[1][0] <= board_dim[0] and\n                max(painting_dims[0][1], painting_dims[1][1]) <= board_dim[1]):\n            return \"YES\"\n        # Try rotating the second painting by swapping its dimensions\n        painting_dims[1] = painting_dims[1][::-1]\n    return \"NO\"\n\n# Read input from stdin\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\n# Call function with input and print result\nprint(can_place_paintings((a1, b1), [(a2, b2), (a3, b3)]))"}
{"solution": "import math\nfrom collections import defaultdict\n\ndef solve(b1, q, l, m, bad):\n    if q == 0:\n        if abs(b1) <= l and b1 not in bad:\n            return 1\n        else:\n            return 0\n\n    bad_set = set(bad)\n\n    def count_terms_in_range(b1, q, l):\n        if q > 0:\n            n = int(math.log(l / abs(b1), abs(q))) + 1 if b1 != 0 else 1\n        else:\n            n = int(math.log(l / abs(b1), abs(q))) + 2 if b1 != 0 else 1\n        return n\n\n    total_positive = count_terms_in_range(b1, q, l)\n    total_negative = count_terms_in_range(-b1, -q, l)\n\n    # Handle the case when b1 is 0 separately\n    if b1 == 0:\n        if 0 in bad_set:\n            return 0\n        else:\n            return \"inf\"\n\n    # Check for cycles due to bad numbers\n    cycle_detected = False\n    visited = set()\n    current = b1\n    steps = 0\n    while current not in visited and not cycle_detected:\n        visited.add(current)\n        if abs(current) > l:\n            break\n        if current in bad_set:\n            steps += 1\n        current = current * q\n        if abs(current) > l:\n            break\n        if current in visited:\n            cycle_detected = True\n\n    if cycle_detected:\n        return \"inf\"\n\n    total_skipped = sum(1 for i in range(total_positive + total_negative) if b1 * (q ** i) in bad_set)\n\n    return (total_positive + total_negative) - total_skipped\n\nb1, q, l, m = map(int, input().split())\nbad = list(map(int, input().split()))\n\nprint(solve(b1, q, l, m, bad))"}
{"solution": "import sys\n\ndef find_frame(n, m, screen):\n    top, bottom, left, right = None, None, None, None\n    \n    # Find top and bottom rows\n    for i in range(n):\n        if 'w' in screen[i]:\n            if top is None:\n                top = i\n            bottom = i\n    \n    # Find leftmost and rightmost columns\n    for j in range(m):\n        if any(screen[i][j] == 'w' for i in range(n)):\n            if left is None:\n                left = j\n            right = j\n    \n    # Check if all white pixels form a valid frame\n    for i in range(top, bottom + 1):\n        for j in range(left, right + 1):\n            if screen[i][j] == 'w':\n                if (i == top or i == bottom) and j != left and j != right:\n                    return -1\n                elif (j == left or j == right) and i != top and i != bottom:\n                    return -1\n    \n    # Draw the frame\n    for i in range(top, bottom + 1):\n        for j in range(left, right + 1):\n            if (i == top or i == bottom) and (j != left and j != right):\n                screen[i] = screen[i][:j] + '+' + screen[i][j+1:]\n            elif (j == left or j == right) and (i != top and i != bottom):\n                screen[i] = screen[i][:j] + '+' + screen[i][j+1:]\n    \n    return '\\n'.join(screen)\n\nn, m = map(int, input().split())\nscreen = [input() for _ in range(n)]\n\nresult = find_frame(n, m, screen)\nprint(result)"}
{"solution": "def solve(n, a, b):\n    if a == b:\n        print(\"YES\")\n        print(n // a, 0)\n    elif a > b:\n        if n % b == 0:\n            print(\"YES\")\n            print(0, n // b)\n        else:\n            x = n // a\n            y = (n - (x * a)) / b\n            if y >= 0 and y.is_integer():\n                print(\"YES\")\n                print(x, int(y))\n            else:\n                print(\"NO\")\n    else:\n        if n % a == 0:\n            print(\"YES\")\n            print(n // a, 0)\n        else:\n            x = n // b\n            y = (n - (x * b)) / a\n            if y >= 0 and y.is_integer():\n                print(\"YES\")\n                print(int(y), x)\n            else:\n                print(\"NO\")\n\nn = int(input())\na = int(input())\nb = int(input())\nsolve(n, a, b)"}
{"solution": "def number_to_words(n):\n    if n == 0:\n        return \"zero\"\n    under_20 = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n                \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    \n    if n < 20:\n        return under_20[n]\n    elif n < 100:\n        if n % 10 == 0:\n            return tens[n // 10]\n        else:\n            return tens[n // 10] + \"-\" + under_20[n % 10]\n\nn = int(input())\nprint(number_to_words(n))"}
{"solution": "def max_elements_to_erase(n, a):\n    min_diff = a[1] - a[0]\n    for i in range(2, n):\n        min_diff = min(min_diff, a[i] - a[i-1])\n    \n    if min_diff == 0:\n        return 0\n    else:\n        return min_diff - 1\n\n# Example usage\nn = int(input())\na = list(map(int, input().split()))\nprint(max_elements_to_erase(n, a))"}
{"solution": "def find_equator_day():\n    n = int(input())\n    problems = list(map(int, input().split()))\n    \n    total_problems = sum(problems)\n    solved = 0\n    \n    for i in range(n):\n        solved += problems[i]\n        if solved * 2 >= total_problems:\n            return i + 1\n\nprint(find_equator_day())"}
{"solution": "from heapq import heappush, heappop\nimport sys\n\ndef solve():\n    N = int(input())\n    board = [list(map(int, input().split())) for _ in range(N)]\n    \n    # Helper function to calculate Manhattan distance\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n    \n    # Helper function to check if a move is within the board boundaries\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    \n    # Generate all possible moves for each piece\n    knight_moves = [(dx, dy) for dx, dy in ((2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)) if is_valid(0+dx, 0+dy)]\n    bishop_diagonals = [(dx, dy) for dx in range(-N, N) for dy in range(-N, N) if dx == dy or dx == -dy]\n    rook_lines = [(dx, 0) for dx in range(-N, N+1, N)] + [(0, dy) for dy in range(-N, N+1, N)]\n    \n    # Mapping from piece type to its moves\n    moves = {\n        'knight': knight_moves,\n        'bishop': bishop_diagonals,\n        'rook': rook_lines,\n    }\n    \n    # Initialize distances and predecessors\n    dist = {(x, y, piece): float('inf') for x in range(N) for y in range(N) for piece in ['knight', 'bishop', 'rook']}\n    prev = {(x, y, piece): None for x in range(N) for y in range(N) for piece in ['knight', 'bishop', 'rook']}\n    \n    # Find starting position (1 on the board)\n    start_pos = next((x, y) for x in range(N) for y in range(N) if board[x][y] == 1)\n    \n    # Initialize priority queue and distances\n    pq = []\n    heappush(pq, (0, 0, *start_pos, 'knight'))\n    dist[start_pos + ('knight',)] = 0\n    \n    while pq:\n        cost, replacements, x, y, piece = heappop(pq)\n        \n        # Check if we reached the last square\n        if board[x][y] == N*N:\n            print(cost, replacements)\n            return\n        \n        for d_piece, directions in moves.items():\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                \n                # Check if the move is valid\n                if is_valid(nx, ny) and board[nx][ny] > board[x][y]:\n                    ncost = cost + 1\n                    nreplacements = replacements + (piece != d_piece)\n                    \n                    # Update the distance if a shorter path is found\n                    if ncost < dist[(nx, ny, d_piece)]:\n                        dist[(nx, ny, d_piece)] = ncost\n                        prev[(nx, ny, d_piece)] = (x, y, piece)\n                        heappush(pq, (ncost, nreplacements, nx, ny, d_piece))\n    \n    # If no solution was found\n    print(\"No solution\")\n\nsolve()"}
{"solution": "def min_time_to_reach(n, m, k, a, b):\n    def get_coords(apart):\n        apt = apart - 1\n        return (apt // (m * k), (apt % (m * k)) // k, apt % k)\n\n    def time_to_meet(e, n, use_elevator=True):\n        if e[1] == n[1]:  # Same floor\n            if use_elevator:\n                return 10 + abs(e[0] - n[0]) * 15\n            else:\n                return abs(e[0] - n[0]) * 15\n        else:\n            if use_elevator:\n                return 10 + abs(e[1] - n[1]) + abs(e[0] - n[0]) * 15\n            else:\n                return 5 * abs(e[1] - n[1]) + abs(e[0] - n[0]) * 15\n\n    edward = get_coords(a)\n    natasha = get_coords(b)\n\n    # Calculate time using elevator\n    time_with_elevator = time_to_meet(edward, natasha, True)\n\n    # Calculate time using stairs\n    time_with_stairs = time_to_meet(edward, natasha, False)\n\n    # Calculate time walking around the building\n    walk_around = 15 * min(abs(edward[0] - natasha[0]), n - abs(edward[0] - natasha[0]))\n\n    return min(time_with_elevator, time_with_stairs + walk_around)\n\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\nprint(min_time_to_reach(n, m, k, a, b))"}
{"solution": "def can_form_divisible_by_64(binary_str):\n    # Check if the string can form a number divisible by 64 after removals\n    # A number is divisible by 64 if the last 6 digits form a number divisible by 64\n    # Remove all trailing zeros as they do not affect divisibility by 64\n    while binary_str.endswith('0'):\n        binary_str = binary_str[:-1]\n\n    # Check substrings of the last 6 bits\n    for i in range(len(binary_str) - 6, len(binary_str)):\n        if i < 0:\n            continue\n        if int(binary_str[i:i+6], 2) % 64 == 0:\n            return \"yes\"\n    return \"no\"\n\n# Read input\nbinary_str = input().strip()\n\n# Process and print output\nprint(can_form_divisible_by_64(binary_str))"}
{"solution": "from collections import Counter\n\ndef next_char(c):\n    return 'a' if c == 'z' else chr(ord(c) + 1)\n\ndef solve(s):\n    char_count = Counter(s)\n    result = []\n    used_chars = set()\n    \n    for char in 'abcdefghijklmnopqrstuvwxyz':\n        found = False\n        for c in sorted(char_count.keys()):\n            if c > char:\n                result.append(c)\n                char_count[c] -= 1\n                if char_count[c] == 0:\n                    del char_count[c]\n                used_chars.add(c)\n                found = True\n                break\n        if not found:\n            for c in sorted(char_count.keys()):\n                if c >= char:\n                    result.append(next_char(c))\n                    char_count[c] -= 1\n                    if char_count[c] == 0:\n                        del char_count[c]\n                    used_chars.add(c)\n                    found = True\n                    break\n        if not found:\n            return -1\n    \n    for c in sorted(char_count.keys()):\n        result.extend([c] * char_count[c])\n    \n    return ''.join(result) if len(used_chars) != 26 else -1\n\ns = input().strip()\nprint(solve(s))"}
{"solution": "import math\n\ndef max_expected_fish():\n    n, m, r, k = map(int, input().split())\n    total_cells = (n - r + 1) * (m - r + 1)\n    \n    # Calculate the maximum number of fish that can fit within the scoop-net\n    max_fish_in_scoop = min(k, r * r)\n    \n    # Calculate the maximum possible expected number of caught fishes\n    # The strategy is to place the fish in a way that maximizes overlap with the scoop-net\n    # This is done by placing them in a grid of r x r size if possible\n    # Otherwise, place them in a way that spreads out evenly\n    if k <= r * r:\n        # If we can fit all fish within a single scoop-net, the expected value is simply the number of fish\n        expected_value = k\n    else:\n        # If we have more fish than can fit in a single scoop-net, spread them out\n        # Calculate how many full scoops we can fill and the remainder\n        full_scoops, remainder = divmod(k, r * r)\n        \n        # Calculate the number of positions where the center of the scoop-net can catch fish\n        # This is essentially the number of positions minus the borders\n        effective_positions = total_cells - (n - r) - (m - r) + 1\n        \n        # Calculate the expected value based on the number of full scoops and the remainder\n        expected_value = full_scoops * r * r + max(remainder / effective_positions, 0)\n    \n    return expected_value\n\nprint(max_expected_fish())"}
{"solution": "def max_product_array():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    all_negative = True\n    non_positive_count = 0\n    min_positive = float('inf')\n    max_negative = float('-inf')\n\n    for num in a:\n        if num > 0:\n            min_positive = min(min_positive, num)\n        elif num <= 0:\n            non_positive_count += 1\n            max_negative = max(max_negative, num)\n            all_negative = False\n\n    if all_negative and non_positive_count % 2 != 0:\n        a[a.index(max_negative)] = -max_negative - 1\n\n    else:\n        for i in range(len(a)):\n            if a[i] == min_positive:\n                a[i] = -a[i] - 1\n                break\n\n    print(*a)\n\nmax_product_array()"}
{"solution": "import math\n\ndef find_kth_divisor(n, k):\n    divisors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n\n    divisors.sort()\n\n    if len(divisors) < k:\n        return -1\n    else:\n        return divisors[k - 1]\n\nn, k = map(int, input().split())\nprint(find_kth_divisor(n, k))"}
{"solution": "def can_build_all_numbers_up_to_x(cubes_faces):\n    from collections import Counter\n    n = len(cubes_faces)\n    face_counts = [Counter(cube) for cube in cubes_faces]\n    one_count = sum(count[1] for count in face_counts)\n    \n    if one_count == 0:\n        return 0\n    \n    usable_digits = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n    unusable_cubes = [cube for cube in cubes_faces if set(cube) - usable_digits]\n    usable_cubes = [cube for cube in cubes_faces if cube not in unusable_cubes]\n    \n    min_ones_needed = 1\n    max_possible = 1\n    while True:\n        total_needed = sum([int(digit == '1') for digit in str(max_possible + 1)])\n        if total_needed > one_count * min_ones_needed:\n            break\n        max_possible += 1\n        if '1' not in str(max_possible):\n            min_ones_needed += 1\n    \n    return max_possible\n\nn = int(input())\ncubes_faces = [list(map(int, input().split())) for _ in range(n)]\nprint(can_build_all_numbers_up_to_x(cubes_faces))"}
{"solution": "def k_rounding(n, k):\n    if k == 0:\n        return n\n    power_of_five = 0\n    power_of_two = 0\n    temp_n = n\n    while temp_n % 5 == 0:\n        power_of_five += 1\n        temp_n //= 5\n    temp_n = n\n    while temp_n % 2 == 0:\n        power_of_two += 1\n        temp_n //= 2\n    required_zeros = max(power_of_five, power_of_two) + k\n    result = n * (10 ** (required_zeros - max(power_of_five, power_of_two)))\n    return result\n\nn, k = map(int, input().split())\nprint(k_rounding(n, k))"}
{"solution": "def solve(A):\n    n, m = len(A), len(A[0])\n    operations = []\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1:\n                operations.append((i + 1, j + 1))\n                for x in range(i, i + 2):\n                    for y in range(j, j + 2):\n                        A[x][y] = 0\n    # Check if there's any 1 left in the last row or column\n    for i in range(n):\n        if A[i][-1] == 1:\n            return [-1]\n    for j in range(m):\n        if A[-1][j] == 1:\n            return [-1]\n    return operations\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = list(map(int, input().split()))\nw = data[0]\nh = data[1]\ndata = data[2:]\nA = [data[h * i:h * (i + 1)] for i in range(w)]\n\n# Solving and printing output\nresult = solve(A)\nprint(len(result))\nfor op in result:\n    print(*op)"}
{"solution": "from math import gcd\nr, s, p = map(int,input().split())\ntot = r+s+p\ndef prob(x,y):\n    g = gcd(x,y)\n    return (x//g,y//g)\n\ndef solve(a,b,c):\n    x = prob(a,c+b).index(max(prob(a,c+b)))\n    y = a+prob(b,c)[x]\n    z = prob(y,tot-y)[x]\n    return z/tot if x==0 else 1-z/tot\n\nprint(solve(r,s,p),solve(s,p,r),solve(p,r,s))"}
{"solution": "def calculate_meeting_time(s_l1, s_r1, f_l2, f_r2, s_prink):\n   \u5171\u540c\u65f6\u95f4_start = max(s_l1, f_l2)\n    \u5171\u540c\u65f6\u95f4_end = min(s_r1, f_r2)\n\n    if \u5171\u540c\u65f6\u95f4_start >= \u5171\u540c\u65f6\u95f4_end or s_prink < \u5171\u540c\u65f6\u95f4_start or s_prink > \u5171\u540c\u65f6\u95f4_end:\n        return max(0, \u5171\u540c\u65f6\u95f4_end - \u5171\u540c\u65f6\u95f4_start)\n    else:\n        return max(0, (\u5171\u540c\u65f6\u95f4_end - \u5171\u540c\u65f6\u95f4_start) - 1)\n\n# \u8bfb\u53d6\u8f93\u5165\ns_l1, s_r1, f_l2, f_r2, s_prink = map(int, input().split())\n\n# \u8ba1\u7b97\u7ed3\u679c\u5e76\u8f93\u51fa\nprint(calculate_meeting_time(s_l1, s_r1, f_l2, f_r2, s_prink))"}
{"solution": "from typing import List\nimport bisect\n\ndef cross_product(p1: List[int], p2: List[int]) -> int:\n    return p1[0] * p2[1] - p1[1] * p2[0]\n\ndef solve(N: int, M: int, ABC: List[List[int]], DEF: List[List[int]]) -> None:\n    AB = []\n    for a, b, c in ABC:\n        AB.append([a, 1, c])\n        AB.append([b, -1, c])\n    AB.sort()\n    \n    CD = []\n    for d, e, f in DEF:\n        CD.append([d, 1, e, f])\n        CD.append([e, -1, f, e])\n    CD.sort()\n    \n    x_list = [0]\n    y_list = [0]\n    for ab in AB:\n        if ab[1] > 0:\n            x_list.append(ab[0])\n        else:\n            x_list.append(ab[0])\n            x_list.append(ab[0])\n    for cd in CD:\n        if cd[1] > 0:\n            y_list.append(cd[2])\n            y_list.append(cd[3])\n        else:\n            y_list.append(cd[2])\n    \n    x_list.sort()\n    y_list.sort()\n    \n    area = 0\n    for i in range(1, len(x_list)):\n        for j in range(1, len(y_list)):\n            x1 = x_list[i-1]\n            x2 = x_list[i]\n            y1 = y_list[j-1]\n            y2 = y_list[j]\n            if x1 == x2 or y1 == y2:\n                continue\n            \n            if cross_product([x2-x1, y2-y1], [x2, y2]) >= 0:\n                area += (x2 - x1) * (y2 - y1)\n    \n    print(area if area != float('inf') else 'INF')\n\n# Reading input\nN, M = map(int, input().split())\nABC = [list(map(int, input().split())) for _ in range(N)]\nDEF = [list(map(int, input().split())) for _ in range(M)]\n\nsolve(N, M, ABC, DEF)"}
{"solution": "def will_pineapple_bark(t, s, x):\n    if x == t:\n        return \"YES\"\n    elif x > t:\n        adjusted_x = x - t\n        if adjusted_x % (s + 1) == 0 or adjusted_x % (s + 1) == 1:\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        return \"NO\"\n\n# Reading input\nt, s, x = map(int, input().split())\n\n# Calling function and printing result\nprint(will_pineapple_bark(t, s, x))"}
{"solution": "def find_nested_segments():\n    import sys\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n\n    n = data[0]\n    data = data[1:]\n    segments = [(data[2 * i], data[2 * i + 1]) for i in range(n)]\n\n    segments_with_index = [(segments[i], i + 1) for i in range(n)]\n    segments_with_index.sort(key=lambda x: (x[0][0], -x[0][1]))\n\n    ans = [-1, -1]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if segments_with_index[j][0][0] <= segments_with_index[i][0][0] and \\\n               segments_with_index[j][0][1] >= segments_with_index[i][0][1]:\n                ans = [segments_with_index[i][1], segments_with_index[j][1]]\n                break\n        if ans != [-1, -1]:\n            break\n\n    print(' '.join(map(str, ans)))\n\nfind_nested_segments()"}
{"solution": "def decode_genome(n, s):\n    \"\"\"\n    Decodes the genome by replacing unrecognized nucleotides with 'A', 'C', 'G', or 'T'\n    so that the number of each type of nucleotide becomes equal.\n    \"\"\"\n    from collections import Counter\n\n    nucleotides = {'A', 'C', 'G', 'T'}\n    cnt = Counter(s)\n    question_marks = cnt['?']\n    \n    if (n + question_marks) % 4 != 0:\n        return \"===\"\n\n    required_each = (n + question_marks) // 4\n    \n    for nt in nucleotides:\n        if cnt[nt] > required_each:\n            return \"===\"\n\n    for i, ch in enumerate(s):\n        if ch == '?':\n            options = nucleotides - set(cnt.keys())\n            for opt in options:\n                if cnt[opt] < required_each:\n                    s = s[:i] + opt + s[i+1:]\n                    cnt[opt] += 1\n                    break\n\n    return s\n\n# Example usage\nif __name__ == \"__main__\":\n    n = int(input())\n    s = input().strip()\n    print(decode_genome(n, s))"}
{"solution": "import itertools\n\ndef can_ilya_win(grid):\n    \"\"\"\n    Determines if Ilya can win the game by making a single turn.\n    \n    :param grid: List of strings representing the 4x4 tic-tac-toe board\n    :return: \"YES\" if Ilya can win with one move, \"NO\" otherwise\n    \"\"\"\n    # Check rows and columns\n    for i in range(4):\n        for combo in ('...x', '..x.', '.x..', 'x...', 'o...'):\n            s = ''.join(grid[i])\n            s2 = ''.join(grid[j][i] for j in range(4))\n            if combo in s or combo in s2:\n                return \"YES\"\n\n    # Check diagonals\n    diagonal1 = ''.join(grid[i][i] for i in range(4))\n    diagonal2 = ''.join(grid[3-i][i] for i in range(4))\n    for combo in ('...x', '..x.', '.x..', 'x...', 'o...'):\n        if combo in diagonal1 or combo in diagonal2:\n            return \"YES\"\n\n    return \"NO\"\n\n# Read input\ngrid = [input() for _ in range(4)]\n\n# Output result\nprint(can_ilya_win(grid))"}
{"solution": "def can_divide_after_move(n, arr):\n    total_sum = sum(arr)\n    if total_sum % 2 != 0:\n        return \"NO\"\n    \n    target_sum = total_sum // 2\n    prefix_sum = 0\n    suffix_sum = 0\n    \n    for i in range(n):\n        suffix_sum = arr[i]\n        if prefix_sum + suffix_sum == target_sum:\n            if i > 0 and prefix_sum == target_sum - arr[i]:\n                return \"YES\"\n            if i < n - 1 and sum(arr[i+1:]) == target_sum - arr[i]:\n                return \"YES\"\n        \n        prefix_sum += arr[i]\n        \n        if prefix_sum == target_sum:\n            if i > 0 and sum(arr[:i]) + arr[i] == target_sum:\n                return \"YES\"\n            if i < n - 1 and sum(arr[i+1:]) + arr[i] == target_sum:\n                return \"YES\"\n    \n    return \"NO\""}
{"solution": "def can_recover_sequence(n, k, a, b):\n    a_sorted = sorted(a)\n    b_sorted = sorted(b, reverse=True)\n    \n    for i in range(k):\n        a_sorted[a.index(0)] = b_sorted[i]\n    \n    return not all(a_sorted[i] <= a_sorted[i + 1] for i in range(n - 1))\n\ndef main():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    print(\"Yes\" if can_recover_sequence(n, k, a, b) else \"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_make_happy(x, y, z, a, b, c):\n    # Check if Andrew can get at least x green grapes\n    if a < x:\n        return \"NO\"\n    \n    # Check if Dmitry can get at least y grapes (green or purple)\n    remaining_green_after_andrew = a - x\n    total_non_black = remaining_green_after_andrew + b\n    if total_non_black < y:\n        return \"NO\"\n    \n    # Check if Michal can get at least z grapes from what's left\n    remaining_after_dmitry = total_non_black - y + c\n    if remaining_after_dmitry < z:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input values\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Output result\nprint(can_make_happy(x, y, z, a, b, c))"}
{"solution": "def check_accident(lights):\n    for i in range(4):\n        if lights[i][3] == 1:  # Pedestrian light is green\n            for j in [0, 1, 2]:  # Check left, straight, right lights\n                if lights[i][j] == 1:\n                    return \"YES\"\n            opp_part = (i + 2) % 4\n            for j in [0, 1, 2]:\n                if lights[opp_part][j] == 1:\n                    return \"YES\"\n    return \"NO\"\n\nlights = []\nfor _ in range(4):\n    lights.append(list(map(int, input().split())))\n\nprint(check_accident(lights))"}
{"solution": "def is_unique_sequence(n, number):\n    # Mapping of digits to their possible alternatives based on finger movements\n    alternatives = {\n        '1': '1', '2': '25', '3': '36', '4': '48', '5': '258', \n        '6': '369', '7': '7', '8': '458', '9': '69', '0': '0'\n    }\n    \n    # Generate all possible numbers based on finger movements\n    possible_numbers = {number}\n    for i in range(n):\n        new_possible_numbers = set()\n        for num in possible_numbers:\n            for j in range(n):\n                digit = num[j]\n                for alt in alternatives[digit]:\n                    new_num = num[:j] + alt + num[j+1:]\n                    new_possible_numbers.add(new_num)\n        possible_numbers = new_possible_numbers\n    \n    # Check if there is more than one unique number\n    unique_numbers = len(possible_numbers)\n    return \"YES\" if unique_numbers == 1 else \"NO\"\n\n# Reading input\nn = int(input())\nnumber = input()\n\n# Printing output\nprint(is_unique_sequence(n, number))"}
{"solution": "import heapq\n\ndef max_products_sold():\n    n, f = map(int, input().split())\n    days = [list(map(int, input().split())) for _ in range(n)]\n\n    # Calculate potential sales for each day (max possible sales - original sales)\n    potential_sales = [(max(0, 2 * k - l) - max(0, k - l), max(0, k - l)) for k, l in days]\n    potential_sales.sort(reverse=True)\n\n    sold = sum(max(0, k - l) for k, l in days)\n    heap = []\n\n    for ps, s in potential_sales[:f]:\n        sold += ps\n        heapq.heappush(heap, s)\n\n    for ps, s in potential_sales[f:]:\n        if s < heap[0]:\n            sold -= heapq.heappop(heap)\n            sold += ps\n            heapq.heappush(heap, s)\n\n    print(sold)\n\nmax_products_sold()"}
{"solution": "import sys\n\ndef max_messiness(n, k):\n    # Calculate the maximum messiness based on the number of cows and the time available for swaps\n    return min(n * (n - 1) // 2, n * k)\n\n# Reading input\ninput_data = sys.stdin.read().split()\nn, k = map(int, input_data)\n\n# Calculating and printing the output\nprint(max_messiness(n, k))"}
{"solution": "def min_coins_gift(N, M, K, L):\n    if N - K < L:\n        return -1\n    elif N < M:\n        return -1\n    else:\n        return max((L + M - 1) // M, (N + M - K - 1) // M)\n\nN, M, K, L = map(int, input().split())\nprint(min_coins_gift(N, M, K, L))"}
{"solution": "def min_paintings(n, m, grid):\n    top, bottom, left, right = -1, -1, m, -1\n    black_count = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                black_count += 1\n                top = min(top, i)\n                bottom = max(bottom, i)\n                left = min(left, j)\n                right = max(right, j)\n\n    if top == -1:\n        return 1 if black_count == 0 else -1\n\n    side = right - left\n    if side < 0:\n        return -1\n\n    total_paintings = (side + 1) ** 2\n    additional_paintings = total_paintings - black_count\n\n    if bottom - top != side:\n        return -1\n\n    for i in range(top, bottom + 1):\n        if grid[i][left] == 'W' or grid[i][right] == 'W':\n            return -1\n\n    for j in range(left + 1, right):\n        if grid[top][j] == 'W' or grid[bottom][j] == 'W':\n            return -1\n\n    return additional_paintings if additional_paintings >= 0 else -1\n\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\nprint(min_paintings(n, m, grid))"}
{"solution": "def check_stone_piles(x, y):\n    changes = []\n    for xi, yi in zip(x, y):\n        if xi > yi:\n            changes.append((xi - yi, 'remove'))\n        elif yi > xi:\n            changes.append((yi - xi, 'add'))\n\n    changes.sort()\n    deficit = 0\n    for change in changes:\n        if change[1] == 'remove':\n            if deficit > change[0]:\n                return \"No\"\n            deficit += change[0]\n        else:\n            if deficit > change[0]:\n                return \"No\"\n            deficit -= change[0]\n\n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    n = int(input())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n\n    print(check_stone_piles(x, y))"}
{"solution": "def min_pizza_diff(n, angles):\n    total_angle = sum(angles)\n    half_angle = total_angle / 2\n    dp = [0] * (n + 1)\n    angle_sum = 0\n    \n    for i in range(n):\n        angle_sum += angles[i]\n        for j in range(n, 0, -1):\n            if dp[j - 1] + angles[i] <= half_angle:\n                dp[j] = max(dp[j], dp[j - 1] + angles[i])\n    \n    diff = abs(half_angle - dp[n - 1])\n    return int(2 * diff)\n\n# Reading input\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(min_pizza_diff(n, angles))"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_pow(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef solve(n, m):\n    if n > m:\n        return 0\n    elif n == m or n == 1:\n        return mod_pow(2, m) - 1\n    else:\n        return (mod_pow(2, m) - 1 - m) % MOD\n\nn, m = map(int, input().split())\nprint(solve(n, m))"}
{"solution": "def find_pythagorean_triple(n):\n    if n == 1:\n        return [-1]\n    if n % 2 == 1:\n        m = (n ** 2 - 1) // 2\n        k = (n ** 2 + 1) // 2\n    else:\n        m = (n ** 2) // 4 - 1\n        k = (n ** 2) // 4 + 1\n    return [m, k]\n\nn = int(input())\nresult = find_pythagorean_triple(n)\nprint(' '.join(map(str, result)))"}
{"solution": "def check_distinct_remainders(n, k):\n    seen = set()\n    for i in range(1, min(k + 1, n + 1)):\n        remainder = n % i\n        if remainder in seen:\n            return \"No\"\n        seen.add(remainder)\n    return \"Yes\"\n\n# Read input\nn, k = map(int, input().split())\n\n# Check and print result\nprint(check_distinct_remainders(n, k))"}
{"solution": "def compare_large_numbers():\n    a = raw_input().strip()\n    b = raw_input().strip()\n\n    # Remove leading zeros for comparison\n    a = a.lstrip('0')\n    b = b.lstrip('0')\n\n    # If both strings become empty after removing leading zeros, they are equal\n    if not a and not b:\n        print('=')\n        return\n\n    # Directly compare if lengths differ\n    if len(a) != len(b):\n        print('>' if len(a) > len(b) else '<')\n    else:\n        # Compare lexicographically if lengths are equal\n        print('>' if a > b else ('<' if a < b else '='))\n\ncompare_large_numbers()"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_pow(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef solve(n, p, c):\n    # Counting fixed colors\n    fixed_black = sum(1 for color in c if color == 0)\n    fixed_white = sum(1 for color in c if color == 1)\n    \n    # Counting free colors\n    free = n - fixed_black - fixed_white\n    \n    # Total ways to connect all nodes\n    total_ways = mod_pow(2, (n * (n - 1)) // 2)\n    \n    # Ways to choose free colors\n    free_ways = mod_pow(2, free)\n    \n    # Calculating parity\n    fixed_odd = (fixed_black * fixed_white) % 2\n    if p == 1:\n        # If odd parity is required\n        if fixed_odd == 1:\n            # All combinations work\n            return (total_ways * free_ways) % MOD\n        else:\n            # Splitting free colors into even and odd\n            even_ways = mod_pow(2, free - 1)\n            return (total_ways * (free_ways - even_ways)) % MOD\n    else:\n        # If even parity is required\n        if fixed_odd == 0:\n            # All combinations work\n            return (total_ways * free_ways) % MOD\n        else:\n            # Splitting free colors into even and odd\n            even_ways = mod_pow(2, free - 1)\n            return (total_ways * even_ways) % MOD\n\n# Reading input\nn, p = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Solving and printing output\nprint(solve(n, p, c))"}
{"solution": "import sys\n\nn, a, b, c = map(int, sys.stdin.readline().split())\n\ncosts = [float('inf')] * 4\nfor i in range(4):\n    k = (4 - n % 4 + i) % 4\n    costs[i] = min(\n        k * a,\n        (k // 3) * c + ((k % 3) * a if k % 3 <= 1 or a < b else b)\n    )\n\nprint(min(costs))"}
{"solution": "from collections import defaultdict\n\ndef dfs(node, visited, recStack, graph):\n    visited[node] = True\n    recStack[node] = True\n\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            if dfs(neighbor, visited, recStack, graph):\n                return True\n        elif recStack[neighbor]:\n            return True\n\n    recStack[node] = False\n    return False\n\ndef isCyclic(graph, n):\n    visited = [False] * n\n    recStack = [False] * n\n\n    for node in range(n):\n        if not visited[node]:\n            if dfs(node, visited, recStack, graph):\n                return True\n    return False\n\ndef checkAcyclicAfterEdgeRemoval(graph, n, m):\n    hasCycle = isCyclic(graph, n)\n\n    if not hasCycle:\n        return \"YES\"\n\n    for i in range(m):\n        graph[i][1].remove(i)\n        if not isCyclic(graph, n):\n            return \"YES\"\n        graph[i][1].append(i)\n\n    return \"NO\"\n\ndef main():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    edges = []\n\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u-1].append(v-1)\n        edges.append((u-1, v-1))\n\n    # Reconstructing the graph with edges as indices\n    indexed_graph = [[] for _ in range(n)]\n    for i, (u, v) in enumerate(edges):\n        indexed_graph[u].append(i)\n\n    result = checkAcyclicAfterEdgeRemoval(indexed_graph, n, m)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from typing import List\n\ndef min_coins_for_coverage(n: int, m: int, antennas: List[List[int]]) -> int:\n    \"\"\"\n    Calculates the minimum number of coins required to ensure all positions from 1 to m are covered by at least one antenna.\n    \n    :param n: Number of antennas.\n    :param m: Last position to be covered.\n    :param antennas: List of [position, initial_scope] for each antenna.\n    :return: Minimum number of coins required.\n    \"\"\"\n    antennas.sort(key=lambda x: x[0])\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    max_reach = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        x, s = antennas[i - 1]\n        left, right = max(1, x - s), x + s\n        j = max_reach[i - 1]\n\n        while j < i and antennas[j][0] < left:\n            j += 1\n\n        while j < n and antennas[j][0] <= right:\n            new_reach = min(m, antennas[j][0] + antennas[j][1])\n            if new_reach > max_reach[j]:\n                dp[j + 1] = min(dp[j + 1], dp[j])\n                max_reach[j + 1] = new_reach\n            j += 1\n\n        new_reach = min(m, x + s)\n        coins_needed = dp[i - 1] + (new_reach - max_reach[i - 1]) - (x - left)\n        dp[i] = min(dp[i], coins_needed)\n        max_reach[i] = new_reach\n\n    return dp[n]\n\n# Example check function (not part of the solution)\ndef check_solution():\n    assert min_coins_for_coverage(3, 595, [[43, 2], [300, 4], [554, 10]]) == 281\n    assert min_coins_for_coverage(1, 1, [[1, 1]]) == 0\n    assert min_coins_for_coverage(2, 50, [[20, 0], [3, 1]]) == 30\n    assert min_coins_for_coverage(5, 240, [[13, 0], [50, 25], [60, 5], [155, 70], [165, 70]]) == 26\n\ncheck_solution()"}
{"solution": "def max_subset_weight(W, weights):\n    \"\"\"\n    Calculate the maximum possible weight of a good subset of items.\n    \"\"\"\n    # Initialize the result\n    result = 0\n    \n    # Iterate through each weight starting from the highest\n    for i in range(7, -1, -1):\n        # Calculate the maximum usable weight for this category\n        usable_weight = min(W // (i + 1), weights[i])\n        # Add the total weight of the usable items to the result\n        result += usable_weight * (i + 1)\n        # Decrease W by the weight added to the result\n        W -= usable_weight * (i + 1)\n\n    return result\n\n# Read input\nW = int(input())\nweights = list(map(int, input().split()))\n\n# Print the result\nprint(max_subset_weight(W, weights))"}
{"solution": "import heapq\n\ndef min_cost_lemonade(n, L, costs):\n    \"\"\"\n    Calculate the minimum cost to buy at least L liters of lemonade.\n    \n    :param n: Number of types of bottles available.\n    :param L: Required amount of lemonade in liters.\n    :param costs: List of costs for each type of bottle.\n    :return: Minimum cost to buy at least L liters of lemonade.\n    \"\"\"\n    volumes = [2**i - 1 for i in range(1, n + 1)]\n    cost_heap = [(cost, volume) for cost, volume in zip(costs, volumes)]\n    heapq.heapify(cost_heap)\n\n    total_cost = 0\n    while L > 0:\n        cost, volume = heapq.heappop(cost_heap)\n        if volume <= L:\n            total_cost += cost\n            L -= volume\n        else:\n            # Calculate the cost for the exact amount needed\n            exact_cost = cost * ((L + volume - 1) // volume)\n            total_cost += exact_cost\n            break\n\n    return total_cost\n\n# Function to read input and call the above function\ndef solve():\n    n, L = map(int, input().split())\n    costs = list(map(int, input().split()))\n    print(min_cost_lemonade(n, L, costs))\n\nsolve()"}
{"solution": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\ndef find_max_mex(arr):\n    n = len(arr)\n    arr.sort()\n    \n    mex = 1\n    count = defaultdict(int)\n\n    for num in arr:\n        if num >= mex:\n            count[num] += 1\n            if count[mex] > 0:\n                count[mex] -= 1\n            else:\n                mex += 1\n\n    return mex\n\nn = int(input())\na = list(map(int, input().split()))\n\nprint(find_max_mex(a))"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(map(int, digits))\n    segment_sum = 0\n    segments = []\n\n    for digit in digits:\n        segment_sum += int(digit)\n        if segment_sum * (n - len(segments) - 1) > total_sum:\n            break\n        if segment_sum * (n - len(segments)) == total_sum:\n            segments.append(segment_sum)\n            segment_sum = 0\n\n    return \"YES\" if len(segments) >= 2 else \"NO\""}
{"solution": "def determine_gender(username):\n    distinct_chars = set(username)\n    if len(distinct_chars) % 2 == 0:\n        print(\"IGNORE HIM!\")\n    else:\n        print(\"CHAT WITH HER!\")\n\nusername = input().strip()\ndetermine_gender(username)"}
{"solution": "def max_diff_after_closing_tabs(n, k, tabs):\n    import itertools\n\n    max_diff = 0\n    for start in range(1, n + 1):\n        remaining = [tab for i, tab in enumerate(tabs, start=1) if (i - start) % k != 0]\n        e = remaining.count(1)\n        s = remaining.count(-1)\n        diff = abs(e - s)\n        max_diff = max(max_diff, diff)\n\n    return max_diff\n\n# Reading input\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Printing output\nprint(max_diff_after_closing_tabs(n, k, tabs))"}
{"solution": "def min_cost(n, c0, c1):\n    from math import sqrt\n    if c0 > c1: c0, c1 = c1, c0\n    if c0 == 0:\n        return (n - 1) * c1\n    A = 2 * c0 * c1\n    B = c0 ** 2 + c1 ** 2\n    C = (n - 1) * c1 - c0\n    D = B * C * C + 4 * A\n    res = (-B * C + sqrt(D)) / A\n    return int(round(res))\n\nn, c0, c1 = map(int, input().split())\nprint(min_cost(n, c0, c1))"}
{"solution": "def check_meet(n, a, x, b, y):\n    daniel_path = set()\n    current_d = a\n    while current_d != x:\n        daniel_path.add(current_d)\n        current_d += 1\n        if current_d > n:\n            current_d = 1\n    \n    current_v = b\n    while current_v != y:\n        if current_v in daniel_path:\n            return \"YES\"\n        current_v -= 1\n        if current_v < 1:\n            current_v = n\n    \n    return \"NO\" if x not in daniel_path else \"YES\"\n\n# Function to take input and call the above function\ndef solve():\n    n, a, x, b, y = map(int, input().split())\n    print(check_meet(n, a, x, b, y))\n\nsolve()"}
{"solution": "import math\n\ndef is_unlucky_year(x, y, n):\n    max_power = int(math.log(n, max(x, y))) + 1\n    for a in range(max_power + 1):\n        for b in range(max_power + 1):\n            if x**a + y**b == n:\n                return True\n    return False\n\ndef max_golden_age_length(x, y, l, r):\n    unlucky_years = set()\n    for n in range(l, r + 1):\n        if is_unlucky_year(x, y, n):\n            unlucky_years.add(n)\n    \n    if len(unlucky_years) == r - l + 1:  # All years are unlucky\n        return 0\n    \n    golden_ages = []\n    start = l\n    for year in range(l, r + 1):\n        if year in unlucky_years:\n            if start < year:\n                golden_ages.append((start, year - 1))\n            start = year + 1\n    if start <= r:\n        golden_ages.append((start, r))\n    \n    max_length = 0\n    for age in golden_ages:\n        max_length = max(max_length, age[1] - age[0] + 1)\n    \n    return max_length\n\n# Reading input\nx, y, l, r = map(int, input().split())\n\n# Calculating and printing the result\nprint(max_golden_age_length(x, y, l, r))"}
{"solution": "def min_tax(burles):\n    if burles % 2 == 0:\n        return burles // 2\n    else:\n        return (burles // 2) + 1\n\nincome = int(input())\nprint(min_tax(income))"}
{"solution": "def is_vowel(ch):\n    return ch in 'aeiou'\n\ndef fix_typo(word):\n    i = 0\n    result = []\n    while i < len(word):\n        j = i + 1\n        while j < len(word) and not is_vowel(word[j]) and word[j] == word[i]:\n            j += 1\n        if j - i >= 3:\n            result.append(word[i:j])\n            i = j\n        else:\n            k = j\n            while k < len(word) and not is_vowel(word[k]) and word[k] != word[i]:\n                k += 1\n            if k - i >= 3:\n                result.append(word[i:j])\n                i = j\n            else:\n                result.append(word[i:k])\n                i = k\n    return ' '.join(result)\n\nword = input().strip()\nprint(fix_typo(word))"}
{"solution": "import sys\nfrom typing import List, Tuple\n\ndef read_ints() -> List[int]:\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef read_single_int() -> int:\n    return int(sys.stdin.readline().strip())\n\nclass PotionPreparation:\n    def __init__(self, n: int, m: int, k: int, x: int, s: int, a: List[int], b: List[int], c: List[int], d: List[int]):\n        self.n = n\n        self.m = m\n        self.k = k\n        self.x = x\n        self.s = s\n        self.a = a\n        self.b = b\n        self.c = c\n        self.d = d\n        self.first_type_spells = list(zip(a, b))\n        self.second_type_spells = list(zip(c, d))\n\n    def find_min_time(self) -> int:\n        self.first_type_spells.sort(key=lambda x: x[0])\n        self.second_type_spells.sort(key=lambda x: x[1])\n\n        first_spell_prefix_sums = [0] * (self.m + 1)\n        for i in range(1, self.m + 1):\n            first_spell_prefix_sums[i] = first_spell_prefix_sums[i - 1] + self.first_type_spells[i - 1][1]\n\n        second_spell_prefix_sums = [0] * (self.k + 1)\n        for i in range(1, self.k + 1):\n            second_spell_prefix_sums[i] = second_spell_prefix_sums[i - 1] + self.second_type_spells[i - 1][1]\n\n        def is_possible(time_limit: int) -> bool:\n            left, right = 0, self.m\n            while left < right:\n                mid = (left + right + 1) // 2\n                remaining_time = time_limit - (mid * (self.x - self.first_type_spells[mid - 1][0]))\n                if remaining_time >= 0:\n                    left = mid\n                else:\n                    right = mid - 1\n            potions_crafted = left * (self.x - self.first_type_spells[left - 1][0])\n            manapoints_used = first_spell_prefix_sums[left]\n            remaining_manapoints = self.s - manapoints_used\n\n            left, right = 0, self.k\n            while left < right:\n                mid = (left + right) // 2\n                if second_spell_prefix_sums[mid] <= remaining_manapoints:\n                    left = mid + 1\n                else:\n                    right = mid\n            potions_crafted += self.second_type_spells[left - 1][0] if left > 0 else 0\n            manapoints_used += second_spell_prefix_sums[left] if left > 0 else 0\n\n            remaining_potions = self.n - potions_crafted\n            if remaining_potions <= 0 or ((remaining_potions * self.x) <= (time_limit - manapoints_used)):\n                return True\n            return False\n\n        low, high = 0, self.n * self.x\n        while low < high:\n            mid = (low + high) // 2\n            if is_possible(mid):\n                high = mid\n            else:\n                low = mid + 1\n        return low\n\ndef main():\n    n, m, k = read_ints()\n    x, s = read_ints()\n    a = read_ints()\n    b = read_ints()\n    c = read_ints()\n    d = read_ints()\n    solver = PotionPreparation(n, m, k, x, s, a, b, c, d)\n    print(solver.find_min_time())\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_points(n, k, M, t):\n    t.sort()\n    prefix_sums = [0]\n    for time in t:\n        prefix_sums.append(prefix_sums[-1] + time)\n    \n    full_tasks = 0\n    while full_tasks < n and prefix_sums[k] <= M:\n        M -= prefix_sums[k]\n        full_tasks += 1\n    \n    points = full_tasks * k + full_tasks\n    \n    i = 0\n    while M >= t[i] and i < k:\n        M -= t[i]\n        points += 1\n        i += 1\n    \n    return points\n\n# Reading input\nn, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Printing output\nprint(max_points(n, k, M, t))"}
{"solution": "MOD = 998244353\n\nfac = [1]\nfor i in range(1, 10**6 + 1):\n    fac.append(fac[-1] * i % MOD)\n\nrfac = [pow(fac[-1], MOD - 2, MOD)]\nfor i in range(1, 10**6 + 1)[::-1]:\n    rfac.append(rfac[-1] * i % MOD)\nrfac.reverse()\n\ndef C(n, k):\n    return fac[n] * rfac[k] * rfac[n - k] % MOD\n\ndef solve(n):\n    if n == 1:\n        return 1\n    if n % 2 == 1:\n        return 0\n    m = n // 2\n    return C(m - 1, m - 1) * pow(2, m, MOD) % MOD\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def find_lara_position(n, m, k):\n    cycle_length = 2 * (m + n - 2)\n    adjusted_k = k % cycle_length\n    \n    if adjusted_k < m:\n        return (1 + adjusted_k // m, 1 + adjusted_k % m)\n    else:\n        adjusted_k -= m\n        if adjusted_k < n - 1:\n            return (n - adjusted_k, m)\n        else:\n            adjusted_k -= (n - 1)\n            if adjusted_k < m - 1:\n                return (1, m - adjusted_k)\n            else:\n                return (adjusted_k - (m - 1), 1)\n\nn, m, k = map(int, input().split())\nrow, col = find_lara_position(n, m, k)\nprint(row, col)"}
{"solution": "import math\n\ndef find_pair(X):\n    for i in range(1, int(math.sqrt(X)) + 1, 1):\n        if X % i == 0:\n            return (i, X // i)\n    return (X, 1)\n\nX = int(input())\na, b = find_pair(X)\nprint(a, b)"}
{"solution": "def max_compote_fruits():\n    a = int(input())\n    b = int(input())\n    c = int(input())\n\n    min_lemons = min(a, b // 2, c // 4)\n    if min_lemons > 0:\n        return min_lemons * 7\n    else:\n        return 0\n\nprint(max_compote_fruits())"}
{"solution": "def can_ensure_victory(n, ratings):\n    ratings.sort()\n    return 'YES' if ratings[-1] > ratings[n-1] else 'NO'\n\n# Reading input\nn = int(input())\nratings = list(map(int, input().split()))\n\n# Printing output\nprint(can_ensure_victory(n, ratings))"}
{"solution": "import math\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef find_coprime(num):\n    coprime = num + 1\n    while gcd(coprime, num) != 1:\n        coprime += 1\n    return coprime\n\ndef make_coprime_array(arr):\n    n = len(arr)\n    if n == 1:\n        return 0, arr\n\n    insertions = 0\n    i = 0\n    while i < n - 1:\n        if gcd(arr[i], arr[i + 1]) != 1:\n            new_num = find_coprime(arr[i])\n            arr.insert(i + 1, new_num)\n            insertions += 1\n            n += 1\n        i += 1\n\n    return insertions, arr\n\nn = int(input())\na = list(map(int, input().split()))\n\ninsertions, new_array = make_coprime_array(a)\n\nprint(insertions)\nprint(*new_array)"}
{"solution": "def solve(n, k, arr):\n    total = sum(arr)\n    divisors = [i for i in range(1, int(total**0.5) + 1) if total % i == 0]\n    divisors.extend([total // i for i in divisors if i * i != total])\n    divisors.sort(reverse=True)\n    \n    for divisor in divisors:\n        mod_arr = sorted([a % divisor for a in arr])\n        left_sum = sum(mod_arr)\n        right_sum = 0\n        for i in range(n):\n            left_sum -= mod_arr[i]\n            if left_sum == divisor * (n - i - right_sum):\n                if right_sum <= k:\n                    return divisor\n                break\n            right_sum += divisor - mod_arr[i]\n\n    return 1\n\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\nprint(solve(n, k, arr))"}
{"solution": "def find_transformation(x):\n    operations = []\n    # Find the next power of 2 greater than x\n    target_power = x.bit_length()\n    target_value = (1 << target_power) - 1\n\n    # Apply Operation A to make x odd if it's not already\n    if x % 2 == 0:\n        operations.append(0)\n        x ^= 1\n\n    while x < target_value:\n        # Apply Operation A\n        current_power = x.bit_length() - 1\n        operations.append(current_power)\n        x ^= ((1 << current_power) - 1)\n\n        # Apply Operation B\n        x += 1\n        operations.append(-1)\n\n    # Remove the last Operation B since it's not needed\n    operations.pop()\n\n    # Adjust operations to fit the format\n    adjusted_operations = [op for op in operations if op != -1]\n\n    return len(adjusted_operations), adjusted_operations\n\n# Read input\nx = int(input())\n\n# Solve the problem\nt, n_list = find_transformation(x)\n\n# Output the result\nprint(t)\nif n_list:\n    print(' '.join(map(str, n_list)))"}
{"solution": "# Import necessary library\nfrom math import ceil\n\ndef min_hours_to_water_garden(n, k, segments):\n    \"\"\"\n    Finds the minimum number of hours required to water the entire garden.\n    \"\"\"\n    # Find the maximum segment length that divides k without remainder\n    max_efficient_segment = max([length for length in segments if k % length == 0])\n    # Calculate and return the minimum hours needed\n    return ceil(k / max_efficient_segment)\n\n# Read input values\nn, k = map(int, input().split())\nsegments = list(map(int, input().split()))\n\n# Output the result\nprint(min_hours_to_water_garden(n, k, segments))"}
{"solution": "def can_grasshopper_reach(n, k, line):\n    start = line.find('G')\n    target = line.find('T')\n    step = k\n\n    if abs(target - start) % k != 0:\n        return \"NO\"\n\n    current = start\n    while current != target:\n        next_positions = [current + step, current - step]\n        valid_next_positions = [pos for pos in next_positions if 0 <= pos < n and line[pos] != '#']\n\n        if not valid_next_positions:\n            return \"NO\"\n\n        current = valid_next_positions[0]\n\n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\nline = input()\n\n# Print the result\nprint(can_grasshopper_reach(n, k, line))"}
{"solution": "from math import fabs\n\nEPS = 1e-8\n\ndef equals(a, b):\n    return fabs(a - b) <= EPS\n\ndef solve(y1, y2, yw, xb, yb, r):\n    k = (y2 - y1) / (2 * r)\n    d = yw - yb\n    xw = (xb + d / k) if (d / k > xb) else ((d / k) * 2 - xb)\n\n    if xw <= xb or (not equals(yb + d, yw) and (yb + d < y1 + r or yb + d > y2 - r)):\n        return -1\n    return xw\n\nif __name__ == \"__main__\":\n    y1, y2, yw, xb, yb, r = map(int, input().split())\n    print(solve(y1, y2, yw, xb, yb, r))"}
{"solution": "def min_missed_meals(b, d, s):\n    \"\"\"\n    Calculate the minimum number of meals Vasiliy could have missed.\n    \"\"\"\n    # If Vasiliy had all meals on different days\n    full_days = min(b, d, s)\n    \n    # Meals outside of full days\n    b -= full_days\n    d -= full_days\n    s -= full_days\n    \n    # Minimum missed meals\n    missed = (b + d + s)\n    \n    return max(0, missed - 1)\n\n# Read input\nb, d, s = map(int, input().split())\n\n# Calculate and print result\nprint(min_missed_meals(b, d, s))"}
{"solution": "from math import gcd\n\ndef get_position(val, x, y):\n    row = (val - 1) // y + 1\n    col = (val - 1) % y + 1\n    return row, col\n\ndef check_path(x, y, path):\n    for i in range(1, len(path)):\n        row1, col1 = get_position(path[i-1], x, y)\n        row2, col2 = get_position(path[i], x, y)\n        if abs(row2 - row1) + abs(col2 - col1) != 1:\n            return False\n    return True\n\ndef find_dimensions(n, path):\n    max_val = max(path)\n    for d in range(1, int(max_val**0.5) + 1):\n        if max_val % d == 0:\n            x, y = d, max_val // d\n            if check_path(x, y, path):\n                print('YES')\n                print(x, y)\n                return\n            y, x = d, max_val // d\n            if check_path(x, y, path):\n                print('YES')\n                print(x, y)\n                return\n    print('NO')\n\nn = int(input())\npath = list(map(int, input().split()))\nfind_dimensions(n, path)"}
{"solution": "def find_min_subseq(a, b):\n    n, m = len(a), len(b)\n    dp = [[-1] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][0] = i\n\n    for j in range(1, m + 1):\n        dp[0][j] = -1\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = i\n            elif dp[i - 1][j] != -1:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = -1\n\n    result = []\n    i, j = n, m\n    while i >= 0 and j >= 0 and dp[i][j] != -1:\n        while dp[i][j] == dp[i - 1][j]:\n            i -= 1\n        result.append(a[i - 1])\n        i -= 1\n        j -= 1\n\n    if not result:\n        print(\"-\")\n    else:\n        print(\"\".join(result[::-1]))\n\n# Read input\na = input().strip()\nb = input().strip()\n\nfind_min_subseq(a, b)"}
{"solution": "def min_stones_after_operations(n, operations):\n    min_stones = 0\n    current_stones = 0\n    \n    for op in operations:\n        if op == '+':\n            current_stones += 1\n        else:  # op == '-'\n            current_stones -= 1\n            min_stones = max(min_stones, current_stones)\n    \n    return max(min_stones, 1)\n\n# Read input\nn = int(input())\noperations = input()\n\n# Calculate and print the result\nprint(min_stones_after_operations(n, operations))"}
{"solution": "def max_kefir_liters(n, a, b, c):\n    def calculate_with_glass_bottles(money):\n        # Buy as many glass bottles as possible\n        bottles = money // b\n        # Calculate remaining money after buying glass bottles\n        remaining_money = money % b + (bottles * c)\n        # Use remaining money to buy additional glass bottles\n        additional_bottles = remaining_money // b\n        # Return total liters of kefir\n        return bottles + additional_bottles + (remaining_money % b) // c\n\n    def calculate_with_plastic_bottles(money):\n        # Simply divide the money by the cost of a plastic bottle\n        return money // a\n\n    # Calculate the maximum liters of kefir with both options\n    glass_liters = calculate_with_glass_bottles(n)\n    plastic_liters = calculate_with_plastic_bottles(n)\n\n    # Return the maximum of the two results\n    return max(glass_liters, plastic_liters)\n\n# Read input values\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Output the result\nprint(max_kefir_liters(n, a, b, c))"}
{"solution": "def read_ints():\n    return list(map(int, input().split()))\n\ndef simulate_war(cards1, cards2):\n    fights = 0\n    while cards1 and cards2:\n        if cards1[0] > cards2[0]:\n            cards1.append(cards2.pop(0))\n            cards1.append(cards1.pop(0))\n        else:\n            cards2.append(cards1.pop(0))\n            cards2.append(cards2.pop(0))\n        fights += 1\n        if fights > 10**6: return -1\n    return (fights, 1 if cards1 else 2)\n\nn = int(input())\nk1 = read_ints()[0]\ncards1 = read_ints()\nk2 = read_ints()[0]\ncards2 = read_ints()\n\nresult = simulate_war(cards1, cards2)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "import re\n\npassword = input().strip()\n\n# Check if the password meets all the criteria\nif (len(password) >= 5 and\n    re.search(r'[A-Z]', password) and\n    re.search(r'[a-z]', password) and\n    re.search(r'\\d', password)):\n    print(\"Correct\")\nelse:\n    print(\"Too weak\")"}
{"solution": "from collections import Counter\n\ndef min_exchanges_to_equalize_groups():\n    n = int(input())\n    group_a = Counter(map(int, input().split()))\n    group_b = Counter(map(int, input().split()))\n\n    # Check if it's impossible to equalize groups\n    if any(group_a[i] + group_b[i] % 2 for i in range(1, 6)):\n        print(-1)\n        return\n\n    exchanges = 0\n    surplus_a = []\n    surplus_b = []\n\n    # Calculate surpluses in each group\n    for grade in range(1, 6):\n        diff = group_a[grade] - group_b[grade]\n        if diff > 0:\n            surplus_a.extend([grade] * (diff // 2))\n        elif diff < 0:\n            surplus_b.extend([grade] * (-diff // 2))\n\n    # Match surpluses to minimize exchanges\n    while surplus_a:\n        exchanges += 1\n        surplus_b.append(surplus_a.pop())\n\n    print(exchanges)\n\nmin_exchanges_to_equalize_groups()"}
{"solution": "def is_reachable(n, m, h_streets, v_streets):\n    h_left_to_right = False\n    h_right_to_left = False\n    v_top_to_bottom = False\n    v_bottom_to_top = False\n    \n    for street in h_streets:\n        if street == '>':\n            h_left_to_right = True\n        else:\n            h_right_to_left = True\n            \n    for street in v_streets:\n        if street == 'v':\n            v_top_to_bottom = True\n        else:\n            v_bottom_to_top = True\n            \n    if (h_left_to_right and h_right_to_left and v_top_to_bottom and v_bottom_to_top):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Reading input\nn, m = map(int, input().split())\nh_streets = input()\nv_streets = input()\n\n# Printing output\nprint(is_reachable(n, m, h_streets, v_streets))"}
{"solution": "def generate_implication_expression(n, values):\n    zero_count = values.count('0')\n    \n    if zero_count == 0:\n        return \"NO\"\n    \n    if zero_count >= 2 or (zero_count == 1 and values[0] == '0'):\n        expression = ''.join(f'({val})' for val in values)\n        return f\"YES\\n{expression}\"\n    \n    return \"NO\"\n\ndef main():\n    n = int(input())\n    values = input().split()\n    result = generate_implication_expression(n, values)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def process_sequence(a, b):\n    while a > 0 and b > 0:\n        if a >= 2 * b:\n            a %= 2 * b\n        elif b >= 2 * a:\n            b %= 2 * a\n        else:\n            break\n    return a, b\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    result_a, result_b = process_sequence(n, m)\n    print(result_a, result_b)"}
{"solution": "def count_k_divisible(k, a, b):\n    \"\"\"\n    Finds the number of k-divisible numbers in the range [a, b].\n    \"\"\"\n    if a > b or k < 1:\n        return 0\n\n    # Adjusting the range for counting\n    if a % k != 0:\n        a += (k - a % k)\n    if b % k != 0:\n        b -= b % k\n\n    # Counting the k-divisible numbers\n    return (b - a) // k + 1 if a <= b else 0\n\n# Reading inputs\nk, a, b = map(int, input().split())\n\n# Printing the result\nprint(count_k_divisible(k, a, b))"}
{"solution": "def find_kth_digit(k):\n    n = 1\n    digit_count = 1\n    while k > digit_count * 9 * (10 ** (n - 1)):\n        k -= digit_count * 9 * (10 ** (n - 1))\n        n += 1\n        digit_count *= 2\n\n    if k % n == 0:\n        quotient = k // n\n    else:\n        quotient = k // n + 10 ** (n - 1)\n\n    remainder = k % n\n    if remainder == 0:\n        result_digit = int(str(quotient - 1)[n - 1])\n    else:\n        result_digit = int(str(quotient)[remainder - 1])\n\n    print(result_digit)\n\n# Taking input\nk = int(input())\nfind_kth_digit(k)"}
{"solution": "def can_win_vasya(n, s):\n    from collections import Counter\n    \n    if s[0] != '8':\n        return \"NO\"\n    \n    c = Counter(s)\n    \n    if c['8'] == 1 and s[0] == '8':\n        return \"NO\" if any(c[digit] % 2 != 0 for digit in map(str, range(10)) if digit != '8') else \"YES\"\n    \n    return \"YES\" if c['8'] >= 2 else \"NO\"\n\n# Example usage\nn = int(input())\ns = input()\nprint(can_win_vasya(n, s))"}
{"solution": "MOD = 10**9 + 7\n\ndef fact(n):\n    f = [1] * (n + 1)\n    for i in range(2, n + 1):\n        f[i] = f[i-1] * i % MOD\n    return f\n\ndef inv_fact(n, f, inv):\n    inv_f = [1] * (n + 1)\n    inv_f[n] = pow(f[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        inv_f[i - 1] = inv_f[i] * i % MOD\n    return inv_f\n\ndef C(n, k, f, inv_f):\n    return f[n] * inv_f[k] * inv_f[n - k] % MOD\n\ndef solve():\n    n, x, pos = map(int, input().split())\n    f = fact(n)\n    inv = [pow(i, MOD - 2, MOD) for i in range(1, n + 1)]\n    inv_f = inv_fact(n, f, inv)\n\n    ans = 0\n    for k in range(pos + 1, n + 1):\n        ans += C(k - 1, pos, f, inv_f) * C(n - k, n - k - (n - x), f, inv_f) % MOD * f[n - k] * f[k - 1] % MOD\n        ans %= MOD\n    print(ans)\n\nsolve()"}
{"solution": "def decode_message(s, k):\n    i, n, result = 0, len(s), \"\"\n    while len(result) < k and i < n:\n        if s[i].isalpha():\n            result += s[i]\n            if len(result) > k:\n                return \"Impossible\"\n            if '?' in s[i+1:i+s.count('*', i)+2]:\n                i += s[i+1:i+s.count('*', i)+2].index('?') + 1\n            else:\n                i += s[i+1:i+s.count('*', i)+2].rfind('*') + 1\n        i += 1\n    if len(result) == k:\n        return result\n    elif len(result) < k and '*' in s:\n        for j in range(i, n):\n            if s[j] == '*':\n                result += s[j-1] * (k - len(result))\n                break\n    return result if len(result) == k else \"Impossible\"\n\n# Read inputs\ns = input().strip()\nk = int(input().strip())\n\n# Print decoded message\nprint(decode_message(s, k))"}
{"solution": "def min_rotations(x):\n    x = x % 360  # Normalize angle to be within 0-359 degrees\n    if x <= 90: return x // 90\n    elif x <= 180: return (180 - x) // 90 + 1\n    elif x <= 270: return (270 - x) // 90 + 2\n    else: return (360 - x) // 90 + 3\n\nx = int(input())\nprint(min_rotations(x))"}
{"solution": "def can_achieve_spheres(a, b, c, x, y, z):\n    extra_needed = max(0, x - a) + max(0, y - b) + max(0, z - c)\n    total_initial = a + b + c\n    possible_transforms = (total_initial - x - y - z) // 2\n    return \"Yes\" if extra_needed <= possible_transforms else \"No\"\n\n# Reading input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Calculating and printing output\nprint(can_achieve_spheres(a, b, c, x, y, z))"}
{"solution": "def solve(n, k, m):\n    mod = m\n    dp = [0] * (k + 1)\n    dp[0] = 1\n    for _ in range(1, n + 1):\n        new_dp = [0] * (k + 1)\n        power_10 = pow(10, _ - 1, mod)\n        inv_power_10 = pow(power_10, -1, mod)\n        for j in range(k + 1):\n            for d in range(10):\n                if _ == 1 and d == 0:\n                    continue\n                new_j = (j * 10 + d) % k\n                new_dp[new_j] += dp[j]\n                new_dp[new_j] %= mod\n        dp = new_dp\n    return dp[0]\n\ndef main():\n    n, k, m = map(int, input().split())\n    print(solve(n, k, m))\n\nmain()"}
{"solution": "def max_team_size(l, r, a):\n    min_side = min(l + a, r + a)\n    return min_side * 2\n\n# To use this function:\n# l, r, a = map(int, input().split())\n# print(max_team_size(l, r, a))"}
{"solution": "def min_moves(n, k):\n    # Initialize DP table\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Fill DP table\n    for length in range(2, n + 1):\n        for start in range(1, n - length + 2):\n            end = start + length - 1\n            dp[start][end] = float('inf')\n            for mid in range(start, end):\n                moves = dp[start][mid] + dp[mid + 1][end] + end - start + 1\n                dp[start][end] = min(dp[start][end], moves)\n    \n    # Calculate result considering the starting position\n    result = sum(range(1, n)) - dp[1][n] + min(dp[1][k - 1], dp[k + 1][n])\n    return result\n\n# Read input\nn, k = map(int, input().split())\n\n# Compute and print result\nprint(min_moves(n, k))"}
{"solution": "import heapq\n\ndef min_max_tower_height(n, m):\n    \"\"\"\n    Finds the minimum height of the tallest tower that can be built by students\n    using pieces of two or three blocks, ensuring all towers have unique heights.\n    \"\"\"\n    h = [3]\n    heapq.heapify(h)\n    for _ in range(1, n + m):\n        smallest = heapq.heappop(h)\n        next_smallest = smallest + 3\n        while next_smallest % 2 == 0 or next_smallest % 3 == 0:\n            next_smallest += 1\n        heapq.heappush(h, smallest + 2)\n        heapq.heappush(h, next_smallest)\n    return h[0]\n\n# Input\nn, m = map(int, input().split())\n\n# Compute and print the result\nprint(min_max_tower_height(n, m))"}
{"solution": "def can_play_fair_game(n, cards):\n    from collections import Counter\n    \n    card_counts = Counter(cards)\n    sorted_cards = sorted(card_counts.items(), key=lambda x: x[1], reverse=True)\n    \n    for i, (num1, count1) in enumerate(sorted_cards):\n        for num2, count2 in sorted_cards[i + 1:]:\n            if count1 + count2 == n // 2:\n                return f\"YES\\n{num1} {num2}\"\n    \n    return \"NO\"\n\n# Reading input\nn = int(input())\ncards = [int(input()) for _ in range(n)]\n\n# Printing output\nprint(can_play_fair_game(n, cards))"}
{"solution": "def can_arrange_army(rows, groups):\n    total_seats = rows * 8\n    group_counts = [0] * (max(groups) + 1)\n    for group in groups:\n        group_counts[group] += 1\n\n    for count in range(len(group_counts), 0, -1):\n        if group_counts[count]:\n            max_rows = (total_seats - count) // (count * 2)\n            if max_rows < rows:\n                rows = max_rows\n            if rows < group_counts[count]:\n                return \"NO\"\n            rows -= group_counts[count]\n    return \"YES\"\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(can_arrange_army(n, a))"}
{"solution": "def find_optimal_t_and_cost(stick_lengths):\n    stick_lengths.sort()\n    n = len(stick_lengths)\n    \n    # Calculate prefix sums to make range sum queries efficient\n    prefix_sums = [0]\n    for length in stick_lengths:\n        prefix_sums.append(prefix_sums[-1] + length)\n    \n    min_cost = float('inf')\n    optimal_t = None\n    \n    # Try each possible t in the sorted list\n    for i in range(n):\n        t = stick_lengths[i]\n        current_cost = 0\n        \n        # Calculate cost for elements before t\n        if i > 0:\n            current_cost += 2 * (prefix_sums[i] - i * t)\n        \n        # Calculate cost for elements after t\n        current_cost += 2 * ((n-i) * t - (prefix_sums[n] - prefix_sums[i]))\n        \n        if current_cost < min_cost:\n            min_cost = current_cost\n            optimal_t = t\n    \n    return optimal_t, min_cost\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Compute and print the result\nt, cost = find_optimal_t_and_cost(a)\nprint(t, cost)"}
{"solution": "def min_square_side(n, m, sky):\n    star_rows = []\n    star_cols = []\n\n    for i in range(n):\n        for j in range(m):\n            if sky[i][j] == '*':\n                star_rows.append(i)\n                star_cols.append(j)\n\n    row_min, row_max = min(star_rows), max(star_rows)\n    col_min, col_max = min(star_cols), max(star_cols)\n\n    return max(row_max - row_min + 1, col_max - col_min + 1)\n\n\nn, m = map(int, input().split())\nsky = [input() for _ in range(n)]\n\nprint(min_square_side(n, m, sky))"}
{"solution": "MOD = 10**9 + 7\n\ndef modinv(x):\n    return pow(x, MOD-2, MOD)\n\ndef solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    ones = a.count(1)\n    zeros = n - ones\n    \n    if abs(ones - zeros) > 1:\n        print(0)\n        return\n    \n    # Calculate the initial number of inversions\n    inversions = sum(a[i] > a[j] for i in range(n) for j in range(i+1, n))\n    \n    if k % 2 == 0 or inversions == 0:\n        result = 1\n    else:\n        result = n * (n - 1) // 2 - inversions\n    \n    result %= MOD\n    total = (n * (n - 1) // 2) % MOD\n    ans = result * modinv(total) % MOD\n    \n    print(ans)\n\nsolve()"}
{"solution": "x, y = map(int, input().split())\nprint(x - y)"}
{"solution": "from math import sqrt\n\ndef min_norm_degenerate(a, b, c, d):\n    det = a * d - b * c\n    if det == 0:\n        return 0.0\n    else:\n        n1 = abs(a * d - b * b)\n        n2 = abs(a * d - c * c)\n        n3 = abs(a * c - b * d)\n        n4 = abs(d * c - b * b)\n        return sqrt(min(n1, n2, n3, n4) / det)\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\nprint(min_norm_degenerate(a, b, c, d))"}
{"solution": "import sys\n\nn, a, b = map(int, input().split())\nt = list(map(int, sys.stdin.readline().split()))\n\nrefuse = 0\none_seater = a\ntwo_seater = b\n\nfor group in t:\n    if group == 1:\n        if one_seater > 0:\n            one_seater -= 1\n        elif two_seater > 0:\n            two_seater -= 1\n        elif two_seater < 0:\n            two_seater += 1\n        else:\n            refuse += 1\n    else:\n        if two_seater > 0:\n            two_seater -= 1\n        else:\n            refuse += 2\n\nprint(refuse)"}
{"solution": "def failed_students(A, B, C, N):\n    both_restaurants = C\n    only_bugdonalds = A - C\n    only_beaverking = B - C\n    \n    # Check for valid conditions\n    if (only_bugdonalds < 0 or only_beaverking < 0 or\n        (only_bugdonalds + only_beaverking + both_restaurants > N)):\n        return -1\n    \n    failed = N - (only_bugdonalds + only_beaverking + both_restaurants)\n    return failed if failed >= 1 else -1\n\n# Read input values\nA, B, C, N = map(int, input().split())\n\n# Calculate and print the result\nprint(failed_students(A, B, C, N))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(x, k):\n    def matrix_mult(a, b):\n        return [[sum(a[i][k] * b[k][j] for k in range(2)) % MOD for j in range(2)] for i in range(2)]\n\n    def matrix_pow(m, n):\n        result = [[1, 0], [0, 1]]\n        while n > 0:\n            if n & 1:\n                result = matrix_mult(result, m)\n            m = matrix_mult(m, m)\n            n >>= 1\n        return result\n\n    if k == 0:\n        return (x * (1 << k)) % MOD\n    else:\n        transition_matrix = [[1, 1], [1, 0]]\n        powered_matrix = matrix_pow(transition_matrix, k)\n        return (x * powered_matrix[0][0]) % MOD\n\nx, k = map(int, input().split())\nprint(solve(x, k))"}
{"solution": "MOD = 998244353\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef solve():\n    from math import gcd\n    n = int(input())\n    probs = [list(map(int, input().split())) for _ in range(n)]\n    \n    numerator = 1\n    denominator = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            lo = max(probs[i][0], probs[j][0])\n            hi = min(probs[i][1], probs[j][1])\n            if lo > hi:\n                numerator = 0\n            else:\n                numerator *= max(hi - lo + 1, 1)\n                numerator %= MOD\n    \n    for lr in probs:\n        denominator *= (lr[1] - lr[0] + 1)\n        denominator %= MOD\n    \n    # Simplify fraction\n    common_divisor = gcd(numerator, denominator)\n    numerator //= common_divisor\n    denominator //= common_divisor\n    \n    # Find modular inverse of denominator\n    denominator_inv = modinv(denominator)\n    \n    # Calculate result\n    result = (numerator * denominator_inv) % MOD\n    print(result)\n\nsolve()"}
{"solution": "def count_ways_to_form_rectangle(n):\n    \"\"\"\n    Counts the number of ways to split a stick of length n into four parts\n    so that it's possible to form a rectangle but not a square.\n    \"\"\"\n    ways = 0\n    for x in range(1, n // 2):\n        if n % 2 == 0 and 2 * x < n:  # Ensure 2x < n to leave room for other parts\n            ways += 1\n    return ways\n\n# Read input\nn = int(input())\n\n# Compute and print result\nprint(count_ways_to_form_rectangle(n))"}
{"solution": "import sys\nfrom typing import List\n\ndef min_kvass_volume(n: int, s: int, volumes: List[int]) -> int:\n    if sum(volumes) < s:\n        return -1\n\n    min_volume = max(0, min(volumes) - s)\n    max_volume = max(volumes)\n\n    while min_volume < max_volume:\n        mid_volume = (min_volume + max_volume + 1) // 2\n        total = sum(max(0, volume - mid_volume) for volume in volumes)\n\n        if total >= s:\n            min_volume = mid_volume\n        else:\n            max_volume = mid_volume - 1\n\n    return min_volume if min_volume >= 0 else -1\n\n# Reading input from stdin\nn, s = map(int, sys.stdin.readline().split())\nvolumes = list(map(int, sys.stdin.readline().split()))\n\n# Calculating and printing the result\nresult = min_kvass_volume(n, s, volumes)\nprint(result)"}
{"solution": "def caterpillar_and_apple():\n    h1, h2 = map(int, input().split())\n    a, b = map(int, split())\n\n    net_daily_progress = (8 * a) - (12 * b)\n    initial_day_progress = (6 * a)\n\n    if net_daily_progress <= 0 and h2 > h1 + initial_day_progress:\n        return -1\n\n    if h2 <= h1 + initial_day_progress:\n        return 0\n\n    days_needed = ((h2 - h1) + (8 * b) - 1) // (8 * (a - b))\n\n    if h1 + (days_needed * (8 * a - 12 * b)) + (8 * a) >= h2:\n        return days_needed\n\n    return days_needed + 1\n\nprint(caterpillar_and_apple())"}
{"solution": "def max_joy_units(c, hr, hb, wr, wb):\n    max_joy = 0\n    max_joy = max(max_joy, ((c // wr) * hr))\n    max_joy = max(max_joy, ((c // wb) * hb))\n    \n    for i in range(0, c // wr + 1):\n        remaining_weight = c - (i * wr)\n        if remaining_weight >= 0:\n            max_joy = max(max_joy, (i * hr + (remaining_weight // wb) * hb))\n            \n    return max_joy\n\nif __name__ == \"__main__\":\n    c, hr, hb, wr, wb = map(int, input().split())\n    print(max_joy_units(c, hr, hb, wr, wb))"}
{"solution": "def min_steps(start, end):\n    x1, y1 = start\n    x2, y2 = end\n    dx = abs(x1 - x2)\n    dy = abs(y1 - y2)\n    return max(dx, dy)\n\nstart = tuple(map(int, input().split()))\nend = tuple(map(int, input().split()))\nprint(min_steps(start, end))"}
{"solution": "def vote_outcome(n, fractions):\n    d_count = fractions.count('D')\n    r_count = n - d_count\n    rounds = 0\n\n    while d_count != 1 and r_count != 1:\n        if rounds % 2 == 0:\n            d_count = max(0, d_count - r_count)\n        else:\n            r_count = max(0, r_count - d_count)\n        rounds += 1\n\n    return 'D' if d_count == 1 else 'R'\n\nn = int(input())\nfractions = input().strip()\nprint(vote_outcome(n, fractions))"}
{"solution": "from math import gcd\n\na, b, x, y = map(int, input().split())\n\ngcd_xy = gcd(x, y)\n\nx //= gcd_xy\ny //= gcd_xy\n\nmin_val = min(a // x, b // y)\n\nresult = min_val - (min_val % gcd(x, y)) + (gcd(x, y) > 1 and min_val % gcd(x, y) != 0)\n\nprint(result)"}
{"solution": "from collections import defaultdict\nimport math\n\ndef maxPowerDividingKFactorial(k, p):\n    cnt = 0\n    pp = p\n    while k >= pp:\n        cnt += k // pp\n        pp *= p\n\n    return cnt\n\ndef highestPowerOfBaseInFactorial(n, b):\n    prime_factors = defaultdict(int)\n\n    # Prime factorize the base 'b'\n    x = b\n    for i in range(2, int(math.sqrt(b)) + 1):\n        while x % i == 0:\n            prime_factors[i] += 1\n            x //= i\n\n    if x > 1:\n        prime_factors[x] += 1\n\n    minPower = float('inf')\n    for p in prime_factors:\n        powerP = prime_factors[p]\n        powerPInNFact = maxPowerDividingKFactorial(n, p)\n        minPower = min(minPower, powerPInNFact // powerP)\n\n    return minPower\n\n# Reading input\nn, b = map(int, input().split())\n\n# Calculating and printing the result\nprint(highestPowerOfBaseInFactorial(n, b))"}
{"solution": "def calculate_sum(m, a, b):\n    gcd = abs(a - b)\n    if gcd == 0:\n        return (m + 1) * (m // 2) + (m + 1) // 2\n    else:\n        c = (m + 1) // gcd * (gcd * (gcd + 1)) // 2\n        if (m + 1) % gcd == 0:\n            c += (gcd * (gcd + 1)) // 2\n        return c - (gcd * (gcd + 1)) // 2 + m + 1\n\n# Reading input\nm, a, b = map(int, input().split())\n\n# Calculating and printing the result\nprint(calculate_sum(m, a, b))"}
{"solution": "def can_divide_into_odds(n, seq):\n    odd_count = 0\n    start = -1\n    \n    for i in range(n):\n        if seq[i] % 2 == 1:\n            if start == -1:\n                start = i\n        else:\n            if start != -1:\n                odd_count += 1\n                start = -1\n    \n    # Check last segment if it ends with an odd number\n    if start != -1 and seq[-1] % 2 == 1:\n        odd_count += 1\n    \n    return \"Yes\" if odd_count % 2 == 1 else \"No\"\n\n# Reading input\nn = int(input())\nseq = list(map(int, input().split()))\n\n# Printing output\nprint(can_divide_into_odds(n, seq))"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    if x1 == x2:\n        x3, x4 = x1, x2\n        y3, y4 = y2, y2\n    elif y1 == y2:\n        y3, y4 = y1, y2\n        x3, x4 = x2, x1\n    else:\n        if abs(x1 - x2) == abs(y1 - y2):\n            x3, x4 = x1, x2\n            y3, y4 = y2, y1\n        else:\n            return -1\n\n    if -1000 <= x3 <= 1000 and -1000 <= y3 <= 1000 and -1000 <= x4 <= 1000 and -1000 <= y4 <= 1000:\n        return x3, y3, x4, y4\n    else:\n        return -1\n\nx1, y1, x2, y2 = map(int, input().split())\nresult = find_remaining_trees(x1, y1, x2, y2)\nprint(*result)"}
{"solution": "MOD = 1000000007\n\ndef solve(x, y, n):\n    if n == 1:\n        return x % MOD\n    elif n == 2:\n        return y % MOD\n    \n    # Calculate the period length\n    a, b = x, y\n    period_length = 2\n    while True:\n        a, b = b, (a - b) % MOD\n        period_length += 1\n        if a == x and b == y:\n            break\n    \n    # Calculate f_n using the periodicity\n    n = ((n - 2) % (period_length - 2)) + 2\n    a, b = x, y\n    for _ in range(n - 2):\n        a, b = b, (a - b) % MOD\n    \n    return b\n\n# Read input\nx, y = map(int, input().split())\nn = int(input())\n\n# Solve and print result\nprint(solve(x, y, n))"}
{"solution": "def find_splits(arr):\n    n = len(arr)\n    start = 0\n    splits = []\n    \n    for end in range(n):\n        # Check if current subarray sum is non-zero\n        if sum(arr[start:end+1]) != 0:\n            splits.append((start, end))\n            start = end + 1\n    \n    # If no valid splits were found\n    if not splits:\n        return \"NO\"\n    \n    # Prepare the answer\n    answer = [\"YES\", str(len(splits))]\n    for split in splits:\n        answer.append(f\"{split[0] + 1} {split[1] + 1}\")\n    \n    return \"\\n\".join(answer)\n\n# Reading input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Printing output\nprint(find_splits(arr))"}
{"solution": "MOD = 1000000009\n\ndef min_score(n, m, k):\n    if k >= m:\n        return m\n    if k == 0:\n        return 0\n    full_sequences, extra_correct = divmod(m, k)\n    base_score = (k * (full_sequences + 1) + extra_correct) % MOD\n    doubling_score = ((2 ** full_sequences) * base_score) % MOD\n    return doubling_score\n\nif __name__ == \"__main__\":\n    n, m, k = map(int, input().split())\n    print(min_score(n, m, k))"}
{"solution": "def find_divisible_by_8(n: str):\n    \"\"\"\n    Finds a subsequence of the digits in n that forms a number divisible by 8.\n    If such a subsequence exists, prints 'YES' and the subsequence.\n    Otherwise, prints 'NO'.\n    \"\"\"\n    length = len(n)\n    \n    # Check for a single digit divisible by 8 (0)\n    if n[-1] == '0':\n        print(\"YES\")\n        print('0')\n        return\n    \n    # Check for any two or three consecutive digits forming a number divisible by 8\n    for i in range(length - 1, -1, -1):\n        if int(n[i]) % 8 == 0:\n            print(\"YES\")\n            print(n[i])\n            return\n        if i > 0 and int(n[i-1:i+1]) % 8 == 0:\n            print(\"YES\")\n            print(n[i-1:i+1])\n            return\n        if i > 1 and int(n[i-2:i+1]) % 8 == 0:\n            print(\"YES\")\n            print(n[i-2:i+1])\n            return\n    \n    # If no such subsequence found, print 'NO'\n    print(\"NO\")\n\n# Read input and process\nn = input().strip()\nfind_divisible_by_8(n)"}
{"solution": "def find_floor(n, memories):\n    possible_flats = set()\n\n    for k, f in memories:\n        if k % f == 0:\n            possible_flats.add(k // f)\n        else:\n            possible_flats.add(k // f + 1)\n\n    consistent_flats = set()\n    for flats in possible_flats:\n        if all(1 if k % flats == 0 else k // flats + 1 == f for k, f in memories):\n            consistent_flats.add(flats)\n\n    if len(consistent_flats) == 1:\n        return (n - 1) // list(consistent_flats)[0] + 1\n    return -1\n\nn, m = map(int, input().split())\nmemories = [tuple(map(int, input().split())) for _ in range(m)]\nprint(find_floor(n, memories))"}
{"solution": "from typing import List\n\ndef max_bishwocks(board: List[str]) -> int:\n    dp = [0] * 4\n    for row in zip(*board):\n        new_dp = [0] * 4\n        for i in range(4):\n            if row[0] == '0':\n                new_dp[i] = max(new_dp[i], dp[i])\n            if row[1] == '0':\n                new_dp[i] = max(new_dp[i], dp[i ^ 3])\n            if row == ['0', '0']:\n                new_dp[i] = max(new_dp[i], dp[i] + 1)\n                new_dp[(i + 1) % 4] = max(new_dp[(i + 1) % 4], dp[i] + 1)\n        dp = new_dp\n    return max(dp)\n\n# Reading input\nboard = []\nfor _ in range(2):\n    board.append(input())\n\n# Calculating and printing the result\nprint(max_bishwocks(board))"}
{"solution": "def max_pretty_positions(n, s):\n    count = 0\n    last_upper = -1\n    lower_set = set()\n\n    for i in range(n):\n        if s[i].islower():\n            if last_upper == -1:\n                count += 1\n                lower_set.add(s[i])\n            elif s[i] not in lower_set:\n                count += 1\n                lower_set.add(s[i])\n                last_upper = -1\n        else:\n            last_upper = i\n\n    return count\n\n# Read input\nn = int(input())\ns = input()\n\n# Compute and print the result\nprint(max_pretty_positions(n, s))"}
{"solution": "# Importing necessary library\nfrom typing import List\n\ndef max_diff_B_C(arr: List[int]) -> int:\n    \"\"\"Calculates the maximum possible value of B - C\"\"\"\n    # Calculate total sum of array elements\n    total_sum = sum(arr)\n    # Initialize C as 0 for the case when all elements are put in B\n    C = 0\n    # Sort the array in ascending order\n    arr.sort()\n    # Iterate over the array from start to find optimal split\n    for num in arr:\n        # If adding current number to C increases B-C, update C\n        if C + num > 0:\n            C += num\n        else:\n            break\n    # B is the remaining part of total sum after forming C\n    B = total_sum - C\n    return B - C\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(max_diff_B_C(a))"}
{"solution": "import math\n\ndef min_refuels(a, b, f, k):\n    if b >= 2 * a - f:\n        return k - 1\n    if b < 2 * f:\n        if b < f:\n            return -1 if k > 1 else 0\n        return math.ceil(k * (a - f) / (b - f))\n    # b in [2*f, 2*a-f)\n    return math.ceil(k * (a - f) / (b - f)) + (k - 1)\n\n# Example usage\na, b, f, k = map(int, input().split())\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(s, p, q):\n    n = len(s)\n    parts = []\n    \n    while s:\n        if len(s) >= p:\n            parts.append(s[:p])\n            s = s[p:]\n        elif len(s) >= q:\n            parts.append(s[:q])\n            s = s[q:]\n        else:\n            return [-1]\n    \n    if len(parts[-1]) != p and len(parts[-1]) != q:\n        return [-1]\n        \n    return [str(len(parts))] + parts\n\nif __name__ == \"__main__\":\n    n, p, q = map(int, input().split())\n    s = input()\n    result = split_string(s, p, q)\n    for res in result:\n        print(res)"}
{"solution": "from collections import deque\n\ndef can_reach_end(obstacles, m, s, d):\n    obs_set = set(obstacles)\n    obs_set.add(m)\n    obstacles = sorted(list(obs_set))\n    n = len(obstacles)\n\n    dp = [False] * n\n    dp[0] = True\n    prev_jumps = [0] * n\n\n    for i in range(1, n):\n        diff = obstacles[i] - obstacles[i-1]\n        if diff <= s:\n            dp[i] = dp[i-1]\n            prev_jumps[i] = i - 1\n        else:\n            for j in range(max(0, i-d), i-s):\n                if dp[j] and (obstacles[i] - obstacles[j] <= d):\n                    dp[i] = True\n                    prev_jumps[i] = j\n                    break\n\n    if not dp[-1]:\n        print(\"IMPOSSIBLE\")\n        return\n\n    path = deque()\n    idx = n - 1\n    while idx > 0:\n        jump_start = prev_jumps[idx]\n        if jump_start == idx - 1:\n            path.appendleft(f\"RUN {obstacles[idx] - obstacles[jump_start]}\")\n        else:\n            path.appendleft(f\"RUN {s}\")\n            path.appendleft(f\"JUMP {obstacles[idx] - obstacles[jump_start]}\")\n        idx = jump_start\n\n    print(\"\\n\".join(path))\n\nif __name__ == \"__main__\":\n    n, m, s, d = map(int, input().split())\n    obstacles = list(map(int, input().split()))\n    can_reach_end(obstacles, m, s, d)"}
{"solution": "def count_pairs(s, x):\n    if s > 2 * x:\n        return 0\n    lower_bit_diff = (s - x) % 2\n    higher_bits = min(x, s - x)\n    higher_bits_count = 0\n    while higher_bits > 0:\n        higher_bits >>= 1\n        higher_bits_count += 1\n    if lower_bit_diff == 0:\n        return (1 << higher_bits_count) - 1\n    else:\n        return (1 << higher_bits_count)\n\ns, x = map(int, input().split())\nprint(count_pairs(s, x))"}
{"solution": "def solve(n, k):\n    import math\n    l = math.ceil(n / (2 * k + 1))\n    print(l)\n    for i in range(l):\n        print(1 + i * (2 * k + 1), end=\" \")\n    print()\n\n# Example usage\nn, k = map(int, input().split())\nsolve(n, k)"}
{"solution": "from math import sqrt, floor\n\ndef is_square(n):\n    root = int(sqrt(n))\n    return root * root == n\n\ndef solve(n):\n    str_n = str(n)\n    min_operations = float('inf')\n\n    for mask in range(1 << len(str_n)):\n        new_num_str = ''\n        for i in range(len(str_n)):\n            if not mask & (1 << i):\n                new_num_str += str_n[i]\n\n        if new_num_str and new_num_str[0] != '0':\n            new_num = int(new_num_str)\n            if is_square(new_num):\n                min_operations = min(min_operations, len(str_n) - len(new_num_str))\n\n    return min_operations if min_operations != float('inf') else -1\n\nn = int(input())\nprint(solve(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef add(x, y):\n    return (x + y) % MOD\n\ndef mul(x, y):\n    return (x * y) % MOD\n\nclass Factorial:\n    def __init__(self, n, mod):\n        self.fact = [1] * (n + 1)\n        self.invfact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            self.fact[i] = self.fact[i - 1] * i % mod\n        self.invfact[n] = pow(self.fact[n], mod - 2, mod)\n        for i in range(n, 0, -1):\n            self.invfact[i - 1] = self.invfact[i] * i % mod\n\n    def factorial(self, n):\n        return self.fact[n]\n\n    def ifactorial(self, n):\n        return self.invfact[n]\n\n    def comb(self, n, k):\n        return self.fact[n] * self.invfact[k] % MOD * self.invfact[n - k] % MOD\n\nn = int(input())\nfac = Factorial(n, MOD)\nprimes = []\nis_prime = [True] * (n + 1)\nfor i in range(2, n + 1):\n    if is_prime[i]:\n        primes.append(i)\n        for j in range(i, n + 1, i):\n            is_prime[j] = False\ncnt = len(primes)\nif n >= 4:\n    cnt += 1\nans = fac.factorial(n)\nfor i in range(cnt):\n    ans = mul(ans, fac.ifactorial(n - primes[i]))\nprint(ans)"}
{"solution": "def min_jump_ability(s):\n    vowels = \"AEIOUY\"\n    positions = [i for i, char in enumerate(s) if char in vowels]\n    \n    if not positions:\n        return len(s)\n    \n    max_gap = max(positions[0], len(s) - positions[-1])\n    for i in range(1, len(positions)):\n        max_gap = max(max_gap, positions[i] - positions[i - 1])\n    \n    return max_gap\n\n# Read input\ns = input().strip()\n\n# Calculate and print the result\nprint(min_jump_ability(s))"}
{"solution": "def can_distribute_evenly(bags):\n    total_candies = sum(bags)\n    if total_candies % 2 != 0:\n        return \"NO\"\n    possible = [False] * (total_candies // 2 + 1)\n    possible[0] = True\n    for bag in bags:\n        for i in range(total_candies // 2, bag - 1, -1):\n            if not possible[i]:\n                possible[i] = possible[i - bag]\n    return \"YES\" if possible[total_candies // 2] else \"NO\"\n\nbags = list(map(int, input().split()))\nprint(can_distribute_evenly(bags))"}
{"solution": "def pie_sharing(slices):\n    n = len(slices)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for length in range(1, n + 1):\n        for start in range(n - length + 1):\n            end = start + length\n            if length == 1:\n                dp[start][end] = slices[start]\n            else:\n                bob_takes = slices[start] + dp[start + 1][end - 1]\n                alice_takes = slices[start + length - 1] + dp[start + 1][end - 1]\n                dp[start][end] = max(bob_takes, alice_takes)\n                \n                bob_passes = dp[start + 1][end]\n                alice_passes = dp[start][end - 1]\n                dp[start][end] = max(dp[start][end], min(bob_passes, alice_passes))\n                \n    return dp[0][n]\n\nif __name__ == \"__main__\":\n    n = int(input())\n    slices = list(map(int, input().split()))\n    total_pie = sum(slices)\n    optimal_alice = pie_sharing(slices)\n    optimal_bob = total_pie - optimal_alice\n    print(optimal_alice, optimal_bob)"}
{"solution": "from math import gcd\nfrom functools import reduce\n\ndef find_min_vars(nums):\n    \"\"\"\n    Finds the minimum number of variables needed to perform the operations.\n    \"\"\"\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def smallest_divisor(n):\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return i\n        return n\n\n    if len(set(nums)) != len(nums) or nums[0] != min(nums):\n        return -1\n\n    lcm_val = reduce(lcm, nums)\n    if lcm_val == nums[0]:\n        return 1\n\n    smallest_div = smallest_divisor(lcm_val // nums[0])\n    return smallest_div\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculating and printing the answer\nprint(find_min_vars(a))"}
{"solution": "def main():\n    n = int(input())\n    piles = list(map(int, input().split()))\n    alice_turn = True\n    piles.sort(reverse=True)\n    while piles.count(0) < n // 2:\n        if alice_turn:\n            # Alice takes max and second max\n            if len(piles) >= 2:\n                piles[0] -= 1\n                piles[1] -= 1\n                piles = [x for x in piles if x > 0]  # Remove 0s\n                piles.sort(reverse=True)\n                alice_turn = False\n            else:\n                break\n        else:\n            # Bob can only take from the largest pile(s)\n            if len(piles) >= 1:\n                piles[0] -= 2\n                piles = [x for x in piles if x > 0]  # Remove 0s\n                piles.sort(reverse=True)\n                alice_turn = True\n            else:\n                break\n    if piles.count(0) >= n // 2 and not alice_turn:\n        print(\"Alice\")\n    else:\n        print(\"Bob\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_make_equal(arr):\n    n = len(arr)\n    min_val = min(arr)\n    for x in range(2 * (max(arr) - min_val) + 1):\n        changes = [0] * (2 * x + 1)\n        for num in arr:\n            target = num - x\n            diff = num - target\n            if 0 <= diff <= 2 * x:\n                changes[diff] += 1\n        for i in range(1, len(changes)):\n            changes[i] += changes[i - 1]\n        for i in range(x + 1):\n            if (changes[2 * x] == changes[i - 1] + (n - changes[i]) and\n                    changes[x - 1] == changes[i - 1] + (changes[x] - changes[i])):\n                return \"YES\"\n    return \"NO\"\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Output result\nprint(can_make_equal(arr))"}
{"solution": "def solve():\n    n = int(input())\n    s = input()\n    \n    def match_len(a, b):\n        \"\"\"Return the length of the longest common prefix of a and b.\"\"\"\n        i = 0\n        while i < len(a) and i < len(b) and a[i] == b[i]:\n            i += 1\n        return i\n    \n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Find the maximum length of the repeating substring\n            repeat_len = match_len(s[:j], s[j:])\n            if repeat_len and j + repeat_len <= n:\n                ans = max(ans, repeat_len)\n    \n    print(ans)\n\nsolve()"}
{"solution": "def min_time_to_reach_house(n, a):\n    if a == 1 or a == n:\n        return 1\n    if a <= n // 2:\n        return a\n    else:\n        return n - a + 1\n\nn, a = map(int, input().split())\nprint(min_time_to_reach_house(n, a))"}
{"solution": "def check_interval\u53ef\u884c\u6027(n, m, lightsabers, color_counts):\n    total_count = sum(color_counts)\n    \n    # \u9884\u8ba1\u7b97\u524d\u7f00\u548c\u4ee5\u4fbf\u5feb\u901f\u67e5\u8be2\u533a\u95f4\u548c\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + (lightsabers[i - 1] <= m)\n    \n    # \u8bb0\u5f55\u6bcf\u4e2a\u989c\u8272\u9700\u8981\u7684\u6570\u91cf\u4ee5\u53ca\u5f53\u524d\u533a\u95f4\u7684\u6570\u91cf\n    required_counts = color_counts[:]\n    current_counts = [0] * (m + 1)\n    \n    # \u4f7f\u7528\u54c8\u5e0c\u8868\u8bb0\u5f55\u76ee\u6807\u6570\u91cf\u7684\u6a21\u5f0f\n    target_pattern = {}\n    for color in range(1, m + 1):\n        pattern = tuple(required_counts)\n        if pattern not in target_pattern:\n            target_pattern[pattern] = []\n        target_pattern[pattern].append(color)\n    \n    for start in range(n):\n        for end in range(start, min(n, start + total_count)):\n            color = lightsabers[end]\n            if color <= m:\n                current_counts[color] += 1\n            \n            # \u68c0\u67e5\u5f53\u524d\u533a\u95f4\u662f\u5426\u6ee1\u8db3\u6761\u4ef6\n            if end - start + 1 == total_count:\n                if tuple(current_counts) in target_pattern:\n                    for color in target_pattern[tuple(current_counts)]:\n                        if current_counts[color] == required_counts[color - 1]:\n                            required_counts[color - 1] = -1\n                \n                if all(x <= 0 for x in required_counts):\n                    return \"YES\"\n                \n                # \u56de\u6eaf\uff0c\u91cd\u7f6e\u6240\u9700\u6570\u91cf\n                for color in range(1, m + 1):\n                    if current_counts[color] > 0:\n                        current_counts[color] -= 1\n                        required_counts[color - 1] = color_counts[color - 1]\n                \n                break\n    \n    return \"NO\"\n\n# \u8bfb\u53d6\u8f93\u5165\nn, m = map(int, input().split())\nlightsabers = list(map(int, input().split()))\ncolor_counts = list(map(int, input().split()))\n\n# \u8f93\u51fa\u7ed3\u679c\nprint(check_interval\u53ef\u884c\u6027(n, m, lightsabers, color_counts))"}
{"solution": "def determine_winner(n, rounds):\n    mishka_wins = 0\n    chris_wins = 0\n    \n    for m, c in rounds:\n        if m > c:\n            mishka_wins += 1\n        elif c > m:\n            chris_wins += 1\n    \n    if mishka_wins > chris_wins:\n        print(\"Mishka\")\n    elif chris_wins > mishka_wins:\n        print(\"Chris\")\n    else:\n        print(\"Friendship is magic!^^\")\n\n# Reading input\nn = int(input())\nrounds = [list(map(int, input().split())) for _ in range(n)]\n\n# Determining and printing the winner\ndetermine_winner(n, rounds)"}
{"solution": "def is_valid_minesweeper_field(n, m, field):\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n\n    def count_bombs(x, y):\n        count = 0\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and field[nx][ny] == '*':\n                count += 1\n        return count\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '.':\n                if any(field[i + dx][j + dy] == '*' for dx, dy in directions if 0 <= i + dx < n and 0 <= j + dy < m):\n                    return \"NO\"\n            elif field[i][j] == '*':\n                continue\n            else:\n                expected_bombs = int(field[i][j])\n                actual_bombs = count_bombs(i, j)\n                if actual_bombs != expected_bombs:\n                    return \"NO\"\n\n    return \"YES\"\n\n# Reading input\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\n# Output result\nprint(is_valid_minesweeper_field(n, m, field))"}
{"solution": "import math\n\ndef min_k_value(n):\n    k = 1\n    while True:\n        remaining_candies = n\n        vasya_candies = 0\n        while remaining_candies > 0:\n            remaining_candies -= k\n            vasya_candies += k\n            if remaining_candies <= 0:\n                break\n            petya_candies = math.floor(remaining_candies * 0.1)\n            remaining_candies -= petya_candies\n        if vasya_candies >= n / 2:\n            return k\n        k += 1\n\nn = int(input())\nprint(min_k_value(n))"}
{"solution": "def solve_necklace(necklace):\n    n = len(necklace)\n    pearl_positions = [i for i, char in enumerate(necklace) if char == 'o']\n    num_pearls = len(pearl_positions)\n\n    if num_pearls <= 1:\n        return \"YES\"\n\n    link_counts = []\n    for i in range(num_pearls):\n        start = pearl_positions[i]\n        end = pearl_positions[(i + 1) % num_pearls]\n        link_count = end - start - 1\n        if start < end:\n            link_counts.append(link_count)\n        else:\n            link_counts.append(n - start + end - 1)\n\n    max_links = max(link_counts)\n    min_links = min(link_counts)\n\n    if max_links == min_links:\n        return \"YES\"\n    elif max_links - min_links == num_pearls - 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nnecklace = input().strip()\n\n# Solve and print result\nprint(solve_necklace(necklace))"}
{"solution": "def max_pillows_for_frodo(n, m, k):\n    low, high = 1, m\n    while low <= high:\n        mid = (low + high) // 2\n        required = calculate_required_pillows(n, k, mid)\n        if required <= m:\n            equal_distribution = (m - required) // (n - 1)\n            total_pillows_for_frodo = mid + equal_distribution\n            if (mid > 1 and calculate_required_pillows(n, k, mid + 1) <= m) or total_pillows_for_frodo - 1 >= mid:\n                low = mid + 1\n            else:\n                high = mid - 1\n        else:\n            high = mid - 1\n    return low\n\ndef calculate_required_pillows(n, k, pillows_for_frodo):\n    left_extra = max(0, pillows_for_frodo - 1)\n    right_extra = max(0, pillows_for_frodo - 1)\n    total_extra = (k - 1) * left_extra + (n - k) * right_extra\n    return total_extra + n\n\nn, m, k = map(int, input().split())\nprint(max_pillows_for_frodo(n, m, k))"}
{"solution": "from collections import deque\n\ndef max_subarray_cost(arr, m, k):\n    n = len(arr)\n    dp = [0] * (n + 1)\n    dq = deque()\n    sum_elements = 0\n    max_cost = 0\n\n    for i in range(n):\n        sum_elements += arr[i]\n        while dq and i - dq[0] + 1 > m:\n            dq.popleft()\n        if dq:\n            dp[i + 1] = dp[dq[0]] + sum_elements - k\n        else:\n            dp[i + 1] = sum_elements\n        while dq and dp[i + 1] >= dp[dq[-1]]:\n            dq.pop()\n        dq.append(i + 1)\n        max_cost = max(max_cost, dp[i + 1])\n\n    return max_cost\n\n# Reading input\nn, m, k = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(max_subarray_cost(arr, m, k))"}
{"solution": "def main():\n    n, m = map(int, input().split())\n    \n    if n > 1 and m > 1:\n        print(f\"{n} {m}\")\n        print(f\"0 0\")\n        print(f\"{n} 0\")\n        print(f\"0 {m}\")\n    elif n == 0:  # Only horizontal options\n        print(f\"0 {m-1}\")\n        print(f\"0 {m}\")\n        print(f\"0 0\")\n        print(f\"0 {m-1}\")\n    else:  # Only vertical options or square grid with one dimension size 1\n        print(f\"{n} 0\")\n        print(f\"0 0\")\n        print(f\"{n} 1\")\n        print(f\"0 1\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_smallest_number(s, t):\n    import collections\n    \n    s_counter = collections.Counter(s)\n    t_counter = collections.Counter(t)\n    \n    result = []\n    remaining = list(s)\n    \n    for i in range(1, len(s)):\n        current_counter = collections.Counter(s[:i])\n        suffix = s[i:]\n        \n        for j in range(len(t)):\n            if j > 0:\n                current_counter[suffix[j - 1]] += 1\n            \n            if current_counter == t_counter:\n                result = sorted([x for x in s if x not in t] + [t], key=lambda x: (x, -len(x)), reverse=True)\n                break\n        \n        if result:\n            break\n    \n    return ''.join(result)\n\ns = input()\nt = input()\nprint(find_smallest_number(s, t))"}
{"solution": "def check_temperatures(n, m, min_temp, max_temp, temps):\n    if min(temps) < min_temp or max(temps) > max_temp:\n        return \"Incorrect\"\n    if n == m:\n        if min_temp != max_temp:\n            return \"Incorrect\"\n        else:\n            return \"Correct\"\n    if max(temps) < max_temp or min(temps) > min_temp:\n        return \"Correct\"\n    return \"Incorrect\"\n\n# Reading input\nn, m, min_temp, max_temp = map(int, input().split())\ntemps = list(map(int, input().split()))\n\n# Checking and printing output\nprint(check_temperatures(n, m, min_temp, max_temp, temps))"}
{"solution": "def find_n(m):\n    def count_trailing_zeros(n):\n        cnt = 0\n        while n % 10 == 0:\n            n //= 10\n            cnt += 1\n        return cnt\n\n    def find_factorial_trailing_zeros(m):\n        fact = 1\n        n = 1\n        while True:\n            fact *= n\n            if count_trailing_zeros(fact) > m:\n                break\n            n += 1\n        return n - 1\n\n    start = find_factorial_trailing_zeros(m)\n    if start == 0 or m == 1:\n        return 5 * (m != 0), [i for i in range(start + 1, start + 6)]\n    \n    end = find_factorial_trailing_zeros(m + 1)\n    return end - start, [i for i in range(start, end)]\n\nm = int(input())\nk, n_values = find_n(m)\nprint(k)\nprint(*n_values)"}
{"solution": "from heapq import heappush, heappop\nfrom collections import defaultdict\n\ndef dijkstra(graph, start):\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[start] = 0\n    heap = [(0, start)]\n    \n    while heap:\n        current_distance, current_vertex = heappop(heap)\n        \n        if current_distance > distances[current_vertex]:\n            continue\n        \n        for neighbor, weight in graph[current_vertex].items():\n            distance = max(current_distance, weight)\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heappush(heap, (distance, neighbor))\n    \n    return distances\n\ndef solve():\n    n, m, k = map(int, input().split())\n    special_vertices = list(map(int, input().split()))\n    \n    graph = defaultdict(dict)\n    for _ in range(m):\n        u, v, w = map(int, input().split())\n        graph[u][v] = w\n        graph[v][u] = w\n    \n    all_distances = {vertex: dijkstra(graph, vertex) for vertex in special_vertices}\n    \n    result = []\n    for vertex in special_vertices:\n        max_distance = max((all_distances[vertex][other] for other in special_vertices if other != vertex), default=0)\n        result.append(max_distance)\n    \n    print(*result)\n\nsolve()"}
{"solution": "def find_initial_position(moves, final_shell):\n    # Determine the effect of an even or odd number of moves on the shell positions\n    if moves % 2 == 0:\n        # For even number of moves, the positions transform as follows:\n        if final_shell == 0: initial = 1\n        elif final_shell == 1: initial = 0\n        else: initial = 1\n    else:\n        # For odd number of moves, the positions transform differently:\n        if final_shell == 0: initial = 2\n        elif final_shell == 1: initial = 1\n        else: initial = 0\n\n    return initial\n\n# Read inputs\nn = int(input())\nx = int(input())\n\n# Calculate and print the initial position\nprint(find_initial_position(n, x))"}
{"solution": "def check_square(rectangles):\n    import collections\n    \n    Point = collections.namedtuple('Point', ['x', 'y'])\n    \n    def is_square(points):\n        if len(points) != 4:\n            return False\n        \n        def distance(p1, p2):\n            return ((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2) ** 0.5\n        \n        distances = [distance(points[i], points[(i + 1) % 4]) for i in range(4)]\n        diagonal_distance = distance(points[0], points[2])\n        \n        return all(d == distances[0] for d in distances) and diagonal_distance == distances[0] * (2 ** 0.5)\n    \n    corners = []\n    for rect in rectangles:\n        corners.append(Point(rect[0], rect[1]))  # Bottom-left corner\n        corners.append(Point(rect[2], rect[3]))  # Top-right corner\n        corners.append(Point(rect[0], rect[3]))  # Top-left corner\n        corners.append(Point(rect[2], rect[1]))  # Bottom-right corner\n    \n    corner_counts = collections.Counter(corners)\n    \n    # Check if exactly 4 corners are present with the correct counts\n    if len(corner_counts) != 4 or any(count != 2 for count in corner_counts.values()):\n        return \"NO\"\n    \n    # Check if these 4 corners form a square\n    if is_square(list(corner_counts.keys())):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Reading input\nn = int(input())\nrectangles = [list(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(check_square(rectangles))"}
{"solution": "def count_really_big_numbers(n, s):\n    def count_digits(num):\n        return sum(int(digit) for digit in str(num))\n    \n    count = 0\n    for x in range(1, n + 1):\n        if x - count_digits(x) >= s:\n            count += 1\n    return count\n\n# Reading input\nn, s = map(int, input().split())\n\n# Processing and printing output\nprint(count_really_big_numbers(n, s))"}
{"solution": "from collections import defaultdict\ndef check(slope1, slope2):\n    if slope1 == slope2:\n        return False\n    if slope1[0] * slope2[1] == slope1[1] * slope2[0]:\n        return True\n    return False\ndef solve():\n    n = int(input())\n    points = []\n    slopes = defaultdict(int)\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n        if x == 0 or y == 0:\n            if x == 0:\n                slopes[(10**9 + 7, 1)] += 1\n            elif y == 0:\n                slopes[(1, 10**9 + 7)] += 1\n        else:\n            gcd = abs(x * y) // math.gcd(abs(x), abs(y))\n            slopes[(y // abs(y) * (gcd // abs(x)), x // abs(x) * (gcd // abs(y)))] += 1\n    if max(slopes.values()) >= n - 1:\n        print(\"YES\")\n        return\n    for slope1 in slopes:\n        for slope2 in slopes:\n            if check(slope1, slope2):\n                if slopes[slope1] + slopes[slope2] >= n:\n                    print(\"YES\")\n                    return\n    print(\"NO\")\nsolve()"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(a, b, k, t):\n    dp = [[0] * (2 * k + 1) for _ in range(t + 1)]\n    mid = k\n    dp[0][mid] = 1\n\n    for turn in range(1, t + 1):\n        new_dp = [0] * (2 * k + 1)\n        for diff in range(2 * k + 1):\n            for x in range(-k, k + 1):\n                prev_diff = diff - x\n                if 0 <= prev_diff < 2 * k + 1:\n                    new_dp[diff] += dp[turn - 1][prev_diff]\n                    new_dp[diff] %= MOD\n        dp[turn] = new_dp\n\n    result = 0\n    for diff in range(mid + 1, 2 * k + 1):\n        result += dp[t][diff] * pow(2 * k + 1, t, MOD)\n        result %= MOD\n\n    return (result * pow(pow(2 * k + 1, t, MOD), MOD - 2, MOD)) % MOD\n\na, b, k, t = map(int, input().split())\nprint(solve(a, b, k, t))"}
{"solution": "def min_marks(n, l, x, y, marks):\n    def find_mark(distance):\n        lo, hi = 0, n\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if marks[mid] == distance:\n                return True\n            elif marks[mid] < distance:\n                lo = mid + 1\n            else:\n                hi = mid\n        return False\n\n    missing_x = x not in marks[1:-1]\n    missing_y = y not in marks[1:-1]\n\n    if missing_x and missing_y:\n        result = [x, y]\n        if x > marks[-2]:\n            result.remove(x)\n        if y > marks[-2]:\n            result.remove(y)\n        if x not in result:\n            result.append(x)\n        if y not in result:\n            result.append(y)\n        return [2], result\n    elif missing_x:\n        return [1], [x]\n    elif missing_y:\n        return [1], [y]\n    else:\n        return [0], []\n\ndef main():\n    n, l, x, y = map(int, input().split())\n    marks = list(map(int, input().split()))\n    count, positions = min_marks(n, l, x, y, marks)\n    print(count)\n    print(*positions)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef cake_volume(radius, height):\n    return math.pi * radius**2 * height\n\ndef max_cake_volume(n, cakes):\n    volumes = [cake_volume(r, h) for r, h in cakes]\n    dp = [0] * n\n    result = 0\n\n    for i in range(n):\n        dp[i] = volumes[i]\n        for j in range(i):\n            if volumes[i] > volumes[j] and dp[i] < dp[j] + volumes[i]:\n                dp[i] = dp[j] + volumes[i]\n        if result < dp[i]:\n            result = dp[i]\n\n    return result\n\nif __name__ == \"__main__\":\n    n = int(input())\n    cakes = [tuple(map(int, input().split())) for _ in range(n)]\n    print(max_cake_volume(n, cakes))"}
{"solution": "def min_good_slices(n, k, heights):\n    \"\"\"\n    Calculate the minimum number of good slices to make all towers have the same height.\n    \"\"\"\n    def is_possible(cuts):\n        total_cubes = sum(min(h, heights[i]) for i, h in enumerate(cuts))\n        return total_cubes <= k + cuts.count(0)\n\n    min_height, max_height = 0, max(heights)\n    result = max_height\n\n    while min_height <= max_height:\n        mid = (min_height + max_height) // 2\n        if is_possible([mid] * n):\n            result = mid\n            max_height = mid - 1\n        else:\n            min_height = mid + 1\n\n    # Count the number of actual cuts needed\n    cuts_needed = 0\n    target_height = result\n    for height in heights:\n        if height > target_height:\n            cuts_needed += (height - target_height) // (target_height + 1 - (result - 1))\n\n    return cuts_needed\n\n# Example check (This part should not be included in the generated code)\nif __name__ == \"__main__\":\n    print(min_good_slices(5, 5, [3, 1, 2, 2, 4]))  # Output: 2\n    print(min_good_slices(4, 5, [2, 3, 4, 5]))     # Output: 2"}
{"solution": "def max_game_score(n, cards):\n    prefix_sum = [0]\n    for card in cards:\n        prefix_sum.append(prefix_sum[-1] + card)\n\n    max_score = 0\n    left_exclusion_sum = 0\n    for i in range(1, n + 1):\n        # Calculate the sum excluding the current element (i)\n        right_exclusion_sum = prefix_sum[-1] - prefix_sum[i]\n        # Score when excluding the current element\n        score = right_exclusion_sum + left_exclusion_sum\n        max_score = max(max_score, score)\n        # Update left_exclusion_sum for the next iteration\n        left_exclusion_sum = prefix_sum[i] - prefix_sum[0]\n\n    return max_score\n\n# Example usage\nn = int(input())\ncards = list(map(int, input().split()))\nprint(max_game_score(n, cards))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(k1, k2, k3):\n    lcm12 = lcm(k1, k2)\n    lcm13 = lcm(k1, k3)\n    lcm23 = lcm(k2, k3)\n    lcm123 = lcm(lcm12, k3)\n\n    # Check if there's any moment where all are off\n    if lcm123 == lcm12 or lcm123 == lcm13 or lcm123 == lcm23:\n        return \"NO\"\n    else:\n        return \"YES\"\n\n# Read input\nk1, k2, k3 = map(int, input().split())\nprint(solve(k1, k2, k3))"}
{"solution": "def min_operations_to_delete(s):\n    n = len(s)\n    dp = [1] * n  # Initialize DP array with 1s, as each character is a single group by itself\n    \n    for i in range(n - 2, -1, -1):\n        if s[i] == s[i + 1]:\n            dp[i] = dp[i + 1]\n        else:\n            dp[i] = 1 + dp[i + 1]\n    \n    return dp[0]\n\n# Read input\nn = int(input())\ns = input()\n\n# Calculate and print result\nprint(min_operations_to_delete(s))"}
{"solution": "def max_dance_pairs():\n    \"\"\"This function reads the number of boys and their dancing skills, then the number of girls and their dancing skills.\n    It returns the maximum number of pairs that can be formed such that the difference in dancing skills is at most 1.\"\"\"\n    import sys\n\n    input()  # Skip the number of boys\n    boys = sorted(map(int, input().split()))\n    input()  # Skip the number of girls\n    girls = sorted(map(int, input().split()))\n\n    boys_ptr, girls_ptr = 0, 0\n    pair_count = 0\n\n    while boys_ptr < len(boys) and girls_ptr < len(girls):\n        if abs(boys[boys_ptr] - girls[girls_ptr]) <= 1:\n            pair_count += 1\n            boys_ptr += 1\n            girls_ptr += 1\n        elif boys[boys_ptr] < girls[girls_ptr]:\n            boys_ptr += 1\n        else:\n            girls_ptr += 1\n\n    print(pair_count)\n\n# Call the function if this script is executed directly\nif __name__ == \"__main__\":\n    max_dance_pairs()"}
{"solution": "def team_victory(a, b, c, d):\n    # Checking if Team 1 can guarantee a win\n    if max(a[1], b[1]) > min(c[0], d[0]) and max(a[0], b[0]) > min(c[1], d[1]):\n        return \"Team 1\"\n    # Checking if Team 2 can guarantee a win\n    if max(c[1], d[1]) > min(a[0], b[0]) and max(c[0], d[0]) > min(a[1], b[1]):\n        return \"Team 2\"\n    # If neither team can guarantee a win\n    return \"Draw\"\n\n# Reading input\nplayers = [list(map(int, input().split())) for _ in range(4)]\n\n# Determining and printing the winner or declaring a draw\nprint(team_victory(*players))"}
{"solution": "import heapq\nimport math\nfrom typing import List\n\ndef solve_meat_grilling(N: int, K: int, meats: List[List[int]]) -> float:\n    def is_k_or_more_ready(t: float) -> bool:\n        # Find K closest points based on the distance * c_i\n        heap = []\n        for x, y, c in meats:\n            d = math.sqrt(x**2 + y**2)\n            if c * d <= t:\n                # If the time to cook is less than or equal to t,\n                # it's already cooked, so decrease the required time by c * d.\n                t -= c * d\n            else:\n                # Otherwise, push the point into the heap with adjusted distance.\n                heapq.heappush(heap, (c * d - t, c))\n        \n        # Try to add more points until we reach K.\n        while heap:\n            diff, c = heapq.heappop(heap)\n            if diff <= 0:\n                continue\n            if t / diff >= K:\n                return True\n            t -= diff\n            K -= 1\n        \n        return False\n    \n    # Binary search to find the minimum time.\n    left, right = 0.0, 1e9\n    while right - left > 1e-6:\n        mid = (left + right) / 2\n        if is_k_or_more_ready(mid):\n            right = mid\n        else:\n            left = mid\n    \n    return right\n\n# Reading input\nN, K = map(int, input().split())\nmeats = [list(map(int, input().split())) for _ in range(N)]\n\n# Calculating and printing the result\nprint(solve_meat_grilling(N, K, meats))"}
{"solution": "def main():\n    n = int(input())\n    ticket = input()\n    \n    left_sum, right_sum = 0, 0\n    left_q, right_q = 0, 0\n    \n    for i, char in enumerate(ticket):\n        if i < n // 2:\n            left_q += char == '?'\n            left_sum += 0 if char == '?' else int(char)\n        else:\n            right_q += char == '?'\n            right_sum += 0 if char == '?' else int(char)\n    \n    q_diff = abs(left_q - right_q)\n    sum_diff = abs(left_sum - right_sum)\n    \n    if sum_diff != 9 * (q_diff // 2) * (-1 if left_q > right_q else 1):\n        print(\"Monocarp\")\n    else:\n        print(\"Bicarp\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_bus_route(n, t, routes):\n    closest_time = float('inf')\n    closest_route = None\n\n    for i, (s, d) in enumerate(routes, start=1):\n        if s < t:\n            # Calculate the arrival time of the next bus\n            arrival_time = s + ((t - s) // d + (1 if (t - s) % d != 0 else 0)) * d\n        else:\n            arrival_time = s\n\n        if arrival_time < closest_time:\n            closest_time = arrival_time\n            closest_route = i\n\n    return closest_route\n\n# Reading input\nn, t = map(int, input().split())\nroutes = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Outputting the result\nprint(find_bus_route(n, t, routes))"}
{"solution": "def count_set_bits(n):\n    count = 0\n    while n:\n        n &= (n - 1)\n        count += 1\n    return count\n\ndef find_n(m, k):\n    low, high = 1, 10**18\n    while low <= high:\n        mid = (low + high) // 2\n        count = sum(1 for i in range(mid + 1, 2 * mid + 1) if count_set_bits(i) == k)\n        if count == m:\n            return mid\n        elif count < m:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\nm, k = map(int, input().split())\nprint(find_n(m, k))"}
{"solution": "def is_good_level(level_str):\n    n = len(level_str)\n    for d in range(1, n // 4 + 1):\n        for i in range(n - 4 * d + 1):\n            if (level_str[i] == '*' and level_str[i + d] == '*' and\n                    level_str[i + 2 * d] == '*' and level_str[i + 3 * d] == '*' and\n                    level_str[i + 4 * d] == '*'):\n                return \"yes\"\n    return \"no\"\n\n# Reading input\nn = int(input())\nlevel_scheme = input()\n\n# Printing output\nprint(is_good_level(level_scheme))"}
{"solution": "import numpy as np\n\ndef find_magic_square_value(n, grid):\n    grid = np.array(grid)\n    zero_pos = np.argwhere(grid == 0)[0]\n    \n    if zero_pos[0] == zero_pos[1]:  # Main diagonal\n        diag_sum = np.sum(grid[i, i] for i in range(n))\n        target_val = diag_sum - np.sum(grid[i, i] for i in range(n) if i != zero_pos[0])\n    elif zero_pos[0] + zero_pos[1] == n - 1:  # Secondary diagonal\n        diag_sum = np.sum(grid[i, n - 1 - i] for i in range(n))\n        target_val = diag_sum - np.sum(grid[i, n - 1 - i] for i in range(n) if i != zero_pos[0])\n    else:\n        row_sum = np.sum(grid[zero_pos[0]])\n        col_sum = np.sum(grid[:, zero_pos[1]])\n        \n        if np.sum(grid[0]) != col_sum or np.any(np.sum(grid, axis=1) != col_sum) or np.any(np.sum(grid, axis=0) != col_sum):\n            return -1\n        \n        if zero_pos[0] == 0:\n            target_val = col_sum - np.sum(grid[zero_pos[0], :zero_pos[1]] + grid[zero_pos[0], zero_pos[1]+1:])\n        elif zero_pos[1] == 0:\n            target_val = row_sum - np.sum(grid[zero_pos[0], :zero_pos[1]] + grid[zero_pos[0], zero_pos[1]+1:])\n        else:\n            target_val = row_sum - np.sum(grid[zero_pos[0], :zero_pos[1]] + grid[zero_pos[0], zero_pos[1]+1:])\n            if target_val != col_sum - np.sum(grid[:zero_pos[1], zero_pos[1]] + grid[zero_pos[1]+1:, zero_pos[1]]):\n                return -1\n    \n    if target_val > 0 and target_val <= 10**18:\n        return target_val\n    return -1\n\n# Example usage\nn = int(input().strip())\ngrid = [list(map(int, input().strip().split())) for _ in range(n)]\nprint(find_magic_square_value(n, grid))"}
{"solution": "def min_max_people(n, m, benches):\n    benches.sort()\n    \n    # Calculate minimum k\n    min_k = (m + n - 1) // n\n    extra = m % n\n    for i in range(extra):\n        benches[i] += 1\n    min_k = max(min_k, max(benches))\n    \n    # Calculate maximum k\n    max_k = benches[0] + m\n    \n    return min_k, max_k\n\n# Read input\nn = int(input())\nm = int(input())\nbenches = [int(input()) for _ in range(n)]\n\n# Compute and print result\nmin_k, max_k = min_max_people(n, m, benches)\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef calculate_ways(n, m):\n    if n < m:\n        return 0\n    ways = 1\n    for i in range(1, m + 1):\n        ways = (ways * pow(2, i, MOD) % MOD * pow(i, n - i, MOD) % MOD) % MOD\n    return ways\n\nn, m = map(int, input().split())\nprint(calculate_ways(n, m))"}
{"solution": "from itertools import combinations\n\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef read_list():\n    return list(map(int, input().split()))\n\ndef happy_friends(friends, pizza_comb):\n    happy = 0\n    pizza1, pizza2 = pizza_comb\n    for friend in friends:\n        if not (friend - pizza1 - pizza2):\n            happy += 1\n    return happy\n\ndef main():\n    n, m = read_ints()\n    friends = []\n    pizzas = []\n    \n    for _ in range(n):\n        _, *ingredients = read_list()\n        friends.append(set(ingredients))\n        \n    for _ in range(m):\n        cost, num_ingredients, *ingredients = read_list()\n        pizzas.append((cost, set(ingredients)))\n        \n    best_happy = 0\n    best_pair = None\n    best_cost = float('inf')\n    \n    for pizza1, pizza2 in combinations(pizzas, 2):\n        happy = happy_friends(friends, (pizza1[1], pizza2[1]))\n        if happy > best_happy or (happy == best_happy and pizza1[0] + pizza2[0] < best_cost):\n            best_happy = happy\n            best_pair = (pizza1, pizza2)\n            best_cost = pizza1[0] + pizza2[0]\n            \n    index1 = pizzas.index(best_pair[0]) + 1\n    index2 = pizzas.index(best_pair[1]) + 1\n    print(min(index1, index2), max(index1, index2))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_min_max_numbers(m, s):\n    \"\"\"\n    Finds the minimum and maximum numbers with length m and digit sum s.\n    \"\"\"\n    def build_min(s, m):\n        num = []\n        while s > 9:\n            num.append(9)\n            s -= 9\n            m -= 1\n        if m == 1:\n            if s > 0:\n                num.append(s)\n            else:\n                return -1\n        else:\n            num.append(s if s > 0 else 1)\n            s = 0\n            for _ in range(m - len(num) - 1):\n                num.append(0)\n            num.append(1 if s == 0 else s)\n        return int(\"\".join(map(str, reversed(num))))\n\n    def build_max(s, m):\n        num = []\n        while m > 0:\n            if s >= 9:\n                num.append(9)\n                s -= 9\n            else:\n                num.append(s)\n                s = 0\n            m -= 1\n        return int(\"\".join(map(str, num))) if s == 0 else -1\n\n    min_num = build_min(s, m)\n    max_num = build_max(s, m)\n    return min_num, max_num\n\n# Reading input\nm, s = map(int, input().split())\nmin_num, max_num = find_min_max_numbers(m, s)\nprint(min_num, max_num)"}
{"solution": "MOD = 998244353\n\ndef sum_of_numbers(l, r, k):\n    def count_digits(n):\n        return len(str(n))\n\n    def sum_of_range(a, b):\n        return (b * (b + 1) // 2) - (a * (a - 1) // 2)\n\n    def valid_numbers(n, k):\n        if k == 1:\n            total_sum = 0\n            for i in range(1, 10):\n                current_sum = 0\n                multiplier = 1\n                while n >= i * multiplier:\n                    current_sum += sum_of_range(i * multiplier, min((i+1) * multiplier - 1, n))\n                    multiplier *= 10\n                total_sum += current_sum\n                total_sum %= MOD\n            return total_sum\n        else:\n            total_sum = 0\n            multiplier = 1\n            for length in range(1, count_digits(n) + 1):\n                if length <= k:\n                    for i in range(1, 10):\n                        current_sum = 0\n                        for j in range(1, k + 1):\n                            current_sum += sum_of_range(i * multiplier, min((i+1) * multiplier - 1, n)) * (9 ** (j-1))\n                            current_sum %= MOD\n                        multiplier *= 10\n                        total_sum += current_sum\n                        total_sum %= MOD\n            return total_sum\n\n    # Calculate the sum of valid numbers up to r and subtract the sum of valid numbers up to l-1\n    sum_r = valid_numbers(r, k)\n    sum_l_minus_1 = valid_numbers(l-1, k)\n    result = (sum_r - sum_l_minus_1) % MOD\n    return result\n\n# Reading input\nl, r, k = map(int, input().split())\nprint(sum_of_numbers(l, r, k))"}
{"solution": "def can_distribute_pencils(n, k, d, pencils):\n    pencils.sort()\n    box_start = 0\n    for i in range(1, n):\n        if pencils[i] - pencils[box_start] > d or (i - box_start + 1) >= k:\n            box_start = i\n        if i == n - 1 and (i - box_start + 1) < k:\n            return \"NO\"\n    return \"YES\" if (n - box_start) % (k-1) == 0 else \"NO\"\n\n# Reading input\nn, k, d = map(int, input().split())\npencils = list(map(int, input().split()))\n\n# Printing output\nprint(can_distribute_pencils(n, k, d, pencils))"}
{"solution": "def count_dead_bulbs(garland_str):\n    colors = 'RGBY'\n    color_positions = {color: [] for color in colors}\n    \n    # Record positions of live bulbs\n    for idx, bulb in enumerate(garland_str):\n        if bulb in colors:\n            color_positions[bulb].append(idx)\n    \n    # Calculate dead bulbs for each color\n    dead_counts = {color: 0 for color in colors}\n    for color in colors:\n        for i, pos in enumerate(color_positions[color]):\n            before = garland_str[pos-3:pos]\n            after = garland_str[pos+1:pos+4]\n            segment = before + after\n            \n            for c in colors:\n                dead_counts[c] += segment.count('!')\n                \n            # Adjust for overcounting\n            for other_color in colors:\n                if other_color != color:\n                    other_positions = color_positions[other_color]\n                    if any(abs(pos - other) <= 3 for other in other_positions):\n                        dead_counts[other_color] -= 1\n                        \n    return [dead_counts[color] for color in 'RBYG']\n\n# Read input\ngarland_str = input().strip()\n\n# Calculate and print the result\nprint(*count_dead_bulbs(garland_str))"}
{"solution": "from collections import defaultdict, deque\nimport sys\ninput = sys.stdin.readline\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.graph = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    def bfs(self, start):\n        queue = deque([start])\n        dist = {start: 0}\n        order = []\n        while queue:\n            u = queue.popleft()\n            order.append(u)\n            for v in self.graph[u]:\n                if v not in dist:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return order, dist\n\ndef solve():\n    N, M = map(int, input().split())\n    g = Graph(N)\n    for _ in range(M):\n        u, v = map(int, input().split())\n        g.add_edge(u, v)\n    \n    _, dist = g.bfs(1)\n    max_dist_node = max(dist, key=dist.get)\n    _, reverse_order = g.bfs(max_dist_node)\n    \n    dp = [0] * (N + 1)\n    dp[N] = 0\n    for node in reverse_order[:-1][::-1]:\n        dp[node] = sum(dp[neighbor] + 1 for neighbor in g.graph[node]) / len(g.graph[node])\n    \n    min_expected_value = dp[1]\n    for u in g.graph[1]:\n        next_dp = dp[:]\n        next_dp[1] = sum(next_dp[v] + 1 for v in g.graph[1] if v != u) / (len(g.graph[1]) - 1)\n        min_expected_value = min(min_expected_value, next_dp[1])\n    \n    print(f\"{min_expected_value:.10f}\")\n\nsolve()"}
{"solution": "def round_to_nearest_ten(n):\n    last_digit = n % 10\n    if last_digit < 5:\n        return n - last_digit\n    else:\n        return n + (10 - last_digit)\n\nn = int(input())\nresult = round_to_nearest_ten(n)\nprint(result)"}
{"solution": "def solve(s, t):\n    if s == t:\n        return [0]\n\n    from collections import defaultdict\n    swaps = []\n    indexes = defaultdict(list)\n\n    for i, (char_s, char_t) in enumerate(zip(s, t)):\n        if char_s != char_t:\n            indexes[char_s].append(i)\n            indexes[char_t].append(i)\n\n    for char_s, char_t in zip(s, t):\n        if char_s != char_t:\n            if indexes[char_s][-1] == indexes[char_t][0]:\n                swaps.append([char_s, char_t])\n                del indexes[char_s][-1]\n                del indexes[char_t][0]\n            else:\n                return [-1]\n\n    return [len(swaps)] + swaps\n\ns = input().strip()\nt = input().strip()\n\nresult = solve(s, t)\nif result[0] == -1:\n    print(-1)\nelse:\n    print(result[0])\n    for r in result[1:]:\n        print(' '.join(r))"}
{"solution": "def earliest_login(first_name, last_name):\n    for i in range(1, len(first_name) + 1):\n        for j in range(1, len(last_name) + 1):\n            login = first_name[:i] + last_name[:j]\n            return login  # Returning the first possible login, which is also the earliest alphabetically\n    return \"\"  # Fallback, should not reach here if input constraints are met\n\n# Reading input\nfirst_name, last_name = input().split()\n\n# Processing and printing output\nprint(earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(sequence):\n    def draw_part(part, level=0):\n        if not part:\n            return [\"\"] * level\n        mid = len(part) // 2\n        left = draw_part(part[:mid], level + 1)\n        right = draw_part(part[mid + 1:], level + 1)\n        max_len = max(len(left), len(right))\n        top = ['+' + ('-' * (max_len * 2 - 1)) + '+' + ('-' * 2) + '+' + ('-' * (max_len * 2 - 1)) + '+']\n        combined = [l + '|' + r for l, r in zip(left, right)]\n        combined.extend(left[len(right):])\n        combined.extend(right[len(left):])\n        bottom = top[:]\n        return top + [('|' + s + '|') if s else ('|' + (' ' * (max_len * 2 + 3)) + '|') for s in combined] + bottom\n\n    parts = []\n    stack = []\n    for c in sequence:\n        if c == '[':\n            stack.append(c)\n        else:\n            parts.append(stack)\n            stack = []\n    if stack:\n        parts.append(stack)\n\n    result = draw_part(parts)\n    return '\\n'.join(' '.join(line.split()) for line in result)\n\nn = int(input())\nsequence = input()\nprint(draw_brackets(sequence))"}
{"solution": "from math import sqrt\n\nq = (1 + sqrt(5)) / 2\nq_map = {0: 0, 1: q}\n\ndef golden_to_decimal(golden_str):\n    global q_map\n    # Extend q_map dynamically if needed\n    if len(golden_str) > max(q_map.keys()):\n        for i in range(max(q_map.keys()) + 1, len(golden_str)):\n            q_map[i] = q_map[i-1] * q\n    return sum([q_map[len(golden_str) - i - 1] * int(digit) for i, digit in enumerate(golden_str)])\n\n# Reading inputs\nnum1 = input().strip()\nnum2 = input().strip()\n\n# Converting from golden to decimal\ndecimal_num1 = golden_to_decimal(num1)\ndecimal_num2 = golden_to_decimal(num2)\n\n# Comparing and printing result\nif decimal_num1 > decimal_num2:\n    print(\">\")\nelif decimal_num1 < decimal_num2:\n    print(\"<\")\nelse:\n    print(\"=\")"}
{"solution": "def find_absent_gems(colors_seen):\n    gem_colors = {\n        \"purple\": \"Power\",\n        \"green\": \"Time\",\n        \"blue\": \"Space\",\n        \"orange\": \"Soul\",\n        \"red\": \"Reality\",\n        \"yellow\": \"Mind\"\n    }\n\n    gems_present = set()\n    for color in colors_seen:\n        gems_present.add(gem_colors[color])\n\n    all_gems = set(gem_colors.values())\n    absent_gems = all_gems - gems_present\n\n    print(len(absent_gems))\n    for gem in absent_gems:\n        print(gem)\n\n# Example usage\nn = int(input())\ncolors_seen = [input() for _ in range(n)]\nfind_absent_gems(colors_seen)"}
{"solution": "def find_meeting_round(n, a, b):\n    while a != b:\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n //= 2\n        if n == 1 and a == b:\n            return \"Final!\"\n    return n\n\nn, a, b = map(int, input().split())\nprint(find_meeting_round(n, min(a, b), max(a, b)))"}
{"solution": "from collections import defaultdict\n\ndef find_cycle_length(n, p, b):\n    visited = [False] * (n + 1)\n    cycle_lengths = []\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            length = 0\n            j = i\n            while not visited[j]:\n                visited[j] = True\n                length += 1\n                j = p[j - 1]\n            cycle_lengths.append(length)\n    \n    changes_needed = 0\n    for length in cycle_lengths:\n        if length % 2 == 0:\n            changes_needed += 1\n    \n    return changes_needed\n\ndef main():\n    n = int(input())\n    p = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    # Adjust p to be 1-indexed\n    for i in range(n):\n        p[i] -= 1\n\n    # Find cycles and their lengths\n    visited = [False] * n\n    cycles = []\n    for i in range(n):\n        if not visited[i]:\n            cycle = []\n            current = i\n            while not visited[current]:\n                cycle.append(current)\n                visited[current] = True\n                current = p[current]\n            cycles.append(cycle)\n\n    # Determine if reversing is needed in cycles\n    cycle_reversals = [False] * len(cycles)\n    for idx, cycle in enumerate(cycles):\n        reversal_needed = False\n        for i in cycle:\n            if b[i] == 1:\n                reversal_needed = not reversal_needed\n        cycle_reversals[idx] = reversal_needed\n\n    # Calculate the number of changes needed\n    changes_needed = 0\n    for cycle in cycles:\n        if len(cycle) % 2 == 0:\n            changes_needed += 1\n\n    # Check if reversing adjustments are needed\n    for idx, cycle in enumerate(cycles):\n        if len(cycle) % 2 == 0 and cycle_reversals[idx]:\n            changes_needed -= 1\n        elif len(cycle) % 2 == 1 and not cycle_reversals[idx]:\n            changes_needed -= 1\n\n    print(changes_needed)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_distance(v1, v2, t, d):\n    speeds = [v1]\n    while len(speeds) < t:\n        if speeds[-1] <= v2:\n            new_speed = min(speeds[-1] + d, v2)\n        else:\n            new_speed = max(speeds[-1] - d, v2)\n        speeds.append(new_speed)\n\n    return sum(speeds)\n\n# Reading input\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Calculating and printing the result\nprint(max_distance(v1, v2, t, d))"}
{"solution": "from bisect import bisect_left\nfrom itertools import accumulate\n\ndef check(gaps, bridge_weights, camel_weights, d):\n    n = len(camel_weights)\n    m = len(bridge_weights)\n\n    # Add gaps at the start and end\n    gaps = [0] + gaps + [d]\n    \n    # Accumulated weights of camels\n    acc_weights = [0] + list(accumulate(camel_weights)) + [camel_weights[-1]]\n\n    # Calculate max allowed weight for each bridge segment\n    max_weights = [v - (w if i > 0 else 0) for i, (l, v, w) in enumerate(zip(bridge_lengths, bridge_weights, gaps[1:-1]))]\n\n    # Check each bridge segment\n    for i, (l, mw) in enumerate(zip(bridge_lengths, max_weights)):\n        # Determine start and end positions of camels that affect this bridge segment\n        start_pos = gaps.index(next(x for x in gaps if x >= l))\n        end_pos = n + 1 - gaps[::-1].index(next(x for x in reversed(gaps) if x >= d - l))\n\n        # Calculate max accumulated weight within the segment\n        max_acc_weight = max(acc_weights[start_pos:end_pos+1]) - acc_weights[start_pos-1]\n\n        if max_acc_weight > mw:\n            return False\n    \n    return True\n\n# Read inputs\nn, m = map(int, input().split())\ncamel_weights = list(map(int, input().split()))\nbridge_lengths = [0] * m\nbridge_weights = []\n\nfor _ in range(m):\n    l, v = map(int, input().split())\n    bridge_lengths[-1] += l\n    bridge_weights.append(v)\n\n# Sort camels by weight\nsorted_indices = sorted(range(n), key=lambda x: camel_weights[x])\ncamel_weights.sort()\n\n# Binary search for minimum gap\ngaps = [0] * (n - 1)\nlo, hi = 0, 10**9\n\nwhile lo < hi:\n    mid = (lo + hi) // 2\n    if check(gaps, bridge_weights, camel_weights, mid):\n        hi = mid\n    else:\n        lo = mid + 1\n\n# Check if solution is valid and print\nif check(gaps, bridge_weights, camel_weights, lo):\n    print(lo)\nelse:\n    print(-1)"}
{"solution": "from math import factorial\n\ndef last_digit_of_factorial_division(a, b):\n    \"\"\"\n    Calculate the last digit of the division of two factorials.\n    \"\"\"\n    if b >= 5 and a >= 5:\n        return 0\n\n    last_digit_a = 1 if a == 0 else factorial(a) % 10\n    last_digit_b = 1 if b == 0 else factorial(b) % 10\n\n    # Find the last digit of the division result\n    for i in range(a + 1, b + 1):\n        last_digit_a = (last_digit_a * (i % 10)) % 10\n\n    return last_digit_a\n\n# Reading input\na, b = map(int, input().split())\n\n# Output the last digit\nprint(last_digit_of_factorial_division(a, b))"}
{"solution": "def min_jumps(n, d, lily_pads):\n    jumps = [0] * n\n    queue = [0]\n\n    for position in queue:\n        for jump in range(1, d + 1):\n            next_position = position + jump\n            if next_position >= n:\n                break\n            if lily_pads[next_position] == '1' and jumps[next_position] == 0:\n                jumps[next_position] = jumps[position] + 1\n                queue.append(next_position)\n\n    return jumps[-1] if jumps[-1] > 0 else -1\n\nif __name__ == \"__main__\":\n    n, d = map(int, input().split())\n    lily_pads = input()\n    print(min_jumps(n, d, lily_pads))"}
{"solution": "def find_counterexample(n):\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\ndef is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num ** 0. 5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\nn = int(input())\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all(n):\n    if n < 1234:\n        return \"NO\"\n\n    for a in range(n // 1234567 + 1):\n        remaining_after_houses = n - a * 1234567\n        max_b = remaining_after_houses // 123456\n\n        for b in range(max_b + 1):\n            remaining_after_cars = remaining_after_houses - b * 123456\n            c = remaining_after_cars // 1234\n\n            if c * 1234 == remaining_after_cars and c >= 0:\n                return \"YES\"\n    return \"NO\"\n\nn = int(input())\nprint(can_spend_all(n))"}
{"solution": "from sys import stdin, stdout\nfrom math import gcd\n\ndef input(): return stdin.readline().strip()\ndef write(*args, sep=' '): stdout.write(sep. join(map(str, args)) + '\\n')\n\ndef solve():\n    n = int(input())\n    x1, x2 = map(int, input().split())\n    lines = []\n    for _ in range(n):\n        k, b = map(int, input().split())\n        lines.append((k, b))\n\n    lines.sort(key=lambda x: x[0])\n    events = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            k1, b1 = lines[i]\n            k2, b2 = lines[j]\n\n            if k1 == k2:\n                continue\n\n            x_intersect = (b2 - b1) / (k1 - k2)\n\n            if x1 < x_intersect < x2:\n                events.append(x_intersect)\n\n    if events:\n        write(\"YES\")\n    else:\n        write(\"NO\")\n\nif __name__ == '__main__':\n    solve()"}
{"solution": "def count_possible_weights(n):\n    return min(n, (1 + 8 * n) ** 0.5 // 2)\n\n# Reading an integer from the input\nn = int(input())\n\n# Printing the result\nprint(int(count_possible_weights(n)))"}
{"solution": "def find_good_apartments(n, k):\n    if k == 0:\n        min_good = 0\n        max_good = 0\n    else:\n        min_good = (k - 1)\n        max_good = n - k\n\n    if k >= n - 1:\n        min_good = n - k\n        max_good = n - 1\n\n    print(min_good, max_good)\n\nn, k = map(int, input().split())\nfind_good_apartments(n, k)"}
{"solution": "def max_games(winner):\n    games_played = 0\n    while winner > 1:\n        if winner % 2 == 0:\n            games_played += winner // 2\n            winner = winner // 2\n        else:\n            games_played += (winner - 1) // 2\n            winner = (winner - 1) // 2 + 1\n    return games_played\n\nn = int(input())\nprint(max_games(n))"}
{"solution": "def max_vk_occurrences(s):\n    n = len(s)\n    vk_count = 0\n    v_count = 0\n    k_after_v = 0\n\n    for i in range(n):\n        if s[i] == 'V':\n            v_count += 1\n            k_after_v = 0\n        elif s[i] == 'K' and v_count > 0:\n            vk_count += 1\n            v_count -= 1\n        else:\n            k_after_v = 1 if v_count > 0 else 0\n\n    possible_extra = min(v_count, 1) + k_after_v\n\n    return vk_count + possible_extra\n\n# Read input\ns = input().strip()\n\n# Calculate and print the result\nprint(max_vk_occurrences(s))"}
{"solution": "def min_segments(n):\n    return 2 * ((n // 2) + (n % 2))\n\n# Reading input\nn = int(input())\n\n# Calculating and printing output\nprint(min_segments(n))"}
{"solution": "def bear_weights(a, b):\n    years = 0\n    while a <= b:\n        a *= 3\n        b *= 2\n        years += 1\n    return years\n\na, b = map(int, input().split())\nprint(bear_weights(a, b))"}
{"solution": "def calculate_visited_nodes(h, n):\n    total_visits = (1 << h) - 1\n    depth = 0\n    position = 0\n    index = 0\n    while (1 << depth) <= n:\n        index ^= 1\n        if ((n >> (h - depth - 1)) & 1) == index:\n            if (total_visits & 3) != 3 or total_visits < 7:\n                depth += 1\n                position ^= index\n            else:\n                depth -= 1\n                position ^= index\n                index ^= 1\n                total_visits -= 4\n        else:\n            if (total_visits & 1) == 1:\n                depth += 1\n                position ^= index\n            else:\n                depth -= 1\n                position ^= index\n                index ^= 1\n                total_visits -= 2\n        total_visits += 1\n    return total_visits - (1 << h)\n\n# Read inputs\nh, n = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_visited_nodes(h, n))"}
{"solution": "from math import sqrt\n\ndef find_tables(x):\n    tables = []\n    for n in range(1, int(sqrt(2 * x)) + 1):\n        for m in range(n, int(sqrt(2 * x)) + 1):\n            total_squares = sum(min(n, m - i) for i in range(m))\n            if total_squares == x:\n                tables.append((n, m))\n    return tables\n\ndef main():\n    x = int(input())\n    tables = find_tables(x)\n    print(len(tables))\n    for n, m in sorted(tables, key=lambda pair: (pair[0], pair[1])):\n        print(n, m)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_leap(year):\n    return year % 400 == 0 or (year % 4 == 0 and year % 100 != 0)\n\ndef check_months(days):\n    feb_days = 29 if is_leap(2000) else 28\n    months = [31, feb_days, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    for i in range(12):\n        if all(months[(i + j) % 12] == d for j, d in enumerate(days)):\n            return True\n    return False\n\nn = int(input())\na = list(map(int, input().split()))\n\nprint(\"Yes\" if check_months(a) else \"No\")"}
{"solution": "from math import gcd\n\ndef find_sequence(n):\n    \"\"\"\n    Finds a sequence of fractions that sum up to 1 - 1/n.\n    \"\"\"\n    def decompose(target, divisors, used):\n        if target[0] == 0:\n            return []\n        for divisor in divisors:\n            if divisor in used:\n                continue\n            a, b = target\n            if b % divisor == 0:\n                new_a = a * (b // divisor)\n                new_b = b\n                if new_a < new_b:\n                    remaining = (new_a, new_b)\n                    used.add(divisor)\n                    subsequence = decompose((gcd(new_a, new_b) - new_a, new_b), divisors, used)\n                    if subsequence is not None:\n                        return [(new_a, new_b)] + subsequence\n                    used.remove(divisor)\n        return None\n\n    divisors = {d for d in range(2, n) if n % d == 0}\n    result = decompose((n-1, n), divisors, set())\n    if result is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(len(result))\n        for frac in result:\n            print(f\"{frac[0]} {frac[1]}\")\n\n# Example usage\nn = int(input().strip())\nfind_sequence(n)"}
{"solution": "import sys\n\ndef min_unattractiveness(n, limits, heights):\n    a, b = limits\n    dp = [[sys.maxsize] * 2 for _ in range(n + 1)]\n    dp[0][0], dp[0][1] = 0, 0\n    a_used, b_used = [0] * (n + 1), [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        for j in range(2):\n            color = j ^ 1\n            new_a_used = a_used[i - 1] + heights[i - 1] if color == 0 else a_used[i - 1]\n            new_b_used = b_used[i - 1] + heights[i - 1] if color == 1 else b_used[i - 1]\n            cost = dp[i - 1][j] + (1 if j else 0)\n\n            if color == 0 and new_a_used <= a:\n                dp[i][color] = min(dp[i][color], cost)\n                a_used[i] = new_a_used\n            elif color == 1 and new_b_used <= b:\n                dp[i][color] = min(dp[i][color], cost)\n                b_used[i] = new_b_used\n\n    min_cost = min(dp[n][0], dp[n][1])\n    return min_cost if min_cost != sys.maxsize else -1\n\n# Example usage\nn = int(input())\nlimits = list(map(int, input().split()))\nheights = list(map(int, input().split()))\nprint(min_unattractiveness(n, limits, heights))"}
{"solution": "from math import gcd\n\ndef solve(n, m, k):\n    area = n * m // k\n    if area * 2 > n * m:\n        return \"NO\"\n    \n    # Check if we can form a triangle with the given area\n    if n % 2 == 0 or m % 2 == 0 or area % 2 == 0:\n        if n >= 1 and m >= 2 * area:\n            return \"YES\", [(0, 0), (0, 2 * area), (1, m)]\n        elif m >= 1 and n >= 2 * area:\n            return \"YES\", [(0, 0), (2 * area, 0), (n, 1)]\n    else:\n        g = gcd(n, m)\n        if g >= 2 * area:\n            return \"YES\", [(0, 0), (g, 0), (0, g)]\n    \n    return \"NO\"\n\n# Reading input\nn, m, k = map(int, input().split())\n\nresult = solve(n, m, k)\nprint(result[0])\nif result[0] == \"YES\":\n    for point in result[1]:\n        print(*point)"}
{"solution": "def sasha_wins(n, k):\n    remaining_sticks = n\n    moves = 0\n    \n    while remaining_sticks >= k:\n        remaining_sticks -= k\n        moves += 1\n    \n    # Sasha wins if he makes more moves than Lena\n    return \"YES\" if moves % 2 == 1 else \"NO\"\n\n# Read input from stdin\nn, k = map(int, input().split())\n\n# Print the result to stdout\nprint(sasha_wins(n, k))"}
{"solution": "def main():\n    n = int(input())\n    exercises = list(map(int, input().split()))\n    \n    chest = biceps = back = 0\n    for i, e in enumerate(exercises):\n        if i % 3 == 0:\n            chest += e\n        elif i % 3 == 1:\n            biceps += e\n        else:\n            back += e\n    \n    if chest > biceps and chest > back:\n        print(\"chest\")\n    elif biceps > chest and biceps > back:\n        print(\"biceps\")\n    else:\n        print(\"back\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_redo_for_grade_five(n, grades):\n    \"\"\"\n    Calculate the minimum number of lab works Vasya needs to redo to get a grade of 5.\n    \"\"\"\n    total = sum(grades)\n    redo_count = 0\n    \n    # Try to increase the average to 5 by redoing the minimum number of lab works.\n    while True:\n        if (total + 5 * redo_count) // (n + redo_count) < 5:\n            redo_count += 1\n        else:\n            break\n    \n    return redo_count\n\n# Reading input\nn = int(input())\ngrades = list(map(int, input().split()))\n\n# Printing output\nprint(min_redo_for_grade_five(n, grades))"}
{"solution": "def solve(u, v):\n    if v < u:\n        return [-1]\n\n    if u == 0:\n        return [v] if v % 2 == 0 else [2, (v - 2) // 2, (v - 2) // 2]\n    \n    n = 1 + bin(u).count('1')\n    if v < 2 * u:\n        if v == u:\n            return [1, u]\n        elif v > u:\n            return [2, u, v - u]\n    else:\n        m = (v - u) // (n - 1)\n        r = (v - u) % (n - 1)\n        res = [m + (1 if i < r else 0) for i in range(n - 1)]\n        res.append(u + m * (n - 1) + r)\n        return [len(res)] + res\n\nimport sys\nu, v = map(int, input().split())\nresult = solve(u, v)\nprint(result[0])\nprint(' '.join(map(str, result[1:])))"}
{"solution": "def min_ones(n):\n    ones = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    for i in range(11, n + 1):\n        min_val = float('inf')\n        j = 1\n        while j <= len(str(i)) + 1 and j * 11 <= i:\n            min_val = min(min_val, ones[i - j * 11], min_val)\n            j *= 10\n        ones.append(min_val + 1)\n\n    return ones[n]\n\nn = int(input())\nprint(min_ones(n))"}
{"solution": "def can_reach_treasure(start, target, move_values):\n    dx = target[0] - start[0]\n    dy = target[1] - start[1]\n\n    gcd_val = gcd(move_values[0], move_values[1])\n\n    return (dx % gcd_val == 0) and (dy % gcd_val == 0)\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Read input\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\nstart_position = (x1, y1)\ntreasure_position = (x2, y2)\npotion_values = (x, y)\n\n# Check if Captain Bill the Hummingbird can reach the treasure\nif can_reach_treasure(start_position, treasure_position, potion_values):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "from collections import Counter\nfrom math import factorial\n\ndef find_permutations(counter):\n    total = factorial(sum(counter.values()))\n    for count in counter.values():\n        total //= factorial(count)\n    return total\n\ndef solve(n):\n    str_n = str(n)\n    digits = sorted(set(str_n))\n    total_count = 0\n\n    for d in digits:\n        if d == '0':\n            continue\n        modified_counter = Counter(str_n)\n        modified_counter[d] -= 1\n        if modified_counter[d] == 0:\n            del modified_counter[d]\n        total_count += find_permutations(modified_counter)\n\n    return total_count\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def max_suit_value():\n    a = int(input())  # Ties\n    b = int(input())  # Scarves\n    c = int(input())  # Vests\n    d = int(input())  # Jackets\n    e = int(input())  # Cost of suit type 1\n    f = int(input())  # Cost of suit type 2\n\n    # Calculate max suits for each type based on jackets available\n    max_type1 = min(a, d)\n    max_type2 = min(b, c, d)\n\n    if e >= f:\n        # Prioritize type 1 if it's equal or more valuable\n        value = max_type1 * e\n        remaining_jackets = d - max_type1\n        value += min(max_type2, remaining_jackets) * f\n    else:\n        # Prioritize type 2 if it's more valuable\n        value = max_type2 * f\n        remaining_jackets = d - max_type2\n        value += min(max_type1, remaining_jackets) * e\n\n    print(value)\n\nmax_suit_value()"}
{"solution": "from math import gcd\nfrom itertools import accumulate\n\ndef prepare_inverse(p):\n    \"\"\"\n    Precomputes modular inverses for numbers up to p-1 under modulo p.\n    \"\"\"\n    inv = [0] * p\n    inv[1] = 1\n    for i in range(2, p):\n        inv[i] = (-(p // i) * inv[p % i]) % p\n    return inv\n\ndef prepare_pow_mod(a, p):\n    \"\"\"\n    Precomputes powers of a modulo p.\n    \"\"\"\n    powers = [1]\n    val = a % p\n    while val != 1:\n        powers.append(val)\n        val = (val * a) % p\n    return powers\n\ndef solve(a, b, p, x):\n    \"\"\"\n    Solves the equation n * a^n \u2261 b (mod p) for 1 \u2264 n \u2264 x.\n    \"\"\"\n    if b == 0:\n        if a == 1:\n            return max(x - p + 1, 0)\n        else:\n            return 0\n    \n    order = p - 1\n    period = order\n    inv = prepare_inverse(p)\n    powers = prepare_pow_mod(a, p)\n    \n    # Find the smallest k such that a^k \u2261 b (mod p)\n    k = None\n    for i, power in enumerate(powers):\n        if power * inv[b] % p == 1:\n            k = i\n            break\n    if k is None:\n        return 0\n    \n    # Calculate the number of valid n values within the period\n    valid_in_period = sum(1 for n in range(1, period + 1) if (n * powers[n % len(powers)]) % p == b)\n    \n    # Total number of solutions, considering the full periods and the partial last period\n    full_periods = x // period\n    remainder = x % period\n    total_solutions = full_periods * valid_in_period + sum(1 for n in range(1, remainder + 1) if (n * powers[n % len(powers)]) % p == b)\n    \n    return total_solutions\n\n# Reading input\na, b, p, x = map(int, input().split())\n\n# Solve and print the result\nprint(solve(a, b, p, x))"}
{"solution": "def max_sum(k2, k3, k5, k6):\n    # Calculate the maximum number of '256' that can be formed\n    num_256 = min(k2, k5, k6)\n    \n    # Update counts after forming '256'\n    k2 -= num_256\n    k5 -= num_256\n    k6 -= num_256\n    \n    # Calculate the maximum number of '32' that can be formed with remaining digits\n    num_32 = min(k2, k3)\n    \n    # Calculate total sum\n    total_sum = num_256 * 256 + num_32 * 32\n    return total_sum\n\n# Read input\nk2, k3, k5, k6 = map(int, input().split())\n\n# Output result\nprint(max_sum(k2, k3, k5, k6))"}
{"solution": "def min_seconds(n, x, y, c):\n    if c == 1:\n        return 0\n    max_dist = max(abs(n - x) + abs(n - y), x + y - 1)\n    area = 1 + max_dist * 8\n    if c <= area:\n        return max_dist\n    additional_cells = c - area\n    full_squares = (additional_cells - 1) // (max_dist * 8 + 8) + 1\n    return max_dist + full_squares\n\nn, x, y, c = map(int, input().split())\nprint(min_seconds(n, x, y, c))"}
{"solution": "def solve(l, r):\n    if l == r:\n        return 0\n    else:\n        xor = l ^ r\n        while xor & (xor - 1) > 0:\n            xor &= xor - 1\n        return xor + ((r - l) & (r - l + 1))\n\nl, r = map(int, input().split())\nprint(solve(l, r))"}
{"solution": "import math\n\ndef min_height(n, k):\n    left, right = 0, int(1e18)\n    while left < right:\n        mid = (left + right) // 2\n        if sum(max(0, mid - i) for i in range(n + 1)) >= k:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef main():\n    n, k = map(int, input().split())\n    result = min_height(n, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    # Calculate time using stairs\n    stairs_time = abs(y - x) * t1\n    \n    # Calculate time using elevator\n    to_elevator_time = abs(z - x) * t2 + t3\n    travel_time = abs(y - z) * t2 + t3\n    elevator_time = to_elevator_time + travel_time\n    \n    return \"YES\" if elevator_time <= stairs_time else \"NO\"\n\n# Read input\nx, y, z, t1, t2, t3 = map(int, input().split())\n\n# Output result\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "def find_best_choice(n, m):\n    # Calculate the optimal choice for Andrew\n    if m == 1:\n        return 2\n    elif m == n:\n        return n - 1\n    else:\n        return m - 1\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the result\nprint(find_best_choice(n, m))"}
{"solution": "def calculate_university_time(lessons):\n    from itertools import groupby\n    \n    # Convert 0-1 list to 1-0 (present-absent) for easier calculation\n    adjusted_lessons = [0 if x == 1 else 1 for x in lessons]\n    \n    total_time_at_uni = 0\n    for k, g in groupby(adjusted_lessons):\n        count = len(list(g))\n        if k == 0:  # If present (class)\n            total_time_at_uni += count\n        elif count >= 2:  # If absent (break) and long enough to go home\n            total_time_at_uni += 1  # Time to get back to university\n    \n    # If last lesson is not present, subtract extra added unit\n    if adjusted_lessons[-1] == 1:\n        total_time_at_uni += 1\n    \n    return total_time_at_uni\n\n# Read input\nn = int(input())\nlessons = list(map(int, input().split()))\n\n# Calculate and print result\nprint(calculate_university_time(lessons))"}
{"solution": "def min_days_for_candies(n, k, candies):\n    total_given = 0\n    for day in range(n):\n        total_given += min(8, candies[day])\n        if total_given >= k:\n            return day + 1\n    return -1\n\ndef main():\n    n, k = map(int, input().split())\n    candies = list(map(int, input().split()))\n    print(min_days_for_candies(n, k, candies))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_additional_walks(n, k, walks):\n    additional_walks = 0\n    schedule = [0] * n\n    prev_adjusted = k\n    \n    for i, walk in enumerate(walks):\n        needed = max(prev_adjusted - walk, 0)\n        additional_walks += needed\n        schedule[i] = walk + needed\n        prev_adjusted = max(k - walk, 0) if schedule[i] == walk else 0\n        \n    # Adjust last day to ensure Cormen feels good the day after\n    if schedule[-1] < k:\n        additional_walks += k - schedule[-1]\n        schedule[-1] = k\n    \n    return additional_walks, schedule\n\n# Reading input\nn, k = map(int, input().split())\nwalks = list(map(int, input().split()))\n\n# Calculating result\nresult_walks, result_schedule = min_additional_walks(n, k, walks)\n\n# Printing output\nprint(result_walks)\nprint(' '.join(map(str, result_schedule)))"}
{"solution": "def rhombus_cells(n):\n    if n == 1:\n        return 1\n    else:\n        return 4 * n - 3 + rhombus_cells(n - 1)\n\n# Example usage:\n# Uncomment the following lines to test with example inputs\n# print(rhombus_cells(1)) # Output: 1\n# print(rhombus_cells(2)) # Output: 5\n# print(rhombus_cells(3)) # Output: 13\n\n# Read input and print output\nn = int(input())\nprint(rhombus_cells(n))"}
{"solution": "def check_pangram(length):\n    text = input().strip()\n    alphabet = set('abcdefghijklmnopqrstuvwxyz')\n    text_set = set(text.lower())\n    return \"YES\" if alphabet.issubset(text_set) else \"NO\"\n\nn = int(input())\nprint(check_pangram(n))"}
{"solution": "from datetime import datetime, timedelta\n\n# Read the current time and minutes to add\ncurrent_time_str = input().strip()\nminutes_to_add = int(input())\n\n# Convert the current time string to a datetime object\ncurrent_time = datetime.strptime(current_time_str, '%H:%M')\n\n# Add the specified number of minutes\nnew_time = current_time + timedelta(minutes=minutes_to_add)\n\n# Format and print the new time\nprint(new_time.strftime('%H:%M'))"}
{"solution": "from sys import stdin\nfrom itertools import accumulate\n\ndef main():\n    stdin.readline()\n    A = [tuple(map(int, list(stdin.readline().strip()))) for _ in range(2000)]\n    B = list(accumulate([set(i) for i in zip(*A)], set.union))\n    print(\"YES\" if any(B[-1] == B[i] | set(A[i]) for i in range(len(A))) else \"NO\")\n\nmain()"}
{"solution": "def min_time_to_even_sums(n, dominoes):\n    top_sum, bottom_sum = 0, 0\n    odd_top, odd_bottom = [], []\n    \n    for top, bottom in dominoes:\n        top_sum += top\n        bottom_sum += bottom\n        \n        if top % 2 == 1:\n            odd_top.append(bottom)\n        if bottom % 2 == 1:\n            odd_bottom.append(top)\n            \n    if (top_sum % 2 == 0 and bottom_sum % 2 == 0) or (n == 1 and (top_sum + bottom_sum) % 2 == 1):\n        return 0 if (top_sum + bottom_sum) % 2 == 0 else -1\n    \n    odd_top.sort()\n    odd_bottom.sort(reverse=True)\n    \n    flips = 0\n    while (top_sum + bottom_sum) % 2 != 0 or (top_sum % 2 != 0 and bottom_sum % 2 != 0):\n        if len(odd_top) == 0 or len(odd_bottom) == 0:\n            return -1\n        if top_sum % 2 != 0:\n            top_sum -= odd_top[0]\n            bottom_sum += odd_top[0]\n            flips += 1\n            del odd_top[0]\n        if bottom_sum % 2 != 0:\n            top_sum += odd_bottom[0]\n            bottom_sum -= odd_bottom[0]\n            flips += 1\n            del odd_bottom[0]\n            \n    return flips\n\n# Reading input\nn = int(input())\ndominoes = [list(map(int, input().split())) for _ in range(n)]\n\nprint(min_time_to_even_sums(n, dominoes))"}
{"solution": "from math import sqrt\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(sqrt(n)) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return False\n    return True\n\ndef remaining_area(a, b):\n    return a**2 - b**2\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        a, b = map(int, input().split())\n        area = remaining_area(a, b)\n        print(\"YES\" if is_prime(area) else \"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def check_points(n, points):\n    points.sort(key=lambda p: p[0])\n\n    for i in range(1, n):\n        if (points[i][0] * points[i - 1][0] > 0 and\n                points[i][1] * points[i - 1][1] >= 0):\n            return \"Yes\"\n    return \"No\"\n\nn = int(input())\npoints = [list(map(int, input().split())) for _ in range(n)]\nprint(check_points(n, points))"}
{"solution": "def gcd_factorials(A, B):\n    min_val = min(A, B)\n    result = 1\n    for i in range(2, min_val + 1):\n        result *= i\n    return result\n\n# Reading input\nA, B = map(int, input().split())\n\n# Calculating and printing output\nprint(gcd_factorials(A, B))"}
{"solution": "def find_composite_pair(n):\n    \"\"\"\n    Finds two composite integers a and b such that a - b = n.\n    \"\"\"\n    # Starting with the smallest even composite number\n    a = 4\n    b = a - n\n    \n    # Ensure b is positive and composite\n    while b < 2 or (b % 2 == 1 and b != 9) or b == 3:\n        a += 2\n        b = a - n\n    \n    print(a, b)\n\n# Note: The function should be called with an integer n as input in actual use\n# Example call: find_composite_pair(512)"}
{"solution": "from collections import defaultdict, deque\n\ndef solve():\n    N, M, P = map(int, input().split())\n    graph = defaultdict(list)\n    edges = []\n    for _ in range(M):\n        A, B, C = map(int, input().split())\n        graph[A-1].append(len(edges))\n        edges.append((B-1, C))\n\n    def bellman_ford(start):\n        dist = [float('inf')] * N\n        dist[start] = 0\n        negative_cycle = False\n        prev = None\n        for i in range(N+1):\n            updated = False\n            for u, (v, w) in enumerate(edges):\n                if dist[v] > dist[u] + w:\n                    dist[v] = dist[u] + w\n                    prev[v] = u\n                    updated = True\n                    if i == N:\n                        negative_cycle = True\n            if not updated:\n                break\n        return dist, negative_cycle, prev\n\n    def find_negative_cycle(start, prev):\n        cycle = [start]\n        at = start\n        while True:\n            at = prev[at]\n            if at in cycle:\n                cycle_index = cycle.index(at)\n                break\n            cycle.append(at)\n        return cycle[cycle_index:]\n\n    def find_max_coins_on_cycle(cycle):\n        max_coins = 0\n        time = 0\n        current_coins = 0\n        for node in cycle:\n            for _, (next_node, coins) in enumerate(edges):\n                if next_node == node:\n                    time += 1\n                    current_coins += coins\n                    fee = time * P\n                    if current_coins - fee > max_coins:\n                        max_coins = current_coins - fee\n        return max_coins\n\n    dist, negative_cycle, prev = bellman_ford(0)\n    if dist[N-1] == float('inf'):\n        print(-1)\n        return\n\n    if negative_cycle:\n        cycle = find_negative_cycle(N-1, prev)\n        max_coins = find_max_coins_on_cycle(cycle)\n        print(max_coins)\n    else:\n        max_coins = 0\n        time = dist[N-1]\n        for u, (v, w) in edges:\n            if v == N-1:\n                fee = time * P\n                if w - fee > max_coins:\n                    max_coins = w - fee\n        print(max_coins)\n\nsolve()"}
{"solution": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\ndef solve():\n    N = int(input())\n    strings = [input().split() for _ in range(N)]\n\n    costs = defaultdict(lambda: float('inf'))\n    center = float('inf')\n    for s, c in strings:\n        if s == s[::-1]:\n            center = min(center, int(c))\n        costs[s] = min(costs[s], int(c))\n        costs[s[::-1]] = min(costs[s[::-1]], int(c))\n\n    dp = {'' : 0}\n    for s, c in strings:\n        new_dp = dp.copy()\n        for palindrome, cost in dp.items():\n            ns = s + palindrome + s[::-1]\n            new_dp[ns] = min(new_dp.get(ns, float('inf')), cost + 2 * c)\n            if len(palindrome) % 2 == 1:\n                msp = palindrome[1:-1]\n                ns = s + palindrome[0] + msp + palindrome[-1] + s[::-1]\n                new_dp[ns] = min(new_dp.get(ns, float('inf')), cost + 2 * c + center)\n        dp = new_dp\n\n    ans = min(dp.values(), default=-1)\n    print(ans)\n\nsolve()"}
{"solution": "def max_xor_sum(n, k):\n    \"\"\"\n    Calculate the maximum xor-sum of k numbers from 1 to n.\n    \"\"\"\n    # If we can include all numbers, calculate xor-sum directly\n    if n.bit_count() >= k:\n        return n ^ ((1 << n.bit_length()) - 1) ^ ((1 << (n.bit_length() - 1)) - 1)\n    else:\n        return (1 << k) - 1\n\n# Read input\nn, k = map(int, input().split())\n\n# Output result\nprint(max_xor_sum(n, k))"}
{"solution": "def min_side_length(n, points):\n    max_x = max_y = 0\n    for x, y in points:\n        max_x = max(max_x, x)\n        max_y = max(max_y, y)\n    return min(max_x, max_y) * 2\n\n# Reading input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculating and printing output\nprint(min_side_length(n, points))"}
{"solution": "from collections import Counter\n\ndef max_nineteens(s):\n    count = Counter(s)\n    result = min(count['n'], count['i'] // 2, count['e'] // 2)\n    return result\n\n# Read input\ns = input()\n# Calculate and print the result\nprint(max_nineteens(s))"}
{"solution": "def find_highest_suitable_branch(p, y):\n    \"\"\"\n    Finds the highest branch that cannot be reached by any of the grasshoppers.\n    \n    :param p: int, the highest branch occupied by grasshoppers.\n    :param y: int, the total number of branches.\n    :return: int, the number of the highest suitable branch or -1 if there are none.\n    \"\"\"\n    if p == y:\n        return -1\n    \n    # Adjusting p to be the next branch after the last occupied one\n    p += 1\n    \n    # If p is within the range, it might be the answer\n    if p <= y:\n        return p\n    \n    # Check for the highest branch that is not a multiple of any branch from 2 to p\n    for i in range(2, int(y ** 0.5) + 2):\n        if p % i == 0:\n            while p % i == 0:\n                p //= i\n            if p > y:\n                return -1\n    \n    return p if p <= y else -1\n\n# Read input\np, y = map(int, input().split())\n\n# Compute and print the result\nprint(find_highest_suitable_branch(p, y))"}
{"solution": "def find_closest_house(n, m, k, prices):\n    # Filter houses that Zane can afford\n    affordable_houses = [i for i, price in enumerate(prices) if price > 0 and price <= k]\n\n    # Calculate distances from each affordable house to the girl's house\n    distances = [abs(i - (m - 1)) * 10 for i in affordable_houses]\n\n    # Return the minimum distance\n    return min(distances)\n\n# Reading input\nn, m, k = map(int, input().split())\nprices = list(map(int, input().split()))\n\n# Compute and print the result\nprint(find_closest_house(n, m, k, prices))"}
{"solution": "def can_transform(a, b):\n    n, m = len(a), len(a[0])\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] != b[j][i]:\n                return False\n    return True\n\ndef main():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    b = [list(map(int, input().split())) for _ in range(n)]\n\n    if a == b or can_transform(a, b):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def longest_uncommon_subsequence(a, b):\n    \"\"\"\n    Finds the length of the longest uncommon subsequence between two strings.\n    If there is no uncommon subsequence, returns -1.\n    \"\"\"\n    if a == b:\n        return -1\n    else:\n        return max(len(a), len(b))\n\n# Example usage\n# a = input().strip()\n# b = input().strip()\n# print(longest_uncommon_subsequence(a, b))"}
{"solution": "def find_scream_time(a, b, c, d):\n    \"\"\"\n    Finds the first time Rick and Morty will scream at the same time.\n    If they never scream at the same time, returns -1.\n    \"\"\"\n    if a == 0 and c == 0:\n        return b if b == d else -1\n    elif a == 0:\n        return d if (d - b) % c == 0 else -1\n    elif c == 0:\n        return b if (b - d) % a == 0 else -1\n    \n    lcm = a * c // math.gcd(a, c)\n    x = (d - b) % lcm\n    if x % c != 0:\n        return -1\n    t = (x // c) * c + b\n    return t if t >= b and t >= d else -1\n\nimport math\na, b = map(int, input().split())\nc, d = map(int, input().split())\nprint(find_scream_time(a, b, c, d))"}
{"solution": "def find_numbers(n):\n    if n % 3 == 0:\n        a = n // 3 - 1\n        b = n // 3 - 1\n        c = n // 3 + 2\n    elif n % 3 == 1:\n        a = n // 3 + 1\n        b = n // 3\n        c = n // 3\n    else:\n        a = n // 3\n        b = n // 3\n        c = n // 3 + 1\n    return a, b, c\n\nn = int(input())\na, b, c = find_numbers(n)\nprint(a, b, c)"}
{"solution": "def count_valid_squares(n, a, b, c, d):\n    \"\"\"\n    Counts the number of valid 3x3 squares given the constraints.\n    \"\"\"\n    valid_count = 0\n    for x1 in range(1, n + 1):\n        for x2 in range(1, n + 1):\n            s = 2 * (a + x1) - (b + c)\n            t = 2 * (a + x2) - (b + c)\n            if 1 <= s <= n and 1 <= t <= n:\n                y1 = 2 * (x1 + x2) - (a + d)\n                if 1 <= y1 <= n and y1 == s:\n                    y2 = 2 * (b + y1) - (x1 + d)\n                    if 1 <= y2 <= n and y2 == t:\n                        valid_count += 1\n    return valid_count\n\n# Read input\nn, a, b, c, d = map(int, input().split())\n\n# Output result\nprint(count_valid_squares(n, a, b, c, d))"}
{"solution": "def snowball_weight(w, h, stone1, stone2):\n    # Unpack stones\n    u1, d1 = stone1\n    u2, d2 = stone2\n\n    # Ensure d1 < d2 for processing\n    if d1 > d2:\n        u1, u2, d1, d2 = u2, u1, d2, d1\n\n    while h > 0:\n        w += h\n        h -= 1\n\n        if h == d1:\n            w = max(0, w - u1)\n        elif h == d2:\n            w = max(0, w - u2)\n\n    return w\n\n# Read input\nw, h = map(int, input().split())\nstone1 = list(map(int, input().split()))\nstone2 = list(map(int, input().split()))\n\n# Calculate and print result\nprint(snowball_weight(w, h, stone1, stone2))"}
{"solution": "def find_passing_rate():\n    m = int(input())\n    scores = list(map(int, input().split()))\n    x, y = map(int, input().split())\n\n    prefix_sum = [0]\n    for score in scores:\n        prefix_sum.append(prefix_sum[-1] + score)\n\n    for k in range(m, 0, -1):\n        beginners = prefix_sum[k]\n        intermediates = prefix_sum[m] - beginners\n        if x <= beginners <= y and x <= intermediates <= y:\n            return k\n    return 0\n\nprint(find_passing_rate())"}
{"solution": "def min_cost(n, k, A, B):\n    costs = [float('inf')] * (n + 1)\n    costs[1] = 0\n    operations = [None] * (n + 1)\n\n    for x in range(2, n + 1):\n        # Cost of subtracting 1 until reaching 1\n        cost_subtract = costs[x - 1] + A\n        costs[x] = cost_subtract\n\n        if x % k == 0:\n            # Calculate cost if we divide by k\n            cost_divide = costs[x // k] + B\n            if cost_divide < cost_subtract:\n                costs[x] = cost_divide\n                operations[x] = (x // k, 'divide')\n\n        # If no division, track subtraction\n        if operations[x] is None:\n            operations[x] = (x - 1, 'subtract')\n\n    return costs[n]\n\n# Read inputs\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\n# Calculate and print result\nprint(min_cost(n, k, A, B))"}
{"solution": "from math import sqrt\n\ndef min_value_and_operations(n):\n    factors = []\n    for i in range(2, int(sqrt(n)) + 1):\n        while n % (i * i) == 0:\n            factors.append(i)\n            n //= (i * i)\n    if n > 1:\n        factors.append(n)\n    \n    if not factors:\n        return (n, 0)\n    \n    min_val = min(factors)\n    operations = len(factors) + 1  # +1 for final sqrt operation\n    \n    return (min_val, operations)\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print result\nresult = min_value_and_operations(n)\nprint(*result)"}
{"solution": "import sys\ninput = sys.stdin.readline\n\ndef main():\n    N, K = map(int, input().split())\n    R, S, P = map(int, input().split())\n    T = input().rstrip()\n    \n    dp = [[0]*3 for _ in range(N+1)]\n    \n    for i in range(1, N+1):\n        if T[i-1] == 'r':\n            dp[i][0] = max(dp[i-1])\n            dp[i][1] = dp[i-1][1] + P if i-K <= 0 else max(dp[i-K][1], dp[i-K][2]) + P\n            dp[i][2] = dp[i-1][2] + S if i-K <= 0 else max(dp[i-K][0], dp[i-K][2]) + S\n        elif T[i-1] == 's':\n            dp[i][0] = dp[i-1][0] + R if i-K <= 0 else max(dp[i-K][0], dp[i-K][1]) + R\n            dp[i][1] = max(dp[i-1])\n            dp[i][2] = dp[i-1][2] + P if i-K <= 0 else max(dp[i-K][0], dp[i-K][1]) + P\n        else:\n            dp[i][0] = dp[i-1][0] + R if i-K <= 0 else max(dp[i-K][0], dp[i-K][2]) + R\n            dp[i][1] = dp[i-1][1] + P if i-K <= 0 else max(dp[i-K][0], dp[i-K][1]) + P\n            dp[i][2] = max(dp[i-1])\n            \n    print(max(dp[N]))\n    \nmain()"}
{"solution": "def max_good_string_length(a, b, c):\n    \"\"\"\n    Calculate the maximum length of a good string that can be formed.\n    \"\"\"\n    # Minimum of a and b ensures the base alternating pattern\n    min_ab = min(a, b)\n    # Length contributed by the minimum of a and b\n    length = 2 * min_ab\n    \n    # Excess of a or b after forming 'ab' pairs\n    excess = abs(a - b)\n    \n    # All 'ab' strings can be used\n    length += 2 * c\n    \n    # If there are 'ab' strings, we can use an extra 'a' or 'b' from the excess\n    if c > 0 and excess > 0:\n        length += 1\n    \n    # Add remaining excess to the length\n    length += min(1, excess)\n    \n    return length\n\n# Read input from stdin\na, b, c = map(int, input().split())\n\n# Output the result\nprint(max_good_string_length(a, b, c))"}
{"solution": "def find_marks(n, k, p, x, y, marks):\n    if k == 0:\n        if (n + 1) // 2 * y > x:\n            return [-1]\n        return [y] * ((n + 1) // 2) + [1] * (n - (n + 1) // 2)\n\n    current_sum = sum(marks)\n    needed_sum = x - current_sum\n\n    if (n - k) * p < needed_sum or (n + 1) // 2 - k + k - (marks[:k].count(y) + marks[:k].count(y - 1)) > (n - k):\n        return [-1]\n\n    result = []\n    low_marks_needed = max(0, (n + 1) // 2 - k - marks[:k].count(y) - marks[:k].count(y - 1))\n    high_marks_possible = min(n - k, max(0, (needed_sum - low_marks_needed * 1) // (n - k - low_marks_needed)))\n\n    for _ in range(max(0, n - k - low_marks_needed)):\n        result.append(min(p, high_marks_possible))\n\n    for _ in range(max(0, low_marks_needed)):\n        result.append(1)\n\n    return result\n\ndef main():\n    n, k, p, x, y = map(int, input().split())\n    marks = list(map(int, input().split()))\n    result = find_marks(n, k, p, x, y, marks)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_berlanese(word):\n    vowels = 'aouie'\n    prev_char = ''\n    for char in word:\n        if char not in vowels and prev_char != 'n':\n            return \"NO\"\n        prev_char = char\n    return \"YES\" if prev_char == 'n' or prev_char in vowels else \"NO\"\n\n# Read input\ns = input()\n# Print output\nprint(is_berlanese(s))"}
{"solution": "from collections import defaultdict\n\ndef read_ints():\n    return list(map(int, input().split()))\n\ndef max_dominoes(n, edges):\n    adj = defaultdict(set)\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n\n    def dfs(node, visited, component):\n        visited.add(node)\n        component.append(node)\n        for neighbor in adj[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, component)\n\n    components = []\n    visited = set()\n    for node in range(1, n + 1):\n        if node not in visited:\n            component = []\n            dfs(node, visited, component)\n            components.append(component)\n\n    result = 0\n    for component in components:\n        degree_counts = [0] * 7\n        for node in component:\n            degree_counts[len(adj[node])] += 1\n\n        min_degrees = min(len(component), 6)\n        for i in range(min_degrees, 0, -1):\n            count = degree_counts[i]\n            result += count // i * (i * (i - 1) // 2 + (i % 2) * (count // i % 2))\n            degree_counts[i] %= i\n            degree_counts[0] += count % i\n\n        result += degree_counts[2] // 2\n        result += sum((x * (x - 1) // 2 for x in degree_counts[3:]))\n    return result\n\nif __name__ == \"__main__\":\n    n, m = read_ints()\n    edges = [read_ints() for _ in range(m)]\n    print(max_dominoes(n, edges))"}
{"solution": "import heapq\n\ndef jeopardy_max_score(n, m, prices, auctions):\n    def max_points(prices, auctions, score=0, pos=0):\n        if pos == len(auctions):\n            return score\n        best = score\n        for i in range(len(prices)):\n            if prices[i] >= 0:\n                new_score = score\n                if i in auctions:\n                    new_score += prices[i]\n                    new_prices = list(prices)\n                    new_prices[i] = -1  # Mark as used\n                    for j in range(len(prices)):\n                        if new_prices[j] >= 0:\n                            new_val = min(new_scores[j], new_score)\n                            if new_prices[j] != new_val:\n                                new_prices[j] = new_val\n                                best = max(best, max_points(tuple(new_prices), auctions[pos + 1:], new_score, pos + 1))\n                else:\n                    new_score -= prices[i]\n                    best = max(best, max_points(tuple(prices), auctions, new_score, pos))\n                break  # Only consider the first choice for simplicity in this example\n        return best\n\n    prices = sorted(prices, reverse=True)\n    auctions = set(auctions)\n    return max_points(tuple(prices), auctions)\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    prices = list(map(int, input().split()))\n    auctions = set(map(int, input().split()))\n    print(jejeopardy_max_score(n, m, prices, auctions))"}
{"solution": "def calculate_score(m, w, hs, hu):\n    import math\n    scores = [500, 1000, 1500, 2000, 2500]\n    total_score = 0\n    for i in range(5):\n        score = max(0.3 * scores[i], (1 - m[i] / 250) * scores[i] - 50 * w[i])\n        total_score += int(score)\n    total_score += 100 * hs - 50 * hu\n    return total_score\n\nm = list(map(int, input().split()))\nw = list(map(int, input().split()))\nhs, hu = map(int, input().split())\n\nprint(calculate_score(m, w, hs, hu))"}
{"solution": "MOD = 998244353\n\ndef solve(n, m, L, R):\n    if (n * m) % 2 == 1:\n        return 0\n    total_cells = n * m\n    half_cells = total_cells // 2\n    valid_grids = pow(R - L + 1, half_cells, MOD)\n    return valid_grids\n\ndef main():\n    n, m, L, R = map(int, input().split())\n    result = solve(n, m, L, R)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n\n# This code snippet is designed to solve the problem as described without including any test cases within the code."}
{"solution": "def is_possible(n, m, a, b):\n    a_sorted = sorted(set(sum(a, [])))\n    b_sorted = sorted(set(sum(b, [])))\n\n    mapping = {}\n    for i in range(min(len(a_sorted), len(b_sorted))):\n        mapping[a_sorted[i]] = b_sorted[i]\n\n    def check(matrix, reverse_mapping):\n        for row in matrix:\n            for i in range(len(row) - 1):\n                if reverse_mapping[row[i]] >= reverse_mapping[row[i + 1]]:\n                    return False\n        for col in zip(*matrix):\n            for i in range(len(col) - 1):\n                if reverse_mapping[col[i]] >= reverse_mapping[col[i + 1]]:\n                    return False\n        return True\n\n    reverse_mapping = {v: k for k, v in mapping.items()}\n    reverse_mapping.update({k: k for k in set(sum(b, [])) - set(mapping.values())})\n\n    return \"Possible\" if check(a, mapping) and check(b, reverse_mapping) else \"Impossible\"\n\ndef main():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    b = [list(map(int, input().split())) for _ in range(n)]\n    print(is_possible(n, m, a, b))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_string_length(n, limits):\n    \"\"\"\n    Calculate the maximum possible length of a string with given constraints.\n    \"\"\"\n    limits.sort(reverse=True)\n    total_length = 0\n    available = n\n    \n    for limit in limits:\n        if limit > 0:\n            if limit > available:\n                if total_length + available * (available + 1) // 2 >= limit + total_length:\n                    for i in range(available, 0, -1):\n                        if limit > 0:\n                            total_length += i\n                            limit -= i\n                else:\n                    diff = (limit + total_length) - (total_length + available * (available + 1) // 2)\n                    available += 1\n                    total_length += diff\n                    for i in range(available, 0, -1):\n                        if limit > 0:\n                            total_length += i\n                            limit -= i\n            else:\n                total_length += sum(range(1, limit + 1))\n            available -= 1\n        else:\n            break\n    return total_length\n\n# Reading input\nn = int(input())\nlimits = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(max_string_length(n, limits))"}
{"solution": "def min_extra_problems(n, k, difficulties):\n    max_difficulty = max(difficulties)\n    steps = 0\n    current_max_difficulty = k\n    \n    while current_max_difficulty * 2 < max_difficulty:\n        current_max_difficulty *= 2\n        steps += 1\n    \n    for difficulty in sorted(difficulties):\n        if difficulty > k and difficulty // 2 > current_max_difficulty:\n            current_max_difficulty = difficulty\n        elif difficulty > current_max_difficulty * 2:\n            break\n    \n    return steps - (current_max_difficulty >= max_difficulty)\n\n# Read input\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_extra_problems(n, k, difficulties))"}
{"solution": "def distribute_diplomas(n, limits):\n    min_1, max_1 = limits[0]\n    min_2, max_2 = limits[1]\n    min_3, max_3 = limits[2]\n\n    # Maximize first degree diplomas\n    first_degree = min(n, max_1)\n    remaining = n - first_degree\n\n    # Ensure minimum requirements for second and third degree\n    if remaining < min_2 + min_3:\n        first_degree -= (min_2 + min_3) - remaining\n        remaining = n - first_degree\n\n    # Maximize second degree diplomas\n    second_degree = min(remaining, max_2)\n    remaining -= second_degree\n\n    # Remaining go to third degree\n    third_degree = remaining\n\n    # Adjust first and second degrees if needed\n    while first_degree > min_1 and second_degree < max_2 and remaining < min_3:\n        first_degree -= 1\n        second_degree += 1\n        remaining += 1\n\n    # Final adjustment for third degree\n    third_degree = remaining\n\n    return first_degree, second_degree, third_degree\n\n# Read input\nn = int(input())\nlimits = [tuple(map(int, input().split())) for _ in range(3)]\n\n# Output result\nprint(*distribute_diplomas(n, limits))"}
{"solution": "def moon_cycle Observation_days, observations):\n    cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n             14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    \n    possible_positions = cycle.index(observations[0])\n    \n    for i in range(1, Observation_days):\n        possible_positions = [pos for pos in possible_positions if cycle[pos + i] == observations[i]]\n        \n        if not possible_positions:\n            return -1\n    \n    if len(possible_positions) == 1:\n        next_day_index = possible_positions[0] + Observation_days\n        if cycle[next_day_index] < observations[-1]:\n            return \"DOWN\"\n        elif cycle[next_day_index] > observations[-1]:\n            return \"UP\"\n    \n    return -1\n\nObservation_days = int(input())\nobservations = list(map(int, input().split()))\n\nprint(moon_cycle(Observation_days, observations))"}
{"solution": "def can_transform(s, t):\n    vowels = set('aeiou')\n    if len(s) != len(t):\n        return \"No\"\n    for cs, ct in zip(s, t):\n        if (cs in vowels and ct not in vowels) or (cs not in vowels and ct in vowels):\n            return \"No\"\n    return \"Yes\"\n\ns = input().strip()\nt = input().strip()\nprint(can_transform(s, t))"}
{"solution": "def pawn_chess_winner(board):\n    min_white = 8\n    max_black = 1\n\n    for i, row in enumerate(board):\n        for j, cell in enumerate(row):\n            if cell == 'W':\n                min_white = min(min_white, i)\n            elif cell == 'B':\n                max_black = max(max_black, i)\n\n    return 'A' if min_white < max_black else 'B'\n\n# Read input\nboard = [input() for _ in range(8)]\n\n# Print output\nprint(pawn_chess_winner(board))"}
{"solution": "def find_max_length(n, a, m, b):\n    sa, sb = sum(a), sum(b)\n    if sa != sb: return -1\n    i, j, x, y = 0, 0, sa, sb\n    while i < n:\n        x -= a[i]\n        while j < m and x == y:\n            y -= b[j]\n            j += 1\n        if x == y: break\n        x += a[i]\n        i += 1\n        while i < n and a[i] == b[j - 1]:\n            x -= a[i]\n            i += 1\n    else: return -1\n    while i < n and j < m and a[i] == b[j]: i += 1; j += 1\n    return min(i, j) + max(n - i, m - j)\n\nn = int(input())\na = list(map(int, input().split()))\nm = int(input())\nb = list(map(int, input().split()))\nprint(find_max_length(n, a, m, b))"}
{"solution": "def check_friend_name(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    for friend in friends:\n        count = problem_name.count(friend)\n        if count == 1:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nproblem_name = input().strip()\n\n# Check and print result\nprint(check_friend_name(problem_name))"}
{"solution": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2 or n == 3:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(math.sqrt(n)) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef min_l(a, b, k):\n    primes = [i for i in range(a, b+1) if is_prime(i)]\n    if len(primes) < k:\n        return -1\n    l = 1\n    while True:\n        valid = True\n        for i in range(a, b-l+2):\n            segment_primes = [x for x in range(i, i+l) if is_prime(x)]\n            if len(segment_primes) < k:\n                valid = False\n                break\n        if valid:\n            return l\n        l += 1\n\na, b, k = map(int, input().split())\nprint(min_l(a, b, k))"}
{"solution": "from math import inf\n\ndef min_distance(a, h, w):\n    def find_min_x(m, n):\n        # Equation derived from the problem statement\n        return (m * n * a - min(m * h, n * w)) / (max(m, 1) + max(n, 1) - 1)\n\n    best = inf\n    for m in range(1, h // a + 2):\n        for n in range(1, w // a + 2):\n            if m * a <= h and n * a <= w:\n                best = min(best, find_min_x(m, n))\n    return -1 if best == inf else round(best, 6)\n\n# Example inputs\na, h, w = map(int, input().split())\nprint(min_distance(a, h, w))"}
{"solution": "def chapters_left():\n    n = int(input())\n    chapters = [list(map(int, input().split())) for _ in range(n)]\n    k = int(input())\n\n    unread_chapters = 0\n    for start, end in chapters:\n        if k > end:\n            continue\n        else:\n            unread_chapters += 1\n\n    print(unread_chapters)\n\nchapters_left()"}
{"solution": "def check_banner(banner):\n    target = \"CODEFORCES\"\n    i = 0\n    for char in banner:\n        if i < len(target) and char == target[i]:\n            i += 1\n        if i == len(target):\n            return \"YES\"\n    return \"NO\"\n\nbanner = input()\nprint(check_banner(banner))"}
{"solution": "def min_triangulation_weight(n):\n    \"\"\"\n    Calculate the minimum weight of triangulation of a regular polygon with n vertices.\n    \"\"\"\n    if n == 3:\n        return 6\n    dp = [[0] * n for _ in range(n)]\n    for gap in range(2, n):\n        for i in range(n - gap):\n            start, end = i + 1, (i + gap + 1) % n\n            dp[start][end] = float('inf')\n            for k in range(start, end):\n                weight = (start * k * end) + dp[start][k] + dp[k][end]\n                dp[start][end] = min(dp[start][end], weight)\n    return dp[1][0]\n\n# Function to read input and print output\ndef process_input_and_print_output():\n    n = int(input())\n    print(min_triangulation_weight(n))\n\nprocess_input_and_print_output()"}
{"solution": "def count_digits(n):\n    if n < 10:\n        return n\n    digits = 1\n    while 10 ** digits <= n:\n        digits += 1\n    return (n - 10 ** (digits - 1)) * digits + (10 ** (digits - 1) - 1) * (digits - 1)\n\nn = int(input())\nprint(count_digits(n))"}
{"solution": "def find_bob_winning_color(n, a, colors):\n    from collections import Counter\n    \n    alice_count = 0\n    max_diff = 0\n    color_counter = Counter()\n    \n    for color in colors:\n        if color == a:\n            alice_count += 1\n            max_diff += 1\n        else:\n            color_counter[color] += 1\n            max_diff = max(max_diff, alice_count - color_counter[color])\n    \n    for color, count in color_counter.items():\n        if count + max_diff >= alice_count:\n            return color\n    \n    return -1\n\n# Read input\nn, a = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Find and print the result\nresult = find_bob_winning_color(n, a, colors)\nprint(result)"}
{"solution": "def check_crossword(encoding, length):\n    if not encoding and length != 0:\n        return \"NO\"\n    if not encoding and length == 0:\n        return \"YES\"\n    current_position = 0\n    for segment in encoding:\n        current_position += segment + 1\n        if current_position > length:\n            return \"NO\"\n    if current_position - 1 != length:\n        return \"NO\"\n    return \"YES\"\n\nif __name__ == \"__main__\":\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(check_crossword(a, x))"}
{"solution": "import math\n\nn, S = map(int, input().split())\nprint(math.ceil(S / n))"}
{"solution": "from collections import Counter\n\ndef min_changes_palindrome(s):\n    letter_counts = Counter(s)\n    odd_count_letters = [ch for ch, count in letter_counts.items() if count % 2]\n    middle = ''\n    \n    if len(odd_count_letters) > 1:\n        middle = odd_count_letters[0]\n        letter_counts[middle] -= 1\n        if letter_counts[middle] == 0:\n            del letter_counts[middle]\n    \n    half_palindrome = ''.join([ch * (count // 2) for ch, count in sorted(letter_counts.items())])\n    return half_palindrome + middle + half_palindrome[::-1]\n\n# Read input\ns = input().strip()\n# Compute and print the result\nprint(min_changes_palindrome(s))"}
{"solution": "def chess_position_strength(board):\n    piece_weights = {'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n                     'q': -9, 'r': -5, 'b': -3, 'n': -3, 'p': -1}\n    strength = 0\n    for row in board:\n        for cell in row:\n            strength += piece_weights.get(cell, 0)\n    return strength\n\ndef evaluate_position(board):\n    strength = chess_position_strength(board)\n    if strength > 0:\n        return \"White\"\n    elif strength < 0:\n        return \"Black\"\n    else:\n        return \"Draw\"\n\n# Read input from stdin\nboard = [input() for _ in range(8)]\n\n# Output result to stdout\nprint(evaluate_position(board))"}
{"solution": "import sys\nfrom functools import lru_cache\n\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\nN, M = map(int, readline().split())\nS = readline().strip()\n\n@lru_cache(maxsize=None)\ndef ok(n):\n    if n == 0:\n        return 0\n    if S[n - 1] == \"1\":\n        return -float(\"inf\")\n    res = -float(\"inf\")\n    for m in range(1, min(M, n) + 1):\n        res = max(res, ok(n - m) + 10**9 * m + 1)\n    return res\n\nans = []\nif ok(N) < 0:\n    write(\"-1\")\nelse:\n    pos = N\n    while pos > 0:\n        best = -float(\"inf\")\n        best_move = None\n        for m in range(1, min(M, pos) + 1):\n            val = ok(pos - m) + 10**9 * m + 1\n            if val > best:\n                best = val\n                best_move = m\n        ans.append(best_move)\n        pos -= best_move\n    write(\" \".join(map(str, reversed(ans))))"}
{"solution": "from collections import deque, defaultdict\nimport math\n\ndef solve(K, X, Y):\n    if (abs(X) + abs(Y)) % K == 0:\n        return 1\n    if K % 2 == 0 and (abs(X) + abs(Y)) % 2 != 0:\n        return -1\n    if K % 2 != 0 and (abs(X) + abs(Y)) % 2 == 0 and (abs(X) + abs(Y)) < K:\n        return -1\n    steps = 0\n    x, y = X, Y\n    if K > abs(X) + abs(Y):\n        steps += 1\n        x, y = 0, 0\n    else:\n        while abs(x) + abs(y) > K:\n            sign_x = -1 if x > 0 else 1\n            sign_y = -1 if y > 0 else 1\n            dx = min(K, abs(x))\n            dy = min(K - abs(dx), abs(y))\n            x += sign_x * dx\n            y += sign_y * dy\n            steps += 1\n        if abs(x) + abs(y) == K:\n            steps += 1\n            x, y = 0, 0\n    if x != 0 or y != 0:\n        steps += 1\n    path = []\n    while (x, y) != (X, Y):\n        path.append((x, y))\n        if abs(x) + abs(y) == K:\n            x -= math.copysign(K, x)\n            y -= math.copysign(K, y)\n        else:\n            sign_x = 1 if x > 0 else -1\n            sign_y = 1 if y > 0 else -1\n            dx = min(K, abs(x))\n            dy = min(K - abs(dx), abs(y))\n            x += sign_x * dx\n            y += sign_y * dy\n    path.append((X, Y))\n    path.reverse()\n    return len(path) - 1, path[1:]\n\nK = int(input())\nX, Y = map(int, input().split())\n\nresult = solve(K, X, Y)\nif result == -1:\n    print(-1)\nelse:\n    steps, path = result\n    print(steps)\n    for x, y in path:\n        print(x, y)"}
{"solution": "from math import sqrt\n\ndef find_smallest_n(m):\n    \"\"\"\n    Finds the smallest possible value of n such that there are exactly m ways\n    the thieves could have taken the chocolates, given there are 4 thieves\n    and each thief takes k times more than the previous one.\n    Returns -1 if no such n exists.\n    \"\"\"\n    max_k = int(sqrt(sqrt(m))) + 1\n    for n in range(8, 10**15):\n        count = 0\n        for k in range(2, max_k):\n            total = 0\n            for _ in range(4):\n                total += 1\n                if total > n:\n                    break\n                total *= k\n            else:\n                if total <= n:\n                    count += 1\n        if count == m:\n            return n\n    return -1\n\n# Function to receive the input and call the above function\ndef solve():\n    m = int(input().strip())\n    print(find_smallest_n(m))\n\nsolve()"}
{"solution": "import math\n\ndef intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\n    if d >= r1 + r2:\n        return 0\n    elif d <= abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n    else:\n        phi1 = math.acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        phi2 = math.acos((r2 ** 2 + d ** 2 - r1 ** 2) / (2 * r2 * d))\n        A1 = phi1 * r1 ** 2 - r1 ** 2 * math.sin(2 * phi1) / 2\n        A2 = phi2 * r2 ** 2 - r2 ** 2 * math.sin(2 * phi2) / 2\n        return A1 + A2\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\nprint(intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "def min_value(n):\n    for x in range(2, int(n**0.5) + 1):\n        if n % x == 0:\n            div = x\n            while n % div == 0:\n                div *= x\n            n -= div - 1\n            return min_value(n)\n    return n\n\nv = int(input())\nprint(min_value(v))"}
{"solution": "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\ndef build_tree(n, edges):\n    tree = defaultdict(list)\n    for i, edge in enumerate(edges, start=2):\n        tree[edge].append(i)\n    return tree\n\ndef dfs(tree, values, node=1, depth=0):\n    value = values[node - 1]\n    children_value = 0\n    for child in tree[node]:\n        child_value, child_depth = dfs(tree, values, child, depth + 1)\n        value = max(value, child_value)\n        if child_depth % 2 == 1:\n            value += child_value\n            children_value += child_value\n    value = max(value, sum(values[child - 1] for child in tree[node]) - children_value)\n    return value, depth\n\nn = int(input())\nparents = list(map(int, input().split()))\nvalues = list(map(int, input().split()))\n\ntree = build_tree(n, parents)\nresult, _ = dfs(tree, values)\nprint(result)"}
{"solution": "def count_possible_words(n, s, t):\n    \"\"\"\n    Counts the number of possible words of length n+1 that can be transformed into both s and t by deleting exactly one character.\n    \"\"\"\n    start, end = 0, n - 1\n    while s[start] == t[start]:\n        start += 1\n    while s[end] == t[end]:\n        end -= 1\n\n    return 2 - (s[start+1:end+1] == t[start:end] or s[start:end] == t[start+1:end+1])\n\n# Reading input\nn = int(input())\ns = input()\nt = input()\n\n# Printing output\nprint(count_possible_words(n, s, t))"}
{"solution": "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\ndef dfs(v, p):\n    global ans\n    if ans < 0:\n        return\n    mx = -1\n    for u in g[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n        mx = max(mx, dp[u])\n    if mx >= 0:\n        dp[v] = a[v] + mx\n        ans = min(ans, dp[v])\n\nn = int(input())\na = list(map(int, input().split()))\ng = defaultdict(list)\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    g[u - 1].append(v - 1)\n    g[v - 1].append(u - 1)\n\ndp = [-1] * n\nans = max(a)\ndfs(0, -1)\nprint(ans)"}
{"solution": "def max_groups(n, m):\n    return min(n, m + 1)\n\nn, m = map(int, input().split())\nprint(max_groups(n, m))"}
{"solution": "def min_shovels(k, r):\n    n = 1\n    while (n * k) % 10 != r:\n        n += 1\n    return n\n\nk, r = map(int, input().split())\nprint(min_shovels(k, r))"}
{"solution": "def is_rectangle_possible(puzzle):\n    min_row, max_row, min_col, max_col = float('inf'), float('-inf'), float('inf'), float('-inf')\n    x_count = 0\n    \n    for i, row in enumerate(puzzle):\n        for j, cell in enumerate(row):\n            if cell == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n                x_count += 1\n                \n    width = max_row - min_row + 1\n    height = max_col - min_col + 1\n    \n    # Check if the number of X's is equal to the area of the bounding box\n    if x_count != width * height:\n        return False\n    \n    # Check if the puzzle fits within its bounding box\n    for i in range(min_row, max_row + 1):\n        for j in range(min_col, max_col + 1):\n            if puzzle[i][j] != 'X':\n                return False\n    \n    # Check if the puzzle forms a rectangle when two pieces are placed side by side\n    if width >= 2 and height >= 2:\n        return True\n    else:\n        return False\n\nn, m = map(int, input().split())\npuzzle = [input() for _ in range(n)]\n\nprint(\"YES\" if is_rectangle_possible(puzzle) else \"NO\")"}
{"solution": "# Importing necessary package for deep copy (if needed)\nfrom copy import deepcopy\n\ndef min_segments(x1, y1, x2, y2, x3, y3):\n    points = [(x1, y1), (x2, y2), (x3, y3)]\n    # Sort by x then y to get points in order\n    points.sort(key=lambda p: (p[0], p[1]))\n    \n    # Check if all have same x or y coordinate\n    same_x = points[0][0] == points[1][0] == points[2][0]\n    same_y = points[0][1] == points[1][1] == points[2][1]\n    \n    # If all x or all y are same, we need at least 2 segments\n    if same_x or same_y:\n        return 2\n    \n    # For other cases, check relative positions and calculate\n    if points[0][1] < points[1][1]:\n        if points[2][1] < points[1][1]:\n            return 2\n        else:\n            return 3 if points[0][0] < points[1][0] else 2\n    else:\n        if points[2][1] > points[1][1]:\n            return 2\n        else:\n            return 3 if points[0][0] > points[1][0] else 2\n\n# Directly using function arguments for simplicity\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\nprint(min_segments(x1, y1, x2, y2, x3, y3))"}
{"solution": "def print_graph(n, edges):\n    print(\"YES\")\n    print(n, len(edges))\n    for edge in edges:\n        print(edge[0], edge[1])\n\ndef build_k_regular_graph(k):\n    if k == 1:\n        print_graph(2, [(1, 2)])\n    elif k % 2 == 0:\n        print(\"NO\")\n    else:\n        n = k + 1\n        edges = []\n        # Create a cycle\n        for i in range(n - 1):\n            edges.append((i + 1, i + 2))\n        edges.append((n, 1))\n        # Add remaining edges to make it k-regular\n        for i in range(2, n):\n            for j in range(i + (k - 1) // 2 + 1, n + (k - 1) // 2 + 1):\n                edges.append((i, j % n + 1))\n        print_graph(n, edges)\n\ndef main():\n    k = int(input())\n    build_k_regular_graph(k)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def z_function(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            z[i] = min(r - i + 1, z[i - l])\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > r:\n            l, r = i, i + z[i] - 1\n    return z\n\ndef preprocess(s, t):\n    concatenated = t + '$' + s\n    z_values = z_function(concatenated)\n    n = len(s)\n    m = len(t)\n    occurrences = [0] * (n + 1)\n    for i, z in enumerate(z_values[m+1:], start=m+1):\n        if z == m:\n            occurrences[i - m] += 1\n        occurrences[i] -= 1\n    for i in range(1, n + 1):\n        occurrences[i] += occurrences[i - 1]\n    return occurrences\n\ndef solve():\n    n, m, q = map(int, input().split())\n    s = input()\n    t = input()\n    occurrences = preprocess(s, t)\n    \n    for _ in range(q):\n        l, r = map(int, input().split())\n        print(occurrences[r - 1] - occurrences[l - 1])\n\nsolve()"}
{"solution": "MOD = 10**9 + 7\n\ndef calculate_paths(n, k, d):\n    dp = [[0] * (n + 1) for _ in range(d + 1)]\n    for j in range(1, min(k + 1, n + 1)):\n        dp[1][j] = 1\n\n    for i in range(2, d + 1):\n        for j in range(1, n + 1):\n            for l in range(1, min(j, k) + 1):\n                dp[i][j] += dp[i - 1][j - l]\n                dp[i][j] %= MOD\n\n    result = 0\n    for j in range(d, n + 1):\n        for l in range(1, min(k + 1, n + 1)):\n            result += dp[d - 1][j - l]\n            result %= MOD\n\n    return result\n\nn, k, d = map(int, input().split())\nprint(calculate_paths(n, k, d))"}
{"solution": "def solve(row):\n    groups = []\n    count = 0\n    for i, cell in enumerate(row):\n        if cell == 'B':\n            count += 1\n        if cell == 'W' or i == len(row) - 1:\n            if count > 0:\n                groups.append(count)\n                count = 0\n    return groups\n\nn = int(input())\nrow = input()\n\ngroups = solve(row)\n\nprint(len(groups))\nif len(groups) > 0:\n    print(' '.join(map(str, groups)))\nelse:\n    print(0)"}
{"solution": "def process_operations(s, ops, cursor_pos):\n    stack = []\n    pairs = {}\n    \n    # Build pairs mapping\n    for i, ch in enumerate(s):\n        if ch == '(':\n            stack.append(i)\n        elif stack:\n            pairs[stack.pop()] = i\n            pairs[i] = stack[-1] if stack else None\n    \n    def move_cursor_left():\n        nonlocal cursor_pos\n        if cursor_pos > 0:\n            cursor_pos -= 1\n            while cursor_pos > 0 and s[cursor_pos] != '(' and s[cursor_pos] != ')':\n                cursor_pos -= 1\n    \n    def move_cursor_right():\n        nonlocal cursor_pos\n        if cursor_pos < len(s) - 1:\n            cursor_pos += 1\n            while cursor_pos < len(s) - 1 and s[cursor_pos] != '(' and s[cursor_pos] != ')':\n                cursor_pos += 1\n    \n    def delete():\n        nonlocal cursor_pos\n        if cursor_pos >= 0 and cursor_pos < len(s):\n            start = cursor_pos\n            end = pairs[start]\n            del_len = end - start + 1\n            s[start:end+1] = ''\n            cursor_pos += 1 if cursor_pos <= end else -1\n            while cursor_pos > 0 and cursor_pos < len(s) and s[cursor_pos] != '(' and s[cursor_pos] != ')':\n                cursor_pos += 1\n            update_pairs(start, del_len)\n    \n    def update_pairs(pos, del_len):\n        for k in pairs:\n            if pairs[k] >= pos:\n                pairs[k] -= del_len\n            if k >= pos:\n                pairs[k] -= del_len\n    \n    for op in ops:\n        if op == 'L':\n            move_cursor_left()\n        elif op == 'R':\n            move_cursor_right()\n        elif op == 'D':\n            delete()\n    \n    return ''.join(s)\n\nn, m, p = map(int, input().split())\ns = list(input())\nops = input()\n\nprint(process_operations(s, ops, p - 1))"}
{"solution": "def find_possible_y(questions):\n    lower, upper = -2e9, 2e9\n    for q in questions:\n        comp, x, ans = q\n        x = int(x)\n        if comp == '>':\n            if (ans == 'Y' and x >= upper) or (ans == 'N' and x > lower):\n                return 'Impossible'\n            if ans == 'Y': lower = max(lower, x + 1)\n        elif comp == '<':\n            if (ans == 'Y' and x <= lower) or (ans == 'N' and x < upper):\n                return 'Impossible'\n            if ans == 'Y': upper = min(upper, x - 1)\n        elif comp == '>=':\n            if (ans == 'Y' and x > upper) or (ans == 'N' and x >= lower):\n                return 'Impossible'\n            if ans == 'Y': lower = max(lower, x)\n        else: # comp == '<='\n            if (ans == 'Y' and x < lower) or (ans == 'N' and x <= upper):\n                return 'Impossible'\n            if ans == 'Y': upper = min(upper, x)\n    if lower <= upper: return int(lower)\n    return 'Impossible'\n\nif __name__ == \"__main__\":\n    n = int(input())\n    questions = [input().split() for _ in range(n)]\n    print(find_possible_y(questions))"}
{"solution": "from math import gcd\n\ndef number_of_periods(a, b):\n    return a + b - gcd(a, b)\n\na, b = map(int, input().split())\nprint(number_of_periods(a, b))"}
{"solution": "def find_names(n, k, notes):\n    names = [chr(65 + i % 26) for i in range(n)]\n    for i in range(n - k + 1):\n        if notes[i] == 'NO':\n            for j in range(k):\n                if names[i + j] == names[i + j + 1]:\n                    names[i + j] += 'a'\n                    break\n    return names\n\ndef main():\n    n, k = map(int, input().split())\n    notes = input().split()\n    names = find_names(n, k, notes)\n    print(\" \".join(names))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from math import inf\n\ndef min_operations_to_equal(a, b):\n    if a == b:\n        return 0\n\n    if a > b:\n        a, b = b, a\n\n    factors = [2, 3, 5]\n    operations = inf\n\n    for f in factors:\n        temp_a, temp_ops = a, 0\n        while temp_a < b:\n            if temp_a % f == 0:\n                temp_a += temp_a // f\n                temp_ops += 1\n            else:\n                break\n        if temp_a == b:\n            operations = min(operations, temp_ops)\n\n    return operations if operations != inf else -1\n\n# Read input\na, b = map(int, input().split())\nprint(min_operations_to_equal(a, b))"}
{"solution": "def min_cost_palindrome(n, a, b, c):\n    dp = [[float('inf')] * (1 << n) for _ in range(n)]\n    for mask in range(1 << n):\n        for j in range(n):\n            if mask & (1 << j):\n                symm_pos = n - 1 - j\n                symm_mask = 1 << symm_pos\n                if c[j] == c[symm_pos] or c[j] == 2 or c[symm_pos] == 2:\n                    prev_mask = mask ^ symm_mask ^ (1 << j)\n                    cost = 0\n                    if c[j] == 2:\n                        cost += a if c[symm_pos] == 0 else b\n                    elif c[symm_pos] == 2:\n                        cost += a if c[j] == 0 else b\n                    dp[j][mask] = min(dp[j][mask], dp[symm_pos][prev_mask] + cost)\n                else:\n                    dp[j][mask] = float('inf')\n    return dp[0][(1 << n) - 1] if dp[0][(1 << n) - 1] != float('inf') else -1\n\n# Reading input\nn, a, b = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculating and printing result\nprint(min_cost_palindrome(n, a, b, c))"}
{"solution": "def solve_cube(k):\n    if k == 1:\n        print(-1)\n        return\n\n    for z in range(k):\n        for y in range(k):\n            for x in range(k):\n                # Alternating pattern, but ensure each color has exactly 2 neighbors of its own color\n                if (x + y + z) % 2 == 0:\n                    print('b', end='')\n                else:\n                    print('w', end='')\n            print()\n        print()\n\nk = int(input().strip())\nsolve_cube(k)"}
{"solution": "import math\n\ndef largest_lovely_divisor(n):\n    max_lovely = 1\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % (i * i) == 0:\n            max_lovely = max(max_lovely, n // (i * i))\n    return max_lovely if max_lovely > 1 else n\n\nn = int(input())\nprint(largest_lovely_divisor(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    if n == 1:\n        return \"Yes\"\n    \n    prev = seating[0]\n    for i in range(1, n):\n        if seating[i] == '1':\n            if prev == '1' or (i != n-1 and seating[i+1] == '1'):\n                return \"No\"\n            if prev == '0' and i != n-1 and seating[i+1] == '0':\n                return \"No\"\n        prev = seating[i]\n    \n    return \"Yes\""}
{"solution": "def possible_k_values(n, a):\n    from math import gcd\n\n    # Calculate differences\n    diffs = [a[i] - a[i - 1] for i in range(1, len(a))]\n\n    possible_ks = set()\n\n    # Check each potential k\n    for k in range(1, n + 1):\n        valid = True\n        base_gcd = None\n        for i in range(k):\n            current_gcd = diffs[i]\n            for j in range(i + k, n, k):\n                current_gcd = gcd(current_gcd, diffs[j])\n            if base_gcd is None:\n                base_gcd = current_gcd\n            elif base_gcd != current_gcd:\n                valid = False\n                break\n        if valid:\n            possible_ks.add(k)\n\n    return sorted(list(possible_ks))\n\n# Reading input\nn = int(input())\na = list(map(int, input().split()))\n\n# Processing and printing output\nresult = possible_k_values(n, a)\nprint(len(result))\nprint(\" \".join(map(str, result)))"}
{"solution": "from itertools import combinations\n\ndef can_form_equal_teams(scores):\n    \"\"\"\n    Determines if it's possible to form two teams with equal scores from six given scores.\n    \n    :param scores: List of six integers representing the scores of participants.\n    :return: \"YES\" if it's possible to form two teams with equal scores, \"NO\" otherwise.\n    \"\"\"\n    total_sum = sum(scores)\n    if total_sum % 2 != 0:\n        return \"NO\"\n    \n    target = total_sum // 2\n    for team1 in combinations(scores, 3):\n        if sum(team1) == target:\n            return \"YES\"\n    return \"NO\"\n\n# Read input\nscores = list(map(int, input().split()))\n\n# Output result\nprint(can_form_equal_teams(scores))"}
{"solution": "import math\n\ndef is_2_3_integer(n):\n    if n == 1:\n        return True\n    while n % 2 == 0:\n        n //= 2\n    while n % 3 == 0:\n        n //= 3\n    return n == 1\n\ndef count_2_3_integers(l, r):\n    return sum(is_2_3_integer(i) for i in range(max(1, l), r + 1))\n\nif __name__ == \"__main__\":\n    l, r = map(int, input().split())\n    print(count_2_3_integers(l, r))"}
{"solution": "def candies_eaten(n, k):\n    if k == 0 and n == 1:\n        return 1\n    if k >= n * (n + 1) // 2:\n        return n - 1\n    min_ops = (-1 + (1 + 4 * (2 * k + 1)) ** 0.5) / 2\n    remaining_candies = k - (min_ops * (min_ops + 1)) // 2\n    return int(n - min_ops - remaining_candies)\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(candies_eaten(n, k))"}
{"solution": "def can_form_triangle(n, segments):\n    segments.sort()\n    for i in range(n - 2):\n        if segments[i] + segments[i + 1] > segments[i + 2]:\n            return \"YES\"\n    return \"NO\"\n\nn = int(input())\nsegments = list(map(int, input().split()))\nprint(can_form_triangle(n, segments))"}
{"solution": "def is_possible(x, y):\n    if y > x + 1:\n        return \"No\"\n    while x > 0 or y > 1:\n        if y >= 1 and y <= x + 1:\n            if x % 2 == 0 and y - 1 == x // 2:\n                return \"Yes\"\n            else:\n                return \"No\"\n        if x >= 2:\n            x -= 2\n            y += 1\n        elif y >= 1:\n            y -= 1\n            x += 1\n        else:\n            return \"No\"\n    return \"Yes\"\n\nx, y = map(int, input().split())\nprint(is_possible(x, y))"}
{"solution": "def max_rating(n, k, skills):\n    skills.sort(reverse=True)\n    total = sum(x // 10 for x in skills)\n    extra = sum(x % 10 for x in skills)\n    for i, skill in enumerate(skills):\n        needed = 10 - (skill % 10)\n        if k >= needed:\n            k -= needed\n            extra -= needed\n            total += 1\n        else:\n            extra += k\n            break\n    return total + extra // 10\n\n# Reading input\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Printing output\nprint(max_rating(n, k, skills))"}
{"solution": "def smallest_pretty_integer():\n    n, m = map(int, input().split())\n    a = set(map(int, input().split()))\n    b = set(map(int, input().split()))\n\n    # Try to find the smallest number with at least one digit from each set\n    for i in range(1, 10):\n        if i in a and i in b:\n            return i\n\n    # Construct the smallest number using digits from both sets\n    min_a = min(a)\n    min_b = min(b)\n\n    # Check if the minimum digit from one set is less than 10\n    if min_a < 10 and min_b < 10:\n        return str(min_a) + str(min_b)\n\n    # If no single-digit solution, try combinations\n    for i in a:\n        for j in b:\n            if i != j:\n                return int(str(i) + str(j))\n\n    # Fallback, should not reach here if input constraints are met\n    return 1\n\nprint(smallest_pretty_integer())"}
{"solution": "def contest_problems(n, k):\n    total_time = 240  # Total time from 20:00 to midnight\n    time_needed_for_travel = k\n    contest_time = total_time - time_needed_for_travel\n\n    total_time_to_solve = 0\n    problems_solved = 0\n\n    for i in range(1, n + 1):\n        time_to_solve_current = 5 * i\n        if total_time_to_solve + time_to_solve_current <= contest_time:\n            total_time_to_solve += time_to_solve_current\n            problems_solved += 1\n        else:\n            break\n\n    return problems_solved\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(contest_problems(n, k))"}
{"solution": "def max_teams(n, x, y, pages):\n    pages.sort()\n    for i in range(n):\n        if x * 2 + y < pages[i]:\n            return i\n        used_x = min(x, (pages[i] + 1) // 2)\n        x -= used_x\n        y -= pages[i] - 2 * used_x\n    return n\n\n# Reading input\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculating and printing the result\nprint(max_teams(n, x, y, a))"}
{"solution": "def solve(b):\n    import math\n    factors = []\n    while b % 2 == 0:\n        factors.append(2)\n        b //= 2\n    for i in range(3, int(math.sqrt(b)) + 1, 2):\n        while b % i == 0:\n            factors.append(i)\n            b //= i\n    if b > 2:\n        factors.append(b)\n    \n    distinct_values = set()\n    for factor in factors:\n        current_factor = factor\n        while current_factor <= 10**18:\n            distinct_values.add(current_factor)\n            current_factor *= factor\n    \n    return len(distinct_values) + 1 # +1 for the value 1 which is always present\n\nb = int(input())\nprint(solve(b))"}
{"solution": "def count_falling_positions(bumpers):\n    n = len(bumpers)\n    left_sequence = 0\n    right_sequence = 0\n    max_left_sequence = 0\n    max_right_sequence = 0\n    \n    # Counting the longest sequence of '<' from left to right\n    for bumper in bumpers:\n        if bumper == '<':\n            left_sequence += 1\n        else:\n            max_left_sequence = max(max_left_sequence, left_sequence)\n            left_sequence = 0\n            \n    max_left_sequence = max(max_left_sequence, left_sequence)\n    \n    # Counting the longest sequence of '>' from right to left\n    for bumper in reversed(bumpers):\n        if bumper == '>':\n            right_sequence += 1\n        else:\n            max_right_sequence = max(max_right_sequence, right_sequence)\n            right_sequence = 0\n            \n    max_right_sequence = max(max_right_sequence, right_sequence)\n    \n    # Calculating the number of positions from which the ball will fall\n    falling_positions = (n - max_left_sequence - max_right_sequence) if (max_left_sequence + max_right_sequence < n) else 0\n    \n    return falling_positions\n\n# Reading input\nn = int(input())\nbumpers = input()\n\n# Printing output\nprint(count_falling_positions(bumpers))"}
{"solution": "from collections import Counter\nimport sys\n\ninput = sys.stdin.readline\n\nn = int(input())\nstick_lengths = list(map(int, input().split()))\n\nstick_count = Counter(stick_lengths)\n\ntotal_area = 0\n\nfor length in sorted(stick_count):\n    while stick_count[length] >= 4:\n        total_area += length * length\n        stick_count[length] -= 4\n\n    if stick_count[length] >= 2 and stick_count.get(length - 1, 0) >= 2:\n        total_area += length * (length - 1)\n        stick_count[length] -= 2\n        stick_count[length - 1] -= 2\n\nprint(total_area)"}
{"solution": "from collections import defaultdict, Counter\nimport sys\n\ninput = sys.stdin.read\nreader = (s.split() for s in input().split('\\n'))\nir = iter(reader)\nnext(ir)\n\ndef decode(digits, mapping):\n    return int(''.join(str(mapping[d]) for d in digits))\n\ndef solve():\n    strings = [s for s in ir if s]\n    digit_counts = [Counter(s) for s in strings]\n\n    digit_groups = defaultdict(list)\n    for i, counts in enumerate(digit_counts):\n        for d, count in counts.items():\n            digit_groups[count].append((d, i))\n\n    mapping = {}\n    min_sum = float('inf')\n    \n    for perm in permutations('0123456789', len(digit_groups)):\n        for count, digits in digit_groups.items():\n            if len(digits) > 1 and '0' in perm[:count]:\n                break\n            for d, _ in digits:\n                mapping[d] = perm[count - 1]\n        else:\n            sum_ = sum(decode(s, mapping) for s in strings)\n            min_sum = min(min_sum, sum_)\n    \n    return min_sum\n\nprint(solve())"}
{"solution": "def max_teams(n, m):\n    min_teams = min(n, m//2)  # Maximum teams by A's method\n    remaining_newbies = m - 2 * min_teams\n    remaining_experienced = n - min_teams\n\n    extra_teams = 0\n    if remaining_newbies > 0:\n        extra_teams = min(remaining_newbies, remaining_experienced // 2)\n    \n    return min_teams + extra_teams\n\nn, m = map(int, input().split())\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    \"\"\"\n    Checks if the string s contains two non-overlapping substrings \"AB\" and \"BA\".\n    \"\"\"\n    ab_count = s.count(\"AB\")\n    ba_count = s.count(\"BA\")\n\n    # If both substrings exist and their total count is exactly 2, they are non-overlapping\n    has_ab = ab_count > 0\n    has_ba = ba_count > 0\n    non_overlapping = (ab_count + ba_count) == 2\n\n    return \"YES\" if has_ab and has_ba and non_overlapping else \"NO\"\n\n# Read input\ns = input().strip()\n\n# Output result\nprint(check_substrings(s))"}
{"solution": "def can_transform(initial, final):\n    stack = []\n    j = 0\n    n = len(final)\n    for weight in initial:\n        stack.append(weight)\n        while stack and j < n and stack[-1] <= final[j]:\n            stack.pop()\n            j += 1\n        if len(stack) >= 2 and stack[-2] > stack[-1] and j < n and stack[-1] == final[j]:\n            return \"NO\"\n    return \"YES\" if j == n else \"NO\"\n\ndef simulate_eating(initial, final):\n    result = can_transform(initial, final)\n    if result == \"NO\":\n        print(\"NO\")\n        return\n    print(\"YES\")\n    stack = []\n    j = 0\n    operations = []\n    for weight in initial:\n        stack.append(weight)\n        while stack and j < len(final) and stack[-1] <= final[j]:\n            if len(stack) >= 2 and stack[-2] > stack[-1]:\n                operations.append((len(stack) - 1, 'L'))\n            else:\n                operations.append((len(stack) - 1, 'R'))\n            stack.pop()\n            j += 1\n    for op in reversed(operations):\n        print(f\"{op[0]} {op[1]}\")\n\ndef main():\n    n = int(input())\n    initial = list(map(int, input().split()))\n    k = int(input())\n    final = list(map(int, input().split()))\n    simulate_eating(initial, final)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\nfrom typing import List, Tuple\n\nPoint = Tuple[int, int]\n\ndef cross_product(o: Point, a: Point, b: Point) -> int:\n    \"\"\"\n    Returns the cross product of vectors OA and OB.\n    Positive if OAB makes a counter-clockwise turn,\n    negative for a clockwise turn, and zero if the points are collinear.\n    \"\"\"\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef can_connect_without_crossing(points: List[Point], matches: List[int]) -> bool:\n    n = len(points)\n    for i in range(n):\n        for k in range(i + 1, n):\n            if cross_product(points[i], points[matches[i]], points[matches[k]]) > 0:\n                return False\n    return True\n\ndef find_matching(rebels: List[Point], bases: List[Point]) -> str:\n    def dfs(u, match, visited):\n        for v in range(len(bases)):\n            if not visited[v] and rebels[u] < bases[v]:\n                visited[v] = True\n                if match[v] == -1 or dfs(match[v], match, visited):\n                    match[v] = u\n                    return True\n        return False\n\n    rebels.sort()\n    bases.sort()\n    match = [-1] * len(bases)\n    for u in range(len(rebels)):\n        visited = [False] * len(bases)\n        if not dfs(u, match, visited):\n            return \"No\"\n    \n    # Reconstruct the matches from the 'match' array to check for crossing\n    rebels_bases_match = [-1] * len(rebels)\n    for v, u in enumerate(match):\n        rebels_bases_match[u] = v\n    \n    return \"Yes\" if can_connect_without_crossing(rebels + bases, rebels_bases_match) else \"No\"\n\ndef main():\n    reader = (line.split() for line in sys.stdin)\n    rebels, bases = map(int, next(reader))\n    rebel_spaceships = [(int(x), int(y)) for _ in range(rebels) for x, y in [next(reader)]]\n    bases_positions = [(int(x), int(y)) for _ in range(bases) for x, y in [next(reader)]]\n    \n    print(find_matching(rebel_spaceships, bases_positions))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_power_of_two(n, arr):\n    max_power = 0\n    count = 0\n    for num in arr:\n        current_power = 0\n        while num % 2 == 0:\n            num //= 2\n            current_power += 1\n        if current_power > max_power:\n            max_power = current_power\n            count = 1\n        elif current_power == max_power:\n            count += 1\n    return 2 ** max_power, count\n\nn = int(input())\na = list(map(int, input().split()))\nr, cnt = max_power_of_two(n, a)\nprint(r, cnt)"}
{"solution": "def min_clicks(n, m):\n    if n == m:\n        return 0\n    steps = 0\n    while n < m:\n        if m % 2 == 0:\n            m //= 2\n        else:\n            m += 1\n        steps += 1\n    return steps + (n - m)\n\nn, m = map(int, input().split())\nprint(min_clicks(n, m))"}
{"solution": "from collections import defaultdict\n\ndef check_tree(n, segments):\n    graph = defaultdict(set)\n    endpoints = []\n\n    for i, (l, r) in enumerate(segments):\n        endpoints.append((l, 'start', i))\n        endpoints.append((r, 'end', i))\n\n    endpoints.sort(key=lambda x: (x[0], x[1] == 'end'))\n\n    intersections = set()\n    last_end = None\n\n    for pos, typ, seg_id in endpoints:\n        if typ == 'start':\n            for other_seg in intersections:\n                graph[seg_id].add(other_seg)\n                graph[other_seg].add(seg_id)\n            intersections.add(seg_id)\n        else:\n            intersections.remove(seg_id)\n\n            if last_end and last_end != pos:\n                return \"NO\"\n            last_end = pos\n\n    for node in graph.values():\n        if len(node) != 2:\n            return \"NO\"\n\n    visited = set()\n\n    def dfs(node, parent):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not dfs(neighbor, node):\n                return False\n        return True\n\n    if not dfs(next(iter(graph)), -1):\n        return \"NO\"\n\n    return \"YES\" if len(visited) == n else \"NO\"\n\n# Reading input\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Printing output\nprint(check_tree(n, segments))"}
{"solution": "def max_ddos_period(n, requests):\n    \"\"\"\n    Finds the maximum length of a continuous period considered as a DDoS attack.\n    \"\"\"\n    from collections import deque\n    max_length = 0\n    q = deque()\n    sum_requests = 0\n    \n    for i in range(n):\n        while q and q[0] < i - n + 1:\n            sum_requests -= requests[q[0]]\n            q.popleft()\n            \n        while sum_requests > 100 * (i - len(q) + 1):\n            if q:\n                sum_requests -= requests[q.pop()]\n                \n        sum_requests += requests[i]\n        q.append(i)\n        \n        if sum_requests > 100 * (i - len(q) + 2):\n            max_length = max(max_length, i - len(q) + 2)\n        else:\n            max_length = max(max_length, i - len(q) + 1)\n    \n    return max_length\n\n# Read input\nn = int(input())\nrequests = list(map(int, input().split()))\n\n# Compute and print the result\nprint(max_ddos_period(n, requests))"}
{"solution": "def check_dissatisfaction(n, k, episodes):\n    from itertools import groupby\n\n    def max_consecutive_N(s):\n        return max((sum(1 for _ in g) for k, g in groupby(s) if k == 'N'), default=0)\n\n    # Replace '?' with 'Y' to minimize consecutive 'N'\n    min_consec = max_consecutive_N(episodes.replace('?', 'Y'))\n    if min_consec >= k:\n        return \"YES\"\n\n    # Replace '?' with 'N' to find max consecutive 'N'\n    max_consec = max_consecutive_N(episodes.replace('?', 'N'))\n\n    return \"YES\" if min_consec <= k <= max_consec else \"NO\"\n\n# Example usage\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    episodes = input().strip()\n    print(check_dissatisfaction(n, k, episodes))"}
{"solution": "import sys\ninput = sys.stdin.readline\n\ndef main():\n    N, X, D = map(int, input().split())\n    if D == 0:\n        if N % 2 == 0:\n            print(1)\n        else:\n            print(2)\n    else:\n        ans = 2 * N - 1\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\ngood_performance = False\n\nfor _ in range(n):\n    name, before, after = input().split()\n    before = int(before)\n    after = int(after)\n    \n    if before >= 2400 and after > before:\n        good_performance = True\n\nif good_performance:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_trains_missed(binary_time):\n    \"\"\"\n    Given a binary string representing the time Team BowWow arrived at the station,\n    this function calculates the number of trains that have departed strictly before that time.\n    \n    :param binary_time: A string representing the arrival time in binary format without leading zeroes.\n    :return: The number of trains missed.\n    \"\"\"\n    missed_count = 0\n    binary_time = binary_time[::-1]  # Reverse the string to process from least significant bit\n    \n    for bit in binary_time:\n        if bit == '1':\n            missed_count += 1\n            if missed_count >= 64:  # Optimization: no need to continue if missed_count exceeds 63\n                break\n            missed_count = missed_count * 2\n    \n    return missed_count\n\n# Read input from stdin\nimport sys\nbinary_time = sys.stdin.readline().strip()\n\n# Calculate and print the result\nprint(count_trains_missed(binary_time))"}
{"solution": "# Import necessary library\nimport sys\n\n# Read input from stdin\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\n\n# Initialize variable to store the result\nmin_rows = 1\n\n# Iterate through each column\nfor col in zip(*matrix_a):\n    # Convert the current column to a string for easy comparison\n    col_str = ''.join(map(str, col))\n    # Check if the reversed column is different from the original\n    if col_str != col_str[::-1]:\n        min_rows = 2\n        break\n\n# Print the result\nprint(min_rows)"}
{"solution": "import heapq\n\ndef max_acceptable_orders(n, intervals):\n    intervals.sort(key=lambda x: x[1])\n    heap = []\n    for start, end in intervals:\n        if not heap or heap[0] <= start:\n            heapq.heappush(heap, end)\n        else:\n            heapq.heappushpop(heap, end)\n    return len(heap)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    intervals = [list(map(int, input().split())) for _ in range(n)]\n    print(max_acceptable_orders(n, intervals))"}
{"solution": "def check_boredom(n, k, x, y):\n    current_tables, current_formulas = 0, 0\n    prev_page_tables, prev_page_formulas = 0, 0\n\n    for i in range(n):\n        # Calculate current tables and formulas including previous page's contribution\n        current_tables = x[i] + prev_page_tables\n        current_formulas = y[i] + prev_page_formulas\n\n        # Check if rearrangement is possible without exceeding k\n        if current_tables > k and current_formulas > k:\n            return \"NO\"\n\n        # Update previous page's contribution for next iteration\n        if current_tables > k:\n            prev_page_formulas = current_formulas\n            prev_page_tables = 0\n        elif current_formulas > k:\n            prev_page_tables = current_tables\n            prev_page_formulas = 0\n        else:\n            # Choose the one which needs to be carried over based on the minimum value\n            if current_tables < current_formulas:\n                prev_page_tables = current_tables\n                prev_page_formulas = 0\n            else:\n                prev_page_formulas = current_formulas\n                prev_page_tables = 0\n\n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Call function and print result\nprint(check_boredom(n, k, x, y))"}
{"solution": "def can_human_win(n, k, coefficients):\n    # Track which indices have been set\n    set_indices = [coeff != '?' for coeff in coefficients]\n    \n    # Determine whose turn it is based on the last set index\n    computer_turn = sum(set_indices) % 2 == 1\n    \n    # Check divisibility condition\n    required_coeffs = [(coefficients[i] if set_indices[i] else '?') - (coefficients[0] if i > 0 else 0) * (k ** i)\n                       for i in range(n + 1)]\n    \n    # Count unset indices that must be zero\n    unset_must_be_zero = sum(1 for i, coeff in enumerate(required_coeffs[:-1]) if coeff == '?' and set_indices[i + 1])\n    \n    # Determine if human can win\n    can_win = (unset_must_be_zero % 2 != 0) ^ computer_turn\n    \n    return \"Yes\" if can_win else \"No\"\n\n# Read input\nn, k = map(int, input().split())\ncoefficients = [input() if i > 0 else input() for i in range(n + 1)]\n\n# Output result\nprint(can_human_win(n, k, coefficients))"}
{"solution": "from math import sqrt\nfrom bisect import bisect_left\n\n# Sieve of Eratosthenes for generating primes\nMAX_PRIME = 10**6 + 1\nis_prime = [True] * MAX_PRIME\nprimes = []\nfor i in range(2, MAX_PRIME):\n    if is_prime[i]:\n        primes.append(i)\n        for j in range(i*i, MAX_PRIME, i):\n            is_prime[j] = False\n\ndef find_smallest_X0(X2):\n    for i in range(bisect_left(primes, 2), bisect_left(primes, X2-1) + 1):\n        p = primes[i]\n        X = ((X2 - 1) // p) * p\n        if X < X2:\n            X += p\n        if X == X2:\n            X2 = (X2 - 1) // p * p\n            break\n    return X2\n\nif __name__ == \"__main__\":\n    X2 = int(input())\n    print(find_smallest_X0(X2))"}
{"solution": "def min_p_binary_summands(n, p):\n    if n == 1 and p != 0:\n        return -1\n    if p <= 0:\n        count = 0\n        while n > 0:\n            remainder = n % (-p)\n            n -= remainder\n            count += remainder // (-p) + (1 if n > 0 else 0)\n        return count\n    else:\n        binary_representation = bin(n)[2:]\n        return sum(int(bit) for bit in binary_representation) + (0 if p == 0 else 1)\n\n# Example usage\nn, p = map(int, input().split())\nprint(min_p_binary_summands(n, p))"}
{"solution": "def minify_number(n, k, S):\n    S = list(map(int, S))\n    changes = 0\n    for i in range(n):\n        if changes < k and S[i] > 0:\n            if i == 0 and S[i] != 1:  # Special case for the first digit\n                S[i] = 1\n                changes += 1\n            else:\n                S[i] = 0\n                changes += 1\n        if changes >= k:\n            break\n    # Ensure the number has n digits and doesn't start with zero\n    if S[0] == 0:\n        S[0] = 1\n    return ''.join(map(str, S))\n\n# Reading input\nn, k = map(int, input().split())\nS = input()\n\n# Processing and printing output\nprint(minify_number(n, k, S))"}
{"solution": "def solve(cnt_1, cnt_2, x, y):\n    lcm = x * y\n    a = cnt_1 + cnt_2\n    b = (x + y - 1) - ((cnt_1 - (cnt_1 // x) - (cnt_1 // y) + (cnt_1 // lcm)) + (cnt_2 - (cnt_2 // x) - (cnt_2 // y) + (cnt_2 // lcm)))\n    return a + b\n\ndef main():\n    cnt_1, cnt_2, x, y = map(int, input().split())\n    print(solve(cnt_1, cnt_2, x, y))\n\nmain()"}
{"solution": "def final_position(n, sx, sy, dx, dy, t):\n    for _ in range(t):\n        k = sx + sy - 2\n        dx += k\n        dy += k\n        sx = ((sx + dx - 1) % n) + 1\n        sy = ((sy + dy - 1) % n) + 1\n    return sx, sy\n\n# Reading input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Calculating final position\nresult = final_position(n, sx, sy, dx, dy, t)\n\n# Printing output\nprint(*result)"}
{"solution": "def solve(s):\n    from collections import Counter\n    s = list(s)\n    cnt = Counter(s)\n    if '?' not in cnt or len(s) - cnt['?'] < 26:\n        if '?' in cnt: del cnt['?']\n        if max(cnt.values()) > 26 - (26 - len(s) + cnt['?']):\n            return -1\n    else:\n        return -1\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    seen = set()\n    i = 0\n    j = 25\n    while j < len(s):\n        for k in range(i, j + 1):\n            if s[k] != '?':\n                seen.add(s[k])\n        if len(seen) == 26:\n            break\n        seen.clear()\n        i += 1\n        j += 1\n    else:\n        return -1\n    used = set()\n    for k in range(i, j + 1):\n        if s[k] == '?':\n            for c in alphabet:\n                if c not in used and c not in seen:\n                    s[k] = c\n                    used.add(c)\n                    break\n    for k, v in enumerate(s):\n        if v == '?':\n            for c in alphabet:\n                if c not in used:\n                    s[k] = c\n                    used.add(c)\n                    break\n    return ''.join(s)\n\ns = input().strip()\nprint(solve(s))"}
{"solution": "def can_divide_apples(n, weights):\n    total_weight = sum(weights)\n    if total_weight % 2 != 0:\n        return \"NO\"\n    else:\n        target_weight = total_weight // 2\n        current_weight = 0\n        can_be_divided = \"YES\" if target_weight == 0 else \"NO\"\n        weights_count_100 = weights.count(100)\n        \n        if weights_count_100 % 2 == 0 or target_weight == 100 * weights_count_100:\n            can_be_divided = \"YES\"\n        \n        return can_be_divided\n\nif __name__ == \"__main__\":\n    n = int(input())\n    weights = list(map(int, input().split()))\n    print(can_divide_apples(n, weights))"}
{"solution": "import sys\nfrom functools import lru_cache\n\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\ndef solve():\n    n, m = map(int, input().split())\n    floors = [input() for _ in range(n)]\n    \n    @lru_cache(maxsize=None)\n    def dp(floor, last_pos):\n        if floor == n:\n            return 0\n        \n        # Left Stair\n        if last_pos == 0:\n            light_on = [(i, int(floors[floor][i])) for i in range(1, m+1) if int(floors[floor][i]) == 1]\n            min_time = float('inf')\n            for i, status in light_on:\n                time_to_room = i\n                time_from_room = min(i, m-i+1)\n                time_to_switch = dp(floor, i)\n                min_time = min(min_time, time_to_room + time_from_room + time_to_switch)\n            \n            time_to_right_stair = m+1\n            time_from_right_stair = 1\n            time_to_switch = dp(floor, m+1)\n            min_time = min(min_time, time_to_right_stair + time_from_right_stair + time_to_switch)\n            \n            return min_time\n        \n        # Room\n        elif 0 < last_pos <= m:\n            light_on_left = [(i, int(floors[floor][i])) for i in range(1, last_pos) if int(floors[floor][i]) == 1]\n            light_on_right = [(i, int(floors[floor][i])) for i in range(last_pos+1, m+1) if int(floors[floor][i]) == 1]\n            \n            min_time = float('inf')\n            for i, status in light_on_left:\n                time_to_room = last_pos - i\n                time_from_room = i\n                time_to_switch = dp(floor, i)\n                min_time = min(min_time, time_to_room + time_from_room + time_to_switch)\n            \n            for i, status in light_on_right:\n                time_to_room = i - last_pos\n                time_from_room = min(i, m-i+1)\n                time_to_switch = dp(floor, i)\n                min_time = min(min_time, time_to_room + time_from_room + time_to_switch)\n            \n            time_to_left_stair = last_pos\n            time_from_left_stair = last_pos\n            time_to_switch = dp(floor, 0)\n            min_time = min(min_time, time_to_left_stair + time_from_left_stair + time_to_switch)\n            \n            time_to_right_stair = m - last_pos + 1\n            time_from_right_stair = 1\n            time_to_switch = dp(floor, m+1)\n            min_time = min(min_time, time_to_right_stair + time_from_right_stair + time_to_switch)\n            \n            return min_time\n        \n        # Right Stair\n        else:\n            light_on = [(i, int(floors[floor][i])) for i in range(1, m+1) if int(floors[floor][i]) == 1]\n            min_time = float('inf')\n            for i, status in light_on:\n                time_to_room = m+1-i\n                time_from_room = min(i, m-i+1)\n                time_to_switch = dp(floor, i)\n                min_time = min(min_time, time_to_room + time_from_room + time_to_switch)\n            \n            time_to_left_stair = m+1\n            time_from_left_stair = 1\n            time_to_switch = dp(floor, 0)\n            min_time = min(min_time, time_to_left_stair + time_from_left_stair + time_to_switch)\n            \n            return min_time\n    \n    print(dp(0, 0))\n\nsolve()"}
{"solution": "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\ndef solve():\n    n = int(input())\n    cost = list(map(int, input().split()))\n    moves = list(map(int, input().split()))\n    for i in range(n):\n        moves[i] -= 1\n    \n    visited = [False] * n\n    components = []\n    \n    def dfs(node, comp):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if not visited[cur]:\n                visited[cur] = True\n                comp.append(cur)\n                if cur != node:\n                    stack.append(cur)\n                stack.extend([moves[cur]])\n    \n    for i in range(n):\n        if not visited[i]:\n            component = []\n            dfs(i, component)\n            components.append(component)\n    \n    ans = 0\n    for comp in components:\n        min_cost = min(cost[node] for node in comp)\n        ans += min_cost\n    print(ans)\n\nsolve()"}
{"solution": "def find_entrance(n, a, b):\n    result = (a + b - 1) % n + 1\n    print(result)\n\n# The following lines are for reading input and do not pertain to the solution logic.\nn, a, b = map(int, input().split())\nfind_entrance(n, a, b)"}
{"solution": "from collections import defaultdict\n\ndef min_arithmetic_progressions(n, a):\n    \"\"\"\n    Finds the minimum number of arithmetic progressions needed to form the sequence a.\n    \"\"\"\n    if n == 1:\n        return 1\n\n    dp = [1] * n  # Initialize DP table\n    last = defaultdict(lambda: -10**10)  # Tracks the last occurrence of each value\n\n    for i in range(n - 1, -1, -1):\n        if a[i] != -1:\n            last[a[i]] = i  # Update the last occurrence of the current value\n\n        if i == n - 1:\n            continue\n\n        next_val = last.get(a[i] + (a[i + 1] - a[i]), -1)\n        if next_val != -1 and next_val > i + 1:\n            dp[i] = dp[next_val]\n        else:\n            dp[i] = dp[i + 1] + 1\n\n    return dp[0]\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Compute and print the result\nprint(min_arithmetic_progressions(n, a))"}
{"solution": "def max_beauty(n, k, s):\n    max_len = 0\n    left = 0\n    count_a = 0\n    count_b = 0\n\n    for right in range(n):\n        if s[right] == 'a':\n            count_a += 1\n        else:\n            count_b += 1\n\n        while min(count_a, count_b) > k:\n            if s[left] == 'a':\n                count_a -= 1\n            else:\n                count_b -= 1\n            left += 1\n\n        max_len = max(max_len, right - left + 1)\n\n    return max_len\n\n# Reading input\nn, k = map(int, input().split())\ns = input()\n\n# Calculating and printing the result\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, parties):\n    alice_party = parties[0]\n    total_seats = sum(parties)\n    coalition_seats = alice_party\n    coalition = [1]\n\n    for i in range(1, n):\n        if alice_party >= 2 * parties[i]:\n            coalition_seats += parties[i]\n            coalition.append(i + 1)\n\n    if coalition_seats > total_seats // 2:\n        print(len(coalition))\n        print(' '.join(map(str, coalition)))\n    else:\n        print(0)\n\nn = int(input())\nparties = list(map(int, input().split()))\nfind_coalition(n, parties)"}
{"solution": "import math\n\ndef max_reward(n):\n    return math.log2(n + 1)\n\nn = int(input())\nprint(max_reward(n))"}
{"solution": "def santa_gifts(n):\n    kids = []\n    i = 1\n    while n > 0:\n        if n - i >= 0:\n            kids.append(i)\n            n -= i\n            i += 1\n        else:\n            break\n    if n > 0:\n        kids[-1] += n\n    return len(kids), kids\n\nn = int(input())\nk, candies = santa_gifts(n)\nprint(k)\nprint(' '.join(map(str, candies)))"}
{"solution": "n = int(input())\nm = int(input())\n\nprint(m % (2**n))"}
{"solution": "def correct_word(s):\n    vowels = \"aeiouy\"\n    i = 0\n    while i < len(s) - 1:\n        if s[i] in vowels and s[i + 1] in vowels:\n            s = s[:i] + s[i+1:]\n        else:\n            i += 1\n    return s\n\nn = int(input())\ns = input()\nprint(correct_word(s))"}
{"solution": "def max_students(n, a, b, seats):\n    dp = [[0 for _ in range(3)] for _ in range(n + 1)]\n    dp[0][0], dp[0][1], dp[0][2] = 0, -float('inf'), -float('inf')\n\n    for i in range(1, n + 1):\n        if seats[i - 1] == '*':\n            dp[i][0] = dp[i - 1][0]\n            dp[i][1] = dp[i - 1][1]\n            dp[i][2] = dp[i - 1][2]\n        else:\n            dp[i][0] = max(dp[i - 1])\n            dp[i][1] = dp[i - 1][0] + 1\n            dp[i][2] = max(dp[i - 1][1], dp[i - 1][0]) + 1\n\n    programmers = min(a, max(dp[n][1], dp[n][2]))\n    athletes = min(b, max(dp[n][0] - programmers, dp[n][1] - programmers, dp[n][2] - programmers))\n    return programmers + athletes\n\nn, a, b = map(int, input().split())\nseats = input()\nprint(max_students(n, a, b, seats))"}
{"solution": "import math\nr = int(input())\na = -1 + math.sqrt(1 + 4 * (r - 1))\nif int(a) == a and a > 0:\n    x = int(a / 2)\n    y = (r - x ** 2 - x - 1) // (2 * x)\n    if y > 0:\n        print(x, y)\n    else:\n        print(\"NO\")\nelse:\n    print(\"NO\")"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    total = sum(a)\n    for i in range(1, n):\n        for subset in range(1 << i):\n            grigory_sum = sum(a[j] for j in range(i) if (subset & (1 << j)) != 0)\n            andrew_sum = sum(a[j] for j in range(i) if (subset & (1 << j)) == 0)\n            if grigory_sum == andrew_sum:\n                continue\n            remaining = total - (grigory_sum + andrew_sum)\n            if remaining == 0 or (grigory_sum != remaining and andrew_sum != remaining):\n                print(i)\n                print(\" \".join(str(j+1) for j in range(i) if (subset & (1 << j)) != 0))\n                return\n    print(-1)\n\nsolve()"}
{"solution": "def min_diff_digits(n):\n    # Calculate the minimal number of different digits\n    min_diff = 1 if n <= 9 else len(str(n))\n    \n    # Adjust min_diff based on n's divisibility by 9\n    if n > 9:\n        remainder = n % 9\n        min_diff = 2 if remainder else 1\n    \n    # Determine the digits\n    digits = []\n    if min_diff == 1:\n        digits = [n]\n    elif min_diff == 2:\n        digits = [9] * (n // 9)\n        if n % 9:\n            digits.append(n % 9)\n    \n    return [len(digits), *digits]\n\n# Read input\nn = int(input())\n\n# Output result\nresult = min_diff_digits(n)\nprint(result[0])\nprint(' '.join(map(str, result[1:])))"}
{"solution": "from collections import Counter\nimport math\nimport sys\ninput = sys.stdin.readline\ndef check_prime(n):\n    if n == 1:\n        return False\n    max_div = math.isqrt(n) + 1\n    for i in range(2, max_div):\n        if n % i == 0:\n            return False\n    return True\ndef main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    freq = Counter(arr)\n    # Check if we can take all 1s and a 2 if present\n    ones = freq[1]\n    twos = freq[2]\n    if check_prime(sum(arr) - ones):\n        print(n)\n        print(*arr)\n        return\n    elif ones + twos > 0 and check_prime(sum(arr) - ones - twos + 1):\n        print(n - 1)\n        if twos == 0:\n            arr.remove(1)\n        else:\n            arr.remove(2)\n        print(*arr)\n        return\n    # General case\n    result = []\n    for num in arr:\n        if check_prime(sum(result) + num):\n            result.append(num)\n    print(len(result))\n    print(*result)\n    \nmain()"}
{"solution": "def greatest_beautiful_divisor(n):\n    max_divisor = 0\n    for k in range(1, 17):  # Limiting k to a reasonable range\n        candidate = (2**k - 1) * (2**k)\n        if candidate <= n and candidate > max_divisor:\n            max_divisor = candidate\n    return max_divisor\n\n# Read input\nn = int(input())\n\n# Compute and print the result\nprint(greatest_beautiful_divisor(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef pow_mod(x, n):\n    result = 1\n    while n > 0:\n        if n & 1:\n            result = result * x % MOD\n        x = x * x % MOD\n        n >>= 1\n    return result\n\ndef count_d_magic(m, d, a, b):\n    n = len(a)\n    dp = [[[0 for _ in range(2)] for _ in range(m)] for _ in range(n + 1)]\n    dp[0][0][1] = 1\n\n    for i in range(1, n + 1):\n        for j in range(m):\n            for k in range(2):\n                for digit in range(10):\n                    if (digit == d and i % 2 == 0) or (digit != d and i % 2 != 0):\n                        continue\n                    new_val = (j * 10 + digit) % m\n                    dp[i][new_val][k] += dp[i - 1][j][k]\n                    dp[i][new_val][k] %= MOD\n                if k == 1:\n                    dp[i][(j * 10) % m][0] += dp[i - 1][j][1]\n                    dp[i][(j * 10) % m][0] %= MOD\n\n    def calculate_range(start, end):\n        result = 0\n        for i in range(n):\n            for digit in range(int(start[i]), int(end[i]) + 1):\n                if (digit == d and i % 2 == 0) or (digit != d and i % 2 != 0):\n                    continue\n                current_val = int(start[:i] + str(digit) + '0' * (n - i - 1))\n                if current_val % m == 0:\n                    result += dp[i][(current_val // (10 ** i)) % m][start[i] == str(digit)]\n                    result %= MOD\n        return result\n\n    return (calculate_range(a, b) - calculate_range('0' * n, a) + MOD) % MOD\n\nm, d = map(int, input().split())\na = input()\nb = input()\nprint(count_d_magic(m, d, a, b))"}
{"solution": "def last_child_home(n, m, desires):\n    queue = list(range(1, n + 1))\n    for desire in desires:\n        m_given = 0\n        while True:\n            child = queue.pop(0)\n            m_given += m\n            if m_given >= desire:\n                desire += 101  # Mark as finished by setting a high value\n                print(child)\n                break\n            else:\n                queue.append(child)\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    desires = list(map(int, input().split()))\n    last_child_home(n, m, desires)"}
{"solution": "# Import necessary package\nfrom math import floor\n\ndef min_bills(n):\n    # Denominations of dollar bills\n    denominations = [100, 20, 10, 5, 1]\n    \n    # Initialize count of bills\n    count = 0\n    \n    # Calculate the minimum number of bills\n    for denom in denominations:\n        count += n // denom\n        n %= denom\n    \n    return count\n\n# Read input\nn = int(input())\n\n# Print the result\nprint(min_bills(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef modinv(x):\n    return pow(x, MOD-2, MOD)\n\ndef precompute_factorials(n):\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    invfact[n] = modinv(fact[n])\n    for i in range(n, 0, -1):\n        invfact[i-1] = invfact[i] * i % MOD\n    return fact, invfact\n\ndef C(n, k, fact, invfact):\n    return fact[n] * invfact[k] * invfact[n-k] % MOD\n\ndef solve(n, k):\n    fact, invfact = precompute_factorials(n)\n    dp = [[0]*(k+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        for j in range(k+1):\n            dp[i][j] = (dp[i-1][j] + (dp[i-1][j-1] if j > 0 else 0) * 2) % MOD\n            if j > 1:\n                dp[i][j] -= dp[i-1][j-2]\n                dp[i][j] %= MOD\n    ans = 0\n    for bad in range(k+1):\n        good = k - bad\n        ans += C(n, good, fact, invfact) * dp[n-good][bad]\n        ans %= MOD\n    return ans\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    print(solve(n, k))"}
{"solution": "import heapq\nfrom collections import defaultdict\n\ndef max_beauty(n, k, beauties, colors):\n    color_counts = defaultdict(list)\n    for b, c in zip(beauties, colors):\n        heapq.heappush(color_counts[c], -b)  # Use negative beauty for max heap\n    \n    unique_colors = [c for c in color_counts if len(color_counts[c]) >= k]\n    \n    if not unique_colors:\n        return -1\n    \n    max_beauty = -1\n    for uc in unique_colors:\n        current_beauty = sum(heapq.nsmallest(k, color_counts[uc]))\n        max_beauty = max(max_beauty, current_beauty)\n    \n    combined_beauty = defaultdict(int)\n    for c in color_counts:\n        if len(color_counts[c]) < k:\n            combined_beauty[c] = sum(heapq.nsmallest(len(color_counts[c]), color_counts[c]))\n    \n    for c1 in color_counts:\n        for c2 in color_counts:\n            if c1 != c2 and c1 + c2 != \"RW\" and c1 + c2 != \"WR\":\n                if len(color_counts[c1]) + len(color_counts[c2]) >= k:\n                    combined_sum = combined_beauty[c1] + combined_beauty[c2]\n                    max_beauty = max(max_beauty, combined_sum)\n    \n    return max_beauty if max_beauty > 0 else -1\n\n# Example usage\nn, k = map(int, input().split())\nbeauties = list(map(int, input().split()))\ncolors = input()\nprint(max_beauty(n, k, beauties, colors))"}
{"solution": "import sys\n\ndef continued_fraction_to_rational(a):\n    n = len(a)\n    if n == 1:\n        return (a[0], 1)\n    p1, q1 = continued_fraction_to_rational(a[:n//2])\n    p2, q2 = continued_fraction_to_rational(a[n//2:])\n    return (p2 * p1 + q2, q2 * p1)\n\ndef main():\n    p, q = map(int, sys.stdin.readline().split())\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    \n    cf_p, cf_q = continued_fraction_to_rational(a)\n    \n    if p * cf_q == q * cf_p:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def shift_stick(expression):\n    parts = expression.split('+=')\n    a = parts[0].count('|')\n    c = parts[1].count('|')\n\n    b_plus_eq = parts[1][:2]\n    b = parts[1][2:].count('|')\n\n    if a + b == c:\n        return expression\n\n    if a + b + 1 == c and '+' in b_plus_eq:\n        return f\"{a * '|'}+{b * '|'}={c * '|'}\"\n\n    if a + b - 1 == c and '++' in expression or '+|' in expression or '|+' in expression:\n        return f\"{a * '|'}+{b * '|'}={c * '|'}\"\n\n    if a + b == c + 1 and '=' in b_plus_eq:\n        return f\"{a * '|'}+{b * '|'}={c * '|'}|\"\n\n    return \"Impossible\"\n\nexpression = input().strip()\nprint(shift_stick(expression))"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial_mod(n, mod):\n    fact = 1\n    for i in range(1, n + 1):\n        fact = (fact * i) % mod\n    return fact\n\ndef inverse_factorial(n, fact, mod):\n    inv = pow(fact[n], mod - 2, mod)\n    return inv\n\ndef comb_mod(n, k, fact, ifact, mod):\n    return (fact[n] * ifact[k] * ifact[n - k]) % mod\n\ndef perm_odd(n, k):\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n    ifact = [1] * (n + 1)\n    ifact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        ifact[i - 1] = (ifact[i] * i) % MOD\n\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= i - 1:\n                dp[i][j] += dp[i - 1][j - (i - 1)] * (i - 1) * 2\n            if j >= i:\n                dp[i][j] += dp[i - 1][j - i] * i\n            dp[i][j] %= MOD\n\n    ans = 0\n    for i in range(n):\n        if (n - i) % 2 == 1:\n            continue\n        ans += dp[n][k - i * 2] * comb_mod(n, i, fact, ifact, MOD) * factorial_mod(n - i, MOD)\n        ans %= MOD\n    return ans\n\nn, k = map(int, input().split())\nprint(perm_odd(n, k))"}
{"solution": "from collections import defaultdict\nimport math\nimport copy\n\ndef solve(points):\n    n = len(points)\n    if n == 1:\n        x, y = points[0]\n        return [max(abs(x), abs(y))], [f\"{'' if x >= 0 else 'D' * abs(x)}{'R' * abs(x) if x >= 0 else ''}{'' if y >= 0 else 'D' * abs(y)}{'U' * abs(y) if y >= 0 else ''}\"]\n    \n    # Find the minimum number of segments needed\n    min_segments = float('inf')\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dx = points[i][0] - points[j][0]\n                dy = points[i][1] - points[j][1]\n                min_segments = min(min_segments, max(abs(dx), abs(dy)))\n    \n    # Build the robot arm configuration\n    arm_config = [min_segments]\n    arm_modes = []\n    \n    # Calculate modes for each point\n    modes = []\n    for x, y in points:\n        mode = ''\n        if x < 0:\n            mode += 'L' * (-x // min_segments)\n        elif x > 0:\n            mode += 'R' * (x // min_segments)\n        \n        if y < 0:\n            mode += 'D' * (-y // min_segments)\n        elif y > 0:\n            mode += 'U' * (y // min_segments)\n        \n        modes.append(mode)\n    \n    # Extend the arm if necessary\n    while len(modes[0]) < 40:\n        arm_config.append(arm_config[-1])\n        for k in range(n):\n            modes[k] += modes[k][-1]\n    \n    return arm_config, modes\n\n# Read input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Solve and print output\nresult = solve(points)\nif result is None:\n    print(-1)\nelse:\n    arm_config, modes = result\n    print(len(arm_config))\n    print(' '.join(map(str, arm_config)))\n    for mode in modes:\n        print(mode)"}
{"solution": "n = int(input())\ns = input()\n\ni = 0\nwhile i < len(s):\n    if s[i:i+3] == 'ogo':\n        count = 3\n        while i + count <= len(s) and s[i:i+count] == 'ogo'[:count]:\n            count += 2\n        s = s[:i] + \"***\" + s[count-3:]\n    i += 1\n\nprint(s)"}
{"solution": "from math import sqrt\n\ndef prime_factors(n):\n    i = 2\n    factors = set()\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.add(i)\n    if n > 1:\n        factors.add(n)\n    return factors\n\ndef max_divisible(n, p):\n    res = 1\n    while n % p == 0:\n        res *= p\n        n //= p\n    return res\n\ndef power_mod(base, exp, mod):\n    result = 1\n    base %= mod\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        exp = exp >> 1\n        base = (base * base) % mod\n    return result\n\nMOD = 10**9 + 7\nx, n = map(int, input().split())\nprimes = prime_factors(x)\n\nresult = 1\nfor p in primes:\n    count = 0\n    cur_n = n\n    while cur_n > 0:\n        cur_n //= p\n        count += cur_n\n    result = (result * power_mod(p, count, MOD)) % MOD\n\nprint(result)"}
{"solution": "from collections import defaultdict\n\ndef sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    max_x = 10**9\n    # Create a map to store possible ranges for s(x)\n    s_x_ranges = defaultdict(lambda: [max_x, 0])\n    \n    # Initialize the range for s(x) based on the equation constraints\n    min_s_x = max(1, (-c - 1) // (b * a) + 1)\n    max_s_x = (-c - 1) // b + 1\n    \n    for s_x in range(min_s_x, max_s_x + 1):\n        # Calculate the range for x based on the current s(x)\n        lower_bound = max(1, (c - s_x**a) // (-b) + 1)\n        upper_bound = (c - s_x**a) // (-b)\n        \n        # Update the range for s(x) if necessary\n        if lower_bound > s_x_ranges[s_x][0]:\n            s_x_ranges[s_x][0] = lower_bound\n        if upper_bound < s_x_ranges[s_x][1]:\n            s_x_ranges[s_x][1] = upper_bound\n    \n    # Check for valid solutions within the calculated ranges\n    for s_x, (min_x, max_x) in s_x_ranges.items():\n        for x in range(max(1, min_x), min(max_x, 10**9)):\n            if x == b * s_x**a + c:\n                solutions.append(x)\n    \n    return sorted(solutions)\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find and print solutions\nsolutions = find_solutions(a, b, c)\nprint(len(solutions))\nif solutions:\n    print(' '.join(map(str, solutions)))"}
{"solution": "def can_solve_with_one_turn(colors):\n    from collections import Counter\n    \n    def is_solved_with_one_move(face):\n        return len(set(face)) == 1 or (len(set(face)) == 2 and max(Counter(face).values()) == 3)\n    \n    faces = [\n        colors[0:4],     # Top face\n        colors[0::6],    # Front face (left column)\n        [colors[1], colors[7], colors[11], colors[17]],  # Right face (middle column)\n        [colors[2], colors[6], colors[10], colors[16]],  # Back face (right column)\n        colors[3::6],    # Left face (last column)\n        colors[18:22]    # Bottom face\n    ]\n    \n    for face in faces:\n        if is_solved_with_one_move(face):\n            return \"YES\"\n    return \"NO\"\n\n# Example usage\nif __name__ == \"__main__\":\n    colors = list(map(int, input().split()))\n    print(can_solve_with_one_turn(colors))"}
{"solution": "def find_min_hacks(p, x, y):\n    def simulate(s):\n        i = (s // 50) % 475\n        for _ in range(25):\n            if 26 + i == p:\n                return True\n            i = (i * 96 + 42) % 475\n        return False\n\n    min_hacks = float('inf')\n    for s in range(y, 20001):\n        if simulate(s):\n            needed_points = s - x\n            hacks, remainder = divmod(needed_points, 100)\n            unsuccessful_hacks = remainder // 50 if remainder else 0\n            min_hacks = min(min_hacks, hacks + unsuccessful_hacks)\n\n    return max(0, min_hacks)\n\n# Example usage\np, x, y = map(int, input().split())\nprint(find_min_hacks(p, x, y))"}
{"solution": "def min_distance(n, a, b, c):\n    if n == 1:\n        return 0\n    else:\n        return min(a, b) + (n - 2) * min(a, b, c)\n\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nprint(min_distance(n, a, b, c))"}
{"solution": "def min_total_distance():\n    x1, x2, x3 = map(int, input().split())\n    # Sort the coordinates to find the middle point\n    coords = sorted([x1, x2, x3])\n    meeting_point = coords[1]  # The middle coordinate\n    # Calculate total distance to the meeting point\n    total_distance = abs(x1 - meeting_point) + abs(x2 - meeting_point) + abs(x3 - meeting_point)\n    print(total_distance)\n\nmin_total_distance()"}
{"solution": "from collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\ndef min_operations(n, x, arr):\n    bit_counts = [0] * 20  # Assuming max value in arr is within given limit\n    for num in arr:\n        for bit in range(20):\n            if num & (1 << bit):\n                bit_counts[bit] += 1\n\n    # Calculate x's bits presence in the array\n    x_bits = []\n    for bit in range(19, -1, -1):  # Reverse order for significance\n        if x & (1 << bit):\n            x_bits.append(bit)\n\n    # Check if already have duplicates\n    freq = defaultdict(int)\n    for num in arr:\n        freq[num] += 1\n    if any(val >= 2 for val in freq.values()):\n        return 0\n\n    # Try to form new duplicates using minimum operations\n    for bit in x_bits:\n        if bit_counts[bit] > 1:\n            return 1\n\n    # Form duplicates by forcing one element to match another\n    for bit in x_bits:\n        if bit_counts[bit]:\n            return 2\n\n    # Impossible to form duplicates\n    return -1\n\n# Reading inputs\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Calculating and printing result\nprint(min_operations(n, x, arr))"}
{"solution": "def is_cross(picture):\n    h, w = len(picture), len(picture[0])\n    center = None\n\n    for y in range(h):\n        for x in range(w):\n            if picture[y][x] == '*':\n                if center is None:\n                    center = (y, x)\n                else:\n                    # Check for more than one '*' before finding the center\n                    if center != (y, x):\n                        return False\n\n    if center is None:\n        return False\n\n    cy, cx = center\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    arms = []\n\n    for dy, dx in directions:\n        length = 0\n        y, x = cy + dy, cx + dx\n        while 0 <= y < h and 0 <= x < w and picture[y][x] == '*':\n            length += 1\n            y += dy\n            x += dx\n        if length == 0:\n            return False\n        arms.append(length)\n\n    # Check if arms are contiguous and only '*' around center\n    for y in range(h):\n        for x in range(w):\n            if picture[y][x] == '*' and (y, x) != center:\n                if abs(y - cy) + abs(x - cx) > max(arms):\n                    return False\n\n    return True\n\n# Read input\nh, w = map(int, input().split())\npicture = [input() for _ in range(h)]\n\n# Output result\nprint(\"YES\" if is_cross(picture) else \"NO\")"}
{"solution": "def generate_adjacency_matrix(n, a, b):\n    if a + b - 1 > n:\n        print(\"NO\")\n        return\n    print(\"YES\")\n    components = [1] * a\n    components[-1] += n - sum(components)\n    \n    for i in range(a - 1, 0, -1):\n        if components[i] + b <= n:\n            components[i - 1] -= b - components[i]\n            b = components[i]\n    \n    adj_matrix = [[0] * n for _ in range(n)]\n    start = 0\n    for size in components[:-1]:\n        for i in range(start, start + size):\n            for j in range(i + 1, n):\n                adj_matrix[i][j] = 1\n                adj_matrix[j][i] = 1\n        start += size\n    \n    for row in adj_matrix:\n        print(''.join(map(str, row)))\n\n# Example usage\nn, a, b = map(int, input().split())\ngenerate_adjacency_matrix(n, a, b)"}
{"solution": "def min_problems_needed():\n    c, d = map(int, input().split())\n    n, m = map(int, input().split())\n    k = int(input())\n\n    needed_slots = n * m - k\n    if needed_slots <= 0:\n        return 0\n\n    max_main_rounds = needed_slots // n\n    if needed_slots % n > 0:\n        max_main_rounds += 1\n\n    min_problems = float('inf')\n    for main_rounds in range(max_main_rounds + 1):\n        additional_rounds = max(0, (needed_slots - main_rounds * n) // 1)\n        current_problems = main_rounds * c + additional_rounds * d\n        min_problems = min(min_problems, current_problems)\n\n    return min_problems\n\nprint(min_problems_needed())"}
{"solution": "from collections import Counter\n\ndef generate_grid(s):\n    counter = Counter(s)\n    \n    # Check if it's possible to form a grid\n    if max(counter.values()) > 5:\n        print(\"Impossible\")\n        return\n    \n    # Initialize the grid\n    grid = [['' for _ in range(13)] for _ in range(2)]\n    \n    # Place the letters in the grid\n    row, col = 0, 0\n    for letter, count in counter.items():\n        for _ in range(count):\n            grid[row][col] = letter\n            col += 1\n            if col >= 13:\n                col = 0\n                row += 1\n                if row > 1:\n                    break\n    \n    # Check if we can form the string s as a path\n    def dfs(grid, x, y, index, visited):\n        if index == len(s):\n            return True\n        if x < 0 or x >= 2 or y < 0 or y >= 13 or visited[x][y] or grid[x][y] != s[index]:\n            return False\n        visited[x][y] = True\n        directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n        for dx, dy in directions:\n            if dfs(grid, x + dx, y + dy, index + 1, visited):\n                return True\n        visited[x][y] = False\n        return False\n    \n    visited = [[False for _ in range(13)] for _ in range(2)]\n    for i in range(2):\n        for j in range(13):\n            if dfs(grid, i, j, 0, visited):\n                break\n    \n    if not visited[0][0]:\n        print(\"Impossible\")\n    else:\n        print(''.join(grid[0]))\n        print(''.join(grid[1]))\n\ns = input()\ngenerate_grid(s)"}
{"solution": "import math\nx, y = map(int, input().split())\nif x == y:\n    print('=')\nelse:\n    x_log = y * math.log(x)\n    y_log = x * math.log(y)\n    if x_log > y_log:\n        print('>')\n    else:\n        print('<')"}
{"solution": "3\nimport sys\nfrom math import pi\n\n# Define a function to calculate the maximum number of balloons\ndef max_balloons(r, h):\n    \"\"\"\n    Calculate the maximum number of balloons that can fit in the cupboard.\n    \n    :param r: Radius of the semicircle (top of the cupboard)\n    :param h: Height of the walls (sides of the cupboard)\n    :return: Maximum number of balloons that can fit\n    \"\"\"\n    # Calculate the number of balloons that can fit in the height\n    vertical_balloons = (h + r) // r\n    # Calculate the number of balloons that can fit in the width (semicircle diameter)\n    horizontal_balloons = r // (r / 2)\n    # Total number of balloons is the product of vertical and horizontal fits\n    return vertical_balloons * horizontal_balloons\n\n# Read input from stdin\nr, h = map(int, sys.stdin.readline().strip().split())\n\n# Calculate and print the result\nprint(max_balloons(r, h))"}
{"solution": "from collections import Counter\n\n# Reading input\nt = list(map(int, input().split()))\n\n# Counting occurrences\ncount = Counter(t)\n\n# Sum of all cards\ntotal_sum = sum(t)\n\n# Minimize the sum by removing possibilities\nfor num in count:\n    if count[num] >= 2:\n        # Removing two cards\n        total_sum -= 2 * num\n        break\n    elif count[num] >= 3:\n        # Removing three cards for the minimum sum\n        total_sum -= 3 * num\n        break\n\nprint(total_sum)"}
{"solution": "def min_distance(n, a, xs):\n    xs.append(a)\n    xs.sort()\n    a_idx = xs.index(a)\n    \n    left_dist = xs[a_idx - 1] if a_idx > 0 else float('-inf')\n    right_dist = xs[a_idx + 1] if a_idx < n else float('inf')\n    \n    if left_dist == float('-inf'):\n        return right_dist - a\n    elif right_dist == float('inf'):\n        return a - left_dist\n    else:\n        return min(right_dist - a, a - left_dist) + xs[-1] - xs[1]\n\n# Reading input\nn, a = map(int, input().split())\nxs = list(map(int, input().split()))\n\n# Calculating and printing output\nprint(min_distance(n, a, xs))"}
{"solution": "import math\n\ndef sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef find_smallest_root(n):\n    \"\"\"\n    Finds the smallest positive integer root of the equation x^2 + s(x)*x - n = 0,\n    where s(x) is the sum of digits of x. Returns -1 if no such root exists.\n    \"\"\"\n    upper_limit = int(math.sqrt(n)) + 1000\n    for x in range(1, upper_limit + 1):\n        if x**2 + sum_of_digits(x) * x - n == 0:\n            return x\n    return -1\n\n# Example usage\nn = int(input().strip())\nprint(find_smallest_root(n))"}
{"solution": "def bedtime(s, t):\n    hs, ms = map(int, s.split(':'))\n    ht, mt = map(int, t.split(':'))\n    \n    ms -= mt\n    if ms < 0:\n        hs -= 1\n        ms += 60\n    hs -= ht\n    if hs < 0:\n        hs += 24\n    return '{:02d}:{:02d}'.format(hs, ms)\n\ns = input()\nt = input()\nprint(bedtime(s, t))"}
{"solution": "def max_mean_subsegment_length():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    max_sum = current_sum = a[0]\n    start = end = 0\n    temp_start = 0\n\n    for i in range(1, n + 1):\n        if current_sum > 0:\n            current_sum += a[i-1] if i < n else 0\n        else:\n            temp_start = i - 1\n            current_sum = a[i-1]\n\n        if (current_sum / (i - temp_start)) >= (max_sum / (end - start + 1)):\n            max_sum = current_sum\n            start = temp_start\n            end = i - 1\n\n    return end - start + 1\n\nprint(max_mean_subsegment_length())"}
{"solution": "MOD = 998244353\n\ndef modinv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef comb(n, k):\n    if k > n:\n        return 0\n    num = den = 1\n    for i in range(k):\n        num = (num * (n - i)) % MOD\n        den = (den * (i + 1)) % MOD\n    return (num * modinv(den)) % MOD\n\ndef solve(n, m, k):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1] * (m - 1)\n            dp[i][j] %= MOD\n            \n    result = 0\n    for j in range(k + 1):\n        result += dp[n][j] * comb(m - 1 + n - 1 - j, n - 1 - j)\n        result %= MOD\n        \n    return result\n\nn, m, k = map(int, input().split())\nprint(solve(n, m, k))"}
{"solution": "def is_magic_number(n):\n    patterns = ['1', '14', '144']\n    def search(s, index=0):\n        if index == len(s):\n            return True\n        for p in patterns:\n            if s.startswith(p, index):\n                if search(s, index + len(p)):\n                    return True\n        return False\n    return \"YES\" if search(str(n)) else \"NO\"\n\n# Example usage:\n# n = int(input())\n# print(is_magic_number(n))"}
{"solution": "def min_moves_to_corner(n, m, i, j, a, b):\n    def dist(x1, y1, x2, y2):\n        return abs(x1 - x2), abs(y1 - y2)\n    \n    corners = [(1, 1), (1, m), (n, 1), (n, m)]\n    res = []\n    \n    for x, y in corners:\n        dx, dy = dist(i, j, x, y)\n        \n        if dx % a == 0 and dy % b == 0:\n            moves = (dx // a + dy // b) % 2\n            res.append(moves)\n        else:\n            res.append(float('inf'))\n    \n    min_moves = min(res)\n    \n    if min_moves == float('inf'):\n        return \"Poor Inna and pony!\"\n    else:\n        return min_moves\n\n# Example check (uncomment to test)\n# print(min_moves_to_corner(5, 7, 1, 3, 2, 2))\n# print(min_moves_to_corner(5, 5, 2, 3, 1, 1))"}
{"solution": "def max_removals(s):\n    \"\"\"\n    Given a string s, returns the maximum number of characters that can be removed\n    such that a character s[i] can be removed if s[i-1] or s[i+1] is equal to prev letter in the alphabet.\n    \"\"\"\n    s = list(s)\n    removed = 0\n\n    for char_code in range(ord('z'), ord('a') - 1, -1):\n        prev_char = chr(char_code - 1)\n        current_char = chr(char_code)\n\n        i = 0\n        while i < len(s):\n            if s[i] == current_char:\n                if i > 0 and s[i - 1] == prev_char:\n                    del s[i]\n                    removed += 1\n                elif i < len(s) - 1 and s[i + 1] == prev_char:\n                    del s[i]\n                    removed += 1\n                else:\n                    i += 1\n            else:\n                i += 1\n\n    return removed\n\n# Reading input\nlength = int(input())\nstring = input()\n\n# Calculating result\nresult = max_removals(string)\n\n# Printing output\nprint(result)"}
{"solution": "import bisect\n\nn, k = map(int, input().split())\nbills = list(map(int, input().split()))\nq = int(input())\n\npossible_sums = set()\nfor i in range(n):\n    for count in range(1, k + 1):\n        possible_sums.add((count, bills[i] * count))\n\nsorted_sums = sorted(list(possible_sums))\n\nfor _ in range(q):\n    target = int(input())\n    min_bills = float('inf')\n    for i in range(n):\n        for count in range(1, k + 1):\n            remainder = target - (bills[i] * count)\n            if remainder == 0:\n                min_bills = min(min_bills, count)\n                break\n            if remainder > 0:\n                j = bisect.bisect_left(sorted_sums, (1, remainder))\n                while j < len(sorted_sums) and sorted_sums[j][1] == remainder:\n                    if sorted_sums[j][0] + count <= k:\n                        min_bills = min(min_bills, sorted_sums[j][0] + count)\n                    j += 1\n    print(min_bills if min_bills != float('inf') else -1)"}
{"solution": "import math\n\ndef find_min_time(s, x1, x2, t1, t2, p, d):\n    if t2 <= t1:\n        return abs(x2 - x1) * t2\n\n    def time_to_meet(x1, x2, p, d):\n        if d == 1:\n            if p < x1:\n                return (x1 - p) * t1\n            else:\n                return ((p - x1) + (s - p) + x2) * t1\n        else:\n            if p > x1:\n                return (p - x1) * t1\n            else:\n                return ((x1 - p) + p + (s - x2)) * t1\n\n    def time_to_destination(x1, x2, p, d):\n        meet_time = time_to_meet(x1, x2, p, d)\n        travel_time = abs(x2 - p) * t1\n        walk_time = abs(x2 - x1) * t2\n        return min(meet_time + travel_time, walk_time)\n\n    return time_to_destination(x1, x2, p, d)\n\n# Example inputs\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\nprint(find_min_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "import math\n\nn, x = map(int, input().split())\nprint(min(n, x // n) * 2 - max(1, int(math.sqrt(x))) % n)"}
{"solution": "def generate_password(n, k):\n    password = []\n    alphabet = [chr(97 + i) for i in range(k)]  # First k letters of the alphabet\n    \n    # Fill most of the password\n    for i in range(n - 1):\n        password.append(alphabet[i % k])\n    \n    # Add a different last character if needed\n    if n > k:\n        password.append(alphabet[(n - 1) % k])\n    else:\n        password.append(alphabet[k - 1])\n    \n    return ''.join(password)\n\n# Read input\nn, k = map(int, input().split())\n\n# Generate and print the password\nprint(generate_password(n, k))"}
{"solution": "def main():\n    n = int(input())\n    directions = input()\n    coordinates = list(map(int, input().split()))\n    \n    closest_collision_time = float('inf')\n    \n    for i in range(n - 1):\n        if directions[i] == 'R' or directions[i + 1] == 'L':\n            continue\n        \n        distance = coordinates[i + 1] - coordinates[i]\n        if directions[i] == 'L' and directions[i + 1] == 'L':\n            collision_time = distance // 2\n        else:\n            collision_time = distance\n        \n        closest_collision_time = min(closest_collision_time, collision_time)\n    \n    if closest_collision_time == float('inf'):\n        print(-1)\n    else:\n        print(closest_collision_time)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_seal_area(n, a, b, seals):\n    areas = sorted(min(x, y) * min(a // x, b // y) * (x * y) for x, y in seals for _ in range(2))\n    return 0 if len(areas) < 2 else areas[-1] + areas[-2]\n\nn, a, b = map(int, input().split())\nseals = [tuple(map(int, input().split())) for _ in range(n)]\nprint(max_seal_area(n, a, b, seals))"}
{"solution": "def find_odd_one_out(n, points):\n    x_counts, y_counts = {}, {}\n    \n    for x, y in points:\n        x_counts[x] = x_counts.get(x, 0) + 1\n        y_counts[y] = y_counts.get(y, 0) + 1\n\n    for x, y in points:\n        if x_counts[x] > n or y_counts[y] > n:\n            continue\n        else:\n            return x, y\n\nif __name__ == \"__main__\":\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(4 * n + 1)]\n    result = find_odd_one_out(n, points)\n    print(*result)"}
{"solution": "def max_digit_product(n):\n    if n < 10:\n        return n\n    digits = []\n    while n > 0:\n        digits.append(n % 10)\n        n //= 10\n    digits.sort(reverse=True)\n    product = 1\n    for d in digits:\n        if d == 0:\n            digits.remove(d)\n        else:\n            product *= d\n    if product == 1 and 0 in digits:\n        return max(digits)\n    while digits and digits[-1] == 1:\n        digits.pop()\n    if len(digits) >= 10:\n        digits[-10] -= 1\n        digits.extend([9] * 9)\n    else:\n        digits.extend([9] * (10 - len(digits)))\n    result = 1\n    for d in digits:\n        result *= d\n    return result\nn = int(input())\nprint(max_digit_product(n))"}
{"solution": "def find_min_k_to_win(e_votes):\n    n = len(e_votes)\n    e_votes.sort()\n\n    min_k = max(e_votes)\n    awruk_votes = 0\n    e_total_votes = sum(e_votes)\n\n    for i in range(n):\n        awruk_votes += (min_k - e_votes[i])\n        if awruk_votes > e_total_votes - e_votes[i]:\n            return min_k\n        elif awruk_votes == e_total_votes - e_votes[i]:\n            min_k += 1\n            awruk_votes -= e_votes[i]\n            awruk_votes += (min_k - e_votes[i])\n            if awruk_votes > e_total_votes - e_votes[i]:\n                return min_k\n\n    return min_k\n\nn = int(input())\na = list(map(int, input().split()))\n\nprint(find_min_k_to_win(a))"}
{"solution": "def count_operations_until_empty(s):\n    operations = 0\n    while True:\n        stack = []\n        delete = False\n        for i in range(len(s)):\n            if stack and s[i] != stack[-1]:\n                delete = True\n                stack.pop()\n            else:\n                stack.append(s[i])\n        if not delete:\n            break\n        s = ''.join(stack)\n        operations += 1\n    print(operations)\n\n# Example usage\ncount_operations_until_empty(\"aabb\")\ncount_operations_until_empty(\"aabcaa\")"}
{"solution": "import heapq\n\ndef find_min_product_triplets():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    # Initialize variables to track the smallest product and its count\n    min_product = float('inf')\n    min_product_count = 0\n    \n    # Use a min heap to keep track of the smallest elements seen so far\n    min_heap = []\n    \n    for i, value in enumerate(arr):\n        # Maintain a min heap of size 3 with current element\n        if len(min_heap) < 3:\n            heapq.heappush(min_heap, (-value, i))\n        else:\n            heapq.heappushpop(min_heap, (-value, i))\n        \n        # Calculate the product of the top 3 elements in the heap\n        if len(min_heap) == 3:\n            product = -min_heap[0][0] * -min_heap[1][0] * -min_heap[2][0]\n            \n            # Update the minimum product and its count\n            if product < min_product:\n                min_product = product\n                min_product_count = 0\n            \n            if product == min_product:\n                # Calculate the number of ways to form the triplet with the current minimum product\n                indices = [idx for _, idx in min_heap]\n                min_product_count += len(indices) * (len(indices) - 1) * (len(indices) - 2)\n                min_product_count //= 6  # Divide by 6 to avoid counting duplicates\n    \n    print(min_product_count)\n\nfind_min_product_triplets()"}
{"solution": "def min_cuts(n):\n    if n == 0: return 0\n    if n == 1: return 1\n    if n <= 3: return n\n    return n - 1 + (n + 1) % 2\n\n# Example usage:\n# n = int(input())\n# print(min_cuts(n))"}
{"solution": "def max_bank_balance(n):\n    str_n = str(n)\n    if n > 0:\n        return max(int(str_n[:-1]), int(str_n[1:]))\n    else:\n        if len(str_n) == 2:\n            return 0\n        else:\n            max_val = int(str_n)\n            for i in range(1, len(str_n)-1):\n                new_val = int(str_n[:i] + str_n[i+1:])\n                max_val = max(max_val, new_val)\n            return max_val\n\nn = int(input())\nprint(max_bank_balance(n))"}
{"solution": "def spinner_direction(start, end, n):\n    positions = {'v': 0, '<': 1, '^': 2, '>': 3}\n    start_pos = positions[start]\n    end_pos = positions[end]\n    \n    diff = (start_pos - end_pos) % 4\n    if diff == 1:\n        return 'cw'\n    elif diff == 3:\n        return 'ccw'\n    else:\n        return 'undefined'\n\n# Read input\nstart, end = input().split()\nn = int(input())\n\n# Print output\nprint(spinner_direction(start, end, n))"}
{"solution": "def remaining_dominoes(n, pushes):\n    pushes = 'L' + pushes + 'R'\n    count = 0\n    i = 1\n    while i < len(pushes) - 1:\n        if pushes[i] == '.':\n            if pushes[i - 1] == pushes[i + 1]:\n                count += 1\n            elif pushes[i - 1] != '.' and pushes[i + 1] != '.':\n                dist = i - (i - 1) + (i + 1) - i + 1\n                count += dist - 1\n        i += 1\n    return count\n\nn = int(input())\npushes = input()\nprint(remaining_dominoes(n, pushes))"}
{"solution": "def find_permutation(n, m, leaders):\n    # Initialize the permutation list with -1 values\n    perm = [-1] * n\n    \n    # Track the last position for each element\n    last_pos = {i: -1 for i in range(1, n + 1)}\n    \n    for i in range(m):\n        leader = leaders[i]\n        \n        if i == m - 1:\n            # Last leader can have any value not yet used\n            for j in range(n):\n                if perm[j] == -1:\n                    perm[leader - 1] = j + 1\n                    break\n        else:\n            next_leader = leaders[i + 1]\n            \n            if last_pos[leader] == -1:\n                # First time leader is seen, set its value\n                perm[leader - 1] = next_leader - leader\n                last_pos[leader] = leader - 1\n            else:\n                # Calculate the expected next leader based on previous value\n                expected_next_leader = (last_pos[leader] + perm[leader - 1]) % n + 1\n                \n                if expected_next_leader != next_leader:\n                    # If the expected next leader doesn't match, there's no valid permutation\n                    return -1\n                \n                # Update the last seen position of the leader\n                last_pos[leader] = (last_pos[leader] + perm[leader - 1]) % n\n    \n    # Fill remaining positions with unused values\n    used = set(perm)\n    for i in range(n):\n        if perm[i] == -1:\n            for val in range(1, n + 1):\n                if val not in used:\n                    perm[i] = val\n                    used.add(val)\n                    break\n    \n    return ' '.join(map(str, perm))\n\n# Read input\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\n# Print the result\nprint(find_permutation(n, m, leaders))"}
{"solution": "import sys\n\ndef read_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef solve():\n    a, k = read_ints()\n    s = str(a)\n    n = len(s)\n\n    # Precompute the minimum digit at each position for all suffixes\n    min_suffix = [n] * n\n    for i in reversed(range(n - 1)):\n        min_suffix[i] = min(i, min_suffix[i + 1])\n\n    result = list(s)\n    for i in range(n):\n        if k <= 0: break\n        j = min_suffix[i]\n        if i == j: continue  # No need to swap if the current digit is already the smallest in the suffix\n\n        # Find the farthest possible position we can swap with, within k swaps\n        while j > i and k < j - i:\n            j -= 1\n\n        # Swap the digits\n        result[i], result[j] = result[j], result[i]\n        k -= j - i\n\n    print(\"\".join(result))\n\nsolve()"}
{"solution": "def next_in_sequence(a, b, c, d):\n    # Check for arithmetic progression\n    if (b - a) == (c - b) == (d - c):\n        return d + (b - a)\n    \n    # Check for geometric progression\n    elif (b / a) == (c / b) == (d / c) and b % a == 0 and c % b == 0 and d % c == 0:\n        return int(d * (b / a))\n    \n    # Neither arithmetic nor geometric\n    else:\n        return 42\n\n# Read input\na, b, c, d = map(int, input().split())\n\n# Calculate and print the result\nprint(next_in_sequence(a, b, c, d))"}
{"solution": "def max_distance(n, colors):\n    max_dist = 0\n    color_index = {}\n\n    for i in range(n):\n        if colors[i] not in color_index:\n            color_index[colors[i]] = i\n        else:\n            for color, index in color_index.items():\n                if color != colors[i]:\n                    max_dist = max(max_dist, i - index)\n\n    return max_dist\n\n# Example usage\nn = int(input())\ncolors = list(map(int, input().split()))\nprint(max_distance(n, colors))"}
{"solution": "def find_santa_seat(n, m, k):\n    lane = (k - 1) // (m * 2) + 1\n    desk = ((k - 1) % (m * 2)) // 2 + 1\n    side = \"L\" if ((k - 1) % 2 == 0) else \"R\"\n    return f\"{lane} {desk} {side}\"\n\nn, m, k = map(int, input().split())\nprint(find_santa_seat(n, m, k))"}
{"solution": "def final_card_color(n, cards):\n    colors = {'B': 0, 'G': 0, 'R': 0}\n    for card in cards:\n        colors[card] += 1\n\n    parity_b, parity_g, parity_r = colors['B'] % 2, colors['G'] % 2, colors['R'] % 2\n\n    if parity_b + parity_g + parity_r == 1:\n        for color, parity in colors.items():\n            if parity % 2 == 1:\n                print(color)\n                break\n    elif parity_b + parity_g + parity_r == 0:\n        print('BG')\n    else:\n        print('R')\n\n# Reading input\nn = int(input())\ncards = input().strip()\nfinal_card_color(n, cards)"}
