{"solution": "def max_accordion_length(s):\n    max_length = -1\n    opening_bracket_index = -1\n    for i, char in enumerate(s):\n        if char == '[':\n            opening_bracket_index = i\n        elif char == ':':\n            if opening_bracket_index!= -1:\n                max_length = max(max_length, 4)\n                colon_index = i\n                max_vertical_bars = 0\n                for j in range(colon_index + 1, len(s)):\n                    if s[j] == '|':\n                        max_vertical_bars += 1\n                    elif s[j] == ':':\n                        max_length = max(max_length, 4 + 2 * max_vertical_bars)\n                        break\n                    elif s[j] == ']':\n                        max_length = max(max_length, 4 + max_vertical_bars)\n                        break\n    return max_length\n\ns = input()\nprint(max_accordion_length(s))"}
{"solution": "def digit_sum(n):\n    return sum(int(digit) for digit in str(n))\n\ndef largest_digit_sum(x):\n    max_sum = 0\n    max_num = 0\n    for i in range(x, 0, -1):\n        current_sum = digit_sum(i)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_num = i\n    return max_num\n\nx = int(input())\nprint(largest_digit_sum(x))"}
{"solution": "def count_digits(n):\n    return len(str(n))\n\ndef is_lucky_year(year):\n    count = 0\n    for digit in str(year):\n        if digit!= '0':\n            count += 1\n        if count > 1:\n            return False\n    return True\n\ndef next_lucky_year(year):\n    while True:\n        year += 1\n        if is_lucky_year(year):\n            return year\n\nyear = int(input())\nnext_year = next_lucky_year(year)\nprint(next_year - year)"}
{"solution": "import sys\n\ndef read_ints():\n    return map(int, sys.stdin.readline().split())\n\ndef main():\n    n, q = read_ints()\n    ranges = [tuple(read_ints()) for _ in range(q)]\n\n    dp = [[[0] * (n + 1) for _ in range(q)] for _ in range(q)]\n\n    for i in range(q):\n        for j in range(i + 1, q):\n            for k in range(ranges[i][0], ranges[i][1] + 1):\n                dp[i][j][k] = 1\n\n            for k in range(ranges[j][0], ranges[j][1] + 1):\n                dp[i][j][k] = 1\n\n            for k in range(1, n + 1):\n                dp[i][j][k] += dp[i][j][k - 1]\n\n    ans = 0\n    for i in range(q):\n        for j in range(i + 1, q):\n            for k in range(j + 1, q):\n                for l in range(k + 1, q):\n                    left = max(ranges[i][0], ranges[j][0], ranges[k][0], ranges[l][0])\n                    right = min(ranges[i][1], ranges[j][1], ranges[k][1], ranges[l][1])\n\n                    if left > right:\n                        continue\n\n                    ans = max(ans, dp[i][j][n] + dp[k][l][n] - dp[i][j][right] - dp[k][l][left - 1])\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_lucky(time):\n    return '7' in time\n\ndef prev_time(time, x):\n    h, m = map(int, time.split(':'))\n    m -= x\n    if m < 0:\n        h -= 1\n        m += 60\n    if h < 0:\n        h += 24\n    return f'{h:02d}:{m:02d}'\n\nx = int(input())\ntime = input()\nif is_lucky(time):\n    print(0)\nelse:\n    count = 0\n    while True:\n        time = prev_time(time, x)\n        count += 1\n        if is_lucky(time):\n            print(count)\n            break"}
{"solution": "n, pos, l, r = map(int, input().split())\n\nleft = min(pos, l)\nright = max(pos, r)\n\nleft_close = left - 1\nright_close = n - right\n\nleft_steps = left - 1\nright_steps = n - right\n\nif pos < l:\n    left_steps += r - pos\nelif pos > r:\n    right_steps += pos - l\n\nans = min(left_steps + left_close, right_steps + right_close)\n\nprint(ans)"}
{"solution": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    d = []\n    h = []\n    for _ in range(n):\n        di, hi = map(int, sys.stdin.readline().split())\n        d.append(di)\n        h.append(hi)\n\n    best = -1\n    for i in range(n):\n        if d[i] > h[i]:\n            best = i\n            break\n\n    if best == -1:\n        print(-1)\n        return\n\n    ans = 0\n    while x > 0:\n        if d[best] >= x:\n            ans += 1\n            break\n        else:\n            x -= d[best]\n            x += h[best]\n            ans += 1\n    print(ans)\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    solve()"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    day = 0\n    while True:\n        day += 1\n        n += m\n        if n > 10**18:\n            n = 10**18\n        if n < day:\n            break\n        n -= day\n    print(day)\n\nsolve()"}
{"solution": "def is_koutsu(hand):\n    return len(set([tile[0] for tile in hand])) == 1 and len(set([tile for tile in hand])) == 1\n\ndef is_shuntsu(hand):\n    numbers = sorted([int(tile[0]) for tile in hand])\n    return len(set([tile[1] for tile in hand])) == 1 and (numbers == list(range(numbers[0], numbers[0] + 3)) or numbers == [9, 1, 2] or numbers == [8, 9, 1])\n\ndef is_mentsu(hand):\n    return is_koutsu(hand) or is_shuntsu(hand)\n\ndef min_tiles_to_draw(hand):\n    if is_mentsu(hand):\n        return 0\n    else:\n        min_tiles = float('inf')\n        for i in range(1, 10):\n            for suit in ['m', 'p','s']:\n                new_hand = hand + [str(i) + suit]\n                new_hand.sort()\n                for j in range(len(new_hand) - 2):\n                    if is_mentsu(new_hand[j:j+3]):\n                        min_tiles = min(min_tiles, 1)\n        for i in range(1, 10):\n            for suit in ['m', 'p','s']:\n                for j in range(1, 10):\n                    for new_suit in ['m', 'p','s']:\n                        new_hand = hand + [str(i) + suit, str(j) + new_suit]\n                        new_hand.sort()\n                        for k in range(len(new_hand) - 2):\n                            if is_mentsu(new_hand[k:k+3]):\n                                min_tiles = min(min_tiles, 2)\n        return min_tiles\n\nhand = [input() for _ in range(3)]\nprint(min_tiles_to_draw(hand))"}
{"solution": "import sys\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(input())\n\ndef read_ints():\n    return map(int, input().split())\n\ndef read_list():\n    return list(map(int, input().split()))\n\ndef solve():\n    d = read_int()\n    n, m = read_ints()\n    sofas = []\n    for _ in range(d):\n        x1, y1, x2, y2 = read_ints()\n        sofas.append([(min(x1, x2), min(y1, y2)), (max(x1, x2), max(y1, y2))])\n\n    cnt_l, cnt_r, cnt_t, cnt_b = read_ints()\n\n    left = [0] * d\n    right = [0] * d\n    top = [0] * d\n    bottom = [0] * d\n\n    for i in range(d):\n        for j in range(d):\n            if i!= j:\n                if sofas[i][0][0] == sofas[j][0][0]:\n                    if sofas[i][0][1] < sofas[j][0][1]:\n                        bottom[i] += 1\n                    else:\n                        top[i] += 1\n                elif sofas[i][0][1] == sofas[j][0][1]:\n                    if sofas[i][0][0] < sofas[j][0][0]:\n                        right[i] += 1\n                    else:\n                        left[i] += 1\n\n    for i in range(d):\n        if left[i] == cnt_l and right[i] == cnt_r and top[i] == cnt_t and bottom[i] == cnt_b:\n            return i + 1\n\n    return -1\n\nprint(solve())"}
{"solution": "n = int(input())\nmin_days_off = (n - 1) // 7 * 2 + max(0, (n - 1) % 7 - 4)\nmax_days_off = n // 7 * 2 + min(2, n % 7)\nprint(min_days_off, max_days_off)"}
{"solution": "import math\n\nn, a, b, p, q = map(int, input().split())\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nlcm = (a * b) // gcd(a, b)\n\nred = n // a\nblue = n // b\nboth = n // lcm\n\nchocolates_red = red * p - both * min(p, q)\nchocolates_blue = blue * q - both * min(p, q)\n\nprint(chocolates_red + chocolates_blue + both * max(p, q))"}
{"solution": "def max_golden_trophies(n, trophies):\n    max_length = 0\n    current_length = 0\n    first_silver = -1\n    last_silver = -1\n    silver_count = 0\n\n    for i in range(n):\n        if trophies[i] == 'G':\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            if first_silver == -1:\n                first_silver = i\n            last_silver = i\n            silver_count += 1\n            current_length = 0\n\n    if silver_count == 0:\n        return max_length\n    elif silver_count == 1:\n        return max_length + 1\n    else:\n        max_length_with_swap = 0\n        left_length = 0\n        right_length = 0\n\n        for i in range(first_silver):\n            if trophies[i] == 'G':\n                left_length += 1\n\n        for i in range(last_silver + 1, n):\n            if trophies[i] == 'G':\n                right_length += 1\n\n        max_length_with_swap = max(max_length_with_swap, left_length + right_length + 1)\n\n        for i in range(first_silver + 1, last_silver):\n            if trophies[i] == 'G':\n                max_length_with_swap += 1\n\n        return max(max_length, max_length_with_swap)\n\n\nn = int(input())\ntrophies = input()\nprint(max_golden_trophies(n, trophies))"}
{"solution": "from collections import defaultdict, deque\n\ndef solve():\n    n, k = map(int, input().split())\n    main_courses = list(map(int, input().split()))\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        dependencies = list(map(int, input().split()))\n        in_degree[i] = dependencies[0]\n        if dependencies[0] > 0:\n            for dependency in dependencies[1:]:\n                graph[dependency].append(i)\n\n    queue = deque([course for course in main_courses if in_degree[course] == 0])\n    result = []\n    visited = set()\n\n    while queue:\n        course = queue.popleft()\n        if course not in visited:\n            result.append(course)\n            visited.add(course)\n            for neighbor in graph[course]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n\n    if len(result)!= len(visited):\n        print(-1)\n        return\n\n    print(len(result))\n    print(*result)\n\nsolve()"}
{"solution": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    p = list(map(int, sys.stdin.readline().split()))\n\n    s = []\n    b = []\n    for i in range(k):\n        while s and s[-1] < p[i]:\n            b.append(s.pop())\n        if s and s[-1] > p[i]:\n            print(-1)\n            return\n        s.append(p[i])\n\n    left = set(range(1, n + 1)) - set(p)\n    left = sorted(list(left), reverse=True)\n\n    while s:\n        if left and left[-1] > s[-1]:\n            print(-1)\n            return\n        while left and left[-1] < s[-1]:\n            b.append(left.pop())\n        b.append(s.pop())\n\n    while left:\n        b.append(left.pop())\n\n    print(*p, *b)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "a, b, c = map(int, input().split())\n\nif c == 0:\n    print(\"YES\" if a == b else \"NO\")\nelse:\n    print(\"YES\" if (b - a) % c == 0 and (b - a) // c >= 0 else \"NO\")"}
{"solution": "a = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\n\nif a == c and b >= 1 or a == c + 1 and b >= c + 1 or a + 1 == c and b >= c:\n    print(1)\nelse:\n    print(0)"}
{"solution": "n, k, t = map(int, input().split())\n\nif t <= k:\n    print(min(t, n))\nelif t <= n:\n    print(k)\nelse:\n    print(max(k - (t - n), 0))"}
{"solution": "def solve(s):\n    t = []\n    u = []\n    for char in s:\n        if not t or char < t[-1]:\n            t.append(char)\n        else:\n            while t and char > t[-1]:\n                u.append(t.pop())\n            t.append(char)\n    while t:\n        u.append(t.pop())\n    return ''.join(u)\n\ns = input()\nprint(solve(s))"}
{"solution": "def check_records(n, records):\n    for i in range(1, n):\n        plays_diff = records[i][0] - records[i-1][0]\n        clears_diff = records[i][1] - records[i-1][1]\n        if plays_diff < 0 or clears_diff < 0 or clears_diff > plays_diff:\n            return \"NO\"\n    return \"YES\"\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    records = [list(map(int, input().split())) for _ in range(n)]\n    print(check_records(n, records))"}
{"solution": "def is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome(time):\n    h, m = map(int, time.split(':'))\n    m += 1\n    if m == 60:\n        m = 0\n        h = (h + 1) % 24\n    return f'{h:02d}:{m:02d}'\n\ndef minutes_diff(time1, time2):\n    h1, m1 = map(int, time1.split(':'))\n    h2, m2 = map(int, time2.split(':'))\n    return (h2 - h1) * 60 + (m2 - m1)\n\ntime = input()\nif is_palindrome(time):\n    print(0)\nelse:\n    next_pal = next_palindrome(time)\n    while not is_palindrome(next_pal):\n        next_pal = next_palindrome(next_pal)\n    print(minutes_diff(time, next_pal))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmin_index = a.index(1)\nmax_index = a.index(n)\n\nmax_distance = max(abs(min_index - (n - 1)), abs(max_index - 0))\n\nfor i in range(n):\n    if a[i] == n:\n        continue\n    temp = a[i]\n    a[i] = a[min_index]\n    a[min_index] = temp\n    distance = abs(a.index(n) - a.index(1))\n    max_distance = max(max_distance, distance)\n\n    a[min_index] = a[i]\n    a[i] = temp\n\n    temp = a[i]\n    a[i] = a[max_index]\n    a[max_index] = temp\n    distance = abs(a.index(n) - a.index(1))\n    max_distance = max(max_distance, distance)\n\n    a[max_index] = a[i]\n    a[i] = temp\n\nprint(max_distance)"}
{"solution": "def is_s_palindrome(s):\n    s = s.lower()\n    return s == s[::-1]\n\ns = input()\nprint(\"TAK\" if is_s_palindrome(s) else \"NIE\")"}
{"solution": "from collections import Counter\n\ndef largest_permutation(a, b):\n    a = list(a)\n    b = list(b)\n    a_count = Counter(a)\n    b_count = Counter(b)\n    result = []\n\n    for digit in b:\n        if a_count[digit] > 0 and digit!= '0':\n            result.append(digit)\n            a_count[digit] -= 1\n        else:\n            break\n\n    for digit in sorted(a_count.keys(), reverse=True):\n        while a_count[digit] > 0:\n            result.append(digit)\n            a_count[digit] -= 1\n\n    return ''.join(result)\n\na = input()\nb = input()\nprint(largest_permutation(a, b))"}
{"solution": "def check_win(board, x, y):\n    directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n    for dx, dy in directions:\n        count = 0\n        for i in range(-4, 5):\n            nx, ny = x + i * dx, y + i * dy\n            if 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n                if count >= 5:\n                    return True\n            else:\n                count = 0\n    return False\n\ndef check_win_in_one_move(board):\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i] = board[i][:j] + 'X' + board[i][j+1:]\n                if check_win(board, i, j):\n                    return True\n                board[i] = board[i][:j] + '.' + board[i][j+1:]\n    return False\n\nboard = [input() for _ in range(10)]\nprint('YES' if check_win_in_one_move(board) else 'NO')"}
{"solution": "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [[0]*n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i, n):\n            if k > 0:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 1\n\n    if k > 0:\n        print(-1)\n    else:\n        for row in matrix:\n            print(*row)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\nx, y, z = map(float, input().split())\n\nexpressions = [\n    (x**y)**z, (x**z)**y, x**(y**z), x**(z**y),\n    (y**x)**z, (y**z)**x, y**(x**z), y**(z**x),\n    (z**x)**y, (z**y)**x, z**(x**y), z**(y**x)\n]\n\nmax_value = max(expressions)\nmax_index = expressions.index(max_value)\n\noptions = [\n    f\"x^{y}^{z}\", f\"x^{z}^{y}\", f\"(x^{y})^{z}\", f\"(x^{z})^{y}\",\n    f\"y^{x}^{z}\", f\"y^{z}^{x}\", f\"(y^{x})^{z}\", f\"(y^{z})^{x}\",\n    f\"z^{x}^{y}\", f\"z^{y}^{x}\", f\"(z^{x})^{y}\", f\"(z^{y})^{x}\"\n]\n\nprint(options[max_index])"}
{"solution": "def min_operations(n, s):\n    min_ops = n\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            if s[:i] * (n // i) == s:\n                min_ops = min(min_ops, i + 1)\n            if s[:i] * (n // i - 1) + s[:n % i] == s:\n                min_ops = min(min_ops, i + 2)\n    return min_ops\n\nn = int(input())\ns = input()\nprint(min_operations(n, s))"}
{"solution": "import sys\n\nn = int(input())\nfiles = {}\nexamples = []\nnon_examples = []\nfor _ in range(n):\n    name, type = input().split()\n    files[name] = int(type)\n    if type == '1':\n        examples.append(name)\n    else:\n        non_examples.append(name)\n\ne = len(examples)\nall_files = examples + non_examples\nused = set(all_files)\nmoves = []\n\nfor i in range(1, e + 1):\n    name = str(i)\n    if name not in used:\n        moves.append((name, name))\n    elif name not in examples:\n        moves.append((all_files[0], name))\n        all_files = all_files[1:]\n    else:\n        continue\n\nfor i in range(e + 1, n + 1):\n    name = str(i)\n    if name not in used:\n        moves.append((name, name))\n    elif name not in non_examples:\n        moves.append((all_files[0], name))\n        all_files = all_files[1:]\n    else:\n        continue\n\nfor i in range(1, e + 1):\n    name = str(i)\n    if name in non_examples:\n        moves.append((name, str(n + 1)))\n        moves.append((str(n + 1), name))\n\nfor i in range(e + 1, n + 1):\n    name = str(i)\n    if name in examples:\n        moves.append((name, str(n + 2)))\n        moves.append((str(n + 2), name))\n\nprint(len(moves))\nfor move in moves:\n    print(f'move {move[0]} {move[1]}')"}
{"solution": "def min_replacements(ticket):\n    first_half_sum = sum(int(digit) for digit in ticket[:3])\n    second_half_sum = sum(int(digit) for digit in ticket[3:])\n\n    if first_half_sum == second_half_sum:\n        return 0\n\n    min_replacements = float('inf')\n\n    for i in range(10):\n        for j in range(10):\n            new_first_half_sum = first_half_sum - int(ticket[0]) + i\n            new_second_half_sum = second_half_sum - int(ticket[3]) + j\n\n            if new_first_half_sum == new_second_half_sum:\n                min_replacements = min(min_replacements, 2)\n\n            elif new_first_half_sum == second_half_sum or new_second_half_sum == first_half_sum:\n                min_replacements = min(min_replacements, 1)\n\n    for i in range(1, 4):\n        for j in range(10):\n            new_first_half_sum = first_half_sum - int(ticket[i]) + j\n            if new_first_half_sum == second_half_sum:\n                min_replacements = min(min_replacements, 1)\n\n            new_second_half_sum = second_half_sum - int(ticket[i+3]) + j\n            if new_second_half_sum == first_half_sum:\n                min_replacements = min(min_replacements, 1)\n\n    return min_replacements\n\n\nticket = input()\nprint(min_replacements(ticket))"}
{"solution": "import math\n\ndef euler_totient(n):\n    result = n\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            while n % p == 0:\n                n //= p\n            result -= result // p\n        p += 1\n    if n > 1:\n        result -= result // n\n    return result\n\ndef solve():\n    m, x = map(int, input().split())\n    if m % 2 == 0:\n        print(m // 2 + 1 if x % 2 == 1 else 1)\n    else:\n        print(euler_totient(m))\n\nsolve()"}
{"solution": "def extended_gcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x, y = extended_gcd(b % a, a)\n        return gcd, y - (b // a) * x, x\n\ndef modinv(a, m):\n    gcd, x, y = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef powmod(a, b, m):\n    res = 1\n    a = a % m\n    while b > 0:\n        if b % 2 == 1:\n            res = (res * a) % m\n        b = b >> 1\n        a = (a * a) % m\n    return res\n\nn, k = map(int, input().split())\nmod = 10**6 + 3\ndenom = powmod(2, n, mod)\nnum = 1\nfor i in range(1, k):\n    num = (num * (denom - i + mod)) % mod\n    num = (num * modinv(i, mod)) % mod\nnum = (1 - num) % mod\ngcd = extended_gcd(num, denom)[0]\nprint((num // gcd) % mod, (denom // gcd) % mod)"}
{"solution": "n = int(input())\nlat = 0\nfor _ in range(n):\n    t, dir = input().split()\n    t = int(t)\n    if dir == \"North\":\n        if lat == -20000:\n            print(\"NO\")\n            exit()\n        lat += t\n        if lat > 0:\n            lat = 0\n    elif dir == \"South\":\n        if lat == 0 and t > 0:\n            lat -= t\n            if lat < -20000:\n                lat = -20000\n        elif lat!= 0:\n            print(\"NO\")\n            exit()\n    elif dir == \"East\" or dir == \"West\":\n        if lat!= 0 and lat!= -20000:\n            print(\"NO\")\n            exit()\nprint(\"YES\" if lat == 0 else \"NO\")"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\na1, b1, a2, b2, L, R = map(int, input().split())\n\nif a1 > a2:\n    a1, a2 = a2, a1\n    b1, b2 = b2, b1\n\nif b1 > b2:\n    k = math.ceil((b2 - b1) / a1)\n    b1 += a1 * k\n\nif b1 < b2:\n    print(0)\nelse:\n    d = lcm(a1, a2)\n    k = b1 - b2\n    if k % d!= 0:\n        print(0)\n    else:\n        k = k // d\n        a = a1 * a2 // d\n        l = (b1 - L) // a\n        r = (R - b1) // a\n        if l > r:\n            print(0)\n        else:\n            print(r - l + 1)"}
{"solution": "import math\n\nn, a, b = map(int, input().split())\n\ndef check(x):\n    if a % x == 0 and b % x == 0:\n        return a // x + b // x >= n\n    elif a % x == 0:\n        return a // x + (b - b % x) // x >= n\n    elif b % x == 0:\n        return (a - a % x) // x + b // x >= n\n    else:\n        return (a - a % x) // x + (b - b % x) // x >= n\n\nl, r = 1, min(a, b)\nwhile l < r:\n    mid = (l + r + 1) // 2\n    if check(mid):\n        l = mid\n    else:\n        r = mid - 1\n\nprint(l)"}
{"solution": "def is_valid_flag(n, m, flag):\n    colors = set()\n    for i in range(n):\n        color = flag[i][0]\n        for j in range(m):\n            if flag[i][j]!= color:\n                return False\n        colors.add(color)\n    if len(colors)!= 3:\n        return False\n    return True\n\ndef is_valid_stripe(n, m, flag):\n    stripe_height = n // 3\n    for i in range(3):\n        start = i * stripe_height\n        end = start + stripe_height\n        for j in range(start, end):\n            color = flag[j][0]\n            for k in range(m):\n                if flag[j][k]!= color:\n                    return False\n    return True\n\nn, m = map(int, input().split())\nflag = [input() for _ in range(n)]\n\nif is_valid_flag(n, m, flag) and is_valid_stripe(n, m, flag):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\nn = int(input())\n\nlayer = math.ceil((math.sqrt(6 * n + 1) - 1) / 6)\nstart = (layer - 1) * 6\nx, y = layer, -layer\n\nfor i in range(start, start + 6):\n    if i <= n:\n        if i < start + 1:\n            y += 1\n        elif i < start + 2:\n            x -= 1\n            y += 1\n        elif i < start + 3:\n            x -= 1\n        elif i < start + 4:\n            x -= 1\n            y -= 1\n        elif i < start + 5:\n            y -= 1\n        elif i < start + 6:\n            x += 1\n            y -= 1\n\nprint(x, y)"}
{"solution": "a, b, c = map(int, input().split())\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef can_deal_damage(a, b, c):\n    g = gcd(a, b)\n    return c % g == 0 and c // g <= a // g * b // g\n\nprint(\"Yes\" if can_deal_damage(a, b, c) else \"No\")"}
{"solution": "def is_coinciding_tracks(n, L, kefa, sasha):\n    kefa_diff = [(kefa[i] - kefa[i-1]) % L for i in range(n)]\n    kefa_diff.append((L - kefa[-1] + kefa[0]) % L)\n    sasha_diff = [(sasha[i] - sasha[i-1]) % L for i in range(n)]\n    sasha_diff.append((L - sasha[-1] + sasha[0]) % L)\n    return sorted(kefa_diff) == sorted(sasha_diff)\n\nn, L = map(int, input().split())\nkefa = list(map(int, input().split()))\nsasha = list(map(int, input().split()))\n\nif is_coinciding_tracks(n, L, kefa, sasha):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome(s):\n    max_length = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if not is_palindrome(substring):\n                max_length = max(max_length, len(substring))\n    return max_length\n\ns = input()\nprint(longest_non_palindrome(s))"}
{"solution": "n = int(input())\nrated = False\nmaybe = True\n\nratings_before = []\nratings_after = []\n\nfor _ in range(n):\n    a, b = map(int, input().split())\n    ratings_before.append(a)\n    ratings_after.append(b)\n\nfor i in range(n):\n    if ratings_after[i]!= ratings_before[i]:\n        rated = True\n        break\n\nfor i in range(n - 1):\n    if ratings_before[i] < ratings_before[i + 1]:\n        maybe = False\n        break\n\nif rated:\n    print(\"rated\")\nelif maybe:\n    print(\"maybe\")\nelse:\n    print(\"unrated\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ndistances = [float('inf')] * n\nzeros = [i for i, x in enumerate(a) if x == 0]\n\nfor i in range(n):\n    for zero in zeros:\n        distances[i] = min(distances[i], abs(i - zero))\n\nprint(*distances)"}
{"solution": "def count_cyclical_strings(n, s):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def count_strings(length):\n        count = 0\n        for i in range(1 << length):\n            binary = bin(i)[2:].zfill(length)\n            if s in binary:\n                count += 1\n        return count\n\n    def count_cyclical_strings(length):\n        count = 0\n        for i in range(1 << length):\n            binary = bin(i)[2:].zfill(length)\n            cyclical_binary = binary + binary\n            if s in cyclical_binary:\n                count += 1\n        return count\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def count_distinct_cyclical_strings(length):\n        count = 0\n        for i in range(1, length + 1):\n            if length % i == 0:\n                count += count_cyclical_strings(i) * (1 << (length - i))\n        return count\n\n    return count_distinct_cyclical_strings(n)\n\nn = int(input())\ns = input()\nprint(count_cyclical_strings(n, s))"}
{"solution": "import math\n\nn = int(input())\nvectors = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    length = math.sqrt(x**2 + y**2)\n    angle = math.atan2(y, x)\n    vectors.append((angle, i+1))\n\nvectors.sort()\n\nmin_angle = float('inf')\nmin_indices = None\nfor i in range(n):\n    angle1 = vectors[i][0]\n    angle2 = vectors[(i+1)%n][0]\n    if angle2 < angle1:\n        angle2 += 2 * math.pi\n    angle_diff = angle2 - angle1\n    if angle_diff < min_angle:\n        min_angle = angle_diff\n        min_indices = (vectors[i][1], vectors[(i+1)%n][1])\n\nprint(*min_indices)"}
{"solution": "import math\n\nd, k, a, b, t = map(int, input().split())\n\ndef calculate_time(distance, k, a, b, t):\n    full_trips = math.floor(distance / k)\n    remaining_distance = distance % k\n\n    time_driving = full_trips * k * a + remaining_distance * a\n    time_repairing = full_trips * t\n\n    time_walking = distance * b\n\n    time_driving_and_walking = float('inf')\n    for i in range(full_trips + 1):\n        driving_distance = i * k\n        walking_distance = distance - driving_distance\n        time = i * (k * a + t) + walking_distance * b\n        time_driving_and_walking = min(time_driving_and_walking, time)\n\n    return min(time_driving + time_repairing, time_walking, time_driving_and_walking)\n\nprint(calculate_time(d, k, a, b, t))"}
{"solution": "import math\n\nn, k = map(int, input().split())\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve():\n    if n % k == 0:\n        return [n // k] * k\n    if k == 1:\n        return [n]\n    if k > n:\n        return [-1]\n    if n < k * (k + 1) // 2:\n        return [-1]\n    g = math.floor(n / k)\n    seq = list(range(g, g + k))\n    if sum(seq) == n:\n        return seq\n    diff = n - sum(seq)\n    seq[-1] += diff\n    return seq\n\nprint(*solve())"}
{"solution": "n, m = map(int, input().split())\n\ncount = 0\nfor i in range(5):\n    count += min(n - i, m - (4 - i)) + max(0, min(n - i, m - (9 - i)) - 5)\n\nprint(count)"}
{"solution": "import sys\n\ndef read_ints():\n    return map(int, sys.stdin.readline().split())\n\ndef kadane(arr):\n    max_sum = 0\n    current_sum = 0\n    for num in arr:\n        current_sum = max(0, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef solve():\n    n, x = read_ints()\n    a = list(read_ints())\n\n    if x >= 0:\n        return kadane([x * num for num in a])\n\n    max_sum = 0\n    min_sum = 0\n    current_max_sum = 0\n    current_min_sum = 0\n    prefix_sum = 0\n    max_prefix_sum = 0\n    max_suffix_sum = 0\n    suffix_sum = 0\n\n    for i in range(n):\n        current_max_sum = max(0, current_max_sum + a[i])\n        max_sum = max(max_sum, current_max_sum)\n\n        current_min_sum = min(0, current_min_sum + a[i])\n        min_sum = min(min_sum, current_min_sum)\n\n        prefix_sum += a[i]\n        max_prefix_sum = max(max_prefix_sum, prefix_sum)\n\n        suffix_sum += a[n - i - 1]\n        max_suffix_sum = max(max_suffix_sum, suffix_sum)\n\n    return max(max_sum, x * min_sum, max_prefix_sum + x * (prefix_sum - max_prefix_sum), max_suffix_sum + x * (suffix_sum - max_suffix_sum))\n\nprint(solve())"}
{"solution": "import sys\n\ndef count_less_or_equal(mid, n, m):\n    count = 0\n    for i in range(1, n + 1):\n        count += min(mid // i, m)\n    return count\n\ndef find_kth_largest(n, m, k):\n    left, right = 1, n * m\n    while left < right:\n        mid = (left + right) // 2\n        if count_less_or_equal(mid, n, m) < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\nn, m, k = map(int, sys.stdin.readline().split())\nprint(find_kth_largest(n, m, n * m - k + 1))"}
{"solution": "import math\n\nk = int(input())\n\nlength = 0\ndigits = 1\nwhile True:\n    num_digits = 9 * (10 ** (digits - 1)) * digits\n    if length + num_digits >= k:\n        break\n    length += num_digits\n    digits += 1\n\nstart_num = 10 ** (digits - 1)\nindex = k - length - 1\nnum = start_num + index // digits\ndigit_index = index % digits\n\nprint(int(str(num)[digit_index]))"}
{"solution": "import sys\n\nn, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ns.sort()\nb.sort(reverse=True)\n\nmax_bourles = r\nfor i in range(n):\n    for j in range(m):\n        if s[i] < b[j]:\n            shares = r // s[i]\n            bourles = shares * b[j] + r % s[i]\n            max_bourles = max(max_bourles, bourles)\n\nprint(max_bourles)"}
{"solution": "def solve():\n    s = input()\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0 and s[:i] * (n // i) == s:\n            print(\"YES\")\n            print(s[:i] * ((n // i) // 2))\n            return\n    print(\"NO\")\n\nsolve()"}
{"solution": "import math\n\ndef solve():\n    n = int(input())\n    ans = []\n    for i in range(1, 64):\n        x = 2 ** i - n\n        if x >= 0 and (x & (x - 1) == 0):\n            ans.append(x + n)\n    if not ans:\n        print(-1)\n    else:\n        for num in sorted(ans):\n            print(num)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "from collections import Counter\n\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\nchar_count = Counter(s)\nbeauty = 0\n\nfor char, count in char_count.items():\n    if count > n // 2:\n        char_count[char] = n // 2\n        char_count[s.replace(char, '')] = count - n // 2\n\nfor i in range(n // 2):\n    max_beauty = 0\n    for char, count in char_count.items():\n        if count > 0:\n            max_beauty = max(max_beauty, b[i] if s[i] == char else b[n - i - 1] if s[n - i - 1] == char else 0)\n            if max_beauty > 0:\n                char_count[char] -= 1\n                break\n    beauty += max_beauty\n\nprint(beauty)"}
{"solution": "def can_weight(w, m):\n    return 'YES' if m % w == 0 or m > w and (m % w) * (w - 1) >= m else 'NO'\n\nw, m = map(int, input().split())\nprint(can_weight(w, m))"}
{"solution": "import sys\n\ndef solve(n, k):\n    if k > n:\n        return [-1] * k\n\n    max_val = n.bit_length() - 1\n    ans = []\n    while k > 0:\n        if n >= (1 << max_val) and k >= (n >> max_val):\n            ans.extend([max_val] * (n >> max_val))\n            n -= (1 << max_val) * (n >> max_val)\n            k -= (n >> max_val)\n        max_val -= 1\n    return ans\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    ans = solve(n, k)\n    if len(ans)!= k or sum(1 << x for x in ans)!= n:\n        print(\"No\")\n    else:\n        print(\"Yes\")\n        print(*ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef champagne_pyramid():\n    n, t = map(int, sys.stdin.readline().split())\n    pyramid = [[0] * i for i in range(1, n + 1)]\n    pyramid[0][0] = t\n\n    for i in range(n):\n        for j in range(len(pyramid[i])):\n            if pyramid[i][j] > 1:\n                excess = (pyramid[i][j] - 1) / 2\n                pyramid[i][j] = 1\n                if i < n - 1:\n                    pyramid[i + 1][j] += excess\n                    pyramid[i + 1][j + 1] += excess\n\n    return sum(1 for row in pyramid for glass in row if glass >= 1)\n\nprint(champagne_pyramid())"}
{"solution": "def calculate_area(n, points):\n    if n < 2:\n        return -1\n\n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n\n    x_coords.sort()\n    y_coords.sort()\n\n    if n == 2:\n        if x_coords[0] == x_coords[1] or y_coords[0] == y_coords[1]:\n            return -1\n        else:\n            return abs(x_coords[0] - x_coords[1]) * abs(y_coords[0] - y_coords[1])\n\n    if n == 3:\n        if x_coords[0] == x_coords[1] == x_coords[2] or y_coords[0] == y_coords[1] == y_coords[2]:\n            return -1\n        else:\n            return abs(x_coords[0] - x_coords[2]) * abs(y_coords[0] - y_coords[2])\n\n    if n == 4:\n        return abs(x_coords[0] - x_coords[3]) * abs(y_coords[0] - y_coords[3])\n\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\nprint(calculate_area(n, points))"}
{"solution": "import math\n\nn = int(input())\na = int(input())\nb = int(input())\n\ntotal_length = 2 * (2 * a + b)\nnum_bars = math.ceil(total_length / n)\n\nprint(num_bars)"}
{"solution": "def can_sort_array(n, a, swaps):\n    max_values = [0] * n\n    max_values[n - 1] = a[n - 1]\n    for i in range(n - 2, -1, -1):\n        if swaps[i] == '1':\n            max_values[i] = max_values[i + 1]\n        else:\n            max_values[i] = a[i]\n    for i in range(n - 1):\n        if a[i] > max_values[i + 1]:\n            return \"NO\"\n    return \"YES\"\n\nn = int(input())\na = list(map(int, input().split()))\nswaps = input()\nprint(can_sort_array(n, a, swaps))"}
{"solution": "def solve():\n    s = input()\n    n = int(s[:-1])\n    seat = s[-1]\n    seats = 'fedcba'\n    seat_index = seats.index(seat)\n    row_diff = n % 2\n    if row_diff == 0:\n        row_diff = -1\n    row = (n + row_diff + 3) // 2\n    time = (row - 1) * 6 + (row - 1)\n    if row_diff == -1:\n        time += 3 - seat_index\n    else:\n        time += 6 + 3 - seat_index\n    print(time)\n\nsolve()"}
{"solution": "def convert_to_decimal(digits, base):\n    decimal = 0\n    for i, digit in enumerate(reversed(digits)):\n        decimal += digit * (base ** i)\n    return decimal\n\nn, bx = map(int, input().split())\nx = list(map(int, input().split()))\n\nm, by = map(int, input().split())\ny = list(map(int, input().split()))\n\nx_decimal = convert_to_decimal(x, bx)\ny_decimal = convert_to_decimal(y, by)\n\nif x_decimal < y_decimal:\n    print('<')\nelif x_decimal > y_decimal:\n    print('>')\nelse:\n    print('=')"}
{"solution": "def mex(a):\n    b = sorted(a)\n    for i in range(len(b)):\n        if b[i]!= i:\n            return i\n    return len(b)\n\ndef nim_sum(a):\n    res = 0\n    for x in a:\n        res ^= x\n    return res\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(\"BitLGM\" if a[0] > 0 else \"BitAryo\")\nelif n == 2:\n    if a[0] == a[1]:\n        print(\"BitLGM\" if a[0] > 0 else \"BitAryo\")\n    else:\n        print(\"BitAryo\")\nelse:\n    print(\"BitLGM\" if nim_sum(a)!= 0 else \"BitAryo\")"}
{"solution": "from collections import defaultdict\nfrom math import sqrt\nfrom functools import reduce\n\ndef prime_factors(n):\n    factors = defaultdict(int)\n    while n % 2 == 0:\n        factors[2] += 1\n        n //= 2\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        while n % i == 0:\n            factors[i] += 1\n            n //= i\n    if n > 2:\n        factors[n] += 1\n    return factors\n\ndef count_ways(n, k, a):\n    k_factors = prime_factors(k)\n    prefix_factors = [defaultdict(int) for _ in range(n + 1)]\n    suffix_factors = [defaultdict(int) for _ in range(n + 1)]\n\n    for i in range(n):\n        factors = prime_factors(a[i])\n        for p, c in factors.items():\n            prefix_factors[i + 1][p] = prefix_factors[i][p] + c\n            suffix_factors[n - i - 1][p] = suffix_factors[n - i][p] + c\n\n    ways = 0\n    for i in range(n):\n        prefix = prefix_factors[i + 1]\n        suffix = suffix_factors[i + 1]\n        combined = {p: prefix[p] + suffix[p] for p in set(prefix) | set(suffix)}\n        if all(combined[p] >= c for p, c in k_factors.items()):\n            ways += 1\n\n    return ways\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(count_ways(n, k, a))"}
{"solution": "n, k = map(int, input().split())\ns = input()\n\ncolor_counts = {}\nfor color in s:\n    if color in color_counts:\n        color_counts[color] += 1\n    else:\n        color_counts[color] = 1\n\nmax_count = max(color_counts.values())\nif max_count <= k:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmin_val = min(a)\nmin_indices = [i for i, x in enumerate(a) if x == min_val]\n\nmin_distance = float('inf')\nfor i in range(len(min_indices) - 1):\n    min_distance = min(min_distance, min_indices[i + 1] - min_indices[i])\n\nprint(min_distance)"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nt, w, b = map(int, input().split())\n\ng = gcd(w, b)\nlcm = (w * b) // g\n\ncount = 0\nfor i in range(1, t + 1):\n    if i % lcm == 0:\n        count += 1\n\ng = gcd(count, t)\nprint(f\"{count // g}/{t // g}\")"}
{"solution": "x, y, z = map(int, input().split())\n\nif x > y + z:\n    print(\"+\")\nelif x + z < y:\n    print(\"-\")\nelif x == y:\n    print(\"0\")\nelif x + z == y or x == y + z:\n    print(\"?\")\nelse:\n    print(\"+\") if x > y else print(\"-\")"}
{"solution": "def solve():\n    n = int(input())\n    s = input()\n    x, y = map(int, input().split())\n\n    dx = s.count('R') - s.count('L')\n    dy = s.count('U') - s.count('D')\n\n    if dx == x and dy == y:\n        return 0\n\n    if abs(x - dx) > s.count('L') + s.count('R') or abs(y - dy) > s.count('U') + s.count('D'):\n        return -1\n\n    ans = float('inf')\n    for i in range(n):\n        for j in range(i, n):\n            cnt = [0, 0, 0, 0]\n            for k in range(i, j + 1):\n                cnt['RULD'.index(s[k])] += 1\n\n            for k in range(4):\n                for t in range(cnt[k] + 1):\n                    tmp = [0, 0, 0, 0]\n                    for l in range(4):\n                        tmp[l] = cnt[l]\n                    tmp[k] -= t\n                    tmp[(k + 2) % 4] += t\n\n                    ddx = tmp[0] + s[:i].count('R') + s[j + 1:].count('R') - tmp[1] - s[:i].count('L') - s[j + 1:].count('L')\n                    ddy = tmp[2] + s[:i].count('U') + s[j + 1:].count('U') - tmp[3] - s[:i].count('D') - s[j + 1:].count('D')\n\n                    if ddx == x and ddy == y:\n                        ans = min(ans, j - i + 1)\n\n    return ans if ans!= float('inf') else -1\n\nprint(solve())"}
{"solution": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    s = sys.stdin.readline().strip()\n\n    balance = 0\n    cnt = 0\n    seen = set()\n    seen.add(0)\n\n    for i in range(n):\n        if s[i] == '0':\n            balance += 1\n        else:\n            balance -= 1\n\n        if balance == x:\n            cnt += 1\n        seen.add(balance)\n\n    if x % balance!= 0:\n        print(cnt)\n        return\n\n    if x // balance < 0 and min(seen) <= x:\n        print(-1)\n        return\n\n    if x // balance > 0 and max(seen) >= x:\n        print(-1)\n        return\n\n    print(cnt)\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    solve()"}
{"solution": "import math\n\nn, k = map(int, input().split())\nn_str = str(n)\nk_str = '0' * k\n\ndef is_divisible(num):\n    return num.endswith(k_str)\n\ndef remove_digits(num, k):\n    count = 0\n    while not is_divisible(num):\n        num = num[:-1]\n        count += 1\n    return count\n\ndef remove_from_start(num, k):\n    count = 0\n    while not num.startswith('0' * k) and len(num) > k:\n        num = num[1:]\n        count += 1\n    return count\n\nprint(min(remove_digits(n_str, k), remove_from_start(n_str, k)))"}
{"solution": "n, m, k, x, y = map(int, input().split())\n\nif n == 1:\n    max_val = k // m + (k % m > 0)\n    min_val = k // m + (k % m > 0 and k % m!= 1)\n    times = k // m + (k % m >= y)\nelse:\n    cycle = 2 * n - 2\n    max_val = k // (m * cycle) + (k % (m * cycle) > 0)\n    min_val = k // (m * cycle) + (k % (m * cycle) > 0 and k % (m * cycle) >= m)\n    times = k // (m * cycle) + (k % (m * cycle) >= m * ((x - 1) % cycle + 1) + y)\n\nprint(max_val, min_val, times)"}
{"solution": "def beauty(s, n):\n    if n >= len(s):\n        return len(s)\n\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    max_count = max(char_count.values())\n    max_char = [char for char, count in char_count.items() if count == max_count]\n\n    if len(max_char) > 1:\n        return max_count + n\n\n    if max_count + n >= len(s):\n        return len(s)\n\n    return max_count + n\n\nn = int(input())\nkuro = input()\nshiro = input()\nkatie = input()\n\nkuro_beauty = beauty(kuro, n)\nshiro_beauty = beauty(shiro, n)\nkatie_beauty = beauty(katie, n)\n\nmax_beauty = max(kuro_beauty, shiro_beauty, katie_beauty)\n\nif kuro_beauty == max_beauty and shiro_beauty!= max_beauty and katie_beauty!= max_beauty:\n    print(\"Kuro\")\nelif shiro_beauty == max_beauty and kuro_beauty!= max_beauty and katie_beauty!= max_beauty:\n    print(\"Shiro\")\nelif katie_beauty == max_beauty and kuro_beauty!= max_beauty and shiro_beauty!= max_beauty:\n    print(\"Katie\")\nelse:\n    print(\"Draw\")"}
{"solution": "def calculate_days(c, v0, v1, a, l):\n    days = 0\n    total_pages_read = 0\n    current_speed = v0\n\n    while total_pages_read < c:\n        pages_to_read = min(current_speed, v1)\n        if total_pages_read + pages_to_read - l >= c:\n            pages_to_read = c - total_pages_read + l\n        total_pages_read += pages_to_read - l\n        days += 1\n        current_speed = min(current_speed + a, v1)\n\n    return days\n\nc, v0, v1, a, l = map(int, input().split())\nprint(calculate_days(c, v0, v1, a, l))"}
{"solution": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\nn = int(input())\nfor i in range(2, n):\n    if is_prime(i) and is_prime(n - i):\n        print(2)\n        print(i, n - i)\n        break\nelse:\n    print(3)\n    print(3, 3, n - 6)"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n\n    rows = [sum(row.count('*') for row in grid)]\n    cols = [sum(grid[i][j] == '*' for i in range(n)) for j in range(m)]\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*':\n                rows.append(rows[0] - rows[i] - cols[j] + 1)\n                cols.append(cols[0] - cols[j] - rows[i] + 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if rows[i] + cols[j] == rows[0] + cols[0]:\n                print(\"YES\")\n                print(i, j)\n                return\n\n    print(\"NO\")\n\nsolve()"}
{"solution": "n, m, a, b = map(int, input().split())\nmod = n % m\nadd = m - mod\ndestroy = mod\nadd_cost = add * a\ndestroy_cost = destroy * b\nmin_cost = min(add_cost, destroy_cost)\nif n < m:\n    print(min_cost)\nelse:\n    div = n // m\n    div_cost = div * m\n    div_add_cost = (div + 1) * m - n\n    div_add_cost = div_add_cost * a\n    div_destroy_cost = n - div_cost\n    div_destroy_cost = div_destroy_cost * b\n    print(min(min_cost, div_add_cost, div_destroy_cost))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nodd = [x for x in a if x % 2!= 0]\neven = [x for x in a if x % 2 == 0]\n\nodd.sort()\neven.sort(reverse=True)\n\nodd_sum = sum(odd)\neven_sum = sum(even)\n\nif odd_sum % 2 == 0:\n    if even_sum!= 0:\n        odd_sum -= odd[0]\n    else:\n        odd_sum -= odd[0] * 2\n\nprint(odd_sum + even_sum)"}
{"solution": "from collections import defaultdict\nfrom functools import lru_cache\n\nMOD = 10**9 + 7\n\ndef main():\n    n, T = map(int, input().split())\n    songs = defaultdict(list)\n    for _ in range(n):\n        t, g = map(int, input().split())\n        songs[g].append(t)\n\n    @lru_cache(None)\n    def dp(t, last, used):\n        if t == 0:\n            return 1\n        if t < 0:\n            return 0\n        res = 0\n        for g in range(1, 4):\n            if g!= last:\n                for i, song in enumerate(songs[g]):\n                    if not (used >> i) & 1:\n                        res += dp(t - song, g, used | (1 << i))\n                        res %= MOD\n        return res\n\n    print(dp(T, 0, 0))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef solve(m):\n    phi = [i for i in range(m + 1)]\n    for i in range(2, m + 1):\n        if phi[i] == i:\n            for j in range(i, m + 1, i):\n                phi[j] -= phi[j] // i\n\n    res = 0\n    for i in range(2, m + 1):\n        res += phi[i]\n        res %= MOD\n\n    res = (res * mod_inverse(m, MOD)) % MOD\n    res = (res + 1) % MOD\n    return res\n\nm = int(input())\nprint(solve(m))"}
{"solution": "import math\n\ndef count_pairs(l, r, x, y):\n    if x > y or y % x!= 0 or y < x * x:\n        return 0\n\n    count = 0\n    for i in range(1, int(math.sqrt(y // x)) + 1):\n        if y % (i * x) == 0:\n            j = y // (i * x)\n            a = i * x\n            b = j * x\n            if a >= l and a <= r:\n                count += 1\n            if a!= b and b >= l and b <= r:\n                count += 1\n    return count\n\nl, r, x, y = map(int, input().split())\nprint(count_pairs(l, r, x, y))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\na, b = map(int, input().split())\ng = gcd(a, b)\na //= g\nb //= g\n\nif a > b:\n    a, b = b, a\n\nif a == 1:\n    print(g - b % g)\nelse:\n    print(g * (b - 1) // (a - 1) - b)"}
{"solution": "n, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\ntotal_marks = sum(marks)\nadditional_marks = 0\n\nwhile (total_marks + additional_marks * k) / (n + additional_marks) < k:\n    additional_marks += 1\n\nprint(additional_marks)"}
{"solution": "import math\n\nn = int(input())\na = list(map(int, input().split()))\n\ndef check(d):\n    count = sum(1 for x in a if x / d > 0)\n    return count >= math.ceil(n / 2)\n\nfor d in range(-1000, 1001):\n    if d!= 0 and check(d):\n        print(d)\n        break\nelse:\n    print(0)"}
{"solution": "import math\n\nn = int(input())\nk = int(math.log10(n))\nmax_nines = 10**k\nmax_nines_count = 0\n\nfor i in range(1, n+1):\n    complement = max_nines - i\n    if complement > 0 and complement <= n and complement!= i:\n        max_nines_count += 1\n\nif max_nines > n:\n    max_nines_count = 0\n    for i in range(1, n+1):\n        complement = n - i\n        if complement > 0 and complement!= i:\n            max_nines_count += 1\n\nprint(max_nines_count)"}
{"solution": "import sys\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(a, b, c, d):\n    if a * b == c * d:\n        return 0, a, b, c, d\n    if a * b < c * d:\n        a, b, c, d = c, d, a, b\n    if a % 2 == 0 and b % 2 == 0:\n        return solve(a // 2, b // 2, c, d) if a * b // 2 >= c * d else solve(a, b // 2, c, d // 2)\n    if a % 2 == 0:\n        return solve(a // 2, b, c, d) if a * b // 2 >= c * d else solve(a, b // 2, c, d)\n    if b % 2 == 0:\n        return solve(a, b // 2, c, d) if a * b // 2 >= c * d else solve(a // 2, b, c, d)\n    if a % 3 == 0 and b % 3 == 0:\n        return solve(a // 3, b // 3, c, d) if a * b // 3 >= c * d else solve(a, b // 3, c, d // 3)\n    if a % 3 == 0:\n        return solve(a // 3, b, c, d) if a * b // 3 >= c * d else solve(a, b // 3, c, d)\n    if b % 3 == 0:\n        return solve(a, b // 3, c, d) if a * b // 3 >= c * d else solve(a // 3, b, c, d)\n    return -1, -1, -1, -1, -1\n\na, b = map(int, sys.stdin.readline().split())\nc, d = map(int, sys.stdin.readline().split())\n\nans = solve(a, b, c, d)\nif ans[0] == -1:\n    print(-1)\nelse:\n    print(ans[0])\n    print(ans[1], ans[2])\n    print(ans[3], ans[4])"}
{"solution": "x_p, y_p, x_v, y_v = map(int, input().split())\n\nif x_p + y_p <= max(x_v, y_v):\n    print(\"Polycarp\")\nelif x_p <= x_v and y_p <= y_v:\n    print(\"Polycarp\")\nelse:\n    print(\"Vasiliy\")"}
{"solution": "def days_in_month(month):\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return 31\n    elif month == 2:\n        return 28\n    else:\n        return 30\n\nm, d = map(int, input().split())\ndays = days_in_month(m)\nweeks = (days + d - 1) // 7\nprint(weeks + (1 if days % 7!= 0 and d > 1 else 0))"}
{"solution": "def count_binary_zeros(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef solve(a, b):\n    def dfs(n, cur, has_zero):\n        if cur > n:\n            return 0\n        res = 0\n        if count_binary_zeros(cur) == 1:\n            res += 1\n        if has_zero:\n            res += dfs(n, cur * 2, True)\n        res += dfs(n, cur * 2 + 1, has_zero)\n        return res\n\n    return dfs(b, 1, False) - dfs(a - 1, 1, False)\n\na, b = map(int, input().split())\nprint(solve(a, b))"}
{"solution": "import math\n\nn = int(input())\nprint(math.ceil(n * (n + 1) / (2 * math.floor(math.sqrt(n * (n + 1))))))"}
{"solution": "import math\n\ndef solve(n, k, S, a):\n    fact = [math.factorial(i) for i in range(1, 10)]\n    a = [min(x, 6) for x in a]\n    dp = [[0] * (k + 1) for _ in range(S + 1)]\n    dp[0] = [1] * (k + 1)\n    for x in a:\n        for s in range(S, x - 1, -1):\n            for j in range(k + 1):\n                dp[s][j] += dp[s - x][j]\n                if j > 0 and s - fact[x] >= 0:\n                    dp[s][j] += dp[s - fact[x]][j - 1]\n    return sum(dp[S])\n\nn, k, S = map(int, input().split())\na = list(map(int, input().split()))\nprint(solve(n, k, S, a))"}
{"solution": "import sys\n\ndef solve(n, k, a):\n    for x in a:\n        p = 0\n        while x:\n            if x % k:\n                if x % k!= 1:\n                    return \"NO\"\n                x //= k\n                p += 1\n            else:\n                x //= k\n                p += 1\n        if p > 60:\n            return \"NO\"\n    return \"YES\"\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(solve(n, k, a))"}
{"solution": "def get_divisors(n):\n    divisors = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(i, n + 1, i):\n            divisors[j] += 1\n    return divisors\n\ndef main():\n    a, b, c = map(int, input().split())\n    divisors = get_divisors(a * b * c)\n    result = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                result += divisors[i * j * k]\n                result %= 1073741824\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import deque\n\ndef is_solvable(puzzle):\n    flat_list = [item for sublist in puzzle for item in sublist]\n    inversions = 0\n    for i in range(len(flat_list)):\n        if flat_list[i] == 'X':\n            continue\n        for j in range(i + 1, len(flat_list)):\n            if flat_list[j]!= 'X' and flat_list[i] > flat_list[j]:\n                inversions += 1\n    return inversions % 2 == 0\n\ndef main():\n    bessie = [input() for _ in range(2)]\n    elsie = [input() for _ in range(2)]\n    print(\"YES\" if is_solvable(bessie) == is_solvable(elsie) else \"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\nk = input()\n\nresult = 0\npower = 0\n\nfor digit in reversed(k):\n    result += int(digit) * (n ** power)\n    power += 1\n\nprint(result)"}
{"solution": "def is_unimodal(arr):\n    increasing = decreasing = False\n    for i in range(len(arr) - 1):\n        if arr[i] < arr[i + 1]:\n            if decreasing:\n                return False\n            increasing = True\n        elif arr[i] > arr[i + 1]:\n            decreasing = True\n    return True\n\nn = int(input())\narr = list(map(int, input().split()))\n\nprint(\"YES\" if is_unimodal(arr) else \"NO\")"}
{"solution": "def solve():\n    n, k = map(int, input().split())\n    if k > n:\n        print(0)\n        return\n    if k == n:\n        print(1)\n        return\n    if n == 1:\n        print(1)\n        return\n    if n == 2:\n        print(2)\n        return\n    if n == 3:\n        if k == 1:\n            print(3)\n        else:\n            print(1)\n        return\n    if n % 2 == 0:\n        if k <= n // 2:\n            print(n)\n            return\n        else:\n            print(solve_helper(n, k))\n            return\n    else:\n        if k <= (n - 1) // 2 + 1:\n            print(n)\n            return\n        else:\n            print(solve_helper(n, k))\n            return\n\n\ndef solve_helper(n, k):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 1\n    if n % 2 == 0:\n        if k <= n // 2:\n            return n\n        else:\n            return solve_helper(n // 2, k - n // 2)\n    else:\n        if k <= (n - 1) // 2 + 1:\n            return n\n        else:\n            return solve_helper((n - 1) // 2, k - (n - 1) // 2 - 1)\n\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn, m, x, y, vx, vy = map(int, input().split())\n\nif vx == 0 and vy == 0:\n    print(-1)\nelif vx == 0:\n    if vy > 0:\n        print(x, m)\n    else:\n        print(x, 0)\nelif vy == 0:\n    if vx > 0:\n        print(n, y)\n    else:\n        print(0, y)\nelif abs(vx) == abs(vy):\n    if vx > 0 and vy > 0:\n        dx, dy = n - x, m - y\n    elif vx > 0 and vy < 0:\n        dx, dy = n - x, y\n    elif vx < 0 and vy > 0:\n        dx, dy = x, m - y\n    else:\n        dx, dy = x, y\n    if dx == dy:\n        if vx > 0 and vy > 0:\n            print(n, m)\n        elif vx > 0 and vy < 0:\n            print(n, 0)\n        elif vx < 0 and vy > 0:\n            print(0, m)\n        else:\n            print(0, 0)\n    else:\n        print(-1)\nelse:\n    if vx > 0:\n        x1 = n\n    else:\n        x1 = 0\n    if vy > 0:\n        y1 = m\n    else:\n        y1 = 0\n    dx = abs(x1 - x)\n    dy = abs(y1 - y)\n    g = gcd(dx, dy)\n    dx //= g\n    dy //= g\n    if vx > 0:\n        x2 = n\n    else:\n        x2 = 0\n    if vy > 0:\n        y2 = m\n    else:\n        y2 = 0\n    dx2 = abs(x2 - x1)\n    dy2 = abs(y2 - y1)\n    if dx2 % dx == 0 and dy2 % dy == 0:\n        print(x2, y2)\n    else:\n        print(-1)"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    # Check if the sum of the areas of the paintings is less than or equal to the area of the board\n    if a2 * b2 + a3 * b3 > a1 * b1:\n        return False\n\n    # Check all possible orientations of the paintings\n    for a2_rotated, b2_rotated in [(a2, b2), (b2, a2)]:\n        for a3_rotated, b3_rotated in [(a3, b3), (b3, a3)]:\n            # Check if the paintings can be placed side by side\n            if max(a2_rotated, a3_rotated) <= a1 and b2_rotated + b3_rotated <= b1:\n                return True\n            # Check if the paintings can be placed one on top of the other\n            if max(b2_rotated, b3_rotated) <= b1 and a2_rotated + a3_rotated <= a1:\n                return True\n\n    return False\n\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\nprint(\"YES\" if can_place_paintings(a1, b1, a2, b2, a3, b3) else \"NO\")"}
{"solution": "def solve():\n    b1, q, l, m = map(int, input().split())\n    bad = set(map(int, input().split()))\n\n    if q == 0:\n        return 1 if b1 not in bad and abs(b1) <= l else 0\n\n    if q == 1:\n        return \"inf\" if b1 not in bad and abs(b1) <= l else 0\n\n    if q < 0:\n        q = -q\n        b1 = -b1\n\n    if b1 > 0:\n        if b1 > l:\n            return 0\n        if b1 in bad:\n            return 0\n        count = 1\n        b1 *= q\n        while b1 <= l and b1 not in bad:\n            count += 1\n            b1 *= q\n        return count\n\n    if b1 < 0:\n        if -b1 > l:\n            return 0\n        if b1 in bad:\n            return 0\n        count = 1\n        b1 *= q\n        while -b1 <= l and b1 not in bad:\n            count += 1\n            b1 *= q\n        return count\n\n    return \"inf\" if 0 not in bad else 0\n\n\nprint(solve())"}
{"solution": "def get_frame_size(monitor):\n    min_x = float('inf')\n    max_x = float('-inf')\n    min_y = float('inf')\n    max_y = float('-inf')\n\n    for y, row in enumerate(monitor):\n        for x, pixel in enumerate(row):\n            if pixel == 'w':\n                min_x = min(min_x, x)\n                max_x = max(max_x, x)\n                min_y = min(min_y, y)\n                max_y = max(max_y, y)\n\n    return min_x, max_x, min_y, max_y\n\n\ndef is_valid_frame(monitor, min_x, max_x, min_y, max_y):\n    for y, row in enumerate(monitor):\n        for x, pixel in enumerate(row):\n            if pixel == 'w' and not (min_x <= x <= max_x and min_y <= y <= max_y):\n                return False\n            if pixel == '+' and not ((x == min_x or x == max_x or y == min_y or y == max_y) and min_x <= x <= max_x and min_y <= y <= max_y):\n                return False\n    return True\n\n\ndef draw_frame(monitor, min_x, max_x, min_y, max_y):\n    frame = [list(row) for row in monitor]\n    for y in range(min_y, max_y + 1):\n        for x in range(min_x, max_x + 1):\n            if x == min_x or x == max_x or y == min_y or y == max_y:\n                frame[y][x] = '+'\n    return frame\n\n\ndef solve(monitor):\n    min_x, max_x, min_y, max_y = get_frame_size(monitor)\n    size = max(max_x - min_x, max_y - min_y) + 1\n\n    for s in range(size, 0, -1):\n        for x in range(len(monitor[0]) - s + 1):\n            for y in range(len(monitor) - s + 1):\n                if is_valid_frame(monitor, x, x + s - 1, y, y + s - 1):\n                    return draw_frame(monitor, x, x + s - 1, y, y + s - 1)\n\n    return -1\n\n\ndef main():\n    n, m = map(int, input().split())\n    monitor = [list(input()) for _ in range(n)]\n\n    result = solve(monitor)\n    if result == -1:\n        print(-1)\n    else:\n        for row in result:\n            print(''.join(row))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def extended_gcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x, y = extended_gcd(b % a, a)\n        return gcd, y - (b // a) * x, x\n\ndef solve(n, a, b):\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd!= 0:\n        return None\n    x *= n // gcd\n    y *= n // gcd\n    k = a // gcd\n    x = x % k\n    if x < 0:\n        x += k\n    return x, y\n\nn = int(input())\na = int(input())\nb = int(input())\n\nresult = solve(n, a, b)\nif result is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(*result)"}
{"solution": "def int_to_words(n):\n    ones = ['', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight', 'nine']\n    teens = ['ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen','sixteen','seventeen', 'eighteen', 'nineteen']\n    tens = ['', '', 'twenty', 'thirty', 'forty', 'fifty','sixty','seventy', 'eighty', 'ninety']\n\n    if n < 10:\n        return ones[n]\n    elif n < 20:\n        return teens[n - 10]\n    elif n < 100:\n        return tens[n // 10] + ('' if n % 10 == 0 else '-' + ones[n % 10])\n\nn = int(input())\nprint(int_to_words(n))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmax_erase = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if a[j] - a[i] > j - i + 1:\n            max_erase = max(max_erase, j - i - 1)\n        elif j == n - 1 and a[j] - a[i] == j - i + 1:\n            max_erase = max(max_erase, j - i)\n\nprint(max_erase)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ntotal_problems = sum(a)\nhalf_problems = total_problems / 2\ncurrent_problems = 0\n\nfor i, problems in enumerate(a):\n    current_problems += problems\n    if current_problems >= half_problems:\n        print(i + 1)\n        break"}
{"solution": "import sys\nfrom collections import deque\n\nN = int(input())\nA = [list(map(int, input().split())) for _ in range(N)]\n\npos = [[-1, -1] for _ in range(N * N + 1)]\nfor i in range(N):\n    for j in range(N):\n        pos[A[i][j]] = [i, j]\n\ndx = [1, 1, 2, 2, -1, -1, -2, -2]\ndy = [2, -2, 1, -1, 2, -2, 1, -1]\n\ndef bfs(start, piece):\n    q = deque([(start, 0, 0)])\n    visited = set([start])\n    while q:\n        x, y, step = q.popleft()\n        if x!= start:\n            return step, 1\n        for i in range(1, N * N + 1):\n            nx, ny = pos[i]\n            if piece == 0:\n                if abs(nx - pos[x][0]) == 2 and abs(ny - pos[x][1]) == 1 or abs(nx - pos[x][0]) == 1 and abs(ny - pos[x][1]) == 2:\n                    if (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        q.append((i, 0, step + 1))\n            elif piece == 1:\n                if abs(nx - pos[x][0]) == abs(ny - pos[x][1]):\n                    if (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        q.append((i, 1, step + 1))\n            else:\n                if nx == pos[x][0] or ny == pos[x][1]:\n                    if (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        q.append((i, 2, step + 1))\n    return N * N, N * N\n\ndef solve():\n    ans = N * N, N * N\n    for piece in range(3):\n        step, replace = bfs(1, piece)\n        for i in range(2, N * N + 1):\n            nstep, nreplace = bfs(i, piece)\n            step += nstep\n            replace += nreplace\n        ans = min(ans, (step, replace))\n    print(*ans)\n\nsolve()"}
{"solution": "import math\n\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\ndef get_floor_and_block(num, n, m, k):\n    block = math.ceil(num / (m * k))\n    floor = math.ceil((num - (block - 1) * m * k) / k)\n    return block, floor\n\na_block, a_floor = get_floor_and_block(a, n, m, k)\nb_block, b_floor = get_floor_and_block(b, n, m, k)\n\nblocks_diff = abs(a_block - b_block)\nfloors_diff = abs(a_floor - b_floor)\n\nblocks_diff_clockwise = min(blocks_diff, n - blocks_diff)\n\nlift_time = 10 + abs(a_floor - 1)\nstairs_time = 5 * floors_diff\n\ntime_clockwise = blocks_diff_clockwise * 15 + lift_time + stairs_time\ntime_counter_clockwise = (n - blocks_diff_clockwise) * 15 + lift_time + stairs_time\n\nprint(min(time_clockwise, time_counter_clockwise))"}
{"solution": "s = input()\nif s[-6:] >= '1000000' and '1' in s[:-6]:\n    print('yes')\nelse:\n    print('no')"}
{"solution": "def solve(s):\n    result = []\n    target = 'abcdefghijklmnopqrstuvwxyz'\n    target_index = 0\n\n    for char in s:\n        if char >= target[target_index]:\n            result.append(char)\n            if char == target[target_index]:\n                target_index += 1\n                if target_index == len(target):\n                    break\n\n    if target_index!= len(target):\n        return -1\n\n    remaining_chars = list(s)\n    for char in result:\n        remaining_chars.remove(char)\n\n    for i in range(len(result)):\n        next_char = chr(ord(result[i]) + 1)\n        while next_char <= 'z':\n            remaining_chars = [char for char in remaining_chars if char!= next_char]\n            result[i] = next_char\n            next_char = chr(ord(next_char) + 1)\n\n    return ''.join(result + remaining_chars)\n\n\ns = input()\nprint(solve(s))"}
{"solution": "import math\n\nn, m, r, k = map(int, input().split())\n\nif k == 1:\n    print(1 / ((n - r + 1) * (m - r + 1)))\nelse:\n    ans = 0\n    for i in range(1, min(r, k) + 1):\n        x = min(math.ceil(k / i), n)\n        y = min(math.ceil(k / i), m)\n        ans = max(ans, (k * (k - 1) / 2) / ((x - r + 1) * (y - r + 1)) + k / ((n - r + 1) * (m - r + 1)))\n    print(ans)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\nnegatives = sum(1 for x in a if x < 0)\nzeroes = sum(1 for x in a if x == 0)\n\nif (negatives + zeroes) % 2 == 0:\n    print(*[-x - 1 if x > 0 else x for x in a])\nelse:\n    min_abs = min(abs(x) for x in a)\n    if min_abs == 0:\n        print(*a)\n    else:\n        print(*[-x - 1 if x > 0 and abs(x)!= min_abs else x for x in a])"}
{"solution": "import math\n\ndef prime_factors(n):\n    factors = []\n    for i in range(2, int(math.sqrt(n)) + 1):\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef divisors(n):\n    factors = prime_factors(n)\n    unique_factors = set(factors)\n    divisors = [1]\n    for factor in unique_factors:\n        new_divisors = []\n        for divisor in divisors:\n            for _ in range(factors.count(factor)):\n                new_divisors.append(divisor * factor)\n        divisors.extend(new_divisors)\n    return sorted(divisors)\n\nn, k = map(int, input().split())\ndivs = divisors(n)\nprint(divs[k-1] if k <= len(divs) else -1)"}
{"solution": "from collections import defaultdict\nfrom itertools import permutations\n\ndef get_rotations(cube):\n    rotations = set()\n    for i in range(6):\n        for j in range(4):\n            rotations.add(cube[i])\n            cube[i] = cube[(i + 1) % 6]\n    return rotations\n\ndef get_permutations(cubes, length):\n    permutations = set()\n    for p in permutations(cubes, length):\n        for r in permutations([get_rotations(cube) for cube in p]):\n            permutations.add(tuple(sorted([next(iter(r[i])) for i in range(length)])))\n    return permutations\n\ndef get_max_number(cubes):\n    max_number = 0\n    for length in range(1, len(cubes) + 1):\n        for p in get_permutations(cubes, length):\n            if '0' in p and p[0] == '0':\n                continue\n            number = int(''.join(p))\n            if number > max_number and can_make_all_numbers(cubes, number):\n                max_number = number\n    return max_number\n\ndef can_make_all_numbers(cubes, number):\n    digits = defaultdict(int)\n    for cube in cubes:\n        for digit in get_rotations(cube):\n            digits[digit] += 1\n    for i in range(1, number + 1):\n        digits_i = defaultdict(int)\n        for digit in str(i):\n            digits_i[digit] += 1\n        for digit, count in digits_i.items():\n            if digits[digit] < count:\n                return False\n    return True\n\nn = int(input())\ncubes = []\nfor _ in range(n):\n    cubes.append(list(map(int, input().split())))\n\nprint(get_max_number(cubes))"}
{"solution": "import math\n\nn, k = map(int, input().split())\npower_of_ten = 10 ** k\nlcm = (n * power_of_ten) // math.gcd(n, power_of_ten)\nprint(lcm)"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n\n    if any(a[i][j] and not (a[i+1][j] or a[i][j+1] or a[i+1][j+1]) for i in range(n-1) for j in range(m-1)):\n        print(-1)\n        return\n\n    ans = []\n    for i in range(n-1, 0, -1):\n        for j in range(m-1, 0, -1):\n            if a[i][j]:\n                ans.append((i, j))\n                a[i][j] = a[i-1][j] = a[i][j-1] = a[i-1][j-1] = 0\n\n    for i in range(n-1, 0, -1):\n        if a[i][0]:\n            ans.append((i, 1))\n            a[i][0] = a[i-1][0] = 0\n\n    for j in range(m-1, 0, -1):\n        if a[0][j]:\n            ans.append((1, j))\n            a[0][j] = a[0][j-1] = 0\n\n    if a[0][0]:\n        ans.append((1, 1))\n\n    print(len(ans))\n    for x, y in ans:\n        print(x, y)\n\nsolve()"}
{"solution": "import sys\n\ndef read_input():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef calculate_probability(r, s, p):\n    total = r + s + p\n    if total == 3:\n        return [1/3, 1/3, 1/3]\n    elif total == 4:\n        if r == 2:\n            return [1/2, 1/4, 1/4]\n        elif s == 2:\n            return [1/4, 1/2, 1/4]\n        else:\n            return [1/4, 1/4, 1/2]\n    else:\n        if r == 1:\n            return [0, (s - 1) / (total - 1), p / (total - 1)]\n        elif s == 1:\n            return [r / (total - 1), 0, (p - 1) / (total - 1)]\n        else:\n            return [(r - 1) / (total - 1), s / (total - 1), 0]\n\ndef main():\n    r, s, p = read_input()\n    prob = calculate_probability(r, s, p)\n    print(' '.join(map(str, prob)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_time_together(l1, r1, l2, r2, k):\n    start = max(l1, l2)\n    end = min(r1, r2)\n    time_together = max(0, end - start + 1)\n    if k >= start and k <= end:\n        time_together -= 1\n    return time_together\n\nl1, r1, l2, r2, k = map(int, input().split())\nprint(calculate_time_together(l1, r1, l2, r2, k))"}
{"solution": "import sys\n\ndef main():\n    input = sys.stdin.readline\n\n    N, M = map(int, input().split())\n    A = []\n    B = []\n    C = []\n    D = []\n    E = []\n    F = []\n\n    for _ in range(N):\n        a, b, c = map(int, input().split())\n        A.append(a)\n        B.append(b)\n        C.append(c)\n\n    for _ in range(M):\n        d, e, f = map(int, input().split())\n        D.append(d)\n        E.append(e)\n        F.append(f)\n\n    def check(x):\n        for i in range(N):\n            if A[i] <= x <= B[i] and C[i] == 0:\n                return False\n        return True\n\n    def check2(y):\n        for i in range(M):\n            if E[i] <= y <= F[i] and D[i] == 0:\n                return False\n        return True\n\n    def calc(x):\n        left = -10**9\n        right = 10**9\n        for i in range(M):\n            if D[i] == x:\n                left = max(left, E[i])\n                right = min(right, F[i])\n        if left > right:\n            return 0\n        return right - left\n\n    def calc2(y):\n        left = -10**9\n        right = 10**9\n        for i in range(N):\n            if C[i] == y:\n                left = max(left, A[i])\n                right = min(right, B[i])\n        if left > right:\n            return 0\n        return right - left\n\n    left = 0\n    right = 10**9\n    for i in range(N):\n        if C[i] == 0:\n            left = max(left, A[i])\n            right = min(right, B[i])\n\n    if left > right:\n        print(\"INF\")\n        return\n\n    if not check(left) or not check(right):\n        print(\"INF\")\n        return\n\n    ans = 0\n    for i in range(left, right + 1):\n        ans += calc(i)\n\n    up = 0\n    down = 10**9\n    for i in range(M):\n        if D[i] == 0:\n            up = max(up, E[i])\n            down = min(down, F[i])\n\n    if up > down:\n        print(\"INF\")\n        return\n\n    if not check2(up) or not check2(down):\n        print(\"INF\")\n        return\n\n    ans2 = 0\n    for i in range(up, down + 1):\n        ans2 += calc2(i)\n\n    print(ans + ans2)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "t, s, x = map(int, input().split())\n\nif t == x or (x - t) % s in [0, 1] and (x - t) // s > 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef solve():\n    n = int(input())\n    segments = []\n    for i in range(n):\n        l, r = map(int, input().split())\n        segments.append((l, r, i + 1))\n\n    segments.sort()\n\n    min_r = sys.maxsize\n    min_idx = -1\n    for l, r, idx in segments:\n        if r <= min_r:\n            min_r = r\n            min_idx = idx\n        elif l >= min_r:\n            print(idx, min_idx)\n            return\n\n    print(-1, -1)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "n = int(input())\ns = input()\n\ncounts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\nfor char in s:\n    if char in counts:\n        counts[char] += 1\n\ntarget_count = (n + 3) // 4\nfor char in counts:\n    counts[char] = target_count - counts[char]\n\nif any(count < 0 for count in counts.values()):\n    print(\"===\")\nelse:\n    result = []\n    for char in s:\n        if char == '?':\n            for c in counts:\n                if counts[c] > 0:\n                    result.append(c)\n                    counts[c] -= 1\n                    break\n        else:\n            result.append(char)\n    print(\"\".join(result))"}
{"solution": "def check_win(board, symbol):\n    # Check rows\n    for row in board:\n        if row.count(symbol) == 3 and '.' in row:\n            return True\n\n    # Check columns\n    for col in range(4):\n        column = [row[col] for row in board]\n        if column.count(symbol) == 3 and '.' in column:\n            return True\n\n    # Check diagonals\n    diagonal1 = [board[i][i] for i in range(4)]\n    diagonal2 = [board[i][3-i] for i in range(4)]\n    if (diagonal1.count(symbol) == 3 and '.' in diagonal1) or (diagonal2.count(symbol) == 3 and '.' in diagonal2):\n        return True\n\n    return False\n\n\ndef main():\n    board = [input() for _ in range(4)]\n    print(\"YES\" if check_win(board, 'x') else \"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_divide_array(n, a):\n    total_sum = sum(a)\n    if total_sum % 2!= 0:\n        return False\n\n    target_sum = total_sum // 2\n    prefix_sum = 0\n    for i in range(n):\n        if prefix_sum == target_sum:\n            return True\n        prefix_sum += a[i]\n\n    for i in range(n):\n        new_prefix_sum = prefix_sum - a[i]\n        if new_prefix_sum == target_sum:\n            return True\n        new_prefix_sum += a[i]\n\n    return False\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nif can_divide_array(n, a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\na.sort()\nb.sort()\n\ni = 0\nj = 0\nincreasing = True\n\nwhile i < n and j < k:\n    if a[i] == 0:\n        a[i] = b[j]\n        j += 1\n    elif i > 0 and a[i] <= a[i-1]:\n        increasing = False\n        break\n    i += 1\n\nprint(\"Yes\" if not increasing else \"No\")"}
{"solution": "x, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\nandrew = min(x, a)\ndmitry = min(max(y - (a - andrew), 0), a - andrew + b)\nmichal = min(z, a - andrew - dmitry + b - dmitry + c)\n\nif andrew + dmitry + michal >= x + y + z:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def is_accident_possible():\n    parts = [list(map(int, input().split())) for _ in range(4)]\n\n    for i in range(4):\n        if parts[i][3] == 1 and (parts[i][0] == 1 or parts[i][1] == 1 or parts[i][2] == 1):\n            return \"YES\"\n        if parts[i][3] == 1 and (parts[(i-1)%4][2] == 1 or parts[(i+1)%4][0] == 1):\n            return \"YES\"\n\n    return \"NO\"\n\nprint(is_accident_possible())"}
{"solution": "def get_key_positions():\n    return {\n        '0': (0, 0), '1': (0, 1), '2': (0, 2),\n        '3': (1, 0), '4': (1, 1), '5': (1, 2),\n        '6': (2, 0), '7': (2, 1), '8': (2, 2), '9': (3, 1)\n    }\n\ndef get_finger_movements(number, key_positions):\n    movements = []\n    for i in range(len(number) - 1):\n        x1, y1 = key_positions[number[i]]\n        x2, y2 = key_positions[number[i + 1]]\n        movement = (x2 - x1, y2 - y1)\n        movements.append(movement)\n    return movements\n\ndef has_same_movements(number, key_positions):\n    movements = get_finger_movements(number, key_positions)\n    for i in range(10 ** len(number)):\n        new_number = str(i).zfill(len(number))\n        if new_number == number:\n            continue\n        if get_finger_movements(new_number, key_positions) == movements:\n            return True\n    return False\n\ndef main():\n    n = int(input())\n    number = input()\n    key_positions = get_key_positions()\n    if has_same_movements(number, key_positions):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nn, f = map(int, sys.stdin.readline().split())\ndays = []\nfor _ in range(n):\n    k, l = map(int, sys.stdin.readline().split())\n    days.append((k, l))\n\ndays.sort(key=lambda x: min(x[0], x[1]) - min(x[0]*2, x[1]), reverse=True)\n\nsold = 0\nfor i, (k, l) in enumerate(days):\n    if i < f:\n        sold += min(k*2, l)\n    else:\n        sold += min(k, l)\n\nprint(sold)"}
{"solution": "import math\n\nn, k = map(int, input().split())\n\nmessiness = 0\nswaps = min(k, n // 2)\n\nmessiness += swaps * (2 * n - 2 * swaps - 1)\n\nprint(messiness)"}
{"solution": "import math\n\ndef solve():\n    n, m, k, l = map(int, input().split())\n    if m > n:\n        print(-1)\n        return\n    if l > n - k:\n        print(-1)\n        return\n    if m * (n - k) < l:\n        print(-1)\n        return\n    if m >= n - k:\n        print(math.ceil(l / m))\n    else:\n        print(math.ceil((n - k) / m))\n\nsolve()"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    def count_black_cells_in_square(x, y, size):\n        count = 0\n        for i in range(x, x + size):\n            for j in range(y, y + size):\n                if grid[i][j] == 'B':\n                    count += 1\n        return count\n\n    def is_square_possible(x, y, size):\n        for i in range(x, x + size):\n            for j in range(y, y + size):\n                if grid[i][j] == 'W':\n                    return False\n        return True\n\n    min_cells = float('inf')\n    for size in range(1, min(n, m) + 1):\n        for x in range(n - size + 1):\n            for y in range(m - size + 1):\n                if is_square_possible(x, y, size):\n                    cells_to_paint = size * size - count_black_cells_in_square(x, y, size)\n                    min_cells = min(min_cells, cells_to_paint)\n\n    if min_cells == float('inf'):\n        return -1\n    return min_cells\n\n\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\nprint(min_cells_to_paint(n, m, grid))"}
{"solution": "n = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\nif sum(x)!= sum(y):\n    print(\"No\")\nelse:\n    print(\"Yes\")"}
{"solution": "n = int(input())\nangles = list(map(int, input().split()))\n\ntotal_angle = sum(angles)\nmin_diff = float('inf')\ncurr_angle = 0\n\nfor angle in angles:\n    curr_angle += angle\n    diff = abs(curr_angle - (total_angle - curr_angle))\n    min_diff = min(min_diff, diff)\n\nprint(min_diff)"}
{"solution": "MOD = 10**9 + 7\n\ndef pow_mod(a, b):\n    res = 1\n    while b:\n        if b & 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b >>= 1\n    return res\n\ndef main():\n    n, m = map(int, input().split())\n    ans = 0\n    for i in range(m + 1):\n        ans = (ans + ((-1) ** i) * pow_mod(m - i, n) * pow_mod(m, i) * pow_mod(pow_mod(m - i + 1, MOD - 2), i)) % MOD\n    print((ans + MOD) % MOD)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\nn = int(input())\n\nif n == 1:\n    print(-1)\nelse:\n    found = False\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if (n * n - i * i) % n == 0:\n            m = i\n            k = (n * n - i * i) // n\n            print(m, k)\n            found = True\n            break\n    if not found:\n        print(-1)"}
{"solution": "def check_remainders(n, k):\n    for i in range(2, int(k**0.5) + 1):\n        if n % i == 0:\n            return \"No\"\n    for i in range(2, k + 1):\n        if n % i == n % (i - 1):\n            return \"No\"\n    return \"Yes\"\n\nn, k = map(int, input().split())\nprint(check_remainders(n, k))"}
{"solution": "import sys\n\na = sys.stdin.readline().strip()\nb = sys.stdin.readline().strip()\n\nif len(a) > len(b):\n    print('>')\nelif len(a) < len(b):\n    print('<')\nelse:\n    if a > b:\n        print('>')\n    elif a < b:\n        print('<')\n    else:\n        print('=')"}
{"solution": "MOD = 10**9 + 7\n\ndef solve():\n    n, p = map(int, input().split())\n    c = list(map(int, input().split()))\n\n    dp = [[[[0, 0] for _ in range(2)] for _ in range(2)] for _ in range(n + 1)]\n    dp[0][0][0][0] = 1\n\n    for i in range(n):\n        for j in range(2):\n            for k in range(2):\n                for l in range(2):\n                    if dp[i][j][k][l] == 0:\n                        continue\n                    if c[i] == -1:\n                        for x in range(2):\n                            for y in range(i + 1, n + 1):\n                                dp[y][x][k ^ x][l ^ (y - i - 1) * x] += dp[i][j][k][l]\n                                dp[y][x][k ^ x][l ^ (y - i - 1) * x] %= MOD\n                            dp[i + 1][x][k ^ x][l] += dp[i][j][k][l]\n                            dp[i + 1][x][k ^ x][l] %= MOD\n                    elif c[i] == j:\n                        for y in range(i + 1, n + 1):\n                            dp[y][j][k ^ j][l ^ (y - i - 1) * j] += dp[i][j][k][l]\n                            dp[y][j][k ^ j][l ^ (y - i - 1) * j] %= MOD\n                        dp[i + 1][j][k ^ j][l] += dp[i][j][k][l]\n                        dp[i + 1][j][k ^ j][l] %= MOD\n\n    ans = 0\n    for i in range(2):\n        ans += dp[n][i][0][p]\n        ans %= MOD\n    print(ans)\n\nsolve()"}
{"solution": "n, a, b, c = map(int, input().split())\n\ndef min_cost(n, a, b, c):\n    min_val = float('inf')\n    for i in range(4):\n        cost = 0\n        k = (4 - n % 4) % 4\n        if k == 1:\n            cost = min(a, b - a, c - 2 * a)\n        elif k == 2:\n            cost = min(2 * a, b, c - a)\n        elif k == 3:\n            cost = min(3 * a, 2 * b, c)\n        min_val = min(min_val, cost)\n    return min_val\n\nprint(min_cost(n, a, b, c))"}
{"solution": "from collections import defaultdict, deque\n\ndef dfs(graph, visited, stack, vertex):\n    visited[vertex] = True\n    for neighbor in graph[vertex]:\n        if not visited[neighbor]:\n            if dfs(graph, visited, stack, neighbor):\n                return True\n        elif stack[neighbor]:\n            return True\n    stack[vertex] = True\n    return False\n\ndef is_acyclic(graph, n):\n    visited = [False] * n\n    stack = [False] * n\n    for vertex in range(n):\n        if not visited[vertex]:\n            if dfs(graph, visited, stack, vertex):\n                return False\n    return True\n\ndef remove_edge(graph, u, v):\n    graph[u].remove(v)\n    return graph\n\ndef main():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        edges.append((u, v))\n\n    if is_acyclic(graph, n):\n        print(\"YES\")\n        return\n\n    for u, v in edges:\n        new_graph = remove_edge(graph, u, v)\n        if is_acyclic(new_graph, n):\n            print(\"YES\")\n            return\n\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef read_ints():\n    return map(int, sys.stdin.readline().split())\n\ndef main():\n    n, m = read_ints()\n    antennas = [tuple(read_ints()) for _ in range(n)]\n\n    antennas.sort()\n\n    dp = [float('inf')] * (m + 1)\n    dp[0] = 0\n\n    for x, s in antennas:\n        for i in range(m, -1, -1):\n            if i - s - 1 >= 0:\n                dp[i] = min(dp[i], dp[i - s - 1] + max(0, i - x))\n            if i + s + 1 <= m:\n                dp[i + s + 1] = min(dp[i + s + 1], dp[i] + max(0, x - i))\n\n    print(dp[m])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_weight(W, cnt):\n    max_weight = 0\n    for i in range(8, 0, -1):\n        max_weight += min(W // i, cnt[i-1]) * i\n        W -= min(W // i, cnt[i-1]) * i\n    return max_weight\n\nW = int(input())\ncnt = list(map(int, input().split()))\nprint(max_weight(W, cnt))"}
{"solution": "import sys\n\ndef solve():\n    n, L = map(int, sys.stdin.readline().split())\n    c = list(map(int, sys.stdin.readline().split()))\n\n    ans = float('inf')\n    for mask in range(1 << n):\n        cost = 0\n        volume = 0\n        for i in range(n):\n            if (mask >> i) & 1:\n                volume += (1 << (i + 1)) - 1\n                cost += c[i]\n        if volume >= L:\n            ans = min(ans, cost)\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    mex = 1\n    for i in range(n):\n        if a[i] >= mex:\n            mex += 1\n    print(mex)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_lucky_ticket(n, ticket):\n    for i in range(1, n):\n        left_sum = sum(int(digit) for digit in ticket[:i])\n        right_sum = sum(int(digit) for digit in ticket[i:])\n        if left_sum == right_sum:\n            return True\n        if left_sum < right_sum:\n            break\n\n    for i in range(1, n):\n        right_sum = sum(int(digit) for digit in ticket[-i:])\n        left_sum = sum(int(digit) for digit in ticket[:-i])\n        if left_sum == right_sum:\n            return True\n        if left_sum < right_sum:\n            break\n\n    for segment_sum in range(1, sum(int(digit) for digit in ticket)):\n        segment_count = 0\n        current_sum = 0\n        for digit in ticket:\n            current_sum += int(digit)\n            if current_sum == segment_sum:\n                segment_count += 1\n                current_sum = 0\n            elif current_sum > segment_sum:\n                break\n        else:\n            if current_sum == 0 and segment_count > 1:\n                return True\n\n    return False\n\n\nn = int(input())\nticket = input()\nprint(\"YES\" if is_lucky_ticket(n, ticket) else \"NO\")"}
{"solution": "username = input()\ndistinct_chars = set(username)\nif len(distinct_chars) % 2 == 0:\n    print(\"CHAT WITH HER!\")\nelse:\n    print(\"IGNORE HIM!\")"}
{"solution": "n, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\nmax_diff = 0\nfor i in range(n):\n    diff = 0\n    test_tabs = 0\n    social_tabs = 0\n    for j in range(n):\n        if (j - i) % k!= 0:\n            if tabs[j] == 1:\n                test_tabs += 1\n            else:\n                social_tabs += 1\n    diff = abs(test_tabs - social_tabs)\n    max_diff = max(max_diff, diff)\n\nprint(max_diff)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n, c0, c1 = map(int, read_input().split())\n    if c0 == c1:\n        print(n * c0 * (n.bit_length() - 1))\n        return\n\n    if c0 < c1:\n        c0, c1 = c1, c0\n        swap = True\n    else:\n        swap = False\n\n    total_cost = 0\n    nodes = 1\n    while nodes < n:\n        total_cost += nodes * c1\n        nodes *= 2\n\n    remaining = n - nodes // 2\n    total_cost += remaining * (c1 + c0)\n\n    if swap:\n        c0, c1 = c1, c0\n\n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve():\n    n, a, x, b, y = map(int, input().split())\n    if (a < x and b < y and (a > b or x < y)) or (a > x and b > y and (a < b or x > y)):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n\nsolve()"}
{"solution": "def get_unlucky_years(x, y, start, end):\n    unlucky_years = set()\n    a = 0\n    while x ** a <= end:\n        b = 0\n        while x ** a + y ** b <= end:\n            if x ** a + y ** b >= start:\n                unlucky_years.add(x ** a + y ** b)\n            b += 1\n        a += 1\n    return unlucky_years\n\ndef get_golden_age(x, y, start, end):\n    unlucky_years = get_unlucky_years(x, y, start, end)\n    max_golden_age = 0\n    current_golden_age = 0\n    for year in range(start, end + 1):\n        if year in unlucky_years:\n            max_golden_age = max(max_golden_age, current_golden_age)\n            current_golden_age = 0\n        else:\n            current_golden_age += 1\n    return max(max_golden_age, current_golden_age)\n\nx, y, start, end = map(int, input().split())\nprint(get_golden_age(x, y, start, end))"}
{"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef min_tax(n):\n    if is_prime(n):\n        return 1\n    if n % 2 == 0:\n        return 2\n    return 3\n\nn = int(input())\nprint(min_tax(n))"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    result = []\n    current_word = []\n    current_consonants = set()\n\n    for char in word:\n        if char in vowels:\n            current_word.append(char)\n            current_consonants.clear()\n        else:\n            if char in current_consonants and len(current_consonants) > 1 and len(current_word) - len(current_consonants) >= 2:\n                result.append(''.join(current_word))\n                current_word = [char]\n                current_consonants = {char}\n            else:\n                current_word.append(char)\n                current_consonants.add(char)\n\n    if current_word:\n        result.append(''.join(current_word))\n\n    return''.join(result)\n\n\nword = input()\nprint(fix_typos(word))"}
{"solution": "import sys\n\nn, m, k = map(int, sys.stdin.readline().split())\nx, s = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\nb = list(map(int, sys.stdin.readline().split()))\nc = list(map(int, sys.stdin.readline().split()))\nd = list(map(int, sys.stdin.readline().split()))\n\nab = sorted(zip(a, b))\ncd = sorted(zip(c, d))\n\nmin_time = n * x\ni = 0\nfor ai, bi in ab:\n    while i < k and bi + d[i] <= s:\n        i += 1\n    if i > 0:\n        i -= 1\n        ci, di = cd[i]\n        min_time = min(min_time, max(0, n - ci) * ai + bi + di)\n    else:\n        min_time = min(min_time, n * ai + bi)\n\ni = 0\nfor ci, di in cd:\n    while i < m and di + b[i] <= s:\n        i += 1\n    if i > 0:\n        i -= 1\n        ai, bi = ab[i]\n        min_time = min(min_time, max(0, n - ci) * ai + bi + di)\n    else:\n        min_time = min(min_time, max(0, n - ci) * x + di)\n\nprint(min_time)"}
{"solution": "import sys\n\ndef solve():\n    n, k, M = map(int, sys.stdin.readline().split())\n    t = list(map(int, sys.stdin.readline().split()))\n\n    t.sort()\n    task_times = [0] * (k + 1)\n    for i in range(1, k + 1):\n        task_times[i] = task_times[i - 1] + t[i - 1]\n\n    dp = [0] * (n * (k + 1) + 1)\n    for i in range(1, n + 1):\n        for j in range(k, -1, -1):\n            for x in range(i * (j + 1), -1, -1):\n                y = x + j + 1\n                if y > n * (k + 1):\n                    break\n                dp[y] = max(dp[y], dp[x] + task_times[j] + (1 if j == k else 0))\n\n    ans = 0\n    for i in range(n * (k + 1) + 1):\n        if dp[i] <= M:\n            ans = max(ans, i)\n\n    print(ans)\n\nsolve()"}
{"solution": "MOD = 998244353\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef mod_choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    numerator = mod_factorial(n)\n    denominator = (mod_factorial(k) * mod_factorial(n - k)) % MOD\n    return (numerator * mod_inverse(denominator, MOD)) % MOD\n\ndef mod_catalan(n):\n    if n % 2 == 1:\n        return 0\n    n = n // 2\n    return (mod_choose(2 * n, n) * mod_inverse(n + 1, MOD)) % MOD\n\ndef solve(n):\n    if n % 2 == 1:\n        return 0\n    n = n // 2\n    return (mod_catalan(n) * mod_choose(n, n // 2) * mod_factorial(n) * mod_factorial(n)) % MOD\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def calculate_position(n, m, k):\n    # Calculate the total number of cells\n    total_cells = n * m\n\n    # Calculate the number of full rows\n    full_rows = m // 2\n\n    # Calculate the remaining cells after full rows\n    remaining_cells = total_cells - full_rows * n * 2\n\n    # Calculate the number of rows Lara has moved in the remaining cells\n    rows_moved = k // (m - 1)\n\n    # Calculate the remaining moves after moving full rows\n    remaining_moves = k % (m - 1)\n\n    # Calculate the current row\n    current_row = rows_moved + 1 if remaining_moves == 0 else rows_moved + 2 - (remaining_moves % 2)\n\n    # Calculate the current column\n    current_column = 1 if remaining_moves == 0 else remaining_moves + 1 if rows_moved % 2 == 0 else m - remaining_moves\n\n    # Adjust the current row and column if Lara has moved beyond the full rows\n    if k >= full_rows * (m - 1) * 2:\n        current_row = n - (k - full_rows * (m - 1) * 2) // (m - 1) * 2 - 1\n        current_column = m if (k - full_rows * (m - 1) * 2) % (m - 1) == 0 else (k - full_rows * (m - 1) * 2) % (m - 1) + 1\n\n    return current_row, current_column\n\n\nn, m, k = map(int, input().split())\ncurrent_row, current_column = calculate_position(n, m, k)\nprint(current_row, current_column)"}
{"solution": "import math\n\ndef prime_factors(n):\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef solve():\n    x = int(input())\n    factors = prime_factors(x)\n    a = 1\n    b = x\n    for i in range(2, int(math.sqrt(x)) + 1):\n        if x % i == 0:\n            if math.lcm(i, x // i) == x:\n                a = i\n                b = x // i\n                break\n    print(a, b)\n\nsolve()"}
{"solution": "a = int(input())\nb = int(input())\nc = int(input())\n\nratio_a = 1\nratio_b = 2\nratio_c = 4\n\nmin_a = a // ratio_a\nmin_b = b // ratio_b\nmin_c = c // ratio_c\n\nmin_fruits = min(min_a, min_b, min_c)\n\ntotal_fruits = min_fruits * (ratio_a + ratio_b + ratio_c)\n\nprint(total_fruits)"}
{"solution": "n = int(input())\nratings = sorted(map(int, input().split()))\n\nprint(\"YES\" if ratings[n-1] > ratings[n] else \"NO\")"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef is_coprime(a, b):\n    return gcd(a, b) == 1\n\ndef make_coprime_array(arr):\n    result = [arr[0]]\n    count = 0\n    for i in range(1, len(arr)):\n        if is_coprime(result[-1], arr[i]):\n            result.append(arr[i])\n        else:\n            count += 1\n            result.append(1)\n            result.append(arr[i])\n    return count, result\n\nn = int(input())\narr = list(map(int, input().split()))\ncount, result = make_coprime_array(arr)\nprint(count)\nprint(*result)"}
{"solution": "import math\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ng = a[0]\nfor i in range(1, n):\n    g = gcd(g, a[i])\n\nans = g\nfor i in range(n):\n    a[i] //= g\n    a[i] %= n\n\ng = a[0]\nfor i in range(1, n):\n    g = gcd(g, a[i])\n\nprint(g * ans)"}
{"solution": "import sys\n\nx = int(input())\nans = []\nwhile x!= 0 and len(ans) < 40:\n    if x & 1:\n        ans.append(0)\n        x += 1\n    else:\n        n = x.bit_length() - 1\n        ans.append(n)\n        x ^= (1 << n) - 1\n\nprint(len(ans))\nfor i in range(0, len(ans), 2):\n    print(ans[i], end=' ')"}
{"solution": "import math\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nmin_hours = float('inf')\nfor bucket in a:\n    if k % bucket == 0:\n        min_hours = min(min_hours, k // bucket)\n\nprint(min_hours)"}
{"solution": "from collections import deque\n\ndef can_reach_target(n, k, line):\n    start = line.index('G')\n    target = line.index('T')\n    visited = set([start])\n\n    queue = deque([start])\n\n    while queue:\n        current = queue.popleft()\n\n        if current == target:\n            return True\n\n        for jump in [current - k, current + k]:\n            if 0 <= jump < n and line[jump]!= '#' and jump not in visited:\n                queue.append(jump)\n                visited.add(jump)\n\n    return False\n\nn, k = map(int, input().split())\nline = input().strip()\n\nprint(\"YES\" if can_reach_target(n, k, line) else \"NO\")"}
{"solution": "import math\n\ndef calculate_xw(y1, y2, yw, xb, yb, r):\n    if yb - r <= y1 or yb + r >= y2:\n        return -1\n\n    xw = (xb * (y2 - y1)) / (2 * (yw - yb))\n    y_reflect = (y1 + y2) / 2\n\n    if y_reflect - r <= yb <= y_reflect + r:\n        return -1\n\n    if yb < y_reflect:\n        y_reflect -= r\n    else:\n        y_reflect += r\n\n    xw = (xb * (y_reflect - yb)) / (yw - yb)\n\n    return xw\n\ny1, y2, yw, xb, yb, r = map(float, input().split())\nxw = calculate_xw(y1, y2, yw, xb, yb, r)\n\nif xw == -1:\n    print(\"-1\")\nelse:\n    print(\"{:.10f}\".format(xw))"}
{"solution": "b, d, s = map(int, input().split())\n\nif b == d == s:\n    print(0)\nelif b == d + 1 and s == d:\n    print(0)\nelif b == d and s == d + 1:\n    print(0)\nelif b == d and s < d:\n    print(d - s)\nelif b == s and d < b:\n    print(b - d)\nelif d == s and b < d:\n    print(d - b)\nelif b > d and s > d:\n    print(max(b - d, s - d))\nelif b < d and s < d:\n    print(d - b + d - s)\nelse:\n    print(max(abs(b - d), abs(d - s)))"}
{"solution": "import math\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    min_x = 1\n    max_x = 10**9\n    min_y = 1\n    max_y = 10**9\n\n    for i in range(n - 1):\n        if a[i + 1] - a[i] > 0:\n            if a[i + 1] - a[i] == 1:\n                min_y = max(min_y, 2)\n            else:\n                min_x = max(min_x, (a[i + 1] - a[i]))\n        else:\n            if a[i] - a[i + 1] == 1:\n                min_y = max(min_y, 2)\n            else:\n                min_x = max(min_x, (a[i] - a[i + 1]))\n\n    for i in range(n - 1):\n        if a[i + 1] - a[i] > 0:\n            if a[i + 1] - a[i] == 1:\n                max_x = min(max_x, (a[i] - 1) // (min_y - 1) + 1)\n            else:\n                max_x = min(max_x, (a[i] - 1) // (a[i + 1] - a[i]) + 1)\n        else:\n            if a[i] - a[i + 1] == 1:\n                max_x = min(max_x, (a[i] - 1) // (min_y - 1) + 1)\n            else:\n                max_x = min(max_x, (a[i] - 1) // (a[i] - a[i + 1]) + 1)\n\n    for i in range(n - 1):\n        if a[i + 1] - a[i] > 0:\n            if a[i + 1] - a[i] == 1:\n                max_y = min(max_y, a[i] + (max_x - 1) * min_x)\n            else:\n                max_y = min(max_y, a[i] + (max_x - 1) * (a[i + 1] - a[i]))\n        else:\n            if a[i] - a[i + 1] == 1:\n                max_y = min(max_y, a[i] + (max_x - 1) * min_x)\n            else:\n                max_y = min(max_y, a[i] + (max_x - 1) * (a[i] - a[i + 1]))\n\n    for i in range(n - 1):\n        if a[i + 1] - a[i] > 0:\n            if a[i + 1] - a[i] == 1:\n                min_x = max(min_x, (a[i] - 1) // (max_y - 1) + 1)\n            else:\n                min_x = max(min_x, (a[i] - 1) // (a[i + 1] - a[i]) + 1)\n        else:\n            if a[i] - a[i + 1] == 1:\n                min_x = max(min_x, (a[i] - 1) // (max_y - 1) + 1)\n            else:\n                min_x = max(min_x, (a[i] - 1) // (a[i] - a[i + 1]) + 1)\n\n    if min_x > max_x or min_y > max_y:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(min_x, min_y)\n\nsolve()"}
{"solution": "def longest_subsequence(a, b):\n    i = 0\n    j = 0\n    result = []\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            result.append(a[i])\n            i += 1\n            j += 1\n        else:\n            i += 1\n    if not result:\n        return '-'\n    return ''.join(result)\n\na = input()\nb = input()\nprint(longest_subsequence(a, b))"}
{"solution": "n = int(input())\ns = input()\nminus_count = s.count('-')\nplus_count = n - minus_count\nstones = 0\nfor i in range(n):\n    if s[i] == '-':\n        stones -= 1\n    else:\n        stones += 1\n    if stones < minus_count:\n        stones += 1\n        minus_count -= 1\n    elif stones > 0 and minus_count > 0:\n        stones -= 1\n        minus_count -= 1\nprint(stones)"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nglass_bottles = n // b\nremaining_money = n % b\nadditional_glass_bottles = remaining_money // (b - c)\nadditional_plastic_bottles = remaining_money // a\nadditional_bottles = max(additional_glass_bottles, additional_plastic_bottles)\n\ntotal_glass_bottles = glass_bottles + additional_glass_bottles\ntotal_plastic_bottles = n // a\n\nprint(max(total_glass_bottles, total_plastic_bottles))"}
{"solution": "def card_war(n, k1, cards1, k2, cards2):\n    seen = set()\n    rounds = 0\n    while cards1 and cards2:\n        rounds += 1\n        card1 = cards1.pop(0)\n        card2 = cards2.pop(0)\n        if (tuple(cards1), tuple(cards2)) in seen:\n            return -1\n        seen.add((tuple(cards1), tuple(cards2)))\n        if card1 > card2:\n            cards1.extend([card2, card1])\n        else:\n            cards2.extend([card1, card2])\n    return rounds, 1 if cards1 else 2\n\nn = int(input())\nk1 = int(input().split()[0])\ncards1 = list(map(int, input().split()[1:]))\nk2 = int(input().split()[0])\ncards2 = list(map(int, input().split()[1:]))\nresult = card_war(n, k1, cards1, k2, cards2)\nprint(*result)"}
{"solution": "password = input()\n\ndef is_complex(password):\n    if len(password) < 5:\n        return False\n    has_upper = False\n    has_lower = False\n    has_digit = False\n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n    return has_upper and has_lower and has_digit\n\nprint(\"Correct\" if is_complex(password) else \"Too weak\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ncount_a = [0] * 6\ncount_b = [0] * 6\n\nfor i in a:\n    count_a[i] += 1\n\nfor i in b:\n    count_b[i] += 1\n\nexchanges = 0\nfor i in range(1, 6):\n    diff = abs(count_a[i] - count_b[i])\n    if diff % 2!= 0:\n        print(-1)\n        exit()\n    exchanges += diff // 2\n\nprint(exchanges)"}
{"solution": "from collections import deque\n\ndef is_possible(n, m, horizontal, vertical):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = [[False for _ in range(m)] for _ in range(n)]\n\n    def bfs(start):\n        queue = deque([start])\n        visited[start[0]][start[1]] = True\n\n        while queue:\n            x, y = queue.popleft()\n\n            if horizontal[x] == '<':\n                dx, dy = directions[1]\n            else:\n                dx, dy = directions[0]\n\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]:\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n\n            if vertical[y] == '^':\n                dx, dy = directions[3]\n            else:\n                dx, dy = directions[2]\n\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]:\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n\n    bfs((0, 0))\n\n    return all(all(row) for row in visited)\n\n\nn, m = map(int, input().split())\nhorizontal = input()\nvertical = input()\n\nif is_possible(n, m, horizontal, vertical):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    if a[0] == 0:\n        print(\"YES\")\n        print(a[0])\n        return\n\n    for i in range(1, n):\n        if a[i] == 0:\n            print(\"YES\")\n            s = \"(\" * i + str(a[0])\n            for j in range(1, i):\n                s += \"->\" + str(a[j]) + \")\"\n            s += \"->\" + str(a[i])\n            print(s)\n            return\n\n    print(\"NO\")\n\nsolve()"}
{"solution": "a, b = map(int, input().split())\n\nwhile a!= 0 and b!= 0:\n    if a >= 2 * b:\n        a -= 2 * b\n    elif b >= 2 * a:\n        b -= 2 * a\n\nprint(a, b)"}
{"solution": "k, a, b = map(int, input().split())\nprint((b // k) - ((a - 1) // k))"}
{"solution": "def find_kth_digit():\n    k = int(input())\n    length = 0\n    count = 0\n    num = 1\n\n    while True:\n        length = len(str(num))\n        count += length\n        if count >= k:\n            break\n        num += 1\n\n    diff = count - k\n    return int(str(num)[diff])\n\nprint(find_kth_digit())"}
{"solution": "n = int(input())\ns = input()\n\neight_count = s.count('8')\nif eight_count < 2:\n    print('NO')\nelse:\n    first_eight = s.find('8')\n    second_eight = s.find('8', first_eight + 1)\n    if second_eight - first_eight > n - 11:\n        print('NO')\n    else:\n        print('YES')"}
{"solution": "MOD = 10**9 + 7\n\ndef modmul(a, b):\n    return (a * b) % MOD\n\ndef modpow(a, b):\n    if b == 0:\n        return 1\n    if b % 2 == 0:\n        return modpow(modmul(a, a), b // 2)\n    return modmul(a, modpow(a, b - 1))\n\ndef modinv(a):\n    return modpow(a, MOD - 2)\n\ndef moddiv(a, b):\n    return modmul(a, modinv(b))\n\ndef comb(n, k):\n    if k < 0 or k > n:\n        return 0\n    return modmul(fact[n], moddiv(1, modmul(fact[k], fact[n - k])))\n\nfact = [1]\nfor i in range(1, 1001):\n    fact.append(modmul(fact[-1], i))\n\nn, x, pos = map(int, input().split())\n\nif pos == 0:\n    print(comb(n - 1, x - 1))\nelif pos == n - 1:\n    print(comb(n - 1, x - 1))\nelse:\n    ans = 0\n    for i in range(pos):\n        if i < x - 1:\n            ans = modmul(ans + comb(pos - 1, i) * comb(n - pos - 1, x - i - 2) * fact[n - x - 1], 1)\n        elif i == x - 1:\n            ans = modmul(ans + comb(pos - 1, i) * comb(n - pos - 1, x - i - 1) * fact[n - x - 1], 1)\n        else:\n            ans = modmul(ans + comb(pos - 1, i) * comb(n - pos - 1, x - i - 1) * fact[n - x - 1], 1)\n    print(ans)"}
{"solution": "import sys\n\ndef solve():\n    s = input()\n    k = int(input())\n    n = len(s)\n    dp = [[False] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(n):\n        if s[i].isalpha():\n            for j in range(k + 1):\n                if dp[i][j]:\n                    dp[i + 1][j] = True\n                    dp[i + 1][j + 1] = True\n        elif s[i] == '*':\n            for j in range(k + 1):\n                if dp[i - 1][j]:\n                    dp[i + 1][j] = True\n                    if j + 1 <= k:\n                        dp[i + 1][j + 1] = True\n                    if j + 2 <= k:\n                        dp[i + 1][j + 2] = True\n        elif s[i] == '?':\n            for j in range(k + 1):\n                if dp[i - 1][j]:\n                    dp[i + 1][j] = True\n                    if j + 1 <= k:\n                        dp[i + 1][j + 1] = True\n    if not dp[n][k]:\n        print(\"Impossible\")\n        return\n    res = []\n    i, j = n, k\n    while i > 0 and j > 0:\n        if s[i - 1].isalpha():\n            res.append(s[i - 1])\n            if dp[i - 1][j - 1]:\n                i -= 1\n                j -= 1\n            else:\n                i -= 1\n        elif s[i - 1] == '*':\n            if dp[i - 2][j - 1]:\n                res.append(s[i - 2])\n                i -= 2\n                j -= 1\n            elif dp[i - 2][j - 2]:\n                res.append(s[i - 2] * 2)\n                i -= 2\n                j -= 2\n            else:\n                i -= 2\n        elif s[i - 1] == '?':\n            if dp[i - 2][j - 1]:\n                res.append(s[i - 2])\n                i -= 2\n                j -= 1\n            else:\n                i -= 2\n    print(''.join(reversed(res)))\n\nif __name__ == '__main__':\n    solve()"}
{"solution": "x = int(input())\nx = (x % 360 + 360) % 360\nif x == 0:\n    print(0)\nelif x < 90:\n    print(1)\nelif x < 180:\n    print(2)\nelse:\n    print(3)"}
{"solution": "a, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\ndef can_transform(a, b, c, x, y, z):\n    if a >= x and b >= y and c >= z:\n        return True\n    if a % 2 == b % 2 == c % 2:\n        return (a + b + c) // 2 >= (x + y + z) // 2\n    return False\n\nprint(\"Yes\" if can_transform(a, b, c, x, y, z) else \"No\")"}
{"solution": "def modPow(a, n, mod):\n    res = 1\n    while n > 0:\n        if n % 2 == 1:\n            res = (res * a) % mod\n        a = (a * a) % mod\n        n //= 2\n    return res\n\ndef solve():\n    n, k, m = map(int, input().split())\n    dp = [0] * k\n    dp[0] = 1\n    for _ in range(n - 1):\n        ndp = [0] * k\n        for i in range(k):\n            for j in range(10):\n                ndp[(i * 10 + j) % k] = (ndp[(i * 10 + j) % k] + dp[i]) % m\n        dp = ndp\n    ans = 0\n    for i in range(1, k):\n        ans = (ans + dp[i] * modPow(10, n - 1, m)) % m\n    print(ans)\n\nsolve()"}
{"solution": "l, r, a = map(int, input().split())\n\nmin_lr = min(l, r)\nmax_lr = max(l, r)\ndiff = max_lr - min_lr\n\nif diff > a:\n    ans = min_lr * 2 + a * 2\nelse:\n    ans = (min_lr + diff // 2) * 2 + (a - diff // 2) * 2\n\nif ans % 2!= 0:\n    ans -= 1\n\nprint(ans)"}
{"solution": "import sys\n\ndef solve(n, k):\n    dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = abs(i - k)\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            dp[j][i] = min(dp[j][i], dp[j - 1][i - 1] + 1)\n            dp[j][i] = min(dp[j][i], dp[j + 1][i - 1] + 1)\n            dp[j][i] = min(dp[j][i], dp[j][i - 1] + 2)\n    ans = float('inf')\n    for i in range(n + 1):\n        ans = min(ans, dp[i][n] + n)\n    return ans\n\nn, k = map(int, sys.stdin.readline().split())\nprint(solve(n, k))"}
{"solution": "def min_height(n, m):\n    two_blocks = set(2 * i for i in range(1, n + 1))\n    three_blocks = set(3 * i for i in range(1, m + 1))\n    used = two_blocks.union(three_blocks)\n    i = 1\n    while True:\n        if i not in used:\n            if len(used) == n + m:\n                return i\n            used.add(i)\n            if i % 2 == 0:\n                two_blocks.add(i)\n            else:\n                three_blocks.add(i)\n        i += 1\n\nn, m = map(int, input().split())\nprint(min_height(n, m))"}
{"solution": "n = int(input())\ncards = [int(input()) for _ in range(n)]\n\ncounts = {}\nfor card in cards:\n    if card in counts:\n        counts[card] += 1\n    else:\n        counts[card] = 1\n\neven_counts = [card for card, count in counts.items() if count % 2 == 0 and count!= n]\n\nif len(even_counts) > 0:\n    print(\"YES\")\n    print(even_counts[0], end=' ')\n    for card, count in counts.items():\n        if card!= even_counts[0] and count % 2 == 0 and count!= n:\n            print(card)\n            break\nelse:\n    print(\"NO\")"}
{"solution": "def solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n\n    dp = [[0] * 1024 for _ in range(k + 1)]\n    dp[0][0] = 1\n\n    for i in range(k):\n        for j in range(1024):\n            if dp[i][j]:\n                for k in range(9):\n                    if a[i] >= k and (j >> k) & 1 == 0:\n                        nj = j | (1 << k)\n                        if (nj & 1) == 0 and (nj & 2) == 0 and (nj & 12) == 0 and (nj & 48) == 0 and (nj & 192) == 0:\n                            dp[i + 1][nj] = 1\n\n    for i in range(1024):\n        if dp[k][i]:\n            return \"YES\"\n\n    return \"NO\"\n\nprint(solve())"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\nmin_cost = float('inf')\noptimal_t = -1\n\nfor t in range(1, 101):\n    cost = sum(min(abs(x - t), abs(x - (t - 1)), abs(x - (t + 1))) for x in a)\n    if cost < min_cost:\n        min_cost = cost\n        optimal_t = t\n\nprint(optimal_t, min_cost)"}
{"solution": "n, m = map(int, input().split())\nsky_map = [input() for _ in range(n)]\n\nmin_row = float('inf')\nmax_row = float('-inf')\nmin_col = float('inf')\nmax_col = float('-inf')\n\nfor i in range(n):\n    for j in range(m):\n        if sky_map[i][j] == '*':\n            min_row = min(min_row, i)\n            max_row = max(max_row, i)\n            min_col = min(min_col, j)\n            max_col = max(max_col, j)\n\nside = max(max_row - min_row + 1, max_col - min_col + 1)\nprint(side)"}
{"solution": "import sys\n\nMOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_pow(a, n, m):\n    res = 1\n    while n > 0:\n        if n % 2 == 1:\n            res = (res * a) % m\n        a = (a * a) % m\n        n //= 2\n    return res\n\ndef comb(n, k):\n    return fact[n] * inv_fact[k] * inv_fact[n-k] % MOD\n\nn, k = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\n\nfact = [1] * (n + 1)\nfor i in range(1, n + 1):\n    fact[i] = fact[i-1] * i % MOD\n\ninv_fact = [0] * (n + 1)\ninv_fact[n] = mod_inverse(fact[n], MOD)\nfor i in range(n-1, -1, -1):\n    inv_fact[i] = inv_fact[i+1] * (i+1) % MOD\n\ncnt = [0] * 2\nfor x in a:\n    cnt[x] += 1\n\nif cnt[1] == 0 or cnt[0] == 0:\n    print(1)\n    sys.exit()\n\ndp = [[0] * (cnt[1] + 1) for _ in range(n + 1)]\ndp[0][0] = 1\n\nfor i in range(n):\n    for j in range(min(i+1, cnt[1]) + 1):\n        dp[i+1][j] += dp[i][j] * (n-i-j) % MOD\n        dp[i+1][j] %= MOD\n        if j > 0:\n            dp[i+1][j] += dp[i][j-1] * (i+1-j) % MOD\n            dp[i+1][j] %= MOD\n\nans = 0\nfor i in range(cnt[1] + 1):\n    ans += dp[n][i] * comb(cnt[1], i) % MOD\n    ans %= MOD\n\nans *= mod_inverse(mod_pow(n*(n-1)//2, k, MOD), MOD)\nans %= MOD\n\nprint(ans)"}
{"solution": "x, y = map(int, input().split())\nprint(2 * (x - y) - (x - y) // 2)"}
{"solution": "import math\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\ndet = a * d - b * c\n\nif det == 0:\n    print(0)\nelse:\n    x1 = abs(det / (a + c))\n    x2 = abs(det / (a + d))\n    x3 = abs(det / (b + c))\n    x4 = abs(det / (b + d))\n\n    print(min(x1, x2, x3, x4))"}
{"solution": "n, a, b = map(int, input().split())\nt = list(map(int, input().split()))\n\ndenied = 0\nsingle_occupied_tables = 0\n\nfor i in t:\n    if i == 1:\n        if a > 0:\n            a -= 1\n        elif b > 0:\n            b -= 1\n            single_occupied_tables += 1\n        elif single_occupied_tables > 0:\n            single_occupied_tables -= 1\n        else:\n            denied += 1\n    else:\n        if b > 0:\n            b -= 1\n        else:\n            denied += 2\n\nprint(denied)"}
{"solution": "A, B, C, N = map(int, input().split())\ntotal_visited = A + B - C\nif total_visited > N or total_visited == N or A < C or B < C or C < 0:\n    print(-1)\nelse:\n    print(N - total_visited)"}
{"solution": "MOD = 10**9 + 7\n\ndef solve():\n    x, k = map(int, input().split())\n    ans = x\n    for _ in range(k):\n        ans = (ans * 2 + (1 << _)) % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "MOD = 998244353\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_multiply(a, b, m):\n    return (a * b) % m\n\ndef mod_add(a, b, m):\n    return (a + b) % m\n\ndef mod_subtract(a, b, m):\n    return (a - b) % m\n\ndef calculate_probability(n, problems):\n    prefix_product = [1] * (n + 1)\n    for i in range(n):\n        prefix_product[i + 1] = mod_multiply(prefix_product[i], (problems[i][1] - problems[i][0] + 1), MOD)\n\n    result = 1\n    for i in range(n):\n        numerator = 1\n        for j in range(i):\n            numerator = mod_multiply(numerator, max(0, problems[j][1] - problems[i][0] + 1), MOD)\n        denominator = prefix_product[i] * prefix_product[n - i - 1] % MOD\n        result = mod_multiply(result, mod_multiply(numerator, mod_inverse(denominator, MOD), MOD), MOD)\n\n    return result\n\nn = int(input())\nproblems = []\nfor _ in range(n):\n    l, r = map(int, input().split())\n    problems.append((l, r))\n\nprint(calculate_probability(n, problems))"}
{"solution": "import math\n\ndef count_ways(n):\n    count = 0\n    for a in range(1, n // 4 + 1):\n        for b in range(a, (n - 2 * a) // 2 + 1):\n            c = n - 2 * a - 2 * b\n            if c < b:\n                break\n            if c == b:\n                if 2 * a == b or 2 * b == a:\n                    continue\n                count += 3\n            elif c > b:\n                if 2 * a == c or 2 * b == c or 2 * a == b:\n                    continue\n                count += 6\n    return count\n\nn = int(input())\nprint(count_ways(n))"}
{"solution": "import sys\n\ndef binary_search(arr, s):\n    low = 0\n    high = min(min(arr), s)\n    while low <= high:\n        mid = (low + high) // 2\n        total = sum(min(mid, x) for x in arr)\n        if total == s:\n            return mid\n        elif total < s:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1\n\nn, s = map(int, sys.stdin.readline().split())\narr = list(map(int, sys.stdin.readline().split()))\n\nprint(binary_search(arr, s))"}
{"solution": "def caterpillar_height(h1, h2, a, b):\n    day_hours = 12\n    night_hours = 12\n    day_progress = a * day_hours\n    night_progress = b * night_hours\n\n    if day_progress <= night_progress:\n        return -1\n\n    days = 0\n    hours = 4  # initial hours after 2 pm\n    height = h1 + hours * a\n\n    while height < h2:\n        height += day_progress\n        if height >= h2:\n            break\n        height -= night_progress\n        days += 1\n\n    if height >= h2:\n        return days + 1\n    else:\n        return -1\n\n\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\nprint(caterpillar_height(h1, h2, a, b))"}
{"solution": "def calculate_max_joy_units():\n    C, Hr, Hb, Wr, Wb = map(int, input().split())\n\n    max_joy_units = 0\n    for r in range(C // Wr + 1):\n        remaining_weight = C - r * Wr\n        b = remaining_weight // Wb\n        joy_units = r * Hr + b * Hb\n        max_joy_units = max(max_joy_units, joy_units)\n\n    print(max_joy_units)\n\ncalculate_max_joy_units()"}
{"solution": "x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\nprint(max(abs(x2 - x1), abs(y2 - y1)))"}
{"solution": "n = int(input())\ns = input()\n\ndef solve(n, s):\n    d = s.count('D')\n    r = n - d\n    if d > r:\n        return 'D'\n    elif d < r:\n        return 'R'\n    else:\n        return 'D' if s[-1] == 'D' else 'R'\n\nprint(solve(n, s))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\na, b, x, y = map(int, input().split())\ng = gcd(x, y)\nx //= g\ny //= g\n\nans = 0\nfor k in range(1, int(math.sqrt(a)) + 1):\n    if a % k == 0:\n        if k * y <= b and x * k <= a:\n            ans += 1\n        k2 = a // k\n        if k2 * y <= b and x * k2 <= a and k2!= k:\n            ans += 1\n\nprint(ans)"}
{"solution": "import math\n\ndef count_trailing_zeros(n, b):\n    count = 0\n    i = 1\n    while True:\n        p = b ** i\n        if p > n:\n            break\n        count += n // p\n        i += 1\n    return count\n\nn, b = map(int, input().split())\nprint(count_trailing_zeros(n, b))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nm, a, b = map(int, input().split())\ng = gcd(a, b)\nlcm = a * b // g\n\nif a < b:\n    a, b = b, a\n\nif a == 1:\n    print((m + 1) * (m + 2) // 2)\nelse:\n    ans = m // lcm * (lcm // a + 1) + (m % lcm) // a + 1\n    ans += (m // lcm) * (m // lcm - 1) // 2 * (lcm // a + 1) * (lcm // a + 2)\n    ans += (m // lcm) * (m % lcm) // a * (lcm // a + 2)\n    ans += (m % lcm) // a * ((m % lcm) // a - 1) // 2 * (lcm // a + 2)\n    print(ans)"}
{"solution": "def can_divide_into_odd_subsegments(n, sequence):\n    if n % 2 == 0 and sequence[0] % 2!= 0 and sequence[-1] % 2!= 0:\n        return False\n\n    if sequence[0] % 2 == 0 or sequence[-1] % 2 == 0:\n        return False\n\n    count = 0\n    i = 0\n    while i < n:\n        if sequence[i] % 2!= 0:\n            count += 1\n            i += 1\n            while i < n and sequence[i] % 2 == 0:\n                i += 1\n            if i < n and sequence[i] % 2!= 0:\n                i += 1\n            else:\n                return False\n        else:\n            i += 1\n\n    return count % 2!= 0\n\n\nn = int(input())\nsequence = list(map(int, input().split()))\n\nif can_divide_into_odd_subsegments(n, sequence):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "x1, y1, x2, y2 = map(int, input().split())\n\nif x1 == x2:\n    x3, x4 = x1, x1\n    y3, y4 = y1 + abs(x2 - x1), y2 - abs(x2 - x1)\nelif y1 == y2:\n    x3, x4 = x1 + abs(y2 - y1), x2 - abs(y2 - y1)\n    y3, y4 = y1, y1\nelse:\n    print(-1)\n    exit()\n\nprint(x3, y3, x4, y4)"}
{"solution": "def matrix_multiply(a, b, mod):\n    c = [[0, 0], [0, 0]]\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                c[i][j] += a[i][k] * b[k][j]\n            c[i][j] %= mod\n    return c\n\ndef matrix_power(matrix, n, mod):\n    if n == 1:\n        return matrix\n    if n % 2 == 0:\n        half_pow = matrix_power(matrix, n // 2, mod)\n        return matrix_multiply(half_pow, half_pow, mod)\n    else:\n        half_pow = matrix_power(matrix, n // 2, mod)\n        return matrix_multiply(matrix_multiply(half_pow, half_pow, mod), matrix, mod)\n\nmod = 1000000007\nx, y = map(int, input().split())\nn = int(input())\n\nif n == 1:\n    print(x % mod)\nelif n == 2:\n    print(y % mod)\nelse:\n    matrix = [[1, 1], [1, 0]]\n    result_matrix = matrix_power(matrix, n - 2, mod)\n    result = (result_matrix[0][0] * y - result_matrix[0][1] * x) % mod\n    print((result + mod) % mod)"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    if prefix_sum[n] == 0:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    result = []\n    start = 0\n    for i in range(n + 1):\n        if prefix_sum[i]!= 0 and prefix_sum[n] - prefix_sum[i]!= 0:\n            result.append((start + 1, i))\n            start = i\n    result.append((start + 1, n))\n\n    print(len(result))\n    for l, r in result:\n        print(l, r)\n\nsolve()"}
{"solution": "def min_score(n, m, k):\n    mod = 1000000009\n    if m < n - m + 1:\n        return m\n    score = m - (n - m + 1)\n    score += (n - m + 1) * 2\n    score -= (score // k) * 2 + 1\n    return score % mod\n\nn, m, k = map(int, input().split())\nprint(min_score(n, m, k))"}
{"solution": "def is_divisible_by_8(num):\n    return num % 8 == 0\n\ndef find_divisible_substring(num_str):\n    for length in range(1, 4):\n        for i in range(len(num_str) - length + 1):\n            substring = num_str[i:i+length]\n            if substring[0]!= '0' and is_divisible_by_8(int(substring)):\n                return substring\n    return None\n\nnum_str = input()\ndivisible_substring = find_divisible_substring(num_str)\n\nif divisible_substring is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(divisible_substring)"}
{"solution": "import math\n\nn, m = map(int, input().split())\nmemories = [list(map(int, input().split())) for _ in range(m)]\n\nmin_flats_per_floor = 1\nmax_flats_per_floor = n\n\nfor flat, floor in memories:\n    min_flats_per_floor = max(min_flats_per_floor, math.ceil(flat / floor))\n    max_flats_per_floor = min(max_flats_per_floor, math.floor((flat - 1) / (floor - 1)) if floor > 1 else n)\n\npossible_floors = set()\nfor flats_per_floor in range(min_flats_per_floor, max_flats_per_floor + 1):\n    possible_floors.add(math.ceil(n / flats_per_floor))\n\nprint(possible_floors.pop() if len(possible_floors) == 1 else -1)"}
{"solution": "def count_bishwocks(board):\n    n = len(board[0])\n    count = 0\n\n    for i in range(n - 1):\n        if board[0][i] == '0' and board[0][i + 1] == '0' and board[1][i] == '0':\n            count += 1\n            i += 1\n        elif board[0][i] == '0' and board[1][i] == '0' and board[1][i + 1] == '0':\n            count += 1\n            i += 1\n\n    for i in range(n - 2):\n        if board[0][i] == '0' and board[0][i + 1] == '0' and board[0][i + 2] == '0' and board[1][i + 1] == '0':\n            count += 1\n            i += 2\n        elif board[1][i] == '0' and board[1][i + 1] == '0' and board[1][i + 2] == '0' and board[0][i + 1] == '0':\n            count += 1\n            i += 2\n\n    return count\n\nboard = [input(), input()]\nprint(count_bishwocks(board))"}
{"solution": "def max_pretty_set(n, s):\n    dp = [[0] * 27 for _ in range(n + 1)]\n    last_lower = [-1] * 27\n\n    for i in range(n):\n        if s[i].islower():\n            idx = ord(s[i]) - ord('a')\n            last_lower[idx] = i\n            for j in range(27):\n                if last_lower[j]!= -1:\n                    dp[i + 1][j] = max(dp[i + 1][j], dp[last_lower[j] + 1][j] + 1)\n        else:\n            for j in range(27):\n                dp[i + 1][j] = dp[i][j]\n\n    return max(dp[n])\n\nn = int(input())\ns = input()\nprint(max_pretty_set(n, s))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\na.sort()\nprint(sum(a[n//2:]))"}
{"solution": "a, b, f, k = map(int, input().split())\n\nif 2 * a > b:\n    if f * 2 > b:\n        if (a - f) * 2 > b:\n            print(-1)\n        else:\n            ans = 0\n            if f > b / 2:\n                ans += k * 2\n            else:\n                ans += k\n                if a - f > b / 2:\n                    ans += k\n            print(ans)\n    else:\n        ans = 0\n        if a - f > b / 2:\n            ans += k\n        if f > b / 2:\n            ans += k\n        print(ans)\nelse:\n    if (a - f) * 2 > b:\n        print(-1)\n    else:\n        print(0)"}
{"solution": "import sys\n\nn, p, q = map(int, input().split())\ns = input()\n\ndef split_string(s, p, q):\n    result = []\n    while s:\n        if len(s) >= q:\n            result.append(s[:q])\n            s = s[q:]\n        elif len(s) >= p:\n            result.append(s[:p])\n            s = s[p:]\n        else:\n            return None\n    return result\n\ndef split_string_only_p(s, p):\n    result = []\n    while s:\n        result.append(s[:p])\n        s = s[p:]\n    return result\n\ndef split_string_only_q(s, q):\n    result = []\n    while s:\n        result.append(s[:q])\n        s = s[q:]\n    return result\n\nresult = split_string(s, p, q)\nif result is None:\n    result = split_string_only_p(s, p)\n    if result is None:\n        result = split_string_only_q(s, q)\n        if result is None:\n            print(-1)\n        else:\n            print(len(result))\n            for item in result:\n                print(item)\n    else:\n        print(len(result))\n        for item in result:\n            print(item)\nelse:\n    print(len(result))\n    for item in result:\n        print(item)"}
{"solution": "import sys\n\ndef solve():\n    n, m, s, d = map(int, sys.stdin.readline().split())\n    obstacles = sorted(map(int, sys.stdin.readline().split()))\n\n    if obstacles[0] < s:\n        print(\"IMPOSSIBLE\")\n        return\n\n    print(\"RUN\", obstacles[0])\n    pos = obstacles[0]\n\n    for i in range(n):\n        if i == n - 1:\n            if m - pos <= s:\n                print(\"RUN\", m - pos)\n            else:\n                print(\"RUN\", s)\n                pos += s\n                print(\"JUMP\", min(m - pos, d))\n            break\n\n        if obstacles[i + 1] - pos <= s:\n            print(\"RUN\", obstacles[i + 1] - pos)\n            pos = obstacles[i + 1]\n        else:\n            print(\"RUN\", s)\n            pos += s\n            print(\"JUMP\", min(obstacles[i + 1] - pos, d))\n            pos = min(obstacles[i + 1] + 1, pos + d)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def count_pairs(s, x):\n    if s < x or (s - x) % 2!= 0:\n        return 0\n\n    y = (s - x) // 2\n    count = 0\n    for i in range(40):\n        if (x >> i) & 1 and (y >> i) & 1:\n            return 0\n        elif (x >> i) & 1:\n            count += 1\n        elif (y >> i) & 1:\n            count += 1\n\n    return 2 ** count if x!= y else 2 ** count - 2\n\n\ns, x = map(int, input().split())\nprint(count_pairs(s, x))"}
{"solution": "import sys\n\nn, k = map(int, sys.stdin.readline().split())\n\nif n <= 2 * k:\n    print(1)\n    print(1)\nelse:\n    print((n - 1) // (2 * k) + (1 if (n - 1) % (2 * k)!= 0 else 0))\n    for i in range(1, n, 2 * k):\n        print(i, end=' ')"}
{"solution": "from collections import defaultdict\n\ndef min_operations(n):\n    n = str(n)\n    squares = set(str(i**2) for i in range(1, 10**5))\n    dp = defaultdict(lambda: float('inf'))\n    dp[''] = 0\n\n    for digit in n:\n        new_dp = defaultdict(lambda: float('inf'))\n        for key in dp:\n            new_dp[key] = min(new_dp[key], dp[key] + 1)\n            new_dp[key + digit] = min(new_dp[key + digit], dp[key])\n        for key in new_dp:\n            if key in squares:\n                return new_dp[key]\n        dp = new_dp\n\n    return -1\n\nprint(min_operations(int(input())))"}
{"solution": "import math\n\nMOD = 10**9 + 7\nMAXN = 10**6 + 5\n\ndef sieve():\n    spf[1] = 1\n    for i in range(2, MAXN):\n        spf[i] = i\n    for i in range(4, MAXN, 2):\n        spf[i] = 2\n    for i in range(3, int(math.sqrt(MAXN)) + 1):\n        if spf[i] == i:\n            for j in range(i*i, MAXN, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef get_factorization(x):\n    ret = []\n    while x!= 1:\n        ret.append(spf[x])\n        x //= spf[x]\n    return ret\n\ndef main():\n    sieve()\n    n = int(input())\n    ans = 1\n    for i in range(2, n+1):\n        if spf[i] == i:\n            ans = (ans * i) % MOD\n    for i in range(2, n+1):\n        if spf[i] == i:\n            ans = (ans * (i-1)) % MOD\n    print(ans)\n\nspf = [0] * MAXN\nmain()"}
{"solution": "def grasshopper_on_string(s):\n    vowels = set('AEIOUY')\n    positions = [i for i, c in enumerate(s) if c in vowels]\n    max_jump = 0\n    for i in range(len(positions) - 1):\n        max_jump = max(max_jump, positions[i + 1] - positions[i])\n    return max_jump + 1\n\ns = input()\nprint(grasshopper_on_string(s))"}
{"solution": "def can_distribute_candies(a):\n    total_sum = sum(a)\n    if total_sum % 2!= 0:\n        return \"NO\"\n    target_sum = total_sum // 2\n    a.sort(reverse=True)\n    def dfs(index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(a):\n            return False\n        return dfs(index + 1, current_sum + a[index]) or dfs(index + 1, current_sum)\n    return \"YES\" if dfs(0, 0) else \"NO\"\n\na = list(map(int, input().split()))\nprint(can_distribute_candies(a))"}
{"solution": "def calculate_pie_sums(n, slices):\n    alice_sum = 0\n    bob_sum = 0\n    alice_turn = False\n\n    for i in range(n):\n        if alice_turn:\n            if i % 2 == 0:\n                alice_sum += slices[i]\n            else:\n                bob_sum += slices[i]\n        else:\n            if i % 2 == 0:\n                bob_sum += slices[i]\n            else:\n                alice_sum += slices[i]\n\n        if i % 2 == 0:\n            alice_turn = not alice_turn\n\n    return alice_sum, bob_sum\n\n\nn = int(input())\nslices = list(map(int, input().split()))\n\nalice_sum, bob_sum = calculate_pie_sums(n, slices)\nprint(alice_sum, bob_sum)"}
{"solution": "import sys\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    max_num = max(a)\n    max_bits = max_num.bit_length()\n\n    if max_bits > n:\n        print(-1)\n        return\n\n    dp = [0] * (1 << n)\n    dp[0] = 1\n\n    for i in range(1, 1 << n):\n        if not dp[i]:\n            continue\n        for j in range(n):\n            if (i >> j) & 1:\n                for k in range(j):\n                    if (i >> k) & 1:\n                        sum_val = a[j] + a[k]\n                        if sum_val <= max_num:\n                            dp[sum_val] = 1\n\n    if dp[max_num]:\n        print(max_bits)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmin_val = min(a)\ncount = a.count(min_val)\n\nif count > n // 2:\n    print(\"Bob\")\nelse:\n    print(\"Alice\")"}
{"solution": "import math\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\nif n == 1 or a[0] == a[-1]:\n    print(\"YES\")\nelse:\n    x = a[-1] - a[0]\n    for i in range(1, n - 1):\n        if (a[i] - a[0]) % x!= 0 or (a[i] - a[0]) // x > 1 or (a[-1] - a[i]) % x!= 0 or (a[-1] - a[i]) // x > 1:\n            print(\"NO\")\n            break\n    else:\n        print(\"YES\")"}
{"solution": "def max_repeated_substring_length(n, s):\n    max_length = 0\n    for length in range(1, n // 2 + 1):\n        for i in range(n - length):\n            if s[i:i + length] in s[i + length:]:\n                max_length = max(max_length, length)\n    return max_length\n\nn = int(input())\ns = input()\nprint(max_repeated_substring_length(n, s))"}
{"solution": "n, a = map(int, input().split())\nif a <= n // 2:\n    print(a // 2 + a % 2)\nelse:\n    print(n // 2 - (a - n) // 2 + (a - n) % 2)"}
{"solution": "def can_select_jedi(n, m, colors, counts):\n    for i in range(n - sum(counts) + 1):\n        color_counts = [0] * m\n        for j in range(sum(counts)):\n            color_counts[colors[i + j] - 1] += 1\n        if color_counts == counts:\n            return True\n    return False\n\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\ncounts = list(map(int, input().split()))\n\nif can_select_jedi(n, m, colors, counts):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\nmishka_wins = 0\nchris_wins = 0\n\nfor _ in range(n):\n    mishka, chris = map(int, input().split())\n    if mishka > chris:\n        mishka_wins += 1\n    elif chris > mishka:\n        chris_wins += 1\n\nif mishka_wins > chris_wins:\n    print(\"Mishka\")\nelif chris_wins > mishka_wins:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")"}
{"solution": "def is_valid_field(n, m, field):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                continue\n            count = 0\n            for d in directions:\n                ni, nj = i + d[0], j + d[1]\n                if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':\n                    count += 1\n            if field[i][j] == '.':\n                if count!= 0:\n                    return False\n            else:\n                if int(field[i][j])!= count:\n                    return False\n    return True\n\n\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\nprint(\"YES\" if is_valid_field(n, m, field) else \"NO\")"}
{"solution": "def calculate_vasya_candies(n, k):\n    vasya_candies = 0\n    while n > 0:\n        vasya_candies += min(k, n)\n        n -= min(k, n)\n        n -= n // 10\n    return vasya_candies\n\ndef find_min_k(n):\n    target = (n + 1) // 2\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if calculate_vasya_candies(n, mid) < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\nn = int(input())\nprint(find_min_k(n))"}
{"solution": "def solve():\n    s = input()\n    n = len(s)\n    pearl_count = s.count('o')\n    link_count = n - pearl_count\n\n    if pearl_count == 0 or pearl_count == 1:\n        print(\"YES\")\n        return\n\n    if link_count % pearl_count!= 0:\n        print(\"NO\")\n        return\n\n    link_per_pearl = link_count // pearl_count\n    pearl_index = 0\n    while True:\n        pearl_index = s.find('o', pearl_index)\n        if pearl_index == -1:\n            break\n        next_pearl_index = s.find('o', pearl_index + 1)\n        if next_pearl_index == -1:\n            next_pearl_index = s.find('o', 0)\n        link_count_between_pearls = next_pearl_index - pearl_index - 1\n        if next_pearl_index < pearl_index:\n            link_count_between_pearls += n\n        if link_count_between_pearls!= link_per_pearl:\n            print(\"NO\")\n            return\n        pearl_index += 1\n\n    print(\"YES\")\n\nsolve()"}
{"solution": "def max_pillows(n, m, k):\n    if n == 1:\n        return m\n    if n == m:\n        return 1\n    if k == 1 or k == n:\n        return m - n + 2\n    min_pillows = m // n\n    if m % n == 0:\n        return min_pillows\n    else:\n        return min(min_pillows + 1, (m - (n - k + 1)) // (n - k + 1) + 1)\n\nn, m, k = map(int, input().split())\nprint(max_pillows(n, m, k))"}
{"solution": "import math\n\ndef solve():\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    dp = [[-math.inf] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(m):\n            dp[i][j] = dp[i - 1][j + 1] + a[i - 1]\n            if j == 0:\n                dp[i][j] = max(dp[i][j], 0)\n            ans = max(ans, dp[i][j] - k * math.ceil((i - j) / m))\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "n, m = map(int, input().split())\n\nif n > m:\n    if n > 0:\n        print(n, m)\n        print(0, m)\n        print(n, 0)\n        print(0, 0)\n    else:\n        print(0, m)\n        print(0, 0)\n        print(0, m-1)\n        print(0, 1)\nelif n < m:\n    if m > 0:\n        print(n, m)\n        print(n, 0)\n        print(0, m)\n        print(0, 0)\n    else:\n        print(n, m)\n        print(n-1, m)\n        print(n, m-1)\n        print(n-1, m-1)\nelse:\n    if n > 0:\n        print(n, m)\n        print(0, m)\n        print(n, 0)\n        print(0, 0)\n    else:\n        print(0, m)\n        print(0, 0)\n        print(0, m-1)\n        print(0, 1)"}
{"solution": "def find_smallest_number(s, sub):\n    n = len(s)\n    k = len(sub)\n    sub = sub.lstrip('0')\n    if not sub:\n        sub = '0'\n    k = len(sub)\n\n    for i in range(n - k + 1):\n        if s[i:i+k] == sub:\n            break\n\n    left = s[:i]\n    right = s[i+k:]\n    left = left.rstrip('0')\n    if not left:\n        left = '0'\n    right = right.lstrip('0')\n    if not right:\n        right = '0'\n\n    return left + sub + right + str(len(left + sub + right))\n\ns = input()\nsub = input()\nprint(find_smallest_number(s, sub))"}
{"solution": "n, m, min_val, max_val = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\nif min(temperatures) < min_val or max(temperatures) > max_val:\n    print(\"Incorrect\")\nelif min_val in temperatures and max_val in temperatures:\n    print(\"Correct\")\nelif min_val not in temperatures and max_val not in temperatures and n - m >= 2:\n    print(\"Correct\")\nelif min_val not in temperatures and max_val in temperatures and n - m >= 1:\n    print(\"Correct\")\nelif min_val in temperatures and max_val not in temperatures and n - m >= 1:\n    print(\"Correct\")\nelse:\n    print(\"Incorrect\")"}
{"solution": "import math\n\ndef find_trailing_zeros(m):\n    start = 5\n    count = 0\n    result = []\n    while True:\n        zeros = 0\n        n = start\n        while n // 5 > 0:\n            zeros += n // 5\n            n //= 5\n        if zeros == m:\n            count += 1\n            result.append(start)\n        elif zeros < m:\n            break\n        start += 1\n    print(count)\n    print(*result)\n\nm = int(input())\nfind_trailing_zeros(m)"}
{"solution": "import sys\nimport heapq\n\ndef read_ints():\n    return map(int, sys.stdin.readline().split())\n\ndef read_int():\n    return int(sys.stdin.readline())\n\ndef read_string():\n    return sys.stdin.readline().strip()\n\ndef read_strings():\n    return sys.stdin.readline().strip().split()\n\ndef solve():\n    n, m, k = read_ints()\n    special = list(read_ints())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v, w = read_ints()\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    def dijkstra(start):\n        distances = [float('inf')] * (n + 1)\n        distances[start] = 0\n        pq = [(0, start)]\n        while pq:\n            dist, node = heapq.heappop(pq)\n            if dist > distances[node]:\n                continue\n            for neighbor, weight in graph[node]:\n                new_dist = max(dist, weight)\n                if new_dist < distances[neighbor]:\n                    distances[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, neighbor))\n        return distances\n\n    distances = [dijkstra(node) for node in special]\n    max_distances = [max(dist[node] for dist in distances) for node in special]\n    print(*max_distances)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "n = int(input())\nx = int(input())\n\nif n % 2 == 0:\n    if x == 0:\n        print(0)\n    elif x == 1:\n        print(2)\n    else:\n        print(1)\nelse:\n    if x == 0:\n        print(1)\n    elif x == 1:\n        print(0)\n    else:\n        print(2)"}
{"solution": "def is_square(rectangles):\n    points = set()\n    for x1, y1, x2, y2 in rectangles:\n        for x in range(x1, x2):\n            for y in range(y1, y2):\n                points.add((x, y))\n\n    min_x = min(x for x, y in points)\n    max_x = max(x for x, y in points)\n    min_y = min(y for x, y in points)\n    max_y = max(y for x, y in points)\n\n    side_length = max_x - min_x\n    if side_length!= max_y - min_y:\n        return False\n\n    expected_points = set((x, y) for x in range(min_x, max_x) for y in range(min_y, max_y))\n    return points == expected_points\n\n\nn = int(input())\nrectangles = [tuple(map(int, input().split())) for _ in range(n)]\nprint(\"YES\" if is_square(rectangles) else \"NO\")"}
{"solution": "def digit_sum(x):\n    return sum(int(digit) for digit in str(x))\n\ndef count_big_numbers(n, s):\n    count = 0\n    for i in range(1, n + 1):\n        if i - digit_sum(i) >= s:\n            count += 1\n    return count\n\nn, s = map(int, input().split())\nprint(count_big_numbers(n, s))"}
{"solution": "from collections import defaultdict\nfrom math import gcd\nfrom functools import reduce\n\ndef get_slope(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    if x1 == x2:\n        return float('inf')\n    return (y2 - y1) / (x2 - x1)\n\ndef get_gcd(a, b):\n    return reduce(gcd, [a, b])\n\ndef get_line(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    dx = x2 - x1\n    dy = y2 - y1\n    g = get_gcd(dx, dy)\n    dx //= g\n    dy //= g\n    return (dx, dy)\n\ndef main():\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    if n <= 2:\n        print(\"YES\")\n        return\n\n    slopes = defaultdict(int)\n    lines = defaultdict(int)\n    for i in range(n):\n        for j in range(i + 1, n):\n            slope = get_slope(points[i], points[j])\n            slopes[slope] += 1\n            line = get_line(points[i], points[j])\n            lines[line] += 1\n\n    max_slope_count = max(slopes.values())\n    max_line_count = max(lines.values())\n\n    if max_slope_count >= n - 1 or max_line_count >= n - 1:\n        print(\"YES\")\n    else:\n        for slope in slopes:\n            if slopes[slope] >= n // 2:\n                for line in lines:\n                    if lines[line] >= n - slopes[slope]:\n                        print(\"YES\")\n                        return\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 10**9 + 7\n\ndef add(a, b):\n    return (a + b) % MOD\n\ndef mul(a, b):\n    return (a * b) % MOD\n\ndef pow(a, b):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = mul(res, a)\n        a = mul(a, a)\n        b >>= 1\n    return res\n\ndef inv(a):\n    return pow(a, MOD - 2)\n\ndef C(n, k):\n    if k < 0 or k > n:\n        return 0\n    return mul(fact[n], mul(inv(fact[k]), inv(fact[n - k])))\n\nfact = [1] * 200001\nfor i in range(1, 200001):\n    fact[i] = mul(fact[i - 1], i)\n\na, b, k, t = map(int, input().split())\nres = 0\nfor i in range(1, 2 * k * t + 1):\n    res = add(res, mul(C(2 * k * t, i + b - a - 1), C(2 * k * t - (i + b - a - 1), t - (i + b - a - 1))))\nprint(res)"}
{"solution": "def can_measure(distances, x, y):\n    for i in range(len(distances)):\n        for j in range(i, len(distances)):\n            if distances[j] - distances[i] == x and x!= y:\n                for k in range(len(distances)):\n                    for last in range(k, len(distances)):\n                        if distances[last] - distances[k] == y:\n                            return True\n            elif distances[j] - distances[i] == y and x!= y:\n                for k in range(len(distances)):\n                    for last in range(k, len(distances)):\n                        if distances[last] - distances[k] == x:\n                            return True\n            elif distances[j] - distances[i] == x and x == y:\n                return True\n    return False\n\n\ndef find_mark(distances, x, y):\n    for i in range(len(distances)):\n        if distances[i] >= x:\n            return distances[i] - x\n    return x\n\n\ndef find_mark2(distances, x, y):\n    for i in range(len(distances)):\n        if distances[i] >= y:\n            return distances[i] - y\n    return y\n\n\ndef find_mark3(distances, x, y):\n    for i in range(len(distances)):\n        for j in range(i, len(distances)):\n            if distances[j] - distances[i] == x:\n                return distances[j] + (distances[j] - distances[i])\n    return x + y\n\n\ndef find_mark4(distances, x, y):\n    for i in range(len(distances)):\n        for j in range(i, len(distances)):\n            if distances[j] - distances[i] == y:\n                return distances[j] + (distances[j] - distances[i])\n    return x + y\n\n\nn, l, x, y = map(int, input().split())\ndistances = list(map(int, input().split()))\n\nif can_measure(distances, x, y):\n    print(0)\nelse:\n    mark1 = find_mark(distances, x, y)\n    mark2 = find_mark2(distances, x, y)\n    mark3 = find_mark3(distances, x, y)\n    mark4 = find_mark4(distances, x, y)\n\n    if mark1 <= l and (mark1 not in distances):\n        if mark2 <= l and (mark2 not in distances):\n            print(2)\n            print(mark1, mark2)\n        else:\n            print(1)\n            print(mark1)\n    elif mark2 <= l and (mark2 not in distances):\n        print(1)\n        print(mark2)\n    elif mark3 <= l and (mark3 not in distances):\n        if mark4 <= l and (mark4 not in distances):\n            print(2)\n            print(mark3, mark4)\n        else:\n            print(1)\n            print(mark3)\n    elif mark4 <= l and (mark4 not in distances):\n        print(1)\n        print(mark4)\n    else:\n        print(2)\n        print(x, y)"}
{"solution": "import math\n\nn = int(input())\ncakes = []\nfor _ in range(n):\n    r, h = map(int, input().split())\n    cakes.append((math.pi * r * r * h, r, h))\n\ncakes.sort()\n\ndp = [0] * n\ndp[0] = cakes[0][0]\n\nfor i in range(1, n):\n    max_volume = 0\n    for j in range(i):\n        if cakes[i][1] > cakes[j][1] and cakes[i][2] > cakes[j][2]:\n            max_volume = max(max_volume, dp[j])\n    dp[i] = max(max_volume + cakes[i][0], dp[i-1])\n\nprint(dp[-1])"}
{"solution": "import sys\nimport math\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(input())\n\ndef read_ints():\n    return map(int, input().split())\n\ndef solve():\n    n, k = read_ints()\n    h = list(read_ints())\n    h.sort()\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + h[i]\n\n    def check(x):\n        total = 0\n        for i in range(n - x, n):\n            total += h[i] - h[i - x]\n        return total <= k\n\n    lo, hi = 0, n\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if check(mid):\n            lo = mid\n        else:\n            hi = mid - 1\n\n    print(n - lo)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\nprefix_sum = [0] * (n + 1)\nfor i in range(n):\n    prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\nmin_value = min(a)\nmax_score = 0\n\nfor i in range(n):\n    for j in range(i, n):\n        segment_sum = prefix_sum[j + 1] - prefix_sum[i]\n        max_score = max(max_score, segment_sum - min(a[i:j + 1]))\n\nprint(max_score)"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nk1, k2, k3 = map(int, input().split())\n\nlcm12 = lcm(k1, k2)\nlcm23 = lcm(k2, k3)\nlcm13 = lcm(k1, k3)\n\nif max(lcm12, lcm23, lcm13) <= k1 + k2 + k3 - max(k1, k2, k3):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\ns = input()\n\ndp = [[0] * 26 for _ in range(n + 1)]\nfor i in range(n - 1, -1, -1):\n    for j in range(26):\n        dp[i][j] = dp[i + 1][j]\n    dp[i][ord(s[i]) - ord('a')] = min(dp[i + 1][ord(s[i]) - ord('a')] + 1, dp[i + 1][ord(s[i + 1]) - ord('a')] if i < n - 1 else 1)\n\nprint(dp[0][ord(s[0]) - ord('a')])"}
{"solution": "from collections import Counter\n\nn = int(input())\nboys = Counter(map(int, input().split()))\n\nm = int(input())\ngirls = Counter(map(int, input().split()))\n\npairs = 0\nfor skill in set(list(boys.keys()) + list(girls.keys())):\n    pairs += min(boys[skill], girls[skill])\n    pairs += min(boys[skill - 1] if skill - 1 in boys else 0, girls[skill] if skill in girls else 0)\n    pairs += min(boys[skill], girls[skill + 1] if skill + 1 in girls else 0)\n\nprint(pairs)"}
{"solution": "def determine_winner():\n    team1 = [list(map(int, input().split())) for _ in range(2)]\n    team2 = [list(map(int, input().split())) for _ in range(2)]\n\n    team1_defence = max(team1[0][0], team1[1][0])\n    team1_attack = min(team1[0][1], team1[1][1])\n\n    team2_defence = max(team2[0][0], team2[1][0])\n    team2_attack = min(team2[0][1], team2[1][1])\n\n    if team1_defence > team2_attack and team1_attack > team2_defence:\n        return \"Team 1\"\n    elif team2_defence > team1_attack and team2_attack > team1_defence:\n        return \"Team 2\"\n    else:\n        return \"Draw\"\n\nprint(determine_winner())"}
{"solution": "import math\nimport sys\n\ndef dist(x1, y1, x2, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef check(x, y, k, arr):\n    times = []\n    for x1, y1, c in arr:\n        times.append(c * dist(x, y, x1, y1))\n    times.sort()\n    return times[k - 1]\n\ndef solve():\n    n, k = map(int, input().split())\n    arr = []\n    for _ in range(n):\n        x, y, c = map(int, input().split())\n        arr.append((x, y, c))\n\n    ans = sys.maxsize\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1, _ = arr[i]\n            x2, y2, _ = arr[j]\n            for x in [x1, x2, (x1 + x2) / 2]:\n                for y in [y1, y2, (y1 + y2) / 2]:\n                    ans = min(ans, check(x, y, k, arr))\n\n    print(f\"{ans:.1f}\")\n\nsolve()"}
{"solution": "def solve():\n    n = int(input())\n    s = input()\n\n    a = [0] * n\n    for i in range(n):\n        if s[i]!= '?':\n            a[i] = int(s[i])\n\n    diff = sum(a[:n//2]) - sum(a[n//2:])\n\n    cnt = s[:n//2].count('?') + s[n//2:].count('?')\n    cnt_diff = s[:n//2].count('?') - s[n//2:].count('?')\n\n    if diff % 10!= 0:\n        return \"Monocarp\"\n    if diff // 10 > cnt // 2 or diff // 10 < -cnt // 2:\n        return \"Monocarp\"\n    if cnt_diff % 2!= 0:\n        return \"Monocarp\"\n\n    return \"Bicarp\"\n\nprint(solve())"}
{"solution": "import math\n\nn, t = map(int, input().split())\nmin_time = float('inf')\nmin_index = -1\n\nfor i in range(n):\n    s, d = map(int, input().split())\n    time = s + (t - s + d - 1) // d * d\n    if time < min_time:\n        min_time = time\n        min_index = i + 1\n\nprint(min_index)"}
{"solution": "def count_ones(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef solve(m, k):\n    n = 1\n    while True:\n        count = 0\n        for i in range(n + 1, 2 * n + 1):\n            if count_ones(i) == k:\n                count += 1\n        if count == m:\n            return n\n        n += 1\n\nm, k = map(int, input().split())\nprint(solve(m, k))"}
{"solution": "def is_good_level(level):\n    n = len(level)\n    for i in range(n):\n        for jump in range(1, n // 4):\n            if i + 4 * jump < n and all(level[i + k * jump] == '*' for k in range(5)):\n                return True\n    return False\n\nn = int(input())\nlevel = input().strip()\nprint(\"yes\" if is_good_level(level) else \"no\")"}
{"solution": "def calculate_magic_constant(n, grid):\n    total_sum = sum(sum(row) for row in grid)\n    return (n * (n**2 + 1)) // 2 - total_sum\n\ndef check_magic_square(n, grid, magic_constant):\n    for i in range(n):\n        row_sum = sum(grid[i])\n        col_sum = sum(grid[j][i] for j in range(n))\n        if row_sum!= magic_constant or col_sum!= magic_constant:\n            return False\n\n    diagonal_sum1 = sum(grid[i][i] for i in range(n))\n    diagonal_sum2 = sum(grid[i][n - i - 1] for i in range(n))\n    if diagonal_sum1!= magic_constant or diagonal_sum2!= magic_constant:\n        return False\n\n    return True\n\ndef find_empty_cell(n, grid):\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                return i, j\n\ndef solve(n, grid):\n    magic_constant = calculate_magic_constant(n, grid)\n    if magic_constant < 1:\n        return -1\n\n    empty_row, empty_col = find_empty_cell(n, grid)\n    grid[empty_row][empty_col] = magic_constant\n\n    if check_magic_square(n, grid, sum(grid[0])):\n        return magic_constant\n    else:\n        return -1\n\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\nprint(solve(n, grid))"}
{"solution": "n = int(input())\nm = int(input())\na = [int(input()) for _ in range(n)]\n\nmin_k = max(max(a), (m + sum(a) - 1) // n + 1)\nmax_k = max(a) + m\n\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef pow_mod(a, b):\n    res = 1\n    while b:\n        if b & 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b >>= 1\n    return res\n\ndef main():\n    n, m = map(int, input().split())\n    if m > n:\n        print(0)\n        return\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n\n    inv_fact = [pow_mod(fact[i], MOD - 2) for i in range(n + 1)]\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, m + 1):\n        new_dp = [0] * (n + 1)\n        for j in range(i, n + 1):\n            new_dp[j] = (dp[j - 1] + dp[j] * (j - i)) % MOD\n        dp = new_dp\n\n    res = 0\n    for i in range(m, n + 1):\n        res = (res + dp[i] * fact[i] * inv_fact[i - m] * pow_mod(2, i)) % MOD\n\n    print(res)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import defaultdict\nfrom itertools import combinations\n\ndef solve():\n    n, m = map(int, input().split())\n    friends = []\n    for _ in range(n):\n        f, *b = map(int, input().split())\n        friends.append(set(b))\n\n    pizzas = []\n    for _ in range(m):\n        c, r, *a = map(int, input().split())\n        pizzas.append((c, set(a)))\n\n    max_satisfied = 0\n    min_cost = float('inf')\n    best_pair = None\n\n    for i, (c1, a1) in enumerate(pizzas):\n        for j, (c2, a2) in enumerate(pizzas):\n            if i >= j:\n                continue\n            satisfied = sum(1 for f in friends if f.issubset(a1 | a2))\n            if satisfied > max_satisfied or (satisfied == max_satisfied and c1 + c2 < min_cost):\n                max_satisfied = satisfied\n                min_cost = c1 + c2\n                best_pair = (i + 1, j + 1)\n\n    print(*best_pair)\n\nsolve()"}
{"solution": "def find_min_max(m, s):\n    if s == 0 and m > 1:\n        return -1, -1\n    if s < m or s > 9 * m:\n        return -1, -1\n\n    min_num = ''\n    max_num = ''\n\n    remaining_sum = s\n    for i in range(m):\n        if i == 0:\n            min_num += str(min(9, remaining_sum))\n            remaining_sum -= int(min_num[-1])\n        else:\n            min_num += str(min(9, remaining_sum))\n            remaining_sum -= int(min_num[-1])\n\n    remaining_sum = s\n    for i in range(m):\n        if i == 0:\n            max_num += str(min(9, remaining_sum))\n            remaining_sum -= int(max_num[-1])\n        else:\n            max_num += str(max(0, remaining_sum))\n            remaining_sum -= int(max_num[-1])\n\n    max_num = max_num[::-1]\n\n    return int(min_num), int(max_num)\n\n\nm, s = map(int, input().split())\nmin_num, max_num = find_min_max(m, s)\nprint(min_num, max_num)"}
{"solution": "MOD = 998244353\n\ndef count(x, k):\n    if k == 1:\n        return sum(int(digit) * (10 ** i) for i, digit in enumerate(str(x)[::-1]))\n    else:\n        res = 0\n        for i in range(1, len(str(x)) + 1):\n            for j in range(1, 10):\n                res += j * (10 ** (i - 1)) * (9 ** (k - 1)) * (10 ** (len(str(x)) - i))\n                res %= MOD\n        return res\n\ndef solve():\n    l, r, k = map(int, input().split())\n    print((count(r, k) - count(l - 1, k)) % MOD)\n\nsolve()"}
{"solution": "import sys\n\nn, k, d = map(int, sys.stdin.readline().split())\na = sorted(map(int, sys.stdin.readline().split()))\n\nleft = 0\nwhile left < n:\n    right = left + 1\n    while right < n and a[right] - a[left] <= d:\n        right += 1\n    if right - left >= k:\n        left = right\n    else:\n        print(\"NO\")\n        sys.exit()\n\nprint(\"YES\")"}
{"solution": "def find_dead_bulbs(s):\n    colors = {'R': 0, 'B': 1, 'Y': 2, 'G': 3}\n    dead_bulbs = [0, 0, 0, 0]\n    pattern = [0, 1, 2, 3]\n    for i in range(len(s)):\n        if s[i] == '!':\n            dead_bulbs[pattern[i % 4]] += 1\n        else:\n            pattern = [colors[s[i]], (colors[s[i]] + 1) % 4, (colors[s[i]] + 2) % 4, (colors[s[i]] + 3) % 4]\n    return dead_bulbs\n\ns = input()\ndead_bulbs = find_dead_bulbs(s)\nprint(*dead_bulbs)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_int_list():\n    return list(read_ints())\n\ndef main():\n    n, m = read_ints()\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        s, t = read_ints()\n        s -= 1\n        t -= 1\n        graph[s].append(t)\n\n    out_degree = [len(graph[i]) for i in range(n)]\n    prob = [[0.0] * n for _ in range(n)]\n    for i in range(n):\n        for j in graph[i]:\n            prob[i][j] = 1.0 / out_degree[i]\n\n    expected = [0.0] * n\n    expected[-1] = 0.0\n    for _ in range(n):\n        for i in range(n - 1):\n            expected[i] = 1.0 + sum(prob[i][j] * expected[j] for j in range(n))\n\n    min_expected = float('inf')\n    for i in range(1, n):\n        if i in graph[0]:\n            new_prob = prob[0][i] / (1.0 - prob[0][i])\n            new_expected = expected[i] * new_prob + sum(expected[j] * prob[0][j] for j in range(n) if j!= i)\n            min_expected = min(min_expected, new_expected)\n\n    print(min_expected)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\nprint(n - (n % 10))"}
{"solution": "def find_swapped_keys(s, t):\n    swapped_keys = {}\n    for i in range(len(s)):\n        if s[i]!= t[i]:\n            if s[i] in swapped_keys:\n                if swapped_keys[s[i]]!= t[i]:\n                    return -1\n            elif t[i] in swapped_keys.values():\n                return -1\n            else:\n                swapped_keys[s[i]] = t[i]\n                swapped_keys[t[i]] = s[i]\n    return swapped_keys\n\n\ndef main():\n    s = input()\n    t = input()\n    swapped_keys = find_swapped_keys(s, t)\n    if swapped_keys == -1:\n        print(-1)\n    else:\n        pairs = [(key, value) for key, value in swapped_keys.items() if key < value]\n        print(len(pairs))\n        for pair in pairs:\n            print(pair[0], pair[1])\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef earliest_login(first_name, last_name):\n    first_prefix = first_name[0]\n    last_prefix = last_name[0]\n    for i in range(1, len(first_name)):\n        for j in range(1, len(last_name)):\n            new_login = first_name[:i] + last_name[:j]\n            if new_login < first_prefix + last_prefix:\n                first_prefix = first_name[:i]\n                last_prefix = last_name[:j]\n    return first_prefix + last_prefix\n\nfirst_name, last_name = input().split()\nprint(earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(n, brackets):\n    stack = []\n    max_height = 0\n    heights = [0] * n\n\n    for i, bracket in enumerate(brackets):\n        if bracket == '[':\n            stack.append(i)\n        else:\n            start = stack.pop()\n            height = 1\n            while start > 0 and heights[start - 1] >= height:\n                start -= 1\n                height += 1\n            heights[i] = height\n            heights[start] = height\n            max_height = max(max_height, height)\n\n    lines = [[' '] * (n * 2 + 1) for _ in range(max_height * 2 + 1)]\n\n    for i, bracket in enumerate(brackets):\n        if bracket == '[':\n            lines[0][i * 2] = '+'\n            lines[0][i * 2 + 1] = '-'\n            lines[1][i * 2] = '|'\n        else:\n            lines[0][i * 2] = '-'\n            lines[0][i * 2 + 1] = '+'\n            lines[1][i * 2] = '|'\n\n    for i in range(2, max_height * 2 + 1):\n        for j, bracket in enumerate(brackets):\n            if bracket == '[':\n                if heights[j] * 2 > i:\n                    lines[i][j * 2] = '|'\n                else:\n                    lines[i][j * 2] =''\n            else:\n                if heights[j] * 2 > i:\n                    lines[i][j * 2] = '|'\n                else:\n                    lines[i][j * 2] =''\n\n    for line in lines:\n        print(''.join(line))\n\nn = int(input())\nbrackets = input()\ndraw_brackets(n, brackets)"}
{"solution": "import math\n\ndef golden_system(s):\n    q = (math.sqrt(5) + 1) / 2\n    result = 0\n    for i, c in enumerate(reversed(s)):\n        result += int(c) * (q ** i)\n    return result\n\ns1 = input()\ns2 = input()\n\nif len(s1) > len(s2):\n    s2 = '0' * (len(s1) - len(s2)) + s2\nelif len(s2) > len(s1):\n    s1 = '0' * (len(s2) - len(s1)) + s1\n\nfor i in range(max(len(s1), len(s2))):\n    if s1[i] > s2[i]:\n        print('>')\n        break\n    elif s1[i] < s2[i]:\n        print('<')\n        break\nelse:\n    print('=')"}
{"solution": "n = int(input())\ncolors = [input() for _ in range(n)]\n\ngems = {\n    \"purple\": \"Power\",\n    \"green\": \"Time\",\n    \"blue\": \"Space\",\n    \"orange\": \"Soul\",\n    \"red\": \"Reality\",\n    \"yellow\": \"Mind\"\n}\n\nabsent_gems = [gem for color, gem in gems.items() if color not in colors]\n\nprint(len(absent_gems))\nfor gem in absent_gems:\n    print(gem)"}
{"solution": "import math\n\nn, a, b = map(int, input().split())\n\nrounds = int(math.log2(n))\n\nfor i in range(rounds):\n    if math.ceil(a / 2 ** i) == math.ceil(b / 2 ** i):\n        if i == rounds - 1:\n            print(\"Final!\")\n        else:\n            print(rounds - i)\n        break"}
{"solution": "def solve():\n    n = int(input())\n    p = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    cnt = sum(b) % 2\n    vis = [0] * (n + 1)\n    res = 0\n\n    for i in range(1, n + 1):\n        if not vis[i]:\n            j = i\n            while not vis[j]:\n                vis[j] = 1\n                j = p[j - 1]\n            res += 1\n\n    if res > 1:\n        res -= 1\n    if cnt:\n        res += 1\n    print(res)\n\nsolve()"}
{"solution": "v1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\nif v1 < v2:\n    v1, v2 = v2, v1\n\nmax_speed = v1\nmin_speed = v1 - (t - 1) * d\nmax_speed = min(max_speed, v2 + (t - 1) * d)\n\nif min_speed < v2:\n    min_speed = v2\n\ntotal_distance = (max_speed + min_speed) * t // 2\n\nprint(total_distance)"}
{"solution": "import sys\nimport itertools\n\ndef check_order(order, weights, parts):\n    total_weight = sum(weights)\n    max_weight = max(weights)\n    min_weight = min(weights)\n    min_sum = min(sum(weights[i] for i in range(len(weights) - 1)) for weights in itertools.permutations(weights))\n    if min_sum > parts[-1][1] or max_weight > parts[0][1]:\n        return False\n    if total_weight - min_weight <= parts[0][1]:\n        return True\n    for i in range(len(parts) - 1):\n        if parts[i][1] >= total_weight - min_weight:\n            continue\n        if parts[i + 1][1] < min_sum:\n            return False\n    return True\n\ndef solve(weights, parts):\n    min_distance = sys.maxsize\n    for order in itertools.permutations(range(len(weights))):\n        if not check_order(order, weights, parts):\n            continue\n        total_weight = sum(weights)\n        max_weight = max(weights)\n        min_weight = min(weights)\n        min_sum = min(sum(weights[i] for i in range(len(weights) - 1)) for weights in itertools.permutations(weights))\n        distance = 0\n        for i in range(len(parts) - 1):\n            if parts[i][1] >= total_weight - min_weight:\n                continue\n            if parts[i + 1][1] < min_sum:\n                break\n            distance = max(distance, parts[i][0])\n        min_distance = min(min_distance, distance)\n    return min_distance if min_distance!= sys.maxsize else -1\n\ndef main():\n    n, m = map(int, input().split())\n    weights = list(map(int, input().split()))\n    parts = [tuple(map(int, input().split())) for _ in range(m)]\n    print(solve(weights, parts))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef last_digit_factorial(n):\n    if n < 5:\n        return math.factorial(n) % 10\n    else:\n        return 0\n\na, b = map(int, input().split())\n\nif b < 5:\n    result = math.factorial(b) // math.factorial(a)\n    print(result % 10)\nelse:\n    print(last_digit_factorial(b) // last_digit_factorial(a))"}
{"solution": "from collections import deque\n\nn, d = map(int, input().split())\ns = input()\n\ndef min_jumps(n, d, s):\n    queue = deque([(1, 0)])\n    visited = set([1])\n\n    while queue:\n        pos, jumps = queue.popleft()\n        if pos == n:\n            return jumps\n\n        for i in range(1, d + 1):\n            new_pos = pos + i\n            if new_pos <= n and new_pos not in visited and s[new_pos - 1] == '1':\n                queue.append((new_pos, jumps + 1))\n                visited.add(new_pos)\n\n    return -1\n\nprint(min_jumps(n, d, s))"}
{"solution": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\nn = int(input())\nfor m in range(1, 1001):\n    if not is_prime(n * m + 1):\n        print(m)\n        break"}
{"solution": "def can_spend_all_coins(n):\n    for a in range(n // 1234567 + 1):\n        remaining_coins = n - a * 1234567\n        if remaining_coins < 0:\n            break\n        for b in range(remaining_coins // 123456 + 1):\n            remaining_coins_2 = remaining_coins - b * 123456\n            if remaining_coins_2 < 0:\n                break\n            if remaining_coins_2 % 1234 == 0:\n                return True\n    return False\n\nn = int(input())\nprint(\"YES\" if can_spend_all_coins(n) else \"NO\")"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef solve():\n    n = int(read_input())\n    x1, x2 = read_ints()\n    lines = []\n    for _ in range(n):\n        k, b = read_ints()\n        lines.append((k, b))\n\n    lines.sort()\n\n    events = []\n    for i in range(n):\n        k, b = lines[i]\n        x = (b - lines[0][1]) / (lines[0][0] - k) if k!= lines[0][0] else float('inf')\n        events.append((x, 1, i))\n        for j in range(i + 1, n):\n            k2, b2 = lines[j]\n            x = (b2 - b) / (k - k2) if k!= k2 else float('inf')\n            events.append((x, 0, i, j))\n\n    events.sort()\n\n    active = set()\n    for x, type, *args in events:\n        if x <= x1 or x >= x2:\n            continue\n        if type == 1:\n            active.add(args[0])\n        else:\n            i, j = args\n            if i in active and j in active:\n                print(\"Yes\")\n                return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import math\n\nn = int(input())\n\nweights = set()\n\nfor i in range(1, int(math.sqrt(n)) + 1):\n    if n % i == 0:\n        weights.add(i)\n        weights.add(n // i)\n\nprint(len(weights))"}
{"solution": "n, k = map(int, input().split())\n\nif k == 0 or k == 1 or n < k + 2:\n    print(0, 0)\nelse:\n    min_good = 1 if k == n else 2\n    max_good = min(k, n - k) * 2 - (k == n - k)\n    print(min_good, max_good)"}
{"solution": "def fibonacci(n):\n    a, b = 0, 1\n    while a < n:\n        a, b = b, a + b\n    return a\n\ndef find_max_games(n):\n    games = 0\n    while fibonacci(games + 2) <= n:\n        games += 1\n    return games\n\nn = int(input())\nprint(find_max_games(n))"}
{"solution": "def max_vk(s):\n    vk_count = s.count(\"VK\")\n    kv_count = s.count(\"KV\")\n    vv_count = s.count(\"VV\")\n    kk_count = s.count(\"KK\")\n\n    max_count = vk_count\n\n    if vv_count > 0:\n        max_count = max(max_count, vk_count + 1)\n\n    if kk_count > 0:\n        max_count = max(max_count, vk_count + 1)\n\n    if kv_count > 0:\n        max_count = max(max_count, vk_count + 1)\n\n    return max_count\n\ns = input()\nprint(max_vk(s))"}
{"solution": "import math\n\nn = int(input())\nif n == 1:\n    print(2)\nelse:\n    print(2 * math.isqrt(n) + (n - math.isqrt(n) ** 2) // math.isqrt(n))"}
{"solution": "a, b = map(int, input().split())\nyears = 0\n\nwhile a <= b:\n    a *= 3\n    b *= 2\n    years += 1\n\nprint(years)"}
{"solution": "def solve(h, n):\n    if h == 1:\n        return 2 if n == 2 else 1\n\n    nodes = 2 ** h\n    mid = nodes // 2\n    left = mid\n    right = nodes - mid\n\n    if n <= left:\n        return solve(h - 1, n) + 2 * (h - 1) + 1\n    else:\n        return solve(h - 1, n - left) + 2 * (h - 1) + 2\n\nh, n = map(int, input().split())\nprint(solve(h, n))"}
{"solution": "import math\n\ndef get_divisors(x):\n    divisors = set()\n    for i in range(1, int(math.sqrt(x)) + 1):\n        if x % i == 0:\n            divisors.add(i)\n            divisors.add(x // i)\n    return divisors\n\ndef get_tables(x):\n    tables = []\n    for n in range(1, int(math.sqrt(x)) + 1):\n        for m in get_divisors(x - (n * (n + 1)) // 2):\n            if m >= n and (m * (m + 1)) // 2 - (n * (n + 1)) // 2 == x:\n                tables.append((n, m))\n                if n!= m:\n                    tables.append((m, n))\n    return tables\n\nx = int(input())\ntables = get_tables(x)\nprint(len(tables))\nfor table in sorted(tables):\n    print(*table)"}
{"solution": "def is_leap(year):\n    return year % 4 == 0 and (year % 100!= 0 or year % 400 == 0)\n\ndef get_months(year):\n    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if is_leap(year):\n        months[1] = 29\n    return months\n\ndef check_sequence(sequence, months, start):\n    for i in range(len(sequence)):\n        if sequence[i]!= months[(start + i) % 12]:\n            return False\n    return True\n\nn = int(input())\nsequence = list(map(int, input().split()))\n\nfor year in range(2000, 2005):\n    months = get_months(year)\n    for start in range(12):\n        if check_sequence(sequence, months, start):\n            print(\"YES\")\n            exit()\n\nprint(\"NO\")"}
{"solution": "import math\n\ndef get_divisors(n):\n    divisors = []\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i!= n // i:\n                divisors.append(n // i)\n    return divisors\n\ndef get_sequence(n):\n    sequence = []\n    divisors = get_divisors(n)\n    for divisor in divisors:\n        if divisor!= n:\n            sequence.append((1, divisor))\n            sequence.append((divisor - 1, divisor))\n    return sequence\n\ndef get_sum(sequence):\n    total = 0\n    for a, b in sequence:\n        total += a / b\n    return total\n\ndef solve(n):\n    sequence = get_sequence(n)\n    total = get_sum(sequence)\n    if total == 1 - 1 / n:\n        return sequence\n    else:\n        return None\n\ndef main():\n    n = int(input())\n    sequence = solve(n)\n    if sequence is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(len(sequence))\n        for a, b in sequence:\n            print(a, b)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef read_ints():\n    return map(int, sys.stdin.readline().split())\n\ndef read_int():\n    return int(sys.stdin.readline())\n\ndef solve():\n    n = read_int()\n    a, b = read_ints()\n    h = list(read_ints())\n\n    total = sum(h)\n    if a < 0 or b < 0 or a + b < total:\n        print(-1)\n        return\n\n    dp = [[[float('inf')] * (total + 1) for _ in range(2)] for _ in range(n + 1)]\n    dp[0][0][0] = 0\n    dp[0][1][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(2):\n            for k in range(total + 1):\n                if k - h[i - 1] >= 0:\n                    dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - h[i - 1]])\n                if j == 0 and k + h[i - 1] <= total:\n                    dp[i][1][k + h[i - 1]] = min(dp[i][1][k + h[i - 1]], dp[i - 1][0][k] + h[i - 1])\n                if j == 1 and k + h[i - 1] <= total:\n                    dp[i][0][k + h[i - 1]] = min(dp[i][0][k + h[i - 1]], dp[i - 1][1][k] + h[i - 1])\n\n    ans = float('inf')\n    for i in range(total + 1):\n        if i <= a and total - i <= b:\n            ans = min(ans, dp[n][0][i], dp[n][1][i])\n\n    print(ans if ans!= float('inf') else -1)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn, m, k = map(int, input().split())\n\nif n % 2 == 0 and m % 2 == 0 and k % 2 == 0:\n    k //= 2\n    n //= 2\n    m //= 2\n\ng = gcd(n, m)\nif (n * m) // k < g:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(0, 0)\n    print(n, 0)\n    print(0, m - (m // g) * (k // (n // g)))"}
{"solution": "n, k = map(int, input().split())\nprint(\"YES\" if (n - 1) // k > n // (2 * k) else \"NO\")"}
{"solution": "n = int(input())\nexercises = list(map(int, input().split()))\n\nchest_exercises = sum(exercises[i] for i in range(0, n, 3))\nbiceps_exercises = sum(exercises[i] for i in range(1, n, 3))\nback_exercises = sum(exercises[i] for i in range(2, n, 3))\n\nmax_exercises = max(chest_exercises, biceps_exercises, back_exercises)\n\nif max_exercises == chest_exercises:\n    print(\"chest\")\nelif max_exercises == biceps_exercises:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "n = int(input())\ngrades = list(map(int, input().split()))\n\ntotal = sum(grades)\ncount = 0\n\nwhile (total + count) / (n + count) < 4.5:\n    count += 1\n\nprint(count)"}
{"solution": "def solve(u, v):\n    if u > v:\n        return None\n    if u % 2!= v % 2:\n        return None\n    if u == 0 and v == 0:\n        return []\n    if u == v:\n        return [u]\n    if v - u <= u:\n        return [v - u, u]\n    if v - u == 2 * u + 1:\n        return [1, 1, v - 2]\n    if v - u == 2 * u + 2:\n        return [2, v - 2 * u - 2, u]\n    if v - u == 2 * u + 3:\n        return [1, 3, v - 2 * u - 3, u]\n    if v - u == 2 * u + 4:\n        return [2, 2, v - 2 * u - 4, u]\n    if v - u == 2 * u + 5:\n        return [1, 1, 3, v - 2 * u - 5, u]\n    if v - u == 2 * u + 6:\n        return [2, 2, 2, v - 2 * u - 6, u]\n    if v - u == 2 * u + 7:\n        return [1, 3, 3, v - 2 * u - 7, u]\n    if v - u == 2 * u + 8:\n        return [2, 2, 2, 2, v - 2 * u - 8, u]\n    if v - u == 2 * u + 9:\n        return [1, 1, 3, 3, v - 2 * u - 9, u]\n    if v - u == 2 * u + 10:\n        return [2, 2, 2, 2, 2, v - 2 * u - 10, u]\n    if v - u == 2 * u + 11:\n        return [1, 3, 3, 3, v - 2 * u - 11, u]\n    if v - u == 2 * u + 12:\n        return [2, 2, 2, 2, 2, 2, v - 2 * u - 12, u]\n    if v - u == 2 * u + 13:\n        return [1, 1, 3, 3, 3, v - 2 * u - 13, u]\n    if v - u == 2 * u + 14:\n        return [2, 2, 2, 2, 2, 2, 2, v - 2 * u - 14, u]\n    if v - u == 2 * u + 15:\n        return [1, 3, 3, 3, 3, v - 2 * u - 15, u]\n    return None\n\nu, v = map(int, input().split())\nres = solve(u, v)\nif res is None:\n    print(-1)\nelse:\n    print(len(res))\n    print(*res)"}
{"solution": "def min_ones(n):\n    ones = [0] * 15\n    ones[1] = 1\n    for i in range(2, 15):\n        ones[i] = ones[i-1] * 10 + 1\n\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for i in range(1, n + 1):\n        for j in range(1, 15):\n            if ones[j] > i:\n                break\n            dp[i] = min(dp[i], dp[i - ones[j]] + j)\n\n    return dp[n]\n\nn = int(input())\nprint(min_ones(n))"}
{"solution": "import math\n\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\ndx = abs(x1 - x2)\ndy = abs(y1 - y2)\n\nif dx == 0:\n    print(\"YES\" if dy % y == 0 else \"NO\")\nelif dy == 0:\n    print(\"YES\" if dx % x == 0 else \"NO\")\nelse:\n    gcd = math.gcd(dx, dy)\n    print(\"YES\" if gcd == math.gcd(gcd, x) and gcd == math.gcd(gcd, y) else \"NO\")"}
{"solution": "from math import factorial\nfrom collections import Counter\n\ndef count_permutations(n):\n    n = str(n)\n    counter = Counter(n)\n    denominator = 1\n    for count in counter.values():\n        denominator *= factorial(count)\n    numerator = factorial(len(n) - 1) if n[0] == '0' else factorial(len(n))\n    return numerator // denominator\n\nn = int(input())\nprint(count_permutations(n))"}
{"solution": "a = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\nmin_ab = min(a, b)\nmin_cd = min(c, d)\nmin_ad = min(a, d)\n\nx = min(min_ab, min_cd)\ny = min_ad - x\n\ncost1 = x * f + y * e\ncost2 = min(min_ad, d) * e + (min(b, c, d - min(min_ad, d)) * f)\ncost3 = min(a, d) * e + (min(b, c, d - min(a, d)) * f)\n\nprint(max(cost1, cost2, cost3))"}
{"solution": "import math\n\ndef exgcd(a, b):\n    if b == 0:\n        return a, 1, 0\n    else:\n        gcd, x, y = exgcd(b, a % b)\n        return gcd, y, x - (a // b) * y\n\ndef mod_inverse(a, p):\n    gcd, x, y = exgcd(a, p)\n    return x % p\n\ndef solve():\n    a, b, p, x = map(int, input().split())\n    if b == 0:\n        if a == 1:\n            print(x)\n        else:\n            print(0)\n        return\n    if a == 1:\n        if b == 1:\n            print(x)\n        else:\n            print(0)\n        return\n    if a > p // 2:\n        a = p - a\n    k = 1\n    while pow(a, k, p)!= 1:\n        k += 1\n    if b % a!= 0:\n        print(0)\n        return\n    b //= a\n    ans = 0\n    for i in range(1, k + 1):\n        if pow(b, (k - i) * mod_inverse(k, p) % k, p) == pow(a, i, p):\n            ans += x // k\n            if x % k >= i:\n                ans += 1\n    print(ans)\n\nsolve()"}
{"solution": "k2, k3, k5, k6 = map(int, input().split())\n\nans = 0\nans += min(k5, k2, k6) * 256\nk2 -= min(k5, k2, k6)\nk5 -= min(k5, k2, k6)\nk6 -= min(k5, k2, k6)\n\nans += min(k2, k3) * 32\nk2 -= min(k2, k3)\nk3 -= min(k2, k3)\n\nprint(ans)"}
{"solution": "import math\n\nn, x, y, c = map(int, input().split())\n\nif n * n < c:\n    print(-1)\nelse:\n    if n % 2 == 0:\n        max_side = n\n    else:\n        max_side = n - 1\n\n    if x % 2 == 0:\n        x_side = x - 1\n    else:\n        x_side = x\n\n    if y % 2 == 0:\n        y_side = y - 1\n    else:\n        y_side = y\n\n    side = max(x_side, y_side, max_side - x_side + 1, max_side - y_side + 1)\n\n    if side * side < c:\n        print(-1)\n    else:\n        if side % 2 == 0:\n            side -= 1\n\n        if c <= (side // 2 + 1) ** 2:\n            print(0)\n        else:\n            print(2 * (math.ceil(math.sqrt(c)) - side // 2) - 1)"}
{"solution": "def max_xor(l, r):\n    if l == r:\n        return 0\n\n    max_val = 0\n    i = 0\n    while (1 << i) <= r:\n        i += 1\n\n    for j in range(i - 1, -1, -1):\n        if l + (1 << j) <= r:\n            max_val += 1 << j\n            l += 1 << j\n\n    return max_val\n\nl, r = map(int, input().split())\nprint(max_xor(l, r))"}
{"solution": "def check(n, k, h):\n    return (n * h) + (h - 1) * h <= 2 * k\n\ndef solve(n, k):\n    l, r = 0, k\n    while l < r:\n        mid = (l + r) // 2\n        if check(n, k, mid):\n            r = mid\n        else:\n            l = mid + 1\n    return l\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "x, y, z, t1, t2, t3 = map(int, input().split())\n\nstairs_time = abs(y - x) * t1\nelevator_time = (abs(z - x) * t2) + (2 * t3) + (abs(y - x) * t2)\n\nprint(\"YES\" if elevator_time <= stairs_time else \"NO\")"}
{"solution": "n, m = map(int, input().split())\nif m == 1:\n    print(2)\nelif m == n:\n    print(n - 1)\nelse:\n    print(m - 1 if m - 1 >= n - m else m + 1)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ncount = 0\ni = 0\nwhile i < n:\n    if a[i] == 1:\n        count += 1\n        while i < n and a[i] == 1:\n            count += 1\n            i += 1\n    elif i + 1 < n and a[i + 1] == 1:\n        count += 1\n        i += 1\n    i += 1\n\nprint(count)"}
{"solution": "n, k = map(int, input().split())\ncandies = list(map(int, input().split()))\n\ntotal_candies = 0\ndays = 0\ngiven_candies = 0\n\nfor candy in candies:\n    total_candies += candy\n    days += 1\n    given_candies += min(candy, 8)\n    if given_candies >= k:\n        break\n\nif given_candies < k:\n    print(-1)\nelse:\n    print(days)"}
{"solution": "import sys\n\nn, k = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\n\nb = [max(a[0], k)] + [max(a[i], b[i-1] - k + 1) for i in range(1, n)]\nadditional_walks = sum(b[i] - a[i] for i in range(n))\n\nprint(additional_walks)\nprint(*b)"}
{"solution": "n = int(input())\nprint(2*n**2 - 2*n + 1)"}
{"solution": "def is_pangram(s):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    return set(alphabet).issubset(set(s.lower()))\n\nn = int(input())\ns = input()\nprint(\"YES\" if is_pangram(s) else \"NO\")"}
{"solution": "def time_after_a_minutes(current_time, minutes_passed):\n    hours, mins = map(int, current_time.split(':'))\n    total_minutes = hours * 60 + mins + minutes_passed\n    new_hours = (total_minutes // 60) % 24\n    new_mins = total_minutes % 60\n    return f\"{new_hours:02d}:{new_mins:02d}\"\n\ncurrent_time = input()\nminutes_passed = int(input())\nprint(time_after_a_minutes(current_time, minutes_passed))"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    a = [input() for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            a[i] = a[i][:j] + '0' + a[i][j+1:]\n        if all('1' in row for row in zip(*a)):\n            return True\n        for j in range(m):\n            a[i] = a[i][:j] + '1' + a[i][j+1:]\n    return False\n\nprint(\"YES\" if solve() else \"NO\")"}
{"solution": "n = int(input())\ndominos = [list(map(int, input().split())) for _ in range(n)]\n\ndef is_even_sum(dominoes):\n    upper_sum = sum(x for x, y in dominoes)\n    lower_sum = sum(y for x, y in dominoes)\n    return upper_sum % 2 == 0 and lower_sum % 2 == 0\n\ndef rotate(dominoes, index):\n    dominoes[index][0], dominoes[index][1] = dominoes[index][1], dominoes[index][0]\n\ndef solve(dominoes):\n    if is_even_sum(dominoes):\n        return 0\n    for i in range(len(dominoes)):\n        rotate(dominoes, i)\n        if is_even_sum(dominoes):\n            return 1\n        rotate(dominoes, i)\n    return -1\n\nprint(solve(dominos))"}
{"solution": "import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef solve():\n    a, b = map(int, input().split())\n    area = a**2 - b**2\n    if is_prime(area):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nt = int(input())\nfor _ in range(t):\n    solve()"}
{"solution": "import sys\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # Collinear\n    elif val > 0:\n        return 1  # Clockwise\n    else:\n        return 2  # Counterclockwise\n\ndef convex_hull(points):\n    n = len(points)\n    if n < 3:\n        raise ValueError(\"Convex hull not possible\")\n\n    hull = []\n    l = 0\n    for i in range(1, n):\n        if points[i][0] < points[l][0]:\n            l = i\n\n    p = l\n    while True:\n        hull.append(points[p])\n        q = (p + 1) % n\n\n        for i in range(n):\n            if orientation(points[p], points[i], points[q]) == 2:\n                q = i\n\n        p = q\n        if p == l:\n            break\n\n    return hull\n\nhull = convex_hull(points)\n\nfor point in points:\n    if point not in hull:\n        continue\n    new_hull = [p for p in hull if p!= point]\n    if len(new_hull) < 3:\n        print(\"Yes\")\n        sys.exit()\n\n    min_x = min(p[0] for p in new_hull)\n    max_x = max(p[0] for p in new_hull)\n\n    if min_x > 0 or max_x < 0:\n        print(\"Yes\")\n        sys.exit()\n\nprint(\"No\")"}
{"solution": "import math\n\na, b = map(int, input().split())\nprint(math.factorial(min(a, b)))"}
{"solution": "n = int(input())\n\nif n % 2 == 0:\n    print(n + 9, 9)\nelse:\n    print(n + 8, 8)"}
{"solution": "import sys\nimport heapq\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_list():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n, m, p = read_ints()\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, c = read_ints()\n        a -= 1\n        b -= 1\n        adj[a].append((b, c))\n\n    dist = [float('inf')] * n\n    dist[0] = 0\n    pq = [(0, 0)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, c in adj[u]:\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                heapq.heappush(pq, (dist[v], v))\n\n    if dist[-1] == float('inf'):\n        print(-1)\n        return\n\n    dp = [[-float('inf')] * (n + 1) for _ in range(n)]\n    dp[-1][dist[-1]] = 0\n    for u in range(n - 1, -1, -1):\n        for d in range(n + 1):\n            if dp[u][d] == -float('inf'):\n                continue\n            for v, c in adj[u]:\n                if d + 1 <= n:\n                    dp[v][d + 1] = max(dp[v][d + 1], dp[u][d] + c)\n\n    ans = -float('inf')\n    for d in range(1, n + 1):\n        coins = dp[-1][d]\n        if coins < p * d:\n            continue\n        ans = max(ans, coins - p * d)\n        if p * d <= dp[-1][d]:\n            ans = max(ans, dp[-1][d] - p * d)\n            break\n    print(ans)\n\nif __name__ == '__main__':\n    solve()"}
{"solution": "from collections import defaultdict\nfrom itertools import combinations\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef can_form_palindrome(s1, s2):\n    return is_palindrome(s1 + s2)\n\ndef min_cost_to_palindrome(n, strings, costs):\n    odd_count = 0\n    odd_cost = 0\n    min_even_cost = float('inf')\n    min_odd_cost = float('inf')\n    min_pair_cost = float('inf')\n    pair_costs = defaultdict(lambda: float('inf'))\n\n    for s, c in zip(strings, costs):\n        if is_palindrome(s):\n            if c < min_even_cost:\n                min_even_cost = c\n        else:\n            odd_count += 1\n            odd_cost += c\n            rev_s = s[::-1]\n            if rev_s in strings:\n                idx = strings.index(rev_s)\n                pair_costs[s] = min(pair_costs[s], c + costs[idx])\n                if pair_costs[s] < min_pair_cost:\n                    min_pair_cost = pair_costs[s]\n            if c < min_odd_cost:\n                min_odd_cost = c\n\n    if odd_count == 0:\n        return min_even_cost if min_even_cost!= float('inf') else -1\n    elif odd_count == 1:\n        return min_odd_cost if min_odd_cost!= float('inf') else -1\n    else:\n        for r in range(1, n + 1):\n            for combo in combinations(range(n), r):\n                combo_s = ''.join([strings[i] for i in combo])\n                if is_palindrome(combo_s):\n                    combo_cost = sum([costs[i] for i in combo])\n                    if combo_cost < min_pair_cost:\n                        min_pair_cost = combo_cost\n        if min_pair_cost == float('inf'):\n            return -1\n        else:\n            return min_pair_cost\n\nn = int(input())\nstrings = []\ncosts = []\nfor _ in range(n):\n    s, c = input().split()\n    strings.append(s)\n    costs.append(int(c))\n\nprint(min_cost_to_palindrome(n, strings, costs))"}
{"solution": "def max_xor(n, k):\n    result = 0\n    i = 0\n    while n > 0:\n        if n >= 2**i and k > 0:\n            result += 2**i\n            k -= 1\n        n -= 2**i\n        i += 1\n    return result\n\nn, k = map(int, input().split())\nprint(max_xor(n, k))"}
{"solution": "import sys\n\nn = int(input())\nx_max, y_max = 0, 0\npoints = []\n\nfor _ in range(n):\n    x, y = map(int, input().split())\n    x_max = max(x_max, x)\n    y_max = max(y_max, y)\n    points.append((x, y))\n\ndef check(limit):\n    x, y = 0, 0\n    for px, py in points:\n        if px > x and py > y:\n            if px > limit or py > limit:\n                return False\n            if px > y:\n                y = px\n            if py > x:\n                x = py\n    return True\n\nleft, right = 0, max(x_max, y_max)\nwhile left < right:\n    mid = (left + right) // 2\n    if check(mid):\n        right = mid\n    else:\n        left = mid + 1\n\nprint(left)"}
{"solution": "from collections import Counter\n\ndef max_nineteens(s):\n    counter = Counter('nineteen')\n    s_counter = Counter(s)\n    return min(s_counter[c] // counter[c] for c in counter)\n\ns = input()\nprint(max_nineteens(s))"}
{"solution": "def highest_unreachable_branch(p, y):\n    def is_reachable(branch):\n        for i in range(2, p + 1):\n            if branch % i == 0 and branch // i <= y // i:\n                return True\n        return False\n\n    for branch in range(y, 1, -1):\n        if not is_reachable(branch):\n            return branch\n    return -1\n\np, y = map(int, input().split())\nprint(highest_unreachable_branch(p, y))"}
{"solution": "n, m, k = map(int, input().split())\nhouses = list(map(int, input().split()))\n\nmin_distance = float('inf')\n\nfor i in range(n):\n    if houses[i]!= 0 and houses[i] <= k:\n        distance = abs(m - 1 - i) * 10\n        min_distance = min(min_distance, distance)\n\nprint(min_distance)"}
{"solution": "from collections import defaultdict\n\ndef solve():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    b = [list(map(int, input().split())) for _ in range(n)]\n\n    cnt = defaultdict(int)\n    for i in range(n):\n        for j in range(m):\n            cnt[a[i][j]] += 1\n            cnt[b[i][j]] -= 1\n\n    for k, v in cnt.items():\n        if v!= 0:\n            print(\"NO\")\n            return\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j]!= b[i][j]:\n                break\n        else:\n            continue\n        break\n    else:\n        print(\"YES\")\n        return\n\n    for j in range(m):\n        for i in range(n):\n            if a[i][j]!= b[i][j]:\n                break\n        else:\n            continue\n        break\n    else:\n        print(\"YES\")\n        return\n\n    print(\"NO\")\n\nsolve()"}
{"solution": "def longest_uncommon_subsequence(a, b):\n    if a == b:\n        return -1\n    else:\n        return max(len(a), len(b))\n\na = input()\nb = input()\n\nprint(longest_uncommon_subsequence(a, b))"}
{"solution": "import math\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\ndef lcm(a, b):\n    return abs(a*b) // math.gcd(a, b)\n\nlcm_value = lcm(a, c)\nm = (d - b) % lcm_value\n\nif m!= 0:\n    print(-1)\nelse:\n    k = (d - b) // a\n    print(b + k * a)"}
{"solution": "n = int(input())\nif n % 3 == 0:\n    print(1, (n - 1) // 3 * 2, (n - 1) // 3)\nelse:\n    print((n - 2) // 3, (n - 2) // 3, n - (n - 2) // 3 * 2)"}
{"solution": "def solve():\n    n, a, b, c, d = map(int, input().split())\n    ans = 0\n    for x in range(1, n + 1):\n        for y in range(1, n + 1):\n            for z in range(1, n + 1):\n                s = a + b + x + y\n                if s - c - z < 1 or s - c - z > n:\n                    continue\n                t = s - c - z\n                if x + y + z + t!= s and x + y + c + d!= s and x + a + z + t!= s:\n                    continue\n                ans += 1\n    print(ans)\n\nsolve()"}
{"solution": "w, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\nstones = {d1: u1, d2: u2}\n\nfor i in range(h, 0, -1):\n    w += i\n    if i in stones:\n        w -= stones[i]\n        if w < 0:\n            w = 0\n\nprint(w)"}
{"solution": "m = int(input())\nc = list(map(int, input().split()))\nx, y = map(int, input().split())\n\ntotal_students = sum(c)\nfor k in range(1, m + 1):\n    beginner_group = sum(c[:k])\n    intermediate_group = total_students - beginner_group\n    if x <= beginner_group <= y and x <= intermediate_group <= y:\n        print(k)\n        break\nelse:\n    print(0)"}
{"solution": "import math\n\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\ndef min_coins(n, k, A, B):\n    coins = 0\n    while n > 1:\n        if n % k == 0:\n            coins += min(A * (n % k), B)\n            n = n // k\n        else:\n            coins += A\n            n -= 1\n    return coins\n\nprint(min_coins(n, k, A, B))"}
{"solution": "from collections import deque\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef solve(n):\n    factors = prime_factors(n)\n    factors.sort()\n    queue = deque([(n, 0)])\n    visited = set([n])\n    min_val = n\n    min_ops = 0\n    while queue:\n        curr, ops = queue.popleft()\n        if curr < min_val:\n            min_val = curr\n            min_ops = ops\n        sqrt = int(curr ** 0.5)\n        if sqrt ** 2 == curr and sqrt not in visited:\n            queue.append((sqrt, ops + 1))\n            visited.add(sqrt)\n        for factor in factors:\n            if curr % factor == 0:\n                new_val = curr // factor\n                if new_val not in visited:\n                    queue.append((new_val, ops + 1))\n                    visited.add(new_val)\n    return min_val, min_ops\n\nn = int(input())\nmin_val, min_ops = solve(n)\nprint(min_val, min_ops)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_strs():\n    return read_input().split()\n\ndef solve():\n    n, k = read_ints()\n    r, s, p = read_ints()\n    t = read_input()\n\n    win = {'r': p,'s': r, 'p': s}\n    dp = [[-1] * 3 for _ in range(n)]\n    for i in range(k):\n        for j in range(3):\n            if win[t[i]] == [r, s, p][j]:\n                dp[i][j] = win[t[i]]\n\n    for i in range(k, n):\n        for j in range(3):\n            if win[t[i]] == [r, s, p][j]:\n                dp[i][j] = max(dp[i - k][0] if j!= 0 else -1,\n                               dp[i - k][1] if j!= 1 else -1,\n                               dp[i - k][2] if j!= 2 else -1) + win[t[i]]\n            else:\n                dp[i][j] = max(dp[i - k][0] if j!= 0 else -1,\n                               dp[i - k][1] if j!= 1 else -1,\n                               dp[i - k][2] if j!= 2 else -1)\n\n    print(max(dp[-1]))\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "a, b, c = map(int, input().split())\nx = min(a, b)\ny = min(x, c)\na -= y\nb -= y\nc -= y\nprint(2 * c + 2 * min(a, b) + abs(a - b))"}
{"solution": "import sys\n\nn, k, p, x, y = map(int, input().split())\na = sorted(map(int, input().split()))\n\ntotal = sum(a)\nmedian_index = (n + 1) // 2\nmedian_count = n - k\n\nif total + (n - k) * p > x:\n    print(-1)\n    sys.exit()\n\nif a[k - median_count:] + [y] * median_count + a[:k - median_count] < [y] * median_index + a[median_index:]:\n    print(-1)\n    sys.exit()\n\nresult = []\nwhile len(result) < n - k:\n    if total + p <= x:\n        result.append(p)\n        total += p\n    elif total + y <= x:\n        result.append(y)\n        total += y\n    else:\n        result.append(x - total)\n        total = x\n        break\n\nprint(*result)"}
{"solution": "def is_berlanese(word):\n    vowels = 'aeiou'\n    for i in range(len(word) - 1):\n        if word[i] not in vowels and word[i]!= 'n' and word[i + 1] not in vowels:\n            return 'NO'\n    if word[-1] not in vowels and word[-1]!= 'n':\n        return 'NO'\n    return 'YES'\n\nword = input()\nprint(is_berlanese(word))"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, m = read_ints()\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = read_ints()\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def check(deg):\n        for i in range(n):\n            if len(graph[i]) > deg:\n                return False\n        return True\n\n    def solve(deg):\n        if not check(deg):\n            return 0\n        res = 0\n        for i in range(n):\n            if len(graph[i]) == deg:\n                res += 1\n        return res // 2\n\n    ans = 0\n    for deg in range(1, n + 1):\n        ans = max(ans, solve(deg))\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef read_ints():\n    return map(int, sys.stdin.readline().split())\n\ndef main():\n    n, m = read_ints()\n    a = list(read_ints())\n    b = list(read_ints())\n    b.sort(key=lambda x: a[x-1], reverse=True)\n\n    score = 0\n    for i in range(n):\n        if i in b:\n            score += a[i-1]\n            a[i-1] = score\n        else:\n            score += a[i-1] * 2\n\n    print(score)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_score(max_points, time, wrong_submissions):\n    return max(0.3 * max_points, (1 - time / 250) * max_points - 50 * wrong_submissions)\n\ndef main():\n    times = list(map(int, input().split()))\n    wrong_submissions = list(map(int, input().split()))\n    successful_hacks, unsuccessful_hacks = map(int, input().split())\n\n    max_points = [500, 1000, 1500, 2000, 2500]\n    total_score = sum(calculate_score(max_points[i], times[i], wrong_submissions[i]) for i in range(5))\n\n    total_score += 100 * successful_hacks - 50 * unsuccessful_hacks\n    print(int(total_score))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 998244353\n\ndef qpow(a, b):\n    res = 1\n    while b:\n        if b & 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b >>= 1\n    return res\n\ndef main():\n    n, m, L, R = map(int, input().split())\n    if n & 1 and m & 1:\n        print(qpow(R - L + 1, 1))\n    elif (n & 1) or (m & 1):\n        sum_val = 0\n        for i in range(L, R + 1):\n            if (i - L) & 1:\n                sum_val = (sum_val - qpow(R - i + 1, 1) + MOD) % MOD\n            else:\n                sum_val = (sum_val + qpow(R - i + 1, 1)) % MOD\n        print(sum_val)\n    else:\n        sum_val = 0\n        for i in range(L, R + 1):\n            if (i - L) & 1:\n                sum_val = (sum_val - qpow(R - i + 1, 2) + MOD) % MOD\n            else:\n                sum_val = (sum_val + qpow(R - i + 1, 2)) % MOD\n        print(sum_val)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_increasing(matrix):\n    n, m = len(matrix), len(matrix[0])\n    for i in range(n):\n        for j in range(m - 1):\n            if matrix[i][j] >= matrix[i][j + 1]:\n                return False\n    for j in range(m):\n        for i in range(n - 1):\n            if matrix[i][j] >= matrix[i + 1][j]:\n                return False\n    return True\n\n\ndef solve():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    b = [list(map(int, input().split())) for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] > b[i][j]:\n                a[i][j], b[i][j] = b[i][j], a[i][j]\n\n    if is_increasing(a) and is_increasing(b):\n        print(\"Possible\")\n    else:\n        print(\"Impossible\")\n\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort(reverse=True)\nans = 0\nfor i in range(n):\n    if a[i] > i:\n        ans += min(a[i], n - i)\n    else:\n        break\n\nprint(ans)"}
{"solution": "import heapq\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\nheap = []\nheapq.heappush(heap, -k)\n\ncount = 0\nfor num in a:\n    while -heap[0] < num / 2:\n        if -heap[0] >= num:\n            break\n        heapq.heappop(heap)\n        heapq.heappush(heap, -num)\n        count += 1\n    if -heap[0] < num / 2:\n        heapq.heappush(heap, -num)\n        count += 1\n    else:\n        heapq.heappop(heap)\n        heapq.heappush(heap, -num)\n\nprint(count)"}
{"solution": "n = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\nfirst = min(max_1, n - min_2 - min_3)\nsecond = min(max_2, n - first - min_3)\nthird = n - first - second\n\nprint(first, second, third)"}
{"solution": "def get_next_moon_state(n, moon_sizes):\n    moon_cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    current_state = moon_sizes[-1]\n    next_state = moon_cycle[(moon_cycle.index(current_state) + 1) % len(moon_cycle)]\n\n    if n < 30:\n        if current_state < next_state:\n            return \"UP\"\n        elif current_state > next_state:\n            return \"DOWN\"\n        else:\n            return \"-1\"\n    else:\n        if moon_sizes[-30:] == moon_cycle:\n            return \"UP\" if current_state < next_state else \"DOWN\"\n        else:\n            return \"-1\"\n\n\nn = int(input())\nmoon_sizes = list(map(int, input().split()))\nprint(get_next_moon_state(n, moon_sizes))"}
{"solution": "def can_transform(s, t):\n    vowels = set('aeiou')\n    if len(s)!= len(t):\n        return False\n    for i in range(len(s)):\n        if (s[i] in vowels and t[i] not in vowels) or (s[i] not in vowels and t[i] in vowels):\n            return False\n    return True\n\ns = input()\nt = input()\nprint(\"Yes\" if can_transform(s, t) else \"No\")"}
{"solution": "def min_steps(board, color):\n    min_steps = float('inf')\n    for row in range(8):\n        for col in range(8):\n            if board[row][col] == color:\n                if color == 'W':\n                    min_steps = min(min_steps, row)\n                else:\n                    min_steps = min(min_steps, 8 - row - 1)\n    return min_steps\n\nboard = [input() for _ in range(8)]\nmin_steps_A = min_steps(board, 'W')\nmin_steps_B = min_steps(board, 'B')\n\nif min_steps_A <= min_steps_B:\n    print('A')\nelse:\n    print('B')"}
{"solution": "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    m = int(input())\n    b = list(map(int, input().split()))\n\n    sa = [0] * (n + 1)\n    sb = [0] * (m + 1)\n    for i in range(n):\n        sa[i + 1] = sa[i] + a[i]\n    for i in range(m):\n        sb[i + 1] = sb[i] + b[i]\n\n    if sa[-1]!= sb[-1]:\n        print(-1)\n        return\n\n    ans = 0\n    for i in range(n):\n        for j in range(m):\n            if sa[i + 1] == sb[j + 1]:\n                ans = max(ans, 1 + solve_helper(a[i + 1:], b[j + 1:], sa[i + 1], sb[j + 1], sa, sb))\n\n    print(ans)\n\ndef solve_helper(a, b, sa, sb, sa_all, sb_all):\n    n = len(a)\n    m = len(b)\n    ans = 0\n    i = 0\n    j = 0\n    while i < n and j < m:\n        if a[i] == b[j]:\n            ans += 1\n            i += 1\n            j += 1\n        else:\n            if sa_all[i + 1] < sb_all[j + 1]:\n                while i < n and sa_all[i + 1] < sb_all[j + 1]:\n                    i += 1\n            else:\n                while j < m and sa_all[i + 1] > sb_all[j + 1]:\n                    j += 1\n            if sa_all[i + 1] == sb_all[j + 1]:\n                ans += 1\n                i += 1\n                j += 1\n    return ans\n\nsolve()"}
{"solution": "def is_from_contest(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    for friend in friends:\n        if problem_name.count(friend) == 1:\n            return \"YES\"\n    return \"NO\"\n\nproblem_name = input()\nprint(is_from_contest(problem_name))"}
{"solution": "import sys\n\ndef sieve_of_eratosthenes(n):\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n    p = 2\n    while p * p <= n:\n        if primes[p]:\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n    return primes\n\ndef main():\n    a, b, k = map(int, sys.stdin.readline().split())\n    primes = sieve_of_eratosthenes(b)\n    prime_count = [0] * (b + 1)\n    for i in range(2, b + 1):\n        if primes[i]:\n            prime_count[i] = prime_count[i - 1] + 1\n        else:\n            prime_count[i] = prime_count[i - 1]\n    min_l = float('inf')\n    for i in range(a, b + 1):\n        l = 1\n        while i + l - 1 <= b:\n            if prime_count[i + l - 1] - prime_count[i - 1] >= k:\n                min_l = min(min_l, l)\n                break\n            l += 1\n    if min_l == float('inf'):\n        print(-1)\n    else:\n        print(min_l)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef solve():\n    a, h, w = map(int, input().split())\n    ans = float('inf')\n    for n in range(1, h // a + 1):\n        if h % n!= 0:\n            continue\n        for m in range(1, w // a + 1):\n            if w % m!= 0:\n                continue\n            x = min((h - n * a) / (n + 1), (w - m * a) / (m + 1))\n            if x >= 0:\n                ans = min(ans, x)\n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nsolve()"}
{"solution": "n = int(input())\nchapters = [list(map(int, input().split())) for _ in range(n)]\nk = int(input())\n\ncount = 0\nfor chapter in chapters:\n    if chapter[0] >= k or chapter[1] >= k:\n        count += 1\n\nprint(count)"}
{"solution": "def can_form_codeforces(s):\n    codeforces = \"CODEFORCES\"\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            remaining = s[:i] + s[j:]\n            if all(c in remaining for c in codeforces) and remaining.count(c) >= codeforces.count(c) for c in set(codeforces):\n                return \"YES\"\n    return \"NO\"\n\ns = input()\nprint(can_form_codeforces(s))"}
{"solution": "import sys\n\ndef read_int():\n    return int(sys.stdin.readline())\n\ndef read_ints():\n    return map(int, sys.stdin.readline().split())\n\ndef solve():\n    n = read_int()\n    dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][i] = 0\n        dp[i][i + 1] = 0\n    for length in range(2, n):\n        for i in range(1, n - length + 1):\n            j = i + length\n            for k in range(i + 1, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + i * k * j)\n    print(dp[1][n] + sum(range(1, n + 1)))\n\nif __name__ == '__main__':\n    solve()"}
{"solution": "n = int(input())\ntotal_digits = 0\ni = 1\nwhile i <= n:\n    total_digits += len(str(i))\n    i += 1\nprint(total_digits)"}
{"solution": "def solve():\n    n, A = map(int, input().split())\n    c = list(map(int, input().split()))\n\n    cnt_A = 0\n    cnt_B = 0\n    max_cnt = 0\n    max_color = -1\n\n    for i in range(n):\n        if c[i] == A:\n            cnt_A += 1\n        else:\n            cnt_B += 1\n            if cnt_B > max_cnt and cnt_A <= cnt_B:\n                max_cnt = cnt_B\n                max_color = c[i]\n\n    if max_color!= -1:\n        return max_color\n\n    for i in range(1, 10**6 + 1):\n        if i == A:\n            continue\n        cnt_A = 0\n        cnt_B = 0\n        flag = True\n        for j in range(n):\n            if c[j] == A:\n                cnt_A += 1\n            elif c[j] == i:\n                cnt_B += 1\n            if cnt_A > cnt_B:\n                flag = False\n                break\n        if flag:\n            return i\n\n    return -1\n\nprint(solve())"}
{"solution": "n, x = map(int, input().split())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nif total_sum > x or (total_sum < x and total_sum + n - 1!= x):\n    print(\"NO\")\nelif total_sum == x or (total_sum < x and total_sum + n - 1 == x and a[0] > 1):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\nn, S = map(int, input().split())\nprint(math.ceil(S / (n + 1)))"}
{"solution": "from collections import Counter\n\ns = input()\nn = len(s)\ncnt = Counter(s)\n\nodd = sum(val % 2 for val in cnt.values())\nif odd > 1:\n    for char, val in cnt.items():\n        if val % 2 == 1:\n            cnt[char] -= 1\n            odd -= 1\n            break\n\nfirst_half = ''.join(char * (val // 2) for char, val in sorted(cnt.items()))\nmiddle = ''.join(char for char, val in sorted(cnt.items()) if val % 2 == 1)\n\nprint(first_half + middle + first_half[::-1])"}
{"solution": "def calculate_position_weight(board):\n    weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': -9, 'r': -5, 'b': -3, 'n': -3, 'p': -1\n    }\n    return sum(weights.get(piece, 0) for row in board for piece in row)\n\ndef main():\n    board = [input() for _ in range(8)]\n    weight = calculate_position_weight(board)\n    if weight > 0:\n        print(\"White\")\n    elif weight < 0:\n        print(\"Black\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import heapq\nimport sys\n\ndef solve():\n    n, m = map(int, input().split())\n    s = input()\n\n    dist = [float('inf')] * (n + 1)\n    prev = [-1] * (n + 1)\n    dist[0] = 0\n\n    pq = [(0, 0)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for i in range(1, m + 1):\n            v = u + i\n            if v > n or s[v] == '1':\n                continue\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                prev[v] = i\n                heapq.heappush(pq, (dist[v], v))\n\n    if dist[n] == float('inf'):\n        print(-1)\n        return\n\n    path = []\n    u = n\n    while u > 0:\n        path.append(prev[u])\n        u -= prev[u]\n    print(*reversed(path))\n\nif __name__ == '__main__':\n    solve()"}
{"solution": "import math\n\ndef solve():\n    k = int(input())\n    x, y = map(int, input().split())\n\n    if abs(x) % k == 0 and abs(y) % k == 0:\n        if abs(x) // k + abs(y) // k == 1:\n            print(1)\n            print(x, y)\n        else:\n            print(abs(x) // k + abs(y) // k)\n            steps = []\n            if x >= 0:\n                steps.append((k, 0))\n                x -= k\n            else:\n                steps.append((-k, 0))\n                x += k\n            if y >= 0:\n                steps.append((0, k))\n                y -= k\n            else:\n                steps.append((0, -k))\n                y += k\n            while x!= 0 or y!= 0:\n                if x >= 0:\n                    steps.append((k, 0))\n                    x -= k\n                else:\n                    steps.append((-k, 0))\n                    x += k\n                if y >= 0:\n                    steps.append((0, k))\n                    y -= k\n                else:\n                    steps.append((0, -k))\n                    y += k\n            for step in steps:\n                print(step[0], step[1])\n    else:\n        if (abs(x) + abs(y)) % k == 0:\n            print((abs(x) + abs(y)) // k)\n            steps = []\n            while x!= 0 or y!= 0:\n                if x >= 0 and y >= 0:\n                    if x >= y:\n                        steps.append((k, 0))\n                        x -= k\n                    else:\n                        steps.append((0, k))\n                        y -= k\n                elif x < 0 and y >= 0:\n                    if abs(x) >= y:\n                        steps.append((-k, 0))\n                        x += k\n                    else:\n                        steps.append((0, k))\n                        y -= k\n                elif x >= 0 and y < 0:\n                    if x >= abs(y):\n                        steps.append((k, 0))\n                        x -= k\n                    else:\n                        steps.append((0, -k))\n                        y += k\n                else:\n                    if abs(x) >= abs(y):\n                        steps.append((-k, 0))\n                        x += k\n                    else:\n                        steps.append((0, -k))\n                        y += k\n            for step in steps:\n                print(step[0], step[1])\n        else:\n            print(-1)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import math\n\ndef find_n(m):\n    n = 1\n    while True:\n        count = 0\n        for k in range(2, int(math.sqrt(n)) + 2):\n            a = 1\n            total = 0\n            for _ in range(4):\n                total += a\n                if total > n:\n                    break\n                a *= k\n            else:\n                count += 1\n        if count == m:\n            return n\n        elif count > m:\n            return -1\n        n += 1\n\nm = int(input())\nprint(find_n(m))"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    if d >= r1 + r2:\n        return 0\n    if d <= abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n    a = (r1 ** 2 - r2 ** 2 + d ** 2) / (2 * d)\n    h = math.sqrt(r1 ** 2 - a ** 2)\n    return r1 ** 2 * math.acos(a / r1) - a * h + r2 ** 2 * math.acos((d - a) / r2) - (d - a) * h\n\nx1, y1, r1 = map(float, input().split())\nx2, y2, r2 = map(float, input().split())\n\nprint(circle_intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "import math\n\ndef solve():\n    n = int(input())\n    if n == 1:\n        print(1)\n    elif n % 2 == 1:\n        print(1)\n    else:\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i!= 0:\n                print(1)\n                return\n        print(2)\n\nsolve()"}
{"solution": "from collections import defaultdict\n\ndef dfs(node, graph, a, dp):\n    if dp[node]!= -1:\n        return dp[node]\n    if not graph[node]:\n        dp[node] = a[node]\n        return a[node]\n    min_val = float('inf')\n    for child in graph[node]:\n        min_val = min(min_val, dfs(child, graph, a, dp))\n    dp[node] = a[node] + min_val\n    return dp[node]\n\ndef solve():\n    n = int(input())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    graph = defaultdict(list)\n    for i in range(n-1):\n        graph[p[i]].append(i+2)\n    dp = [-1] * (n + 1)\n    ans = float('inf')\n    for child in graph[1]:\n        ans = min(ans, dfs(child, graph, a, dp))\n    print(ans + a[0])\n\nsolve()"}
{"solution": "def count_common_words(n, s, t):\n    def get_prefix(s, t):\n        prefix = 0\n        while prefix < n and s[prefix] == t[prefix]:\n            prefix += 1\n        return prefix\n\n    def get_suffix(s, t):\n        suffix = 0\n        while suffix < n and s[n - suffix - 1] == t[n - suffix - 1]:\n            suffix += 1\n        return suffix\n\n    prefix = get_prefix(s, t)\n    suffix = get_suffix(s, t)\n    if prefix + suffix >= n - 1:\n        return 2 if s[prefix] == t[prefix + 1] and s[prefix + 1] == t[prefix] else 1\n    else:\n        return 0\n\nn = int(input())\ns = input()\nt = input()\nprint(count_common_words(n, s, t))"}
{"solution": "import sys\ninput = sys.stdin.readline\n\ndef dfs(u, p):\n    for v in adj[u]:\n        if v!= p:\n            dfs(v, u)\n            dp[u] = max(dp[u], dp[v] + 1)\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    dp = [1] * n\n    dfs(0, -1)\n\n    ans = float('-inf')\n    for i in range(n):\n        ans = max(ans, a[i] + dp[i] - 1)\n\n    print(ans)\n\nsolve()"}
{"solution": "n, m = map(int, input().split())\nprint(min(m, n - m + (m > 0)))"}
{"solution": "import math\n\nk, r = map(int, input().split())\n\ndef min_shovels(k, r):\n    for n in range(1, 11):\n        total = k * n\n        if (total - r) % 10 == 0:\n            return n\n    return 10\n\nprint(min_shovels(k, r))"}
{"solution": ""}
{"solution": "def min_segments():\n    points = [tuple(map(int, input().split())) for _ in range(3)]\n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n\n    x_unique = len(set(x_coords))\n    y_unique = len(set(y_coords))\n\n    if x_unique == 1 or y_unique == 1:\n        return 1\n    elif x_unique == 2 and y_unique == 2:\n        return 2\n    else:\n        return 3\n\nprint(min_segments())"}
{"solution": "import sys\n\ndef main():\n    k = int(sys.stdin.readline())\n\n    if k == 1:\n        print(\"YES\")\n        print(\"2 1\")\n        print(\"1 2\")\n        return\n\n    if k == 2:\n        print(\"NO\")\n        return\n\n    n = 2 * k\n    m = k * n // 2\n\n    print(\"YES\")\n    print(n, m)\n\n    for i in range(1, n // 2 + 1):\n        for j in range(1, k):\n            print(i, i + j)\n\n    print(n // 2, n // 2 + 1)\n\n    for i in range(n // 2 + 2, n + 1):\n        for j in range(1, k):\n            print(i, i + j)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef prefix_function(s):\n    n = len(s)\n    pi = [0] * n\n    for i in range(1, n):\n        j = pi[i - 1]\n        while j > 0 and s[i]!= s[j]:\n            j = pi[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        pi[i] = j\n    return pi\n\ndef kmp(s, t):\n    pi = prefix_function(t)\n    n, m = len(s), len(t)\n    count = [0] * (n + 1)\n    j = 0\n    for i in range(n):\n        while j > 0 and s[i]!= t[j]:\n            j = pi[j - 1]\n        if s[i] == t[j]:\n            j += 1\n        if j == m:\n            count[i - m + 2] += 1\n            j = pi[j - 1]\n    for i in range(1, n + 1):\n        count[i] += count[i - 1]\n    return count\n\ndef solve():\n    n, m, q = map(int, sys.stdin.readline().split())\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    count = kmp(s, t)\n    for _ in range(q):\n        l, r = map(int, sys.stdin.readline().split())\n        print(count[r] - count[l - 1])\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "MOD = 10**9 + 7\n\ndef solve():\n    n, k, d = map(int, input().split())\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            for x in range(1, min(i // j + 1, k + 1)):\n                dp[i][j] = (dp[i][j] + dp[i - j * x][x]) % MOD\n    ans = sum(dp[n][i] for i in range(d, k + 1)) % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "n = int(input())\nrow = input()\n\ngroups = []\ncurrent_group = 0\n\nfor square in row:\n    if square == 'B':\n        current_group += 1\n    elif current_group > 0:\n        groups.append(current_group)\n        current_group = 0\n\nif current_group > 0:\n    groups.append(current_group)\n\nprint(len(groups))\nprint(*groups)"}
{"solution": "import sys\n\ndef main():\n    n, m, p = map(int, sys.stdin.readline().split())\n    s = sys.stdin.readline().strip()\n    q = sys.stdin.readline().strip()\n\n    st = []\n    for i in range(n):\n        if s[i] == '(':\n            st.append(i)\n        else:\n            st.append(st.pop())\n\n    pos = p - 1\n    for op in q:\n        if op == 'L':\n            pos -= 1\n        elif op == 'R':\n            pos += 1\n        else:\n            if s[pos] == '(':\n                st.remove(pos)\n                pos = st.pop()\n            else:\n                st.remove(st[pos])\n                pos = st.pop()\n            if pos >= len(st):\n                pos = len(st) - 1\n\n    ans = [''] * len(st)\n    for i in range(len(st)):\n        if i < st[i]:\n            ans[i] = '('\n        else:\n            ans[i] = ')'\n\n    print(''.join(ans))\n\nif __name__ == '__main__':\n    main()"}
{"solution": "import sys\n\nn = int(input())\nmin_val = -2 * 10**9\nmax_val = 2 * 10**9\n\nfor _ in range(n):\n    sign, x, answer = input().split()\n    x = int(x)\n\n    if sign == \">\":\n        if answer == \"Y\":\n            min_val = max(min_val, x + 1)\n        else:\n            max_val = min(max_val, x)\n    elif sign == \"<\":\n        if answer == \"Y\":\n            max_val = min(max_val, x - 1)\n        else:\n            min_val = max(min_val, x)\n    elif sign == \">=\":\n        if answer == \"Y\":\n            min_val = max(min_val, x)\n        else:\n            max_val = min(max_val, x - 1)\n    elif sign == \"<=\":\n        if answer == \"Y\":\n            max_val = min(max_val, x)\n        else:\n            min_val = max(min_val, x + 1)\n\nif min_val <= max_val:\n    print(min_val)\nelse:\n    print(\"Impossible\")"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_periods(a, b):\n    total = a + b\n    count = 0\n    for i in range(1, total + 1):\n        if total % i == 0:\n            if a % (total // i) == 0 and b % (total // i) == 0:\n                count += 1\n            elif gcd(a, total // i) == gcd(b, total // i) == gcd(a + b, total // i):\n                count += 1\n    return count\n\na, b = map(int, input().split())\nprint(count_periods(a, b))"}
{"solution": "import string\n\ndef generate_name():\n    for i in range(26):\n        for j in range(26):\n            yield f\"{string.ascii_uppercase[i]}{string.ascii_lowercase[j]}\"\n\ndef solve():\n    n, k = map(int, input().split())\n    notes = input().split()\n    names = []\n    gen = generate_name()\n    for i in range(n):\n        if i < k - 1:\n            names.append(next(gen))\n        else:\n            if notes[i - k + 1] == \"YES\":\n                names.append(next(gen))\n            else:\n                names.append(names[i - k + 1])\n    print(\" \".join(names))\n\nsolve()"}
{"solution": "from math import gcd\nfrom functools import reduce\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef min_operations(a, b):\n    if a == b:\n        return 0\n    if a < b:\n        a, b = b, a\n\n    ops = 0\n    while a!= b:\n        if a % 2 == 0:\n            a //= 2\n            ops += 1\n        elif a % 3 == 0:\n            a *= 2\n            a //= 3\n            ops += 1\n        elif a % 5 == 0:\n            a *= 4\n            a //= 5\n            ops += 1\n        else:\n            return -1\n\n        if a < b:\n            a, b = b, a\n\n    return ops\n\na, b = map(int, input().split())\nprint(min_operations(a, b))"}
{"solution": "n, a, b = map(int, input().split())\nc = list(map(int, input().split()))\n\ncost = 0\nfor i in range(n // 2):\n    if c[i]!= c[n - i - 1]:\n        if c[i] == 2:\n            c[i] = c[n - i - 1]\n        elif c[n - i - 1] == 2:\n            c[n - i - 1] = c[i]\n        elif c[i]!= c[n - i - 1]:\n            print(-1)\n            exit()\n\nfor i in range(n // 2):\n    if c[i] == 2:\n        if c[n - i - 1] == 0:\n            cost += a\n        elif c[n - i - 1] == 1:\n            cost += b\n    elif c[i] == 0 and c[n - i - 1] == 2:\n        cost += a\n    elif c[i] == 1 and c[n - i - 1] == 2:\n        cost += b\n\nif n % 2 == 1 and c[n // 2] == 2:\n    if sum(c[:n // 2]) >= n // 2:\n        cost += b\n    else:\n        cost += a\n\nprint(cost)"}
{"solution": "import sys\n\nk = int(input())\n\nif k == 1:\n    print(-1)\n    sys.exit()\n\nfor i in range(k):\n    for j in range(k):\n        for z in range(k):\n            if (i + j + z) % 2 == 0:\n                print('b', end='')\n            else:\n                print('w', end='')\n        print()\n    print()"}
{"solution": "import math\n\ndef largest_lovely_number(n):\n    i = 2\n    while i * i <= n:\n        if n % (i * i) == 0:\n            while n % (i * i) == 0:\n                n //= i * i\n        i += 1\n    return n\n\nn = int(input())\nprint(largest_lovely_number(n))"}
{"solution": "n = int(input())\nseating = input()\n\ndef is_maximal(seating):\n    seating = '0' + seating + '0'\n    for i in range(1, len(seating) - 1):\n        if seating[i] == '1':\n            if seating[i-1] == '1' or seating[i+1] == '1':\n                return False\n            if seating[i-2] == '0' and seating[i+2] == '0':\n                return False\n    return True\n\nprint('Yes' if is_maximal(seating) else 'No')"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn = int(input())\na = list(map(int, input().split()))\n\ndiffs = [a[i] - a[i - 1] for i in range(1, n)]\ng = diffs[0]\nfor d in diffs:\n    g = gcd(g, d)\n\npossible_k = set()\nfor i in range(1, n + 1):\n    if n % i == 0 and g % i == 0:\n        possible_k.add(i)\n\nvalid_k = set()\nfor k in possible_k:\n    x = [a[i] - a[i - 1] for i in range(1, k + 1)]\n    valid = True\n    for i in range(k, n):\n        if a[i] - a[i - 1]!= x[(i - 1) % k]:\n            valid = False\n            break\n    if valid:\n        valid_k.add(k)\n\nprint(len(valid_k))\nprint(*sorted(valid_k))"}
{"solution": "from itertools import combinations\n\ndef can_form_equal_teams(scores):\n    total_sum = sum(scores)\n    if total_sum % 2!= 0:\n        return False\n\n    target_sum = total_sum // 2\n    for team in combinations(scores, 3):\n        if sum(team) == target_sum:\n            return True\n\n    return False\n\nscores = list(map(int, input().split()))\nprint(\"YES\" if can_form_equal_teams(scores) else \"NO\")"}
{"solution": "import sys\n\ndef count_2_3_integers(left, right):\n    count = 0\n    for x in range(31):\n        for y in range(20):\n            num = (1 << x) * (3 ** y)\n            if left <= num <= right:\n                count += 1\n    return count\n\nleft, right = map(int, sys.stdin.readline().split())\nprint(count_2_3_integers(left, right))"}
{"solution": "import math\n\nn, k = map(int, input().split())\n\ndef solve(n, k):\n    if n == 1:\n        return 0\n\n    total_sum = 0\n    i = 1\n    while True:\n        total_sum += i\n        if total_sum > k:\n            break\n        i += 1\n\n    x = i - 1\n    total_sum -= x\n    n -= x\n\n    if total_sum == k:\n        return n\n\n    if n % 2 == 0:\n        return (n // 2) - 1 + (k - total_sum)\n\n    return (n // 2) + (k - total_sum)\n\nprint(solve(n, k))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\nfor i in range(n - 2):\n    if a[i] + a[i + 1] > a[i + 2]:\n        print(\"YES\")\n        sys.exit()\n\nprint(\"NO\")"}
{"solution": "x, y = map(int, input().split())\n\nif y == 1 and x > 0:\n    print(\"No\")\nelif y - 1 > x:\n    print(\"No\")\nelse:\n    print(\"Yes\" if (x - (y - 1)) % 2 == 0 else \"No\")"}
{"solution": "import sys\n\nn, k = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\n\nskills = {}\nfor i in range(n):\n    skill = a[i] // 10\n    skills[skill] = skills.get(skill, []) + [a[i]]\n\ntotal_rating = 0\nfor skill in sorted(skills.keys()):\n    for value in skills[skill]:\n        if value + 10 <= 100 and k > 0:\n            total_rating += 1\n            k -= 10 - (value % 10)\n        total_rating += value // 10\n\nprint(total_rating)"}
{"solution": "n, m = map(int, input().split())\na = sorted(map(int, input().split()))\nb = sorted(map(int, input().split()))\n\ncommon = set(a) & set(b)\nif common:\n    print(min(common))\nelse:\n    min_a = min(a)\n    min_b = min(b)\n    print(min_a * 10 + min_b if min_a < min_b else min_b * 10 + min_a)"}
{"solution": "n, k = map(int, input().split())\ntotal_time = 240 - k\nproblems_solved = 0\ntime_spent = 0\n\nfor i in range(1, n + 1):\n    time_required = 5 * i\n    if time_spent + time_required <= total_time:\n        time_spent += time_required\n        problems_solved += 1\n    else:\n        break\n\nprint(problems_solved)"}
{"solution": "import sys\n\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\ncnt = 0\nfor i in a:\n    if i <= y:\n        y -= i\n        cnt += 1\n    elif i <= 2 * x + y:\n        if i % 2 == 1:\n            y -= 1\n        x -= (i + 1) // 2\n        cnt += 1\n    else:\n        break\n\nprint(cnt)"}
{"solution": "import math\n\ndef count_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return divisors\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_different_numbers(b):\n    divisors = count_divisors(b)\n    result = 0\n    for d in divisors:\n        result += 1\n        for d2 in divisors:\n            if d!= d2 and lcm(d, d2) == b:\n                result -= 1\n                break\n    return result\n\nb = int(input())\nprint(count_different_numbers(b))"}
{"solution": "n = int(input())\ns = input()\n\ndef simulate(start):\n    while 0 <= start < n:\n        if s[start] == '<':\n            start -= 1\n        else:\n            start += 1\n        if start < 0 or start >= n:\n            return True\n    return False\n\ndef solve():\n    left, right = 0, n - 1\n    while left < right and s[left] == '<':\n        left += 1\n    while left < right and s[right] == '>':\n        right -= 1\n    if left >= right:\n        return n\n    if s[left] == '>' and s[right] == '<':\n        return 0\n    if s[left] == '<':\n        return n - left\n    return right + 1\n\nprint(solve())"}
{"solution": "import sys\n\nn = int(input())\nl = list(map(int, input().split()))\n\ncount = {}\nfor i in l:\n    if i in count:\n        count[i] += 1\n    else:\n        count[i] = 1\n\nsorted_count = sorted(count.items())\n\ndp = [0] * (n + 1)\nfor i, (length, freq) in enumerate(sorted_count):\n    if freq >= 2:\n        dp[i + 1] = max(dp[i], freq // 2 * length * length)\n    if i > 0 and freq >= 1 and sorted_count[i - 1][1] >= 1:\n        dp[i + 1] = max(dp[i + 1], dp[i], (freq + sorted_count[i - 1][1]) // 2 * length * (length - 1))\n    if i > 0 and freq >= 2 and sorted_count[i - 1][1] >= 2:\n        dp[i + 1] = max(dp[i + 1], dp[i], freq // 2 * length * length + sorted_count[i - 1][1] // 2 * (length - 1) * (length - 1))\n    if i > 0 and freq >= 1 and sorted_count[i - 1][1] >= 3:\n        dp[i + 1] = max(dp[i + 1], dp[i], (freq + sorted_count[i - 1][1]) // 2 * length * (length - 1))\n    dp[i + 1] = max(dp[i + 1], dp[i])\n\nprint(dp[-1])"}
{"solution": "from collections import defaultdict\n\nn = int(input())\ns = [input() for _ in range(n)]\n\ncnt = defaultdict(int)\nfor si in s:\n    for i, c in enumerate(si[::-1]):\n        cnt[c] += 10 ** i\n\nt = sorted(cnt.items(), key=lambda x: x[1], reverse=True)\nd = {c: str(i) for i, (c, _) in enumerate(t, 1)}\n\nfor i, c in enumerate('abcdefghij'):\n    if c not in d:\n        d[c] = str(i)\n\nans = 0\nfor si in s:\n    ans += int(''.join(d[c] for c in si))\n\nprint(ans)"}
{"solution": "n, m = map(int, input().split())\n\na = min(n, m // 2)\nm -= a * 2\nn -= a\n\nb = min(m, n // 2)\n\nprint(a + b)"}
{"solution": "def solve(s):\n    ab = s.find(\"AB\")\n    ba = s.find(\"BA\")\n    if ab!= -1 and ba!= -1:\n        if ab > ba:\n            return \"YES\" if ab + 1 > ba + 1 else \"NO\"\n        else:\n            return \"YES\" if ab + 1 < ba else \"NO\"\n    return \"NO\"\n\ns = input()\nprint(solve(s))"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    k = int(input())\n    b = list(map(int, input().split()))\n\n    if sum(a)!= sum(b):\n        print(\"NO\")\n        return\n\n    ans = []\n    for i in range(n - k):\n        for j in range(n - i - 1):\n            if a[j] > a[j + 1]:\n                a[j] += a[j + 1]\n                a[j + 1] = 0\n                ans.append((j + 1, 'L'))\n                break\n            elif a[j] < a[j + 1]:\n                a[j + 1] += a[j]\n                a[j] = 0\n                ans.append((j + 2, 'R'))\n                break\n        else:\n            print(\"NO\")\n            return\n\n    if a!= b:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    for x, y in ans:\n        print(x, y)\n\nsolve()"}
{"solution": "import sys\n\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # Collinear\n    elif val > 0:\n        return 1  # Clockwise\n    else:\n        return 2  # Counterclockwise\n\ndef intersect(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if (o1!= o2 and o3!= o4):\n        return True\n\n    if (o1 == 0 and on_segment(p1, p2, q1)):\n        return True\n\n    if (o2 == 0 and on_segment(p1, q2, q1)):\n        return True\n\n    if (o3 == 0 and on_segment(p2, p1, q2)):\n        return True\n\n    if (o4 == 0 and on_segment(p2, q1, q2)):\n        return True\n\n    return False\n\ndef on_segment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n        q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\ndef is_valid(edges, n):\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(n):\n                for last in range(k + 1, n):\n                    if intersect(edges[i], edges[j], edges[k], edges[last]):\n                        return False\n    return True\n\nR, B = map(int, input().split())\nspaceships = []\nbases = []\nfor _ in range(R):\n    x, y = map(int, input().split())\n    spaceships.append((x, y))\nfor _ in range(B):\n    x, y = map(int, input().split())\n    bases.append((x, y))\n\nif R!= B:\n    print(\"No\")\n    sys.exit()\n\nedges = []\nfor i in range(R):\n    edges.append((spaceships[i], bases[i]))\n\nif is_valid(edges, R):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "import math\n\nn = int(input())\na = list(map(int, input().split()))\n\ndef max_power_of_two(x):\n    return 2 ** math.floor(math.log2(x))\n\nmax_power = max(map(max_power_of_two, a))\ncount = sum(1 for x in a if x % max_power == 0)\n\nprint(max_power, count)"}
{"solution": "def min_clicks(n, m):\n    clicks = 0\n    while m > n:\n        if m % 2 == 0:\n            m //= 2\n        else:\n            m += 1\n        clicks += 1\n    return clicks + (n - m)\n\nn, m = map(int, input().split())\nprint(min_clicks(n, m))"}
{"solution": "import sys\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x]!= x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x!= root_y:\n            if self.rank[root_x] > self.rank[root_y]:\n                self.parent[root_y] = root_x\n            elif self.rank[root_x] < self.rank[root_y]:\n                self.parent[root_x] = root_y\n            else:\n                self.parent[root_y] = root_x\n                self.rank[root_x] += 1\n\ndef solve():\n    n = int(sys.stdin.readline())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, sys.stdin.readline().split())\n        segments.append((l, r))\n\n    points = sorted(set([l for l, _ in segments] + [r for _, r in segments]))\n    point_map = {p: i for i, p in enumerate(points)}\n\n    tree = UnionFind(n)\n    for i, (l, r) in enumerate(segments):\n        l, r = point_map[l], point_map[r]\n        for j in range(l + 1, r):\n            if tree.find(i)!= tree.find(point_map[j]):\n                tree.union(i, point_map[j])\n\n    roots = set()\n    for i in range(n):\n        roots.add(tree.find(i))\n\n    if len(roots) == 1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import sys\n\ndef solve():\n    n = int(input())\n    r = list(map(int, input().split()))\n\n    max_len = 0\n    for i in range(n):\n        total = 0\n        for j in range(i, n):\n            total += r[j]\n            if total > 100 * (j - i + 1):\n                max_len = max(max_len, j - i + 1)\n\n    print(max_len)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "n, k = map(int, input().split())\nepisodes = input()\n\nmax_dissatisfaction = 0\ncurrent_dissatisfaction = 0\n\nfor episode in episodes:\n    if episode == 'N':\n        current_dissatisfaction += 1\n        max_dissatisfaction = max(max_dissatisfaction, current_dissatisfaction)\n    else:\n        current_dissatisfaction = 0\n\nif max_dissatisfaction > k:\n    print(\"NO\")\nelse:\n    if k == 0:\n        print(\"YES\")\n    else:\n        episodes = episodes.replace('?', 'N')\n        dissatisfaction = 0\n        max_dissatisfaction = 0\n        for episode in episodes:\n            if episode == 'N':\n                dissatisfaction += 1\n                max_dissatisfaction = max(max_dissatisfaction, dissatisfaction)\n            else:\n                dissatisfaction = 0\n        if max_dissatisfaction == k:\n            print(\"YES\")\n        else:\n            print(\"NO\")"}
{"solution": "import sys\n\ndef main():\n    n, x, d = map(int, sys.stdin.readline().split())\n\n    if d == 0:\n        print(1 if n % 2 == 0 else 2)\n        return\n\n    max_sum = (n * (2 * x + (n - 1) * d)) // 2\n    min_sum = 0\n\n    if n % 2 == 0:\n        mid_sum = (n * (2 * x + (n - 1) * d)) // 4\n        print(2 * (max_sum - mid_sum) + 1)\n    else:\n        mid_sum = (n * (2 * x + (n - 1) * d)) // 4 + (x + (n - 1) // 2 * d) // 2\n        print(2 * (max_sum - mid_sum) + 1)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def get_color(rating):\n    if rating >= 2400:\n        return \"red\"\n    elif rating >= 2200:\n        return \"orange\"\n    elif rating >= 2000:\n        return \"blue\"\n    elif rating >= 1800:\n        return \"violet\"\n    elif rating >= 1500:\n        return \"indigo\"\n    else:\n        return \"gray\"\n\nn = int(input())\ngood_performance = False\n\nfor _ in range(n):\n    name, before, after = input().split()\n    before, after = int(before), int(after)\n    if get_color(before) == \"red\" and after > before:\n        good_performance = True\n        break\n\nprint(\"YES\" if good_performance else \"NO\")"}
{"solution": "def count_missed_trains(s):\n    count = 0\n    i = 0\n    while i < len(s):\n        if s[i] == '1':\n            count += 1\n            i += 2\n        else:\n            i += 1\n    return count\n\ns = input()\nprint(count_missed_trains(s))"}
{"solution": "def min_rows(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n    rows = n\n\n    for i in range(n // 2):\n        if matrix[i] == matrix[n - i - 1]:\n            rows -= 1\n        else:\n            break\n\n    return rows\n\n\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\nprint(min_rows(matrix))"}
{"solution": "import sys\n\ndef max_non_overlapping_orders(orders):\n    orders.sort(key=lambda x: x[1])\n    end_time = -sys.maxsize\n    count = 0\n\n    for start, end in orders:\n        if start > end_time:\n            count += 1\n            end_time = end\n\n    return count\n\nn = int(input())\norders = [tuple(map(int, input().split())) for _ in range(n)]\n\nprint(max_non_overlapping_orders(orders))"}
{"solution": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    x = list(map(int, sys.stdin.readline().split()))\n    y = list(map(int, sys.stdin.readline().split()))\n\n    x_prev, y_prev = 0, 0\n    for i in range(n):\n        x_prev, y_prev = x[i] + x_prev, y[i] + y_prev\n        if x_prev > k * (i + 1) or y_prev > k * (i + 1):\n            print(\"NO\")\n            return\n        if x[i] > k or y[i] > k:\n            print(\"NO\")\n            return\n        if x_prev - (k - 1) > y_prev or y_prev - (k - 1) > x_prev:\n            print(\"NO\")\n            return\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def main():\n    n, k = map(int, input().split())\n    a = [input().strip() for _ in range(n + 1)]\n\n    p = 0\n    for i in range(n + 1):\n        if a[i] == '?':\n            p += k ** i\n        else:\n            p += int(a[i]) * (k ** i)\n\n    if p % (k ** (n + 1)) == 0:\n        print(\"Yes\")\n    else:\n        if (n + 1) % 2 == 0:\n            print(\"No\")\n        else:\n            print(\"Yes\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef smallest_multiple(p, x):\n    return (x + p - 1) // p * p\n\ndef smallest_start(x2):\n    min_x0 = x2\n    for p in range(2, x2):\n        if is_prime(p):\n            x1 = smallest_multiple(p, x2)\n            if x1 < x2:\n                for q in range(2, x1):\n                    if is_prime(q):\n                        x0 = smallest_multiple(q, x1)\n                        if x0 < x1:\n                            min_x0 = min(min_x0, x0)\n    return min_x0\n\nx2 = int(input())\nprint(smallest_start(x2))"}
{"solution": "def solve(n, p):\n    for i in range(1, n + 1):\n        if bin((n - i * p)).count('1') <= i:\n            return i\n    return -1\n\nn, p = map(int, input().split())\nprint(solve(n, p))"}
{"solution": "n, k = map(int, input().split())\ns = input()\n\nif k == 0:\n    print(s)\nelse:\n    s = list(s)\n    if s[0]!= '1':\n        s[0] = '1'\n        k -= 1\n    for i in range(1, n):\n        if k > 0 and s[i]!= '0':\n            s[i] = '0'\n            k -= 1\n    print(''.join(s))"}
{"solution": "def min_presents(cnt_1, cnt_2, x, y):\n    def count_excluded(n, p):\n        return n // p\n\n    def count_excluded_both(n, p, q):\n        return n // (p * q)\n\n    def count_included(n, p, q):\n        return n - count_excluded(n, p) - count_excluded(n, q) + count_excluded_both(n, p, q)\n\n    def check(v):\n        included = count_included(v, x, y)\n        if included < cnt_1 + cnt_2:\n            return False\n        excluded_x = count_excluded(v, x)\n        excluded_y = count_excluded(v, y)\n        excluded_both = count_excluded_both(v, x, y)\n        if excluded_x - excluded_both >= cnt_2 and included - (excluded_x - excluded_both) >= cnt_1:\n            return True\n        if excluded_y - excluded_both >= cnt_1 and included - (excluded_y - excluded_both) >= cnt_2:\n            return True\n        return False\n\n    left, right = 1, cnt_1 + cnt_2 + x + y\n    while left < right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ncnt_1, cnt_2, x, y = map(int, input().split())\nprint(min_presents(cnt_1, cnt_2, x, y))"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip().split()\n\ndef main():\n    n, sx, sy, dx, dy, t = map(int, read_input())\n    sx -= 1\n    sy -= 1\n    dx += sx + sy + 1\n    dy += sx + sy + 1\n    for _ in range(t):\n        sx = (sx + dx - 1) % n\n        sy = (sy + dy - 1) % n\n        dx += sx + sy + 1 + _\n        dy += sx + sy + 1 + _\n    print(sx + 1, sy + 1)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from string import ascii_uppercase\n\ndef solve(s):\n    n = len(s)\n    if n < 26:\n        return -1\n\n    alphabet = set(ascii_uppercase)\n    window = set()\n    left = 0\n    for right in range(n):\n        if s[right]!= '?':\n            window.add(s[right])\n        while len(window) == 26:\n            if s[left]!= '?':\n                window.remove(s[left])\n            left += 1\n\n    if left + 26 > n:\n        return -1\n\n    result = list(s)\n    for i in range(left, left + 26):\n        if result[i] == '?':\n            for char in alphabet - window:\n                result[i] = char\n                window.add(char)\n                break\n        else:\n            window.add(result[i])\n\n    for i in range(n):\n        if result[i] == '?':\n            for char in alphabet - set(result):\n                result[i] = char\n                break\n\n    return ''.join(result)\n\ns = input()\nresult = solve(s)\nif result == -1:\n    print(-1)\nelse:\n    print(result)"}
{"solution": "n = int(input())\nweights = list(map(int, input().split()))\n\ntotal_weight = sum(weights)\nif total_weight % 2!= 0:\n    print(\"NO\")\nelse:\n    target_weight = total_weight // 2\n    weights.sort(reverse=True)\n    first_person_weight = 0\n    for weight in weights:\n        if first_person_weight + weight <= target_weight:\n            first_person_weight += weight\n        else:\n            break\n    print(\"YES\" if first_person_weight == target_weight else \"NO\")"}
{"solution": "import sys\n\ndef min_time_to_turn_off_lights(n, m, building):\n    total_time = 0\n    for i in range(n):\n        floor = building[i]\n        left_stairs_time = 0\n        right_stairs_time = 0\n        for j in range(1, m + 1):\n            if floor[j] == '1':\n                left_stairs_time = max(left_stairs_time, j * 2 - 1)\n                right_stairs_time = max(right_stairs_time, (m + 1 - j) * 2 - 1)\n        total_time += min(left_stairs_time, right_stairs_time) + 1\n    return total_time\n\nn, m = map(int, sys.stdin.readline().split())\nbuilding = [sys.stdin.readline().strip() for _ in range(n)]\n\nprint(min_time_to_turn_off_lights(n, m, building))"}
{"solution": "from collections import defaultdict, deque\n\ndef find_cycle(graph, start):\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if node not in graph['visited']:\n            graph['visited'].add(node)\n            stack.extend(neighbor for neighbor in graph['graph'][node] if neighbor not in graph['visited'])\n            graph['stack'].append(node)\n        elif node in graph['stack']:\n            cycle = []\n            while graph['stack'][-1]!= node:\n                cycle.append(graph['stack'].pop())\n            cycle.append(graph['stack'].pop())\n            return cycle\n    return None\n\ndef find_scc(graph):\n    scc = []\n    visited = set()\n    stack = []\n    low = {}\n    index = {}\n    idx = 0\n    for node in graph:\n        if node not in visited:\n            strongconnect(node, graph, visited, stack, low, index, idx, scc)\n    return scc\n\ndef strongconnect(node, graph, visited, stack, low, index, idx, scc):\n    index[node] = idx\n    low[node] = idx\n    idx += 1\n    stack.append(node)\n    visited.add(node)\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            strongconnect(neighbor, graph, visited, stack, low, index, idx, scc)\n            low[node] = min(low[node], low[neighbor])\n        elif neighbor in stack:\n            low[node] = min(low[node], index[neighbor])\n    if low[node] == index[node]:\n        connected_component = []\n        while True:\n            w = stack.pop()\n            connected_component.append(w)\n            if w == node:\n                break\n        scc.append(connected_component)\n\ndef solve():\n    n = int(input())\n    c = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    graph = defaultdict(list)\n    for i in range(n):\n        graph[i].append(a[i] - 1)\n    scc = find_scc(graph)\n    scc_costs = {}\n    for component in scc:\n        min_cost = float('inf')\n        for node in component:\n            min_cost = min(min_cost, c[node])\n        scc_costs[tuple(component)] = min_cost\n    total_cost = 0\n    for component in scc:\n        total_cost += scc_costs[tuple(component)]\n    print(total_cost)\n\nsolve()"}
{"solution": "n, a, b = map(int, input().split())\nprint((a + b - 1) % n + 1)"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    if all(x == -1 for x in a):\n        print(1)\n        return\n\n    ans = 1\n    i = 0\n    while i < n:\n        if a[i] == -1:\n            i += 1\n            continue\n        j = i + 1\n        while j < n and a[j]!= -1:\n            j += 1\n        if j == n:\n            break\n        if j - i == 1:\n            i = j\n            continue\n        d = a[i + 1] - a[i]\n        k = i + 2\n        while k < j and a[k] - a[k - 1] == d:\n            k += 1\n        if k == j:\n            i = j\n            continue\n        if a[k] == -1:\n            l = k + 1\n            while l < j and a[l] == -1:\n                l += 1\n            if l == j:\n                i = j\n                continue\n            if a[l] - a[k - 1] == d:\n                i = l\n                continue\n        ans += 1\n        i = j\n    print(ans)\n\nsolve()"}
{"solution": "def max_beauty(n, k, s):\n    def max_beauty_with_char(c):\n        left = 0\n        beauty = 0\n        changes = 0\n        for right in range(n):\n            if s[right]!= c:\n                changes += 1\n            while changes > k:\n                if s[left]!= c:\n                    changes -= 1\n                left += 1\n            beauty = max(beauty, right - left + 1)\n        return beauty\n\n    return max(max_beauty_with_char('a'), max_beauty_with_char('b'))\n\nn, k = map(int, input().split())\ns = input()\nprint(max_beauty(n, k, s))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ntotal_seats = sum(a)\nmajority = (total_seats + 1) // 2\n\nif a[0] >= majority:\n    print(1)\n    print(1)\nelse:\n    coalition = [1]\n    current_sum = a[0]\n    for i in range(1, n):\n        if a[i] * 2 <= a[0] and current_sum + a[i] <= majority:\n            coalition.append(i + 1)\n            current_sum += a[i]\n    if current_sum < majority:\n        print(0)\n    else:\n        print(len(coalition))\n        print(*coalition)"}
{"solution": "import sys\n\nn = int(sys.stdin.readline())\n\nresult = 0\nwhile n > 0:\n    result += n / (n + 1) if n > 1 else 1\n    n -= 1\n\nprint(f\"{result:.15f}\")"}
{"solution": "import math\n\nn = int(input())\nk = int(math.sqrt(2 * n))\n\nwhile (k * (k + 1)) // 2 > n:\n    k -= 1\n\nprint(k)\nfor i in range(1, k + 1):\n    print(i, end=\" \")\nprint(n - (k * (k + 1)) // 2 + k)"}
{"solution": "n = int(input())\nm = int(input())\nprint(m % (1 << n))"}
{"solution": "n = int(input())\ns = input()\nvowels = set('aeiouy')\n\nstack = []\nfor char in s:\n    if char in vowels and stack and stack[-1] in vowels:\n        stack.pop()\n    else:\n        stack.append(char)\n\nprint(''.join(stack))"}
{"solution": "import sys\n\nn, a, b = map(int, input().split())\ns = input()\n\nempty = []\ncurr = 0\nfor i in range(n):\n    if s[i] == '*':\n        if curr > 0:\n            empty.append(curr)\n        curr = 0\n    else:\n        curr += 1\nif curr > 0:\n    empty.append(curr)\n\nans = 0\nfor x in empty:\n    if x % 2 == 0:\n        ans += min(x // 2, a, b)\n        a -= min(x // 2, a, b)\n        b -= min(x // 2, a, b)\n    else:\n        ans += min(x // 2 + 1, a + b)\n        if a < b:\n            a -= min(x // 2, a)\n            b -= min(x // 2 + 1, a + b) - min(x // 2, a)\n        else:\n            b -= min(x // 2, b)\n            a -= min(x // 2 + 1, a + b) - min(x // 2, b)\n\nprint(ans)"}
{"solution": "import math\n\ndef solve():\n    r = int(input())\n    for x in range(1, int(math.sqrt(r)) + 1):\n        discriminant = 4 * x**2 - 4 * (r - x**2 - x - 1)\n        if discriminant >= 0:\n            y = (2 * x + math.sqrt(discriminant)) / 2\n            if y == int(y) and y > 0:\n                print(x, int(y))\n                return\n    print(\"NO\")\n\nsolve()"}
{"solution": "import itertools\n\ndef solve(n, a):\n    total = sum(a)\n    if n == 1 or total % 2 == 0 and a[0] == a[-1]:\n        return [-1]\n\n    for k in range(1, n):\n        for indices in itertools.combinations(range(n), k):\n            if sum(a[i] for i in indices)!= total - sum(a[i] for i in indices):\n                return [k] + [i + 1 for i in indices]\n\n    return [-1]\n\nn = int(input())\na = list(map(int, input().split()))\nprint(*solve(n, a))"}
{"solution": "import sys\n\nn = int(input())\n\nfor i in range(9, 0, -1):\n    count = n // i\n    if count > 0:\n        print(count)\n        print(' '.join([str(i)] * count))\n        sys.exit(0)"}
{"solution": "import sys\n\ndef sieve_of_eratosthenes(n):\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n    p = 2\n    while p * p <= n:\n        if primes[p]:\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n    return primes\n\ndef is_prime(n, primes):\n    return primes[n]\n\ndef find_simple_subset(a, primes):\n    a.sort()\n    n = len(a)\n    max_size = 0\n    max_subset = []\n    for i in range(n):\n        subset = [a[i]]\n        for j in range(i + 1, n):\n            if is_prime(a[i] + a[j], primes):\n                subset.append(a[j])\n        if len(subset) > max_size:\n            max_size = len(subset)\n            max_subset = subset\n    return max_size, max_subset\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    primes = sieve_of_eratosthenes(2 * 10**6)\n    max_size, max_subset = find_simple_subset(a, primes)\n    print(max_size)\n    print(*max_subset)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef is_beautiful(n):\n    binary = bin(n)[2:]\n    k = 0\n    while k < len(binary) and binary[k] == '1':\n        k += 1\n    if k == 0:\n        return False\n    while k < len(binary) and binary[k] == '0':\n        k += 1\n    return k == len(binary)\n\ndef greatest_beautiful_divisor(n):\n    for i in range(int(math.sqrt(n)), 0, -1):\n        if n % i == 0:\n            if is_beautiful(i):\n                return i\n            if is_beautiful(n // i):\n                return n // i\n    return 1\n\nn = int(input())\nprint(greatest_beautiful_divisor(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(m, d, a, b):\n    n = len(a)\n    dp = [[0] * m for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(m):\n            for k in range(10):\n                if i % 2 == 0 and k!= d:\n                    dp[i][(j + k * (10 ** (i - 1) % m)) % m] += dp[i - 1][j]\n                elif i % 2 == 1 and k == d:\n                    dp[i][(j + k * (10 ** (i - 1) % m)) % m] += dp[i - 1][j]\n                dp[i][(j + k * (10 ** (i - 1) % m)) % m] %= MOD\n\n    def count(x):\n        res = 0\n        for i in range(1, len(x) + 1):\n            for j in range(m):\n                for k in range(int(x[i - 1]) if i > 1 else 1):\n                    if i % 2 == 0 and k!= d:\n                        res += dp[i - 1][j]\n                    elif i % 2 == 1 and k == d:\n                        res += dp[i - 1][j]\n                    res %= MOD\n                if i % 2 == 0 and int(x[i - 1]) == d:\n                    break\n                elif i % 2 == 1 and int(x[i - 1])!= d:\n                    break\n                res += dp[i][(j + int(x[i - 1]) * (10 ** (i - 1) % m)) % m]\n                res %= MOD\n        return res\n\n    return (count(b) - count(a) + dp[n][0]) % MOD\n\nm, d = map(int, input().split())\na = input()\nb = input()\nprint(solve(m, d, a, b))"}
{"solution": "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\ni = 0\nwhile True:\n    a[i] -= m\n    if a[i] <= 0:\n        if all(x <= 0 for x in a):\n            print(i + 1)\n            break\n        a.pop(i)\n        if not a:\n            print(i + 1)\n            break\n        n -= 1\n    else:\n        a.append(a.pop(i))"}
{"solution": "n = int(input())\nbills = [100, 20, 10, 5, 1]\ncount = 0\n\nfor bill in bills:\n    count += n // bill\n    n %= bill\n\nprint(count)"}
{"solution": "MOD = 1000000007\n\ndef solve():\n    n, k = map(int, input().split())\n    dp = [[[0 for _ in range(2)] for _ in range(n + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            for t in range(2):\n                if t == 0:\n                    dp[i][j][t] = (dp[i][j][t] + dp[i - 1][j][0]) % MOD\n                    if j > 0:\n                        dp[i][j][t] = (dp[i][j][t] + dp[i - 1][j - 1][1]) % MOD\n                else:\n                    dp[i][j][t] = (dp[i][j][t] + dp[i - 1][j][1]) % MOD\n                    if j > 0:\n                        dp[i][j][t] = (dp[i][j][t] + (i - 1 - j) * dp[i - 1][j - 1][0]) % MOD\n                        dp[i][j][t] = (dp[i][j][t] + (i - 1 - j) * dp[i - 1][j - 1][1]) % MOD\n\n    print((dp[n][k][0] + dp[n][k][1]) % MOD)\n\nsolve()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_int_list():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n, k = read_ints()\n    b = read_int_list()\n    c = read_input()\n\n    red = []\n    white = []\n    orange = []\n\n    for i in range(n):\n        if c[i] == 'R':\n            red.append(b[i])\n        elif c[i] == 'W':\n            white.append(b[i])\n        else:\n            orange.append(b[i])\n\n    red.sort(reverse=True)\n    white.sort(reverse=True)\n    orange.sort(reverse=True)\n\n    def get_max(red, white, k):\n        max_sum = 0\n        for i in range(1, k):\n            if i >= len(red) or k - i >= len(white):\n                break\n            max_sum = max(max_sum, sum(red[:i]) + sum(white[:k - i]))\n        return max_sum\n\n    max_sum = -1\n    if orange:\n        for i in range(1, k):\n            if i >= len(orange):\n                break\n            remaining = k - i\n            if remaining >= len(red) or remaining >= len(white):\n                continue\n            max_sum = max(max_sum, sum(orange[:i]) + max(get_max(red, white, remaining), get_max(white, red, remaining)))\n\n    print(max_sum)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef simplify(p, q):\n    g = gcd(p, q)\n    return p // g, q // g\n\np, q = map(int, input().split())\nn = int(input())\na = list(map(int, input().split()))\n\nfor i in range(n - 1, 0, -1):\n    a[i - 1] = a[i - 1] * a[i] + 1\n\np2, q2 = a[0], 1\np2, q2 = simplify(p2, q2)\n\nprint(\"YES\" if p == p2 and q == q2 else \"NO\")"}
{"solution": "def solve(expression):\n    parts = expression.split('+')\n    a, b = parts[0], parts[1].split('=')[0]\n    c = parts[1].split('=')[1]\n\n    def check(a, b, c):\n        return a.count('|') + b.count('|') == c.count('|')\n\n    if check(a, b, c):\n        return expression\n\n    for i in range(len(a)):\n        new_a = a[:i] + a[i+1:]\n        new_b = b + '|'\n        if check(new_a, new_b, c):\n            return new_a + '+' + new_b + '=' + c\n\n    for i in range(len(b)):\n        new_b = b[:i] + b[i+1:]\n        new_a = a + '|'\n        if check(new_a, new_b, c):\n            return new_a + '+' + new_b + '=' + c\n\n    for i in range(len(c)):\n        new_c = c[:i] + c[i+1:]\n        new_b = b + '|'\n        if check(a, new_b, new_c):\n            return a + '+' + new_b + '=' + new_c\n\n    for i in range(len(a)):\n        new_a = a[:i] + a[i+1:]\n        new_c = c + '|'\n        if check(new_a, b, new_c):\n            return new_a + '+' + b + '=' + new_c\n\n    for i in range(len(b)):\n        new_b = b[:i] + b[i+1:]\n        new_c = c + '|'\n        if check(a, new_b, new_c):\n            return a + '+' + new_b + '=' + new_c\n\n    return 'Impossible'\n\nexpression = input()\nprint(solve(expression))"}
{"solution": "MOD = 10**9 + 7\n\ndef main():\n    n, k = map(int, input().split())\n    dp = [[0] * (n * n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i * i + 1):\n            for d in range(i + 1):\n                if j - d < 0:\n                    continue\n                dp[i][j] += dp[i - 1][j - d] * (i - d)\n                dp[i][j] %= MOD\n\n    print(dp[n][k])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef solve():\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    def check(x, y):\n        for i in range(n):\n            if abs(points[i][0] - x) + abs(points[i][1] - y)!= m:\n                return False\n        return True\n\n    for m in range(1, 41):\n        for x in range(-m, m + 1):\n            for y in range(-m, m + 1):\n                if check(x, y):\n                    print(m)\n                    print(*([1] * m))\n                    for i in range(n):\n                        px, py = 0, 0\n                        ans = []\n                        for j in range(m):\n                            dx = points[i][0] - px\n                            dy = points[i][1] - py\n                            if dx > 0:\n                                ans.append('R')\n                                px += 1\n                            elif dx < 0:\n                                ans.append('L')\n                                px -= 1\n                            elif dy > 0:\n                                ans.append('U')\n                                py += 1\n                            elif dy < 0:\n                                ans.append('D')\n                                py -= 1\n                        print(''.join(ans))\n                    return\n    print(-1)\n\nif __name__ == '__main__':\n    solve()"}
{"solution": "import re\n\nn = int(input())\ns = input()\n\nprint(re.sub('o(go)+', '***', s))"}
{"solution": "def prime_factors(n):\n    i = 2\n    factors = {}\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors[i] = factors.get(i, 0) + 1\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef g(y, p):\n    k = 0\n    while y % p == 0:\n        y //= p\n        k += 1\n    return p ** k\n\ndef f(x, y):\n    factors = prime_factors(x)\n    result = 1\n    for p in factors:\n        result = (result * g(y, p)) % (10**9 + 7)\n    return result\n\ndef main():\n    x, n = map(int, input().split())\n    factors = prime_factors(x)\n    result = 1\n    for p in factors:\n        k = factors[p]\n        sum_p_k = (p ** k * (n // (p ** k) * (p - 1) + (n % (p ** k) - 1) // (p - 1))) % (10**9 + 7)\n        result = (result * sum_p_k) % (10**9 + 7)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve(a, b, c):\n    solutions = set()\n    for x in range(1, 10**9):\n        if x == b * (sum_of_digits(x) ** a) + c:\n            solutions.add(x)\n    return sorted(list(solutions))\n\na, b, c = map(int, input().split())\nsolutions = solve(a, b, c)\nprint(len(solutions))\nprint(*solutions)"}
{"solution": "def is_solved(cube):\n    for i in range(0, 24, 4):\n        if len(set(cube[i:i+4]))!= 1:\n            return False\n    return True\n\ndef rotate_face(cube, face):\n    faces = {\n        0: [0, 1, 2, 3],\n        1: [4, 5, 6, 7],\n        2: [8, 9, 10, 11],\n        3: [12, 13, 14, 15],\n        4: [16, 17, 18, 19],\n        5: [20, 21, 22, 23]\n    }\n    face = faces[face]\n    cube[face[0]], cube[face[1]], cube[face[2]], cube[face[3]] = cube[face[3]], cube[face[0]], cube[face[1]], cube[face[2]]\n    return cube\n\ndef is_solvable(cube):\n    for i in range(6):\n        if is_solved(rotate_face(cube[:], i)):\n            return True\n    return False\n\ncube = list(map(int, input().split()))\nprint(\"YES\" if is_solvable(cube) else \"NO\")"}
{"solution": "def get_score(s):\n    i = (s // 50) % 475\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        yield 26 + i\n\ndef solve():\n    p, x, y = map(int, input().split())\n    best = float('inf')\n    for s in range(x, y - 1, -1):\n        if s % 50 == 0:\n            continue\n        if p in get_score(s):\n            best = min(best, (s - x + 99) // 100)\n    for s in range(y, y + 2500):\n        if p in get_score(s):\n            best = min(best, (s - x + 99) // 100)\n    print(best)\n\nsolve()"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nif n == 1:\n    print(0)\nelse:\n    print(min((n-1)*a + (n-2)*c, (n-1)*b + (n-2)*c, (n-1)*c + (n-2)*a, (n-1)*c + (n-2)*b))"}
{"solution": "x1, x2, x3 = map(int, input().split())\nprint(sum(abs(x - sorted([x1, x2, x3])[1]) for x in [x1, x2, x3]))"}
{"solution": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    s = set()\n    for i in range(n):\n        a[i] &= x\n        s.add(a[i])\n\n    if len(s) < n:\n        print(0)\n        return\n\n    s = set()\n    for i in range(n):\n        if a[i] in s:\n            print(1)\n            return\n        s.add(a[i])\n\n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def check_plus_shape(grid):\n    h, w = len(grid), len(grid[0])\n    center = None\n\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*':\n                if center is None:\n                    center = (i, j)\n                else:\n                    if (i, j) not in [(center[0], center[1] - 1), (center[0], center[1] + 1), \n                                      (center[0] - 1, center[1]), (center[0] + 1, center[1])]:\n                        return False\n\n    if center is None:\n        return False\n\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for dx, dy in directions:\n        x, y = center[0] + dx, center[1] + dy\n        while 0 <= x < h and 0 <= y < w and grid[x][y] == '*':\n            x += dx\n            y += dy\n        if (x, y)!= (center[0] - dx, center[1] - dy):\n            return False\n\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*' and (i, j) not in [(center[0] + dx, center[1] + dy) for dx, dy in directions]:\n                return False\n\n    return True\n\n\nh, w = map(int, input().split())\ngrid = [input() for _ in range(h)]\n\nif check_plus_shape(grid):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef solve(n, a, b):\n    if a == 1 and b == 1:\n        return \"NO\"\n    if a == 1:\n        return [[1 if i!= j else 0 for j in range(n)] for i in range(n)]\n    if b == 1:\n        return [[0 if i!= j else 0 for j in range(n)] for i in range(n)]\n    if a + b > n + 1:\n        return \"NO\"\n    if a == b:\n        return \"NO\"\n\n    matrix = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i // (n - a) == j // (n - a):\n                matrix[i][j] = matrix[j][i] = 1\n\n    return matrix\n\ndef print_matrix(matrix):\n    if matrix == \"NO\":\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for row in matrix:\n            print(\"\".join(map(str, row)))\n\nn, a, b = map(int, sys.stdin.readline().split())\nmatrix = solve(n, a, b)\nprint_matrix(matrix)"}
{"solution": "import math\n\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\ntotal_winners_needed = n * m - k\n\nif total_winners_needed <= 0:\n    print(0)\nelse:\n    main_rounds = math.ceil(total_winners_needed / n)\n    additional_rounds = total_winners_needed - main_rounds * n\n    total_problems = main_rounds * c + additional_rounds * d\n    print(total_problems)"}
{"solution": "def solve(s):\n    if len(s)!= 27:\n        return \"Impossible\"\n\n    grid = [[' ']*13 for _ in range(2)]\n    grid[0][0] = s[0]\n    grid[1][0] = s[1]\n    grid[0][12] = s[2]\n    grid[1][12] = s[3]\n\n    for i in range(4, 27):\n        for x in range(2):\n            for y in range(13):\n                if grid[x][y] == s[i-1] and grid[x^1][y] =='':\n                    grid[x^1][y] = s[i]\n                    break\n                elif grid[x][y] == s[i-1] and grid[x][(y+1)%13] =='':\n                    grid[x][(y+1)%13] = s[i]\n                    break\n                elif grid[x][y] == s[i-1] and grid[x][(y-1)%13] =='':\n                    grid[x][(y-1)%13] = s[i]\n                    break\n            else:\n                continue\n            break\n        else:\n            return \"Impossible\"\n\n    return ''.join(grid[0]) + '\\n' + ''.join(grid[1])\n\ns = input()\nprint(solve(s))"}
{"solution": "import math\n\nx, y = map(int, input().split())\n\nif x == y:\n    print('=')\nelif x > y:\n    if math.log(x) / y > math.log(y) / x:\n        print('>')\n    else:\n        print('<')\nelse:\n    if math.log(x) / y < math.log(y) / x:\n        print('>')\n    else:\n        print('<')"}
{"solution": "import math\n\nr, h = map(int, input().split())\n\nballoons_in_height = math.floor(h / (r / 2)) + 1\nballoons_in_radius = math.floor(r / (r / 2)) + 1\n\nballoons_in_semicircle = math.floor((math.pi * r * r) / (math.pi * (r / 2) * (r / 2))) // 2\n\nprint(balloons_in_semicircle + (balloons_in_radius - 1) * balloons_in_height)"}
{"solution": "import sys\n\nnumbers = list(map(int, input().split()))\nnumbers.sort()\n\nmin_sum = sum(numbers)\n\n# Check if we can discard two or three cards with the same number\nif numbers[0] == numbers[1] == numbers[2]:\n    min_sum = min(min_sum, sum(numbers[3:]))\nelif numbers[0] == numbers[1]:\n    min_sum = min(min_sum, sum(numbers[2:]))\nelif numbers[1] == numbers[2] == numbers[3]:\n    min_sum = min(min_sum, sum(numbers[:1]) + sum(numbers[4:]))\nelif numbers[2] == numbers[3] == numbers[4]:\n    min_sum = min(min_sum, sum(numbers[:2]))\n\nprint(min_sum)"}
{"solution": "import sys\n\ndef main():\n    n, a = map(int, sys.stdin.readline().split())\n    x = sorted(map(int, sys.stdin.readline().split()))\n\n    a_idx = next((i for i, val in enumerate(x) if val >= a), n)\n    left = x[:a_idx]\n    right = x[a_idx:]\n\n    left_dist = sum(abs(a - val) for val in left)\n    right_dist = sum(abs(a - val) for val in right)\n\n    if len(left) > len(right):\n        if len(left) > 1:\n            left_dist -= abs(left[-1] - left[-2])\n        if len(right):\n            left_dist += abs(left[-1] - right[0])\n    elif len(right) > len(left):\n        if len(right) > 1:\n            right_dist -= abs(right[0] - right[1])\n        if len(left):\n            right_dist += abs(right[0] - left[-1])\n\n    print(min(left_dist, right_dist))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve(n):\n    x = math.isqrt(n)\n    while x * x <= n:\n        s_x = sum_of_digits(x)\n        if x * x + s_x * x - n == 0:\n            return x\n        x += 1\n    return -1\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def calculate_bed_time(current_time, sleep_time):\n    current_time_parts = list(map(int, current_time.split(':')))\n    sleep_time_parts = list(map(int, sleep_time.split(':')))\n\n    current_time_minutes = current_time_parts[0] * 60 + current_time_parts[1]\n    sleep_time_minutes = sleep_time_parts[0] * 60 + sleep_time_parts[1]\n\n    bed_time_minutes = (current_time_minutes - sleep_time_minutes) % (24 * 60)\n\n    bed_time_hours = bed_time_minutes // 60\n    bed_time_minutes %= 60\n\n    return f\"{bed_time_hours:02d}:{bed_time_minutes:02d}\"\n\ncurrent_time = input()\nsleep_time = input()\n\nprint(calculate_bed_time(current_time, sleep_time))"}
{"solution": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    max_sum = float('-inf')\n    max_len = 0\n    curr_sum = 0\n    curr_len = 0\n\n    for i in range(n):\n        if curr_sum < 0:\n            curr_sum = a[i]\n            curr_len = 1\n        else:\n            curr_sum += a[i]\n            curr_len += 1\n\n        if curr_sum * max_len > max_sum * curr_len:\n            max_sum = curr_sum\n            max_len = curr_len\n\n    print(max_len)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "MOD = 998244353\n\nn, m, k = map(int, input().split())\n\ndp = [[0] * (k + 1) for _ in range(n + 1)]\ndp[1][0] = m\n\nfor i in range(2, n + 1):\n    for j in range(min(i, k) + 1):\n        if j == 0:\n            dp[i][j] = dp[i - 1][j]\n        else:\n            dp[i][j] = (dp[i - 1][j - 1] * (m - 1) + dp[i - 1][j]) % MOD\n\nans = sum(dp[n][j] for j in range(k + 1)) % MOD\nprint(ans)"}
{"solution": "def is_magic_number(n):\n    n = str(n)\n    while len(n) > 0:\n        if n.startswith('1'):\n            n = n[1:]\n        elif n.startswith('14'):\n            n = n[2:]\n        elif n.startswith('144'):\n            n = n[3:]\n        else:\n            return 'NO'\n    return 'YES'\n\nn = int(input())\nprint(is_magic_number(n))"}
{"solution": "import math\n\ndef solve():\n    n, m, i, j, a, b = map(int, input().split())\n\n    def get_moves(x, y):\n        return max(math.ceil((x - 1) / a), math.ceil((y - 1) / b))\n\n    moves = float('inf')\n    for x, y in [(1, m), (n, 1), (n, m), (1, 1)]:\n        if (x - i) % a == 0 and (y - j) % b == 0:\n            moves = min(moves, max(abs(x - i) // a, abs(y - j) // b))\n        else:\n            moves = min(moves, get_moves(x, y) + get_moves(i, j))\n\n    if moves == float('inf'):\n        print(\"Poor Inna and pony!\")\n    else:\n        print(moves)\n\nsolve()"}
{"solution": "def remove_chars(s):\n    n = len(s)\n    dp = [[0] * 26 for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(26):\n            if j == ord(s[i - 1]) - ord('a'):\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + 1)\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[n][25]\n\nn = int(input())\ns = input()\nprint(remove_chars(s))"}
{"solution": "import sys\n\nn, k = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\nq = int(sys.stdin.readline())\n\nfor _ in range(q):\n    x = int(sys.stdin.readline())\n    ans = float('inf')\n\n    for i in range(n):\n        for j in range(i, n):\n            for u in range(k + 1):\n                for v in range(k + 1):\n                    if u + v > k:\n                        break\n                    if a[i] * u + a[j] * v == x:\n                        ans = min(ans, u + v)\n\n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)"}
{"solution": "import math\n\ndef calculate_time(s, x1, x2, t1, t2, p, d):\n    if x1 < x2:\n        if d == 1:\n            wait_time = max(0, (p - x1) * t1)\n            tram_time = (s - p) * t1\n            walk_time = (x2 - s) * t2\n            return wait_time + tram_time + walk_time\n        else:\n            tram_time = (s - p) * t1\n            wait_time = max(0, (s - x2) * t1 - tram_time)\n            walk_time = (x2 - x1) * t2\n            return wait_time + tram_time + walk_time\n    else:\n        if d == -1:\n            wait_time = max(0, (x1 - p) * t1)\n            tram_time = p * t1\n            walk_time = (x1 - x2) * t2\n            return wait_time + tram_time + walk_time\n        else:\n            tram_time = (s - p) * t1\n            wait_time = max(0, (p - x2) * t1 - tram_time)\n            walk_time = (x1 - x2) * t2\n            return wait_time + tram_time + walk_time\n\ndef calculate_min_time(s, x1, x2, t1, t2, p, d):\n    walk_time = abs(x2 - x1) * t2\n    tram_time = calculate_time(s, x1, x2, t1, t2, p, d)\n    return min(walk_time, tram_time)\n\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\nprint(calculate_min_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "import math\n\nn, x = map(int, input().split())\ncount = 0\n\nfor i in range(1, int(math.sqrt(x)) + 1):\n    if x % i == 0:\n        if i <= n and x // i <= n:\n            count += 1\n        if i!= x // i and i <= n and x // i <= n:\n            count += 1\n\nprint(count)"}
{"solution": "import string\n\nn, k = map(int, input().split())\npassword = string.ascii_lowercase[:k]\nif n > k:\n    password += password[:n-k]\nprint(password)"}
{"solution": "import sys\n\nn = int(input())\ndirections = input()\npositions = list(map(int, input().split()))\n\nmin_time = float('inf')\n\nfor i in range(n - 1):\n    if directions[i] == 'L' and directions[i + 1] == 'R':\n        time = (positions[i + 1] - positions[i]) // 2\n        min_time = min(min_time, time)\n\nif min_time == float('inf'):\n    print(-1)\nelse:\n    print(min_time)"}
{"solution": "import sys\n\nn, a, b = map(int, sys.stdin.readline().split())\nseals = []\nfor _ in range(n):\n    x, y = map(int, sys.stdin.readline().split())\n    seals.append((min(x, y), max(x, y)))\n\nseals.sort(key=lambda x: x[0], reverse=True)\nseals.sort(key=lambda x: x[1], reverse=True)\n\nmax_area = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if seals[i][0] + seals[j][0] <= a and max(seals[i][1], seals[j][1]) <= b:\n            max_area = max(max_area, seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1])\n        if seals[i][1] + seals[j][1] <= a and max(seals[i][0], seals[j][0]) <= b:\n            max_area = max(max_area, seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1])\n        if seals[i][0] + seals[j][0] <= b and max(seals[i][1], seals[j][1]) <= a:\n            max_area = max(max_area, seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1])\n        if seals[i][1] + seals[j][1] <= b and max(seals[i][0], seals[j][0]) <= a:\n            max_area = max(max_area, seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1])\n\nprint(max_area)"}
{"solution": "n = int(input())\npoints = [list(map(int, input().split())) for _ in range(4*n + 1)]\n\nx_coords = [point[0] for point in points]\ny_coords = [point[1] for point in points]\n\nmin_x, max_x = min(x_coords), max(x_coords)\nmin_y, max_y = min(y_coords), max(y_coords)\n\nfor point in points:\n    if min_x < point[0] < max_x and min_y < point[1] < max_y:\n        print(*point)\n        break"}
{"solution": "import math\n\ndef digit_product(n):\n    product = 1\n    while n > 0:\n        product *= n % 10\n        n //= 10\n    return product\n\ndef main():\n    n = int(input())\n    max_product = 1\n    for i in range(1, n + 1):\n        max_product = max(max_product, digit_product(i))\n        if i % 10 == 9 and i > 1:\n            num = int(str(i) + '9' * (len(str(n)) - len(str(i))))\n            if num <= n:\n                max_product = max(max_product, digit_product(num))\n    print(max_product)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ntotal_votes_elodreip = sum(a)\nmax_votes_elodreip = max(a)\n\nk = max_votes_elodreip\nwhile True:\n    total_votes_awruk = sum(k - ai for ai in a)\n    if total_votes_awruk > total_votes_elodreip:\n        print(k)\n        break\n    k += 1"}
{"solution": "def min_operations(s):\n    stack = []\n    operations = 0\n\n    for color in s:\n        if stack and stack[-1][0]!= color:\n            while stack and stack[-1][0]!= color:\n                stack.pop()\n            if stack:\n                stack[-1][1] += 1\n            else:\n                stack.append([color, 1])\n        else:\n            if stack and stack[-1][0] == color:\n                stack[-1][1] += 1\n            else:\n                stack.append([color, 1])\n\n        if len(stack) > 1 and stack[-1][1] == 1 and stack[-2][1] == 1:\n            stack.pop()\n            stack[-1][1] += 1\n            operations += 1\n\n    return operations\n\ns = input()\nprint(min_operations(s))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\nmin_product = a[0] * a[1] * a[2]\nmin_product_count = 1\n\nfor i in range(3, n):\n    if a[0] * a[1] * a[i] == min_product:\n        min_product_count += 1\n    elif a[0] * a[1] * a[i] < min_product:\n        min_product = a[0] * a[1] * a[i]\n        min_product_count = 1\n\nif a[0] == a[1] == a[2]:\n    print((n - 2) * (n - 1) * n // 6)\nelif a[0] == a[1]:\n    print(min_product_count * (n - 2))\nelse:\n    print(min_product_count)"}
{"solution": "import math\n\nn = int(input())\nans = 0\ni = 2\nwhile i * i <= n + 1:\n    if (n + 1) % i == 0:\n        ans += i - 1\n        n = (n + 1) // i\n        i = 2\n    else:\n        i += 1\nif n > 1:\n    ans += n - 1\nprint(ans)"}
{"solution": "def remove_last_digit(n):\n    return int(str(n)[:-1])\n\ndef remove_second_last_digit(n):\n    return int(str(n)[:-2] + str(n)[-1])\n\ndef solve(n):\n    n_str = str(n)\n    if n_str[0] == '-':\n        n_str = n_str[1:]\n        return -min(int(n_str), remove_last_digit(n_str), remove_second_last_digit(n_str))\n    else:\n        return max(int(n_str), remove_last_digit(n_str), remove_second_last_digit(n_str))\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def get_position_index(position):\n    positions = ['v', '<', '^', '>']\n    return positions.index(position)\n\ndef get_direction(start, end, n):\n    start_index = get_position_index(start)\n    end_index = get_position_index(end)\n    clockwise_diff = (end_index - start_index) % 4\n    counter_clockwise_diff = (start_index - end_index) % 4\n    if n % 4 == clockwise_diff:\n        return 'cw'\n    elif n % 4 == counter_clockwise_diff:\n        return 'ccw'\n    else:\n        return 'undefined'\n\nstart, end = input().split()\nn = int(input())\nprint(get_direction(start, end, n))"}
{"solution": "def solve():\n    n = int(input())\n    s = input()\n\n    left = [0] * n\n    right = [0] * n\n\n    for i in range(1, n):\n        if s[i - 1] == 'R':\n            left[i] = left[i - 1] + 1\n        else:\n            left[i] = left[i - 1]\n\n    for i in range(n - 2, -1, -1):\n        if s[i + 1] == 'L':\n            right[i] = right[i + 1] + 1\n        else:\n            right[i] = right[i + 1]\n\n    ans = 0\n    for i in range(n):\n        if s[i] == '.':\n            if left[i] == right[i]:\n                ans += 1\n        elif s[i] == 'L':\n            if left[i] > 0:\n                ans += 1\n        else:\n            if right[i] > 0:\n                ans += 1\n\n    print(ans)\n\nsolve()"}
{"solution": "def solve(n, m, leaders):\n    a = [0] * n\n    for i in range(m - 1):\n        leader = leaders[i] - 1\n        next_leader = leaders[i + 1] - 1\n        diff = (next_leader - leader) % n\n        if diff == 0:\n            diff = n\n        a[leader] = diff\n    for i in range(n):\n        if a[i] == 0:\n            a[i] = n\n            for j in range(n):\n                if a[j] == 0:\n                    a[j] = n - 1\n                    break\n    if a[leaders[-1] - 1]!= n:\n        return -1\n    a[leaders[-1] - 1] = n\n    for i in range(m - 1):\n        leader = leaders[i] - 1\n        next_leader = leaders[i + 1] - 1\n        diff = (next_leader - leader) % n\n        if diff == 0:\n            diff = n\n        if diff!= a[leader]:\n            return -1\n    return a\n\n\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\nresult = solve(n, m, leaders)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def largest_number(a, k):\n    a = list(a)\n    n = len(a)\n    result = []\n\n    for i in range(n):\n        if k == 0:\n            result.extend(a[i:])\n            break\n\n        max_digit = a[i]\n        max_index = i\n\n        for j in range(i + 1, min(i + k + 1, n)):\n            if a[j] > max_digit:\n                max_digit = a[j]\n                max_index = j\n\n        if max_index!= i:\n            k -= max_index - i\n\n        result.append(max_digit)\n        a[i] = '0'\n        a[max_index] = '0'\n\n    return ''.join(result).lstrip('0') or '0'\n\na, k = input().split()\nprint(largest_number(a, int(k)))"}
{"solution": "def is_arithmetic_progression(sequence):\n    diff = sequence[1] - sequence[0]\n    for i in range(2, len(sequence)):\n        if sequence[i] - sequence[i-1]!= diff:\n            return False\n    return True\n\ndef is_geometric_progression(sequence):\n    ratio = sequence[1] / sequence[0]\n    for i in range(2, len(sequence)):\n        if sequence[i] / sequence[i-1]!= ratio:\n            return False\n    return True\n\ndef next_arithmetic_progression(sequence):\n    diff = sequence[1] - sequence[0]\n    return sequence[-1] + diff\n\ndef next_geometric_progression(sequence):\n    ratio = sequence[1] / sequence[0]\n    return sequence[-1] * ratio\n\ndef main():\n    sequence = list(map(int, input().split()))\n    if is_arithmetic_progression(sequence):\n        next_num = next_arithmetic_progression(sequence)\n        if next_num == int(next_num):\n            print(int(next_num))\n        else:\n            print(42)\n    elif is_geometric_progression(sequence):\n        next_num = next_geometric_progression(sequence)\n        if next_num == int(next_num):\n            print(int(next_num))\n        else:\n            print(42)\n    else:\n        print(42)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\ncolors = list(map(int, input().split()))\n\nfirst_occurrence = {}\nlast_occurrence = {}\n\nfor i, color in enumerate(colors):\n    if color not in first_occurrence:\n        first_occurrence[color] = i\n    last_occurrence[color] = i\n\nmax_distance = 0\nfor color in first_occurrence:\n    distance = last_occurrence[color] - first_occurrence[color]\n    max_distance = max(max_distance, distance)\n\nif max_distance == n - 1:\n    max_distance = n - 1\nelse:\n    max_distance = n - 1\n\nprint(max_distance)"}
{"solution": "n, m, k = map(int, input().split())\nlane = (k + 1) // (2 * m)\ndesk = ((k - 1) % (2 * m)) // 2 + 1\nside = 'L' if (k - 1) % 2 == 0 else 'R'\nprint(lane, desk, side)"}
{"solution": "n = int(input())\ns = input()\n\ncolors = {'B': 0, 'G': 0, 'R': 0}\nfor color in s:\n    colors[color] += 1\n\nresult = []\nfor color, count in colors.items():\n    if count % 2 == n % 2:\n        result.append(color)\n\nprint(''.join(sorted(result)))"}
