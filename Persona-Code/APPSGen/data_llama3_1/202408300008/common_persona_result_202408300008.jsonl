{"solution": "def max_accordion_length(s):\n    max_length = -1\n    opening_bracket_index = -1\n    colon_count = 0\n    vertical_line_count = 0\n\n    for i, char in enumerate(s):\n        if char == '[':\n            if opening_bracket_index == -1:\n                opening_bracket_index = i\n        elif char == ':':\n            if opening_bracket_index!= -1:\n                colon_count += 1\n                if colon_count == 1:\n                    continue\n                elif colon_count == 2:\n                    max_length = max(max_length, 4 + vertical_line_count)\n                    vertical_line_count = 0\n        elif char == '|':\n            if opening_bracket_index!= -1 and colon_count == 1:\n                vertical_line_count += 1\n        elif char == ']':\n            if opening_bracket_index!= -1 and colon_count == 2:\n                max_length = max(max_length, 4 + vertical_line_count)\n                opening_bracket_index = -1\n                colon_count = 0\n                vertical_line_count = 0\n\n    return max_length\n\ns = input()\nprint(max_accordion_length(s))"}
{"solution": "def max_digit_sum(x):\n    x_str = str(x)\n    max_sum = sum(int(digit) for digit in x_str)\n    max_num = x\n\n    for i in range(len(x_str) - 1, -1, -1):\n        if x_str[i]!= '9':\n            new_num_str = x_str[:i] + str(int(x_str[i]) - 1) + '9' * (len(x_str) - i - 1)\n            new_sum = sum(int(digit) for digit in new_num_str)\n            if new_sum >= max_sum:\n                max_sum = new_sum\n                max_num = int(new_num_str)\n            break\n\n    return max_num\n\nx = int(input())\nprint(max_digit_sum(x))"}
{"solution": "def is_lucky_year(year):\n    \"\"\"Check if a year is lucky.\"\"\"\n    count = 0\n    for digit in str(year):\n        if digit!= '0':\n            count += 1\n        if count > 1:\n            return False\n    return True\n\n\ndef next_lucky_year(current_year):\n    \"\"\"Find the next lucky year.\"\"\"\n    next_year = current_year + 1\n    while not is_lucky_year(next_year):\n        next_year += 1\n    return next_year\n\n\ndef main():\n    current_year = int(input())\n    next_year = next_lucky_year(current_year)\n    print(next_year - current_year)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, q = read_ints()\n    painters = [tuple(read_ints()) for _ in range(q)]\n\n    dp = [[0] * (q + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, q + 1):\n            l, r = painters[j - 1]\n            if r < i:\n                dp[i][j] = dp[i][j - 1]\n            elif l > i:\n                dp[i][j] = dp[i][j - 1]\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[l - 1][j - 1] + (r - l + 1))\n\n    dp2 = [[0] * (q + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, q + 1):\n            l, r = painters[j - 1]\n            if r < i:\n                dp2[i][j] = dp2[i][j - 1]\n            elif l > i:\n                dp2[i][j] = dp2[i][j - 1]\n            else:\n                dp2[i][j] = max(dp2[i][j - 1], dp2[l - 1][j - 1] + (r - l + 1))\n\n    for i in range(1, n + 1):\n        for j in range(1, q + 1):\n            l, r = painters[j - 1]\n            if r < i:\n                dp2[i][j] = max(dp2[i][j], dp2[i][j - 1])\n            elif l > i:\n                dp2[i][j] = max(dp2[i][j], dp2[i][j - 1])\n            else:\n                dp2[i][j] = max(dp2[i][j], dp2[l - 1][j - 1] + dp[r][j - 1])\n\n    print(dp2[n][q])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_lucky(time):\n    \"\"\"Check if a time is lucky.\"\"\"\n    return '7' in time\n\ndef find_lucky_time(x, target_time):\n    \"\"\"Find the smallest number of times Jamie needs to press the snooze button.\"\"\"\n    minutes, seconds = map(int, target_time.split(':'))\n    total_minutes = minutes + seconds // 60\n    remainder_seconds = seconds % 60\n\n    # Calculate the time x minutes before the target time\n    for y in range(total_minutes + 1):\n        new_minutes = (total_minutes - y * x) % (24 * 60)\n        new_hours = new_minutes // 60\n        new_minutes %= 60\n        new_time = f\"{new_hours:02d}:{new_minutes:02d}\"\n        if is_lucky(new_time):\n            return y\n\nx = int(input())\ntarget_time = input()\nprint(find_lucky_time(x, target_time))"}
{"solution": "n, pos, l, r = map(int, input().split())\n\nif l == 1 and r == n:\n    print(0)\nelif l == 1:\n    print(abs(pos - r) + 1)\nelif r == n:\n    print(abs(pos - l) + 1)\nelse:\n    left_time = abs(pos - l) + (l - 1) + abs(r - n)\n    right_time = abs(pos - r) + (n - r) + abs(l - 1)\n    print(min(left_time, right_time) + 1)"}
{"solution": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    blows = []\n    for _ in range(n):\n        d, h = map(int, sys.stdin.readline().split())\n        blows.append((d, h))\n\n    blows.sort(key=lambda x: x[1])\n\n    for d, h in blows:\n        if d > h:\n            ans = (x + d - h - 1) // (d - h)\n            print(ans)\n            return\n\n    print(-1)\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    solve()"}
{"solution": "def solve(n, m):\n    day = 0\n    while True:\n        day += 1\n        n += m\n        if n > 10**18:\n            n = 10**18\n        if n < day:\n            return day\n        n -= day\n\nn, m = map(int, input().split())\nprint(solve(n, m))"}
{"solution": ""}
{"solution": ""}
{"solution": "n = int(input())\nfull_weeks = n // 7\nremaining_days = n % 7\n\nmin_days_off = full_weeks * 2\nif remaining_days <= 2:\n    max_days_off = full_weeks * 2 + remaining_days\nelse:\n    max_days_off = full_weeks * 2 + 2\n\nprint(min_days_off, max_days_off)"}
{"solution": "import math\n\nn, a, b, p, q = map(int, input().split())\n\ndef count_multiples(n, x):\n    return n // x\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nred = count_multiples(n, a)\nblue = count_multiples(n, b)\nboth = count_multiples(n, lcm(a, b))\n\nred_chocolates = red * p\nblue_chocolates = blue * q\n\nif p > q:\n    max_chocolates = red_chocolates + (blue - both) * q + both * p\nelse:\n    max_chocolates = blue_chocolates + (red - both) * p + both * q\n\nprint(max_chocolates)"}
{"solution": "def max_golden_trophies(n, trophies):\n    max_length = 0\n    current_length = 0\n    first_silver = -1\n    last_silver = -1\n    silver_count = 0\n\n    for i in range(n):\n        if trophies[i] == 'G':\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            if first_silver == -1:\n                first_silver = i\n            last_silver = i\n            silver_count += 1\n            current_length = 0\n\n    if silver_count == 0:\n        return max_length\n    elif silver_count == 1:\n        return max_length + 1\n    else:\n        max_length_with_swap = max_length\n        for i in range(first_silver, last_silver + 1):\n            if trophies[i] == 'S':\n                max_length_with_swap += 1\n        return max_length_with_swap\n\n\nn = int(input())\ntrophies = input()\nprint(max_golden_trophies(n, trophies))"}
{"solution": "from collections import defaultdict, deque\n\ndef main():\n    n, k = map(int, input().split())\n    main_courses = list(map(int, input().split()))\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        dependencies = list(map(int, input().split()))\n        in_degree[i] = dependencies[0]\n        if dependencies[0] > 0:\n            for dependency in dependencies[1:]:\n                graph[dependency].append(i)\n\n    queue = deque([course for course in main_courses if in_degree[course] == 0])\n    result = []\n    visited = set()\n\n    while queue:\n        course = queue.popleft()\n        if course not in visited:\n            result.append(course)\n            visited.add(course)\n            for neighbor in graph[course]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n\n    if len(result)!= len(visited):\n        print(-1)\n        return\n\n    queue = deque([course for course in range(1, n + 1) if in_degree[course] == 0 and course not in visited])\n    while queue:\n        course = queue.popleft()\n        if course not in visited:\n            result.append(course)\n            visited.add(course)\n            for neighbor in graph[course]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n\n    if len(visited)!= len(result):\n        print(-1)\n        return\n\n    print(len(result))\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef solve(n, k, p):\n    s = []\n    for i in range(k):\n        while s and s[-1] < p[i]:\n            s.pop()\n        if s and s[-1] > p[i]:\n            return [-1]\n        s.append(p[i])\n\n    max_val = n\n    for i in range(k - 1, -1, -1):\n        if p[i] < max_val:\n            for j in range(max_val - 1, p[i], -1):\n                s.append(j)\n            max_val = p[i]\n\n    for i in range(k):\n        if p[i] > s[-1]:\n            return [-1]\n        s.remove(p[i])\n\n    return p + s[::-1]\n\nn, k = map(int, sys.stdin.readline().split())\np = list(map(int, sys.stdin.readline().split()))\n\nprint(*solve(n, k, p))"}
{"solution": "def does_b_appear_in_sequence():\n    a, b, c = map(int, input().split())\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\nprint(does_b_appear_in_sequence())"}
{"solution": "def can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    if cnt_1 == cnt_4:\n        return 1\n    elif cnt_1 + cnt_2 == cnt_3 + cnt_4:\n        return 1\n    else:\n        return 0\n\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\nprint(can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4))"}
{"solution": "def mexican_wave(n, k, t):\n    if t < k:\n        return t\n    elif t < n:\n        return k\n    else:\n        return k - (t - n)\n\nn, k, t = map(int, input().split())\nprint(mexican_wave(n, k, t))"}
{"solution": "def lexicographically_minimal_string(s):\n    t = []\n    u = []\n    min_char = min(s)\n    s = list(s)\n    \n    while s or t:\n        if t and (not s or t[-1] <= min_char):\n            u.append(t.pop())\n        else:\n            char = s.pop(0)\n            t.append(char)\n            if s:\n                min_char = min(s)\n    \n    return ''.join(u)\n\ns = input().strip()\nprint(lexicographically_minimal_string(s))"}
{"solution": "def check_records(n, records):\n    for i in range(1, n):\n        plays_diff = records[i][0] - records[i-1][0]\n        clears_diff = records[i][1] - records[i-1][1]\n        \n        if plays_diff < 0 or clears_diff < 0:\n            return \"NO\"\n        \n        if clears_diff > plays_diff:\n            return \"NO\"\n    \n    return \"YES\"\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    records = [list(map(int, input().split())) for _ in range(n)]\n    \n    print(check_records(n, records))"}
{"solution": "def is_palindrome(time):\n    \"\"\"Check if a time string is a palindrome.\"\"\"\n    return time == time[::-1]\n\ndef next_palindrome(time):\n    \"\"\"Find the next palindrome time.\"\"\"\n    hours, minutes = map(int, time.split(':'))\n    minutes += 1\n    if minutes == 60:\n        minutes = 0\n        hours += 1\n        if hours == 24:\n            hours = 0\n    return f\"{hours:02d}:{minutes:02d}\"\n\ndef minutes_until_palindrome(time):\n    \"\"\"Calculate the minimum number of minutes until the next palindrome time.\"\"\"\n    minutes = 0\n    while not is_palindrome(time):\n        time = next_palindrome(time)\n        minutes += 1\n    return minutes\n\ntime = input()\nprint(minutes_until_palindrome(time))"}
{"solution": "def max_distance(n, arr):\n    min_idx = arr.index(1)\n    max_idx = arr.index(n)\n    \n    # Calculate the distance if we swap the minimum element with the first element\n    dist1 = abs(max_idx - 0)\n    \n    # Calculate the distance if we swap the minimum element with the last element\n    dist2 = abs(max_idx - (n - 1))\n    \n    # Calculate the distance if we swap the maximum element with the first element\n    dist3 = abs(min_idx - 0)\n    \n    # Calculate the distance if we swap the maximum element with the last element\n    dist4 = abs(min_idx - (n - 1))\n    \n    # Return the maximum distance\n    return max(dist1, dist2, dist3, dist4)\n\nn = int(input())\narr = list(map(int, input().split()))\n\nprint(max_distance(n, arr))"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    mid = n // 2\n    if n % 2 == 0:\n        first_half = s[:mid]\n        second_half = s[mid:]\n    else:\n        first_half = s[:mid]\n        second_half = s[mid+1:]\n    \n    if first_half.lower() == second_half.lower()[::-1]:\n        return \"TAK\"\n    else:\n        return \"NIE\"\n\ns = input().strip()\nprint(is_s_palindrome(s))"}
{"solution": "from collections import Counter\n\ndef max_permutation(a, b):\n    a_count = Counter(a)\n    b = list(b)\n    result = []\n\n    # Try to use the largest possible digits from b\n    for digit in b:\n        if digit in a_count and a_count[digit] > 0:\n            result.append(digit)\n            a_count[digit] -= 1\n        else:\n            # If the current digit in b is not available in a, \n            # try to use the largest possible digit from a\n            for d in sorted(a_count.keys(), reverse=True):\n                if a_count[d] > 0:\n                    result.append(d)\n                    a_count[d] -= 1\n                    break\n\n    # Fill the rest of the result with the remaining digits from a\n    for digit, count in sorted(a_count.items(), reverse=True):\n        result.extend([digit] * count)\n\n    # Ensure the result does not exceed b\n    if int(''.join(result)) > int(''.join(b)):\n        # If the result exceeds b, try to use the next largest digit from a\n        for i in range(len(result)):\n            for d in sorted(a_count.keys(), reverse=True):\n                if a_count[d] > 0 and d < result[i]:\n                    result[i] = d\n                    a_count[d] -= 1\n                    break\n\n    return ''.join(result)\n\na = input()\nb = input()\nprint(max_permutation(a, b))"}
{"solution": "def check_win(matrix, i, j):\n    # Check horizontal\n    count = 0\n    for k in range(max(0, j-4), min(10, j+5)):\n        if matrix[i][k] == 'X':\n            count += 1\n            if count >= 5:\n                return True\n        else:\n            count = 0\n\n    # Check vertical\n    count = 0\n    for k in range(max(0, i-4), min(10, i+5)):\n        if matrix[k][j] == 'X':\n            count += 1\n            if count >= 5:\n                return True\n        else:\n            count = 0\n\n    # Check diagonal (top-left to bottom-right)\n    count = 0\n    for k in range(max(0, i-4), min(10, i+5)):\n        for col in range(max(0, j-4), min(10, j+5)):\n            if k - i == col - j and matrix[k][col] == 'X':\n                count += 1\n                if count >= 5:\n                    return True\n            else:\n                count = 0\n\n    # Check diagonal (bottom-left to top-right)\n    count = 0\n    for k in range(max(0, i-4), min(10, i+5)):\n        for col in range(max(0, j-4), min(10, j+5)):\n            if k - i == j - col and matrix[k][col] == 'X':\n                count += 1\n                if count >= 5:\n                    return True\n            else:\n                count = 0\n\n    return False\n\n\ndef can_win(matrix):\n    for i in range(10):\n        for j in range(10):\n            if matrix[i][j] == '.':\n                matrix[i] = matrix[i][:j] + 'X' + matrix[i][j+1:]\n                if check_win(matrix, i, j):\n                    return True\n                matrix[i] = matrix[i][:j] + '.' + matrix[i][j+1:]\n    return False\n\n\nmatrix = [input() for _ in range(10)]\nprint('YES' if can_win(matrix) else 'NO')"}
{"solution": "def solve(n, k):\n    if k > n * (n + 1) // 2:\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            if k > 0:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 1\n            else:\n                break\n\n    return matrix\n\n\ndef print_matrix(matrix):\n    if matrix == -1:\n        print(-1)\n    else:\n        for row in matrix:\n            print(' '.join(map(str, row)))\n\n\nn, k = map(int, input().split())\nmatrix = solve(n, k)\nprint_matrix(matrix)"}
{"solution": "import math\n\nx, y, z = map(float, input().split())\n\nexpressions = [\n    (x ** (y ** z), f\"x^{y}^{z}\"),\n    (x ** (z ** y), f\"x^{z}^{y}\"),\n    ((x ** y) ** z, f\"(x^{y})^{z}\"),\n    ((x ** z) ** y, f\"(x^{z})^{y}\"),\n    (y ** (x ** z), f\"y^{x}^{z}\"),\n    (y ** (z ** x), f\"y^{z}^{x}\"),\n    ((y ** x) ** z, f\"(y^{x})^{z}\"),\n    ((y ** z) ** x, f\"(y^{z})^{x}\"),\n    (z ** (x ** y), f\"z^{x}^{y}\"),\n    (z ** (y ** x), f\"z^{y}^{x}\"),\n    ((z ** x) ** y, f\"(z^{x})^{y}\"),\n    ((z ** y) ** x, f\"(z^{y})^{x}\"),\n]\n\nmax_value, max_expression = max(expressions, key=lambda x: x[0])\n\nprint(max_expression)"}
{"solution": "def min_operations(n, s):\n    \"\"\"\n    Calculate the minimum number of operations to type a string.\n\n    Args:\n    n (int): The length of the string.\n    s (str): The string to be typed.\n\n    Returns:\n    int: The minimum number of operations.\n    \"\"\"\n    # Initialize the minimum number of operations as the length of the string\n    min_ops = n\n\n    # Iterate over all possible prefixes of the string\n    for i in range(1, n // 2 + 1):\n        # Check if the string can be formed by repeating the prefix\n        if s == s[:i] * (n // i) + s[:n % i]:\n            # Update the minimum number of operations\n            min_ops = min(min_ops, i + 1 + (n % i!= 0))\n\n    return min_ops\n\n\n# Read the input\nn = int(input())\ns = input()\n\n# Calculate and print the minimum number of operations\nprint(min_operations(n, s))"}
{"solution": "import sys\n\ndef read_input():\n    n = int(sys.stdin.readline())\n    files = []\n    for _ in range(n):\n        name, type = sys.stdin.readline().split()\n        files.append((name, int(type)))\n    return n, files\n\ndef solve(n, files):\n    examples = [file for file in files if file[1] == 1]\n    regulars = [file for file in files if file[1] == 0]\n\n    e = len(examples)\n    example_names = [str(i) for i in range(1, e + 1)]\n    regular_names = [str(i) for i in range(e + 1, n + 1)]\n\n    used_names = set(file[0] for file in files)\n    free_names = set(example_names + regular_names) - used_names\n\n    moves = []\n    for i, file in enumerate(examples):\n        if file[0]!= example_names[i]:\n            if example_names[i] in used_names:\n                free_name = free_names.pop()\n                moves.append((file[0], free_name))\n                moves.append((free_name, example_names[i]))\n            else:\n                moves.append((file[0], example_names[i]))\n\n    for i, file in enumerate(regulars):\n        if file[0]!= regular_names[i]:\n            if regular_names[i] in used_names:\n                free_name = free_names.pop()\n                moves.append((file[0], free_name))\n                moves.append((free_name, regular_names[i]))\n            else:\n                moves.append((file[0], regular_names[i]))\n\n    return moves\n\ndef print_output(moves):\n    print(len(moves))\n    for move in moves:\n        print(f\"move {move[0]} {move[1]}\")\n\ndef main():\n    n, files = read_input()\n    moves = solve(n, files)\n    print_output(moves)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_replacements(ticket):\n    \"\"\"\n    Calculate the minimum number of digits Luba needs to replace to make the ticket lucky.\n\n    Args:\n    ticket (str): A string of 6 digits representing Luba's ticket.\n\n    Returns:\n    int: The minimum number of digits Luba needs to replace.\n    \"\"\"\n    # Calculate the sum of the first three digits\n    sum_first_half = sum(int(digit) for digit in ticket[:3])\n    \n    # Calculate the sum of the last three digits\n    sum_second_half = sum(int(digit) for digit in ticket[3:])\n    \n    # Calculate the difference between the two sums\n    difference = abs(sum_first_half - sum_second_half)\n    \n    # If the difference is 0, the ticket is already lucky\n    if difference == 0:\n        return 0\n    \n    # If the difference is less than or equal to 9, we can replace one digit to make the ticket lucky\n    if difference <= 9:\n        return 1\n    \n    # If the difference is greater than 9, we need to replace at least two digits to make the ticket lucky\n    return 2\n\n# Read the ticket from input\nticket = input()\n\n# Print the minimum number of replacements needed\nprint(min_replacements(ticket))"}
{"solution": "import math\n\nm, x = map(int, input().split())\nprint(m - 1 if m % 2 == 0 else m // 2)"}
{"solution": "def mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef solve(n, k):\n    mod = 10**6 + 3\n    total_days = pow(2, n, mod)\n    prob = 1\n    for i in range(1, k):\n        prob = (prob * (total_days - i)) % mod\n        prob = (prob * mod_inverse(total_days, mod)) % mod\n    prob = (1 - prob) % mod\n    return prob, total_days\n\nn, k = map(int, input().split())\na, b = solve(n, k)\nprint(a, b)"}
{"solution": "def check_journey(n, journey):\n    \"\"\"\n    Checks if Limak's journey satisfies the given conditions.\n\n    Args:\n    n (int): The number of parts in the journey.\n    journey (list): A list of tuples, where each tuple contains the distance and direction of a part of the journey.\n\n    Returns:\n    bool: True if the journey satisfies the conditions, False otherwise.\n    \"\"\"\n    position = 0  # Initialize position at the North Pole (0)\n\n    for distance, direction in journey:\n        if position == 0 and direction!= \"South\":\n            return False  # Can't move from North Pole in any direction other than South\n        elif position == -20000 and direction!= \"North\":\n            return False  # Can't move from South Pole in any direction other than North\n\n        if direction == \"North\":\n            position += distance\n        elif direction == \"South\":\n            position -= distance\n        # Ignore East and West directions as they don't affect the North-South position\n\n        if position > 20000 or position < -20000:\n            return False  # Position is outside the valid range\n\n    return position == 0  # Journey must end at the North Pole\n\n\nn = int(input())\njourney = []\nfor _ in range(n):\n    distance, direction = input().split()\n    journey.append((int(distance), direction))\n\nif check_journey(n, journey):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def gcd(a, b):\n    \"\"\"Compute the greatest common divisor of a and b\"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    \"\"\"Compute the lowest common multiple of a and b\"\"\"\n    return a * b // gcd(a, b)\n\ndef count_common_terms(a1, b1, a2, b2, L, R):\n    \"\"\"Count the number of common terms in two arithmetic progressions\"\"\"\n    # Calculate the difference between the two progressions\n    diff = b2 - b1\n    \n    # If the difference is not a multiple of the LCM of a1 and a2, there are no common terms\n    if diff % lcm(a1, a2)!= 0:\n        return 0\n    \n    # Calculate the first common term\n    first_common_term = b1 + (lcm(a1, a2) * ((diff // lcm(a1, a2))))\n    \n    # If the first common term is outside the range [L, R], there are no common terms\n    if first_common_term < L or first_common_term > R:\n        return 0\n    \n    # Calculate the number of common terms\n    num_common_terms = (R - first_common_term) // lcm(a1, a2) + 1\n    \n    # If the first common term is less than L, subtract the number of terms before L\n    if first_common_term < L:\n        num_common_terms -= (first_common_term - L) // lcm(a1, a2)\n    \n    return num_common_terms\n\na1, b1, a2, b2, L, R = map(int, input().split())\nprint(count_common_terms(a1, b1, a2, b2, L, R))"}
{"solution": "def calculate_max_pieces(n, a, b):\n    \"\"\"\n    Calculate the maximum possible number of pieces on each plate.\n\n    Args:\n    n (int): The number of plates.\n    a (int): The number of pieces of the first cake.\n    b (int): The number of pieces of the second cake.\n\n    Returns:\n    int: The maximum possible number of pieces on each plate.\n    \"\"\"\n    # Calculate the total number of pieces\n    total_pieces = a + b\n    \n    # Calculate the minimum number of pieces per plate\n    min_pieces_per_plate = total_pieces // n\n    \n    # Calculate the remaining pieces\n    remaining_pieces = total_pieces % n\n    \n    # If there are remaining pieces, we can distribute them to some plates\n    if remaining_pieces > 0:\n        # Calculate the number of plates that will get an extra piece\n        extra_pieces_plates = remaining_pieces\n        \n        # Calculate the number of plates that will not get an extra piece\n        no_extra_pieces_plates = n - extra_pieces_plates\n        \n        # Calculate the minimum number of pieces on plates with an extra piece\n        min_pieces_with_extra = min_pieces_per_plate + 1\n        \n        # Calculate the minimum number of pieces on plates without an extra piece\n        min_pieces_without_extra = min_pieces_per_plate\n        \n        # Return the minimum of the two\n        return min(min_pieces_with_extra, min_pieces_without_extra)\n    else:\n        # If there are no remaining pieces, all plates will have the same number of pieces\n        return min_pieces_per_plate\n\n\n# Read the input\nn, a, b = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_max_pieces(n, a, b))"}
{"solution": "def is_valid_flag(n, m, flag):\n    # Check if the number of unique colors is 3\n    colors = set()\n    for row in flag:\n        colors.update(row)\n    if len(colors)!= 3:\n        return False\n\n    # Check if the flag can be divided into three equal parts\n    if n % 3!= 0:\n        return False\n\n    # Check if each part has the same color\n    part_height = n // 3\n    for i in range(3):\n        part_color = flag[i * part_height][0]\n        for j in range(part_height):\n            if flag[i * part_height + j]!= [part_color] * m:\n                return False\n\n    return True\n\n\nn, m = map(int, input().split())\nflag = [list(input()) for _ in range(n)]\n\nif is_valid_flag(n, m, flag):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\ndef hex_spiral(n):\n    \"\"\"\n    Calculate the coordinates of Ayrat's location after n moves in a hexagonal grid.\n\n    Args:\n    n (int): The number of moves.\n\n    Returns:\n    tuple: A tuple containing the x and y coordinates.\n    \"\"\"\n    if n == 0:\n        return 0, 0\n\n    # Calculate the layer of the spiral\n    layer = math.floor((math.sqrt(3 * n + 1) - 1) / 2)\n\n    # Calculate the position in the layer\n    pos = n - (3 * layer * layer - 3 * layer + 1) // 2\n\n    # Calculate the coordinates based on the layer and position\n    if pos < layer:\n        x = layer\n        y = pos - layer + 1\n    elif pos < 2 * layer:\n        x = layer - (pos - layer)\n        y = layer\n    elif pos < 3 * layer:\n        x = -layer\n        y = layer - (pos - 2 * layer)\n    else:\n        x = -layer + (pos - 3 * layer)\n        y = -layer\n\n    return x, y\n\nn = int(input())\nx, y = hex_spiral(n)\nprint(x, y)"}
{"solution": "import math\n\ndef can_break_shield(a, b, c):\n    # Calculate the greatest common divisor of a and b\n    gcd_ab = math.gcd(a, b)\n    \n    # Check if c is divisible by the gcd of a and b\n    if c % gcd_ab == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input values\na, b, c = map(int, input().split())\n\n# Output the result\nprint(can_break_shield(a, b, c))"}
{"solution": "def can_tracks_coincide(n, L, kefa_barriers, sasha_barriers):\n    # Calculate distances between consecutive barriers for Kefa\n    kefa_distances = [(kefa_barriers[(i + 1) % n] - kefa_barriers[i]) % L for i in range(n)]\n    # Calculate distances between consecutive barriers for Sasha\n    sasha_distances = [(sasha_barriers[(i + 1) % n] - sasha_barriers[i]) % L for i in range(n)]\n    \n    # Double the kefa_distances to handle circular rotation\n    doubled_kefa_distances = kefa_distances + kefa_distances\n    \n    # Check if sasha_distances is a sublist of doubled_kefa_distances\n    for i in range(n):\n        if doubled_kefa_distances[i:i + n] == sasha_distances:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_barriers, sasha_barriers))"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome(s):\n    max_length = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if not is_palindrome(substring):\n                max_length = max(max_length, len(substring))\n    return max_length\n\ns = input()\nprint(longest_non_palindrome(s))"}
{"solution": "def is_round_rated(n, ratings):\n    \"\"\"\n    Determine if the current round is rated, unrated, or it's impossible to determine whether it is rated or not.\n\n    Args:\n    n (int): The number of round participants.\n    ratings (list): A list of tuples containing the rating of each participant before and after the round.\n\n    Returns:\n    str: \"rated\" if the round is rated for sure, \"unrated\" if the round is unrated for sure, \"maybe\" if it's impossible to determine.\n    \"\"\"\n\n    # Check if at least one participant's rating has changed\n    if any(before!= after for before, after in ratings):\n        return \"rated\"\n\n    # Check if the round was rated and a participant with lower rating took a better place in the standings\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            return \"unrated\"\n\n    # If none of the above conditions are met, it's impossible to determine whether the round is rated or not\n    return \"maybe\"\n\n\n# Read the number of participants\nn = int(input())\n\n# Read the ratings of each participant\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Determine if the round is rated, unrated, or indeterminate\nresult = is_round_rated(n, ratings)\n\n# Print the result\nprint(result)"}
{"solution": "def nearest_zero(n, arr):\n    \"\"\"\n    Calculate the distance to the nearest zero for each element in the array.\n\n    Args:\n    n (int): The length of the array.\n    arr (list): The input array.\n\n    Returns:\n    list: A list of distances to the nearest zero for each element.\n    \"\"\"\n    # Initialize a list to store the distances\n    distances = [float('inf')] * n\n\n    # Initialize the distance to the previous zero\n    prev_zero = -float('inf')\n\n    # Iterate over the array from left to right\n    for i in range(n):\n        # If the current element is zero, update the previous zero index\n        if arr[i] == 0:\n            prev_zero = i\n        # Otherwise, update the distance to the previous zero\n        else:\n            distances[i] = i - prev_zero\n\n    # Initialize the distance to the next zero\n    next_zero = float('inf')\n\n    # Iterate over the array from right to left\n    for i in range(n - 1, -1, -1):\n        # If the current element is zero, update the next zero index\n        if arr[i] == 0:\n            next_zero = i\n        # Otherwise, update the distance to the next zero\n        else:\n            distances[i] = min(distances[i], next_zero - i)\n\n    return distances\n\n\n# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Calculate and print the distances\nprint(*nearest_zero(n, arr))"}
{"solution": "def count_distinct_cyclical_strings(n, s):\n    def is_substring_in_cyclical_shifts(t, s):\n        t_extended = t + t\n        return any(s in t_extended[i:i+len(t)] for i in range(len(t)))\n    \n    distinct_cyclical_strings = set()\n    \n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if is_substring_in_cyclical_shifts(t, s):\n            distinct_cyclical_strings.add(t)\n    \n    return len(distinct_cyclical_strings)\n\nfrom itertools import product\nn = int(input())\ns = input().strip()\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import math\n\ndef polar_angle(x, y):\n    \"\"\"Calculate the polar angle of a vector.\"\"\"\n    return math.atan2(y, x)\n\ndef angle_between_vectors(a, b):\n    \"\"\"Calculate the non-oriented angle between two vectors.\"\"\"\n    return min(math.pi - abs(a - b), abs(a - b))\n\ndef main():\n    n = int(input())\n    vectors = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        vectors.append((x, y, i + 1))\n\n    # Sort vectors by polar angle\n    vectors.sort(key=lambda v: polar_angle(v[0], v[1]))\n\n    min_angle = math.pi\n    min_indices = (0, 0)\n    for i in range(n - 1):\n        angle = angle_between_vectors(polar_angle(vectors[i][0], vectors[i][1]),\n                                      polar_angle(vectors[i + 1][0], vectors[i + 1][1]))\n        if angle < min_angle:\n            min_angle = angle\n            min_indices = (vectors[i][2], vectors[i + 1][2])\n\n    # Check the angle between the first and last vectors\n    angle = angle_between_vectors(polar_angle(vectors[0][0], vectors[0][1]),\n                                  polar_angle(vectors[-1][0], vectors[-1][1]))\n    if angle < min_angle:\n        min_angle = angle\n        min_indices = (vectors[0][2], vectors[-1][2])\n\n    print(*min_indices)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nd, k, a, b, t = map(int, sys.stdin.readline().split())\n\nif d <= k:\n    print(d * a)\nelse:\n    full_segments = d // k\n    remaining_distance = d % k\n\n    time_for_full_segments = full_segments * k * a + (full_segments - 1) * t\n\n    if remaining_distance == 0:\n        print(time_for_full_segments + t)\n    else:\n        time_drive_remaining = remaining_distance * a + t\n        time_walk_remaining = remaining_distance * b\n\n        print(time_for_full_segments + min(time_drive_remaining, time_walk_remaining))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(n, k):\n    if n < k:\n        return -1\n    if n % k == 0:\n        return [n // k] * k\n    if k == 1:\n        return [n]\n    if k == 2:\n        g = math.gcd(n, k)\n        if n // g % 2 == 0:\n            return [g, n - g]\n        else:\n            return -1\n    g = n // k\n    if g == 1:\n        return -1\n    return [g] * (k - 1) + [n - (k - 1) * g]\n\nn, k = map(int, input().split())\nresult = solve(n, k)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def count_pairs(n, m):\n    \"\"\"\n    Count the number of pairs of integers (x, y) such that 1 \u2264 x \u2264 n, 1 \u2264 y \u2264 m and (x + y) is divisible by 5.\n    \n    Parameters:\n    n (int): The upper limit of the first column.\n    m (int): The upper limit of the second column.\n    \n    Returns:\n    int: The number of pairs of integers (x, y) such that 1 \u2264 x \u2264 n, 1 \u2264 y \u2264 m and (x + y) is divisible by 5.\n    \"\"\"\n    count = 0\n    for i in range(5):\n        count += (n - i) // 5 * (m - (5 - i)) // 5\n        if (n - i) % 5 >= (5 - i):\n            count += (n - i) % 5 - (5 - i) + 1\n    return count\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))"}
{"solution": "import sys\n\ndef max_beauty(n, x, a):\n    if x == 1:\n        return max_subarray_sum(a)\n\n    max_sum = max_subarray_sum(a)\n    max_sum_with_x = max_subarray_sum_with_x(a, x)\n\n    return max(max_sum, max_sum_with_x)\n\n\ndef max_subarray_sum(a):\n    max_sum = 0\n    current_sum = 0\n\n    for num in a:\n        current_sum = max(0, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\n\ndef max_subarray_sum_with_x(a, x):\n    prefix_sum = [0] * (len(a) + 1)\n    for i in range(len(a)):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    max_sum = float('-inf')\n    min_prefix_sum = 0\n\n    for i in range(len(a)):\n        max_sum = max(max_sum, prefix_sum[i + 1] - min_prefix_sum)\n        min_prefix_sum = min(min_prefix_sum, prefix_sum[i + 1] - x * a[i])\n\n    return max_sum * x\n\n\ndef main():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    print(max_beauty(n, x, a))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_kth_largest(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(m, x // i)\n        return count\n\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_less_equal(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\nn, m, k = map(int, input().split())\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    start += (k - 1) // length\n    return str(start)[(k - 1) % length]\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "def max_bourles(n, m, r, s, b):\n    max_bourles = r\n    for buy_price in s:\n        for sell_price in b:\n            if buy_price < sell_price:\n                shares = r // buy_price\n                bourles = shares * sell_price\n                max_bourles = max(max_bourles, bourles + r % buy_price)\n    return max_bourles\n\nn, m, r = map(int, input().split())\ns = sorted(map(int, input().split()))\nb = sorted(map(int, input().split()))\n\nprint(max_bourles(n, m, r, s, b))"}
{"solution": "def find_original_message(t):\n    n = len(t)\n    \n    # \u041f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u0432\u0441\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0434\u043b\u0438\u043d\u044b \u043d\u0430\u043b\u043e\u0436\u0435\u043d\u0438\u044f\n    for overlap in range(1, n // 2 + 1):\n        # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u043c\u043e\u0436\u043d\u043e \u043b\u0438 \u0440\u0430\u0437\u0434\u0435\u043b\u0438\u0442\u044c \u0441\u0442\u0440\u043e\u043a\u0443 t \u043d\u0430 \u0434\u0432\u0435 \u0447\u0430\u0441\u0442\u0438 \u0441 \u043d\u0430\u043b\u043e\u0436\u0435\u043d\u0438\u0435\u043c \u0434\u043b\u0438\u043d\u044b overlap\n        if t[:overlap] == t[-overlap:]:\n            s = t[:-overlap]\n            if s + t[-overlap:] == t and len(s) > overlap:\n                return \"YES\", s\n    \n    return \"NO\", None\n\n# \u0427\u0442\u0435\u043d\u0438\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\nt = input().strip()\n\n# \u041f\u043e\u0438\u0441\u043a \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0433\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f s\nresult, s = find_original_message(t)\n\n# \u0412\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\nprint(result)\nif result == \"YES\":\n    print(s)"}
{"solution": "import math\n\ndef solve(n):\n    result = []\n    for i in range(1, int(math.sqrt(2 * n)) + 1):\n        x = 2 * n // i - i + 1\n        if x % 2 == 1 and x >= i and (2 * n - i * (i - 1) // 2) % x == 0:\n            y = (2 * n - i * (i - 1) // 2) // x\n            if y == 2 ** (int(math.log2(y))):  # check if y is a power of 2\n                result.append(x + y)\n    return sorted(result)\n\nn = int(input())\nresult = solve(n)\nif not result:\n    print(-1)\nelse:\n    for num in result:\n        print(num)"}
{"solution": "def max_beauty(n, s, b):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    beauty = 0\n    for i in range(n // 2):\n        char1 = s[i]\n        char2 = s[n - i - 1]\n        if char1 == char2:\n            if char_count[char1] > 2:\n                beauty += b[i] + b[n - i - 1]\n                char_count[char1] -= 2\n            else:\n                char_count[char1] = 0\n        else:\n            char_count[char1] -= 1\n            char_count[char2] -= 1\n\n    remaining_chars = [char for char, count in char_count.items() if count > 0]\n    remaining_beauty = sorted([(b[i], i) for i in range(n) if s[i] in remaining_chars], reverse=True)\n\n    for i in range(n // 2):\n        if remaining_beauty:\n            char1 = s[i]\n            char2 = s[n - i - 1]\n            if char1 in remaining_chars and char2 in remaining_chars:\n                if char1!= char2:\n                    beauty += max(remaining_beauty[0][0], remaining_beauty[1][0])\n                    remaining_beauty.pop(0)\n                    remaining_beauty.pop(0)\n                else:\n                    beauty += remaining_beauty[0][0]\n                    remaining_beauty.pop(0)\n\n    return beauty\n\n\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\nprint(max_beauty(n, s, b))"}
{"solution": "def can_be_weighted(w, m):\n    \"\"\"\n    Determine whether an item of mass m can be weighed using the given weights in a balanced manner.\n\n    Args:\n    w (int): The number defining the masses of the weights.\n    m (int): The mass of the item.\n\n    Returns:\n    bool: True if the item can be weighted, False otherwise.\n    \"\"\"\n    # Calculate the maximum weight that can be represented using the given weights\n    max_weight = (w ** 101 - 1) // (w - 1)\n\n    # Check if the mass of the item is within the range of representable weights\n    if m > max_weight:\n        return False\n\n    # Check if the mass of the item can be represented as a sum of powers of w\n    for i in range(101):\n        # Calculate the remainder of m divided by w^i\n        remainder = m % (w ** i)\n\n        # If the remainder is not a multiple of w^i, the mass cannot be represented\n        if remainder!= 0 and remainder!= (w ** i) - 1:\n            return False\n\n        # Subtract the remainder from the mass\n        m -= remainder\n\n    return True\n\n\ndef main():\n    # Read the input values\n    w, m = map(int, input().split())\n\n    # Check if the item can be weighted\n    if can_be_weighted(w, m):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve(n, k):\n    if k > n:\n        return [-1] * k\n\n    powers = []\n    i = 0\n    while n > 0:\n        if n & 1:\n            powers.append(i)\n        n >>= 1\n        i += 1\n\n    if len(powers) < k:\n        return None\n\n    powers.sort(reverse=True)\n    result = powers[:k]\n    return result\n\n\nn, k = map(int, input().split())\nresult = solve(n, k)\nif result is None:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    print(*result)"}
{"solution": "def champagne_pyramid(n, t):\n    pyramid = [[0.0] * i for i in range(1, n + 1)]\n    pyramid[0][0] = t\n\n    for i in range(n):\n        for j in range(len(pyramid[i])):\n            if pyramid[i][j] > 1:\n                excess = (pyramid[i][j] - 1) / 2\n                pyramid[i][j] = 1\n                if i < n - 1:\n                    pyramid[i + 1][j] += excess\n                    pyramid[i + 1][j + 1] += excess\n\n    return sum(1 for row in pyramid for glass in row if glass >= 1)\n\n\nn, t = map(int, input().split())\nprint(champagne_pyramid(n, t))"}
{"solution": "n = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\n\nif n == 1:\n    print(-1)\nelif n == 2:\n    x1, y1 = vertices[0]\n    x2, y2 = vertices[1]\n    if x1!= x2 and y1!= y2:\n        print(abs(x1 - x2) * abs(y1 - y2))\n    else:\n        print(-1)\nelif n == 3:\n    x_coords = set()\n    y_coords = set()\n    for x, y in vertices:\n        x_coords.add(x)\n        y_coords.add(y)\n    if len(x_coords) == 2 and len(y_coords) == 2:\n        x1, x2 = x_coords\n        y1, y2 = y_coords\n        print(abs(x1 - x2) * abs(y1 - y2))\n    else:\n        print(-1)\nelif n == 4:\n    x_coords = set()\n    y_coords = set()\n    for x, y in vertices:\n        x_coords.add(x)\n        y_coords.add(y)\n    if len(x_coords) == 2 and len(y_coords) == 2:\n        x1, x2 = x_coords\n        y1, y2 = y_coords\n        print(abs(x1 - x2) * abs(y1 - y2))\n    else:\n        print(-1)"}
{"solution": "import math\n\nn = int(input())\na = int(input())\nb = int(input())\n\ntotal_length = 2 * (2 * a + b)\nnum_bars = math.ceil(total_length / n)\n\nprint(num_bars)"}
{"solution": "def can_sort_array(n, a, swaps):\n    \"\"\"\n    Determine if it's possible to sort the array in ascending order using the given swaps.\n\n    Args:\n    n (int): The number of elements in the array.\n    a (list): The array of integers.\n    swaps (str): A string of 0s and 1s indicating which swaps are allowed.\n\n    Returns:\n    bool: True if the array can be sorted, False otherwise.\n    \"\"\"\n    # Initialize a list to store the maximum value that can be placed at each position\n    max_values = [0] * n\n\n    # Iterate over the array from right to left\n    for i in range(n - 1, -1, -1):\n        # If the current element is the maximum value, update the maximum value for this position\n        if i == n - 1 or a[i] > max_values[i + 1]:\n            max_values[i] = a[i]\n        # If the current element is not the maximum value and a swap is allowed, use the maximum value from the next position\n        elif swaps[i] == '1':\n            max_values[i] = max_values[i + 1]\n        # If the current element is not the maximum value and no swap is allowed, return False\n        else:\n            return False\n\n    # If we've iterated over the entire array without returning False, the array can be sorted\n    return True\n\n\ndef main():\n    # Read the number of elements in the array\n    n = int(input())\n\n    # Read the array of integers\n    a = list(map(int, input().split()))\n\n    # Read the string of swaps\n    swaps = input()\n\n    # Determine if the array can be sorted\n    if can_sort_array(n, a, swaps):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_time(row, seat):\n    # Calculate the number of rows the attendants need to move\n    rows_to_move = (row + 1) // 2\n\n    # Calculate the time spent moving rows\n    time_spent_moving = rows_to_move - 1\n\n    # Calculate the time spent serving rows\n    time_spent_serving = 6 * (rows_to_move - 1)\n\n    # Calculate the time spent serving the current row\n    if row % 2 == 1:\n        # First attendant serves the row\n        if seat in 'fefd':\n            time_spent_serving_current_row = 'fefd'.index(seat) + 1\n        else:\n            time_spent_serving_current_row = 3 + 'cba'.index(seat) + 1\n    else:\n        # Second attendant serves the row\n        if seat in 'fefd':\n            time_spent_serving_current_row = 'fefd'.index(seat) + 1\n        else:\n            time_spent_serving_current_row = 3 + 'cba'.index(seat) + 1\n\n    # Calculate the total time\n    total_time = time_spent_moving + time_spent_serving + time_spent_serving_current_row\n\n    return total_time\n\n\ndef main():\n    input_str = input()\n    row = int(input_str[:-1])\n    seat = input_str[-1]\n\n    print(calculate_time(row, seat))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def convert_to_decimal(digits, base):\n    decimal = 0\n    for i, digit in enumerate(reversed(digits)):\n        decimal += digit * (base ** i)\n    return decimal\n\ndef compare_numbers():\n    n, bx = map(int, input().split())\n    x_digits = list(map(int, input().split()))\n\n    m, by = map(int, input().split())\n    y_digits = list(map(int, input().split()))\n\n    x_decimal = convert_to_decimal(x_digits, bx)\n    y_decimal = convert_to_decimal(y_digits, by)\n\n    if x_decimal < y_decimal:\n        print('<')\n    elif x_decimal > y_decimal:\n        print('>')\n    else:\n        print('=')\n\ncompare_numbers()"}
{"solution": "def mex(arr):\n    arr.sort()\n    mex = 0\n    for i in arr:\n        if i == mex:\n            mex += 1\n    return mex\n\ndef xor(arr):\n    xor = 0\n    for i in arr:\n        xor ^= i\n    return xor\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    if n == 1:\n        if arr[0] == 0:\n            print(\"BitAryo\")\n        else:\n            print(\"BitLGM\")\n    elif n == 2:\n        if arr[0] == arr[1]:\n            print(\"BitLGM\")\n        else:\n            print(\"BitAryo\")\n    else:\n        if xor(arr) == 0:\n            print(\"BitAryo\")\n        else:\n            print(\"BitLGM\")\n\nsolve()"}
{"solution": "import math\nimport sys\n\ndef prime_factors(n):\n    factors = {}\n    while n % 2 == 0:\n        factors[2] = factors.get(2, 0) + 1\n        n //= 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            factors[i] = factors.get(i, 0) + 1\n            n //= i\n    if n > 2:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    k_factors = prime_factors(k)\n    prefix_factors = [{} for _ in range(n + 1)]\n    suffix_factors = [{} for _ in range(n + 1)]\n\n    for i in range(n):\n        factors = prime_factors(a[i])\n        for p, c in factors.items():\n            prefix_factors[i + 1][p] = prefix_factors[i].get(p, 0) + c\n            suffix_factors[n - i - 1][p] = suffix_factors[n - i].get(p, 0) + c\n\n    ans = 0\n    for i in range(n + 1):\n        for j in range(n + 1):\n            if i + j > n:\n                break\n            if all(prefix_factors[i].get(p, 0) + suffix_factors[j].get(p, 0) >= c for p, c in k_factors.items()):\n                ans += 1\n\n    print(ans - (n + 1) if ans > n + 1 else ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_distribute_balloons(n, k, s):\n    color_counts = {}\n    for color in s:\n        if color in color_counts:\n            color_counts[color] += 1\n        else:\n            color_counts[color] = 1\n\n    max_balloons_per_friend = n // k\n    remaining_balloons = n % k\n\n    for count in color_counts.values():\n        if count > max_balloons_per_friend + (1 if remaining_balloons > 0 else 0):\n            return \"NO\"\n        remaining_balloons -= 1 if count > max_balloons_per_friend else 0\n\n    return \"YES\"\n\nn, k = map(int, input().split())\ns = input().strip()\n\nprint(can_distribute_balloons(n, k, s))"}
{"solution": "def find_distance_between_minima():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    min_val = min(a)\n    indices = [i for i, x in enumerate(a) if x == min_val]\n\n    min_distance = float('inf')\n    for i in range(len(indices) - 1):\n        min_distance = min(min_distance, indices[i + 1] - indices[i])\n\n    print(min_distance)\n\nfind_distance_between_minima()"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nt, w, b = map(int, input().split())\n\nlcm_value = lcm(w, b)\ncount = t // lcm_value\n\nnumerator = count\ndenominator = t // math.gcd(count, t)\n\ngcd_value = gcd(numerator, denominator)\nnumerator //= gcd_value\ndenominator //= gcd_value\n\nprint(f\"{numerator}/{denominator}\")"}
{"solution": "def determine_vote_result(x, y, z):\n    \"\"\"\n    Determine the result of Nauuo's comment based on the number of upvotes, downvotes, and unknown votes.\n\n    Args:\n        x (int): The number of upvotes.\n        y (int): The number of downvotes.\n        z (int): The number of unknown votes.\n\n    Returns:\n        str: The result of Nauuo's comment, either \"+\", \"-\", \"0\", or \"?\".\n    \"\"\"\n\n    # Calculate the difference between upvotes and downvotes\n    diff = x - y\n\n    # If the difference is greater than the number of unknown votes, the result is certain\n    if diff > z:\n        return \"+\"\n    elif diff < -z:\n        return \"-\"\n    elif diff == 0 and z == 0:\n        return \"0\"\n    else:\n        return \"?\"\n\n\n# Read the input\nx, y, z = map(int, input().split())\n\n# Determine and print the result\nprint(determine_vote_result(x, y, z))"}
{"solution": "def min_length_changed_subsegment(n, operations, x, y):\n    # Calculate the initial position after performing all operations\n    initial_x = operations.count('R') - operations.count('L')\n    initial_y = operations.count('U') - operations.count('D')\n\n    # Calculate the difference between the target position and the initial position\n    dx = x - initial_x\n    dy = y - initial_y\n\n    # If the target position is not reachable, return -1\n    if abs(dx) > n or abs(dy) > n:\n        return -1\n\n    # Initialize the minimum length of the changed subsegment\n    min_length = float('inf')\n\n    # Try to change the subsegment starting from each position\n    for i in range(n):\n        # Calculate the number of operations that need to be changed\n        # to move the robot to the target position\n        changes = 0\n        new_x = initial_x\n        new_y = initial_y\n        for j in range(i, n):\n            if operations[j] == 'R':\n                new_x += 1\n            elif operations[j] == 'L':\n                new_x -= 1\n            elif operations[j] == 'U':\n                new_y += 1\n            elif operations[j] == 'D':\n                new_y -= 1\n\n            # If the robot is at the target position, update the minimum length\n            if new_x == x and new_y == y:\n                changes = j - i + 1\n                min_length = min(min_length, changes)\n                break\n\n            # If the robot is beyond the target position, break\n            if (new_x > x and dx > 0) or (new_x < x and dx < 0) or (new_y > y and dy > 0) or (new_y < y and dy < 0):\n                break\n\n            # If the robot is not at the target position, increment the changes\n            changes += 1\n\n    # If the minimum length is still infinity, return -1\n    if min_length == float('inf'):\n        return -1\n\n    # Return the minimum length of the changed subsegment\n    return min_length\n\n\nn = int(input())\noperations = input()\nx, y = map(int, input().split())\n\nprint(min_length_changed_subsegment(n, operations, x, y))"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.readline\n\n    T = int(input())\n    \n    results = []\n    \n    for _ in range(T):\n        n, x = map(int, input().split())\n        s = input().strip()\n        \n        balance_s = s.count('0') - s.count('1')\n        prefix_balances = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix_balances[i + 1] = prefix_balances[i] + (1 if s[i] == '0' else -1)\n        \n        if balance_s == 0:\n            if x in prefix_balances:\n                results.append(-1)\n            else:\n                results.append(0)\n        else:\n            count = 0\n            for b in prefix_balances:\n                if (x - b) % balance_s == 0 and (x - b) // balance_s >= 0:\n                    count += 1\n            results.append(count)\n    \n    for result in results:\n        print(result)\n\nsolve()"}
{"solution": "def min_digits_to_delete(n, k):\n    \"\"\"\n    Calculate the minimum number of digits to delete from n to make it divisible by 10^k.\n    \n    Args:\n    n (int): The input number.\n    k (int): The power of 10.\n    \n    Returns:\n    int: The minimum number of digits to delete.\n    \"\"\"\n    # Convert the number to a string to easily access each digit\n    num_str = str(n)\n    \n    # Calculate the number of trailing zeros required\n    trailing_zeros = k\n    \n    # Initialize the count of digits to delete\n    delete_count = 0\n    \n    # Iterate over the digits in the number from right to left\n    for i in range(len(num_str) - 1, -1, -1):\n        # If the digit is not zero, increment the delete count\n        if num_str[i]!= '0':\n            delete_count += 1\n        # If the digit is zero, decrement the trailing zeros count\n        else:\n            trailing_zeros -= 1\n        # If the number of trailing zeros is zero, break the loop\n        if trailing_zeros == 0:\n            break\n    \n    # If the number of trailing zeros is still greater than zero, \n    # it means we need to delete more digits to get the required trailing zeros\n    if trailing_zeros > 0:\n        delete_count += trailing_zeros\n    \n    # Return the minimum number of digits to delete\n    return delete_count\n\n\n# Read the input\nn, k = map(int, input().split())\n\n# Calculate and print the minimum number of digits to delete\nprint(min_digits_to_delete(n, k))"}
{"solution": "def calculate_max_min_sergei(n, m, k, x, y):\n    if n == 1:\n        max_val = (k + m - 1) // m\n        min_val = (k + m - 1) // m - 1 if k % m!= 0 else (k + m - 1) // m\n        sergei_val = (k + y - 1) // m\n    else:\n        full_cycles = (k - 1) // (2 * n * m - 2 * m) + 1\n        remaining_questions = k - (full_cycles - 1) * (2 * n * m - 2 * m)\n        max_val = full_cycles * 2 - 1 + min(remaining_questions, 2 * n * m - 2 * m) // (2 * m)\n        min_val = full_cycles * 2 - 1 + max(0, min(remaining_questions, 2 * n * m - 2 * m) - (2 * n * m - 2 * m)) // (2 * m)\n        sergei_val = full_cycles * 2 - 1 + (remaining_questions - 1) // (2 * m) + 1 if (x - 1) * m + y <= remaining_questions else full_cycles * 2 - 1\n    return max_val, min_val, sergei_val\n\nn, m, k, x, y = map(int, input().split())\nmax_val, min_val, sergei_val = calculate_max_min_sergei(n, m, k, x, y)\nprint(max_val, min_val, sergei_val)"}
{"solution": "def calculate_beauty(ribbon, n):\n    max_beauty = 0\n    for char in set(ribbon):\n        beauty = ribbon.count(char) + min(n, len(ribbon) - ribbon.count(char))\n        max_beauty = max(max_beauty, beauty)\n    return max_beauty\n\ndef main():\n    n = int(input())\n    ribbons = [input() for _ in range(3)]\n    beauty_values = [calculate_beauty(ribbon, n) for ribbon in ribbons]\n    max_beauty = max(beauty_values)\n    if beauty_values.count(max_beauty) > 1:\n        print(\"Draw\")\n    else:\n        print([\"Kuro\", \"Shiro\", \"Katie\"][beauty_values.index(max_beauty)])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_days(c, v0, v1, a, l):\n    \"\"\"\n    Calculate the number of days Mister B needs to finish the book.\n\n    Args:\n    c (int): The length of the book in pages.\n    v0 (int): The initial reading speed.\n    v1 (int): The maximum reading speed.\n    a (int): The acceleration in reading speed.\n    l (int): The number of pages for rereading.\n\n    Returns:\n    int: The number of days Mister B needs to finish the book.\n    \"\"\"\n    days = 0\n    total_pages_read = 0\n\n    while total_pages_read < c:\n        # Calculate the pages read on the current day\n        pages_read = min(v0 + days * a, v1)\n\n        # If this is not the first day, subtract the pages that need to be reread\n        if days > 0:\n            pages_read -= l\n\n        # Update the total pages read\n        total_pages_read += pages_read\n\n        # Increment the day counter\n        days += 1\n\n    return days\n\n\n# Read the input values\nc, v0, v1, a, l = map(int, input().split())\n\n# Calculate and print the number of days\nprint(calculate_days(c, v0, v1, a, l))"}
{"solution": "def is_prime(num):\n    \"\"\"Check if a number is prime.\"\"\"\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef find_primes(n):\n    \"\"\"Find a set of primes that sum up to n.\"\"\"\n    if is_prime(n):\n        return [n]\n    for i in range(2, n):\n        if is_prime(i) and is_prime(n - i):\n            return [i, n - i]\n    for i in range(2, n):\n        if is_prime(i):\n            for j in range(2, n - i):\n                if is_prime(j) and is_prime(n - i - j):\n                    return [i, j, n - i - j]\n\ndef main():\n    n = int(input())\n    primes = find_primes(n)\n    print(len(primes))\n    print(*primes)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_walls(grid):\n    \"\"\"Count the number of walls in each row and column.\"\"\"\n    row_walls = [row.count('*') for row in grid]\n    col_walls = [sum(1 for row in grid if row[i] == '*') for i in range(len(grid[0]))]\n    return row_walls, col_walls\n\ndef find_bomb_location(grid):\n    \"\"\"Find the location where the bomb should be placed.\"\"\"\n    row_walls, col_walls = count_walls(grid)\n    total_walls = sum(row_walls)\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if row_walls[i] + col_walls[j] - (grid[i][j] == '*') == total_walls:\n                return i + 1, j + 1\n    return None\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [input() for _ in range(n)]\n    \n    bomb_location = find_bomb_location(grid)\n    if bomb_location:\n        print(\"YES\")\n        print(*bomb_location)\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\nn, m, a, b = map(int, input().split())\n\ndef min_cost(n, m, a, b):\n    remainder = n % m\n    if remainder == 0:\n        return 0\n    else:\n        build_cost = (m - remainder) * a\n        demolish_cost = remainder * b\n        return min(build_cost, demolish_cost)\n\ndef min_cost_with_zero(n, m, a, b):\n    remainder = n % m\n    if remainder == 0:\n        return 0\n    else:\n        build_cost = (m - remainder) * a\n        demolish_cost = remainder * b\n        zero_cost = n * b\n        return min(build_cost, demolish_cost, zero_cost)\n\nprint(min_cost_with_zero(n, m, a, b))"}
{"solution": "def max_odd_subsequence_sum(n, sequence):\n    \"\"\"\n    This function calculates the maximum sum of a subsequence with an odd sum.\n\n    Args:\n    n (int): The length of the sequence.\n    sequence (list): A list of integers.\n\n    Returns:\n    int: The maximum sum of a subsequence with an odd sum.\n    \"\"\"\n    # Initialize variables to store the maximum sum of subsequences with odd and even sums\n    max_odd_sum = float('-inf')\n    max_even_sum = 0\n\n    # Iterate over the sequence\n    for num in sequence:\n        # If the current number is odd, update max_odd_sum and max_even_sum accordingly\n        if num % 2!= 0:\n            max_odd_sum, max_even_sum = max(max_odd_sum + num, max_even_sum), max(max_even_sum + num, max_odd_sum)\n        # If the current number is even, update max_odd_sum and max_even_sum accordingly\n        else:\n            max_odd_sum, max_even_sum = max(max_odd_sum, max_even_sum + num), max(max_even_sum, max_odd_sum + num)\n\n    # Return the maximum sum of a subsequence with an odd sum\n    return max_odd_sum\n\n\n# Read the input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Calculate and print the maximum sum of a subsequence with an odd sum\nprint(max_odd_subsequence_sum(n, sequence))"}
{"solution": ""}
{"solution": "MOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef totient(n):\n    \"\"\"Compute Euler's totient function\"\"\"\n    result = n\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            while n % p == 0:\n                n //= p\n            result -= result // p\n        p += 1\n    if n > 1:\n        result -= result // n\n    return result\n\ndef expected_length(m):\n    \"\"\"Compute the expected length of the array\"\"\"\n    result = 0\n    for i in range(2, m + 1):\n        result += totient(i) * mod_inverse(i, MOD)\n        result %= MOD\n    return (result + m) % MOD\n\nm = int(input())\nprint(expected_length(m))"}
{"solution": "import math\n\ndef count_good_pairs(l, r, x, y):\n    if x > y or y % x!= 0 or y < x * x:\n        return 0\n\n    count = 0\n    for a in range(x, y + 1, x):\n        if a * a > y:\n            break\n        if y % a == 0:\n            b = y // a\n            if b * x > r:\n                break\n            count += max(min(r // (a * x), r // (b * x)) - l // (a * x) + 1, 0)\n            if a!= b:\n                count += max(min(r // (b * x), r // (a * x)) - l // (b * x) + 1, 0)\n    return count\n\nl, r, x, y = map(int, input().split())\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\na, b = map(int, input().split())\n\nif a > b:\n    a, b = b, a\n\nk = 0\nwhile True:\n    if (b + k) % (a + k) == 0:\n        break\n    k += 1\n\nprint(k)"}
{"solution": "def calculate_additional_marks(n, k, marks):\n    \"\"\"\n    Calculate the minimal number of additional marks needed to achieve a final mark of k.\n\n    Args:\n    n (int): The number of marks received by Noora.\n    k (int): The value of the highest possible mark.\n    marks (list): A list of marks received by Noora before Leha's hack.\n\n    Returns:\n    int: The minimal number of additional marks needed.\n    \"\"\"\n    total_marks = sum(marks)\n    additional_marks = 0\n\n    while True:\n        average = (total_marks + additional_marks) / (n + additional_marks)\n        if average >= k - 0.5:\n            break\n        additional_marks += 1\n\n    return additional_marks\n\n\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\nadditional_marks = calculate_additional_marks(n, k, marks)\nprint(additional_marks)"}
{"solution": "import math\n\ndef find_d(n, arr):\n    for d in range(-1000, 1001):\n        if d == 0:\n            continue\n        positive_count = sum(1 for x in arr if x / d > 0)\n        if positive_count >= math.ceil(n / 2):\n            return d\n    return 0\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(find_d(n, arr))"}
{"solution": "def count_pairs(n):\n    \"\"\"\n    Calculate the number of pairs of shovels such that their total cost ends with maximum possible number of nines.\n\n    Args:\n    n (int): The number of shovels in Polycarp's shop.\n\n    Returns:\n    int: The number of pairs of shovels such that their total cost ends with maximum possible number of nines.\n    \"\"\"\n    # Calculate the maximum possible number of nines at the end\n    max_nines = len(str(n)) - 1\n\n    # Initialize the count of pairs\n    count = 0\n\n    # Iterate over the possible numbers of nines at the end\n    for i in range(max_nines, -1, -1):\n        # Calculate the target sum\n        target_sum = int('9' * (i + 1))\n\n        # Calculate the maximum possible sum\n        max_sum = n * (n + 1) // 2\n\n        # If the target sum is greater than the maximum possible sum, break the loop\n        if target_sum > max_sum:\n            break\n\n        # Calculate the count of pairs for the current number of nines\n        count = (n - target_sum + 1) // 10\n\n        # If the count is greater than 0, return the count\n        if count > 0:\n            return count\n\n    # If no pairs are found, return 0\n    return 0\n\n\n# Read the input\nn = int(input())\n\n# Print the output\nprint(count_pairs(n))"}
{"solution": "from collections import deque\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(a1, b1, a2, b2):\n    queue = deque([(a1, b1, 0)])\n    visited = set((a1, b1))\n    while queue:\n        a, b, steps = queue.popleft()\n        if a * b == a2 * b2:\n            return steps, (a, b), (a2, b2)\n        if a % 2 == 0 and (a // 2, b) not in visited:\n            queue.append((a // 2, b, steps + 1))\n            visited.add((a // 2, b))\n        if b % 2 == 0 and (a, b // 2) not in visited:\n            queue.append((a, b // 2, steps + 1))\n            visited.add((a, b // 2))\n        if a % 3 == 0 and (a // 3, b) not in visited:\n            queue.append((a // 3, b, steps + 1))\n            visited.add((a // 3, b))\n        if b % 3 == 0 and (a, b // 3) not in visited:\n            queue.append((a, b // 3, steps + 1))\n            visited.add((a, b // 3))\n    return -1, None, None\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\nif a1 * b1 < a2 * b2:\n    a1, b1, a2, b2 = a2, b2, a1, b1\nsteps, (a, b), (c, d) = solve(a1, b1, a2, b2)\nif steps == -1:\n    print(-1)\nelse:\n    print(steps)\n    print(a, b)\n    print(c, d)"}
{"solution": "def determine_winner(x_p, y_p, x_v, y_v):\n    \"\"\"\n    Determine the winner of the game based on the starting coordinates of both pawns.\n\n    Args:\n    x_p (int): Polycarp's x-coordinate.\n    y_p (int): Polycarp's y-coordinate.\n    x_v (int): Vasiliy's x-coordinate.\n    y_v (int): Vasiliy's y-coordinate.\n\n    Returns:\n    str: The name of the winner, either \"Polycarp\" or \"Vasiliy\".\n    \"\"\"\n    # Calculate the minimum number of moves for Polycarp to reach (0, 0)\n    polycarp_moves = max(x_p, y_p)\n\n    # Calculate the minimum number of moves for Vasiliy to reach (0, 0)\n    vasiliy_moves = max(x_v + y_v - min(x_v, y_v), min(x_v, y_v))\n\n    # If Polycarp can reach (0, 0) in less moves, he wins\n    if polycarp_moves < vasiliy_moves:\n        return \"Polycarp\"\n    # If Vasiliy can reach (0, 0) in less moves, he wins\n    elif polycarp_moves > vasiliy_moves:\n        return \"Vasiliy\"\n    # If both can reach (0, 0) in the same number of moves, Polycarp wins because he starts first\n    else:\n        return \"Polycarp\"\n\n\n# Read the input coordinates\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Determine and print the winner\nprint(determine_winner(x_p, y_p, x_v, y_v))"}
{"solution": "def calculate_columns(m, d):\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    first_day_weekday = d\n    total_days = days_in_month[m - 1]\n    days_before_first_full_week = 7 - first_day_weekday + 1\n    remaining_days = total_days - days_before_first_full_week\n    full_weeks = remaining_days // 7\n    partial_week_days = remaining_days % 7\n    if partial_week_days > 0:\n        full_weeks += 1\n    total_columns = days_before_first_full_week // 7 + full_weeks\n    if days_before_first_full_week % 7 > 0:\n        total_columns += 1\n    return total_columns\n\nm, d = map(int, input().split())\nprint(calculate_columns(m, d))"}
{"solution": "def count_years_with_one_zero(a, b):\n    def count_years_with_one_zero_up_to(n):\n        count = 0\n        for i in range(1, n.bit_length() + 1):\n            count += 2 ** (i - 1)\n        for i in range(n.bit_length()):\n            if (n >> i) & 1 == 0:\n                count -= 2 ** i\n                break\n        return count\n\n    return count_years_with_one_zero_up_to(b) - count_years_with_one_zero_up_to(a - 1)\n\n\na, b = map(int, input().split())\nprint(count_years_with_one_zero(a, b))"}
{"solution": "import math\n\ndef minimal_layers(N):\n    return math.ceil((N + 1) / 2)\n\nN = int(input())\nprint(minimal_layers(N))"}
{"solution": "import math\nimport sys\n\ndef read_input():\n    n, k, S = map(int, input().split())\n    a = list(map(int, input().split()))\n    return n, k, S, a\n\ndef solve(n, k, S, a):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n            dp[i][j] += dp[i - 1][j]\n\n            if a[i - 1] <= S:\n                for l in range(j + 1):\n                    if a[i - 1] * math.factorial(l) <= S:\n                        dp[i][j] += dp[i - 1][j - l]\n\n    return dp[n][k]\n\ndef main():\n    n, k, S, a = read_input()\n    print(solve(n, k, S, a))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef solve(n, k, a):\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        p = 0\n        while a[i] > 0:\n            if a[i] % k == 0:\n                a[i] //= k\n                p += 1\n            else:\n                return \"NO\"\n        if p > 60:\n            return \"NO\"\n    return \"YES\"\n\ndef main():\n    input = sys.stdin.readline\n    t = int(input())\n    for _ in range(t):\n        n, k = map(int, input().split())\n        a = list(map(int, input().split()))\n        print(solve(n, k, a))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_divisors(n):\n    \"\"\"Count the number of divisors of a positive integer n.\"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef main():\n    \"\"\"Calculate the sum of divisors of all combinations of i, j, and k.\"\"\"\n    a, b, c = map(int, input().split())\n    total_sum = 0\n    mod = 2**30\n\n    # Precompute the number of divisors for each number up to max(a, b, c)\n    max_num = max(a, b, c)\n    divisors = [count_divisors(i) for i in range(1, max_num + 1)]\n\n    # Calculate the sum of divisors for all combinations of i, j, and k\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                total_sum += divisors[i - 1] * divisors[j - 1] * divisors[k - 1]\n                total_sum %= mod\n\n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    neighbors = []\n    idx = state.index('X')\n    if idx == 0:\n        neighbors.append(swap(state, 0, 1))\n        neighbors.append(swap(state, 0, 2))\n    elif idx == 1:\n        neighbors.append(swap(state, 1, 0))\n        neighbors.append(swap(state, 1, 3))\n    elif idx == 2:\n        neighbors.append(swap(state, 2, 0))\n        neighbors.append(swap(state, 2, 3))\n    elif idx == 3:\n        neighbors.append(swap(state, 3, 1))\n        neighbors.append(swap(state, 3, 2))\n    return neighbors\n\ndef swap(state, i, j):\n    state = list(state)\n    state[i], state[j] = state[j], state[i]\n    return ''.join(state)\n\ndef bfs(start):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        current = queue.popleft()\n        for neighbor in get_neighbors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return visited\n\ndef can_be_same_configuration(bessie, elsie):\n    bessie_start = ''.join(bessie)\n    elsie_start = ''.join(elsie)\n    \n    bessie_reachable = bfs(bessie_start)\n    elsie_reachable = bfs(elsie_start)\n    \n    return not bessie_reachable.isdisjoint(elsie_reachable)\n\ndef main():\n    bessie = [input().strip() for _ in range(2)]\n    elsie = [input().strip() for _ in range(2)]\n\n    if can_be_same_configuration(bessie, elsie):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def convert_to_decimal(n, k):\n    decimal = 0\n    power = 0\n    for digit in reversed(k):\n        decimal += int(digit) * (n ** power)\n        power += 1\n    return decimal\n\nn = int(input())\nk = input()\n\nprint(convert_to_decimal(n, k))"}
{"solution": "def is_unimodal(arr):\n    increasing = decreasing = False\n    constant = True\n\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            if decreasing:\n                return False\n            increasing = True\n            constant = False\n        elif arr[i] < arr[i - 1]:\n            if increasing:\n                decreasing = True\n            constant = False\n        else:\n            if decreasing:\n                return False\n\n    return True\n\n\nn = int(input())\narr = list(map(int, input().split()))\n\nprint(\"YES\" if is_unimodal(arr) else \"NO\")"}
{"solution": "def solve(n, k):\n    if k == 1:\n        return n\n    if n == k:\n        return 1\n\n    def count(y):\n        if y == 1:\n            return n - y + 1\n        if y % 2 == 1:\n            return n // y - (y - 1) // 2\n        return n // y - (y - 2) // 2\n\n    lo, hi = 1, n\n    while lo < hi:\n        mid = (lo + hi + 1) // 2\n        if count(mid) >= k:\n            lo = mid\n        else:\n            hi = mid - 1\n    return lo\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve():\n    n, m, x, y, vx, vy = map(int, input().split())\n\n    if vx == 0:\n        if vy > 0:\n            return f\"{x} {m}\"\n        else:\n            return f\"{x} 0\"\n\n    if vy == 0:\n        if vx > 0:\n            return f\"{n} {y}\"\n        else:\n            return f\"0 {y}\"\n\n    dx = n - x if vx > 0 else x\n    dy = m - y if vy > 0 else y\n\n    g = gcd(dx, dy)\n\n    if dx // g!= dy // g:\n        return \"-1\"\n\n    if vx > 0:\n        x = n\n    else:\n        x = 0\n\n    if vy > 0:\n        y = m\n    else:\n        y = 0\n\n    return f\"{x} {y}\"\n\nprint(solve())"}
{"solution": "def can_place_paintings():\n    a1, b1 = map(int, input().split())\n    a2, b2 = map(int, input().split())\n    a3, b3 = map(int, input().split())\n\n    def fits(w1, h1, w2, h2, W, H):\n        return (w1 + w2 <= W and max(h1, h2) <= H) or (h1 + h2 <= H and max(w1, w2) <= W)\n\n    if (fits(a2, b2, a3, b3, a1, b1) or fits(b2, a2, a3, b3, a1, b1) or\n        fits(a2, b2, b3, a3, a1, b1) or fits(b2, a2, b3, a3, a1, b1) or\n        fits(a3, b3, a2, b2, a1, b1) or fits(b3, a3, a2, b2, a1, b1) or\n        fits(a3, b3, b2, a2, a1, b1) or fits(b3, a3, b2, a2, a1, b1)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\ncan_place_paintings()"}
{"solution": "def calculate_written_numbers(b1, q, limit, bad_numbers):\n    \"\"\"\n    Calculate the number of progression terms that will be written on the board.\n\n    Args:\n    b1 (int): The initial term of the geometric progression.\n    q (int): The common ratio of the geometric progression.\n    limit (int): The absolute value of the maximal number that can be written on the board.\n    bad_numbers (set): A set of numbers that will never be written on the board.\n\n    Returns:\n    int or str: The number of progression terms that will be written on the board if it is finite, or \"inf\" otherwise.\n    \"\"\"\n    if q == 1:\n        # If the common ratio is 1, the progression is constant\n        if b1 in bad_numbers:\n            return 0\n        elif abs(b1) <= limit:\n            return \"inf\"\n        else:\n            return 0\n\n    if q == 0:\n        # If the common ratio is 0, the progression is constant after the first term\n        if b1 in bad_numbers:\n            return 0\n        elif abs(b1) <= limit:\n            return 1\n        else:\n            return 0\n\n    if q == -1:\n        # If the common ratio is -1, the progression alternates between two values\n        if b1 in bad_numbers:\n            if -b1 in bad_numbers:\n                return 0\n            elif abs(-b1) <= limit:\n                return \"inf\"\n            else:\n                return 0\n        elif abs(b1) <= limit:\n            if -b1 in bad_numbers:\n                return \"inf\"\n            elif abs(-b1) <= limit:\n                return \"inf\"\n            else:\n                return 1\n        else:\n            return 0\n\n    written_numbers = 0\n    current_term = b1\n\n    while abs(current_term) <= limit:\n        if current_term not in bad_numbers:\n            written_numbers += 1\n        current_term *= q\n\n    if abs(current_term) > limit:\n        return written_numbers\n    else:\n        return \"inf\"\n\n\n# Read input\nb1, q, limit, _ = map(int, input().split())\nbad_numbers = set(map(int, input().split()))\n\n# Calculate and print the result\nresult = calculate_written_numbers(b1, q, limit, bad_numbers)\nprint(result)"}
{"solution": ""}
{"solution": "def extended_gcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x, y = extended_gcd(b % a, a)\n        return gcd, y - (b // a) * x, x\n\ndef solve(n, a, b):\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd!= 0:\n        return None\n    x *= n // gcd\n    y *= n // gcd\n    if x < 0:\n        k = (-x) // (b // gcd)\n        x += k * (b // gcd)\n        y -= k * (a // gcd)\n    if y < 0:\n        k = (-y) // (a // gcd)\n        x -= k * (b // gcd)\n        y += k * (a // gcd)\n    return x, y\n\nn = int(input())\na = int(input())\nb = int(input())\n\nsolution = solve(n, a, b)\nif solution is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(*solution)"}
{"solution": "def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\ns = int(input())\nprint(number_to_words(s))"}
{"solution": "def max_consecutive_elements_to_erase(n, arr):\n    \"\"\"\n    Calculate the maximum number of consecutive elements that can be erased from the array.\n\n    Args:\n    n (int): The number of elements in the array.\n    arr (list): The array of integers.\n\n    Returns:\n    int: The maximum number of consecutive elements that can be erased.\n    \"\"\"\n    max_erase = 0\n\n    # Check if it's possible to erase elements from the start\n    if arr[0] > 1:\n        max_erase = max(max_erase, arr[0] - 1)\n\n    # Check if it's possible to erase elements from the end\n    if arr[-1] < 1000:\n        max_erase = max(max_erase, 1000 - arr[-1])\n\n    # Check for the maximum number of consecutive elements that can be erased in the middle\n    for i in range(1, n - 1):\n        if arr[i + 1] - arr[i - 1] > 2:\n            max_erase = max(max_erase, arr[i + 1] - arr[i - 1] - 2)\n\n    return max_erase\n\n\nn = int(input())\narr = list(map(int, input().split()))\n\nprint(max_consecutive_elements_to_erase(n, arr))"}
{"solution": "def find_equator_day(n, problems):\n    \"\"\"\n    Determine the index of day when Polycarp will celebrate the equator.\n\n    Args:\n    n (int): The number of days to prepare for the programming contests.\n    problems (list): A sequence of the number of problems Polycarp will solve each day.\n\n    Returns:\n    int: The index of the day when Polycarp will celebrate the equator.\n    \"\"\"\n    total_problems = sum(problems)\n    cumulative_sum = 0\n\n    for i, problems_solved in enumerate(problems):\n        cumulative_sum += problems_solved\n        if cumulative_sum >= total_problems / 2:\n            return i + 1\n\nn = int(input())\nproblems = list(map(int, input().split()))\n\nprint(find_equator_day(n, problems))"}
{"solution": ""}
{"solution": "def calculate_time(n, m, k, a, b):\n    # Calculate the position of Edward's and Natasha's apartments\n    edward_pod = (a - 1) // (m * k) + 1\n    edward_et = ((a - 1) % (m * k)) // k + 1\n    natasha_pod = (b - 1) // (m * k) + 1\n    natasha_et = ((b - 1) % (m * k)) // k + 1\n\n    # Calculate the distance between the two apartments\n    pod_distance = abs(edward_pod - natasha_pod)\n    if pod_distance > n // 2:\n        pod_distance = n - pod_distance\n\n    # Calculate the time to move between the apartments\n    time_to_move = 5 * abs(edward_et - 1) + 15 * pod_distance + 5 * abs(natasha_et - 1)\n\n    # Calculate the time to use the elevator\n    elevator_time = 10 + abs(edward_et - 1) + 15 * pod_distance + abs(natasha_et - 1)\n\n    # Return the minimum time\n    return min(time_to_move, elevator_time)\n\n\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\nprint(calculate_time(n, m, k, a, b))"}
{"solution": "def is_divisible_by_64(binary_string):\n    \"\"\"\n    Checks if it's possible to remove some digits from the binary string \n    to get a number divisible by 64 in the binary numerical system.\n    \n    Args:\n    binary_string (str): A non-empty binary string.\n    \n    Returns:\n    bool: True if it's possible to get a number divisible by 64, False otherwise.\n    \"\"\"\n    # Check if the string has at least 6 characters (minimum length for a binary number divisible by 64)\n    if len(binary_string) < 6:\n        return False\n    \n    # Check if the string ends with '000000' (a necessary condition for a binary number to be divisible by 64)\n    if not binary_string.endswith('0') * 6:\n        return False\n    \n    # Check if there's at least one '1' in the string (a necessary condition for a binary number to be non-zero)\n    if '1' not in binary_string:\n        return False\n    \n    # If all conditions are met, it's possible to get a number divisible by 64\n    return True\n\n\ndef main():\n    binary_string = input()\n    if is_divisible_by_64(binary_string):\n        print('yes')\n    else:\n        print('no')\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def transform_string(s):\n    result = list(s)\n    target = 'abcdefghijklmnopqrstuvwxyz'\n    target_index = 0\n\n    for i in range(len(s)):\n        if s[i] >= target[target_index]:\n            result[i] = target[target_index]\n            target_index += 1\n            if target_index == len(target):\n                break\n\n    if target_index == len(target):\n        for i in range(len(s)):\n            if result[i] < target[target_index - 1]:\n                next_char = chr(ord(result[i]) + 1)\n                if next_char <= target[target_index - 1]:\n                    result[i] = next_char\n    else:\n        return '-1'\n\n    return ''.join(result)\n\ns = input()\nprint(transform_string(s))"}
{"solution": "import math\n\ndef calculate_expected_value(n, m, r, k):\n    total_positions = (n - r + 1) * (m - r + 1)\n    max_fish = min(n * m, k)\n\n    if max_fish <= (n - r + 1) * (m - r + 1):\n        return (max_fish * (r ** 2)) / total_positions\n\n    result = 0\n    for i in range(1, r + 1):\n        for j in range(1, r + 1):\n            if i * j <= k:\n                result += (i * j) * (n - i + 1) * (m - j + 1)\n            else:\n                result += k * (n - i + 1) * (m - j + 1)\n    return result / total_positions\n\nn, m, r, k = map(int, input().split())\nprint(calculate_expected_value(n, m, r, k))"}
{"solution": "def maximize_product(n, arr):\n    \"\"\"\n    This function maximizes the product of an array by applying the operation a_i := -a_i - 1.\n    \n    Parameters:\n    n (int): The number of elements in the array.\n    arr (list): The input array.\n    \n    Returns:\n    list: The array with the maximal possible product of elements.\n    \"\"\"\n    \n    # Initialize a variable to track the number of negative numbers in the array\n    negative_count = 0\n    \n    # Initialize a variable to track the number of zeros in the array\n    zero_count = 0\n    \n    # Initialize a variable to track the minimum absolute value in the array\n    min_abs = float('inf')\n    \n    # Iterate over the array to count the number of negative numbers, zeros, and find the minimum absolute value\n    for i in range(n):\n        if arr[i] < 0:\n            negative_count += 1\n        if arr[i] == 0:\n            zero_count += 1\n        if abs(arr[i]) < min_abs:\n            min_abs = abs(arr[i])\n    \n    # If the number of negative numbers is odd, we need to make one of them positive to maximize the product\n    if negative_count % 2!= 0:\n        # If there is a zero in the array, we can make the smallest absolute value positive\n        if zero_count > 0:\n            for i in range(n):\n                if arr[i] == 0:\n                    arr[i] = -min_abs - 1\n                    break\n        # If there is no zero in the array, we need to make the smallest absolute value positive\n        else:\n            for i in range(n):\n                if abs(arr[i]) == min_abs:\n                    arr[i] = -arr[i] - 1\n                    break\n    \n    # If the number of negative numbers is even, we can make all negative numbers positive to maximize the product\n    else:\n        for i in range(n):\n            if arr[i] < 0:\n                arr[i] = -arr[i] - 1\n    \n    return arr\n\n# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Maximize the product of the array\nresult = maximize_product(n, arr)\n\n# Print the result\nprint(*result)"}
{"solution": "import math\n\ndef kth_smallest_divisor(n, k):\n    divisors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    divisors = sorted(list(divisors))\n    if k > len(divisors):\n        return -1\n    else:\n        return divisors[k - 1]\n\nn, k = map(int, input().split())\nprint(kth_smallest_divisor(n, k))"}
{"solution": "from collections import defaultdict\nfrom itertools import permutations\n\ndef get_digits(cube):\n    digits = set(cube)\n    if 6 in digits:\n        digits.add(9)\n    if 9 in digits:\n        digits.add(6)\n    return digits\n\ndef get_permutations(cubes, n):\n    perms = []\n    for p in permutations(cubes, n):\n        digits = [get_digits(cube) for cube in p]\n        perms.append(digits)\n    return perms\n\ndef check_number(num, perms):\n    num_str = str(num)\n    for perm in perms:\n        found = True\n        for digit in num_str:\n            if not any(digit in perm[i] for i in range(len(perm))):\n                found = False\n                break\n            if found:\n                for i in range(len(perm)):\n                    if digit in perm[i]:\n                        perm[i].remove(digit)\n                        break\n        if found:\n            return True\n    return False\n\ndef solve(n, cubes):\n    perms = get_permutations(cubes, n)\n    max_num = 0\n    for num in range(1, 1000):\n        if check_number(num, perms):\n            max_num = num\n        else:\n            break\n    return max_num\n\nn = int(input())\ncubes = []\nfor _ in range(n):\n    cube = list(map(int, input().split()))\n    cubes.append(cube)\n\nprint(solve(n, cubes))"}
{"solution": "import math\n\ndef k_rounding(n, k):\n    \"\"\"\n    Calculate the k-rounding of a given positive integer n.\n    \n    The k-rounding of n is the minimum positive integer x, such that x ends with k or more zeros in base 10 and is divisible by n.\n    \n    Parameters:\n    n (int): The input number.\n    k (int): The number of trailing zeros.\n    \n    Returns:\n    int: The k-rounding of n.\n    \"\"\"\n    \n    # Calculate the number of trailing zeros needed\n    trailing_zeros = 10 ** k\n    \n    # Calculate the least common multiple of n and the number of trailing zeros\n    lcm = (n * trailing_zeros) // math.gcd(n, trailing_zeros)\n    \n    return lcm\n\n# Read the input\nn, k = map(int, input().split())\n\n# Calculate and print the k-rounding of n\nprint(k_rounding(n, k))"}
{"solution": ""}
{"solution": "import sys\n\ndef read_input():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef calculate_probabilities(r, s, p):\n    total = r + s + p\n    probabilities = [0, 0, 0]\n\n    if total == 3:\n        probabilities[0] = r / total\n        probabilities[1] = s / total\n        probabilities[2] = p / total\n    else:\n        if r == 0:\n            probabilities[1] = s / (s + p)\n            probabilities[2] = p / (s + p)\n        elif s == 0:\n            probabilities[0] = r / (r + p)\n            probabilities[2] = p / (r + p)\n        elif p == 0:\n            probabilities[0] = r / (r + s)\n            probabilities[1] = s / (r + s)\n        else:\n            probabilities[0] = (r * (s + p - 1)) / ((r + s) * (r + p - 1))\n            probabilities[1] = (s * (r + p - 1)) / ((s + p) * (s + r - 1))\n            probabilities[2] = (p * (r + s - 1)) / ((r + p) * (p + s - 1))\n\n    return probabilities\n\ndef main():\n    r, s, p = read_input()\n    probabilities = calculate_probabilities(r, s, p)\n    print(' '.join(map(str, probabilities)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_time_together(l1, r1, l2, r2, k):\n    \"\"\"\n    Calculate the number of minutes Sonya and Filya will be able to spend together.\n\n    Args:\n        l1 (int): The start minute of Sonya's awake time.\n        r1 (int): The end minute of Sonya's awake time.\n        l2 (int): The start minute of Filya's visit time.\n        r2 (int): The end minute of Filya's visit time.\n        k (int): The minute when Sonya prinks.\n\n    Returns:\n        int: The number of minutes Sonya and Filya will be able to spend together.\n    \"\"\"\n    # Calculate the overlap between Sonya's awake time and Filya's visit time\n    overlap_start = max(l1, l2)\n    overlap_end = min(r1, r2)\n\n    # If there is no overlap, return 0\n    if overlap_start > overlap_end:\n        return 0\n\n    # Calculate the total overlap time\n    total_overlap = overlap_end - overlap_start + 1\n\n    # If Sonya prinks during the overlap time, subtract 1 from the total overlap time\n    if overlap_start <= k <= overlap_end:\n        total_overlap -= 1\n\n    return total_overlap\n\n\n# Read input from the user\nl1, r1, l2, r2, k = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_time_together(l1, r1, l2, r2, k)\nprint(result)"}
{"solution": "import sys\n\ndef main():\n    N, M = map(int, sys.stdin.readline().split())\n\n    A = []\n    B = []\n    C = []\n    D = []\n    E = []\n    F = []\n\n    for _ in range(N):\n        a, b, c = map(int, sys.stdin.readline().split())\n        A.append(a)\n        B.append(b)\n        C.append(c)\n\n    for _ in range(M):\n        d, e, f = map(int, sys.stdin.readline().split())\n        D.append(d)\n        E.append(e)\n        F.append(f)\n\n    def check(x, y):\n        for i in range(N):\n            if A[i] <= x <= B[i] and C[i] == y:\n                return False\n        for i in range(M):\n            if E[i] <= y <= F[i] and D[i] == x:\n                return False\n        return True\n\n    def check_range(x1, x2, y):\n        if x1 > x2:\n            x1, x2 = x2, x1\n        for i in range(N):\n            if A[i] <= x1 <= B[i] and C[i] == y:\n                return False\n            if A[i] <= x2 <= B[i] and C[i] == y:\n                return False\n            if x1 <= A[i] and B[i] <= x2 and C[i] == y:\n                return False\n        return True\n\n    def check_range2(y1, y2, x):\n        if y1 > y2:\n            y1, y2 = y2, y1\n        for i in range(M):\n            if E[i] <= y1 <= F[i] and D[i] == x:\n                return False\n            if E[i] <= y2 <= F[i] and D[i] == x:\n                return False\n            if y1 <= E[i] and F[i] <= y2 and D[i] == x:\n                return False\n        return True\n\n    def calc(x, y):\n        if not check(x, y):\n            return 0\n        if x > 0 and y > 0:\n            if check_range(0, x, y) and check_range2(0, y, x):\n                return x * y\n            else:\n                return 0\n        elif x < 0 and y > 0:\n            if check_range(x, 0, y) and check_range2(0, y, x):\n                return -x * y\n            else:\n                return 0\n        elif x < 0 and y < 0:\n            if check_range(x, 0, y) and check_range2(y, 0, x):\n                return x * y\n            else:\n                return 0\n        elif x > 0 and y < 0:\n            if check_range(0, x, y) and check_range2(y, 0, x):\n                return -x * y\n            else:\n                return 0\n\n    ans = 0\n    for i in range(N):\n        ans += calc(A[i], C[i])\n        ans += calc(B[i], C[i])\n    for i in range(M):\n        ans += calc(D[i], E[i])\n        ans += calc(D[i], F[i])\n\n    if ans == 0:\n        print(\"INF\")\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def will_pineapple_bark(t, s, x):\n    \"\"\"\n    Determine if the pineapple will bark at time x.\n\n    Args:\n    t (int): The time the pineapple barks for the first time.\n    s (int): The pineapple barking interval.\n    x (int): The time Barney wants to eat the pineapple.\n\n    Returns:\n    bool: True if the pineapple will bark at time x, False otherwise.\n    \"\"\"\n    # Calculate the number of intervals that have passed\n    intervals = (x - t) // s\n    \n    # Check if the pineapple will bark at the start of the interval\n    if x == t + intervals * s:\n        return True\n    \n    # Check if the pineapple will bark at the end of the interval\n    if x == t + intervals * s + 1:\n        return True\n    \n    # If none of the above conditions are met, the pineapple will not bark\n    return False\n\n\n# Read input from the user\nt, s, x = map(int, input().split())\n\n# Determine if the pineapple will bark\nif will_pineapple_bark(t, s, x):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef find_nested_segments(n, segments):\n    sorted_segments = sorted(enumerate(segments), key=lambda x: (x[1][0], -x[1][1]))\n    max_right = -1\n    max_right_index = -1\n    for i, (left, right) in sorted_segments:\n        if right <= max_right:\n            return f\"{i + 1} {max_right_index + 1}\"\n        if right > max_right:\n            max_right = right\n            max_right_index = i\n    return \"-1 -1\"\n\nn = int(sys.stdin.readline())\nsegments = []\nfor _ in range(n):\n    left, right = map(int, sys.stdin.readline().split())\n    segments.append((left, right))\n\nprint(find_nested_segments(n, segments))"}
{"solution": "def decode_genome(n, s):\n    counts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\n    unknowns = 0\n\n    for char in s:\n        if char in counts:\n            counts[char] += 1\n        elif char == '?':\n            unknowns += 1\n\n    target_count = (n + 3) // 4\n\n    for char in counts:\n        if counts[char] > target_count:\n            return \"===\"\n\n    for char in counts:\n        counts[char] = target_count - counts[char]\n\n    result = []\n    for char in s:\n        if char in counts:\n            result.append(char)\n        elif char == '?':\n            for c in counts:\n                if counts[c] > 0:\n                    result.append(c)\n                    counts[c] -= 1\n                    break\n\n    if any(count > 0 for count in counts.values()):\n        return \"===\"\n\n    return ''.join(result)\n\n\nn = int(input())\ns = input()\nprint(decode_genome(n, s))"}
{"solution": "def check_win(board, row, col, char):\n    # Check horizontal\n    if board[row].count(char) == 3 and board[row][col] == '.':\n        return True\n\n    # Check vertical\n    count = 0\n    for i in range(4):\n        if board[i][col] == char:\n            count += 1\n    if count == 3 and board[row][col] == '.':\n        return True\n\n    # Check main diagonal\n    if row == col:\n        count = 0\n        for i in range(4):\n            if board[i][i] == char:\n                count += 1\n        if count == 3 and board[row][col] == '.':\n            return True\n\n    # Check anti-diagonal\n    if row + col == 3:\n        count = 0\n        for i in range(4):\n            if board[i][3-i] == char:\n                count += 1\n        if count == 3 and board[row][col] == '.':\n            return True\n\n    return False\n\n\ndef check_win_by_placing(board, char):\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                if check_win(board, i, j, char):\n                    return True\n    return False\n\n\ndef main():\n    board = [input() for _ in range(4)]\n    if check_win_by_placing(board, 'x'):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_divide_array(n, a):\n    total_sum = sum(a)\n    if total_sum % 2!= 0:\n        return False\n\n    target_sum = total_sum // 2\n    prefix_sum = 0\n    for i in range(n):\n        prefix_sum += a[i]\n        if prefix_sum == target_sum:\n            return True\n        if prefix_sum > target_sum:\n            break\n\n    for i in range(n):\n        new_sum = total_sum - a[i]\n        if new_sum % 2!= 0:\n            continue\n        new_target_sum = new_sum // 2\n        new_prefix_sum = 0\n        for j in range(n):\n            if j == i:\n                continue\n            new_prefix_sum += a[j]\n            if new_prefix_sum == new_target_sum:\n                return True\n            if new_prefix_sum > new_target_sum:\n                break\n\n    return False\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nif can_divide_array(n, a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def can_recover(n, k, a, b):\n    zeros = [i for i, x in enumerate(a) if x == 0]\n    b.sort(reverse=True)\n    a_copy = a[:]\n\n    for i, zero in enumerate(zeros):\n        a_copy[zero] = b[i]\n\n    for i in range(1, n):\n        if a_copy[i] < a_copy[i - 1]:\n            return \"Yes\"\n\n    return \"No\"\n\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(can_recover(n, k, a, b))"}
{"solution": "def can_distribute_grapes(x, y, z, a, b, c):\n    # Check if Andrew can eat enough green grapes\n    if x > a:\n        return False\n\n    # Calculate the remaining green grapes after Andrew eats\n    remaining_green = a - x\n\n    # Check if Dmitry can eat enough grapes\n    if y > remaining_green + b:\n        return False\n\n    # Calculate the remaining grapes after Andrew and Dmitry eat\n    remaining_grapes = remaining_green + b - (y - remaining_green)\n    remaining_grapes += c\n\n    # Check if Michal can eat enough grapes\n    if z > remaining_grapes:\n        return False\n\n    return True\n\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\nif can_distribute_grapes(x, y, z, a, b, c):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def is_accident_possible():\n    # Read the traffic light configurations for each part\n    parts = [list(map(int, input().split())) for _ in range(4)]\n\n    # Check if an accident is possible\n    for i in range(4):\n        # Check if the pedestrian light is green\n        if parts[i][3] == 1:\n            # Check if any of the car lights are green\n            if parts[i][0] == 1 or parts[i][1] == 1 or parts[i][2] == 1:\n                return \"YES\"\n            # Check the adjacent parts\n            if i == 0:\n                if parts[3][2] == 1 or parts[1][0] == 1:\n                    return \"YES\"\n            elif i == 1:\n                if parts[0][2] == 1 or parts[2][0] == 1:\n                    return \"YES\"\n            elif i == 2:\n                if parts[1][2] == 1 or parts[3][0] == 1:\n                    return \"YES\"\n            elif i == 3:\n                if parts[2][2] == 1 or parts[0][0] == 1:\n                    return \"YES\"\n\n    # If no accident is possible, return \"NO\"\n    return \"NO\"\n\nprint(is_accident_possible())"}
{"solution": "def get_coordinates(digit):\n    keypad = {\n        '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2),\n        '0': (3, 1)\n    }\n    return keypad[digit]\n\ndef get_vectors(number):\n    vectors = []\n    for i in range(len(number) - 1):\n        x1, y1 = get_coordinates(number[i])\n        x2, y2 = get_coordinates(number[i + 1])\n        vectors.append((x2 - x1, y2 - y1))\n    return vectors\n\ndef is_unique_finger_movement(n, number):\n    original_vectors = get_vectors(number)\n    for i in range(10**(n-1), 10**n):\n        candidate = str(i).zfill(n)\n        if candidate!= number:\n            if get_vectors(candidate) == original_vectors:\n                return \"NO\"\n    return \"YES\"\n\nn = int(input())\nnumber = input().strip()\nprint(is_unique_finger_movement(n, number))"}
{"solution": "import sys\n\ndef main():\n    n, f = map(int, sys.stdin.readline().split())\n    days = []\n    for _ in range(n):\n        k, l = map(int, sys.stdin.readline().split())\n        days.append((k, l))\n\n    days.sort(key=lambda x: min(x[0], x[1]) - min(x[0]*2, x[1]), reverse=True)\n\n    sold = 0\n    for i, (k, l) in enumerate(days):\n        if i < f:\n            sold += min(k*2, l)\n        else:\n            sold += min(k, l)\n\n    print(sold)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef calculate_messiness(n, k):\n    \"\"\"\n    Calculate the maximum messiness that can be achieved by performing no more than k swaps.\n\n    Args:\n    n (int): The number of cows.\n    k (int): The number of swaps.\n\n    Returns:\n    int: The maximum messiness.\n    \"\"\"\n    # Calculate the maximum number of swaps needed to reverse the array\n    max_swaps = n // 2\n    \n    # If k is greater than or equal to the maximum number of swaps, we can reverse the array\n    if k >= max_swaps:\n        # The maximum messiness is the sum of the first n-1 integers\n        return (n - 1) * n // 2\n    else:\n        # Otherwise, we can only make k swaps, so we calculate the messiness for k swaps\n        return k * (2 * n - 2 * k - 1)\n\ndef main():\n    # Read the input\n    n, k = map(int, sys.stdin.readline().split())\n    \n    # Calculate and print the maximum messiness\n    print(calculate_messiness(n, k))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef min_coins(N, M, K, L):\n    if M > N:\n        return -1\n\n    max_new_coins = N - K\n    if max_new_coins < L:\n        return -1\n\n    min_coins_per_friend = math.ceil(L / M)\n    if min_coins_per_friend > N // M:\n        return -1\n\n    return min_coins_per_friend\n\nN, M, K, L = map(int, input().split())\nprint(min_coins(N, M, K, L))"}
{"solution": "n, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\nmin_row, max_row = n, -1\nmin_col, max_col = m, -1\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 'B':\n            min_row = min(min_row, i)\n            max_row = max(max_row, i)\n            min_col = min(min_col, j)\n            max_col = max(max_col, j)\n\nif min_row == n:\n    print(1)\nelse:\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    if side_length > n or side_length > m:\n        print(-1)\n    else:\n        min_paint = float('inf')\n        for i in range(n - side_length + 1):\n            for j in range(m - side_length + 1):\n                paint_count = 0\n                for x in range(i, i + side_length):\n                    for y in range(j, j + side_length):\n                        if grid[x][y] == 'W':\n                            paint_count += 1\n                min_paint = min(min_paint, paint_count)\n        print(min_paint)"}
{"solution": "def can_transform(x, y):\n    \"\"\"\n    Checks if sequence x can be transformed into sequence y by moving or taking stones.\n    \n    Args:\n    x (list): Initial sequence of stone counts.\n    y (list): Target sequence of stone counts.\n    \n    Returns:\n    bool: True if x can be transformed into y, False otherwise.\n    \"\"\"\n    # Calculate the total difference in stone counts between the two sequences\n    total_diff = sum(x) - sum(y)\n    \n    # If the total difference is not zero, it's impossible to transform x into y\n    if total_diff!= 0:\n        return False\n    \n    # Initialize a variable to track the cumulative difference\n    cum_diff = 0\n    \n    # Iterate over the sequences\n    for i in range(len(x)):\n        # Update the cumulative difference\n        cum_diff += x[i] - y[i]\n        \n        # If the cumulative difference is ever negative, it's impossible to transform x into y\n        if cum_diff < 0:\n            return False\n    \n    # If we've made it this far, it's possible to transform x into y\n    return True\n\n\n# Read the number of piles\nn = int(input())\n\n# Read the initial and target sequences\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Check if the sequences can be transformed\nif can_transform(x, y):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def min_angle_diff(n, angles):\n    total_angle = sum(angles)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + angles[i]\n    \n    min_diff = float('inf')\n    for i in range(n):\n        left_angle = prefix_sum[i]\n        right_angle = total_angle - left_angle\n        diff = abs(left_angle - right_angle)\n        min_diff = min(min_diff, diff)\n    \n    return min_diff\n\nn = int(input())\nangles = list(map(int, input().split()))\nprint(min_angle_diff(n, angles))"}
{"solution": "def mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_power(a, n, m):\n    result = 1\n    while n > 0:\n        if n % 2 == 1:\n            result = (result * a) % m\n        a = (a * a) % m\n        n //= 2\n    return result\n\ndef mod_factorial(n, m):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % m\n    return result\n\ndef mod_combination(n, k, m):\n    if k > n:\n        return 0\n    numerator = mod_factorial(n, m)\n    denominator = (mod_factorial(k, m) * mod_factorial(n - k, m)) % m\n    return (numerator * mod_inverse(denominator, m)) % m\n\ndef solve(n, m):\n    mod = 10**9 + 7\n    result = 0\n    for i in range(n + 1):\n        combination = mod_combination(n, i, mod)\n        power = mod_power(m - i + 1, n - i, mod)\n        result = (result + combination * power) % mod\n    return result\n\nn, m = map(int, input().split())\nprint(solve(n, m))"}
{"solution": "import math\n\ndef pythagorean_triple(n):\n    for m in range(1, n):\n        k = math.sqrt(m**2 + n**2)\n        if k == int(k):\n            return m, int(k)\n    for k in range(n, n**2):\n        m = math.sqrt(k**2 - n**2)\n        if m == int(m):\n            return int(m), k\n    return -1, -1\n\nn = int(input())\nm, k = pythagorean_triple(n)\nif m == -1:\n    print(-1)\nelse:\n    print(m, k)"}
{"solution": "def check_remainders(n, k):\n    \"\"\"\n    Checks whether all remainders of n divided by integers from 1 to k are distinct.\n\n    Args:\n        n (int): The number to check remainders for.\n        k (int): The upper limit for the divisors.\n\n    Returns:\n        bool: True if all remainders are distinct, False otherwise.\n    \"\"\"\n    remainders = set()\n    for i in range(1, k + 1):\n        remainder = n % i\n        if remainder in remainders:\n            return False\n        remainders.add(remainder)\n    return True\n\n\ndef main():\n    n, k = map(int, input().split())\n    if check_remainders(n, k):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef compare_integers(a, b):\n    a = a.lstrip('0') or '0'\n    b = b.lstrip('0') or '0'\n\n    if len(a) > len(b):\n        return '>'\n    elif len(a) < len(b):\n        return '<'\n    else:\n        return '>' if a > b else '<' if a < b else '='\n\na = sys.stdin.readline().strip()\nb = sys.stdin.readline().strip()\n\nprint(compare_integers(a, b))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve():\n    n, p = map(int, input().split())\n    c = list(map(int, input().split()))\n\n    dp = [[[[0, 0] for _ in range(2)] for _ in range(2)] for _ in range(n + 1)]\n    dp[0][0][0][0] = 1\n\n    for i in range(n):\n        for j in range(2):\n            for k in range(2):\n                for l in range(2):\n                    if dp[i][j][k][l] == 0:\n                        continue\n                    if c[i] == -1:\n                        for m in range(2):\n                            for x in range(i + 1):\n                                dp[i + 1][j | (m ^ k)][k][l ^ (x & 1)] = (dp[i + 1][j | (m ^ k)][k][l ^ (x & 1)] + dp[i][j][k][l] * pow(2, x, MOD) * pow(i, i - x, MOD)) % MOD\n                    elif c[i] == 0:\n                        for x in range(i + 1):\n                            dp[i + 1][j | (k ^ 0)][k][l ^ (x & 1)] = (dp[i + 1][j | (k ^ 0)][k][l ^ (x & 1)] + dp[i][j][k][l] * pow(2, x, MOD) * pow(i, i - x, MOD)) % MOD\n                    else:\n                        for x in range(i + 1):\n                            dp[i + 1][j | (k ^ 1)][k][l ^ (x & 1)] = (dp[i + 1][j | (k ^ 1)][k][l ^ (x & 1)] + dp[i][j][k][l] * pow(2, x, MOD) * pow(i, i - x, MOD)) % MOD\n\n    print((dp[n][1][0][p] + dp[n][1][1][p]) % MOD)\n\nsolve()"}
{"solution": "def min_rubles(n, a, b, c):\n    remainder = n % 4\n    if remainder == 0:\n        return 0\n    elif remainder == 1:\n        return min(a, b + c, 4 * c)\n    elif remainder == 2:\n        return min(2 * a, b, 3 * c)\n    else:\n        return min(3 * a, 2 * b, 4 * c)\n\nn, a, b, c = map(int, input().split())\nprint(min_rubles(n, a, b, c))"}
{"solution": "from collections import defaultdict\n\ndef dfs(graph, visited, stack, vertex):\n    visited[vertex] = True\n    stack[vertex] = True\n\n    for neighbor in graph[vertex]:\n        if not visited[neighbor]:\n            if dfs(graph, visited, stack, neighbor):\n                return True\n        elif stack[neighbor]:\n            return True\n\n    stack[vertex] = False\n    return False\n\ndef is_acyclic(graph, n):\n    visited = [False] * n\n    stack = [False] * n\n\n    for vertex in range(n):\n        if not visited[vertex]:\n            if dfs(graph, visited, stack, vertex):\n                return False\n\n    return True\n\ndef remove_edge(graph, u, v):\n    graph[u].remove(v)\n\ndef add_edge(graph, u, v):\n    graph[u].append(v)\n\ndef can_make_acyclic(n, m, edges):\n    graph = defaultdict(list)\n\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n\n    if is_acyclic(graph, n):\n        return True\n\n    for u, v in edges:\n        remove_edge(graph, u - 1, v - 1)\n        if is_acyclic(graph, n):\n            return True\n        add_edge(graph, u - 1, v - 1)\n\n    return False\n\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\nif can_make_acyclic(n, m, edges):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, m = read_ints()\n    antennas = []\n    for _ in range(n):\n        x, s = read_ints()\n        antennas.append((x, s))\n\n    antennas.sort()\n\n    dp = [float('inf')] * (m + 1)\n    dp[0] = 0\n\n    for x, s in antennas:\n        for i in range(m, -1, -1):\n            if i - s <= 0:\n                dp[i] = min(dp[i], max(0, 1 - s))\n            else:\n                dp[i] = min(dp[i], dp[i - s - 1] + max(0, i - x + s))\n\n            if i + s >= m:\n                continue\n            dp[i + s + 1] = min(dp[i + s + 1], dp[i] + max(0, x + s - i))\n\n    print(dp[m])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_weight(W, weights):\n    max_weight = 0\n    for i in range(8, 0, -1):\n        max_weight += min(W // i, weights[8 - i]) * i\n        W -= min(W // i, weights[8 - i]) * i\n    return max_weight\n\nW = int(input())\nweights = list(map(int, input().split()))\nprint(max_weight(W, weights))"}
{"solution": "def calculate_min_cost(n, L, costs):\n    \"\"\"\n    Calculate the minimum cost to buy at least L liters of lemonade.\n\n    Args:\n    n (int): The number of types of bottles in the store.\n    L (int): The required amount of lemonade in liters.\n    costs (list): A list of costs of bottles of different types.\n\n    Returns:\n    int: The smallest number of roubles to pay in order to buy at least L liters of lemonade.\n    \"\"\"\n    # Initialize a list to store the minimum cost for each liter\n    min_costs = [float('inf')] * (L + 1)\n    min_costs[0] = 0\n\n    # Iterate over each type of bottle\n    for i in range(n):\n        # Calculate the volume of the current bottle type\n        volume = 2 ** (i + 1) - 1\n\n        # Iterate over each liter from the current volume to L\n        for j in range(volume, L + 1):\n            # Update the minimum cost for the current liter\n            min_costs[j] = min(min_costs[j], min_costs[j - volume] + costs[i])\n\n    # Return the minimum cost for L liters\n    return min_costs[L]\n\n\n# Read the input\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Calculate and print the minimum cost\nprint(calculate_min_cost(n, L, costs))"}
{"solution": "def max_mex(n, a):\n    a.sort()\n    mex = 1\n    for num in a:\n        if num >= mex:\n            mex += 1\n    return mex\n\nn = int(input())\na = list(map(int, input().split()))\n\nresult = max_mex(n, a)\nprint(result)"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(int(digit) for digit in digits)\n    \n    # Try every possible segment sum from 1 to total_sum\n    for segment_sum in range(1, total_sum + 1):\n        if total_sum % segment_sum == 0:\n            current_sum = 0\n            valid_partition = True\n            for digit in digits:\n                current_sum += int(digit)\n                if current_sum > segment_sum:\n                    valid_partition = False\n                    break\n                elif current_sum == segment_sum:\n                    current_sum = 0\n            if valid_partition and current_sum == 0 and total_sum // segment_sum > 1:\n                return \"YES\"\n    \n    return \"NO\"\n\nn = int(input())\ndigits = input().strip()\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\"\n\nusername = input().strip()\nprint(determine_gender(username))"}
{"solution": "def calculate_max_difference(n, k, tabs):\n    max_difference = 0\n    for b in range(1, n + 1):\n        closed_tabs = set()\n        i = 0\n        while True:\n            c = b + i * k\n            if 1 <= c <= n:\n                closed_tabs.add(c)\n                i += 1\n            else:\n                break\n        e = 0\n        s = 0\n        for i in range(1, n + 1):\n            if i not in closed_tabs:\n                if tabs[i - 1] == 1:\n                    e += 1\n                else:\n                    s += 1\n        difference = abs(e - s)\n        max_difference = max(max_difference, difference)\n    return max_difference\n\n\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\nprint(calculate_max_difference(n, k, tabs))"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n, c0, c1 = map(int, read_input().split())\n\n    if c0 > c1:\n        c0, c1 = c1, c0\n\n    total_cost = 0\n    length = 0\n\n    while (1 << length) < n:\n        total_cost += (1 << length) * c0\n        length += 1\n\n    remaining = n - (1 << (length - 1))\n    total_cost += remaining * (c0 + c1)\n    total_cost += (1 << (length - 1)) * c0 - remaining * c0\n\n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def will_meet(n, a, x, b, y):\n    if a < x:\n        daniel_stations = list(range(a, x + 1))\n    else:\n        daniel_stations = list(range(a, n + 1)) + list(range(1, x + 1))\n\n    if b > y:\n        vlad_stations = list(range(b, y - 1, -1))\n    else:\n        vlad_stations = list(range(b, 0, -1)) + list(range(n, y - 1, -1))\n\n    common_stations = set(daniel_stations) & set(vlad_stations)\n    return \"YES\" if common_stations else \"NO\"\n\nn, a, x, b, y = map(int, input().split())\nprint(will_meet(n, a, x, b, y))"}
{"solution": "import math\n\ndef is_unlucky(x, y, n):\n    \"\"\"Check if a number is unlucky.\"\"\"\n    a = 0\n    while x ** a <= n:\n        b = 0\n        while x ** a + y ** b <= n:\n            if x ** a + y ** b == n:\n                return True\n            b += 1\n        a += 1\n    return False\n\ndef max_golden_age(x, y, left, right):\n    \"\"\"Find the maximum length of The Golden Age.\"\"\"\n    max_length = 0\n    current_length = 0\n    for i in range(left, right + 1):\n        if is_unlucky(x, y, i):\n            max_length = max(max_length, current_length)\n            current_length = 0\n        else:\n            current_length += 1\n    return max(max_length, current_length)\n\nx, y, left, right = map(int, input().split())\nprint(max_golden_age(x, y, left, right))"}
{"solution": "def min_tax(n):\n    if n % 2 == 0:\n        return 2\n    elif n % 3 == 0:\n        return 3\n    elif n % 3 == 1:\n        return 2\n    else:\n        return 3\n\nn = int(input())\nprint(min_tax(n))"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    n = len(word)\n    result = []\n    i = 0\n    \n    while i < n:\n        result.append(word[i])\n        if word[i] not in vowels:\n            start = i\n            while i < n and word[i] not in vowels:\n                i += 1\n            if i - start >= 3:\n                block = word[start:i]\n                if len(set(block)) > 1:\n                    result.append(' ')\n        i += 1\n    \n    return ''.join(result)\n\nword = input()\nprint(fix_typos(word))"}
{"solution": "import sys\n\nn, m, k = map(int, sys.stdin.readline().split())\nx, s = map(int, sys.stdin.readline().split())\n\na = list(map(int, sys.stdin.readline().split()))\nb = list(map(int, sys.stdin.readline().split()))\n\nc = list(map(int, sys.stdin.readline().split()))\nd = list(map(int, sys.stdin.readline().split()))\n\nmin_time = float('inf')\n\nfor i in range(m):\n    if b[i] <= s:\n        time = a[i] * max(n - 1, 0)\n        min_time = min(min_time, time)\n\nfor i in range(k):\n    if d[i] <= s:\n        time = x * max(n - c[i], 0)\n        min_time = min(min_time, time)\n\nfor i in range(m):\n    for j in range(k):\n        if b[i] + d[j] <= s:\n            time = a[i] * max(n - c[j], 0)\n            min_time = min(min_time, time)\n\nprint(min_time)"}
{"solution": "def solve():\n    n, k, M = map(int, input().split())\n    t = list(map(int, input().split()))\n\n    dp = [0] * (k + 1)\n    for i in range(1, k + 1):\n        dp[i] = dp[i - 1] + t[i - 1]\n\n    ans = 0\n    for i in range(k + 1):\n        if dp[i] <= M:\n            ans = max(ans, i * n + (M - dp[i]) // dp[i] + 1)\n\n    for i in range(k):\n        if dp[i] <= M:\n            rest = M - dp[i]\n            cnt = 0\n            for j in range(i + 1, k + 1):\n                if dp[j] - dp[i] <= rest:\n                    cnt += 1\n                    rest -= dp[j] - dp[i]\n            ans = max(ans, (i + 1) * n + cnt)\n\n    print(ans)\n\nsolve()"}
{"solution": "MOD = 998244353\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef mod_binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    else:\n        numerator = mod_factorial(n)\n        denominator = (mod_factorial(k) * mod_factorial(n - k)) % MOD\n        return (numerator * mod_inverse(denominator, MOD)) % MOD\n\ndef mod_catalan(n):\n    if n % 2 == 1:\n        return 0\n    else:\n        return (mod_binomial_coefficient(n, n // 2) * mod_inverse(n // 2 + 1, MOD)) % MOD\n\ndef main():\n    n = int(input())\n    if n % 2 == 1:\n        print(0)\n    else:\n        print((mod_catalan(n) * mod_factorial(n // 2) * mod_factorial(n // 2)) % MOD)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def lara_croft_path(n, m, k):\n    # Calculate the total number of cells\n    total_cells = n * m\n\n    # Calculate the number of full rows\n    full_rows = (total_cells - 2) // (n - 1) + 1\n\n    # Calculate the number of cells in the last row\n    last_row_cells = total_cells - (full_rows - 1) * (n - 1) - 1\n\n    # Calculate the number of rows Lara has moved\n    rows_moved = k // (n - 1) + 1\n\n    # Calculate the number of cells Lara has moved in the current row\n    cells_moved_in_row = k % (n - 1) + 1\n\n    # Calculate the current row\n    current_row = rows_moved % 2 == 1 and n - cells_moved_in_row + 1 or cells_moved_in_row\n\n    # Calculate the current column\n    current_column = rows_moved <= full_rows and (rows_moved - 1) % 2 == 0 and rows_moved or (rows_moved - 1) % 2 == 1 and m - rows_moved + 1 or last_row_cells - (rows_moved - full_rows) + 1\n\n    return current_row, current_column\n\n\nn, m, k = map(int, input().split())\ncurrent_row, current_column = lara_croft_path(n, m, k)\nprint(current_row, current_column)"}
{"solution": "import math\n\ndef prime_factors(n):\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef solve():\n    x = int(input())\n    factors = prime_factors(x)\n    a = 1\n    b = x\n    for factor in set(factors):\n        if factors.count(factor) > 1:\n            a *= factor\n            b //= factor\n    print(a, b)\n\nsolve()"}
{"solution": "def max_fruits_for_compote(a, b, c):\n    # Calculate the maximum number of complete sets for each fruit type\n    max_sets_lemons = a // 1\n    max_sets_apples = b // 2\n    max_sets_pears = c // 4\n    \n    # Find the limiting factor (minimum number of complete sets)\n    max_complete_sets = min(max_sets_lemons, max_sets_apples, max_sets_pears)\n    \n    # Calculate the total number of fruits used in the compote\n    total_fruits = max_complete_sets * (1 + 2 + 4)\n    \n    return total_fruits\n\na = int(input())\nb = int(input())\nc = int(input())\n\nprint(max_fruits_for_compote(a, b, c))"}
{"solution": "n = int(input())\nratings = list(map(int, input().split()))\nratings.sort()\nfor i in range(n):\n    if ratings[i] >= ratings[i + n]:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef is_coprime(a, b):\n    return gcd(a, b) == 1\n\ndef make_coprime_array(arr):\n    result = [arr[0]]\n    for i in range(1, len(arr)):\n        if is_coprime(result[-1], arr[i]):\n            result.append(arr[i])\n        else:\n            for j in range(2, arr[i]):\n                if is_coprime(result[-1], j) and is_coprime(j, arr[i]):\n                    result.append(j)\n                    break\n            result.append(arr[i])\n    return result\n\nn = int(input())\narr = list(map(int, input().split()))\n\nnew_arr = make_coprime_array(arr)\nprint(len(new_arr) - n)\nprint(*new_arr)"}
{"solution": "import math\nfrom functools import reduce\nfrom math import gcd\n\ndef compute_gcd_of_list(lst):\n    return reduce(gcd, lst)\n\ndef max_divisor_after_operations(N, K, A):\n    if N == 1:\n        return A[0]\n    \n    # Compute the GCD of the differences between all pairs\n    diffs = [abs(A[i] - A[j]) for i in range(N) for j in range(i + 1, N)]\n    initial_gcd = compute_gcd_of_list(diffs)\n    \n    # Check all divisors of the initial GCD\n    max_divisor = 1\n    for d in range(1, initial_gcd + 1):\n        if initial_gcd % d == 0:\n            # Check if we can make all elements divisible by d\n            if all((a % d) <= K for a in A):\n                max_divisor = d\n    \n    return max_divisor\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\nprint(max_divisor_after_operations(N, K, A))"}
{"solution": "import math\n\ndef solve():\n    x = int(input())\n    if (x & (x + 1) == 0):\n        print(0)\n        return\n    n = int(math.log2(x + 1))\n    ans = []\n    for i in range(n, 0, -1):\n        ans.append(i)\n        x ^= (1 << i) - 1\n        x += 1\n    ans.append(0)\n    print(len(ans))\n    print(*ans)\n\nsolve()"}
{"solution": "import math\n\ndef min_hours_to_water_garden(n, k, bucket_lengths):\n    \"\"\"\n    Calculate the minimum number of hours required to water the garden.\n\n    Args:\n    n (int): The number of buckets.\n    k (int): The length of the garden.\n    bucket_lengths (list): A list of integers representing the length of the segment that can be watered by each bucket in one hour.\n\n    Returns:\n    int: The minimum number of hours required to water the garden.\n    \"\"\"\n    min_hours = float('inf')\n    \n    # Iterate through each bucket length\n    for length in bucket_lengths:\n        # Check if the garden length is divisible by the bucket length\n        if k % length == 0:\n            # Calculate the number of hours required to water the garden with the current bucket\n            hours = k // length\n            # Update the minimum number of hours if the current hours is less\n            min_hours = min(min_hours, hours)\n    \n    return min_hours\n\n# Read the input\nn, k = map(int, input().split())\nbucket_lengths = list(map(int, input().split()))\n\n# Calculate and print the minimum number of hours required to water the garden\nprint(min_hours_to_water_garden(n, k, bucket_lengths))"}
{"solution": "from collections import deque\n\ndef can_grasshopper_reach_insect(n, k, cells):\n    \"\"\"\n    Determine whether the grasshopper can reach the insect by jumping over obstacles.\n\n    Args:\n    n (int): The number of cells in the line.\n    k (int): The length of one grasshopper's jump.\n    cells (str): A string of length n consisting of characters '.', '#', 'G', and 'T'.\n\n    Returns:\n    bool: True if the grasshopper can reach the insect, False otherwise.\n    \"\"\"\n    # Find the initial position of the grasshopper and the target insect\n    grasshopper_position = cells.index('G')\n    insect_position = cells.index('T')\n\n    # Create a queue for BFS and add the initial position of the grasshopper\n    queue = deque([grasshopper_position])\n\n    # Create a set to store visited positions\n    visited = set([grasshopper_position])\n\n    while queue:\n        # Dequeue the next position\n        position = queue.popleft()\n\n        # If the grasshopper has reached the insect, return True\n        if position == insect_position:\n            return True\n\n        # Calculate the next possible positions\n        next_positions = [position - k, position + k]\n\n        # Iterate over the next possible positions\n        for next_position in next_positions:\n            # Check if the next position is within the bounds and is not an obstacle\n            if 0 <= next_position < n and cells[next_position]!= '#':\n                # If the next position has not been visited, mark it as visited and add it to the queue\n                if next_position not in visited:\n                    visited.add(next_position)\n                    queue.append(next_position)\n\n    # If the grasshopper cannot reach the insect, return False\n    return False\n\n\n# Read the input\nn, k = map(int, input().split())\ncells = input()\n\n# Determine whether the grasshopper can reach the insect\nif can_grasshopper_reach_insect(n, k, cells):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": ""}
{"solution": "def calculate_missed_meals(breakfasts, dinners, suppers):\n    meals = [breakfasts, dinners, suppers]\n    meals.sort()\n    missed_meals = 0\n\n    if meals[0] == meals[2]:\n        return 0\n    elif meals[0] == meals[1]:\n        missed_meals = meals[2] - meals[0]\n    else:\n        missed_meals = meals[2] - meals[0] + meals[1] - meals[0] - 1\n\n    return missed_meals\n\nbreakfasts, dinners, suppers = map(int, input().split())\nprint(calculate_missed_meals(breakfasts, dinners, suppers))"}
{"solution": "import math\n\ndef find_dimensions(n, path):\n    min_x = 1\n    max_x = 10**9\n    min_y = 1\n    max_y = 10**9\n\n    for i in range(n - 1):\n        a = path[i]\n        b = path[i + 1]\n        if b - a == 1:\n            min_y = max(min_y, 2)\n            max_x = min(max_x, 10**9)\n        elif b - a > 1:\n            min_x = max(min_x, (b - a) // (b - a - 1) + 1)\n            max_y = min(max_y, b - a)\n        elif b - a == -1:\n            min_y = max(min_y, 2)\n            max_x = min(max_x, 10**9)\n        elif b - a < -1:\n            min_x = max(min_x, (a - b) // (a - b - 1) + 1)\n            max_y = min(max_y, a - b)\n\n    for x in range(min_x, max_x + 1):\n        y = math.ceil(max(path) / x)\n        if y >= min_y and y <= max_y:\n            if all(1 <= a <= x * y for a in path):\n                if all(abs(path[i] - path[i + 1]) <= x and abs(path[i] - path[i + 1]) <= y for i in range(n - 1)):\n                    return x, y\n\n    return None\n\nn = int(input())\npath = list(map(int, input().split()))\n\ndimensions = find_dimensions(n, path)\n\nif dimensions is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(*dimensions)"}
{"solution": "def longest_subsequence(a, b):\n    i, j = 0, 0\n    result = []\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            result.append(a[i])\n            i += 1\n            j += 1\n        else:\n            i += 1\n    if not result:\n        return '-'\n    return ''.join(result)\n\na = input()\nb = input()\nprint(longest_subsequence(a, b))"}
{"solution": "def minimal_stones(n, s):\n    current_stones = 0\n    min_stones = 0\n    \n    for char in s:\n        if char == '+':\n            current_stones += 1\n        elif char == '-':\n            current_stones -= 1\n            min_stones = min(min_stones, current_stones)\n    \n    return max(0, current_stones)\n\nn = int(input())\ns = input().strip()\nprint(minimal_stones(n, s))"}
{"solution": "def calculate_kefir(n, a, b, c):\n    \"\"\"\n    Calculate the maximum number of liters of kefir Kolya can drink.\n\n    Args:\n    n (int): The number of rubles Kolya has at the beginning.\n    a (int): The cost of one plastic liter bottle.\n    b (int): The cost of one glass liter bottle.\n    c (int): The money one can get back by returning an empty glass bottle.\n\n    Returns:\n    int: The maximum number of liters of kefir Kolya can drink.\n    \"\"\"\n    # Calculate the number of liters of kefir Kolya can buy with plastic bottles\n    plastic_liters = n // a\n\n    # Calculate the number of liters of kefir Kolya can buy with glass bottles\n    glass_liters = 0\n    if n >= b:\n        # Calculate the number of glass bottles Kolya can buy\n        glass_bottles = n // b\n        # Calculate the remaining money after buying glass bottles\n        remaining_money = n % b\n        # Calculate the number of additional glass bottles Kolya can buy with the remaining money\n        additional_bottles = remaining_money // (b - c)\n        # Update the total number of glass bottles\n        glass_bottles += additional_bottles\n        # Update the remaining money\n        remaining_money %= (b - c)\n        # Calculate the number of liters of kefir Kolya can buy with the remaining money\n        additional_liters = remaining_money // a\n        # Update the total number of liters of kefir\n        glass_liters = glass_bottles + additional_liters\n\n    # Return the maximum number of liters of kefir Kolya can drink\n    return max(plastic_liters, glass_liters)\n\n\n# Read the input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate and print the maximum number of liters of kefir Kolya can drink\nprint(calculate_kefir(n, a, b, c))"}
{"solution": "def play_game(deck1, deck2):\n    seen = set()\n    rounds = 0\n    while deck1 and deck2:\n        rounds += 1\n        card1 = deck1.pop(0)\n        card2 = deck2.pop(0)\n        if (tuple(deck1), tuple(deck2)) in seen:\n            return -1\n        seen.add((tuple(deck1), tuple(deck2)))\n        if card1 > card2:\n            deck1.extend([card2, card1])\n        else:\n            deck2.extend([card1, card2])\n    return rounds, 1 if deck1 else 2\n\nn = int(input())\nk1 = int(input().split()[0])\ndeck1 = list(map(int, input().split()[1:]))\nk2 = int(input().split()[0])\ndeck2 = list(map(int, input().split()[1:]))\n\nresult = play_game(deck1, deck2)\nprint(*result)"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    \n    has_upper = False\n    has_lower = False\n    has_digit = False\n    \n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n    \n    if has_upper and has_lower and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\"\n\npassword = input().strip()\nprint(check_password_complexity(password))"}
{"solution": "def min_exchanges(n, a, b):\n    count_a = [0] * 5\n    count_b = [0] * 5\n\n    for i in range(n):\n        count_a[a[i] - 1] += 1\n        count_b[b[i] - 1] += 1\n\n    exchanges = 0\n    for i in range(5):\n        diff = abs(count_a[i] - count_b[i])\n        if diff % 2!= 0:\n            return -1\n        exchanges += diff // 2\n\n    return exchanges\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(min_exchanges(n, a, b))"}
{"solution": "from collections import deque\n\ndef is_reachable(n, m, horizontal_streets, vertical_streets):\n    # Create a graph with all intersections as nodes\n    graph = {}\n    for i in range(n - 1):\n        for j in range(m - 1):\n            graph[(i, j)] = []\n\n    # Add edges to the graph based on street directions\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if horizontal_streets[i] == '<':\n                if j > 0:\n                    graph[(i, j)].append((i, j - 1))\n                    graph[(i, j - 1)].append((i, j))\n            else:\n                if j < m - 2:\n                    graph[(i, j)].append((i, j + 1))\n                    graph[(i, j + 1)].append((i, j))\n\n            if vertical_streets[j] == '^':\n                if i > 0:\n                    graph[(i, j)].append((i - 1, j))\n                    graph[(i - 1, j)].append((i, j))\n            else:\n                if i < n - 2:\n                    graph[(i, j)].append((i + 1, j))\n                    graph[(i + 1, j)].append((i, j))\n\n    # Perform BFS to check if all nodes are reachable from a given node\n    visited = set()\n    queue = deque([(0, 0)])\n    visited.add((0, 0))\n\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n\n    return len(visited) == (n - 1) * (m - 1)\n\n\nn, m = map(int, input().split())\nhorizontal_streets = input()\nvertical_streets = input()\n\nif is_reachable(n, m, horizontal_streets, vertical_streets):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    if a[0] == 0:\n        print(\"YES\")\n        print(\"0\" if n == 1 else \"0->\" + \"->\".join(map(str, a[1:])))\n        return\n\n    for i in range(1, n):\n        if a[i] == 0:\n            print(\"YES\")\n            print(\"(\" + \"->\".join(map(str, a[:i])) + \")->\" + \"->\".join(map(str, a[i:])))\n            return\n\n    print(\"NO\")\n\nsolve()"}
{"solution": "def calculate_final_values(a, b):\n    while True:\n        if a == 0 or b == 0:\n            break\n        elif a >= 2 * b:\n            a -= 2 * b\n        elif b >= 2 * a:\n            b -= 2 * a\n        else:\n            break\n    return a, b\n\na, b = map(int, input().split())\nfinal_a, final_b = calculate_final_values(a, b)\nprint(final_a, final_b)"}
{"solution": "def count_k_divisible_numbers():\n    k, a, b = map(int, input().split())\n    return (b // k) - ((a - 1) // k)\n\nprint(count_k_divisible_numbers())"}
{"solution": "def find_kth_digit(k):\n    \"\"\"\n    Find the k-th digit in the infinite sequence of concatenated positive integers.\n\n    Args:\n    k (int): The position of the digit to find (1-based index).\n\n    Returns:\n    int: The k-th digit in the sequence.\n    \"\"\"\n    length = 0\n    count = 0\n    num_digits = 1\n\n    # Calculate the number of digits in the sequence up to the k-th digit\n    while length < k:\n        count += 9 * (10 ** (num_digits - 1)) * num_digits\n        length += 9 * (10 ** (num_digits - 1)) * num_digits\n        num_digits += 1\n\n    # Adjust the count and length for the last number of digits\n    count -= length - k\n    length -= length - k\n\n    # Calculate the k-th digit\n    num = 10 ** (num_digits - 1) + (k - length - 1) // num_digits\n    digit_index = (k - length - 1) % num_digits\n\n    return int(str(num)[digit_index])\n\n# Read the input\nk = int(input())\n\n# Print the k-th digit\nprint(find_kth_digit(k))"}
{"solution": "def can_vasya_win(n, s):\n    # Calculate the number of moves each player will make\n    moves_each = (n - 11) // 2\n    \n    # Count the number of '8's in the string\n    count_8s = s.count('8')\n    \n    # If there are no '8's, Vasya cannot win\n    if count_8s == 0:\n        return \"NO\"\n    \n    # If there is only one '8', Vasya can only win if it's in the first position\n    if count_8s == 1:\n        return \"YES\" if s[0] == '8' else \"NO\"\n    \n    # If there are multiple '8's, Vasya can win if there are more '8's than the number of moves Petya can make\n    if count_8s > moves_each + 1:\n        return \"YES\"\n    \n    # If there are multiple '8's but not enough to guarantee a win, Vasya can still win if one of the '8's is in the first position\n    return \"YES\" if s[0] == '8' else \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Determine if Vasya has a winning strategy\nresult = can_vasya_win(n, s)\nprint(result)"}
{"solution": "import sys\n\nMOD = 10**9 + 7\n\ndef modmul(a, b):\n    return (a * b) % MOD\n\ndef modpow(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = modmul(res, a)\n        a = modmul(a, a)\n        b //= 2\n    return res\n\ndef modinv(a):\n    return modpow(a, MOD - 2)\n\ndef moddiv(a, b):\n    return modmul(a, modinv(b))\n\ndef modfact(n):\n    res = 1\n    for i in range(1, n + 1):\n        res = modmul(res, i)\n    return res\n\ndef modchoose(n, k):\n    return moddiv(modfact(n), modmul(modfact(k), modfact(n - k)))\n\ndef solve(n, x, pos):\n    if pos == 0:\n        return modfact(n - 1)\n    elif pos == n - 1:\n        return modmul(modchoose(n - 1, x - 1), modfact(n - x - 1))\n    else:\n        res = 0\n        for i in range(x - 1):\n            res = modmul(res + modmul(modchoose(pos - 1, i), modmul(modchoose(n - pos - 1, x - i - 2), modfact(n - x - 1))), 1)\n        return res\n\nn, x, pos = map(int, sys.stdin.readline().split())\nprint(solve(n, x, pos))"}
{"solution": "def solve(s, k):\n    n = len(s)\n    dp = [[False] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(n):\n        if s[i].isalpha():\n            for j in range(k + 1):\n                if dp[i][j]:\n                    dp[i + 1][j] = True\n                    if j < k:\n                        dp[i + 1][j + 1] = True\n        elif s[i] == '*':\n            for j in range(k + 1):\n                if dp[i - 1][j]:\n                    dp[i + 1][j] = True\n                    if j < k:\n                        for x in range(1, k - j + 1):\n                            dp[i + 1][j + x] = True\n        elif s[i] == '?':\n            for j in range(k + 1):\n                if dp[i - 1][j]:\n                    dp[i + 1][j] = True\n                    if j < k:\n                        dp[i + 1][j + 1] = True\n\n    if not dp[n][k]:\n        return \"Impossible\"\n\n    result = []\n    i, j = n, k\n    while i > 0 and j > 0:\n        if s[i - 1].isalpha():\n            if dp[i - 1][j - 1]:\n                result.append(s[i - 1])\n                i -= 1\n                j -= 1\n            else:\n                i -= 1\n        elif s[i - 1] == '*':\n            if dp[i - 2][j]:\n                i -= 2\n            else:\n                result.append(s[i - 2])\n                i -= 2\n                j -= 1\n        elif s[i - 1] == '?':\n            if dp[i - 2][j]:\n                i -= 2\n            else:\n                result.append(s[i - 2])\n                i -= 2\n                j -= 1\n\n    return ''.join(reversed(result))\n\ns = input()\nk = int(input())\nprint(solve(s, k))"}
{"solution": "def min_turns(angle):\n    angle = (angle + 360) % 360  # Normalize angle to [0, 360)\n    if angle == 0:\n        return 0\n    elif angle < 90:\n        return 1\n    elif angle < 180:\n        return 2\n    elif angle < 270:\n        return 3\n    else:\n        return 1\n\nangle = int(input())\nprint(min_turns(angle))"}
{"solution": "def can_transform_spheres(a, b, c, x, y, z):\n    # Calculate the total number of spheres\n    total_spheres = a + b + c\n    \n    # Calculate the total number of spheres needed\n    total_needed = x + y + z\n    \n    # If the total number of spheres is less than the total number needed, it's impossible\n    if total_spheres < total_needed:\n        return False\n    \n    # Calculate the parity of the total number of spheres and the total number needed\n    parity_total = total_spheres % 2\n    parity_needed = total_needed % 2\n    \n    # If the parities don't match, it's impossible\n    if parity_total!= parity_needed:\n        return False\n    \n    # Calculate the maximum number of spheres that can be transformed\n    max_transformed = (a // 2) + (b // 2) + (c // 2)\n    \n    # Calculate the number of spheres that need to be transformed\n    needed_transformed = max(0, x - a) + max(0, y - b) + max(0, z - c)\n    \n    # If the number of spheres that need to be transformed is more than the maximum that can be transformed, it's impossible\n    if needed_transformed > max_transformed:\n        return False\n    \n    # If all checks pass, it's possible\n    return True\n\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\nif can_transform_spheres(a, b, c, x, y, z):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def solve():\n    n, k, m = map(int, input().split())\n    dp = [0] * k\n    dp[0] = 1\n    for _ in range(n - 1):\n        new_dp = [0] * k\n        for i in range(k):\n            for j in range(10):\n                new_dp[(i * 10 + j) % k] += dp[i]\n                new_dp[(i * 10 + j) % k] %= m\n        dp = new_dp\n    ans = sum(dp) % m\n    print(ans)\n\nsolve()"}
{"solution": "def max_team_size():\n    l, r, a = map(int, input().split())\n    \n    if l > r:\n        l, r = r, l  # Ensure l is always the smaller or equal group\n    \n    # Use ambidexters to balance the difference\n    d = r - l\n    if a >= d:\n        l += d\n        a -= d\n        # Now l == r, distribute remaining ambidexters equally\n        l += a // 2\n        r += a // 2\n    else:\n        l += a\n        # Not enough ambidexters to balance completely, r remains larger\n    \n    # The maximum team size is twice the smaller group\n    return 2 * min(l, r)\n\nprint(max_team_size())"}
{"solution": "import sys\n\ndef min_moves(n, k):\n    if n == 2:\n        return 6\n    if k == 1:\n        return 3 * n - 2\n    if k == n:\n        return 3 * n - 2\n    return 3 * n - 2 + min(k - 1, n - k)\n\nn, k = map(int, sys.stdin.readline().split())\nprint(min_moves(n, k))"}
{"solution": "def min_tower_height(n, m):\n    \"\"\"\n    Calculate the minimum height necessary for the tallest of the students' towers.\n\n    Args:\n    n (int): The number of students using two-block pieces.\n    m (int): The number of students using three-block pieces.\n\n    Returns:\n    int: The minimum possible height of the tallest tower.\n    \"\"\"\n    # Initialize the current height for two-block and three-block towers\n    two_block_height = 0\n    three_block_height = 0\n\n    # Initialize the count of used heights\n    used_heights = set()\n\n    # Generate heights for two-block towers\n    for _ in range(n):\n        two_block_height += 2\n        # If the generated height is already used, increment it by 1\n        while two_block_height in used_heights:\n            two_block_height += 1\n        used_heights.add(two_block_height)\n\n    # Generate heights for three-block towers\n    for _ in range(m):\n        three_block_height += 3\n        # If the generated height is already used, increment it by 1\n        while three_block_height in used_heights:\n            three_block_height += 1\n        used_heights.add(three_block_height)\n\n    # Return the maximum height\n    return max(two_block_height, three_block_height)\n\n\n# Read input\nn, m = map(int, input().split())\n\n# Print the result\nprint(min_tower_height(n, m))"}
{"solution": "from collections import Counter\n\nn = int(input())\nnumbers = [int(input()) for _ in range(n)]\n\ncount = Counter(numbers)\neven_counts = [num for num, freq in count.items() if freq % 2 == 0 and freq!= 0]\n\nif len(even_counts) < 2:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(even_counts[0], even_counts[1])"}
{"solution": "def can_place_soldiers(n, k, groups):\n    total_seats = n * 8\n    total_soldiers = sum(groups)\n\n    if total_soldiers > total_seats:\n        return False\n\n    groups.sort(reverse=True)\n\n    for i in range(k):\n        if groups[i] > 4:\n            if i == 0:\n                if groups[i] > total_seats:\n                    return False\n                total_seats -= groups[i]\n            else:\n                return False\n\n    dp = [[False] * 9 for _ in range(k + 1)]\n    dp[0][0] = True\n\n    for i in range(1, k + 1):\n        for j in range(9):\n            if j >= groups[i - 1]:\n                dp[i][j] = dp[i - 1][j - groups[i - 1]] or dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    for i in range(1, n + 1):\n        for j in range(1, 9):\n            if dp[k][j]:\n                if i * 8 - j >= total_soldiers - j:\n                    return True\n\n    return False\n\n\nn, k = map(int, input().split())\ngroups = list(map(int, input().split()))\n\nif can_place_soldiers(n, k, groups):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_cost(n, sticks):\n    sticks.sort()\n    min_cost = float('inf')\n    best_t = None\n\n    for t in range(1, 101):\n        cost = sum(min(abs(stick - t), abs(stick - (t - 1)), abs(stick - (t + 1))) for stick in sticks)\n        if cost < min_cost:\n            min_cost = cost\n            best_t = t\n\n    return best_t, min_cost\n\n\nn = int(input())\nsticks = list(map(int, input().split()))\n\nt, cost = min_cost(n, sticks)\nprint(t, cost)"}
{"solution": "n, m = map(int, input().split())\n\nmin_x, max_x = m, 0\nmin_y, max_y = n, 0\n\nfor y in range(n):\n    row = input()\n    for x, char in enumerate(row):\n        if char == '*':\n            min_x = min(min_x, x)\n            max_x = max(max_x, x)\n            min_y = min(min_y, y)\n            max_y = max(max_y, y)\n\nside = max(max_x - min_x + 1, max_y - min_y + 1)\nprint(side)"}
{"solution": "import sys\n\nMOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_comb(n, k):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return (mod_fact(n) * mod_inverse(mod_fact(k), MOD) * mod_inverse(mod_fact(n - k), MOD)) % MOD\n\ndef mod_fact(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    num_ones = sum(a)\n    num_zeros = n - num_ones\n\n    if num_ones == 0 or num_zeros == 0:\n        print(1)\n        return\n\n    if k < num_ones * num_zeros:\n        print(0)\n        return\n\n    k = min(k, n * (n - 1) // 2)\n\n    result = 0\n    for i in range(num_ones * num_zeros, k + 1):\n        result = (result + mod_comb(k, i) * mod_comb(n * (n - 1) // 2, i)) % MOD\n\n    result = (result * mod_inverse(mod_comb(n * (n - 1) // 2, k), MOD)) % MOD\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_seconds(x, y):\n    \"\"\"\n    Calculate the minimum number of seconds required to transform an equilateral triangle of side length x into one of side length y.\n\n    Args:\n    x (int): The initial side length of the equilateral triangle.\n    y (int): The target side length of the equilateral triangle.\n\n    Returns:\n    int: The minimum number of seconds required for the transformation.\n    \"\"\"\n    # Calculate the difference between the initial and target side lengths\n    diff = x - y\n    \n    # If the difference is even, we can reduce the side length by 1 in each step\n    if diff % 2 == 0:\n        return diff\n    else:\n        # If the difference is odd, we need to reduce the side length by 1 in each step, but we need one extra step to adjust the side length\n        return diff + 1\n\n# Read the input\nx, y = map(int, input().split())\n\n# Calculate and print the minimum number of seconds\nprint(min_seconds(x, y))"}
{"solution": "import math\n\ndef calculate_norm(a, b, c, d):\n    det = a * d - b * c\n    if det == 0:\n        return 0\n\n    min_norm = float('inf')\n    for x in [a, b, c, d]:\n        if x!= 0:\n            norm = abs(det / x)\n            min_norm = min(min_norm, norm)\n\n    return min_norm\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\nnorm = calculate_norm(a, b, c, d)\nprint(norm)"}
{"solution": "def restaurant_denials(n, a, b, groups):\n    \"\"\"\n    Calculate the total number of people the restaurant denies service to.\n\n    Args:\n    n (int): The number of groups coming to the restaurant.\n    a (int): The number of one-seater tables.\n    b (int): The number of two-seater tables.\n    groups (list): A list of integers representing the size of each group.\n\n    Returns:\n    int: The total number of people the restaurant denies service to.\n    \"\"\"\n    one_seater_tables = a\n    two_seater_tables = b\n    occupied_two_seater_tables = 0\n    denials = 0\n\n    for group in groups:\n        if group == 1:\n            if one_seater_tables > 0:\n                one_seater_tables -= 1\n            elif two_seater_tables > 0:\n                two_seater_tables -= 1\n                occupied_two_seater_tables += 1\n            elif occupied_two_seater_tables > 0:\n                occupied_two_seater_tables -= 1\n            else:\n                denials += 1\n        else:\n            if two_seater_tables > 0:\n                two_seater_tables -= 1\n            else:\n                denials += 2\n\n    return denials\n\n\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\nprint(restaurant_denials(n, a, b, groups))"}
{"solution": "def calculate_students(a, b, c, n):\n    \"\"\"\n    Calculate the number of students who didn't pass the exam.\n\n    Args:\n        a (int): The number of students who visited BugDonalds.\n        b (int): The number of students who visited BeaverKing.\n        c (int): The number of students who visited both restaurants.\n        n (int): The total number of students in the group.\n\n    Returns:\n        int: The number of students who didn't pass the exam, or -1 if the data is contradictory.\n    \"\"\"\n\n    # Calculate the total number of students who visited at least one restaurant\n    total_visited = a + b - c\n\n    # Check if the total number of students who visited at least one restaurant exceeds the total number of students\n    if total_visited > n:\n        return -1\n\n    # Check if all students passed the exam\n    if total_visited == n:\n        return -1\n\n    # Calculate the number of students who didn't pass the exam\n    students_not_passed = n - total_visited\n\n    return students_not_passed\n\n\n# Read the input values\na, b, c, n = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_students(a, b, c, n)\nprint(result)"}
{"solution": "def power(base, exponent, mod):\n    \"\"\"Compute base^exponent modulo mod.\"\"\"\n    result = 1\n    base %= mod\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % mod\n        exponent //= 2\n        base = (base * base) % mod\n    return result\n\ndef solve(x, k):\n    \"\"\"Compute the expected number of dresses after k+1 months.\"\"\"\n    mod = 10**9 + 7\n    result = x\n    for _ in range(k):\n        result = (result * 2 + (power(2, _, mod) - 1)) % mod\n    return result\n\nx, k = map(int, input().split())\nprint(solve(x, k))"}
{"solution": "MOD = 998244353\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_multiply(a, b, m):\n    return (a * b) % m\n\ndef mod_add(a, b, m):\n    return (a + b) % m\n\ndef mod_subtract(a, b, m):\n    return (a - b) % m\n\ndef calculate_probability(n, problems):\n    total_probability = 1\n    for i in range(n):\n        total_probability = mod_multiply(total_probability, (problems[i][1] - problems[i][0] + 1), MOD)\n        for j in range(i + 1, n):\n            total_probability = mod_multiply(total_probability, mod_subtract(problems[j][1], problems[i][0], MOD) + 1, MOD)\n            total_probability = mod_multiply(total_probability, mod_inverse(problems[j][1] - problems[j][0] + 1, MOD), MOD)\n            problems[j][0] = mod_subtract(problems[j][0], problems[i][0], MOD)\n            problems[j][1] = mod_subtract(problems[j][1], problems[i][0], MOD)\n    return total_probability\n\nn = int(input())\nproblems = []\nfor _ in range(n):\n    l, r = map(int, input().split())\n    problems.append([l, r])\n\nprobability = calculate_probability(n, problems)\nprobability = mod_multiply(probability, mod_inverse(mod_multiply(1, 1, MOD), MOD), MOD)\nfor i in range(n):\n    probability = mod_multiply(probability, mod_inverse((problems[i][1] - problems[i][0] + 1), MOD), MOD)\n\nprint(probability)"}
{"solution": "def count_ways(n):\n    count = 0\n    for a in range(1, n // 4 + 1):\n        for b in range(a, (n - a) // 3 + 1):\n            c = n - 2 * a - b\n            if c >= b and a + b!= c and 2 * a!= c and 2 * b!= c:\n                count += 1\n            if c < b:\n                break\n    return count\n\nn = int(input())\nprint(count_ways(n))"}
{"solution": "import sys\n\ndef fair_nut(n, s, v):\n    v.sort()\n    total = sum(v)\n    if total < s:\n        return -1\n\n    left, right = 0, v[-1]\n    while left < right:\n        mid = (left + right + 1) // 2\n        needed = sum(min(mid, x) for x in v)\n        if needed > s:\n            right = mid - 1\n        else:\n            left = mid\n    return left\n\nn, s = map(int, sys.stdin.readline().split())\nv = list(map(int, sys.stdin.readline().split()))\nprint(fair_nut(n, s, v))"}
{"solution": "def caterpillar_reach_apple(h1, h2, a, b):\n    \"\"\"\n    Calculate the number of days for the caterpillar to reach the apple.\n\n    Args:\n    h1 (int): Initial height of the caterpillar.\n    h2 (int): Height of the apple.\n    a (int): Distance the caterpillar goes up by day.\n    b (int): Distance the caterpillar slips down by night.\n\n    Returns:\n    int: Number of days for the caterpillar to reach the apple. Returns -1 if it's impossible.\n    \"\"\"\n    # Calculate the total distance the caterpillar needs to cover\n    total_distance = h2 - h1\n\n    # Calculate the net progress per day\n    net_progress_per_day = 12 * a - 14 * b\n\n    # If the caterpillar slips down more than it goes up, it's impossible to reach the apple\n    if net_progress_per_day <= 0:\n        return -1\n\n    # Calculate the number of days needed to cover the total distance\n    days_needed = total_distance // net_progress_per_day\n\n    # If there's still some distance left, add one more day\n    if total_distance % net_progress_per_day!= 0:\n        days_needed += 1\n\n    # Calculate the remaining distance after the last full day\n    remaining_distance = total_distance - days_needed * net_progress_per_day\n\n    # If the caterpillar can cover the remaining distance in the last day, return the number of days\n    if remaining_distance <= 12 * a:\n        return days_needed\n    else:\n        return -1\n\n\n# Read input\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate and print the result\nresult = caterpillar_reach_apple(h1, h2, a, b)\nprint(result)"}
{"solution": "def max_joy_units():\n    C, Hr, Hb, Wr, Wb = map(int, input().split())\n\n    max_joy = 0\n\n    for r in range(C // Wr + 1):\n        b = (C - r * Wr) // Wb\n        joy = r * Hr + b * Hb\n        max_joy = max(max_joy, joy)\n\n    print(max_joy)\n\nmax_joy_units()"}
{"solution": "def calculate_min_steps(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the minimal number of steps the robot should make to get the finish position.\n\n    Args:\n        x1 (int): The x-coordinate of the start position.\n        y1 (int): The y-coordinate of the start position.\n        x2 (int): The x-coordinate of the finish position.\n        y2 (int): The y-coordinate of the finish position.\n\n    Returns:\n        int: The minimal number of steps to get the finish position.\n    \"\"\"\n    # Calculate the absolute difference in x and y coordinates\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n\n    # The minimal number of steps is the maximum of dx and dy\n    return max(dx, dy)\n\n\n# Read the start position coordinates\nx1, y1 = map(int, input().split())\n\n# Read the finish position coordinates\nx2, y2 = map(int, input().split())\n\n# Calculate and print the minimal number of steps\nprint(calculate_min_steps(x1, y1, x2, y2))"}
{"solution": "def predict_outcome(n, fractions):\n    \"\"\"\n    Predict the outcome of the vote based on the given fractions and their optimal behavior.\n\n    Args:\n    n (int): The number of employees.\n    fractions (str): A string of 'D's and 'R's representing the fractions of the employees.\n\n    Returns:\n    str: The predicted outcome of the vote, either 'D' or 'R'.\n    \"\"\"\n    # Initialize the count of 'D's and 'R's\n    d_count = fractions.count('D')\n    r_count = n - d_count\n\n    # If the number of 'D's is greater than the number of 'R's, 'D' wins\n    if d_count > r_count:\n        return 'D'\n    # If the number of 'R's is greater than the number of 'D's, 'R' wins\n    elif r_count > d_count:\n        return 'R'\n    # If the number of 'D's and 'R's is equal, the last person to vote wins\n    else:\n        # If the last person is a 'D', 'D' wins\n        if fractions[-1] == 'D':\n            return 'D'\n        # If the last person is an 'R', 'R' wins\n        else:\n            return 'R'\n\n# Read the input\nn = int(input())\nfractions = input()\n\n# Predict and print the outcome\nprint(predict_outcome(n, fractions))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_tv_sets(a, b, x, y):\n    # Calculate the greatest common divisor of x and y\n    gcd_xy = gcd(x, y)\n\n    # Normalize x and y by dividing by their gcd\n    x //= gcd_xy\n    y //= gcd_xy\n\n    # Calculate the maximum possible width and height\n    max_w = a // x\n    max_h = b // y\n\n    # Calculate the minimum possible width and height\n    min_w = math.ceil(1 / x)\n    min_h = math.ceil(1 / y)\n\n    # Calculate the number of possible TV sets\n    count = 0\n    for w in range(min_w, max_w + 1):\n        h = (w * y) // x\n        if h <= max_h and (w * y) % x == 0:\n            count += 1\n\n    return count\n\n# Read input\na, b, x, y = map(int, input().split())\n\n# Print output\nprint(count_tv_sets(a, b, x, y))"}
{"solution": "import math\n\ndef prime_factors(n):\n    \"\"\"Returns a dictionary of prime factors and their powers\"\"\"\n    factors = {}\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors[i] = factors.get(i, 0) + 1\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef count_trailing_zeros(n, b):\n    \"\"\"Returns the number of trailing zeros in the base b representation of n!\"\"\"\n    factors = prime_factors(b)\n    min_count = float('inf')\n    for p in factors:\n        count = 0\n        i = p\n        while i <= n:\n            count += n // i\n            i *= p\n        count //= factors[p]\n        min_count = min(min_count, count)\n    return min_count\n\nn, b = map(int, input().split())\nprint(count_trailing_zeros(n, b))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nm, a, b = map(int, input().split())\ng = gcd(a, b)\nlcm = a * b // g\nif a < b:\n    a, b = b, a\n\nif lcm > m:\n    ans = (m + 1) * (m + 2) // 2\nelse:\n    ans = (lcm + 1) * (lcm + 2) // 2\n    ans += (m - lcm) // a * (lcm // a + 1)\n    ans += (m - lcm) // a * ((m - lcm) // a + 1) // 2 * a\n\nprint(ans)"}
{"solution": "def can_divide_into_odd_subsegments(n, sequence):\n    \"\"\"\n    Decide whether it is possible to divide the sequence into an odd number of non-empty subsegments,\n    each of which has an odd length and begins and ends with odd numbers.\n\n    Args:\n        n (int): The length of the sequence.\n        sequence (list): The elements of the sequence.\n\n    Returns:\n        bool: True if it's possible to fulfill the requirements, False otherwise.\n    \"\"\"\n    # Initialize a variable to track the number of subsegments\n    subsegments = 0\n\n    # Initialize a variable to track the current subsegment length\n    current_length = 0\n\n    # Iterate over the sequence\n    for i, num in enumerate(sequence):\n        # If the number is odd, it could be the start or end of a subsegment\n        if num % 2!= 0:\n            # If this is the start of a new subsegment, increment the subsegment count\n            if current_length == 0:\n                subsegments += 1\n            # Increment the current subsegment length\n            current_length += 1\n        else:\n            # If the number is even, it can only be part of a subsegment if it's not the first or last number\n            if current_length > 0:\n                current_length += 1\n            else:\n                # If the number is even and it's the first or last number, it's not possible to divide the sequence\n                return False\n\n    # If the last subsegment has an odd length and the total number of subsegments is odd, return True\n    return current_length % 2!= 0 and subsegments % 2!= 0\n\n\n# Read the input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Check if it's possible to divide the sequence into an odd number of subsegments\nif can_divide_into_odd_subsegments(n, sequence):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    # Calculate the distance between the two given points\n    distance = abs(x2 - x1)\n\n    # If the distance is not equal in both x and y directions, \n    # it means the points are not on the same line and there is no solution\n    if abs(y2 - y1)!= distance:\n        return -1\n\n    # Calculate the coordinates of the remaining two points\n    x3, y3 = x2, y1\n    x4, y4 = x1, y2\n\n    return x3, y3, x4, y4\n\n\n# Read the input\nx1, y1, x2, y2 = map(int, input().split())\n\n# Find the remaining trees\nresult = find_remaining_trees(x1, y1, x2, y2)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def matrix_multiply(a, b, mod):\n    c = [[0, 0], [0, 0]]\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                c[i][j] += a[i][k] * b[k][j]\n            c[i][j] %= mod\n    return c\n\ndef matrix_power(matrix, n, mod):\n    if n == 1:\n        return matrix\n    if n % 2 == 0:\n        half_pow = matrix_power(matrix, n // 2, mod)\n        return matrix_multiply(half_pow, half_pow, mod)\n    else:\n        half_pow = matrix_power(matrix, n // 2, mod)\n        return matrix_multiply(matrix_multiply(half_pow, half_pow, mod), matrix, mod)\n\ndef calculate_f_n(x, y, n, mod):\n    if n == 1:\n        return x\n    if n == 2:\n        return y\n    matrix = [[1, 1], [1, 0]]\n    result_matrix = matrix_power(matrix, n - 2, mod)\n    return (result_matrix[0][0] * y - result_matrix[0][1] * x) % mod\n\nmod = 10**9 + 7\nx, y = map(int, input().split())\nn = int(input())\nprint(calculate_f_n(x, y, n, mod))"}
{"solution": "def split_array(n, arr):\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n\n    if prefix_sum[n] == 0:\n        return \"NO\"\n\n    result = []\n    start = 0\n    for i in range(1, n + 1):\n        if prefix_sum[i]!= 0 and prefix_sum[i]!= prefix_sum[n]:\n            result.append((start + 1, i))\n            start = i\n\n    result.append((start + 1, n))\n\n    print(\"YES\")\n    print(len(result))\n    for r in result:\n        print(r[0], r[1])\n\n\nn = int(input())\narr = list(map(int, input().split()))\nsplit_array(n, arr)"}
{"solution": "def min_score(n, m, k):\n    mod = 10**9 + 9\n    if m < n // k * (k - 1) + n % k:\n        return m\n    else:\n        return (n // k - 1) * (k - 1) + n % k + (m - (n // k - 1) * (k - 1) - n % k) // k * 2 + (m - (n // k - 1) * (k - 1) - n % k) % k\n\nn, m, k = map(int, input().split())\nprint(min_score(n, m, k) % (10**9 + 9))"}
{"solution": "def is_divisible_by_8(num):\n    return num % 8 == 0\n\ndef find_divisible_by_8(num_str):\n    for i in range(len(num_str)):\n        for j in range(i + 1, len(num_str) + 1):\n            substr = num_str[i:j]\n            if substr[0]!= '0' and is_divisible_by_8(int(substr)):\n                return substr\n    return None\n\ndef main():\n    num_str = input()\n    divisible_num = find_divisible_by_8(num_str)\n    if divisible_num is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(divisible_num)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_floor(n, m, flats):\n    min_flats_per_floor = float('inf')\n    max_flats_per_floor = 0\n\n    for flat, floor in flats:\n        flats_per_floor = (flat - 1) // (floor - 1) + 1\n        min_flats_per_floor = min(min_flats_per_floor, flats_per_floor)\n        max_flats_per_floor = max(max_flats_per_floor, flats_per_floor)\n\n    n_floor_min = (n - 1) // min_flats_per_floor + 1\n    n_floor_max = (n - 1) // max_flats_per_floor + 1\n\n    return n_floor_min if n_floor_min == n_floor_max else -1\n\n\nn, m = map(int, input().split())\nflats = [tuple(map(int, input().split())) for _ in range(m)]\n\nprint(find_floor(n, m, flats))"}
{"solution": "def max_bishwocks():\n    board1 = input()\n    board2 = input()\n    n = len(board1)\n    board = [[board1[i], board2[i]] for i in range(n)]\n\n    bishwock_shapes = [\n        [(0, 0), (0, 1), (1, 0)],  \n        [(0, 0), (0, 1), (1, 1)],  \n        [(0, 1), (1, 0), (1, 1)],  \n        [(0, 0), (1, 0), (1, 1)]   \n    ]\n\n    def can_place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            if nx >= 2 or ny >= n or board[ny][nx] == 'X':\n                return False\n        return True\n\n    def place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            board[ny][nx] = 'X'\n\n    count = 0\n    for y in range(n):\n        for x in range(2):\n            for shape in bishwock_shapes:\n                if can_place_bishwock(x, y, shape):\n                    place_bishwock(x, y, shape)\n                    count += 1\n                    break\n\n    return count\n\nprint(max_bishwocks())"}
{"solution": "def max_pretty_set_length(n, s):\n    max_length = 0\n    current_set = set()\n    \n    for char in s:\n        if char.islower():\n            current_set.add(char)\n        else:\n            max_length = max(max_length, len(current_set))\n            current_set.clear()\n    \n    # Check the last segment\n    max_length = max(max_length, len(current_set))\n    \n    return max_length\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult = max_pretty_set_length(n, s)\n\n# Print the result\nprint(result)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\na.sort(reverse=True)\nb = sum(a)\nprint(b)"}
{"solution": "def min_refuel(a, b, f, k):\n    if 2 * a * k > b:\n        return -1\n\n    if f * 2 > b:\n        return -1\n\n    if (a - f) * 2 > b:\n        return -1\n\n    if (a - f) * 2 <= b and f * 2 <= b:\n        return 0\n\n    if (a - f) * 2 <= b:\n        return k\n\n    if f * 2 <= b:\n        return k\n\n    if (a - f) * 2 > b and f * 2 > b:\n        return -1\n\n    if (2 * a) % b == 0:\n        return (2 * a * k) // b\n\n    return (2 * a * k) // b + 1\n\n\na, b, f, k = map(int, input().split())\nprint(min_refuel(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    result = []\n    i = 0\n    while i < n:\n        if i + q <= n:\n            result.append(s[i:i+q])\n            i += q\n        elif i + p <= n:\n            result.append(s[i:i+p])\n            i += p\n        else:\n            return \"-1\"\n    return str(len(result)) + \"\\n\" + \"\\n\".join(result)\n\nn, p, q = map(int, input().split())\ns = input()\nprint(split_string(n, p, q, s))"}
{"solution": "def solve(n, m, s, d, obstacles):\n    obstacles.sort()\n    pos = 0\n    while pos < m:\n        next_obstacle = next((obstacle for obstacle in obstacles if obstacle > pos), m)\n        if next_obstacle - pos < s:\n            return \"IMPOSSIBLE\"\n        run_length = min(s, next_obstacle - pos)\n        print(f\"RUN {run_length}\")\n        pos += run_length\n        if pos >= m:\n            break\n        jump_length = min(d, next_obstacle + d - pos)\n        print(f\"JUMP {jump_length}\")\n        pos += jump_length\n        obstacles = [obstacle for obstacle in obstacles if obstacle > pos]\n    return \"\"\n\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\nresult = solve(n, m, s, d, obstacles)\nif result == \"\":\n    pass\nelse:\n    print(result)"}
{"solution": "def solve(s, x):\n    if (s - x) % 2!= 0:\n        return 0\n    b = (s - x) // 2\n    a = s - b\n    if a > 0 and b > 0:\n        if a == b:\n            return 2\n        else:\n            return 4\n    else:\n        return 0\n\ns, x = map(int, input().split())\nprint(solve(s, x))"}
{"solution": "def solve(n, k):\n    if n <= 2 * k:\n        return [1]\n    elif n % 2 == 0:\n        return [1, n]\n    else:\n        return [1, n - 2 * k]\n\nn, k = map(int, input().split())\nresult = solve(n, k)\nprint(len(result))\nprint(*result)"}
{"solution": "import math\n\nn = input().strip()\nn_len = len(n)\n\nmax_square_root = int(math.sqrt(2 * 10**9)) + 1\nsquares = [str(i * i) for i in range(1, max_square_root + 1)]\n\ndef is_subsequence(small, large):\n    it = iter(large)\n    return all(char in it for char in small)\n\nmin_deletions = float('inf')\n\nfor square in squares:\n    if is_subsequence(square, n):\n        deletions = n_len - len(square)\n        min_deletions = min(min_deletions, deletions)\n\nprint(min_deletions if min_deletions!= float('inf') else -1)"}
{"solution": "import math\n\nMOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef mod_permutations(n, k):\n    return (mod_factorial(n) * mod_inverse(mod_factorial(n - k), MOD)) % MOD\n\ndef main():\n    n = int(input())\n    if n <= 3:\n        print(mod_permutations(n, n))\n    else:\n        print((mod_permutations(n - 1, n - 1) * (n - 1)) % MOD)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def minimum_jump_ability():\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    s = input()\n    positions = [-1]  # Start position before the first character\n    \n    # Collect positions of all vowels\n    for i, char in enumerate(s):\n        if char in vowels:\n            positions.append(i)\n    \n    positions.append(len(s))  # End position after the last character\n    \n    # Calculate maximum distance between consecutive positions\n    max_distance = 0\n    for i in range(1, len(positions)):\n        max_distance = max(max_distance, positions[i] - positions[i - 1])\n    \n    return max_distance\n\nprint(minimum_jump_ability())"}
{"solution": "def can_distribute_equally(a):\n    total_sum = sum(a)\n    if total_sum % 2!= 0:\n        return False\n\n    target_sum = total_sum // 2\n    a.sort(reverse=True)\n\n    def dfs(index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(a):\n            return False\n\n        return dfs(index + 1, current_sum + a[index]) or dfs(index + 1, current_sum)\n\n    return dfs(0, 0)\n\n\na = list(map(int, input().split()))\nif can_distribute_equally(a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def calculate_pie_sums(n, pie_sizes):\n    alice_sum = 0\n    bob_sum = 0\n    alice_turn = False\n\n    for i in range(n - 1, -1, -1):\n        if alice_turn:\n            if pie_sizes[i] >= pie_sizes[i - 1]:\n                alice_sum += pie_sizes[i]\n                alice_turn = False\n            else:\n                alice_sum += pie_sizes[i - 1]\n                alice_turn = False\n                i -= 1\n        else:\n            if pie_sizes[i] >= pie_sizes[i - 1]:\n                bob_sum += pie_sizes[i - 1]\n                alice_turn = True\n                i -= 1\n            else:\n                bob_sum += pie_sizes[i]\n                alice_turn = True\n\n    return alice_sum, bob_sum\n\n\nn = int(input())\npie_sizes = list(map(int, input().split()))\n\nalice_sum, bob_sum = calculate_pie_sums(n, pie_sizes)\n\nprint(alice_sum, bob_sum)"}
{"solution": "def min_variables(n, a):\n    max_num = max(a)\n    max_bits = max_num.bit_length()\n    dp = [0] * (1 << max_bits)\n    dp[a[0]] = 1\n    for i in range(1, n):\n        new_dp = [0] * (1 << max_bits)\n        for j in range(1 << max_bits):\n            if dp[j]:\n                new_dp[j] = 1\n                for k in range(1 << max_bits):\n                    if dp[k] and j!= k and j + k <= max_num and not new_dp[j + k]:\n                        new_dp[j + k] = 1\n        dp = new_dp\n        if not dp[a[i]]:\n            return -1\n    return bin(dp.count(1)).count('1')\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_variables(n, a))"}
{"solution": "def determine_winner(n, piles):\n    odd_count = sum(1 for pile in piles if pile % 2!= 0)\n    if odd_count % 2 == 0:\n        return \"Alice\" if min(piles) % 2!= 0 else \"Bob\"\n    else:\n        return \"Alice\"\n\nn = int(input())\npiles = list(map(int, input().split()))\n\nprint(determine_winner(n, piles))"}
{"solution": "def can_make_equal(n, a):\n    if n == 1:\n        return \"YES\"\n\n    a.sort()\n    diff = a[-1] - a[0]\n\n    if diff == 0:\n        return \"YES\"\n\n    x = diff // 2\n    if diff % 2!= 0:\n        return \"NO\"\n\n    for i in range(n):\n        if a[i] + x < a[-1] and a[i] - x > a[0]:\n            return \"NO\"\n\n    return \"YES\"\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nprint(can_make_equal(n, a))"}
{"solution": "def longest_repeated_substring(n, s):\n    max_len = 0\n    for length in range(1, n // 2 + 1):\n        for i in range(n - length):\n            substr = s[i:i + length]\n            if s.find(substr, i + length)!= -1:\n                max_len = max(max_len, length)\n    return max_len\n\nn = int(input())\ns = input()\nprint(longest_repeated_substring(n, s))"}
{"solution": "def minimum_time_to_house(n, a):\n    if a % 2 == 1:\n        # a is odd\n        return min((a + 1) // 2, n // 2 + (n - a) // 2)\n    else:\n        # a is even\n        return min(n // 2 - (a - 2) // 2, (a - 1) // 2 + 1)\n\n# Read input\nn, a = map(int, input().split())\n\n# Calculate and print the result\nprint(minimum_time_to_house(n, a))"}
{"solution": "def find_interval(n, m, colors, counts):\n    \"\"\"\n    Find if there is a contiguous interval of Jedi Knights with prescribed color counts.\n\n    Args:\n    n (int): The number of Jedi Knights.\n    m (int): The number of possible colors.\n    colors (list): A list of colors of the lightsabers of the Jedi Knights.\n    counts (list): A list of desired counts of lightsabers of each color.\n\n    Returns:\n    bool: True if an interval with prescribed color counts exists, False otherwise.\n    \"\"\"\n    # Initialize a dictionary to store the current counts of each color\n    current_counts = {i: 0 for i in range(1, m + 1)}\n\n    # Initialize the left and right pointers of the sliding window\n    left = 0\n    right = 0\n\n    # Initialize a flag to indicate if the desired counts are found\n    found = False\n\n    # Expand the window to the right\n    while right < n:\n        # Add the color at the right pointer to the current counts\n        current_counts[colors[right]] += 1\n\n        # Check if the current counts match the desired counts\n        if all(current_counts[i] == counts[i - 1] for i in range(1, m + 1)):\n            found = True\n            break\n\n        # If the window exceeds the desired counts, move the left pointer to the right\n        while any(current_counts[i] > counts[i - 1] for i in range(1, m + 1)):\n            current_counts[colors[left]] -= 1\n            left += 1\n\n        # Move the right pointer to the right\n        right += 1\n\n    return found\n\n\n# Read the input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\ncounts = list(map(int, input().split()))\n\n# Find if an interval with prescribed color counts exists\nif find_interval(n, m, colors, counts):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def determine_winner():\n    n = int(input())\n    mishka_wins = 0\n    chris_wins = 0\n    \n    for _ in range(n):\n        m, c = map(int, input().split())\n        if m > c:\n            mishka_wins += 1\n        elif c > m:\n            chris_wins += 1\n    \n    if mishka_wins > chris_wins:\n        return \"Mishka\"\n    elif chris_wins > mishka_wins:\n        return \"Chris\"\n    else:\n        return \"Friendship is magic!^^\"\n\nprint(determine_winner())"}
{"solution": "def is_valid_field(n, m, field):\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                continue\n\n            if field[i][j] == '.':\n                for direction in directions:\n                    ni, nj = i + direction[0], j + direction[1]\n                    if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':\n                        return False\n            else:\n                count = 0\n                for direction in directions:\n                    ni, nj = i + direction[0], j + direction[1]\n                    if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':\n                        count += 1\n                if count!= int(field[i][j]):\n                    return False\n\n    return True\n\n\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\nif is_valid_field(n, m, field):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def can_vasya_eat_half(n, k):\n    total_candies = n\n    vasya_eaten = 0\n    \n    while total_candies > 0:\n        # Vasya eats k candies\n        vasya_eaten += min(k, total_candies)\n        total_candies -= min(k, total_candies)\n        \n        # Petya eats 10% of the remaining candies\n        petya_eaten = total_candies // 10\n        total_candies -= petya_eaten\n    \n    return vasya_eaten >= (n + 1) // 2\n\ndef find_min_k(n):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\nn = int(input().strip())\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace():\n    s = input()\n    p = s.count('o')\n    l = s.count('-')\n    \n    if p == 0 or p == 1:\n        print(\"YES\")\n    elif l % p == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\ncan_rearrange_necklace()"}
{"solution": "def max_pillows(n, m, k):\n    \"\"\"\n    Calculate the maximum number of pillows Frodo can have.\n\n    Args:\n    n (int): The number of hobbits.\n    m (int): The number of pillows.\n    k (int): The position of Frodo's bed.\n\n    Returns:\n    int: The maximum number of pillows Frodo can have.\n    \"\"\"\n    # Calculate the number of pillows that can be distributed equally\n    equal_pillows = m // n\n    \n    # Calculate the remaining pillows after equal distribution\n    remaining_pillows = m % n\n    \n    # If Frodo is at the edge, he can have all the remaining pillows\n    if k == 1 or k == n:\n        return equal_pillows + remaining_pillows\n    \n    # If Frodo is not at the edge, he can have at most one more pillow than his neighbors\n    else:\n        # Calculate the maximum number of pillows Frodo can have\n        max_frodo_pillows = equal_pillows + min(remaining_pillows, 1)\n        \n        # If Frodo has more pillows than his neighbors, his neighbors will be hurt\n        # So, we need to distribute the remaining pillows to his neighbors\n        if remaining_pillows > 1:\n            # Calculate the number of pillows that need to be distributed to Frodo's neighbors\n            distribute_pillows = remaining_pillows - 1\n            \n            # Calculate the number of pillows that Frodo's neighbors can have\n            neighbor_pillows = equal_pillows + min(distribute_pillows // 2, 1)\n            \n            # If Frodo's neighbors have more pillows than Frodo, Frodo will be hurt\n            # So, we need to reduce the number of pillows Frodo can have\n            if neighbor_pillows > max_frodo_pillows:\n                max_frodo_pillows -= 1\n        \n        return max_frodo_pillows\n\n# Read the input\nn, m, k = map(int, input().split())\n\n# Calculate and print the maximum number of pillows Frodo can have\nprint(max_pillows(n, m, k))"}
{"solution": "import math\n\ndef max_subarray_cost(n, m, k, a):\n    max_cost = 0\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    for length in range(1, m + 1):\n        dp = [float('-inf')] * (n + 1)\n        for i in range(length, n + 1):\n            dp[i] = max(dp[i - 1], prefix_sum[i] - prefix_sum[i - length] - k * math.ceil(length / m))\n            max_cost = max(max_cost, dp[i])\n\n    return max_cost\n\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\nprint(max_subarray_cost(n, m, k, a))"}
{"solution": "import math\n\ndef calculate_distance(point1, point2):\n    \"\"\"Calculate the Euclidean distance between two points.\"\"\"\n    return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\ndef find_longest_polyline(n, m):\n    \"\"\"Find the longest possible polyline on a rectangular grid.\"\"\"\n    # Initialize the maximum length and the corresponding points\n    max_length = 0\n    points = [(0, 0), (0, 0), (0, 0), (0, 0)]\n\n    # Check all possible combinations of points\n    for x1 in range(n+1):\n        for y1 in range(m+1):\n            for x2 in range(n+1):\n                for y2 in range(m+1):\n                    for x3 in range(n+1):\n                        for y3 in range(m+1):\n                            for x4 in range(n+1):\n                                for y4 in range(m+1):\n                                    # Ensure that all points are distinct\n                                    if (x1, y1)!= (x2, y2) and (x1, y1)!= (x3, y3) and (x1, y1)!= (x4, y4) and \\\n                                       (x2, y2)!= (x3, y3) and (x2, y2)!= (x4, y4) and (x3, y3)!= (x4, y4):\n                                        # Calculate the length of the polyline\n                                        length = calculate_distance((x1, y1), (x2, y2)) + \\\n                                                 calculate_distance((x2, y2), (x3, y3)) + \\\n                                                 calculate_distance((x3, y3), (x4, y4))\n                                        # Update the maximum length and the corresponding points\n                                        if length > max_length:\n                                            max_length = length\n                                            points = [(x1, y1), (x2, y2), (x3, y3), (x4, y4)]\n\n    return points\n\ndef main():\n    # Read the input\n    n, m = map(int, input().split())\n\n    # Find the longest polyline\n    points = find_longest_polyline(n, m)\n\n    # Print the points\n    for point in points:\n        print(point[0], point[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_smallest_number(shuffled_string, remembered_substring):\n    # Find the length of the original number\n    for i in range(len(shuffled_string) - 1, -1, -1):\n        if shuffled_string[i].isdigit():\n            original_length = int(shuffled_string[i])\n            break\n\n    # Remove the length from the shuffled string\n    shuffled_string = shuffled_string[:i]\n\n    # Initialize the result\n    result = \"\"\n\n    # Check if the remembered substring is in the shuffled string\n    if remembered_substring in shuffled_string:\n        # Find the index of the remembered substring in the shuffled string\n        index = shuffled_string.find(remembered_substring)\n\n        # Add the remembered substring to the result\n        result += shuffled_string[index:index + len(remembered_substring)]\n\n        # Remove the remembered substring from the shuffled string\n        shuffled_string = shuffled_string[:index] + shuffled_string[index + len(remembered_substring):]\n\n    # Sort the remaining digits in ascending order\n    shuffled_string = sorted(shuffled_string)\n\n    # Add the remaining digits to the result\n    result += \"\".join(shuffled_string)\n\n    # Add leading zeroes if necessary\n    while len(result) < original_length:\n        result = \"0\" + result\n\n    # Remove trailing zeroes if necessary\n    while result.endswith(\"0\") and len(result) > original_length:\n        result = result[:-1]\n\n    return result\n\n\nshuffled_string = input()\nremembered_substring = input()\nprint(find_smallest_number(shuffled_string, remembered_substring))"}
{"solution": "def check_temperature_consistency(n, m, min_temp, max_temp, temperatures):\n    \"\"\"\n    Checks if the given temperatures can be extended to meet the minimum and maximum constraints.\n\n    Args:\n        n (int): The total number of temperatures.\n        m (int): The number of temperatures reported by the assistant.\n        min_temp (int): The minimum temperature.\n        max_temp (int): The maximum temperature.\n        temperatures (list): The list of temperatures reported by the assistant.\n\n    Returns:\n        bool: True if the temperatures can be extended, False otherwise.\n    \"\"\"\n\n    # Check if the minimum temperature is already present in the reported temperatures\n    if min_temp not in temperatures:\n        # If not, we need to add it\n        temperatures.append(min_temp)\n\n    # Check if the maximum temperature is already present in the reported temperatures\n    if max_temp not in temperatures:\n        # If not, we need to add it\n        temperatures.append(max_temp)\n\n    # Check if the number of temperatures exceeds the total number of temperatures\n    if len(temperatures) > n:\n        return False\n\n    # Check if all temperatures are within the minimum and maximum constraints\n    for temp in temperatures:\n        if temp < min_temp or temp > max_temp:\n            return False\n\n    # If all checks pass, the temperatures can be extended\n    return True\n\n\ndef main():\n    # Read the input\n    n, m, min_temp, max_temp = map(int, input().split())\n    temperatures = list(map(int, input().split()))\n\n    # Check the temperature consistency\n    if check_temperature_consistency(n, m, min_temp, max_temp, temperatures):\n        print(\"Correct\")\n    else:\n        print(\"Incorrect\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_trailing_zeroes(m):\n    \"\"\"\n    Find the number of positive integers n, such that the factorial of n ends with exactly m zeroes.\n    \n    Args:\n    m (int): The required number of trailing zeroes in factorial.\n    \n    Returns:\n    list: A list containing the count of integers and the integers themselves.\n    \"\"\"\n    count = 0\n    result = []\n    i = 5\n    \n    # Calculate the number of trailing zeroes for each factorial\n    while m > 0:\n        m -= i // 5\n        i *= 5\n        count += 1\n    \n    # Find the range of integers that have exactly m trailing zeroes\n    start = 5 * count\n    end = start + 4\n    \n    # If m is not zero, it means there are no integers with exactly m trailing zeroes\n    if m!= 0:\n        return [0]\n    \n    # Return the count and the range of integers\n    return [end - start + 1] + list(range(start, end + 1))\n\n\nm = int(input())\nresult = find_trailing_zeroes(m)\nprint(result[0])\nif result[0] > 0:\n    print(*result[1:])"}
{"solution": "import sys\nimport heapq\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_int_list():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n, m, k = read_ints()\n    special_vertices = read_int_list()\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v, w = read_ints()\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    distances = [0] * (n + 1)\n    for start in special_vertices:\n        pq = [(0, start)]\n        visited = [False] * (n + 1)\n        while pq:\n            dist, node = heapq.heappop(pq)\n            if visited[node]:\n                continue\n            visited[node] = True\n            distances[node] = max(distances[node], dist)\n            for neighbor, weight in graph[node]:\n                if not visited[neighbor]:\n                    heapq.heappush(pq, (max(dist, weight), neighbor))\n\n    max_distances = [0] * k\n    for i, vertex in enumerate(special_vertices):\n        max_distances[i] = max(distances[vertex] for vertex in special_vertices if vertex!= special_vertices[i])\n\n    print(*max_distances)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def initial_shell_position(n, x):\n    \"\"\"\n    Calculate the initial position of the ball in the shell game.\n\n    Args:\n    n (int): The number of movements made by the operator.\n    x (int): The index of the shell where the ball was found after n movements.\n\n    Returns:\n    int: The index of the shell where the ball was initially placed.\n    \"\"\"\n    # Calculate the remainder of n divided by 3\n    remainder = n % 3\n    \n    # If the remainder is 0, the ball is in the same position as the initial position\n    if remainder == 0:\n        return x\n    \n    # If the remainder is 1, the ball is in the position that is one to the left of the initial position\n    # If the ball is in the leftmost position, it is in the rightmost position initially\n    elif remainder == 1:\n        if x == 0:\n            return 2\n        else:\n            return (x - 1) % 3\n    \n    # If the remainder is 2, the ball is in the position that is one to the right of the initial position\n    # If the ball is in the rightmost position, it is in the leftmost position initially\n    else:\n        if x == 2:\n            return 0\n        else:\n            return (x + 1) % 3\n\n\n# Read the input\nn = int(input())\nx = int(input())\n\n# Calculate and print the initial position of the ball\nprint(initial_shell_position(n, x))"}
{"solution": "def is_square(rectangles):\n    # Calculate the bounding box\n    min_x = min(rectangle[0] for rectangle in rectangles)\n    max_x = max(rectangle[2] for rectangle in rectangles)\n    min_y = min(rectangle[1] for rectangle in rectangles)\n    max_y = max(rectangle[3] for rectangle in rectangles)\n\n    # Check if the bounding box is a square\n    if max_x - min_x!= max_y - min_y:\n        return False\n\n    # Check if the union of rectangles covers the entire bounding box\n    for x in range(min_x, max_x):\n        for y in range(min_y, max_y):\n            covered = False\n            for rectangle in rectangles:\n                if (rectangle[0] <= x < rectangle[2] and\n                    rectangle[1] <= y < rectangle[3]):\n                    covered = True\n                    break\n            if not covered:\n                return False\n\n    return True\n\n\nn = int(input())\nrectangles = [list(map(int, input().split())) for _ in range(n)]\n\nif is_square(rectangles):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def digit_sum(x):\n    return sum(int(digit) for digit in str(x))\n\ndef count_big_numbers(n, s):\n    count = 0\n    for i in range(1, n + 1):\n        if i - digit_sum(i) >= s:\n            count += 1\n    return count\n\nn, s = map(int, input().split())\nprint(count_big_numbers(n, s))"}
{"solution": "from collections import defaultdict\nfrom math import gcd\n\ndef get_slope(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    if x1 == x2:\n        return float('inf')\n    return (y2 - y1) / (x2 - x1)\n\ndef solve(points):\n    n = len(points)\n    if n <= 2:\n        return True\n\n    slopes = defaultdict(set)\n    for i in range(n):\n        for j in range(i + 1, n):\n            slope = get_slope(points[i], points[j])\n            slopes[slope].add(tuple(points[i]))\n            slopes[slope].add(tuple(points[j]))\n\n    max_points = 0\n    for slope in slopes:\n        max_points = max(max_points, len(slopes[slope]))\n\n    return max_points >= n - 1\n\ndef main():\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    if solve(points):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def mod_inverse(a, m):\n    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        raise ValueError(\"Modular inverse does not exist\")\n    return x % m\n\ndef mod_power(base, exponent, mod):\n    \"\"\"Compute base^exponent modulo mod\"\"\"\n    result = 1\n    base = base % mod\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % mod\n        exponent = exponent >> 1\n        base = (base * base) % mod\n    return result\n\ndef mod_combinations(n, k, mod):\n    \"\"\"Compute the number of combinations of n items taken k at a time modulo mod\"\"\"\n    if k > n:\n        return 0\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator = (numerator * (n - i)) % mod\n        denominator = (denominator * (i + 1)) % mod\n    return (numerator * mod_inverse(denominator, mod)) % mod\n\ndef solve(a, b, k, t, mod):\n    \"\"\"Compute the number of possible games where Memory ends with a higher score than Lexa\"\"\"\n    result = 0\n    for diff in range(1, 2 * k * t + 1):\n        combinations = mod_combinations(2 * k * t, diff + b - a, mod)\n        result = (result + combinations * mod_power(2 * k + 1, t - diff, mod)) % mod\n    return result\n\nmod = 10**9 + 7\na, b, k, t = map(int, input().split())\nprint(solve(a, b, k, t, mod))"}
{"solution": "def can_measure(distances, target):\n    for i in range(len(distances)):\n        for j in range(i, len(distances)):\n            if distances[j] - distances[i] == target:\n                return True\n    return False\n\ndef find_additional_marks(n, l, x, y, distances):\n    if can_measure(distances, x) and can_measure(distances, y):\n        return 0, []\n    \n    if can_measure(distances, x):\n        return 1, [y]\n    \n    if can_measure(distances, y):\n        return 1, [x]\n    \n    for i in range(len(distances)):\n        for j in range(i, len(distances)):\n            if distances[j] - distances[i] == x:\n                if can_measure(distances, y - x):\n                    return 1, [y - x]\n                else:\n                    return 1, [y]\n            elif distances[j] - distances[i] == y:\n                if can_measure(distances, y - x):\n                    return 1, [x]\n                else:\n                    return 1, [x]\n    \n    return 2, [x, y]\n\nn, l, x, y = map(int, input().split())\ndistances = list(map(int, input().split()))\n\nadditional_marks_count, additional_marks = find_additional_marks(n, l, x, y, distances)\n\nprint(additional_marks_count)\nprint(*additional_marks)"}
{"solution": "import math\n\ndef calculate_volume(radius, height):\n    \"\"\"Calculate the volume of a cylinder.\"\"\"\n    return math.pi * radius ** 2 * height\n\ndef find_max_volume(n, cakes):\n    \"\"\"Find the maximum volume of the cake that Babaei can make.\"\"\"\n    # Sort the cakes based on their volumes in descending order\n    cakes.sort(key=lambda x: calculate_volume(x[0], x[1]), reverse=True)\n\n    # Initialize a list to store the maximum volume that can be achieved at each position\n    max_volumes = [0] * n\n\n    # The maximum volume that can be achieved at the first position is the volume of the first cake\n    max_volumes[0] = calculate_volume(cakes[0][0], cakes[0][1])\n\n    # Iterate over the cakes to find the maximum volume that can be achieved at each position\n    for i in range(1, n):\n        max_volume = calculate_volume(cakes[i][0], cakes[i][1])\n        for j in range(i):\n            if cakes[i][0] < cakes[j][0] and cakes[i][1] < cakes[j][1]:\n                max_volume = max(max_volume, max_volumes[j] + calculate_volume(cakes[i][0], cakes[i][1]))\n        max_volumes[i] = max_volume\n\n    # Return the maximum volume that can be achieved\n    return max(max_volumes)\n\n# Read the input\nn = int(input())\ncakes = []\nfor _ in range(n):\n    radius, height = map(int, input().split())\n    cakes.append((radius, height))\n\n# Find and print the maximum volume\nmax_volume = find_max_volume(n, cakes)\nprint(max_volume)"}
{"solution": "import math\n\ndef min_slices(n, k, heights):\n    heights.sort()\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + heights[i]\n\n    def cost(height):\n        return prefix_sum[n] - prefix_sum[heights.index(height)] - height * (n - heights.index(height))\n\n    def check(mid):\n        total_cost = 0\n        for i in range(mid, n):\n            total_cost += cost(heights[i])\n            if total_cost > k * (i - mid + 1):\n                return False\n        return True\n\n    left, right = 0, n - 1\n    while left < right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left + 1\n\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\nprint(min_slices(n, k, heights))"}
{"solution": "def max_score(n, a):\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    max_score = float('-inf')\n\n    for l in range(n):\n        max_in_segment = float('-inf')\n        for r in range(l, n):\n            max_in_segment = max(max_in_segment, a[r])\n            segment_sum = prefix_sum[r + 1] - prefix_sum[l]\n            score = segment_sum - max_in_segment\n            max_score = max(max_score, score)\n\n    return max_score\n\nn = int(input())\na = list(map(int, input().split()))\nprint(max_score(n, a))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve():\n    k1, k2, k3 = map(int, input().split())\n    if lcm(k1, k2) <= k3 or lcm(k2, k3) <= k1 or lcm(k1, k3) <= k2:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nsolve()"}
{"solution": "def min_operations_to_delete_string(n, s):\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = 1\n    \n    for length in range(2, n + 1):  \n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j-1]\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n    \n    return dp[0][n-1]\n\nn = int(input())\ns = input().strip()\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "def max_pairs(boys, girls):\n    boys.sort()\n    girls.sort()\n    i = j = pairs = 0\n    while i < len(boys) and j < len(girls):\n        if abs(boys[i] - girls[j]) <= 1:\n            pairs += 1\n            i += 1\n            j += 1\n        elif boys[i] < girls[j]:\n            i += 1\n        else:\n            j += 1\n    return pairs\n\nn = int(input())\nboys = list(map(int, input().split()))\nm = int(input())\ngirls = list(map(int, input().split()))\n\nprint(max_pairs(boys, girls))"}
{"solution": "def determine_winner():\n    team1 = [list(map(int, input().split())) for _ in range(2)]\n    team2 = [list(map(int, input().split())) for _ in range(2)]\n\n    team1_defence = max(team1[0][0], team1[1][0])\n    team1_attack = min(team1[0][1], team1[1][1])\n\n    team2_defence = max(team2[0][0], team2[1][0])\n    team2_attack = min(team2[0][1], team2[1][1])\n\n    if team1_defence > team2_attack and team1_attack > team2_defence:\n        return \"Team 1\"\n    elif team2_defence > team1_attack and team2_attack > team1_defence:\n        return \"Team 2\"\n    else:\n        return \"Draw\"\n\nprint(determine_winner())"}
{"solution": "import math\nimport sys\n\ndef dist(x1, y1, x2, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef check(x, y, k, arr):\n    times = []\n    for i in range(len(arr)):\n        times.append(arr[i][2] * dist(x, y, arr[i][0], arr[i][1]))\n    times.sort()\n    return times[k - 1]\n\ndef solve():\n    n, k = map(int, input().split())\n    arr = []\n    for _ in range(n):\n        x, y, c = map(int, input().split())\n        arr.append([x, y, c])\n\n    min_time = sys.maxsize\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            x = (arr[i][0] + arr[j][0]) / 2\n            y = (arr[i][1] + arr[j][1]) / 2\n            time = check(x, y, k, arr)\n            min_time = min(min_time, time)\n\n    print(min_time)\n\nsolve()"}
{"solution": "def calculate_difference(s, n):\n    \"\"\"Calculate the difference between the sum of the first half and the sum of the second half.\"\"\"\n    first_half_sum = sum(int(s[i]) for i in range(n // 2) if s[i]!= '?')\n    second_half_sum = sum(int(s[i]) for i in range(n // 2, n) if s[i]!= '?')\n    return first_half_sum - second_half_sum\n\ndef can_monocarp_win(s, n):\n    \"\"\"Check if Monocarp can win.\"\"\"\n    difference = calculate_difference(s, n)\n    unknown_count = sum(1 for c in s[:n // 2] if c == '?') + sum(1 for c in s[n // 2:] if c == '?')\n    \n    # If the difference is not a multiple of 10 and there are not enough unknown digits to make it a multiple of 10, Monocarp can win.\n    if difference % 10!= 0 and unknown_count < 2:\n        return True\n    \n    # If the difference is a multiple of 10 but there are an odd number of unknown digits, Monocarp can win.\n    if difference % 10 == 0 and unknown_count % 2!= 0:\n        return True\n    \n    return False\n\ndef main():\n    n = int(input())\n    s = input()\n    \n    if can_monocarp_win(s, n):\n        print(\"Monocarp\")\n    else:\n        print(\"Bicarp\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_bus_route():\n    n, t = map(int, input().split())\n    earliest_time = float('inf')\n    chosen_route = -1\n    \n    for i in range(n):\n        s_i, d_i = map(int, input().split())\n        \n        if s_i >= t:\n            next_bus_time = s_i\n        else:\n            if (t - s_i) % d_i == 0:\n                next_bus_time = t\n            else:\n                next_bus_time = s_i + ((t - s_i) // d_i + 1) * d_i\n        \n        if next_bus_time < earliest_time:\n            earliest_time = next_bus_time\n            chosen_route = i + 1\n    \n    print(chosen_route)\n\nfind_bus_route()"}
{"solution": "def count_ones(n):\n    \"\"\"Count the number of ones in the binary representation of n.\"\"\"\n    return bin(n).count('1')\n\ndef find_n(m, k):\n    \"\"\"Find the smallest n such that there are exactly m numbers in the range [n+1, 2n] with k ones in their binary representation.\"\"\"\n    n = 1\n    while True:\n        count = sum(1 for i in range(n+1, 2*n+1) if count_ones(i) == k)\n        if count == m:\n            return n\n        n += 1\n\nm, k = map(int, input().split())\nprint(find_n(m, k))"}
{"solution": "def is_good_level(level):\n    platforms = [i for i, x in enumerate(level) if x == '*']\n    for i in range(len(platforms) - 4):\n        interval = platforms[i + 1] - platforms[i]\n        if all(platforms[i + j + 1] - platforms[i + j] == interval for j in range(3)):\n            return True\n    return False\n\nn = int(input())\nlevel = input().strip()\n\nprint('yes' if is_good_level(level) else 'no')"}
{"solution": "def find_magic_number(n, grid):\n    # Find the position of the empty cell\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                empty_row, empty_col = i, j\n\n    # Calculate the expected sum of each row, column, and diagonal\n    expected_sum = sum(grid[0])\n\n    # Check if the expected sum is consistent across all rows and columns\n    for i in range(1, n):\n        if sum(grid[i])!= expected_sum:\n            return -1\n\n    for j in range(n):\n        col_sum = sum(grid[k][j] for k in range(n))\n        if col_sum!= expected_sum:\n            return -1\n\n    # Calculate the sum of the main diagonal\n    main_diagonal_sum = sum(grid[k][k] for k in range(n))\n\n    # Calculate the sum of the secondary diagonal\n    secondary_diagonal_sum = sum(grid[k][n - k - 1] for k in range(n))\n\n    # If the main diagonal or secondary diagonal sum is inconsistent, return -1\n    if main_diagonal_sum!= expected_sum or secondary_diagonal_sum!= expected_sum:\n        return -1\n\n    # Calculate the sum of the row and column containing the empty cell\n    row_sum = sum(grid[empty_row])\n    col_sum = sum(grid[k][empty_col] for k in range(n))\n\n    # Calculate the magic number\n    magic_number = expected_sum - row_sum + grid[empty_row][empty_col]\n\n    return magic_number\n\n\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\nprint(find_magic_number(n, grid))"}
{"solution": "import math\n\n# Read the number of benches\nn = int(input())\n\n# Read the number of additional people\nm = int(input())\n\n# Initialize a list to store the number of people on each bench\na = []\n\n# Read the number of people on each bench\nfor _ in range(n):\n    a.append(int(input()))\n\n# Calculate the maximum possible k\nmax_k = max(a) + m\n\n# Calculate the total number of people after adding m people\ntotal_people = sum(a) + m\n\n# Calculate the minimum possible k\nmin_k = math.ceil(total_people / n)\n\n# Print the minimum and maximum possible k\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef pow_mod(a, b):\n    res = 1\n    while b:\n        if b & 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b >>= 1\n    return res\n\ndef main():\n    n, m = map(int, input().split())\n    if m > n:\n        print(0)\n        return\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n\n    inv_fact = [pow_mod(fact[i], MOD - 2) for i in range(n + 1)]\n\n    res = 0\n    for k in range(m + 1):\n        res = (res + fact[n - k] * inv_fact[n - m] * pow_mod(2, m - k) * pow_mod(2, n - m)) % MOD\n\n    print(res)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import defaultdict\nfrom itertools import combinations\n\ndef solve():\n    n, m = map(int, input().split())\n\n    friends = []\n    for _ in range(n):\n        f, *b = map(int, input().split())\n        friends.append(set(b))\n\n    pizzas = []\n    for j in range(m):\n        c, r, *a = map(int, input().split())\n        pizzas.append((c, set(a), j + 1))\n\n    pizzas.sort()\n\n    max_friends = 0\n    min_cost = float('inf')\n    best_pizzas = None\n\n    for (c1, a1, j1), (c2, a2, j2) in combinations(pizzas, 2):\n        friends_satisfied = sum(1 for b in friends if b.issubset(a1 | a2))\n        if friends_satisfied > max_friends or (friends_satisfied == max_friends and c1 + c2 < min_cost):\n            max_friends = friends_satisfied\n            min_cost = c1 + c2\n            best_pizzas = (j1, j2)\n\n    print(*best_pizzas)\n\nsolve()"}
{"solution": "def find_min_max_numbers(m, s):\n    if s == 0 and m > 1:\n        return -1, -1\n    if s < m or s > 9 * m:\n        return -1, -1\n\n    min_num = ''\n    max_num = ''\n\n    # Construct the minimum number\n    if s < 9:\n        min_num = str(s)\n        min_num += '0' * (m - 1)\n    else:\n        min_num = '1'\n        s -= 1\n        while s > 9:\n            min_num += '9'\n            s -= 9\n        if s > 0:\n            min_num += str(s)\n        min_num += '0' * (m - len(min_num))\n\n    # Construct the maximum number\n    if s < 9:\n        max_num = '0' * (m - 1)\n        max_num += str(s)\n    else:\n        max_num = '9' * (s // 9)\n        s %= 9\n        if s > 0:\n            max_num = str(s) + max_num\n        max_num = max_num[:m]\n\n    return int(min_num), int(max_num)\n\n\nm, s = map(int, input().split())\nmin_num, max_num = find_min_max_numbers(m, s)\nprint(min_num, max_num)"}
{"solution": "MOD = 998244353\n\ndef count_numbers_with_at_most_k_digits(n, k):\n    count = 0\n    for i in range(1, k + 1):\n        count += count_numbers_with_exactly_i_digits(n, i)\n    return count\n\ndef count_numbers_with_exactly_i_digits(n, i):\n    if i == 1:\n        return count_numbers_with_one_digit(n)\n    else:\n        return count_numbers_with_exactly_i_digits_recursive(n, i, 0, 0, 0)\n\ndef count_numbers_with_exactly_i_digits_recursive(n, i, pos, mask, is_smaller):\n    if pos == len(str(n)):\n        return 1 if i == 0 else 0\n    if (pos, i, mask, is_smaller) in memo:\n        return memo[(pos, i, mask, is_smaller)]\n    count = 0\n    upper_limit = int(str(n)[pos]) if not is_smaller else 9\n    for digit in range(upper_limit + 1):\n        new_is_smaller = is_smaller or digit < upper_limit\n        new_mask = mask | (1 << digit)\n        new_i = i - (1 if (mask & (1 << digit)) == 0 else 0)\n        count += count_numbers_with_exactly_i_digits_recursive(n, new_i, pos + 1, new_mask, new_is_smaller)\n    memo[(pos, i, mask, is_smaller)] = count\n    return count\n\ndef count_numbers_with_one_digit(n):\n    count = 0\n    for digit in range(1, 10):\n        count += min(n, digit * (10 ** (len(str(n)) - 1))) - digit * (10 ** (len(str(n)) - 2)) + 1\n    return count\n\ndef sum_of_numbers_with_at_most_k_digits(n, k):\n    count = count_numbers_with_at_most_k_digits(n, k)\n    sum_of_numbers = (n * (n + 1)) // 2 - (n - count) * (n - count + 1) // 2\n    return sum_of_numbers % MOD\n\ndef main():\n    l, r, k = map(int, input().split())\n    memo = {}\n    result = (sum_of_numbers_with_at_most_k_digits(r, k) - sum_of_numbers_with_at_most_k_digits(l - 1, k)) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef main():\n    n, k, d = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] - a[i] <= d:\n            j += 1\n        if j - i >= k:\n            i = j\n        else:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_dead_bulbs(garland):\n    colors = ['R', 'B', 'Y', 'G']\n    dead_bulbs = {color: 0 for color in colors}\n\n    for i in range(len(garland)):\n        if garland[i] == '!':\n            possible_colors = [color for color in colors if color not in garland[i-1:i+3] and color!= garland[(i-4) % len(garland)]]\n            dead_bulbs[possible_colors[0]] += 1\n\n    return dead_bulbs\n\ngarland = input()\ndead_bulbs = count_dead_bulbs(garland)\nprint(dead_bulbs['R'], dead_bulbs['B'], dead_bulbs['Y'], dead_bulbs['G'])"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_list():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n, m = read_ints()\n    graph = defaultdict(list)\n    for _ in range(m):\n        s, t = read_ints()\n        graph[s].append(t)\n\n    e = [0] * (n + 1)\n    e[n] = 0\n    for i in range(n - 1, 0, -1):\n        if len(graph[i]) == 1:\n            e[i] = 1 + e[graph[i][0]]\n        else:\n            e[i] = 1 + sum(e[j] for j in graph[i]) / len(graph[i])\n\n    min_e = float('inf')\n    for i in range(1, n):\n        if len(graph[i]) > 1:\n            new_e = 1 + sum(e[j] for j in graph[i] if j!= graph[i][0]) / (len(graph[i]) - 1)\n            min_e = min(min_e, new_e)\n        else:\n            min_e = min(min_e, e[i])\n\n    print(min_e)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def round_to_nearest_multiple_of_ten(n):\n    remainder = n % 10\n    if remainder <= 4:\n        return n - remainder\n    else:\n        return n + (10 - remainder)\n\nn = int(input())\nprint(round_to_nearest_multiple_of_ten(n))"}
{"solution": "def find_swaps(s, t):\n    if len(s)!= len(t):\n        print(-1)\n        return\n    \n    mismatches = {}\n    \n    for i in range(len(s)):\n        if s[i]!= t[i]:\n            if s[i] in mismatches and mismatches[s[i]]!= t[i]:\n                print(-1)\n                return\n            if t[i] in mismatches and mismatches[t[i]]!= s[i]:\n                print(-1)\n                return\n            mismatches[s[i]] = t[i]\n            mismatches[t[i]] = s[i]\n    \n    visited = set()\n    swaps = []\n    \n    for key in mismatches:\n        if key not in visited:\n            cycle = []\n            current = key\n            while current not in visited:\n                visited.add(current)\n                cycle.append(current)\n                current = mismatches[current]\n            if len(cycle)!= 2:\n                print(-1)\n                return\n            swaps.append((cycle[0], cycle[1]))\n    \n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0], swap[1])\n\ns = input()\nt = input()\nfind_swaps(s, t)"}
{"solution": "def generate_login(first_name, last_name):\n    \"\"\"\n    Generate the alphabetically earliest possible login from the given first and last names.\n    \n    Parameters:\n    first_name (str): The user's first name.\n    last_name (str): The user's last name.\n    \n    Returns:\n    str: The alphabetically earliest possible login.\n    \"\"\"\n    # Initialize the earliest login with the full first name and the full last name\n    earliest_login = first_name + last_name\n    \n    # Iterate over all possible prefixes of the first name\n    for i in range(1, len(first_name)):\n        # Iterate over all possible prefixes of the last name\n        for j in range(1, len(last_name)):\n            # Generate the current login\n            current_login = first_name[:i] + last_name[:j]\n            # If the current login is alphabetically earlier than the earliest login, update the earliest login\n            if current_login < earliest_login:\n                earliest_login = current_login\n    \n    return earliest_login\n\n# Read the input\nfirst_name, last_name = input().split()\n\n# Generate and print the alphabetically earliest possible login\nprint(generate_login(first_name, last_name))"}
{"solution": "def draw_brackets(n, brackets):\n    stack = []\n    max_height = 0\n    for bracket in brackets:\n        if bracket == '[':\n            stack.append(bracket)\n            max_height = max(max_height, len(stack))\n        else:\n            stack.pop()\n\n    lines = [''] * max_height\n    stack = []\n    for bracket in brackets:\n        if bracket == '[':\n            stack.append(bracket)\n            height = len(stack)\n            lines[height - 1] += '+'\n            for i in range(height - 2, -1, -1):\n                lines[i] += '|'\n        else:\n            height = len(stack)\n            lines[height - 1] += '-'\n            for i in range(height - 2, -1, -1):\n                lines[i] += '|'\n            stack.pop()\n\n    for i in range(max_height):\n        lines[i] +='' * (n // 2 - len(lines[i]))\n        if i < max_height - 1:\n            lines[i] +='' * (n // 2 - len(lines[i + 1]))\n\n    for i in range(max_height):\n        if i > 0:\n            lines[i] = lines[i - 1][:len(lines[i - 1]) - len(lines[i])] + lines[i]\n        print(lines[i])\n\nn = int(input())\nbrackets = input()\ndraw_brackets(n, brackets)"}
{"solution": "def normalize_golden_number(golden_number):\n    golden_number = list(map(int, golden_number))\n    n = len(golden_number)\n    \n    for i in range(n - 1, 0, -1):\n        if golden_number[i] > 1:\n            golden_number[i] -= 2\n            golden_number[i - 1] += 1\n            if i - 2 >= 0:\n                golden_number[i - 2] += 1\n    \n    while len(golden_number) > 1 and golden_number[0] == 0:\n        golden_number.pop(0)\n    \n    return golden_number\n\ndef compare_golden_numbers(num1, num2):\n    norm_num1 = normalize_golden_number(num1)\n    norm_num2 = normalize_golden_number(num2)\n    \n    if len(norm_num1) > len(norm_num2):\n        return \">\"\n    elif len(norm_num1) < len(norm_num2):\n        return \"<\"\n    \n    for digit1, digit2 in zip(norm_num1, norm_num2):\n        if digit1 > digit2:\n            return \">\"\n        elif digit1 < digit2:\n            return \"<\"\n    \n    return \"=\"\n\nnum1 = input().strip()\nnum2 = input().strip()\n\nresult = compare_golden_numbers(num1, num2)\nprint(result)"}
{"solution": "def find_absent_gems():\n    gems = {\n        \"purple\": \"Power\",\n        \"green\": \"Time\",\n        \"blue\": \"Space\",\n        \"orange\": \"Soul\",\n        \"red\": \"Reality\",\n        \"yellow\": \"Mind\"\n    }\n\n    n = int(input())\n    present_gems = [input() for _ in range(n)]\n\n    absent_gems = [gems[color] for color in gems if color not in present_gems]\n\n    print(len(absent_gems))\n    for gem in absent_gems:\n        print(gem)\n\nfind_absent_gems()"}
{"solution": "def find_meeting_round(n, a, b):\n    \"\"\"\n    Determine the round in which two teams can meet in a play-off system.\n\n    Args:\n    n (int): The total number of teams.\n    a (int): The id of the first team.\n    b (int): The id of the second team.\n\n    Returns:\n    str or int: The round in which the teams can meet, or \"Final!\" if they can meet in the final.\n    \"\"\"\n    # Initialize the round number\n    round_num = 1\n\n    # Continue until the teams meet\n    while True:\n        # Calculate the position of each team in the current round\n        pos_a = (a - 1) // (n // 2) + 1\n        pos_b = (b - 1) // (n // 2) + 1\n\n        # If the teams are in the same position, they meet in this round\n        if pos_a == pos_b:\n            # If there are only two teams left, they meet in the final\n            if n == 2:\n                return \"Final!\"\n            else:\n                return round_num\n\n        # Move to the next round\n        n //= 2\n        round_num += 1\n\n\n# Read the input\nn, a, b = map(int, input().split())\n\n# Find the meeting round\nmeeting_round = find_meeting_round(n, a, b)\n\n# Print the result\nprint(meeting_round)"}
{"solution": "def min_changes(n, p, b):\n    # Calculate the number of cycles in the permutation\n    cycles = 0\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            cycles += 1\n            j = i\n            while not visited[j]:\n                visited[j] = True\n                j = p[j] - 1\n\n    # Calculate the number of ones in the sequence\n    ones = sum(b)\n\n    # If the number of cycles is 1, we need to change at least one element in the sequence\n    if cycles == 1:\n        return 1 if ones == 0 else 0\n\n    # If the number of cycles is greater than 1, we need to change at least one element in the permutation\n    # and the number of ones in the sequence should be odd\n    return (cycles - 1) + (ones % 2)\n\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(min_changes(n, p, b))"}
{"solution": "def calculate_max_distance(v1, v2, t, d):\n    \"\"\"\n    Calculate the maximum possible length of the path section in meters.\n\n    Args:\n    v1 (int): The speed in meters per second at the beginning of the segment.\n    v2 (int): The speed in meters per second at the end of the segment.\n    t (int): The time when the car moves along the segment in seconds.\n    d (int): The maximum value of the speed change between adjacent seconds.\n\n    Returns:\n    int: The maximum possible length of the path section in meters.\n    \"\"\"\n    # Calculate the total distance if the speed changes linearly\n    linear_distance = (v1 + v2) * t // 2\n\n    # Calculate the maximum possible speed change\n    max_speed_change = min(d * (t - 1), abs(v2 - v1))\n\n    # Calculate the remaining speed change after linear change\n    remaining_speed_change = abs(v2 - v1) - max_speed_change\n\n    # Calculate the number of seconds for the remaining speed change\n    remaining_seconds = remaining_speed_change // d + (1 if remaining_speed_change % d!= 0 else 0)\n\n    # Calculate the maximum possible distance\n    max_distance = linear_distance + max_speed_change * (t - remaining_seconds - 1) // 2\n\n    return max_distance\n\n\n# Read input\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Calculate and print the maximum possible length of the path section\nprint(calculate_max_distance(v1, v2, t, d))"}
{"solution": "import sys\nimport itertools\n\ndef check_order(order, weights, bridge):\n    total_weight = sum(weights)\n    min_distance = 0\n    for i, (length, capacity) in enumerate(bridge):\n        max_weight = 0\n        for j in range(len(order)):\n            if j > 0 and min_distance + length < sum(weights[order[k]] for k in range(j)):\n                break\n            max_weight = max(max_weight, sum(weights[order[k]] for k in range(j+1) if k < len(order) and min_distance + length >= sum(weights[order[kk]] for kk in range(k))))\n        if max_weight > capacity:\n            return False\n        min_distance = max(min_distance, sum(weights[order[k]] for k in range(len(order)) if sum(weights[order[kk]] for kk in range(k)) <= length))\n    return True\n\ndef main():\n    input = sys.stdin.readline\n    N, M = map(int, input().split())\n    weights = list(map(int, input().split()))\n    bridge = [tuple(map(int, input().split())) for _ in range(M)]\n    min_distance = float('inf')\n    for order in itertools.permutations(range(N)):\n        if check_order(order, weights, bridge):\n            min_distance = min(min_distance, sum(length for length, _ in bridge))\n    print(min_distance if min_distance!= float('inf') else -1)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def last_digit_factorial(n):\n    \"\"\"Calculate the last digit of n!\"\"\"\n    if n < 5:\n        result = 1\n        for i in range(1, n + 1):\n            result = (result * i) % 10\n        return result\n    else:\n        return 0\n\ndef last_digit_division(a, b):\n    \"\"\"Calculate the last digit of b! / a!\"\"\"\n    if a >= 5:\n        return 0\n    else:\n        return (last_digit_factorial(b) * pow(last_digit_factorial(a), -1, 10)) % 10\n\na, b = map(int, input().split())\nprint(last_digit_division(a, b))"}
{"solution": "from collections import deque\n\ndef min_jumps(n, d, s):\n    queue = deque([(1, 0)])\n    visited = set([1])\n\n    while queue:\n        pos, jumps = queue.popleft()\n\n        if pos == n:\n            return jumps\n\n        for jump in range(1, min(d + 1, n - pos + 1)):\n            new_pos = pos + jump\n\n            if s[new_pos - 1] == '1' and new_pos not in visited:\n                queue.append((new_pos, jumps + 1))\n                visited.add(new_pos)\n\n    return -1\n\nn, d = map(int, input().split())\ns = input()\n\nprint(min_jumps(n, d, s))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_counterexample(n):\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\nn = int(input().strip())\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all_coins(n):\n    \"\"\"\n    Checks if it's possible to spend all initial game-coins buying only houses, cars and computers.\n\n    Args:\n    n (int): Kolya's initial game-coin score.\n\n    Returns:\n    bool: True if it's possible to spend all coins, False otherwise.\n    \"\"\"\n    house_cost = 1234567\n    car_cost = 123456\n    computer_cost = 1234\n\n    for a in range(n // house_cost + 1):\n        remaining_coins = n - a * house_cost\n        if remaining_coins < 0:\n            break\n        for b in range(remaining_coins // car_cost + 1):\n            remaining_coins_after_cars = remaining_coins - b * car_cost\n            if remaining_coins_after_cars < 0:\n                break\n            if remaining_coins_after_cars % computer_cost == 0:\n                return True\n\n    return False\n\n\ndef main():\n    n = int(input())\n    if can_spend_all_coins(n):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n = int(read_input())\n    x1, x2 = read_ints()\n    lines = []\n    for _ in range(n):\n        k, b = read_ints()\n        lines.append((k, b))\n\n    lines.sort(key=lambda x: x[0])\n\n    for i in range(n - 1):\n        k1, b1 = lines[i]\n        k2, b2 = lines[i + 1]\n        if k1 == k2:\n            continue\n        x = (b2 - b1) / (k1 - k2)\n        if x1 < x < x2:\n            print(\"Yes\")\n            return\n\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef count_weights(n):\n    weights = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            weights.add(i)\n            weights.add(n // i)\n    return len(weights)\n\nn = int(input())\nprint(count_weights(n))"}
{"solution": "n, k = map(int, input().split())\n\nif k == 0:\n    min_good = 0\n    max_good = 0\nelse:\n    min_good = 1\n    max_good = min(n - k, 2 * k - (k == 1))\n\nprint(min_good, max_good)"}
{"solution": "import math\n\ndef max_games(n):\n    \"\"\"\n    Calculate the maximum number of games the winner of a knockout tournament can play.\n    \n    Parameters:\n    n (int): The number of players in the tournament.\n    \n    Returns:\n    int: The maximum number of games the winner can play.\n    \"\"\"\n    # Calculate the maximum number of games using the formula floor(log2(n))\n    max_games = math.floor(math.log2(n))\n    \n    return max_games\n\n# Read the number of players from the input\nn = int(input())\n\n# Calculate and print the maximum number of games\nprint(max_games(n))"}
{"solution": "def max_vk(s):\n    vk_count = s.count(\"VK\")\n    v_count = s.count(\"V\")\n    k_count = s.count(\"K\")\n\n    if v_count > 1 and k_count > 1:\n        vk_count = max(vk_count, v_count - 1, k_count - 1)\n    elif v_count == 1 and k_count > 1:\n        vk_count = max(vk_count, 1)\n    elif v_count > 1 and k_count == 1:\n        vk_count = max(vk_count, 1)\n    else:\n        vk_count = max(vk_count, 0)\n\n    return vk_count\n\ns = input()\nprint(max_vk(s))"}
{"solution": "import math\n\ndef min_segments(n):\n    a = int(math.sqrt(n))\n    while a * a < n:\n        a += 1\n    b = (n + a - 1) // a\n    return a + b + 2\n\nn = int(input().strip())\nprint(min_segments(n))"}
{"solution": "def years_until_larger(a, b):\n    years = 0\n    while a <= b:\n        a *= 3\n        b *= 2\n        years += 1\n    return years\n\na, b = map(int, input().split())\nprint(years_until_larger(a, b))"}
{"solution": "def calculate_nodes_to_visit(h, n):\n    # Calculate the total number of nodes in the tree\n    total_nodes = 2 ** (h + 1) - 1\n\n    # Calculate the number of nodes to visit before reaching the exit\n    nodes_to_visit = total_nodes - 1\n\n    # Calculate the number of nodes to visit in the left subtree\n    left_subtree_nodes = 2 ** h - 1\n\n    # If the exit is in the left subtree, subtract the nodes in the right subtree\n    if n <= left_subtree_nodes:\n        nodes_to_visit -= 2 ** h\n\n    # If the exit is in the right subtree, subtract the nodes in the left subtree\n    else:\n        nodes_to_visit -= 2 ** h\n        # Add the nodes in the left subtree that Amr will visit before going to the right subtree\n        nodes_to_visit += 2 * (n - left_subtree_nodes - 1)\n\n    return nodes_to_visit\n\n\nh, n = map(int, input().split())\nprint(calculate_nodes_to_visit(h, n))"}
{"solution": "import math\n\ndef find_pairs(x):\n    pairs = []\n    for n in range(1, int(math.sqrt(x)) + 1):\n        for m in range(n, x // n + 1):\n            total_squares = sum(min(n, m - i) for i in range(n))\n            if total_squares == x:\n                pairs.append((n, m))\n                if n!= m:\n                    pairs.append((m, n))\n    return pairs\n\nx = int(input())\npairs = find_pairs(x)\nprint(len(pairs))\nfor pair in sorted(pairs):\n    print(pair[0], pair[1])"}
{"solution": "def is_leap_year(year):\n    return year % 4 == 0 and (year % 100!= 0 or year % 400 == 0)\n\ndef get_month_days(year, month):\n    if month == 2:\n        return 29 if is_leap_year(year) else 28\n    elif month in [1, 3, 5, 7, 8, 10, 12]:\n        return 31\n    else:\n        return 30\n\ndef check_sequence(sequence):\n    for year in range(2000, 2100):\n        for month in range(1, 13):\n            if sequence == [get_month_days(year, m) for m in range(month, month + len(sequence))]:\n                return True\n    return False\n\nn = int(input())\nsequence = list(map(int, input().split()))\n\nif check_sequence(sequence):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def find_sequence(n):\n    if n == 2:\n        return None\n\n    sequence = []\n    remaining = n - 1\n\n    for i in range(2, n):\n        if n % i == 0:\n            a = remaining // i\n            if a > 0:\n                sequence.append((a, i))\n                remaining -= a\n\n    if remaining > 0:\n        sequence.append((1, n))\n\n    return sequence\n\n\ndef main():\n    n = int(input())\n\n    sequence = find_sequence(n)\n\n    if sequence is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(len(sequence))\n        for a, b in sequence:\n            print(a, b)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef solve():\n    n = read_int()\n    a, b = read_ints()\n    h = list(read_ints())\n\n    total_height = sum(h)\n    if total_height > a + b:\n        return -1\n\n    if a >= total_height:\n        return 0\n\n    if b >= total_height:\n        return 0\n\n    dp = [[float('inf')] * (b + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(b + 1):\n            if j >= h[i - 1]:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j - h[i - 1]])\n            if j + h[i - 1] <= b:\n                dp[i][j + h[i - 1]] = min(dp[i][j + h[i - 1]], dp[i - 1][j] + h[i - 1])\n\n    min_unattractiveness = float('inf')\n    for j in range(b + 1):\n        if dp[n][j] <= a:\n            min_unattractiveness = min(min_unattractiveness, dp[n][j])\n\n    return min_unattractiveness if min_unattractiveness!= float('inf') else -1\n\nprint(solve())"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn, m, k = map(int, input().split())\n\nif n * m % k!= 0:\n    print(\"NO\")\nelse:\n    area = n * m // k\n    g = gcd(n, m)\n    if area * 2 % g!= 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(0, 0)\n        print(n, 0)\n        print(0, m - (area * 2 // g))"}
{"solution": "def sasha_game(n, k):\n    if n % (2 * k) == 0:\n        return \"NO\"\n    else:\n        return \"YES\"\n\nn, k = map(int, input().split())\nprint(sasha_game(n, k))"}
{"solution": "n = int(input())\nexercises = list(map(int, input().split()))\n\nmuscle_groups = [\"chest\", \"biceps\", \"back\"]\nmuscle_repetitions = [0, 0, 0]\n\nfor i, repetition in enumerate(exercises):\n    muscle_repetitions[i % 3] += repetition\n\nmax_repetition = max(muscle_repetitions)\nmax_index = muscle_repetitions.index(max_repetition)\n\nprint(muscle_groups[max_index])"}
{"solution": "def min_redos_to_get_five():\n    n = int(input())\n    grades = list(map(int, input().split()))\n    \n    current_sum = sum(grades)\n    target_sum = n * 4.5\n    \n    if current_sum >= target_sum:\n        return 0\n    \n    grades.sort()\n    redos = 0\n    \n    for grade in grades:\n        if current_sum >= target_sum:\n            break\n        current_sum += (5 - grade)\n        redos += 1\n    \n    return redos\n\nprint(min_redos_to_get_five())"}
{"solution": "def solve(u, v):\n    if u > v:\n        return None\n    if u % 2!= v % 2:\n        return None\n    if u == 0 and v == 0:\n        return []\n    if u == v:\n        return [u]\n    if u == 0:\n        if v % 2 == 0:\n            return [v // 2, v // 2]\n        else:\n            return [1, v - 1, 1]\n    if v % 2 == 0:\n        return [u ^ (v - u) // 2, (v - u) // 2]\n    return [1, u ^ (v - 1) // 2, (v - 1) // 2]\n\nu, v = map(int, input().split())\nresult = solve(u, v)\nif result is None:\n    print(-1)\nelse:\n    print(len(result))\n    print(*result)"}
{"solution": "def min_ones(n):\n    \"\"\"Return the minimum number of digits '1' in the sum of addends containing only '1'.\"\"\"\n    result = 0\n    i = 1\n    while n > 0:\n        if n >= i:\n            n -= i\n            result += len(str(i))\n        i *= 10\n    return result\n\nn = int(input())\nprint(min_ones(n))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\ndx = abs(x2 - x1)\ndy = abs(y2 - y1)\n\nif dx == 0 and dy % y == 0:\n    print(\"YES\")\nelif dy == 0 and dx % x == 0:\n    print(\"YES\")\nelif dx == 0 or dy == 0 or gcd(dx, x) == gcd(dy, y):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "from itertools import permutations\nfrom collections import Counter\n\ndef count_valid_bus_numbers(n):\n    # Convert the number to a string to extract digits\n    digits = list(str(n))\n    \n    # Count the frequency of each digit\n    digit_counts = Counter(digits)\n    \n    # Initialize the count of valid permutations\n    count = 0\n    \n    # Generate all unique permutations of the digits\n    for r in range(1, len(digits) + 1):\n        for perm in permutations(digits, r):\n            # Check if the permutation is valid\n            if perm[0]!= '0' and Counter(perm) <= digit_counts:\n                count += 1\n                \n    # Return the count of valid permutations\n    return count\n\n# Read input\nn = int(input().strip())\n\n# Get the count of valid bus numbers\nresult = count_valid_bus_numbers(n)\n\n# Print the result\nprint(result)"}
{"solution": "def calculate_max_cost():\n    a = int(input())\n    b = int(input())\n    c = int(input())\n    d = int(input())\n    e = int(input())\n    f = int(input())\n\n    # Calculate the maximum number of suits of the first type\n    max_suits_first_type = min(a, d)\n\n    # Calculate the maximum number of suits of the second type\n    max_suits_second_type = min(b, c, d)\n\n    # Initialize the maximum cost\n    max_cost = 0\n\n    # Iterate over all possible combinations of suits\n    for suits_first_type in range(max_suits_first_type + 1):\n        remaining_jackets = d - suits_first_type\n        suits_second_type = min(remaining_jackets, b, c)\n        cost = suits_first_type * e + suits_second_type * f\n        max_cost = max(max_cost, cost)\n\n    print(max_cost)\n\ncalculate_max_cost()"}
{"solution": "def pow_mod(a, n, p):\n    \"\"\"Compute a^n mod p\"\"\"\n    res = 1\n    while n > 0:\n        if n % 2 == 1:\n            res = (res * a) % p\n        a = (a * a) % p\n        n //= 2\n    return res\n\ndef discrete_log(a, b, p):\n    \"\"\"Find the discrete logarithm of b with base a mod p\"\"\"\n    m = int(p ** 0.5) + 1\n    a_pow = [pow_mod(a, i, p) for i in range(m)]\n    a_inv = pow_mod(a, p - 2, p)\n    b_pow = pow_mod(a_inv, m, p)\n    for i in range(m):\n        if b in a_pow:\n            return a_pow.index(b)\n        b = (b * b_pow) % p\n    return -1\n\ndef solve(a, b, p, x):\n    \"\"\"Solve the congruence equation n * a^n \u2261 b (mod p)\"\"\"\n    if a == 1:\n        return 1 if b == 1 else 0\n    if b == 0:\n        return 1 if a == 0 else 0\n    if pow_mod(a, p - 1, p) == 1:\n        return 1 if pow_mod(a, x, p) == b else 0\n    d = discrete_log(a, b, p)\n    if d == -1:\n        return 0\n    k = (p - 1) // gcd(a, p - 1)\n    return (x - d) // k + 1\n\ndef gcd(a, b):\n    \"\"\"Compute the greatest common divisor of a and b\"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\na, b, p, x = map(int, input().split())\nprint(solve(a, b, p, x))"}
{"solution": "def calculate_max_sum(k_2, k_3, k_5, k_6):\n    max_256 = min(k_2, k_5, k_6)\n    remaining_2 = max(0, k_2 - max_256)\n    max_32 = min(remaining_2, k_3)\n    return max_256 * 256 + max_32 * 32\n\nk_2, k_3, k_5, k_6 = map(int, input().split())\nprint(calculate_max_sum(k_2, k_3, k_5, k_6))"}
{"solution": "import math\n\nn, x, y, c = map(int, input().split())\n\nif c == 1:\n    print(0)\nelse:\n    if c > n * n:\n        print(-1)\n    else:\n        if x == 1 or x == n:\n            if y == 1 or y == n:\n                print(math.ceil((math.sqrt(c) - 1) / 2))\n            else:\n                print(math.ceil((math.sqrt(c) - 2) / 2))\n        elif y == 1 or y == n:\n            print(math.ceil((math.sqrt(c) - 2) / 2))\n        else:\n            print(math.ceil((math.sqrt(c) - 3) / 2))"}
{"solution": "def max_xor(l, r):\n    if l == r:\n        return 0\n\n    max_val = 0\n    i = 0\n    while (1 << i) <= r:\n        i += 1\n\n    for j in range(i - 1, -1, -1):\n        max_val |= (1 << j)\n        if l | max_val <= r:\n            continue\n        else:\n            max_val ^= (1 << j)\n\n    return max_val\n\nl, r = map(int, input().split())\nprint(max_xor(l, r))"}
{"solution": "def minimum_height():\n    n, k = map(int, input().split())\n    left, right = 1, k\n    \n    while left < right:\n        mid = (left + right) // 2\n        if n * mid >= k:\n            right = mid\n        else:\n            left = mid + 1\n    \n    print(left)\n\nminimum_height()"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    stairs_time = abs(x - y) * t1\n    \n    elevator_to_masha_time = abs(z - x) * t2 + t3\n    elevator_to_egor_time = abs(x - y) * t2 + 2 * t3\n    elevator_time = elevator_to_masha_time + elevator_to_egor_time\n    \n    if stairs_time < elevator_time:\n        return \"NO\"\n    else:\n        return \"YES\"\n\nx, y, z, t1, t2, t3 = map(int, input().split())\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "def find_optimal_a(n, m):\n    \"\"\"\n    Find the optimal value of a that maximizes the probability of Andrew's victory.\n\n    Args:\n    n (int): The range of numbers in the game.\n    m (int): The number selected by Misha.\n\n    Returns:\n    int: The optimal value of a.\n    \"\"\"\n    # If m is at one of the extremes, a should be at the other extreme\n    if m == 1:\n        return n\n    elif m == n:\n        return 1\n    # If m is closer to one end, a should be closer to the other end\n    elif m < (n + 1) // 2:\n        return m + 1\n    else:\n        return m - 1\n\n# Read input\nn, m = map(int, input().split())\n\n# Find and print the optimal value of a\nprint(find_optimal_a(n, m))"}
{"solution": "def count_pairs(n, schedule):\n    \"\"\"\n    Calculate the number of pairs Alena will stay at the university.\n\n    Args:\n    n (int): The number of lessons at the university.\n    schedule (list): A list of 0s and 1s representing the schedule.\n\n    Returns:\n    int: The number of pairs Alena will stay at the university.\n    \"\"\"\n    pairs = 0\n    i = 0\n    while i < n:\n        # If the current pair has a class, increment pairs and move to the next pair\n        if schedule[i] == 1:\n            pairs += 1\n            i += 1\n        # If the current pair is a break, check if it's long enough to go home\n        else:\n            # If the break is at the end of the schedule, don't count it\n            if i == n - 1:\n                break\n            # If the break is long enough, skip it and move to the next pair with a class\n            elif schedule[i + 1] == 0:\n                i += 2\n            # If the break is not long enough, count the current pair and move to the next pair\n            else:\n                pairs += 1\n                i += 1\n    return pairs\n\nn = int(input())\nschedule = list(map(int, input().split()))\nprint(count_pairs(n, schedule))"}
{"solution": "def min_days_to_give_candies(n, k, candies):\n    total_candies = 0\n    days = 0\n    for candy in candies:\n        total_candies += candy\n        days += 1\n        if total_candies >= k:\n            given_candies = min(total_candies, k + (days - 1) * 8)\n            if given_candies >= k:\n                return days\n    return -1\n\nn, k = map(int, input().split())\ncandies = list(map(int, input().split()))\n\nprint(min_days_to_give_candies(n, k, candies))"}
{"solution": "def minimum_additional_walks(n, k, a):\n    b = a[:]\n    additional_walks = 0\n    \n    # Adjust walks for the first day considering the day before the first day\n    if b[0] < k:\n        needed_walks = k - b[0]\n        b[0] += needed_walks\n        additional_walks += needed_walks\n    \n    for i in range(n - 1):\n        if b[i] + b[i + 1] < k:\n            needed_walks = k - (b[i] + b[i + 1])\n            b[i + 1] += needed_walks\n            additional_walks += needed_walks\n    \n    # Adjust walks for the last day considering the day after the n-th day\n    if b[-1] < k:\n        needed_walks = k - b[-1]\n        b[-1] += needed_walks\n        additional_walks += needed_walks\n    \n    return additional_walks, b\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nadditional_walks, b = minimum_additional_walks(n, k, a)\n\n# Print the result\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "def calculate_rhombus_cells(n):\n    \"\"\"\n    Calculate the number of cells in an n-th order rhombus.\n\n    Args:\n    n (int): The order of the rhombus.\n\n    Returns:\n    int: The number of cells in the rhombus.\n    \"\"\"\n    return 2 * n ** 2 - 2 * n + 1\n\n\ndef main():\n    n = int(input())\n    print(calculate_rhombus_cells(n))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_pangram(n, s):\n    alphabet = set('abcdefghijklmnopqrstuvwxyz')\n    return 'YES' if set(s.lower()).issuperset(alphabet) else 'NO'\n\nn = int(input())\ns = input()\nprint(is_pangram(n, s))"}
{"solution": "def calculate_time(time_str, minutes):\n    hours, mins = map(int, time_str.split(':'))\n    total_mins = hours * 60 + mins + minutes\n    new_hours = (total_mins // 60) % 24\n    new_mins = total_mins % 60\n    return f\"{new_hours:02d}:{new_mins:02d}\"\n\ntime_str = input()\nminutes = int(input())\nprint(calculate_time(time_str, minutes))"}
{"solution": "def can_ignore_switch(n, m, switches):\n    # Create a set to store the lamps that each switch can turn on\n    switch_lamps = [set() for _ in range(n)]\n    \n    # Populate the switch_lamps set\n    for i in range(n):\n        for j in range(m):\n            if switches[i][j] == '1':\n                switch_lamps[i].add(j)\n    \n    # Check if there is a switch that can be ignored\n    for i in range(n):\n        # Create a set to store the lamps that can be turned on by the other switches\n        other_lamps = set()\n        for j in range(n):\n            if i!= j:\n                other_lamps.update(switch_lamps[j])\n        \n        # If all lamps can be turned on by the other switches, return True\n        if len(other_lamps) == m:\n            return True\n    \n    # If no switch can be ignored, return False\n    return False\n\n# Read the input\nn, m = map(int, input().split())\nswitches = [input() for _ in range(n)]\n\n# Check if a switch can be ignored\nif can_ignore_switch(n, m, switches):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_time_to_rotate(n, dominoes):\n    \"\"\"\n    Calculate the minimum time required to rotate dominoes to achieve even sums on both halves.\n\n    Args:\n    n (int): The number of dominoes.\n    dominoes (list): A list of tuples, where each tuple contains the numbers on the upper and lower halves of a domino.\n\n    Returns:\n    int: The minimum time required to rotate dominoes. If it's impossible to achieve even sums, return -1.\n    \"\"\"\n    upper_sum = sum(x for x, y in dominoes)\n    lower_sum = sum(y for x, y in dominoes)\n\n    if upper_sum % 2!= lower_sum % 2:\n        # If the sums have different parities, we need to rotate some dominoes\n        odd_upper = sum(1 for x, y in dominoes if x % 2!= y % 2)\n        if odd_upper == 0:\n            # If there are no dominoes with different parities, it's impossible to achieve even sums\n            return -1\n        else:\n            # We need to rotate at least one domino\n            return 1\n    else:\n        # If the sums already have the same parity, we don't need to rotate any dominoes\n        return 0\n\n\nn = int(input())\ndominoes = [tuple(map(int, input().split())) for _ in range(n)]\nprint(min_time_to_rotate(n, dominoes))"}
{"solution": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = math.isqrt(n)\n    for i in range(3, sqrt_n + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef solve():\n    a, b = map(int, input().split())\n    area = (a - b) * (a + b)\n    if is_prime(area):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nt = int(input())\nfor _ in range(t):\n    solve()"}
{"solution": "def can_remove_one_point(n, points):\n    positive_count = 0\n    negative_count = 0\n    \n    for x, y in points:\n        if x > 0:\n            positive_count += 1\n        else:\n            negative_count += 1\n    \n    if positive_count <= 1 or negative_count <= 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Reading input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_remove_one_point(n, points))"}
{"solution": "import math\n\ndef calculate_gcd_factorials():\n    a, b = map(int, input().split())\n    min_val = min(a, b)\n    gcd_factorial = math.factorial(min_val)\n    print(gcd_factorial)\n\ncalculate_gcd_factorials()"}
{"solution": "def find_composite_numbers(n):\n    if n % 2 == 0:\n        a = n + 4\n        b = 4\n    else:\n        a = n + 9\n        b = 9\n    return a, b\n\nn = int(input())\na, b = find_composite_numbers(n)\nprint(a, b)"}
{"solution": "import sys\nimport heapq\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_list():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n, m, p = read_ints()\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, c = read_ints()\n        a -= 1\n        b -= 1\n        graph[a].append((b, c))\n\n    dist = [float('inf')] * n\n    dist[0] = 0\n    pq = [(0, 0)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, c in graph[u]:\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                heapq.heappush(pq, (dist[v], v))\n\n    if dist[-1] == float('inf'):\n        print(-1)\n        return\n\n    dp = [0] * n\n    for u in range(n):\n        for v, c in graph[u]:\n            dp[v] = max(dp[v], dp[u] + c)\n\n    ans = 0\n    for i in range(1, dist[-1] + 1):\n        coins = dp[-1] * i - p * i\n        if coins > ans:\n            ans = coins\n\n    print(ans)\n\nif __name__ == '__main__':\n    solve()"}
{"solution": "from collections import defaultdict\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef solve():\n    n = int(input())\n    s = []\n    c = []\n    for _ in range(n):\n        si, ci = input().split()\n        s.append(si)\n        c.append(int(ci))\n\n    odd = []\n    even = []\n    for i in range(n):\n        if len(s[i]) % 2 == 1:\n            odd.append((s[i], c[i]))\n        else:\n            even.append((s[i], c[i]))\n\n    odd.sort(key=lambda x: x[1])\n    even.sort(key=lambda x: x[1])\n\n    odd_palindrome = []\n    odd_non_palindrome = []\n    for si, ci in odd:\n        if is_palindrome(si):\n            odd_palindrome.append((si, ci))\n        else:\n            odd_non_palindrome.append((si, ci))\n\n    even_palindrome = []\n    even_non_palindrome = []\n    for si, ci in even:\n        if is_palindrome(si):\n            even_palindrome.append((si, ci))\n        else:\n            even_non_palindrome.append((si, ci))\n\n    odd_non_palindrome_dict = defaultdict(list)\n    for si, ci in odd_non_palindrome:\n        odd_non_palindrome_dict[si].append(ci)\n\n    even_non_palindrome_dict = defaultdict(list)\n    for si, ci in even_non_palindrome:\n        even_non_palindrome_dict[si].append(ci)\n\n    odd_non_palindrome = []\n    for si, cis in odd_non_palindrome_dict.items():\n        odd_non_palindrome.append((si, min(cis)))\n\n    even_non_palindrome = []\n    for si, cis in even_non_palindrome_dict.items():\n        even_non_palindrome.append((si, min(cis)))\n\n    odd_non_palindrome.sort(key=lambda x: x[1])\n    even_non_palindrome.sort(key=lambda x: x[1])\n\n    odd_non_palindrome_pairs = []\n    for i in range(len(odd_non_palindrome)):\n        for j in range(i + 1, len(odd_non_palindrome)):\n            si1, ci1 = odd_non_palindrome[i]\n            si2, ci2 = odd_non_palindrome[j]\n            if si1 == si2[::-1]:\n                odd_non_palindrome_pairs.append((ci1 + ci2, si1, si2))\n\n    even_non_palindrome_pairs = []\n    for i in range(len(even_non_palindrome)):\n        for j in range(i + 1, len(even_non_palindrome)):\n            si1, ci1 = even_non_palindrome[i]\n            si2, ci2 = even_non_palindrome[j]\n            if si1 == si2[::-1]:\n                even_non_palindrome_pairs.append((ci1 + ci2, si1, si2))\n\n    odd_non_palindrome_pairs.sort()\n    even_non_palindrome_pairs.sort()\n\n    odd_palindrome_cost = sum([ci for si, ci in odd_palindrome])\n    even_palindrome_cost = sum([ci for si, ci in even_palindrome])\n\n    odd_non_palindrome_cost = float('inf')\n    if odd_non_palindrome_pairs:\n        odd_non_palindrome_cost = odd_non_palindrome_pairs[0][0]\n\n    even_non_palindrome_cost = float('inf')\n    if even_non_palindrome_pairs:\n        even_non_palindrome_cost = even_non_palindrome_pairs[0][0]\n\n    if not odd_palindrome and not even_palindrome and not odd_non_palindrome_pairs and not even_non_palindrome_pairs:\n        print(-1)\n    else:\n        print(min(odd_palindrome_cost, even_palindrome_cost, odd_non_palindrome_cost, even_non_palindrome_cost))\n\nsolve()"}
{"solution": "def largest_xor_sum():\n    n, k = map(int, input().split())\n    num_bits = n.bit_length()\n    max_xor_sum = (1 << num_bits) - 1\n    print(max_xor_sum)\n\nlargest_xor_sum()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef solve():\n    n = read_int()\n    points = [tuple(read_ints()) for _ in range(n)]\n\n    max_x = max(x for x, y in points)\n    max_y = max(y for x, y in points)\n\n    def check(side):\n        if side >= max_x and side >= max_y:\n            return True\n        if side < max_x:\n            return False\n        x, y = 0, side\n        for px, py in points:\n            if px > x and py > y:\n                return False\n            if px > x:\n                x = px\n            if py > y:\n                y = py\n        return True\n\n    lo, hi = 0, max(max_x, max_y) + 1\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if check(mid):\n            hi = mid\n        else:\n            lo = mid + 1\n\n    return lo\n\nprint(solve())"}
{"solution": "def max_nineteens(s):\n    from collections import Counter\n    \n    char_count = Counter(s)\n    required_counts = {'n': 3, 'i': 1, 'e': 3, 't': 1}\n    \n    max_nineteens = float('inf')\n    for char, required in required_counts.items():\n        if char in char_count:\n            max_nineteens = min(max_nineteens, char_count[char] // required)\n        else:\n            return 0\n    \n    return max_nineteens\n\ns = input()\nprint(max_nineteens(s))"}
{"solution": "def highest_branch(p, y):\n    \"\"\"\n    Find the highest branch that cannot be reached by any of the grasshoppers.\n\n    Args:\n    p (int): The highest branch occupied by a grasshopper.\n    y (int): The total number of branches.\n\n    Returns:\n    int: The highest branch that cannot be reached by any of the grasshoppers, or -1 if no such branch exists.\n    \"\"\"\n    # Initialize the highest branch to y\n    highest = y\n\n    # Iterate over each branch occupied by a grasshopper\n    for x in range(2, p + 1):\n        # Calculate the highest branch that can be reached by the grasshopper at branch x\n        reachable = x * (y // x)\n\n        # If the highest branch is reachable, update it\n        if reachable >= highest:\n            highest = reachable - 1\n\n    # If the highest branch is less than 2, return -1\n    if highest < 2:\n        return -1\n\n    # Return the highest branch\n    return highest\n\n\n# Read the input\np, y = map(int, input().split())\n\n# Print the output\nprint(highest_branch(p, y))"}
{"solution": "def min_distance(n, m, k, houses):\n    \"\"\"\n    Calculate the minimum distance from the girl's house to a house Zane can afford.\n\n    Args:\n    n (int): The number of houses in the village.\n    m (int): The house where the girl lives.\n    k (int): The amount of money Zane has.\n    houses (list): A list of integers representing the availability and prices of the houses.\n\n    Returns:\n    int: The minimum distance from the girl's house to a house Zane can afford.\n    \"\"\"\n    min_dist = float('inf')  # Initialize minimum distance as infinity\n\n    # Check houses to the left of the girl's house\n    for i in range(m - 1, -1, -1):\n        if houses[i]!= 0 and houses[i] <= k:\n            min_dist = min(min_dist, (m - i - 1) * 10)\n\n    # Check houses to the right of the girl's house\n    for i in range(m, n):\n        if houses[i]!= 0 and houses[i] <= k:\n            min_dist = min(min_dist, (i - m) * 10)\n\n    return min_dist\n\n\n# Read input\nn, m, k = map(int, input().split())\nhouses = list(map(int, input().split()))\n\n# Calculate and print the minimum distance\nprint(min_distance(n, m, k, houses))"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    b = [list(map(int, input().split())) for _ in range(n)]\n\n    if n == 1 and m == 1:\n        print(\"YES\" if a[0][0] == b[0][0] else \"NO\")\n        return\n\n    if n == 1:\n        print(\"YES\" if sorted(a[0]) == sorted(b[0]) else \"NO\")\n        return\n\n    if m == 1:\n        print(\"YES\" if sorted([row[0] for row in a]) == sorted([row[0] for row in b]) else \"NO\")\n        return\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j]!= b[i][j] and a[j][i]!= b[i][j]:\n                print(\"NO\")\n                return\n\n    print(\"YES\")\n\nsolve()"}
{"solution": "def longest_uncommon_subsequence(a, b):\n    if a == b:\n        return -1\n    else:\n        return max(len(a), len(b))\n\na = input()\nb = input()\n\nprint(longest_uncommon_subsequence(a, b))"}
{"solution": "def find_intersection(a, b, c, d):\n    \"\"\"\n    Find the first time Rick and Morty will scream at the same time.\n\n    Args:\n    a (int): The interval at which Rick screams.\n    b (int): The initial time at which Rick screams.\n    c (int): The interval at which Morty screams.\n    d (int): The initial time at which Morty screams.\n\n    Returns:\n    int: The first time Rick and Morty will scream at the same time, or -1 if they will never scream at the same time.\n    \"\"\"\n    # Calculate the least common multiple of a and c\n    lcm = (a * c) // gcd(a, c)\n\n    # Initialize the time at which Rick screams\n    rick_time = b\n\n    # Initialize the time at which Morty screams\n    morty_time = d\n\n    # Loop until we find a common time or we exceed the maximum possible time\n    while rick_time <= 10000 and morty_time <= 10000:\n        # Check if Rick and Morty scream at the same time\n        if rick_time == morty_time:\n            return rick_time\n\n        # Move to the next time Rick screams\n        if rick_time < morty_time:\n            rick_time += lcm\n        # Move to the next time Morty screams\n        else:\n            morty_time += lcm\n\n    # If we exit the loop without finding a common time, return -1\n    return -1\n\n\ndef gcd(a, b):\n    \"\"\"\n    Calculate the greatest common divisor of two numbers.\n\n    Args:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: The greatest common divisor of a and b.\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\n\n# Read the input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Find and print the first time Rick and Morty will scream at the same time\nprint(find_intersection(a, b, c, d))"}
{"solution": "def split_number(n):\n    if n % 3 == 0:\n        return [1, (n - 1) // 3, (n - 1) // 3 + 1]\n    elif n % 3 == 1:\n        return [(n - 1) // 3, (n - 1) // 3, (n - 1) // 3 + 1]\n    else:\n        return [(n - 2) // 3 + 1, (n - 2) // 3 + 1, (n - 2) // 3]\n\nn = int(input())\nprint(*split_number(n))"}
{"solution": "def calculate_squares(n, a, b, c, d):\n    \"\"\"\n    Calculate the number of distinct squares that satisfy all the conditions.\n\n    Args:\n    n (int): Maximum possible value of an integer in the cell.\n    a (int): First known integer.\n    b (int): Second known integer.\n    c (int): Third known integer.\n    d (int): Fourth known integer.\n\n    Returns:\n    int: Number of distinct valid squares.\n    \"\"\"\n    total_sum = a + b + c + d\n    if total_sum % 2!= 0:\n        return 0\n\n    target_sum = total_sum // 2\n    if a + b > target_sum or c + d > target_sum:\n        return 0\n\n    count = 0\n    for x in range(1, n + 1):\n        for y in range(1, n + 1):\n            if x + y == target_sum - a:\n                for z in range(1, n + 1):\n                    if x + z == target_sum - d:\n                        w = target_sum - y - z\n                        if w >= 1 and w <= n:\n                            count += 1\n    return count\n\n\nn, a, b, c, d = map(int, input().split())\nprint(calculate_squares(n, a, b, c, d))"}
{"solution": "def calculate_snowball_weight():\n    # Read initial snowball weight and height\n    w, h = map(int, input().split())\n\n    # Read stone weights and heights\n    u1, d1 = map(int, input().split())\n    u2, d2 = map(int, input().split())\n\n    # Initialize current height\n    current_height = h\n\n    # Simulate snowball movement\n    while current_height > 0:\n        # Increase snowball weight by current height\n        w += current_height\n\n        # Check if snowball hits a stone\n        if current_height == d1:\n            w -= u1\n            if w < 0:\n                w = 0\n        elif current_height == d2:\n            w -= u2\n            if w < 0:\n                w = 0\n\n        # Move snowball one meter down\n        current_height -= 1\n\n    return w\n\n# Print final snowball weight\nprint(calculate_snowball_weight())"}
{"solution": "def find_passing_rate(m, scores, x, y):\n    total_students = sum(scores)\n    prefix_sum = [0] * (m + 1)\n    for i in range(m):\n        prefix_sum[i + 1] = prefix_sum[i] + scores[i]\n\n    for k in range(1, m + 1):\n        beginner_group_size = prefix_sum[k]\n        intermediate_group_size = total_students - beginner_group_size\n        if x <= beginner_group_size <= y and x <= intermediate_group_size <= y:\n            return k\n\n    return 0\n\n\nm = int(input())\nscores = list(map(int, input().split()))\nx, y = map(int, input().split())\n\nprint(find_passing_rate(m, scores, x, y))"}
{"solution": "import math\n\ndef min_coins(n, k, A, B):\n    if k == 1:\n        return (n - 1) * A\n\n    coins = 0\n    while n > 1:\n        if n % k == 0:\n            if (n - 1) * A < B:\n                n -= 1\n                coins += A\n            else:\n                n //= k\n                coins += B\n        else:\n            if (k - (n % k)) * A < B:\n                n -= (n % k)\n                coins += (n % k) * A\n            else:\n                n -= 1\n                coins += A\n\n    return coins\n\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\nprint(min_coins(n, k, A, B))"}
{"solution": "import math\n\ndef prime_factors(n):\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef solve(n):\n    factors = prime_factors(n)\n    unique_factors = set(factors)\n    min_n = 1\n    for factor in unique_factors:\n        if factors.count(factor) % 2 == 1:\n            min_n *= factor\n    operations = 0\n    while n > min_n:\n        sqrt_n = math.isqrt(n)\n        if sqrt_n ** 2 == n:\n            n = sqrt_n\n            operations += 1\n        else:\n            n *= sqrt_n\n            operations += 1\n    return min_n, operations\n\nn = int(input())\nmin_n, operations = solve(n)\nprint(min_n, operations)"}
{"solution": "def max_score(N, K, R, S, P, T):\n    scores = {'r': P,'s': R, 'p': S}\n    last_used = {'r': -1,'s': -1, 'p': -1}\n    total_score = 0\n\n    for i, c in enumerate(T):\n        for hand in 'rsp':\n            if (c == 'r' and hand == 'p') or (c =='s' and hand == 'r') or (c == 'p' and hand =='s'):\n                if last_used[hand] < i - K:\n                    last_used[hand] = i\n                    total_score += scores[hand]\n                    break\n\n    return total_score\n\n\nN, K = map(int, input().split())\nR, S, P = map(int, input().split())\nT = input()\n\nprint(max_score(N, K, R, S, P, T))"}
{"solution": "def longest_good_string(a, b, c):\n    # Calculate the minimum number of 'ab' strings that can be used\n    min_ab = min(a, b)\n    used_ab = min(min_ab, c)\n    \n    # Calculate the remaining 'a' and 'b' strings\n    remaining_a = a - used_ab\n    remaining_b = b - used_ab\n    \n    # Calculate the total length of the good string\n    total_length = used_ab * 2 + min(remaining_a, remaining_b) * 2 + abs(remaining_a - remaining_b)\n    \n    return total_length\n\na, b, c = map(int, input().split())\nprint(longest_good_string(a, b, c))"}
{"solution": "def solve(n, k, p, x, y, a):\n    a.sort()\n    remaining_tests = n - k\n    total_marks = sum(a)\n    median_index = (n + 1) // 2\n\n    # Calculate the maximum marks Vova can get\n    max_marks = x - total_marks\n\n    # If max_marks is less than 0, it's impossible to get the desired result\n    if max_marks < 0:\n        return [-1]\n\n    # Calculate the minimum marks Vova needs to get to achieve the desired median\n    min_marks = (median_index - k) * y\n\n    # If min_marks is more than max_marks, it's impossible to get the desired result\n    if min_marks > max_marks:\n        return [-1]\n\n    # Calculate the marks Vova needs to get for the remaining tests\n    marks = [y] * (median_index - k)\n    remaining_marks = max_marks - min_marks\n    for i in range(len(marks)):\n        if remaining_marks > 0:\n            marks[i] += min(remaining_marks, p - y)\n            remaining_marks -= min(remaining_marks, p - y)\n\n    # Fill the rest of the marks with the minimum possible value\n    marks += [1] * (remaining_tests - len(marks))\n\n    return marks\n\n\nn, k, p, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\nresult = solve(n, k, p, x, y, a)\nprint(*result)"}
{"solution": "def is_berlanese(word):\n    vowels = 'aeiou'\n    for i in range(len(word) - 1):\n        if word[i] not in vowels and word[i]!= 'n' and word[i + 1] not in vowels:\n            return 'NO'\n        if word[i] in vowels and word[i + 1] not in vowels + 'n' and i == len(word) - 2:\n            return 'NO'\n    if word[-1] not in vowels and word[-1]!= 'n':\n        return 'NO'\n    return 'YES'\n\nword = input()\nprint(is_berlanese(word))"}
{"solution": ""}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, m = read_ints()\n    prices = list(read_ints())\n    auction_questions = list(read_ints())\n\n    auction_questions = [q - 1 for q in auction_questions]\n    auction_questions.sort(key=lambda q: prices[q], reverse=True)\n\n    points = 0\n    for i in range(n):\n        if i in auction_questions:\n            points += prices[i]\n            prices[i] = points\n        else:\n            points += prices[i]\n\n    print(points)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_score(max_points, submission_time, wrong_submissions):\n    \"\"\"Calculate the score for a single problem.\"\"\"\n    score = max(0.3 * max_points, (1 - submission_time / 250) * max_points - 50 * wrong_submissions)\n    return int(score)\n\n\ndef main():\n    # Read submission times\n    submission_times = list(map(int, input().split()))\n\n    # Read wrong submissions\n    wrong_submissions = list(map(int, input().split()))\n\n    # Read hack information\n    successful_hacks, unsuccessful_hacks = map(int, input().split())\n\n    # Define maximum points for each problem\n    max_points = [500, 1000, 1500, 2000, 2500]\n\n    # Calculate score for each problem\n    problem_scores = [calculate_score(max_points[i], submission_times[i], wrong_submissions[i]) for i in range(5)]\n\n    # Calculate total score\n    total_score = sum(problem_scores) + 100 * successful_hacks - 50 * unsuccessful_hacks\n\n    print(total_score)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 998244353\n\ndef pow_mod(a, b):\n    res = 1\n    while b:\n        if b & 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b >>= 1\n    return res\n\ndef inv(a):\n    return pow_mod(a, MOD - 2)\n\ndef main():\n    n, m, L, R = map(int, input().split())\n    if (n * m) % 2 == 1:\n        print(0)\n        return\n    if n % 2 == 1 and m % 2 == 1:\n        print(0)\n        return\n    if n % 2 == 1:\n        n, m = m, n\n    if m % 2 == 1:\n        print(0)\n        return\n    ans = 0\n    for i in range(L, R + 1, 2):\n        ans = (ans + pow_mod(R - i + 1, n * m // 2)) % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_possible_to_make_increasing(n, m, matrix_a, matrix_b):\n    for i in range(n):\n        for j in range(m):\n            # Ensure that matrix_a[i][j] is the smaller or equal element\n            if matrix_a[i][j] > matrix_b[i][j]:\n                matrix_a[i][j], matrix_b[i][j] = matrix_b[i][j], matrix_a[i][j]\n    \n    # Check rows for strictly increasing property\n    for i in range(n):\n        for j in range(1, m):\n            if matrix_a[i][j] <= matrix_a[i][j-1] or matrix_b[i][j] <= matrix_b[i][j-1]:\n                return \"Impossible\"\n    \n    # Check columns for strictly increasing property\n    for j in range(m):\n        for i in range(1, n):\n            if matrix_a[i][j] <= matrix_a[i-1][j] or matrix_b[i][j] <= matrix_b[i-1][j]:\n                return \"Impossible\"\n    \n    return \"Possible\"\n\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\nmatrix_b = [list(map(int, input().split())) for _ in range(n)]\n\nprint(is_possible_to_make_increasing(n, m, matrix_a, matrix_b))"}
{"solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    a.sort(reverse=True)\n    ans = 0\n    used = set()\n    for i in range(n):\n        for j in range(a[i], -1, -1):\n            if j not in used:\n                ans += j\n                used.add(j)\n                break\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import heapq\n\ndef min_problems_to_solve(n, k, difficulties):\n    \"\"\"\n    Calculate the minimum number of problems Makes should solve on other judges\n    in order to solve all the chosen problems from Decoforces.\n\n    Args:\n    n (int): The number of problems Makes has chosen to solve on Decoforces.\n    k (int): The maximum difficulty of problems Makes has already solved.\n    difficulties (list): A list of difficulties of the problems Makes has chosen to solve on Decoforces.\n\n    Returns:\n    int: The minimum number of problems Makes should solve on other judges.\n    \"\"\"\n    # Create a max heap to store the difficulties of the problems\n    max_heap = [-difficulty for difficulty in difficulties]\n    heapq.heapify(max_heap)\n\n    # Initialize the count of problems to solve on other judges\n    count = 0\n\n    # While the max heap is not empty\n    while max_heap:\n        # Get the maximum difficulty from the heap\n        max_difficulty = -heapq.heappop(max_heap)\n\n        # If the maximum difficulty is greater than k\n        if max_difficulty > k:\n            # Calculate the difficulty needed to solve the problem\n            needed_difficulty = (max_difficulty + 1) // 2\n\n            # If the needed difficulty is greater than k\n            if needed_difficulty > k:\n                # Increment the count of problems to solve on other judges\n                count += 1\n\n                # Update k to the needed difficulty\n                k = needed_difficulty\n\n            # Push the maximum difficulty back into the heap\n            heapq.heappush(max_heap, -max_difficulty)\n\n        # If the maximum difficulty is not greater than k\n        else:\n            # Continue to the next problem\n            continue\n\n    # Return the count of problems to solve on other judges\n    return count\n\n\n# Read the input\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Calculate and print the minimum number of problems to solve on other judges\nprint(min_problems_to_solve(n, k, difficulties))"}
{"solution": "n = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\nfirst = min(max_1, n - min_2 - min_3)\nsecond = min(max_2, n - first - min_3)\nthird = n - first - second\n\nprint(first, second, third)"}
{"solution": "def moon_phase(n, observations):\n    moon_cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    current_index = moon_cycle.index(observations[0])\n    next_index = (current_index + n) % len(moon_cycle)\n    next_moon_size = moon_cycle[next_index]\n    current_moon_size = observations[-1]\n\n    if next_moon_size > current_moon_size:\n        return \"UP\"\n    elif next_moon_size < current_moon_size:\n        return \"DOWN\"\n    else:\n        return \"-1\"\n\nn = int(input())\nobservations = list(map(int, input().split()))\nprint(moon_phase(n, observations))"}
{"solution": "def can_transform(s, t):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    # Check if lengths are the same\n    if len(s)!= len(t):\n        return \"No\"\n    \n    # Check each character\n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels)!= (char_t in vowels):\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(can_transform(s, t))"}
{"solution": "def determine_winner(board):\n    min_white_steps = float('inf')\n    min_black_steps = float('inf')\n\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'W':\n                min_white_steps = min(min_white_steps, 8 - i - 1)\n            elif board[i][j] == 'B':\n                min_black_steps = min(min_black_steps, i)\n\n    return 'A' if min_white_steps <= min_black_steps else 'B'\n\nboard = [input() for _ in range(8)]\nprint(determine_winner(board))"}
{"solution": "def max_equal_length(n, A, m, B):\n    if sum(A)!= sum(B):\n        return -1\n    \n    i, j = 0, 0\n    sumA, sumB = 0, 0\n    count = 0\n    \n    while i < n and j < m:\n        sumA += A[i]\n        sumB += B[j]\n        \n        if sumA == sumB:\n            count += 1\n            sumA = 0\n            sumB = 0\n            i += 1\n            j += 1\n        elif sumA < sumB:\n            i += 1\n        else:\n            j += 1\n    \n    return count\n\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\nprint(max_equal_length(n, A, m, B))"}
{"solution": "def check_problem_name(problem_name):\n    friends_names = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    count = 0\n\n    for friend_name in friends_names:\n        if problem_name.count(friend_name) == 1:\n            count += 1\n\n    return \"YES\" if count == 1 else \"NO\"\n\nproblem_name = input()\nprint(check_problem_name(problem_name))"}
{"solution": "def sieve(n):\n    is_prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (is_prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n    is_prime[0], is_prime[1] = False, False  # 0 and 1 are not primes\n    return is_prime\n\ndef count_primes_in_range(is_prime, a, b):\n    prime_count = [0] * (b + 1)\n    for i in range(a, b + 1):\n        prime_count[i] = prime_count[i - 1] + (1 if is_prime[i] else 0)\n    return prime_count\n\ndef min_length_with_k_primes(a, b, k):\n    is_prime = sieve(b)\n    prime_count = count_primes_in_range(is_prime, a, b)\n    \n    def has_k_primes_in_length(l):\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] >= k:\n                return True\n        return False\n    \n    left, right = 1, b - a + 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if has_k_primes_in_length(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\na, b, k = map(int, input().split())\nprint(min_length_with_k_primes(a, b, k))"}
{"solution": "import math\n\ndef calculate_x(a, h, w):\n    min_x = float('inf')\n\n    for n in range(1, math.ceil(w / a) + 1):\n        m = math.floor((w - n * a) / (n + 1))\n        if m < 0:\n            continue\n        x = (w - n * a - m) / (n + 1)\n\n        if x >= 0 and h >= a + 2 * x:\n            min_x = min(min_x, x)\n\n    for m in range(1, math.ceil(h / a) + 1):\n        n = math.floor((h - m * a) / (m + 1))\n        if n < 0:\n            continue\n        x = (h - m * a - n) / (m + 1)\n\n        if x >= 0 and w >= a + 2 * x:\n            min_x = min(min_x, x)\n\n    if min_x == float('inf'):\n        return -1\n    else:\n        return min_x\n\na, h, w = map(int, input().split())\nprint(calculate_x(a, h, w))"}
{"solution": "def count_unread_chapters():\n    n = int(input())\n    chapters = [list(map(int, input().split())) for _ in range(n)]\n    k = int(input())\n\n    unread_chapters = 0\n    for start, end in chapters:\n        if start >= k:\n            unread_chapters += 1\n        elif end >= k:\n            unread_chapters += 1\n            break\n\n    print(unread_chapters)\n\ncount_unread_chapters()"}
{"solution": "def can_form_codeforces(word):\n    target = \"CODEFORCES\"\n    n = len(word)\n    m = len(target)\n    \n    if n < m:\n        return \"NO\"\n    \n    for i in range(m + 1):\n        if word[:i] == target[:i] and word[n - (m - i):] == target[i:]:\n            return \"YES\"\n    \n    return \"NO\"\n\nword = input()\nprint(can_form_codeforces(word))"}
{"solution": "import sys\n\ndef min_weight(n):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][i] = 0\n        dp[i][i + 1] = i * (i + 1) * (i + 2)\n    for length in range(3, n + 1):\n        for i in range(1, n - length + 2):\n            j = i + length - 1\n            dp[i][j] = sys.maxsize\n            for k in range(i + 1, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + i * k * j)\n    return dp[1][n]\n\nn = int(input())\nprint(min_weight(n))"}
{"solution": "def count_digits(n):\n    digits = 0\n    i = 1\n    while i <= n:\n        digits += len(str(i))\n        i += 1\n    return digits\n\nn = int(input())\nprint(count_digits(n))"}
{"solution": "def find_winning_color(n, A, cars):\n    \"\"\"\n    Find a color that Bob can choose to win the game.\n\n    Args:\n    n (int): The number of cars.\n    A (int): The color chosen by Alice.\n    cars (list): A list of colors of the cars in the order of their appearance.\n\n    Returns:\n    int: A color that Bob can choose to win the game, or -1 if no such color exists.\n    \"\"\"\n    # Initialize a dictionary to store the count of each color\n    color_count = {}\n    for car in cars:\n        if car not in color_count:\n            color_count[car] = 0\n        color_count[car] += 1\n\n    # Initialize variables to store the maximum count and the corresponding color\n    max_count = 0\n    winning_color = -1\n\n    # Iterate over each color and its count\n    for color, count in color_count.items():\n        # Skip the color chosen by Alice\n        if color == A:\n            continue\n\n        # Initialize variables to store the count of the current color and the color chosen by Alice\n        curr_count = 0\n        alice_count = 0\n\n        # Iterate over each car\n        for car in cars:\n            # Increment the count of the current color if it matches the car's color\n            if car == color:\n                curr_count += 1\n            # Increment the count of the color chosen by Alice if it matches the car's color\n            if car == A:\n                alice_count += 1\n\n            # If the count of the current color is less than the count of the color chosen by Alice, break the loop\n            if curr_count < alice_count:\n                break\n\n        # If the loop completes without breaking, it means the current color is a potential winning color\n        else:\n            # If the count of the current color is greater than the maximum count, update the maximum count and the winning color\n            if curr_count > max_count:\n                max_count = curr_count\n                winning_color = color\n\n    # Return the winning color\n    return winning_color\n\n\n# Read the input\nn, A = map(int, input().split())\ncars = list(map(int, input().split()))\n\n# Find and print the winning color\nprint(find_winning_color(n, A, cars))"}
{"solution": "def is_unique_crossword(n, x, a):\n    total_length = sum(a)\n    if total_length > x:\n        return False\n    if total_length == x:\n        return n == 1\n    if n == 1:\n        return False\n    if x - total_length - (n - 1) > 1:\n        return False\n    return True\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\nif is_unique_crossword(n, x, a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\nn, S = map(int, input().split())\nprint(math.ceil(S / n) if S % n!= 0 else S // n)"}
{"solution": "def lexicographically_smallest_palindrome(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    middle_char = ''\n    first_half = ''\n    for char in sorted(char_count.keys()):\n        count = char_count[char]\n        if count % 2 == 1:\n            if middle_char:\n                first_half += char * (count // 2)\n            else:\n                middle_char = char\n                first_half += char * (count // 2)\n        else:\n            first_half += char * (count // 2)\n\n    return first_half + middle_char + first_half[::-1]\n\ns = input()\nprint(lexicographically_smallest_palindrome(s))"}
{"solution": "def calculate_weight(board):\n    piece_weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n    }\n    \n    white_weight = 0\n    black_weight = 0\n    \n    for row in board:\n        for piece in row:\n            if piece in piece_weights:\n                if piece.isupper():\n                    white_weight += piece_weights[piece]\n                else:\n                    black_weight += piece_weights[piece]\n    \n    if white_weight > black_weight:\n        return \"White\"\n    elif black_weight > white_weight:\n        return \"Black\"\n    else:\n        return \"Draw\"\n\nboard = [input() for _ in range(8)]\nprint(calculate_weight(board))"}
{"solution": "import heapq\n\ndef solve(N, M, S):\n    S = [int(x) for x in S]\n    dist = [float('inf')] * (N + 1)\n    prev = [-1] * (N + 1)\n    dist[0] = 0\n    queue = [(0, 0)]\n    while queue:\n        d, u = heapq.heappop(queue)\n        if d > dist[u]:\n            continue\n        for v in range(u + 1, min(u + M + 1, N + 1)):\n            if S[v] == 1:\n                continue\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                prev[v] = u\n                heapq.heappush(queue, (dist[v], v))\n    if dist[N] == float('inf'):\n        return -1\n    path = []\n    u = N\n    while u!= 0:\n        path.append(u - prev[u])\n        u = prev[u]\n    return''.join(map(str, reversed(path)))\n\nN, M = map(int, input().split())\nS = input()\nprint(solve(N, M, S))"}
{"solution": "import math\n\ndef manhattan_distance(x1, y1, x2, y2):\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef find_path(K, X, Y):\n    if manhattan_distance(0, 0, X, Y) % K!= 0:\n        return -1\n\n    steps = []\n    current_x, current_y = 0, 0\n\n    while (current_x, current_y)!= (X, Y):\n        if current_x == X:\n            if current_y < Y:\n                new_y = current_y + K\n                steps.append((X, new_y))\n                current_y = new_y\n            else:\n                new_y = current_y - K\n                steps.append((X, new_y))\n                current_y = new_y\n        elif current_y == Y:\n            if current_x < X:\n                new_x = current_x + K\n                steps.append((new_x, Y))\n                current_x = new_x\n            else:\n                new_x = current_x - K\n                steps.append((new_x, Y))\n                current_x = new_x\n        else:\n            if abs(X - current_x) >= K:\n                new_x = current_x + K if X > current_x else current_x - K\n                new_y = current_y\n                steps.append((new_x, new_y))\n                current_x = new_x\n            else:\n                new_x = current_x\n                new_y = current_y + K if Y > current_y else current_y - K\n                steps.append((new_x, new_y))\n                current_y = new_y\n\n    return steps\n\ndef main():\n    K = int(input())\n    X, Y = map(int, input().split())\n\n    result = find_path(K, X, Y)\n\n    if result == -1:\n        print(-1)\n    else:\n        print(len(result))\n        for step in result:\n            print(step[0], step[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_smallest_n(m):\n    def count_ways(n):\n        count = 0\n        for k in range(2, n + 1):\n            a = 1\n            total = 0\n            for _ in range(4):\n                total += a\n                a *= k\n                if total > n:\n                    break\n            else:\n                count += 1\n        return count\n\n    n = 1\n    while True:\n        ways = count_ways(n)\n        if ways == m:\n            return n\n        elif ways > m:\n            return -1\n        n += 1\n\nm = int(input())\nprint(find_smallest_n(m))"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    if d >= r1 + r2:\n        return 0\n    elif d <= abs(r1 - r2):\n        r_min = min(r1, r2)\n        return math.pi * r_min ** 2\n    else:\n        a = (r1 ** 2 - r2 ** 2 + d ** 2) / (2 * d)\n        h = math.sqrt(r1 ** 2 - a ** 2)\n        area = r1 ** 2 * math.acos(a / r1) - a * h + r2 ** 2 * math.acos((d - a) / r2) - (d - a) * h\n        return area\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\nprint(circle_intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "def min_value(n):\n    if n == 1:\n        return 1\n    elif n % 2 == 0:\n        return 1 if n > 4 else n\n    else:\n        return 1 if n > 3 else n\n\nv = int(input())\nprint(min_value(v))"}
{"solution": "from collections import defaultdict\n\ndef dfs(graph, a, dp, i):\n    if dp[i]!= -1:\n        return dp[i]\n    if not graph[i]:\n        dp[i] = a[i]\n        return a[i]\n    dp[i] = a[i]\n    for j in graph[i]:\n        dp[i] = min(dp[i], dfs(graph, a, dp, j))\n    return dp[i]\n\ndef solve():\n    n = int(input())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    graph = defaultdict(list)\n    for i in range(n-1):\n        graph[p[i]].append(i+2)\n    dp = [-1] * (n+1)\n    print(dfs(graph, a, dp, 1))\n\nsolve()"}
{"solution": "def count_typo_words(n, S, T):\n    count = 0\n    for i in range(n + 1):\n        # Construct W by inserting a character at position i in both S and T\n        if i == 0:\n            W1 = S[0] + S\n            W2 = T[0] + T\n        elif i == n:\n            W1 = S + S[-1]\n            W2 = T + T[-1]\n        else:\n            W1 = S[:i] + S[i] + S[i:]\n            W2 = T[:i] + T[i] + T[i:]\n        \n        # Check if the constructed words are the same\n        if W1 == W2:\n            count += 1\n    \n    return count\n\nn = int(input())\nS = input().strip()\nT = input().strip()\nprint(count_typo_words(n, S, T))"}
{"solution": "import sys\nfrom collections import deque, defaultdict\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(input())\n\ndef read_ints():\n    return map(int, input().split())\n\ndef solve():\n    n = read_int()\n    a = list(read_ints())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = read_ints()\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    def is_possible(strength):\n        q = deque()\n        visited = [False] * n\n        for i in range(n):\n            if a[i] <= strength:\n                q.append(i)\n                visited[i] = True\n\n        while q:\n            u = q.popleft()\n            for v in graph[u]:\n                if not visited[v]:\n                    a[v] += 1\n                    if a[v] <= strength:\n                        q.append(v)\n                        visited[v] = True\n\n        return all(visited)\n\n    low, high = min(a), max(a)\n    while low < high:\n        mid = (low + high) // 2\n        if is_possible(mid):\n            high = mid\n        else:\n            low = mid + 1\n\n    return low\n\nprint(solve())"}
{"solution": "n, m = map(int, input().split())\nprint(min(m, n - m) if m!= n else 0)"}
{"solution": "def min_shovels(k, r):\n    \"\"\"\n    Calculate the minimum number of shovels Polycarp needs to buy to pay without any change.\n\n    Args:\n    k (int): The price of one shovel.\n    r (int): The denomination of the coin in Polycarp's pocket that is different from \"10-burle coins\".\n\n    Returns:\n    int: The minimum number of shovels Polycarp needs to buy.\n    \"\"\"\n    for i in range(1, 11):\n        total_cost = k * i\n        if total_cost % 10 == r:\n            return i\n    return 10\n\nk, r = map(int, input().split())\nprint(min_shovels(k, r))"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # Dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Extract the bounding box\n    piece = []\n    for i in range(min_row, max_row + 1):\n        piece.append(grid[i][min_col:max_col + 1])\n    \n    # Check horizontal placement\n    if width * 2 == m:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j]!= piece[i][j + width]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    # Check vertical placement\n    if height * 2 == n:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j]!= piece[i + height][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "def min_segments():\n    points = [list(map(int, input().split())) for _ in range(3)]\n\n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n\n    if len(set(x_coords)) == 1 or len(set(y_coords)) == 1:\n        return 1\n    elif len(set(x_coords)) == 2 and len(set(y_coords)) == 2:\n        return 2\n    else:\n        return 3\n\nprint(min_segments())"}
{"solution": "def construct_k_regular_graph(k):\n    if k == 1:\n        return 2, [(1, 2)]\n    elif k == 2:\n        return \"NO\"\n    else:\n        n = 2 * k\n        edges = []\n        for i in range(1, k + 1):\n            edges.append((i, i + k))\n            for j in range(1, k):\n                edges.append((i, i + j))\n                edges.append((i + k, i + k + j))\n        edges.append((1, k + 1))\n        return n, edges\n\n\ndef main():\n    k = int(input())\n    result = construct_k_regular_graph(k)\n    if result == \"NO\":\n        print(\"NO\")\n    else:\n        n, edges = result\n        m = len(edges)\n        print(\"YES\")\n        print(n, m)\n        for edge in edges:\n            print(*edge)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def kmp(s, t):\n    n, m = len(s), len(t)\n    lps = [0] * m\n    j = 0\n    for i in range(1, m):\n        while j > 0 and t[i]!= t[j]:\n            j = lps[j - 1]\n        if t[i] == t[j]:\n            j += 1\n        lps[i] = j\n    j = 0\n    count = 0\n    for i in range(n):\n        while j > 0 and s[i]!= t[j]:\n            j = lps[j - 1]\n        if s[i] == t[j]:\n            j += 1\n        if j == m:\n            count += 1\n            j = lps[j - 1]\n    return count\n\ndef solve():\n    n, m, q = map(int, input().split())\n    s = input()\n    t = input()\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + kmp(s[:i + 1], t)\n    for _ in range(q):\n        l, r = map(int, input().split())\n        print(prefix[r] - prefix[l - 1])\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "MOD = 1000000007\n\ndef count_paths(n, k, d):\n    dp = [[[0 for _ in range(k + 1)] for _ in range(n + 1)] for _ in range(2)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            for x in range(1, k + 1):\n                if i - x < 0:\n                    break\n                dp[i % 2][i][j] += dp[(i - 1) % 2][i - x][j - 1]\n                dp[i % 2][i][j] %= MOD\n\n    total = sum(dp[n % 2][n]) % MOD\n    exclude = sum(dp[n % 2][n][:d]) % MOD\n    return (total - exclude) % MOD\n\nn, k, d = map(int, input().split())\nprint(count_paths(n, k, d))"}
{"solution": "def encrypt_japanese_crossword(n, row):\n    groups = []\n    count = 0\n    \n    for char in row:\n        if char == 'B':\n            count += 1\n        else:\n            if count > 0:\n                groups.append(count)\n                count = 0\n    \n    if count > 0:\n        groups.append(count)\n    \n    print(len(groups))\n    if groups:\n        print(\" \".join(map(str, groups)))\n\nn = int(input())\nrow = input().strip()\nencrypt_japanese_crossword(n, row)"}
{"solution": ""}
{"solution": "def find_y():\n    n = int(input())\n    min_val = -2 * 10**9\n    max_val = 2 * 10**9\n\n    for _ in range(n):\n        sign, x, answer = input().split()\n        x = int(x)\n\n        if sign == \">\":\n            if answer == \"Y\":\n                min_val = max(min_val, x + 1)\n            else:\n                max_val = min(max_val, x)\n        elif sign == \"<\":\n            if answer == \"Y\":\n                max_val = min(max_val, x - 1)\n            else:\n                min_val = max(min_val, x)\n        elif sign == \">=\":\n            if answer == \"Y\":\n                min_val = max(min_val, x)\n            else:\n                max_val = min(max_val, x - 1)\n        elif sign == \"<=\":\n            if answer == \"Y\":\n                max_val = min(max_val, x)\n            else:\n                min_val = max(min_val, x + 1)\n\n    if min_val <= max_val:\n        return min_val\n    else:\n        return \"Impossible\"\n\nprint(find_y())"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef solve():\n    a, b = map(int, input().split())\n    if a == b:\n        print(count_divisors(a + b) - 1)\n    else:\n        g = gcd(a, b)\n        print(count_divisors(a + b) - count_divisors(g) + 1)\n\nsolve()"}
{"solution": "def generate_names(n, k, conditions):\n    names = []\n    counter = 0\n    for i in range(n):\n        if i < k - 1:\n            names.append(f\"A{counter}\")\n            counter += 1\n        else:\n            if conditions[i - k + 1] == \"YES\":\n                names.append(f\"A{counter}\")\n                counter += 1\n            else:\n                names.append(names[i - k + 1])\n    return names\n\nn, k = map(int, input().split())\nconditions = input().split()\n\nnames = generate_names(n, k, conditions)\nprint(\" \".join(names))"}
{"solution": "def min_operations_to_equal(a, b):\n    def count_factors(n, factor):\n        count = 0\n        while n % factor == 0:\n            n //= factor\n            count += 1\n        return count, n\n\n    # Count the number of times we can divide by 2, 3, and 5\n    a2, a = count_factors(a, 2)\n    a3, a = count_factors(a, 3)\n    a5, a = count_factors(a, 5)\n    \n    b2, b = count_factors(b, 2)\n    b3, b = count_factors(b, 3)\n    b5, b = count_factors(b, 5)\n    \n    # If the remaining parts are not equal, return -1\n    if a!= b:\n        return -1\n    \n    # Calculate the total number of operations needed\n    operations = abs(a2 - b2) + abs(a3 - b3) + abs(a5 - b5)\n    \n    return operations\n\na, b = map(int, input().split())\nprint(min_operations_to_equal(a, b))"}
{"solution": "def calculate_min_cost(n, a, b, colors):\n    \"\"\"\n    Calculate the minimum cost to form a palindrome.\n\n    Args:\n    n (int): The number of dancers.\n    a (int): The cost of a white suit.\n    b (int): The cost of a black suit.\n    colors (list): A list of integers representing the color of each dancer's suit.\n\n    Returns:\n    int: The minimum cost to form a palindrome, or -1 if it's not possible.\n    \"\"\"\n    total_cost = 0\n    for i in range(n // 2):\n        if colors[i] == colors[n - i - 1]:\n            continue\n        elif colors[i] == 2:\n            if colors[n - i - 1] == 0:\n                total_cost += a\n            elif colors[n - i - 1] == 1:\n                total_cost += b\n            colors[i] = colors[n - i - 1]\n        elif colors[n - i - 1] == 2:\n            if colors[i] == 0:\n                total_cost += a\n            elif colors[i] == 1:\n                total_cost += b\n            colors[n - i - 1] = colors[i]\n        else:\n            return -1\n\n    for i in range(n // 2, n):\n        if colors[i] == 2:\n            if i < n // 2 + n % 2:\n                if colors[n - i - 1] == 0:\n                    total_cost += a\n                elif colors[n - i - 1] == 1:\n                    total_cost += b\n            else:\n                if a < b:\n                    total_cost += a\n                else:\n                    total_cost += b\n\n    return total_cost\n\n\nn, a, b = map(int, input().split())\ncolors = list(map(int, input().split()))\n\nprint(calculate_min_cost(n, a, b, colors))"}
{"solution": "def paint_cube(k):\n    if k == 1:\n        return -1\n\n    cube = []\n    for i in range(k):\n        layer = []\n        for j in range(k):\n            row = []\n            for z in range(k):\n                if (i + j + z) % 2 == 0:\n                    row.append('b')\n                else:\n                    row.append('w')\n            layer.append(''.join(row))\n        cube.append(layer)\n\n    for layer in cube:\n        for row in layer:\n            print(row)\n        print()\n\nk = int(input())\nresult = paint_cube(k)\nif result == -1:\n    print(-1)"}
{"solution": "import math\nfrom collections import Counter\n\ndef largest_lovely_number(n):\n    def prime_factors(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            while (n % i) == 0:\n                factors.append(i)\n                n //= i\n            i += 1\n        if n > 1:\n            factors.append(n)\n        return factors\n\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n    \n    lovely_number = 1\n    for prime, count in factor_counts.items():\n        lovely_number *= prime ** min(count, 1)\n    \n    return lovely_number\n\nn = int(input())\nprint(largest_lovely_number(n))"}
{"solution": "n = int(input())\nseating = input().strip()\n\ndef is_maximal_seating(seating):\n    # Check for adjacent occupied seats\n    for i in range(len(seating) - 1):\n        if seating[i] == '1' and seating[i + 1] == '1':\n            return \"No\"\n    \n    # Check for possible additional seating\n    for i in range(len(seating)):\n        if seating[i] == '0':\n            if (i == 0 or seating[i - 1] == '0') and (i == len(seating) - 1 or seating[i + 1] == '0'):\n                return \"No\"\n    \n    return \"Yes\"\n\nprint(is_maximal_seating(seating))"}
{"solution": "def find_possible_k_values(n, a):\n    possible_k_values = []\n    for k in range(1, n + 1):\n        x = [a[i] - a[i - 1] for i in range(1, k + 1)]\n        is_valid = True\n        for i in range(k + 1, n + 1):\n            if a[i] - a[i - 1]!= x[(i - 1) % k]:\n                is_valid = False\n                break\n        if is_valid:\n            possible_k_values.append(k)\n    return possible_k_values\n\n\nn = int(input())\na = list(map(int, input().split()))\npossible_k_values = find_possible_k_values(n, a)\nprint(len(possible_k_values))\nprint(*possible_k_values)"}
{"solution": "def can_form_equal_teams(scores):\n    total_score = sum(scores)\n    if total_score % 2!= 0:\n        return False\n\n    target_score = total_score // 2\n    scores.sort(reverse=True)\n\n    def dfs(index, current_score, count):\n        if count == 3:\n            return current_score == target_score\n        if current_score > target_score or index >= len(scores):\n            return False\n\n        return dfs(index + 1, current_score + scores[index], count + 1) or dfs(index + 1, current_score, count)\n\n    return dfs(0, 0, 0)\n\n\nscores = list(map(int, input().split()))\nprint(\"YES\" if can_form_equal_teams(scores) else \"NO\")"}
{"solution": "def count_2_3_integers(left, right):\n    \"\"\"\n    Counts the number of 2-3-integers in the given range [left, right].\n    \n    A 2-3-integer is a positive integer that is equal to 2^x * 3^y for some non-negative integers x and y.\n    \n    Args:\n        left (int): The lower bound of the range (inclusive).\n        right (int): The upper bound of the range (inclusive).\n    \n    Returns:\n        int: The number of 2-3-integers in the given range.\n    \"\"\"\n    def count(x):\n        count = 0\n        i = 1\n        while i <= x:\n            j = 1\n            while i * j <= x:\n                count += 1\n                j *= 3\n            i *= 2\n        return count\n\n    return count(right) - count(left - 1)\n\n\nleft, right = map(int, input().split())\nprint(count_2_3_integers(left, right))"}
{"solution": "def calculate_eaten_candies(n, k):\n    \"\"\"\n    Calculate the total number of candies Alya ate.\n\n    Args:\n    n (int): The total number of moves.\n    k (int): The number of candies in the box at the end.\n\n    Returns:\n    int: The total number of candies Alya ate.\n    \"\"\"\n    # Initialize the number of candies put and eaten\n    put = 0\n    eaten = 0\n\n    # Initialize the number of candies in the box\n    box = 0\n\n    # Perform n actions\n    for i in range(n):\n        # If the box is empty, put candies into the box\n        if box == 0:\n            put += 1\n            box += put\n        # If the box is not empty, choose an action randomly\n        else:\n            # If the number of candies in the box is less than or equal to k,\n            # put candies into the box\n            if box <= k:\n                put += 1\n                box += put\n            # If the number of candies in the box is greater than k,\n            # eat a candy from the box\n            else:\n                eaten += 1\n                box -= 1\n\n    # Return the total number of candies Alya ate\n    return eaten\n\n\n# Read the input\nn, k = map(int, input().split())\n\n# Calculate and print the total number of candies Alya ate\nprint(calculate_eaten_candies(n, k))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\nfor i in range(n - 2):\n    if a[i] + a[i + 1] > a[i + 2]:\n        print(\"YES\")\n        sys.exit()\n\nprint(\"NO\")"}
{"solution": "def solve(x, y):\n    if y < 1 or x < 0:\n        return \"No\"\n    if x == 0:\n        return \"Yes\" if y == 1 else \"No\"\n    if y == 1:\n        return \"Yes\" if x == 0 else \"No\"\n    if x < y - 1:\n        return \"No\"\n    return \"Yes\" if (x - (y - 1)) % 2 == 0 else \"No\"\n\nx, y = map(int, input().split())\nprint(solve(x, y))"}
{"solution": "import math\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate the initial total rating\ntotal_rating = sum(math.floor(x / 10) for x in a)\n\n# Create a list of tuples containing the skill value and the number of units needed to reach the next multiple of 10\nunits_needed = [(x, 10 * (math.floor(x / 10) + 1) - x) for x in a]\n\n# Sort the list based on the number of units needed\nunits_needed.sort(key=lambda x: x[1])\n\n# Allocate units to the skills that require the fewest units first\nfor i in range(n):\n    if k >= units_needed[i][1]:\n        k -= units_needed[i][1]\n        total_rating += 1\n    else:\n        break\n\nprint(total_rating)"}
{"solution": "def find_smallest_pretty_integer():\n    n, m = map(int, input().split())\n    list1 = list(map(int, input().split()))\n    list2 = list(map(int, input().split()))\n\n    set1 = set(list1)\n    set2 = set(list2)\n\n    common_digits = set1.intersection(set2)\n    if common_digits:\n        return min(common_digits)\n\n    min1 = min(list1)\n    min2 = min(list2)\n\n    smallest_pretty = min(int(str(min1) + str(min2)), int(str(min2) + str(min1)))\n    return smallest_pretty\n\nprint(find_smallest_pretty_integer())"}
{"solution": "def calculate_problems(n, k):\n    \"\"\"\n    Calculate the maximum number of problems Limak can solve before leaving for the party.\n\n    Args:\n        n (int): The number of problems in the contest.\n        k (int): The number of minutes Limak needs to get to the party from his house.\n\n    Returns:\n        int: The maximum number of problems Limak can solve.\n    \"\"\"\n    total_time = 240  # Total time available in minutes\n    time_left = total_time - k  # Time left for solving problems\n    problems_solved = 0\n    time_spent = 0\n\n    for i in range(1, n + 1):\n        time_required = 5 * i  # Time required to solve the current problem\n        if time_spent + time_required <= time_left:\n            time_spent += time_required\n            problems_solved += 1\n        else:\n            break\n\n    return problems_solved\n\n\nn, k = map(int, input().split())\nprint(calculate_problems(n, k))"}
{"solution": ""}
{"solution": "import math\n\ndef count_divisors(n):\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return len(divisors)\n\nb = int(input().strip())\nresult = count_divisors(b)\nprint(result)"}
{"solution": "def pinball_game(n, bumpers):\n    \"\"\"\n    Calculate the number of positions such that the ball will eventually fall from the game field if it starts at that position.\n\n    Args:\n    n (int): The length of the sequence of bumpers.\n    bumpers (str): A string representing the bumpers' types.\n\n    Returns:\n    int: The number of positions in the sequence such that the ball will eventually fall from the game field if it starts at that position.\n    \"\"\"\n    # Initialize variables to keep track of the number of positions that lead to a fall\n    fall_positions = 0\n\n    # Initialize variables to keep track of the current position and the direction of the ball\n    current_position = 0\n    direction = 1\n\n    # Initialize a set to keep track of visited positions\n    visited = set()\n\n    # Iterate over the bumpers\n    for i in range(n):\n        # If the current position is out of bounds, increment the fall_positions counter\n        if current_position < 0 or current_position >= n:\n            fall_positions += 1\n            # Reset the current position and direction\n            current_position = i\n            direction = 1 if bumpers[i] == '>' else -1\n        # If the current position has been visited before, it means the ball will stay in the game field forever\n        elif current_position in visited:\n            break\n        # Mark the current position as visited\n        visited.add(current_position)\n        # Update the current position based on the direction of the ball\n        current_position += direction\n        # Update the direction of the ball based on the type of the bumper\n        direction = 1 if bumpers[current_position] == '>' else -1\n\n    # Return the total number of positions that lead to a fall\n    return fall_positions\n\n# Read the input\nn = int(input())\nbumpers = input()\n\n# Print the output\nprint(pinball_game(n, bumpers))"}
{"solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    sticks = list(map(int, sys.stdin.readline().split()))\n\n    sticks.sort()\n    sticks.append(0)\n\n    total_area = 0\n    i = 0\n    while i < n:\n        if sticks[i] == sticks[i + 1]:\n            j = i + 2\n            while j < n and sticks[j] == sticks[j + 1]:\n                j += 2\n            if j < n and sticks[j] - 1 == sticks[i]:\n                total_area += sticks[i] * sticks[j]\n                i = j + 1\n            elif j + 1 < n and sticks[j + 1] - 1 == sticks[i]:\n                total_area += sticks[i] * sticks[j + 1]\n                i = j + 2\n            else:\n                i += 2\n        else:\n            if sticks[i + 1] - 1 == sticks[i]:\n                j = i + 2\n                while j < n and sticks[j] == sticks[j + 1]:\n                    j += 2\n                if j < n and sticks[j] == sticks[i]:\n                    total_area += sticks[i] * sticks[j]\n                    i = j + 1\n                elif j + 1 < n and sticks[j + 1] == sticks[i]:\n                    total_area += sticks[i] * sticks[j + 1]\n                    i = j + 2\n                else:\n                    i += 1\n            else:\n                i += 1\n\n    print(total_area)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import defaultdict\n\ndef restore_numbers(n, numbers):\n    # Create a dictionary to store the frequency of each letter\n    freq = defaultdict(int)\n    for num in numbers:\n        for char in num:\n            freq[char] += 1\n\n    # Sort the letters by frequency in descending order\n    sorted_letters = sorted(freq, key=freq.get, reverse=True)\n\n    # Create a dictionary to store the mapping of letters to digits\n    mapping = {}\n    for i, letter in enumerate(sorted_letters):\n        mapping[letter] = str(i)\n\n    # Replace the letters with digits in the numbers\n    restored_numbers = []\n    for num in numbers:\n        restored_num = ''.join(mapping[char] for char in num)\n        restored_numbers.append(int(restored_num))\n\n    # Return the sum of the restored numbers\n    return sum(restored_numbers)\n\n# Read the input\nn = int(input())\nnumbers = [input() for _ in range(n)]\n\n# Print the output\nprint(restore_numbers(n, numbers))"}
{"solution": "def max_teams(n, m):\n    # Calculate the maximum number of teams of type 1 (1 XP, 2 NB)\n    t1 = min(n, m // 2)\n    \n    # Calculate the remaining newbies after forming type 1 teams\n    remaining_nb = m - 2 * t1\n    \n    # Calculate the maximum number of teams of type 2 (2 XP, 1 NB) using the remaining newbies\n    t2 = min((n - t1) // 2, remaining_nb)\n    \n    # Return the total number of teams\n    return t1 + t2\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    n = len(s)\n    \n    # Check for \"AB\" followed by \"BA\"\n    found_AB = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"AB\":\n            found_AB = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"BA\":\n                    print(\"YES\")\n                    return\n            break\n    \n    # Check for \"BA\" followed by \"AB\"\n    found_BA = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"BA\":\n            found_BA = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"AB\":\n                    print(\"YES\")\n                    return\n            break\n    \n    # If neither condition is met\n    print(\"NO\")\n\ns = input().strip()\ncheck_substrings(s)"}
{"solution": ""}
{"solution": "import sys\n\ndef read_input():\n    lines = sys.stdin.readlines()\n    R, B = map(int, lines[0].split())\n    points = []\n    for i in range(1, R + B + 1):\n        x, y = map(int, lines[i].split())\n        points.append((x, y))\n    return R, B, points\n\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # Collinear\n    elif val > 0:\n        return 1  # Clockwise\n    else:\n        return 2  # Counterclockwise\n\ndef intersect(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if (o1!= o2 and o3!= o4):\n        return True\n\n    if (o1 == 0 and on_segment(p1, p2, q1)):\n        return True\n\n    if (o2 == 0 and on_segment(p1, q2, q1)):\n        return True\n\n    if (o3 == 0 and on_segment(p2, p1, q2)):\n        return True\n\n    if (o4 == 0 and on_segment(p2, q1, q2)):\n        return True\n\n    return False\n\ndef on_segment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n        q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\ndef solve(R, B, points):\n    if R!= B:\n        return \"No\"\n\n    for i in range(R):\n        for j in range(i + 1, R):\n            for k in range(R):\n                for l in range(k + 1, R + B):\n                    if intersect(points[i], points[R + k], points[j], points[R + l]):\n                        return \"No\"\n    return \"Yes\"\n\nR, B, points = read_input()\nprint(solve(R, B, points))"}
{"solution": "import math\n\nn = int(input())\na = list(map(int, input().split()))\n\nmax_power = 0\ncount = 0\n\nfor num in a:\n    power = 0\n    while num % 2 == 0:\n        power += 1\n        num //= 2\n    if power > max_power:\n        max_power = power\n        count = 1\n    elif power == max_power:\n        count += 1\n\nprint(2 ** max_power, count)"}
{"solution": "def min_clicks(n, m):\n    clicks = 0\n    while m > n:\n        if m % 2 == 0:\n            m //= 2\n        else:\n            m += 1\n        clicks += 1\n    return clicks + (n - m)\n\nn, m = map(int, input().split())\nprint(min_clicks(n, m))"}
{"solution": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x]!= x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x!= root_y:\n            if self.rank[root_x] > self.rank[root_y]:\n                self.parent[root_y] = root_x\n            elif self.rank[root_x] < self.rank[root_y]:\n                self.parent[root_x] = root_y\n            else:\n                self.parent[root_y] = root_x\n                self.rank[root_x] += 1\n\n\ndef solve():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, input().split())\n        segments.append((l, r))\n\n    events = []\n    for i, (l, r) in enumerate(segments):\n        events.append((l, 1, i))\n        events.append((r, -1, i))\n    events.sort()\n\n    uf = UnionFind(n)\n    edges = 0\n    for _, type, i in events:\n        if type == 1:\n            for j in range(i + 1, n):\n                if segments[j][0] < segments[i][1] and segments[i][0] < segments[j][1]:\n                    if uf.find(i)!= uf.find(j):\n                        uf.union(i, j)\n                        edges += 1\n    if edges == n - 1 and len(set(uf.find(i) for i in range(n))) == 1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def longest_ddos_period(n, requests):\n    max_length = 0\n    for i in range(n):\n        total_requests = 0\n        for j in range(i, n):\n            total_requests += requests[j]\n            if total_requests > 100 * (j - i + 1):\n                max_length = max(max_length, j - i + 1)\n    return max_length\n\nn = int(input())\nrequests = list(map(int, input().split()))\nprint(longest_ddos_period(n, requests))"}
{"solution": "def check_dissatisfaction(n, k, episodes):\n    max_dissatisfaction = 0\n    current_dissatisfaction = 0\n\n    for episode in episodes:\n        if episode == 'N' or episode == '?':\n            current_dissatisfaction += 1\n            max_dissatisfaction = max(max_dissatisfaction, current_dissatisfaction)\n        else:\n            current_dissatisfaction = 0\n\n    if max_dissatisfaction == k:\n        return \"YES\"\n    elif max_dissatisfaction > k:\n        return \"NO\"\n    else:\n        # Check if we can make the dissatisfaction equal to k\n        # by assuming '?' as 'N'\n        current_dissatisfaction = 0\n        for episode in episodes:\n            if episode == 'N':\n                current_dissatisfaction += 1\n            elif episode == '?':\n                current_dissatisfaction += 1\n                if current_dissatisfaction == k:\n                    return \"YES\"\n                if current_dissatisfaction > k:\n                    current_dissatisfaction -= 1\n            else:\n                current_dissatisfaction = 0\n        return \"NO\"\n\n\nn, k = map(int, input().split())\nepisodes = input()\n\nprint(check_dissatisfaction(n, k, episodes))"}
{"solution": "def calculate_possible_values(n, x, d):\n    \"\"\"\n    Calculate the number of possible values of S - T.\n\n    Args:\n    n (int): The length of the sequence.\n    x (int): The first element of the sequence.\n    d (int): The common difference of the sequence.\n\n    Returns:\n    int: The number of possible values of S - T.\n    \"\"\"\n    # Calculate the sum of the sequence\n    total_sum = n * (2 * x + (n - 1) * d) // 2\n\n    # If the total sum is odd, the number of possible values is 2 * n - 1\n    if total_sum % 2!= 0:\n        return 2 * n - 1\n\n    # If the total sum is even, the number of possible values is 2 * n\n    # However, we need to subtract 1 if the sequence has an even number of elements\n    # and the common difference is even, because in this case, the sum of the sequence\n    # is divisible by 4, and the difference between the sums of the two parts\n    # will always be even\n    if n % 2 == 0 and d % 2 == 0:\n        return 2 * n - 1\n    else:\n        return 2 * n\n\n\n# Read input from standard input\nn, x, d = map(int, input().split())\n\n# Calculate and print the number of possible values\nprint(calculate_possible_values(n, x, d))"}
{"solution": "def did_anton_perform_good():\n    n = int(input())\n    for _ in range(n):\n        handle, before, after = input().split()\n        before, after = int(before), int(after)\n        if before >= 2400 and after > before:\n            return \"YES\"\n    return \"NO\"\n\nprint(did_anton_perform_good())"}
{"solution": "def count_missed_trains(s):\n    \"\"\"\n    Calculate the number of trains that have departed strictly before time s.\n\n    Args:\n    s (str): A binary number representing the time.\n\n    Returns:\n    int: The number of trains that have departed strictly before time s.\n    \"\"\"\n    # Convert binary string to integer\n    s_int = int(s, 2)\n    \n    # Initialize the number of trains and the current time\n    num_trains = 0\n    current_time = 1\n    \n    # Loop until the current time exceeds s\n    while current_time <= s_int:\n        # If the current time is less than s, increment the number of trains\n        if current_time < s_int:\n            num_trains += 1\n        # Update the current time to the next train departure time\n        current_time *= 4\n    \n    return num_trains\n\n# Read the binary time from input\ns = input().strip()\n\n# Calculate and print the number of missed trains\nprint(count_missed_trains(s))"}
{"solution": "def min_rows(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n    for i in range(n // 2):\n        if matrix[i]!= matrix[n - i - 1]:\n            return n - i\n    return n // 2 if n % 2 == 0 else n // 2 + 1\n\n\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\nprint(min_rows(matrix))"}
{"solution": "def max_non_overlapping_orders(n, orders):\n    \"\"\"\n    This function calculates the maximum number of non-overlapping orders a restaurant can accept.\n\n    Parameters:\n    n (int): The number of orders.\n    orders (list): A list of tuples, where each tuple contains the start and end time of an order.\n\n    Returns:\n    int: The maximum number of non-overlapping orders.\n    \"\"\"\n    # Sort the orders based on their end times\n    orders.sort(key=lambda x: x[1])\n    \n    # Initialize the count of non-overlapping orders with 1 (the first order)\n    count = 1\n    \n    # Initialize the end time of the last accepted order\n    last_end_time = orders[0][1]\n    \n    # Iterate through the orders starting from the second order\n    for start, end in orders[1:]:\n        # If the current order does not overlap with the last accepted order, increment the count and update the last end time\n        if start > last_end_time:\n            count += 1\n            last_end_time = end\n    \n    return count\n\n# Read the number of orders\nn = int(input())\n\n# Read the orders\norders = []\nfor _ in range(n):\n    start, end = map(int, input().split())\n    orders.append((start, end))\n\n# Calculate and print the maximum number of non-overlapping orders\nprint(max_non_overlapping_orders(n, orders))"}
{"solution": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    x = list(map(int, sys.stdin.readline().split()))\n    y = list(map(int, sys.stdin.readline().split()))\n\n    x_sum = 0\n    y_sum = 0\n    x_prev = 0\n    y_prev = 0\n\n    for i in range(n):\n        x_sum += x[i]\n        y_sum += y[i]\n\n        if x_sum > k * (i + 1) or y_sum > k * (i + 1):\n            print(\"NO\")\n            return\n\n        if x[i] > k or y[i] > k:\n            print(\"NO\")\n            return\n\n        if x_prev + x[i] > k or y_prev + y[i] > k:\n            x_prev = x[i]\n            y_prev = y[i]\n        else:\n            x_prev += x[i]\n            y_prev += y[i]\n\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def can_human_win(n, k, coefficients):\n    # Calculate the value of P(k)\n    p_k = sum(int(coeff) * (k ** i) for i, coeff in enumerate(coefficients) if coeff!= '?')\n\n    # Count the number of unknown coefficients\n    unknown_count = sum(1 for coeff in coefficients if coeff == '?')\n\n    # If the number of unknown coefficients is even, the human can win\n    # by setting the remaining coefficients to make P(k) = 0\n    if unknown_count % 2 == 0:\n        return p_k == 0\n\n    # If the number of unknown coefficients is odd, the human can win\n    # by setting the remaining coefficients to make P(k) = 0, unless\n    # the computer can set the last coefficient to make P(k)!= 0\n    return p_k!= 0\n\n\ndef main():\n    n, k = map(int, input().split())\n    coefficients = [input().strip() for _ in range(n + 1)]\n\n    if can_human_win(n, k, coefficients):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def sieve_of_eratosthenes(n):\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n    p = 2\n    while p * p <= n:\n        if primes[p]:\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n    return [p for p in range(2, n + 1) if primes[p]]\n\n\ndef smallest_starting_number(x2):\n    primes = sieve_of_eratosthenes(x2)\n    min_x0 = x2\n    for p in primes:\n        if p >= x2 - 1:\n            break\n        x1 = ((x2 - 1) // p + 1) * p\n        for q in primes:\n            if q >= x1 - 1:\n                break\n            x0 = ((x1 - 1) // q + 1) * q\n            if x0 >= 3:\n                min_x0 = min(min_x0, x0)\n    return min_x0\n\n\nx2 = int(input())\nprint(smallest_starting_number(x2))"}
{"solution": "def min_p_binary_numbers(n, p):\n    for k in range(1, n + 1):\n        if (n - k * p) < k or bin(n - k * p).count('1') > k:\n            continue\n        return k\n    return -1\n\nn, p = map(int, input().split())\nprint(min_p_binary_numbers(n, p))"}
{"solution": "def minimize_integer(n, k, s):\n    s = list(s)\n    if k == 0:\n        return ''.join(s)\n    if n == 1:\n        return '0'\n    if s[0]!= '1':\n        s[0] = '1'\n        k -= 1\n    for i in range(1, n):\n        if k > 0 and s[i]!= '0':\n            s[i] = '0'\n            k -= 1\n    return ''.join(s)\n\nn, k = map(int, input().split())\ns = input()\nprint(minimize_integer(n, k, s))"}
{"solution": "def min_presents(cnt_1, cnt_2, x, y):\n    def lcm(a, b):\n        from math import gcd\n        return a * b // gcd(a, b)\n\n    def count_multiples(v, x):\n        return v // x\n\n    def count_multiples_xy(v, lcm_xy):\n        return v // lcm_xy\n\n    lcm_xy = lcm(x, y)\n    v = 0\n    while True:\n        v += 1\n        multiples_x = count_multiples(v, x)\n        multiples_y = count_multiples(v, y)\n        multiples_xy = count_multiples_xy(v, lcm_xy)\n        free = v - (multiples_x + multiples_y - multiples_xy)\n        if free >= cnt_1 + cnt_2:\n            return v\n\ncnt_1, cnt_2, x, y = map(int, input().split())\nprint(min_presents(cnt_1, cnt_2, x, y))"}
{"solution": "def calculate_position(n, sx, sy, dx, dy, t):\n    x, y = sx, sy\n    for _ in range(min(t, 2 * n + 2)):\n        k = x + y\n        dx += k\n        dy += k\n        x = ((x + dx - 1) % n) + 1\n        y = ((y + dy - 1) % n) + 1\n    if t > 2 * n + 2:\n        period = 2 * n + 2\n        t %= period\n        x, y = sx, sy\n        dx, dy = dx, dy\n        for _ in range(t):\n            k = x + y\n            dx += k\n            dy += k\n            x = ((x + dx - 1) % n) + 1\n            y = ((y + dy - 1) % n) + 1\n    return x, y\n\nn, sx, sy, dx, dy, t = map(int, input().split())\nx, y = calculate_position(n, sx, sy, dx, dy, t)\nprint(x, y)"}
{"solution": "def solve(s):\n    n = len(s)\n    if n < 26:\n        return -1\n\n    for i in range(n - 26 + 1):\n        window = s[i:i + 26]\n        if len(set(window.replace('?', ''))) > 25:\n            continue\n        if len(set(window)) == 26:\n            return s[:i] + window + s[i + 26:]\n\n        alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        available = set(alphabet) - set(window.replace('?', ''))\n        if len(available) > window.count('?'):\n            continue\n\n        new_window = list(window)\n        for j in range(26):\n            if new_window[j] == '?':\n                new_window[j] = available.pop()\n        if len(set(new_window)) == 26:\n            return s[:i] + ''.join(new_window) + s[i + 26:]\n\n    return -1\n\ns = input()\nresult = solve(s)\nif result == -1:\n    print(-1)\nelse:\n    print(result)"}
{"solution": "def can_divide_apples():\n    n = int(input())\n    weights = list(map(int, input().split()))\n\n    total_weight = sum(weights)\n    if total_weight % 2!= 0:\n        return \"NO\"\n\n    target_weight = total_weight // 2\n    num_200g_apples = weights.count(200)\n\n    if target_weight % 100 == 0 and num_200g_apples % 2 == 0:\n        return \"YES\"\n    elif target_weight % 100 == 50 and num_200g_apples % 2 == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\nprint(can_divide_apples())"}
{"solution": "import sys\n\ndef min_time_to_turn_off_lights(n, m, building):\n    total_time = 0\n    for i in range(n):\n        floor = building[i]\n        left_index = 1\n        right_index = m\n        while left_index <= right_index:\n            if floor[left_index] == '1':\n                total_time += left_index - 1\n                left_index += 1\n            elif floor[right_index] == '1':\n                total_time += m - right_index + 1\n                right_index -= 1\n            else:\n                left_index += 1\n                right_index -= 1\n        if i < n - 1:\n            total_time += 1\n    return total_time\n\nn, m = map(int, sys.stdin.readline().split())\nbuilding = [sys.stdin.readline().strip() for _ in range(n)]\n\nprint(min_time_to_turn_off_lights(n, m, building))"}
{"solution": "def find_min_trap_cost(n, costs, transitions):\n    visited = [False] * n\n    in_stack = [False] * n\n    min_cost = 0\n\n    def dfs(node):\n        stack = []\n        while True:\n            if visited[node]:\n                if in_stack[node]:\n                    # Found a cycle, calculate the minimum cost in this cycle\n                    cycle_min_cost = float('inf')\n                    while stack:\n                        cycle_node = stack.pop()\n                        in_stack[cycle_node] = False\n                        cycle_min_cost = min(cycle_min_cost, costs[cycle_node])\n                        if cycle_node == node:\n                            break\n                    return cycle_min_cost\n                else:\n                    return 0\n            visited[node] = True\n            in_stack[node] = True\n            stack.append(node)\n            node = transitions[node] - 1\n\n    for i in range(n):\n        if not visited[i]:\n            min_cost += dfs(i)\n\n    return min_cost\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(find_min_trap_cost(n, costs, transitions))"}
{"solution": "def calculate_final_entrance(n, a, b):\n    \"\"\"\n    Calculate the final entrance number after Vasya's walk.\n\n    Args:\n    n (int): The total number of entrances.\n    a (int): The initial entrance number.\n    b (int): The length of Vasya's walk.\n\n    Returns:\n    int: The final entrance number.\n    \"\"\"\n    # Calculate the final entrance number by adding the walk length to the initial entrance number\n    # and taking the modulus of the total number of entrances to handle circular movement\n    final_entrance = (a + b - 1) % n + 1\n    \n    return final_entrance\n\n# Read input values\nn, a, b = map(int, input().split())\n\n# Calculate and print the final entrance number\nprint(calculate_final_entrance(n, a, b))"}
{"solution": "def min_arithmetic_progressions(n, sequence):\n    \"\"\"\n    Calculate the minimum number of arithmetic progressions needed to represent a given sequence.\n\n    Args:\n    n (int): The number of elements in the sequence.\n    sequence (list): A list of integers representing the sequence.\n\n    Returns:\n    int: The minimum number of arithmetic progressions.\n    \"\"\"\n    if n == 1:\n        return 1\n\n    progressions = 1\n    prev_diff = None\n    prev_prev_value = None\n    prev_value = None\n\n    for i in range(n):\n        value = sequence[i]\n        if value == -1:\n            continue\n\n        if prev_value is not None:\n            curr_diff = value - prev_value\n            if prev_prev_value is not None and prev_diff is not None:\n                if curr_diff!= prev_diff:\n                    progressions += 1\n                    prev_diff = None\n                    prev_prev_value = None\n            else:\n                prev_diff = curr_diff\n            prev_prev_value = prev_value\n        prev_value = value\n\n    return progressions\n\n\nn = int(input())\nsequence = list(map(int, input().split()))\nprint(min_arithmetic_progressions(n, sequence))"}
{"solution": "def max_beauty(n, k, s):\n    def max_beauty_with_char(c):\n        max_length = 0\n        current_length = 0\n        changes = 0\n        for char in s:\n            if char == c:\n                current_length += 1\n            else:\n                if changes < k:\n                    changes += 1\n                    current_length += 1\n                else:\n                    max_length = max(max_length, current_length)\n                    current_length = 0\n        return max(max_length, current_length)\n\n    return max(max_beauty_with_char('a'), max_beauty_with_char('b'))\n\nn, k = map(int, input().split())\ns = input()\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, seats):\n    total_seats = sum(seats)\n    alice_seats = seats[0]\n    majority_seats = (total_seats + 1) // 2\n\n    if alice_seats >= majority_seats:\n        return [1]\n\n    coalition = [1]\n    seats = [(seats[i], i + 1) for i in range(1, n)]\n    seats.sort()\n\n    for seat, party in seats:\n        if alice_seats >= 2 * seat:\n            coalition.append(party)\n            alice_seats += seat\n            if alice_seats >= majority_seats:\n                return coalition\n\n    return []\n\nn = int(input())\nseats = list(map(int, input().split()))\n\ncoalition = find_coalition(n, seats)\n\nif coalition:\n    print(len(coalition))\n    print(*coalition)\nelse:\n    print(0)"}
{"solution": "def max_reward(n):\n    harmonic_sum = 0.0\n    for i in range(1, n + 1):\n        harmonic_sum += 1.0 / i\n    return harmonic_sum\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the maximum reward\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "import math\n\ndef calculate_max_children(n):\n    k = int((math.sqrt(8 * n + 1) - 1) / 2)\n    remaining_candies = n - k * (k + 1) // 2\n    candies = list(range(1, k + 1))\n    candies[-1] += remaining_candies\n    return k, candies\n\nn = int(input())\nk, candies = calculate_max_children(n)\nprint(k)\nprint(*candies)"}
{"solution": "n = int(input())\nm = int(input())\n\nprint(m % (1 << n))"}
{"solution": "def correct_word(word):\n    vowels = 'aeiouy'\n    stack = []\n    \n    for char in word:\n        if char in vowels and stack and stack[-1] in vowels:\n            stack.pop()\n        else:\n            stack.append(char)\n    \n    return ''.join(stack)\n\nn = int(input())\nword = input()\n\nprint(correct_word(word))"}
{"solution": "def max_students(n, a, b, seats):\n    segments = []\n    i = 0\n    \n    # Identify segments of empty seats\n    while i < n:\n        if seats[i] == '.':\n            start = i\n            while i < n and seats[i] == '.':\n                i += 1\n            segments.append(i - start)\n        else:\n            i += 1\n    \n    total_students = 0\n    \n    # Place students in each segment\n    for length in segments:\n        # Calculate the number of students that can be placed in this segment\n        # We will place students in an alternating fashion\n        if a > b:\n            # Start with a student-programmer if more student-programmers are available\n            programmers = (length + 1) // 2\n            athletes = length // 2\n        else:\n            # Start with a student-athlete if more student-athletes are available\n            athletes = (length + 1) // 2\n            programmers = length // 2\n        \n        # Place the students\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n        \n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n    \n    return total_students\n\nn, a, b = map(int, input().split())\nseats = input()\nprint(max_students(n, a, b, seats))"}
{"solution": "import math\n\ndef find_xy(r):\n    for x in range(1, int(math.sqrt(r)) + 1):\n        discriminant = 4 * x**2 - 4 * (r - x**2 - x - 1)\n        if discriminant >= 0:\n            y = (2 * x + math.sqrt(discriminant)) / 2\n            if y == int(y) and y > 0:\n                return x, int(y)\n    return None\n\nr = int(input())\nresult = find_xy(r)\nif result is None:\n    print(\"NO\")\nelse:\n    print(*result)"}
{"solution": "def divide_packets(n, packets):\n    total_balloons = sum(packets)\n    if n == 1 or total_balloons % 2 == 0 and len(set(packets)) == 1:\n        return -1\n\n    grigory_packets = []\n    andrew_packets = []\n    packets.sort(reverse=True)\n\n    for i, packet in enumerate(packets):\n        if sum(grigory_packets) <= sum(andrew_packets):\n            grigory_packets.append(packet)\n        else:\n            andrew_packets.append(packet)\n\n    if sum(grigory_packets) == sum(andrew_packets):\n        if len(grigory_packets) > 1:\n            andrew_packets.append(grigory_packets.pop())\n        elif len(andrew_packets) > 1:\n            grigory_packets.append(andrew_packets.pop())\n        else:\n            return -1\n\n    grigory_indices = [i + 1 for i, packet in enumerate(packets) if packet in grigory_packets]\n    return len(grigory_indices), grigory_indices\n\n\nn = int(input())\npackets = list(map(int, input().split()))\n\nresult = divide_packets(n, packets)\nif result == -1:\n    print(-1)\nelse:\n    print(result[0])\n    print(*result[1])"}
{"solution": "def min_diverse_digits(n):\n    if n < 10:\n        return [n]\n\n    for i in range(9, 0, -1):\n        if n % i == 0:\n            return [i] * (n // i)\n\n    for i in range(9, 0, -1):\n        if n > i and n % i!= 0:\n            return [i] + min_diverse_digits(n - i)\n\nn = int(input())\nresult = min_diverse_digits(n)\nprint(len(result))\nprint(*result)"}
{"solution": "def sieve_of_eratosthenes(n):\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n    p = 2\n    while p**2 <= n:\n        if primes[p]:\n            for i in range(p**2, n + 1, p):\n                primes[i] = False\n        p += 1\n    return primes\n\ndef is_prime(n, primes):\n    return primes[n]\n\ndef find_simple_subset(a, primes):\n    a.sort()\n    max_size = 0\n    max_subset = []\n    for i in range(len(a)):\n        subset = [a[i]]\n        for j in range(i + 1, len(a)):\n            if is_prime(a[i] + a[j], primes):\n                subset.append(a[j])\n        if len(subset) > max_size:\n            max_size = len(subset)\n            max_subset = subset\n    return max_size, max_subset\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    primes = sieve_of_eratosthenes(2 * 10**6)\n    max_size, max_subset = find_simple_subset(a, primes)\n    print(max_size)\n    print(*max_subset)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef greatest_beautiful_divisor(n):\n    max_divisor = 1\n    for k in range(1, int(math.log2(n)) + 1):\n        beautiful_number = (2**k - 1)**2\n        if n % beautiful_number == 0:\n            max_divisor = max(max_divisor, beautiful_number)\n    return max_divisor\n\nn = int(input())\nprint(greatest_beautiful_divisor(n))"}
{"solution": "def count_magic_numbers(m, d, a, b):\n    MOD = 10**9 + 7\n    n = len(a)\n    dp = [[0] * m for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(m):\n            for k in range(10):\n                if i % 2 == 0 and k!= d:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD\n                elif i % 2 == 1 and k == d:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][(j - k * (10 ** (i - 1))) % m]) % MOD\n\n    def get_count(num):\n        count = 0\n        for i in range(n):\n            for j in range(int(num[i])):\n                if i % 2 == 0 and j!= d:\n                    count = (count + dp[n - i][0]) % MOD\n                elif i % 2 == 1 and j == d:\n                    count = (count + dp[n - i][(m - j * (10 ** (n - i - 1))) % m]) % MOD\n        return count\n\n    return (get_count(b) - get_count(a) + dp[n][0]) % MOD\n\n\nm, d = map(int, input().split())\na = input()\nb = input()\nprint(count_magic_numbers(m, d, a, b))"}
{"solution": "from collections import deque\n\ndef last_child(n, m, candies):\n    queue = deque(range(1, n + 1))\n    index = 0\n    while queue:\n        child = queue.popleft()\n        candies[index] -= m\n        if candies[index] > 0:\n            queue.append(child)\n        index = (index + 1) % n\n    return child\n\nn, m = map(int, input().split())\ncandies = list(map(int, input().split()))\nprint(last_child(n, m, candies))"}
{"solution": "def min_bills(n):\n    denominations = [100, 20, 10, 5, 1]\n    bills = 0\n\n    for denomination in denominations:\n        bills += n // denomination\n        n %= denomination\n\n    return bills\n\nn = int(input())\nprint(min_bills(n))"}
{"solution": "MOD = 1000000007\n\ndef count_permutations(n, k):\n    if k > n or (n - k) % 2!= 0:\n        return 0\n\n    dp = [[[0 for _ in range(k + 1)] for _ in range(n + 1)] for _ in range(2)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(min(i, k) + 1):\n            dp[i % 2][i][j] = dp[(i - 1) % 2][i - 1][j]\n            if j > 0:\n                dp[i % 2][i][j] += dp[(i - 1) % 2][i - 1][j - 1]\n            if i >= 2 and j > 0:\n                dp[i % 2][i][j] += dp[(i - 1) % 2][i - 2][j - 1]\n            dp[i % 2][i][j] %= MOD\n\n    return dp[n % 2][n][k]\n\nn, k = map(int, input().split())\nprint(count_permutations(n, k))"}
{"solution": "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    beauty = list(map(int, sys.stdin.readline().split()))\n    color = sys.stdin.readline().strip()\n\n    red = []\n    orange = []\n    white = []\n\n    for i in range(n):\n        if color[i] == 'R':\n            red.append(beauty[i])\n        elif color[i] == 'O':\n            orange.append(beauty[i])\n        else:\n            white.append(beauty[i])\n\n    red.sort(reverse=True)\n    orange.sort(reverse=True)\n    white.sort(reverse=True)\n\n    max_beauty = -1\n\n    if len(red) > 0 and len(orange) > 0:\n        for i in range(1, min(len(red), k) + 1):\n            for j in range(1, min(len(orange), k - i + 1)):\n                if i + j == k:\n                    max_beauty = max(max_beauty, sum(red[:i]) + sum(orange[:j]))\n\n    if len(white) > 0 and len(orange) > 0:\n        for i in range(1, min(len(white), k) + 1):\n            for j in range(1, min(len(orange), k - i + 1)):\n                if i + j == k:\n                    max_beauty = max(max_beauty, sum(white[:i]) + sum(orange[:j]))\n\n    print(max_beauty)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef simplify_fraction(numerator, denominator):\n    common_divisor = gcd(numerator, denominator)\n    return numerator // common_divisor, denominator // common_divisor\n\ndef evaluate_continued_fraction(coefficients):\n    numerator, denominator = coefficients[-1], 1\n    for coefficient in reversed(coefficients[:-1]):\n        numerator, denominator = coefficient * numerator + denominator, numerator\n    return numerator, denominator\n\ndef main():\n    p, q = map(int, input().split())\n    n = int(input())\n    coefficients = list(map(int, input().split()))\n\n    p, q = simplify_fraction(p, q)\n    cf_numerator, cf_denominator = evaluate_continued_fraction(coefficients)\n    cf_numerator, cf_denominator = simplify_fraction(cf_numerator, cf_denominator)\n\n    print(\"YES\" if (p, q) == (cf_numerator, cf_denominator) else \"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_sticks(expression):\n    sticks = expression.replace('+','').replace('=','').split()\n    return [len(stick) for stick in sticks]\n\ndef is_correct(expression):\n    sticks = count_sticks(expression)\n    return sticks[0] + sticks[1] == sticks[2]\n\ndef shift_stick(expression, from_index, to_index):\n    sticks = expression.replace('+','').replace('=','').split()\n    stick = sticks[from_index][-1]\n    sticks[from_index] = sticks[from_index][:-1]\n    sticks[to_index] += stick\n    return ''.join(sticks).replace(' ', '+').replace('=', '=')\n\ndef solve(expression):\n    if is_correct(expression):\n        return expression\n\n    for i in range(3):\n        for j in range(3):\n            if i!= j:\n                new_expression = shift_stick(expression, i, j)\n                if is_correct(new_expression):\n                    return new_expression\n\n    return \"Impossible\"\n\nexpression = input()\nprint(solve(expression))"}
{"solution": "MOD = 10**9 + 7\n\ndef main():\n    n, k = map(int, input().split())\n    dp = [[[0] * (n * n + 1) for _ in range(n + 1)] for _ in range(2)]\n    dp[0][0][0] = 1\n\n    for i in range(n):\n        for j in range(n + 1):\n            for odd in range(n * n + 1):\n                if dp[i % 2][j][odd] == 0:\n                    continue\n                for l in range(2):\n                    for m in range(2):\n                        if j + l + m > n:\n                            break\n                        nj = j + l + m\n                        nodd = odd + l * (n - i - 1) + m * (n - i - 1 - l)\n                        if nodd > k:\n                            break\n                        dp[(i + 1) % 2][nj][nodd] = (dp[(i + 1) % 2][nj][nodd] + dp[i % 2][j][odd]) % MOD\n\n    print(dp[n % 2][n][k])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": ""}
{"solution": "import re\n\nn = int(input())\ns = input()\n\npattern = r'ogo(go)*'\ns = re.sub(pattern, '***', s)\n\nprint(s)"}
{"solution": "def prime_factors(n):\n    \"\"\"Returns a dictionary of prime factors and their powers\"\"\"\n    factors = {}\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors[i] = factors.get(i, 0) + 1\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef g(y, p):\n    \"\"\"Returns the maximum possible integer p^k where k is an integer such that y is divisible by p^k\"\"\"\n    k = 0\n    while y % p == 0:\n        y //= p\n        k += 1\n    return p ** k\n\ndef f(x, y):\n    \"\"\"Returns the product of g(y, p) for all p in prime(x)\"\"\"\n    product = 1\n    for p in prime_factors(x):\n        product = (product * g(y, p)) % (10**9 + 7)\n    return product\n\ndef main():\n    x, n = map(int, input().split())\n    result = 1\n    for y in range(1, n + 1):\n        result = (result * f(x, y)) % (10**9 + 7)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = set()\n    for s in range(1, 82):  # s(x) can be at most 81\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and sum_of_digits(x) == s:\n            solutions.add(x)\n    return sorted(list(solutions))\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find solutions\nsolutions = find_solutions(a, b, c)\n\n# Print results\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "def is_solved(face):\n    return len(set(face)) == 1\n\ndef is_possible_to_solve(cube):\n    for i in range(0, 24, 4):\n        face = cube[i:i+4]\n        if is_solved(face):\n            return True\n    return False\n\ndef main():\n    cube = list(map(int, input().split()))\n    if is_possible_to_solve(cube):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def get_score(s):\n    i = (s // 50) % 475\n    scores = []\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        scores.append(26 + i)\n    return scores\n\ndef solve():\n    p, x, y = map(int, input().split())\n    min_hacks = float('inf')\n    for s in range(y, 20001):\n        scores = get_score(s)\n        if p in scores:\n            hacks = (s - x + 99) // 100\n            min_hacks = min(min_hacks, hacks)\n    print(min_hacks)\n\nsolve()"}
{"solution": "import sys\n\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nif n == 1:\n    print(0)\nelse:\n    distances = [a + b, a + c, b + c]\n    min_distance = min(distances)\n    if n % 2 == 0:\n        print(min_distance * (n // 2))\n    else:\n        print(min_distance * ((n - 1) // 2) + min(a, b, c))"}
{"solution": "def min_distance(x1, x2, x3):\n    return sum(abs(x - sorted([x1, x2, x3])[1]) for x in [x1, x2, x3])\n\nx1, x2, x3 = map(int, input().split())\nprint(min_distance(x1, x2, x3))"}
{"solution": "def min_operations(n, x, arr):\n    seen = set()\n    min_ops = float('inf')\n    \n    for num in arr:\n        if num & x in seen:\n            return 0\n        seen.add(num & x)\n        \n        temp = num\n        ops = 0\n        while temp!= (temp & x):\n            temp &= x\n            ops += 1\n            if temp in seen:\n                min_ops = min(min_ops, ops)\n    \n    if min_ops == float('inf'):\n        return -1\n    return min_ops\n\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\nprint(min_operations(n, x, arr))"}
{"solution": "def check_plus(grid, center):\n    h, w = len(grid), len(grid[0])\n    x, y = center\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for dx, dy in directions:\n        length = 0\n        nx, ny = x + dx, y + dy\n        while 0 <= nx < h and 0 <= ny < w and grid[nx][ny] == '*':\n            length += 1\n            nx += dx\n            ny += dy\n        if length == 0:\n            return False\n    return True\n\ndef check_empty(grid, center):\n    h, w = len(grid), len(grid[0])\n    x, y = center\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for dx, dy in directions:\n        nx, ny = x + dx, y + dy\n        while 0 <= nx < h and 0 <= ny < w:\n            if grid[nx][ny] == '*':\n                if not (nx == x + dx and ny == y + dy):\n                    return False\n            nx += dx\n            ny += dy\n    return True\n\ndef solve():\n    h, w = map(int, input().split())\n    grid = [list(input()) for _ in range(h)]\n    centers = [(i, j) for i in range(h) for j in range(w) if grid[i][j] == '*']\n    if len(centers) == 0:\n        print(\"NO\")\n        return\n    for center in centers:\n        if check_plus(grid, center) and check_empty(grid, center):\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nsolve()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, a, b = read_ints()\n\n    if a == 1 and b == 1:\n        print(\"NO\")\n        return\n\n    if a == 1:\n        print(\"YES\")\n        for i in range(n):\n            row = ['1'] * n\n            row[i] = '0'\n            print(''.join(row))\n        return\n\n    if b == 1:\n        print(\"YES\")\n        for i in range(n):\n            row = ['0'] * n\n            row[i] = '0'\n            print(''.join(row))\n        return\n\n    if a + b > n + 1:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    for i in range(n):\n        row = ['0'] * n\n        row[i] = '0'\n        if i < a - 1:\n            row[i + 1] = '1'\n        if i >= n - b + 1:\n            row[i - 1] = '1'\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_problems(c, d, n, m, k):\n    \"\"\"\n    Calculate the minimum number of problems needed for the finals.\n\n    Args:\n    c (int): The number of problems in the main elimination rounds.\n    d (int): The number of problems in the additional elimination rounds.\n    n (int): The number of winners in each main elimination round.\n    m (int): The number of main elimination rounds.\n    k (int): The number of pre-chosen winners.\n\n    Returns:\n    int: The minimum number of problems needed for the finals.\n    \"\"\"\n    total_winners_needed = n * m - k\n    if total_winners_needed <= 0:\n        return 0\n\n    main_rounds = total_winners_needed // n\n    additional_winners_needed = total_winners_needed % n\n    additional_rounds = additional_winners_needed\n\n    main_problems = main_rounds * c\n    additional_problems = additional_rounds * d\n\n    return main_problems + additional_problems\n\n\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\nprint(min_problems(c, d, n, m, k))"}
{"solution": "from collections import defaultdict\n\ndef find_grid(s):\n    # Create a graph where each letter is a node and two nodes are connected if the corresponding letters are adjacent in the string\n    graph = defaultdict(list)\n    for i in range(len(s)):\n        for j in range(max(0, i-2), min(len(s), i+3)):\n            if i!= j:\n                graph[s[i]].append(s[j])\n\n    # Try to place the letters in the grid\n    grid = [[' ']*13 for _ in range(2)]\n    used = set()\n    def place(letter, row, col):\n        if (row, col) in used:\n            return False\n        if grid[row][col]!='' and grid[row][col]!= letter:\n            return False\n        grid[row][col] = letter\n        used.add((row, col))\n        for neighbor in graph[letter]:\n            if neighbor not in used:\n                for r in range(2):\n                    for c in range(13):\n                        if (r, c) not in used and abs(r-row) <= 1 and abs(c-col) <= 1:\n                            if place(neighbor, r, c):\n                                return True\n        used.remove((row, col))\n        return False\n\n    # Try to place the first letter in each position in the grid\n    for row in range(2):\n        for col in range(13):\n            if place(s[0], row, col):\n                break\n        else:\n            continue\n        break\n    else:\n        return \"Impossible\"\n\n    # Fill in the rest of the grid\n    for row in range(2):\n        for col in range(13):\n            if grid[row][col] =='':\n                for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                    if letter not in used:\n                        if place(letter, row, col):\n                            break\n\n    # Check if the grid contains a path that forms the string\n    def has_path(row, col, index):\n        if index == len(s):\n            return True\n        if grid[row][col]!= s[index]:\n            return False\n        for r in range(2):\n            for c in range(13):\n                if abs(r-row) <= 1 and abs(c-col) <= 1 and (r, c)!= (row, col):\n                    if has_path(r, c, index+1):\n                        return True\n        return False\n\n    for row in range(2):\n        for col in range(13):\n            if has_path(row, col, 0):\n                return '\\n'.join(''.join(row) for row in grid)\n\n    return \"Impossible\"\n\ns = input()\nprint(find_grid(s))"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<' if y > 1 else '='\n    elif y == 1:\n        return '>' if x > 1 else '='\n    else:\n        # Compute y * log(x) and x * log(y)\n        lhs = y * math.log(x)\n        rhs = x * math.log(y)\n        \n        if lhs < rhs:\n            return '<'\n        elif lhs > rhs:\n            return '>'\n        else:\n            return '='\n\n# Read input\nx, y = map(int, input().split())\n\n# Output the result of the comparison\nprint(compare_powers(x, y))"}
{"solution": "import math\n\ndef calculate_max_balloons():\n    r, h = map(int, input().split())\n    max_balloons_in_height = math.floor((h + r) / r)\n    max_balloons_in_width = math.floor((2 * r) / r)\n    max_balloons_in_arc = math.floor(math.pi * r / (2 * (r / 2)))\n    max_balloons = max_balloons_in_height * max_balloons_in_width + max_balloons_in_arc\n    return max_balloons\n\nprint(calculate_max_balloons())"}
{"solution": "def min_sum_of_remaining_cards():\n    # Read the input\n    cards = list(map(int, input().split()))\n\n    # Sort the cards in ascending order\n    cards.sort()\n\n    # Initialize the minimum sum\n    min_sum = sum(cards)\n\n    # Check if we can discard two or three cards with the same number\n    for i in range(len(cards) - 2):\n        if cards[i] == cards[i + 1] == cards[i + 2]:\n            # Discard three cards with the same number\n            min_sum = min(min_sum, sum(cards[:i]) + sum(cards[i + 3:]))\n        elif cards[i] == cards[i + 1]:\n            # Discard two cards with the same number\n            min_sum = min(min_sum, sum(cards[:i]) + sum(cards[i + 2:]))\n\n    # Check if we can discard two cards with the same number at the end\n    if len(cards) >= 4 and cards[-1] == cards[-2]:\n        min_sum = min(min_sum, sum(cards[:-2]))\n\n    # Print the minimum sum\n    print(min_sum)\n\nmin_sum_of_remaining_cards()"}
{"solution": "import sys\n\ndef calculate_min_distance(n, a, checkpoints):\n    checkpoints.sort()\n    min_distance = sys.maxsize\n    for i in range(n):\n        distance = 0\n        if i > 0:\n            distance += checkpoints[i] - checkpoints[i - 1]\n        if i < n - 1:\n            distance += checkpoints[i + 1] - checkpoints[i]\n        distance += abs(a - checkpoints[i])\n        min_distance = min(min_distance, distance)\n    return min_distance\n\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\nprint(calculate_min_distance(n, a, checkpoints))"}
{"solution": "def sum_of_digits(x):\n    \"\"\"Calculate the sum of digits of a number.\"\"\"\n    return sum(int(digit) for digit in str(x))\n\ndef solve_equation(n):\n    \"\"\"Find the smallest positive integer root of the equation x^2 + s(x)*x - n = 0.\"\"\"\n    x = 1\n    while True:\n        s_x = sum_of_digits(x)\n        if x**2 + s_x*x - n == 0:\n            return x\n        elif x**2 + s_x*x > n:\n            return -1\n        x += 1\n\nn = int(input())\nprint(solve_equation(n))"}
{"solution": "def calculate_bed_time(current_time, sleep_time):\n    current_hours, current_minutes = map(int, current_time.split(':'))\n    sleep_hours, sleep_minutes = map(int, sleep_time.split(':'))\n\n    total_minutes = current_hours * 60 + current_minutes - (sleep_hours * 60 + sleep_minutes)\n    if total_minutes < 0:\n        total_minutes += 24 * 60\n\n    bed_hours = total_minutes // 60 % 24\n    bed_minutes = total_minutes % 60\n\n    return f\"{bed_hours:02d}:{bed_minutes:02d}\"\n\ncurrent_time = input()\nsleep_time = input()\n\nprint(calculate_bed_time(current_time, sleep_time))"}
{"solution": "def find_longest_subsegment(n, a):\n    max_sum = float('-inf')\n    max_length = 0\n    current_sum = 0\n    current_length = 0\n\n    for num in a:\n        if current_sum <= 0:\n            current_sum = num\n            current_length = 1\n        else:\n            current_sum += num\n            current_length += 1\n\n        if current_sum * max_length > max_sum * current_length:\n            max_sum = current_sum\n            max_length = current_length\n\n    return max_length\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nprint(find_longest_subsegment(n, a))"}
{"solution": "MOD = 998244353\n\ndef main():\n    n, m, k = map(int, input().split())\n\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[1][0] = m\n\n    for i in range(2, n + 1):\n        for j in range(min(i, k) + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] * (m - 1) % MOD\n            else:\n                dp[i][j] = (dp[i - 1][j - 1] * (m - 1) + dp[i - 1][j]) % MOD\n\n    ans = 0\n    for i in range(k + 1):\n        ans = (ans + dp[n][i]) % MOD\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import re\n\ndef is_magic_number(n):\n    pattern = re.compile(r'^(1|14|144)+$')\n    if pattern.match(str(n)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\nn = int(input())\nprint(is_magic_number(n))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef min_moves(n, m, i, j, a, b):\n    moves = float('inf')\n    for x, y in [(1, m), (n, 1), (n, m), (1, 1)]:\n        dx, dy = abs(x - i), abs(y - j)\n        if dx % a == 0 and dy % b == 0:\n            moves = min(moves, dx // a + dy // b)\n        elif dx % b == 0 and dy % a == 0:\n            moves = min(moves, dx // b + dy // a)\n    return moves if moves!= float('inf') else -1\n\nn, m, i, j, a, b = map(int, input().split())\nmoves = min_moves(n, m, i, j, a, b)\nif moves == -1:\n    print(\"Poor Inna and pony!\")\nelse:\n    print(moves)"}
{"solution": "def max_removals(n, s):\n    dp = [[0] * 26 for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(26):\n            if ord(s[i - 1]) - ord('a') == j:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + 1)\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return max(dp[n])\n\nn = int(input())\ns = input()\nprint(max_removals(n, s))"}
{"solution": "def min_bills(n, k, denominations, q, requests):\n    results = []\n    for request in requests:\n        min_bills = float('inf')\n        for i in range(n):\n            for j in range(i, n):\n                bills = 0\n                remaining = request\n                while remaining > 0 and bills <= k:\n                    if remaining >= denominations[j]:\n                        remaining -= denominations[j]\n                        bills += 1\n                    elif remaining >= denominations[i]:\n                        remaining -= denominations[i]\n                        bills += 1\n                    else:\n                        break\n                if remaining == 0 and bills < min_bills:\n                    min_bills = bills\n        if min_bills == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_bills)\n    return results\n\nn, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\nrequests = [int(input()) for _ in range(q)]\n\nresults = min_bills(n, k, denominations, q, requests)\nfor result in results:\n    print(result)"}
{"solution": "import math\n\ndef calculate_time(s, x1, x2, t1, t2, p, d):\n    # Calculate the time it takes for Igor to walk from x1 to x2\n    walk_time = abs(x2 - x1) * t2\n\n    # Calculate the time it takes for the tram to reach x1\n    tram_time_to_x1 = abs(p - x1) * t1\n\n    # Calculate the time it takes for the tram to reach x2 after reaching x1\n    tram_time_to_x2 = abs(x2 - x1) * t1\n\n    # Calculate the total time it takes for Igor to take the tram\n    tram_time = tram_time_to_x1 + tram_time_to_x2\n\n    # Calculate the time it takes for Igor to take the tram and walk\n    tram_walk_time = tram_time_to_x1 + (abs(x2 - p) * t2)\n\n    # Calculate the minimum time\n    min_time = min(walk_time, tram_time, tram_walk_time)\n\n    # If the tram is moving towards x2, calculate the time it takes for Igor to take the tram\n    if (x1 < x2 and d == 1) or (x1 > x2 and d == -1):\n        tram_time = tram_time_to_x1 + (abs(x2 - p) * t1)\n        min_time = min(min_time, tram_time)\n\n    return min_time\n\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\nprint(calculate_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "import math\n\ndef count_cells(n, x):\n    count = 0\n    for i in range(1, min(n, int(math.sqrt(x))) + 1):\n        if x % i == 0:\n            j = x // i\n            if j <= n:\n                if i!= j:\n                    count += 2\n                else:\n                    count += 1\n    return count\n\nn, x = map(int, input().split())\nprint(count_cells(n, x))"}
{"solution": "import string\n\nn, k = map(int, input().split())\npassword = string.ascii_lowercase[:k]\n\nif n <= k:\n    print(password[:n])\nelse:\n    repeated_password = password * (n // k)\n    remaining_chars = password[:n % k]\n    print(repeated_password + remaining_chars)"}
{"solution": "n = int(input())\ndirections = input()\npositions = list(map(int, input().split()))\n\nmin_time = float('inf')\ncollision_found = False\n\nfor i in range(n - 1):\n    if directions[i] == 'R' and directions[i + 1] == 'L':\n        collision_time = (positions[i + 1] - positions[i]) // 2\n        min_time = min(min_time, collision_time)\n        collision_found = True\n\nif collision_found:\n    print(min_time)\nelse:\n    print(-1)"}
{"solution": "import sys\n\ndef max_area(seals, a, b):\n    max_area = 0\n    for i in range(len(seals)):\n        for j in range(i + 1, len(seals)):\n            seal1 = seals[i]\n            seal2 = seals[j]\n            # Check if both seals can fit in the paper without rotating\n            if seal1[0] <= a and seal1[1] <= b and seal2[0] <= a and seal2[1] <= b:\n                area = seal1[0] * seal1[1] + seal2[0] * seal2[1]\n                max_area = max(max_area, area)\n            # Check if both seals can fit in the paper after rotating one or both of them\n            if seal1[0] <= b and seal1[1] <= a and seal2[0] <= a and seal2[1] <= b:\n                area = seal1[0] * seal1[1] + seal2[0] * seal2[1]\n                max_area = max(max_area, area)\n            if seal1[0] <= a and seal1[1] <= b and seal2[0] <= b and seal2[1] <= a:\n                area = seal1[0] * seal1[1] + seal2[0] * seal2[1]\n                max_area = max(max_area, area)\n            if seal1[0] <= b and seal1[1] <= a and seal2[0] <= b and seal2[1] <= a:\n                area = seal1[0] * seal1[1] + seal2[0] * seal2[1]\n                max_area = max(max_area, area)\n    return max_area\n\nn, a, b = map(int, sys.stdin.readline().split())\nseals = []\nfor _ in range(n):\n    x, y = map(int, sys.stdin.readline().split())\n    seals.append((x, y))\n    seals.append((y, x))\n\nprint(max_area(seals, a, b))"}
{"solution": "def find_outlier_point():\n    n = int(input())\n    points = [list(map(int, input().split())) for _ in range(4 * n + 1)]\n\n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n\n    x_counts = {}\n    y_counts = {}\n\n    for x in x_coords:\n        x_counts[x] = x_counts.get(x, 0) + 1\n\n    for y in y_coords:\n        y_counts[y] = y_counts.get(y, 0) + 1\n\n    outlier_x = None\n    outlier_y = None\n\n    for x, count in x_counts.items():\n        if count == 1:\n            outlier_x = x\n            break\n\n    for y, count in y_counts.items():\n        if count == 1:\n            outlier_y = y\n            break\n\n    if outlier_x is not None:\n        for point in points:\n            if point[0] == outlier_x:\n                return point\n\n    if outlier_y is not None:\n        for point in points:\n            if point[1] == outlier_y:\n                return point\n\n    # If no outlier is found, return the first point\n    return points[0]\n\noutlier_point = find_outlier_point()\nprint(*outlier_point)"}
{"solution": "def max_digit_product(n):\n    max_product = 1\n    for i in range(1, n + 1):\n        product = 1\n        num = i\n        while num > 0:\n            digit = num % 10\n            if digit > 1:\n                product *= digit\n            num //= 10\n        max_product = max(max_product, product)\n    return max_product\n\ndef main():\n    n = int(input())\n    print(max_digit_product(n))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def smallest_winning_k(n, votes):\n    \"\"\"\n    Calculate the smallest k that guarantees Awruk's win.\n\n    Args:\n    n (int): The number of students in the school.\n    votes (list): A list of votes each student gives to Elodreip.\n\n    Returns:\n    int: The smallest k that guarantees Awruk's win.\n    \"\"\"\n    # Calculate the total votes for Elodreip\n    elodreip_votes = sum(votes)\n    \n    # Initialize k as the maximum vote\n    k = max(votes)\n    \n    # Calculate Awruk's votes for the current k\n    awruk_votes = sum(k - vote for vote in votes)\n    \n    # While Awruk's votes are not more than Elodreip's votes, increment k\n    while awruk_votes <= elodreip_votes:\n        k += 1\n        awruk_votes = sum(k - vote for vote in votes)\n    \n    return k\n\n# Read the number of students\nn = int(input())\n\n# Read the votes for Elodreip\nvotes = list(map(int, input().split()))\n\n# Calculate and print the smallest winning k\nprint(smallest_winning_k(n, votes))"}
{"solution": "def min_operations(s):\n    stack = []\n    operations = 0\n\n    for color in s:\n        if stack and stack[-1][0]!= color:\n            while stack and stack[-1][0]!= color:\n                stack.pop()\n            if stack:\n                stack[-1][1] += 1\n            else:\n                stack.append([color, 1])\n        else:\n            if stack and stack[-1][0] == color:\n                stack[-1][1] += 1\n            else:\n                stack.append([color, 1])\n\n        if len(stack) > 1 and stack[-1][1] == 1 and stack[-2][1] == 1:\n            stack.pop()\n            stack.pop()\n            operations += 1\n\n    return operations\n\ns = input()\nprint(min_operations(s))"}
{"solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n\n    min_product = a[0] * a[1] * a[2]\n    min_product_count = 1\n\n    for i in range(3, n):\n        if a[0] * a[1] * a[i] == min_product:\n            min_product_count += 1\n        elif a[0] * a[1] * a[i] < min_product:\n            min_product = a[0] * a[1] * a[i]\n            min_product_count = 1\n\n    if a[0] == a[1] == a[2]:\n        print(n * (n - 1) * (n - 2) // 6)\n    elif a[0] == a[1]:\n        print((n - 2) * (n - 3) // 2)\n    else:\n        print(min_product_count)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef min_cuts(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 2\n    elif n == 4:\n        return 5\n    else:\n        return math.ceil(math.sqrt(n + 1))\n\nn = int(input())\nprint(min_cuts(n))"}
{"solution": "def maximize_balance(n):\n    n_str = str(n)\n    if n_str[0] == '-':\n        if len(n_str) > 2 and int(n_str[-1]) > int(n_str[-2]):\n            return int(n_str[:-1])\n        elif len(n_str) > 2 and int(n_str[-1]) < int(n_str[-2]):\n            return int(n_str[:-2] + n_str[-1])\n        else:\n            return 0\n    else:\n        if len(n_str) > 1 and int(n_str[-1]) == 0:\n            return int(n_str[:-1])\n        else:\n            return n\n\nn = int(input())\nprint(maximize_balance(n))"}
{"solution": "def spinner_direction(start, end, n):\n    positions = ['v', '<', '^', '>']\n    start_index = positions.index(start)\n    end_index = positions.index(end)\n    \n    clockwise_diff = (end_index - start_index) % 4\n    counter_clockwise_diff = (start_index - end_index) % 4\n    \n    if n % 4 == clockwise_diff:\n        return 'cw'\n    elif n % 4 == counter_clockwise_diff:\n        return 'ccw'\n    else:\n        return 'undefined'\n\nstart, end = input().split()\nn = int(input())\n\nprint(spinner_direction(start, end, n))"}
{"solution": "def count_vertical_dominoes(n, s):\n    \"\"\"\n    Calculate the number of dominoes left standing vertically at the end of the process.\n\n    Args:\n    n (int): The number of dominoes in the line.\n    s (str): A character string representing the initial directions of the dominoes.\n\n    Returns:\n    int: The number of dominoes left standing vertically.\n    \"\"\"\n    count = 0\n    i = 0\n    while i < n:\n        if s[i] == '.':\n            j = i + 1\n            while j < n and s[j] == '.':\n                j += 1\n            if j == n:\n                count += n - i\n                break\n            if (j - i) % 2 == 1:\n                count += (j - i) // 2 + 1\n            else:\n                count += (j - i) // 2\n            i = j\n        else:\n            i += 1\n    return count\n\nn = int(input())\ns = input()\nprint(count_vertical_dominoes(n, s))"}
{"solution": "def restore_permutation(n, leaders):\n    permutation = [0] * n\n    for i in range(n):\n        permutation[i] = i + 1\n\n    for i in range(len(leaders) - 1):\n        leader_index = leaders[i] - 1\n        next_leader_index = leaders[i + 1] - 1\n        diff = (next_leader_index - leader_index) % n\n        if diff == 0:\n            diff = n\n        permutation[leader_index] = diff\n\n    if leaders[-1]!= leaders[0]:\n        permutation[leaders[-1] - 1] = n\n\n    for i in range(len(leaders) - 1):\n        leader_index = leaders[i] - 1\n        next_leader_index = leaders[i + 1] - 1\n        diff = (next_leader_index - leader_index) % n\n        if diff == 0:\n            diff = n\n        if permutation[leader_index]!= diff:\n            return [-1]\n\n    return permutation\n\n\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\nresult = restore_permutation(n, leaders)\nprint(*result)"}
{"solution": "def max_number(a, k):\n    a = list(str(a))\n    n = len(a)\n    max_a = a[:]\n    for i in range(n):\n        for j in range(i + 1, min(i + k + 1, n)):\n            if a[j] > a[i]:\n                a[i], a[j] = a[j], a[i]\n                k -= j - i\n                if a > max_a:\n                    max_a = a[:]\n                a[i], a[j] = a[j], a[i]\n    return ''.join(max_a)\n\na, k = input().split()\na, k = int(a), int(k)\nprint(max_number(a, k))"}
{"solution": "def is_arithmetic_progression(sequence):\n    \"\"\"Check if a sequence is an arithmetic progression.\"\"\"\n    diff = sequence[1] - sequence[0]\n    for i in range(2, len(sequence)):\n        if sequence[i] - sequence[i - 1]!= diff:\n            return False\n    return True\n\n\ndef is_geometric_progression(sequence):\n    \"\"\"Check if a sequence is a geometric progression.\"\"\"\n    ratio = sequence[1] / sequence[0]\n    for i in range(2, len(sequence)):\n        if sequence[i] / sequence[i - 1]!= ratio:\n            return False\n    return True\n\n\ndef next_arithmetic_progression(sequence):\n    \"\"\"Find the next element in an arithmetic progression.\"\"\"\n    diff = sequence[1] - sequence[0]\n    return sequence[-1] + diff\n\n\ndef next_geometric_progression(sequence):\n    \"\"\"Find the next element in a geometric progression.\"\"\"\n    ratio = sequence[1] / sequence[0]\n    return sequence[-1] * ratio\n\n\ndef main():\n    sequence = list(map(int, input().split()))\n    \n    if is_arithmetic_progression(sequence):\n        next_element = next_arithmetic_progression(sequence)\n        if next_element == int(next_element):\n            print(int(next_element))\n        else:\n            print(42)\n    elif is_geometric_progression(sequence):\n        next_element = next_geometric_progression(sequence)\n        if next_element == int(next_element):\n            print(int(next_element))\n        else:\n            print(42)\n    else:\n        print(42)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_distance(n, colors):\n    # Find the first and last occurrence of each color\n    first_occurrence = {}\n    last_occurrence = {}\n    \n    for i in range(n):\n        color = colors[i]\n        if color not in first_occurrence:\n            first_occurrence[color] = i\n        last_occurrence[color] = i\n    \n    # Get the list of unique colors\n    unique_colors = list(first_occurrence.keys())\n    \n    # Calculate the maximum distance\n    max_dist = 0\n    \n    # Compare distances from the first house to the last house of a different color\n    for color in unique_colors:\n        if colors[0]!= color:\n            max_dist = max(max_dist, last_occurrence[color])\n        if colors[-1]!= color:\n            max_dist = max(max_dist, n - 1 - first_occurrence[color])\n    \n    # Check if the maximum distance can be obtained by walking from the first house of a color to the last house of the same color\n    for color in unique_colors:\n        max_dist = max(max_dist, last_occurrence[color] - first_occurrence[color])\n    \n    return max_dist\n\nn = int(input())\ncolors = list(map(int, input().split()))\nprint(max_distance(n, colors))"}
{"solution": "n, m, k = map(int, input().split())\n\nlane = (k - 1) // (2 * m) + 1\ndesk = ((k - 1) % (2 * m)) // 2 + 1\nside = 'L' if (k - 1) % 2 == 0 else 'R'\n\nprint(lane, desk, side)"}
{"solution": "def possible_final_colors(n, s):\n    color_counts = {'B': 0, 'G': 0, 'R': 0}\n    for color in s:\n        color_counts[color] += 1\n\n    possible_colors = []\n    if color_counts['B'] % 2 == 1:\n        possible_colors.append('B')\n    if color_counts['G'] % 2 == 1:\n        possible_colors.append('G')\n    if color_counts['R'] % 2 == 1:\n        possible_colors.append('R')\n\n    if len(possible_colors) == 0 or len(possible_colors) == 3:\n        return 'BGR'\n    else:\n        return ''.join(sorted(possible_colors))\n\nn = int(input())\ns = input()\nprint(possible_final_colors(n, s))"}
