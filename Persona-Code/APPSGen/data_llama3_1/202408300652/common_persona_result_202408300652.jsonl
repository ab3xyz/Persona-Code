{"solution": "def max_accordion_length(s):\n    max_length = -1\n    opening_bracket_index = -1\n    colon_count = 0\n    vertical_line_count = 0\n\n    for i, char in enumerate(s):\n        if char == '[':\n            if opening_bracket_index == -1:\n                opening_bracket_index = i\n        elif char == ':':\n            if opening_bracket_index!= -1:\n                colon_count += 1\n                if colon_count == 1:\n                    continue\n                elif colon_count == 2:\n                    max_length = max(max_length, 4 + vertical_line_count)\n                    vertical_line_count = 0\n        elif char == '|':\n            if opening_bracket_index!= -1 and colon_count == 1:\n                vertical_line_count += 1\n        elif char == ']':\n            if opening_bracket_index!= -1 and colon_count == 2:\n                max_length = max(max_length, 4 + vertical_line_count)\n                opening_bracket_index = -1\n                colon_count = 0\n                vertical_line_count = 0\n\n    return max_length\n\ns = input()\nprint(max_accordion_length(s))"}
{"solution": "def max_digit_sum(x):\n    x_str = str(x)\n    max_sum = sum(int(digit) for digit in x_str)\n    max_num = x\n\n    for i in range(len(x_str) - 1, 0, -1):\n        if x_str[i]!= '9':\n            new_num_str = x_str[:i] + str(int(x_str[i]) - 1) + '9' * (len(x_str) - i - 1)\n            new_num = int(new_num_str)\n            new_sum = sum(int(digit) for digit in new_num_str)\n            if new_sum >= max_sum and new_num <= x:\n                max_sum = new_sum\n                max_num = new_num\n\n    return max_num\n\nx = int(input())\nprint(max_digit_sum(x))"}
{"solution": "def is_lucky_year(year):\n    \"\"\"Check if a year is lucky.\"\"\"\n    count = 0\n    for digit in str(year):\n        if digit!= '0':\n            count += 1\n        if count > 1:\n            return False\n    return True\n\n\ndef next_lucky_year(current_year):\n    \"\"\"Find the next lucky year.\"\"\"\n    next_year = current_year + 1\n    while not is_lucky_year(next_year):\n        next_year += 1\n    return next_year\n\n\ndef main():\n    current_year = int(input())\n    next_year = next_lucky_year(current_year)\n    print(next_year - current_year)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, q = read_ints()\n    painters = [tuple(read_ints()) for _ in range(q)]\n\n    dp = [[[0] * (q + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, q + 1):\n            l, r = painters[j - 1]\n            if l > i:\n                dp[i][i][j] = dp[i - 1][i - 1][j - 1]\n            elif r < i:\n                dp[i][i][j] = dp[i - 1][i - 1][j - 1]\n            else:\n                dp[i][i][j] = max(dp[i - 1][i - 1][j - 1], 1 + dp[l - 1][i - 1][j - 1])\n\n    for length in range(2, n + 1):\n        for i in range(1, n - length + 2):\n            j = i + length - 1\n            for k in range(1, q + 1):\n                dp[i][j][k] = max(dp[i][j][k - 1], dp[i][j - 1][k - 1])\n                l, r = painters[k - 1]\n                if l > j or r < i:\n                    continue\n                if l == i and r == j:\n                    dp[i][j][k] = max(dp[i][j][k], k)\n                else:\n                    dp[i][j][k] = max(dp[i][j][k], dp[i][r - 1][k - 1] + dp[l][j][k - 1])\n\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            ans = max(ans, dp[i][j][q - 2])\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_lucky(time):\n    return '7' in time\n\ndef find_lucky_time(x, target_time):\n    minutes = int(target_time[:2]) * 60 + int(target_time[3:])\n    y = 0\n    while True:\n        minutes -= x\n        if minutes < 0:\n            minutes += 24 * 60\n        hours = minutes // 60\n        mins = minutes % 60\n        time = f\"{hours:02d}:{mins:02d}\"\n        if is_lucky(time):\n            return y\n        y += 1\n\nx = int(input())\ntarget_time = input()\nprint(find_lucky_time(x, target_time))"}
{"solution": "n, pos, l, r = map(int, input().split())\n\nif l == 1 and r == n:\n    print(0)\nelif l == 1:\n    print(abs(pos - r) + 1)\nelif r == n:\n    print(abs(pos - l) + 1)\nelse:\n    left_cost = abs(pos - l) + (l - 1) + abs(r - n)\n    right_cost = abs(pos - r) + (n - r) + abs(l - 1)\n    print(min(left_cost, right_cost) + 1)"}
{"solution": "import sys\n\ndef solve(n, x, blows):\n    best_blow = None\n    best_blow_diff = -sys.maxsize\n\n    for d, h in blows:\n        if d > h:\n            return 1 + (x - 1) // (d - h)\n        diff = d - h\n        if diff > best_blow_diff:\n            best_blow_diff = diff\n            best_blow = (d, h)\n\n    if best_blow is None:\n        return -1\n\n    d, h = best_blow\n    if x <= d:\n        return 1\n    else:\n        return 1 + (x - d - 1) // best_blow_diff + 1\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, x = map(int, input().split())\n        blows = []\n        for _ in range(n):\n            d, h = map(int, input().split())\n            blows.append((d, h))\n        print(solve(n, x, blows))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    day = 0\n    while True:\n        day += 1\n        n += m\n        if n > 10**18:\n            n = 10**18\n        if n < day:\n            break\n        n -= day\n    print(day)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": ""}
{"solution": ""}
{"solution": "n = int(input())\nfull_weeks = n // 7\nremaining_days = n % 7\n\nmin_days_off = full_weeks * 2\nif remaining_days <= 2:\n    max_days_off = full_weeks * 2 + remaining_days\nelse:\n    max_days_off = full_weeks * 2 + 2\n\nprint(min_days_off, max_days_off)"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nn, a, b, p, q = map(int, input().split())\n\nred = n // a\nblue = n // b\nboth = n // lcm(a, b)\n\nmax_chocolates = max(red * p + (blue - both) * q, blue * q + (red - both) * p)\n\nprint(max_chocolates)"}
{"solution": "def max_golden_trophies(n, trophies):\n    max_length = 0\n    current_length = 0\n    first_silver = -1\n    last_silver = -1\n    silver_count = 0\n\n    for i in range(n):\n        if trophies[i] == 'G':\n            current_length += 1\n        else:\n            silver_count += 1\n            if first_silver == -1:\n                first_silver = i\n            last_silver = i\n            current_length = 0\n        max_length = max(max_length, current_length)\n\n    if silver_count == 0:\n        return max_length\n\n    if silver_count == 1:\n        return max_length + 1\n\n    if silver_count == 2:\n        if last_silver - first_silver == 1:\n            return max_length + 1\n        else:\n            return max_length + 2\n\n    max_length_with_swap = 0\n    current_length = 0\n\n    for i in range(first_silver):\n        if trophies[i] == 'G':\n            current_length += 1\n        else:\n            current_length = 0\n        max_length_with_swap = max(max_length_with_swap, current_length)\n\n    current_length = 0\n    for i in range(last_silver + 1, n):\n        if trophies[i] == 'G':\n            current_length += 1\n        else:\n            current_length = 0\n        max_length_with_swap = max(max_length_with_swap, current_length)\n\n    return max_length_with_swap + 1\n\n\nn = int(input())\ntrophies = input()\nprint(max_golden_trophies(n, trophies))"}
{"solution": "from collections import defaultdict, deque\n\ndef main():\n    n, k = map(int, input().split())\n    main_courses = list(map(int, input().split()))\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        dependencies = list(map(int, input().split()))\n        in_degree[i] = dependencies[0]\n        if dependencies[0] > 0:\n            for dependency in dependencies[1:]:\n                graph[dependency].append(i)\n\n    queue = deque([course for course in main_courses if in_degree[course] == 0])\n    result = []\n    visited = set()\n\n    while queue:\n        course = queue.popleft()\n        if course not in visited:\n            result.append(course)\n            visited.add(course)\n\n            for neighbor in graph[course]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n\n    if len(result)!= len(visited):\n        print(-1)\n        return\n\n    queue = deque([course for course in range(1, n + 1) if in_degree[course] == 0 and course not in visited])\n    while queue:\n        course = queue.popleft()\n        if course not in visited:\n            result.append(course)\n            visited.add(course)\n\n            for neighbor in graph[course]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n\n    if len(result)!= len(visited):\n        print(-1)\n        return\n\n    print(len(result))\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    p = list(map(int, sys.stdin.readline().split()))\n\n    s = []\n    for i in range(k):\n        while s and s[-1] < p[i]:\n            s.pop()\n        if s and s[-1] > p[i]:\n            print(-1)\n            return\n        s.append(p[i])\n\n    remaining = set(range(1, n + 1)) - set(p)\n    remaining = sorted(list(remaining), reverse=True)\n\n    for i in range(k, n):\n        while s and s[-1] < remaining[-1]:\n            s.pop()\n        if s and s[-1] > remaining[-1]:\n            print(-1)\n            return\n        if not s or s[-1] < p[i - 1]:\n            s.append(remaining.pop())\n\n    print(*p, end=' ')\n    print(*s, end=' ')\n    print(*remaining)\n\nif __name__ == '__main__':\n    solve()"}
{"solution": "def does_b_appear_in_sequence(a, b, c):\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\na, b, c = map(int, input().split())\nprint(does_b_appear_in_sequence(a, b, c))"}
{"solution": "def can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    if cnt_1 == cnt_4:\n        return 1\n    elif cnt_1 + cnt_2 == cnt_3 + cnt_4:\n        return 1\n    else:\n        return 0\n\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\nprint(can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4))"}
{"solution": "def mexican_wave(n, k, t):\n    if t < k:\n        return t\n    elif t < n:\n        return k\n    else:\n        return k - (t - n)\n\nn, k, t = map(int, input().split())\nprint(mexican_wave(n, k, t))"}
{"solution": "def lexicographically_minimal_string(s):\n    t = []\n    u = []\n    min_char = min(s)\n    s = list(s)\n    \n    while s or t:\n        if t and (not s or t[-1] <= min_char):\n            u.append(t.pop())\n        else:\n            char = s.pop(0)\n            t.append(char)\n            if s:\n                min_char = min(s)\n    \n    return ''.join(u)\n\ns = input().strip()\nprint(lexicographically_minimal_string(s))"}
{"solution": "def check_records(n, records):\n    for i in range(1, n):\n        plays_diff = records[i][0] - records[i-1][0]\n        clears_diff = records[i][1] - records[i-1][1]\n        \n        if plays_diff < 0 or clears_diff < 0:\n            return \"NO\"\n        \n        if clears_diff > plays_diff:\n            return \"NO\"\n    \n    return \"YES\"\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    records = [list(map(int, input().split())) for _ in range(n)]\n    \n    print(check_records(n, records))"}
{"solution": "def is_palindrome(time):\n    \"\"\"Check if a given time is a palindrome.\"\"\"\n    return time == time[::-1]\n\n\ndef next_palindrome(time):\n    \"\"\"Find the next palindrome time.\"\"\"\n    hours, minutes = map(int, time.split(':'))\n    minutes += 1\n    if minutes == 60:\n        minutes = 0\n        hours += 1\n        if hours == 24:\n            hours = 0\n    return f\"{hours:02d}:{minutes:02d}\"\n\n\ndef minutes_until_palindrome(time):\n    \"\"\"Calculate the minimum number of minutes until the next palindrome time.\"\"\"\n    minutes = 0\n    while not is_palindrome(time):\n        time = next_palindrome(time)\n        minutes += 1\n    return minutes\n\n\ndef main():\n    time = input()\n    print(minutes_until_palindrome(time))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_distance(n, arr):\n    min_idx = arr.index(1)\n    max_idx = arr.index(n)\n    \n    # Calculate the distance if we swap the minimum element with the first element\n    dist1 = abs(max_idx - 0)\n    \n    # Calculate the distance if we swap the minimum element with the last element\n    dist2 = abs(max_idx - (n - 1))\n    \n    # Calculate the distance if we swap the maximum element with the first element\n    dist3 = abs(min_idx - 0)\n    \n    # Calculate the distance if we swap the maximum element with the last element\n    dist4 = abs(min_idx - (n - 1))\n    \n    # Return the maximum distance\n    return max(dist1, dist2, dist3, dist4)\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(max_distance(n, arr))"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    mid = n // 2\n    if n % 2 == 0:\n        first_half = s[:mid]\n        second_half = s[mid:]\n    else:\n        first_half = s[:mid]\n        second_half = s[mid+1:]\n    \n    if first_half.lower() == second_half.lower()[::-1]:\n        return \"TAK\"\n    else:\n        return \"NIE\"\n\ns = input().strip()\nprint(is_s_palindrome(s))"}
{"solution": "from collections import Counter\n\ndef max_permutation(a, b):\n    a_count = Counter(a)\n    b = list(b)\n    result = []\n\n    for digit in b:\n        if a_count[digit] > 0:\n            result.append(digit)\n            a_count[digit] -= 1\n        else:\n            for d in sorted(a_count.keys(), reverse=True):\n                if a_count[d] > 0:\n                    result.append(d)\n                    a_count[d] -= 1\n                    break\n            else:\n                break\n\n    for d in sorted(a_count.keys(), reverse=True):\n        result.extend([d] * a_count[d])\n\n    return ''.join(result)\n\na = input()\nb = input()\nprint(max_permutation(a, b))"}
{"solution": "def check_win(matrix, i, j):\n    # Check horizontal\n    count = 0\n    for k in range(max(0, j-4), min(10, j+5)):\n        if matrix[i][k] == 'X':\n            count += 1\n        else:\n            count = 0\n        if count >= 5:\n            return True\n\n    # Check vertical\n    count = 0\n    for k in range(max(0, i-4), min(10, i+5)):\n        if matrix[k][j] == 'X':\n            count += 1\n        else:\n            count = 0\n        if count >= 5:\n            return True\n\n    # Check diagonal (top-left to bottom-right)\n    count = 0\n    for k in range(max(0, i-4), min(10, i+5)):\n        for col in range(max(0, j-4), min(10, j+5)):\n            if k - i == col - j and matrix[k][col] == 'X':\n                count += 1\n            else:\n                count = 0\n            if count >= 5:\n                return True\n\n    # Check diagonal (bottom-left to top-right)\n    count = 0\n    for k in range(max(0, i-4), min(10, i+5)):\n        for col in range(max(0, j-4), min(10, j+5)):\n            if k - i == j - col and matrix[k][col] == 'X':\n                count += 1\n            else:\n                count = 0\n            if count >= 5:\n                return True\n\n    return False\n\n\ndef check_win_in_one_move(matrix):\n    for i in range(10):\n        for j in range(10):\n            if matrix[i][j] == '.':\n                matrix[i] = matrix[i][:j] + 'X' + matrix[i][j+1:]\n                if check_win(matrix, i, j):\n                    return True\n                matrix[i] = matrix[i][:j] + '.' + matrix[i][j+1:]\n    return False\n\n\nmatrix = [input() for _ in range(10)]\nif check_win_in_one_move(matrix):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def solve(n, k):\n    if k > n * (n + 1) // 2:\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i, n):\n            if k > 0:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 1\n\n    return matrix\n\n\ndef print_matrix(matrix):\n    if matrix == -1:\n        print(-1)\n    else:\n        for row in matrix:\n            print(' '.join(map(str, row)))\n\n\nn, k = map(int, input().split())\nmatrix = solve(n, k)\nprint_matrix(matrix)"}
{"solution": "import math\n\nx, y, z = map(float, input().split())\n\nexpressions = [\n    (x ** y) ** z,\n    (x ** z) ** y,\n    (x ** y) ** z,\n    (x ** z) ** y,\n    (y ** x) ** z,\n    (y ** z) ** x,\n    (y ** x) ** z,\n    (y ** z) ** x,\n    (z ** x) ** y,\n    (z ** y) ** x,\n    (z ** x) ** y,\n    (z ** y) ** x\n]\n\nmax_index = expressions.index(max(expressions))\n\noptions = [\n    f\"x^{y}^{z}\",\n    f\"x^{z}^{y}\",\n    f\"(x^{y})^{z}\",\n    f\"(x^{z})^{y}\",\n    f\"y^{x}^{z}\",\n    f\"y^{z}^{x}\",\n    f\"(y^{x})^{z}\",\n    f\"(y^{z})^{x}\",\n    f\"z^{x}^{y}\",\n    f\"z^{y}^{x}\",\n    f\"(z^{x})^{y}\",\n    f\"(z^{y})^{x}\"\n]\n\nprint(options[max_index])"}
{"solution": "def min_operations(n, s):\n    \"\"\"\n    Calculate the minimum number of operations to type a string.\n\n    Args:\n    n (int): The length of the string.\n    s (str): The string to be typed.\n\n    Returns:\n    int: The minimum number of operations.\n    \"\"\"\n    # Initialize the minimum number of operations as the length of the string\n    min_ops = n\n\n    # Iterate over the possible lengths of the first part of the string\n    for i in range(1, n // 2 + 1):\n        # Check if the string can be formed by copying the first part and appending the rest\n        if s[:i] * (n // i) == s[:n // i * i]:\n            # Update the minimum number of operations\n            min_ops = min(min_ops, i + 1 + (n - i * (n // i)))\n\n    return min_ops\n\n\n# Read the input\nn = int(input())\ns = input()\n\n# Calculate and print the minimum number of operations\nprint(min_operations(n, s))"}
{"solution": "import sys\n\ndef read_input():\n    n = int(sys.stdin.readline())\n    files = []\n    for _ in range(n):\n        name, type = sys.stdin.readline().split()\n        files.append((name, int(type)))\n    return n, files\n\ndef solve(n, files):\n    examples = [file for file in files if file[1] == 1]\n    regulars = [file for file in files if file[1] == 0]\n\n    e = len(examples)\n    moves = []\n\n    # Move examples to correct positions\n    for i, file in enumerate(examples):\n        if file[0]!= str(i + 1):\n            moves.append((file[0], str(i + 1)))\n\n    # Move regulars to correct positions\n    for i, file in enumerate(regulars):\n        if file[0]!= str(i + e + 1):\n            moves.append((file[0], str(i + e + 1)))\n\n    # Handle conflicts\n    temp_files = set()\n    for i in range(1, n + 1):\n        temp_files.add(str(i))\n\n    for file in files:\n        if file[0] in temp_files:\n            temp_files.remove(file[0])\n\n    temp_files = list(temp_files)\n    temp_files.sort()\n\n    for i, move in enumerate(moves):\n        if move[1] in [m[0] for m in moves[:i]]:\n            moves.insert(i, (move[1], temp_files.pop(0)))\n\n    return moves\n\ndef print_output(moves):\n    print(len(moves))\n    for move in moves:\n        print(f\"move {move[0]} {move[1]}\")\n\ndef main():\n    n, files = read_input()\n    moves = solve(n, files)\n    print_output(moves)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_replacements(ticket):\n    \"\"\"\n    Calculate the minimum number of digits Luba needs to replace to make the ticket lucky.\n    \n    A ticket is considered lucky if the sum of the first three digits equals the sum of the last three digits.\n    \n    Parameters:\n    ticket (str): A string consisting of 6 characters (all characters are digits from 0 to 9) \u2014 this string denotes Luba's ticket.\n    \n    Returns:\n    int: The minimum possible number of digits Luba needs to replace to make the ticket lucky.\n    \"\"\"\n    \n    # Calculate the sum of the first three digits\n    sum_first_half = sum(int(digit) for digit in ticket[:3])\n    \n    # Calculate the sum of the last three digits\n    sum_second_half = sum(int(digit) for digit in ticket[3:])\n    \n    # Calculate the difference between the sums of the two halves\n    difference = abs(sum_first_half - sum_second_half)\n    \n    # If the difference is 0, the ticket is already lucky\n    if difference == 0:\n        return 0\n    \n    # If the difference is less than or equal to 9, we can make the ticket lucky by replacing one digit\n    if difference <= 9:\n        return 1\n    \n    # If the difference is greater than 9, we need to replace at least two digits\n    # We can make the ticket lucky by replacing two digits in the half with the larger sum\n    # The maximum sum of two digits is 18, so we can reduce the sum by at most 18\n    # We can reduce the sum by at least 1 by replacing one digit, so we can reduce the sum by at least 19\n    # Therefore, we can make the ticket lucky by replacing at most 2 digits\n    return 2\n\n\n# Read the ticket from the input\nticket = input()\n\n# Calculate and print the minimum number of replacements\nprint(min_replacements(ticket))"}
{"solution": "import math\n\nm, x = map(int, input().split())\nprint(m - 1 if m % 2 == 0 else m // 2)"}
{"solution": "def mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef solve(n, k):\n    mod = 10**6 + 3\n    total_days = pow(2, n, mod)\n    prob = 1\n    for i in range(1, k):\n        prob = (prob * (total_days - i)) % mod\n        prob = (prob * mod_inverse(total_days, mod)) % mod\n    prob = (1 - prob) % mod\n    return prob, 1\n\nn, k = map(int, input().split())\na, b = solve(n, k)\nprint(a, b)"}
{"solution": "def check_journey(n, journey):\n    \"\"\"\n    Checks if Limak's journey description is valid.\n\n    Args:\n    n (int): The number of parts in the journey.\n    journey (list): A list of tuples, where each tuple contains the distance and direction of a part of the journey.\n\n    Returns:\n    bool: True if the journey description is valid, False otherwise.\n    \"\"\"\n    position = 0  # Start at the North Pole\n\n    for distance, direction in journey:\n        if position == 0:  # At the North Pole\n            if direction!= \"South\":\n                return False\n        elif position == 20000:  # At the South Pole\n            if direction!= \"North\":\n                return False\n        elif direction == \"North\":\n            position -= distance\n            if position < 0:  # Can't move further north than the North Pole\n                position = 0\n        elif direction == \"South\":\n            position += distance\n            if position > 20000:  # Can't move further south than the South Pole\n                position = 20000\n        # Ignore East and West directions, as they don't affect the north-south position\n\n    return position == 0  # The journey must end at the North Pole\n\n\nn = int(input())\njourney = []\nfor _ in range(n):\n    distance, direction = input().split()\n    journey.append((int(distance), direction))\n\nif check_journey(n, journey):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_common_elements(a1, b1, a2, b2, L, R):\n    # Calculate the LCM of a1 and a2\n    lcm_value = lcm(a1, a2)\n    \n    # Calculate the first common element\n    first_common = (b2 - b1) // lcm_value * a1 + b1\n    if (b2 - b1) % lcm_value!= 0:\n        return 0\n    \n    # Calculate the first common element within the range [L, R]\n    first_common_in_range = max(L, first_common)\n    if first_common_in_range % lcm_value!= first_common % lcm_value:\n        first_common_in_range += lcm_value - first_common_in_range % lcm_value\n    \n    # Calculate the last common element within the range [L, R]\n    last_common_in_range = min(R, first_common + lcm_value * (R - first_common) // lcm_value)\n    \n    # Calculate the number of common elements\n    count = (last_common_in_range - first_common_in_range) // lcm_value + 1\n    \n    return count\n\na1, b1, a2, b2, L, R = map(int, input().split())\nprint(count_common_elements(a1, b1, a2, b2, L, R))"}
{"solution": "def max_min_pieces(n, a, b):\n    \"\"\"\n    Calculate the maximum possible number x such that Ivan can distribute the cakes \n    according to the aforementioned conditions, and each plate will contain at least x pieces of cake.\n\n    Args:\n        n (int): The number of plates.\n        a (int): The number of pieces of the first cake.\n        b (int): The number of pieces of the second cake.\n\n    Returns:\n        int: The maximum possible number x.\n    \"\"\"\n    # Calculate the total number of pieces\n    total_pieces = a + b\n    \n    # Initialize the minimum and maximum possible number of pieces per plate\n    low = 1\n    high = total_pieces // n\n    \n    # Perform binary search to find the maximum possible number of pieces per plate\n    while low <= high:\n        mid = (low + high) // 2\n        \n        # Calculate the number of plates required for the current number of pieces per plate\n        plates_required = (a + mid - 1) // mid + (b + mid - 1) // mid\n        \n        # If the number of plates required is less than or equal to the total number of plates,\n        # update the minimum possible number of pieces per plate\n        if plates_required <= n:\n            low = mid + 1\n        # Otherwise, update the maximum possible number of pieces per plate\n        else:\n            high = mid - 1\n    \n    # The maximum possible number of pieces per plate is the last value of 'low' that made 'plates_required' greater than 'n'\n    return low - 1\n\n\n# Read the input\nn, a, b = map(int, input().split())\n\n# Calculate and print the maximum possible number x\nprint(max_min_pieces(n, a, b))"}
{"solution": "def is_valid_flag(n, m, flag):\n    # Check if the number of unique colors is 3\n    colors = set()\n    for row in flag:\n        for cell in row:\n            colors.add(cell)\n    if len(colors)!= 3:\n        return False\n\n    # Check if the flag can be divided into three equal stripes\n    stripe_height = n // 3\n    if n % 3!= 0:\n        return False\n\n    # Check each stripe\n    for i in range(3):\n        stripe_color = flag[i * stripe_height][0]\n        for j in range(stripe_height):\n            for k in range(m):\n                if flag[i * stripe_height + j][k]!= stripe_color:\n                    return False\n\n    return True\n\n\nn, m = map(int, input().split())\nflag = [input() for _ in range(n)]\n\nif is_valid_flag(n, m, flag):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\nn = int(input())\n\nlayer = math.floor((math.sqrt(6 * n + 1) - 1) / 2)\nstart = 3 * layer * (layer - 1) + 1\nside_length = 6 * layer\n\nx, y = 0, 0\n\nif n < start:\n    layer -= 1\n    start = 3 * layer * (layer - 1) + 1\n    side_length = 6 * layer\n\n    x, y = layer, layer\n    n -= start\n    n %= side_length\n\n    if n < layer:\n        x -= n\n    elif n < 2 * layer:\n        y -= n - layer\n    elif n < 3 * layer:\n        x += n - 2 * layer\n    else:\n        y += n - 3 * layer\n\nelse:\n    x, y = -layer, layer\n    n -= start\n    n %= side_length\n\n    if n < layer:\n        y -= n\n    elif n < 2 * layer:\n        x += n - layer\n    elif n < 3 * layer:\n        y += n - 2 * layer\n    else:\n        x -= n - 3 * layer\n\nprint(x, y)"}
{"solution": "import math\n\ndef can_break_shield(a, b, c):\n    gcd_ab = math.gcd(a, b)\n    if c % gcd_ab == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\na, b, c = map(int, input().split())\nprint(can_break_shield(a, b, c))"}
{"solution": "def can_tracks_coincide(n, L, kefa_barriers, sasha_barriers):\n    # Calculate distances between consecutive barriers for Kefa\n    kefa_distances = [(kefa_barriers[(i + 1) % n] - kefa_barriers[i]) % L for i in range(n)]\n    # Calculate distances between consecutive barriers for Sasha\n    sasha_distances = [(sasha_barriers[(i + 1) % n] - sasha_barriers[i]) % L for i in range(n)]\n    \n    # Double the kefa_distances to handle circular rotation\n    doubled_kefa_distances = kefa_distances + kefa_distances\n    \n    # Check if sasha_distances is a sublist of doubled_kefa_distances\n    for i in range(n):\n        if doubled_kefa_distances[i:i + n] == sasha_distances:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_barriers, sasha_barriers))"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome(s):\n    max_length = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if not is_palindrome(substring):\n                max_length = max(max_length, len(substring))\n    return max_length\n\ns = input()\nprint(longest_non_palindrome(s))"}
{"solution": "def is_round_rated(n, ratings):\n    \"\"\"\n    Determine if the current round is rated, unrated, or it's impossible to determine whether it is rated or not.\n\n    Args:\n    n (int): The number of round participants.\n    ratings (list): A list of tuples containing the rating of each participant before and after the round.\n\n    Returns:\n    str: \"rated\" if the round is rated for sure, \"unrated\" if the round is unrated for sure, \"maybe\" if it's impossible to determine.\n    \"\"\"\n\n    # Check if any participant's rating has changed\n    if any(before!= after for before, after in ratings):\n        return \"rated\"\n\n    # Check if the participants took places in non-increasing order of their rating\n    if all(before >= after for (before, _), (_, after) in zip(ratings, ratings[1:])):\n        return \"maybe\"\n\n    return \"unrated\"\n\n\ndef main():\n    n = int(input())\n    ratings = [tuple(map(int, input().split())) for _ in range(n)]\n    print(is_round_rated(n, ratings))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def nearest_zero(n, arr):\n    zeros = [i for i, x in enumerate(arr) if x == 0]\n    result = []\n\n    for i in range(n):\n        result.append(min([abs(i - zero) for zero in zeros]))\n\n    return result\n\n\nn = int(input())\narr = list(map(int, input().split()))\n\nprint(*nearest_zero(n, arr))"}
{"solution": "def count_distinct_cyclical_strings(n, s):\n    def is_substring_in_cyclical_shifts(t, s):\n        t_extended = t + t\n        return any(s in t_extended[i:i+len(t)] for i in range(len(t)))\n    \n    distinct_cyclical_strings = set()\n    \n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if is_substring_in_cyclical_shifts(t, s):\n            distinct_cyclical_strings.add(t)\n    \n    return len(distinct_cyclical_strings)\n\nfrom itertools import product\nn = int(input())\ns = input().strip()\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import math\n\ndef polar_angle(x, y):\n    \"\"\"Calculate the polar angle of a vector.\"\"\"\n    return math.atan2(y, x)\n\ndef angle_between_vectors(a, b):\n    \"\"\"Calculate the non-oriented angle between two vectors.\"\"\"\n    return min(abs(a - b), 2 * math.pi - abs(a - b))\n\ndef main():\n    n = int(input())\n    vectors = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        vectors.append((polar_angle(x, y), i + 1))\n\n    vectors.sort()\n    min_angle = float('inf')\n    result = None\n\n    for i in range(n):\n        angle = angle_between_vectors(vectors[i][0], vectors[(i + 1) % n][0])\n        if angle < min_angle:\n            min_angle = angle\n            result = (vectors[i][1], vectors[(i + 1) % n][1])\n\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nd, k, a, b, t = map(int, sys.stdin.readline().split())\n\nif d <= k:\n    print(d * a)\nelse:\n    full_segments = d // k\n    remaining_distance = d % k\n\n    time_for_full_segments = full_segments * k * a + (full_segments - 1) * t\n\n    if remaining_distance == 0:\n        print(time_for_full_segments + t)\n    else:\n        time_drive_remaining = remaining_distance * a + t\n        time_walk_remaining = remaining_distance * b\n\n        print(time_for_full_segments + min(time_drive_remaining, time_walk_remaining))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(n, k):\n    if n < k:\n        return -1\n    if n % k == 0:\n        return [n // k] * k\n    if k == 1:\n        return [n]\n    if k == 2:\n        d = n // 2\n        if n % 2 == 0:\n            return [d, d]\n        else:\n            return [d, d + 1]\n    d = n // k\n    r = n % k\n    if r == 0:\n        return [d] * k\n    if r == 1:\n        return [d] * (k - 1) + [d + 1]\n    if r == 2 and k % 2 == 0:\n        return [d] * (k - 2) + [d + 1, d + 1]\n    if r == 2 and k % 2 == 1:\n        return [d] * (k - 3) + [d + 1, d + 1, d + 2]\n    if r > 2:\n        return [d] * (k - r) + [d + 1] * (r - 1) + [d + 2]\n\nn, k = map(int, input().split())\nresult = solve(n, k)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def count_pairs(n, m):\n    \"\"\"\n    Counts the number of pairs of integers (x, y) such that 1 \u2264 x \u2264 n, 1 \u2264 y \u2264 m and (x + y) is divisible by 5.\n    \n    Args:\n        n (int): The upper limit of the first column.\n        m (int): The upper limit of the second column.\n    \n    Returns:\n        int: The number of pairs of integers (x, y) such that 1 \u2264 x \u2264 n, 1 \u2264 y \u2264 m and (x + y) is divisible by 5.\n    \"\"\"\n    count = 0\n    for i in range(5):\n        count += (n - i) // 5 * (m - (5 - i)) // 5\n        if (n - i) % 5 >= (5 - i):\n            count += (n - i) % 5 - (5 - i) + 1\n    return count\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))"}
{"solution": "import sys\n\ndef max_beauty(n, x, a):\n    if x == 1:\n        return max_subarray_sum(a)\n\n    max_sum = max_subarray_sum(a)\n    max_sum_with_x = max_subarray_sum_with_x(a, x)\n\n    return max(max_sum, max_sum_with_x)\n\n\ndef max_subarray_sum(a):\n    max_sum = 0\n    current_sum = 0\n\n    for num in a:\n        current_sum = max(0, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\n\ndef max_subarray_sum_with_x(a, x):\n    prefix_sum = [0] * (len(a) + 1)\n    for i in range(len(a)):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    max_sum = float('-inf')\n    min_prefix_sum = 0\n\n    for i in range(len(a)):\n        max_sum = max(max_sum, prefix_sum[i + 1] - min_prefix_sum)\n        min_prefix_sum = min(min_prefix_sum, prefix_sum[i + 1] - x * a[i])\n\n    return max_sum * x\n\n\ndef main():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    print(max_beauty(n, x, a))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_kth_largest(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(m, x // i)\n        return count\n\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_less_equal(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\nn, m, k = map(int, input().split())\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    start += (k - 1) // length\n    return str(start)[(k - 1) % length]\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "def max_bourles(n, m, r, s, b):\n    max_bourles = r\n    for buy_price in s:\n        for sell_price in b:\n            if buy_price < sell_price:\n                shares = r // buy_price\n                bourles = shares * sell_price\n                max_bourles = max(max_bourles, bourles + r % buy_price)\n    return max_bourles\n\nn, m, r = map(int, input().split())\ns = sorted(map(int, input().split()))\nb = sorted(map(int, input().split()))\n\nprint(max_bourles(n, m, r, s, b))"}
{"solution": "def find_original_message(t):\n    n = len(t)\n    \n    # \u041f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u0432\u0441\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0434\u043b\u0438\u043d\u044b \u043d\u0430\u043b\u043e\u0436\u0435\u043d\u0438\u044f\n    for overlap in range(1, n // 2 + 1):\n        # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u043c\u043e\u0436\u043d\u043e \u043b\u0438 \u0440\u0430\u0437\u0434\u0435\u043b\u0438\u0442\u044c \u0441\u0442\u0440\u043e\u043a\u0443 t \u043d\u0430 \u0434\u0432\u0435 \u0447\u0430\u0441\u0442\u0438 \u0441 \u043d\u0430\u043b\u043e\u0436\u0435\u043d\u0438\u0435\u043c \u0434\u043b\u0438\u043d\u044b overlap\n        if t[:overlap] == t[-overlap:]:\n            s = t[:-overlap]\n            if s + t[-overlap:] == t and len(s) > overlap:\n                return \"YES\", s\n    \n    return \"NO\", None\n\n# \u0427\u0442\u0435\u043d\u0438\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\nt = input().strip()\n\n# \u041f\u043e\u0438\u0441\u043a \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0433\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f s\nresult, s = find_original_message(t)\n\n# \u0412\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\nprint(result)\nif result == \"YES\":\n    print(s)"}
{"solution": "import math\n\ndef find_teams(n):\n    teams = set()\n    for i in range(1, int(math.sqrt(2 * n)) + 1):\n        if (n - i * (i - 1) // 2) % i == 0:\n            x = (n - i * (i - 1) // 2) // i\n            if x >= i:\n                teams.add(x)\n    return teams\n\ndef main():\n    n = int(input())\n    teams = find_teams(n)\n    if not teams:\n        print(-1)\n    else:\n        for team in sorted(teams):\n            print(team)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_beauty(n, s, b):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    max_beauty = 0\n    for i in range(n // 2):\n        char1 = s[i]\n        char2 = s[n - i - 1]\n        if char1 == char2:\n            if char_count[char1] > 2:\n                max_beauty += b[i] + b[n - i - 1]\n                char_count[char1] -= 2\n            else:\n                max_beauty += max(b[i], b[n - i - 1])\n                char_count[char1] -= 1\n        else:\n            max_beauty += b[i] + b[n - i - 1]\n            char_count[char1] -= 1\n            char_count[char2] -= 1\n\n    return max_beauty\n\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\nprint(max_beauty(n, s, b))"}
{"solution": "def can_be_weighted(w, m):\n    \"\"\"\n    Determine whether an item of mass m can be weighed using the given weights in a balanced manner.\n\n    Args:\n    w (int): The number defining the masses of the weights.\n    m (int): The mass of the item.\n\n    Returns:\n    bool: True if the item can be weighted, False otherwise.\n    \"\"\"\n    # Calculate the maximum weight that can be represented using the given weights\n    max_weight = (w ** 101 - 1) // (w - 1)\n\n    # Check if the mass of the item is within the range of representable weights\n    if m > max_weight:\n        return False\n\n    # Check if the mass of the item can be represented as a sum of powers of w\n    for i in range(101):\n        if (m >> i) & 1:\n            # If the mass of the item has a 1 in the ith bit, subtract w^i from the mass\n            m -= w ** i\n\n    # If the mass of the item becomes 0, it can be weighted\n    return m == 0\n\n\ndef main():\n    # Read the input\n    w, m = map(int, input().split())\n\n    # Check if the item can be weighted\n    if can_be_weighted(w, m):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve(n, k):\n    if k > n:\n        return [-1] * k\n\n    max_val = n.bit_length() - 1\n    ans = []\n\n    while k > 0:\n        if n >= (1 << max_val) and k >= (n >> max_val):\n            ans.extend([max_val] * (n >> max_val))\n            n -= (1 << max_val) * (n >> max_val)\n            k -= (n >> max_val)\n        else:\n            max_val -= 1\n\n    if n!= 0:\n        return \"No\"\n\n    ans.extend([0] * (k - len(ans)))\n    return \"Yes\\n\" + \" \".join(map(str, sorted(ans, reverse=True)))\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "def champagne_pyramid(n, t):\n    pyramid = [[0.0] * i for i in range(1, n + 1)]\n    pyramid[0][0] = t\n\n    for i in range(n):\n        for j in range(len(pyramid[i])):\n            if pyramid[i][j] > 1:\n                excess = (pyramid[i][j] - 1) / 2\n                pyramid[i][j] = 1\n                if i < n - 1:\n                    pyramid[i + 1][j] += excess\n                    pyramid[i + 1][j + 1] += excess\n\n    return sum(1 for row in pyramid for glass in row if glass >= 1)\n\n\nn, t = map(int, input().split())\nprint(champagne_pyramid(n, t))"}
{"solution": "n = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\n\nif n == 1:\n    print(-1)\nelif n == 2:\n    x1, y1 = vertices[0]\n    x2, y2 = vertices[1]\n    if x1!= x2 and y1!= y2:\n        print(abs(x1 - x2) * abs(y1 - y2))\n    else:\n        print(-1)\nelif n == 3:\n    x_coords = set()\n    y_coords = set()\n    for x, y in vertices:\n        x_coords.add(x)\n        y_coords.add(y)\n    if len(x_coords) == 2 and len(y_coords) == 2:\n        x1, x2 = x_coords\n        y1, y2 = y_coords\n        print(abs(x1 - x2) * abs(y1 - y2))\n    else:\n        print(-1)\nelif n == 4:\n    x_coords = set()\n    y_coords = set()\n    for x, y in vertices:\n        x_coords.add(x)\n        y_coords.add(y)\n    if len(x_coords) == 2 and len(y_coords) == 2:\n        x1, x2 = x_coords\n        y1, y2 = y_coords\n        print(abs(x1 - x2) * abs(y1 - y2))\n    else:\n        print(-1)"}
{"solution": "import math\n\nn = int(input())\na = int(input())\nb = int(input())\n\ntotal_length = 2 * (2 * a + b)\nnum_bars = math.ceil(total_length / n)\n\nprint(num_bars)"}
{"solution": "def can_sort_array(n, a, swaps):\n    \"\"\"\n    Checks if it's possible to sort the array in ascending order using the given swaps.\n\n    Args:\n    n (int): The number of elements in the array.\n    a (list): The array of integers.\n    swaps (str): A string of 0s and 1s representing the allowed swaps.\n\n    Returns:\n    bool: True if the array can be sorted, False otherwise.\n    \"\"\"\n    # Initialize a list to store the maximum value that can be placed at each position\n    max_values = [0] * n\n\n    # Iterate over the array from right to left\n    for i in range(n - 1, -1, -1):\n        # If the current element is the maximum value, update the max_values list\n        if i == n - 1 or swaps[i] == '1':\n            max_values[i] = a[i]\n        else:\n            # If the current element cannot be swapped with the next one, it must be the maximum value\n            max_values[i] = max(a[i], max_values[i + 1])\n\n    # Check if the array can be sorted by comparing each element with the maximum value that can be placed at its position\n    for i in range(n):\n        if a[i] > max_values[i]:\n            return False\n\n    return True\n\n\ndef main():\n    # Read the input\n    n = int(input())\n    a = list(map(int, input().split()))\n    swaps = input()\n\n    # Check if the array can be sorted\n    if can_sort_array(n, a, swaps):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_time(row, seat):\n    # Calculate the number of rows the attendants need to move\n    rows_to_move = (row + 1) // 2\n\n    # Calculate the time spent moving rows\n    time_spent_moving = rows_to_move - 1\n\n    # Calculate the time spent serving rows\n    time_spent_serving = 6 * (rows_to_move - 1)\n\n    # Calculate the time spent serving the current row\n    if row % 2 == 1:\n        # First attendant serves the row\n        if seat in 'fefd':\n            time_spent_serving_current_row = 'fefd'.index(seat) + 1\n        else:\n            time_spent_serving_current_row = 3 + 'cba'.index(seat) + 1\n    else:\n        # Second attendant serves the row\n        if seat in 'fefd':\n            time_spent_serving_current_row = 'fefd'.index(seat) + 1\n        else:\n            time_spent_serving_current_row = 3 + 'cba'.index(seat) + 1\n\n    # Calculate the total time\n    total_time = time_spent_moving + time_spent_serving + time_spent_serving_current_row\n\n    return total_time\n\n\ndef main():\n    input_str = input()\n    row = int(input_str[:-1])\n    seat = input_str[-1]\n\n    print(calculate_time(row, seat))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def convert_to_decimal(digits, base):\n    decimal = 0\n    for i, digit in enumerate(reversed(digits)):\n        decimal += digit * (base ** i)\n    return decimal\n\ndef compare_numbers():\n    n, bx = map(int, input().split())\n    x_digits = list(map(int, input().split()))\n\n    m, by = map(int, input().split())\n    y_digits = list(map(int, input().split()))\n\n    x_decimal = convert_to_decimal(x_digits, bx)\n    y_decimal = convert_to_decimal(y_digits, by)\n\n    if x_decimal < y_decimal:\n        print('<')\n    elif x_decimal > y_decimal:\n        print('>')\n    else:\n        print('=')\n\ncompare_numbers()"}
{"solution": "def mex(arr):\n    arr.sort()\n    mex = 0\n    for num in arr:\n        if num == mex:\n            mex += 1\n    return mex\n\ndef nim_sum(arr):\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    if n == 1:\n        if arr[0] == 0:\n            print(\"BitAryo\")\n        else:\n            print(\"BitLGM\")\n    elif n == 2:\n        if arr[0] == arr[1]:\n            print(\"BitLGM\")\n        else:\n            print(\"BitAryo\")\n    else:\n        if mex(arr) == min(arr):\n            print(\"BitAryo\")\n        else:\n            print(\"BitLGM\")\n\nsolve()"}
{"solution": "import math\nimport sys\n\ndef prime_factors(n):\n    factors = {}\n    while n % 2 == 0:\n        factors[2] = factors.get(2, 0) + 1\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            factors[i] = factors.get(i, 0) + 1\n            n = n // i\n    if n > 2:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    k_factors = prime_factors(k)\n    prefix_factors = [{} for _ in range(n + 1)]\n    suffix_factors = [{} for _ in range(n + 1)]\n\n    for i in range(n):\n        factors = prime_factors(a[i])\n        for p, c in factors.items():\n            prefix_factors[i + 1][p] = prefix_factors[i].get(p, 0) + c\n            suffix_factors[n - i - 1][p] = suffix_factors[n - i].get(p, 0) + c\n\n    ans = 0\n    for i in range(n + 1):\n        for j in range(n + 1):\n            if i + j > n:\n                break\n            if all(prefix_factors[i].get(p, 0) + suffix_factors[j].get(p, 0) >= c for p, c in k_factors.items()):\n                ans += 1\n\n    print(ans - (n + 1) + 1)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_distribute_balloons(n, k, s):\n    color_counts = {}\n    for color in s:\n        if color in color_counts:\n            color_counts[color] += 1\n        else:\n            color_counts[color] = 1\n\n    for count in color_counts.values():\n        if count > k:\n            return \"NO\"\n\n    return \"YES\"\n\nn, k = map(int, input().split())\ns = input().strip()\n\nprint(can_distribute_balloons(n, k, s))"}
{"solution": "def find_distance_between_minima():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    min_val = min(a)\n    min_indices = [i for i, x in enumerate(a) if x == min_val]\n\n    min_distance = float('inf')\n    for i in range(len(min_indices) - 1):\n        min_distance = min(min_distance, min_indices[i + 1] - min_indices[i])\n\n    print(min_distance)\n\nfind_distance_between_minima()"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef main():\n    t, w, b = map(int, input().split())\n    g = gcd(w, b)\n    lcm = (w * b) // g\n    count = t // lcm\n    if t % lcm!= 0:\n        count += 1\n    numerator = count\n    denominator = t\n    common_divisor = gcd(numerator, denominator)\n    print(f\"{numerator // common_divisor}/{denominator // common_divisor}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def determine_vote_result(x, y, z):\n    \"\"\"\n    Determine the result of Nauuo's comment based on the number of upvotes, downvotes, and unknown votes.\n\n    Args:\n        x (int): The number of upvotes.\n        y (int): The number of downvotes.\n        z (int): The number of unknown votes.\n\n    Returns:\n        str: The result of Nauuo's comment, either \"+\", \"-\", \"0\", or \"?\".\n    \"\"\"\n\n    # Calculate the difference between upvotes and downvotes\n    diff = x - y\n\n    # If the difference is greater than the number of unknown votes, the result is certain\n    if diff > z:\n        return \"+\"\n    elif diff < -z:\n        return \"-\"\n    elif diff == 0 and z == 0:\n        return \"0\"\n    else:\n        return \"?\"\n\n\n# Read the input\nx, y, z = map(int, input().split())\n\n# Determine and print the result\nprint(determine_vote_result(x, y, z))"}
{"solution": "def min_length_changed_subsegment(n, operations, x, y):\n    \"\"\"\n    Calculate the minimum length of subsegment that needs to be changed \n    so that the robot will go from (0, 0) to (x, y).\n\n    Args:\n    n (int): The number of operations.\n    operations (str): A string of n characters representing the operations.\n    x (int): The x-coordinate of the target cell.\n    y (int): The y-coordinate of the target cell.\n\n    Returns:\n    int: The minimum possible length of subsegment that can be changed. \n         If this change is impossible, return -1.\n    \"\"\"\n    # Calculate the initial position after performing all operations\n    initial_x = operations.count('R') - operations.count('L')\n    initial_y = operations.count('U') - operations.count('D')\n\n    # Calculate the difference between the target position and the initial position\n    diff_x = x - initial_x\n    diff_y = y - initial_y\n\n    # Initialize the minimum length of changed subsegment\n    min_length = float('inf')\n\n    # Check all possible subsegments\n    for i in range(n):\n        for j in range(i, n):\n            # Calculate the position after performing the operations up to index j\n            new_x = operations[:i].count('R') - operations[:i].count('L') + \\\n                    operations[i:j+1].count('L') - operations[i:j+1].count('R') + \\\n                    operations[j+1:].count('R') - operations[j+1:].count('L')\n            new_y = operations[:i].count('U') - operations[:i].count('D') + \\\n                    operations[i:j+1].count('D') - operations[i:j+1].count('U') + \\\n                    operations[j+1:].count('U') - operations[j+1:].count('D')\n\n            # Check if the new position is equal to the target position\n            if new_x == x and new_y == y:\n                # Update the minimum length of changed subsegment\n                min_length = min(min_length, j - i + 1)\n\n    # If no valid subsegment is found, return -1\n    if min_length == float('inf'):\n        return -1\n    else:\n        return min_length\n\n\n# Read input\nn = int(input())\noperations = input()\nx, y = map(int, input().split())\n\n# Calculate and print the minimum length of changed subsegment\nprint(min_length_changed_subsegment(n, operations, x, y))"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.readline\n\n    T = int(input())\n    results = []\n\n    for _ in range(T):\n        n, x = map(int, input().split())\n        s = input().strip()\n\n        balance_s = s.count('0') - s.count('1')\n        prefix_balances = [0] * (n + 1)\n\n        for i in range(n):\n            prefix_balances[i + 1] = prefix_balances[i] + (1 if s[i] == '0' else -1)\n\n        if balance_s == 0:\n            if x in prefix_balances:\n                results.append(-1)\n            else:\n                results.append(0)\n        else:\n            count = 0\n            for b in prefix_balances:\n                if (x - b) % balance_s == 0 and (x - b) // balance_s >= 0:\n                    count += 1\n            results.append(count)\n\n    for result in results:\n        print(result)\n\nsolve()"}
{"solution": "def min_digits_to_delete(n, k):\n    n_str = str(n)\n    k_str = '0' * k\n    n_len = len(n_str)\n    k_len = len(k_str)\n\n    # Find the first occurrence of k_str in n_str\n    for i in range(n_len - k_len + 1):\n        if n_str[i:i+k_len] == k_str:\n            return n_len - k_len\n\n    # If no occurrence of k_str is found, try to find the largest suffix of n_str that is divisible by 10^k\n    for i in range(n_len - 1, -1, -1):\n        if n_str[i] == '0':\n            return n_len - i - k\n\n    # If no suffix is found, try to find the largest prefix of n_str that is divisible by 10^k\n    for i in range(n_len):\n        if n_str[i] == '0':\n            return i + k\n\n    # If no prefix or suffix is found, return the length of n_str minus k\n    return n_len - k\n\n\nn, k = map(int, input().split())\nprint(min_digits_to_delete(n, k))"}
{"solution": "def calculate_max_min_sergei(n, m, k, x, y):\n    if n == 1:\n        max_val = (k + m - 1) // m\n        min_val = (k + m - 1) // m - 1 if (k + m - 1) % m!= 0 else (k + m - 1) // m\n        sergei_val = (k + m - y) // m\n        return max_val, min_val, sergei_val\n\n    full_cycles = (k - 1) // (2 * n * m - 2 * m) + 1\n    remaining_questions = k - (full_cycles - 1) * (2 * n * m - 2 * m)\n\n    max_val = full_cycles * 2\n    min_val = full_cycles * 2 - 1\n\n    if remaining_questions <= m:\n        max_val = full_cycles * 2\n        min_val = full_cycles * 2\n    elif remaining_questions <= n * m:\n        max_val = full_cycles * 2 + 1\n        min_val = full_cycles * 2\n    else:\n        max_val = full_cycles * 2 + 1\n        min_val = full_cycles * 2 + 1\n\n    if x == 1 or x == n:\n        sergei_val = full_cycles * 2\n        if remaining_questions >= m * (x - 1) + y:\n            sergei_val += 1\n    else:\n        sergei_val = full_cycles * 2 - 1\n        if remaining_questions >= m * (x - 1) + y:\n            sergei_val += 1\n        if remaining_questions >= 2 * n * m - m * (n - x) - m + y:\n            sergei_val += 1\n\n    return max_val, min_val, sergei_val\n\n\nn, m, k, x, y = map(int, input().split())\nmax_val, min_val, sergei_val = calculate_max_min_sergei(n, m, k, x, y)\nprint(max_val, min_val, sergei_val)"}
{"solution": "def calculate_beauty(ribbon, n):\n    max_beauty = 0\n    for char in set(ribbon):\n        beauty = ribbon.count(char) + min(n, len(ribbon) - ribbon.count(char))\n        max_beauty = max(max_beauty, beauty)\n    return max_beauty\n\ndef main():\n    n = int(input())\n    ribbons = [input() for _ in range(3)]\n    beauty_values = [calculate_beauty(ribbon, n) for ribbon in ribbons]\n    max_beauty = max(beauty_values)\n    if beauty_values.count(max_beauty) > 1:\n        print(\"Draw\")\n    else:\n        print([\"Kuro\", \"Shiro\", \"Katie\"][beauty_values.index(max_beauty)])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_days(c, v0, v1, a, l):\n    \"\"\"\n    Calculate the number of days Mister B needs to finish the book.\n\n    Args:\n    c (int): The length of the book in pages.\n    v0 (int): The initial reading speed.\n    v1 (int): The maximum reading speed.\n    a (int): The acceleration in reading speed.\n    l (int): The number of pages for rereading.\n\n    Returns:\n    int: The number of days Mister B needs to finish the book.\n    \"\"\"\n    days = 0\n    pages_read = 0\n    current_speed = v0\n\n    while pages_read < c:\n        # Calculate the number of pages to read today\n        pages_to_read = min(current_speed, v1)\n        if pages_read + pages_to_read - l >= c:\n            pages_to_read = c - pages_read + l\n\n        # Update the number of pages read\n        pages_read += pages_to_read - l\n\n        # Update the current speed\n        current_speed = min(current_speed + a, v1)\n\n        # Increment the number of days\n        days += 1\n\n    return days\n\n\n# Read the input\nc, v0, v1, a, l = map(int, input().split())\n\n# Calculate and print the number of days\nprint(calculate_days(c, v0, v1, a, l))"}
{"solution": "def is_prime(num):\n    \"\"\"Check if a number is prime.\"\"\"\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef find_primes(n):\n    \"\"\"Find a set of primes that sum up to n.\"\"\"\n    if is_prime(n):\n        return [n]\n    for i in range(2, n):\n        if is_prime(i) and is_prime(n - i):\n            return [i, n - i]\n    for i in range(2, n):\n        if is_prime(i):\n            remaining = n - i\n            for j in range(2, remaining):\n                if is_prime(j) and is_prime(remaining - j):\n                    return [i, j, remaining - j]\n\ndef main():\n    n = int(input())\n    primes = find_primes(n)\n    print(len(primes))\n    print(*primes)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_walls(grid):\n    \"\"\"Count the number of walls in each row and column.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    row_walls = [0] * rows\n    col_walls = [0] * cols\n\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '*':\n                row_walls[i] += 1\n                col_walls[j] += 1\n\n    return row_walls, col_walls\n\n\ndef find_bomb_location(grid):\n    \"\"\"Find the location where the bomb should be placed.\"\"\"\n    rows = len(grid)\n    cols = len(grid[0])\n    row_walls, col_walls = count_walls(grid)\n    total_walls = sum(row_walls)\n\n    for i in range(rows):\n        for j in range(cols):\n            if row_walls[i] + col_walls[j] - (grid[i][j] == '*') == total_walls:\n                return i + 1, j + 1\n\n    return None\n\n\ndef main():\n    rows, cols = map(int, input().split())\n    grid = [input() for _ in range(rows)]\n\n    bomb_location = find_bomb_location(grid)\n\n    if bomb_location is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(*bomb_location)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\nn, m, a, b = map(int, input().split())\n\ndef min_cost(n, m, a, b):\n    remainder = n % m\n    if remainder == 0:\n        return 0\n    else:\n        cost_to_build = (m - remainder) * a\n        cost_to_demolish = remainder * b\n        return min(cost_to_build, cost_to_demolish)\n\nprint(min_cost(n, m, a, b))"}
{"solution": "def max_odd_subsequence_sum(n, sequence):\n    \"\"\"\n    This function calculates the maximum sum of a subsequence with an odd sum.\n\n    Args:\n    n (int): The length of the sequence.\n    sequence (list): A list of integers.\n\n    Returns:\n    int: The maximum sum of a subsequence with an odd sum.\n    \"\"\"\n    # Initialize variables to store the maximum sum of subsequences with odd and even sums\n    max_odd_sum = float('-inf')\n    max_even_sum = 0\n\n    # Iterate over the sequence\n    for num in sequence:\n        # If the current number is odd, update max_odd_sum and max_even_sum accordingly\n        if num % 2!= 0:\n            max_odd_sum, max_even_sum = max(max_odd_sum + num, max_even_sum), max(max_even_sum + num, max_odd_sum)\n        # If the current number is even, update max_odd_sum and max_even_sum accordingly\n        else:\n            max_odd_sum, max_even_sum = max(max_odd_sum, max_even_sum + num), max(max_even_sum, max_odd_sum + num)\n\n    # Return the maximum sum of a subsequence with an odd sum\n    return max_odd_sum\n\n\n# Read the input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Calculate and print the maximum sum of a subsequence with an odd sum\nprint(max_odd_subsequence_sum(n, sequence))"}
{"solution": "from collections import defaultdict\nfrom functools import lru_cache\n\nMOD = 10**9 + 7\n\ndef main():\n    n, T = map(int, input().split())\n    songs = []\n    for _ in range(n):\n        t, g = map(int, input().split())\n        songs.append((t, g))\n\n    @lru_cache(None)\n    def dp(i, t, last_genre):\n        if t == 0:\n            return 1\n        if t < 0 or i == n:\n            return 0\n        ans = 0\n        for j in range(n):\n            if j!= i and songs[j][1]!= last_genre:\n                ans += dp(j, t - songs[i][0], songs[i][1])\n                ans %= MOD\n        return ans\n\n    ans = 0\n    for i in range(n):\n        ans += dp(i, T - songs[i][0], songs[i][1])\n        ans %= MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef phi(n):\n    result = n\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            while n % p == 0:\n                n //= p\n            result -= result // p\n        p += 1\n    if n > 1:\n        result -= result // n\n    return result\n\ndef main():\n    m = int(input())\n    if m == 1:\n        print(1)\n        return\n\n    result = 0\n    for i in range(2, m + 1):\n        result += phi(i) * mod_inverse(i, MOD)\n        result %= MOD\n\n    result = (result * mod_inverse(m, MOD)) % MOD\n    result = (result + 1) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_good_pairs(l, r, x, y):\n    \"\"\"\n    Count the number of good pairs of integers (a, b) such that l \u2264 a, b \u2264 r,\n    where GCD(a, b) = x and LCM(a, b) = y.\n\n    Args:\n        l (int): The lower bound of the range.\n        r (int): The upper bound of the range.\n        x (int): The GCD of the pair.\n        y (int): The LCM of the pair.\n\n    Returns:\n        int: The number of good pairs.\n    \"\"\"\n    if x > y or y % x!= 0 or y < x * x:\n        return 0\n\n    count = 0\n    for k in range(1, int(y / x) + 1):\n        if y % k == 0:\n            a = x * k\n            b = y // k\n            if a <= r and b <= r and a >= l and b >= l:\n                if a == b:\n                    count += 1\n                else:\n                    count += 2\n    return count\n\n\nl, r, x, y = map(int, input().split())\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve():\n    a, b = map(int, input().split())\n    if a > b:\n        a, b = b, a\n    k = 0\n    if a!= b:\n        k = b - gcd(a, b)\n    print(k)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def calculate_additional_marks(n, k, marks):\n    \"\"\"\n    Calculate the minimal number of additional marks needed to achieve a final mark of k.\n\n    Args:\n        n (int): The number of marks received by Noora.\n        k (int): The value of the highest possible mark.\n        marks (list): A list of marks received by Noora before Leha's hack.\n\n    Returns:\n        int: The minimal number of additional marks needed.\n    \"\"\"\n    total_marks = sum(marks)\n    additional_marks = 0\n\n    while True:\n        average = (total_marks + additional_marks) / (n + additional_marks)\n        if average >= k - 0.5:\n            break\n        additional_marks += 1\n\n    return additional_marks\n\n\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\nadditional_marks = calculate_additional_marks(n, k, marks)\nprint(additional_marks)"}
{"solution": "import math\n\ndef find_d():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    for d in range(-1000, 1001):\n        if d == 0:\n            continue\n        positive_count = sum(1 for x in a if x / d > 0)\n        if positive_count >= math.ceil(n / 2):\n            return d\n    return 0\n\nprint(find_d())"}
{"solution": "def count_pairs(n):\n    \"\"\"\n    Calculate the number of pairs of shovels such that their total cost ends with maximum possible number of nines.\n\n    Args:\n    n (int): The number of shovels in Polycarp's shop.\n\n    Returns:\n    int: The number of pairs of shovels such that their total cost ends with maximum possible number of nines.\n    \"\"\"\n    # Calculate the maximum possible number of nines at the end of the sum\n    max_nines = len(str(n)) - 1\n\n    # Initialize the count of pairs\n    count = 0\n\n    # Iterate over the possible sums that end with the maximum number of nines\n    for i in range(10**(max_nines - 1), 10**max_nines):\n        # Calculate the sum of the pair\n        pair_sum = 10**max_nines + i\n\n        # Check if the pair sum is less than or equal to n\n        if pair_sum <= n:\n            # Calculate the number of pairs that sum up to pair_sum\n            pairs = (pair_sum - 1) // 2\n\n            # Update the count of pairs\n            count += pairs\n\n    # Return the count of pairs\n    return count\n\n\n# Read the input\nn = int(input())\n\n# Calculate and print the result\nprint(count_pairs(n))"}
{"solution": "from collections import deque\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(a, b, c, d):\n    queue = deque([(a, b, 0)])\n    visited = set((a, b))\n\n    while queue:\n        x, y, steps = queue.popleft()\n\n        if x * y == c * d:\n            return steps, (x, y), (c, d)\n\n        if x % 2 == 0 and (x // 2, y) not in visited:\n            queue.append((x // 2, y, steps + 1))\n            visited.add((x // 2, y))\n\n        if y % 2 == 0 and (x, y // 2) not in visited:\n            queue.append((x, y // 2, steps + 1))\n            visited.add((x, y // 2))\n\n        if x % 3 == 0 and (x // 3, y) not in visited:\n            queue.append((x // 3, y, steps + 1))\n            visited.add((x // 3, y))\n\n        if y % 3 == 0 and (x, y // 3) not in visited:\n            queue.append((x, y // 3, steps + 1))\n            visited.add((x, y // 3))\n\n    return -1, None, None\n\ndef main():\n    a, b = map(int, input().split())\n    c, d = map(int, input().split())\n\n    if a * b < c * d:\n        a, b, c, d = c, d, a, b\n\n    steps, (x, y), (z, w) = solve(a, b, c, d)\n\n    if steps == -1:\n        print(-1)\n    else:\n        print(steps)\n        print(x, y)\n        print(z, w)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def determine_winner(x_p, y_p, x_v, y_v):\n    \"\"\"\n    Determine the winner of the game given the starting coordinates of both pawns.\n\n    Args:\n    x_p (int): Polycarp's x-coordinate.\n    y_p (int): Polycarp's y-coordinate.\n    x_v (int): Vasiliy's x-coordinate.\n    y_v (int): Vasiliy's y-coordinate.\n\n    Returns:\n    str: The name of the winner, either \"Polycarp\" or \"Vasiliy\".\n    \"\"\"\n    # Calculate the minimum number of moves for Polycarp to reach (0, 0)\n    polycarp_moves = max(x_p, y_p)\n\n    # Calculate the minimum number of moves for Vasiliy to reach (0, 0)\n    vasiliy_moves = max(x_v + y_v - min(x_v, y_v), min(x_v, y_v))\n\n    # If Polycarp can reach (0, 0) in less moves, he wins\n    if polycarp_moves < vasiliy_moves:\n        return \"Polycarp\"\n    # If Vasiliy can reach (0, 0) in less moves, he wins\n    elif polycarp_moves > vasiliy_moves:\n        return \"Vasiliy\"\n    # If both can reach (0, 0) in the same number of moves, Polycarp wins because he moves first\n    else:\n        return \"Polycarp\"\n\n\n# Read the input coordinates\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Determine and print the winner\nprint(determine_winner(x_p, y_p, x_v, y_v))"}
{"solution": "def calculate_columns(month, weekday):\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    first_day_offset = weekday - 1\n    total_days = days_in_month[month - 1] + first_day_offset\n    columns = (total_days + 6) // 7\n    return columns\n\nmonth, weekday = map(int, input().split())\nprint(calculate_columns(month, weekday))"}
{"solution": "def count_years_with_one_zero(a, b):\n    def count_years_with_one_zero_up_to(n):\n        count = 0\n        for i in range(1, n.bit_length() + 1):\n            count += 2 ** (i - 1)\n        for i in range(n.bit_length()):\n            if (n >> i) & 1 == 0:\n                count -= 2 ** i\n                break\n        return count\n\n    return count_years_with_one_zero_up_to(b) - count_years_with_one_zero_up_to(a - 1)\n\n\na, b = map(int, input().split())\nprint(count_years_with_one_zero(a, b))"}
{"solution": "import math\n\ndef minimal_layers(N):\n    return math.ceil((N + 1) / 2)\n\nN = int(input())\nprint(minimal_layers(N))"}
{"solution": "import math\n\ndef calculate_factorials(nums):\n    factorials = {}\n    for num in nums:\n        if num not in factorials:\n            factorials[num] = math.factorial(num)\n    return factorials\n\ndef solve(n, k, S, nums):\n    factorials = calculate_factorials(nums)\n    dp = [[0] * (k + 1) for _ in range(S + 1)]\n    dp[0][0] = 1\n\n    for num in nums:\n        for i in range(S, num - 1, -1):\n            for j in range(k + 1):\n                dp[i][j] += dp[i - num][j]\n                if j < k:\n                    dp[i][j] += dp[i - factorials[num]][j + 1]\n\n    return dp[S][k]\n\nn, k, S = map(int, input().split())\nnums = list(map(int, input().split()))\n\nprint(solve(n, k, S, nums))"}
{"solution": "import sys\n\ndef solve(n, k, a):\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        p = 0\n        while a[i] > 0:\n            if a[i] % k == 0:\n                a[i] //= k\n                p += 1\n            else:\n                return \"NO\"\n        if p > 60:\n            return \"NO\"\n    return \"YES\"\n\ndef main():\n    input = sys.stdin.readline\n    t = int(input())\n    for _ in range(t):\n        n, k = map(int, input().split())\n        a = list(map(int, input().split()))\n        print(solve(n, k, a))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_divisors(n):\n    \"\"\"Count the number of divisors of a positive integer n.\"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef calculate_sum(a, b, c):\n    \"\"\"Calculate the sum of divisors for all combinations of i, j, and k.\"\"\"\n    total_sum = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                total_sum += count_divisors(i * j * k)\n    return total_sum % (2**30)\n\n# Read input\na, b, c = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_sum(a, b, c)\nprint(result)"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    neighbors = []\n    idx = state.index('X')\n    if idx == 0:\n        neighbors.append(swap(state, 0, 1))\n        neighbors.append(swap(state, 0, 2))\n    elif idx == 1:\n        neighbors.append(swap(state, 1, 0))\n        neighbors.append(swap(state, 1, 3))\n    elif idx == 2:\n        neighbors.append(swap(state, 2, 0))\n        neighbors.append(swap(state, 2, 3))\n    elif idx == 3:\n        neighbors.append(swap(state, 3, 1))\n        neighbors.append(swap(state, 3, 2))\n    return neighbors\n\ndef swap(state, i, j):\n    state = list(state)\n    state[i], state[j] = state[j], state[i]\n    return ''.join(state)\n\ndef bfs(start):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        current = queue.popleft()\n        for neighbor in get_neighbors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return visited\n\ndef can_be_same_configuration(bessie, elsie):\n    bessie_start = ''.join(bessie)\n    elsie_start = ''.join(elsie)\n    \n    bessie_reachable = bfs(bessie_start)\n    elsie_reachable = bfs(elsie_start)\n    \n    return not bessie_reachable.isdisjoint(elsie_reachable)\n\nbessie = [input().strip() for _ in range(2)]\nelsie = [input().strip() for _ in range(2)]\n\nif can_be_same_configuration(bessie, elsie):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def convert_to_decimal(n, k):\n    decimal = 0\n    power = 0\n    for digit in reversed(k):\n        decimal += int(digit) * (n ** power)\n        power += 1\n    return decimal\n\nn = int(input())\nk = input()\n\nprint(convert_to_decimal(n, k))"}
{"solution": "def is_unimodal(arr):\n    increasing = decreasing = False\n    constant = True\n\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            if decreasing:\n                return False\n            increasing = True\n            constant = False\n        elif arr[i] < arr[i - 1]:\n            if increasing:\n                decreasing = True\n            constant = False\n        else:\n            if decreasing:\n                return False\n\n    return True\n\n\nn = int(input())\narr = list(map(int, input().split()))\n\nprint(\"YES\" if is_unimodal(arr) else \"NO\")"}
{"solution": "def solve(n, k):\n    if k == 1:\n        return n\n    if n == k:\n        return 1\n\n    if n % 2 == 0:\n        return solve(n // 2, k // 2 + k % 2)\n    else:\n        return solve(n // 2, k // 2)\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve():\n    n, m, x, y, vx, vy = map(int, input().split())\n\n    if vx == 0:\n        if vy > 0:\n            return f\"{x} {m}\"\n        else:\n            return f\"{x} 0\"\n\n    if vy == 0:\n        if vx > 0:\n            return f\"{n} {y}\"\n        else:\n            return f\"0 {y}\"\n\n    dx = n - x if vx > 0 else x\n    dy = m - y if vy > 0 else y\n\n    g = gcd(dx, dy)\n\n    if dx // g!= dy // g:\n        return \"-1\"\n\n    if vx > 0:\n        x = n\n    else:\n        x = 0\n\n    if vy > 0:\n        y = m\n    else:\n        y = 0\n\n    return f\"{x} {y}\"\n\nprint(solve())"}
{"solution": "def can_place_paintings():\n    a1, b1 = map(int, input().split())\n    a2, b2 = map(int, input().split())\n    a3, b3 = map(int, input().split())\n\n    def fits(w1, h1, w2, h2, W, H):\n        return (w1 + w2 <= W and max(h1, h2) <= H) or (h1 + h2 <= H and max(w1, w2) <= W)\n\n    if (fits(a2, b2, a3, b3, a1, b1) or fits(b2, a2, a3, b3, a1, b1) or\n        fits(a2, b2, b3, a3, a1, b1) or fits(b2, a2, b3, a3, a1, b1) or\n        fits(a3, b3, a2, b2, a1, b1) or fits(b3, a3, a2, b2, a1, b1) or\n        fits(a3, b3, b2, a2, a1, b1) or fits(b3, a3, b2, a2, a1, b1)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\ncan_place_paintings()"}
{"solution": "def count_written_terms(b1, q, limit, bad_terms):\n    \"\"\"\n    Calculate the number of terms written on the board.\n\n    Args:\n    b1 (int): The initial term of the geometric progression.\n    q (int): The common ratio of the geometric progression.\n    limit (int): The absolute value of the maximal number that can be written on the board.\n    bad_terms (set): A set of \"bad\" integers that will never be written on the board.\n\n    Returns:\n    int or str: The number of progression terms that will be written on the board if it is finite, or \"inf\" otherwise.\n    \"\"\"\n    if q == 1:\n        # If q is 1, the progression is constant and will either be infinite or 0\n        return \"inf\" if b1 not in bad_terms and abs(b1) <= limit else 0\n\n    if q == 0:\n        # If q is 0, the progression is constant and will either be infinite or 0\n        return \"inf\" if b1 not in bad_terms and abs(b1) <= limit else 0\n\n    if q == -1:\n        # If q is -1, the progression will alternate between two values\n        if b1 in bad_terms or abs(b1) > limit:\n            return 0\n        if -b1 in bad_terms:\n            return 1\n        return \"inf\"\n\n    if abs(q) > 1:\n        # If the absolute value of q is greater than 1, the progression will eventually exceed the limit\n        count = 0\n        current_term = b1\n        while abs(current_term) <= limit and current_term not in bad_terms:\n            count += 1\n            current_term *= q\n        return count\n\n    # If the absolute value of q is less than 1, the progression will converge to 0\n    if b1 == 0:\n        return 0\n\n    count = 0\n    current_term = b1\n    while abs(current_term) <= limit and current_term not in bad_terms:\n        count += 1\n        current_term *= q\n    if abs(current_term) > limit:\n        return count\n    return \"inf\"\n\n\ndef main():\n    b1, q, limit, _ = map(int, input().split())\n    bad_terms = set(map(int, input().split()))\n    result = count_written_terms(b1, q, limit, bad_terms)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": ""}
{"solution": "def extended_gcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x, y = extended_gcd(b % a, a)\n        return gcd, y - (b // a) * x, x\n\ndef solve(n, a, b):\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd!= 0:\n        return None\n    x *= n // gcd\n    y *= n // gcd\n    if x < 0:\n        k = (-x) // (b // gcd)\n        x += k * (b // gcd)\n        y -= k * (a // gcd)\n    if y < 0:\n        k = (-y) // (a // gcd)\n        x -= k * (b // gcd)\n        y += k * (a // gcd)\n    return x, y\n\nn = int(input())\na = int(input())\nb = int(input())\n\nsolution = solve(n, a, b)\nif solution is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(*solution)"}
{"solution": "def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\ns = int(input())\nprint(number_to_words(s))"}
{"solution": "def max_consecutive_elements_to_erase(n, array):\n    \"\"\"\n    Calculate the maximum number of consecutive elements that can be erased from the array.\n\n    Args:\n    n (int): The number of elements in the array.\n    array (list): The array of integers.\n\n    Returns:\n    int: The maximum number of consecutive elements that can be erased.\n    \"\"\"\n    if n <= 2:\n        return n - 1\n\n    max_erase = 0\n    for i in range(n - 1):\n        # Check if erasing elements from the start\n        if array[i + 1] - array[i] > 1 and array[i] > 1:\n            max_erase = max(max_erase, i + 1)\n        # Check if erasing elements from the end\n        if array[n - 1] - array[i] > n - i - 1 and array[n - 1] < 1000:\n            max_erase = max(max_erase, n - i - 1)\n        # Check if erasing elements in the middle\n        if i > 0 and array[i + 1] - array[i - 1] > 2:\n            max_erase = max(max_erase, 2)\n\n    return max_erase\n\n\nn = int(input())\narray = list(map(int, input().split()))\n\nprint(max_consecutive_elements_to_erase(n, array))"}
{"solution": "def find_equator_day(n, problems):\n    total_problems = sum(problems)\n    cumulative_sum = 0\n    for i, problems_solved in enumerate(problems):\n        cumulative_sum += problems_solved\n        if cumulative_sum >= total_problems / 2:\n            return i + 1\n\nn = int(input())\nproblems = list(map(int, input().split()))\nprint(find_equator_day(n, problems))"}
{"solution": ""}
{"solution": "import math\n\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\ndef get_position(num):\n    return ((num - 1) // (m * k), (num - 1) % (m * k) // k, (num - 1) % k)\n\ndef get_distance(pos1, pos2):\n    dist = abs(pos1[0] - pos2[0])\n    return min(dist, n - dist)\n\ndef get_time(pos1, pos2):\n    if pos1[0] == pos2[0]:\n        return abs(pos1[1] - pos2[1]) * 5\n    else:\n        lift_time = 10 + abs(pos1[1] - 0) + abs(pos2[1] - 0)\n        stairs_time = abs(pos1[1] - 0) * 5 + abs(pos2[1] - 0) * 5\n        return min(lift_time, stairs_time) + get_distance(pos1, pos2) * 15\n\na_pos = get_position(a)\nb_pos = get_position(b)\n\nclockwise_time = get_time(a_pos, b_pos)\ncounterclockwise_time = get_time(a_pos, (b_pos[0] + n // 2, b_pos[1], b_pos[2]))\n\nprint(min(clockwise_time, counterclockwise_time))"}
{"solution": "def is_divisible_by_64(binary_string):\n    \"\"\"\n    Checks if it's possible to remove some digits from the binary string \n    to get a number divisible by 64 in the binary numerical system.\n    \n    Args:\n    binary_string (str): A non-empty binary string.\n    \n    Returns:\n    bool: True if it's possible to get a number divisible by 64, False otherwise.\n    \"\"\"\n    \n    # Check if the string has at least 6 characters (minimum length for a binary number divisible by 64)\n    if len(binary_string) < 6:\n        return False\n    \n    # Check if the string ends with '000000' (a necessary condition for a binary number to be divisible by 64)\n    if not binary_string.endswith('0') * 6:\n        return False\n    \n    # Check if the string has at least one '1' (a necessary condition for a binary number to be non-zero)\n    if '1' not in binary_string:\n        return False\n    \n    # If all conditions are met, it's possible to get a number divisible by 64\n    return True\n\n\ndef main():\n    binary_string = input()\n    if is_divisible_by_64(binary_string):\n        print('yes')\n    else:\n        print('no')\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def transform_string(s):\n    result = list(s)\n    target = 'abcdefghijklmnopqrstuvwxyz'\n    target_index = 0\n\n    for i in range(len(s)):\n        if s[i] >= target[target_index]:\n            result[i] = target[target_index]\n            target_index += 1\n            if target_index == len(target):\n                break\n\n    if target_index == len(target):\n        for i in range(len(s)):\n            if result[i] < target[target_index - 1]:\n                next_char = chr(ord(result[i]) + 1)\n                if next_char <= target[target_index - 1]:\n                    result[i] = next_char\n    else:\n        return '-1'\n\n    return ''.join(result)\n\ns = input()\nprint(transform_string(s))"}
{"solution": "import math\n\nn, m, r, k = map(int, input().split())\n\nif k == 1:\n    print(1 / ((n - r + 1) * (m - r + 1)))\nelse:\n    ans = 0\n    for i in range(1, min(k, r) + 1):\n        ans = max(ans, (i * (i - 1) / 2) * (math.floor((n - r + 1) / i) * math.floor((m - r + 1) / i)) / ((n - r + 1) * (m - r + 1)) + i * (k - i) * (math.floor((n - r + 1) / i) * math.floor((m - r + 1) / i) - (math.floor((n - r + 1) / i) - 1) * (math.floor((m - r + 1) / i) - 1)) / ((n - r + 1) * (m - r + 1)))\n    print(ans)"}
{"solution": "def maximize_product(n, arr):\n    \"\"\"\n    This function maximizes the product of an array by applying the operation a_i := -a_i - 1.\n    \n    Parameters:\n    n (int): The number of elements in the array.\n    arr (list): The input array.\n    \n    Returns:\n    list: The array with the maximal possible product of elements.\n    \"\"\"\n    \n    # Initialize a variable to store the number of negative numbers in the array\n    negative_count = 0\n    \n    # Initialize a variable to store the number of zeros in the array\n    zero_count = 0\n    \n    # Initialize a variable to store the index of the smallest absolute value\n    smallest_abs_index = 0\n    \n    # Initialize a variable to store the smallest absolute value\n    smallest_abs = float('inf')\n    \n    # Iterate over the array to count the number of negative numbers and zeros\n    for i in range(n):\n        if arr[i] < 0:\n            negative_count += 1\n        if arr[i] == 0:\n            zero_count += 1\n        if abs(arr[i]) < smallest_abs:\n            smallest_abs = abs(arr[i])\n            smallest_abs_index = i\n    \n    # If the number of negative numbers is odd, we need to make one of them positive\n    if negative_count % 2!= 0:\n        # If there is a zero in the array, we can make the smallest absolute value negative\n        if zero_count > 0:\n            arr[smallest_abs_index] = -arr[smallest_abs_index] - 1\n        # If there is no zero in the array, we need to make the smallest absolute value positive\n        else:\n            arr[smallest_abs_index] = -arr[smallest_abs_index] - 1\n    \n    # Apply the operation to all positive numbers\n    for i in range(n):\n        if arr[i] > 0:\n            arr[i] = -arr[i] - 1\n    \n    return arr\n\n# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Print the output\nprint(*maximize_product(n, arr))"}
{"solution": "import math\n\ndef kth_smallest_divisor(n, k):\n    divisors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    divisors = sorted(list(divisors))\n    if k > len(divisors):\n        return -1\n    else:\n        return divisors[k - 1]\n\nn, k = map(int, input().split())\nprint(kth_smallest_divisor(n, k))"}
{"solution": "from collections import defaultdict\nfrom itertools import permutations\n\ndef get_digits(cube):\n    digits = set()\n    for i in range(6):\n        for j in range(i+1, 6):\n            if cube[i] == cube[j]:\n                continue\n            if (cube[i] == 6 and cube[j] == 9) or (cube[i] == 9 and cube[j] == 6):\n                continue\n            digits.add(cube[i])\n            digits.add(cube[j])\n    return digits\n\ndef get_permutations(cubes, n):\n    perms = set()\n    for p in permutations(cubes, n):\n        digits = [get_digits(cube) for cube in p]\n        for i in range(1, 10**n):\n            i_str = str(i)\n            valid = True\n            for j, digit in enumerate(i_str):\n                if int(digit) not in digits[j]:\n                    valid = False\n                    break\n            if valid:\n                perms.add(i)\n    return perms\n\ndef main():\n    n = int(input())\n    cubes = []\n    for _ in range(n):\n        cube = list(map(int, input().split()))\n        cubes.append(cube)\n\n    perms = set()\n    for i in range(1, n+1):\n        perms.update(get_permutations(cubes, i))\n\n    max_num = 0\n    for i in range(1, max(perms)+1):\n        if i not in perms:\n            break\n        max_num = i\n\n    print(max_num)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef k_rounding(n, k):\n    \"\"\"\n    Calculate the k-rounding of a given positive integer n.\n    \n    The k-rounding of n is the minimum positive integer x, such that x ends with k or more zeros in base 10 and is divisible by n.\n    \n    Parameters:\n    n (int): The input number.\n    k (int): The number of trailing zeros required.\n    \n    Returns:\n    int: The k-rounding of n.\n    \"\"\"\n    \n    # Calculate the number of trailing zeros required\n    trailing_zeros = 10 ** k\n    \n    # Calculate the least common multiple of n and the number of trailing zeros required\n    lcm = (n * trailing_zeros) // math.gcd(n, trailing_zeros)\n    \n    return lcm\n\n# Read input\nn, k = map(int, input().split())\n\n# Calculate and print the k-rounding of n\nprint(k_rounding(n, k))"}
{"solution": ""}
{"solution": "import sys\n\ndef read_input():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef calculate_probabilities(r, s, p):\n    total = r + s + p\n    probabilities = [0, 0, 0]\n\n    if total == 3:\n        probabilities = [1/3, 1/3, 1/3]\n    else:\n        if r == 0:\n            probabilities[1] = 1\n        elif s == 0:\n            probabilities[0] = 1\n        elif p == 0:\n            probabilities[2] = 1\n        else:\n            probabilities[0] = (r * (s + p)) / (total * (total - 1))\n            probabilities[1] = (s * (r + p)) / (total * (total - 1))\n            probabilities[2] = (p * (r + s)) / (total * (total - 1))\n\n            if r == 1:\n                probabilities[0] += (s * p) / (total * (total - 1))\n            elif s == 1:\n                probabilities[1] += (r * p) / (total * (total - 1))\n            elif p == 1:\n                probabilities[2] += (r * s) / (total * (total - 1))\n\n    return probabilities\n\ndef main():\n    r, s, p = read_input()\n    probabilities = calculate_probabilities(r, s, p)\n    print(' '.join(map(str, probabilities)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_time_together(l1, r1, l2, r2, k):\n    \"\"\"\n    Calculate the number of minutes Sonya and Filya will be able to spend together.\n\n    Args:\n        l1 (int): The start minute of Sonya's awake time.\n        r1 (int): The end minute of Sonya's awake time.\n        l2 (int): The start minute of Filya's visit time.\n        r2 (int): The end minute of Filya's visit time.\n        k (int): The minute Sonya prinks.\n\n    Returns:\n        int: The number of minutes Sonya and Filya will be able to spend together.\n    \"\"\"\n\n    # Calculate the overlap between Sonya's awake time and Filya's visit time\n    overlap_start = max(l1, l2)\n    overlap_end = min(r1, r2)\n\n    # If there is no overlap, return 0\n    if overlap_start > overlap_end:\n        return 0\n\n    # Calculate the total overlap time\n    total_overlap = overlap_end - overlap_start + 1\n\n    # If Sonya prinks during the overlap time, subtract 1 from the total overlap time\n    if l1 <= k <= r1 and l2 <= k <= r2:\n        total_overlap -= 1\n\n    return total_overlap\n\n\n# Read input from the user\nl1, r1, l2, r2, k = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_time_together(l1, r1, l2, r2, k)\nprint(result)"}
{"solution": "import sys\n\ndef main():\n    input = sys.stdin.readline\n\n    N, M = map(int, input().split())\n\n    A = []\n    B = []\n    C = []\n    D = []\n    E = []\n    F = []\n\n    for _ in range(N):\n        a, b, c = map(int, input().split())\n        A.append(a)\n        B.append(b)\n        C.append(c)\n\n    for _ in range(M):\n        d, e, f = map(int, input().split())\n        D.append(d)\n        E.append(e)\n        F.append(f)\n\n    def check(x, y):\n        for i in range(N):\n            if A[i] <= x <= B[i] and C[i] == y:\n                return False\n        for i in range(M):\n            if E[i] <= y <= F[i] and D[i] == x:\n                return False\n        return True\n\n    def calc(x, y):\n        if x < 0 or y < 0:\n            return 0\n        if not check(x, y):\n            return 0\n        if not check(x - 1, y) and not check(x, y - 1):\n            return x * y\n        if not check(x - 1, y):\n            return x * y + calc(x, y - 1)\n        if not check(x, y - 1):\n            return x * y + calc(x - 1, y)\n        return calc(x - 1, y) + calc(x, y - 1) - calc(x - 1, y - 1)\n\n    ans = calc(10**9, 10**9)\n    if ans == 10**18:\n        print(\"INF\")\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def will_pineapple_bark(t, s, x):\n    \"\"\"\n    Determine if the pineapple will bark at time x.\n\n    Args:\n    t (int): The time the pineapple barks for the first time.\n    s (int): The pineapple barking interval.\n    x (int): The time Barney wants to eat the pineapple.\n\n    Returns:\n    bool: True if the pineapple will bark at time x, False otherwise.\n    \"\"\"\n    # Calculate the number of intervals that have passed\n    intervals = (x - t) // s\n    \n    # Check if the pineapple will bark at time x\n    # If x is equal to t or x is one second after a multiple of s, the pineapple will bark\n    return x == t or (x - t - 1) % s == 0\n\n\n# Read input\nt, s, x = map(int, input().split())\n\n# Print output\nprint(\"YES\" if will_pineapple_bark(t, s, x) else \"NO\")"}
{"solution": "import sys\n\ndef find_nested_segments(n, segments):\n    sorted_segments = sorted(enumerate(segments), key=lambda x: (x[1][0], -x[1][1]))\n    max_right = -1\n    max_right_index = -1\n    for i, (left, right) in sorted_segments:\n        if right <= max_right:\n            return f\"{i + 1} {max_right_index + 1}\"\n        if right > max_right:\n            max_right = right\n            max_right_index = i\n    return \"-1 -1\"\n\nn = int(sys.stdin.readline())\nsegments = []\nfor _ in range(n):\n    left, right = map(int, sys.stdin.readline().split())\n    segments.append((left, right))\n\nprint(find_nested_segments(n, segments))"}
{"solution": "def decode_genome(n, s):\n    counts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\n    unknowns = 0\n\n    for char in s:\n        if char in counts:\n            counts[char] += 1\n        elif char == '?':\n            unknowns += 1\n\n    target_count = (n + 3) // 4\n\n    for char in counts:\n        if counts[char] > target_count:\n            return \"===\"\n\n    for char in counts:\n        counts[char] = target_count - counts[char]\n\n    result = []\n    for char in s:\n        if char in counts:\n            result.append(char)\n        elif char == '?':\n            for c in counts:\n                if counts[c] > 0:\n                    result.append(c)\n                    counts[c] -= 1\n                    break\n\n    if any(count > 0 for count in counts.values()):\n        return \"===\"\n\n    return \"\".join(result)\n\n\nn = int(input())\ns = input()\n\nprint(decode_genome(n, s))"}
{"solution": "def check_win(board, row, col, char):\n    # Check horizontal\n    if board[row].count(char) == 3 and '.' in board[row]:\n        return True\n\n    # Check vertical\n    vertical = [board[i][col] for i in range(4)]\n    if vertical.count(char) == 3 and '.' in vertical:\n        return True\n\n    # Check main diagonal\n    if row == col:\n        diagonal = [board[i][i] for i in range(4)]\n        if diagonal.count(char) == 3 and '.' in diagonal:\n            return True\n\n    # Check anti-diagonal\n    if row + col == 3:\n        anti_diagonal = [board[i][3-i] for i in range(4)]\n        if anti_diagonal.count(char) == 3 and '.' in anti_diagonal:\n            return True\n\n    return False\n\n\ndef check_win_by_placing(board, row, col, char):\n    # Check horizontal\n    if board[row].count(char) == 2 and board[row].count('.') == 1:\n        return True\n\n    # Check vertical\n    vertical = [board[i][col] for i in range(4)]\n    if vertical.count(char) == 2 and vertical.count('.') == 1:\n        return True\n\n    # Check main diagonal\n    if row == col:\n        diagonal = [board[i][i] for i in range(4)]\n        if diagonal.count(char) == 2 and diagonal.count('.') == 1:\n            return True\n\n    # Check anti-diagonal\n    if row + col == 3:\n        anti_diagonal = [board[i][3-i] for i in range(4)]\n        if anti_diagonal.count(char) == 2 and anti_diagonal.count('.') == 1:\n            return True\n\n    return False\n\n\ndef can_win(board):\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                board[i] = board[i][:j] + 'x' + board[i][j+1:]\n                if check_win_by_placing(board, i, j, 'x'):\n                    return True\n                board[i] = board[i][:j] + '.' + board[i][j+1:]\n    return False\n\n\nboard = [input() for _ in range(4)]\nprint(\"YES\" if can_win(board) else \"NO\")"}
{"solution": "def can_divide_array(n, a):\n    total_sum = sum(a)\n    if total_sum % 2!= 0:\n        return False\n\n    target_sum = total_sum // 2\n    prefix_sum = 0\n    for i in range(n):\n        if prefix_sum == target_sum:\n            return True\n        prefix_sum += a[i]\n\n    for i in range(n):\n        new_prefix_sum = prefix_sum - a[i]\n        if new_prefix_sum == target_sum:\n            return True\n        new_prefix_sum += a[i]\n\n    return False\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nif can_divide_array(n, a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def can_recover(n, k, a, b):\n    zeros = [i for i, x in enumerate(a) if x == 0]\n    b.sort(reverse=True)\n    a_copy = a[:]\n\n    for i, zero in enumerate(zeros):\n        a_copy[zero] = b[i]\n\n    for i in range(1, n):\n        if a_copy[i] < a_copy[i - 1]:\n            return \"Yes\"\n\n    return \"No\"\n\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(can_recover(n, k, a, b))"}
{"solution": "def can_distribute_grapes(x, y, z, a, b, c):\n    # Check if Andrew can eat enough green grapes\n    if x > a:\n        return False\n\n    # Calculate the remaining green grapes after Andrew eats\n    remaining_green = a - x\n\n    # Check if Dmitry can eat enough grapes (green and purple)\n    if y > remaining_green + b:\n        return False\n\n    # Calculate the remaining grapes after Andrew and Dmitry eat\n    remaining_grapes = remaining_green + b - max(0, y - remaining_green)\n\n    # Check if Michal can eat enough grapes (any type)\n    if z > remaining_grapes + c:\n        return False\n\n    return True\n\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\nif can_distribute_grapes(x, y, z, a, b, c):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def is_accident_possible(traffic_lights):\n    for i in range(4):\n        if traffic_lights[i][3] == 1 and (traffic_lights[i][0] == 1 or traffic_lights[i][1] == 1 or traffic_lights[i][2] == 1):\n            return True\n        if traffic_lights[i][3] == 1 and traffic_lights[(i+1)%4][2] == 1:\n            return True\n        if traffic_lights[i][3] == 1 and traffic_lights[(i-1)%4][0] == 1:\n            return True\n    return False\n\ntraffic_lights = []\nfor _ in range(4):\n    traffic_lights.append(list(map(int, input().split())))\n\nif is_accident_possible(traffic_lights):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def get_coordinates(digit):\n    keypad = {\n        '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2),\n        '0': (3, 1)\n    }\n    return keypad[digit]\n\ndef get_vectors(number):\n    vectors = []\n    for i in range(len(number) - 1):\n        x1, y1 = get_coordinates(number[i])\n        x2, y2 = get_coordinates(number[i + 1])\n        vectors.append((x2 - x1, y2 - y1))\n    return vectors\n\ndef is_unique_finger_movement(n, number):\n    original_vectors = get_vectors(number)\n    for i in range(10**(n-1), 10**n):\n        candidate = str(i).zfill(n)\n        if candidate!= number:\n            if get_vectors(candidate) == original_vectors:\n                return \"NO\"\n    return \"YES\"\n\nn = int(input())\nnumber = input().strip()\nprint(is_unique_finger_movement(n, number))"}
{"solution": "import sys\n\ndef main():\n    n, f = map(int, sys.stdin.readline().split())\n    days = []\n    for _ in range(n):\n        k, l = map(int, sys.stdin.readline().split())\n        days.append((k, l))\n\n    days.sort(key=lambda x: min(x[0], x[1]) - min(x[0]*2, x[1]), reverse=True)\n\n    sold = 0\n    for i in range(n):\n        if i < f:\n            sold += min(days[i][0]*2, days[i][1])\n        else:\n            sold += min(days[i][0], days[i][1])\n\n    print(sold)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef calculate_messiness(n, k):\n    \"\"\"\n    Calculate the maximum messiness that can be achieved by performing no more than k swaps.\n\n    Args:\n    n (int): The number of cows.\n    k (int): The number of swaps.\n\n    Returns:\n    int: The maximum messiness.\n    \"\"\"\n    # Calculate the maximum number of inversions possible\n    max_inversions = n * (n - 1) // 2\n    \n    # Calculate the number of swaps needed to achieve the maximum inversions\n    swaps_needed = n // 2\n    \n    # If the number of swaps is less than the number of swaps needed, return the maximum messiness achievable with the given swaps\n    if k < swaps_needed:\n        return k * (2 * n - 2 * k - 1)\n    \n    # Otherwise, return the maximum messiness\n    return max_inversions\n\ndef main():\n    # Read the input\n    n, k = map(int, sys.stdin.readline().split())\n    \n    # Calculate and print the maximum messiness\n    print(calculate_messiness(n, k))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef min_coins(N, M, K, L):\n    if M > N:\n        return -1\n\n    max_new_coins = N - K\n    min_coins_per_friend = math.ceil(L / M)\n\n    if min_coins_per_friend > max_new_coins:\n        return -1\n\n    return min_coins_per_friend\n\nN, M, K, L = map(int, input().split())\nprint(min_coins(N, M, K, L))"}
{"solution": "n, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\nmin_row, max_row = n, -1\nmin_col, max_col = m, -1\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 'B':\n            min_row = min(min_row, i)\n            max_row = max(max_row, i)\n            min_col = min(min_col, j)\n            max_col = max(max_col, j)\n\nif min_row == n:\n    print(1)\nelse:\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    if side_length > n or side_length > m:\n        print(-1)\n    else:\n        min_paint = float('inf')\n        for i in range(n - side_length + 1):\n            for j in range(m - side_length + 1):\n                paint_count = 0\n                for x in range(i, i + side_length):\n                    for y in range(j, j + side_length):\n                        if grid[x][y] == 'W':\n                            paint_count += 1\n                min_paint = min(min_paint, paint_count)\n        print(min_paint)"}
{"solution": "def can_transform(x, y):\n    \"\"\"Check if sequence x can be transformed into sequence y.\"\"\"\n    # Calculate the total difference between the two sequences\n    total_diff = sum(abs(a - b) for a, b in zip(x, y))\n    \n    # If the total difference is even, it's possible to transform x into y\n    return total_diff % 2 == 0\n\n\ndef main():\n    # Read the number of piles\n    n = int(input())\n    \n    # Read the initial and final sequences\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n    \n    # Check if the sequences can be transformed into each other\n    if can_transform(x, y):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_angle_diff(n, angles):\n    total_angle = sum(angles)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + angles[i]\n\n    min_diff = float('inf')\n    for i in range(n + 1):\n        left_angle = prefix_sum[i]\n        right_angle = total_angle - left_angle\n        diff = abs(left_angle - right_angle)\n        min_diff = min(min_diff, diff)\n\n    return min_diff\n\nn = int(input())\nangles = list(map(int, input().split()))\nprint(min_angle_diff(n, angles))"}
{"solution": "MOD = 10**9 + 7\n\ndef pow_mod(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef main():\n    n, m = map(int, input().split())\n    if n > m:\n        print(0)\n        return\n\n    result = 0\n    for i in range(n + 1):\n        term = pow_mod(m, n - i)\n        term *= pow_mod(m - i, i)\n        term %= MOD\n        if i % 2 == 0:\n            result += term\n        else:\n            result -= term\n        result %= MOD\n\n    result = (result + pow_mod(m, n)) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef pythagorean_triple(n):\n    for m in range(n, int(math.sqrt(2 * n**2)) + 1):\n        k = math.sqrt(m**2 - n**2)\n        if k == int(k):\n            return m, int(k)\n    for m in range(1, n):\n        k = math.sqrt(n**2 - m**2)\n        if k == int(k):\n            return m, int(k)\n    return -1, -1\n\nn = int(input())\nm, k = pythagorean_triple(n)\nif m == -1:\n    print(-1)\nelse:\n    print(m, k)"}
{"solution": "def check_remainders(n, k):\n    \"\"\"\n    Checks if all remainders of n divided by integers from 1 to k are distinct.\n\n    Args:\n    n (int): The number to check remainders for.\n    k (int): The upper limit for the range of divisors.\n\n    Returns:\n    bool: True if all remainders are distinct, False otherwise.\n    \"\"\"\n    remainders = set()\n    for i in range(1, k + 1):\n        remainder = n % i\n        if remainder in remainders:\n            return False\n        remainders.add(remainder)\n    return True\n\n\ndef main():\n    n, k = map(int, input().split())\n    if check_remainders(n, k):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def compare_long_integers(a, b):\n    # Remove leading zeroes\n    a = a.lstrip('0')\n    b = b.lstrip('0')\n\n    # Compare lengths\n    if len(a) > len(b):\n        return '>'\n    elif len(a) < len(b):\n        return '<'\n\n    # Compare lexicographically\n    if a > b:\n        return '>'\n    elif a < b:\n        return '<'\n    else:\n        return '='\n\n# Read input\na = input()\nb = input()\n\n# Print output\nprint(compare_long_integers(a, b))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, p, c):\n    dp = [[[0, 0] for _ in range(2)] for _ in range(n + 1)]\n    dp[0][0][0] = 1\n    dp[0][1][0] = 1\n\n    for i in range(n):\n        for j in range(2):\n            for k in range(2):\n                if c[i] == -1:\n                    for l in range(2):\n                        for m in range(2):\n                            dp[i + 1][j ^ l][k ^ m] = (dp[i + 1][j ^ l][k ^ m] + dp[i][j][k]) % MOD\n                elif c[i] == j:\n                    for m in range(2):\n                        dp[i + 1][j][k ^ m] = (dp[i + 1][j][k ^ m] + dp[i][j][k]) % MOD\n                else:\n                    for l in range(2):\n                        for m in range(2):\n                            dp[i + 1][l][k ^ m] = (dp[i + 1][l][k ^ m] + dp[i][j][k]) % MOD\n\n    return sum(dp[n][0]) % MOD if p == 0 else (sum(dp[n][1]) % MOD)\n\nn, p = map(int, input().split())\nc = list(map(int, input().split()))\nprint(solve(n, p, c))"}
{"solution": "def min_rubles(n, a, b, c):\n    remainder = n % 4\n    if remainder == 0:\n        return 0\n    elif remainder == 1:\n        return min(a, b + c, 4 * c)\n    elif remainder == 2:\n        return min(2 * a, b, 3 * c)\n    else:\n        return min(3 * a, 2 * b, 4 * c)\n\nn, a, b, c = map(int, input().split())\nprint(min_rubles(n, a, b, c))"}
{"solution": "from collections import defaultdict\n\ndef dfs(graph, visited, stack, vertex):\n    visited[vertex] = True\n    stack[vertex] = True\n\n    for neighbor in graph[vertex]:\n        if not visited[neighbor]:\n            if dfs(graph, visited, stack, neighbor):\n                return True\n        elif stack[neighbor]:\n            return True\n\n    stack[vertex] = False\n    return False\n\ndef is_acyclic(graph, n):\n    visited = [False] * n\n    stack = [False] * n\n\n    for vertex in range(n):\n        if not visited[vertex]:\n            if dfs(graph, visited, stack, vertex):\n                return False\n\n    return True\n\ndef remove_edge(graph, u, v):\n    graph[u].remove(v)\n\ndef add_edge(graph, u, v):\n    graph[u].append(v)\n\ndef can_make_acyclic(n, m, edges):\n    graph = defaultdict(list)\n\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n\n    if is_acyclic(graph, n):\n        return True\n\n    for u, v in edges:\n        remove_edge(graph, u - 1, v - 1)\n        if is_acyclic(graph, n):\n            return True\n        add_edge(graph, u - 1, v - 1)\n\n    return False\n\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\nif can_make_acyclic(n, m, edges):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, m = read_ints()\n    antennas = []\n    for _ in range(n):\n        x, s = read_ints()\n        antennas.append((x, s))\n\n    antennas.sort()\n\n    dp = [float('inf')] * (m + 1)\n    dp[0] = 0\n\n    for x, s in antennas:\n        for i in range(m, -1, -1):\n            if i - s <= 0:\n                dp[i] = min(dp[i], max(0, 1 - s))\n            else:\n                dp[i] = min(dp[i], dp[i - s - 1] + max(0, i - x + s))\n\n            if i + s >= m:\n                continue\n            else:\n                dp[i + s + 1] = min(dp[i + s + 1], dp[i] + max(0, x + s - i))\n\n    print(dp[m])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_weight_subset(W, weights):\n    \"\"\"\n    Calculate the maximum possible weight of a good subset of items.\n\n    Args:\n    W (int): The maximum total weight of a good subset.\n    weights (list): A list of integers representing the number of items having weight i in the set.\n\n    Returns:\n    int: The maximum possible weight of a good subset of items.\n    \"\"\"\n    total_weight = 0\n    for i, cnt in enumerate(weights, start=1):\n        # Calculate the maximum number of items of weight i that can be included\n        num_items = min(cnt, W // i)\n        # Update the total weight and the remaining capacity\n        total_weight += num_items * i\n        W -= num_items * i\n    return total_weight\n\n\n# Read the input\nW = int(input())\nweights = list(map(int, input().split()))\n\n# Calculate and print the maximum possible weight of a good subset\nprint(max_weight_subset(W, weights))"}
{"solution": "def min_cost(n, L, costs):\n    volumes = [2**i - 1 for i in range(1, n + 1)]\n    dp = [float('inf')] * (L + 1)\n    dp[0] = 0\n\n    for i in range(1, L + 1):\n        for j in range(n):\n            if volumes[j] <= i:\n                dp[i] = min(dp[i], dp[i - volumes[j]] + costs[j])\n\n    return dp[L]\n\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\nprint(min_cost(n, L, costs))"}
{"solution": "def max_mex(n, a):\n    a.sort()\n    mex = 1\n    for num in a:\n        if num >= mex:\n            mex += 1\n    return mex\n\nn = int(input())\na = list(map(int, input().split()))\nresult = max_mex(n, a)\nprint(result)"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(int(digit) for digit in digits)\n    \n    # Try every possible segment sum from 1 to total_sum\n    for segment_sum in range(1, total_sum + 1):\n        if total_sum % segment_sum == 0:\n            current_sum = 0\n            valid_partition = True\n            for digit in digits:\n                current_sum += int(digit)\n                if current_sum > segment_sum:\n                    valid_partition = False\n                    break\n                elif current_sum == segment_sum:\n                    current_sum = 0\n            if valid_partition and current_sum == 0 and total_sum // segment_sum > 1:\n                return \"YES\"\n    \n    return \"NO\"\n\nn = int(input())\ndigits = input().strip()\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\"\n\nusername = input().strip()\nprint(determine_gender(username))"}
{"solution": "def calculate_max_difference(n, k, tabs):\n    max_difference = 0\n    for b in range(1, n + 1):\n        closed_tabs = set()\n        i = 0\n        while True:\n            c = b + i * k\n            if 1 <= c <= n:\n                closed_tabs.add(c)\n                i += 1\n            else:\n                break\n        e = 0\n        s = 0\n        for i in range(1, n + 1):\n            if i not in closed_tabs:\n                if tabs[i - 1] == 1:\n                    e += 1\n                else:\n                    s += 1\n        difference = abs(e - s)\n        max_difference = max(max_difference, difference)\n    return max_difference\n\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\nprint(calculate_max_difference(n, k, tabs))"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n, c0, c1 = map(int, read_input().split())\n\n    if c0 > c1:\n        c0, c1 = c1, c0\n\n    total_cost = 0\n    length = 1\n    while n > 0:\n        if n % 2 == 1:\n            total_cost += (n // 2 + 1) * length * c0 + (n // 2) * length * c1\n            n = n // 2 + 1\n        else:\n            total_cost += (n // 2) * length * c0 + (n // 2) * length * c1\n            n = n // 2\n        length += 1\n\n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def will_meet(n, a, x, b, y):\n    if a < x:\n        daniel_stations = list(range(a, x + 1))\n    else:\n        daniel_stations = list(range(a, n + 1)) + list(range(1, x + 1))\n\n    if b > y:\n        vlad_stations = list(range(b, y - 1, -1))\n    else:\n        vlad_stations = list(range(b, 0, -1)) + list(range(n, y - 1, -1))\n\n    common_stations = set(daniel_stations) & set(vlad_stations)\n    return \"YES\" if common_stations else \"NO\"\n\nn, a, x, b, y = map(int, input().split())\nprint(will_meet(n, a, x, b, y))"}
{"solution": "import math\n\ndef is_unlucky(x, y, n):\n    \"\"\"Check if a number is unlucky.\"\"\"\n    a = 0\n    while x ** a <= n:\n        b = 0\n        while x ** a + y ** b <= n:\n            if x ** a + y ** b == n:\n                return True\n            b += 1\n        a += 1\n    return False\n\ndef max_golden_age(x, y, left, right):\n    \"\"\"Find the maximum length of The Golden Age.\"\"\"\n    max_length = 0\n    current_length = 0\n    for i in range(left, right + 1):\n        if is_unlucky(x, y, i):\n            max_length = max(max_length, current_length)\n            current_length = 0\n        else:\n            current_length += 1\n    return max(max_length, current_length)\n\nx, y, left, right = map(int, input().split())\nprint(max_golden_age(x, y, left, right))"}
{"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef min_tax(n):\n    \"\"\"Calculate the minimum tax Mr. Funt has to pay.\"\"\"\n    if n % 2 == 0:\n        # If n is even, split it into two equal parts\n        return 2\n    elif is_prime(n):\n        # If n is prime, split it into two parts: 2 and n-2\n        return 2\n    else:\n        # If n is odd and not prime, split it into two parts: 3 and n-3\n        return 3\n\nn = int(input())\nprint(min_tax(n))"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    n = len(word)\n    result = []\n    i = 0\n    \n    while i < n:\n        result.append(word[i])\n        if word[i] not in vowels:\n            start = i\n            while i < n and word[i] not in vowels:\n                i += 1\n            if i - start >= 3:\n                block = word[start:i]\n                if len(set(block)) > 1:\n                    result.append(' ')\n        i += 1\n    \n    return ''.join(result)\n\nword = input()\nprint(fix_typos(word))"}
{"solution": "import sys\n\nn, m, k = map(int, sys.stdin.readline().split())\nx, s = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\nb = list(map(int, sys.stdin.readline().split()))\nc = list(map(int, sys.stdin.readline().split()))\nd = list(map(int, sys.stdin.readline().split()))\n\nmin_time = float('inf')\n\n# No spell of the first type\nfor i in range(k):\n    if d[i] <= s:\n        time = max(0, n - c[i]) * x\n        min_time = min(min_time, time)\n\n# Spell of the first type\nfor i in range(m):\n    if b[i] <= s:\n        for j in range(k):\n            if d[j] <= s - b[i]:\n                time = max(0, n - c[j]) * a[i]\n                min_time = min(min_time, time)\n\n# No spell of the second type\nfor i in range(m):\n    if b[i] <= s:\n        time = n * a[i]\n        min_time = min(min_time, time)\n\nprint(min_time)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, k, M = read_ints()\n    t = list(read_ints())\n\n    t.sort()\n    task_times = [sum(t[:i+1]) for i in range(k)]\n\n    dp = [0] * (n * k + 1)\n    for i in range(1, n * k + 1):\n        for j in range(1, min(i, k) + 1):\n            dp[i] = max(dp[i], dp[i-j] + task_times[j-1])\n\n    ans = 0\n    for i in range(n * k + 1):\n        if dp[i] <= M:\n            ans = max(ans, i + (i // k))\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 998244353\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef mod_binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    numerator = mod_factorial(n)\n    denominator = (mod_factorial(k) * mod_factorial(n - k)) % MOD\n    return (numerator * mod_inverse(denominator, MOD)) % MOD\n\ndef mod_catalan(n):\n    if n % 2 == 1:\n        return 0\n    n = n // 2\n    return (mod_binomial_coefficient(2 * n, n) * mod_inverse(n + 1, MOD)) % MOD\n\ndef solve(n):\n    if n % 2 == 1:\n        return 0\n    n = n // 2\n    return (mod_catalan(n) * mod_catalan(n)) % MOD\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def lara_croft_path(n, m, k):\n    # Calculate the total number of cells\n    total_cells = n * m\n\n    # Calculate the number of full rows\n    full_rows = m // 2\n\n    # Calculate the number of cells in the last row\n    last_row_cells = m % 2\n\n    # Calculate the number of cells Lara has moved in the current row\n    current_row_cells = k % (2 * m - 1)\n\n    # Calculate the number of rows Lara has moved\n    rows_moved = k // (2 * m - 1)\n\n    # Calculate the current row\n    current_row = n - rows_moved - 1\n\n    # Calculate the current column\n    if current_row_cells < m:\n        current_column = current_row_cells + 1\n    else:\n        current_column = 2 * m - current_row_cells\n\n    # Adjust the current row and column based on the last row\n    if rows_moved >= full_rows:\n        current_row -= (rows_moved - full_rows) * 2\n        if last_row_cells == 1:\n            current_column = m\n        else:\n            current_column = 1\n\n    return current_row, current_column\n\n\nn, m, k = map(int, input().split())\ncurrent_row, current_column = lara_croft_path(n, m, k)\nprint(current_row, current_column)"}
{"solution": "import math\n\ndef prime_factors(n):\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef solve():\n    x = int(input())\n    factors = prime_factors(x)\n    a = 1\n    b = x\n    for factor in set(factors):\n        if factors.count(factor) > 1:\n            a *= factor\n            b //= factor\n    print(a, b)\n\nsolve()"}
{"solution": "def max_fruits_for_compote(a, b, c):\n    # Calculate the maximum number of complete sets for each fruit type\n    max_sets_lemons = a // 1\n    max_sets_apples = b // 2\n    max_sets_pears = c // 4\n    \n    # Find the limiting factor (minimum number of complete sets)\n    max_complete_sets = min(max_sets_lemons, max_sets_apples, max_sets_pears)\n    \n    # Calculate the total number of fruits used in the compote\n    total_fruits = max_complete_sets * (1 + 2 + 4)\n    \n    return total_fruits\n\na = int(input())\nb = int(input())\nc = int(input())\n\nprint(max_fruits_for_compote(a, b, c))"}
{"solution": "n = int(input())\nratings = list(map(int, input().split()))\nratings.sort()\nfor i in range(n):\n    if ratings[i] >= ratings[i + n]:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef is_coprime(a, b):\n    return gcd(a, b) == 1\n\ndef find_next_coprime(a):\n    for i in range(a + 1, 10**9 + 1):\n        if is_coprime(a, i):\n            return i\n\nn = int(input())\narr = list(map(int, input().split()))\n\ninsertions = 0\nresult = [arr[0]]\n\nfor i in range(1, n):\n    if is_coprime(result[-1], arr[i]):\n        result.append(arr[i])\n    else:\n        insertions += 1\n        result.append(find_next_coprime(result[-1]))\n        result.append(arr[i])\n\nprint(insertions)\nprint(*result)"}
{"solution": "import math\nfrom functools import reduce\nfrom math import gcd\n\ndef compute_gcd_of_list(lst):\n    return reduce(gcd, lst)\n\ndef max_divisor_after_operations(N, K, A):\n    if N == 1:\n        return A[0]\n    \n    # Compute the GCD of the differences between all pairs\n    diffs = [abs(A[i] - A[j]) for i in range(N) for j in range(i + 1, N)]\n    initial_gcd = compute_gcd_of_list(diffs)\n    \n    # Check all divisors of the initial GCD\n    max_divisor = 1\n    for d in range(1, initial_gcd + 1):\n        if initial_gcd % d == 0:\n            # Check if we can make all elements divisible by d\n            if all((a % d) <= K for a in A):\n                max_divisor = d\n    \n    return max_divisor\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\nprint(max_divisor_after_operations(N, K, A))"}
{"solution": "import math\n\ndef solve():\n    x = int(input())\n    if (x & (x + 1) == 0):\n        print(0)\n        return\n    n = int(math.log2(x + 1))\n    ans = []\n    for i in range(n, 0, -1):\n        if (x >> i) & 1:\n            ans.append(i)\n            x ^= (1 << i) - 1\n    print(len(ans) * 2)\n    for i in range(len(ans)):\n        print(ans[i], end=' \\n'[i == len(ans) - 1])\n\nsolve()"}
{"solution": "import math\n\ndef min_hours_to_water_garden(n, k, bucket_lengths):\n    \"\"\"\n    Calculate the minimum number of hours required to water the garden.\n\n    Args:\n    n (int): The number of buckets.\n    k (int): The length of the garden.\n    bucket_lengths (list): A list of integers representing the length of the segment that can be watered by each bucket in one hour.\n\n    Returns:\n    int: The minimum number of hours required to water the garden.\n    \"\"\"\n    min_hours = float('inf')\n\n    for length in bucket_lengths:\n        if k % length == 0:\n            hours = k // length\n            min_hours = min(min_hours, hours)\n\n    return min_hours\n\nn, k = map(int, input().split())\nbucket_lengths = list(map(int, input().split()))\n\nprint(min_hours_to_water_garden(n, k, bucket_lengths))"}
{"solution": "from collections import deque\n\ndef can_reach_insect(n, k, line):\n    # Find the positions of the grasshopper and the insect\n    grasshopper_pos = line.index('G')\n    insect_pos = line.index('T')\n\n    # Create a queue for BFS and add the grasshopper's position\n    queue = deque([grasshopper_pos])\n\n    # Create a set to store visited positions\n    visited = set([grasshopper_pos])\n\n    while queue:\n        # Dequeue the next position\n        pos = queue.popleft()\n\n        # If this is the insect's position, return True\n        if pos == insect_pos:\n            return True\n\n        # Calculate the next possible positions\n        next_pos = [pos - k, pos + k]\n\n        # Check each next position\n        for np in next_pos:\n            # If the position is within the line and is not an obstacle and has not been visited\n            if 0 <= np < n and line[np]!= '#' and np not in visited:\n                # Mark the position as visited and add it to the queue\n                visited.add(np)\n                queue.append(np)\n\n    # If the insect's position has not been reached, return False\n    return False\n\n# Read the input\nn, k = map(int, input().split())\nline = input()\n\n# Print the result\nprint(\"YES\" if can_reach_insect(n, k, line) else \"NO\")"}
{"solution": ""}
{"solution": "def calculate_missed_meals(breakfasts, dinners, suppers):\n    meals = [breakfasts, dinners, suppers]\n    meals.sort()\n    missed_meals = 0\n\n    if meals[0] == meals[2]:\n        return 0\n    elif meals[0] == meals[1]:\n        missed_meals = meals[2] - meals[0]\n    else:\n        missed_meals = meals[2] - meals[0] - 1\n\n    return missed_meals\n\nbreakfasts, dinners, suppers = map(int, input().split())\nprint(calculate_missed_meals(breakfasts, dinners, suppers))"}
{"solution": "import math\n\ndef find_dimensions(n, path):\n    max_value = max(path)\n    min_x = math.ceil(math.sqrt(max_value))\n    min_y = math.ceil(max_value / min_x)\n\n    for x in range(min_x, 1000000001):\n        y = math.ceil(max_value / x)\n        if x * y < max_value:\n            continue\n        if check_path(x, y, path):\n            return x, y\n\n    return None\n\ndef check_path(x, y, path):\n    for i in range(1, len(path)):\n        a1, a2 = path[i-1], path[i]\n        i1, j1 = get_coordinates(a1, x, y)\n        i2, j2 = get_coordinates(a2, x, y)\n        if not is_adjacent(i1, j1, i2, j2, x, y):\n            return False\n    return True\n\ndef get_coordinates(a, x, y):\n    i = math.ceil(a / y)\n    j = a - (i - 1) * y\n    return i, j\n\ndef is_adjacent(i1, j1, i2, j2, x, y):\n    if i1 == i2:\n        return abs(j1 - j2) == 1\n    elif j1 == j2:\n        return abs(i1 - i2) == 1\n    else:\n        return False\n\nn = int(input())\npath = list(map(int, input().split()))\n\ndimensions = find_dimensions(n, path)\nif dimensions is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(dimensions[0], dimensions[1])"}
{"solution": "def longest_subsequence(a, b):\n    i, j = 0, 0\n    result = []\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            result.append(a[i])\n            i += 1\n            j += 1\n        else:\n            i += 1\n    return ''.join(result)\n\ndef min_consecutive_removal(a, b):\n    subsequence = longest_subsequence(a, b)\n    if subsequence == '':\n        return '-'\n    else:\n        return subsequence\n\na = input()\nb = input()\nprint(min_consecutive_removal(a, b))"}
{"solution": "def minimal_stones(n, s):\n    current_stones = 0\n    min_stones = 0\n    \n    for char in s:\n        if char == '+':\n            current_stones += 1\n        elif char == '-':\n            current_stones -= 1\n            if current_stones < min_stones:\n                min_stones = current_stones\n    return max(0, current_stones)\n\nn = int(input())\ns = input().strip()\nprint(minimal_stones(n, s))"}
{"solution": "def calculate_kefir(n, a, b, c):\n    \"\"\"\n    Calculate the maximum number of liters of kefir Kolya can drink.\n\n    Args:\n    n (int): The number of rubles Kolya has at the beginning.\n    a (int): The cost of one plastic liter bottle.\n    b (int): The cost of one glass liter bottle.\n    c (int): The money one can get back by returning an empty glass bottle.\n\n    Returns:\n    int: The maximum number of liters of kefir Kolya can drink.\n    \"\"\"\n    # Calculate the maximum number of plastic bottles Kolya can buy\n    plastic_bottles = n // a\n    \n    # Calculate the remaining money after buying plastic bottles\n    remaining_money = n % a\n    \n    # Calculate the maximum number of glass bottles Kolya can buy\n    glass_bottles = n // (b - c)\n    \n    # Calculate the remaining money after buying glass bottles\n    remaining_money_glass = n % (b - c)\n    \n    # Calculate the maximum number of additional glass bottles Kolya can buy\n    additional_glass_bottles = remaining_money_glass // b\n    \n    # Return the maximum number of liters of kefir Kolya can drink\n    return max(plastic_bottles, glass_bottles + additional_glass_bottles)\n\n\n# Read the input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate and print the maximum number of liters of kefir Kolya can drink\nprint(calculate_kefir(n, a, b, c))"}
{"solution": "def play_game(deck1, deck2):\n    seen = set()\n    rounds = 0\n    while deck1 and deck2:\n        rounds += 1\n        card1 = deck1.pop(0)\n        card2 = deck2.pop(0)\n        if (tuple(deck1), tuple(deck2)) in seen:\n            return -1\n        seen.add((tuple(deck1), tuple(deck2)))\n        if card1 > card2:\n            deck1.extend([card2, card1])\n        else:\n            deck2.extend([card1, card2])\n    return rounds, 1 if deck1 else 2\n\nn = int(input())\nk1 = int(input().split()[0])\ndeck1 = list(map(int, input().split()[1:]))\nk2 = int(input().split()[0])\ndeck2 = list(map(int, input().split()[1:]))\n\nresult = play_game(deck1, deck2)\nif result == -1:\n    print(-1)\nelse:\n    print(result[0], result[1])"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    \n    has_upper = False\n    has_lower = False\n    has_digit = False\n    \n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n    \n    if has_upper and has_lower and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\"\n\npassword = input().strip()\nprint(check_password_complexity(password))"}
{"solution": "def min_exchanges(n, a, b):\n    count_a = [0] * 5\n    count_b = [0] * 5\n\n    for i in range(n):\n        count_a[a[i] - 1] += 1\n        count_b[b[i] - 1] += 1\n\n    exchanges = 0\n    for i in range(5):\n        diff = abs(count_a[i] - count_b[i])\n        if diff % 2!= 0:\n            return -1\n        exchanges += diff // 2\n\n    return exchanges\n\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(min_exchanges(n, a, b))"}
{"solution": "from collections import deque\n\ndef is_reachable(n, m, horizontal_streets, vertical_streets):\n    # Create a graph to represent the streets\n    graph = {}\n    for i in range(n - 1):\n        for j in range(m - 1):\n            node = (i, j)\n            graph[node] = []\n            if horizontal_streets[i] == '>':\n                if j < m - 2:\n                    graph[node].append((i, j + 1))\n            else:\n                if j > 0:\n                    graph[node].append((i, j - 1))\n            if vertical_streets[j] == '^':\n                if i < n - 2:\n                    graph[node].append((i + 1, j))\n            else:\n                if i > 0:\n                    graph[node].append((i - 1, j))\n\n    # Perform BFS to check if all nodes are reachable\n    visited = set()\n    queue = deque([(0, 0)])\n    visited.add((0, 0))\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n\n    # Check if all nodes are visited\n    return len(visited) == (n - 1) * (m - 1)\n\n\ndef main():\n    n, m = map(int, input().split())\n    horizontal_streets = input()\n    vertical_streets = input()\n    if is_reachable(n, m, horizontal_streets, vertical_streets):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    if a[0] == 0:\n        print(\"YES\")\n        print(\"0\" if n == 1 else \"0->\" + \"->\".join(map(str, a[1:])))\n        return\n\n    for i in range(1, n):\n        if a[i] == 0:\n            print(\"YES\")\n            print(\"(\" + \"->\".join(map(str, a[:i])) + \")->\" + \"->\".join(map(str, a[i:])))\n            return\n\n    print(\"NO\")\n\nsolve()"}
{"solution": "def calculate_final_values(a, b):\n    while True:\n        if a == 0 or b == 0:\n            break\n        elif a >= 2 * b:\n            a -= 2 * b\n        elif b >= 2 * a:\n            b -= 2 * a\n        else:\n            break\n    return a, b\n\na, b = map(int, input().split())\nfinal_a, final_b = calculate_final_values(a, b)\nprint(final_a, final_b)"}
{"solution": "def count_k_divisible_numbers():\n    k, a, b = map(int, input().split())\n    return (b // k) - ((a - 1) // k)\n\nprint(count_k_divisible_numbers())"}
{"solution": "def find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    start += (k - 1) // length\n    return str(start)[(k - 1) % length]\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "def can_vasya_win(n, s):\n    # Calculate the number of moves each player will make\n    moves_each = (n - 11) // 2\n    \n    # Count the number of '8's in the string\n    count_8s = s.count('8')\n    \n    # If there are no '8's, Vasya cannot win\n    if count_8s == 0:\n        return \"NO\"\n    \n    # If there is only one '8', Vasya can only win if it's in the first position\n    if count_8s == 1:\n        return \"YES\" if s[0] == '8' else \"NO\"\n    \n    # If there are multiple '8's, Vasya can win if there are more '8's than the number of moves Petya can make\n    if count_8s > moves_each + 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Determine if Vasya has a winning strategy\nresult = can_vasya_win(n, s)\nprint(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef modmul(a, b):\n    return (a * b) % MOD\n\ndef modpow(a, b):\n    if b == 0:\n        return 1\n    if b % 2 == 0:\n        return modpow(modmul(a, a), b // 2)\n    return modmul(a, modpow(a, b - 1))\n\ndef modinv(a):\n    return modpow(a, MOD - 2)\n\ndef moddiv(a, b):\n    return modmul(a, modinv(b))\n\ndef comb(n, k):\n    if k < 0 or k > n:\n        return 0\n    return modmul(modmul(fact[n], invfact[k]), invfact[n - k])\n\ndef solve():\n    n, x, pos = map(int, input().split())\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = modmul(fact[i - 1], i)\n    invfact[n] = modinv(fact[n])\n    for i in range(n - 1, -1, -1):\n        invfact[i] = modmul(invfact[i + 1], i + 1)\n\n    if pos == 0:\n        return modmul(comb(n - 1, x - 1), fact[n - 1])\n    if pos == n - 1:\n        return modmul(comb(n - 1, x - 1), fact[n - 1])\n\n    left = pos\n    right = n - pos - 1\n    if x - 1 > left:\n        return 0\n    if n - x > right:\n        return 0\n\n    return modmul(modmul(comb(left, x - 1), comb(right, n - x)), modmul(fact[left], fact[right]))\n\nprint(solve())"}
{"solution": "def solve():\n    s = input()\n    k = int(input())\n    n = len(s)\n    dp = [[False] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(n):\n        if s[i].isalpha():\n            for j in range(k + 1):\n                if dp[i][j]:\n                    dp[i + 1][j] = True\n                    if j < k:\n                        dp[i + 1][j + 1] = True\n        if i < n - 1 and s[i + 1] == '?':\n            for j in range(k + 1):\n                if dp[i][j]:\n                    dp[i + 2][j] = True\n                    if j < k:\n                        dp[i + 2][j + 1] = True\n        if i < n - 1 and s[i + 1] == '*':\n            for j in range(k + 1):\n                if dp[i][j]:\n                    dp[i + 2][j] = True\n                    if j < k:\n                        dp[i + 2][j + 1] = True\n                    if j + 1 < k:\n                        dp[i + 2][j + 2] = True\n    if not dp[n][k]:\n        print(\"Impossible\")\n        return\n    ans = []\n    i, j = n, k\n    while i > 0:\n        if s[i - 1].isalpha():\n            if j > 0 and dp[i - 1][j - 1]:\n                ans.append(s[i - 1])\n                j -= 1\n            i -= 1\n        elif s[i - 1] == '?':\n            if j > 0 and dp[i - 2][j - 1]:\n                ans.append(s[i - 2])\n                j -= 1\n            i -= 2\n        else:\n            if j > 1 and dp[i - 2][j - 2]:\n                ans.append(s[i - 2])\n                ans.append(s[i - 2])\n                j -= 2\n            elif j > 0 and dp[i - 2][j - 1]:\n                ans.append(s[i - 2])\n                j -= 1\n            else:\n                ans.append(s[i - 2])\n            i -= 2\n    print(''.join(reversed(ans)))\n\nsolve()"}
{"solution": "def min_turns(angle):\n    angle = (angle + 360) % 360  # Normalize angle to [0, 360)\n    if angle == 0:\n        return 0\n    elif angle < 90:\n        return 1\n    elif angle < 180:\n        return 2\n    elif angle < 270:\n        return 3\n    else:\n        return 1\n\nangle = int(input())\nprint(min_turns(angle))"}
{"solution": "def can_transform_spheres(a, b, c, x, y, z):\n    total_spheres = a + b + c\n    required_spheres = x + y + z\n\n    if total_spheres < required_spheres:\n        return False\n\n    if total_spheres % 2!= required_spheres % 2:\n        return False\n\n    if a >= x and b >= y and c >= z:\n        return True\n\n    if a >= x and b + c >= y + z:\n        return True\n\n    if b >= y and a + c >= x + z:\n        return True\n\n    if c >= z and a + b >= x + y:\n        return True\n\n    return False\n\n\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\nif can_transform_spheres(a, b, c, x, y, z):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def count_suffixes(n, k, m):\n    # Calculate the number of suffixes for each length\n    suffix_counts = [0] * (n + 1)\n    suffix_counts[0] = 1\n\n    # Calculate the number of suffixes for each length\n    for i in range(1, n + 1):\n        suffix_counts[i] = (10 * suffix_counts[i - 1]) % k\n\n    # Calculate the total number of numbers with a suffix\n    total_count = 0\n    for i in range(1, n + 1):\n        # Calculate the number of numbers with a suffix of length i\n        count = (10 ** (n - i)) * suffix_counts[i]\n        # Subtract the numbers that have a leading zero\n        if i > 1:\n            count -= (10 ** (n - i)) * suffix_counts[i - 1]\n        # Add the count to the total\n        total_count = (total_count + count) % m\n\n    return total_count\n\nn, k, m = map(int, input().split())\nprint(count_suffixes(n, k, m))"}
{"solution": "def max_team_size():\n    l, r, a = map(int, input().split())\n    \n    if l > r:\n        l, r = r, l  # Ensure l is always the smaller or equal group\n    \n    # Use ambidexters to balance the difference\n    d = r - l\n    if a >= d:\n        l += d\n        a -= d\n        # Now l == r, distribute remaining ambidexters equally\n        l += a // 2\n        r += a // 2\n    else:\n        l += a\n        # Not enough ambidexters to balance completely, r remains larger\n    \n    # The maximum team size is twice the smaller group\n    print(2 * min(l, r))\n\nmax_team_size()"}
{"solution": "import sys\n\ndef min_moves(n, k):\n    if n == 2:\n        return 6\n    if k == 1:\n        return 3 * n - 2\n    if k == n:\n        return 3 * n - 2\n    return 3 * n - 2 + min(k - 1, n - k)\n\nn, k = map(int, sys.stdin.readline().split())\nprint(min_moves(n, k))"}
{"solution": "def min_tower_height(n, m):\n    \"\"\"\n    Calculate the minimum height necessary for the tallest of the students' towers.\n\n    Args:\n    n (int): The number of students using two-block pieces.\n    m (int): The number of students using three-block pieces.\n\n    Returns:\n    int: The minimum possible height of the tallest tower.\n    \"\"\"\n    # Initialize the current height for two-block and three-block towers\n    two_block_height = 0\n    three_block_height = 0\n\n    # Initialize the count of used heights\n    used_heights = set()\n\n    # Generate heights for two-block towers\n    for _ in range(n):\n        two_block_height += 2\n        while two_block_height in used_heights:\n            two_block_height += 2\n\n    # Generate heights for three-block towers\n    for _ in range(m):\n        three_block_height += 3\n        while three_block_height in used_heights:\n            three_block_height += 3\n        used_heights.add(three_block_height)\n\n    # Return the maximum height\n    return max(two_block_height, three_block_height)\n\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the minimum tower height\nprint(min_tower_height(n, m))"}
{"solution": "def fair_game(n, cards):\n    count_dict = {}\n    for card in cards:\n        if card in count_dict:\n            count_dict[card] += 1\n        else:\n            count_dict[card] = 1\n\n    even_counts = [num for num, count in count_dict.items() if count % 2 == 0]\n    odd_counts = [num for num, count in count_dict.items() if count % 2!= 0]\n\n    if len(odd_counts) > 2:\n        return \"NO\"\n\n    if len(odd_counts) == 2:\n        odd_sum = sum(count_dict[odd_counts[0]] + count_dict[odd_counts[1]])\n        if odd_sum!= n:\n            return \"NO\"\n        else:\n            return \"YES\\n{} {}\".format(odd_counts[0], odd_counts[1])\n\n    if len(even_counts) < 2:\n        return \"NO\"\n\n    return \"YES\\n{} {}\".format(even_counts[0], even_counts[1])\n\n\nn = int(input())\ncards = [int(input()) for _ in range(n)]\nprint(fair_game(n, cards))"}
{"solution": "def can_place_soldiers(n, k, groups):\n    total_seats = n * 8\n    total_soldiers = sum(groups)\n\n    if total_soldiers > total_seats:\n        return False\n\n    groups.sort(reverse=True)\n\n    for i in range(k):\n        if groups[i] > 4:\n            if i == 0:\n                if groups[i] > total_seats:\n                    return False\n            else:\n                if groups[i] > total_seats - sum(groups[:i]):\n                    return False\n        else:\n            if i == 0:\n                if groups[i] > 4:\n                    if total_seats - groups[i] < sum(groups[1:]):\n                        return False\n                else:\n                    if total_seats - 2 * groups[i] < sum(groups[1:]):\n                        return False\n            else:\n                if groups[i] > 4:\n                    if total_seats - sum(groups[:i]) - groups[i] < sum(groups[i+1:]):\n                        return False\n                else:\n                    if total_seats - sum(groups[:i]) - 2 * groups[i] < sum(groups[i+1:]):\n                        return False\n\n    return True\n\n\nn, k = map(int, input().split())\ngroups = list(map(int, input().split()))\n\nif can_place_soldiers(n, k, groups):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def calculate_cost(sticks, t):\n    return sum(min(abs(stick - t), abs(stick - (t + 1)), abs(stick - (t - 1))) for stick in sticks)\n\ndef main():\n    n = int(input())\n    sticks = list(map(int, input().split()))\n\n    min_cost = float('inf')\n    optimal_t = None\n\n    for t in range(1, 101):\n        cost = calculate_cost(sticks, t)\n        if cost < min_cost:\n            min_cost = cost\n            optimal_t = t\n\n    print(optimal_t, min_cost)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n, m = map(int, input().split())\nmin_x, max_x, min_y, max_y = float('inf'), float('-inf'), float('inf'), float('-inf')\n\nfor i in range(n):\n    row = input()\n    for j in range(m):\n        if row[j] == '*':\n            min_x, max_x = min(min_x, i), max(max_x, i)\n            min_y, max_y = min(min_y, j), max(max_y, j)\n\nside = max(max_x - min_x + 1, max_y - min_y + 1)\nprint(side)"}
{"solution": "import sys\n\nMOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_factorial(n, m):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % m\n    return result\n\ndef mod_combination(n, k, m):\n    numerator = mod_factorial(n, m)\n    denominator = (mod_factorial(k, m) * mod_factorial(n - k, m)) % m\n    return (numerator * mod_inverse(denominator, m)) % m\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    ones = sum(a)\n    zeros = n - ones\n\n    if ones == 0 or zeros == 0:\n        print(1)\n        return\n\n    if k < ones * zeros:\n        print(0)\n        return\n\n    k = min(k, ones * zeros)\n\n    result = 0\n    for i in range(ones + 1):\n        for j in range(zeros + 1):\n            if i + j > n:\n                break\n            if i * j > k:\n                break\n            combination = mod_combination(ones, i, MOD) * mod_combination(zeros, j, MOD)\n            combination %= MOD\n            combination *= mod_combination(n, i + j, MOD)\n            combination %= MOD\n            combination *= mod_combination(i + j, i, MOD)\n            combination %= MOD\n            combination *= mod_inverse(mod_combination(n, 2, MOD), MOD)\n            combination %= MOD\n            combination *= mod_inverse(mod_factorial(k - i * j, MOD), MOD)\n            combination %= MOD\n            combination *= mod_factorial(k, MOD)\n            combination %= MOD\n            result += combination\n            result %= MOD\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\nx, y = map(int, input().split())\n\ndef min_seconds(x, y):\n    seconds = 0\n    while x > y:\n        if x - y > (x - 1) // 2:\n            seconds += x - y\n            x = y\n        else:\n            seconds += 1\n            x = (x - 1) // 2\n    return seconds\n\nprint(min_seconds(x, y))"}
{"solution": "import math\n\ndef calculate_determinant(a, b, c, d):\n    return a * d - b * c\n\ndef calculate_norm(a, b, c, d):\n    return max(abs(a), abs(b), abs(c), abs(d))\n\ndef calculate_min_norm(a, b, c, d):\n    det = calculate_determinant(a, b, c, d)\n    if det == 0:\n        return 0\n\n    norm = calculate_norm(a, b, c, d)\n    if norm == 0:\n        return 0\n\n    x = abs(det) / (abs(a) + abs(c))\n    y = abs(det) / (abs(b) + abs(d))\n    z = abs(det) / (abs(a) + abs(b))\n    w = abs(det) / (abs(c) + abs(d))\n\n    return min(x, y, z, w)\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\nmin_norm = calculate_min_norm(a, b, c, d)\nprint(min_norm)"}
{"solution": "n, a, b = map(int, input().split())\nt = list(map(int, input().split()))\n\ndenied = 0\none_seater = a\ntwo_seater = b\noccupied_two_seater = 0\n\nfor i in t:\n    if i == 1:\n        if one_seater > 0:\n            one_seater -= 1\n        elif two_seater > 0:\n            two_seater -= 1\n            occupied_two_seater += 1\n        elif occupied_two_seater > 0:\n            occupied_two_seater -= 1\n        else:\n            denied += 1\n    else:\n        if two_seater > 0:\n            two_seater -= 1\n        else:\n            denied += 2\n\nprint(denied)"}
{"solution": "def calculate_students_not_passed(a, b, c, n):\n    \"\"\"\n    Calculate the number of students who did not pass the exam.\n\n    Args:\n    a (int): The number of students who visited BugDonalds.\n    b (int): The number of students who visited BeaverKing.\n    c (int): The number of students who visited both restaurants.\n    n (int): The total number of students in the group.\n\n    Returns:\n    int: The number of students who did not pass the exam, or -1 if the data is contradictory.\n    \"\"\"\n    # Calculate the total number of students who visited at least one restaurant\n    total_visited = a + b - c\n    \n    # Check if the total number of students who visited at least one restaurant exceeds the total number of students\n    if total_visited > n:\n        return -1\n    \n    # Calculate the number of students who did not pass the exam\n    not_passed = n - total_visited\n    \n    # Check if at least one student did not pass the exam\n    if not_passed < 1:\n        return -1\n    \n    return not_passed\n\n\n# Read the input values\na, b, c, n = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_students_not_passed(a, b, c, n)\nprint(result)"}
{"solution": "def power(base, exponent, mod):\n    \"\"\"Compute base^exponent modulo mod.\"\"\"\n    result = 1\n    base %= mod\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % mod\n        exponent //= 2\n        base = (base * base) % mod\n    return result\n\ndef solve():\n    \"\"\"Solve the problem.\"\"\"\n    x, k = map(int, input().split())\n    mod = 10**9 + 7\n    result = x\n    for _ in range(k):\n        result = (result * 2 + power(2, _, mod) - 1) % mod\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "MOD = 998244353\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_multiply(a, b):\n    return (a * b) % MOD\n\ndef mod_add(a, b):\n    return (a + b) % MOD\n\ndef mod_subtract(a, b):\n    return (a - b) % MOD\n\ndef calculate_probability(n, problems):\n    total_probability = 1\n    for i in range(n):\n        total_probability = mod_multiply(total_probability, (problems[i][1] - problems[i][0] + 1) % MOD)\n        total_probability = mod_multiply(total_probability, mod_inverse((problems[i][1] - problems[i][0] + 1) % MOD, MOD))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if problems[j][0] < problems[i][0]:\n                continue\n            if problems[j][1] < problems[i][1]:\n                continue\n            if problems[j][0] > problems[i][1]:\n                continue\n\n            overlap = min(problems[i][1], problems[j][1]) - max(problems[i][0], problems[j][0]) + 1\n            total_probability = mod_multiply(total_probability, mod_inverse(overlap, MOD))\n\n    return total_probability\n\nn = int(input())\nproblems = []\nfor _ in range(n):\n    l, r = map(int, input().split())\n    problems.append([l, r])\n\nprobability = calculate_probability(n, problems)\nprint(probability)"}
{"solution": "def count_ways(n):\n    count = 0\n    for a in range(1, n // 4 + 1):\n        for b in range(a, (n - a) // 3 + 1):\n            c = n - 2 * a - b\n            if c >= b and a + b!= c and 2 * a!= c and 2 * b!= c:\n                count += 1\n            if c < b:\n                break\n    return count\n\nn = int(input())\nprint(count_ways(n))"}
{"solution": "import sys\n\ndef fair_nut(n, s, v):\n    v.sort()\n    total = sum(v)\n    if total < s:\n        return -1\n\n    left, right = 0, v[-1]\n    while left < right:\n        mid = (left + right + 1) // 2\n        required = sum(min(mid, x) for x in v)\n        if required > s:\n            right = mid - 1\n        else:\n            left = mid\n\n    return left\n\nn, s = map(int, sys.stdin.readline().split())\nv = list(map(int, sys.stdin.readline().split()))\n\nprint(fair_nut(n, s, v))"}
{"solution": "def caterpillar_reach_apple():\n    h1, h2 = map(int, input().split())\n    a, b = map(int, input().split())\n\n    # Calculate the total distance the caterpillar needs to cover\n    total_distance = h2 - h1\n\n    # Calculate the distance the caterpillar covers in a day\n    day_distance = a * 12 - b * 2\n\n    # If the caterpillar slips down more than it climbs, it will never reach the apple\n    if day_distance <= 0:\n        return -1\n\n    # Calculate the number of days the caterpillar needs to reach the apple\n    days = total_distance // day_distance\n\n    # If the caterpillar still has some distance to cover after the calculated days\n    if total_distance % day_distance!= 0:\n        # Calculate the remaining distance\n        remaining_distance = total_distance % day_distance\n\n        # Calculate the number of hours the caterpillar needs to cover the remaining distance\n        hours = (remaining_distance + a - 1) // a\n\n        # If the caterpillar reaches the apple during the day, add the hours to the days\n        if hours <= 12:\n            days += 1\n        # If the caterpillar reaches the apple during the night, add 2 days\n        else:\n            days += 2\n\n    return days\n\nprint(caterpillar_reach_apple())"}
{"solution": "def calculate_max_joy_units():\n    C, Hr, Hb, Wr, Wb = map(int, input().split())\n\n    max_joy_units = 0\n\n    for r in range(C // Wr + 1):\n        remaining_weight = C - r * Wr\n        b = remaining_weight // Wb\n        joy_units = r * Hr + b * Hb\n        max_joy_units = max(max_joy_units, joy_units)\n\n    print(max_joy_units)\n\ncalculate_max_joy_units()"}
{"solution": "def calculate_min_steps(x1, y1, x2, y2):\n    \"\"\"\n    Calculate the minimal number of steps the robot should make to get the finish position.\n\n    Args:\n        x1 (int): The x-coordinate of the start position.\n        y1 (int): The y-coordinate of the start position.\n        x2 (int): The x-coordinate of the finish position.\n        y2 (int): The y-coordinate of the finish position.\n\n    Returns:\n        int: The minimal number of steps to get the finish position.\n    \"\"\"\n    # Calculate the absolute difference between the x-coordinates\n    dx = abs(x2 - x1)\n    \n    # Calculate the absolute difference between the y-coordinates\n    dy = abs(y2 - y1)\n    \n    # The minimal number of steps is the maximum of dx and dy\n    # This is because the robot can move diagonally, so it can cover the maximum difference in one step\n    return max(dx, dy)\n\n\n# Read the start position coordinates\nx1, y1 = map(int, input().split())\n\n# Read the finish position coordinates\nx2, y2 = map(int, input().split())\n\n# Calculate and print the minimal number of steps\nprint(calculate_min_steps(x1, y1, x2, y2))"}
{"solution": "def predict_outcome(n, fractions):\n    \"\"\"\n    Predict the outcome of the vote based on the given fractions and their optimal behavior.\n\n    Args:\n    n (int): The number of employees.\n    fractions (str): A string of 'D's and 'R's representing the fractions of the employees.\n\n    Returns:\n    str: The predicted outcome of the vote, either 'D' or 'R'.\n    \"\"\"\n    # Initialize the count of 'D's and 'R's\n    d_count = fractions.count('D')\n    r_count = n - d_count\n\n    # If the number of 'D's is greater than the number of 'R's, 'D' wins\n    if d_count > r_count:\n        return 'D'\n    # If the number of 'R's is greater than the number of 'D's, 'R' wins\n    elif r_count > d_count:\n        return 'R'\n    # If the number of 'D's and 'R's is equal, the outcome depends on the last employee\n    else:\n        # If the last employee is 'D', 'D' wins\n        if fractions[-1] == 'D':\n            return 'D'\n        # If the last employee is 'R', 'R' wins\n        else:\n            return 'R'\n\n# Read the input\nn = int(input())\nfractions = input()\n\n# Predict the outcome\noutcome = predict_outcome(n, fractions)\n\n# Print the outcome\nprint(outcome)"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_tv_sets(a, b, x, y):\n    g = gcd(x, y)\n    x //= g\n    y //= g\n\n    max_w = a // x\n    max_h = b // y\n\n    min_w = math.ceil(1 / x)\n    min_h = math.ceil(1 / y)\n\n    max_wh = min(max_w, max_h)\n    min_wh = max(min_w, min_h)\n\n    return max(0, max_wh - min_wh + 1)\n\na, b, x, y = map(int, input().split())\nprint(count_tv_sets(a, b, x, y))"}
{"solution": "import math\n\ndef prime_factors(n):\n    \"\"\"Returns a dictionary of prime factors and their powers\"\"\"\n    factors = {}\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors[i] = factors.get(i, 0) + 1\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef count_trailing_zeros(n, b):\n    \"\"\"Returns the number of trailing zeros in the b-ary representation of n!\"\"\"\n    factors = prime_factors(b)\n    min_count = float('inf')\n    for p in factors:\n        count = 0\n        i = p\n        while i <= n:\n            count += n // i\n            i *= p\n        count //= factors[p]\n        min_count = min(min_count, count)\n    return min_count\n\nn, b = map(int, input().split())\nprint(count_trailing_zeros(n, b))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nm, a, b = map(int, input().split())\nif a > b:\n    a, b = b, a\n\nif a == b:\n    print((m + 1) * (m + 2) // 2)\nelse:\n    c = lcm(a, b)\n    ans = 0\n    for i in range(0, m + 1, c):\n        ans += (i // a + 1) * (min(m, i + c - 1) - i + 1)\n    print(ans)"}
{"solution": "def can_divide_into_odd_subsegments(n, sequence):\n    \"\"\"\n    Decide whether it is possible to divide the sequence into an odd number of non-empty subsegments,\n    each of which has an odd length and begins and ends with odd numbers.\n\n    Args:\n        n (int): The length of the sequence.\n        sequence (list): The elements of the sequence.\n\n    Returns:\n        bool: True if it's possible to fulfill the requirements, False otherwise.\n    \"\"\"\n    # Initialize a list to store the indices of odd numbers in the sequence\n    odd_indices = [i for i, num in enumerate(sequence) if num % 2!= 0]\n\n    # If the number of odd numbers is less than 2, it's impossible to divide the sequence into subsegments\n    if len(odd_indices) < 2:\n        return False\n\n    # Initialize a variable to store the number of subsegments\n    num_subsegments = 0\n\n    # Initialize a variable to store the index of the last odd number\n    last_odd_index = 0\n\n    # Iterate over the indices of odd numbers\n    for i in range(len(odd_indices)):\n        # If the current odd number is not the first one and the distance between it and the last odd number is odd\n        if i > 0 and (odd_indices[i] - last_odd_index - 1) % 2!= 0:\n            # Increment the number of subsegments\n            num_subsegments += 1\n            # Update the index of the last odd number\n            last_odd_index = odd_indices[i]\n\n    # If the number of subsegments is odd and the last subsegment has an odd length\n    if num_subsegments % 2!= 0 and (n - last_odd_index - 1) % 2!= 0:\n        return True\n\n    # If the number of subsegments is even but the sequence can be divided into an odd number of subsegments\n    if num_subsegments % 2 == 0 and (n - odd_indices[0]) % 2!= 0:\n        return True\n\n    # If none of the above conditions are met, it's impossible to divide the sequence into subsegments\n    return False\n\n\n# Read the input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Print the output\nprint(\"Yes\" if can_divide_into_odd_subsegments(n, sequence) else \"No\")"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    # Calculate the difference in x and y coordinates\n    dx = x2 - x1\n    dy = y2 - y1\n\n    # If the points are the same, there is no solution\n    if dx == 0 and dy == 0:\n        return -1\n\n    # If the points are on the same x or y coordinate, \n    # the remaining points will be on the same x or y coordinate\n    if dx == 0:\n        return f\"{x1 + dy} {y1} {x1 + dy} {y2}\"\n    elif dy == 0:\n        return f\"{x1} {y1 + dx} {x2} {y1 + dx}\"\n\n    # If the points are not on the same x or y coordinate, \n    # the remaining points will be on the same x or y coordinate as the first point\n    return f\"{x1 + dy} {y1} {x2 + dy} {y2}\"\n\n# Read the input\nx1, y1, x2, y2 = map(int, input().split())\n\n# Find and print the remaining trees\nresult = find_remaining_trees(x1, y1, x2, y2)\nif result == -1:\n    print(-1)\nelse:\n    print(result)"}
{"solution": "def matrix_multiply(a, b, mod):\n    c = [[0, 0], [0, 0]]\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                c[i][j] += a[i][k] * b[k][j]\n            c[i][j] %= mod\n    return c\n\ndef matrix_power(matrix, n, mod):\n    if n == 1:\n        return matrix\n    if n % 2 == 0:\n        half_pow = matrix_power(matrix, n // 2, mod)\n        return matrix_multiply(half_pow, half_pow, mod)\n    else:\n        half_pow = matrix_power(matrix, n // 2, mod)\n        return matrix_multiply(matrix_multiply(half_pow, half_pow, mod), matrix, mod)\n\ndef solve(x, y, n, mod):\n    if n == 1:\n        return x\n    if n == 2:\n        return y\n    matrix = [[1, 1], [1, 0]]\n    result_matrix = matrix_power(matrix, n - 2, mod)\n    return (result_matrix[0][0] * y - result_matrix[0][1] * x) % mod\n\nmod = 10**9 + 7\nx, y = map(int, input().split())\nn = int(input())\nprint(solve(x, y, n, mod))"}
{"solution": "def split_array(n, arr):\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n\n    if prefix_sum[n] == 0:\n        return \"NO\"\n\n    result = []\n    start = 0\n    for i in range(1, n + 1):\n        if prefix_sum[i]!= 0 and prefix_sum[i]!= prefix_sum[n]:\n            result.append((start + 1, i))\n            start = i\n\n    result.append((start + 1, n))\n\n    print(\"YES\")\n    print(len(result))\n    for r in result:\n        print(r[0], r[1])\n\nn = int(input())\narr = list(map(int, input().split()))\nsplit_array(n, arr)"}
{"solution": "def min_score(n, m, k):\n    MOD = 10**9 + 9\n    if m < n // 2 + 1:\n        return m\n    else:\n        score = n - m\n        score += (m // k) * k\n        score += m % k\n        score *= 2 ** (m // k - 1)\n        return score % MOD\n\nn, m, k = map(int, input().split())\nprint(min_score(n, m, k))"}
{"solution": "def is_divisible_by_8(num):\n    return num % 8 == 0\n\ndef find_divisible_by_8(s):\n    n = len(s)\n    for i in range(n):\n        if is_divisible_by_8(int(s[i])):\n            return s[i]\n    for i in range(n-1):\n        if is_divisible_by_8(int(s[i:i+2])):\n            return s[i:i+2]\n    for i in range(n-2):\n        if is_divisible_by_8(int(s[i:i+3])):\n            return s[i:i+3]\n    return None\n\ns = input()\nresult = find_divisible_by_8(s)\nif result is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(result)"}
{"solution": "def find_floor(n, m, flats):\n    min_flats_per_floor = 1\n    max_flats_per_floor = n\n\n    for flat, floor in flats:\n        min_flats_per_floor = max(min_flats_per_floor, (flat - 1) // (floor - 1) + 1)\n        max_flats_per_floor = min(max_flats_per_floor, (flat - 1) // (floor - 1) + 1)\n\n    if min_flats_per_floor == max_flats_per_floor:\n        return (n - 1) // min_flats_per_floor + 1\n    else:\n        return -1\n\n\nn, m = map(int, input().split())\nflats = [tuple(map(int, input().split())) for _ in range(m)]\n\nprint(find_floor(n, m, flats))"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    board = [[board1[i], board2[i]] for i in range(n)]\n    \n    # Define the four possible shapes of the bishwock\n    bishwock_shapes = [\n        [(0, 0), (0, 1), (1, 0)],  # Original L shape\n        [(0, 0), (0, 1), (1, 1)],  # Rotated 90 degrees\n        [(0, 1), (1, 0), (1, 1)],  # Rotated 180 degrees\n        [(0, 0), (1, 0), (1, 1)]   # Rotated 270 degrees\n    ]\n    \n    def can_place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            if nx >= 2 or ny >= n or board[ny][nx] == 'X':\n                return False\n        return True\n    \n    def place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            board[ny][nx] = 'X'\n    \n    count = 0\n    for y in range(n):\n        for x in range(2):\n            for shape in bishwock_shapes:\n                if can_place_bishwock(x, y, shape):\n                    place_bishwock(x, y, shape)\n                    count += 1\n                    break\n    \n    return count\n\nboard1 = input()\nboard2 = input()\nprint(max_bishwocks(board1, board2))"}
{"solution": "def max_pretty_set_length(n, s):\n    max_length = 0\n    current_set = set()\n    \n    for char in s:\n        if char.islower():\n            current_set.add(char)\n        else:\n            max_length = max(max_length, len(current_set))\n            current_set.clear()\n    \n    # Check the last segment\n    max_length = max(max_length, len(current_set))\n    \n    return max_length\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult = max_pretty_set_length(n, s)\n\n# Print the result\nprint(result)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\na.sort(reverse=True)\nB = sum(a)\nprint(B)"}
{"solution": "def min_refuel(a, b, f, k):\n    if 2 * a * k > b:\n        return -1\n\n    if f * 2 > b:\n        return -1\n\n    if (a - f) * 2 > b:\n        return -1\n\n    if (a - f) * 2 <= b and f * 2 <= b:\n        return 0\n\n    if (a - f) * 2 <= b:\n        return k\n\n    if f * 2 <= b:\n        return k\n\n    if (a - f) * 2 > b and f * 2 > b:\n        return -1\n\n    if (2 * a) % b == 0:\n        return (2 * a * k) // b\n\n    return (2 * a * k) // b + 1\n\n\na, b, f, k = map(int, input().split())\nprint(min_refuel(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    result = []\n    i = 0\n    while i < n:\n        if i + q <= n:\n            result.append(s[i:i+q])\n            i += q\n        elif i + p <= n:\n            result.append(s[i:i+p])\n            i += p\n        else:\n            return \"-1\"\n    return str(len(result)) + \"\\n\" + \"\\n\".join(result)\n\nn, p, q = map(int, input().split())\ns = input()\nprint(split_string(n, p, q, s))"}
{"solution": "def solve(n, m, s, d, obstacles):\n    obstacles.sort()\n    current_position = 0\n    result = []\n    for obstacle in obstacles:\n        if obstacle - current_position < s:\n            return \"IMPOSSIBLE\"\n        result.append(f\"RUN {min(s, obstacle - current_position)}\")\n        current_position += min(s, obstacle - current_position)\n        if current_position + d >= obstacle + 1:\n            result.append(f\"JUMP {min(d, m - current_position)}\")\n            current_position += min(d, m - current_position)\n        else:\n            return \"IMPOSSIBLE\"\n    if current_position < m:\n        result.append(f\"RUN {m - current_position}\")\n    return \"\\n\".join(result)\n\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\nprint(solve(n, m, s, d, obstacles))"}
{"solution": "def solve(s, x):\n    if (s - x) % 2!= 0:\n        return 0\n    b = (s - x) // 2\n    a = s - b\n    if a > 0 and b > 0 and a!= b:\n        return 4\n    elif a > 0 and b > 0 and a == b:\n        return 2\n    else:\n        return 0\n\ns, x = map(int, input().split())\nprint(solve(s, x))"}
{"solution": "def solve(n, k):\n    if n <= 2 * k:\n        return [1]\n    elif n == 2 * k + 1:\n        return [1, n]\n    else:\n        result = []\n        i = 1\n        while i <= n:\n            result.append(i)\n            i += 2 * k + 1\n        if i - 2 * k > n:\n            result[-1] = n\n        return result\n\nn, k = map(int, input().split())\nresult = solve(n, k)\nprint(len(result))\nprint(*result)"}
{"solution": "import math\n\nn = input().strip()\nn_len = len(n)\n\nmax_square_root = int(math.sqrt(2 * 10**9)) + 1\nsquares = [str(i * i) for i in range(1, max_square_root + 1)]\n\ndef is_subsequence(small, large):\n    it = iter(large)\n    return all(char in it for char in small)\n\nmin_deletions = float('inf')\n\nfor square in squares:\n    if is_subsequence(square, n):\n        deletions = n_len - len(square)\n        min_deletions = min(min_deletions, deletions)\n\nprint(min_deletions if min_deletions!= float('inf') else -1)"}
{"solution": "import math\n\nMOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef mod_permutations(n, k):\n    return (mod_factorial(n) * mod_inverse(mod_factorial(n - k), MOD)) % MOD\n\ndef main():\n    n = int(input())\n    if n <= 3:\n        print(mod_permutations(n, n))\n    else:\n        print((mod_permutations(n - 1, n - 1) * (n - 1)) % MOD)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def minimum_jump_ability(s):\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    positions = [-1]  # Start position before the first character\n    \n    # Collect positions of all vowels\n    for i, char in enumerate(s):\n        if char in vowels:\n            positions.append(i)\n    \n    positions.append(len(s))  # End position after the last character\n    \n    # Calculate maximum distance between consecutive positions\n    max_distance = 0\n    for i in range(1, len(positions)):\n        max_distance = max(max_distance, positions[i] - positions[i - 1])\n    \n    return max_distance\n\ns = input()\nprint(minimum_jump_ability(s))"}
{"solution": "def can_distribute_equally(a):\n    total_sum = sum(a)\n    if total_sum % 2!= 0:\n        return False\n\n    target_sum = total_sum // 2\n    a.sort(reverse=True)\n\n    def dfs(index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(a):\n            return False\n\n        return dfs(index + 1, current_sum + a[index]) or dfs(index + 1, current_sum)\n\n    return dfs(0, 0)\n\n\na = list(map(int, input().split()))\nprint(\"YES\" if can_distribute_equally(a) else \"NO\")"}
{"solution": "def calculate_pie_sums(n, pie_sizes):\n    \"\"\"\n    Calculate the sum of pie sizes for Alice and Bob.\n\n    Args:\n    n (int): The number of slices of pie.\n    pie_sizes (list): A list of integers indicating the sizes of the slices.\n\n    Returns:\n    tuple: A tuple containing the sum of pie sizes for Alice and Bob.\n    \"\"\"\n    # Initialize variables to store the sum of pie sizes for Alice and Bob\n    alice_sum = 0\n    bob_sum = 0\n\n    # Initialize a variable to store the current player\n    current_player = \"Bob\"\n\n    # Iterate over the pie sizes in reverse order\n    for i in range(n - 1, -1, -1):\n        # If the current player is Bob, add the current pie size to Bob's sum\n        if current_player == \"Bob\":\n            bob_sum += pie_sizes[i]\n            # Switch the current player to Alice\n            current_player = \"Alice\"\n        # If the current player is Alice, add the current pie size to Alice's sum\n        else:\n            alice_sum += pie_sizes[i]\n            # Switch the current player to Bob\n            current_player = \"Bob\"\n\n    # Return the sums of pie sizes for Alice and Bob\n    return alice_sum, bob_sum\n\n\n# Read the number of slices of pie\nn = int(input())\n\n# Read the sizes of the slices\npie_sizes = list(map(int, input().split()))\n\n# Calculate the sums of pie sizes for Alice and Bob\nalice_sum, bob_sum = calculate_pie_sums(n, pie_sizes)\n\n# Print the sums of pie sizes for Alice and Bob\nprint(alice_sum, bob_sum)"}
{"solution": "def min_variables(n, a):\n    a = sorted(a)\n    max_num = a[-1]\n    max_bits = max_num.bit_length()\n    max_mask = (1 << max_bits) - 1\n\n    dp = [0] * (max_mask + 1)\n    dp[0] = 1\n\n    for num in a:\n        num_bits = num.bit_length()\n        for mask in range(max_mask, -1, -1):\n            if dp[mask] == 0:\n                continue\n            for i in range(num_bits):\n                new_mask = mask | (1 << i)\n                if new_mask > max_mask:\n                    break\n                dp[new_mask] = 1\n\n    for i in range(max_mask, -1, -1):\n        if dp[i] == 1:\n            return i.bit_length()\n\n    return -1\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_variables(n, a))"}
{"solution": "def determine_winner(n, piles):\n    odd_count = sum(1 for pile in piles if pile % 2!= 0)\n    if odd_count % 2 == 0:\n        return \"Alice\" if min(piles) % 2!= 0 else \"Bob\"\n    else:\n        return \"Alice\"\n\nn = int(input())\npiles = list(map(int, input().split()))\n\nprint(determine_winner(n, piles))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(\"YES\")\n    exit()\n\ng = 0\nfor i in range(1, n):\n    g = gcd(g, abs(a[i] - a[0]))\n\nif g == 0:\n    print(\"YES\")\nelse:\n    for i in range(n):\n        if abs(a[i] - a[0]) % g!= 0:\n            print(\"NO\")\n            exit()\n    print(\"YES\")"}
{"solution": "def longest_repeated_substring(n, s):\n    max_len = 0\n    for length in range(1, n // 2 + 1):\n        for i in range(n - length):\n            substr = s[i:i + length]\n            if s.find(substr, i + length)!= -1:\n                max_len = max(max_len, length)\n    return max_len\n\nn = int(input())\ns = input()\nprint(longest_repeated_substring(n, s))"}
{"solution": "def minimum_time_to_house(n, a):\n    if a % 2 == 1:\n        # a is odd\n        return (a + 1) // 2\n    else:\n        # a is even\n        return (n - a + 2) // 2\n\nn, a = map(int, input().split())\nprint(minimum_time_to_house(n, a))"}
{"solution": "def find_interval(n, m, colors, counts):\n    \"\"\"\n    Find if there is a contiguous interval of knights with prescribed color counts.\n\n    Args:\n    n (int): The number of Jedi Knights.\n    m (int): The number of possible colors.\n    colors (list): A list of colors of the lightsabers of the Jedi Knights.\n    counts (list): A list of desired counts of lightsabers of each color.\n\n    Returns:\n    bool: True if an interval with prescribed color counts exists, False otherwise.\n    \"\"\"\n    # Initialize a dictionary to store the current counts of each color\n    current_counts = {i: 0 for i in range(1, m + 1)}\n\n    # Initialize the left and right pointers of the sliding window\n    left = 0\n    right = 0\n\n    # Initialize a flag to indicate if the desired counts are found\n    found = False\n\n    # Expand the right pointer to include more elements\n    while right < n:\n        # Add the color at the right pointer to the current counts\n        current_counts[colors[right]] += 1\n\n        # Check if the current counts match the desired counts\n        if all(current_counts[i] == counts[i - 1] for i in range(1, m + 1)):\n            found = True\n            break\n\n        # If the current counts exceed the desired counts, move the left pointer\n        if sum(current_counts.values()) > sum(counts):\n            current_counts[colors[left]] -= 1\n            left += 1\n\n        # Move the right pointer to include more elements\n        right += 1\n\n    return found\n\n\n# Read the input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\ncounts = list(map(int, input().split()))\n\n# Find if an interval with prescribed color counts exists\nif find_interval(n, m, colors, counts):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def determine_winner():\n    n = int(input())\n    mishka_wins = 0\n    chris_wins = 0\n    \n    for _ in range(n):\n        m, c = map(int, input().split())\n        if m > c:\n            mishka_wins += 1\n        elif c > m:\n            chris_wins += 1\n    \n    if mishka_wins > chris_wins:\n        print(\"Mishka\")\n    elif chris_wins > mishka_wins:\n        print(\"Chris\")\n    else:\n        print(\"Friendship is magic!^^\")\n\ndetermine_winner()"}
{"solution": "def is_valid_field(n, m, field):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                continue\n\n            if field[i][j] == '.':\n                for direction in directions:\n                    ni, nj = i + direction[0], j + direction[1]\n                    if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':\n                        return False\n            else:\n                count = 0\n                for direction in directions:\n                    ni, nj = i + direction[0], j + direction[1]\n                    if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':\n                        count += 1\n                if count!= int(field[i][j]):\n                    return False\n\n    return True\n\n\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\nif is_valid_field(n, m, field):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def can_vasya_eat_half(n, k):\n    total_candies = n\n    vasya_eaten = 0\n    \n    while total_candies > 0:\n        # Vasya eats k candies\n        vasya_eaten += min(k, total_candies)\n        total_candies -= min(k, total_candies)\n        \n        # Petya eats 10% of the remaining candies\n        petya_eaten = total_candies // 10\n        total_candies -= petya_eaten\n    \n    return vasya_eaten >= (n + 1) // 2\n\ndef find_min_k(n):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\nn = int(input().strip())\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace():\n    s = input()\n    p = s.count('o')\n    l = s.count('-')\n    \n    if p == 0 or p == 1:\n        print(\"YES\")\n    elif l % p == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\ncan_rearrange_necklace()"}
{"solution": "def max_pillows(n, m, k):\n    \"\"\"\n    Calculate the maximum number of pillows Frodo can have.\n\n    Args:\n    n (int): The number of hobbits.\n    m (int): The number of pillows.\n    k (int): The position of Frodo's bed.\n\n    Returns:\n    int: The maximum number of pillows Frodo can have.\n    \"\"\"\n    # Calculate the number of pillows that can be distributed equally\n    equal_pillows = m // n\n    \n    # Calculate the remaining pillows after equal distribution\n    remaining_pillows = m % n\n    \n    # If Frodo is at the edge, he can take all the remaining pillows\n    if k == 1 or k == n:\n        return equal_pillows + remaining_pillows\n    \n    # If Frodo is not at the edge, he can take at most one more pillow than his neighbors\n    else:\n        # Calculate the maximum number of pillows Frodo can have\n        max_frodo_pillows = equal_pillows + min(remaining_pillows, 1 + (k - 2) // 2)\n        \n        return max_frodo_pillows\n\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Calculate and print the maximum number of pillows Frodo can have\nprint(max_pillows(n, m, k))"}
{"solution": "import math\n\ndef max_subarray_cost(n, m, k, a):\n    max_cost = 0\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    for length in range(1, m + 1):\n        dp = [float('-inf')] * (n + 1)\n        for i in range(length, n + 1):\n            dp[i] = max(dp[i - 1], prefix_sum[i] - prefix_sum[i - length] - k * math.ceil(length / m))\n            max_cost = max(max_cost, dp[i])\n\n    return max_cost\n\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\nprint(max_subarray_cost(n, m, k, a))"}
{"solution": "import math\n\ndef distance(p1, p2):\n    \"\"\"Calculate the Euclidean distance between two points.\"\"\"\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef longest_polyline(n, m):\n    \"\"\"Find the longest possible polyline on a rectangular grid.\"\"\"\n    points = [(0, 0), (n, 0), (n, m), (0, m)]\n    max_length = 0\n    best_points = None\n\n    for p1 in points:\n        for p2 in points:\n            if p1 == p2:\n                continue\n            for p3 in points:\n                if p3 in (p1, p2):\n                    continue\n                for p4 in points:\n                    if p4 in (p1, p2, p3):\n                        continue\n                    length = distance(p1, p2) + distance(p2, p3) + distance(p3, p4)\n                    if length > max_length:\n                        max_length = length\n                        best_points = [p1, p2, p3, p4]\n\n    return best_points\n\ndef main():\n    n, m = map(int, input().split())\n    points = longest_polyline(n, m)\n    for point in points:\n        print(*point)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_smallest_number(shuffled_string, remembered_substring):\n    # Calculate the length of the original number\n    for i in range(len(shuffled_string) - 1, -1, -1):\n        if shuffled_string[i].isdigit():\n            original_length = int(shuffled_string[i])\n            break\n\n    # Remove the length from the shuffled string\n    shuffled_string = shuffled_string[:i]\n\n    # Initialize variables to store the smallest number and its length\n    smallest_number = float('inf')\n    smallest_length = 0\n\n    # Iterate over all possible positions of the remembered substring\n    for i in range(len(shuffled_string) - len(remembered_substring) + 1):\n        # Check if the substring matches at the current position\n        if shuffled_string[i:i + len(remembered_substring)] == remembered_substring:\n            # Extract the remaining digits\n            remaining_digits = shuffled_string[:i] + shuffled_string[i + len(remembered_substring):]\n\n            # Sort the remaining digits in ascending order\n            remaining_digits = ''.join(sorted(remaining_digits))\n\n            # Construct the number by concatenating the remembered substring and the remaining digits\n            number = remembered_substring + remaining_digits\n\n            # Check if the number has the correct length and is smaller than the current smallest number\n            if len(number) == original_length and int(number) < smallest_number:\n                smallest_number = int(number)\n                smallest_length = len(number)\n\n    # If the smallest number has a leading zero, remove it\n    if smallest_length > 1 and smallest_number == 0:\n        smallest_number = 0\n    elif smallest_length > 1 and str(smallest_number)[0] == '0':\n        smallest_number = int(str(smallest_number)[1:])\n\n    return smallest_number\n\n\nshuffled_string = input()\nremembered_substring = input()\n\nprint(find_smallest_number(shuffled_string, remembered_substring))"}
{"solution": "def check_temperature_consistency():\n    n, m, min_temp, max_temp = map(int, input().split())\n    temperatures = list(map(int, input().split()))\n\n    if min(temperatures) < min_temp or max(temperatures) > max_temp:\n        return \"Incorrect\"\n\n    if min_temp in temperatures and max_temp in temperatures:\n        return \"Correct\"\n\n    if min_temp in temperatures:\n        if len(temperatures) < n and max_temp > max(temperatures):\n            return \"Correct\"\n        return \"Incorrect\"\n\n    if max_temp in temperatures:\n        if len(temperatures) < n and min_temp < min(temperatures):\n            return \"Correct\"\n        return \"Incorrect\"\n\n    if len(temperatures) < n and min_temp < min(temperatures) and max_temp > max(temperatures):\n        return \"Correct\"\n\n    return \"Incorrect\"\n\nprint(check_temperature_consistency())"}
{"solution": "def find_trailing_zeroes(m):\n    \"\"\"\n    Find the number of positive integers n, such that the factorial of n ends with exactly m zeroes.\n    \n    Args:\n    m (int): The required number of trailing zeroes in factorial.\n    \n    Returns:\n    list: A list containing the count of numbers and the numbers themselves.\n    \"\"\"\n    count = 0\n    numbers = []\n    i = 5\n    while True:\n        if m > i // 5 + i // 25 + i // 125 + i // 625 + i // 3125 + i // 15625 + i // 78125 + i // 390625 + i // 1953125 + i // 9765625 + i // 48828125 + i // 244140625:\n            break\n        i += 5\n        count += 1\n        numbers.append(i)\n    return [count] + numbers\n\nm = int(input())\nresult = find_trailing_zeroes(m)\nprint(result[0])\nif result[0] > 0:\n    print(*result[1:])"}
{"solution": "import sys\nimport heapq\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_int_list():\n    return list(read_ints())\n\ndef solve():\n    n, m, k = read_ints()\n    special_vertices = read_int_list()\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v, w = read_ints()\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    distances = [0] * (n + 1)\n    for start in special_vertices:\n        pq = [(0, start)]\n        visited = set()\n        while pq:\n            dist, node = heapq.heappop(pq)\n            if node in visited:\n                continue\n            visited.add(node)\n            distances[node] = max(distances[node], dist)\n            for neighbor, weight in graph[node]:\n                if neighbor not in visited:\n                    heapq.heappush(pq, (max(dist, weight), neighbor))\n\n    max_distances = [0] * k\n    for i, vertex in enumerate(special_vertices):\n        max_distances[i] = max(distances[vertex] for vertex in special_vertices if vertex!= special_vertices[i])\n\n    print(*max_distances)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def initial_shell_position(n, x):\n    \"\"\"\n    Calculate the initial position of the ball in the shell game.\n\n    Args:\n    n (int): The number of movements made by the operator.\n    x (int): The index of the shell where the ball was found after n movements.\n\n    Returns:\n    int: The index of the shell where the ball was initially placed.\n    \"\"\"\n    # Calculate the remainder of n divided by 3\n    remainder = n % 3\n    \n    # If the remainder is 0, the ball is in the same position as the initial position\n    if remainder == 0:\n        return x\n    \n    # If the remainder is 1, the ball is in the position that is one step to the left of the initial position\n    elif remainder == 1:\n        if x == 0:\n            return 2\n        elif x == 1:\n            return 0\n        else:\n            return 1\n    \n    # If the remainder is 2, the ball is in the position that is two steps to the left of the initial position\n    else:\n        if x == 0:\n            return 1\n        elif x == 1:\n            return 2\n        else:\n            return 0\n\n\n# Read the input\nn = int(input())\nx = int(input())\n\n# Calculate and print the initial position of the ball\nprint(initial_shell_position(n, x))"}
{"solution": "def is_square(rectangles):\n    # Calculate the bounding box\n    min_x = min(x1 for x1, _, _, _ in rectangles)\n    max_x = max(x2 for _, _, x2, _ in rectangles)\n    min_y = min(y1 for _, y1, _, _ in rectangles)\n    max_y = max(y2 for _, _, _, y2 in rectangles)\n\n    # Check if the bounding box is a square\n    if max_x - min_x!= max_y - min_y:\n        return False\n\n    # Check if the rectangles cover the entire bounding box\n    covered = [[False] * (max_x - min_x) for _ in range(max_y - min_y)]\n    for x1, y1, x2, y2 in rectangles:\n        for x in range(x1, x2):\n            for y in range(y1, y2):\n                if min_x <= x < max_x and min_y <= y < max_y:\n                    covered[y - min_y][x - min_x] = True\n\n    # Check if all points in the bounding box are covered\n    for row in covered:\n        if not all(row):\n            return False\n\n    return True\n\nn = int(input())\nrectangles = [list(map(int, input().split())) for _ in range(n)]\n\nprint(\"YES\" if is_square(rectangles) else \"NO\")"}
{"solution": "def digit_sum(x):\n    return sum(int(digit) for digit in str(x))\n\ndef count_big_numbers(n, s):\n    count = 0\n    for i in range(1, n + 1):\n        if i - digit_sum(i) >= s:\n            count += 1\n    return count\n\nn, s = map(int, input().split())\nprint(count_big_numbers(n, s))"}
{"solution": "from collections import defaultdict\nfrom math import gcd\n\ndef get_slope(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    if x1 == x2:\n        return float('inf')\n    return (y2 - y1) / (x2 - x1)\n\ndef solve(points):\n    n = len(points)\n    if n <= 2:\n        return True\n\n    slopes = defaultdict(set)\n    for i in range(n):\n        for j in range(i + 1, n):\n            slope = get_slope(points[i], points[j])\n            slopes[slope].add(tuple(points[i]))\n            slopes[slope].add(tuple(points[j]))\n\n    max_points = 0\n    for slope in slopes:\n        max_points = max(max_points, len(slopes[slope]))\n\n    return max_points >= n - 1\n\ndef main():\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    if solve(points):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 10**9 + 7\n\ndef pow_mod(a, b):\n    res = 1\n    while b:\n        if b & 1:\n            res = (res * a) % MOD\n        a = (a * a) % MOD\n        b >>= 1\n    return res\n\ndef inv(a):\n    return pow_mod(a, MOD - 2)\n\ndef comb(n, k):\n    if k < 0 or k > n:\n        return 0\n    return (fact[n] * inv(fact[k]) * inv(fact[n - k])) % MOD\n\nfact = [1] * 200001\nfor i in range(1, 200001):\n    fact[i] = (fact[i - 1] * i) % MOD\n\na, b, k, t = map(int, input().split())\ndiff = b - a + 1\nres = 0\nfor i in range(diff, (2 * k + 1) * t + 1):\n    res = (res + comb((2 * k + 1) * t, i)) % MOD\nprint(res)"}
{"solution": "def can_measure(distances, target):\n    for i in range(len(distances)):\n        for j in range(i, len(distances)):\n            if distances[j] - distances[i] == target:\n                return True\n    return False\n\ndef find_additional_marks(n, l, x, y, distances):\n    if can_measure(distances, x) and can_measure(distances, y):\n        return 0, []\n    elif can_measure(distances, x):\n        return 1, [y]\n    elif can_measure(distances, y):\n        return 1, [x]\n    else:\n        for i in range(len(distances)):\n            for j in range(i, len(distances)):\n                if distances[j] - distances[i] == x:\n                    return 1, [y]\n                elif distances[j] - distances[i] == y:\n                    return 1, [x]\n        return 2, [x, y]\n\nn, l, x, y = map(int, input().split())\ndistances = list(map(int, input().split()))\n\nadditional_marks_count, additional_marks = find_additional_marks(n, l, x, y, distances)\n\nprint(additional_marks_count)\nif additional_marks_count > 0:\n    print(*additional_marks)"}
{"solution": "import math\n\ndef calculate_volume(radius, height):\n    return math.pi * radius * radius * height\n\ndef solve():\n    n = int(input())\n    cakes = []\n    for _ in range(n):\n        radius, height = map(int, input().split())\n        cakes.append((radius, height))\n\n    cakes.sort(key=lambda x: calculate_volume(x[0], x[1]))\n\n    dp = [0] * n\n    dp[0] = calculate_volume(cakes[0][0], cakes[0][1])\n\n    for i in range(1, n):\n        max_volume = 0\n        for j in range(i):\n            if cakes[i][0] > cakes[j][0] and cakes[i][1] > cakes[j][1]:\n                max_volume = max(max_volume, dp[j])\n        dp[i] = max(dp[i-1], max_volume + calculate_volume(cakes[i][0], cakes[i][1]))\n\n    print(dp[-1])\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import math\n\ndef min_slices(n, k, heights):\n    heights.sort()\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + heights[i]\n\n    def check(mid):\n        total_cost = 0\n        for i in range(n - 1, -1, -1):\n            if heights[i] > heights[mid]:\n                total_cost += heights[i] - heights[mid]\n                if total_cost > k:\n                    return False\n        return True\n\n    def binary_search(left, right):\n        while left < right:\n            mid = (left + right) // 2\n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    min_height = binary_search(0, n - 1)\n    return math.ceil((heights[-1] - heights[min_height]) / heights[min_height])\n\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\nprint(min_slices(n, k, heights))"}
{"solution": "def max_score(n, a):\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    max_score = float('-inf')\n\n    for l in range(n):\n        max_in_segment = float('-inf')\n        for r in range(l, n):\n            max_in_segment = max(max_in_segment, a[r])\n            segment_sum = prefix_sum[r + 1] - prefix_sum[l]\n            score = segment_sum - max_in_segment\n            max_score = max(max_score, score)\n\n    return max_score\n\nn = int(input())\na = list(map(int, input().split()))\nprint(max_score(n, a))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve():\n    k1, k2, k3 = map(int, input().split())\n    if lcm(k1, k2) <= k1 + k2 + k3:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nsolve()"}
{"solution": "def min_operations_to_delete_string(n, s):\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = 1\n    \n    for length in range(2, n + 1):  \n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j-1]\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n    \n    return dp[0][n-1]\n\nn = int(input())\ns = input().strip()\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "def max_pairs(boys, girls):\n    boys.sort()\n    girls.sort()\n    i = j = pairs = 0\n    while i < len(boys) and j < len(girls):\n        if abs(boys[i] - girls[j]) <= 1:\n            pairs += 1\n            i += 1\n            j += 1\n        elif boys[i] < girls[j]:\n            i += 1\n        else:\n            j += 1\n    return pairs\n\nn = int(input())\nboys = list(map(int, input().split()))\nm = int(input())\ngirls = list(map(int, input().split()))\n\nprint(max_pairs(boys, girls))"}
{"solution": "def determine_winner():\n    # Read the skills of each player\n    skills = [list(map(int, input().split())) for _ in range(4)]\n\n    # Calculate the maximum attack and defence for each team\n    team1_attack = max(skills[0][1], skills[1][1])\n    team1_defence = max(skills[0][0], skills[1][0])\n    team2_attack = max(skills[2][1], skills[3][1])\n    team2_defence = max(skills[2][0], skills[3][0])\n\n    # Check if team 1 can win\n    if team1_defence > team2_attack and team1_attack > team2_defence:\n        return \"Team 1\"\n\n    # Check if team 2 can win\n    elif team2_defence > team1_attack and team2_attack > team1_defence:\n        return \"Team 2\"\n\n    # If neither team can win, it's a draw\n    else:\n        return \"Draw\"\n\nprint(determine_winner())"}
{"solution": "import math\nimport sys\n\ndef dist(x1, y1, x2, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef check(x, y, k, arr):\n    times = []\n    for x_i, y_i, c_i in arr:\n        times.append(c_i * dist(x, y, x_i, y_i))\n    times.sort()\n    return times[k - 1]\n\ndef solve():\n    n, k = map(int, input().split())\n    arr = []\n    for _ in range(n):\n        x_i, y_i, c_i = map(int, input().split())\n        arr.append((x_i, y_i, c_i))\n\n    min_x, max_x = min(x for x, _, _ in arr), max(x for x, _, _ in arr)\n    min_y, max_y = min(y for _, y, _ in arr), max(y for _, y, _ in arr)\n\n    step = 0.00001\n    ans = sys.maxsize\n    for x in [i * step for i in range(int(min_x / step), int(max_x / step) + 1)]:\n        for y in [i * step for i in range(int(min_y / step), int(max_y / step) + 1)]:\n            ans = min(ans, check(x, y, k, arr))\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def calculate_difference(s, n):\n    \"\"\"Calculate the difference between the sum of the first half and the sum of the second half.\"\"\"\n    first_half_sum = sum(int(s[i]) for i in range(n // 2) if s[i]!= '?')\n    second_half_sum = sum(int(s[i]) for i in range(n // 2, n) if s[i]!= '?')\n    return first_half_sum - second_half_sum\n\n\ndef can_monocarp_win(s, n):\n    \"\"\"Determine if Monocarp can win.\"\"\"\n    difference = calculate_difference(s, n)\n    first_half_unknown = s[:n // 2].count('?')\n    second_half_unknown = s[n // 2:].count('?')\n\n    if difference > 0:\n        # Monocarp needs to make the sum of the first half smaller.\n        return first_half_unknown >= difference // 10 + (difference % 10!= 0)\n    elif difference < 0:\n        # Monocarp needs to make the sum of the second half smaller.\n        return second_half_unknown >= -difference // 10 + (-difference % 10!= 0)\n    else:\n        # The sums are already equal, Monocarp needs to make them unequal.\n        return first_half_unknown + second_half_unknown >= 2\n\n\ndef main():\n    n = int(input())\n    s = input()\n\n    if can_monocarp_win(s, n):\n        print(\"Monocarp\")\n    else:\n        print(\"Bicarp\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_bus_route():\n    n, t = map(int, input().split())\n    earliest_time = float('inf')\n    chosen_route = -1\n    \n    for i in range(n):\n        s_i, d_i = map(int, input().split())\n        \n        if s_i >= t:\n            next_bus_time = s_i\n        else:\n            if (t - s_i) % d_i == 0:\n                next_bus_time = t\n            else:\n                next_bus_time = s_i + ((t - s_i) // d_i + 1) * d_i\n        \n        if next_bus_time < earliest_time:\n            earliest_time = next_bus_time\n            chosen_route = i + 1\n    \n    print(chosen_route)\n\nfind_bus_route()"}
{"solution": "def count_ones(n):\n    \"\"\"Count the number of ones in the binary representation of n.\"\"\"\n    return bin(n).count('1')\n\ndef find_n(m, k):\n    \"\"\"Find the smallest n such that there are exactly m numbers between n+1 and 2n (inclusive) with k ones in their binary representation.\"\"\"\n    n = 1\n    while True:\n        count = sum(1 for i in range(n+1, 2*n+1) if count_ones(i) == k)\n        if count == m:\n            return n\n        n += 1\n\nm, k = map(int, input().split())\nprint(find_n(m, k))"}
{"solution": "def is_good_level(level):\n    platforms = [i for i, x in enumerate(level) if x == '*']\n    for i in range(len(platforms) - 4):\n        interval = platforms[i + 1] - platforms[i]\n        if all(platforms[i + j + 1] - platforms[i + j] == interval for j in range(3)):\n            return True\n    return False\n\nn = int(input())\nlevel = input().strip()\nprint('yes' if is_good_level(level) else 'no')"}
{"solution": "def find_magic_number(n, grid):\n    # Find the position of the empty cell\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                empty_row, empty_col = i, j\n\n    # Calculate the expected sum of each row, column, and diagonal\n    expected_sum = None\n    for i in range(n):\n        row_sum = sum(grid[i])\n        if expected_sum is None:\n            expected_sum = row_sum\n        elif row_sum!= expected_sum:\n            return -1\n\n    for j in range(n):\n        col_sum = sum(grid[i][j] for i in range(n))\n        if col_sum!= expected_sum:\n            return -1\n\n    diagonal_sum1 = sum(grid[i][i] for i in range(n))\n    if diagonal_sum1!= expected_sum:\n        return -1\n\n    diagonal_sum2 = sum(grid[i][n - i - 1] for i in range(n))\n    if diagonal_sum2!= expected_sum:\n        return -1\n\n    # Calculate the sum of all numbers in the grid\n    total_sum = sum(sum(row) for row in grid)\n\n    # Calculate the expected total sum of the magic square\n    expected_total_sum = expected_sum * n\n\n    # Calculate the magic number\n    magic_number = expected_total_sum - total_sum\n\n    # Check if the magic number is positive\n    if magic_number <= 0:\n        return -1\n\n    return magic_number\n\n\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\nprint(find_magic_number(n, grid))"}
{"solution": "import math\n\n# Read the number of benches\nn = int(input())\n\n# Read the number of additional people\nm = int(input())\n\n# Read the initial number of people on each bench\na = [int(input()) for _ in range(n)]\n\n# Calculate the maximum possible k\nmax_k = max(a) + m\n\n# Calculate the total number of people after adding m people\ntotal_people = sum(a) + m\n\n# Calculate the minimum possible k\nmin_k = math.ceil(total_people / n)\n\n# Print the minimum and maximum possible k\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef pow_mod(a, b):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = (res * a) % MOD\n        a = (a * a) % MOD\n        b >>= 1\n    return res\n\ndef inv_mod(a):\n    return pow_mod(a, MOD - 2)\n\ndef main():\n    n, m = map(int, input().split())\n    if m > n:\n        print(0)\n        return\n\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n\n    inv_fact = [1] * (n + 1)\n    inv_fact[n] = inv_mod(fact[n])\n    for i in range(n - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD\n\n    def choose(n, k):\n        return (fact[n] * inv_fact[k] * inv_fact[n - k]) % MOD\n\n    res = 0\n    for k in range(m + 1):\n        res = (res + choose(m, k) * pow_mod(2, k) * pow_mod(2, m - k) * choose(n, m - k) * fact[m - k]) % MOD\n\n    print(res)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import defaultdict\nfrom itertools import combinations\n\ndef solve():\n    n, m = map(int, input().split())\n\n    friends = []\n    for _ in range(n):\n        f, *b = map(int, input().split())\n        friends.append(set(b))\n\n    pizzas = []\n    for _ in range(m):\n        c, r, *a = map(int, input().split())\n        pizzas.append((c, set(a)))\n\n    max_friends = 0\n    min_cost = float('inf')\n    best_pizzas = None\n\n    for i, (c1, a1) in enumerate(pizzas):\n        for j, (c2, a2) in enumerate(pizzas[i+1:], i+1):\n            if c1 + c2 > min_cost:\n                continue\n\n            pleased_friends = 0\n            for friend in friends:\n                if friend.issubset(a1) or friend.issubset(a2) or friend.issubset(a1 | a2):\n                    pleased_friends += 1\n\n            if pleased_friends > max_friends or (pleased_friends == max_friends and c1 + c2 < min_cost):\n                max_friends = pleased_friends\n                min_cost = c1 + c2\n                best_pizzas = (i+1, j+1)\n\n    print(*best_pizzas)\n\nsolve()"}
{"solution": "def find_min_max(m, s):\n    if s == 0 and m > 1:\n        return -1, -1\n    if s > 9 * m:\n        return -1, -1\n\n    min_num = ''\n    max_num = ''\n\n    # Construct the minimum number\n    if s > 0:\n        min_num += str(s - (m - 1))\n        s -= (s - (m - 1))\n    else:\n        min_num += '0'\n    while len(min_num) < m:\n        if s > 0:\n            min_num += '1'\n            s -= 1\n        else:\n            min_num += '0'\n\n    # Construct the maximum number\n    if s > 0:\n        max_num += str(s)\n        s -= s\n    else:\n        max_num += '0'\n    while len(max_num) < m:\n        if s > 0:\n            max_num += '9'\n            s -= 9\n        else:\n            max_num += '0'\n\n    return int(min_num), int(max_num[::-1])\n\nm, s = map(int, input().split())\nmin_num, max_num = find_min_max(m, s)\nprint(min_num, max_num)"}
{"solution": "MOD = 998244353\n\ndef count_numbers_with_at_most_k_digits(n, k):\n    if k == 0:\n        return 0\n    if k == 1:\n        return sum(i * (10 ** (len(str(i)) - 1)) for i in range(1, 10))\n\n    dp = [[0] * 11 for _ in range(19)]\n    dp[0][0] = 1\n\n    for i in range(1, 19):\n        for j in range(1, 11):\n            for digit in range(10):\n                if digit == 0 and i == 1:\n                    continue\n                dp[i][j] += dp[i - 1][j - (digit > 0)]\n\n    res = 0\n    for i in range(1, 19):\n        for j in range(1, k + 1):\n            res += dp[i][j] * (10 ** (i - 1)) * (10 ** (18 - i)) * (10 ** (j - 1))\n\n    return res % MOD\n\ndef sum_of_numbers_with_at_most_k_digits(n, k):\n    if k == 0:\n        return 0\n    if k == 1:\n        return sum(i * (10 ** (len(str(i)) - 1)) * (10 ** (len(str(i)) - 1) + 1) // 2 for i in range(1, 10))\n\n    dp = [[[0] * 11 for _ in range(19)] for _ in range(2)]\n    dp[0][0][0] = 1\n\n    for i in range(1, 19):\n        for j in range(1, 11):\n            for digit in range(10):\n                if digit == 0 and i == 1:\n                    continue\n                dp[0][i][j] += dp[0][i - 1][j - (digit > 0)] * digit * (10 ** (i - 1))\n                dp[1][i][j] += dp[1][i - 1][j - (digit > 0)] + dp[0][i - 1][j - (digit > 0)] * (10 ** (i - 1))\n\n    res = 0\n    for i in range(1, 19):\n        for j in range(1, k + 1):\n            res += dp[1][i][j] * (10 ** (18 - i)) * (10 ** (j - 1))\n\n    return res % MOD\n\ndef solve(l, r, k):\n    return (sum_of_numbers_with_at_most_k_digits(r, k) - sum_of_numbers_with_at_most_k_digits(l - 1, k) + MOD) % MOD\n\nl, r, k = map(int, input().split())\nprint(solve(l, r, k))"}
{"solution": "import sys\n\ndef main():\n    n, k, d = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] - a[i] <= d:\n            j += 1\n        if j - i >= k:\n            i = j\n        else:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_dead_bulbs(garland):\n    colors = ['R', 'B', 'Y', 'G']\n    dead_bulbs = {color: 0 for color in colors}\n\n    for i in range(len(garland)):\n        if garland[i] == '!':\n            possible_colors = [color for color in colors if color not in garland[i-1:i+3] and color!= garland[(i-4) % len(garland)]]\n            dead_bulbs[possible_colors[0]] += 1\n\n    return dead_bulbs\n\ngarland = input()\ndead_bulbs = count_dead_bulbs(garland)\nprint(dead_bulbs['R'], dead_bulbs['B'], dead_bulbs['Y'], dead_bulbs['G'])"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_list():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n, m = read_ints()\n    graph = defaultdict(list)\n    for _ in range(m):\n        s, t = read_ints()\n        graph[s].append(t)\n\n    e = [0] * (n + 1)\n    e[n] = 0\n    for i in range(n - 1, 0, -1):\n        if len(graph[i]) == 1:\n            e[i] = 1 + e[graph[i][0]]\n        else:\n            e[i] = 1 + sum(e[j] for j in graph[i]) / len(graph[i])\n\n    min_e = float('inf')\n    for i in range(1, n):\n        if len(graph[i]) > 1:\n            new_e = 1 + sum(e[j] for j in graph[1] if j!= i) / (len(graph[1]) - 1)\n            min_e = min(min_e, new_e)\n\n    if len(graph[1]) == 1:\n        min_e = e[1]\n\n    print(min_e)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def round_to_nearest_multiple_of_ten(n):\n    remainder = n % 10\n    if remainder <= 4:\n        return n - remainder\n    else:\n        return n + (10 - remainder)\n\nn = int(input())\nprint(round_to_nearest_multiple_of_ten(n))"}
{"solution": "def find_swaps(s, t):\n    if len(s)!= len(t):\n        print(-1)\n        return\n    \n    mismatches = {}\n    \n    for i in range(len(s)):\n        if s[i]!= t[i]:\n            if s[i] in mismatches and mismatches[s[i]]!= t[i]:\n                print(-1)\n                return\n            if t[i] in mismatches and mismatches[t[i]]!= s[i]:\n                print(-1)\n                return\n            mismatches[s[i]] = t[i]\n            mismatches[t[i]] = s[i]\n    \n    visited = set()\n    swaps = []\n    \n    for key in mismatches:\n        if key not in visited:\n            cycle = []\n            current = key\n            while current not in visited:\n                visited.add(current)\n                cycle.append(current)\n                current = mismatches[current]\n            if len(cycle)!= 2:\n                print(-1)\n                return\n            swaps.append((cycle[0], cycle[1]))\n    \n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0], swap[1])\n\ns = input()\nt = input()\nfind_swaps(s, t)"}
{"solution": "def generate_login(first_name, last_name):\n    \"\"\"\n    Generate the alphabetically earliest possible login from the given first and last names.\n    \n    Parameters:\n    first_name (str): The user's first name.\n    last_name (str): The user's last name.\n    \n    Returns:\n    str: The alphabetically earliest possible login.\n    \"\"\"\n    # Initialize the earliest login with the full first name and the full last name\n    earliest_login = first_name + last_name\n    \n    # Iterate over all possible prefixes of the first name\n    for i in range(1, len(first_name)):\n        # Iterate over all possible prefixes of the last name\n        for j in range(1, len(last_name)):\n            # Generate the current login\n            current_login = first_name[:i] + last_name[:j]\n            # If the current login is alphabetically earlier than the earliest login, update the earliest login\n            if current_login < earliest_login:\n                earliest_login = current_login\n    \n    return earliest_login\n\n# Read the input\nfirst_name, last_name = input().split()\n\n# Generate and print the alphabetically earliest possible login\nprint(generate_login(first_name, last_name))"}
{"solution": "def draw_brackets(n, brackets):\n    stack = []\n    max_height = 0\n    for bracket in brackets:\n        if bracket == '[':\n            stack.append(bracket)\n            max_height = max(max_height, len(stack))\n        else:\n            stack.pop()\n\n    lines = [''] * max_height\n    stack = []\n    for bracket in brackets:\n        if bracket == '[':\n            stack.append(bracket)\n            height = len(stack)\n            lines[height - 1] += '+'\n            for i in range(height - 2, -1, -1):\n                lines[i] += '|'\n        else:\n            height = len(stack)\n            lines[height - 1] += '-'\n            for i in range(height - 2, -1, -1):\n                lines[i] += '|'\n            stack.pop()\n\n    for i in range(max_height):\n        if i == 0:\n            print(lines[i].replace('+', '+-').replace('-', '-+'))\n        else:\n            print(lines[i].replace('|','|'))\n\nn = int(input())\nbrackets = input()\ndraw_brackets(n, brackets)"}
{"solution": "def normalize_golden_number(golden_number):\n    golden_number = list(map(int, golden_number))\n    n = len(golden_number)\n    \n    for i in range(n - 1, 0, -1):\n        if golden_number[i] > 1:\n            golden_number[i] -= 2\n            golden_number[i - 1] += 1\n            if i - 2 >= 0:\n                golden_number[i - 2] += 1\n    \n    while len(golden_number) > 1 and golden_number[0] == 0:\n        golden_number.pop(0)\n    \n    return golden_number\n\ndef compare_golden_numbers(num1, num2):\n    norm_num1 = normalize_golden_number(num1)\n    norm_num2 = normalize_golden_number(num2)\n    \n    if len(norm_num1) > len(norm_num2):\n        return \">\"\n    elif len(norm_num1) < len(norm_num2):\n        return \"<\"\n    \n    for digit1, digit2 in zip(norm_num1, norm_num2):\n        if digit1 > digit2:\n            return \">\"\n        elif digit1 < digit2:\n            return \"<\"\n    \n    return \"=\"\n\nnum1 = input().strip()\nnum2 = input().strip()\n\nresult = compare_golden_numbers(num1, num2)\nprint(result)"}
{"solution": "def find_absent_gems():\n    gems = {\n        \"purple\": \"Power\",\n        \"green\": \"Time\",\n        \"blue\": \"Space\",\n        \"orange\": \"Soul\",\n        \"red\": \"Reality\",\n        \"yellow\": \"Mind\"\n    }\n\n    n = int(input())\n    present_gems = [input() for _ in range(n)]\n\n    absent_gems = [gems[color] for color in gems if color not in present_gems]\n\n    print(len(absent_gems))\n    for gem in absent_gems:\n        print(gem)\n\nfind_absent_gems()"}
{"solution": "def find_meeting_round(n, a, b):\n    \"\"\"\n    Determine the round in which two teams can meet in a play-off system.\n\n    Args:\n    n (int): The total number of teams.\n    a (int): The id of the first team.\n    b (int): The id of the second team.\n\n    Returns:\n    str or int: The round in which the teams can meet, or \"Final!\" if they can meet in the final.\n    \"\"\"\n    # Initialize the round number\n    round_num = 1\n\n    # Continue until only two teams are left\n    while n > 2:\n        # Calculate the number of teams that advance to the next round\n        n = n // 2\n\n        # Check if the teams can meet in the current round\n        if (a - 1) // n == (b - 1) // n:\n            # If they can meet, return the current round number\n            return round_num\n\n        # If they cannot meet, increment the round number and continue\n        round_num += 1\n\n    # If the teams can meet in the final, return \"Final!\"\n    return \"Final!\"\n\n\n# Read the input\nn, a, b = map(int, input().split())\n\n# Find and print the meeting round\nprint(find_meeting_round(n, a, b))"}
{"solution": "def min_changes(n, p, b):\n    # Calculate the number of cycles in the permutation\n    cycles = 0\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            cycles += 1\n            j = i\n            while not visited[j]:\n                visited[j] = True\n                j = p[j] - 1\n\n    # Calculate the number of ones in the sequence\n    ones = sum(b)\n\n    # If the number of cycles is 1, we need to change at least one element in the sequence\n    if cycles == 1:\n        return 1 if ones == 0 or ones == n else 0\n\n    # If the number of cycles is greater than 1, we need to change at least the difference between the number of cycles and 1\n    changes = cycles - 1\n\n    # If the number of ones is odd, we need to change at least one more element in the sequence\n    if ones % 2!= 0:\n        changes += 1\n\n    return changes\n\n\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(min_changes(n, p, b))"}
{"solution": "def calculate_max_distance(v1, v2, t, d):\n    \"\"\"\n    Calculate the maximum possible length of the path section.\n\n    Args:\n    v1 (int): The speed at the beginning of the path in meters per second.\n    v2 (int): The speed at the end of the path in meters per second.\n    t (int): The time taken to pass the path in seconds.\n    d (int): The maximum value of the speed change between adjacent seconds.\n\n    Returns:\n    int: The maximum possible length of the path section in meters.\n    \"\"\"\n    # Calculate the total distance if the speed changes linearly\n    linear_distance = (v1 + v2) * t // 2\n\n    # Calculate the maximum possible distance if the speed changes in a way that maximizes the distance\n    max_distance = 0\n    for i in range(t):\n        # Calculate the maximum possible speed at this time step\n        max_speed = min(v1 + i * d, v2 + (t - i - 1) * d)\n        # Update the maximum possible distance\n        max_distance = max(max_distance, linear_distance + (max_speed - (v1 + v2) // 2) * (t - 1))\n\n    return max_distance\n\n\n# Read the input\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Calculate and print the maximum possible length of the path section\nprint(calculate_max_distance(v1, v2, t, d))"}
{"solution": "import sys\nimport itertools\n\ndef check_order(order, weights, bridge):\n    total_weight = sum(weights)\n    max_weight = max(weights)\n    min_weight = min(weights)\n    min_distance = sys.maxsize\n\n    for i in range(len(bridge)):\n        length, capacity = bridge[i]\n        if capacity < max_weight:\n            return sys.maxsize\n\n        if capacity < total_weight - min_weight:\n            continue\n\n        if capacity >= total_weight - max_weight:\n            min_distance = min(min_distance, length)\n            continue\n\n        for j in range(len(order)):\n            if weights[order[j]] > capacity:\n                break\n\n            current_weight = 0\n            current_distance = 0\n            for k in range(j, len(order)):\n                current_weight += weights[order[k]]\n                if current_weight > capacity:\n                    break\n                current_distance += length\n                if current_distance > min_distance:\n                    break\n                if k == len(order) - 1:\n                    min_distance = min(min_distance, current_distance)\n\n    return min_distance\n\ndef main():\n    N, M = map(int, input().split())\n    weights = list(map(int, input().split()))\n    bridge = []\n    for _ in range(M):\n        length, capacity = map(int, input().split())\n        bridge.append((length, capacity))\n\n    min_distance = sys.maxsize\n    for order in itertools.permutations(range(N)):\n        min_distance = min(min_distance, check_order(order, weights, bridge))\n\n    if min_distance == sys.maxsize:\n        print(-1)\n    else:\n        print(min_distance)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def last_digit_factorial(n):\n    \"\"\"Calculate the last digit of n!\"\"\"\n    if n < 5:\n        return 1\n    else:\n        return 0\n\ndef last_digit(a, b):\n    \"\"\"Calculate the last digit of b!/a!\"\"\"\n    last_a = last_digit_factorial(a)\n    last_b = last_digit_factorial(b)\n    \n    if last_a == 0 and last_b == 0:\n        return 0\n    elif last_a == 0 and last_b!= 0:\n        return last_b\n    elif last_a!= 0 and last_b == 0:\n        return 1\n    else:\n        return 1\n\na, b = map(int, input().split())\nprint(last_digit(a, b))"}
{"solution": "from collections import deque\n\ndef min_jumps(n, d, s):\n    queue = deque([(1, 0)])\n    visited = set([1])\n\n    while queue:\n        pos, jumps = queue.popleft()\n\n        if pos == n:\n            return jumps\n\n        for jump in range(1, min(d + 1, n - pos + 1)):\n            new_pos = pos + jump\n\n            if s[new_pos - 1] == '1' and new_pos not in visited:\n                queue.append((new_pos, jumps + 1))\n                visited.add(new_pos)\n\n    return -1\n\nn, d = map(int, input().split())\ns = input()\n\nprint(min_jumps(n, d, s))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_counterexample(n):\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\nn = int(input().strip())\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all_coins(n):\n    \"\"\"\n    Checks if it's possible to spend all initial game-coins buying only houses, cars and computers.\n\n    Args:\n    n (int): Kolya's initial game-coin score.\n\n    Returns:\n    bool: True if it's possible to spend all coins, False otherwise.\n    \"\"\"\n    house_cost = 1234567\n    car_cost = 123456\n    computer_cost = 1234\n\n    for a in range(n // house_cost + 1):\n        remaining_coins = n - a * house_cost\n        if remaining_coins < 0:\n            break\n        for b in range(remaining_coins // car_cost + 1):\n            remaining_coins_after_cars = remaining_coins - b * car_cost\n            if remaining_coins_after_cars < 0:\n                break\n            if remaining_coins_after_cars % computer_cost == 0:\n                return True\n\n    return False\n\n\nn = int(input())\nprint(\"YES\" if can_spend_all_coins(n) else \"NO\")"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n = int(read_input())\n    x1, x2 = read_ints()\n    lines = []\n    for _ in range(n):\n        k, b = read_ints()\n        lines.append((k, b))\n\n    lines.sort(key=lambda x: x[0])\n\n    for i in range(n - 1):\n        k1, b1 = lines[i]\n        k2, b2 = lines[i + 1]\n        if k1 == k2:\n            continue\n        x = (b2 - b1) / (k1 - k2)\n        if x1 < x < x2:\n            print(\"YES\")\n            return\n\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef count_weights(n):\n    weights = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            weights.add(i)\n            weights.add(n // i)\n    return len(weights)\n\nn = int(input())\nprint(count_weights(n))"}
{"solution": "n, k = map(int, input().split())\n\nif k == 0:\n    min_good = 0\n    max_good = 0\nelse:\n    min_good = 1\n    max_good = min(n - k, 2 * k - (k == 1))\n\nprint(min_good, max_good)"}
{"solution": "import math\n\ndef max_games(n):\n    \"\"\"\n    Calculate the maximum number of games the winner of a knockout tournament can play.\n    \n    Parameters:\n    n (int): The number of players in the tournament.\n    \n    Returns:\n    int: The maximum number of games the winner can play.\n    \"\"\"\n    # Initialize the Fibonacci sequence\n    a, b = 1, 1\n    \n    # Continue generating Fibonacci numbers until we exceed the number of players\n    while b < n:\n        a, b = b, a + b\n    \n    # The maximum number of games is the index of the Fibonacci number that exceeds the number of players\n    return math.floor(math.log(n, 2))\n\n# Read the number of players from the input\nn = int(input())\n\n# Calculate and print the maximum number of games\nprint(max_games(n))"}
{"solution": "def max_vk(s):\n    vk_count = s.count(\"VK\")\n    v_count = s.count(\"V\")\n    k_count = s.count(\"K\")\n\n    # Check if changing a 'V' to a 'K' or a 'K' to a 'V' would increase the count\n    vk_count = max(vk_count, v_count - 1, k_count - 1)\n\n    # Check if changing a 'VV' to a 'VK' or a 'KK' to a 'VK' would increase the count\n    vk_count = max(vk_count, s.count(\"VV\"), s.count(\"KK\"))\n\n    return vk_count\n\ns = input()\nprint(max_vk(s))"}
{"solution": "import math\n\ndef min_segments(n):\n    a = int(math.sqrt(n))\n    while a * a < n:\n        a += 1\n    b = (n + a - 1) // a\n    return a + b + 2\n\nn = int(input().strip())\nprint(min_segments(n))"}
{"solution": "def years_until_larger(a, b):\n    years = 0\n    while a <= b:\n        a *= 3\n        b *= 2\n        years += 1\n    return years\n\na, b = map(int, input().split())\nprint(years_until_larger(a, b))"}
{"solution": "def calculate_nodes_to_visit(h, n):\n    # Calculate the total number of nodes in the tree\n    total_nodes = 2 ** (h + 1) - 1\n\n    # Calculate the number of nodes to visit before reaching the exit\n    nodes_to_visit = total_nodes - 1\n\n    # Calculate the number of nodes to visit in the left subtree of the exit node\n    left_subtree_nodes = 2 ** (h - 1) - 1\n\n    # If the exit node is in the right half of the tree, subtract the nodes in the left subtree\n    if n > 2 ** (h - 1):\n        nodes_to_visit -= left_subtree_nodes\n\n    # If the exit node is not in the first half of the right half of the tree, subtract the nodes in the left subtree of the right half\n    if n > 2 ** (h - 1) + 2 ** (h - 2):\n        nodes_to_visit -= 2 ** (h - 2) - 1\n\n    # Continue this pattern until we reach the exit node\n    for i in range(h - 3, -1, -1):\n        if n > 2 ** (h - 1) + sum(2 ** j for j in range(h - 2, i, -1)):\n            nodes_to_visit -= 2 ** i - 1\n\n    return nodes_to_visit\n\n\nh, n = map(int, input().split())\nprint(calculate_nodes_to_visit(h, n))"}
{"solution": "import math\n\ndef find_tables(x):\n    tables = []\n    for n in range(1, int(math.sqrt(x)) + 1):\n        for m in range(n, x // n + 1):\n            total_squares = sum(min(n, m - i) for i in range(n))\n            if total_squares == x:\n                tables.append((n, m))\n                if n!= m:\n                    tables.append((m, n))\n    return tables\n\nx = int(input())\ntables = find_tables(x)\nprint(len(tables))\nfor table in sorted(tables):\n    print(*table)"}
{"solution": "def is_leap_year(year):\n    \"\"\"Check if a year is a leap year.\"\"\"\n    return year % 4 == 0 and (year % 100!= 0 or year % 400 == 0)\n\n\ndef get_month_days(year, month):\n    \"\"\"Get the number of days in a month.\"\"\"\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return 31\n    elif month == 2:\n        return 29 if is_leap_year(year) else 28\n    else:\n        return 30\n\n\ndef check_sequence(sequence):\n    \"\"\"Check if a sequence of days can be consecutive months.\"\"\"\n    for year in range(2000, 2100):  # arbitrary range, can be adjusted\n        for month in range(1, 13):\n            if get_month_days(year, month) == sequence[0]:\n                match = True\n                for i in range(1, len(sequence)):\n                    next_month = (month + i) % 12 + 1\n                    next_year = year + (month + i) // 12\n                    if get_month_days(next_year, next_month)!= sequence[i]:\n                        match = False\n                        break\n                if match:\n                    return True\n    return False\n\n\ndef main():\n    n = int(input())\n    sequence = list(map(int, input().split()))\n    if check_sequence(sequence):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_sequence(n):\n    if n == 2:\n        return None\n\n    sequence = []\n    remaining = 1 - 1 / n\n\n    for i in range(2, n):\n        if n % i == 0:\n            a = 1\n            b = i\n            if a / b <= remaining:\n                sequence.append((a, b))\n                remaining -= a / b\n\n    if remaining > 0:\n        a = int(remaining * n)\n        b = n\n        sequence.append((a, b))\n\n    return sequence\n\n\ndef main():\n    n = int(input())\n    sequence = find_sequence(n)\n\n    if sequence is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(len(sequence))\n        for a, b in sequence:\n            print(a, b)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n = read_int()\n    a, b = read_ints()\n    h = read_ints()\n\n    total_height = sum(h)\n    if a < 0 or b < 0 or a + b < total_height:\n        return -1\n\n    dp = [[[float('inf')] * (b + 1) for _ in range(a + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(a + 1):\n            for k in range(b + 1):\n                if j >= h[i - 1]:\n                    dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - h[i - 1]][k])\n                if k >= h[i - 1]:\n                    dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - h[i - 1]] + (dp[i - 1][j][k - h[i - 1]]!= float('inf') and j > 0))\n\n    min_unattractiveness = float('inf')\n    for j in range(a + 1):\n        for k in range(b + 1):\n            if j + k == total_height:\n                min_unattractiveness = min(min_unattractiveness, dp[n][j][k])\n\n    return min_unattractiveness if min_unattractiveness!= float('inf') else -1\n\nprint(solve())"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn, m, k = map(int, input().split())\n\nif n * m % k!= 0:\n    print(\"NO\")\nelse:\n    area = n * m // k\n    if area % 2 == 0:\n        print(\"YES\")\n        print(\"0 0\")\n        print(\"0\", n)\n        print(m // 2, m // 2)\n    else:\n        g = gcd(n, m)\n        if area % g == 0:\n            print(\"YES\")\n            print(\"0 0\")\n            print(\"0\", n)\n            print(m // g, (m // g) + (m % g))\n        else:\n            print(\"NO\")"}
{"solution": "def sasha_game(n, k):\n    if n % (2 * k) == 0 or n < k:\n        return \"NO\"\n    else:\n        return \"YES\"\n\nn, k = map(int, input().split())\nprint(sasha_game(n, k))"}
{"solution": "n = int(input())\nexercises = list(map(int, input().split()))\n\nmuscle_groups = [\"chest\", \"biceps\", \"back\"]\nmuscle_repetitions = [0, 0, 0]\n\nfor i, repetition in enumerate(exercises):\n    muscle_repetitions[i % 3] += repetition\n\nmax_repetition = max(muscle_repetitions)\nmax_index = muscle_repetitions.index(max_repetition)\n\nprint(muscle_groups[max_index])"}
{"solution": "def min_redos_to_get_five():\n    n = int(input())\n    grades = list(map(int, input().split()))\n    current_sum = sum(grades)\n    target_sum = n * 4.5\n    \n    if current_sum >= target_sum:\n        return 0\n    \n    grades.sort()\n    redos = 0\n    \n    for grade in grades:\n        if current_sum >= target_sum:\n            break\n        current_sum += (5 - grade)\n        redos += 1\n    \n    return redos\n\nprint(min_redos_to_get_five())"}
{"solution": "def solve(u, v):\n    if u > v:\n        return None\n    if u % 2!= v % 2:\n        return None\n    if u == 0 and v == 0:\n        return []\n    if u == v:\n        return [u]\n    if u == 0:\n        if v % 2 == 0:\n            return [v // 2, v // 2]\n        else:\n            return [1, v - 1, 1]\n    if v % 2 == 0:\n        return [u ^ (v - u) // 2, (v - u) // 2]\n    return [1, u ^ (v - 1) // 2, (v - 1) // 2]\n\nu, v = map(int, input().split())\nresult = solve(u, v)\nif result is None:\n    print(-1)\nelse:\n    print(len(result))\n    print(*result)"}
{"solution": "def min_ones(n):\n    \"\"\"Return the minimum number of digits '1' required to represent n as a sum of addends containing only '1'.\"\"\"\n    result = 0\n    i = 1\n    while n > 0:\n        if n >= i:\n            n -= i\n            result += len(str(i))\n        i *= 10\n    return result\n\nn = int(input())\nprint(min_ones(n))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\ndx = abs(x2 - x1)\ndy = abs(y2 - y1)\n\nif dx == 0 and dy % y == 0:\n    print(\"YES\")\nelif dy == 0 and dx % x == 0:\n    print(\"YES\")\nelif dx == 0 or dy == 0 or gcd(dx, x) == gcd(dy, y):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "from itertools import permutations\nfrom collections import Counter\n\ndef count_valid_bus_numbers(n):\n    # Convert the number to a string to extract digits\n    digits = list(str(n))\n    \n    # Count the frequency of each digit\n    digit_counts = Counter(digits)\n    \n    # Initialize the count of valid permutations\n    valid_permutations = 0\n    \n    # Generate all unique permutations of the digits\n    for perm in permutations(digits):\n        # Check if the permutation starts with '0'\n        if perm[0]!= '0':\n            # Count the frequency of each digit in the permutation\n            perm_counts = Counter(perm)\n            \n            # Check if the permutation is a sub-permutation of the original digits\n            if all(perm_counts[digit] <= digit_counts[digit] for digit in perm_counts):\n                valid_permutations += 1\n    \n    # Return the count of valid permutations\n    return valid_permutations\n\n# Read input\nn = int(input().strip())\n\n# Get the count of valid bus numbers\nresult = count_valid_bus_numbers(n)\n\n# Print the result\nprint(result)"}
{"solution": "def calculate_max_cost():\n    a = int(input())\n    b = int(input())\n    c = int(input())\n    d = int(input())\n    e = int(input())\n    f = int(input())\n\n    # Calculate the maximum number of suits of the first type\n    max_suits_first_type = min(a, d)\n\n    # Calculate the maximum number of suits of the second type\n    max_suits_second_type = min(b, c, d)\n\n    # Initialize the maximum cost\n    max_cost = 0\n\n    # Iterate over all possible combinations of suits\n    for suits_first_type in range(max_suits_first_type + 1):\n        remaining_jackets = d - suits_first_type\n        suits_second_type = min(remaining_jackets, b, c)\n        cost = suits_first_type * e + suits_second_type * f\n        max_cost = max(max_cost, cost)\n\n    print(max_cost)\n\ncalculate_max_cost()"}
{"solution": ""}
{"solution": "def calculate_max_sum(k_2, k_3, k_5, k_6):\n    max_256 = min(k_2, k_5, k_6)\n    remaining_2 = max(0, k_2 - max_256)\n    max_32 = min(remaining_2, k_3)\n    return max_256 * 256 + max_32 * 32\n\nk_2, k_3, k_5, k_6 = map(int, input().split())\nprint(calculate_max_sum(k_2, k_3, k_5, k_6))"}
{"solution": "import math\n\nn, x, y, c = map(int, input().split())\n\nif c == 1:\n    print(0)\nelse:\n    if n == 1:\n        print(-1)\n    else:\n        if c > n * n:\n            print(-1)\n        else:\n            if x == 1 or x == n or y == 1 or y == n:\n                if c <= (n * n) // 2 + (n * n) % 2:\n                    print(math.ceil((math.sqrt(c) - 1) / 2))\n                else:\n                    print(-1)\n            else:\n                if c <= (n * n) // 2:\n                    print(math.ceil((math.sqrt(c) - 1) / 2))\n                else:\n                    print(math.ceil((math.sqrt(c) - 1) / 2) + 1)"}
{"solution": "def max_xor(l, r):\n    if l == r:\n        return 0\n\n    max_val = 0\n    bit = 1\n    while bit <= r:\n        if l >= bit:\n            max_val |= bit\n        bit <<= 1\n\n    return max_val\n\nl, r = map(int, input().split())\nprint(max_xor(l, r))"}
{"solution": "def minimum_height():\n    n, k = map(int, input().split())\n    left, right = 1, k\n    \n    while left < right:\n        mid = (left + right) // 2\n        if n * mid >= k:\n            right = mid\n        else:\n            left = mid + 1\n    \n    print(left)\n\nminimum_height()"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    stairs_time = abs(x - y) * t1\n    \n    elevator_to_masha_time = abs(z - x) * t2 + t3\n    elevator_to_egor_time = abs(x - y) * t2 + 2 * t3\n    elevator_time = elevator_to_masha_time + elevator_to_egor_time\n    \n    if stairs_time < elevator_time:\n        return \"NO\"\n    else:\n        return \"YES\"\n\nx, y, z, t1, t2, t3 = map(int, input().split())\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "def find_optimal_a(n, m):\n    \"\"\"\n    Find the optimal value of a that maximizes the probability of Andrew's victory.\n\n    Args:\n    n (int): The range of numbers in the game.\n    m (int): The number selected by Misha.\n\n    Returns:\n    int: The optimal value of a.\n    \"\"\"\n    # If m is at one of the extremes, a should be at the other extreme\n    if m == 1:\n        return n\n    elif m == n:\n        return 1\n\n    # If m is closer to one end, a should be closer to the other end\n    if m < (n + 1) // 2:\n        return m + 1\n    else:\n        return m - 1\n\n# Read input\nn, m = map(int, input().split())\n\n# Find and print the optimal value of a\nprint(find_optimal_a(n, m))"}
{"solution": "def count_pairs(n, schedule):\n    \"\"\"\n    Calculate the number of pairs Alena will stay at the university.\n\n    Args:\n    n (int): The number of lessons at the university.\n    schedule (list): A list of integers representing Alena's schedule.\n\n    Returns:\n    int: The number of pairs Alena will stay at the university.\n    \"\"\"\n    pairs = 0\n    i = 0\n    while i < n:\n        # If the current pair is not empty, increment the pairs count\n        if schedule[i] == 1:\n            pairs += 1\n            # If the current pair is not the last one, check the next pair\n            if i < n - 1:\n                # If the next pair is empty, check the pair after that\n                if schedule[i + 1] == 0:\n                    # If the pair after that is not empty, increment the pairs count\n                    if i < n - 2 and schedule[i + 2] == 1:\n                        pairs += 1\n        # Move to the next pair\n        i += 1\n    return pairs\n\n\nn = int(input())\nschedule = list(map(int, input().split()))\nprint(count_pairs(n, schedule))"}
{"solution": "def min_days_to_give_candies(n, k, candies):\n    total_candies = 0\n    days = 0\n    for candy in candies:\n        total_candies += candy\n        days += 1\n        if total_candies >= k:\n            return days\n        total_candies -= min(candy, 8)\n    return -1 if total_candies < k else days\n\n\nn, k = map(int, input().split())\ncandies = list(map(int, input().split()))\nprint(min_days_to_give_candies(n, k, candies))"}
{"solution": "def minimum_additional_walks(n, k, a):\n    b = a[:]\n    additional_walks = 0\n    \n    # Consider the day before the first day\n    if b[0] < k:\n        needed_walks = k - b[0]\n        b[0] += needed_walks\n        additional_walks += needed_walks\n    \n    for i in range(n - 1):\n        if b[i] + b[i + 1] < k:\n            needed_walks = k - (b[i] + b[i + 1])\n            b[i + 1] += needed_walks\n            additional_walks += needed_walks\n    \n    # Consider the day after the n-th day\n    if b[-1] < k:\n        needed_walks = k - b[-1]\n        b[-1] += needed_walks\n        additional_walks += needed_walks\n    \n    return additional_walks, b\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nadditional_walks, b = minimum_additional_walks(n, k, a)\n\n# Print the result\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "def calculate_rhombus_cells(n):\n    return 2 * n**2 - 2 * n + 1\n\nn = int(input())\nprint(calculate_rhombus_cells(n))"}
{"solution": "def is_pangram(n, s):\n    alphabet = set(\"abcdefghijklmnopqrstuvwxyz\")\n    return \"YES\" if set(s.lower()).issuperset(alphabet) else \"NO\"\n\nn = int(input())\ns = input()\nprint(is_pangram(n, s))"}
{"solution": "def calculate_time(time_str, minutes):\n    hours, mins = map(int, time_str.split(':'))\n    total_mins = hours * 60 + mins + minutes\n    new_hours = (total_mins // 60) % 24\n    new_mins = total_mins % 60\n    return f\"{new_hours:02d}:{new_mins:02d}\"\n\ntime_str = input()\nminutes = int(input())\nprint(calculate_time(time_str, minutes))"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    a = [input() for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            a[i] = a[i][:j] + '0' + a[i][j+1:]\n        if all(any(a[k][j] == '1' for k in range(n)) for j in range(m)):\n            print(\"YES\")\n            return\n        for j in range(m):\n            a[i] = a[i][:j] + '1' + a[i][j+1:]\n    print(\"NO\")\n\nsolve()"}
{"solution": "def min_time_to_rotate(n, dominoes):\n    \"\"\"\n    Calculate the minimum time required to rotate dominoes to make the sum of the numbers on the upper halves and the sum of the numbers on the lower halves even.\n\n    Args:\n        n (int): The number of dominoes.\n        dominoes (list): A list of tuples, where each tuple contains two integers representing the numbers on the upper and lower halves of a domino.\n\n    Returns:\n        int: The minimum time required to rotate dominoes. If it's impossible to make the sums even, return -1.\n    \"\"\"\n    upper_sum = sum(x for x, y in dominoes)\n    lower_sum = sum(y for x, y in dominoes)\n\n    if upper_sum % 2 == 0 and lower_sum % 2 == 0:\n        return 0\n    elif upper_sum % 2!= 0 and lower_sum % 2!= 0:\n        odd_count = sum((x + y) % 2 for x, y in dominoes)\n        return odd_count // 2 if odd_count % 2 == 0 else -1\n    else:\n        return -1\n\n\nn = int(input())\ndominoes = [tuple(map(int, input().split())) for _ in range(n)]\nprint(min_time_to_rotate(n, dominoes))"}
{"solution": "import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = math.isqrt(n)\n    for i in range(3, sqrt_n + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef solve():\n    a, b = map(int, input().split())\n    area = (a - b) * (a + b)\n    if is_prime(area):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nt = int(input())\nfor _ in range(t):\n    solve()"}
{"solution": "def can_remove_one_point(n, points):\n    positive_count = 0\n    negative_count = 0\n    \n    for x, y in points:\n        if x > 0:\n            positive_count += 1\n        else:\n            negative_count += 1\n    \n    if positive_count <= 1 or negative_count <= 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\nprint(can_remove_one_point(n, points))"}
{"solution": "import math\n\ndef calculate_gcd_of_factorials():\n    a, b = map(int, input().split())\n    min_val = min(a, b)\n    return math.factorial(min_val)\n\nprint(calculate_gcd_of_factorials())"}
{"solution": "def find_composite_numbers(n):\n    if n % 2 == 0:\n        return n + 4, 4\n    else:\n        return n + 9, 9\n\nn = int(input())\na, b = find_composite_numbers(n)\nprint(a, b)"}
{"solution": "import sys\nimport heapq\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_list():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n, m, p = read_ints()\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, c = read_ints()\n        a -= 1\n        b -= 1\n        graph[a].append((b, c))\n\n    dist = [float('inf')] * n\n    dist[0] = 0\n    pq = [(0, 0)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, c in graph[u]:\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                heapq.heappush(pq, (dist[v], v))\n\n    if dist[-1] == float('inf'):\n        print(-1)\n        return\n\n    dp = [0] * n\n    for u in range(n):\n        for v, c in graph[u]:\n            dp[v] = max(dp[v], dp[u] + c)\n\n    ans = 0\n    for i in range(1, dist[-1] + 1):\n        coins = dp[-1] * i - p * i\n        if coins > ans:\n            ans = coins\n\n    print(ans)\n\nif __name__ == '__main__':\n    solve()"}
{"solution": ""}
{"solution": "def largest_xor_sum(n, k):\n    # Find the number of bits in n\n    num_bits = n.bit_length()\n    # The largest possible xor-sum\n    max_xor_sum = (1 << num_bits) - 1\n    return max_xor_sum\n\nn, k = map(int, input().split())\nprint(largest_xor_sum(n, k))"}
{"solution": "import sys\n\ndef solve():\n    n = int(input())\n    x = []\n    y = []\n    for _ in range(n):\n        xi, yi = map(int, input().split())\n        x.append(xi)\n        y.append(yi)\n\n    x.sort()\n    y.sort()\n\n    def check(mid):\n        for i in range(n):\n            if x[i] > mid or y[i] > mid:\n                return False\n        return True\n\n    def check2(mid):\n        for i in range(n):\n            if x[i] > mid and y[i] > mid:\n                return False\n        return True\n\n    l, r = 0, 10**9 + 1\n    while l < r:\n        mid = (l + r) // 2\n        if check(mid):\n            r = mid\n        else:\n            l = mid + 1\n\n    ans = l\n\n    l, r = 0, 10**9 + 1\n    while l < r:\n        mid = (l + r) // 2\n        if check2(mid):\n            r = mid\n        else:\n            l = mid + 1\n\n    ans = min(ans, l)\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def max_nineteens(s):\n    from collections import Counter\n    \n    char_count = Counter(s)\n    required_counts = {'n': 3, 'i': 1, 'e': 3, 't': 1}\n    \n    max_nineteens = float('inf')\n    for char, required in required_counts.items():\n        if char in char_count:\n            max_nineteens = min(max_nineteens, char_count[char] // required)\n        else:\n            return 0\n    \n    return max_nineteens\n\ns = input()\nprint(max_nineteens(s))"}
{"solution": "def highest_unreachable_branch(p, y):\n    \"\"\"\n    Find the highest branch that cannot be reached by any of the grasshoppers.\n\n    Args:\n    p (int): The highest branch occupied by a grasshopper.\n    y (int): The total number of branches.\n\n    Returns:\n    int: The highest branch that cannot be reached by any grasshopper, or -1 if no such branch exists.\n    \"\"\"\n    # Initialize the highest unreachable branch to -1\n    highest_branch = -1\n\n    # Iterate over all branches from y down to 2\n    for branch in range(y, 1, -1):\n        # Assume the current branch is unreachable\n        is_unreachable = True\n\n        # Check if the current branch can be reached by any grasshopper\n        for grasshopper in range(2, p + 1):\n            # If the current branch is a multiple of the grasshopper's branch, it can be reached\n            if branch % grasshopper == 0:\n                is_unreachable = False\n                break\n\n        # If the current branch is unreachable, update the highest unreachable branch\n        if is_unreachable:\n            highest_branch = branch\n            break\n\n    return highest_branch\n\n\n# Read the input\np, y = map(int, input().split())\n\n# Find and print the highest unreachable branch\nprint(highest_unreachable_branch(p, y))"}
{"solution": "def min_distance(n, m, k, houses):\n    \"\"\"\n    Calculate the minimum distance from the girl's house to a house Zane can afford.\n\n    Args:\n    n (int): The number of houses in the village.\n    m (int): The house where the girl lives.\n    k (int): The amount of money Zane has.\n    houses (list): A list of integers representing the availability and prices of the houses.\n\n    Returns:\n    int: The minimum distance from the girl's house to a house Zane can afford.\n    \"\"\"\n    # Initialize the minimum distance to infinity\n    min_dist = float('inf')\n\n    # Iterate over the houses\n    for i in range(n):\n        # Check if the house is available and Zane can afford it\n        if houses[i]!= 0 and houses[i] <= k:\n            # Calculate the distance from the girl's house to the current house\n            dist = abs(m - 1 - i) * 10\n            # Update the minimum distance if the current distance is smaller\n            min_dist = min(min_dist, dist)\n\n    # Return the minimum distance\n    return min_dist\n\n\n# Read the input\nn, m, k = map(int, input().split())\nhouses = list(map(int, input().split()))\n\n# Calculate and print the minimum distance\nprint(min_distance(n, m, k, houses))"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    b = [list(map(int, input().split())) for _ in range(n)]\n\n    if sorted([num for row in a for num in row])!= sorted([num for row in b for num in row]):\n        print(\"NO\")\n        return\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j]!= b[i][j]:\n                if i == 0 or j == 0 or a[i-1][j] == b[i-1][j] or a[i][j-1] == b[i][j-1]:\n                    print(\"NO\")\n                    return\n\n    print(\"YES\")\n\nsolve()"}
{"solution": "def longest_uncommon_subsequence(a, b):\n    if a == b:\n        return -1\n    else:\n        return max(len(a), len(b))\n\na = input()\nb = input()\n\nprint(longest_uncommon_subsequence(a, b))"}
{"solution": "def find_intersection(a, b, c, d):\n    \"\"\"\n    Find the first time Rick and Morty will scream at the same time.\n\n    Args:\n    a (int): The interval at which Rick screams.\n    b (int): The initial time at which Rick screams.\n    c (int): The interval at which Morty screams.\n    d (int): The initial time at which Morty screams.\n\n    Returns:\n    int: The first time Rick and Morty will scream at the same time, or -1 if they will never scream at the same time.\n    \"\"\"\n    # Calculate the least common multiple (LCM) of a and c\n    lcm = (a * c) // gcd(a, c)\n\n    # Initialize the time at which Rick screams\n    rick_time = b\n\n    # Initialize the time at which Morty screams\n    morty_time = d\n\n    # Loop until we find a common time or we exceed the maximum possible time\n    while rick_time <= 10000 and morty_time <= 10000:\n        # Check if Rick and Morty scream at the same time\n        if rick_time == morty_time:\n            return rick_time\n\n        # Update the time at which Rick screams\n        if rick_time < morty_time:\n            rick_time += lcm\n        else:\n            morty_time += lcm\n\n    # If we exit the loop without finding a common time, return -1\n    return -1\n\n\ndef gcd(a, b):\n    \"\"\"\n    Calculate the greatest common divisor (GCD) of two numbers.\n\n    Args:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: The GCD of a and b.\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\n\n# Read the input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Find and print the first time Rick and Morty will scream at the same time\nprint(find_intersection(a, b, c, d))"}
{"solution": "def split_number(n):\n    if n % 3 == 0:\n        return [1, (n - 1) // 3, (n - 1) // 3 + 1]\n    elif n % 3 == 1:\n        return [(n - 1) // 3, (n - 1) // 3, (n - 1) // 3 + 1]\n    else:\n        return [(n - 2) // 3 + 1, (n - 2) // 3 + 1, (n - 2) // 3]\n\nn = int(input())\nprint(*split_number(n))"}
{"solution": "def calculate_squares(n, a, b, c, d):\n    \"\"\"\n    Calculate the number of distinct squares that satisfy all the conditions.\n\n    Args:\n    n (int): Maximum possible value of an integer in the cell.\n    a (int): Value of the top right cell.\n    b (int): Value of the middle left cell.\n    c (int): Value of the middle right cell.\n    d (int): Value of the bottom middle cell.\n\n    Returns:\n    int: Number of distinct squares that satisfy all the conditions.\n    \"\"\"\n    # Calculate the sum of the top left 2x2 square\n    sum_2x2 = a + b + c + d\n\n    # Initialize the count of distinct squares\n    count = 0\n\n    # Iterate over all possible values for the top left cell\n    for x in range(1, n + 1):\n        # Calculate the value of the top middle cell\n        y = sum_2x2 - x - a - b\n\n        # Check if the value of the top middle cell is valid\n        if 1 <= y <= n:\n            # Calculate the value of the middle left cell\n            z = sum_2x2 - x - y - c\n\n            # Check if the value of the middle left cell is valid\n            if 1 <= z <= n:\n                # Calculate the value of the bottom left cell\n                w = sum_2x2 - z - b - d\n\n                # Check if the value of the bottom left cell is valid\n                if 1 <= w <= n:\n                    # Increment the count of distinct squares\n                    count += 1\n\n    return count\n\n\n# Read the input values\nn, a, b, c, d = map(int, input().split())\n\n# Calculate and print the number of distinct squares\nprint(calculate_squares(n, a, b, c, d))"}
{"solution": "def calculate_snowball_weight():\n    # Read initial snowball weight and height\n    w, h = map(int, input().split())\n\n    # Read stone weights and heights\n    u1, d1 = map(int, input().split())\n    u2, d2 = map(int, input().split())\n\n    # Initialize current height\n    current_height = h\n\n    # Simulate snowball movement\n    while current_height > 0:\n        # Increase snowball weight by current height\n        w += current_height\n\n        # Check if snowball hits a stone\n        if current_height == d1:\n            w -= u1\n            if w < 0:\n                w = 0\n        elif current_height == d2:\n            w -= u2\n            if w < 0:\n                w = 0\n\n        # Move snowball one meter down\n        current_height -= 1\n\n    return w\n\n# Print final snowball weight\nprint(calculate_snowball_weight())"}
{"solution": "def find_passing_rate(m, scores, x, y):\n    total_students = sum(scores)\n    prefix_sum = [0] * (m + 1)\n    for i in range(m):\n        prefix_sum[i + 1] = prefix_sum[i] + scores[i]\n\n    for k in range(1, m + 1):\n        beginner_group_size = prefix_sum[k]\n        intermediate_group_size = total_students - beginner_group_size\n        if x <= beginner_group_size <= y and x <= intermediate_group_size <= y:\n            return k\n\n    return 0\n\n\nm = int(input())\nscores = list(map(int, input().split()))\nx, y = map(int, input().split())\n\nprint(find_passing_rate(m, scores, x, y))"}
{"solution": "def min_coins(n, k, A, B):\n    \"\"\"\n    Calculate the minimum amount of coins needed to make x equal to 1.\n\n    Args:\n    n (int): The initial value of x.\n    k (int): The divisor for the division operation.\n    A (int): The cost of the subtraction operation.\n    B (int): The cost of the division operation.\n\n    Returns:\n    int: The minimum amount of coins needed.\n    \"\"\"\n    # Initialize the minimum cost to infinity\n    min_cost = float('inf')\n\n    # Calculate the cost for each possible number of divisions\n    for i in range(n + 1):\n        # Calculate the remaining value after i divisions\n        remaining = n - i * (k - 1)\n\n        # If the remaining value is less than 1, break the loop\n        if remaining < 1:\n            break\n\n        # Calculate the cost for the current number of divisions\n        cost = i * B + (remaining - 1) * A\n\n        # Update the minimum cost if the current cost is less\n        min_cost = min(min_cost, cost)\n\n    # Return the minimum cost\n    return min_cost\n\n\n# Read the input values\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\n# Calculate and print the minimum cost\nprint(min_coins(n, k, A, B))"}
{"solution": "import math\n\ndef prime_factors(n):\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef min_value_and_operations(n):\n    factors = prime_factors(n)\n    min_value = 1\n    for factor in set(factors):\n        count = factors.count(factor)\n        if count % 2 == 1:\n            min_value *= factor\n    operations = sum(factors.count(factor) // 2 for factor in set(factors))\n    return min_value, operations\n\nn = int(input())\nmin_value, operations = min_value_and_operations(n)\nprint(min_value, operations)"}
{"solution": "def get_score(N, K, R, S, P, T):\n    scores = {'r': P,'s': R, 'p': S}\n    hands = {'r': 'p','s': 'r', 'p':'s'}\n    last_used = [-1] * N\n    total_score = 0\n\n    for i in range(N):\n        if i < K:\n            total_score += scores[T[i]]\n            last_used[i] = hands[T[i]]\n        else:\n            if last_used[i-K]!= hands[T[i]]:\n                total_score += scores[T[i]]\n                last_used[i] = hands[T[i]]\n            else:\n                for hand in hands.values():\n                    if hand!= last_used[i-K] and (i-K-1 < 0 or hand!= last_used[i-K-1]):\n                        last_used[i] = hand\n                        break\n                if last_used[i] == hands[T[i]]:\n                    total_score += scores[T[i]]\n\n    return total_score\n\n\nN, K = map(int, input().split())\nR, S, P = map(int, input().split())\nT = input()\n\nprint(get_score(N, K, R, S, P, T))"}
{"solution": "def longest_good_string(a, b, c):\n    \"\"\"\n    Calculate the length of the longest good string that can be obtained by concatenating\n    'a', 'b', and 'ab' strings.\n\n    Args:\n    a (int): The number of 'a' strings.\n    b (int): The number of 'b' strings.\n    c (int): The number of 'ab' strings.\n\n    Returns:\n    int: The length of the longest good string.\n    \"\"\"\n    # Calculate the total number of 'ab' pairs that can be formed\n    ab_pairs = min(a, b) + c\n\n    # Calculate the remaining 'a' and 'b' strings\n    remaining_a = a - min(a, b)\n    remaining_b = b - min(a, b)\n\n    # The maximum length of the good string is the sum of the lengths of all 'ab' pairs and the remaining 'a' and 'b' strings\n    max_length = 2 * ab_pairs + remaining_a + remaining_b\n\n    # If there are more 'ab' pairs than remaining 'a' and 'b' strings, we can add 1 to the length for each extra 'ab' pair\n    extra_length = max(0, ab_pairs - remaining_a - remaining_b)\n\n    # Return the maximum length of the good string\n    return max_length + extra_length\n\n\n# Read the input\na, b, c = map(int, input().split())\n\n# Calculate and print the length of the longest good string\nprint(longest_good_string(a, b, c))"}
{"solution": "def calculate_marks(n, k, p, x, y, marks):\n    remaining_tests = n - k\n    total_marks = sum(marks)\n    max_total_marks = x - total_marks\n    min_median_marks = (n + 1) // 2\n    current_median_marks = sorted(marks)[min_median_marks - 1] if k >= min_median_marks else 0\n\n    if total_marks + remaining_tests * p > x:\n        return [-1]\n\n    if current_median_marks < y:\n        marks_needed = y - current_median_marks\n        marks_to_add = [y] * marks_needed\n        remaining_tests -= marks_needed\n        total_marks += marks_needed * y\n        max_total_marks -= marks_needed * y\n\n    else:\n        marks_to_add = []\n\n    if remaining_tests > 0:\n        marks_to_add += [1] * (remaining_tests - 1)\n        marks_to_add.append(max_total_marks - (remaining_tests - 1))\n\n    return marks_to_add\n\n\nn, k, p, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\nresult = calculate_marks(n, k, p, x, y, marks)\nprint(*result)"}
{"solution": "def is_berlanese(word):\n    vowels = 'aeiou'\n    for i in range(len(word) - 1):\n        if word[i] not in vowels and word[i]!= 'n' and word[i + 1] not in vowels:\n            return False\n    if word[-1]!= 'n' and word[-1] not in vowels:\n        return False\n    return True\n\nword = input()\nprint('YES' if is_berlanese(word) else 'NO')"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n, m = read_ints()\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = read_ints()\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def check(x):\n        for i in range(n):\n            if len(graph[i]) % x!= 0:\n                return False\n        return True\n\n    for x in range(6, 0, -1):\n        if check(x):\n            return m // x\n\n    return 0\n\nprint(solve())"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, m = read_ints()\n    prices = list(read_ints())\n    auction_questions = list(read_ints())\n\n    auction_questions = [q - 1 for q in auction_questions]\n    auction_questions.sort(key=lambda q: prices[q], reverse=True)\n\n    points = 0\n    for i in range(n):\n        if i in auction_questions:\n            points += prices[i]\n            prices[i] = points\n        else:\n            points += prices[i]\n\n    print(points)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_score(max_points, submission_time, wrong_submissions):\n    return max(0.3 * max_points, (1 - submission_time / 250) * max_points - 50 * wrong_submissions)\n\ndef main():\n    max_points = [500, 1000, 1500, 2000, 2500]\n    submission_times = list(map(int, input().split()))\n    wrong_submissions = list(map(int, input().split()))\n    successful_hacks, unsuccessful_hacks = map(int, input().split())\n\n    total_score = sum(calculate_score(max_points[i], submission_times[i], wrong_submissions[i]) for i in range(5))\n    total_score += 100 * successful_hacks - 50 * unsuccessful_hacks\n\n    print(int(total_score))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 998244353\n\ndef qpow(a, b):\n    res = 1\n    while b:\n        if b & 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b >>= 1\n    return res\n\ndef C(n, m):\n    if n < m:\n        return 0\n    return fac[n] * inv[m] % MOD * inv[n - m] % MOD\n\nn, m, L, R = map(int, input().split())\nif (n * m) % 2:\n    print(0)\n    exit()\n\nif n % 2 == 0 and m % 2 == 0:\n    k = (n * m) // 2\n    fac = [1] * (k + 1)\n    inv = [1] * (k + 1)\n    for i in range(1, k + 1):\n        fac[i] = fac[i - 1] * i % MOD\n    inv[k] = qpow(fac[k], MOD - 2)\n    for i in range(k - 1, -1, -1):\n        inv[i] = inv[i + 1] * (i + 1) % MOD\n    ans = 0\n    for i in range(L, R + 1, 2):\n        ans = (ans + C(k, i // 2)) % MOD\n    print(ans)\nelse:\n    ans = 0\n    for i in range(L, R + 1):\n        ans = (ans + pow(R - L + 1, (n * m - 1) // 2, MOD)) % MOD\n    print(ans)"}
{"solution": "def is_possible_to_make_increasing(n, m, matrix_a, matrix_b):\n    for i in range(n):\n        for j in range(m):\n            # Ensure that matrix_a[i][j] is the smaller or equal element\n            if matrix_a[i][j] > matrix_b[i][j]:\n                matrix_a[i][j], matrix_b[i][j] = matrix_b[i][j], matrix_a[i][j]\n    \n    # Check rows for strictly increasing property\n    for i in range(n):\n        for j in range(1, m):\n            if matrix_a[i][j] <= matrix_a[i][j-1] or matrix_b[i][j] <= matrix_b[i][j-1]:\n                return \"Impossible\"\n    \n    # Check columns for strictly increasing property\n    for j in range(m):\n        for i in range(1, n):\n            if matrix_a[i][j] <= matrix_a[i-1][j] or matrix_b[i][j] <= matrix_b[i-1][j]:\n                return \"Impossible\"\n    \n    return \"Possible\"\n\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\nmatrix_b = [list(map(int, input().split())) for _ in range(n)]\n\nprint(is_possible_to_make_increasing(n, m, matrix_a, matrix_b))"}
{"solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    a.sort(reverse=True)\n    ans = 0\n    curr = len(a)\n\n    for i in range(n):\n        if curr > a[i]:\n            curr = a[i]\n        ans += curr\n        curr -= 1\n        if curr < 1:\n            break\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import heapq\n\ndef min_problems_to_solve(n, k, difficulties):\n    difficulties.sort()\n    heap = []\n    heapq.heappush(heap, -k)\n\n    for difficulty in difficulties:\n        if -heap[0] < difficulty / 2:\n            heapq.heappush(heap, -difficulty)\n            heapq.heappop(heap)\n            heapq.heappush(heap, -difficulty)\n        else:\n            heapq.heappush(heap, -difficulty)\n\n    return len(heap) - 1\n\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\nprint(min_problems_to_solve(n, k, difficulties))"}
{"solution": "def calculate_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3):\n    \"\"\"\n    Calculate the optimal distribution of diplomas.\n\n    Args:\n    n (int): The total number of participants.\n    min_1 (int): The minimum number of first-degree diplomas.\n    max_1 (int): The maximum number of first-degree diplomas.\n    min_2 (int): The minimum number of second-degree diplomas.\n    max_2 (int): The maximum number of second-degree diplomas.\n    min_3 (int): The minimum number of third-degree diplomas.\n    max_3 (int): The maximum number of third-degree diplomas.\n\n    Returns:\n    tuple: A tuple containing the optimal number of first-degree, second-degree, and third-degree diplomas.\n    \"\"\"\n\n    # Calculate the maximum possible number of first-degree diplomas\n    first_degree = min(max_1, n - min_2 - min_3)\n\n    # Calculate the remaining participants after distributing first-degree diplomas\n    remaining = n - first_degree\n\n    # Calculate the maximum possible number of second-degree diplomas\n    second_degree = min(max_2, remaining - min_3)\n\n    # Calculate the number of third-degree diplomas\n    third_degree = n - first_degree - second_degree\n\n    return first_degree, second_degree, third_degree\n\n\n# Read input\nn = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\n# Calculate and print the optimal distribution of diplomas\nfirst_degree, second_degree, third_degree = calculate_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3)\nprint(first_degree, second_degree, third_degree)"}
{"solution": "def moon_phase(n, observations):\n    moon_cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    current_index = moon_cycle.index(observations[0])\n    next_index = (current_index + n) % len(moon_cycle)\n    next_moon_size = moon_cycle[next_index]\n    current_moon_size = observations[-1]\n    \n    if next_moon_size > current_moon_size:\n        return \"UP\"\n    elif next_moon_size < current_moon_size:\n        return \"DOWN\"\n    else:\n        # Check if the sequence is increasing or decreasing\n        if all(observations[i] < observations[i+1] for i in range(len(observations)-1)):\n            return \"UP\"\n        elif all(observations[i] > observations[i+1] for i in range(len(observations)-1)):\n            return \"DOWN\"\n        else:\n            return \"-1\"\n\nn = int(input())\nobservations = list(map(int, input().split()))\nprint(moon_phase(n, observations))"}
{"solution": "def can_transform(s, t):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    # Check if lengths are the same\n    if len(s)!= len(t):\n        return \"No\"\n    \n    # Check each character\n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels)!= (char_t in vowels):\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(can_transform(s, t))"}
{"solution": "def determine_winner(board):\n    min_white_steps = float('inf')\n    min_black_steps = float('inf')\n\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'W':\n                min_white_steps = min(min_white_steps, 8 - i - 1)\n            elif board[i][j] == 'B':\n                min_black_steps = min(min_black_steps, i)\n\n    return 'A' if min_white_steps <= min_black_steps else 'B'\n\nboard = [input() for _ in range(8)]\nprint(determine_winner(board))"}
{"solution": "def max_equal_length(n, A, m, B):\n    if sum(A)!= sum(B):\n        return -1\n    \n    i, j = 0, 0\n    sumA, sumB = 0, 0\n    count = 0\n    \n    while i < n and j < m:\n        sumA += A[i]\n        sumB += B[j]\n        \n        if sumA == sumB:\n            count += 1\n            sumA = 0\n            sumB = 0\n            i += 1\n            j += 1\n        elif sumA < sumB:\n            i += 1\n        else:\n            j += 1\n    \n    return count\n\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\nprint(max_equal_length(n, A, m, B))"}
{"solution": "def check_contest_problem(problem_name):\n    friends_names = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    count = 0\n\n    for friend_name in friends_names:\n        if problem_name.count(friend_name) == 1:\n            count += 1\n\n    return \"YES\" if count == 1 else \"NO\"\n\n\nproblem_name = input()\nprint(check_contest_problem(problem_name))"}
{"solution": "def sieve(n):\n    is_prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (is_prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n    is_prime[0], is_prime[1] = False, False  # 0 and 1 are not primes\n    return is_prime\n\ndef count_primes_in_range(is_prime, a, b):\n    prime_count = [0] * (b + 1)\n    for i in range(a, b + 1):\n        prime_count[i] = prime_count[i - 1] + (1 if is_prime[i] else 0)\n    return prime_count\n\ndef min_length_with_k_primes(a, b, k):\n    is_prime = sieve(b)\n    prime_count = count_primes_in_range(is_prime, a, b)\n    \n    def has_k_primes_in_length(l):\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] >= k:\n                return True\n        return False\n    \n    left, right = 1, b - a + 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if has_k_primes_in_length(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result\n\na, b, k = map(int, input().split())\nprint(min_length_with_k_primes(a, b, k))"}
{"solution": "import math\n\ndef calculate_x(a, h, w):\n    min_x = float('inf')\n\n    for n in range(1, math.ceil(w / a) + 1):\n        m = math.floor((w - n * a) / (n + 1))\n        if m < 0:\n            continue\n        x = (w - n * a - m) / (n + 1)\n\n        if x >= 0 and h >= a + 2 * x:\n            min_x = min(min_x, x)\n\n    for m in range(1, math.ceil(h / a) + 1):\n        n = math.floor((h - m * a) / (m + 1))\n        if n < 0:\n            continue\n        x = (h - m * a - n) / (m + 1)\n\n        if x >= 0 and w >= a + 2 * x:\n            min_x = min(min_x, x)\n\n    if min_x == float('inf'):\n        return -1\n    else:\n        return min_x\n\na, h, w = map(int, input().split())\nprint(calculate_x(a, h, w))"}
{"solution": "def count_unread_chapters():\n    n = int(input())\n    chapters = [list(map(int, input().split())) for _ in range(n)]\n    k = int(input())\n\n    unread_chapters = 0\n    for start, end in chapters:\n        if start < k <= end:\n            unread_chapters += 1\n            break\n        elif k <= start:\n            unread_chapters = n - chapters.index([start, end])\n            break\n\n    print(unread_chapters)\n\ncount_unread_chapters()"}
{"solution": "def can_form_codeforces(word):\n    target = \"CODEFORCES\"\n    n = len(word)\n    m = len(target)\n    \n    if n < m:\n        return \"NO\"\n    \n    for i in range(m + 1):\n        if word[:i] == target[:i] and word[n - (m - i):] == target[i:]:\n            return \"YES\"\n    \n    return \"NO\"\n\nword = input()\nprint(can_form_codeforces(word))"}
{"solution": "import sys\n\ndef min_weight(n):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][i] = 0\n        dp[i][i + 1] = i * (i + 1) * (i + 2)\n    for length in range(3, n + 1):\n        for i in range(1, n - length + 2):\n            j = i + length - 1\n            dp[i][j] = sys.maxsize\n            for k in range(i + 1, j + 1):\n                dp[i][j] = min(dp[i][j], dp[i][k - 1] + dp[k + 1][j] + i * k * j)\n    return dp[1][n]\n\nn = int(input())\nprint(min_weight(n))"}
{"solution": "def count_digits(n):\n    digits = 0\n    i = 1\n    while i <= n:\n        digits += len(str(i))\n        i += 1\n    return digits\n\nn = int(input())\nprint(count_digits(n))"}
{"solution": "def find_winning_color(n, A, cars):\n    \"\"\"\n    Find a color that Bob can choose to win the game.\n\n    Args:\n    n (int): The number of cars.\n    A (int): The color chosen by Alice.\n    cars (list): A list of colors of the cars in the order of their appearance.\n\n    Returns:\n    int: A color that Bob can choose to win the game, or -1 if no such color exists.\n    \"\"\"\n    # Initialize a dictionary to store the count of each color\n    color_count = {}\n    # Initialize a variable to store the count of Alice's color\n    alice_count = 0\n\n    # Iterate over the cars\n    for i, car in enumerate(cars):\n        # If the car's color is Alice's color, increment the count\n        if car == A:\n            alice_count += 1\n        # If the car's color is not in the dictionary, add it with a count of 1\n        if car not in color_count:\n            color_count[car] = 1\n        # If the car's color is already in the dictionary, increment its count\n        else:\n            color_count[car] += 1\n\n        # If the count of the car's color is less than Alice's count, remove it from the dictionary\n        if color_count[car] < alice_count:\n            del color_count[car]\n\n    # If the dictionary is not empty, return any color from it\n    if color_count:\n        return next(iter(color_count))\n    # If the dictionary is empty, return -1\n    else:\n        return -1\n\n\n# Read the input\nn, A = map(int, input().split())\ncars = list(map(int, input().split()))\n\n# Find and print the winning color\nprint(find_winning_color(n, A, cars))"}
{"solution": "def is_unique_crossword(n, x, a):\n    total_length = sum(a)\n    if total_length > x:\n        return False\n    if total_length == x:\n        return n == 1\n    if n == 1:\n        return False\n    if x - total_length - (n - 1) > 1:\n        return False\n    if x - total_length - (n - 1) == 1 and a[0] > 1:\n        return False\n    return True\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\nif is_unique_crossword(n, x, a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\nn, S = map(int, input().split())\nprint(math.ceil(S / n))"}
{"solution": "def lexicographically_smallest_palindrome(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    mid_char = ''\n    first_half = ''\n    for char in sorted(char_count.keys()):\n        count = char_count[char]\n        if count % 2 == 1:\n            if mid_char:\n                first_half += char * (count // 2)\n            else:\n                mid_char = char\n                first_half += char * (count // 2)\n        else:\n            first_half += char * (count // 2)\n\n    return first_half + mid_char + first_half[::-1]\n\ns = input()\nprint(lexicographically_smallest_palindrome(s))"}
{"solution": "def calculate_weight(board):\n    piece_weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n    }\n    \n    white_weight = 0\n    black_weight = 0\n    \n    for row in board:\n        for piece in row:\n            if piece in piece_weights:\n                if piece.isupper():\n                    white_weight += piece_weights[piece]\n                else:\n                    black_weight += piece_weights[piece]\n    \n    if white_weight > black_weight:\n        return \"White\"\n    elif black_weight > white_weight:\n        return \"Black\"\n    else:\n        return \"Draw\"\n\nboard = [input() for _ in range(8)]\nprint(calculate_weight(board))"}
{"solution": "import heapq\n\ndef solve(n, m, s):\n    s = [int(x) for x in s]\n    dist = [float('inf')] * (n + 1)\n    prev = [-1] * (n + 1)\n    dist[0] = 0\n    queue = [(0, 0)]\n    while queue:\n        d, u = heapq.heappop(queue)\n        if d > dist[u]:\n            continue\n        for i in range(1, m + 1):\n            v = u + i\n            if v > n or s[v]:\n                continue\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                prev[v] = i\n                heapq.heappush(queue, (dist[v], v))\n    if dist[n] == float('inf'):\n        return -1\n    path = []\n    u = n\n    while u:\n        path.append(prev[u])\n        u -= prev[u]\n    return''.join(map(str, reversed(path)))\n\nn, m = map(int, input().split())\ns = input()\nprint(solve(n, m, s))"}
{"solution": "def calculate_distance(x1, y1, x2, y2):\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef find_path(k, x, y):\n    if calculate_distance(0, 0, x, y) % k!= 0:\n        return -1\n\n    path = []\n    current_x, current_y = 0, 0\n\n    while (current_x, current_y)!= (x, y):\n        if abs(x - current_x) >= k:\n            new_x = current_x + k if x > current_x else current_x - k\n            new_y = current_y\n        else:\n            new_x = x\n            new_y = current_y + (k - abs(x - current_x)) if y > current_y else current_y - (k - abs(x - current_x))\n\n        path.append((new_x, new_y))\n        current_x, current_y = new_x, new_y\n\n    return path\n\ndef main():\n    k = int(input())\n    x, y = map(int, input().split())\n\n    result = find_path(k, x, y)\n\n    if result == -1:\n        print(-1)\n    else:\n        print(len(result))\n        for point in result:\n            print(*point)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef find_smallest_n(m):\n    n = 1\n    while True:\n        count = 0\n        for k in range(2, int(math.sqrt(n)) + 2):\n            a = 1\n            for _ in range(3):\n                a *= k\n                if a > n:\n                    break\n            else:\n                count += 1\n        if count == m:\n            return n\n        n += 1\n        if n > 10**6:\n            return -1\n\nm = int(input())\nprint(find_smallest_n(m))"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    if d >= r1 + r2:\n        return 0\n    elif d <= abs(r1 - r2):\n        r_min = min(r1, r2)\n        return math.pi * r_min ** 2\n    else:\n        a = (r1 ** 2 - r2 ** 2 + d ** 2) / (2 * d)\n        h = math.sqrt(r1 ** 2 - a ** 2)\n        area = r1 ** 2 * math.acos(a / r1) - a * h + r2 ** 2 * math.acos((d - a) / r2) - (d - a) * h\n        return area\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\nprint(circle_intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "def min_value(n):\n    if n == 1:\n        return 1\n    elif n % 2 == 0:\n        return 1 if n > 4 else n\n    else:\n        return 1 if n > 3 else n\n\nn = int(input())\nprint(min_value(n))"}
{"solution": "from collections import defaultdict\n\ndef dfs(node, graph, a, dp):\n    if dp[node]!= -1:\n        return dp[node]\n    if not graph[node]:\n        dp[node] = a[node]\n        return dp[node]\n    min_val = float('inf')\n    for child in graph[node]:\n        min_val = min(min_val, dfs(child, graph, a, dp))\n    dp[node] = a[node] + min_val\n    return dp[node]\n\ndef solve():\n    n = int(input())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    graph = defaultdict(list)\n    for i in range(n-1):\n        graph[p[i]].append(i+2)\n    dp = [-1] * (n+1)\n    ans = float('inf')\n    for child in graph[1]:\n        ans = min(ans, dfs(child, graph, a, dp))\n    print(ans + a[0])\n\nsolve()"}
{"solution": "def count_typo_words(n, S, T):\n    count = 0\n    for i in range(n + 1):\n        # Construct W by inserting a character at position i in both S and T\n        if i == 0:\n            W1 = S[0] + S\n            W2 = T[0] + T\n        elif i == n:\n            W1 = S + S[-1]\n            W2 = T + T[-1]\n        else:\n            W1 = S[:i] + S[i] + S[i:]\n            W2 = T[:i] + T[i] + T[i:]\n        \n        # Check if the constructed words are the same\n        if W1 == W2:\n            count += 1\n    \n    return count\n\nn = int(input())\nS = input().strip()\nT = input().strip()\nprint(count_typo_words(n, S, T))"}
{"solution": "import sys\ninput = sys.stdin.readline\n\ndef dfs(u, p):\n    for v in adj[u]:\n        if v!= p:\n            dfs(v, u)\n            if dp[v] > dp[u]:\n                dp[u] = dp[v]\n\nn = int(input())\na = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    u -= 1\n    v -= 1\n    adj[u].append(v)\n    adj[v].append(u)\n\ndp = a[:]\ndfs(0, -1)\nprint(max(dp))"}
{"solution": "n, m = map(int, input().split())\nprint(min(m, n - m) if m!= n else 0)"}
{"solution": "def min_shovels(k, r):\n    \"\"\"\n    Calculate the minimum number of shovels Polycarp needs to buy to pay without any change.\n\n    Args:\n    k (int): The price of one shovel.\n    r (int): The denomination of the coin in Polycarp's pocket that is different from \"10-burle coins\".\n\n    Returns:\n    int: The minimum number of shovels Polycarp needs to buy.\n    \"\"\"\n    for i in range(1, 11):\n        total_cost = i * k\n        if total_cost % 10 == r:\n            return i\n    return 10\n\nk, r = map(int, input().split())\nprint(min_shovels(k, r))"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # Dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Extract the bounding box\n    piece = []\n    for i in range(min_row, max_row + 1):\n        piece.append(grid[i][min_col:max_col + 1])\n    \n    # Check horizontal placement\n    if width * 2 == m:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j]!= piece[i][j + width]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    # Check vertical placement\n    if height * 2 == n:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j]!= piece[i + height][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "def min_segments():\n    points = [list(map(int, input().split())) for _ in range(3)]\n\n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n\n    if len(set(x_coords)) == 1 or len(set(y_coords)) == 1:\n        return 1\n    elif len(set(x_coords)) == 2 and len(set(y_coords)) == 2:\n        return 2\n    else:\n        return 3\n\nprint(min_segments())"}
{"solution": "def construct_k_regular_graph(k):\n    if k == 1:\n        return 2, [(1, 2)]\n    elif k == 2:\n        return \"NO\"\n    else:\n        n = 2 * k\n        edges = []\n        for i in range(1, k + 1):\n            edges.append((i, i + k))\n            for j in range(1, k):\n                edges.append((i, i + j))\n                edges.append((i + k, i + k + j))\n        edges.append((1, k + 1))\n        return n, edges\n\n\ndef main():\n    k = int(input())\n    result = construct_k_regular_graph(k)\n    if result == \"NO\":\n        print(\"NO\")\n    else:\n        n, edges = result\n        m = len(edges)\n        print(\"YES\")\n        print(n, m)\n        for edge in edges:\n            print(*edge)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def kmp(s, t):\n    n, m = len(s), len(t)\n    lps = [0] * m\n    j = 0\n    for i in range(1, m):\n        while j > 0 and t[i]!= t[j]:\n            j = lps[j - 1]\n        if t[i] == t[j]:\n            j += 1\n        lps[i] = j\n    j = 0\n    count = 0\n    for i in range(n):\n        while j > 0 and s[i]!= t[j]:\n            j = lps[j - 1]\n        if s[i] == t[j]:\n            j += 1\n        if j == m:\n            count += 1\n            j = lps[j - 1]\n    return count\n\ndef solve():\n    n, m, q = map(int, input().split())\n    s = input()\n    t = input()\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + kmp(s[:i + 1], t)\n    for _ in range(q):\n        l, r = map(int, input().split())\n        print(prefix[r] - prefix[l - 1])\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "MOD = 1000000007\n\ndef count_paths(n, k, d):\n    dp = [[[0 for _ in range(k + 1)] for _ in range(n + 1)] for _ in range(2)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            for l in range(1, k + 1):\n                if l >= j:\n                    dp[i % 2][j][l] = (dp[i % 2][j][l] + dp[(i - 1) % 2][j - 1][l - 1]) % MOD\n        for l in range(1, k + 1):\n            dp[i % 2][0][l] = (dp[i % 2][0][l] + dp[(i - 1) % 2][k][l]) % MOD\n\n    res = sum(dp[n % 2][k][d:]) % MOD\n    return res\n\nn, k, d = map(int, input().split())\nprint(count_paths(n, k, d))"}
{"solution": "def encrypt_japanese_crossword(n, row):\n    groups = []\n    count = 0\n    \n    for char in row:\n        if char == 'B':\n            count += 1\n        else:\n            if count > 0:\n                groups.append(count)\n                count = 0\n    \n    if count > 0:\n        groups.append(count)\n    \n    print(len(groups))\n    if groups:\n        print(\" \".join(map(str, groups)))\n\nn = int(input())\nrow = input().strip()\nencrypt_japanese_crossword(n, row)"}
{"solution": "import sys\n\ndef main():\n    n, m, p = map(int, sys.stdin.readline().split())\n    s = sys.stdin.readline().strip()\n    operations = sys.stdin.readline().strip()\n\n    stack = []\n    pairs = [-1] * n\n    for i in range(n):\n        if s[i] == '(':\n            stack.append(i)\n        else:\n            pairs[stack.pop()] = i\n            pairs[i] = stack[-1]\n\n    cursor = p - 1\n    for op in operations:\n        if op == 'L':\n            cursor -= 1\n        elif op == 'R':\n            cursor += 1\n        elif op == 'D':\n            left = min(cursor, pairs[cursor])\n            right = max(cursor, pairs[cursor])\n            for i in range(left, right + 1):\n                s = s[:i] +'' + s[i + 1:]\n            cursor = left - 1\n            while cursor >= 0 and s[cursor] =='':\n                cursor -= 1\n            if cursor < 0:\n                cursor = 0\n                while s[cursor] =='':\n                    cursor += 1\n\n    s = ''.join(s.split())\n    print(s)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_y():\n    n = int(input())\n    min_val = -2 * 10**9\n    max_val = 2 * 10**9\n\n    for _ in range(n):\n        sign, x, answer = input().split()\n        x = int(x)\n\n        if sign == \">\":\n            if answer == \"Y\":\n                min_val = max(min_val, x + 1)\n            else:\n                max_val = min(max_val, x)\n        elif sign == \"<\":\n            if answer == \"Y\":\n                max_val = min(max_val, x - 1)\n            else:\n                min_val = max(min_val, x)\n        elif sign == \">=\":\n            if answer == \"Y\":\n                min_val = max(min_val, x)\n            else:\n                max_val = min(max_val, x - 1)\n        elif sign == \"<=\":\n            if answer == \"Y\":\n                max_val = min(max_val, x)\n            else:\n                min_val = max(min_val, x + 1)\n\n    if min_val <= max_val:\n        return min_val\n    else:\n        return \"Impossible\"\n\nprint(find_y())"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_periods(a, b):\n    if a > b:\n        a, b = b, a\n    count = 0\n    for i in range(1, a + 1):\n        if gcd(a, i) == 1 and gcd(b, i) == 1:\n            count += 1\n    return count + a\n\na, b = map(int, input().split())\nprint(count_periods(a, b))"}
{"solution": "def generate_names(n, k, conditions):\n    names = []\n    counter = 0\n    for i in range(n):\n        if i < k - 1:\n            names.append(f\"A{chr(97 + i)}\")\n        else:\n            if conditions[i - k + 1] == \"YES\":\n                counter += 1\n                names.append(f\"A{chr(97 + counter)}\")\n            else:\n                names.append(names[i - 1])\n    return names\n\nn, k = map(int, input().split())\nconditions = input().split()\n\nnames = generate_names(n, k, conditions)\nprint(\" \".join(names))"}
{"solution": "def min_operations_to_equal(a, b):\n    def count_factors(n, factor):\n        count = 0\n        while n % factor == 0:\n            n //= factor\n            count += 1\n        return count, n\n\n    # Count the number of times we can divide by 2, 3, and 5\n    a2, a = count_factors(a, 2)\n    a3, a = count_factors(a, 3)\n    a5, a = count_factors(a, 5)\n    \n    b2, b = count_factors(b, 2)\n    b3, b = count_factors(b, 3)\n    b5, b = count_factors(b, 5)\n    \n    # If the remaining parts are not equal, return -1\n    if a!= b:\n        return -1\n    \n    # Calculate the total number of operations needed\n    operations = abs(a2 - b2) + abs(a3 - b3) + abs(a5 - b5)\n    \n    return operations\n\na, b = map(int, input().split())\nprint(min_operations_to_equal(a, b))"}
{"solution": "def calculate_min_cost(n, a, b, colors):\n    \"\"\"\n    Calculate the minimum cost to form a palindrome.\n\n    Args:\n    n (int): The number of dancers.\n    a (int): The cost of a white suit.\n    b (int): The cost of a black suit.\n    colors (list): A list of integers representing the color of each dancer's suit.\n\n    Returns:\n    int: The minimum cost to form a palindrome, or -1 if it's not possible.\n    \"\"\"\n    total_cost = 0\n    for i in range(n // 2):\n        if colors[i] == colors[n - i - 1]:\n            if colors[i] == 2:\n                total_cost += min(a, b)\n        elif colors[i] == 2:\n            if colors[n - i - 1] == 0:\n                total_cost += a\n            else:\n                total_cost += b\n        elif colors[n - i - 1] == 2:\n            if colors[i] == 0:\n                total_cost += a\n            else:\n                total_cost += b\n        else:\n            return -1\n    if n % 2 == 1 and colors[n // 2] == 2:\n        total_cost += min(a, b)\n    return total_cost\n\n\nn, a, b = map(int, input().split())\ncolors = list(map(int, input().split()))\nprint(calculate_min_cost(n, a, b, colors))"}
{"solution": "def paint_cube(k):\n    if k == 1:\n        return -1\n\n    cube = [[[None for _ in range(k)] for _ in range(k)] for _ in range(k)]\n\n    for i in range(k):\n        for j in range(k):\n            for z in range(k):\n                if (i + j + z) % 2 == 0:\n                    cube[i][j][z] = 'b'\n                else:\n                    cube[i][j][z] = 'w'\n\n    for i in range(k):\n        for j in range(k):\n            row = ''\n            for z in range(k):\n                row += cube[i][j][z]\n            print(row)\n        print()\n\nk = int(input())\nresult = paint_cube(k)\nif result == -1:\n    print(result)"}
{"solution": "import math\nfrom collections import Counter\n\ndef largest_lovely_number(n):\n    def prime_factors(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            while (n % i) == 0:\n                factors.append(i)\n                n //= i\n            i += 1\n        if n > 1:\n            factors.append(n)\n        return factors\n\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n    \n    lovely_number = 1\n    for prime, count in factor_counts.items():\n        lovely_number *= prime ** min(count, 1)\n    \n    return lovely_number\n\nn = int(input())\nprint(largest_lovely_number(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    # Check for adjacent occupied seats\n    for i in range(n - 1):\n        if seating[i] == '1' and seating[i + 1] == '1':\n            return \"No\"\n    \n    # Check for possible additional seating\n    for i in range(n):\n        if seating[i] == '0':\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                return \"No\"\n    \n    return \"Yes\"\n\nn = int(input())\nseating = input().strip()\nprint(is_maximal_seating(n, seating))"}
{"solution": "def find_possible_k_values(n, a):\n    possible_k_values = []\n    for k in range(1, n + 1):\n        x = [a[i] - a[i - 1] for i in range(1, k + 1)]\n        valid = True\n        for i in range(k + 1, n + 1):\n            if a[i] - a[i - 1]!= x[(i - 1) % k]:\n                valid = False\n                break\n        if valid:\n            possible_k_values.append(k)\n    return possible_k_values\n\n\nn = int(input())\na = list(map(int, input().split()))\npossible_k_values = find_possible_k_values(n, a)\nprint(len(possible_k_values))\nprint(*possible_k_values)"}
{"solution": "def can_form_equal_teams(scores):\n    total_score = sum(scores)\n    if total_score % 2!= 0:\n        return False\n\n    target_score = total_score // 2\n    scores.sort(reverse=True)\n\n    def dfs(index, current_score, count):\n        if count == 3:\n            return current_score == target_score\n        if current_score > target_score or index >= len(scores):\n            return False\n\n        return dfs(index + 1, current_score + scores[index], count + 1) or dfs(index + 1, current_score, count)\n\n    return dfs(0, 0, 0)\n\n\nscores = list(map(int, input().split()))\nif can_form_equal_teams(scores):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_2_3_integers(left, right):\n    \"\"\"\n    Counts the number of 2-3-integers in the given range [left, right].\n    \n    A 2-3-integer is a positive integer that is equal to 2^x * 3^y for some non-negative integers x and y.\n    \n    Args:\n        left (int): The lower bound of the range (inclusive).\n        right (int): The upper bound of the range (inclusive).\n    \n    Returns:\n        int: The number of 2-3-integers in the given range.\n    \"\"\"\n    def count_2_3_integers_up_to(n):\n        \"\"\"\n        Counts the number of 2-3-integers up to n.\n        \n        Args:\n            n (int): The upper bound (inclusive).\n        \n        Returns:\n            int: The number of 2-3-integers up to n.\n        \"\"\"\n        count = 0\n        x = 1\n        while x <= n:\n            y = 1\n            while x * y <= n:\n                count += 1\n                y *= 3\n            x *= 2\n        return count\n    \n    return count_2_3_integers_up_to(right) - count_2_3_integers_up_to(left - 1)\n\n\nleft, right = map(int, input().split())\nprint(count_2_3_integers(left, right))"}
{"solution": "def calculate_eaten_candies(n, k):\n    \"\"\"\n    Calculate the total number of candies Alya ate.\n\n    Args:\n    n (int): The total number of moves.\n    k (int): The number of candies in the box at the end.\n\n    Returns:\n    int: The total number of candies Alya ate.\n    \"\"\"\n    # Initialize the number of candies put and eaten\n    put = 0\n    eaten = 0\n\n    # Initialize the number of candies in the box\n    box = 0\n\n    # Iterate over the moves\n    for i in range(n):\n        # If the box is empty, put candies\n        if box == 0:\n            put += 1\n            box += put\n        # If the box is not empty, decide whether to put or eat\n        else:\n            # If the number of candies in the box is less than or equal to the number of candies put,\n            # eat a candy\n            if box <= put:\n                eaten += 1\n                box -= 1\n            # If the number of candies in the box is greater than the number of candies put,\n            # put candies\n            else:\n                put += 1\n                box += put\n\n    # Adjust the number of eaten candies based on the final number of candies in the box\n    eaten += put - k\n\n    return eaten\n\n\n# Read the input\nn, k = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_eaten_candies(n, k))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\nfor i in range(n - 2):\n    if a[i] + a[i + 1] > a[i + 2]:\n        print(\"YES\")\n        sys.exit()\n\nprint(\"NO\")"}
{"solution": "def solve(x, y):\n    if x == 0:\n        return y == 1\n    if y == 1:\n        return x == 0\n    if x < y - 1:\n        return False\n    return (x - (y - 1)) % 2 == 0\n\nx, y = map(int, input().split())\nprint(\"Yes\" if solve(x, y) else \"No\")"}
{"solution": "import math\n\ndef calculate_total_rating(n, k, skills):\n    total_rating = sum(math.floor(skill / 10) for skill in skills)\n    improvements = sorted([(10 - (skill % 10), skill) for skill in skills if skill < 100])\n\n    for improvement in improvements:\n        if k >= improvement[0]:\n            k -= improvement[0]\n            total_rating += 1\n        else:\n            break\n\n    return total_rating\n\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\nprint(calculate_total_rating(n, k, skills))"}
{"solution": "def find_smallest_pretty_integer():\n    n, m = map(int, input().split())\n    list1 = list(map(int, input().split()))\n    list2 = list(map(int, input().split()))\n\n    set1 = set(list1)\n    set2 = set(list2)\n\n    common_digits = set1.intersection(set2)\n    if common_digits:\n        return min(common_digits)\n\n    min1 = min(list1)\n    min2 = min(list2)\n\n    smallest_pretty = min(int(str(min1) + str(min2)), int(str(min2) + str(min1)))\n    return smallest_pretty\n\nprint(find_smallest_pretty_integer())"}
{"solution": "def calculate_problems(n, k):\n    \"\"\"\n    Calculate the maximum number of problems Limak can solve before leaving for the party.\n\n    Args:\n    n (int): The number of problems in the contest.\n    k (int): The number of minutes Limak needs to get to the party from his house.\n\n    Returns:\n    int: The maximum number of problems Limak can solve.\n    \"\"\"\n    total_time = 240  # Total time available in minutes\n    time_left = total_time - k  # Time left for solving problems\n    problems_solved = 0\n    time_spent = 0\n\n    for i in range(1, n + 1):\n        time_required = 5 * i  # Time required to solve the current problem\n        if time_spent + time_required <= time_left:\n            time_spent += time_required\n            problems_solved += 1\n        else:\n            break\n\n    return problems_solved\n\n\nn, k = map(int, input().split())\nprint(calculate_problems(n, k))"}
{"solution": ""}
{"solution": "import math\n\ndef count_divisors(n):\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return len(divisors)\n\nb = int(input().strip())\nresult = count_divisors(b)\nprint(result)"}
{"solution": "def pinball_game(n, bumpers):\n    \"\"\"\n    Calculate the number of positions such that the ball will eventually fall from the game field if it starts at that position.\n\n    Args:\n        n (int): The length of the sequence of bumpers.\n        bumpers (str): A string representing the bumpers' types.\n\n    Returns:\n        int: The number of positions in the sequence such that the ball will eventually fall from the game field if it starts at that position.\n    \"\"\"\n    # Initialize variables to keep track of the number of positions that lead to a fall\n    fall_positions = 0\n\n    # Initialize variables to keep track of the current position and the direction of the ball\n    current_position = 0\n    direction = 1\n\n    # Initialize a set to keep track of visited positions\n    visited = set()\n\n    # Iterate over the bumpers\n    for i in range(n):\n        # If the current position is out of bounds, increment the fall_positions counter\n        if current_position < 0 or current_position >= n:\n            fall_positions += 1\n            # Reset the current position and direction\n            current_position = i\n            direction = 1 if bumpers[i] == '>' else -1\n        # If the current position has been visited before, it means the ball will stay in the game field forever\n        elif current_position in visited:\n            break\n        # Mark the current position as visited\n        visited.add(current_position)\n        # Update the current position based on the direction of the ball\n        current_position += direction\n        # Update the direction of the ball based on the type of the bumper\n        direction = 1 if bumpers[current_position] == '>' else -1\n\n    # Return the total number of fall positions\n    return fall_positions\n\n\n# Read the input\nn = int(input())\nbumpers = input()\n\n# Print the output\nprint(pinball_game(n, bumpers))"}
{"solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    sticks = list(map(int, sys.stdin.readline().split()))\n\n    sticks.sort()\n    sticks.append(0)\n\n    total_area = 0\n    i = 0\n    while i < n:\n        if sticks[i] == sticks[i + 1]:\n            j = i + 2\n            while j < n and sticks[j] == sticks[j + 1]:\n                j += 2\n            if j < n and sticks[j] - 1 == sticks[i]:\n                total_area += sticks[i] * sticks[j]\n                i = j + 1\n            elif j + 1 < n and sticks[j + 1] - 1 == sticks[i]:\n                total_area += sticks[i] * sticks[j + 1]\n                i = j + 2\n            else:\n                i += 2\n        elif sticks[i] == sticks[i + 1] - 1:\n            j = i + 2\n            while j < n and sticks[j] == sticks[j + 1]:\n                j += 2\n            if j < n and sticks[j] == sticks[i + 1]:\n                total_area += sticks[i] * sticks[j]\n                i = j + 1\n            else:\n                i += 1\n        else:\n            i += 1\n\n    print(total_area)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import defaultdict\n\ndef restore_numbers(n, numbers):\n    # Create a dictionary to store the frequency of each letter\n    freq = defaultdict(int)\n    for num in numbers:\n        for i, letter in enumerate(num):\n            freq[letter] += 10 ** (len(num) - i - 1)\n\n    # Sort the letters by frequency\n    sorted_letters = sorted(freq, key=freq.get, reverse=True)\n\n    # Create a dictionary to store the mapping of letters to digits\n    mapping = {}\n    for i, letter in enumerate(sorted_letters):\n        mapping[letter] = i\n\n    # Replace the letters with digits and calculate the sum\n    total_sum = 0\n    for num in numbers:\n        restored_num = 0\n        for i, letter in enumerate(num):\n            restored_num += mapping[letter] * (10 ** (len(num) - i - 1))\n        total_sum += restored_num\n\n    return total_sum\n\nn = int(input())\nnumbers = [input() for _ in range(n)]\nprint(restore_numbers(n, numbers))"}
{"solution": "def max_teams(n, m):\n    # Calculate the maximum number of teams of type 1 (1 XP, 2 NB)\n    t1 = min(n, m // 2)\n    \n    # Calculate the remaining newbies after forming type 1 teams\n    remaining_nb = m - 2 * t1\n    \n    # Calculate the maximum number of teams of type 2 (2 XP, 1 NB) using the remaining newbies\n    t2 = min((n - t1) // 2, remaining_nb)\n    \n    # Return the total number of teams\n    return t1 + t2\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    n = len(s)\n    \n    # Check for \"AB\" followed by \"BA\"\n    found_AB = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"AB\":\n            found_AB = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"BA\":\n                    print(\"YES\")\n                    return\n            break\n    \n    # Check for \"BA\" followed by \"AB\"\n    found_BA = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"BA\":\n            found_BA = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"AB\":\n                    print(\"YES\")\n                    return\n            break\n    \n    # If neither condition is met\n    print(\"NO\")\n\ns = input().strip()\ncheck_substrings(s)"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    k = int(input())\n    b = list(map(int, input().split()))\n\n    if sum(a)!= sum(b):\n        print(\"NO\")\n        return\n\n    ans = []\n    while len(a) > k:\n        for i in range(len(a) - 1):\n            if a[i] > a[i + 1]:\n                a[i] += a[i + 1]\n                ans.append((i + 1, 'R'))\n                a.pop(i + 1)\n                break\n            elif a[i] < a[i + 1]:\n                a[i + 1] += a[i]\n                ans.append((i + 2, 'L'))\n                a.pop(i)\n                break\n        else:\n            print(\"NO\")\n            return\n\n    if a!= b:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    for x, y in ans:\n        print(x, y)\n\nsolve()"}
{"solution": "def orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # Collinear\n    elif val > 0:\n        return 1  # Clockwise\n    else:\n        return 2  # Counterclockwise\n\ndef do_intersect(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if (o1!= o2 and o3!= o4):\n        return True\n\n    if (o1 == 0 and on_segment(p1, p2, q1)):\n        return True\n\n    if (o2 == 0 and on_segment(p1, q2, q1)):\n        return True\n\n    if (o3 == 0 and on_segment(p2, p1, q2)):\n        return True\n\n    if (o4 == 0 and on_segment(p2, q1, q2)):\n        return True\n\n    return False\n\ndef on_segment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n        q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\ndef is_valid_assignment(rebels, bases, assignment):\n    for i in range(len(rebels)):\n        for j in range(i + 1, len(rebels)):\n            if do_intersect(rebels[i], bases[assignment[i]], rebels[j], bases[assignment[j]]):\n                return False\n    return True\n\ndef solve():\n    R, B = map(int, input().split())\n    rebels = []\n    bases = []\n    for _ in range(R):\n        x, y = map(int, input().split())\n        rebels.append((x, y))\n    for _ in range(B):\n        x, y = map(int, input().split())\n        bases.append((x, y))\n\n    if R!= B:\n        print(\"No\")\n        return\n\n    assignment = list(range(R))\n    if is_valid_assignment(rebels, bases, assignment):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nsolve()"}
{"solution": "import math\n\nn = int(input())\na = list(map(int, input().split()))\n\nmax_power = 0\ncount = 0\n\nfor num in a:\n    power = 0\n    while num % 2 == 0:\n        power += 1\n        num //= 2\n    if power > max_power:\n        max_power = power\n        count = 1\n    elif power == max_power:\n        count += 1\n\nprint(2 ** max_power, count)"}
{"solution": "def min_clicks(n, m):\n    clicks = 0\n    while m > n:\n        if m % 2 == 0:\n            m //= 2\n        else:\n            m -= 1\n        clicks += 1\n    return clicks + (n - m)\n\nn, m = map(int, input().split())\nprint(min_clicks(n, m))"}
{"solution": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x]!= x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x!= root_y:\n            if self.rank[root_x] > self.rank[root_y]:\n                self.parent[root_y] = root_x\n            elif self.rank[root_x] < self.rank[root_y]:\n                self.parent[root_x] = root_y\n            else:\n                self.parent[root_y] = root_x\n                self.rank[root_x] += 1\n\n\ndef solve():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, input().split())\n        segments.append((l, r))\n\n    events = []\n    for i, (l, r) in enumerate(segments):\n        events.append((l, 1, i))\n        events.append((r, -1, i))\n    events.sort()\n\n    uf = UnionFind(n)\n    edges = 0\n    for _, type, i in events:\n        if type == 1:\n            for j in range(i + 1, n):\n                if segments[j][0] < segments[i][1] and segments[i][0] < segments[j][1]:\n                    if uf.find(i)!= uf.find(j):\n                        uf.union(i, j)\n                        edges += 1\n    if edges == n - 1 and len(set(uf.find(i) for i in range(n))) == 1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def longest_ddos_period(n, requests):\n    max_length = 0\n    for i in range(n):\n        total_requests = 0\n        for j in range(i, n):\n            total_requests += requests[j]\n            if total_requests > 100 * (j - i + 1):\n                max_length = max(max_length, j - i + 1)\n    return max_length\n\nn = int(input())\nrequests = list(map(int, input().split()))\nprint(longest_ddos_period(n, requests))"}
{"solution": "def check_dissatisfaction(n, k, episodes):\n    max_dissatisfaction = 0\n    current_dissatisfaction = 0\n\n    for episode in episodes:\n        if episode == 'N' or episode == '?':\n            current_dissatisfaction += 1\n            max_dissatisfaction = max(max_dissatisfaction, current_dissatisfaction)\n        else:\n            current_dissatisfaction = 0\n\n    if max_dissatisfaction == k:\n        return \"YES\"\n    elif max_dissatisfaction > k:\n        return \"NO\"\n    else:\n        # Check if we can make the dissatisfaction equal to k by replacing '?' with 'N'\n        current_dissatisfaction = 0\n        for episode in episodes:\n            if episode == 'N':\n                current_dissatisfaction += 1\n            elif episode == '?':\n                current_dissatisfaction += 1\n                if current_dissatisfaction == k:\n                    return \"YES\"\n                if current_dissatisfaction > k:\n                    current_dissatisfaction -= 1\n            else:\n                current_dissatisfaction = 0\n        return \"NO\"\n\nn, k = map(int, input().split())\nepisodes = input()\n\nprint(check_dissatisfaction(n, k, episodes))"}
{"solution": "def calculate_possible_values(n, x, d):\n    \"\"\"\n    Calculate the number of possible values of S - T.\n\n    Args:\n    n (int): The length of the sequence.\n    x (int): The first element of the sequence.\n    d (int): The common difference of the sequence.\n\n    Returns:\n    int: The number of possible values of S - T.\n    \"\"\"\n    # Calculate the sum of the sequence\n    total_sum = n * (2 * x + (n - 1) * d) // 2\n\n    # If the total sum is even, the number of possible values is n + 1\n    if total_sum % 2 == 0:\n        return n + 1\n    # If the total sum is odd and d is even, the number of possible values is n + 1\n    elif d % 2 == 0:\n        return n + 1\n    # If the total sum is odd and d is odd, the number of possible values is n\n    else:\n        return n\n\n\ndef main():\n    # Read the input\n    n, x, d = map(int, input().split())\n\n    # Calculate and print the number of possible values\n    print(calculate_possible_values(n, x, d))\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def did_anton_perform_good():\n    n = int(input())\n    for _ in range(n):\n        handle, before, after = input().split()\n        before, after = int(before), int(after)\n        if before >= 2400 and after > before:\n            return \"YES\"\n    return \"NO\"\n\nprint(did_anton_perform_good())"}
{"solution": "def count_missed_trains(s):\n    \"\"\"\n    Calculate the number of trains that have departed strictly before time s.\n\n    Args:\n    s (str): A binary number representing the time.\n\n    Returns:\n    int: The number of trains that have departed strictly before time s.\n    \"\"\"\n    # Convert binary string to integer\n    s_int = int(s, 2)\n    \n    # Initialize the number of missed trains\n    missed_trains = 0\n    \n    # Initialize the current train departure time\n    current_time = 1\n    \n    # Loop until the current train departure time exceeds s\n    while current_time <= s_int:\n        # If the current train departure time is less than s, increment the missed trains count\n        if current_time < s_int:\n            missed_trains += 1\n        \n        # Update the current train departure time to the next power of 4\n        current_time *= 4\n    \n    return missed_trains\n\n# Read the binary time from input\ns = input()\n\n# Calculate and print the number of missed trains\nprint(count_missed_trains(s))"}
{"solution": "def min_rows(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n    for i in range(n // 2):\n        if matrix[i]!= matrix[n - i - 1]:\n            return n - i\n    return n // 2 if n % 2 == 0 else n // 2 + 1\n\n\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\nprint(min_rows(matrix))"}
{"solution": "def max_non_overlapping_orders(n, orders):\n    \"\"\"\n    This function calculates the maximum number of non-overlapping orders a restaurant can accept.\n\n    Parameters:\n    n (int): The number of orders.\n    orders (list): A list of tuples, where each tuple contains the start and end time of an order.\n\n    Returns:\n    int: The maximum number of non-overlapping orders.\n    \"\"\"\n    # Sort the orders based on their end times\n    orders.sort(key=lambda x: x[1])\n    \n    # Initialize the count of non-overlapping orders with 1 (the first order)\n    count = 1\n    \n    # Initialize the end time of the last accepted order\n    last_end_time = orders[0][1]\n    \n    # Iterate through the orders starting from the second order\n    for start, end in orders[1:]:\n        # If the current order does not overlap with the last accepted order, increment the count and update the last end time\n        if start > last_end_time:\n            count += 1\n            last_end_time = end\n    \n    return count\n\n# Read the number of orders\nn = int(input())\n\n# Read the orders\norders = []\nfor _ in range(n):\n    start, end = map(int, input().split())\n    orders.append((start, end))\n\n# Calculate and print the maximum number of non-overlapping orders\nprint(max_non_overlapping_orders(n, orders))"}
{"solution": "def solve():\n    n, k = map(int, input().split())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n\n    total_tables = sum(x)\n    total_formulas = sum(y)\n\n    if total_tables > k * n or total_formulas > k * n:\n        print(\"NO\")\n        return\n\n    tables = 0\n    formulas = 0\n    for i in range(n):\n        tables += x[i]\n        formulas += y[i]\n\n        if tables > k:\n            if formulas >= k - (tables - k):\n                formulas -= k - (tables - k)\n            else:\n                print(\"NO\")\n                return\n            tables = k\n\n        if formulas > k:\n            if tables >= k - (formulas - k):\n                tables -= k - (formulas - k)\n            else:\n                print(\"NO\")\n                return\n            formulas = k\n\n    print(\"YES\")\n\nsolve()"}
{"solution": "def can_human_win(n, k, coefficients):\n    # Calculate the value of P(k)\n    p_k = sum(int(coeff) * (k ** i) for i, coeff in enumerate(coefficients) if coeff!= '?')\n\n    # Count the number of unknown coefficients\n    unknown_count = sum(1 for coeff in coefficients if coeff == '?')\n\n    # If the number of unknown coefficients is odd, human can win\n    if unknown_count % 2 == 1:\n        return True\n\n    # If P(k) is not divisible by the number of unknown coefficients, human can win\n    if p_k % unknown_count!= 0:\n        return True\n\n    # Otherwise, human cannot win\n    return False\n\n\nn, k = map(int, input().split())\ncoefficients = [input().strip() for _ in range(n + 1)]\n\nif can_human_win(n, k, coefficients):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef smallest_multiple(p, x):\n    return x + (p - x % p) % p\n\ndef smallest_starting_number(x2):\n    min_x0 = x2\n    for p in range(2, x2):\n        if is_prime(p):\n            x1 = smallest_multiple(p, x2)\n            for q in range(2, x1):\n                if is_prime(q):\n                    x0 = smallest_multiple(q, x1)\n                    if x0 >= 3 and x0 < min_x0:\n                        min_x0 = x0\n    return min_x0\n\nx2 = int(input())\nprint(smallest_starting_number(x2))"}
{"solution": "def min_p_binary_numbers(n, p):\n    for k in range(1, n + 1):\n        if (n - k * p) < k:\n            return -1\n        if bin(n - k * p).count('1') <= k:\n            return k\n    return -1\n\nn, p = map(int, input().split())\nprint(min_p_binary_numbers(n, p))"}
{"solution": "def minimize_integer(n, k, s):\n    s = list(s)\n    if k == 0:\n        return ''.join(s)\n    if n == 1:\n        return '0'\n    if s[0]!= '1':\n        s[0] = '1'\n        k -= 1\n    for i in range(1, n):\n        if k > 0 and s[i]!= '0':\n            s[i] = '0'\n            k -= 1\n    return ''.join(s)\n\nn, k = map(int, input().split())\ns = input()\nprint(minimize_integer(n, k, s))"}
{"solution": "def min_presents(cnt_1, cnt_2, x, y):\n    def count_multiples(n, x, y):\n        lcm = x * y // gcd(x, y)\n        return n // x + n // y - n // lcm\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    v = cnt_1 + cnt_2\n    while True:\n        if cnt_1 <= v - count_multiples(v, x, y) and cnt_2 <= count_multiples(v, x, y):\n            return v\n        v += 1\n\ncnt_1, cnt_2, x, y = map(int, input().split())\nprint(min_presents(cnt_1, cnt_2, x, y))"}
{"solution": "def calculate_position(n, sx, sy, dx, dy, t):\n    \"\"\"\n    Calculate the final position of the bear after t seconds.\n\n    Args:\n    n (int): The size of the checkered field.\n    sx (int): The initial x-coordinate of the bear.\n    sy (int): The initial y-coordinate of the bear.\n    dx (int): The initial x-component of the bear's speed.\n    dy (int): The initial y-component of the bear's speed.\n    t (int): The number of seconds the bear spends on the field.\n\n    Returns:\n    tuple: The final x and y coordinates of the bear.\n    \"\"\"\n    # Calculate the initial speed increase\n    speed_increase = sx + sy\n\n    # Update the speed\n    dx += speed_increase\n    dy += speed_increase\n\n    # Calculate the final position\n    x = (sx + dx * t - 1) % n + 1\n    y = (sy + dy * t - 1) % n + 1\n\n    return x, y\n\n\n# Read the input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Calculate and print the final position\nfinal_x, final_y = calculate_position(n, sx, sy, dx, dy, t)\nprint(final_x, final_y)"}
{"solution": "def solve(s):\n    n = len(s)\n    if n < 26:\n        return -1\n\n    alphabet = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    result = list(s)\n\n    for i in range(n - 25):\n        window = set()\n        unknowns = 0\n        for j in range(26):\n            if result[i + j] == '?':\n                unknowns += 1\n            else:\n                window.add(result[i + j])\n\n        if len(alphabet - window) > unknowns:\n            continue\n\n        for char in alphabet - window:\n            for j in range(26):\n                if result[i + j] == '?':\n                    result[i + j] = char\n                    break\n\n        for j in range(n):\n            if result[j] == '?':\n                for char in alphabet - set(result):\n                    result[j] = char\n                    break\n\n        return ''.join(result)\n\n    return -1\n\ns = input()\nprint(solve(s))"}
{"solution": "def can_divide_apples(n, weights):\n    total_weight = sum(weights)\n    if total_weight % 2!= 0:\n        return \"NO\"\n    \n    target_weight = total_weight // 2\n    num_200g = weights.count(200)\n    num_100g = n - num_200g\n    \n    if target_weight % 100 == 0:\n        if target_weight // 100 <= num_100g:\n            return \"YES\"\n        else:\n            remaining_weight = target_weight - num_100g * 100\n            if remaining_weight % 200 == 0 and remaining_weight // 200 <= num_200g:\n                return \"YES\"\n            else:\n                return \"NO\"\n    else:\n        if (target_weight - 100) % 200 == 0 and (target_weight - 100) // 200 <= num_200g and num_100g >= 1:\n            return \"YES\"\n        else:\n            return \"NO\"\n\nn = int(input())\nweights = list(map(int, input().split()))\nprint(can_divide_apples(n, weights))"}
{"solution": "import sys\n\ndef min_time_to_turn_off_lights(n, m, building):\n    total_time = 0\n    for i in range(n):\n        floor = building[i]\n        left_index = 1\n        right_index = m\n        while left_index <= right_index:\n            if floor[left_index] == '1':\n                total_time += left_index - 1\n                left_index += 1\n            elif floor[right_index] == '1':\n                total_time += m - right_index + 1\n                right_index -= 1\n            else:\n                left_index += 1\n                right_index -= 1\n        if i < n - 1:\n            total_time += 1\n    return total_time\n\nn, m = map(int, sys.stdin.readline().split())\nbuilding = [sys.stdin.readline().strip() for _ in range(n)]\n\nprint(min_time_to_turn_off_lights(n, m, building))"}
{"solution": "def find_min_trap_cost(n, costs, transitions):\n    visited = [False] * n\n    in_stack = [False] * n\n    min_cost = 0\n\n    def dfs(node):\n        stack = []\n        while True:\n            if visited[node]:\n                if in_stack[node]:\n                    # Found a cycle, calculate the minimum cost in this cycle\n                    cycle_min_cost = float('inf')\n                    while stack:\n                        cycle_node = stack.pop()\n                        in_stack[cycle_node] = False\n                        cycle_min_cost = min(cycle_min_cost, costs[cycle_node])\n                        if cycle_node == node:\n                            break\n                    return cycle_min_cost\n                else:\n                    return 0\n            visited[node] = True\n            in_stack[node] = True\n            stack.append(node)\n            node = transitions[node] - 1\n\n    for i in range(n):\n        if not visited[i]:\n            min_cost += dfs(i)\n\n    return min_cost\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(find_min_trap_cost(n, costs, transitions))"}
{"solution": "def calculate_entrance(n, a, b):\n    \"\"\"\n    Calculate the entrance number where Vasya will be at the end of his walk.\n\n    Args:\n    n (int): The number of entrances at Vasya's place.\n    a (int): The number of Vasya's entrance.\n    b (int): The length of Vasya's walk.\n\n    Returns:\n    int: The number of the entrance where Vasya will be at the end of his walk.\n    \"\"\"\n    # Calculate the new entrance number by adding the walk length to the current entrance number\n    new_entrance = a + b\n    \n    # If the new entrance number is less than 1, add the total number of entrances to get the correct entrance number\n    if new_entrance < 1:\n        new_entrance += n\n    \n    # If the new entrance number is greater than the total number of entrances, subtract the total number of entrances to get the correct entrance number\n    elif new_entrance > n:\n        new_entrance -= n\n    \n    # Return the new entrance number\n    return new_entrance\n\n# Read the input values\nn, a, b = map(int, input().split())\n\n# Calculate and print the entrance number where Vasya will be at the end of his walk\nprint(calculate_entrance(n, a, b))"}
{"solution": "def min_arithmetic_progressions(n, sequence):\n    \"\"\"\n    Calculate the minimum number of arithmetic progressions needed to represent a given sequence.\n\n    Args:\n    n (int): The number of elements in the sequence.\n    sequence (list): A list of integers representing the sequence.\n\n    Returns:\n    int: The minimum number of arithmetic progressions.\n    \"\"\"\n    if n == 1:\n        return 1\n\n    progressions = 1\n    prev_diff = None\n    prev_prev_value = None\n    prev_value = None\n\n    for i in range(n):\n        value = sequence[i]\n        if value == -1:\n            continue\n\n        if prev_value is not None:\n            curr_diff = value - prev_value\n            if prev_prev_value is not None and prev_diff is not None:\n                if curr_diff!= prev_diff:\n                    progressions += 1\n                    prev_diff = None\n                    prev_prev_value = None\n            else:\n                prev_diff = curr_diff\n            prev_prev_value = prev_value\n        prev_value = value\n\n    return progressions\n\n\nn = int(input())\nsequence = list(map(int, input().split()))\n\nprint(min_arithmetic_progressions(n, sequence))"}
{"solution": "def max_beauty(n, k, s):\n    def max_beauty_helper(s, target):\n        left = 0\n        changes = 0\n        max_length = 0\n\n        for right in range(n):\n            if s[right]!= target:\n                changes += 1\n\n            while changes > k:\n                if s[left]!= target:\n                    changes -= 1\n                left += 1\n\n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n\n    return max(max_beauty_helper(s, 'a'), max_beauty_helper(s, 'b'))\n\nn, k = map(int, input().split())\ns = input()\n\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, seats):\n    total_seats = sum(seats)\n    alice_seats = seats[0]\n    majority = (total_seats + 1) // 2\n\n    if alice_seats >= majority:\n        return [1]\n\n    coalition = [1]\n    seats = [(seats[i], i + 1) for i in range(1, n)]\n    seats.sort()\n\n    for seat, party in seats:\n        if alice_seats >= 2 * seat:\n            coalition.append(party)\n            alice_seats += seat\n            if alice_seats >= majority:\n                return coalition\n\n    return []\n\nn = int(input())\nseats = list(map(int, input().split()))\n\ncoalition = find_coalition(n, seats)\n\nif coalition:\n    print(len(coalition))\n    print(*coalition)\nelse:\n    print(0)"}
{"solution": "def max_reward(n):\n    harmonic_sum = 0.0\n    for i in range(1, n + 1):\n        harmonic_sum += 1.0 / i\n    return harmonic_sum\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the maximum reward\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "import math\n\ndef find_max_children(n):\n    k = int((math.sqrt(8 * n + 1) - 1) / 2)\n    remaining_candies = n - k * (k + 1) // 2\n    candies = list(range(1, k + 1))\n    candies[-1] += remaining_candies\n    return k, candies\n\nn = int(input())\nk, candies = find_max_children(n)\nprint(k)\nprint(*candies)"}
{"solution": "n = int(input())\nm = int(input())\n\nprint(m % (1 << n))"}
{"solution": "def correct_word(word):\n    vowels = set('aeiouy')\n    stack = []\n    \n    for char in word:\n        if char in vowels and stack and stack[-1] in vowels:\n            stack.pop()\n        else:\n            stack.append(char)\n    \n    return ''.join(stack)\n\nn = int(input())\nword = input()\n\nprint(correct_word(word))"}
{"solution": "def max_students(n, a, b, seats):\n    segments = []\n    i = 0\n    \n    # Identify segments of empty seats\n    while i < n:\n        if seats[i] == '.':\n            start = i\n            while i < n and seats[i] == '.':\n                i += 1\n            segments.append(i - start)\n        else:\n            i += 1\n    \n    total_students = 0\n    \n    # Place students in each segment\n    for length in segments:\n        # Calculate the number of students that can be placed in this segment\n        # We will place students in an alternating fashion\n        if a > b:\n            # Start with a student-programmer if more student-programmers are available\n            programmers = (length + 1) // 2\n            athletes = length // 2\n        else:\n            # Start with a student-athlete if more student-athletes are available\n            athletes = (length + 1) // 2\n            programmers = length // 2\n        \n        # Place the students\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n        \n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n    \n    return total_students\n\nn, a, b = map(int, input().split())\nseats = input()\nprint(max_students(n, a, b, seats))"}
{"solution": "import math\n\ndef find_xy(r):\n    for x in range(1, int(math.sqrt(r)) + 1):\n        discriminant = 4 * (r - x**2 - x - 1)\n        if discriminant >= 0:\n            y = (2 * x + 1 + math.sqrt(discriminant)) / 2\n            if y == int(y) and y > 0:\n                return x, int(y)\n    return None\n\nr = int(input())\nresult = find_xy(r)\nif result is None:\n    print(\"NO\")\nelse:\n    print(*result)"}
{"solution": "def divide_packets(n, packets):\n    total_balloons = sum(packets)\n    if n == 1 or total_balloons % 2 == 0 and len(set(packets)) == 1:\n        return -1\n\n    grigory_packets = []\n    andrew_packets = []\n    packets.sort(reverse=True)\n\n    for i, packet in enumerate(packets):\n        if sum(grigory_packets) <= sum(andrew_packets):\n            grigory_packets.append(packet)\n        else:\n            andrew_packets.append(packet)\n\n    if sum(grigory_packets) == sum(andrew_packets):\n        if len(grigory_packets) > 1:\n            andrew_packets.append(grigory_packets.pop())\n        elif len(andrew_packets) > 1:\n            grigory_packets.append(andrew_packets.pop())\n        else:\n            return -1\n\n    grigory_indices = [i + 1 for i, packet in enumerate(packets) if packet in grigory_packets]\n    return len(grigory_indices), grigory_indices\n\n\nn = int(input())\npackets = list(map(int, input().split()))\n\nresult = divide_packets(n, packets)\nif result == -1:\n    print(-1)\nelse:\n    print(result[0])\n    print(*result[1])"}
{"solution": "def min_diverse_digits(n):\n    if n < 10:\n        return [n]\n\n    for i in range(9, 0, -1):\n        if n % i == 0:\n            return [i] * (n // i)\n\n    for i in range(9, 0, -1):\n        if n > i and n % i!= 0:\n            return [i] + min_diverse_digits(n - i)\n\nn = int(input())\nresult = min_diverse_digits(n)\nprint(len(result))\nprint(*result)"}
{"solution": "def sieve_of_eratosthenes(n):\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n    p = 2\n    while p**2 <= n:\n        if primes[p]:\n            for i in range(p**2, n + 1, p):\n                primes[i] = False\n        p += 1\n    return primes\n\ndef is_prime(n, primes):\n    return primes[n]\n\ndef find_simple_subset(a, primes):\n    a.sort()\n    n = len(a)\n    max_size = 0\n    max_subset = []\n    for i in range(n):\n        subset = [a[i]]\n        for j in range(i + 1, n):\n            if is_prime(a[i] + a[j], primes):\n                subset.append(a[j])\n        if len(subset) > max_size:\n            max_size = len(subset)\n            max_subset = subset\n    return max_size, max_subset\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    primes = sieve_of_eratosthenes(2 * 10**6)\n    max_size, max_subset = find_simple_subset(a, primes)\n    print(max_size)\n    print(*max_subset)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef greatest_beautiful_divisor(n):\n    max_k = int(math.log2(math.sqrt(n)))\n    max_beautiful_divisor = 1\n\n    for k in range(max_k, 0, -1):\n        beautiful_number = (2 ** k - 1) ** 2\n        if n % beautiful_number == 0:\n            max_beautiful_divisor = beautiful_number\n            break\n\n    return max_beautiful_divisor\n\nn = int(input())\nprint(greatest_beautiful_divisor(n))"}
{"solution": "def count_magic_numbers(m, d, a, b):\n    MOD = 10**9 + 7\n    n = len(a)\n    dp = [[0] * m for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(m):\n            for k in range(10):\n                if i % 2 == 0 and k!= d:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD\n                elif i % 2 == 1 and k == d:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][(j - k * (10 ** (i - 1))) % m]) % MOD\n\n    def get_count(num):\n        res = 0\n        rem = 0\n        for i in range(n):\n            for j in range(int(num[i])):\n                if i % 2 == 0:\n                    res = (res + dp[n - i][rem]) % MOD\n                else:\n                    res = (res + dp[n - i][(rem - j * (10 ** (n - i - 1))) % m]) % MOD\n            rem = (rem + int(num[i]) * (10 ** (n - i - 1))) % m\n        return res\n\n    return (get_count(b) - get_count(a) + dp[n][0]) % MOD\n\n\nm, d = map(int, input().split())\na = input()\nb = input()\nprint(count_magic_numbers(m, d, a, b))"}
{"solution": "from collections import deque\n\ndef last_child(n, m, candies):\n    queue = deque(range(1, n + 1))\n    index = 0\n    while queue:\n        child = queue.popleft()\n        candies[index] -= m\n        if candies[index] > 0:\n            queue.append(child)\n        index = (index + 1) % n\n    return child\n\nn, m = map(int, input().split())\ncandies = list(map(int, input().split()))\nprint(last_child(n, m, candies))"}
{"solution": "def min_bills(n):\n    denominations = [100, 20, 10, 5, 1]\n    bills = 0\n\n    for denomination in denominations:\n        bills += n // denomination\n        n %= denomination\n\n    return bills\n\nn = int(input())\nprint(min_bills(n))"}
{"solution": "MOD = 1000000007\n\ndef count_permutations(n, k):\n    if k > n or (n - k) % 2!= 0:\n        return 0\n\n    dp = [[[0 for _ in range(k + 1)] for _ in range(n + 1)] for _ in range(2)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(min(i, k) + 1):\n            dp[i % 2][i][j] = dp[(i - 1) % 2][i - 1][j]\n            if j > 0:\n                dp[i % 2][i][j] += dp[(i - 1) % 2][i - 1][j - 1]\n            if i >= 2 and j > 0:\n                dp[i % 2][i][j] += dp[(i - 1) % 2][i - 2][j - 1]\n            dp[i % 2][i][j] %= MOD\n\n    return dp[n % 2][n][k]\n\nn, k = map(int, input().split())\nprint(count_permutations(n, k))"}
{"solution": "import sys\n\ndef read_input():\n    n, k = map(int, sys.stdin.readline().split())\n    beauty = list(map(int, sys.stdin.readline().split()))\n    colors = sys.stdin.readline().strip()\n    return n, k, beauty, colors\n\ndef solve(n, k, beauty, colors):\n    roses = {'R': [], 'O': [], 'W': []}\n    for i in range(n):\n        roses[colors[i]].append(beauty[i])\n\n    for color in roses:\n        roses[color].sort(reverse=True)\n\n    max_beauty = -1\n    for color1 in roses:\n        for color2 in roses:\n            if color1 == color2:\n                continue\n            if len(roses[color1]) + len(roses[color2]) < k:\n                continue\n            if len(roses[color1]) < k // 2 + k % 2 or len(roses[color2]) < k // 2:\n                continue\n            beauty1 = sum(roses[color1][:k // 2 + k % 2])\n            beauty2 = sum(roses[color2][:k // 2])\n            max_beauty = max(max_beauty, beauty1 + beauty2)\n\n    return max_beauty\n\ndef main():\n    n, k, beauty, colors = read_input()\n    max_beauty = solve(n, k, beauty, colors)\n    print(max_beauty)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef simplify_fraction(numerator, denominator):\n    common_divisor = gcd(numerator, denominator)\n    return numerator // common_divisor, denominator // common_divisor\n\ndef evaluate_continued_fraction(coefficients):\n    numerator, denominator = coefficients[-1], 1\n    for coefficient in reversed(coefficients[:-1]):\n        numerator, denominator = coefficient * numerator + denominator, numerator\n    return numerator, denominator\n\ndef main():\n    p, q = map(int, input().split())\n    n = int(input())\n    coefficients = list(map(int, input().split()))\n\n    p, q = simplify_fraction(p, q)\n    cf_numerator, cf_denominator = evaluate_continued_fraction(coefficients)\n    cf_numerator, cf_denominator = simplify_fraction(cf_numerator, cf_denominator)\n\n    print(\"YES\" if (p, q) == (cf_numerator, cf_denominator) else \"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_sticks(expression):\n    sticks = expression.replace('+','').replace('=','').split()\n    return [len(stick) for stick in sticks]\n\ndef is_correct(expression):\n    sticks = count_sticks(expression)\n    return sticks[0] + sticks[1] == sticks[2]\n\ndef shift_stick(expression, from_index, to_index):\n    sticks = expression.replace('+','').replace('=','').split()\n    stick = sticks[from_index][-1]\n    sticks[from_index] = sticks[from_index][:-1]\n    sticks[to_index] += stick\n    return ''.join(sticks).replace(' ', '+').replace('=', '=')\n\ndef solve(expression):\n    if is_correct(expression):\n        return expression\n\n    for i in range(3):\n        for j in range(3):\n            if i!= j:\n                new_expression = shift_stick(expression, i, j)\n                if is_correct(new_expression):\n                    return new_expression\n\n    return \"Impossible\"\n\nexpression = input()\nprint(solve(expression))"}
{"solution": "MOD = 10**9 + 7\n\ndef main():\n    n, k = map(int, input().split())\n    dp = [[[0] * (n * n + 1) for _ in range(n + 1)] for _ in range(2)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            for oddness in range(i * i + 1):\n                if oddness - j >= 0:\n                    dp[i % 2][j][oddness] = (dp[i % 2][j][oddness] + dp[(i - 1) % 2][j][oddness - j]) % MOD\n                if j > 0 and oddness - (i - j) >= 0:\n                    dp[i % 2][j][oddness] = (dp[i % 2][j][oddness] + dp[(i - 1) % 2][j - 1][oddness - (i - j)]) % MOD\n\n    print(dp[n % 2][n][k])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": ""}
{"solution": "import re\n\nn = int(input())\ns = input()\n\npattern = r'ogo(go)*'\ns = re.sub(pattern, '***', s)\n\nprint(s)"}
{"solution": "def prime_factors(n):\n    \"\"\"Returns a dictionary of prime factors and their powers\"\"\"\n    factors = {}\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors[i] = factors.get(i, 0) + 1\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef g(y, p):\n    \"\"\"Returns the maximum possible integer p^k where k is an integer such that y is divisible by p^k\"\"\"\n    k = 0\n    while y % p == 0:\n        y //= p\n        k += 1\n    return p ** k\n\ndef f(x, y):\n    \"\"\"Returns the product of g(y, p) for all p in prime(x)\"\"\"\n    factors = prime_factors(x)\n    result = 1\n    for p in factors:\n        result = (result * g(y, p)) % (10**9 + 7)\n    return result\n\ndef main():\n    x, n = map(int, input().split())\n    factors = prime_factors(x)\n    result = 1\n    for p in factors:\n        k = factors[p]\n        sum_p_k = (p ** k * (n // p ** k) + (p ** (k - 1) * (n // p ** (k - 1)) - (p ** k * (n // p ** k))) % (10**9 + 7)\n        result = (result * sum_p_k) % (10**9 + 7)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = set()\n    for s in range(1, 82):  # s(x) can be at most 81\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and sum_of_digits(x) == s:\n            solutions.add(x)\n    return sorted(list(solutions))\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find solutions\nsolutions = find_solutions(a, b, c)\n\n# Print results\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "def is_solved(face):\n    return len(set(face)) == 1\n\ndef is_possible_to_solve(cube):\n    for i in range(0, 24, 4):\n        face = cube[i:i+4]\n        if is_solved(face):\n            return True\n\n    for i in range(4):\n        face = [cube[i], cube[i+4], cube[i+8], cube[i+12]]\n        if is_solved(face):\n            return True\n\n    for i in range(4):\n        face = [cube[i], cube[i+4], cube[i+8], cube[i+12]]\n        face = [face[0], face[3], face[2], face[1]]\n        if is_solved(face):\n            return True\n\n    for i in range(4):\n        face = [cube[i], cube[i+4], cube[i+8], cube[i+12]]\n        face = [face[0], face[2], face[3], face[1]]\n        if is_solved(face):\n            return True\n\n    return False\n\ncube = list(map(int, input().split()))\nif is_possible_to_solve(cube):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def calculate_score(s):\n    i = (s // 50) % 475\n    scores = set()\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        scores.add(26 + i)\n    return scores\n\ndef main():\n    p, x, y = map(int, input().split())\n    min_hacks = float('inf')\n    for s in range(x, y + 1):\n        scores = calculate_score(s)\n        if p in scores:\n            hacks = (s - x + 99) // 100\n            min_hacks = min(min_hacks, hacks)\n    print(min_hacks)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nif n == 1:\n    print(0)\nelse:\n    distances = [a + b, a + c, b + c]\n    min_distance = min(distances)\n    if n % 2 == 0:\n        print(min_distance * (n // 2))\n    else:\n        print(min_distance * ((n - 1) // 2) + min(a, b, c))"}
{"solution": "def min_distance(x1, x2, x3):\n    \"\"\"\n    Calculate the minimum total distance three friends need to travel to meet at a point.\n\n    Args:\n        x1 (int): The coordinate of the first friend's house.\n        x2 (int): The coordinate of the second friend's house.\n        x3 (int): The coordinate of the third friend's house.\n\n    Returns:\n        int: The minimum total distance the friends need to travel.\n    \"\"\"\n    # Sort the coordinates in ascending order\n    coordinates = sorted([x1, x2, x3])\n    \n    # The optimal meeting point is the middle coordinate\n    meeting_point = coordinates[1]\n    \n    # Calculate the total distance\n    total_distance = abs(x1 - meeting_point) + abs(x2 - meeting_point) + abs(x3 - meeting_point)\n    \n    return total_distance\n\n# Read the input coordinates\nx1, x2, x3 = map(int, input().split())\n\n# Calculate and print the minimum total distance\nprint(min_distance(x1, x2, x3))"}
{"solution": "def solve():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    seen = set()\n    ans = float('inf')\n\n    for i in a:\n        if i & x in seen:\n            ans = 0\n            break\n        seen.add(i & x)\n\n    if ans == 0:\n        print(ans)\n        return\n\n    for i in a:\n        j = i & x\n        while j!= i:\n            if j in seen:\n                ans = min(ans, 1)\n                break\n            j = j & x\n            if j == 0:\n                break\n\n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nsolve()"}
{"solution": "def check_plus(grid, center):\n    h, w = len(grid), len(grid[0])\n    cx, cy = center\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    lengths = [0, 0, 0, 0]\n\n    for i, (dx, dy) in enumerate(directions):\n        x, y = cx + dx, cy + dy\n        while 0 <= x < h and 0 <= y < w and grid[x][y] == '*':\n            lengths[i] += 1\n            x += dx\n            y += dy\n\n    if lengths[0]!= lengths[1] or lengths[2]!= lengths[3]:\n        return False\n\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*':\n                if (i, j) == center:\n                    continue\n                if abs(i - cx)!= abs(j - cy):\n                    return False\n                if abs(i - cx) > lengths[0]:\n                    return False\n\n    return True\n\n\ndef solve():\n    h, w = map(int, input().split())\n    grid = [list(input()) for _ in range(h)]\n\n    centers = [(i, j) for i in range(h) for j in range(w) if grid[i][j] == '*']\n\n    if len(centers) == 0:\n        print(\"NO\")\n        return\n\n    for center in centers:\n        if check_plus(grid, center):\n            print(\"YES\")\n            return\n\n    print(\"NO\")\n\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def solve(n, a, b):\n    if a == 1 and b == 1:\n        return \"NO\"\n    if a == 1:\n        return [[1 if i!= j else 0 for j in range(n)] for i in range(n)]\n    if b == 1:\n        return [[0 if i!= j else 0 for j in range(n)] for i in range(n)]\n    if a + b > n + 1:\n        return \"NO\"\n    if a > b:\n        return solve(n, b, a)\n    matrix = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(a - 1):\n        for j in range(i + 1, a):\n            matrix[i][j] = matrix[j][i] = 1\n    for i in range(a, a + b - 1):\n        for j in range(i + 1, a + b):\n            matrix[i][j] = matrix[j][i] = 1\n    return matrix\n\ndef print_matrix(matrix):\n    if matrix == \"NO\":\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for row in matrix:\n            print(\"\".join(map(str, row)))\n\nn, a, b = map(int, input().split())\nprint_matrix(solve(n, a, b))"}
{"solution": "def min_problems(c, d, n, m, k):\n    \"\"\"\n    Calculate the minimum number of problems needed for the finals.\n\n    Args:\n    c (int): Number of problems in the main elimination rounds.\n    d (int): Number of problems in the additional elimination rounds.\n    n (int): Number of winners in each main elimination round.\n    m (int): Number of main elimination rounds.\n    k (int): Number of pre-chosen winners.\n\n    Returns:\n    int: Minimum number of problems needed for the finals.\n    \"\"\"\n    total_winners_needed = n * m - k\n    if total_winners_needed <= 0:\n        return 0\n\n    main_rounds = total_winners_needed // n\n    additional_winners_needed = total_winners_needed % n\n\n    main_problems = main_rounds * c\n    additional_problems = additional_winners_needed * d\n\n    # If we have enough main rounds to cover all winners, use main rounds\n    if main_rounds > 0 and additional_winners_needed <= n:\n        return main_problems\n\n    # If we need additional rounds, use them\n    if additional_winners_needed > 0:\n        return main_problems + additional_problems\n\n    # If we don't need any additional rounds, use the minimum number of main rounds\n    return (total_winners_needed + n - 1) // n * c\n\n\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\nprint(min_problems(c, d, n, m, k))"}
{"solution": "from collections import defaultdict\n\ndef find_grid(s):\n    graph = defaultdict(list)\n    for i in range(26):\n        for j in range(i + 1, 26):\n            if abs(i - j) == 1 or abs(i - j) == 13:\n                graph[chr(65 + i)].append(chr(65 + j))\n                graph[chr(65 + j)].append(chr(65 + i))\n\n    def dfs(node, path):\n        if len(path) == 27:\n            return path\n        for neighbor in graph[node]:\n            if neighbor not in path:\n                new_path = dfs(neighbor, path + neighbor)\n                if new_path:\n                    return new_path\n        return None\n\n    for i in range(26):\n        path = dfs(chr(65 + i), chr(65 + i))\n        if path and path == s:\n            grid = [[''for _ in range(13)] for _ in range(2)]\n            for i, char in enumerate(path):\n                grid[i // 13][i % 13] = char\n            return '\\n'.join(''.join(row) for row in grid)\n\n    return \"Impossible\"\n\ns = input()\nprint(find_grid(s))"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<' if y > 1 else '='\n    elif y == 1:\n        return '>' if x > 1 else '='\n    else:\n        # Compute y * log(x) and x * log(y)\n        lhs = y * math.log(x)\n        rhs = x * math.log(y)\n        \n        if lhs < rhs:\n            return '<'\n        elif lhs > rhs:\n            return '>'\n        else:\n            return '='\n\n# Read input\nx, y = map(int, input().split())\n\n# Output the result of the comparison\nprint(compare_powers(x, y))"}
{"solution": "import math\n\ndef calculate_max_balloons():\n    r, h = map(int, input().split())\n    max_balloons_in_height = math.floor((h + r) / r)\n    max_balloons_in_width = math.floor((2 * r) / r)\n    max_balloons_in_arc = math.floor(math.pi * r / (2 * (r / 2)))\n    max_balloons = max_balloons_in_height * max_balloons_in_width + max_balloons_in_arc\n    return max_balloons\n\nprint(calculate_max_balloons())"}
{"solution": "import sys\n\n# Read input from stdin\nnumbers = list(map(int, sys.stdin.readline().split()))\n\n# Sort the numbers in ascending order\nnumbers.sort()\n\n# Initialize minimum sum\nmin_sum = sum(numbers)\n\n# Check if we can discard two or three cards with the same number\nif numbers[0] == numbers[2]:\n    min_sum = min(min_sum, sum(numbers[3:]))\nelif numbers[1] == numbers[3]:\n    min_sum = min(min_sum, sum(numbers[0:1] + numbers[4:]))\nelif numbers[2] == numbers[4]:\n    min_sum = min(min_sum, sum(numbers[0:2]))\n\n# Print the minimum sum\nprint(min_sum)"}
{"solution": "import sys\n\ndef main():\n    n, a = map(int, sys.stdin.readline().split())\n    x = list(map(int, sys.stdin.readline().split()))\n\n    x.sort()\n    idx = x.index(min(x, key=lambda x: abs(x - a)))\n\n    dist = 0\n    if idx < n - 1:\n        dist += x[n - 1] - a\n        for i in range(idx, n - 1):\n            dist += x[i + 1] - x[i]\n    else:\n        dist += a - x[0]\n        for i in range(idx - 1, 0, -1):\n            dist += x[i] - x[i - 1]\n\n    print(dist)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def sum_of_digits(x):\n    \"\"\"Calculate the sum of digits of a number.\"\"\"\n    return sum(int(digit) for digit in str(x))\n\ndef solve_equation(n):\n    \"\"\"Find the smallest positive integer root of the equation x^2 + s(x)*x - n = 0.\"\"\"\n    x = 1\n    while True:\n        s_x = sum_of_digits(x)\n        if x**2 + s_x*x - n == 0:\n            return x\n        elif x**2 + s_x*x > n:\n            return -1\n        x += 1\n\nn = int(input())\nprint(solve_equation(n))"}
{"solution": "def calculate_bed_time(current_time, sleep_time):\n    current_hours, current_minutes = map(int, current_time.split(':'))\n    sleep_hours, sleep_minutes = map(int, sleep_time.split(':'))\n\n    total_minutes = current_hours * 60 + current_minutes - (sleep_hours * 60 + sleep_minutes)\n    if total_minutes < 0:\n        total_minutes += 24 * 60\n\n    bed_hours = total_minutes // 60 % 24\n    bed_minutes = total_minutes % 60\n\n    return f\"{bed_hours:02d}:{bed_minutes:02d}\"\n\ncurrent_time = input()\nsleep_time = input()\n\nprint(calculate_bed_time(current_time, sleep_time))"}
{"solution": "def max_subsegment_length(n, a):\n    max_sum = float('-inf')\n    current_sum = 0\n    max_length = 0\n    current_length = 0\n\n    for num in a:\n        if current_sum <= 0:\n            current_sum = num\n            current_length = 1\n        else:\n            current_sum += num\n            current_length += 1\n\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_length = current_length\n        elif current_sum == max_sum:\n            max_length = max(max_length, current_length)\n\n    return max_length\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nprint(max_subsegment_length(n, a))"}
{"solution": "MOD = 998244353\n\ndef main():\n    n, m, k = map(int, input().split())\n\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[1][0] = m\n\n    for i in range(2, n + 1):\n        for j in range(min(i, k) + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] * (m - 1) % MOD\n            elif j == i - 1:\n                dp[i][j] = dp[i - 1][j - 1] * m % MOD\n            else:\n                dp[i][j] = (dp[i - 1][j - 1] * m + dp[i - 1][j] * (m - 1)) % MOD\n\n    ans = 0\n    for i in range(k + 1):\n        ans = (ans + dp[n][i]) % MOD\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import re\n\ndef is_magic_number(n):\n    pattern = re.compile(r'^(1|14|144)+$')\n    if pattern.match(str(n)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\nn = int(input())\nprint(is_magic_number(n))"}
{"solution": "import math\n\ndef min_moves(n, m, i, j, a, b):\n    moves = []\n\n    # Calculate moves to reach top-right corner\n    moves.append(math.ceil((i - 1) / a) + math.ceil((m - j) / b))\n\n    # Calculate moves to reach bottom-left corner\n    moves.append(math.ceil((n - i) / a) + math.ceil((j - 1) / b))\n\n    # Calculate moves to reach bottom-right corner\n    moves.append(math.ceil((n - i) / a) + math.ceil((m - j) / b))\n\n    # Calculate moves to reach top-left corner\n    moves.append(math.ceil((i - 1) / a) + math.ceil((j - 1) / b))\n\n    # Check if it's possible to reach any corner\n    if all(move == float('inf') for move in moves):\n        return \"Poor Inna and pony!\"\n\n    return min(moves)\n\nn, m, i, j, a, b = map(int, input().split())\nprint(min_moves(n, m, i, j, a, b))"}
{"solution": "def max_removals(s):\n    n = len(s)\n    dp = [[0] * 26 for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(26):\n            if j == ord(s[i - 1]) - ord('a'):\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + 1)\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return max(dp[n])\n\nn = int(input())\ns = input()\nprint(max_removals(s))"}
{"solution": "import sys\n\ndef min_bills(n, k, denominations, q, requests):\n    results = []\n    for request in requests:\n        min_bills = float('inf')\n        for i in range(n):\n            for j in range(i, n):\n                bills = 0\n                remaining = request\n                while remaining > 0 and bills <= k:\n                    if remaining >= denominations[j]:\n                        remaining -= denominations[j]\n                        bills += 1\n                    elif remaining >= denominations[i]:\n                        remaining -= denominations[i]\n                        bills += 1\n                    else:\n                        break\n                if remaining == 0 and bills < min_bills:\n                    min_bills = bills\n        if min_bills == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_bills)\n    return results\n\nn, k = map(int, sys.stdin.readline().split())\ndenominations = list(map(int, sys.stdin.readline().split()))\nq = int(sys.stdin.readline())\nrequests = [int(sys.stdin.readline()) for _ in range(q)]\n\nresults = min_bills(n, k, denominations, q, requests)\nfor result in results:\n    print(result)"}
{"solution": "import math\n\ndef calculate_time(s, x1, x2, t1, t2, p, d):\n    # Calculate the time it takes for Igor to walk from x1 to x2\n    walk_time = abs(x2 - x1) * t2\n\n    # Calculate the time it takes for the tram to reach x1\n    tram_time_to_x1 = abs(p - x1) * t1\n\n    # Calculate the time it takes for the tram to reach x2 after reaching x1\n    tram_time_to_x2 = abs(x2 - x1) * t1\n\n    # Calculate the total time it takes for Igor to take the tram\n    tram_time = tram_time_to_x1 + tram_time_to_x2\n\n    # If the tram is moving in the opposite direction, add the time it takes for the tram to turn around\n    if d == -1 and x1 < x2:\n        tram_time += 2 * s * t1\n    elif d == 1 and x1 > x2:\n        tram_time += 2 * s * t1\n\n    # Calculate the time it takes for Igor to take the tram and walk\n    tram_walk_time = tram_time_to_x1 + (s - max(x1, p)) * t1 + (s - x2) * t2\n\n    # Return the minimum time\n    return min(walk_time, tram_time, tram_walk_time)\n\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\nprint(calculate_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "import math\n\ndef count_cells(n, x):\n    count = 0\n    for i in range(1, min(n, int(math.sqrt(x))) + 1):\n        if x % i == 0:\n            j = x // i\n            if j <= n:\n                if i!= j:\n                    count += 2\n                else:\n                    count += 1\n    return count\n\nn, x = map(int, input().split())\nprint(count_cells(n, x))"}
{"solution": "import string\n\nn, k = map(int, input().split())\npassword = string.ascii_lowercase[:k]\n\nif k == 2:\n    print((password[0] * (n // 2) + password[1] * (n // 2 + n % 2)).rstrip(password[0]))\nelse:\n    print((password * (n // k) + password[:n % k]).rstrip(password[0]))"}
{"solution": "n = int(input())\ndirections = input()\npositions = list(map(int, input().split()))\n\nmin_time = float('inf')\ncollision_found = False\n\nfor i in range(n - 1):\n    if directions[i] == 'R' and directions[i + 1] == 'L':\n        collision_time = (positions[i + 1] - positions[i]) // 2\n        min_time = min(min_time, collision_time)\n        collision_found = True\n\nif collision_found:\n    print(min_time)\nelse:\n    print(-1)"}
{"solution": "import sys\n\ndef max_area(seals, a, b):\n    max_area = 0\n    for i in range(len(seals)):\n        for j in range(i + 1, len(seals)):\n            area1 = seals[i][0] * seals[i][1]\n            area2 = seals[j][0] * seals[j][1]\n            if seals[i][0] <= a and seals[j][0] <= a and seals[i][1] + seals[j][1] <= b:\n                max_area = max(max_area, area1 + area2)\n            if seals[i][0] <= a and seals[j][1] <= a and seals[i][1] + seals[j][0] <= b:\n                max_area = max(max_area, area1 + area2)\n            if seals[i][1] <= a and seals[j][0] <= a and seals[i][0] + seals[j][1] <= b:\n                max_area = max(max_area, area1 + area2)\n            if seals[i][1] <= a and seals[j][1] <= a and seals[i][0] + seals[j][0] <= b:\n                max_area = max(max_area, area1 + area2)\n            if seals[i][0] <= b and seals[j][0] <= b and seals[i][1] + seals[j][1] <= a:\n                max_area = max(max_area, area1 + area2)\n            if seals[i][0] <= b and seals[j][1] <= b and seals[i][1] + seals[j][0] <= a:\n                max_area = max(max_area, area1 + area2)\n            if seals[i][1] <= b and seals[j][0] <= b and seals[i][0] + seals[j][1] <= a:\n                max_area = max(max_area, area1 + area2)\n            if seals[i][1] <= b and seals[j][1] <= b and seals[i][0] + seals[j][0] <= a:\n                max_area = max(max_area, area1 + area2)\n    return max_area\n\nn, a, b = map(int, sys.stdin.readline().split())\nseals = []\nfor _ in range(n):\n    x, y = map(int, sys.stdin.readline().split())\n    seals.append((x, y))\n\nprint(max_area(seals, a, b))"}
{"solution": "def find_outlier_point(n, points):\n    \"\"\"\n    Find the point that does not lie on the boundary of an axis-aligned square.\n\n    Args:\n    n (int): The number of points on each side of the square.\n    points (list): A list of tuples representing the coordinates of the points.\n\n    Returns:\n    tuple: The coordinates of the point that is not on the boundary of the square.\n    \"\"\"\n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n\n    # Find the minimum and maximum x and y coordinates\n    min_x = min(x_coords)\n    max_x = max(x_coords)\n    min_y = min(y_coords)\n    max_y = max(y_coords)\n\n    # Initialize counters for points on each side of the square\n    left_side = 0\n    right_side = 0\n    top_side = 0\n    bottom_side = 0\n\n    # Count points on each side of the square\n    for point in points:\n        if point[0] == min_x:\n            left_side += 1\n        elif point[0] == max_x:\n            right_side += 1\n        if point[1] == min_y:\n            bottom_side += 1\n        elif point[1] == max_y:\n            top_side += 1\n\n    # Find the side with less than n points\n    if left_side < n:\n        return (min_x, max_y)\n    elif right_side < n:\n        return (max_x, max_y)\n    elif top_side < n:\n        return (max_x, max_y)\n    elif bottom_side < n:\n        return (max_x, min_y)\n\n    # If no side has less than n points, find the point that is not on the boundary\n    for point in points:\n        if point[0]!= min_x and point[0]!= max_x and point[1]!= min_y and point[1]!= max_y:\n            return point\n\n\n# Read input\nn = int(input())\npoints = []\nfor _ in range(4 * n + 1):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\n# Find and print the outlier point\noutlier_point = find_outlier_point(n, points)\nprint(outlier_point[0], outlier_point[1])"}
{"solution": "import math\n\ndef digit_product(n):\n    if n < 10:\n        return n\n    max_product = 1\n    for i in range(9, 1, -1):\n        while n % i == 0:\n            max_product *= i\n            n //= i\n    if n > 1:\n        max_product *= n\n    return max_product\n\ndef main():\n    n = int(input())\n    max_product = 1\n    for i in range(1, 10):\n        max_product = max(max_product, digit_product(n // i * i))\n    print(max_product)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_smallest_k(n, votes):\n    \"\"\"\n    Find the smallest k that guarantees Awruk's win.\n\n    Args:\n    n (int): The number of students in the school.\n    votes (list): A list of votes each student gives to Elodreip.\n\n    Returns:\n    int: The smallest k that guarantees Awruk's win.\n    \"\"\"\n    # Calculate the total votes for Elodreip\n    total_votes_elodreip = sum(votes)\n\n    # Initialize k as the maximum vote\n    k = max(votes)\n\n    # Calculate the total votes for Awruk\n    total_votes_awruk = sum(k - vote for vote in votes)\n\n    # While Awruk's votes are not more than Elodreip's votes, increment k\n    while total_votes_awruk <= total_votes_elodreip:\n        k += 1\n        total_votes_awruk = sum(k - vote for vote in votes)\n\n    return k\n\n\n# Read the number of students\nn = int(input())\n\n# Read the votes for Elodreip\nvotes = list(map(int, input().split()))\n\n# Find and print the smallest k\nprint(find_smallest_k(n, votes))"}
{"solution": "def min_operations(s):\n    stack = []\n    operations = 0\n\n    for color in s:\n        if stack and stack[-1][0]!= color:\n            while stack and stack[-1][0]!= color:\n                stack.pop()\n            if stack:\n                stack[-1][1] += 1\n            else:\n                stack.append([color, 1])\n        else:\n            if stack and stack[-1][0] == color:\n                stack[-1][1] += 1\n            else:\n                stack.append([color, 1])\n\n        if len(stack) > 1 and stack[-1][1] == 1 and stack[-2][1] == 1:\n            stack.pop()\n            stack.pop()\n            operations += 1\n\n    return operations\n\n\ns = input()\nprint(min_operations(s))"}
{"solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n\n    min_product = a[0] * a[1] * a[2]\n    min_product_count = 1\n\n    for i in range(3, n):\n        if a[0] * a[1] * a[i] == min_product:\n            min_product_count += 1\n        elif a[0] * a[1] * a[i] < min_product:\n            min_product = a[0] * a[1] * a[i]\n            min_product_count = 1\n\n    if a[0] == a[1] == a[2]:\n        print((n - 2) * (n - 1) * n // 6)\n    elif a[0] == a[1]:\n        print((n - 2) * (n - 1) // 2)\n    else:\n        print(min_product_count)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef min_cuts(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 2\n    elif n == 4:\n        return 5\n    else:\n        return math.ceil(math.sqrt(n + 1))\n\nn = int(input())\nprint(min_cuts(n))"}
{"solution": "def maximize_balance(n):\n    n_str = str(n)\n    if n_str[0] == '-':\n        if len(n_str) > 2 and int(n_str[-1]) > int(n_str[-2]):\n            return int(n_str[:-1])\n        elif len(n_str) > 2 and int(n_str[-1]) < int(n_str[-2]):\n            return int(n_str[:-2] + n_str[-1])\n        else:\n            return 0\n    else:\n        if len(n_str) > 1 and int(n_str[-1]) == 0:\n            return int(n_str[:-1])\n        else:\n            return n\n\nn = int(input())\nprint(maximize_balance(n))"}
{"solution": "def spinner_direction():\n    positions = ['v', '<', '^', '>']\n    start, end = input().split()\n    n = int(input())\n\n    start_index = positions.index(start)\n    end_index = positions.index(end)\n\n    clockwise_diff = (end_index - start_index) % 4\n    counter_clockwise_diff = (start_index - end_index) % 4\n\n    if n % 4 == clockwise_diff:\n        return 'cw'\n    elif n % 4 == counter_clockwise_diff:\n        return 'ccw'\n    else:\n        return 'undefined'\n\nprint(spinner_direction())"}
{"solution": "def count_vertical_dominoes(n, s):\n    \"\"\"\n    Calculate the number of dominoes left standing vertically at the end of the process.\n\n    Args:\n    n (int): The number of dominoes in the line.\n    s (str): A character string representing the initial directions of the dominoes.\n\n    Returns:\n    int: The number of dominoes left standing vertically.\n    \"\"\"\n    count = 0\n    i = 0\n    while i < n:\n        if s[i] == '.':\n            j = i + 1\n            while j < n and s[j] == '.':\n                j += 1\n            if j == n:\n                count += n - i\n                break\n            if (j - i) % 2 == 1:\n                count += (j - i) // 2 + 1\n            else:\n                count += (j - i) // 2\n            i = j\n        else:\n            i += 1\n    return count\n\nn = int(input())\ns = input()\nprint(count_vertical_dominoes(n, s))"}
{"solution": "def restore_permutation(n, leaders):\n    permutation = [0] * n\n    for i in range(n):\n        permutation[i] = i + 1\n\n    for i in range(len(leaders) - 1):\n        leader_index = leaders[i] - 1\n        next_leader_index = leaders[i + 1] - 1\n        diff = (next_leader_index - leader_index) % n\n        if diff == 0:\n            diff = n\n        permutation[leader_index] = diff\n\n    if leaders[-1]!= 1 and permutation[leaders[-1] - 1] == n:\n        return -1\n\n    return permutation\n\n\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\nresult = restore_permutation(n, leaders)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def max_number(a, k):\n    a = list(str(a))\n    n = len(a)\n    max_a = a[:]\n    swaps = 0\n\n    for i in range(n):\n        max_digit = a[i]\n        max_index = i\n\n        for j in range(i + 1, min(i + k + 1, n)):\n            if a[j] > max_digit:\n                max_digit = a[j]\n                max_index = j\n\n        if max_index!= i:\n            a[i], a[max_index] = a[max_index], a[i]\n            swaps += max_index - i\n            k -= max_index - i\n\n            if swaps == k:\n                break\n\n    return ''.join(a)\n\n\na, k = input().split()\na, k = int(a), int(k)\nprint(max_number(a, k))"}
{"solution": "def is_arithmetic_progression(sequence):\n    \"\"\"Check if a sequence is an arithmetic progression.\"\"\"\n    diff = sequence[1] - sequence[0]\n    for i in range(2, len(sequence)):\n        if sequence[i] - sequence[i-1]!= diff:\n            return False\n    return True\n\n\ndef is_geometric_progression(sequence):\n    \"\"\"Check if a sequence is a geometric progression.\"\"\"\n    ratio = sequence[1] / sequence[0]\n    for i in range(2, len(sequence)):\n        if sequence[i] / sequence[i-1]!= ratio:\n            return False\n    return True\n\n\ndef next_arithmetic_progression(sequence):\n    \"\"\"Find the next element in an arithmetic progression.\"\"\"\n    diff = sequence[1] - sequence[0]\n    return sequence[-1] + diff\n\n\ndef next_geometric_progression(sequence):\n    \"\"\"Find the next element in a geometric progression.\"\"\"\n    ratio = sequence[1] / sequence[0]\n    return sequence[-1] * ratio\n\n\ndef main():\n    sequence = list(map(int, input().split()))\n    \n    if is_arithmetic_progression(sequence):\n        next_element = next_arithmetic_progression(sequence)\n        if next_element == int(next_element):\n            print(int(next_element))\n        else:\n            print(42)\n    elif is_geometric_progression(sequence):\n        next_element = next_geometric_progression(sequence)\n        if next_element == int(next_element):\n            print(int(next_element))\n        else:\n            print(42)\n    else:\n        print(42)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_distance(n, colors):\n    # Find the first and last occurrence of each color\n    first_occurrence = {}\n    last_occurrence = {}\n    \n    for i in range(n):\n        color = colors[i]\n        if color not in first_occurrence:\n            first_occurrence[color] = i\n        last_occurrence[color] = i\n    \n    # Get the list of unique colors\n    unique_colors = list(first_occurrence.keys())\n    \n    # Calculate the maximum distance\n    max_dist = 0\n    \n    # Compare distances from the first house to the last house of a different color\n    for color in unique_colors:\n        if colors[0]!= color:\n            max_dist = max(max_dist, last_occurrence[color])\n        if colors[-1]!= color:\n            max_dist = max(max_dist, n - 1 - first_occurrence[color])\n    \n    # Check if the maximum distance can be obtained by walking from the first house of a color to the last house of the same color\n    for color in unique_colors:\n        max_dist = max(max_dist, last_occurrence[color] - first_occurrence[color])\n    \n    return max_dist\n\nn = int(input())\ncolors = list(map(int, input().split()))\nprint(max_distance(n, colors))"}
{"solution": "n, m, k = map(int, input().split())\n\nlane = (k - 1) // (2 * m) + 1\ndesk = ((k - 1) % (2 * m)) // 2 + 1\nside = 'L' if (k - 1) % 2 == 0 else 'R'\n\nprint(lane, desk, side)"}
{"solution": "def possible_final_colors(n, s):\n    color_counts = {'B': 0, 'G': 0, 'R': 0}\n    for color in s:\n        color_counts[color] += 1\n\n    possible_colors = set()\n    for color, count in color_counts.items():\n        if count % 2!= 0:\n            possible_colors.add(color)\n\n    if len(possible_colors) == 0:\n        possible_colors = set('BGR')\n\n    return ''.join(sorted(possible_colors))\n\nn = int(input())\ns = input()\nprint(possible_final_colors(n, s))"}
