{"solution": "def max_accordion_length(s):\n    max_length = -1\n    opening_bracket_index = -1\n    for i, char in enumerate(s):\n        if char == '[':\n            opening_bracket_index = i\n        elif char == ':':\n            if opening_bracket_index!= -1:\n                max_length = max(max_length, 4)\n                colon_index = i\n                max_vertical_lines = 0\n                for j in range(colon_index + 1, len(s)):\n                    if s[j] == '|':\n                        max_vertical_lines += 1\n                    elif s[j] == ':':\n                        max_length = max(max_length, 4 + 2 * max_vertical_lines)\n                        break\n                    elif s[j] == ']':\n                        max_length = max(max_length, 4 + max_vertical_lines)\n                        break\n    return max_length\n\ns = input()\nprint(max_accordion_length(s))"}
{"solution": "def digit_sum(n):\n    return sum(int(digit) for digit in str(n))\n\ndef largest_digit_sum(x):\n    max_sum = 0\n    max_num = 0\n    for i in range(x, 0, -1):\n        current_sum = digit_sum(i)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_num = i\n    return max_num\n\nx = int(input())\nprint(largest_digit_sum(x))"}
{"solution": "def count_digits(n):\n    return len(str(n))\n\ndef is_lucky(n):\n    count = 0\n    for digit in str(n):\n        if digit!= '0':\n            count += 1\n        if count > 1:\n            return False\n    return True\n\nn = int(input())\nwhile True:\n    n += 1\n    if is_lucky(n):\n        print(n - int(input()))\n        break"}
{"solution": ""}
{"solution": "def is_lucky(time):\n    return '7' in time\n\ndef prev_time(time, x):\n    h, m = map(int, time.split(':'))\n    m -= x\n    if m < 0:\n        h -= 1\n        m += 60\n    if h < 0:\n        h += 24\n    return f'{h:02d}:{m:02d}'\n\nx = int(input())\ntime = input()\nif is_lucky(time):\n    print(0)\nelse:\n    count = 0\n    while True:\n        time = prev_time(time, x)\n        count += 1\n        if is_lucky(time):\n            print(count)\n            break"}
{"solution": "n, pos, l, r = map(int, input().split())\n\nleft = min(pos - 1, l - 1)\nright = max(pos, r)\n\nleft_time = left + (l - 1) + (n - r)\nright_time = (n - right) + (r - pos) + (l - 1)\n\nprint(min(left_time, right_time) + 1 if l!= 1 or r!= n else 0)"}
{"solution": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    d = []\n    h = []\n    for _ in range(n):\n        di, hi = map(int, sys.stdin.readline().split())\n        d.append(di)\n        h.append(hi)\n\n    best = -1\n    for i in range(n):\n        if d[i] > h[i]:\n            best = i\n            break\n\n    if best == -1:\n        print(-1)\n        return\n\n    ans = 0\n    while x > 0:\n        if d[best] >= x:\n            ans += 1\n            break\n        else:\n            x -= d[best]\n            x += h[best]\n            ans += 1\n\n    print(ans)\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    solve()"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    day = 0\n    while True:\n        day += 1\n        n += m\n        if n > 10**18:\n            n = 10**18\n        if n < day:\n            break\n        n -= day\n    print(day)\n\nsolve()"}
{"solution": "def is_koutsu(hand):\n    return len(set([tile[0] for tile in hand])) == 1 and len(set([tile for tile in hand])) == 1\n\ndef is_shuntsu(hand):\n    numbers = sorted([int(tile[0]) for tile in hand])\n    return len(set([tile[1] for tile in hand])) == 1 and (numbers == list(range(numbers[0], numbers[0] + 3)))\n\ndef is_mentsu(hand):\n    return is_koutsu(hand) or is_shuntsu(hand)\n\ndef min_tiles_to_draw(hand):\n    if is_mentsu(hand):\n        return 0\n    else:\n        suits = set([tile[1] for tile in hand])\n        numbers = [int(tile[0]) for tile in hand]\n        min_tiles = float('inf')\n        for suit in suits:\n            for i in range(1, 10):\n                new_hand = hand + [str(i) + suit]\n                new_hand.sort()\n                for j in range(len(new_hand) - 2):\n                    if is_mentsu(new_hand[j:j+3]):\n                        min_tiles = min(min_tiles, 1)\n        for i in range(1, 10):\n            for suit in suits:\n                new_hand = hand + [str(i) + suit, str(i) + suit]\n                new_hand.sort()\n                for j in range(len(new_hand) - 2):\n                    if is_mentsu(new_hand[j:j+3]):\n                        min_tiles = min(min_tiles, 2)\n        return min_tiles\n\nhand = input().split()\nprint(min_tiles_to_draw(hand))"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_array():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    d = read_int()\n    n, m = read_ints()\n    sofas = []\n    for _ in range(d):\n        x1, y1, x2, y2 = read_ints()\n        sofas.append([(min(x1, x2), min(y1, y2)), (max(x1, x2), max(y1, y2))])\n\n    cnt_l, cnt_r, cnt_t, cnt_b = read_ints()\n\n    def count_sofas(sofas, x, y):\n        cnt_l = sum(1 for sofa in sofas if sofa[0][0] < x and sofa[1][0] == x)\n        cnt_r = sum(1 for sofa in sofas if sofa[0][0] > x and sofa[1][0] == x)\n        cnt_t = sum(1 for sofa in sofas if sofa[0][1] < y and sofa[1][1] == y)\n        cnt_b = sum(1 for sofa in sofas if sofa[0][1] > y and sofa[1][1] == y)\n        return cnt_l, cnt_r, cnt_t, cnt_b\n\n    for i in range(d):\n        cnt_l1, cnt_r1, cnt_t1, cnt_b1 = count_sofas(sofas[:i] + sofas[i+1:], sofas[i][0][0], sofas[i][0][1])\n        cnt_l2, cnt_r2, cnt_t2, cnt_b2 = count_sofas(sofas[:i] + sofas[i+1:], sofas[i][1][0], sofas[i][1][1])\n        if cnt_l1 == cnt_l and cnt_r1 == cnt_r and cnt_t1 == cnt_t and cnt_b1 == cnt_b:\n            return i + 1\n        if cnt_l2 == cnt_l and cnt_r2 == cnt_r and cnt_t2 == cnt_t and cnt_b2 == cnt_b:\n            return i + 1\n\n    return -1\n\nprint(solve())"}
{"solution": "n = int(input())\nmin_days_off = (n - 1) // 7 * 2 + max(0, (n - 1) % 7 - 4)\nmax_days_off = n // 7 * 2 + min(2, n % 7)\nprint(min_days_off, max_days_off)"}
{"solution": "import math\n\nn, a, b, p, q = map(int, input().split())\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nlcm = (a * b) // gcd(a, b)\n\nred = n // a\nblue = n // b\nboth = n // lcm\n\nchocolates_red = red * p - both * min(p, q)\nchocolates_blue = blue * q - both * min(p, q)\n\nprint(chocolates_red + chocolates_blue + both * max(p, q))"}
{"solution": "def max_golden_trophies(n, trophies):\n    max_length = 0\n    current_length = 0\n    first_silver = -1\n    last_silver = -1\n    silver_count = 0\n\n    for i in range(n):\n        if trophies[i] == 'G':\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            if first_silver == -1:\n                first_silver = i\n            last_silver = i\n            silver_count += 1\n            current_length = 0\n\n    if silver_count == 0:\n        return max_length\n    elif silver_count == 1:\n        return max_length + 1\n    else:\n        max_length_with_swap = 0\n        left_length = 0\n        right_length = 0\n\n        for i in range(first_silver):\n            if trophies[i] == 'G':\n                left_length += 1\n\n        for i in range(last_silver + 1, n):\n            if trophies[i] == 'G':\n                right_length += 1\n\n        max_length_with_swap = max(max_length_with_swap, left_length + right_length + 1)\n\n        for i in range(first_silver + 1, last_silver):\n            if trophies[i] == 'G':\n                max_length_with_swap += 1\n\n        return max(max_length, max_length_with_swap)\n\n\nn = int(input())\ntrophies = input()\nprint(max_golden_trophies(n, trophies))"}
{"solution": "from collections import defaultdict, deque\n\ndef solve():\n    n, k = map(int, input().split())\n    main_courses = list(map(int, input().split()))\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        dependencies = list(map(int, input().split()))\n        in_degree[i] = dependencies[0]\n        if dependencies[0] > 0:\n            for dependency in dependencies[1:]:\n                graph[dependency].append(i)\n\n    queue = deque([course for course in main_courses if in_degree[course] == 0])\n    result = []\n\n    while queue:\n        course = queue.popleft()\n        result.append(course)\n        for neighbor in graph[course]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(result)!= len(set(result)) or len(result) < len(main_courses):\n        print(-1)\n        return\n\n    for course in range(1, n + 1):\n        if course not in result and in_degree[course] == 0:\n            result.append(course)\n\n    print(len(result))\n    print(*result)\n\nsolve()"}
{"solution": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    p = list(map(int, sys.stdin.readline().split()))\n\n    s = []\n    b = []\n    for i in range(k):\n        while s and s[-1] < p[i]:\n            b.append(s.pop())\n        if s and s[-1] > p[i]:\n            print(-1)\n            return\n        s.append(p[i])\n\n    left = set(range(1, n + 1)) - set(p)\n    left = sorted(list(left), reverse=True)\n\n    for i in range(k, n):\n        while s and s[-1] < left[-1]:\n            b.append(s.pop())\n        if not s or s[-1] < left[-1]:\n            s.append(left.pop())\n        else:\n            b.append(s.pop())\n\n    while s:\n        b.append(s.pop())\n\n    if b!= sorted(b):\n        print(-1)\n        return\n\n    print(*p, end=' ')\n    print(*b)\n\nif __name__ == '__main__':\n    solve()"}
{"solution": "a, b, c = map(int, input().split())\n\nif c == 0:\n    print(\"YES\" if a == b else \"NO\")\nelse:\n    print(\"YES\" if (b - a) % c == 0 and (b - a) // c >= 0 else \"NO\")"}
{"solution": "def solve():\n    cnt1 = int(input())\n    cnt2 = int(input())\n    cnt3 = int(input())\n    cnt4 = int(input())\n\n    if cnt1 == cnt4 and cnt2 >= cnt3:\n        return 1\n    if cnt2 == 0 and cnt1 == cnt4 + 1:\n        return 1\n    if cnt3 == 0 and cnt1 + 1 == cnt4:\n        return 1\n    if cnt1 + cnt2 == cnt3 + cnt4 and cnt2 >= cnt3:\n        return 1\n    return 0\n\nprint(solve())"}
{"solution": "n, k, t = map(int, input().split())\n\nif t <= k:\n    print(min(t, n))\nelif t <= n:\n    print(k)\nelse:\n    print(max(k - (t - n), 0))"}
{"solution": "s = input()\nt = []\nu = []\nmin_char = 'z'\n\nfor char in s:\n    if char < min_char:\n        min_char = char\n        t.append(char)\n    else:\n        while t and t[-1] > char and t[-1] > min_char:\n            u.append(t.pop())\n        t.append(char)\n\nwhile t:\n    if t[-1] <= min_char:\n        u.append(t.pop())\n    else:\n        break\n\nprint(''.join(u))"}
{"solution": "def check_records(n, records):\n    for i in range(1, n):\n        plays_diff = records[i][0] - records[i-1][0]\n        clears_diff = records[i][1] - records[i-1][1]\n        if plays_diff < 0 or clears_diff < 0 or clears_diff > plays_diff:\n            return \"NO\"\n    return \"YES\"\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    records = [list(map(int, input().split())) for _ in range(n)]\n    print(check_records(n, records))"}
{"solution": "def is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome(time):\n    h, m = map(int, time.split(':'))\n    m += 1\n    if m == 60:\n        m = 0\n        h += 1\n        if h == 24:\n            h = 0\n    return f'{h:02d}:{m:02d}'\n\ndef minutes_diff(time1, time2):\n    h1, m1 = map(int, time1.split(':'))\n    h2, m2 = map(int, time2.split(':'))\n    return (h2 - h1) * 60 + (m2 - m1)\n\ntime = input()\nif is_palindrome(time):\n    print(0)\nelse:\n    next_pal = next_palindrome(time)\n    while not is_palindrome(next_pal):\n        next_pal = next_palindrome(next_pal)\n    print(minutes_diff(time, next_pal))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmin_index = a.index(1)\nmax_index = a.index(n)\n\nmax_distance = max(abs(min_index - (n - 1)), abs(max_index - 0))\n\nfor i in range(n):\n    if a[i] == n:\n        continue\n    temp = a[i]\n    a[i] = a[min_index]\n    a[min_index] = temp\n    distance = abs(a.index(n) - a.index(1))\n    max_distance = max(max_distance, distance)\n\n    a[min_index] = a[i]\n    a[i] = temp\n\n    temp = a[i]\n    a[i] = a[max_index]\n    a[max_index] = temp\n    distance = abs(a.index(n) - a.index(1))\n    max_distance = max(max_distance, distance)\n\n    a[max_index] = a[i]\n    a[i] = temp\n\nprint(max_distance)"}
{"solution": "def is_s_palindrome(s):\n    s = s.lower()\n    return s == s[::-1]\n\ns = input()\nprint(\"TAK\" if is_s_palindrome(s) else \"NIE\")"}
{"solution": "from collections import Counter\n\ndef largest_permutation(a, b):\n    a = list(a)\n    b = list(b)\n    a_count = Counter(a)\n    b_count = Counter(b)\n    result = []\n\n    for digit in b:\n        if a_count[digit] > 0 and digit!= '0':\n            result.append(digit)\n            a_count[digit] -= 1\n        else:\n            break\n\n    for digit in sorted(a_count.keys(), reverse=True):\n        while a_count[digit] > 0:\n            result.append(digit)\n            a_count[digit] -= 1\n\n    return ''.join(result)\n\na = input()\nb = input()\nprint(largest_permutation(a, b))"}
{"solution": "def check_win(board, i, j):\n    directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n    for dx, dy in directions:\n        count = 0\n        for k in range(-4, 5):\n            x, y = i + k * dx, j + k * dy\n            if 0 <= x < 10 and 0 <= y < 10 and board[x][y] == 'X':\n                count += 1\n                if count >= 5:\n                    return True\n            else:\n                count = 0\n    return False\n\ndef check_win_in_one_move(board):\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i] = board[i][:j] + 'X' + board[i][j+1:]\n                if check_win(board, i, j):\n                    return True\n                board[i] = board[i][:j] + '.' + board[i][j+1:]\n    return False\n\nboard = [input() for _ in range(10)]\nprint('YES' if check_win_in_one_move(board) else 'NO')"}
{"solution": "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [[0]*n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i, n):\n            if k > 0:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                k -= 1\n\n    if k > 0:\n        print(-1)\n    else:\n        for row in matrix:\n            print(*row)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\nx, y, z = map(float, input().split())\n\noptions = {\n    \"x^y^z\": x ** (y ** z),\n    \"x^z^y\": x ** (z ** y),\n    \"(x^y)^z\": (x ** y) ** z,\n    \"(x^z)^y\": (x ** z) ** y,\n    \"y^x^z\": y ** (x ** z),\n    \"y^z^x\": y ** (z ** x),\n    \"(y^x)^z\": (y ** x) ** z,\n    \"(y^z)^x\": (y ** z) ** x,\n    \"z^x^y\": z ** (x ** y),\n    \"z^y^x\": z ** (y ** x),\n    \"(z^x)^y\": (z ** x) ** y,\n    \"(z^y)^x\": (z ** y) ** x,\n}\n\nmax_value = max(options.values())\nmax_key = [key for key, value in options.items() if math.isclose(value, max_value)][0]\n\nprint(max_key)"}
{"solution": "def min_operations(n, s):\n    min_ops = n\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            prefix = s[:i]\n            if prefix * (n // i) == s:\n                min_ops = min(min_ops, i + 1)\n            else:\n                for j in range(i + 1, n // 2 + 1):\n                    if n % j == 0:\n                        mid = s[:j]\n                        if mid * (n // j) == s:\n                            min_ops = min(min_ops, j + 1)\n                            break\n    return min_ops\n\nn = int(input())\ns = input()\nprint(min_operations(n, s))"}
{"solution": "import sys\n\ndef read_input():\n    n = int(sys.stdin.readline())\n    files = []\n    for _ in range(n):\n        name, type = sys.stdin.readline().split()\n        files.append((name, int(type)))\n    return n, files\n\ndef solve(n, files):\n    e = sum(1 for _, type in files if type == 1)\n    used = set()\n    for name, _ in files:\n        used.add(name)\n\n    examples = []\n    regulars = []\n    for i in range(1, e + 1):\n        examples.append(str(i))\n    for i in range(e + 1, n + 1):\n        regulars.append(str(i))\n\n    moves = []\n    temp = 'temp'\n\n    for name, type in files:\n        if type == 1 and name not in examples:\n            if name in used:\n                moves.append((name, temp))\n                used.remove(name)\n                used.add(temp)\n            for i in range(len(examples)):\n                if examples[i] not in used:\n                    moves.append((temp, examples[i]))\n                    used.remove(temp)\n                    used.add(examples[i])\n                    break\n        elif type == 0 and name not in regulars:\n            if name in used:\n                moves.append((name, temp))\n                used.remove(name)\n                used.add(temp)\n            for i in range(len(regulars)):\n                if regulars[i] not in used:\n                    moves.append((temp, regulars[i]))\n                    used.remove(temp)\n                    used.add(regulars[i])\n                    break\n\n    return moves\n\ndef print_output(moves):\n    print(len(moves))\n    for move in moves:\n        print(f'move {move[0]} {move[1]}')\n\ndef main():\n    n, files = read_input()\n    moves = solve(n, files)\n    print_output(moves)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "def min_replacements(ticket):\n    first_half_sum = sum(int(digit) for digit in ticket[:3])\n    second_half_sum = sum(int(digit) for digit in ticket[3:])\n\n    diff = abs(first_half_sum - second_half_sum)\n\n    if diff == 0:\n        return 0\n    elif diff < 10:\n        return 1\n    else:\n        return 2\n\nticket = input()\nprint(min_replacements(ticket))"}
{"solution": "import math\n\ndef euler_totient(n):\n    result = n\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            while n % p == 0:\n                n //= p\n            result -= result // p\n        p += 1\n    if n > 1:\n        result -= result // n\n    return result\n\ndef solve():\n    m, x = map(int, input().split())\n    if m % 2 == 0:\n        print(m // 2 + 1 if x % 2 == 1 else 1)\n    else:\n        print(euler_totient(m))\n\nsolve()"}
{"solution": "def extended_euclidean(a, b):\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x, y = extended_euclidean(b % a, a)\n        return gcd, y - (b // a) * x, x\n\ndef mod_inverse(a, m):\n    gcd, x, y = extended_euclidean(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef power_mod(base, exponent, mod):\n    result = 1\n    base = base % mod\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % mod\n        exponent = exponent >> 1\n        base = (base * base) % mod\n    return result\n\ndef solve():\n    n, k = map(int, input().split())\n    mod = 10**6 + 3\n    total_days = power_mod(2, n, mod)\n    denominator = 1\n    for i in range(1, k):\n        denominator = (denominator * (total_days - i + mod)) % mod\n    numerator = (power_mod(total_days, k, mod) - denominator + mod) % mod\n    gcd = extended_euclidean(numerator, denominator)[0]\n    numerator = (numerator // gcd) % mod\n    denominator = (denominator // gcd) % mod\n    print(numerator, denominator)\n\nsolve()"}
{"solution": "n = int(input())\nlat = 0\nfor _ in range(n):\n    t, dir = input().split()\n    t = int(t)\n    if dir == \"North\":\n        if lat == -20000:\n            print(\"NO\")\n            exit()\n        lat += t\n        if lat > 0:\n            lat = 0\n    elif dir == \"South\":\n        if lat == 0 and t > 0:\n            lat -= t\n            if lat < -20000:\n                lat = -20000\n        elif lat!= 0:\n            print(\"NO\")\n            exit()\n    elif dir == \"East\" or dir == \"West\":\n        if lat!= 0 and lat!= -20000:\n            print(\"NO\")\n            exit()\nprint(\"YES\" if lat == 0 else \"NO\")"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\na1, b1, a2, b2, L, R = map(int, input().split())\n\nif a1 > a2:\n    a1, a2 = a2, a1\n    b1, b2 = b2, b1\n\nif b1 > b2:\n    k = math.ceil((b2 - b1) / a1)\n    b1 += k * a1\n\nif b1 < b2:\n    l = math.ceil((b1 - b2) / a2)\n    b2 += l * a2\n\nif b1!= b2:\n    print(0)\nelse:\n    if a1 == a2:\n        print(max(0, R - b1) // a1 + 1 - max(0, L - b1 - 1) // a1)\n    else:\n        print(max(0, R - b1) // lcm(a1, a2) + 1 - max(0, L - b1 - 1) // lcm(a1, a2))"}
{"solution": "import math\n\nn, a, b = map(int, input().split())\n\ndef check(x):\n    if a % x == 0 and b % x == 0:\n        return a // x + b // x >= n\n    elif a % x == 0:\n        return a // x + (b - b % x) // x >= n\n    elif b % x == 0:\n        return (a - a % x) // x + b // x >= n\n    else:\n        return (a - a % x) // x + (b - b % x) // x >= n\n\nl, r = 1, min(a, b)\nwhile l <= r:\n    mid = (l + r) // 2\n    if check(mid):\n        l = mid + 1\n    else:\n        r = mid - 1\n\nprint(r)"}
{"solution": "def is_valid_flag(n, m, flag):\n    colors = set()\n    for i in range(n):\n        color = flag[i][0]\n        for j in range(m):\n            if flag[i][j]!= color:\n                return False\n        colors.add(color)\n        if len(colors) > 3:\n            return False\n    if len(colors)!= 3:\n        return False\n    return True\n\nn, m = map(int, input().split())\nflag = [input() for _ in range(n)]\n\nif is_valid_flag(n, m, flag):\n    print(\"YES\")\nelse:\n    flag = list(zip(*flag))\n    if is_valid_flag(m, n, flag):\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "import math\n\nn = int(input())\n\nlayer = math.ceil((math.sqrt(6 * n + 1) - 1) / 6)\nstart = (layer - 1) * 6\nx, y = layer, -layer\n\nfor i in range(start, start + 6):\n    if i <= n:\n        if i < start + 1:\n            y += 1\n        elif i < start + 2:\n            x -= 1\n            y += 1\n        elif i < start + 3:\n            x -= 1\n        elif i < start + 4:\n            x -= 1\n            y -= 1\n        elif i < start + 5:\n            y -= 1\n        elif i < start + 6:\n            x += 1\n            y -= 1\n    else:\n        break\n\nprint(x, y)"}
{"solution": "a, b, c = map(int, input().split())\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef can_deal_damage(a, b, c):\n    g = gcd(a, b)\n    return c % g == 0 and c // g <= a * b // g\n\nprint(\"Yes\" if can_deal_damage(a, b, c) else \"No\")"}
{"solution": "def is_coinciding_tracks(n, L, kefa, sasha):\n    kefa_diff = [(kefa[i] - kefa[i-1]) % L for i in range(n)]\n    kefa_diff.append((kefa[0] - kefa[-1]) % L)\n\n    for i in range(n):\n        sasha_diff = [(sasha[j] - sasha[j-1]) % L for j in range(n)]\n        sasha_diff.append((sasha[0] - sasha[-1]) % L)\n        sasha_diff = sasha_diff[i:] + sasha_diff[:i]\n\n        if kefa_diff == sasha_diff:\n            return True\n\n    return False\n\n\nn, L = map(int, input().split())\nkefa = list(map(int, input().split()))\nsasha = list(map(int, input().split()))\n\nprint(\"YES\" if is_coinciding_tracks(n, L, kefa, sasha) else \"NO\")"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome(s):\n    max_length = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if not is_palindrome(substring):\n                max_length = max(max_length, len(substring))\n    return max_length\n\ns = input()\nprint(longest_non_palindrome(s))"}
{"solution": "n = int(input())\nrated = False\nmaybe = True\n\nratings_before = []\nratings_after = []\n\nfor _ in range(n):\n    a, b = map(int, input().split())\n    ratings_before.append(a)\n    ratings_after.append(b)\n\nfor i in range(n):\n    if ratings_after[i]!= ratings_before[i]:\n        rated = True\n        break\n\nfor i in range(n - 1):\n    if ratings_before[i] < ratings_before[i + 1]:\n        maybe = False\n        break\n\nif rated:\n    print(\"rated\")\nelif maybe:\n    print(\"maybe\")\nelse:\n    print(\"unrated\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ndistances = [float('inf')] * n\nzeros = [i for i, x in enumerate(a) if x == 0]\n\nfor i in range(n):\n    for zero in zeros:\n        distances[i] = min(distances[i], abs(i - zero))\n\nprint(*distances)"}
{"solution": "def count_cyclical_strings(n, s):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def count_strings(length):\n        count = 0\n        for i in range(2**length):\n            binary = bin(i)[2:].zfill(length)\n            if s in binary or s in binary[1:] + binary[0]:\n                count += 1\n        return count\n\n    def count_cyclical_strings(length):\n        count = 0\n        for i in range(2**length):\n            binary = bin(i)[2:].zfill(length)\n            if s in binary or s in binary[1:] + binary[0]:\n                g = gcd(length, binary.find(binary[0]) + 1)\n                count += 2**g\n        return count\n\n    if len(s) > n:\n        return 0\n    elif len(s) == n:\n        return 1 if s in [s, s[1:] + s[0]] else 2\n    else:\n        return count_cyclical_strings(n) - count_cyclical_strings(n - len(s))\n\nn = int(input())\ns = input()\nprint(count_cyclical_strings(n, s))"}
{"solution": "import math\n\nn = int(input())\nvectors = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    length = math.sqrt(x**2 + y**2)\n    angle = math.atan2(y, x)\n    vectors.append((angle, length, i+1))\n\nvectors.sort()\n\nmin_angle = float('inf')\nmin_indices = (-1, -1)\nfor i in range(n):\n    for j in range(i+1, min(n, i+100)):\n        angle = abs(vectors[i][0] - vectors[j][0])\n        if angle > math.pi:\n            angle = 2 * math.pi - angle\n        if angle < min_angle:\n            min_angle = angle\n            min_indices = (vectors[i][2], vectors[j][2])\n\nprint(*min_indices)"}
{"solution": "import math\n\nd, k, a, b, t = map(int, input().split())\n\ndef calculate_time(distance):\n    full_cycles = math.floor(distance / k)\n    remaining_distance = distance % k\n    time = full_cycles * (k * a + t)\n    time += min(remaining_distance * a, remaining_distance * b)\n    return time\n\ndef calculate_time_with_abandon(distance):\n    abandon_point = (b * k - a * k - t) / (b - a)\n    if abandon_point < 0:\n        return calculate_time(distance)\n    elif abandon_point > k:\n        return calculate_time(distance)\n    else:\n        full_cycles = math.floor(distance / k)\n        remaining_distance = distance % k\n        time = full_cycles * (k * a + t)\n        time += min(abandon_point * a, abandon_point * b)\n        time += (remaining_distance - abandon_point) * b\n        return time\n\nprint(min(calculate_time(d), calculate_time_with_abandon(d)))"}
{"solution": "import math\n\nn, k = map(int, input().split())\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(n, k):\n    if n < k:\n        return -1\n    if n % k == 0:\n        return [n // k] * k\n    g = n // k\n    r = n % k\n    if r == 1:\n        return [g] * (k - 1) + [g + 1]\n    if r == 2 and k % 2 == 0:\n        return [g] * (k - 2) + [g + 1, g + 1]\n    if r == 2 and k % 2 == 1:\n        return [g] * (k - 3) + [g + 1, g + 1, g + 2]\n    if r > 2:\n        return [g] * (k - r) + [g + 1] * (r - 1) + [g + 2]\n\nresult = solve(n, k)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "n, m = map(int, input().split())\n\ndef count_pairs(n, m):\n    count = 0\n    for i in range(5):\n        count += (n - i) // 5 * (m - (5 - i)) // 5\n        if (n - i) % 5 >= (m - (5 - i)) % 5:\n            count += (n - i) % 5 - (m - (5 - i)) % 5\n    return count\n\nprint(count_pairs(n, m))"}
{"solution": "import sys\n\ndef read_ints():\n    return map(int, sys.stdin.readline().split())\n\ndef kadane(arr):\n    max_sum = 0\n    current_sum = 0\n    for num in arr:\n        current_sum = max(0, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef solve():\n    n, x = read_ints()\n    a = list(read_ints())\n\n    if x >= 0:\n        return kadane([x * num for num in a])\n\n    max_sum = 0\n    min_sum = 0\n    current_max_sum = 0\n    current_min_sum = 0\n    prefix_sum = 0\n    max_prefix_sum = 0\n    min_prefix_sum = 0\n\n    for num in a:\n        current_max_sum = max(0, current_max_sum + num)\n        current_min_sum = min(0, current_min_sum + num)\n        max_sum = max(max_sum, current_max_sum)\n        min_sum = min(min_sum, current_min_sum)\n        prefix_sum += num\n        max_prefix_sum = max(max_prefix_sum, prefix_sum)\n        min_prefix_sum = min(min_prefix_sum, prefix_sum)\n\n    return max(max_sum, x * min_sum, max_prefix_sum - min_prefix_sum)\n\nprint(solve())"}
{"solution": "import sys\n\ndef count_less_equal(mid, n, m):\n    count = 0\n    for i in range(1, n + 1):\n        count += min(mid // i, m)\n    return count\n\ndef find_kth_largest(n, m, k):\n    left, right = 1, n * m\n    while left < right:\n        mid = (left + right) // 2\n        if count_less_equal(mid, n, m) < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\nn, m, k = map(int, sys.stdin.readline().split())\nprint(find_kth_largest(n, m, n * m - k + 1))"}
{"solution": "def find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    start += (k - 1) // length\n    return str(start)[(k - 1) % length]\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "import sys\n\ndef solve():\n    n, m, r = map(int, sys.stdin.readline().split())\n    s = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    s.sort()\n    b.sort(reverse=True)\n\n    ans = r\n    for i in range(n):\n        for j in range(m):\n            if s[i] < b[j]:\n                buy = r // s[i]\n                ans = max(ans, r - buy * s[i] + buy * b[j])\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def solve():\n    s = input()\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0 and s[:i] * (n // i) == s:\n            print(\"YES\")\n            print(s[:i] * ((n // i) // 2))\n            return\n    print(\"NO\")\n\nsolve()"}
{"solution": "import math\n\ndef solve(n):\n    result = []\n    for i in range(1, int(math.sqrt(2 * n)) + 1):\n        x = 2 * n // i - i + 1\n        if x % 2 == 1 and x // 2 >= i:\n            t = x\n            while t > 0:\n                if t % 2 == 1:\n                    t = (t - 1) // 2\n                else:\n                    t = t // 2 - 1\n            if t == 0:\n                result.append(x)\n    return result\n\nn = int(input())\nresult = solve(n)\nif len(result) == 0:\n    print(-1)\nelse:\n    for x in sorted(result):\n        print(x)"}
{"solution": "n = int(input())\ns = input()\nb = list(map(int, input().split()))\n\nchar_count = {}\nfor char in s:\n    char_count[char] = char_count.get(char, 0) + 1\n\nmax_beauty = 0\nfor char, count in char_count.items():\n    char_beauty = 0\n    indices = [i for i, c in enumerate(s) if c == char]\n    for i in indices:\n        if s[n - i - 1]!= char:\n            char_beauty += b[i]\n    max_beauty += max(char_beauty, count // 2 * min(b[i] for i in indices))\n\nprint(max_beauty)"}
{"solution": "def can_weight(w, m):\n    return 'YES' if m % w == 0 or m > w and (m % w) * (w - 1) >= m else 'NO'\n\nw, m = map(int, input().split())\nprint(can_weight(w, m))"}
{"solution": "import sys\n\ndef solve(n, k):\n    if k > n:\n        return [-1] * k\n\n    if n.bit_length() < k:\n        return \"No\"\n\n    max_bit = n.bit_length() - 1\n    ans = []\n    while k > 0:\n        if n & (1 << max_bit):\n            ans.append(max_bit)\n            n -= 1 << max_bit\n            k -= 1\n        max_bit -= 1\n\n    if n > 0:\n        return \"No\"\n\n    ans.sort(reverse=True)\n    return ans\n\nn, k = map(int, sys.stdin.readline().split())\nresult = solve(n, k)\nif result == \"No\":\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    print(*result)"}
{"solution": "def champagne_pyramid():\n    n, t = map(int, input().split())\n    pyramid = [[0] * i for i in range(1, n + 1)]\n    pyramid[0][0] = t\n\n    for i in range(n):\n        for j in range(len(pyramid[i])):\n            if pyramid[i][j] > 1:\n                excess = (pyramid[i][j] - 1) / 2\n                pyramid[i][j] = 1\n                if i < n - 1:\n                    pyramid[i + 1][j] += excess\n                    pyramid[i + 1][j + 1] += excess\n\n    return sum(1 for row in pyramid for glass in row if glass >= 1)\n\n\nprint(champagne_pyramid())"}
{"solution": "def calculate_area(n, points):\n    if n < 2:\n        return -1\n\n    points.sort(key=lambda x: (x[0], x[1]))\n\n    if n == 2:\n        if points[0][0] == points[1][0] or points[0][1] == points[1][1]:\n            return -1\n        else:\n            return abs(points[0][0] - points[1][0]) * abs(points[0][1] - points[1][1])\n\n    if n == 3:\n        x_coords = [point[0] for point in points]\n        y_coords = [point[1] for point in points]\n\n        x_coords.sort()\n        y_coords.sort()\n\n        missing_x = x_coords[0] if x_coords[0] == x_coords[1] else x_coords[2]\n        missing_y = y_coords[0] if y_coords[0] == y_coords[1] else y_coords[2]\n\n        for point in points:\n            if point[0] == missing_x and point[1] == missing_y:\n                return -1\n\n        return abs(x_coords[2] - x_coords[0]) * abs(y_coords[2] - y_coords[0])\n\n    if n == 4:\n        x_coords = [point[0] for point in points]\n        y_coords = [point[1] for point in points]\n\n        x_coords.sort()\n        y_coords.sort()\n\n        return abs(x_coords[3] - x_coords[0]) * abs(y_coords[3] - y_coords[0])\n\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\nprint(calculate_area(n, points))"}
{"solution": "import math\n\nn = int(input())\na = int(input())\nb = int(input())\n\ntotal_length = 2 * (2 * a + b)\nnum_bars = math.ceil(total_length / n)\n\nprint(num_bars)"}
{"solution": "def can_sort_array(n, a, swaps):\n    groups = []\n    current_group = [a[0]]\n\n    for i in range(n - 1):\n        if swaps[i] == '0':\n            groups.append(current_group)\n            current_group = [a[i + 1]]\n        else:\n            current_group.append(a[i + 1])\n\n    for group in groups:\n        if group!= sorted(group):\n            return \"NO\"\n\n    return \"YES\"\n\n\nn = int(input())\na = list(map(int, input().split()))\nswaps = input()\n\nprint(can_sort_array(n, a, swaps))"}
{"solution": "def solve():\n    s = input()\n    n = int(s[:-1])\n    seat = s[-1]\n    seats = 'fedcba'\n    seat_index = seats.index(seat)\n    row_diff = (n - 1) % 2\n    row = (n - row_diff) // 2\n    row_time = row * 12\n    move_time = (row - 1) * 2\n    if row_diff == 0:\n        row_time += 6 + seat_index\n    else:\n        row_time += seat_index\n    print(row_time + move_time)\n\nsolve()"}
{"solution": "def convert_to_decimal(digits, base):\n    decimal = 0\n    for i, digit in enumerate(reversed(digits)):\n        decimal += digit * (base ** i)\n    return decimal\n\nn, bx = map(int, input().split())\nx = list(map(int, input().split()))\n\nm, by = map(int, input().split())\ny = list(map(int, input().split()))\n\nx_decimal = convert_to_decimal(x, bx)\ny_decimal = convert_to_decimal(y, by)\n\nif x_decimal < y_decimal:\n    print('<')\nelif x_decimal > y_decimal:\n    print('>')\nelse:\n    print('=')"}
{"solution": "def nim_sum(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\ndef can_win(nums):\n    if len(nums) == 1:\n        return nums[0] > 0\n    if len(nums) == 2:\n        return nums[0]!= nums[1] or nums[0] > 0\n    return nim_sum(nums)!= 0 or max(nums) > min(nums)\n\nn = int(input())\nnums = list(map(int, input().split()))\n\nif can_win(nums):\n    print(\"BitLGM\")\nelse:\n    print(\"BitAryo\")"}
{"solution": "from collections import defaultdict\nfrom math import sqrt\nfrom functools import reduce\n\ndef prime_factors(n):\n    factors = defaultdict(int)\n    while n % 2 == 0:\n        factors[2] += 1\n        n //= 2\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        while n % i == 0:\n            factors[i] += 1\n            n //= i\n    if n > 2:\n        factors[n] += 1\n    return factors\n\ndef calculate_prefix_factors(nums, k_factors):\n    prefix_factors = [defaultdict(int) for _ in range(len(nums) + 1)]\n    for i in range(len(nums)):\n        for factor, count in prime_factors(nums[i]).items():\n            prefix_factors[i + 1][factor] = prefix_factors[i][factor] + count\n    return prefix_factors\n\ndef calculate_suffix_factors(nums, k_factors):\n    suffix_factors = [defaultdict(int) for _ in range(len(nums) + 1)]\n    for i in range(len(nums) - 1, -1, -1):\n        for factor, count in prime_factors(nums[i]).items():\n            suffix_factors[i][factor] = suffix_factors[i + 1][factor] + count\n    return suffix_factors\n\ndef count_ways(prefix_factors, suffix_factors, k_factors, n):\n    ways = 0\n    for i in range(n + 1):\n        remaining_factors = defaultdict(int)\n        for factor, count in k_factors.items():\n            remaining_factors[factor] = count - prefix_factors[i][factor]\n        for j in range(i, n + 1):\n            valid = True\n            for factor, count in remaining_factors.items():\n                if suffix_factors[j][factor] < count:\n                    valid = False\n                    break\n            if valid:\n                ways += 1\n    return ways\n\ndef main():\n    n, k = map(int, input().split())\n    nums = list(map(int, input().split()))\n    k_factors = prime_factors(k)\n    prefix_factors = calculate_prefix_factors(nums, k_factors)\n    suffix_factors = calculate_suffix_factors(nums, k_factors)\n    ways = count_ways(prefix_factors, suffix_factors, k_factors, n)\n    print(ways)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n, k = map(int, input().split())\ns = input()\n\ncolor_counts = {}\nfor color in s:\n    if color in color_counts:\n        color_counts[color] += 1\n    else:\n        color_counts[color] = 1\n\nmax_color_count = max(color_counts.values())\nif max_color_count <= k:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmin_val = min(a)\nmin_indices = [i for i, x in enumerate(a) if x == min_val]\n\nmin_distance = float('inf')\nfor i in range(len(min_indices) - 1):\n    min_distance = min(min_distance, min_indices[i + 1] - min_indices[i])\n\nprint(min_distance)"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nt, w, b = map(int, input().split())\n\ng = gcd(w, b)\nlcm = w * b // g\n\ncount = 0\nfor i in range(1, t + 1):\n    if i % lcm == 0:\n        count += 1\n\ng = gcd(count, t)\nprint(f\"{count // g}/{t // g}\")"}
{"solution": "x, y, z = map(int, input().split())\n\nif x > y + z:\n    print(\"+\")\nelif x + z < y:\n    print(\"-\")\nelif x == y:\n    print(\"0\")\nelif x + z == y or x == y + z:\n    print(\"?\")\nelse:\n    print(\"+\") if x > y else print(\"-\")"}
{"solution": "def solve():\n    n = int(input())\n    s = input()\n    x, y = map(int, input().split())\n\n    dx = s.count('R') - s.count('L')\n    dy = s.count('U') - s.count('D')\n\n    if dx == x and dy == y:\n        return 0\n\n    if abs(x - dx) > s.count('L') + s.count('R') or abs(y - dy) > s.count('U') + s.count('D'):\n        return -1\n\n    ans = float('inf')\n    for i in range(n):\n        for j in range(i, n):\n            cnt = [0, 0, 0, 0]\n            for k in range(i, j + 1):\n                cnt['RULD'.index(s[k])] += 1\n            for k in range(i):\n                cnt['RULD'.index(s[k])] += 1\n            for k in range(j + 1, n):\n                cnt['RULD'.index(s[k])] += 1\n            if cnt[0] + cnt[1] >= abs(x - dx) and cnt[2] + cnt[3] >= abs(y - dy):\n                ans = min(ans, j - i + 1)\n    return ans\n\nprint(solve())"}
{"solution": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    s = sys.stdin.readline().strip()\n\n    balance = 0\n    cnt = 0\n    seen = set()\n    seen.add(0)\n\n    for i in range(n):\n        if s[i] == '0':\n            balance += 1\n        else:\n            balance -= 1\n\n        if balance == x:\n            cnt += 1\n        seen.add(balance)\n\n    if x % balance!= 0:\n        print(cnt)\n        return\n\n    if x // balance < 0 and min(seen) <= x:\n        print(-1)\n        return\n\n    if x // balance > 0 and max(seen) >= x:\n        print(-1)\n        return\n\n    print(cnt)\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    solve()"}
{"solution": "import math\n\nn, k = map(int, input().split())\nn_str = str(n)\nk_str = '0' * k\n\ndef is_divisible(num):\n    return num.endswith(k_str)\n\ndef remove_digits(num, k):\n    num_str = str(num)\n    k_str = '0' * k\n    min_count = float('inf')\n    for i in range(len(num_str)):\n        count = 0\n        temp = num_str\n        for j in range(i, len(num_str)):\n            if temp[j]!= k_str[count]:\n                temp = temp[:j] + temp[j+1:]\n                count += 1\n            else:\n                count += 1\n            if count == k:\n                break\n        if is_divisible(temp):\n            min_count = min(min_count, count)\n    return min_count\n\nprint(remove_digits(n, k))"}
{"solution": "n, m, k, x, y = map(int, input().split())\n\nif n == 1:\n    max_val = k // m + (k % m > 0)\n    min_val = k // m + (k % m > 0 and k % m!= 1)\n    times = k // m + (k % m >= y)\n    print(max_val, min_val, times)\nelse:\n    cycle = 2 * n - 2\n    full_cycles = k // (cycle * m)\n    remaining = k % (cycle * m)\n    max_val = full_cycles * m + min(remaining // m + (remaining % m > 0), n)\n    min_val = full_cycles * m + max(0, min(remaining // m, n - 1))\n    times = full_cycles * m\n    if remaining > 0:\n        row = 1\n        direction = 1\n        for _ in range(remaining):\n            if row == x and direction == 1 and _ % m + 1 == y:\n                times += 1\n            row += direction\n            if row == n + 1:\n                row = n - 1\n                direction = -1\n            elif row == 0:\n                row = 2\n                direction = 1\n    print(max_val, min_val, times)"}
{"solution": "def beauty(s, n):\n    if n >= len(s):\n        return len(s)\n\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n\n    max_freq = max(freq.values())\n    max_char = [char for char, count in freq.items() if count == max_freq]\n\n    if len(max_char) > 1:\n        return max_freq\n\n    max_char = max_char[0]\n    max_freq = s.count(max_char)\n\n    if max_freq + n >= len(s):\n        return len(s)\n\n    return max_freq + n\n\nn = int(input())\nkuro = input()\nshiro = input()\nkatie = input()\n\nkuro_beauty = beauty(kuro, n)\nshiro_beauty = beauty(shiro, n)\nkatie_beauty = beauty(katie, n)\n\nmax_beauty = max(kuro_beauty, shiro_beauty, katie_beauty)\n\nif kuro_beauty == max_beauty and shiro_beauty!= max_beauty and katie_beauty!= max_beauty:\n    print(\"Kuro\")\nelif shiro_beauty == max_beauty and kuro_beauty!= max_beauty and katie_beauty!= max_beauty:\n    print(\"Shiro\")\nelif katie_beauty == max_beauty and kuro_beauty!= max_beauty and shiro_beauty!= max_beauty:\n    print(\"Katie\")\nelse:\n    print(\"Draw\")"}
{"solution": "def calculate_days(c, v0, v1, a, l):\n    days = 0\n    total_pages_read = 0\n    current_speed = v0\n\n    while total_pages_read < c:\n        pages_to_read = min(current_speed, v1)\n        if total_pages_read + pages_to_read - l >= c:\n            days += 1\n            break\n        total_pages_read += pages_to_read - l\n        current_speed = min(current_speed + a, v1)\n        days += 1\n\n    return days\n\n\nc, v0, v1, a, l = map(int, input().split())\nprint(calculate_days(c, v0, v1, a, l))"}
{"solution": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\nn = int(input())\n\nif is_prime(n):\n    print(1)\n    print(n)\nelse:\n    for i in range(2, n):\n        if is_prime(i) and is_prime(n - i):\n            print(2)\n            print(i, n - i)\n            break\n    else:\n        for i in range(2, n - 2):\n            if is_prime(i):\n                for j in range(i, n - i):\n                    if is_prime(j) and is_prime(n - i - j):\n                        print(3)\n                        print(i, j, n - i - j)\n                        break\n                else:\n                    continue\n                break"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n\n    rows = [sum(row.count('*') for row in grid)]\n    cols = [sum(grid[i][j] == '*' for i in range(n)) for j in range(m)]\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*':\n                rows.append(rows[0] - rows[i] - cols[j] + 1)\n                cols.append(cols[0] - cols[j] - rows[i] + 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if rows[i] + cols[j] == rows[0] + cols[0]:\n                print(\"YES\")\n                print(i, j)\n                return\n\n    print(\"NO\")\n\nsolve()"}
{"solution": "n, m, a, b = map(int, input().split())\nmod = n % m\nadd = (m - mod) % m\nremove = mod\nadd_cost = add * a\nremove_cost = remove * b\nmin_cost = min(add_cost, remove_cost)\nif n < m:\n    min_cost = min(min_cost, (m - n) * a)\nprint(min_cost)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nodd = [x for x in a if x % 2!= 0]\neven = [x for x in a if x % 2 == 0]\n\nodd.sort()\neven.sort(reverse=True)\n\nodd_sum = sum(odd)\neven_sum = sum(even)\n\nif odd_sum % 2 == 0:\n    if even_sum!= 0:\n        odd_sum -= odd[0]\n    else:\n        odd_sum -= odd[0] * 2\n\nprint(odd_sum + even_sum)"}
{"solution": "from collections import defaultdict\nfrom functools import lru_cache\n\nMOD = 10**9 + 7\n\ndef main():\n    n, T = map(int, input().split())\n    songs = defaultdict(list)\n    for _ in range(n):\n        t, g = map(int, input().split())\n        songs[g].append(t)\n\n    @lru_cache(None)\n    def dp(i, t, last):\n        if t == 0:\n            return 1\n        if t < 0:\n            return 0\n        ans = 0\n        for j in range(1, 4):\n            if j!= last:\n                for song in songs[j]:\n                    ans += dp(i + 1, t - song, j)\n                    ans %= MOD\n        return ans\n\n    print(dp(0, T, 0))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef solve():\n    m = int(input())\n    if m == 1:\n        print(1)\n        return\n\n    phi = [i for i in range(m + 1)]\n    for i in range(2, m + 1):\n        if phi[i] == i:\n            for j in range(i, m + 1, i):\n                phi[j] -= phi[j] // i\n\n    phi[1] = 0\n    prob = [0] * (m + 1)\n    prob[1] = 1\n    for i in range(2, m + 1):\n        prob[i] = phi[i] * mod_inverse(i, MOD) % MOD\n\n    dp = [0] * (m + 1)\n    dp[1] = 1\n    for i in range(2, m + 1):\n        dp[i] = (1 + sum(dp[j] * prob[i // j] for j in range(1, i + 1))) % MOD * mod_inverse(1 - prob[i], MOD) % MOD\n\n    print(dp[m])\n\nsolve()"}
{"solution": "import math\n\ndef count_pairs(l, r, x, y):\n    if x > y or y % x!= 0 or y < x * x:\n        return 0\n\n    factors = prime_factors(y // x)\n    count = 0\n\n    for mask in range(1 << len(factors)):\n        a = x\n        for i in range(len(factors)):\n            if (mask >> i) & 1:\n                a *= factors[i]\n        b = y // a\n        if l <= a <= r and l <= b <= r:\n            count += 1\n        if a!= b and l <= b <= r and l <= a <= r:\n            count += 1\n\n    return count\n\ndef prime_factors(n):\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\nl, r, x, y = map(int, input().split())\nprint(count_pairs(l, r, x, y))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\na, b = map(int, input().split())\ng = gcd(a, b)\na //= g\nb //= g\n\nif a > b:\n    a, b = b, a\n\nif a == 1:\n    print(g - b % g)\nelse:\n    print(g * (b - 1) // (a - 1) - b)"}
{"solution": "n, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\ntotal_marks = sum(marks)\nadditional_marks = 0\n\nwhile (total_marks + additional_marks * k) / (n + additional_marks) < k:\n    additional_marks += 1\n\nprint(additional_marks)"}
{"solution": "import math\n\nn = int(input())\na = list(map(int, input().split()))\n\ndef check(d):\n    count = sum(1 for x in a if x / d > 0)\n    return count >= math.ceil(n / 2)\n\nfor d in range(-1000, 1001):\n    if d!= 0 and check(d):\n        print(d)\n        break\nelse:\n    print(0)"}
{"solution": "import math\n\nn = int(input())\nk = int(math.log10(n))\nmax_nines = 10**k\nnines = n // max_nines\nif n % max_nines > max_nines // 2:\n    nines += 1\nif nines % 2 == 0:\n    print((nines // 2) * (n - nines // 2))\nelse:\n    print((nines // 2) * (n - nines // 2) + (nines // 2 + 1) * (n - nines // 2 - 1))"}
{"solution": "import sys\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(a, b, c, d):\n    if a * b == c * d:\n        return 0, a, b, c, d\n    if a * b < c * d:\n        a, b, c, d = c, d, a, b\n    if a % 2 == 0 and b % 2 == 0:\n        return solve(a // 2, b // 2, c, d) if a * b // 2 >= c * d else solve(a, b // 2, c, d // 2)\n    if a % 2 == 0:\n        return solve(a // 2, b, c, d) if a * b // 2 >= c * d else solve(a, b // 2, c, d)\n    if b % 2 == 0:\n        return solve(a, b // 2, c, d) if a * b // 2 >= c * d else solve(a // 2, b, c, d)\n    if a % 3 == 0 and b % 3 == 0:\n        return solve(a // 3, b // 3, c, d) if a * b // 3 >= c * d else solve(a, b // 3, c, d // 3)\n    if a % 3 == 0:\n        return solve(a // 3, b, c, d) if a * b // 3 >= c * d else solve(a, b // 3, c, d)\n    if b % 3 == 0:\n        return solve(a, b // 3, c, d) if a * b // 3 >= c * d else solve(a // 3, b, c, d)\n    return -1, -1, -1, -1, -1\n\na, b = map(int, sys.stdin.readline().split())\nc, d = map(int, sys.stdin.readline().split())\n\nans, x, y, z, t = solve(a, b, c, d)\nif ans == -1:\n    print(-1)\nelse:\n    print(ans)\n    print(x, y)\n    print(z, t)"}
{"solution": "x_p, y_p, x_v, y_v = map(int, input().split())\n\nif x_p + y_p <= max(x_v, y_v):\n    print(\"Polycarp\")\nelif x_p <= x_v and y_p <= y_v:\n    print(\"Polycarp\")\nelse:\n    print(\"Vasiliy\")"}
{"solution": "def days_in_month(month):\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return 31\n    elif month == 2:\n        return 28\n    else:\n        return 30\n\nm, d = map(int, input().split())\ndays = days_in_month(m)\nweeks = (days + d - 1) // 7\nprint(weeks + (1 if days % 7!= 0 and d > 1 else 0))"}
{"solution": "def count_binary_zeros(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef solve(a, b):\n    def dfs(n, cur, has_zero):\n        if cur > n:\n            return 0\n        res = 0\n        if count_binary_zeros(cur) == 1:\n            res += 1\n        if has_zero:\n            res += dfs(n, cur * 2 + 1, True)\n        res += dfs(n, cur * 2, False)\n        return res\n\n    return dfs(b, 1, False) - dfs(a - 1, 1, False)\n\na, b = map(int, input().split())\nprint(solve(a, b))"}
{"solution": "import math\n\nn = int(input())\nprint(math.ceil(n * (n + 1) / (2 * math.floor(math.sqrt(n * (n + 1))))))"}
{"solution": "import math\n\ndef solve():\n    n, k, S = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    fact = [math.factorial(x) for x in a]\n\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(k + 1):\n            for x in range(2):\n                if j + x <= k:\n                    dp[i + 1][j + x] += dp[i][j]\n                    if a[i] * (1 + x) <= S:\n                        dp[i + 1][j + x] += dp[i][j] * (1 + x)\n                    if fact[i] * (1 + x) <= S:\n                        dp[i + 1][j + x] += dp[i][j] * (1 + x)\n\n    ans = 0\n    for i in range(k + 1):\n        ans += dp[n][i]\n\n    print(ans)\n\nsolve()"}
{"solution": "import sys\n\ndef solve(n, k, a):\n    for x in a:\n        y = x\n        i = 0\n        while y > 0:\n            if y % k == 0:\n                y //= k\n                i += 1\n            else:\n                if y % k!= 1:\n                    return \"NO\"\n                y -= 1\n        if i >= 60:\n            return \"NO\"\n    return \"YES\"\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(solve(n, k, a))"}
{"solution": "def get_divisors(n):\n    divisors = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(i, n + 1, i):\n            divisors[j] += 1\n    return divisors\n\ndef main():\n    a, b, c = map(int, input().split())\n    divisors = get_divisors(a * b * c)\n    result = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                result += divisors[i * j * k]\n                result %= 1073741824\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import deque\n\ndef is_solvable(puzzle):\n    flat_list = [item for sublist in puzzle for item in sublist]\n    inversions = 0\n    for i in range(len(flat_list)):\n        if flat_list[i] == 'X':\n            continue\n        for j in range(i + 1, len(flat_list)):\n            if flat_list[j]!= 'X' and flat_list[i] > flat_list[j]:\n                inversions += 1\n    return inversions % 2 == 0\n\ndef main():\n    bessie = [input() for _ in range(2)]\n    elsie = [input() for _ in range(2)]\n    print(\"YES\" if is_solvable(bessie) == is_solvable(elsie) else \"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\nk = input()\n\nresult = 0\npower = 0\n\nfor digit in reversed(k):\n    result += int(digit) * (n ** power)\n    power += 1\n\nprint(result)"}
{"solution": "def is_unimodal(arr):\n    increasing = decreasing = False\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            if decreasing:\n                return False\n            increasing = True\n        elif arr[i] < arr[i - 1]:\n            decreasing = True\n    return True\n\nn = int(input())\narr = list(map(int, input().split()))\n\nprint(\"YES\" if is_unimodal(arr) else \"NO\")"}
{"solution": "def solve():\n    n, k = map(int, input().split())\n    if k > n:\n        print(0)\n        return\n    if k == n:\n        print(1)\n        return\n    l, r = 1, n\n    while l < r:\n        mid = (l + r + 1) // 2\n        if mid % 2 == 0:\n            mid -= 1\n        if mid == 1:\n            l = r = 1\n            break\n        cnt = mid // 2 + 1\n        x = mid\n        while x * 2 + 1 <= n:\n            x = x * 2 + 1\n            cnt += 1\n        if cnt >= k:\n            l = mid\n            r = mid\n        else:\n            r = mid - 1\n    print(l)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn, m, x, y, vx, vy = map(int, input().split())\n\nif vx == 0:\n    if vy > 0:\n        print(x, m)\n    else:\n        print(x, 0)\nelif vy == 0:\n    if vx > 0:\n        print(n, y)\n    else:\n        print(0, y)\nelif abs(vx) == abs(vy):\n    if vx > 0 and vy > 0:\n        if n - x > m - y:\n            print(n, y)\n        elif n - x < m - y:\n            print(x, m)\n        else:\n            print(-1)\n    elif vx > 0 and vy < 0:\n        if n - x > y:\n            print(n, y)\n        elif n - x < y:\n            print(x, 0)\n        else:\n            print(-1)\n    elif vx < 0 and vy > 0:\n        if x > m - y:\n            print(x, m)\n        elif x < m - y:\n            print(0, y)\n        else:\n            print(-1)\n    elif vx < 0 and vy < 0:\n        if x > y:\n            print(0, y)\n        elif x < y:\n            print(x, 0)\n        else:\n            print(-1)\nelse:\n    if vx > 0:\n        x1 = n\n    else:\n        x1 = 0\n    if vy > 0:\n        y1 = m\n    else:\n        y1 = 0\n    g = gcd(abs(n - x), abs(m - y))\n    if abs(n - x) // g * abs(vx) == abs(m - y) // g * abs(vy):\n        print(x1, y1)\n    else:\n        print(-1)"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    # Check if the sum of the areas of the paintings is less than or equal to the area of the board\n    if a2 * b2 + a3 * b3 > a1 * b1:\n        return False\n\n    # Check all possible orientations of the paintings\n    for a2_new, b2_new in [(a2, b2), (b2, a2)]:\n        for a3_new, b3_new in [(a3, b3), (b3, a3)]:\n            # Check if the paintings can be placed side by side\n            if a2_new + a3_new <= a1 and max(b2_new, b3_new) <= b1:\n                return True\n            # Check if the paintings can be placed one on top of the other\n            if max(a2_new, a3_new) <= a1 and b2_new + b3_new <= b1:\n                return True\n\n    return False\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\nprint(\"YES\" if can_place_paintings(a1, b1, a2, b2, a3, b3) else \"NO\")"}
{"solution": "def solve():\n    b1, q, l, m = map(int, input().split())\n    bad = set(map(int, input().split()))\n\n    if q == 0:\n        return 0 if b1 in bad else \"inf\" if abs(b1) <= l else 0\n\n    if abs(q) == 1:\n        return 0 if b1 in bad else \"inf\" if abs(b1) <= l else 0\n\n    if q < 0:\n        q = -q\n        b1 = -b1\n\n    if b1 < 0:\n        b1 = -b1\n        bad = {-x for x in bad}\n\n    if b1 > l:\n        return 0\n\n    if b1 in bad:\n        return 0\n\n    res = 1\n    b1 *= q\n\n    while b1 <= l:\n        if b1 not in bad:\n            res += 1\n        if b1 > l // q:\n            break\n        b1 *= q\n\n    return res if b1 > l else \"inf\"\n\nprint(solve())"}
{"solution": "def find_frame(n, m, screen):\n    min_x, max_x, min_y, max_y = float('inf'), float('-inf'), float('inf'), float('-inf')\n    for i in range(n):\n        for j in range(m):\n            if screen[i][j] == 'w':\n                min_x, max_x = min(min_x, j), max(max_x, j)\n                min_y, max_y = min(min_y, i), max(max_y, i)\n\n    size = max(max_x - min_x, max_y - min_y) + 1\n    if size == 1:\n        if screen[min_y][min_x] == 'w':\n            screen[min_y][min_x] = '+'\n        return screen\n\n    for i in range(min_y, max_y + 1):\n        if screen[i][min_x]!= 'w':\n            screen[i] = screen[i][:min_x] + '+' + screen[i][min_x + 1:]\n        if screen[i][max_x]!= 'w':\n            screen[i] = screen[i][:max_x] + '+' + screen[i][max_x + 1:]\n\n    for j in range(min_x, max_x + 1):\n        if screen[min_y][j]!= 'w':\n            screen[min_y] = screen[min_y][:j] + '+' + screen[min_y][j + 1:]\n        if screen[max_y][j]!= 'w':\n            screen[max_y] = screen[max_y][:j] + '+' + screen[max_y][j + 1:]\n\n    return screen\n\n\ndef check_frame(n, m, screen):\n    min_x, max_x, min_y, max_y = float('inf'), float('-inf'), float('inf'), float('-inf')\n    for i in range(n):\n        for j in range(m):\n            if screen[i][j] == 'w':\n                min_x, max_x = min(min_x, j), max(max_x, j)\n                min_y, max_y = min(min_y, i), max(max_y, i)\n\n    size = max(max_x - min_x, max_y - min_y) + 1\n    for i in range(n):\n        for j in range(m):\n            if (i == min_y or i == max_y or j == min_x or j == max_x) and screen[i][j]!= 'w' and screen[i][j]!= '+':\n                return False\n            if screen[i][j] == 'w' and (i < min_y or i > max_y or j < min_x or j > max_x):\n                return False\n    return True\n\n\ndef main():\n    n, m = map(int, input().split())\n    screen = [list(input()) for _ in range(n)]\n\n    frame = find_frame(n, m, screen)\n    if check_frame(n, m, frame):\n        for row in frame:\n            print(''.join(row))\n    else:\n        print(-1)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef extended_gcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x, y = extended_gcd(b % a, a)\n        return gcd, y - (b // a) * x, x\n\ndef solve(n, a, b):\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd!= 0:\n        return None\n    x *= n // gcd\n    y *= n // gcd\n    k = b // gcd\n    x = x % k\n    if x < 0:\n        x += k\n    return x, y\n\nn = int(input())\na = int(input())\nb = int(input())\n\nsolution = solve(n, a, b)\nif solution is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(*solution)"}
{"solution": "def int_to_words(n):\n    ones = ['', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight', 'nine']\n    teens = ['ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen','sixteen','seventeen', 'eighteen', 'nineteen']\n    tens = ['', '', 'twenty', 'thirty', 'forty', 'fifty','sixty','seventy', 'eighty', 'ninety']\n\n    if n < 10:\n        return ones[n]\n    elif n < 20:\n        return teens[n - 10]\n    elif n < 100:\n        return tens[n // 10] + ('' if n % 10 == 0 else '-' + ones[n % 10])\n\ns = int(input())\nprint(int_to_words(s))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmax_erase = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        left = a[i] - 1\n        right = a[j] + 1\n        if left < 1:\n            left = 1\n        if right > 1000:\n            right = 1000\n        if right - left >= j - i + 1:\n            max_erase = max(max_erase, j - i - 1)\n\nprint(max_erase)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ntotal_problems = sum(a)\nhalf_problems = total_problems / 2\ncurrent_problems = 0\n\nfor i in range(n):\n    current_problems += a[i]\n    if current_problems >= half_problems:\n        print(i + 1)\n        break"}
{"solution": "import sys\nfrom collections import deque\n\ndef get_pos(num):\n    return (num - 1) // n, (num - 1) % n\n\ndef get_num(pos):\n    return pos[0] * n + pos[1] + 1\n\ndef is_valid(pos):\n    return 0 <= pos[0] < n and 0 <= pos[1] < n\n\ndef get_knight_moves(pos):\n    moves = []\n    for dx, dy in [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]:\n        new_pos = (pos[0] + dx, pos[1] + dy)\n        if is_valid(new_pos):\n            moves.append(new_pos)\n    return moves\n\ndef get_bishop_moves(pos):\n    moves = []\n    for dx, dy in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:\n        new_pos = (pos[0] + dx, pos[1] + dy)\n        while is_valid(new_pos):\n            moves.append(new_pos)\n            new_pos = (new_pos[0] + dx, new_pos[1] + dy)\n    return moves\n\ndef get_rook_moves(pos):\n    moves = []\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        new_pos = (pos[0] + dx, pos[1] + dy)\n        while is_valid(new_pos):\n            moves.append(new_pos)\n            new_pos = (new_pos[0] + dx, new_pos[1] + dy)\n    return moves\n\ndef bfs():\n    queue = deque([(get_pos(1), 0, 0, 0)])\n    visited = set([(get_pos(1), 0)])\n    while queue:\n        pos, num, steps, replacements = queue.popleft()\n        if num == n * n:\n            return steps, replacements\n        for new_pos in get_knight_moves(pos) + get_bishop_moves(pos) + get_rook_moves(pos):\n            if get_num(new_pos) > num:\n                new_num = get_num(new_pos)\n                if (new_pos, new_num) not in visited:\n                    visited.add((new_pos, new_num))\n                    queue.append((new_pos, new_num, steps + 1, replacements))\n                if (new_pos, num) not in visited:\n                    visited.add((new_pos, num))\n                    queue.append((new_pos, num, steps + 1, replacements + 1))\n    return -1, -1\n\nn = int(sys.stdin.readline())\nboard = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\nsteps, replacements = bfs()\nprint(steps, replacements)"}
{"solution": "import math\n\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\ndef get_floor_and_block(num, n, m, k):\n    block = math.ceil(num / (m * k))\n    floor = math.ceil((num - (block - 1) * m * k) / k)\n    return block, floor\n\na_block, a_floor = get_floor_and_block(a, n, m, k)\nb_block, b_floor = get_floor_and_block(b, n, m, k)\n\nblocks_diff = abs(a_block - b_block)\nfloors_diff = abs(a_floor - b_floor)\n\nblocks_diff_clockwise = min(blocks_diff, n - blocks_diff)\nblocks_diff_counter_clockwise = min(n - blocks_diff, blocks_diff)\n\ntime_clockwise = blocks_diff_clockwise * 15 + floors_diff * 5\ntime_counter_clockwise = blocks_diff_counter_clockwise * 15 + floors_diff * 5\n\ntime_with_lift = 10 + abs(a_floor - 1) + blocks_diff_clockwise * 15 + abs(b_floor - 1)\ntime_with_lift_counter = 10 + abs(a_floor - 1) + blocks_diff_counter_clockwise * 15 + abs(b_floor - 1)\n\nprint(min(time_clockwise, time_counter_clockwise, time_with_lift, time_with_lift_counter))"}
{"solution": "s = input()\nif s[-6:] >= '1000000' and '1' in s[:-6]:\n    print('yes')\nelse:\n    print('no')"}
{"solution": "def solve(s):\n    result = []\n    target = 'abcdefghijklmnopqrstuvwxyz'\n    target_index = 0\n\n    for char in s:\n        if char >= target[target_index]:\n            result.append(char)\n            while target_index < len(target) and char == target[target_index]:\n                target_index += 1\n        else:\n            next_char = chr(ord(char) + 1)\n            if next_char > 'z':\n                continue\n            result.append(next_char)\n            while target_index < len(target) and next_char == target[target_index]:\n                target_index += 1\n\n    if target_index < len(target):\n        return -1\n    return ''.join(result)\n\n\ns = input()\nprint(solve(s))"}
{"solution": "import math\n\nn, m, r, k = map(int, input().split())\n\nif k == 1:\n    print(1 / ((n - r + 1) * (m - r + 1)))\nelse:\n    ans = 0\n    for i in range(1, min(r, k) + 1):\n        x = min(math.ceil(k / i), n)\n        y = min(math.ceil(k / i), m)\n        ans = max(ans, (k * (k - 1)) / (2 * (x - r + 1) * (y - r + 1)))\n\n    print(ans + k / ((n - r + 1) * (m - r + 1)))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\nnegatives = sum(1 for x in a if x < 0)\nzeros = sum(1 for x in a if x == 0)\n\nif zeros > 0:\n    print(*a)\nelif negatives % 2 == 1:\n    print(*[-x-1 if x > 0 else x for x in a])\nelse:\n    min_index = a.index(min(a))\n    print(*[-x-1 if i!= min_index and x > 0 else x for i, x in enumerate(a)])"}
{"solution": "import math\n\ndef prime_factors(n):\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n = n / i\n    if n > 2:\n        factors.append(n)\n    return factors\n\ndef kth_smallest_divisor(n, k):\n    factors = prime_factors(n)\n    unique_factors = list(set(factors))\n    factor_counts = [factors.count(factor) for factor in unique_factors]\n    divisors = [1]\n    for i in range(len(unique_factors)):\n        new_divisors = []\n        for j in range(factor_counts[i] + 1):\n            for divisor in divisors:\n                new_divisors.append(divisor * (unique_factors[i] ** j))\n        divisors = new_divisors\n    divisors.sort()\n    if k > len(divisors):\n        return -1\n    else:\n        return divisors[k - 1]\n\nn, k = map(int, input().split())\nprint(kth_smallest_divisor(n, k))"}
{"solution": "from collections import defaultdict\nfrom itertools import permutations\n\ndef get_digits(cube):\n    digits = set(cube)\n    for i in range(6):\n        if cube[i] in [0, 1, 8]:\n            digits.add(cube[i])\n        elif cube[i] == 6:\n            digits.add(9)\n        elif cube[i] == 9:\n            digits.add(6)\n    return digits\n\ndef get_numbers(cubes, n):\n    numbers = set()\n    for p in permutations(cubes, n):\n        digits = [get_digits(cube) for cube in p]\n        for d in product(*digits):\n            if d[0]!= 0:\n                numbers.add(int(''.join(map(str, d))))\n    return numbers\n\ndef main():\n    n = int(input())\n    cubes = [list(map(int, input().split())) for _ in range(n)]\n    numbers = set()\n    for i in range(1, n + 1):\n        numbers.update(get_numbers(cubes, i))\n    x = 1\n    while x in numbers:\n        x += 1\n    print(x - 1)\n\nif __name__ == \"__main__\":\n    from itertools import product\n    main()"}
{"solution": "import math\n\nn, k = map(int, input().split())\npower_of_ten = 10 ** k\nlcm = (n * power_of_ten) // math.gcd(n, power_of_ten)\nprint(lcm)"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n\n    if any(a[i][j] == 1 and a[i+1][j] == 1 and a[i][j+1] == 1 and a[i+1][j+1] == 1 for i in range(n-1) for j in range(m-1)):\n        print(-1)\n        return\n\n    ans = []\n    for i in range(n-1):\n        for j in range(m-1):\n            if a[i][j] == 1 and a[i+1][j] == 0 and a[i][j+1] == 0 and a[i+1][j+1] == 0:\n                ans.append((i, j))\n                a[i][j] = a[i+1][j] = a[i][j+1] = a[i+1][j+1] = 1\n\n    for i in range(n-1):\n        for j in range(m-1):\n            if a[i][j] == 0 and a[i+1][j] == 1 and a[i][j+1] == 1 and a[i+1][j+1] == 0:\n                ans.append((i, j))\n                a[i][j] = a[i+1][j] = a[i][j+1] = a[i+1][j+1] = 1\n\n    for i in range(n-1):\n        for j in range(m-1):\n            if a[i][j] == 1 and a[i+1][j] == 1 and a[i][j+1] == 1 and a[i+1][j+1] == 1:\n                ans.append((i, j))\n                a[i][j] = a[i+1][j] = a[i][j+1] = a[i+1][j+1] = 1\n\n    for i in range(n-1):\n        for j in range(m-1):\n            if a[i][j] == 1 and a[i+1][j] == 1 and a[i][j+1] == 1 and a[i+1][j+1] == 0:\n                ans.append((i, j))\n                a[i][j] = a[i+1][j] = a[i][j+1] = a[i+1][j+1] = 1\n\n    for i in range(n-1):\n        for j in range(m-1):\n            if a[i][j] == 1 and a[i+1][j] == 0 and a[i][j+1] == 1 and a[i+1][j+1] == 1:\n                ans.append((i, j))\n                a[i][j] = a[i+1][j] = a[i][j+1] = a[i+1][j+1] = 1\n\n    for i in range(n-1):\n        for j in range(m-1):\n            if a[i][j] == 0 and a[i+1][j] == 1 and a[i][j+1] == 1 and a[i+1][j+1] == 1:\n                ans.append((i, j))\n                a[i][j] = a[i+1][j] = a[i][j+1] = a[i+1][j+1] = 1\n\n    if any(a[i][j] == 0 for i in range(n) for j in range(m)):\n        print(-1)\n        return\n\n    print(len(ans))\n    for x, y in ans:\n        print(x+1, y+1)\n\nsolve()"}
{"solution": "import sys\n\ndef read_input():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef calculate_probability(r, s, p):\n    total = r + s + p\n    return (r * (s + p) + s * p) / (total * (total - 1))\n\ndef calculate_survival_probability(r, s, p):\n    total = r + s + p\n    if total == 1:\n        return 1.0\n    if r == 0:\n        return 0.0\n    if s == 0:\n        return 1.0\n    if p == 0:\n        return 1.0\n    probability = calculate_probability(r, s, p)\n    if r == 1:\n        return probability * (s / (total - 1)) * (p / (total - 2))\n    if s == 1:\n        return probability * (r / (total - 1)) * (p / (total - 2))\n    if p == 1:\n        return probability * (r / (total - 1)) * (s / (total - 2))\n    return probability * (calculate_survival_probability(r - 1, s - 1, p) + \n                          calculate_survival_probability(r - 1, s, p - 1) + \n                          calculate_survival_probability(r, s - 1, p - 1)) / 3\n\ndef main():\n    r, s, p = read_input()\n    print(calculate_survival_probability(r, s, p), \n          calculate_survival_probability(s, p, r), \n          calculate_survival_probability(p, r, s))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_time_together(l1, r1, l2, r2, k):\n    start = max(l1, l2)\n    end = min(r1, r2)\n    time_together = max(0, end - start + 1)\n    if k >= start and k <= end:\n        time_together -= 1\n    return time_together\n\nl1, r1, l2, r2, k = map(int, input().split())\nprint(calculate_time_together(l1, r1, l2, r2, k))"}
{"solution": "import sys\n\ndef main():\n    input = sys.stdin.readline\n\n    N, M = map(int, input().split())\n    A = []\n    B = []\n    C = []\n    D = []\n    E = []\n    F = []\n\n    for _ in range(N):\n        a, b, c = map(int, input().split())\n        A.append(a)\n        B.append(b)\n        C.append(c)\n\n    for _ in range(M):\n        d, e, f = map(int, input().split())\n        D.append(d)\n        E.append(e)\n        F.append(f)\n\n    def check(x):\n        for i in range(N):\n            if A[i] <= x <= B[i] and C[i] == 0:\n                return False\n        return True\n\n    def check2(y):\n        for i in range(M):\n            if E[i] <= y <= F[i] and D[i] == 0:\n                return False\n        return True\n\n    left = 0\n    right = 10**9\n    while left < right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    if left == 10**9:\n        print(\"INF\")\n        return\n\n    down = -10**9\n    up = 0\n    while up - down > 1:\n        mid = (up + down) // 2\n        if check2(mid):\n            down = mid\n        else:\n            up = mid\n\n    ans = 0\n    for i in range(N):\n        if C[i] > 0:\n            continue\n        if A[i] < 0 and B[i] > 0:\n            continue\n        if A[i] < 0:\n            a = 0\n            b = B[i]\n        else:\n            a = A[i]\n            b = 0\n        if a < b:\n            a, b = b, a\n        if a > left:\n            continue\n        if b > left:\n            b = left\n        if a > down:\n            a = down\n        if b > down:\n            b = down\n        ans += (a - b) * abs(C[i])\n\n    for i in range(M):\n        if D[i] > 0:\n            continue\n        if E[i] < 0 and F[i] > 0:\n            continue\n        if E[i] < 0:\n            e = 0\n            f = F[i]\n        else:\n            e = E[i]\n            f = 0\n        if e < f:\n            e, f = f, e\n        if e > down:\n            continue\n        if f > down:\n            f = down\n        if e > up:\n            e = up\n        if f > up:\n            f = up\n        ans += (e - f) * abs(D[i])\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "t, s, x = map(int, input().split())\n\nif t == x or (x - t) % s == 0 or (x - t) % s == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        l, r = map(int, sys.stdin.readline().split())\n        segments.append((l, r, i + 1))\n\n    segments.sort()\n\n    min_r = float('inf')\n    min_r_index = -1\n    for l, r, index in segments:\n        if r < min_r:\n            min_r = r\n            min_r_index = index\n        elif l > segments[0][0] and r <= min_r:\n            print(index, min_r_index)\n            return\n\n    print(-1, -1)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "n = int(input())\ns = input()\n\ncounts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\nfor char in s:\n    if char in counts:\n        counts[char] += 1\n\ntarget_count = max(counts.values())\nif (n % 4!= 0) or any(count > target_count + (n - target_count * 4) for count in counts.values()):\n    print(\"===\")\nelse:\n    for char in 'ACGT':\n        counts[char] += (n - sum(counts.values())) // 4\n\n    result = []\n    for char in s:\n        if char == '?':\n            for c in 'ACGT':\n                if counts[c] > 0:\n                    result.append(c)\n                    counts[c] -= 1\n                    break\n        else:\n            result.append(char)\n\n    print(''.join(result))"}
{"solution": "def check_win(board, symbol):\n    # Check rows\n    for row in board:\n        if row.count(symbol) == 3 and '.' in row:\n            return True\n\n    # Check columns\n    for col in range(4):\n        column = [row[col] for row in board]\n        if column.count(symbol) == 3 and '.' in column:\n            return True\n\n    # Check diagonals\n    diagonal1 = [board[i][i] for i in range(4)]\n    diagonal2 = [board[i][3-i] for i in range(4)]\n    if (diagonal1.count(symbol) == 3 and '.' in diagonal1) or (diagonal2.count(symbol) == 3 and '.' in diagonal2):\n        return True\n\n    return False\n\n\ndef main():\n    board = [input() for _ in range(4)]\n    print(\"YES\" if check_win(board, 'x') else \"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_divide_array(n, a):\n    total_sum = sum(a)\n    if total_sum % 2!= 0:\n        return False\n\n    target_sum = total_sum // 2\n    prefix_sum = 0\n    for i in range(n):\n        prefix_sum += a[i]\n        if prefix_sum == target_sum:\n            return True\n\n    for i in range(n):\n        new_prefix_sum = prefix_sum - a[i]\n        if new_prefix_sum == target_sum:\n            return True\n        new_prefix_sum += a[i] + (a[(i + 1) % n] if i < n - 1 else 0)\n        if new_prefix_sum == target_sum:\n            return True\n\n    return False\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nif can_divide_array(n, a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\na.sort()\nb.sort()\n\ni = 0\nj = 0\nincreasing = True\n\nwhile i < n and j < k:\n    if a[i] == 0:\n        a[i] = b[j]\n        j += 1\n    elif a[i] > a[i-1]:\n        increasing = False\n    i += 1\n\nif j < k:\n    a[i:] = b[j:]\n\nprint(\"Yes\" if not increasing else \"No\")"}
{"solution": "x, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\nandrew = min(x, a)\ndmitry = min(max(y - (a - andrew), 0), a - andrew + b)\nmichal = min(z, a - andrew - dmitry + b - dmitry + c)\n\nif andrew + dmitry + michal >= x + y + z:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def is_accident_possible(traffic_lights):\n    for i in range(4):\n        if traffic_lights[i][3] == 1:\n            if traffic_lights[i][0] == 1 or traffic_lights[i][1] == 1 or traffic_lights[i][2] == 1:\n                return True\n            if traffic_lights[(i-1)%4][1] == 1 or traffic_lights[(i+1)%4][1] == 1:\n                return True\n    return False\n\ntraffic_lights = [list(map(int, input().split())) for _ in range(4)]\n\nprint(\"YES\" if is_accident_possible(traffic_lights) else \"NO\")"}
{"solution": "def get_key_positions():\n    return {\n        '0': (0, 0), '1': (0, 1), '2': (0, 2),\n        '3': (1, 0), '4': (1, 1), '5': (1, 2),\n        '6': (2, 0), '7': (2, 1), '8': (2, 2), '9': (3, 1)\n    }\n\ndef get_finger_movements(number, key_positions):\n    movements = []\n    for i in range(len(number) - 1):\n        x1, y1 = key_positions[number[i]]\n        x2, y2 = key_positions[number[i + 1]]\n        movement = (x2 - x1, y2 - y1)\n        movements.append(movement)\n    return movements\n\ndef has_same_movements(number, key_positions):\n    movements = get_finger_movements(number, key_positions)\n    for i in range(10 ** len(number)):\n        new_number = str(i).zfill(len(number))\n        if new_number == number:\n            continue\n        if get_finger_movements(new_number, key_positions) == movements:\n            return True\n    return False\n\ndef main():\n    n = int(input())\n    number = input()\n    key_positions = get_key_positions()\n    if has_same_movements(number, key_positions):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef main():\n    n, f = map(int, sys.stdin.readline().split())\n    days = []\n    for _ in range(n):\n        k, l = map(int, sys.stdin.readline().split())\n        days.append((k, l))\n\n    days.sort(key=lambda x: min(x[0], x[1]) - min(x[0]*2, x[1]), reverse=True)\n\n    sold = 0\n    for i, (k, l) in enumerate(days):\n        if i < f:\n            sold += min(k*2, l)\n        else:\n            sold += min(k, l)\n\n    print(sold)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\nn, k = map(int, input().split())\n\nmessiness = 0\nswaps = min(k, n // 2)\n\nmessiness += swaps * (2 * n - 2 * swaps - 1)\n\nprint(messiness)"}
{"solution": "import math\n\ndef solve():\n    n, m, k, l = map(int, input().split())\n    if n < m:\n        print(-1)\n        return\n    if n - k < l:\n        print(-1)\n        return\n    if n - k >= m:\n        print(math.ceil(l / m))\n        return\n    print(math.ceil((n - k) / (n - m + 1)))\n\nsolve()"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    def count_black_cells_in_square(x, y, size):\n        count = 0\n        for i in range(x, x + size):\n            for j in range(y, y + size):\n                if grid[i][j] == 'B':\n                    count += 1\n        return count\n\n    def is_square_possible(x, y, size):\n        for i in range(x, x + size):\n            for j in range(y, y + size):\n                if grid[i][j] == 'W':\n                    return False\n        return True\n\n    min_cells = float('inf')\n    for size in range(1, min(n, m) + 1):\n        for x in range(n - size + 1):\n            for y in range(m - size + 1):\n                if is_square_possible(x, y, size):\n                    cells_to_paint = size * size - count_black_cells_in_square(x, y, size)\n                    min_cells = min(min_cells, cells_to_paint)\n\n    if min_cells == float('inf'):\n        return -1\n    return min_cells\n\n\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\nprint(min_cells_to_paint(n, m, grid))"}
{"solution": "n = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\nif sum(x)!= sum(y):\n    print(\"No\")\nelse:\n    print(\"Yes\")"}
{"solution": "n = int(input())\nangles = list(map(int, input().split()))\n\ntotal_angle = sum(angles)\nmin_diff = float('inf')\ncurr_angle = 0\n\nfor angle in angles:\n    curr_angle += angle\n    diff = abs(curr_angle - (total_angle - curr_angle))\n    min_diff = min(min_diff, diff)\n\nprint(min_diff)"}
{"solution": "MOD = 10**9 + 7\n\ndef pow_mod(a, b):\n    res = 1\n    while b:\n        if b & 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b >>= 1\n    return res\n\ndef main():\n    n, m = map(int, input().split())\n    ans = pow_mod(m, n)\n    ans = (ans - pow_mod(m - 1, n) + MOD) % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\nn = int(input())\n\nif n == 1:\n    print(-1)\nelse:\n    m = (n * n + 1) // 2\n    k = (n * n - 1) // 2\n    if math.sqrt(k) % 1 == 0 and math.sqrt(m) % 1 == 0:\n        print(int(math.sqrt(k)), int(math.sqrt(m)))\n    else:\n        print(-1)"}
{"solution": "def check_remainders(n, k):\n    for i in range(2, int(k**0.5) + 1):\n        if n % i == 0:\n            return \"No\"\n        if i * i > n:\n            break\n    for i in range(int(k**0.5) + 1, k + 1):\n        if n % i == 0:\n            return \"No\"\n    return \"Yes\"\n\nn, k = map(int, input().split())\nprint(check_remainders(n, k))"}
{"solution": "a = input().lstrip('0') or '0'\nb = input().lstrip('0') or '0'\n\nif len(a) > len(b):\n    print('>')\nelif len(a) < len(b):\n    print('<')\nelse:\n    print('>' if a > b else '<' if a < b else '=')"}
{"solution": "MOD = 10**9 + 7\n\ndef solve():\n    n, p = map(int, input().split())\n    c = list(map(int, input().split()))\n\n    dp = [[[[0 for _ in range(2)] for _ in range(2)] for _ in range(n+1)] for _ in range(n+1)]\n    dp[0][0][0][0] = 1\n\n    for i in range(n):\n        for j in range(i+1):\n            for k in range(2):\n                for l in range(2):\n                    if c[i] == -1:\n                        for m in range(2):\n                            for x in range(2):\n                                dp[i+1][j+(m!=k)][m][l^(x!=k)] += dp[i][j][k][l]\n                                dp[i+1][j+(m!=k)][m][l^(x!=k)] %= MOD\n                    elif c[i] == k:\n                        for x in range(2):\n                            dp[i+1][j][k][l^(x!=k)] += dp[i][j][k][l]\n                            dp[i+1][j][k][l^(x!=k)] %= MOD\n                    else:\n                        for x in range(2):\n                            dp[i+1][j+1][k][l^(x!=k)] += dp[i][j][k][l]\n                            dp[i+1][j+1][k][l^(x!=k)] %= MOD\n\n    ans = 0\n    for i in range(n+1):\n        ans += dp[n][i][0][p]\n        ans += dp[n][i][1][p]\n        ans %= MOD\n\n    print(ans)\n\nsolve()"}
{"solution": "n, a, b, c = map(int, input().split())\n\ndef min_cost(n, a, b, c):\n    min_val = float('inf')\n    for i in range(4):\n        k = (4 - n % 4) % 4\n        if i == 0:\n            cost = k * a\n        elif i == 1:\n            cost = (k // 2) * b + (k % 2) * a\n        elif i == 2:\n            cost = (k // 3) * c + ((k % 3) // 2) * b + ((k % 3) % 2) * a\n        else:\n            cost = min(k * a, (k // 2) * b, (k // 3) * c)\n        min_val = min(min_val, cost)\n    return min_val\n\nprint(min_cost(n, a, b, c))"}
{"solution": "from collections import defaultdict, deque\n\ndef dfs(graph, visited, stack, vertex):\n    visited[vertex] = True\n    for neighbor in graph[vertex]:\n        if not visited[neighbor]:\n            if dfs(graph, visited, stack, neighbor):\n                return True\n        elif stack[neighbor]:\n            return True\n    stack[vertex] = True\n    return False\n\ndef is_acyclic(graph, n):\n    visited = [False] * n\n    stack = [False] * n\n    for vertex in range(n):\n        if not visited[vertex]:\n            if dfs(graph, visited, stack, vertex):\n                return False\n    return True\n\ndef remove_edge(graph, u, v):\n    graph[u].remove(v)\n    return graph\n\ndef main():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        edges.append((u, v))\n\n    if is_acyclic(graph, n):\n        print(\"YES\")\n        return\n\n    for u, v in edges:\n        new_graph = remove_edge(graph, u, v)\n        if is_acyclic(new_graph, n):\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef solve():\n    n, m = read_ints()\n    antennas = []\n    for _ in range(n):\n        x, s = read_ints()\n        antennas.append((x, s))\n\n    antennas.sort()\n\n    dp = [float('inf')] * (m + 1)\n    dp[0] = 0\n\n    for x, s in antennas:\n        for i in range(m, -1, -1):\n            if i - s - 1 >= 0:\n                dp[i] = min(dp[i], dp[i - s - 1] + max(0, i - x))\n            if i + s + 1 <= m:\n                dp[i] = min(dp[i], dp[i + s + 1] + max(0, x - i))\n\n    return dp[m]\n\nprint(solve())"}
{"solution": "def solve():\n    W = int(input())\n    cnt = list(map(int, input().split()))\n\n    dp = [0] * 9\n    dp[0] = 1\n\n    for i in range(8):\n        for j in range(8, -1, -1):\n            for k in range(cnt[i]):\n                if j + i + 1 >= 9:\n                    break\n                dp[j + i + 1] |= dp[j]\n\n    ans = 0\n    for i in range(9):\n        if dp[i]:\n            ans = max(ans, min(i, W))\n\n    print(ans)\n\nsolve()"}
{"solution": "import sys\n\ndef solve():\n    n, L = map(int, sys.stdin.readline().split())\n    c = list(map(int, sys.stdin.readline().split()))\n\n    ans = float('inf')\n    for mask in range(1 << n):\n        cost = 0\n        volume = 0\n        for i in range(n):\n            if (mask >> i) & 1:\n                volume += (1 << (i + 1)) - 1\n                cost += c[i]\n        if volume >= L:\n            ans = min(ans, cost)\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import sys\n\nn = int(sys.stdin.readline())\na = list(map(int, sys.stdin.readline().split()))\n\na.sort()\n\nmex = 1\nfor i in range(n):\n    if a[i] >= mex:\n        while i < n and a[i] >= mex:\n            i += 1\n        mex += 1\n    else:\n        mex = a[i] + 1\n\nprint(mex)"}
{"solution": "def is_lucky(n, ticket):\n    total_sum = sum(int(digit) for digit in ticket)\n    for segment_sum in range(1, total_sum):\n        segment_count = 0\n        current_sum = 0\n        for digit in ticket:\n            current_sum += int(digit)\n            if current_sum == segment_sum:\n                segment_count += 1\n                current_sum = 0\n            elif current_sum > segment_sum:\n                break\n        if current_sum == 0 and segment_count > 1:\n            return True\n    return False\n\nn = int(input())\nticket = input()\nprint(\"YES\" if is_lucky(n, ticket) else \"NO\")"}
{"solution": "username = input()\ndistinct_chars = set(username)\nif len(distinct_chars) % 2 == 0:\n    print(\"CHAT WITH HER!\")\nelse:\n    print(\"IGNORE HIM!\")"}
{"solution": "n, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\nmax_diff = 0\nfor i in range(n):\n    diff = 0\n    test_tabs = 0\n    social_tabs = 0\n    for j in range(n):\n        if (j - i) % k!= 0:\n            if tabs[j] == 1:\n                test_tabs += 1\n            else:\n                social_tabs += 1\n    diff = abs(test_tabs - social_tabs)\n    max_diff = max(max_diff, diff)\n\nprint(max_diff)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n, c0, c1 = map(int, read_input().split())\n    if c0 > c1:\n        c0, c1 = c1, c0\n\n    total_cost = 0\n    nodes = 1\n    depth = 0\n\n    while nodes < n:\n        nodes *= 2\n        depth += 1\n\n    if nodes > n:\n        nodes //= 2\n        depth -= 1\n\n    total_cost += nodes * depth * c0\n\n    remaining_nodes = n - nodes\n    total_cost += remaining_nodes * (depth + 1) * c1\n\n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve(n, a, x, b, y):\n    if a < x:\n        daniel_stations = list(range(a, x + 1))\n    else:\n        daniel_stations = list(range(a, n + 1)) + list(range(1, x + 1))\n\n    if b < y:\n        vlad_stations = list(range(b, y + 1))\n    else:\n        vlad_stations = list(range(b, n + 1)) + list(range(1, y + 1))\n\n    return any(station in vlad_stations for station in daniel_stations)\n\n\nn, a, x, b, y = map(int, input().split())\nprint(\"YES\" if solve(n, a, x, b, y) else \"NO\")"}
{"solution": "import math\n\ndef get_next_power(x, y, n):\n    a = 0\n    while x ** a <= n:\n        b = 0\n        while x ** a + y ** b <= n:\n            if x ** a + y ** b == n:\n                return True\n            b += 1\n        a += 1\n    return False\n\ndef get_max_golden_age(x, y, l, r):\n    max_golden_age = 0\n    i = l\n    while i <= r:\n        if not get_next_power(x, y, i):\n            j = i + 1\n            while j <= r and not get_next_power(x, y, j):\n                j += 1\n            max_golden_age = max(max_golden_age, j - i)\n            i = j\n        else:\n            i += 1\n    return max_golden_age\n\nx, y, l, r = map(int, input().split())\nprint(get_max_golden_age(x, y, l, r))"}
{"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef min_tax(n):\n    if is_prime(n):\n        return 1\n    if n % 2 == 0:\n        return 2\n    return 3\n\nn = int(input())\nprint(min_tax(n))"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    result = []\n    current_word = []\n    current_consonants = set()\n\n    for char in word:\n        if char in vowels:\n            current_word.append(char)\n            current_consonants.clear()\n        else:\n            if char in current_consonants and len(current_consonants) > 1 and len(current_word) - len(current_consonants) >= 2:\n                result.append(''.join(current_word))\n                current_word = [char]\n                current_consonants = {char}\n            else:\n                current_word.append(char)\n                current_consonants.add(char)\n\n    if current_word:\n        result.append(''.join(current_word))\n\n    return''.join(result)\n\nword = input()\nprint(fix_typos(word))"}
{"solution": "import sys\n\nn, m, k = map(int, sys.stdin.readline().split())\nx, s = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\nb = list(map(int, sys.stdin.readline().split()))\nc = list(map(int, sys.stdin.readline().split()))\nd = list(map(int, sys.stdin.readline().split()))\n\nab = sorted(zip(a, b))\ncd = sorted(zip(c, d))\n\nmin_time = n * x\nfor ai, bi in ab:\n    if bi <= s:\n        time = (n - 1) * ai + 1\n        for j in range(k):\n            if d[j] + bi <= s:\n                time = min(time, (n - c[j] - 1) * ai + 1)\n            else:\n                break\n        min_time = min(min_time, time)\n\nfor ci, di in cd:\n    if di <= s:\n        time = (n - ci) * x\n        for j in range(m):\n            if b[j] + di <= s:\n                time = min(time, (n - ci - 1) * a[j] + 1)\n            else:\n                break\n        min_time = min(min_time, time)\n\nprint(min_time)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef solve():\n    n, k, M = read_ints()\n    t = list(read_ints())\n    t.sort()\n\n    task_times = [0] * (k + 1)\n    for i in range(1, k + 1):\n        task_times[i] = task_times[i - 1] + t[i - 1]\n\n    dp = [0] * (n * (k + 1) + 1)\n    for i in range(1, n + 1):\n        for j in range(k, -1, -1):\n            for p in range(n * (k + 1) - i * (j + 1), -1, -1):\n                new_points = i * (j + 1) if j == k else i * j\n                new_time = task_times[j] * i\n                if new_time <= M:\n                    dp[p + new_points] = max(dp[p + new_points], dp[p] + new_points)\n\n    ans = 0\n    for p in range(n * (k + 1) + 1):\n        time = 0\n        for i in range(1, n + 1):\n            for j in range(k, -1, -1):\n                new_points = i * (j + 1) if j == k else i * j\n                new_time = task_times[j] * i\n                if new_time <= M and p >= new_points:\n                    time = max(time, dp[p - new_points] + new_points)\n        ans = max(ans, time)\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "MOD = 998244353\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef mod_binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    else:\n        numerator = mod_factorial(n)\n        denominator = (mod_factorial(k) * mod_factorial(n - k)) % MOD\n        return (numerator * mod_inverse(denominator, MOD)) % MOD\n\ndef mod_catalan(n):\n    if n % 2 == 1:\n        return 0\n    else:\n        return (mod_binomial_coefficient(n, n // 2) * mod_inverse(n // 2 + 1, MOD)) % MOD\n\ndef solve(n):\n    if n % 2 == 1:\n        return 0\n    else:\n        return (mod_catalan(n) * mod_binomial_coefficient(n, n // 2)) % MOD\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def lara_croft_path(n, m, k):\n    # Calculate the number of full rows Lara has traversed\n    full_rows = k // (2 * (m - 1))\n\n    # Calculate the remaining moves after full rows\n    remaining_moves = k % (2 * (m - 1))\n\n    # Calculate the row and column based on the remaining moves\n    if remaining_moves < m - 1:\n        row = n - full_rows * 2 - 1\n        col = remaining_moves + 1\n    else:\n        row = n - full_rows * 2 - 2 + (remaining_moves - (m - 1))\n        col = m - (remaining_moves - (m - 1))\n\n    return row, col\n\n\nn, m, k = map(int, input().split())\nrow, col = lara_croft_path(n, m, k)\nprint(row, col)"}
{"solution": "import math\n\ndef prime_factors(n):\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef solve():\n    x = int(input())\n    factors = prime_factors(x)\n    a = 1\n    b = x\n    for p in set(factors):\n        if factors.count(p) > 1:\n            a *= p\n            b //= p\n    print(a, b)\n\nsolve()"}
{"solution": "a = int(input())\nb = int(input())\nc = int(input())\n\nratio = [1, 2, 4]\ntotal_fruits = [a, b, c]\n\nmin_multiple = float('inf')\nfor i in range(len(total_fruits)):\n    multiple = total_fruits[i] // ratio[i]\n    min_multiple = min(min_multiple, multiple)\n\nprint(min_multiple * sum(ratio))"}
{"solution": "n = int(input())\nratings = sorted(map(int, input().split()))\n\nprint(\"YES\" if ratings[n-1] > ratings[n] else \"NO\")"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef is_coprime(a, b):\n    return gcd(a, b) == 1\n\ndef make_coprime_array(arr):\n    result = [arr[0]]\n    count = 0\n    for i in range(1, len(arr)):\n        if is_coprime(result[-1], arr[i]):\n            result.append(arr[i])\n        else:\n            result.append(1)\n            count += 1\n            result.append(arr[i])\n    return count, result\n\nn = int(input())\narr = list(map(int, input().split()))\ncount, result = make_coprime_array(arr)\nprint(count)\nprint(*result)"}
{"solution": "import math\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ng = a[0]\nfor i in range(1, n):\n    g = gcd(g, a[i])\n\nans = g\nfor i in range(n):\n    a[i] //= g\n    a[i] %= n\n\ng = a[0]\nfor i in range(1, n):\n    g = gcd(g, a[i])\n\nprint(g * ans)"}
{"solution": "import math\n\nx = int(input())\nans = []\nwhile x!= 0 and len(ans) < 40:\n    if x & 1:\n        ans.append(0)\n        x += 1\n    else:\n        n = int(math.log2(x))\n        ans.append(n)\n        x ^= (1 << n) - 1\nif x!= 0:\n    n = int(math.log2(x + 1))\n    ans.append(n)\n    x ^= (1 << n) - 1\n    ans.append(0)\nprint(len(ans))\nfor i in range(0, len(ans), 2):\n    print(ans[i], end=' ')"}
{"solution": "import math\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nmin_hours = float('inf')\nfor bucket in a:\n    if k % bucket == 0:\n        min_hours = min(min_hours, k // bucket)\n\nprint(min_hours)"}
{"solution": "from collections import deque\n\ndef can_reach_target(n, k, line):\n    start = line.index('G')\n    target = line.index('T')\n    visited = set([start])\n    queue = deque([start])\n\n    while queue:\n        current = queue.popleft()\n        if current == target:\n            return True\n\n        for jump in [current - k, current + k]:\n            if 0 <= jump < n and line[jump]!= '#' and jump not in visited:\n                queue.append(jump)\n                visited.add(jump)\n\n    return False\n\nn, k = map(int, input().split())\nline = input().strip()\n\nprint(\"YES\" if can_reach_target(n, k, line) else \"NO\")"}
{"solution": "import math\n\ndef calculate_xw(y1, y2, yw, xb, yb, r):\n    if yb - r <= y1 and yb + r >= y2:\n        return -1\n\n    if yb - r <= y1:\n        yb = y1 + r\n    elif yb + r >= y2:\n        yb = y2 - r\n\n    xw = (xb * (y2 - yb) + (yw - yb) * (y2 - y1)) / (y2 - y1 + yw - yb)\n    return xw\n\ny1, y2, yw, xb, yb, r = map(float, input().split())\nxw = calculate_xw(y1, y2, yw, xb, yb, r)\nprint(\"{:.10f}\".format(xw) if xw!= -1 else -1)"}
{"solution": "b, d, s = map(int, input().split())\n\nif b == d == s:\n    print(0)\nelif b == d:\n    print(abs(b - s))\nelif b == s:\n    print(abs(b - d))\nelif d == s:\n    print(abs(d - b))\nelse:\n    min_val = min(b, d, s)\n    max_val = max(b, d, s)\n    mid_val = b + d + s - min_val - max_val\n\n    if max_val - min_val == 1:\n        print(0)\n    elif max_val - mid_val == 1:\n        print(mid_val - min_val)\n    else:\n        print(max_val - min_val - 1)"}
{"solution": "import math\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    min_x = 1\n    max_x = 10**9\n    min_y = 1\n    max_y = 10**9\n\n    for i in range(n - 1):\n        if a[i + 1] - a[i] > 0:\n            if a[i + 1] - a[i] == 1:\n                min_y = max(min_y, 2)\n            else:\n                min_x = max(min_x, (a[i + 1] - a[i]))\n        else:\n            if a[i] - a[i + 1] == 1:\n                min_y = max(min_y, 2)\n            else:\n                min_x = max(min_x, (a[i] - a[i + 1]))\n\n    for i in range(n - 1):\n        if a[i + 1] - a[i] > 0:\n            if a[i + 1] - a[i] == 1:\n                max_x = min(max_x, (a[i] - 1) // (min_y - 1) + 1)\n            else:\n                max_y = min(max_y, a[i] // min_x + 1)\n        else:\n            if a[i] - a[i + 1] == 1:\n                max_x = min(max_x, (a[i + 1] - 1) // (min_y - 1) + 1)\n            else:\n                max_y = min(max_y, a[i + 1] // min_x + 1)\n\n    if max_x < min_x or max_y < min_y:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(max_x, max_y)\n\nsolve()"}
{"solution": "def longest_subsequence(a, b):\n    i = 0\n    j = 0\n    result = []\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            result.append(a[i])\n            i += 1\n            j += 1\n        else:\n            i += 1\n    if not result:\n        return '-'\n    return ''.join(result)\n\na = input()\nb = input()\nprint(longest_subsequence(a, b))"}
{"solution": "n = int(input())\ns = input()\n\nminus_count = s.count('-')\nplus_count = n - minus_count\n\nif minus_count > plus_count:\n    print(0)\nelse:\n    print(plus_count - minus_count)"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nglass_bottles = n // b\nremaining_money = n % b\nadditional_glass_bottles = remaining_money // (b - c)\nadditional_glass_bottles += glass_bottles - 1\nadditional_glass_bottles = max(additional_glass_bottles, 0)\ntotal_glass_bottles = glass_bottles + additional_glass_bottles\n\nplastic_bottles = n // a\n\nprint(max(total_glass_bottles, plastic_bottles))"}
{"solution": "def card_war(n, k1, cards1, k2, cards2):\n    seen = set()\n    rounds = 0\n    while cards1 and cards2:\n        rounds += 1\n        card1 = cards1.pop(0)\n        card2 = cards2.pop(0)\n        if (tuple(cards1), tuple(cards2)) in seen:\n            return -1\n        seen.add((tuple(cards1), tuple(cards2)))\n        if card1 > card2:\n            cards1.extend([card2, card1])\n        else:\n            cards2.extend([card1, card2])\n    return rounds, 1 if cards1 else 2\n\nn = int(input())\nk1 = int(input().split()[0])\ncards1 = list(map(int, input().split()[1:]))\nk2 = int(input().split()[0])\ncards2 = list(map(int, input().split()[1:]))\n\nresult = card_war(n, k1, cards1, k2, cards2)\nprint(*result)"}
{"solution": "password = input()\n\ndef is_complex(password):\n    if len(password) < 5:\n        return False\n    has_upper = False\n    has_lower = False\n    has_digit = False\n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n    return has_upper and has_lower and has_digit\n\nprint(\"Correct\" if is_complex(password) else \"Too weak\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ncount_a = [0] * 6\ncount_b = [0] * 6\n\nfor i in a:\n    count_a[i] += 1\n\nfor i in b:\n    count_b[i] += 1\n\nexchanges = 0\nfor i in range(1, 6):\n    diff = abs(count_a[i] - count_b[i])\n    if diff % 2!= 0:\n        print(-1)\n        exit()\n    exchanges += diff // 2\n\nprint(exchanges)"}
{"solution": "from collections import deque\n\ndef is_valid_move(x, y, direction, rows, cols, horizontal_streets, vertical_streets):\n    if direction == 'N' and x > 0 and vertical_streets[y] == '^':\n        return True\n    elif direction == 'S' and x < rows - 1 and vertical_streets[y] == 'v':\n        return True\n    elif direction == 'E' and y < cols - 1 and horizontal_streets[x] == '>':\n        return True\n    elif direction == 'W' and y > 0 and horizontal_streets[x] == '<':\n        return True\n    return False\n\ndef bfs(start_x, start_y, rows, cols, horizontal_streets, vertical_streets):\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(start_x, start_y)])\n    visited[start_x][start_y] = True\n\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy, direction in [(-1, 0, 'N'), (1, 0, 'S'), (0, -1, 'W'), (0, 1, 'E')]:\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < rows and 0 <= new_y < cols and not visited[new_x][new_y] and is_valid_move(x, y, direction, rows, cols, horizontal_streets, vertical_streets):\n                queue.append((new_x, new_y))\n                visited[new_x][new_y] = True\n\n    return visited\n\ndef is_reachable(rows, cols, horizontal_streets, vertical_streets):\n    visited = bfs(0, 0, rows, cols, horizontal_streets, vertical_streets)\n    for i in range(rows):\n        for j in range(cols):\n            if not visited[i][j]:\n                return False\n    return True\n\ndef main():\n    rows, cols = map(int, input().split())\n    horizontal_streets = input()\n    vertical_streets = input()\n\n    if is_reachable(rows, cols, horizontal_streets, vertical_streets):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    if 1 not in a:\n        print(\"YES\")\n        print(\"0\" if n == 1 else \"(0->0)\")\n        return\n\n    if a[0] == 0:\n        print(\"YES\")\n        print(\"0\" if n == 1 else \"(0->1)\" if n == 2 else \"(((0)->1)->(1->\" + \"0\" + \"))\")\n        return\n\n    for i in range(1, n):\n        if a[i] == 0:\n            print(\"YES\")\n            print(\"(\" + \"->\".join(map(str, a[:i+1])) + \")\")\n            return\n\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "a, b = map(int, input().split())\n\nwhile a > 0 and b > 0:\n    if a >= 2 * b:\n        a -= 2 * b\n    elif b >= 2 * a:\n        b -= 2 * a\n\nprint(a, b)"}
{"solution": "k, a, b = map(int, input().split())\nprint((b // k) - ((a - 1) // k))"}
{"solution": "def find_kth_digit():\n    k = int(input())\n    length = 0\n    count = 0\n    num = 1\n\n    while length < k:\n        length += len(str(num))\n        count += 1\n        num += 1\n\n    if length!= k:\n        length -= len(str(num - 1))\n        count -= 1\n\n    diff = k - length\n    target_num = count + diff\n\n    return str(target_num)[diff - 1]\n\nprint(find_kth_digit())"}
{"solution": "n = int(input())\ns = input()\n\neight_count = s.count('8')\nif eight_count < 2:\n    print(\"NO\")\nelse:\n    first_eight = s.find('8')\n    second_eight = s.find('8', first_eight + 1)\n    if second_eight - first_eight > n - 11:\n        print(\"NO\")\n    else:\n        print(\"YES\")"}
{"solution": "MOD = 10**9 + 7\n\ndef comb(n, k):\n    if k > n - k:\n        k = n - k\n    result = 1\n    for i in range(k):\n        result = result * (n - i) // (i + 1)\n    return result\n\ndef solve():\n    n, x, pos = map(int, input().split())\n    if pos == 0:\n        return (x - 1) * (n - x) * comb(n - 2, x - 2) % MOD\n    elif pos == n - 1:\n        return (x - 1) * (n - x) * comb(n - 2, x - 1) % MOD\n    else:\n        left = pos\n        right = n - 1 - pos\n        if x == 1:\n            return 0\n        elif x == 2:\n            return comb(left + right, left) % MOD\n        elif x == n:\n            return comb(left + right, right) % MOD\n        else:\n            result = 0\n            for i in range(left + 1):\n                for j in range(right + 1):\n                    if i + j >= x - 2 and i + j <= x - 1:\n                        result += comb(left, i) * comb(right, j) * comb(left + right - i - j, left - i) % MOD\n            return result % MOD\n\nprint(solve())"}
{"solution": "def solve():\n    s = input()\n    k = int(input())\n    n = len(s)\n    dp = [[False] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(n):\n        if s[i].isalpha():\n            for j in range(k + 1):\n                if dp[i][j]:\n                    dp[i + 1][j] = True\n                    dp[i + 1][j + 1] = True\n        elif s[i] == '*':\n            for j in range(k + 1):\n                if dp[i - 1][j]:\n                    dp[i + 1][j] = True\n                    if j < k:\n                        dp[i + 1][j + 1] = True\n                        dp[i + 1][j + 2] = True\n        elif s[i] == '?':\n            for j in range(k + 1):\n                if dp[i - 1][j]:\n                    dp[i + 1][j] = True\n                    if j < k:\n                        dp[i + 1][j + 1] = True\n    if not dp[n][k]:\n        print(\"Impossible\")\n        return\n    ans = []\n    i, j = n, k\n    while i > 0 and j > 0:\n        if s[i - 1].isalpha():\n            ans.append(s[i - 1])\n            if dp[i - 1][j - 1]:\n                i -= 1\n                j -= 1\n            else:\n                i -= 2\n                j -= 1\n        elif s[i - 1] == '*':\n            if dp[i - 2][j - 1]:\n                ans.append(s[i - 2])\n                i -= 2\n                j -= 1\n            elif dp[i - 2][j - 2]:\n                ans.append(s[i - 2] * 2)\n                i -= 2\n                j -= 2\n            else:\n                i -= 2\n        elif s[i - 1] == '?':\n            if dp[i - 2][j - 1]:\n                ans.append(s[i - 2])\n                i -= 2\n                j -= 1\n            else:\n                i -= 2\n    print(''.join(reversed(ans)))\n\nsolve()"}
{"solution": "import math\n\nx = int(input())\nx = x % 360\nif x < 0:\n    x += 360\nx = (360 - x) % 360\nprint(min(math.ceil(x / 90), 4 - math.ceil(x / 90)))"}
{"solution": "a, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\ndef can_transform(a, b, c, x, y, z):\n    total = a + b + c\n    needed = x + y + z\n\n    if total < needed:\n        return False\n\n    if a >= x and b >= y and c >= z:\n        return True\n\n    if a % 2 == x % 2 and b % 2 == y % 2 and c % 2 == z % 2:\n        return True\n\n    return False\n\nprint(\"Yes\" if can_transform(a, b, c, x, y, z) else \"No\")"}
{"solution": "def modPow(a, n, mod):\n    res = 1\n    while n > 0:\n        if n % 2 == 1:\n            res = (res * a) % mod\n        a = (a * a) % mod\n        n //= 2\n    return res\n\ndef solve():\n    n, k, m = map(int, input().split())\n    dp = [0] * k\n    dp[0] = 1\n    for _ in range(n - 1):\n        ndp = [0] * k\n        for i in range(k):\n            for j in range(10):\n                ndp[(i * 10 + j) % k] = (ndp[(i * 10 + j) % k] + dp[i]) % m\n        dp = ndp\n    ans = 0\n    for i in range(1, k):\n        ans = (ans + dp[i] * modPow(10, n - 1, m)) % m\n    print(ans)\n\nsolve()"}
{"solution": "l, r, a = map(int, input().split())\n\nmin_lr = min(l, r)\nmax_lr = max(l, r)\ndiff = max_lr - min_lr\n\nif diff > a:\n    ans = min_lr * 2 + a * 2\nelse:\n    ans = (min_lr + diff) * 2 + (a - diff) * 2\n    if (a - diff) % 2!= 0:\n        ans -= 2\n\nprint(ans)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n, k = map(int, read_input().split())\n    k -= 1\n\n    dp = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for length in range(1, n):\n        for left in range(n - length):\n            right = left + length\n            if left == right:\n                dp[left][right] = 1\n                continue\n\n            for mid in range(left, right):\n                dp[left][right] = min(dp[left][right], dp[left][mid] + dp[mid + 1][right] + 2 * (mid - left + 1))\n\n            if right - left == 1:\n                dp[left][right] = min(dp[left][right], 3)\n\n    ans = float('inf')\n    for i in range(n):\n        ans = min(ans, dp[k][i] + dp[i][k] + 1)\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nn, m = map(int, sys.stdin.readline().split())\n\ndef get_heights(n, m):\n    heights = set()\n    i = 1\n    while len(heights) < n + m:\n        if i % 3!= 0:\n            heights.add(2 * i)\n        else:\n            heights.add(i)\n        i += 1\n    return heights\n\nheights = get_heights(n, m)\nprint(max(heights))"}
{"solution": "n = int(input())\na = [int(input()) for _ in range(n)]\ncounts = {}\nfor num in a:\n    counts[num] = counts.get(num, 0) + 1\npairs = [(num, count) for num, count in counts.items() if count % 2 == 0 and count!= n]\nif pairs:\n    print(\"YES\")\n    print(pairs[0][0], pairs[1][0] if len(pairs) > 1 else list(counts.keys() - {pairs[0][0]})[0])\nelse:\n    print(\"NO\")"}
{"solution": "def solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n\n    dp = [[0] * 1024 for _ in range(k + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, k + 1):\n        for j in range(1024):\n            if dp[i - 1][j]:\n                for k in range(8):\n                    if j & (1 << k):\n                        continue\n                    if k < 7 and not (j & (1 << (k + 1))):\n                        continue\n                    if a[i - 1] > n * (8 - bin(j).count('1') - bin(j).count('0')):\n                        continue\n                    dp[i][j | (1 << k)] = 1\n\n    for i in range(1024):\n        if dp[k][i] and a[-1] <= n * (8 - bin(i).count('1') - bin(i).count('0')):\n            print(\"YES\")\n            return\n    print(\"NO\")\n\nsolve()"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\nmin_cost = float('inf')\noptimal_t = -1\n\nfor t in range(1, 101):\n    cost = sum(min(abs(x - t), abs(x - (t - 1)), abs(x - (t + 1))) for x in a)\n    if cost < min_cost:\n        min_cost = cost\n        optimal_t = t\n\nprint(optimal_t, min_cost)"}
{"solution": "n, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\nmin_row = float('inf')\nmax_row = float('-inf')\nmin_col = float('inf')\nmax_col = float('-inf')\n\nfor i in range(n):\n    for j in range(m):\n        if field[i][j] == '*':\n            min_row = min(min_row, i)\n            max_row = max(max_row, i)\n            min_col = min(min_col, j)\n            max_col = max(max_col, j)\n\nside = max(max_row - min_row + 1, max_col - min_col + 1)\nprint(side)"}
{"solution": "import sys\ninput = sys.stdin.readline\n\nmod = 10**9 + 7\n\ndef pow_mod(a, b):\n    res = 1\n    while b:\n        if b & 1:\n            res = res * a % mod\n        a = a * a % mod\n        b >>= 1\n    return res\n\ndef inv_mod(a):\n    return pow_mod(a, mod - 2)\n\ndef comb(n, k):\n    return fact[n] * inv_fact[k] % mod * inv_fact[n - k] % mod\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nfact = [1] * (n + 1)\ninv_fact = [1] * (n + 1)\nfor i in range(1, n + 1):\n    fact[i] = fact[i - 1] * i % mod\n    inv_fact[i] = inv_mod(fact[i])\n\ncnt = [0] * 2\nfor i in a:\n    cnt[i] += 1\n\nif cnt[1] == 0 or cnt[0] == 0:\n    print(1)\n    exit()\n\ndp = [[0] * (cnt[1] + 1) for _ in range(n + 1)]\ndp[0][0] = 1\nfor i in range(n):\n    for j in range(min(i + 1, cnt[1]) + 1):\n        dp[i + 1][j] += dp[i][j] * (n - i - j) % mod * (n - i - j) % mod\n        dp[i + 1][j] %= mod\n        if j:\n            dp[i + 1][j] += dp[i][j] * j % mod * (n - i - cnt[1] + j) % mod\n            dp[i + 1][j] %= mod\n\nans = dp[n][cnt[1]] * inv_mod(comb(n, 2)) % mod\nfor i in range(n):\n    ans = ans * inv_mod(n - i) % mod * inv_mod(n - i) % mod\n\nif k < cnt[1]:\n    print(0)\nelse:\n    print(ans * comb(n, 2) % mod * pow_mod(comb(n, 2), k - cnt[1]) % mod)"}
{"solution": "x, y = map(int, input().split())\nprint(2 * (x - y) - (x - y) // 2)"}
{"solution": "import math\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\ndet = a * d - b * c\n\nif det == 0:\n    print(0)\nelse:\n    x1 = abs(det / (a + c))\n    x2 = abs(det / (a + d))\n    x3 = abs(det / (b + c))\n    x4 = abs(det / (b + d))\n\n    print(min(x1, x2, x3, x4))"}
{"solution": "n, a, b = map(int, input().split())\nt = list(map(int, input().split()))\n\ndenied = 0\noccupied_two_seaters = 0\n\nfor i in t:\n    if i == 1:\n        if a > 0:\n            a -= 1\n        elif b > 0:\n            b -= 1\n            occupied_two_seaters += 1\n        elif occupied_two_seaters > 0:\n            occupied_two_seaters -= 1\n        else:\n            denied += 1\n    else:\n        if b > 0:\n            b -= 1\n        else:\n            denied += 2\n\nprint(denied)"}
{"solution": "A, B, C, N = map(int, input().split())\ntotal_visited = A + B - C\nif total_visited > N or total_visited == N or A < C or B < C:\n    print(-1)\nelse:\n    print(N - total_visited)"}
{"solution": "MOD = 10**9 + 7\n\ndef solve():\n    x, k = map(int, input().split())\n    ans = x\n    for _ in range(k):\n        ans = (ans * 2 + (1 << _)) % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "MOD = 998244353\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef main():\n    n = int(input())\n    l, r = [0]*n, [0]*n\n    for i in range(n):\n        l[i], r[i] = map(int, input().split())\n\n    ans = 1\n    for i in range(n):\n        for j in range(i+1, n):\n            if l[j] < r[i]:\n                ans *= (r[i] - l[j] + 1)\n                ans %= MOD\n            if l[i] < r[j]:\n                ans *= mod_inverse(r[j] - l[i] + 1, MOD)\n                ans %= MOD\n\n    for i in range(n):\n        ans *= mod_inverse(r[i] - l[i] + 1, MOD)\n        ans %= MOD\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef count_ways(n):\n    count = 0\n    for a in range(1, n // 4 + 1):\n        for b in range(a, (n - 2 * a) // 2 + 1):\n            c = n - 2 * a - 2 * b\n            if c < b:\n                break\n            if c == b:\n                if 2 * a == b or 2 * b == a:\n                    continue\n                count += 3\n            elif c > b:\n                if 2 * a == c or 2 * b == c or 2 * a == b:\n                    continue\n                count += 6\n    return count\n\nn = int(input())\nprint(count_ways(n))"}
{"solution": "import sys\n\ndef binary_search(arr, s):\n    low = 0\n    high = min(min(arr), s)\n    while low <= high:\n        mid = (low + high) // 2\n        total = sum(min(mid, x) for x in arr)\n        if total == s:\n            return mid\n        elif total < s:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1\n\nn, s = map(int, sys.stdin.readline().split())\narr = list(map(int, sys.stdin.readline().split()))\n\nprint(binary_search(arr, s))"}
{"solution": "def caterpillar_height(h1, h2, a, b):\n    day_hours = 12\n    night_hours = 12\n    day_progress = a * day_hours\n    night_progress = b * night_hours\n\n    if day_progress <= night_progress:\n        return -1\n\n    days = 0\n    hours = 4  # initial hours after 2 pm\n    height = h1 + hours * a\n\n    while True:\n        if height >= h2:\n            break\n\n        height += day_progress\n        days += 1\n\n        if height >= h2:\n            break\n\n        height -= night_progress\n\n    return days\n\n\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\nprint(caterpillar_height(h1, h2, a, b))"}
{"solution": "def max_joy_units():\n    C, Hr, Hb, Wr, Wb = map(int, input().split())\n    max_joy = 0\n\n    for r in range(C // Wr + 1):\n        w = C - r * Wr\n        b = w // Wb\n        joy = r * Hr + b * Hb\n        max_joy = max(max_joy, joy)\n\n    print(max_joy)\n\nmax_joy_units()"}
{"solution": "x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\nprint(max(abs(x2 - x1), abs(y2 - y1)))"}
{"solution": "n = int(input())\ns = input()\n\ndef solve(n, s):\n    d_count = s.count('D')\n    r_count = n - d_count\n\n    if d_count == r_count:\n        return 'R' if s[-1] == 'R' else 'D'\n    else:\n        return 'D' if d_count > r_count else 'R'\n\nprint(solve(n, s))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\na, b, x, y = map(int, input().split())\ng = gcd(x, y)\nx //= g\ny //= g\n\nans = 0\nfor k in range(1, int(math.sqrt(a)) + 1):\n    if a % k == 0:\n        if k * y <= b and x * k <= a:\n            ans += 1\n        k2 = a // k\n        if k2 * y <= b and x * k2 <= a and k2!= k:\n            ans += 1\n\nprint(ans)"}
{"solution": "import math\n\ndef count_trailing_zeros(n, b):\n    count = 0\n    i = 1\n    while True:\n        p = b ** i\n        if p > n:\n            break\n        count += n // p\n        i += 1\n    return count\n\nn, b = map(int, input().split())\nprint(count_trailing_zeros(n, b))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nm, a, b = map(int, input().split())\ng = gcd(a, b)\nlcm = a * b // g\n\nif a < b:\n    a, b = b, a\n\nif a == 1:\n    print((m + 1) * (m + 2) // 2)\nelse:\n    ans = m // lcm * (lcm // a + 1) + (m % lcm) // a + 1\n    ans += (m // lcm) * (m // lcm - 1) // 2 * (lcm // a + 1) * (lcm // a + 2)\n    ans += (m // lcm) * (m % lcm) // a * (lcm // a + 2)\n    ans += (m % lcm) * ((m % lcm) - 1) // 2 * (lcm // a + 2)\n    ans += (m % lcm) * (lcm // a + 1)\n    print(ans)"}
{"solution": "def can_divide_into_odd_subsegments(n, sequence):\n    if n % 2 == 0 and sequence[0] % 2!= 0 and sequence[-1] % 2!= 0:\n        return False\n\n    if sequence[0] % 2 == 0 or sequence[-1] % 2 == 0:\n        return False\n\n    count = 0\n    i = 0\n    while i < n:\n        if sequence[i] % 2!= 0:\n            count += 1\n            i += 1\n            while i < n and sequence[i] % 2 == 0:\n                i += 1\n            if i < n and sequence[i] % 2!= 0:\n                i += 1\n            else:\n                return False\n        else:\n            i += 1\n\n    return count % 2!= 0\n\n\nn = int(input())\nsequence = list(map(int, input().split()))\n\nif can_divide_into_odd_subsegments(n, sequence):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "x1, y1, x2, y2 = map(int, input().split())\n\nif x1 == x2:\n    x3, x4 = x1, x1\n    y3, y4 = y1 + abs(y2 - y1), y2 - abs(y2 - y1)\nelif y1 == y2:\n    x3, x4 = x1 + abs(x2 - x1), x2 - abs(x2 - x1)\n    y3, y4 = y1, y1\nelse:\n    if abs(x2 - x1)!= abs(y2 - y1):\n        print(-1)\n        exit()\n    x3, x4 = x1 + abs(x2 - x1), x2 - abs(x2 - x1)\n    y3, y4 = y2, y1\n\nprint(x3, y3, x4, y4)"}
{"solution": "def matrix_multiply(a, b, mod):\n    c = [[0, 0], [0, 0]]\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                c[i][j] += a[i][k] * b[k][j]\n            c[i][j] %= mod\n    return c\n\ndef matrix_power(matrix, n, mod):\n    if n == 1:\n        return matrix\n    if n % 2 == 0:\n        half_pow = matrix_power(matrix, n // 2, mod)\n        return matrix_multiply(half_pow, half_pow, mod)\n    else:\n        half_pow = matrix_power(matrix, n // 2, mod)\n        return matrix_multiply(matrix_multiply(half_pow, half_pow, mod), matrix, mod)\n\nmod = 1000000007\nx, y = map(int, input().split())\nn = int(input())\n\nif n == 1:\n    print(x % mod)\nelif n == 2:\n    print(y % mod)\nelse:\n    matrix = [[1, 1], [1, 0]]\n    result_matrix = matrix_power(matrix, n - 2, mod)\n    result = (result_matrix[0][0] * y - result_matrix[0][1] * x) % mod\n    print((result + mod) % mod)"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n    if prefix_sum[n] == 0:\n        print(\"NO\")\n        return\n    print(\"YES\")\n    result = []\n    left = 0\n    for right in range(1, n + 1):\n        if prefix_sum[right]!= 0 and prefix_sum[n] - prefix_sum[right]!= 0:\n            result.append((left + 1, right))\n            left = right\n    result.append((left + 1, n))\n    print(len(result))\n    for left, right in result:\n        print(left, right)\n\nsolve()"}
{"solution": "def pow_mod(a, b, mod):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = (res * a) % mod\n        a = (a * a) % mod\n        b >>= 1\n    return res\n\ndef solve():\n    mod = 1000000009\n    n, m, k = map(int, input().split())\n    if m < n - m + 1:\n        print(m)\n        return\n    m -= n - m + 1\n    ans = n - m + 1\n    m %= k - 1\n    ans += m\n    m += k - 1\n    ans = (ans * pow_mod(2, m // (k - 1), mod)) % mod\n    print(ans)\n\nsolve()"}
{"solution": "def is_divisible_by_8(num):\n    return num % 8 == 0\n\ndef find_divisible_substring(num_str):\n    for length in range(1, 4):\n        for i in range(len(num_str) - length + 1):\n            substring = num_str[i:i+length]\n            if substring[0]!= '0' and is_divisible_by_8(int(substring)):\n                return substring\n    return None\n\nnum_str = input()\ndivisible_substring = find_divisible_substring(num_str)\n\nif divisible_substring is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(divisible_substring)"}
{"solution": "import math\n\nn, m = map(int, input().split())\nmemories = [list(map(int, input().split())) for _ in range(m)]\n\nmin_flats_per_floor = 1\nmax_flats_per_floor = n\n\nfor k, f in memories:\n    min_flats_per_floor = max(min_flats_per_floor, math.ceil(k / f))\n    max_flats_per_floor = min(max_flats_per_floor, math.floor((k - 1) / (f - 1)) if f > 1 else n)\n\nfloor = math.ceil(n / min_flats_per_floor)\nif math.ceil(n / max_flats_per_floor)!= floor:\n    print(-1)\nelse:\n    print(floor)"}
{"solution": "def count_bishwocks(board):\n    n = len(board[0])\n    count = 0\n\n    for i in range(n - 1):\n        if board[0][i] == '0' and board[0][i + 1] == '0' and board[1][i] == '0':\n            count += 1\n            i += 1\n        elif board[0][i] == '0' and board[1][i] == '0' and board[1][i + 1] == '0':\n            count += 1\n            i += 1\n\n    for i in range(n - 1):\n        if board[1][i] == '0' and board[1][i + 1] == '0' and board[0][i] == '0':\n            count += 1\n            i += 1\n        elif board[1][i] == '0' and board[0][i] == '0' and board[0][i + 1] == '0':\n            count += 1\n            i += 1\n\n    return count\n\nboard = [input(), input()]\nprint(count_bishwocks(board))"}
{"solution": "def max_pretty_set(n, s):\n    max_set = 0\n    last_upper = -1\n    used = set()\n\n    for i in range(n):\n        if s[i].isupper():\n            last_upper = i\n        elif s[i] not in used and (last_upper == -1 or last_upper < i - 1):\n            used.add(s[i])\n            max_set = max(max_set, len(used))\n\n    return max_set\n\n\nn = int(input())\ns = input()\nprint(max_pretty_set(n, s))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\na.sort()\nprint(sum(a[n//2:]))"}
{"solution": "a, b, f, k = map(int, input().split())\n\nif 2 * a > b:\n    if f * 2 > b:\n        if (a - f) * 2 > b:\n            print(-1)\n        else:\n            ans = 0\n            if f > b / 2:\n                ans += k * 2\n            else:\n                ans += k\n                if a - f > b / 2:\n                    ans += k\n            print(ans)\n    else:\n        ans = 0\n        if a - f > b / 2:\n            ans += k\n        if f > b / 2:\n            ans += k\n        print(ans)\nelse:\n    print(0)"}
{"solution": "import sys\n\nn, p, q = map(int, input().split())\ns = input()\n\ndef split_string(s, p, q):\n    result = []\n    while s:\n        if len(s) >= q:\n            result.append(s[:q])\n            s = s[q:]\n        elif len(s) >= p:\n            result.append(s[:p])\n            s = s[p:]\n        else:\n            return None\n    return result\n\ndef split_string_only_p(s, p):\n    result = []\n    while s:\n        result.append(s[:p])\n        s = s[p:]\n    return result\n\ndef split_string_only_q(s, q):\n    result = []\n    while s:\n        result.append(s[:q])\n        s = s[q:]\n    return result\n\nresult = split_string(s, p, q)\nif result is None:\n    result = split_string_only_p(s, p)\n    if result is None:\n        result = split_string_only_q(s, q)\n        if result is None:\n            print(-1)\n        else:\n            print(len(result))\n            for item in result:\n                print(item)\n    else:\n        print(len(result))\n        for item in result:\n            print(item)\nelse:\n    print(len(result))\n    for item in result:\n        print(item)"}
{"solution": "import sys\n\ndef solve():\n    n, m, s, d = map(int, sys.stdin.readline().split())\n    obstacles = sorted(map(int, sys.stdin.readline().split()))\n\n    if obstacles[0] < s:\n        print(\"IMPOSSIBLE\")\n        return\n\n    print(\"RUN\", obstacles[0])\n    pos = obstacles[0]\n\n    for i in range(n):\n        if i == n - 1:\n            if m - pos <= s:\n                print(\"RUN\", m - pos)\n            else:\n                print(\"RUN\", s)\n                pos += s\n                print(\"JUMP\", min(m - pos, d))\n            return\n\n        if obstacles[i + 1] - pos <= s:\n            print(\"RUN\", obstacles[i + 1] - pos)\n            pos = obstacles[i + 1]\n        else:\n            print(\"RUN\", s)\n            pos += s\n            print(\"JUMP\", min(obstacles[i + 1] - pos, d))\n            pos = min(obstacles[i + 1] + 1, pos + d)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def count_pairs(s, x):\n    if s < x:\n        return 0\n    if (s - x) % 2!= 0:\n        return 0\n    y = (s - x) // 2\n    count = 0\n    for i in range(40):\n        bit_x = (x >> i) & 1\n        bit_y = (y >> i) & 1\n        if bit_x == 1 and bit_y == 1:\n            return 0\n        if bit_x == 0 and bit_y == 0:\n            count *= 2\n        if bit_x == 1 and bit_y == 0:\n            count *= 1\n        if bit_x == 0 and bit_y == 1:\n            count += 2 ** i\n    if x == 0 and s!= 0:\n        count -= 2\n    return count\n\ns, x = map(int, input().split())\nprint(count_pairs(s, x))"}
{"solution": "n, k = map(int, input().split())\nif n <= 2 * k:\n    print(1)\n    print(1)\nelse:\n    print((n - 1) // (2 * k) + ((n - 1) % (2 * k)!= 0))\n    for i in range(1, n, 2 * k):\n        print(i)"}
{"solution": "import math\n\ndef min_operations(n):\n    n = str(n)\n    squares = [str(i**2) for i in range(1, math.isqrt(10**len(n)) + 1)]\n\n    def can_form_square(n, square):\n        i = j = 0\n        while i < len(n) and j < len(square):\n            if n[i] == square[j]:\n                j += 1\n            i += 1\n        return j == len(square)\n\n    min_ops = float('inf')\n    for square in squares:\n        if can_form_square(n, square):\n            ops = len(n) - len(square)\n            min_ops = min(min_ops, ops)\n\n    return min_ops if min_ops!= float('inf') else -1\n\nn = int(input())\nprint(min_operations(n))"}
{"solution": "import math\n\nMOD = 10**9 + 7\nMAXN = 10**6 + 5\n\ndef sieve_of_eratosthenes(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n + 1, i):\n                is_prime[j] = False\n    return is_prime\n\ndef count_permutations(n):\n    is_prime = sieve_of_eratosthenes(n)\n    primes = [i for i in range(2, n + 1) if is_prime[i]]\n    k = len(primes)\n    if n == 2:\n        return 1\n    elif n == 3:\n        return 4\n    elif n == 4:\n        return 12\n    elif n == 5:\n        return 60\n    else:\n        result = 1\n        for i in range(2, n + 1):\n            result = (result * i) % MOD\n        for i in range(k - 1):\n            result = (result * (primes[i] - 1)) % MOD\n        return result\n\nn = int(input())\nprint(count_permutations(n))"}
{"solution": "def min_jump_ability(s):\n    vowels = set('AEIOUY')\n    max_distance = 0\n    prev_vowel_index = -1\n\n    for i, char in enumerate(s):\n        if char in vowels:\n            if prev_vowel_index!= -1:\n                max_distance = max(max_distance, i - prev_vowel_index)\n            prev_vowel_index = i\n\n    return max_distance\n\n\ns = input()\nprint(min_jump_ability(s))"}
{"solution": "def can_distribute_candies(a):\n    total_sum = sum(a)\n    if total_sum % 2!= 0:\n        return False\n\n    target_sum = total_sum // 2\n    a.sort(reverse=True)\n\n    def dfs(index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(a):\n            return False\n\n        return dfs(index + 1, current_sum + a[index]) or dfs(index + 1, current_sum)\n\n    return dfs(0, 0)\n\n\na = list(map(int, input().split()))\nprint(\"YES\" if can_distribute_candies(a) else \"NO\")"}
{"solution": "def pie_rule(n, slices):\n    dp = [[[-1 for _ in range(2)] for _ in range(n + 1)] for _ in range(n + 1)]\n\n    def dfs(i, j, k):\n        if i + j == n:\n            return slices[i] if k == 0 else 0\n        if dp[i][j][k]!= -1:\n            return dp[i][j][k]\n        if k == 0:\n            dp[i][j][k] = max(slices[i] + dfs(i + 1, j, 1), slices[i + j] + dfs(i, j - 1, 1))\n        else:\n            dp[i][j][k] = min(slices[i] + dfs(i + 1, j, 0), slices[i + j] + dfs(i, j - 1, 0))\n        return dp[i][j][k]\n\n    alice = dfs(0, n - 1, 0)\n    bob = sum(slices) - alice\n    return alice, bob\n\nn = int(input())\nslices = list(map(int, input().split()))\nalice, bob = pie_rule(n, slices)\nprint(alice, bob)"}
{"solution": "import sys\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    a.sort()\n    dp = [0] * (1 << n)\n    for i in range(n):\n        dp[1 << i] = a[i]\n\n    for mask in range(1 << n):\n        for i in range(n):\n            if (mask >> i) & 1:\n                for j in range(i):\n                    if (mask >> j) & 1:\n                        for k in range(n):\n                            if not ((mask >> k) & 1):\n                                if dp[mask] + dp[1 << j] == a[k]:\n                                    dp[mask | (1 << k)] = a[k]\n\n    ans = 1\n    for mask in range(1 << n):\n        if dp[mask] == a[-1]:\n            ans = max(ans, bin(mask).count('1'))\n    if dp[-1]!= a[-1]:\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\na.sort()\nif a[0] == a[n//2]:\n    print(\"Bob\")\nelse:\n    print(\"Alice\")"}
{"solution": "import math\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\nif n == 1 or a[0] == a[-1]:\n    print(\"YES\")\nelse:\n    x = a[-1] - a[0]\n    for i in range(1, n - 1):\n        if (a[i] - a[0]) % x!= 0 or (a[i] - a[0]) // x > 1 or (a[-1] - a[i]) % x!= 0 or (a[-1] - a[i]) // x > 1:\n            print(\"NO\")\n            break\n    else:\n        print(\"YES\")"}
{"solution": "def max_repeated_substring_length(n, s):\n    max_length = 0\n    for length in range(1, n // 2 + 1):\n        for i in range(n - length):\n            substring = s[i:i + length]\n            if s.find(substring, i + length)!= -1:\n                max_length = max(max_length, length)\n    return max_length\n\nn = int(input())\ns = input()\nprint(max_repeated_substring_length(n, s))"}
{"solution": "n, a = map(int, input().split())\nif a <= n // 2:\n    print(a // 2 + a % 2)\nelse:\n    print(n // 2 - (a - n // 2) // 2 + (a - n // 2) % 2)"}
{"solution": "n, m = map(int, input().split())\ncolors = list(map(int, input().split()))\nk = list(map(int, input().split()))\n\ndef is_possible(colors, k):\n    color_counts = [0] * (m + 1)\n    required_colors = sum(k)\n    left = 0\n    for right in range(len(colors)):\n        color_counts[colors[right]] += 1\n        while color_counts[colors[right]] > k[colors[right] - 1]:\n            color_counts[colors[left]] -= 1\n            left += 1\n        if right - left + 1 == required_colors:\n            if all(color_counts[i] == k[i - 1] for i in range(1, m + 1)):\n                return True\n    return False\n\nif is_possible(colors, k):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\nmishka_wins = 0\nchris_wins = 0\n\nfor _ in range(n):\n    mishka, chris = map(int, input().split())\n    if mishka > chris:\n        mishka_wins += 1\n    elif chris > mishka:\n        chris_wins += 1\n\nif mishka_wins > chris_wins:\n    print(\"Mishka\")\nelif chris_wins > mishka_wins:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")"}
{"solution": "def is_valid_field(n, m, field):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                continue\n            count = 0\n            for d in directions:\n                ni, nj = i + d[0], j + d[1]\n                if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':\n                    count += 1\n            if field[i][j] == '.':\n                if count!= 0:\n                    return False\n            else:\n                if int(field[i][j])!= count:\n                    return False\n    return True\n\n\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\nprint(\"YES\" if is_valid_field(n, m, field) else \"NO\")"}
{"solution": "import math\n\ndef calculate_vasya_eaten(n, k):\n    vasya_eaten = 0\n    while n > 0:\n        vasya_eaten += min(k, n)\n        n -= min(k, n)\n        n -= math.floor(n * 0.1)\n    return vasya_eaten\n\ndef find_min_k(n):\n    target = math.ceil(n / 2)\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if calculate_vasya_eaten(n, mid) < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\nn = int(input())\nprint(find_min_k(n))"}
{"solution": "def solve():\n    s = input()\n    n = len(s)\n    pearl_count = s.count('o')\n    link_count = n - pearl_count\n\n    if pearl_count == 0 or pearl_count == 1:\n        print(\"YES\")\n        return\n\n    if link_count % pearl_count!= 0:\n        print(\"NO\")\n        return\n\n    link_per_pearl = link_count // pearl_count\n    i = 0\n    while i < n:\n        if s[i] == 'o':\n            count = 0\n            i += 1\n            while i < n and s[i] == '-':\n                count += 1\n                i += 1\n            if i == n:\n                count += s[:s.index('o')].count('-')\n            if count!= link_per_pearl:\n                print(\"NO\")\n                return\n        else:\n            i += 1\n\n    print(\"YES\")\n\nsolve()"}
{"solution": "def max_pillows(n, m, k):\n    if n == 1:\n        return m\n    if k == 1 or k == n:\n        return (m - n + 1) // 2 + 1\n    return (m - n + 2) // 3 + 1\n\nn, m, k = map(int, input().split())\nprint(max_pillows(n, m, k))"}
{"solution": "import math\n\ndef solve():\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    dp = [[-math.inf] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(m):\n            dp[i][j] = dp[i - 1][j + 1] + a[i - 1]\n            if j == 0:\n                dp[i][j] = max(dp[i][j], 0)\n        for j in range(m):\n            ans = max(ans, dp[i][j] - k * math.ceil((j + 1) / m))\n        for j in range(1, m):\n            dp[i][j] = max(dp[i][j], dp[i - 1][j])\n\n    print(ans)\n\nsolve()"}
{"solution": "n, m = map(int, input().split())\n\nif n == 0 and m == 0:\n    print(\"0 0\")\n    print(\"1 1\")\n    print(\"0 1\")\n    print(\"1 0\")\nelif n == 0:\n    print(f\"0 {m}\")\n    print(f\"0 0\")\n    print(f\"0 {m-1}\")\n    print(f\"0 1\")\nelif m == 0:\n    print(f\"{n} 0\")\n    print(f\"0 0\")\n    print(f\"{n-1} 0\")\n    print(f\"1 0\")\nelse:\n    print(f\"{n} {m}\")\n    print(f\"0 {m}\")\n    print(f\"0 0\")\n    print(f\"{n} 0\")"}
{"solution": "def find_smallest_number(s, sub):\n    n = len(s)\n    k = len(sub)\n    sub = sub.lstrip('0')\n    if not sub:\n        sub = '0'\n    k = len(sub)\n\n    for i in range(n - k + 1):\n        if s[i:i+k] == sub:\n            left = s[:i]\n            right = s[i+k:]\n            if left and left[0] == '0':\n                left = ''\n            if right and right[0] == '0':\n                right = ''\n            return left + sub + right + str(n)\n\n    for digit in '123456789':\n        if digit in s:\n            idx = s.index(digit)\n            left = s[:idx]\n            right = s[idx+1:]\n            if left and left[0] == '0':\n                left = ''\n            if right and right[0] == '0':\n                right = ''\n            return left + digit + sub + right + str(n)\n\n    return '1' + sub + str(n)\n\ns = input()\nsub = input()\nprint(find_smallest_number(s, sub))"}
{"solution": "n, m, min_val, max_val = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\nif min(temperatures) < min_val or max(temperatures) > max_val:\n    print('Incorrect')\nelif min_val in temperatures and max_val in temperatures:\n    print('Correct')\nelif min_val in temperatures or max_val in temperatures:\n    if n - m >= 1:\n        print('Correct')\n    else:\n        print('Incorrect')\nelse:\n    if n - m >= 2:\n        print('Correct')\n    else:\n        print('Incorrect')"}
{"solution": "import math\n\ndef find_trailing_zeros(m):\n    start = 5\n    count = 0\n    result = []\n    while True:\n        zeros = 0\n        n = start\n        while n // 5 > 0:\n            zeros += n // 5\n            n //= 5\n        if zeros == m:\n            count += 1\n            result.append(start)\n        elif zeros < m:\n            break\n        start += 1\n    print(count)\n    print(*result)\n\nm = int(input())\nfind_trailing_zeros(m)"}
{"solution": "import sys\nimport heapq\n\ndef read_ints():\n    return map(int, sys.stdin.readline().split())\n\ndef read_int():\n    return int(sys.stdin.readline())\n\ndef solve():\n    n, m, k = read_ints()\n    special = list(read_ints())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v, w = read_ints()\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    def dijkstra(start):\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, w in graph[u]:\n                if dist[v] > max(d, w):\n                    dist[v] = max(d, w)\n                    heapq.heappush(pq, (dist[v], v))\n        return dist\n\n    dists = [dijkstra(s) for s in special]\n    ans = [max(d[s] for d in dists) for s in special]\n    print(*ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "n = int(input())\nx = int(input())\n\nif n % 2 == 0:\n    if x == 0:\n        print(2)\n    elif x == 2:\n        print(0)\n    else:\n        print(1)\nelse:\n    if x == 0:\n        print(1)\n    elif x == 1:\n        print(0)\n    else:\n        print(2)"}
{"solution": "def is_square(rectangles):\n    x_coords = set()\n    y_coords = set()\n\n    for x1, y1, x2, y2 in rectangles:\n        x_coords.add(x1)\n        x_coords.add(x2)\n        y_coords.add(y1)\n        y_coords.add(y2)\n\n    if len(x_coords)!= 2 or len(y_coords)!= 2:\n        return False\n\n    x1, x2 = sorted(x_coords)\n    y1, y2 = sorted(y_coords)\n\n    return x2 - x1 == y2 - y1\n\n\nn = int(input())\nrectangles = [list(map(int, input().split())) for _ in range(n)]\n\nprint(\"YES\" if is_square(rectangles) else \"NO\")"}
{"solution": "def digit_sum(x):\n    return sum(int(digit) for digit in str(x))\n\ndef count_big_numbers(n, s):\n    count = 0\n    for i in range(1, n + 1):\n        if i - digit_sum(i) >= s:\n            count += 1\n    return count\n\nn, s = map(int, input().split())\nprint(count_big_numbers(n, s))"}
{"solution": "from collections import defaultdict\nfrom math import gcd\n\ndef slope(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    if x1 == x2:\n        return float('inf')\n    return (y2 - y1) / (x2 - x1)\n\ndef solve(points):\n    n = len(points)\n    if n <= 2:\n        return True\n\n    slopes = defaultdict(set)\n    for i in range(n):\n        for j in range(i + 1, n):\n            s = slope(points[i], points[j])\n            slopes[s].update([i, j])\n\n    max_cover = 0\n    for s in slopes:\n        max_cover = max(max_cover, len(slopes[s]))\n\n    if max_cover == n:\n        return True\n\n    for s in slopes:\n        if len(slopes[s]) < n // 2:\n            continue\n        for s2 in slopes:\n            if s == s2:\n                continue\n            if len(slopes[s2]) + len(slopes[s]) >= n:\n                return True\n\n    return False\n\ndef main():\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    if solve(points):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 10**9 + 7\n\ndef add(a, b):\n    return (a + b) % MOD\n\ndef mul(a, b):\n    return (a * b) % MOD\n\ndef pow(a, b):\n    if b == 0:\n        return 1\n    if b % 2 == 0:\n        return pow(mul(a, a), b // 2)\n    return mul(a, pow(a, b - 1))\n\ndef inv(a):\n    return pow(a, MOD - 2)\n\ndef comb(n, k):\n    if k < 0 or k > n:\n        return 0\n    return mul(fact[n], mul(inv(fact[k]), inv(fact[n - k])))\n\nfact = [1] * 200001\nfor i in range(1, 200001):\n    fact[i] = mul(fact[i - 1], i)\n\na, b, k, t = map(int, input().split())\nans = 0\nfor i in range(1, 2 * k * t + 1):\n    ans = add(ans, mul(comb(2 * k * t, i + b - a - 1), comb(2 * k * t - (i + b - a - 1), t - (i + b - a - 1))))\nprint(ans)"}
{"solution": "def can_measure(distances, target):\n    for i in range(len(distances)):\n        for j in range(i, len(distances)):\n            if distances[j] - distances[i] == target:\n                return True\n    return False\n\ndef find_mark(distances, target):\n    for i in range(len(distances)):\n        for j in range(i, len(distances)):\n            if distances[j] - distances[i] == target:\n                return distances[i], distances[j]\n    return None\n\ndef solve(n, l, x, y, distances):\n    if can_measure(distances, x) and can_measure(distances, y):\n        return 0, []\n    elif can_measure(distances, x):\n        return 1, [y]\n    elif can_measure(distances, y):\n        return 1, [x]\n    else:\n        x_mark = find_mark(distances, x)\n        y_mark = find_mark(distances, y)\n        if x_mark is not None and y_mark is not None:\n            if x_mark[0] == y_mark[0] or x_mark[1] == y_mark[1]:\n                return 1, [x_mark[0] + y]\n            else:\n                return 2, [x, y]\n        elif x_mark is not None:\n            return 1, [x_mark[0] + y]\n        elif y_mark is not None:\n            return 1, [y_mark[0] + x]\n        else:\n            return 2, [x, y]\n\nn, l, x, y = map(int, input().split())\ndistances = list(map(int, input().split()))\n\nnum_marks, marks = solve(n, l, x, y, distances)\nprint(num_marks)\nif num_marks > 0:\n    print(*marks)"}
{"solution": "import math\n\nn = int(input())\ncakes = []\nfor _ in range(n):\n    r, h = map(int, input().split())\n    cakes.append((math.pi * r * r * h, r, h))\n\ncakes.sort()\n\ndp = [0] * n\ndp[0] = cakes[0][0]\n\nfor i in range(1, n):\n    max_volume = 0\n    for j in range(i):\n        if cakes[i][1] > cakes[j][1] and cakes[i][2] > cakes[j][2]:\n            max_volume = max(max_volume, dp[j])\n    dp[i] = max(max_volume + cakes[i][0], dp[i-1])\n\nprint(dp[-1])"}
{"solution": "import sys\nimport math\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef solve():\n    n, k = map(int, input().split())\n    h = list(map(int, input().split()))\n    h.sort()\n\n    def check(x):\n        return sum(h[i] - x for i in range(n)) <= k * x\n\n    l, r = 0, h[-1]\n    while l < r:\n        mid = (l + r + 1) // 2\n        if check(mid):\n            l = mid\n        else:\n            r = mid - 1\n\n    print(h[-1] - l)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nprefix_sum = [0] * (n + 1)\nfor i in range(n):\n    prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\nmin_values = [0] * n\nmin_values[0] = a[0]\nfor i in range(1, n):\n    min_values[i] = min(min_values[i - 1], a[i])\n\nmax_score = 0\nfor i in range(n):\n    for j in range(i, n):\n        segment_sum = prefix_sum[j + 1] - prefix_sum[i]\n        segment_sum -= min_values[j]\n        max_score = max(max_score, segment_sum)\n\nprint(max_score)"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nk1, k2, k3 = map(int, input().split())\n\nlcm12 = lcm(k1, k2)\nlcm23 = lcm(k2, k3)\nlcm13 = lcm(k1, k3)\n\nif max(lcm12, lcm23, lcm13) <= k1 + k2 + k3 - max(k1, k2, k3):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\ns = input()\n\ndp = [[0] * 26 for _ in range(n + 1)]\n\nfor i in range(n - 1, -1, -1):\n    for j in range(26):\n        dp[i][j] = dp[i + 1][j]\n    dp[i][ord(s[i]) - ord('a')] = min(dp[i + 1][ord(s[i]) - ord('a')] + 1, dp[i + 1][ord(s[i + 1]) - ord('a')] + 1 if i < n - 1 else 1)\n\nprint(dp[0][ord(s[0]) - ord('a')])"}
{"solution": "from collections import Counter\n\nn = int(input())\nboys = Counter(map(int, input().split()))\n\nm = int(input())\ngirls = Counter(map(int, input().split()))\n\npairs = 0\nfor skill in set(list(boys.keys()) + list(girls.keys())):\n    pairs += min(boys[skill], girls[skill])\n    pairs += min(boys[skill - 1] if skill - 1 in boys else 0, girls[skill] if skill in girls else 0)\n    pairs += min(boys[skill], girls[skill + 1] if skill + 1 in girls else 0)\n\nprint(pairs)"}
{"solution": "def determine_winner():\n    team1 = [list(map(int, input().split())) for _ in range(2)]\n    team2 = [list(map(int, input().split())) for _ in range(2)]\n\n    team1_defence = max(team1[0][0], team1[1][0])\n    team1_attack = min(team1[0][1], team1[1][1])\n\n    team2_defence = max(team2[0][0], team2[1][0])\n    team2_attack = min(team2[0][1], team2[1][1])\n\n    if team1_defence > team2_attack and team1_attack > team2_defence:\n        return \"Team 1\"\n    elif team2_defence > team1_attack and team2_attack > team1_defence:\n        return \"Team 2\"\n    else:\n        return \"Draw\"\n\nprint(determine_winner())"}
{"solution": "import math\nimport sys\n\ndef dist(x, y, a, b):\n    return math.sqrt((x - a) ** 2 + (y - b) ** 2)\n\ndef check(x, y, k, arr):\n    return sum(1 for a, b, c in arr if c * dist(x, y, a, b) <= t) >= k\n\ndef solve():\n    global t\n    n, k = map(int, input().split())\n    arr = [list(map(int, input().split())) for _ in range(n)]\n    l, r = 0, 10 ** 6\n    for _ in range(100):\n        t = (l + r) / 2\n        ok = False\n        for x in range(-1000, 1001):\n            for y in range(-1000, 1001):\n                if check(x, y, k, arr):\n                    ok = True\n                    break\n            if ok:\n                break\n        if ok:\n            r = t\n        else:\n            l = t\n    print(f\"{t:.6f}\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def solve():\n    n = int(input())\n    s = input()\n    a = [int(c) if c!= '?' else 0 for c in s]\n    diff = sum(a[:n//2]) - sum(a[n//2:])\n    unknown = s[:n//2].count('?') + s[n//2:].count('?')\n    if unknown % 2 == 0:\n        if diff % 10 == 0:\n            return \"Bicarp\"\n        else:\n            return \"Monocarp\"\n    else:\n        if diff % 10 == 0:\n            return \"Monocarp\"\n        else:\n            return \"Bicarp\"\n\nprint(solve())"}
{"solution": "import math\n\nn, t = map(int, input().split())\nmin_time = float('inf')\nmin_index = -1\n\nfor i in range(n):\n    s, d = map(int, input().split())\n    time = s + (t - s + d - 1) // d * d\n    if time < min_time:\n        min_time = time\n        min_index = i + 1\n\nprint(min_index)"}
{"solution": "def count_ones(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef solve(m, k):\n    n = 1\n    while True:\n        count = 0\n        for i in range(n + 1, 2 * n + 1):\n            if count_ones(i) == k:\n                count += 1\n        if count == m:\n            return n\n        n += 1\n\nm, k = map(int, input().split())\nprint(solve(m, k))"}
{"solution": "def is_good_level(level):\n    n = len(level)\n    for i in range(n):\n        for jump in range(1, n // 4):\n            if i + 4 * jump < n and all(level[i + k * jump] == '*' for k in range(5)):\n                return True\n    return False\n\nn = int(input())\nlevel = input().strip()\nprint(\"yes\" if is_good_level(level) else \"no\")"}
{"solution": "def calculate_magic_constant(n, grid):\n    total_sum = sum(sum(row) for row in grid)\n    return (n * (n**2 + 1)) // 2 - total_sum\n\ndef check_magic_square(n, grid, magic_constant):\n    for i in range(n):\n        row_sum = sum(grid[i])\n        col_sum = sum(grid[j][i] for j in range(n))\n        if row_sum!= magic_constant or col_sum!= magic_constant:\n            return False\n\n    diagonal_sum1 = sum(grid[i][i] for i in range(n))\n    diagonal_sum2 = sum(grid[i][n - i - 1] for i in range(n))\n    if diagonal_sum1!= magic_constant or diagonal_sum2!= magic_constant:\n        return False\n\n    return True\n\ndef solve(n, grid):\n    magic_constant = calculate_magic_constant(n, grid)\n    if magic_constant < 1:\n        return -1\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                grid[i][j] = magic_constant\n                break\n\n    if check_magic_square(n, grid, magic_constant + grid[i][j]):\n        return magic_constant\n    else:\n        return -1\n\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\nprint(solve(n, grid))"}
{"solution": "n = int(input())\nm = int(input())\na = [int(input()) for _ in range(n)]\n\nmin_k = max(max(a), (m + sum(a) - 1) // n + 1)\nmax_k = max(a) + m\n\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_power(a, b, m):\n    result = 1\n    while b > 0:\n        if b % 2 == 1:\n            result = (result * a) % m\n        a = (a * a) % m\n        b //= 2\n    return result\n\ndef mod_factorial(n, m):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % m\n    return result\n\ndef mod_combination(n, k, m):\n    return (mod_factorial(n, m) * mod_inverse(mod_factorial(k, m) * mod_factorial(n - k, m) % m, m)) % m\n\ndef solve(n, m):\n    if m > n:\n        return 0\n    result = 0\n    for k in range(m + 1):\n        result = (result + mod_power(2, m - k, MOD) * mod_power(2, n - m + k, MOD) * mod_combination(m, k, MOD) * mod_combination(n - m + k - 1, k - 1, MOD)) % MOD\n    return result\n\nn, m = map(int, input().split())\nprint(solve(n, m))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(input())\n\ndef read_ints():\n    return map(int, input().split())\n\ndef read_list():\n    return list(map(int, input().split()))\n\ndef solve():\n    n, m = read_ints()\n    friends = []\n    for _ in range(n):\n        friends.append(set(read_list()[1:]))\n\n    pizzas = []\n    for _ in range(m):\n        pizzas.append((read_list()[0], set(read_list()[2:])))\n\n    max_friends = 0\n    min_cost = float('inf')\n    ans = (-1, -1)\n\n    for i in range(m):\n        for j in range(i + 1, m):\n            cost = pizzas[i][0] + pizzas[j][0]\n            if cost > min_cost:\n                continue\n            satisfied = 0\n            for friend in friends:\n                if friend.issubset(pizzas[i][1]) or friend.issubset(pizzas[j][1]) or friend.issubset(pizzas[i][1] | pizzas[j][1]):\n                    satisfied += 1\n            if satisfied > max_friends or (satisfied == max_friends and cost < min_cost):\n                max_friends = satisfied\n                min_cost = cost\n                ans = (i + 1, j + 1)\n\n    print(*ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def find_min_max(m, s):\n    if s == 0 and m > 1:\n        return \"-1 -1\"\n    if s < m or s > 9 * m:\n        return \"-1 -1\"\n\n    min_num = ''\n    max_num = ''\n\n    remaining_sum = s\n    for i in range(m):\n        if i == 0:\n            min_num += str(min(s - (m - 1), 9))\n            remaining_sum -= int(min_num[-1])\n        else:\n            min_num += str(min(remaining_sum, 9))\n            remaining_sum -= int(min_num[-1])\n\n    remaining_sum = s\n    for i in range(m):\n        if i == m - 1:\n            max_num = str(remaining_sum) + max_num\n        else:\n            max_num = str(min(remaining_sum, 1)) + max_num\n            remaining_sum -= int(max_num[0])\n\n    return min_num +'' + max_num\n\nm, s = map(int, input().split())\nprint(find_min_max(m, s))"}
{"solution": "MOD = 998244353\n\ndef count(x, k):\n    if k == 1:\n        return x // 9 * 9 + (x % 9) * (x % 9 + 1) // 2\n    elif k == 2:\n        return x * (x + 1) // 2 - 9 * x // 9 * (x // 9 + 1) // 2\n    elif k == 3:\n        return x * (x + 1) // 2 - 9 * x // 9 * (x // 9 + 1) // 2 + 9 * x // 81 * (x // 81 + 1) // 2\n    elif k == 4:\n        return x * (x + 1) // 2 - 9 * x // 9 * (x // 9 + 1) // 2 + 9 * x // 81 * (x // 81 + 1) // 2 - 9 * x // 729 * (x // 729 + 1) // 2\n    elif k == 5:\n        return x * (x + 1) // 2 - 9 * x // 9 * (x // 9 + 1) // 2 + 9 * x // 81 * (x // 81 + 1) // 2 - 9 * x // 729 * (x // 729 + 1) // 2 + 9 * x // 6561 * (x // 6561 + 1) // 2\n    elif k == 6:\n        return x * (x + 1) // 2 - 9 * x // 9 * (x // 9 + 1) // 2 + 9 * x // 81 * (x // 81 + 1) // 2 - 9 * x // 729 * (x // 729 + 1) // 2 + 9 * x // 6561 * (x // 6561 + 1) // 2 - 9 * x // 59049 * (x // 59049 + 1) // 2\n    elif k == 7:\n        return x * (x + 1) // 2 - 9 * x // 9 * (x // 9 + 1) // 2 + 9 * x // 81 * (x // 81 + 1) // 2 - 9 * x // 729 * (x // 729 + 1) // 2 + 9 * x // 6561 * (x // 6561 + 1) // 2 - 9 * x // 59049 * (x // 59049 + 1) // 2 + 9 * x // 531441 * (x // 531441 + 1) // 2\n    elif k == 8:\n        return x * (x + 1) // 2 - 9 * x // 9 * (x // 9 + 1) // 2 + 9 * x // 81 * (x // 81 + 1) // 2 - 9 * x // 729 * (x // 729 + 1) // 2 + 9 * x // 6561 * (x // 6561 + 1) // 2 - 9 * x // 59049 * (x // 59049 + 1) // 2 + 9 * x // 531441 * (x // 531441 + 1) // 2 - 9 * x // 4782969 * (x // 4782969 + 1) // 2\n    elif k == 9:\n        return x * (x + 1) // 2 - 9 * x // 9 * (x // 9 + 1) // 2 + 9 * x // 81 * (x // 81 + 1) // 2 - 9 * x // 729 * (x // 729 + 1) // 2 + 9 * x // 6561 * (x // 6561 + 1) // 2 - 9 * x // 59049 * (x // 59049 + 1) // 2 + 9 * x // 531441 * (x // 531441 + 1) // 2 - 9 * x // 4782969 * (x // 4782969 + 1) // 2 + 9 * x // 43046721 * (x // 43046721 + 1) // 2\n    elif k == 10:\n        return x * (x + 1) // 2\n\ndef solve():\n    l, r, k = map(int, input().split())\n    print((count(r, k) - count(l - 1, k)) % MOD)\n\nsolve()"}
{"solution": "import sys\n\ndef main():\n    n, k, d = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    a.sort()\n\n    left = 0\n    while left < n:\n        right = left + 1\n        while right < n and a[right] - a[left] <= d:\n            right += 1\n        if right - left >= k:\n            left = right\n        else:\n            return \"NO\"\n    return \"YES\"\n\nprint(main())"}
{"solution": "def find_dead_bulbs(s):\n    colors = ['R', 'B', 'Y', 'G']\n    dead_bulbs = [0, 0, 0, 0]\n    for i in range(len(s)):\n        if s[i] == '!':\n            dead_bulbs[colors.index(s[(i + 1) % len(s)])] += 1\n        else:\n            for j in range(4):\n                if s[i] == colors[j]:\n                    dead_bulbs[j] -= 1\n    return dead_bulbs\n\ns = input()\ndead_bulbs = find_dead_bulbs(s)\nprint(*dead_bulbs)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_int_list():\n    return list(read_ints())\n\ndef main():\n    n, m = read_ints()\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        s, t = read_ints()\n        s -= 1\n        t -= 1\n        graph[s].append(t)\n\n    dp = [0.0] * n\n    for i in range(n - 2, -1, -1):\n        if not graph[i]:\n            continue\n        p = 1.0 / len(graph[i])\n        dp[i] = 1.0 + sum(dp[j] * p for j in graph[i])\n\n    ans = float('inf')\n    for j in graph[0]:\n        p = 1.0 / (len(graph[0]) - 1)\n        ans = min(ans, 1.0 + sum(dp[k] * p for k in graph[0] if k!= j))\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\nprint(n - (n % 10))"}
{"solution": "def find_swapped_keys(s, t):\n    swapped_keys = {}\n    for i in range(len(s)):\n        if s[i]!= t[i]:\n            if s[i] in swapped_keys:\n                if swapped_keys[s[i]]!= t[i]:\n                    return -1\n            elif t[i] in swapped_keys.values():\n                return -1\n            else:\n                swapped_keys[s[i]] = t[i]\n                swapped_keys[t[i]] = s[i]\n    return swapped_keys\n\n\ndef main():\n    s = input()\n    t = input()\n    swapped_keys = find_swapped_keys(s, t)\n    if swapped_keys == -1:\n        print(-1)\n    else:\n        pairs = [(key, value) for key, value in swapped_keys.items() if key < value]\n        print(len(pairs))\n        for pair in pairs:\n            print(pair[0], pair[1])\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef earliest_login(first_name, last_name):\n    min_login = first_name + last_name\n    for i in range(1, len(first_name)):\n        for j in range(1, len(last_name)):\n            login = first_name[:i] + last_name[:j]\n            if login < min_login:\n                min_login = login\n    return min_login\n\nfirst_name, last_name = input().split()\nprint(earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(n, brackets):\n    stack = []\n    max_height = 0\n    for bracket in brackets:\n        if bracket == '[':\n            stack.append(1)\n        else:\n            height = stack.pop()\n            if stack:\n                stack[-1] += height\n            max_height = max(max_height, height)\n\n    lines = [[''for _ in range(n)] for _ in range(max_height)]\n    stack = []\n    for i, bracket in enumerate(brackets):\n        if bracket == '[':\n            stack.append((i, len(stack)))\n        else:\n            start, height = stack.pop()\n            for j in range(height):\n                lines[j][i] = '|'\n            lines[height - 1][start] = '+'\n            lines[height - 1][i] = '+'\n            if height > 1:\n                lines[height - 2][start] = '|'\n                lines[height - 2][i] = '|'\n            if height > 2:\n                for j in range(height - 2, 0, -1):\n                    lines[j - 1][start] = '-'\n                    lines[j - 1][i] = '-'\n            if stack:\n                lines[height - 1][start + 1:i] = ['-'] * (i - start - 1)\n            else:\n                lines[height - 1][start + 1:i] = [' '] * (i - start - 1)\n\n    for line in lines:\n        print(''.join(line))\n\nn = int(input())\nbrackets = input()\ndraw_brackets(n, brackets)"}
{"solution": "import math\n\ndef golden_system(s):\n    q = (math.sqrt(5) + 1) / 2\n    result = 0\n    for i, c in enumerate(reversed(s)):\n        result += int(c) * (q ** i)\n    return result\n\ns1 = input()\ns2 = input()\n\nif golden_system(s1) > golden_system(s2):\n    print(\">\")\nelif golden_system(s1) < golden_system(s2):\n    print(\"<\")\nelse:\n    print(\"=\")"}
{"solution": "n = int(input())\ncolors = [input() for _ in range(n)]\n\ngems = {\n    \"purple\": \"Power\",\n    \"green\": \"Time\",\n    \"blue\": \"Space\",\n    \"orange\": \"Soul\",\n    \"red\": \"Reality\",\n    \"yellow\": \"Mind\"\n}\n\nabsent_gems = [gem for color, gem in gems.items() if color not in colors]\n\nprint(len(absent_gems))\nfor gem in absent_gems:\n    print(gem)"}
{"solution": "import math\n\nn, a, b = map(int, input().split())\n\nrounds = int(math.log2(n))\na -= 1\nb -= 1\n\nfor i in range(1, rounds + 1):\n    a //= 2\n    b //= 2\n    if a == b:\n        print(i)\n        break\nelse:\n    print(\"Final!\")"}
{"solution": "def solve():\n    n = int(input())\n    p = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    cnt = sum(b) % 2\n    vis = [False] * (n + 1)\n    res = 0\n\n    for i in range(1, n + 1):\n        if not vis[i]:\n            j = i\n            while not vis[j]:\n                vis[j] = True\n                j = p[j - 1]\n            res += 1\n\n    if res > 1:\n        res -= 1\n    if cnt == 0:\n        res += 1\n\n    print(res)\n\nsolve()"}
{"solution": "v1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\nif v1 < v2:\n    v1, v2 = v2, v1\n\nmax_speed = v1\nmin_speed = v1 - (t - 1) * d\nmax_speed = min(max_speed, v2 + (t - 1) * d)\n\nif min_speed < v2:\n    min_speed = v2\n\ntotal_distance = (max_speed + min_speed) * t // 2\n\nprint(total_distance)"}
{"solution": "import sys\nimport itertools\n\ndef check_order(order, weights, parts):\n    total_weight = sum(weights)\n    max_weight = max(weights)\n    min_weight = min(weights)\n    max_part_weight = max(part[1] for part in parts)\n    min_part_weight = min(part[1] for part in parts)\n\n    if total_weight - max_weight <= min_part_weight and total_weight - min_weight <= max_part_weight:\n        return True\n\n    for i in range(len(parts)):\n        if sum(weights[j] for j in range(len(weights)) if order[j] == i) > parts[i][1]:\n            return False\n\n    return True\n\ndef get_min_distance(weights, parts):\n    min_distance = float('inf')\n    for order in itertools.permutations(range(len(parts))):\n        if check_order(order, weights, parts):\n            distance = sum(part[0] for part in parts)\n            min_distance = min(min_distance, distance)\n    return min_distance\n\ndef main():\n    input_lines = sys.stdin.readlines()\n    n, m = map(int, input_lines[0].split())\n    weights = list(map(int, input_lines[1].split()))\n    parts = [list(map(int, line.split())) for line in input_lines[2:]]\n\n    min_distance = float('inf')\n    for permutation in itertools.permutations(weights):\n        distance = get_min_distance(permutation, parts)\n        if distance!= float('inf'):\n            min_distance = min(min_distance, distance)\n\n    if min_distance == float('inf'):\n        print(-1)\n    else:\n        print(min_distance)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef last_digit_factorial(n):\n    if n < 5:\n        return math.factorial(n) % 10\n    else:\n        return 0\n\na, b = map(int, input().split())\nprint(last_digit_factorial(b) // last_digit_factorial(a))"}
{"solution": "from collections import deque\n\nn, d = map(int, input().split())\ns = input()\n\ndef min_jumps(n, d, s):\n    queue = deque([(1, 0)])\n    visited = set([1])\n\n    while queue:\n        pos, jumps = queue.popleft()\n        if pos == n:\n            return jumps\n\n        for i in range(1, d + 1):\n            if pos + i <= n and s[pos + i - 1] == '1' and pos + i not in visited:\n                queue.append((pos + i, jumps + 1))\n                visited.add(pos + i)\n\n    return -1\n\nprint(min_jumps(n, d, s))"}
{"solution": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\nn = int(input())\nfor m in range(1, 1001):\n    if not is_prime(n * m + 1):\n        print(m)\n        break"}
{"solution": "def can_spend_all_coins(n):\n    for a in range(2):\n        for b in range(11):\n            c = (n - a * 1234567 - b * 123456) // 1234\n            if c >= 0 and a * 1234567 + b * 123456 + c * 1234 == n:\n                return True\n    return False\n\nn = int(input())\nprint(\"YES\" if can_spend_all_coins(n) else \"NO\")"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef solve():\n    n = int(read_input())\n    x1, x2 = read_ints()\n    lines = []\n    for _ in range(n):\n        k, b = read_ints()\n        lines.append((k, b))\n\n    lines.sort()\n\n    events = []\n    for i in range(n):\n        k, b = lines[i]\n        x = (b - lines[0][1]) / (lines[0][0] - k) if lines[0][0]!= k else float('inf')\n        if x1 <= x <= x2:\n            events.append((x, 1, i))\n        x = (b - lines[-1][1]) / (lines[-1][0] - k) if lines[-1][0]!= k else float('inf')\n        if x1 <= x <= x2:\n            events.append((x, -1, i))\n\n    events.sort()\n\n    active = set()\n    for _, type, i in events:\n        if type == 1:\n            if any(lines[i][0]!= lines[j][0] and x1 < (lines[j][1] - lines[i][1]) / (lines[i][0] - lines[j][0]) < x2 for j in active):\n                print(\"Yes\")\n                return\n            active.add(i)\n        else:\n            active.remove(i)\n\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import math\n\nn = int(input())\n\nweights = set()\n\nfor i in range(1, int(math.sqrt(n)) + 1):\n    if n % i == 0:\n        weights.add(i)\n        weights.add(n // i)\n\nprint(len(weights))"}
{"solution": "n, k = map(int, input().split())\n\nif k == 0 or k == 1 or n < k + 2:\n    print(0, 0)\nelse:\n    min_good = 1 if k == n - 1 else 2\n    max_good = min(k, n - k)\n    print(min_good, max_good)"}
{"solution": "def fibonacci(n):\n    a, b = 0, 1\n    while a < n:\n        a, b = b, a + b\n    return a\n\ndef find_max_games(n):\n    i = 0\n    while True:\n        fib = fibonacci(i)\n        if fib > n:\n            return i - 1\n        i += 1\n\nn = int(input())\nprint(find_max_games(n))"}
{"solution": "def max_vk(s):\n    vk_count = s.count(\"VK\")\n    kv_count = s.count(\"KV\")\n    vv_count = s.count(\"VV\")\n    kk_count = s.count(\"KK\")\n\n    max_count = vk_count\n\n    if vv_count > 0:\n        max_count = max(max_count, vk_count + 1)\n\n    if kk_count > 0:\n        max_count = max(max_count, vk_count + 1)\n\n    if kv_count > 0:\n        max_count = max(max_count, vk_count + 1)\n\n    return max_count\n\ns = input()\nprint(max_vk(s))"}
{"solution": "import math\n\nn = int(input())\nif n == 1:\n    print(2)\nelse:\n    print(2 * math.isqrt(n) + (n - math.isqrt(n) ** 2) // math.isqrt(n))"}
{"solution": "a, b = map(int, input().split())\nyears = 0\n\nwhile a <= b:\n    a *= 3\n    b *= 2\n    years += 1\n\nprint(years)"}
{"solution": "def solve(h, n):\n    if h == 1:\n        return 2 if n == 2 else 1\n\n    nodes = 2 ** h\n    mid = nodes // 2\n    left = mid\n    right = nodes - mid\n\n    if n <= mid:\n        return solve(h - 1, n) + right + 1\n    else:\n        return solve(h - 1, n - mid) + left + 1\n\nh, n = map(int, input().split())\nprint(solve(h, n))"}
{"solution": "import math\n\ndef get_divisors(x):\n    divisors = set()\n    for i in range(1, int(math.sqrt(x)) + 1):\n        if x % i == 0:\n            divisors.add(i)\n            divisors.add(x // i)\n    return divisors\n\ndef get_tables(x):\n    tables = []\n    for n in range(1, int(math.sqrt(x)) + 1):\n        if (x - n) % (n + 1) == 0:\n            m = (x - n) // (n + 1) + 1\n            tables.append((n, m))\n            if n!= m:\n                tables.append((m, n))\n    return tables\n\nx = int(input())\ntables = get_tables(x)\nprint(len(tables))\nfor n, m in sorted(tables):\n    print(n, m)"}
{"solution": "def is_leap(year):\n    return year % 4 == 0 and (year % 100!= 0 or year % 400 == 0)\n\ndef get_days_in_month(month, year):\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return 31\n    elif month == 2:\n        return 29 if is_leap(year) else 28\n    else:\n        return 30\n\ndef check_months(days):\n    for year in range(2000, 2025):\n        for month in range(1, 13):\n            if all(get_days_in_month((month + i - 1) % 12 + 1, year + (month + i - 1) // 12) == days[i] for i in range(len(days))):\n                return True\n    return False\n\nn = int(input())\ndays = list(map(int, input().split()))\n\nprint(\"YES\" if check_months(days) else \"NO\")"}
{"solution": "import math\n\ndef get_divisors(n):\n    divisors = []\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i!= n // i:\n                divisors.append(n // i)\n    return divisors\n\ndef get_sequence(n):\n    sequence = []\n    divisors = get_divisors(n)\n    for divisor in divisors:\n        if divisor!= n:\n            sequence.append((1, divisor))\n            sequence.append((divisor - 1, divisor))\n    return sequence\n\ndef get_sequence_sum(sequence):\n    total = 0\n    for a, b in sequence:\n        total += a / b\n    return total\n\ndef solve(n):\n    sequence = get_sequence(n)\n    total = get_sequence_sum(sequence)\n    if total == 1 - 1 / n:\n        return sequence\n    else:\n        return None\n\ndef main():\n    n = int(input())\n    sequence = solve(n)\n    if sequence is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(len(sequence))\n        for a, b in sequence:\n            print(a, b)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef read_ints():\n    return map(int, sys.stdin.readline().split())\n\ndef read_int():\n    return int(sys.stdin.readline())\n\ndef solve():\n    n = read_int()\n    a, b = read_ints()\n    h = list(read_ints())\n\n    total = sum(h)\n    if a < 0 or b < 0 or a + b < total:\n        print(-1)\n        return\n\n    dp = [[[float('inf')] * (total + 1) for _ in range(2)] for _ in range(n + 1)]\n    dp[0][0][0] = 0\n    dp[0][1][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(2):\n            for k in range(total + 1):\n                if k - h[i - 1] >= 0:\n                    dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k - h[i - 1]])\n                if j == 0 and k + h[i - 1] <= total:\n                    dp[i][1][k + h[i - 1]] = min(dp[i][1][k + h[i - 1]], dp[i - 1][0][k] + h[i - 1])\n                if j == 1 and k + h[i - 1] <= total:\n                    dp[i][0][k + h[i - 1]] = min(dp[i][0][k + h[i - 1]], dp[i - 1][1][k] + h[i - 1])\n\n    ans = float('inf')\n    for i in range(total + 1):\n        if i <= a and total - i <= b:\n            ans = min(ans, dp[n][0][i], dp[n][1][i])\n\n    print(ans if ans!= float('inf') else -1)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn, m, k = map(int, input().split())\n\nif n % 2 == 0 and m % 2 == 0 and k % 2 == 0:\n    k //= 2\n    n //= 2\n    m //= 2\n\ng = gcd(n, m)\nn //= g\nm //= g\nk = (k * g) // math.gcd(k, g)\n\nif n * m < k:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(\"0 0\")\n    print(\"0\", m)\n    print(n, \"0\")"}
{"solution": "n, k = map(int, input().split())\nprint(\"YES\" if (n - 1) // k > n // (2 * k) else \"NO\")"}
{"solution": "n = int(input())\nexercises = list(map(int, input().split()))\n\nchest_exercises = sum(exercises[i] for i in range(0, n, 3))\nbiceps_exercises = sum(exercises[i] for i in range(1, n, 3))\nback_exercises = sum(exercises[i] for i in range(2, n, 3))\n\nmax_exercises = max(chest_exercises, biceps_exercises, back_exercises)\n\nif max_exercises == chest_exercises:\n    print(\"chest\")\nelif max_exercises == biceps_exercises:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "n = int(input())\ngrades = list(map(int, input().split()))\n\ntotal = sum(grades)\ncount = 0\n\nwhile (total + count * (5 - grades[count - 1])) / n < 4.5 and count < n:\n    count += 1\n\nprint(count)"}
{"solution": "def solve(u, v):\n    if u > v:\n        return None\n    if u % 2!= v % 2:\n        return None\n    if u == 0 and v == 0:\n        return []\n    if u == v:\n        return [u]\n    if v - u <= u:\n        return [v - u, u]\n    if v - u == 2 * u + 1:\n        return [1, 1, v - 2]\n    if v - u == 2 * u + 2:\n        return [2, v - 2 * u - 2, u]\n    if v - u == 2 * u + 3:\n        return [1, 3, v - 2 * u - 3, u]\n    if v - u == 2 * u + 4:\n        return [2, 2, v - 2 * u - 4, u]\n    if v - u == 2 * u + 5:\n        return [1, 1, 1, 3, v - 2 * u - 5, u]\n    if v - u == 2 * u + 6:\n        return [2, 2, 2, v - 2 * u - 6, u]\n    if v - u == 2 * u + 7:\n        return [1, 3, 3, v - 2 * u - 7, u]\n    if v - u == 2 * u + 8:\n        return [2, 2, 2, 2, v - 2 * u - 8, u]\n    if v - u == 2 * u + 9:\n        return [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, v - 2 * u - 9, u]\n    if v - u == 2 * u + 10:\n        return [2, 2, 2, 2, 2, v - 2 * u - 10, u]\n    if v - u == 2 * u + 11:\n        return [1, 3, 3, 3, 1, v - 2 * u - 11, u]\n    if v - u == 2 * u + 12:\n        return [2, 2, 2, 2, 2, 2, v - 2 * u - 12, u]\n    if v - u == 2 * u + 13:\n        return [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, v - 2 * u - 13, u]\n    if v - u == 2 * u + 14:\n        return [2, 2, 2, 2, 2, 2, 2, v - 2 * u - 14, u]\n    if v - u == 2 * u + 15:\n        return [1, 3, 3, 3, 3, 3, v - 2 * u - 15, u]\n    return [1] * (v - u) + [u]\n\nu, v = map(int, input().split())\nres = solve(u, v)\nif res is None:\n    print(-1)\nelse:\n    print(len(res))\n    print(*res)"}
{"solution": "def min_ones(n):\n    ones = [0] * 16\n    ones[1] = 1\n    for i in range(2, 16):\n        ones[i] = ones[i-1] * 10 + 1\n\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for i in range(1, n + 1):\n        for j in range(1, 16):\n            if i >= ones[j]:\n                dp[i] = min(dp[i], dp[i - ones[j]] + j)\n\n    return dp[n]\n\nn = int(input())\nprint(min_ones(n))"}
{"solution": "import math\n\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\ndx = abs(x1 - x2)\ndy = abs(y1 - y2)\n\nif dx == 0:\n    print(\"YES\" if dy % y == 0 else \"NO\")\nelif dy == 0:\n    print(\"YES\" if dx % x == 0 else \"NO\")\nelse:\n    gcd = math.gcd(dx, dy)\n    print(\"YES\" if gcd == math.gcd(gcd, x) and gcd == math.gcd(gcd, y) else \"NO\")"}
{"solution": "from math import factorial\nfrom collections import Counter\n\ndef calculate_permutations(n):\n    n = str(n)\n    counter = Counter(n)\n    numerator = factorial(len(n))\n    denominator = 1\n    for count in counter.values():\n        denominator *= factorial(count)\n    permutations = numerator // denominator\n    if n[0]!= '0':\n        return permutations\n    else:\n        return 0\n\ndef calculate_variants(n):\n    variants = 0\n    for i in range(1, len(n) + 1):\n        variants += calculate_permutations(n[:i])\n    return variants\n\nn = int(input())\nprint(calculate_variants(str(n)))"}
{"solution": "a = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\nmin_jacket = min(a, d)\nmin_scarf_vest = min(b, c)\n\nfirst_type = min(min_jacket, d - min_scarf_vest)\nsecond_type = min(min_scarf_vest, d - first_type)\n\nremaining_jacket = d - first_type - second_type\nremaining_tie = a - first_type\n\nif remaining_jacket <= remaining_tie:\n    first_type += remaining_jacket\nelse:\n    first_type += remaining_tie\n\nprint(first_type * e + second_type * f)"}
{"solution": "import math\n\ndef exgcd(a, b):\n    if b == 0:\n        return a, 1, 0\n    else:\n        gcd, x, y = exgcd(b, a % b)\n        return gcd, y, x - (a // b) * y\n\ndef mod_inverse(a, p):\n    gcd, x, y = exgcd(a, p)\n    return x % p\n\ndef solve():\n    a, b, p, x = map(int, input().split())\n    if b == 0:\n        if a == 1:\n            print(x)\n        else:\n            print(0)\n        return\n    if a == 1:\n        if b == 1:\n            print(x)\n        else:\n            print(0)\n        return\n    phi = p - 1\n    k = phi\n    for i in range(2, int(math.sqrt(phi)) + 1):\n        if phi % i == 0:\n            k = i\n            break\n    if k == phi:\n        k = phi\n    else:\n        k = phi // k\n    ans = 0\n    for i in range(1, k + 1):\n        if pow(a, i, p) == 1:\n            if pow(a, (x // k) * i, p) == b:\n                ans += x // k + 1\n            elif (x // k) * i + 1 <= x and pow(a, ((x // k) * i + 1), p) == b:\n                ans += x // k + 1\n            elif (x // k) * i + 2 <= x and pow(a, ((x // k) * i + 2), p) == b:\n                ans += x // k + 1\n            break\n    if ans == 0:\n        for i in range(1, phi + 1):\n            if pow(a, i, p) == b:\n                ans += x // phi\n                if x // phi * i <= x and pow(a, (x // phi) * i, p) == b:\n                    ans += 1\n                elif (x // phi) * i + 1 <= x and pow(a, ((x // phi) * i + 1), p) == b:\n                    ans += 1\n                elif (x // phi) * i + 2 <= x and pow(a, ((x // phi) * i + 2), p) == b:\n                    ans += 1\n                break\n    print(ans)\n\nsolve()"}
{"solution": "k2, k3, k5, k6 = map(int, input().split())\nans = 0\nans += min(k5, k2, k6) * 256\nk2 -= min(k5, k2, k6)\nk5 -= min(k5, k2, k6)\nk6 -= min(k5, k2, k6)\nans += min(k2, k3) * 32\nprint(ans)"}
{"solution": "import math\n\nn, x, y, c = map(int, input().split())\n\nif n * n < c:\n    print(-1)\nelse:\n    if n % 2 == 0:\n        max_side = n\n    else:\n        max_side = n - 1\n\n    if x == 1 or x == n:\n        side_x = x\n    else:\n        side_x = min(x - 1, n - x)\n\n    if y == 1 or y == n:\n        side_y = y\n    else:\n        side_y = min(y - 1, n - y)\n\n    max_side = max(max_side, 2 * max(side_x, side_y) + 1)\n\n    if max_side * max_side < c:\n        print(-1)\n    else:\n        if c == 1:\n            print(0)\n        else:\n            print(math.ceil(math.log2(math.sqrt(c))))"}
{"solution": "def max_xor(l, r):\n    if l == r:\n        return 0\n\n    max_val = 0\n    i = 0\n    while (1 << i) <= r:\n        i += 1\n\n    for j in range(i - 1, -1, -1):\n        if (l & (1 << j)) == 0 and (r & (1 << j))!= 0:\n            max_val |= (1 << j)\n        elif (l & (1 << j)) == 0 and (r & (1 << j)) == 0:\n            break\n\n    return max_val | ((1 << (j + 1)) - 1)\n\nl, r = map(int, input().split())\nprint(max_xor(l, r))"}
{"solution": "def check(n, k, h):\n    return (n * h) + (h - 1) * h <= 2 * k\n\ndef solve(n, k):\n    l, r = 0, k\n    while l < r:\n        mid = (l + r) // 2\n        if check(n, k, mid):\n            r = mid\n        else:\n            l = mid + 1\n    return l\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "x, y, z, t1, t2, t3 = map(int, input().split())\n\nstairs_time = abs(y - x) * t1\nelevator_time = abs(z - x) * t2 + 2 * t3 + abs(y - z) * t2\n\nprint(\"YES\" if elevator_time <= stairs_time else \"NO\")"}
{"solution": "n, m = map(int, input().split())\n\nif m == 1:\n    print(2)\nelif m == n:\n    print(n - 1)\nelse:\n    print(m - 1 if m - 1 >= n - m else m + 1)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ncount = 0\ni = 0\nwhile i < n:\n    if a[i] == 1:\n        count += 1\n        while i < n and a[i] == 1:\n            count += 1\n            i += 1\n    elif i + 1 < n and a[i + 1] == 1:\n        count += 1\n        i += 1\n    i += 1\n\nprint(count)"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\ntotal = 0\ndays = 0\nfor i in range(n):\n    total += a[i]\n    days += 1\n    given = min(total, (i + 1) * 8)\n    if given >= k:\n        print(days)\n        break\nelse:\n    print(-1)"}
{"solution": "import sys\n\ndef min_additional_walks(n, k, a):\n    b = [0] * n\n    additional_walks = 0\n\n    b[0] = max(a[0], k)\n    additional_walks += b[0] - a[0]\n\n    for i in range(1, n):\n        b[i] = max(a[i], k - (b[i-1] - a[i-1]))\n        additional_walks += b[i] - a[i]\n\n    return additional_walks, b\n\nn, k = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\n\nadditional_walks, b = min_additional_walks(n, k, a)\n\nprint(additional_walks)\nprint(*b)"}
{"solution": "n = int(input())\nprint(n*n + (n-1)*n + (n-1)*n)"}
{"solution": "def is_pangram(s):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    return set(alphabet).issubset(set(s.lower()))\n\nn = int(input())\ns = input()\nprint(\"YES\" if is_pangram(s) else \"NO\")"}
{"solution": "def time_after_a_minutes(current_time, minutes_passed):\n    hours, mins = map(int, current_time.split(':'))\n    total_minutes = hours * 60 + mins + minutes_passed\n    new_hours = (total_minutes // 60) % 24\n    new_mins = total_minutes % 60\n    return f\"{new_hours:02d}:{new_mins:02d}\"\n\ncurrent_time = input()\nminutes_passed = int(input())\nprint(time_after_a_minutes(current_time, minutes_passed))"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    a = [input() for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            a[i] = a[i][:j] + '0' + a[i][j+1:]\n        for k in range(n):\n            if k!= i:\n                for j in range(m):\n                    if a[k][j] == '1':\n                        a[i] = a[i][:j] + '1' + a[i][j+1:]\n        if '0' not in a[i]:\n            print(\"YES\")\n            return\n        a[i] = a[i].replace('0', '1')\n\n    print(\"NO\")\n\nsolve()"}
{"solution": "n = int(input())\ndominoes = [list(map(int, input().split())) for _ in range(n)]\n\ndef is_even_sum(dominoes):\n    upper_sum = sum(x for x, y in dominoes)\n    lower_sum = sum(y for x, y in dominoes)\n    return upper_sum % 2 == 0 and lower_sum % 2 == 0\n\ndef rotate(dominoes, i):\n    dominoes[i][0], dominoes[i][1] = dominoes[i][1], dominoes[i][0]\n\ndef solve(dominoes):\n    if is_even_sum(dominoes):\n        return 0\n    for i in range(len(dominoes)):\n        rotate(dominoes, i)\n        if is_even_sum(dominoes):\n            return 1\n        rotate(dominoes, i)\n    return -1\n\nprint(solve(dominoes))"}
{"solution": "import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef solve():\n    a, b = map(int, input().split())\n    area = a**2 - b**2\n    if is_prime(area):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nt = int(input())\nfor _ in range(t):\n    solve()"}
{"solution": "import sys\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # Collinear\n    elif val > 0:\n        return 1  # Clockwise\n    else:\n        return 2  # Counterclockwise\n\ndef convex_hull(points):\n    n = len(points)\n    if n < 3:\n        raise ValueError(\"Convex hull not possible\")\n\n    hull = []\n    l = 0\n    for i in range(1, n):\n        if points[i][0] < points[l][0]:\n            l = i\n\n    p = l\n    while True:\n        hull.append(points[p])\n        q = (p + 1) % n\n\n        for i in range(n):\n            if orientation(points[p], points[i], points[q]) == 2:\n                q = i\n\n        p = q\n        if p == l:\n            break\n\n    return hull\n\nhull = convex_hull(points)\n\nfor point in points:\n    if point not in hull:\n        continue\n    new_hull = [p for p in hull if p!= point]\n    if len(new_hull) < 3:\n        print(\"Yes\")\n        sys.exit()\n\n    min_x = min(p[0] for p in new_hull)\n    max_x = max(p[0] for p in new_hull)\n\n    if min_x * max_x < 0:\n        continue\n    else:\n        print(\"Yes\")\n        sys.exit()\n\nprint(\"No\")"}
{"solution": "import math\n\na, b = map(int, input().split())\nprint(math.factorial(min(a, b)))"}
{"solution": "n = int(input())\n\nif n % 2 == 0:\n    print(n + 9, 9)\nelse:\n    print(n + 8, 8)"}
{"solution": "import sys\nimport heapq\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_list():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n, m, p = read_ints()\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, c = read_ints()\n        a -= 1\n        b -= 1\n        adj[a].append((b, c))\n\n    dist = [float('inf')] * n\n    dist[0] = 0\n    pq = [(0, 0)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, c in adj[u]:\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                heapq.heappush(pq, (dist[v], v))\n\n    if dist[-1] == float('inf'):\n        print(-1)\n        return\n\n    dp = [[-float('inf')] * (n + 1) for _ in range(n)]\n    dp[-1][dist[-1]] = 0\n    for u in range(n - 1, -1, -1):\n        for d in range(n + 1):\n            if dp[u][d] == -float('inf'):\n                continue\n            for v, c in adj[u]:\n                if d + 1 <= n:\n                    dp[v][d + 1] = max(dp[v][d + 1], dp[u][d] + c)\n\n    ans = -float('inf')\n    for d in range(1, n + 1):\n        coins = dp[-1][d]\n        if coins < p * d:\n            continue\n        ans = max(ans, coins - p * d)\n        if p * d <= dp[-1][d]:\n            ans = max(ans, dp[-1][d] - p * d)\n            break\n    print(ans)\n\nsolve()"}
{"solution": "from collections import defaultdict\nfrom sys import stdin\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef can_form(s, words):\n    for word in words:\n        if s.startswith(word):\n            new_s = s[len(word):]\n            if is_palindrome(new_s):\n                return True\n            if can_form(new_s, words):\n                return True\n    return False\n\ndef min_cost(words, costs, s):\n    if is_palindrome(s):\n        return 0\n    min_val = float('inf')\n    for i in range(len(words)):\n        if s.startswith(words[i]):\n            new_s = s[len(words[i]):]\n            if is_palindrome(new_s):\n                min_val = min(min_val, costs[i])\n            else:\n                min_val = min(min_val, costs[i] + min_cost(words, costs, new_s))\n    return min_val\n\ndef main():\n    n = int(stdin.readline())\n    words = []\n    costs = []\n    for _ in range(n):\n        s, c = stdin.readline().split()\n        words.append(s)\n        costs.append(int(c))\n\n    odd_count = defaultdict(int)\n    even_count = defaultdict(int)\n    for word in words:\n        for char in set(word):\n            if word.count(char) % 2 == 1:\n                odd_count[char] += 1\n            else:\n                even_count[char] += 1\n\n    if len(odd_count) > 1:\n        print(-1)\n        return\n\n    if len(odd_count) == 1:\n        char = list(odd_count.keys())[0]\n        min_val = float('inf')\n        for i in range(n):\n            if words[i].count(char) % 2 == 1:\n                min_val = min(min_val, costs[i])\n        if min_val == float('inf'):\n            print(-1)\n            return\n        print(min_val)\n        return\n\n    min_val = float('inf')\n    for i in range(n):\n        min_val = min(min_val, min_cost(words, costs, words[i]))\n    if min_val == float('inf'):\n        print(-1)\n    else:\n        print(min_val)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def largest_xor_sum():\n    n, k = map(int, input().split())\n    result = 0\n    i = 0\n    while n > 0:\n        if n >= 2**i and k > 0:\n            result += 2**i\n            k -= 1\n        n -= 2**i\n        i += 1\n    print(result)\n\nlargest_xor_sum()"}
{"solution": "import sys\n\nn = int(input())\nx, y = [], []\nfor _ in range(n):\n    xi, yi = map(int, input().split())\n    x.append(xi)\n    y.append(yi)\n\nmax_x, max_y = max(x), max(y)\nmin_side = min(max_x, max_y)\n\nleft, right = 0, min_side\nwhile left <= right:\n    mid = (left + right) // 2\n    if mid >= max_x or mid >= max_y:\n        right = mid - 1\n    elif all(min(mid, max_x) >= xi or min(mid, max_y) >= yi for xi, yi in zip(x, y)):\n        right = mid - 1\n    else:\n        left = mid + 1\n\nprint(left)"}
{"solution": "from collections import Counter\n\ndef max_nineteens(s):\n    counter = Counter('nineteen')\n    s_counter = Counter(s)\n    return min(s_counter[c] // counter[c] for c in counter)\n\ns = input()\nprint(max_nineteens(s))"}
{"solution": "def highest_unreachable_branch(p, y):\n    \"\"\"\n    Find the highest branch that cannot be reached by any of the grasshoppers.\n\n    Args:\n    p (int): The highest branch occupied by a grasshopper.\n    y (int): The total number of branches.\n\n    Returns:\n    int: The highest branch that cannot be reached by any of the grasshoppers, or -1 if no such branch exists.\n    \"\"\"\n    def is_reachable(branch):\n        for i in range(2, p + 1):\n            if branch % i == 0 and branch // i <= p:\n                return True\n        return False\n\n    for branch in range(y, 1, -1):\n        if not is_reachable(branch):\n            return branch\n    return -1\n\n\np, y = map(int, input().split())\nprint(highest_unreachable_branch(p, y))"}
{"solution": "n, m, k = map(int, input().split())\nhouses = list(map(int, input().split()))\n\nmin_distance = float('inf')\n\nfor i, price in enumerate(houses):\n    if price <= k and i!= m - 1:\n        distance = abs(i - (m - 1)) * 10\n        min_distance = min(min_distance, distance)\n\nprint(min_distance)"}
{"solution": "from collections import defaultdict\n\ndef solve():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    b = [list(map(int, input().split())) for _ in range(n)]\n\n    cnt = defaultdict(int)\n    for i in range(n):\n        for j in range(m):\n            cnt[a[i][j]] += 1\n            cnt[b[i][j]] -= 1\n\n    for k, v in cnt.items():\n        if v!= 0:\n            print(\"NO\")\n            return\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j]!= b[i][j]:\n                break\n        else:\n            continue\n        break\n    else:\n        print(\"YES\")\n        return\n\n    for j in range(m):\n        for i in range(n):\n            if a[i][j]!= b[i][j]:\n                break\n        else:\n            continue\n        break\n    else:\n        print(\"YES\")\n        return\n\n    print(\"NO\")\n\nsolve()"}
{"solution": "def longest_uncommon_subsequence(a, b):\n    if a == b:\n        return -1\n    else:\n        return max(len(a), len(b))\n\na = input()\nb = input()\n\nprint(longest_uncommon_subsequence(a, b))"}
{"solution": "import math\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\ndef lcm(a, b):\n    return abs(a*b) // math.gcd(a, b)\n\nlcm_value = lcm(a, c)\nmin_value = min(b, d)\n\nif (d - b) % a == 0:\n    print(d)\nelif (b - d) % c == 0:\n    print(b)\nelif (d - min_value) % lcm_value == 0:\n    print(d + ((d - min_value) // lcm_value) * lcm_value)\nelse:\n    print(-1)"}
{"solution": "n = int(input())\nif n % 3 == 0:\n    print(1, (n - 1) // 3 * 2, (n - 1) // 3)\nelse:\n    print((n - 2) // 3, (n - 2) // 3, n - (n - 2) // 3 * 2)"}
{"solution": "import sys\n\nn, a, b, c, d = map(int, sys.stdin.readline().split())\n\ndef check(x, y, z):\n    return x + y + z + a == x + b + z + d and x + y + z + a == x + y + c + d and x + y + z + a == y + b + c + d\n\nans = 0\nfor x in range(1, n + 1):\n    for y in range(1, n + 1):\n        for z in range(1, n + 1):\n            if check(x, y, z):\n                ans += 1\n\nprint(ans)"}
{"solution": "w, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\nstones = {d1: u1, d2: u2}\n\nfor i in range(h, 0, -1):\n    w += i\n    if i in stones:\n        w -= stones[i]\n        if w < 0:\n            w = 0\n\nprint(w)"}
{"solution": "m = int(input())\nc = list(map(int, input().split()))\nx, y = map(int, input().split())\n\ntotal_students = sum(c)\nfor k in range(1, m + 1):\n    beginner_group = sum(c[:k])\n    intermediate_group = total_students - beginner_group\n    if x <= beginner_group <= y and x <= intermediate_group <= y:\n        print(k)\n        break\nelse:\n    print(0)"}
{"solution": "import math\n\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\ndef min_coins(n, k, A, B):\n    coins = 0\n    while n > 1:\n        if n % k == 0:\n            coins += min(A * (n % k), B)\n            n = n // k\n        else:\n            coins += A\n            n -= 1\n    return coins\n\nprint(min_coins(n, k, A, B))"}
{"solution": "import math\nfrom collections import deque\n\ndef prime_factors(n):\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef solve(n):\n    factors = prime_factors(n)\n    factors.sort()\n    queue = deque([(n, 0)])\n    visited = set([n])\n    min_n = n\n    min_ops = 0\n    while queue:\n        curr_n, curr_ops = queue.popleft()\n        if curr_n < min_n:\n            min_n = curr_n\n            min_ops = curr_ops\n        sqrt_n = math.isqrt(curr_n)\n        if sqrt_n ** 2 == curr_n and sqrt_n not in visited:\n            queue.append((sqrt_n, curr_ops + 1))\n            visited.add(sqrt_n)\n        for factor in factors:\n            if curr_n % factor == 0:\n                new_n = curr_n // factor\n                if new_n not in visited:\n                    queue.append((new_n, curr_ops + 1))\n                    visited.add(new_n)\n    return min_n, min_ops\n\nn = int(input())\nmin_n, min_ops = solve(n)\nprint(min_n, min_ops)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_string():\n    return read_input()\n\ndef solve():\n    n, k = read_ints()\n    r, s, p = read_ints()\n    t = read_string()\n\n    scores = {'r': p,'s': r, 'p': s}\n    wins = {'r':'s','s': 'p', 'p': 'r'}\n    memo = {}\n\n    def dp(i, last):\n        if i >= n:\n            return 0\n        if (i, last) in memo:\n            return memo[(i, last)]\n\n        max_score = 0\n        for hand in 'rsp':\n            if hand == last and i >= k:\n                continue\n            opponent = t[i]\n            if wins[hand] == opponent:\n                max_score = max(max_score, scores[hand] + dp(i + 1, hand))\n            else:\n                max_score = max(max_score, dp(i + 1, hand))\n\n        memo[(i, last)] = max_score\n        return max_score\n\n    print(dp(0, ''))\n\nsolve()"}
{"solution": "a, b, c = map(int, input().split())\nx = min(a, b) + c\ny = min(a - x, b - x) + c\nprint(2 * x + min(y, 1))"}
{"solution": "import sys\n\nn, k, p, x, y = map(int, input().split())\na = sorted(map(int, input().split()))\n\ntotal = sum(a)\nmedian_index = (n + 1) // 2\nmedian_count = n - k\n\nif total + (n - k) * p > x:\n    print(-1)\n    sys.exit()\n\nif a[k - median_count:] + [y] * median_count + a[:k - median_count] < [y] * median_index + a[median_index:]:\n    print(-1)\n    sys.exit()\n\nresult = []\nwhile len(result) < n - k:\n    if total + p <= x:\n        result.append(p)\n        total += p\n    elif total + y <= x:\n        result.append(y)\n        total += y\n    else:\n        result.append(x - total)\n        total = x\n        break\n\nprint(*result)"}
{"solution": "def is_berlanese(word):\n    vowels = set('aeiou')\n    for i in range(len(word) - 1):\n        if word[i] not in vowels and word[i]!= 'n' and word[i + 1] not in vowels:\n            return False\n    if word[-1] not in vowels and word[-1]!= 'n':\n        return False\n    return True\n\nword = input()\nprint('YES' if is_berlanese(word) else 'NO')"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef solve():\n    n, m = read_ints()\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = read_ints()\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def check(color):\n        for i in range(1, n + 1):\n            if color[i] == 0:\n                continue\n            for j in graph[i]:\n                if color[j]!= 0 and color[j]!= color[i]:\n                    return False\n        return True\n\n    def dfs(u, color, used):\n        if not check(color):\n            return 0\n        if u == n + 1:\n            return sum(1 for i in range(1, n + 1) if color[i]!= 0)\n        res = 0\n        for i in range(1, n + 1):\n            if i not in used:\n                used.add(i)\n                color[u] = i\n                res = max(res, dfs(u + 1, color, used))\n                used.remove(i)\n                color[u] = 0\n        return res\n\n    color = [0] * (n + 1)\n    used = set()\n    return dfs(1, color, used)\n\nprint(solve())"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, m = read_ints()\n    a = list(read_ints())\n    b = list(read_ints())\n\n    a = [0] + a\n    b = set(b)\n\n    dp = [[-float('inf')] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(n + 1):\n            if dp[i - 1][j]!= -float('inf'):\n                dp[i][j] = max(dp[i][j], dp[i - 1][j] + a[i] if j > 0 else dp[i - 1][j] - a[i])\n\n                if i in b:\n                    for k in range(a[i], j + 1):\n                        dp[i][k] = max(dp[i][k], dp[i - 1][j] + k)\n\n    print(max(dp[n]))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_score(max_points, time, wrong_submissions):\n    return max(0.3 * max_points, (1 - time / 250) * max_points - 50 * wrong_submissions)\n\ndef main():\n    times = list(map(int, input().split()))\n    wrong_submissions = list(map(int, input().split()))\n    successful_hacks, unsuccessful_hacks = map(int, input().split())\n\n    max_points = [500, 1000, 1500, 2000, 2500]\n    total_score = sum(calculate_score(max_points[i], times[i], wrong_submissions[i]) for i in range(5))\n    total_score += 100 * successful_hacks - 50 * unsuccessful_hacks\n\n    print(int(total_score))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 998244353\n\ndef qpow(a, b):\n    res = 1\n    while b:\n        if b & 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b >>= 1\n    return res\n\ndef main():\n    n, m, L, R = map(int, input().split())\n    if n & 1 and m & 1:\n        print(qpow(R - L + 1, 1))\n    elif (n & 1) or (m & 1):\n        print((R + 1) // 2 * ((R + 1) // 2 - (L - 1) // 2 + 1) % MOD * qpow(2, (n * m - 1) // 2) % MOD)\n    else:\n        print(((R + 1) // 2 * ((R + 1) // 2 - (L - 1) // 2 + 1) % MOD * qpow(2, n * m // 2 - 1) % MOD + (R - L + 1) * ((R - L + 2) // 2) % MOD * qpow(2, n * m // 2 - 1) % MOD) % MOD)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_increasing(matrix):\n    n, m = len(matrix), len(matrix[0])\n    for i in range(n):\n        for j in range(m - 1):\n            if matrix[i][j] >= matrix[i][j + 1]:\n                return False\n    for j in range(m):\n        for i in range(n - 1):\n            if matrix[i][j] >= matrix[i + 1][j]:\n                return False\n    return True\n\n\ndef solve():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    b = [list(map(int, input().split())) for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] > b[i][j]:\n                a[i][j], b[i][j] = b[i][j], a[i][j]\n\n    if is_increasing(a) and is_increasing(b):\n        print(\"Possible\")\n    else:\n        print(\"Impossible\")\n\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort(reverse=True)\nans = 0\nlast = sys.maxsize\n\nfor i in range(n):\n    if last > a[i]:\n        last = a[i]\n    else:\n        last -= 1\n    if last > 0:\n        ans += last\n    else:\n        break\n\nprint(ans)"}
{"solution": "import heapq\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\nheap = []\nheapq.heappush(heap, -k)\n\ncount = 0\nfor num in a:\n    while -heap[0] < num / 2:\n        if -heap[0] >= num:\n            break\n        heapq.heappop(heap)\n        heapq.heappush(heap, -num)\n        count += 1\n    if -heap[0] < num / 2:\n        heapq.heappush(heap, -num)\n        count += 1\n    else:\n        heapq.heappop(heap)\n        heapq.heappush(heap, -num)\n\nprint(count)"}
{"solution": "n = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\nfirst = min(max_1, n - min_2 - min_3)\nsecond = min(max_2, n - first - min_3)\nthird = n - first - second\n\nprint(first, second, third)"}
{"solution": "def get_next_moon_state(n, a):\n    moon_cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    if n < 30:\n        if a[-1] < 15 and a[-1] > 0:\n            if a[-1] < a[-2]:\n                return -1\n            else:\n                return \"UP\"\n        elif a[-1] == 15:\n            return \"DOWN\"\n        elif a[-1] == 0:\n            return \"UP\"\n    else:\n        if a[-1] < a[-31]:\n            return \"DOWN\"\n        elif a[-1] > a[-31]:\n            return \"UP\"\n        else:\n            return -1\n\nn = int(input())\na = list(map(int, input().split()))\nresult = get_next_moon_state(n, a)\nif result == -1:\n    print(-1)\nelse:\n    print(result)"}
{"solution": "def can_transform(s, t):\n    vowels = set('aeiou')\n    if len(s)!= len(t):\n        return False\n    for i in range(len(s)):\n        if (s[i] in vowels and t[i] not in vowels) or (s[i] not in vowels and t[i] in vowels):\n            return False\n    return True\n\ns = input()\nt = input()\nprint(\"Yes\" if can_transform(s, t) else \"No\")"}
{"solution": "def min_steps(board, color):\n    min_steps = float('inf')\n    for row in range(8):\n        for col in range(8):\n            if board[row][col] == color:\n                if color == 'W':\n                    min_steps = min(min_steps, row)\n                else:\n                    min_steps = min(min_steps, 7 - row)\n    return min_steps\n\nboard = [input() for _ in range(8)]\nmin_steps_A = min_steps(board, 'W')\nmin_steps_B = min_steps(board, 'B')\n\nif min_steps_A <= min_steps_B:\n    print('A')\nelse:\n    print('B')"}
{"solution": "from collections import defaultdict\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    m = int(input())\n    b = list(map(int, input().split()))\n\n    sa = [0] * (n + 1)\n    sb = [0] * (m + 1)\n    for i in range(n):\n        sa[i + 1] = sa[i] + a[i]\n    for i in range(m):\n        sb[i + 1] = sb[i] + b[i]\n\n    if sa[-1]!= sb[-1]:\n        print(-1)\n        return\n\n    s = sa[-1]\n    da = defaultdict(list)\n    db = defaultdict(list)\n    for i in range(n + 1):\n        da[sa[i]].append(i)\n    for i in range(m + 1):\n        db[sb[i]].append(i)\n\n    ans = 0\n    for i in range(n + 1):\n        for j in da[sa[i]]:\n            if j == i:\n                continue\n            if sa[j] - sa[i] in db and db[sa[j] - sa[i]]:\n                k = db[sa[j] - sa[i]][-1]\n                if k > 0 and sb[k] - sb[0] == sa[j] - sa[i]:\n                    ans = max(ans, j - i + k)\n\n    print(ans)\n\nsolve()"}
{"solution": "def is_contest_problem(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    for friend in friends:\n        if problem_name.count(friend) == 1:\n            return \"YES\"\n    return \"NO\"\n\nproblem_name = input()\nprint(is_contest_problem(problem_name))"}
{"solution": "import sys\n\ndef sieve_of_eratosthenes(n):\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n    p = 2\n    while p * p <= n:\n        if primes[p]:\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n    return primes\n\ndef main():\n    a, b, k = map(int, sys.stdin.readline().split())\n    primes = sieve_of_eratosthenes(b)\n    prime_count = [0] * (b + 1)\n    for i in range(2, b + 1):\n        prime_count[i] = prime_count[i - 1] + int(primes[i])\n    min_l = float('inf')\n    for i in range(a, b + 1):\n        l = b - i + 1\n        while prime_count[i + l - 1] - prime_count[i - 1] < k:\n            l -= 1\n            if l == 0:\n                break\n        if l > 0:\n            min_l = min(min_l, b - i + 1 - l + 1)\n    print(-1 if min_l == float('inf') else min_l)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\na, h, w = map(int, input().split())\n\ndef get_x(n, m):\n    return max((h - n * a) / (n + 1), (w - m * a) / (m + 1))\n\nx = float('inf')\nfor n in range(1, h // a + 1):\n    for m in range(1, w // a + 1):\n        x = min(x, get_x(n, m))\n\nif x == float('inf'):\n    print(-1)\nelse:\n    print(x)"}
{"solution": "n = int(input())\nchapters = [list(map(int, input().split())) for _ in range(n)]\nk = int(input())\n\ncount = 0\nfor chapter in chapters:\n    if chapter[0] >= k or (chapter[0] < k and chapter[1] >= k):\n        count += 1\n\nprint(count)"}
{"solution": "def solve(s):\n    target = \"CODEFORCES\"\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            if s[i:j] not in target:\n                temp = s[:i] + s[j:]\n                if target in temp:\n                    return \"YES\"\n    return \"NO\"\n\ns = input()\nprint(solve(s))"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n = read_int()\n    dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][i] = 0\n        dp[i][i + 1] = 0\n    for length in range(2, n):\n        for i in range(1, n - length + 1):\n            j = i + length\n            for k in range(i + 1, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + i * k * j)\n    print(dp[1][n] + sum(range(1, n + 1)))\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def count_digits(n):\n    digits = 0\n    i = 1\n    while i <= n:\n        digits += len(str(i))\n        i += 1\n    return digits\n\nn = int(input())\nprint(count_digits(n))"}
{"solution": "def solve():\n    n, A = map(int, input().split())\n    c = list(map(int, input().split()))\n\n    cnt = {}\n    cntA = 0\n    for i in range(n):\n        if c[i] == A:\n            cntA += 1\n        cnt[c[i]] = cnt.get(c[i], 0) + 1\n\n    for i in range(1, 10**6 + 1):\n        if i == A:\n            continue\n        cntB = 0\n        flag = True\n        for j in range(n):\n            if c[j] == A:\n                cntA += 1\n            if c[j] == i:\n                cntB += 1\n            if cntA > cntB:\n                flag = False\n                break\n        if flag:\n            print(i)\n            return\n    print(-1)\n\nsolve()"}
{"solution": "n, x = map(int, input().split())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nif total_sum > x or (total_sum < x and total_sum + n - 1!= x):\n    print(\"NO\")\nelif total_sum == x or (total_sum < x and total_sum + n - 1 == x and a[0] > 1):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n, S = map(int, input().split())\nprint((S + n - 1) // n)"}
{"solution": "from collections import Counter\n\ns = input()\nn = len(s)\ncnt = Counter(s)\n\nodd = sum(val % 2 for val in cnt.values())\nif odd > 1:\n    for char, val in cnt.items():\n        if val % 2 == 1 and char!= 'a':\n            cnt[char] -= 1\n            cnt['a'] += 1\n            break\n\nfirst_half = ''.join(char * (val // 2) for char, val in sorted(cnt.items()))\nsecond_half = first_half[::-1]\n\nmiddle = 'a' if n % 2 == 1 and sum(val % 2 for val in cnt.values()) == 1 else ''\n\nprint(first_half + middle + second_half)"}
{"solution": "def calculate_position_weight(board):\n    weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': -9, 'r': -5, 'b': -3, 'n': -3, 'p': -1\n    }\n    return sum(weights.get(piece, 0) for row in board for piece in row)\n\ndef main():\n    board = [input() for _ in range(8)]\n    weight = calculate_position_weight(board)\n    if weight > 0:\n        print(\"White\")\n    elif weight < 0:\n        print(\"Black\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import heapq\n\ndef solve():\n    n, m = map(int, input().split())\n    s = input()\n\n    dist = [float('inf')] * (n + 1)\n    prev = [-1] * (n + 1)\n    dist[0] = 0\n\n    pq = [(0, 0)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for i in range(1, m + 1):\n            v = u + i\n            if v > n or s[v] == '1':\n                continue\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                prev[v] = i\n                heapq.heappush(pq, (dist[v], v))\n\n    if dist[n] == float('inf'):\n        print(-1)\n        return\n\n    path = []\n    u = n\n    while u!= 0:\n        path.append(prev[u])\n        u -= prev[u]\n\n    print(*reversed(path))\n\nsolve()"}
{"solution": "import math\n\ndef solve():\n    k = int(input())\n    x, y = map(int, input().split())\n\n    if abs(x) % k == 0 and abs(y) % k == 0:\n        if abs(x) // k + abs(y) // k == 1:\n            print(1)\n            print(x, y)\n        else:\n            print(abs(x) // k + abs(y) // k)\n            cx, cy = 0, 0\n            for _ in range(abs(x) // k + abs(y) // k - 1):\n                if cx < abs(x):\n                    cx += k if x > 0 else -k\n                else:\n                    cy += k if y > 0 else -k\n                print(cx, cy)\n            print(x, y)\n    else:\n        if (abs(x) + abs(y)) % k == 0:\n            print((abs(x) + abs(y)) // k)\n            cx, cy = 0, 0\n            for _ in range((abs(x) + abs(y)) // k - 1):\n                if cx < abs(x):\n                    cx += k if x > 0 else -k\n                else:\n                    cy += k if y > 0 else -k\n                print(cx, cy)\n            print(x, y)\n        else:\n            if abs(x) % k!= 0 and abs(y) % k!= 0:\n                if (k - abs(x) % k) + (k - abs(y) % k) <= k:\n                    print(2)\n                    cx, cy = 0, 0\n                    dx, dy = x, y\n                    if x > 0:\n                        cx += k - abs(x) % k\n                    else:\n                        cx -= k - abs(x) % k\n                    if y > 0:\n                        cy += k - abs(y) % k\n                    else:\n                        cy -= k - abs(y) % k\n                    print(cx, cy)\n                    print(x, y)\n                else:\n                    print(-1)\n            else:\n                if abs(x) % k == 0 and abs(y) % k!= 0:\n                    if (k - abs(y) % k) <= k:\n                        print(2)\n                        cx, cy = 0, 0\n                        dx, dy = x, y\n                        if y > 0:\n                            cy += k - abs(y) % k\n                        else:\n                            cy -= k - abs(y) % k\n                        print(cx, cy)\n                        print(x, y)\n                    else:\n                        print(-1)\n                else:\n                    if abs(x) % k!= 0 and abs(y) % k == 0:\n                        if (k - abs(x) % k) <= k:\n                            print(2)\n                            cx, cy = 0, 0\n                            dx, dy = x, y\n                            if x > 0:\n                                cx += k - abs(x) % k\n                            else:\n                                cx -= k - abs(x) % k\n                            print(cx, cy)\n                            print(x, y)\n                        else:\n                            print(-1)\n                    else:\n                        print(-1)\n\nsolve()"}
{"solution": "import math\n\ndef find_n(m):\n    n = 1\n    while True:\n        count = 0\n        for k in range(2, int(math.sqrt(n)) + 2):\n            a = 1\n            for _ in range(3):\n                a *= k\n                if a > n:\n                    break\n            else:\n                count += 1\n        if count == m:\n            return n\n        if n > m * 100:\n            return -1\n        n += 1\n\nm = int(input())\nprint(find_n(m))"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    if d >= r1 + r2:\n        return 0\n    if d <= abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n    a = (r1 ** 2 - r2 ** 2 + d ** 2) / (2 * d)\n    h = math.sqrt(r1 ** 2 - a ** 2)\n    return r1 ** 2 * math.acos(a / r1) - a * h + r2 ** 2 * math.acos((d - a) / r2) - (d - a) * h\n\nx1, y1, r1 = map(float, input().split())\nx2, y2, r2 = map(float, input().split())\n\nprint(circle_intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "import math\n\ndef solve():\n    n = int(input())\n    if n == 1:\n        print(1)\n    elif n % 2 == 1:\n        print(1)\n    else:\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i!= 0:\n                print(1)\n                return\n        print(2)\n\nsolve()"}
{"solution": "from collections import defaultdict\n\ndef dfs(node, graph, a, dp):\n    if dp[node]!= -1:\n        return dp[node]\n    if not graph[node]:\n        dp[node] = a[node]\n        return dp[node]\n    if len(graph[node]) == 1:\n        dp[node] = dfs(graph[node][0], graph, a, dp)\n        return dp[node]\n    dp[node] = float('inf')\n    for child in graph[node]:\n        dp[node] = min(dp[node], dfs(child, graph, a, dp))\n    return dp[node]\n\ndef solve():\n    n = int(input())\n    graph = defaultdict(list)\n    p = list(map(int, input().split()))\n    for i in range(n-1):\n        graph[p[i]].append(i+2)\n    a = list(map(int, input().split()))\n    dp = [-1]*(n+1)\n    print(dfs(1, graph, a, dp))\n\nsolve()"}
{"solution": "def count_common_words(n, s, t):\n    def get_prefix(s, t):\n        prefix = 0\n        while prefix < n and s[prefix] == t[prefix]:\n            prefix += 1\n        return prefix\n\n    def get_suffix(s, t):\n        suffix = 0\n        while suffix < n and s[n - suffix - 1] == t[n - suffix - 1]:\n            suffix += 1\n        return suffix\n\n    prefix = get_prefix(s, t)\n    suffix = get_suffix(s, t)\n    if prefix + suffix >= n - 1:\n        return 2 if s[prefix] == t[prefix + 1] and s[prefix + 1] == t[prefix] else 1\n    else:\n        return 0\n\nn = int(input())\ns = input()\nt = input()\nprint(count_common_words(n, s, t))"}
{"solution": "import sys\ninput = sys.stdin.readline\n\ndef dfs(u, p):\n    for v in adj[u]:\n        if v!= p:\n            dfs(v, u)\n            dp[u] = max(dp[u], dp[v] + 1)\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    dp = [1] * n\n    dfs(0, -1)\n\n    ans = float('-inf')\n    for i in range(n):\n        ans = max(ans, a[i] + dp[i] - 1)\n\n    print(ans)\n\nsolve()"}
{"solution": "n, m = map(int, input().split())\nprint(min(m, n - m + (m > 0)))"}
{"solution": "import math\n\nk, r = map(int, input().split())\n\ndef min_shovels(k, r):\n    for i in range(1, 11):\n        total = k * i\n        if (total - r) % 10 == 0:\n            return i\n    return 10\n\nprint(min_shovels(k, r))"}
{"solution": "def main():\n    n, m = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and grid[x][y] == 'X'\n\n    def dfs(x, y):\n        if not is_valid(x, y):\n            return\n        grid[x][y] = '.'\n        dfs(x - 1, y)\n        dfs(x + 1, y)\n        dfs(x, y - 1)\n        dfs(x, y + 1)\n\n    def check_rectangle(x, y):\n        for i in range(x, n):\n            for j in range(m):\n                if grid[i][j] == 'X':\n                    return False\n        for i in range(x):\n            if grid[i][y]!= 'X':\n                return False\n        for i in range(y):\n            if grid[x][i]!= 'X':\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                dfs(i, j)\n                if check_rectangle(i, j):\n                    print(\"YES\")\n                    return\n                break\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_segments():\n    points = [tuple(map(int, input().split())) for _ in range(3)]\n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n\n    x_unique = len(set(x_coords))\n    y_unique = len(set(y_coords))\n\n    if x_unique == 1 or y_unique == 1:\n        return 1\n    elif x_unique == 2 and y_unique == 2:\n        return 2\n    else:\n        return 3\n\nprint(min_segments())"}
{"solution": "import sys\n\ndef main():\n    k = int(sys.stdin.readline())\n\n    if k == 1:\n        print(\"YES\")\n        print(\"2 1\")\n        print(\"1 2\")\n        return\n\n    if k == 2:\n        print(\"NO\")\n        return\n\n    n = 2 * k\n    m = k * n // 2\n\n    print(\"YES\")\n    print(n, m)\n\n    for i in range(1, n // 2 + 1):\n        for j in range(1, k):\n            print(i, i + j)\n\n    print(n // 2, n // 2 + 1)\n\n    for i in range(n // 2 + 2, n + 1):\n        for j in range(1, k):\n            print(i, i + j)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef prefix_function(s):\n    n = len(s)\n    p = [0] * n\n    for i in range(1, n):\n        j = p[i - 1]\n        while j > 0 and s[i]!= s[j]:\n            j = p[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        p[i] = j\n    return p\n\ndef kmp(s, t):\n    p = prefix_function(t)\n    n, m = len(s), len(t)\n    j = 0\n    count = 0\n    for i in range(n):\n        while j > 0 and s[i]!= t[j]:\n            j = p[j - 1]\n        if s[i] == t[j]:\n            j += 1\n        if j == m:\n            count += 1\n            j = p[j - 1]\n    return count\n\ndef solve():\n    n, m, q = map(int, sys.stdin.readline().split())\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    p = prefix_function(t)\n    dp = [0] * (n + 1)\n    j = 0\n    for i in range(n):\n        while j > 0 and s[i]!= t[j]:\n            j = p[j - 1]\n        if s[i] == t[j]:\n            j += 1\n        if j == m:\n            dp[i + 1] = dp[i] + 1\n            j = p[j - 1]\n        else:\n            dp[i + 1] = dp[i]\n    for _ in range(q):\n        l, r = map(int, sys.stdin.readline().split())\n        print(dp[r] - dp[l - 1])\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "MOD = 10**9 + 7\n\ndef solve():\n    n, k, d = map(int, input().split())\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            for x in range(1, k + 1):\n                if i - x >= 0:\n                    dp[i][j] = (dp[i][j] + dp[i - x][j - 1]) % MOD\n    ans = sum(dp[n][i] for i in range(d, k + 1)) % MOD\n    print(ans)\n\nsolve()"}
{"solution": "n = int(input())\nrow = input()\n\nblack_groups = []\ncurrent_group = 0\n\nfor square in row:\n    if square == 'B':\n        current_group += 1\n    elif current_group > 0:\n        black_groups.append(current_group)\n        current_group = 0\n\nif current_group > 0:\n    black_groups.append(current_group)\n\nprint(len(black_groups))\nprint(*black_groups)"}
{"solution": "import sys\n\ndef main():\n    n, m, p = map(int, sys.stdin.readline().split())\n    s = sys.stdin.readline().strip()\n    q = sys.stdin.readline().strip()\n\n    st = []\n    for i in range(n):\n        if s[i] == '(':\n            st.append(i)\n        else:\n            st.append(st.pop())\n\n    pos = p - 1\n    for op in q:\n        if op == 'L':\n            pos -= 1\n        elif op == 'R':\n            pos += 1\n        else:\n            if s[pos] == '(':\n                st.remove(pos)\n                pos = st.pop()\n            else:\n                pos = st.pop()\n                st.remove(pos)\n\n            if pos < 0:\n                pos = 0\n            elif pos >= len(st):\n                pos = len(st) - 1\n\n    ans = [''] * n\n    for i in range(len(st)):\n        ans[st[i]] = '(' if i % 2 == 0 else ')'\n\n    print(''.join(ans))\n\nif __name__ == '__main__':\n    main()"}
{"solution": "import sys\n\nn = int(input())\nmin_val = -2 * (10 ** 9)\nmax_val = 2 * (10 ** 9)\n\nfor _ in range(n):\n    sign, x, answer = input().split()\n    x = int(x)\n\n    if sign == \">\":\n        if answer == \"Y\":\n            min_val = max(min_val, x + 1)\n        else:\n            max_val = min(max_val, x)\n    elif sign == \"<\":\n        if answer == \"Y\":\n            max_val = min(max_val, x - 1)\n        else:\n            min_val = max(min_val, x)\n    elif sign == \">=\":\n        if answer == \"Y\":\n            min_val = max(min_val, x)\n        else:\n            max_val = min(max_val, x - 1)\n    elif sign == \"<=\":\n        if answer == \"Y\":\n            max_val = min(max_val, x)\n        else:\n            min_val = max(min_val, x + 1)\n\nif min_val <= max_val:\n    print(min_val)\nelse:\n    print(\"Impossible\")"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_periods(a, b):\n    total = a + b\n    count = 0\n    for i in range(1, total + 1):\n        if total % i == 0:\n            if a % (total // i) == 0 and b % (total // i) == 0:\n                count += 1\n            elif gcd(a, total // i) == gcd(b, total // i) == gcd(a + b, total // i):\n                count += 1\n    return count\n\na, b = map(int, input().split())\nprint(count_periods(a, b))"}
{"solution": "import string\n\ndef generate_name():\n    for i in range(26):\n        for j in range(26):\n            yield f\"{string.ascii_uppercase[i]}{string.ascii_lowercase[j]}\"\n\ndef solve():\n    n, k = map(int, input().split())\n    notes = input().split()\n    names = []\n    gen = generate_name()\n    for i in range(k - 1):\n        names.append(next(gen))\n    for note in notes:\n        if note == \"YES\":\n            names.append(next(gen))\n        else:\n            names.append(names[-k + 1])\n    print(\" \".join(names))\n\nsolve()"}
{"solution": "from math import gcd\nfrom functools import reduce\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef min_operations(a, b):\n    if a == b:\n        return 0\n    if a > b:\n        a, b = b, a\n    if b % a == 0:\n        return -1\n    if gcd(a, b)!= 1:\n        return -1\n    ops = 0\n    while a!= b:\n        if b % 2 == 0:\n            b //= 2\n        elif b % 3 == 0:\n            b *= 2\n            b //= 3\n        elif b % 5 == 0:\n            b *= 4\n            b //= 5\n        else:\n            return -1\n        ops += 1\n    return ops\n\na, b = map(int, input().split())\nprint(min_operations(a, b))"}
{"solution": "n, a, b = map(int, input().split())\nc = list(map(int, input().split()))\n\ncost = 0\nfor i in range(n // 2):\n    if c[i]!= c[n - i - 1]:\n        if c[i] == 2:\n            c[i] = c[n - i - 1]\n        elif c[n - i - 1] == 2:\n            c[n - i - 1] = c[i]\n        elif c[i]!= c[n - i - 1]:\n            print(-1)\n            exit()\n\nfor i in range(n // 2):\n    if c[i] == 2:\n        if c[n - i - 1] == 0:\n            cost += a\n        elif c[n - i - 1] == 1:\n            cost += b\n    elif c[i] == 0 and c[n - i - 1] == 2:\n        cost += a\n    elif c[i] == 1 and c[n - i - 1] == 2:\n        cost += b\n\nif n % 2 == 1 and c[n // 2] == 2:\n    if sum(c[:n // 2]) >= n // 2:\n        cost += b\n    else:\n        cost += a\n\nprint(cost)"}
{"solution": "import sys\n\nk = int(sys.stdin.readline())\n\nif k == 1:\n    print(-1)\nelse:\n    for i in range(k):\n        for j in range(k):\n            for z in range(k):\n                if (i + j + z) % 2 == 0:\n                    print('b', end='')\n                else:\n                    print('w', end='')\n            print()\n        print()"}
{"solution": "import math\n\ndef largest_lovely_number(n):\n    i = 2\n    while i * i <= n:\n        if n % (i * i) == 0:\n            while n % (i * i) == 0:\n                n //= i * i\n        i += 1\n    return n\n\nn = int(input())\nprint(largest_lovely_number(n))"}
{"solution": "n = int(input())\nseating = input()\n\ndef is_maximal(seating):\n    seating += '0'\n    for i in range(len(seating) - 1):\n        if seating[i] == '1' and seating[i+1] == '1':\n            return False\n    for i in range(1, len(seating) - 1):\n        if seating[i] == '0' and seating[i-1] == '0' and seating[i+1] == '0':\n            return False\n    return True\n\nprint(\"Yes\" if is_maximal(seating) else \"No\")"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn = int(input())\na = list(map(int, input().split()))\n\ndiffs = [a[i] - a[i - 1] for i in range(1, n)]\ng = diffs[0]\nfor d in diffs:\n    g = gcd(g, d)\n\npossible_k = set()\nfor i in range(1, n + 1):\n    if n % i == 0 and g % i == 0:\n        possible_k.add(i)\n\nvalid_k = []\nfor k in possible_k:\n    x = [a[i] - a[i - 1] for i in range(1, k + 1)]\n    valid = True\n    for i in range(k, n):\n        if a[i] - a[i - 1]!= x[(i - 1) % k]:\n            valid = False\n            break\n    if valid:\n        valid_k.append(k)\n\nprint(len(valid_k))\nprint(*sorted(valid_k))"}
{"solution": "import itertools\n\ndef can_form_equal_teams(scores):\n    total_sum = sum(scores)\n    if total_sum % 2!= 0:\n        return False\n\n    target_sum = total_sum // 2\n    for combination in itertools.combinations(scores, 3):\n        if sum(combination) == target_sum:\n            return True\n\n    return False\n\nscores = list(map(int, input().split()))\nprint(\"YES\" if can_form_equal_teams(scores) else \"NO\")"}
{"solution": "import sys\n\ndef count_2_3_integers(left, right):\n    count = 0\n    for x in range(31):\n        for y in range(20):\n            num = (1 << x) * (3 ** y)\n            if left <= num <= right:\n                count += 1\n    return count\n\nleft, right = map(int, sys.stdin.readline().split())\nprint(count_2_3_integers(left, right))"}
{"solution": "import math\n\nn, k = map(int, input().split())\n\ndef solve(n, k):\n    if n == 1:\n        return 0\n    if k == 0:\n        return n - 1\n\n    x = (1 + math.sqrt(1 + 8 * (k + n - 1))) / 2\n    x = math.floor(x)\n\n    total = (x * (x + 1)) // 2\n    return n - x + total - k\n\nprint(solve(n, k))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\nfor i in range(n - 2):\n    if a[i] + a[i + 1] > a[i + 2]:\n        print(\"YES\")\n        sys.exit()\n\nprint(\"NO\")"}
{"solution": "x, y = map(int, input().split())\n\nif y == 1 and x > 0:\n    print(\"No\")\nelif y - 1 > x:\n    print(\"No\")\nelse:\n    print(\"Yes\" if (x - (y - 1)) % 2 == 0 else \"No\")"}
{"solution": "import sys\n\nn, k = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\n\nskills = {}\nfor i in range(n):\n    if a[i] % 10!= 0:\n        skills[a[i]] = skills.get(a[i], 0) + 1\n\nsorted_skills = sorted(skills.items())\n\ntotal_rating = sum(a) // 10\nremaining_k = k\n\nfor skill, count in sorted_skills:\n    required = 10 - (skill % 10)\n    if required <= remaining_k:\n        total_rating += count\n        remaining_k -= required * count\n    else:\n        total_rating += remaining_k // 10\n        break\n\nprint(total_rating)"}
{"solution": "n, m = map(int, input().split())\na = sorted(map(int, input().split()))\nb = sorted(map(int, input().split()))\n\ncommon = set(a) & set(b)\nif common:\n    print(min(common))\nelse:\n    min_a = min(a)\n    min_b = min(b)\n    print(min_a * 10 + min_b if min_a < min_b else min_b * 10 + min_a)"}
{"solution": "n, k = map(int, input().split())\ntotal_time = 240 - k\nproblems_solved = 0\ntime_spent = 0\n\nfor i in range(1, n + 1):\n    time_required = 5 * i\n    if time_spent + time_required <= total_time:\n        time_spent += time_required\n        problems_solved += 1\n    else:\n        break\n\nprint(problems_solved)"}
{"solution": "import sys\n\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\ndef check(k):\n    need = sum((a[i] + 1) // 2 for i in range(k))\n    return need <= x + y\n\nl, r = 0, n\nwhile l < r:\n    mid = (l + r + 1) // 2\n    if check(mid):\n        l = mid\n    else:\n        r = mid - 1\n\nprint(l)"}
{"solution": "import math\n\ndef count_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return divisors\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef main():\n    b = int(input())\n    divisors = count_divisors(b)\n    result = 0\n    for d in divisors:\n        result += 1\n        for p in range(2, int(math.sqrt(b)) + 1):\n            if b % p == 0:\n                if d * p > b and gcd(d, p) == 1:\n                    result += 1\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\ns = input()\n\ndef simulate(start):\n    while 0 <= start < n:\n        if s[start] == '<':\n            start -= 1\n        else:\n            start += 1\n        if start < 0 or start >= n:\n            return True\n    return False\n\ndef solve():\n    left = [0] * n\n    right = [0] * n\n    for i in range(1, n):\n        left[i] = left[i - 1] + (s[i - 1] == '<')\n    for i in range(n - 2, -1, -1):\n        right[i] = right[i + 1] + (s[i + 1] == '>')\n    count = 0\n    for i in range(n):\n        if left[i] == right[i]:\n            count += 1\n    return count\n\nprint(solve())"}
{"solution": "import sys\n\nn = int(input())\nl = list(map(int, input().split()))\n\nl.sort()\n\ncount = {}\nfor i in l:\n    if i in count:\n        count[i] += 1\n    else:\n        count[i] = 1\n\ndp = [0] * (max(l) + 2)\nfor i in count:\n    dp[i] = max(dp[i], count[i] // 2 * i * i)\n    dp[i + 1] = max(dp[i + 1], dp[i - 1] + (count[i] // 2) * i * (i - 1))\n\nprint(dp[-1])"}
{"solution": "from collections import defaultdict\n\nn = int(input())\ns = [input() for _ in range(n)]\n\ncnt = defaultdict(int)\nfor si in s:\n    for c in si:\n        cnt[c] += 1\n\nt = sorted(cnt.items(), key=lambda x: x[1], reverse=True)\nd = {t[i][0]: str(9 - i) for i in range(len(t))}\n\nans = 0\nfor si in s:\n    tmp = ''\n    for c in si:\n        tmp += d[c]\n    ans += int(tmp)\n\nprint(ans)"}
{"solution": "n, m = map(int, input().split())\n\na = min(n, m // 2)\nm -= a * 2\nn -= a\n\nb = min(m, n // 2)\n\nprint(a + b)"}
{"solution": "def solve(s):\n    ab = s.find(\"AB\")\n    ba = s.find(\"BA\")\n    if ab!= -1 and ba!= -1:\n        if ab > ba:\n            return \"YES\" if ab + 1 > ba + 1 else \"NO\"\n        else:\n            return \"YES\" if ab + 1 < ba else \"NO\"\n    return \"NO\"\n\ns = input()\nprint(solve(s))"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    k = int(input())\n    b = list(map(int, input().split()))\n\n    if sum(a)!= sum(b):\n        print(\"NO\")\n        return\n\n    ans = []\n    i = 0\n    j = 0\n    while i < n and j < k:\n        if a[i] == b[j]:\n            i += 1\n            j += 1\n        else:\n            if i + 1 < n and a[i] + a[i + 1] == b[j]:\n                ans.append((i + 2, 'L'))\n                a[i] += a[i + 1]\n                a.pop(i + 1)\n            elif j + 1 < k and a[i] == b[j + 1]:\n                ans.append((i + 1, 'R'))\n                a[i] += b[j]\n                b.pop(j)\n            else:\n                print(\"NO\")\n                return\n\n    print(\"YES\")\n    for x, y in ans:\n        print(x, y)\n\nsolve()"}
{"solution": "def orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # Collinear\n    elif val > 0:\n        return 1  # Clockwise\n    else:\n        return 2  # Counterclockwise\n\ndef intersect(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if (o1!= o2 and o3!= o4):\n        return True\n\n    if (o1 == 0 and on_segment(p1, p2, q1)):\n        return True\n\n    if (o2 == 0 and on_segment(p1, q2, q1)):\n        return True\n\n    if (o3 == 0 and on_segment(p2, p1, q2)):\n        return True\n\n    if (o4 == 0 and on_segment(p2, q1, q2)):\n        return True\n\n    return False\n\ndef on_segment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n            q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\ndef is_valid(edges, n):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if intersect(edges[i][0], edges[i][1], edges[j][0], edges[j][1]):\n                return False\n    return True\n\nR, B = map(int, input().split())\nspaceships = []\nbases = []\nfor _ in range(R):\n    x, y = map(int, input().split())\n    spaceships.append((x, y))\nfor _ in range(B):\n    x, y = map(int, input().split())\n    bases.append((x, y))\n\nif R!= B:\n    print(\"No\")\nelse:\n    edges = list(zip(spaceships, bases))\n    if is_valid(edges, R):\n        print(\"Yes\")\n    else:\n        print(\"No\")"}
{"solution": "import math\n\nn = int(input())\na = list(map(int, input().split()))\n\ndef max_power_of_two(x):\n    return 2 ** math.floor(math.log2(x))\n\nmax_power = max(map(max_power_of_two, a))\ncount = sum(1 for x in a if x % max_power == 0)\n\nprint(max_power, count)"}
{"solution": "def min_clicks(n, m):\n    clicks = 0\n    while m > n:\n        if m % 2 == 0:\n            m //= 2\n        else:\n            m += 1\n        clicks += 1\n    return clicks + (n - m)\n\nn, m = map(int, input().split())\nprint(min_clicks(n, m))"}
{"solution": "import sys\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x]!= x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x!= root_y:\n            if self.rank[root_x] > self.rank[root_y]:\n                self.parent[root_y] = root_x\n            elif self.rank[root_x] < self.rank[root_y]:\n                self.parent[root_x] = root_y\n            else:\n                self.parent[root_y] = root_x\n                self.rank[root_x] += 1\n\ndef solve():\n    n = int(sys.stdin.readline())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, sys.stdin.readline().split())\n        segments.append((l, r))\n\n    dsu = DSU(n)\n    events = []\n    for i, (l, r) in enumerate(segments):\n        events.append((l, 0, i))\n        events.append((r, 1, i))\n    events.sort()\n\n    active = set()\n    for _, type, i in events:\n        if type == 0:\n            for j in active:\n                if not (segments[j][0] >= segments[i][0] and segments[j][1] <= segments[i][1] or\n                        segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]):\n                    dsu.union(i, j)\n            active.add(i)\n        else:\n            active.remove(i)\n\n    roots = set()\n    for i in range(n):\n        roots.add(dsu.find(i))\n\n    print(\"YES\" if len(roots) == 1 else \"NO\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import sys\n\ndef solve():\n    n = int(input())\n    r = list(map(int, input().split()))\n\n    max_len = 0\n    for i in range(n):\n        total = 0\n        for j in range(i, n):\n            total += r[j]\n            if total > 100 * (j - i + 1):\n                max_len = max(max_len, j - i + 1)\n\n    print(max_len)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def check_dissatisfaction(n, k, episodes):\n    max_dissatisfaction = 0\n    current_dissatisfaction = 0\n\n    for episode in episodes:\n        if episode == 'N':\n            current_dissatisfaction += 1\n            max_dissatisfaction = max(max_dissatisfaction, current_dissatisfaction)\n        else:\n            current_dissatisfaction = 0\n\n    if max_dissatisfaction > k:\n        return \"NO\"\n\n    if max_dissatisfaction < k:\n        for i in range(n - k + 1):\n            if episodes[i] == 'Y' or episodes[i + k] == 'Y':\n                continue\n            if all(episodes[j] == '?' for j in range(i, i + k)):\n                return \"YES\"\n\n    return \"NO\" if max_dissatisfaction < k else \"YES\"\n\n\nn, k = map(int, input().split())\nepisodes = input()\n\nprint(check_dissatisfaction(n, k, episodes))"}
{"solution": "import sys\n\ndef main():\n    n, x, d = map(int, sys.stdin.readline().split())\n    if d == 0:\n        print(1 if n % 2 == 0 else 2)\n        return\n\n    max_sum = (2 * x + (n - 1) * d) * n // 2\n    min_sum = 0\n    if n % 2 == 1:\n        min_sum = (2 * x + (n - 1) * d) // 2\n\n    print(max_sum - min_sum + 1)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def get_color(rating):\n    if rating >= 2400:\n        return \"red\"\n    elif rating >= 2200:\n        return \"orange\"\n    elif rating >= 2000:\n        return \"blue\"\n    elif rating >= 1800:\n        return \"violet\"\n    elif rating >= 1500:\n        return \"indigo\"\n    else:\n        return \"gray\"\n\nn = int(input())\nres = \"NO\"\n\nfor _ in range(n):\n    name, before, after = input().split()\n    before, after = int(before), int(after)\n    if get_color(before) == \"red\" and after > before:\n        res = \"YES\"\n        break\n\nprint(res)"}
{"solution": "def count_missed_trains(s):\n    count = 0\n    i = 0\n    while i < len(s):\n        if s[i] == '1':\n            count += 1\n            i += 2\n        else:\n            i += 1\n    return count\n\ns = input()\nprint(count_missed_trains(s))"}
{"solution": "def min_rows(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n    rows = n\n\n    for i in range(n // 2):\n        if matrix[i] == matrix[n - i - 1]:\n            rows -= 1\n        else:\n            break\n\n    return rows\n\n\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\nprint(min_rows(matrix))"}
{"solution": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    orders = []\n    for _ in range(n):\n        l, r = map(int, sys.stdin.readline().split())\n        orders.append((l, r))\n\n    orders.sort(key=lambda x: x[1])\n    end_time = -1\n    count = 0\n    for l, r in orders:\n        if l > end_time:\n            count += 1\n            end_time = r\n\n    print(count)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def solve():\n    n, k = map(int, input().split())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n\n    x_prev, y_prev = 0, 0\n    for i in range(n):\n        x_prev, y_prev = x[i] + x_prev, y[i] + y_prev\n        if x_prev > k * (i + 1) or y_prev > k * (i + 1):\n            print(\"NO\")\n            return\n        if x[i] > k or y[i] > k:\n            print(\"NO\")\n            return\n        if x_prev + k < x[i + 1] if i < n - 1 else False:\n            print(\"NO\")\n            return\n        if y_prev + k < y[i + 1] if i < n - 1 else False:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def main():\n    n, k = map(int, input().split())\n    a = [input().strip() for _ in range(n + 1)]\n\n    p = 0\n    for i in range(n + 1):\n        if a[i] == '?':\n            p += k ** i\n        else:\n            p += int(a[i]) * (k ** i)\n\n    if p % (k ** (n + 1)) == 0:\n        print(\"Yes\")\n    else:\n        if (n + 1) % 2 == 0:\n            print(\"No\")\n        else:\n            print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef smallest_multiple(p, x):\n    return (x + p - 1) // p * p\n\ndef smallest_start(x):\n    min_start = x\n    for p in range(2, x):\n        if x % p == 0:\n            x1 = smallest_multiple(p, x - 1)\n            if x1 < x:\n                for q in range(2, x1):\n                    if is_prime(q):\n                        x0 = smallest_multiple(q, x1 - 1)\n                        if x0 < x1:\n                            min_start = min(min_start, x0)\n    return min_start\n\nx2 = int(input())\nprint(smallest_start(x2))"}
{"solution": "def solve(n, p):\n    for i in range(1, n + 1):\n        if bin((n - i * p)).count('1') <= i:\n            return i\n    return -1\n\nn, p = map(int, input().split())\nprint(solve(n, p))"}
{"solution": "n, k = map(int, input().split())\ns = input()\n\nif k == 0:\n    print(s)\nelse:\n    s = list(s)\n    if s[0]!= '1':\n        s[0] = '1'\n        k -= 1\n    for i in range(1, n):\n        if k > 0 and s[i]!= '0':\n            s[i] = '0'\n            k -= 1\n    print(''.join(s))"}
{"solution": "def min_presents(cnt_1, cnt_2, x, y):\n    def count_multiples(n, x, y):\n        return n // x + n // y - n // (x * y)\n\n    def count_valid(n, x, y):\n        return n - count_multiples(n, x, y)\n\n    def count_valid_xy(n, x, y):\n        return n // (x * y)\n\n    def check(v):\n        valid_x = count_valid(v, x, y)\n        valid_y = count_valid(v, y, x)\n        valid_xy = count_valid_xy(v, x, y)\n        return valid_x >= cnt_1 and valid_y >= cnt_2\n\n    left, right = 1, cnt_1 + cnt_2 + 1\n    while left < right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ncnt_1, cnt_2, x, y = map(int, input().split())\nprint(min_presents(cnt_1, cnt_2, x, y))"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip().split()\n\ndef main():\n    n, sx, sy, dx, dy, t = map(int, read_input())\n\n    x, y = sx, sy\n    for _ in range(min(t, 2 * n + 2)):\n        k = x + y + _\n        dx += k\n        dy += k\n        x = ((x + dx - 1) % n) + 1\n        y = ((y + dy - 1) % n) + 1\n\n    if t > 2 * n + 2:\n        period = 2 * n + 2\n        t %= period\n        x, y = sx, sy\n        dx, dy = dx, dy\n        for _ in range(t):\n            k = x + y + _\n            dx += k\n            dy += k\n            x = ((x + dx - 1) % n) + 1\n            y = ((y + dy - 1) % n) + 1\n\n    print(x, y)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from string import ascii_uppercase\n\ndef solve(s):\n    n = len(s)\n    if n < 26:\n        return -1\n\n    s = list(s)\n    for i in range(n):\n        if s[i]!= '?':\n            continue\n        for c in ascii_uppercase:\n            if c not in s[max(0, i-25):i]:\n                s[i] = c\n                break\n\n    for i in range(n-25):\n        if len(set(s[i:i+26])) == 26:\n            return ''.join(s)\n\n    return -1\n\ns = input()\nprint(solve(s))"}
{"solution": "n = int(input())\nweights = list(map(int, input().split()))\n\ntotal_weight = sum(weights)\nif total_weight % 2!= 0:\n    print(\"NO\")\nelse:\n    target_weight = total_weight // 2\n    weights.sort(reverse=True)\n    first_person_weight = 0\n    for weight in weights:\n        if first_person_weight + weight <= target_weight:\n            first_person_weight += weight\n        else:\n            break\n    print(\"YES\" if first_person_weight == target_weight else \"NO\")"}
{"solution": "import sys\n\ndef min_time_to_turn_off_lights(n, m, building):\n    total_time = 0\n    for i in range(n):\n        floor = building[i]\n        left_index = -1\n        right_index = -1\n        for j in range(1, m + 1):\n            if floor[j] == '1':\n                if left_index == -1:\n                    left_index = j\n                right_index = j\n        if left_index!= -1:\n            if i > 0:\n                total_time += 1\n            total_time += min(left_index, m + 1 - right_index) + (right_index - left_index)\n            if right_index == m:\n                total_time += 1\n    return total_time\n\nn, m = map(int, sys.stdin.readline().split())\nbuilding = [sys.stdin.readline().strip() for _ in range(n)]\n\nprint(min_time_to_turn_off_lights(n, m, building))"}
{"solution": "from collections import defaultdict, deque\n\ndef dfs(node, graph, cost, visited, dp):\n    if visited[node]:\n        return dp[node]\n    visited[node] = True\n    if graph[node] == node:\n        dp[node] = cost[node]\n        return dp[node]\n    if dp[graph[node]]!= -1:\n        dp[node] = cost[node] + dp[graph[node]]\n        return dp[node]\n    dp[node] = dfs(graph[node], graph, cost, visited, dp)\n    if dp[node] < cost[node] + dp[graph[node]]:\n        dp[node] = cost[node] + dp[graph[node]]\n    return dp[node]\n\ndef solve():\n    n = int(input())\n    cost = list(map(int, input().split()))\n    graph = list(map(int, input().split()))\n    for i in range(n):\n        graph[i] -= 1\n    visited = [False] * n\n    dp = [-1] * n\n    ans = float('inf')\n    for i in range(n):\n        if not visited[i]:\n            ans = min(ans, dfs(i, graph, cost, visited, dp))\n    print(ans)\n\nsolve()"}
{"solution": "n, a, b = map(int, input().split())\nprint((a + b - 1) % n + 1)"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    ans = 1\n    i = 0\n    while i < n:\n        if a[i] == -1:\n            i += 1\n            continue\n        j = i + 1\n        while j < n and a[j]!= -1:\n            j += 1\n        if j == n:\n            break\n        if j - i == 1:\n            i = j\n            continue\n        d = a[i + 1] - a[i]\n        k = i + 2\n        while k < j and a[k] - a[k - 1] == d:\n            k += 1\n        if k == j:\n            i = j\n            continue\n        if a[k] == -1:\n            l = k + 1\n            while l < j and a[l] == -1:\n                l += 1\n            if l == j:\n                i = j\n                continue\n            if a[l] - a[k - 1] == d:\n                i = l\n                continue\n        ans += 1\n        i = j\n    print(ans)\n\nsolve()"}
{"solution": "def max_beauty(n, k, s):\n    def max_beauty_with_char(c):\n        left = 0\n        beauty = 0\n        changes = 0\n        for right in range(n):\n            if s[right]!= c:\n                changes += 1\n            while changes > k:\n                if s[left]!= c:\n                    changes -= 1\n                left += 1\n            beauty = max(beauty, right - left + 1)\n        return beauty\n\n    return max(max_beauty_with_char('a'), max_beauty_with_char('b'))\n\nn, k = map(int, input().split())\ns = input()\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, a):\n    total_seats = sum(a)\n    alice_seats = a[0]\n    required_seats = (total_seats + 1) // 2\n\n    if alice_seats >= required_seats:\n        return [1]\n\n    coalition = [1]\n    a = [(seats, i + 1) for i, seats in enumerate(a[1:])]\n    a.sort()\n\n    for seats, party in a:\n        if alice_seats >= 2 * seats:\n            coalition.append(party)\n            alice_seats += seats\n            if alice_seats >= required_seats:\n                return coalition\n\n    return []\n\nn = int(input())\na = list(map(int, input().split()))\n\ncoalition = find_coalition(n, a)\n\nif coalition:\n    print(len(coalition))\n    print(*coalition)\nelse:\n    print(0)"}
{"solution": "import sys\n\nn = int(sys.stdin.readline())\ntotal = 0\nwhile n > 0:\n    total += n / (n + 1) if n > 1 else 1\n    n -= 1\nprint(f\"{total:.15f}\")"}
{"solution": "import math\n\nn = int(input())\nk = int(math.sqrt(2 * n))\n\nwhile (k * (k + 1)) // 2 > n:\n    k -= 1\n\nprint(k)\nfor i in range(1, k + 1):\n    print(i, end=\" \")\nprint(n - (k * (k + 1)) // 2 + k)"}
{"solution": "n = int(input())\nm = int(input())\nprint(m % (1 << n))"}
{"solution": "n = int(input())\ns = input()\nvowels = 'aeiouy'\n\nwhile True:\n    corrected = False\n    for i in range(len(s) - 1):\n        if s[i] in vowels and s[i + 1] in vowels:\n            s = s[:i] + s[i + 1:]\n            corrected = True\n            break\n    if not corrected:\n        break\n\nprint(s)"}
{"solution": "import sys\n\nn, a, b = map(int, input().split())\ns = input()\n\nempty = []\ncurr = 0\nfor i in range(n):\n    if s[i] == '*':\n        if curr > 0:\n            empty.append(curr)\n        curr = 0\n    else:\n        curr += 1\nif curr > 0:\n    empty.append(curr)\n\nans = 0\nfor x in empty:\n    if x % 2 == 0:\n        ans += min(x // 2, a, b)\n        a -= min(x // 2, a, b)\n        b -= min(x // 2, a, b)\n    else:\n        ans += min(x // 2, a, b)\n        a -= min(x // 2, a, b)\n        b -= min(x // 2, a, b)\n        if a > 0:\n            ans += 1\n            a -= 1\n        elif b > 0:\n            ans += 1\n            b -= 1\n\nprint(ans)"}
{"solution": "import math\n\ndef solve():\n    r = int(input())\n    for x in range(1, int(math.sqrt(r)) + 1):\n        discriminant = 4 * x**2 - 4 * (r - x**2 - x - 1)\n        if discriminant >= 0:\n            y = (2 * x + math.sqrt(discriminant)) / 2\n            if y == int(y) and y > 0:\n                print(x, int(y))\n                return\n    print(\"NO\")\n\nsolve()"}
{"solution": "def divide_balloons(n, packets):\n    total = sum(packets)\n    if n == 1 or total % 2 == 0 and len(set(packets)) == 1:\n        return -1\n\n    packets = sorted(enumerate(packets), key=lambda x: x[1])\n    grigory_sum = 0\n    andrew_sum = total\n    grigory_packets = []\n\n    for i, packet in packets:\n        if grigory_sum < andrew_sum:\n            grigory_sum += packet\n            andrew_sum -= packet\n            grigory_packets.append(i + 1)\n\n    return len(grigory_packets), grigory_packets\n\n\nn = int(input())\npackets = list(map(int, input().split()))\n\nresult = divide_balloons(n, packets)\nif result == -1:\n    print(-1)\nelse:\n    print(result[0])\n    print(*result[1])"}
{"solution": "import sys\n\nn = int(input())\n\nfor i in range(9, 0, -1):\n    count = n // i\n    if count > 0:\n        print(count)\n        print(*([i] * count))\n        sys.exit(0)"}
{"solution": "import sys\n\ndef sieve_of_eratosthenes(n):\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n    p = 2\n    while p * p <= n:\n        if primes[p]:\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n    return primes\n\ndef is_prime(n, primes):\n    return primes[n]\n\ndef find_simple_subset(a, primes):\n    a.sort()\n    n = len(a)\n    max_size = 0\n    max_subset = []\n    for i in range(n):\n        subset = [a[i]]\n        for j in range(i + 1, n):\n            if is_prime(a[i] + a[j], primes):\n                subset.append(a[j])\n        if len(subset) > max_size:\n            max_size = len(subset)\n            max_subset = subset\n    return max_size, max_subset\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    primes = sieve_of_eratosthenes(2 * 10**6)\n    max_size, max_subset = find_simple_subset(a, primes)\n    print(max_size)\n    print(*max_subset)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef is_beautiful(n):\n    binary = bin(n)[2:]\n    k = 0\n    while k < len(binary) and binary[k] == '1':\n        k += 1\n    if k == 0:\n        return False\n    while k < len(binary) and binary[k] == '0':\n        k += 1\n    return k == len(binary)\n\ndef greatest_beautiful_divisor(n):\n    for i in range(int(math.sqrt(n)), 0, -1):\n        if n % i == 0:\n            if is_beautiful(i):\n                return i\n            if is_beautiful(n // i):\n                return n // i\n    return 1\n\nn = int(input())\nprint(greatest_beautiful_divisor(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(m, d, a, b):\n    def dp(i, rem, tight, even):\n        if i == -1:\n            return rem == 0\n        if (i, rem, tight, even) in memo:\n            return memo[(i, rem, tight, even)]\n        ans = 0\n        ub = int(b[i]) if tight else 9\n        for digit in range(ub + 1):\n            if even and digit!= d:\n                continue\n            if not even and digit == d:\n                continue\n            new_rem = (rem * 10 + digit) % m\n            new_tight = tight and digit == ub\n            new_even = not even\n            ans += dp(i - 1, new_rem, new_tight, new_even)\n            ans %= MOD\n        memo[(i, rem, tight, even)] = ans\n        return ans\n\n    memo = {}\n    ans = dp(len(b) - 1, 0, True, True)\n    memo = {}\n    ans -= dp(len(a) - 1, 0, True, True)\n    ans %= MOD\n    return ans\n\nm, d = map(int, input().split())\na = input()\nb = input()\nprint(solve(m, d, a, b))"}
{"solution": "import sys\n\nn, m = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\n\ni = 0\nwhile True:\n    a[i] -= m\n    if a[i] <= 0:\n        a.pop(i)\n        if not a:\n            print(i + 1)\n            break\n    else:\n        a.append(a.pop(i))"}
{"solution": "n = int(input())\nbills = [100, 20, 10, 5, 1]\ncount = 0\n\nfor bill in bills:\n    count += n // bill\n    n %= bill\n\nprint(count)"}
{"solution": "MOD = 1000000007\n\ndef solve(n, k):\n    if k > n or (n - k) % 2 == 1:\n        return 0\n\n    dp = [[[0 for _ in range(k + 1)] for _ in range(n + 1)] for _ in range(2)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(min(i, k) + 1):\n            dp[i % 2][i][j] = dp[(i - 1) % 2][i - 1][j]\n            if j > 0:\n                dp[i % 2][i][j] += dp[(i - 1) % 2][i - 1][j - 1]\n            if j > 0 and i > 1:\n                dp[i % 2][i][j] += dp[(i - 1) % 2][i - 2][j - 1]\n            dp[i % 2][i][j] %= MOD\n\n    res = 0\n    for i in range(k, -1, -2):\n        res += dp[n % 2][n][i] * dp[n % 2][n - i][0]\n        res %= MOD\n\n    return res\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_int_list():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n, k = read_ints()\n    b = read_int_list()\n    c = read_input()\n\n    red = []\n    white = []\n    orange = []\n\n    for i in range(n):\n        if c[i] == 'R':\n            red.append(b[i])\n        elif c[i] == 'W':\n            white.append(b[i])\n        else:\n            orange.append(b[i])\n\n    red.sort(reverse=True)\n    white.sort(reverse=True)\n    orange.sort(reverse=True)\n\n    def get_max_beauty(red, white, k):\n        max_beauty = 0\n        for i in range(1, k):\n            if i >= len(red) or k - i >= len(white):\n                continue\n            max_beauty = max(max_beauty, sum(red[:i]) + sum(white[:k - i]))\n        return max_beauty\n\n    max_beauty = -1\n    if len(red) > 0 and len(orange) > 0:\n        max_beauty = max(max_beauty, get_max_beauty(red, orange, k))\n    if len(white) > 0 and len(orange) > 0:\n        max_beauty = max(max_beauty, get_max_beauty(white, orange, k))\n\n    print(max_beauty)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef simplify(p, q):\n    g = gcd(p, q)\n    return p // g, q // g\n\ndef evaluate_continued_fraction(a):\n    p, q = a[-1], 1\n    for i in range(len(a) - 2, -1, -1):\n        p, q = a[i] * p + q, p\n    return p, q\n\np, q = map(int, input().split())\nn = int(input())\na = list(map(int, input().split()))\n\np1, q1 = evaluate_continued_fraction(a)\np1, q1 = simplify(p1, q1)\np, q = simplify(p, q)\n\nprint(\"YES\" if (p, q) == (p1, q1) else \"NO\")"}
{"solution": "def solve():\n    s = input()\n    a, b, c = s.split('+')[0], s.split('=')[0].split('+')[1], s.split('=')[1]\n    a, b, c = a.count('|'), b.count('|'), c.count('|')\n    if a + b == c:\n        return s\n    for i in range(len(s)):\n        if s[i] == '|':\n            t = list(s)\n            t[i] = '.'\n            temp = ''.join(t)\n            for j in range(len(temp)):\n                if temp[j] == '.':\n                    t[j] = '|'\n                    temp2 = ''.join(t)\n                    a2, b2, c2 = temp2.split('+')[0].count('|'), temp2.split('=')[0].split('+')[1].count('|'), temp2.split('=')[1].count('|')\n                    if a2 + b2 == c2:\n                        return temp2\n                    t[j] = '.'\n    return \"Impossible\"\n\nprint(solve())"}
{"solution": "MOD = 10**9 + 7\n\ndef main():\n    n, k = map(int, input().split())\n    dp = [[0] * (n * n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i * i + 1):\n            for d in range(i + 1):\n                if j - d >= 0:\n                    dp[i][j] += dp[i - 1][j - d] * (i - d)\n                    dp[i][j] %= MOD\n\n    print(dp[n][k])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": ""}
{"solution": "import re\n\nn = int(input())\ns = input()\n\nprint(re.sub('o(go)+', '***', s))"}
{"solution": "def prime_factors(n):\n    i = 2\n    factors = {}\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors[i] = factors.get(i, 0) + 1\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef g(y, p):\n    k = 0\n    while y % p == 0:\n        y //= p\n        k += 1\n    return p ** k\n\ndef f(x, y):\n    factors = prime_factors(x)\n    result = 1\n    for p in factors:\n        result = (result * g(y, p)) % (10**9 + 7)\n    return result\n\ndef main():\n    x, n = map(int, input().split())\n    factors = prime_factors(x)\n    result = 1\n    for p in factors:\n        k = factors[p]\n        sum_p_k = (p ** k * (n // (p ** k) * (p - 1) + (n % (p ** k) - 1) // (p - 1))) % (10**9 + 7)\n        result = (result * sum_p_k) % (10**9 + 7)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve(a, b, c):\n    solutions = set()\n    for x in range(1, 10**9):\n        if x == b * (sum_of_digits(x) ** a) + c:\n            solutions.add(x)\n    return sorted(list(solutions))\n\na, b, c = map(int, input().split())\nsolutions = solve(a, b, c)\nprint(len(solutions))\nprint(*solutions)"}
{"solution": "def is_solved(cube):\n    for i in range(0, 24, 4):\n        if len(set(cube[i:i+4]))!= 1:\n            return False\n    return True\n\ndef rotate_face(cube, face):\n    faces = {\n        0: [0, 1, 2, 3],\n        1: [4, 5, 6, 7],\n        2: [8, 9, 10, 11],\n        3: [12, 13, 14, 15],\n        4: [16, 17, 18, 19],\n        5: [20, 21, 22, 23]\n    }\n    face = faces[face]\n    cube[face[0]], cube[face[1]], cube[face[2]], cube[face[3]] = cube[face[3]], cube[face[0]], cube[face[1]], cube[face[2]]\n    return cube\n\ndef is_solvable(cube):\n    for i in range(6):\n        if is_solved(rotate_face(cube[:], i)):\n            return True\n    return False\n\ncube = list(map(int, input().split()))\nprint(\"YES\" if is_solvable(cube) else \"NO\")"}
{"solution": "def get_score(s):\n    i = (s // 50) % 475\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        yield 26 + i\n\ndef solve():\n    p, x, y = map(int, input().split())\n    best = float('inf')\n    for s in range(x, y - 1, -1):\n        if s % 50 == 0:\n            continue\n        if p + 1 in get_score(s):\n            best = min(best, (s - x + 99) // 100)\n    for s in range(y, y + 2500):\n        if p + 1 in get_score(s):\n            best = min(best, (s - x + 99) // 100)\n    print(best)\n\nsolve()"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nif n == 1:\n    print(0)\nelse:\n    print(min((n-1)*a + (n-2)*c, (n-1)*b + (n-2)*c, (n-1)*c + (n-2)*a, (n-1)*c + (n-2)*b))"}
{"solution": "x1, x2, x3 = map(int, input().split())\nprint(sum(abs(x - sorted([x1, x2, x3])[1]) for x in [x1, x2, x3]))"}
{"solution": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    s = set()\n    for i in range(n):\n        a[i] &= x\n        s.add(a[i])\n\n    if len(s) < n:\n        print(0)\n        return\n\n    s = set()\n    for i in range(n):\n        if a[i] in s:\n            print(1)\n            return\n        s.add(a[i] & -a[i])\n\n    print(-1)\n\nsolve()"}
{"solution": "def check_plus_shape(grid):\n    h, w = len(grid), len(grid[0])\n    center = None\n\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*':\n                if center is None:\n                    center = (i, j)\n                else:\n                    return False\n\n    if center is None:\n        return False\n\n    ci, cj = center\n    left, right, up, down = False, False, False, False\n\n    for i in range(ci, -1, -1):\n        if grid[i][cj] == '*':\n            up = True\n        else:\n            break\n\n    for i in range(ci, h):\n        if grid[i][cj] == '*':\n            down = True\n        else:\n            break\n\n    for j in range(cj, -1, -1):\n        if grid[ci][j] == '*':\n            left = True\n        else:\n            break\n\n    for j in range(cj, w):\n        if grid[ci][j] == '*':\n            right = True\n        else:\n            break\n\n    if not (left and right and up and down):\n        return False\n\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*':\n                if (i == ci and cj - left + 1 <= j <= cj + right - 1) or \\\n                   (j == cj and ci - up + 1 <= i <= ci + down - 1):\n                    continue\n                else:\n                    return False\n\n    return True\n\n\nh, w = map(int, input().split())\ngrid = [input() for _ in range(h)]\n\nif check_plus_shape(grid):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef main():\n    n, a, b = map(int, sys.stdin.readline().split())\n\n    if a == 1 and b == 1:\n        print(\"NO\")\n        return\n\n    if a == 1:\n        print(\"YES\")\n        for i in range(n):\n            for j in range(n):\n                if i!= j:\n                    print(1, end='')\n                else:\n                    print(0, end='')\n            print()\n        return\n\n    if b == 1:\n        print(\"YES\")\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    print(0, end='')\n                elif i < j:\n                    print(0, end='')\n                else:\n                    print(1, end='')\n            print()\n        return\n\n    if a + b > n + 1:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    for i in range(n):\n        for j in range(n):\n            if i < a - 1 and j < a - 1 and i!= j:\n                print(1, end='')\n            elif i >= a - 1 and j >= a - 1 and i!= j:\n                print(1, end='')\n            elif i == j:\n                print(0, end='')\n            else:\n                print(0, end='')\n        print()\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\nmain_rounds = math.ceil((n * m - k) / n)\nadditional_rounds = max(0, (n * m - k) % n)\n\nproblems = main_rounds * c + additional_rounds * d\n\nif (n * m - k) % n == 0 and main_rounds > 0:\n    problems = min(problems, (main_rounds - 1) * c + d)\n\nprint(problems)"}
{"solution": "def solve(s):\n    if len(s)!= 27:\n        return \"Impossible\"\n\n    grid = [[' ']*13 for _ in range(2)]\n    grid[0][0] = s[0]\n    grid[1][0] = s[1]\n    grid[0][12] = s[2]\n    grid[1][12] = s[3]\n\n    for i in range(4, 27):\n        found = False\n        for j in range(2):\n            for k in range(13):\n                if grid[j][k] == s[i-1]:\n                    for x, y in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n                        nx, ny = j+x, k+y\n                        if 0 <= nx < 2 and 0 <= ny < 13 and grid[nx][ny] =='':\n                            grid[nx][ny] = s[i]\n                            found = True\n                            break\n                    if found:\n                        break\n            if found:\n                break\n        if not found:\n            return \"Impossible\"\n\n    return ''.join(grid[0]) + '\\n' + ''.join(grid[1])\n\ns = input()\nprint(solve(s))"}
{"solution": "import math\n\nx, y = map(int, input().split())\n\nif x == y:\n    print('=')\nelif x > y:\n    if math.log(x) / y > math.log(y) / x:\n        print('>')\n    else:\n        print('<')\nelse:\n    if math.log(x) / y < math.log(y) / x:\n        print('>')\n    else:\n        print('<')"}
{"solution": "import math\n\nr, h = map(int, input().split())\n\nballoons_in_height = math.floor(h / (r / 2)) + 1\nballoons_in_radius = math.floor(r / (r / 2)) + 1\nballoons_in_semicircle = math.floor(math.pi * r / (r / 2)) + 1\n\nif balloons_in_radius == 1:\n    balloons_in_semicircle = 1\nelif balloons_in_radius == 2:\n    balloons_in_semicircle = 3\n\nprint(balloons_in_semicircle * balloons_in_height)"}
{"solution": "import sys\n\nnumbers = list(map(int, input().split()))\nnumbers.sort()\n\nmin_sum = sum(numbers)\n\n# Check if we can discard two cards with the same number\nif numbers[0] == numbers[1]:\n    min_sum = min(min_sum, sum(numbers[2:]))\n\n# Check if we can discard three cards with the same number\nif numbers[0] == numbers[2]:\n    min_sum = min(min_sum, sum(numbers[3:]))\n\n# Check if we can discard two cards with the same number\nif numbers[1] == numbers[2]:\n    min_sum = min(min_sum, sum([numbers[0]] + numbers[3:]))\n\n# Check if we can discard two cards with the same number\nif numbers[2] == numbers[3]:\n    min_sum = min(min_sum, sum(numbers[:2] + [numbers[4]]))\n\n# Check if we can discard two cards with the same number\nif numbers[3] == numbers[4]:\n    min_sum = min(min_sum, sum(numbers[:3]))\n\nprint(min_sum)"}
{"solution": "import sys\n\ndef main():\n    n, a = map(int, sys.stdin.readline().split())\n    x = sorted(map(int, sys.stdin.readline().split()))\n\n    a_idx = next((i for i, val in enumerate(x) if val >= a), n)\n    left = x[:a_idx]\n    right = x[a_idx:]\n\n    left_dist = sum(abs(a - val) for val in left)\n    right_dist = sum(abs(a - val) for val in right)\n\n    if len(left) > len(right):\n        if len(left) > 1:\n            left_dist -= abs(left[-1] - left[-2])\n        if len(right):\n            left_dist += abs(left[-1] - right[0])\n    elif len(right) > len(left):\n        if len(right) > 1:\n            right_dist -= abs(right[0] - right[1])\n        if len(left):\n            right_dist += abs(right[0] - left[-1])\n\n    print(min(left_dist, right_dist))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve(n):\n    x = math.isqrt(n)\n    while x * x <= n:\n        s_x = sum_of_digits(x)\n        if x * x + s_x * x - n == 0:\n            return x\n        x += 1\n    return -1\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def calculate_bed_time(current_time, sleep_time):\n    current_time_parts = list(map(int, current_time.split(':')))\n    sleep_time_parts = list(map(int, sleep_time.split(':')))\n\n    current_time_minutes = current_time_parts[0] * 60 + current_time_parts[1]\n    sleep_time_minutes = sleep_time_parts[0] * 60 + sleep_time_parts[1]\n\n    bed_time_minutes = (current_time_minutes - sleep_time_minutes) % (24 * 60)\n\n    bed_time_hours = bed_time_minutes // 60\n    bed_time_minutes %= 60\n\n    return f\"{bed_time_hours:02d}:{bed_time_minutes:02d}\"\n\ncurrent_time = input()\nsleep_time = input()\n\nprint(calculate_bed_time(current_time, sleep_time))"}
{"solution": "import sys\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    max_sum = float('-inf')\n    current_sum = 0\n    max_length = 0\n    current_length = 0\n\n    for num in a:\n        if current_sum <= 0:\n            current_sum = num\n            current_length = 1\n        else:\n            current_sum += num\n            current_length += 1\n\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_length = current_length\n        elif current_sum == max_sum:\n            max_length = max(max_length, current_length)\n\n    print(max_length)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "MOD = 998244353\n\ndef main():\n    n, m, k = map(int, input().split())\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[1][0] = m\n\n    for i in range(2, n + 1):\n        for j in range(min(i, k) + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = (dp[i - 1][j - 1] * (m - 1) + dp[i - 1][j]) % MOD\n\n    ans = 0\n    for i in range(k + 1):\n        ans = (ans + dp[n][i]) % MOD\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_magic_number(n):\n    n = str(n)\n    while n:\n        if n.startswith('1'):\n            n = n[1:]\n        elif n.startswith('14'):\n            n = n[2:]\n        elif n.startswith('144'):\n            n = n[3:]\n        else:\n            return 'NO'\n    return 'YES'\n\nn = int(input())\nprint(is_magic_number(n))"}
{"solution": "import math\n\ndef solve():\n    n, m, i, j, a, b = map(int, input().split())\n\n    def moves(x, y):\n        return max(math.ceil((x - 1) / a), math.ceil((y - 1) / b))\n\n    def moves2(x, y):\n        return max(math.ceil((n - x) / a), math.ceil((m - y) / b))\n\n    def moves3(x, y):\n        return max(math.ceil((n - x) / a), math.ceil((y - 1) / b))\n\n    def moves4(x, y):\n        return max(math.ceil((x - 1) / a), math.ceil((m - y) / b))\n\n    ans = min(moves(i, j), moves2(i, j), moves3(i, j), moves4(i, j))\n\n    if ans == float('inf'):\n        print(\"Poor Inna and pony!\")\n    else:\n        print(ans)\n\nsolve()"}
{"solution": "def remove_chars(s):\n    stack = []\n    for char in s:\n        if stack and ord(stack[-1]) == ord(char) - 1:\n            stack.pop()\n        else:\n            stack.append(char)\n    return len(s) - len(stack)\n\nn = int(input())\ns = input()\nprint(remove_chars(s))"}
{"solution": "import sys\n\nn, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\n\nfor _ in range(q):\n    x = int(input())\n    min_bills = float('inf')\n\n    for i in range(n):\n        for j in range(i, n):\n            for a in range(k + 1):\n                for b in range(k + 1):\n                    if a + b > k:\n                        break\n                    if a * denominations[i] + b * denominations[j] == x:\n                        min_bills = min(min_bills, a + b)\n\n    if min_bills == float('inf'):\n        print(-1)\n    else:\n        print(min_bills)"}
{"solution": "import math\n\ndef calculate_time(s, x1, x2, t1, t2, p, d):\n    if x1 < x2:\n        if d == 1:\n            wait_time = max(0, (p - x1) * t1)\n            tram_time = (s - p) * t1\n            walk_time = (x2 - s) * t2\n            return wait_time + tram_time + walk_time\n        else:\n            tram_time = (s - p) * t1\n            wait_time = max(0, (s - x2) * t1 - tram_time)\n            walk_time = (x2 - x1) * t2\n            return wait_time + tram_time + walk_time\n    else:\n        if d == -1:\n            wait_time = max(0, (x1 - p) * t1)\n            tram_time = p * t1\n            walk_time = (x1 - x2) * t2\n            return wait_time + tram_time + walk_time\n        else:\n            tram_time = (s - p) * t1\n            wait_time = max(0, (p - x2) * t1 - tram_time)\n            walk_time = (x1 - x2) * t2\n            return wait_time + tram_time + walk_time\n\ndef calculate_min_time(s, x1, x2, t1, t2, p, d):\n    walk_time = abs(x2 - x1) * t2\n    tram_time = calculate_time(s, x1, x2, t1, t2, p, d)\n    return min(walk_time, tram_time)\n\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\nprint(calculate_min_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "import math\n\nn, x = map(int, input().split())\ncount = 0\n\nfor i in range(1, min(n, int(math.sqrt(x))) + 1):\n    if x % i == 0:\n        if x // i <= n:\n            count += 1\n        if x // i!= i and i <= n:\n            count += 1\n\nprint(count)"}
{"solution": "import string\n\nn, k = map(int, input().split())\npassword = string.ascii_lowercase[:k]\nif k == 2:\n    print((password[0] + password[1]) * (n // 2) + password[0] * (n % 2))\nelse:\n    print(password * (n // k) + password[:n % k])"}
{"solution": "import sys\n\nn = int(input())\ndirections = input()\npositions = list(map(int, input().split()))\n\nmin_collision_time = float('inf')\n\nfor i in range(n - 1):\n    if (directions[i] == 'L' and directions[i + 1] == 'R') or (directions[i] == 'R' and directions[i + 1] == 'L'):\n        collision_time = abs(positions[i + 1] - positions[i]) // 2\n        min_collision_time = min(min_collision_time, collision_time)\n\nif min_collision_time == float('inf'):\n    print(-1)\nelse:\n    print(min_collision_time)"}
{"solution": "import sys\n\nn, a, b = map(int, sys.stdin.readline().split())\nseals = []\nfor _ in range(n):\n    x, y = map(int, sys.stdin.readline().split())\n    seals.append((min(x, y), max(x, y)))\n\nseals.sort(key=lambda x: x[0], reverse=True)\nseals.sort(key=lambda x: x[1], reverse=True)\n\nmax_area = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if seals[i][0] + seals[j][0] <= a and max(seals[i][1], seals[j][1]) <= b:\n            max_area = max(max_area, seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1])\n        if seals[i][1] + seals[j][1] <= a and max(seals[i][0], seals[j][0]) <= b:\n            max_area = max(max_area, seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1])\n        if seals[i][0] + seals[j][0] <= b and max(seals[i][1], seals[j][1]) <= a:\n            max_area = max(max_area, seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1])\n        if seals[i][1] + seals[j][1] <= b and max(seals[i][0], seals[j][0]) <= a:\n            max_area = max(max_area, seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1])\n\nprint(max_area)"}
{"solution": "from collections import defaultdict\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(4*n + 1)]\n\nx_counts = defaultdict(int)\ny_counts = defaultdict(int)\n\nfor x, y in points:\n    x_counts[x] += 1\n    y_counts[y] += 1\n\nx_values = sorted(x_counts.keys(), key=lambda x: x_counts[x])\ny_values = sorted(y_counts.keys(), key=lambda y: y_counts[y])\n\nfor x, y in points:\n    if x not in x_values[:2] and y not in y_values[:2]:\n        print(x, y)\n        break"}
{"solution": "import math\n\ndef digit_product(n):\n    product = 1\n    while n > 0:\n        product *= n % 10\n        n //= 10\n    return product\n\ndef main():\n    n = int(input())\n    max_product = 1\n    for i in range(1, n + 1):\n        max_product = max(max_product, digit_product(i))\n        if i % 10 == 9 and i > 1:\n            j = i\n            while j % 10 == 9:\n                j //= 10\n            if j < i // 10:\n                break\n    print(max_product)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ntotal_votes_elodreip = sum(a)\nmax_votes_elodreip = max(a)\n\nk = max_votes_elodreip\nwhile True:\n    total_votes_awruk = sum(k - ai for ai in a)\n    if total_votes_awruk > total_votes_elodreip:\n        print(k)\n        break\n    k += 1"}
{"solution": "def min_operations(s):\n    stack = []\n    operations = 0\n\n    for color in s:\n        if stack and stack[-1][0]!= color:\n            while stack and stack[-1][0]!= color:\n                stack.pop()\n            if stack:\n                stack[-1][1] += 1\n        else:\n            stack.append([color, 1])\n\n    while True:\n        to_delete = []\n        for i in range(len(stack)):\n            if i > 0 and i < len(stack) - 1 and stack[i-1][0]!= stack[i][0] and stack[i+1][0]!= stack[i][0]:\n                to_delete.append(i)\n            elif i == 0 and len(stack) > 1 and stack[i][0]!= stack[i+1][0]:\n                to_delete.append(i)\n            elif i == len(stack) - 1 and len(stack) > 1 and stack[i][0]!= stack[i-1][0]:\n                to_delete.append(i)\n\n        if not to_delete:\n            break\n\n        for i in sorted(to_delete, reverse=True):\n            del stack[i]\n\n        operations += 1\n\n    return operations\n\ns = input()\nprint(min_operations(s))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\nmin_product = a[0] * a[1] * a[2]\nmin_product_count = 1\n\nfor i in range(3, n):\n    if a[0] * a[1] * a[i] == min_product:\n        min_product_count += 1\n    elif a[0] * a[1] * a[i] < min_product:\n        min_product = a[0] * a[1] * a[i]\n        min_product_count = 1\n\nif a[0] == a[1] == a[2]:\n    print(n * (n - 1) * (n - 2) // 6)\nelif a[0] == a[1]:\n    print(min_product_count * (n - 2))\nelse:\n    print(min_product_count)"}
{"solution": "import math\n\ndef min_cuts(n):\n    if n < 4:\n        return n\n    return math.ceil(math.sqrt(n + 1))\n\nn = int(input())\nprint(min_cuts(n))"}
{"solution": "def remove_last_digit(n):\n    return int(str(n)[:-1])\n\ndef remove_second_last_digit(n):\n    return int(str(n)[:-2] + str(n)[-1])\n\nn = int(input())\nif n < 0:\n    n = -n\n    max_n = max(-remove_last_digit(n), -remove_second_last_digit(n), -n)\nelse:\n    max_n = max(remove_last_digit(n), remove_second_last_digit(n), n)\n\nprint(max_n)"}
{"solution": "def get_position_index(position):\n    positions = ['v', '<', '^', '>']\n    return positions.index(position)\n\ndef get_direction(start, end, n):\n    start_index = get_position_index(start)\n    end_index = get_position_index(end)\n    clockwise_diff = (end_index - start_index) % 4\n    counter_clockwise_diff = (start_index - end_index) % 4\n    if clockwise_diff == n % 4:\n        return 'cw'\n    elif counter_clockwise_diff == n % 4:\n        return 'ccw'\n    else:\n        return 'undefined'\n\nstart, end = input().split()\nn = int(input())\nprint(get_direction(start, end, n))"}
{"solution": "n = int(input())\ns = input()\n\nleft = [0] * n\nright = [0] * n\n\nfor i in range(1, n):\n    if s[i - 1] == 'R':\n        left[i] = left[i - 1] + 1\n    else:\n        left[i] = left[i - 1]\n\nfor i in range(n - 2, -1, -1):\n    if s[i + 1] == 'L':\n        right[i] = right[i + 1] + 1\n    else:\n        right[i] = right[i + 1]\n\ncount = 0\nfor i in range(n):\n    if s[i] == '.':\n        if left[i] == right[i]:\n            count += 1\n    elif s[i] == 'L':\n        if left[i] > 0:\n            count += 1\n    else:\n        if right[i] > 0:\n            count += 1\n\nprint(count)"}
{"solution": "def solve(n, m, leaders):\n    permutation = [0] * n\n    for i in range(n):\n        permutation[i] = i + 1\n\n    for i in range(m - 1):\n        leader_index = leaders[i] - 1\n        next_leader_index = leaders[i + 1] - 1\n        diff = (next_leader_index - leader_index) % n\n        if diff == 0:\n            permutation[leader_index] = n\n        else:\n            permutation[leader_index] = diff\n\n    for i in range(n):\n        if permutation[i] == 0:\n            permutation[i] = n\n\n    for i in range(m - 1):\n        leader_index = leaders[i] - 1\n        next_leader_index = leaders[i + 1] - 1\n        diff = (next_leader_index - leader_index) % n\n        if permutation[leader_index]!= diff and permutation[leader_index]!= n:\n            return [-1]\n\n    return permutation\n\n\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\nresult = solve(n, m, leaders)\nprint(*result)"}
{"solution": "def max_number(a, k):\n    a = list(a)\n    n = len(a)\n    result = []\n\n    for i in range(n):\n        if k == 0:\n            result.extend(a[i:])\n            break\n\n        max_digit = a[i]\n        max_index = i\n\n        for j in range(i + 1, min(i + k + 1, n)):\n            if a[j] > max_digit:\n                max_digit = a[j]\n                max_index = j\n\n        k -= max_index - i\n        result.append(max_digit)\n        a = a[:i] + a[i:max_index] + a[max_index + 1:]\n\n    return ''.join(result)\n\n\na, k = input().split()\nk = int(k)\nprint(max_number(a, k))"}
{"solution": "def is_arithmetic_progression(sequence):\n    diff = sequence[1] - sequence[0]\n    for i in range(2, len(sequence)):\n        if sequence[i] - sequence[i-1]!= diff:\n            return False\n    return True\n\n\ndef is_geometric_progression(sequence):\n    ratio = sequence[1] / sequence[0]\n    for i in range(2, len(sequence)):\n        if sequence[i] / sequence[i-1]!= ratio:\n            return False\n    return True\n\n\ndef next_arithmetic_progression(sequence):\n    diff = sequence[1] - sequence[0]\n    return sequence[-1] + diff\n\n\ndef next_geometric_progression(sequence):\n    ratio = sequence[1] / sequence[0]\n    return sequence[-1] * ratio\n\n\ndef main():\n    sequence = list(map(int, input().split()))\n    if is_arithmetic_progression(sequence):\n        next_num = next_arithmetic_progression(sequence)\n        if next_num == int(next_num):\n            print(int(next_num))\n        else:\n            print(42)\n    elif is_geometric_progression(sequence):\n        next_num = next_geometric_progression(sequence)\n        if next_num == int(next_num):\n            print(int(next_num))\n        else:\n            print(42)\n    else:\n        print(42)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    colors = list(map(int, sys.stdin.readline().split()))\n\n    first = {}\n    last = {}\n\n    for i, color in enumerate(colors):\n        if color not in first:\n            first[color] = i\n        last[color] = i\n\n    max_distance = 0\n    for color in first:\n        distance = last[color] - first[color]\n        if distance > max_distance:\n            max_distance = distance\n\n    if max_distance == n - 1:\n        max_distance = n - 2\n    else:\n        max_distance = n - 1\n\n    print(max_distance)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n, m, k = map(int, input().split())\nlane = (k + 1) // (2 * m)\ndesk = ((k - 1) // 2) % m + 1\nside = 'L' if (k - 1) % 2 == 0 else 'R'\nprint(lane, desk, side)"}
{"solution": "n = int(input())\ns = input()\n\ncolors = {'B': 0, 'G': 0, 'R': 0}\nfor color in s:\n    colors[color] += 1\n\npossible_colors = set()\nfor color1 in colors:\n    for color2 in colors:\n        if color1!= color2:\n            temp_colors = colors.copy()\n            temp_colors[color1] -= 1\n            temp_colors[color2] -= 1\n            if temp_colors[color1] < 0 or temp_colors[color2] < 0:\n                continue\n            while sum(temp_colors.values()) > 1:\n                max_color = max(temp_colors, key=temp_colors.get)\n                temp_colors[max_color] -= 2\n                if temp_colors[max_color] < 0:\n                    temp_colors[max_color] += 2\n                    break\n                for color in temp_colors:\n                    if color!= max_color:\n                        temp_colors[color] += 1\n            possible_colors.add(max(temp_colors, key=temp_colors.get))\n\nprint(''.join(sorted(possible_colors)))"}
